{"sha": "d73be2683d8be63e92ade52ba9613e3c7382c809", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDczYmUyNjgzZDhiZTYzZTkyYWRlNTJiYTk2MTNlM2M3MzgyYzgwOQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-25T10:34:13Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-25T10:34:13Z"}, "message": "tree-vrp.c (execute_vrp): Do not pass loops structure through arguments.\n\n\t* tree-vrp.c (execute_vrp): Do not pass loops structure through\n\targuments.\n\t* loop-unswitch.c (unswitch_loops, unswitch_single_loop,\n\tunswitch_loop): Ditto.\n\t* tree-loop-linear.c (linear_transform_loops): Ditto.\n\t* tree-ssa-loop-im.c (determine_lsm, tree_ssa_lim_initialize,\n\ttree_ssa_lim): Ditto.\n\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations,\n\tfree_numbers_of_iterations_estimates): Ditto.\n\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops,\n\ttree_unswitch_single_loop, tree_unswitch_loop): Ditto.\n\t* cfgloopmanip.c (fix_bb_placement, fix_bb_placements,\n\tremove_path, add_loop, loopify, unloop, fix_loop_placements,\n\tplace_new_loop, duplicate_loop, duplicate_subloops,\n\tupdate_single_exit_for_duplicated_loops, copy_loops_to,\n\tduplicate_loop_to_header_edge, create_preheaders,\n\tforce_single_succ_latches, loop_version, fix_loop_structure):\n\tDitto.\n\t* tree-ssa-loop-manip.c (tree_duplicate_loop_to_header_edge,\n\ttree_unroll_loop): Ditto.\n\t* tree-ssa-loop-ch.c (copy_loop_headers): Ditto.\n\t* tree-scalar-evolution.c (select_loops_exit_conditions,\n\tscev_initialize, scev_analysis): Ditto.\n\t* tree-scalar-evolution.h (scev_initialize): Ditto.\n\t* cfghooks.c (cfg_hook_duplicate_loop_to_header_edge): Ditto.\n\t* cfgloopanal.c (mark_irreducible_loops, mark_loop_exit_edges): Ditto.\n\t* tree-ssa-loop-ivopts.c (tree_ssa_iv_optimize): Ditto.\n\t* modulo-sched.c (sms_schedule): Ditto.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Ditto.\n\t* loop-init.c (loop_optimizer_init, rtl_move_loop_invariants,\n\trtl_unswitch, rtl_unroll_and_peel_loops, rtl_doloop): Ditto.\n\t* ifcvt.c (if_convert): Ditto.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely,\n\tcanonicalize_loop_induction_variables,\n\tcanonicalize_induction_variables,\n\ttree_unroll_loops_completely, remove_empty_loops): Ditto.\n\t* tree-ssa-loop.c (tree_ssa_loop_init, tree_ssa_loop_im,\n\ttree_ssa_loop_unswitch, tree_vectorize, tree_linear_transform,\n\ttree_ssa_loop_ivcanon, tree_ssa_empty_loop, tree_ssa_loop_bounds,\n\ttree_complete_unroll, tree_ssa_loop_prefetch, tree_ssa_loop_ivopts,\n\ttree_ssa_loop_done): Ditto.\n\t* predict.c (predict_loops, tree_estimate_probability, estimate_loops,\n\testimate_bb_frequencies): Ditto.\n\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg,\n\tslpeel_tree_peel_loop_to_edge, vectorize_loops): Ditto.\n\t* loop-unroll.c (unroll_and_peel_loops, peel_loops_completely,\n\tdecide_unrolling_and_peeling, peel_loop_completely,\n\tunroll_loop_constant_iterations, unroll_loop_runtime_iterations,\n\tpeel_loop_simple, unroll_loop_stupid): Ditto.\n\t* loop-doloop.c (doloop_optimize_loops): Ditto.\n\t* tree-cfgcleanup.c (cleanup_tree_cfg_loop): Ditto.\n\t* loop-invariant.c (move_loop_invariants): Ditto.\n\t* tree-ssa-dce.c (tree_ssa_dce_loop): Ditto.\n\t* tree-ssa-loop-prefetch.c (loop_prefetch_arrays,\n\ttree_ssa_prefetch_arrays): Ditto.\n\t* lambda-code.c (gcc_loopnest_to_lambda_loopnest, perfect_nestify):\n\tDitto.\n\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound,\n\tvect_do_peeling_for_alignment, vect_transform_loop): Ditto.\n\t* cfgloop.c (flow_loops_cfg_dump, flow_loops_dump,\n\tmark_single_exit_loops, cancel_loop, cancel_loop_tree,\n\tverify_loop_structure): Ditto.\n\t* tree-flow.h (vectorize_loops, tree_ssa_lim, tree_ssa_unswitch_loops,\n\tcanonicalize_induction_variables, tree_unroll_loops_completely,\n\ttree_ssa_prefetch_arrays, remove_empty_loops, tree_ssa_iv_optimize,\n\testimate_numbers_of_iterations, free_numbers_of_iterations_estimates,\n\ttree_duplicate_loop_to_header_edge, tree_ssa_loop_version,\n\ttree_unroll_loop, linear_transform_loops): Declaration changed.\n\t* basic-block.h: Remove declaration of struct loops.\n\t* cfghooks.h (struct cfg_hooks): Change type of\n\tcfg_hook_duplicate_loop_to_header_edge.\n\t(cfg_hook_duplicate_loop_to_header_edge): Declaration changed.\n\t* tree-vectorizer.h (slpeel_tree_peel_loop_to_edge,\n\tvect_transform_loop): Declaration changed.\n\t* lambda.h (gcc_loopnest_to_lambda_loopnest): Declaration changed.\n\t* cfgloop.h (flow_loops_dump, fix_loop_structure,\n\tmark_irreducible_loops, mark_single_exit_loops, mark_loop_exit_edges,\n\tcancel_loop_tree, create_preheaders, force_single_succ_latches,\n\tverify_loop_structure, duplicate_loop, duplicate_loop_to_header_edge,\n\tloopify, loop_version, remove_path, unswitch_loops,\n\tunroll_and_peel_loops, doloop_optimize_loops, move_loop_invariants):\n\tDeclaration changed.\n\nFrom-SVN: r119189", "tree": {"sha": "636a54cd82ce51b89b5846595db769b85ef6d0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/636a54cd82ce51b89b5846595db769b85ef6d0ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d73be2683d8be63e92ade52ba9613e3c7382c809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d73be2683d8be63e92ade52ba9613e3c7382c809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d73be2683d8be63e92ade52ba9613e3c7382c809", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d73be2683d8be63e92ade52ba9613e3c7382c809/comments", "author": null, "committer": null, "parents": [{"sha": "013021041a82ec4f9e1ea3e3aa94b8e92d9ca4d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013021041a82ec4f9e1ea3e3aa94b8e92d9ca4d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/013021041a82ec4f9e1ea3e3aa94b8e92d9ca4d2"}], "stats": {"total": 959, "additions": 502, "deletions": 457}, "files": [{"sha": "c43316eb8dbe9fa59426f6bcb72077afdc427ebe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -1,6 +1,91 @@\n+2006-11-25  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-vrp.c (execute_vrp): Do not pass loops structure through\n+\targuments.\n+\t* loop-unswitch.c (unswitch_loops, unswitch_single_loop,\n+\tunswitch_loop): Ditto.\n+\t* tree-loop-linear.c (linear_transform_loops): Ditto.\n+\t* tree-ssa-loop-im.c (determine_lsm, tree_ssa_lim_initialize,\n+\ttree_ssa_lim): Ditto.\n+\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations,\n+\tfree_numbers_of_iterations_estimates): Ditto.\n+\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops,\n+\ttree_unswitch_single_loop, tree_unswitch_loop): Ditto.\n+\t* cfgloopmanip.c (fix_bb_placement, fix_bb_placements,\n+\tremove_path, add_loop, loopify, unloop, fix_loop_placements,\n+\tplace_new_loop, duplicate_loop, duplicate_subloops,\n+\tupdate_single_exit_for_duplicated_loops, copy_loops_to,\n+\tduplicate_loop_to_header_edge, create_preheaders,\n+\tforce_single_succ_latches, loop_version, fix_loop_structure):\n+\tDitto.\n+\t* tree-ssa-loop-manip.c (tree_duplicate_loop_to_header_edge,\n+\ttree_unroll_loop): Ditto.\n+\t* tree-ssa-loop-ch.c (copy_loop_headers): Ditto.\n+\t* tree-scalar-evolution.c (select_loops_exit_conditions,\n+\tscev_initialize, scev_analysis): Ditto.\n+\t* tree-scalar-evolution.h (scev_initialize): Ditto.\n+\t* cfghooks.c (cfg_hook_duplicate_loop_to_header_edge): Ditto.\n+\t* cfgloopanal.c (mark_irreducible_loops, mark_loop_exit_edges): Ditto.\n+\t* tree-ssa-loop-ivopts.c (tree_ssa_iv_optimize): Ditto.\n+\t* modulo-sched.c (sms_schedule): Ditto.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Ditto.\n+\t* loop-init.c (loop_optimizer_init, rtl_move_loop_invariants,\n+\trtl_unswitch, rtl_unroll_and_peel_loops, rtl_doloop): Ditto.\n+\t* ifcvt.c (if_convert): Ditto.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely,\n+\tcanonicalize_loop_induction_variables,\n+\tcanonicalize_induction_variables,\n+\ttree_unroll_loops_completely, remove_empty_loops): Ditto.\n+\t* tree-ssa-loop.c (tree_ssa_loop_init, tree_ssa_loop_im,\n+\ttree_ssa_loop_unswitch, tree_vectorize, tree_linear_transform,\n+\ttree_ssa_loop_ivcanon, tree_ssa_empty_loop, tree_ssa_loop_bounds,\n+\ttree_complete_unroll, tree_ssa_loop_prefetch, tree_ssa_loop_ivopts,\n+\ttree_ssa_loop_done): Ditto.\n+\t* predict.c (predict_loops, tree_estimate_probability, estimate_loops,\n+\testimate_bb_frequencies): Ditto.\n+\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg,\n+\tslpeel_tree_peel_loop_to_edge, vectorize_loops): Ditto.\n+\t* loop-unroll.c (unroll_and_peel_loops, peel_loops_completely,\n+\tdecide_unrolling_and_peeling, peel_loop_completely,\n+\tunroll_loop_constant_iterations, unroll_loop_runtime_iterations,\n+\tpeel_loop_simple, unroll_loop_stupid): Ditto.\n+\t* loop-doloop.c (doloop_optimize_loops): Ditto.\n+\t* tree-cfgcleanup.c (cleanup_tree_cfg_loop): Ditto.\n+\t* loop-invariant.c (move_loop_invariants): Ditto.\n+\t* tree-ssa-dce.c (tree_ssa_dce_loop): Ditto.\n+\t* tree-ssa-loop-prefetch.c (loop_prefetch_arrays,\n+\ttree_ssa_prefetch_arrays): Ditto.\n+\t* lambda-code.c (gcc_loopnest_to_lambda_loopnest, perfect_nestify):\n+\tDitto.\n+\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound,\n+\tvect_do_peeling_for_alignment, vect_transform_loop): Ditto.\n+\t* cfgloop.c (flow_loops_cfg_dump, flow_loops_dump,\n+\tmark_single_exit_loops, cancel_loop, cancel_loop_tree,\n+\tverify_loop_structure): Ditto.\n+\t* tree-flow.h (vectorize_loops, tree_ssa_lim, tree_ssa_unswitch_loops,\n+\tcanonicalize_induction_variables, tree_unroll_loops_completely,\n+\ttree_ssa_prefetch_arrays, remove_empty_loops, tree_ssa_iv_optimize,\n+\testimate_numbers_of_iterations, free_numbers_of_iterations_estimates,\n+\ttree_duplicate_loop_to_header_edge, tree_ssa_loop_version,\n+\ttree_unroll_loop, linear_transform_loops): Declaration changed.\n+\t* basic-block.h: Remove declaration of struct loops.\n+\t* cfghooks.h (struct cfg_hooks): Change type of\n+\tcfg_hook_duplicate_loop_to_header_edge.\n+\t(cfg_hook_duplicate_loop_to_header_edge): Declaration changed.\n+\t* tree-vectorizer.h (slpeel_tree_peel_loop_to_edge,\n+\tvect_transform_loop): Declaration changed.\n+\t* lambda.h (gcc_loopnest_to_lambda_loopnest): Declaration changed.\n+\t* cfgloop.h (flow_loops_dump, fix_loop_structure,\n+\tmark_irreducible_loops, mark_single_exit_loops, mark_loop_exit_edges,\n+\tcancel_loop_tree, create_preheaders, force_single_succ_latches,\n+\tverify_loop_structure, duplicate_loop, duplicate_loop_to_header_edge,\n+\tloopify, loop_version, remove_path, unswitch_loops,\n+\tunroll_and_peel_loops, doloop_optimize_loops, move_loop_invariants):\n+\tDeclaration changed.\n+\n 2006-11-24  Uros Bizjak  <ubizjak@gmail.com>\n \n-\tconfig/i386/i386.md (UNSPEC_TRUNC_NOOP): New unspec definition.\n+\t* config/i386/i386.md (UNSPEC_TRUNC_NOOP): New unspec definition.\n \t(X87MODEF): New mode macro.\n \t(ssemodefsuffix): New mode attribute.\n \t(truncxf<mode>2_i387_noop_unspec): New insn pattern.\n@@ -17,7 +102,7 @@\n \t(fmodsf3, fmoddf3, remaindersf3, remainderdf3): Use noop\n \ttruncation patterns.\n \n-\treg-stack.c (get_true_reg): Handle UNSPEC_TRUNC_NOOP. \n+\t* reg-stack.c (get_true_reg): Handle UNSPEC_TRUNC_NOOP. \n \t\n 2006-11-24  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "dd5d1f3fb1612242c475601dc11b9799a5964484", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -180,7 +180,6 @@ extern const struct gcov_ctr_summary *profile_info;\n \n /* Declared in cfgloop.h.  */\n struct loop;\n-struct loops;\n \n /* Declared in tree-flow.h.  */\n struct edge_prediction;"}, {"sha": "89df3e54ea31033e28005e26634a0a24893eb75c", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -937,13 +937,13 @@ lv_flush_pending_stmts (edge e)\n    than duplicate_loop_to_header_edge when we are in tree mode.  */\n bool\n cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n-\t\t\t\t\tstruct loops *loops, unsigned int ndupl,\n+\t\t\t\t\tunsigned int ndupl,\n \t\t\t\t\tsbitmap wont_exit, edge orig,\n \t\t\t\t\tedge *to_remove,\n \t\t\t\t\tunsigned int *n_to_remove, int flags)\n {\n   gcc_assert (cfg_hooks->cfg_hook_duplicate_loop_to_header_edge);\n-  return cfg_hooks->cfg_hook_duplicate_loop_to_header_edge (loop, e, loops,\n+  return cfg_hooks->cfg_hook_duplicate_loop_to_header_edge (loop, e,\n \t\t\t\t\t\t\t    ndupl, wont_exit,\n \t\t\t\t\t\t\t    orig, to_remove,\n \t\t\t\t\t\t\t    n_to_remove, flags);"}, {"sha": "008072df3f15e519ac94eea46abcb6f21f826242", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -112,7 +112,6 @@ struct cfg_hooks\n   /* A hook for duplicating loop in CFG, currently this is used\n      in loop versioning.  */\n   bool (*cfg_hook_duplicate_loop_to_header_edge) (struct loop *loop, edge e,\n-\t\t\t\t\t\t  struct loops *loops,\n \t\t\t\t\t\t  unsigned int ndupl,\n \t\t\t\t\t\t  sbitmap wont_exit,\n \t\t\t\t\t\t  edge orig, edge *to_remove,\n@@ -164,7 +163,6 @@ extern int flow_call_edges_add (sbitmap);\n extern void execute_on_growing_pred (edge);\n extern void execute_on_shrinking_pred (edge);\n extern bool cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge,\n-\t\t\t\t\t\t    struct loops *loops,\n \t\t\t\t\t\t    unsigned int ndupl,\n \t\t\t\t\t\t    sbitmap wont_exit,\n \t\t\t\t\t\t    edge orig, edge *to_remove,"}, {"sha": "5a58fb257c16ba9afa1ddfbba7e2156826b63d18", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -40,19 +40,19 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define HEADER_BLOCK(B) (* (int *) (B)->aux)\n #define LATCH_EDGE(E) (*(int *) (E)->aux)\n \n-static void flow_loops_cfg_dump (const struct loops *, FILE *);\n+static void flow_loops_cfg_dump (FILE *);\n static void establish_preds (struct loop *);\n static void canonicalize_loop_headers (void);\n static bool glb_enum_p (basic_block, void *);\n \f\n /* Dump loop related CFG information.  */\n \n static void\n-flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n+flow_loops_cfg_dump (FILE *file)\n {\n   basic_block bb;\n \n-  if (! loops->num || ! file)\n+  if (!file)\n     return;\n \n   FOR_EACH_BB (bb)\n@@ -122,24 +122,22 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n     loop_dump_aux (loop, file, verbose);\n }\n \n-/* Dump the loop information specified by LOOPS to the stream FILE,\n+/* Dump the loop information about loops to the stream FILE,\n    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n \n void\n-flow_loops_dump (const struct loops *loops, FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *, int), int verbose)\n+flow_loops_dump (FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *, int), int verbose)\n {\n-  int i;\n-  int num_loops;\n+  unsigned i;\n \n-  num_loops = loops->num;\n-  if (! num_loops || ! file)\n+  if (!current_loops || ! file)\n     return;\n \n-  fprintf (file, \";; %d loops found\\n\", num_loops);\n+  fprintf (file, \";; %d loops found\\n\", current_loops->num);\n \n-  for (i = 0; i < num_loops; i++)\n+  for (i = 0; i < current_loops->num; i++)\n     {\n-      struct loop *loop = loops->parray[i];\n+      struct loop *loop = current_loops->parray[i];\n \n       if (!loop)\n \tcontinue;\n@@ -148,7 +146,7 @@ flow_loops_dump (const struct loops *loops, FILE *file, void (*loop_dump_aux) (c\n     }\n \n   if (verbose)\n-    flow_loops_cfg_dump (loops, file);\n+    flow_loops_cfg_dump (file);\n }\n \n /* Free data allocated for LOOP.  */\n@@ -236,28 +234,27 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n   return num_nodes;\n }\n \n-/* For each loop in the lOOPS tree that has just a single exit\n-   record the exit edge.  */\n+/* For each loop that has just a single exit, record the exit edge.  */\n \n void\n-mark_single_exit_loops (struct loops *loops)\n+mark_single_exit_loops (void)\n {\n   basic_block bb;\n   edge e;\n   struct loop *loop;\n   unsigned i;\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (loop)\n \tset_single_exit (loop, NULL);\n     }\n \n   FOR_EACH_BB (bb)\n     {\n       edge_iterator ei;\n-      if (bb->loop_father == loops->tree_root)\n+      if (bb->loop_father == current_loops->tree_root)\n \tcontinue;\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n@@ -281,17 +278,17 @@ mark_single_exit_loops (struct loops *loops)\n \t}\n     }\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n       if (single_exit (loop) == single_succ_edge (ENTRY_BLOCK_PTR))\n \tset_single_exit (loop, NULL);\n     }\n \n-  loops->state |= LOOPS_HAVE_MARKED_SINGLE_EXITS;\n+  current_loops->state |= LOOPS_HAVE_MARKED_SINGLE_EXITS;\n }\n \n static void\n@@ -930,7 +927,7 @@ find_common_loop (struct loop *loop_s, struct loop *loop_d)\n /* Cancels the LOOP; it must be innermost one.  */\n \n static void\n-cancel_loop (struct loops *loops, struct loop *loop)\n+cancel_loop (struct loop *loop)\n {\n   basic_block *bbs;\n   unsigned i;\n@@ -946,30 +943,30 @@ cancel_loop (struct loops *loops, struct loop *loop)\n   flow_loop_tree_node_remove (loop);\n \n   /* Remove loop from loops array.  */\n-  loops->parray[loop->num] = NULL;\n+  current_loops->parray[loop->num] = NULL;\n \n   /* Free loop data.  */\n   flow_loop_free (loop);\n }\n \n /* Cancels LOOP and all its subloops.  */\n void\n-cancel_loop_tree (struct loops *loops, struct loop *loop)\n+cancel_loop_tree (struct loop *loop)\n {\n   while (loop->inner)\n-    cancel_loop_tree (loops, loop->inner);\n-  cancel_loop (loops, loop);\n+    cancel_loop_tree (loop->inner);\n+  cancel_loop (loop);\n }\n \n-/* Checks that LOOPS are all right:\n+/* Checks that information about loops is correct\n      -- sizes of loops are all right\n      -- results of get_loop_body really belong to the loop\n      -- loop header have just single entry edge and single latch edge\n      -- loop latches have only single successor that is header of their loop\n      -- irreducible loops are correctly marked\n   */\n void\n-verify_loop_structure (struct loops *loops)\n+verify_loop_structure (void)\n {\n   unsigned *sizes, i, j;\n   sbitmap irreds;\n@@ -979,30 +976,30 @@ verify_loop_structure (struct loops *loops)\n   edge e;\n \n   /* Check sizes.  */\n-  sizes = XCNEWVEC (unsigned, loops->num);\n+  sizes = XCNEWVEC (unsigned, current_loops->num);\n   sizes[0] = 2;\n \n   FOR_EACH_BB (bb)\n     for (loop = bb->loop_father; loop; loop = loop->outer)\n       sizes[loop->num]++;\n \n-  for (i = 0; i < loops->num; i++)\n+  for (i = 0; i < current_loops->num; i++)\n     {\n-      if (!loops->parray[i])\n+      if (!current_loops->parray[i])\n \tcontinue;\n \n-      if (loops->parray[i]->num_nodes != sizes[i])\n+      if (current_loops->parray[i]->num_nodes != sizes[i])\n \t{\n \t  error (\"size of loop %d should be %d, not %d\",\n-\t\t   i, sizes[i], loops->parray[i]->num_nodes);\n+\t\t   i, sizes[i], current_loops->parray[i]->num_nodes);\n \t  err = 1;\n \t}\n     }\n \n   /* Check get_loop_body.  */\n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n       bbs = get_loop_body (loop);\n@@ -1018,19 +1015,19 @@ verify_loop_structure (struct loops *loops)\n     }\n \n   /* Check headers and latches.  */\n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n-      if ((loops->state & LOOPS_HAVE_PREHEADERS)\n+      if ((current_loops->state & LOOPS_HAVE_PREHEADERS)\n \t  && EDGE_COUNT (loop->header->preds) != 2)\n \t{\n \t  error (\"loop %d's header does not have exactly 2 entries\", i);\n \t  err = 1;\n \t}\n-      if (loops->state & LOOPS_HAVE_SIMPLE_LATCHES)\n+      if (current_loops->state & LOOPS_HAVE_SIMPLE_LATCHES)\n \t{\n \t  if (!single_succ_p (loop->latch))\n \t    {\n@@ -1053,7 +1050,7 @@ verify_loop_structure (struct loops *loops)\n \t  error (\"loop %d's header does not belong directly to it\", i);\n \t  err = 1;\n \t}\n-      if ((loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n+      if ((current_loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n \t  && (loop_latch_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP))\n \t{\n \t  error (\"loop %d's latch is marked as part of irreducible region\", i);\n@@ -1062,7 +1059,7 @@ verify_loop_structure (struct loops *loops)\n     }\n \n   /* Check irreducible loops.  */\n-  if (loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n+  if (current_loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n     {\n       /* Record old info.  */\n       irreds = sbitmap_alloc (last_basic_block);\n@@ -1079,7 +1076,7 @@ verify_loop_structure (struct loops *loops)\n \t}\n \n       /* Recount it.  */\n-      mark_irreducible_loops (loops);\n+      mark_irreducible_loops ();\n \n       /* Compare.  */\n       FOR_EACH_BB (bb)\n@@ -1121,13 +1118,13 @@ verify_loop_structure (struct loops *loops)\n     }\n \n   /* Check the single_exit.  */\n-  if (loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n+  if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n     {\n-      memset (sizes, 0, sizeof (unsigned) * loops->num);\n+      memset (sizes, 0, sizeof (unsigned) * current_loops->num);\n       FOR_EACH_BB (bb)\n \t{\n \t  edge_iterator ei;\n-\t  if (bb->loop_father == loops->tree_root)\n+\t  if (bb->loop_father == current_loops->tree_root)\n \t    continue;\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n@@ -1157,9 +1154,9 @@ verify_loop_structure (struct loops *loops)\n \t    }\n \t}\n \n-      for (i = 1; i < loops->num; i++)\n+      for (i = 1; i < current_loops->num; i++)\n \t{\n-\t  loop = loops->parray[i];\n+\t  loop = current_loops->parray[i];\n \t  if (!loop)\n \t    continue;\n "}, {"sha": "9c755c8e2622638d95145587a93a455a14a20b06", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -191,15 +191,15 @@ struct loops\n /* Loop recognition.  */\n extern int flow_loops_find (struct loops *);\n extern void flow_loops_free (struct loops *);\n-extern void flow_loops_dump (const struct loops *, FILE *,\n+extern void flow_loops_dump (FILE *,\n \t\t\t     void (*)(const struct loop *, FILE *, int), int);\n extern void flow_loop_dump (const struct loop *, FILE *,\n \t\t\t    void (*)(const struct loop *, FILE *, int), int);\n extern void flow_loop_free (struct loop *);\n int flow_loop_nodes_find (basic_block, struct loop *);\n-void fix_loop_structure (struct loops *, bitmap changed_bbs);\n-void mark_irreducible_loops (struct loops *);\n-void mark_single_exit_loops (struct loops *);\n+void fix_loop_structure (bitmap changed_bbs);\n+void mark_irreducible_loops (void);\n+void mark_single_exit_loops (void);\n \n /* Loop data structure manipulation/querying.  */\n extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n@@ -213,7 +213,7 @@ extern int num_loop_insns (struct loop *);\n extern int average_num_loop_insns (struct loop *);\n extern unsigned get_loop_level (const struct loop *);\n extern bool loop_exit_edge_p (const struct loop *, edge);\n-extern void mark_loop_exit_edges (struct loops *);\n+extern void mark_loop_exit_edges (void);\n \n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body (const struct loop *);\n@@ -230,7 +230,7 @@ extern edge loop_latch_edge (const struct loop *);\n extern void add_bb_to_loop (basic_block, struct loop *);\n extern void remove_bb_from_loops (basic_block);\n \n-extern void cancel_loop_tree (struct loops *, struct loop *);\n+extern void cancel_loop_tree (struct loop *);\n \n extern int fix_loop_placement (struct loop *);\n \n@@ -239,10 +239,10 @@ enum\n   CP_SIMPLE_PREHEADERS = 1\n };\n \n-extern void create_preheaders (struct loops *, int);\n-extern void force_single_succ_latches (struct loops *);\n+extern void create_preheaders (int);\n+extern void force_single_succ_latches (void);\n \n-extern void verify_loop_structure (struct loops *);\n+extern void verify_loop_structure (void);\n \n /* Loop analysis.  */\n extern bool just_once_each_iteration_p (const struct loop *, basic_block);\n@@ -259,16 +259,15 @@ extern bool can_duplicate_loop_p (struct loop *loop);\n #define DLTHE_FLAG_COMPLETTE_PEEL 4\t/* Update frequencies expecting\n \t\t\t\t\t   a complete peeling.  */\n \n-extern struct loop * duplicate_loop (struct loops *, struct loop *,\n-\t\t\t\t     struct loop *);\n-extern bool duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n+extern struct loop * duplicate_loop (struct loop *, struct loop *);\n+extern bool duplicate_loop_to_header_edge (struct loop *, edge, \n \t\t\t\t\t   unsigned, sbitmap, edge, edge *,\n \t\t\t\t\t   unsigned *, int);\n-extern struct loop *loopify (struct loops *, edge, edge,\n+extern struct loop *loopify (edge, edge,\n \t\t\t     basic_block, edge, edge, bool);\n-struct loop * loop_version (struct loops *, struct loop *, void *,\n+struct loop * loop_version (struct loop *, void *,\n \t\t\t    basic_block *, bool);\n-extern bool remove_path (struct loops *, edge);\n+extern bool remove_path (edge);\n \n /* Induction variable analysis.  */\n \n@@ -397,7 +396,7 @@ extern void loop_optimizer_init (unsigned);\n extern void loop_optimizer_finalize (void);\n \n /* Optimization passes.  */\n-extern void unswitch_loops (struct loops *);\n+extern void unswitch_loops (void);\n \n enum\n {\n@@ -406,8 +405,8 @@ enum\n   UAP_UNROLL_ALL = 4\t/* Enables unrolling of all loops.  */\n };\n \n-extern void unroll_and_peel_loops (struct loops *, int);\n-extern void doloop_optimize_loops (struct loops *);\n-extern void move_loop_invariants (struct loops *);\n+extern void unroll_and_peel_loops (int);\n+extern void doloop_optimize_loops (void);\n+extern void move_loop_invariants (void);\n \n #endif /* GCC_CFGLOOP_H */"}, {"sha": "16b3b46118efe0fd84d9667da210dad29a9804e7", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -266,14 +266,14 @@ free_graph (struct graph *g)\n #define BB_REPR(BB) ((BB)->index + 1)\n \n void\n-mark_irreducible_loops (struct loops *loops)\n+mark_irreducible_loops (void)\n {\n   basic_block act;\n   edge e;\n   edge_iterator ei;\n   int i, src, dest;\n   struct graph *g;\n-  int num = loops ? loops->num : 1;\n+  int num = current_loops ? current_loops->num : 1;\n   int *queue1 = XNEWVEC (int, last_basic_block + num);\n   int *queue2 = XNEWVEC (int, last_basic_block + num);\n   int nq, depth;\n@@ -300,7 +300,7 @@ mark_irreducible_loops (struct loops *loops)\n \tsrc = BB_REPR (act);\n \tdest = BB_REPR (e->dest);\n \n-\tif (loops)\n+\tif (current_loops)\n \t  {\n \t    /* Ignore latch edges.  */\n \t    if (e->dest->loop_father->header == e->dest\n@@ -344,8 +344,8 @@ mark_irreducible_loops (struct loops *loops)\n       queue1[nq++] = BB_REPR (act);\n     }\n   for (i = 1; i < num; i++)\n-    if (loops->parray[i])\n-      queue1[nq++] = LOOP_REPR (loops->parray[i]);\n+    if (current_loops->parray[i])\n+      queue1[nq++] = LOOP_REPR (current_loops->parray[i]);\n   dfs (g, queue1, nq, queue2, false);\n   for (i = 0; i < nq; i++)\n     queue1[i] = queue2[nq - i - 1];\n@@ -358,8 +358,8 @@ mark_irreducible_loops (struct loops *loops)\n   free (queue1);\n   free (queue2);\n \n-  if (loops)\n-    loops->state |= LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n+  if (current_loops)\n+    current_loops->state |= LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n }\n \n /* Counts number of insns inside LOOP.  */\n@@ -572,15 +572,15 @@ global_cost_for_size (unsigned size, unsigned regs_used, unsigned n_uses)\n   return cost;\n }\n \n-/* Sets EDGE_LOOP_EXIT flag for all exits of LOOPS.  */\n+/* Sets EDGE_LOOP_EXIT flag for all loop exits.  */\n \n void\n-mark_loop_exit_edges (struct loops *loops)\n+mark_loop_exit_edges (void)\n {\n   basic_block bb;\n   edge e;\n \n-  if (loops->num <= 1)\n+  if (!current_loops)\n     return;\n \n   FOR_EACH_BB (bb)"}, {"sha": "180a4757ee9eeec12e024cd9ebacbae4989dd780", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 87, "deletions": 90, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -31,22 +31,22 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cfghooks.h\"\n #include \"output.h\"\n \n-static void duplicate_subloops (struct loops *, struct loop *, struct loop *);\n-static void copy_loops_to (struct loops *, struct loop **, int,\n+static void duplicate_subloops (struct loop *, struct loop *);\n+static void copy_loops_to (struct loop **, int,\n \t\t\t   struct loop *);\n static void loop_redirect_edge (edge, basic_block);\n static bool loop_delete_branch_edge (edge, int);\n static void remove_bbs (basic_block *, int);\n static bool rpe_enum_p (basic_block, void *);\n static int find_path (edge, basic_block **);\n static bool alp_enum_p (basic_block, void *);\n-static void fix_loop_placements (struct loops *, struct loop *, bool *);\n-static bool fix_bb_placement (struct loops *, basic_block);\n-static void fix_bb_placements (struct loops *, basic_block, bool *);\n-static void place_new_loop (struct loops *, struct loop *);\n+static void fix_loop_placements (struct loop *, bool *);\n+static bool fix_bb_placement (basic_block);\n+static void fix_bb_placements (basic_block, bool *);\n+static void place_new_loop (struct loop *);\n static void scale_loop_frequencies (struct loop *, int, int);\n static basic_block create_preheader (struct loop *, int);\n-static void unloop (struct loops *, struct loop *, bool *);\n+static void unloop (struct loop *, bool *);\n \n #define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n \n@@ -85,19 +85,19 @@ find_path (edge e, basic_block **bbs)\n \t\t\t     n_basic_blocks, e->dest);\n }\n \n-/* Fix placement of basic block BB inside loop hierarchy stored in LOOPS --\n+/* Fix placement of basic block BB inside loop hierarchy --\n    Let L be a loop to that BB belongs.  Then every successor of BB must either\n      1) belong to some superloop of loop L, or\n      2) be a header of loop K such that K->outer is superloop of L\n    Returns true if we had to move BB into other loop to enforce this condition,\n    false if the placement of BB was already correct (provided that placements\n    of its successors are correct).  */\n static bool\n-fix_bb_placement (struct loops *loops, basic_block bb)\n+fix_bb_placement (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n-  struct loop *loop = loops->tree_root, *act;\n+  struct loop *loop = current_loops->tree_root, *act;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -134,7 +134,7 @@ fix_bb_placement (struct loops *loops, basic_block bb)\n    IRRED_INVALIDATED is set to true.  */\n \n static void\n-fix_bb_placements (struct loops *loops, basic_block from,\n+fix_bb_placements (basic_block from,\n \t\t   bool *irred_invalidated)\n {\n   sbitmap in_queue;\n@@ -150,7 +150,7 @@ fix_bb_placements (struct loops *loops, basic_block from,\n      fix_loop_placement.  */\n \n   base_loop = from->loop_father;\n-  if (base_loop == loops->tree_root)\n+  if (base_loop == current_loops->tree_root)\n     return;\n \n   in_queue = sbitmap_alloc (last_basic_block);\n@@ -183,7 +183,7 @@ fix_bb_placements (struct loops *loops, basic_block from,\n       else\n \t{\n \t  /* Ordinary basic block.  */\n-\t  if (!fix_bb_placement (loops, from))\n+\t  if (!fix_bb_placement (from))\n \t    continue;\n \t}\n \n@@ -235,11 +235,10 @@ fix_bb_placements (struct loops *loops, basic_block from,\n }\n \n /* Removes path beginning at edge E, i.e. remove basic blocks dominated by E\n-   and update loop structure stored in LOOPS and dominators.  Return true if\n-   we were able to remove the path, false otherwise (and nothing is affected\n-   then).  */\n+   and update loop structures and dominators.  Return true if we were able\n+   to remove the path, false otherwise (and nothing is affected then).  */\n bool\n-remove_path (struct loops *loops, edge e)\n+remove_path (edge e)\n {\n   edge ae;\n   basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n@@ -273,7 +272,7 @@ remove_path (struct loops *loops, edge e)\n   while (e->src->loop_father->outer\n \t && dominated_by_p (CDI_DOMINATORS,\n \t\t\t    e->src->loop_father->latch, e->dest))\n-    unloop (loops, e->src->loop_father, &irred_invalidated);\n+    unloop (e->src->loop_father, &irred_invalidated);\n \n   /* Identify the path.  */\n   nrem = find_path (e, &rem_bbs);\n@@ -318,7 +317,7 @@ remove_path (struct loops *loops, edge e)\n   free (rem_bbs);\n \n   for (i = 0; i < nreml; i++)\n-    cancel_loop_tree (loops, deleted_loop[i]);\n+    cancel_loop_tree (deleted_loop[i]);\n   free (deleted_loop);\n \n   /* Find blocks whose dominators may be affected.  */\n@@ -349,12 +348,12 @@ remove_path (struct loops *loops, edge e)\n \n   /* Fix placements of basic blocks inside loops and the placement of\n      loops in the loop tree.  */\n-  fix_bb_placements (loops, from, &irred_invalidated);\n-  fix_loop_placements (loops, from->loop_father, &irred_invalidated);\n+  fix_bb_placements (from, &irred_invalidated);\n+  fix_loop_placements (from->loop_father, &irred_invalidated);\n \n   if (irred_invalidated\n-      && (loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS) != 0)\n-    mark_irreducible_loops (loops);\n+      && (current_loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS) != 0)\n+    mark_irreducible_loops ();\n \n   return true;\n }\n@@ -367,17 +366,17 @@ alp_enum_p (basic_block bb, void *alp_header)\n }\n \n /* Given LOOP structure with filled header and latch, find the body of the\n-   corresponding loop and add it to LOOPS tree.  Insert the LOOP as a son of\n+   corresponding loop and add it to loops tree.  Insert the LOOP as a son of\n    outer.  */\n \n static void\n-add_loop (struct loops *loops, struct loop *loop, struct loop *outer)\n+add_loop (struct loop *loop, struct loop *outer)\n {\n   basic_block *bbs;\n   int i, n;\n \n   /* Add it to loop structure.  */\n-  place_new_loop (loops, loop);\n+  place_new_loop (loop);\n   flow_loop_tree_node_add (outer, loop);\n \n   /* Find its nodes.  */\n@@ -408,7 +407,7 @@ scale_loop_frequencies (struct loop *loop, int num, int den)\n }\n \n /* Make area between HEADER_EDGE and LATCH_EDGE a loop by connecting\n-   latch to header and update loop tree stored in LOOPS and dominators\n+   latch to header and update loop tree and dominators\n    accordingly. Everything between them plus LATCH_EDGE destination must\n    be dominated by HEADER_EDGE destination, and back-reachable from\n    LATCH_EDGE source.  HEADER_EDGE is redirected to basic block SWITCH_BB,\n@@ -417,7 +416,7 @@ scale_loop_frequencies (struct loop *loop, int num, int den)\n    Returns newly created loop.  */\n \n struct loop *\n-loopify (struct loops *loops, edge latch_edge, edge header_edge,\n+loopify (edge latch_edge, edge header_edge,\n \t basic_block switch_bb, edge true_edge, edge false_edge,\n \t bool redirect_all_edges)\n {\n@@ -462,7 +461,7 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   set_immediate_dominator (CDI_DOMINATORS, succ_bb, switch_bb);\n \n   /* Compute new loop.  */\n-  add_loop (loops, loop, outer);\n+  add_loop (loop, outer);\n \n   /* Add switch_bb to appropriate loop.  */\n   if (switch_bb->loop_father)\n@@ -510,15 +509,15 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   return loop;\n }\n \n-/* Remove the latch edge of a LOOP and update LOOPS tree to indicate that\n+/* Remove the latch edge of a LOOP and update loops to indicate that\n    the LOOP was removed.  After this function, original loop latch will\n    have no successor, which caller is expected to fix somehow.\n \n    If this may cause the information about irreducible regions to become\n    invalid, IRRED_INVALIDATED is set to true.  */\n \n static void\n-unloop (struct loops *loops, struct loop *loop, bool *irred_invalidated)\n+unloop (struct loop *loop, bool *irred_invalidated)\n {\n   basic_block *body;\n   struct loop *ploop;\n@@ -554,15 +553,15 @@ unloop (struct loops *loops, struct loop *loop, bool *irred_invalidated)\n \n   /* Remove the loop and free its data.  */\n   flow_loop_tree_node_remove (loop);\n-  loops->parray[loop->num] = NULL;\n+  current_loops->parray[loop->num] = NULL;\n   flow_loop_free (loop);\n \n   remove_edge (single_succ_edge (latch));\n \n   /* We do not pass IRRED_INVALIDATED to fix_bb_placements here, as even if\n      there is an irreducible region inside the cancelled loop, the flags will\n      be still correct.  */\n-  fix_bb_placements (loops, latch, &dummy);\n+  fix_bb_placements (latch, &dummy);\n }\n \n /* Fix placement of LOOP inside loop tree, i.e. find the innermost superloop\n@@ -610,8 +609,7 @@ fix_loop_placement (struct loop *loop)\n    invalidate the information about irreducible regions.  */\n \n static void\n-fix_loop_placements (struct loops *loops, struct loop *loop,\n-\t\t     bool *irred_invalidated)\n+fix_loop_placements (struct loop *loop, bool *irred_invalidated)\n {\n   struct loop *outer;\n \n@@ -626,31 +624,31 @@ fix_loop_placements (struct loops *loops, struct loop *loop,\n \t for its preheader, because the successor is the header and belongs\n \t to the loop.  So call fix_bb_placements to fix up the placement\n \t of the preheader and (possibly) of its predecessors.  */\n-      fix_bb_placements (loops, loop_preheader_edge (loop)->src,\n+      fix_bb_placements (loop_preheader_edge (loop)->src,\n \t\t\t irred_invalidated);\n       loop = outer;\n     }\n }\n \n-/* Creates place for a new LOOP in LOOPS structure.  */\n+/* Creates place for a new LOOP in loops structure.  */\n static void\n-place_new_loop (struct loops *loops, struct loop *loop)\n+place_new_loop (struct loop *loop)\n {\n-  loops->parray =\n-    xrealloc (loops->parray, (loops->num + 1) * sizeof (struct loop *));\n-  loops->parray[loops->num] = loop;\n+  current_loops->parray =\n+    xrealloc (current_loops->parray, (current_loops->num + 1) * sizeof (struct loop *));\n+  current_loops->parray[current_loops->num] = loop;\n \n-  loop->num = loops->num++;\n+  loop->num = current_loops->num++;\n }\n \n /* Copies copy of LOOP as subloop of TARGET loop, placing newly\n-   created loop into LOOPS structure.  */\n+   created loop into loops structure.  */\n struct loop *\n-duplicate_loop (struct loops *loops, struct loop *loop, struct loop *target)\n+duplicate_loop (struct loop *loop, struct loop *target)\n {\n   struct loop *cloop;\n   cloop = XCNEW (struct loop);\n-  place_new_loop (loops, cloop);\n+  place_new_loop (cloop);\n \n   /* Mark the new loop as copy of LOOP.  */\n   loop->copy = cloop;\n@@ -662,31 +660,31 @@ duplicate_loop (struct loops *loops, struct loop *loop, struct loop *target)\n }\n \n /* Copies structure of subloops of LOOP into TARGET loop, placing\n-   newly created loops into loop tree stored in LOOPS.  */\n+   newly created loops into loop tree.  */\n static void\n-duplicate_subloops (struct loops *loops, struct loop *loop, struct loop *target)\n+duplicate_subloops (struct loop *loop, struct loop *target)\n {\n   struct loop *aloop, *cloop;\n \n   for (aloop = loop->inner; aloop; aloop = aloop->next)\n     {\n-      cloop = duplicate_loop (loops, aloop, target);\n-      duplicate_subloops (loops, aloop, cloop);\n+      cloop = duplicate_loop (aloop, target);\n+      duplicate_subloops (aloop, cloop);\n     }\n }\n \n /* Copies structure of subloops of N loops, stored in array COPIED_LOOPS,\n-   into TARGET loop, placing newly created loops into loop tree LOOPS.  */\n+   into TARGET loop, placing newly created loops into loop tree.  */\n static void\n-copy_loops_to (struct loops *loops, struct loop **copied_loops, int n, struct loop *target)\n+copy_loops_to (struct loop **copied_loops, int n, struct loop *target)\n {\n   struct loop *aloop;\n   int i;\n \n   for (i = 0; i < n; i++)\n     {\n-      aloop = duplicate_loop (loops, copied_loops[i], target);\n-      duplicate_subloops (loops, copied_loops[i], aloop);\n+      aloop = duplicate_loop (copied_loops[i], target);\n+      duplicate_subloops (copied_loops[i], aloop);\n     }\n }\n \n@@ -812,7 +810,7 @@ update_single_exit_for_duplicated_loops (struct loop *orig_loops[], unsigned n)\n }\n \n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n-   LOOPS structure and dominators.  E's destination must be LOOP header for\n+   loop structure and dominators.  E's destination must be LOOP header for\n    this to work, i.e. it must be entry or latch edge of this loop; these are\n    unique, as the loops must have preheaders for this function to work\n    correctly (in case E is latch, the function unrolls the loop, if E is entry\n@@ -822,7 +820,7 @@ update_single_exit_for_duplicated_loops (struct loop *orig_loops[], unsigned n)\n    flow through them) into TO_REMOVE array.  Returns false if duplication is\n    impossible.  */\n bool\n-duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n+duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t\t\t       unsigned int ndupl, sbitmap wont_exit,\n \t\t\t       edge orig, edge *to_remove,\n \t\t\t       unsigned int *n_to_remove, int flags)\n@@ -970,7 +968,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n     }\n \n   /* Update the information about single exits.  */\n-  if (loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n+  if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n     update_single_exits_after_duplication (bbs, n, target);\n \n   /* Record exit edge in original loop body.  */\n@@ -984,14 +982,14 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   for (j = 0; j < ndupl; j++)\n     {\n       /* Copy loops.  */\n-      copy_loops_to (loops, orig_loops, n_orig_loops, target);\n+      copy_loops_to (orig_loops, n_orig_loops, target);\n \n       /* Copy bbs.  */\n       copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop,\n \t\tplace_after);\n       place_after = new_spec_edges[SE_LATCH]->src;\n \n-      if (loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n+      if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n \t{\n \t  for (i = 0; i < n; i++)\n \t    bbs[i]->flags |= BB_DUPLICATED;\n@@ -1192,37 +1190,37 @@ create_preheader (struct loop *loop, int flags)\n   return dummy;\n }\n \n-/* Create preheaders for each loop from loop tree stored in LOOPS; for meaning\n-   of FLAGS see create_preheader.  */\n+/* Create preheaders for each loop; for meaning of FLAGS see create_preheader.  */\n+\n void\n-create_preheaders (struct loops *loops, int flags)\n+create_preheaders (int flags)\n {\n   unsigned i;\n-  for (i = 1; i < loops->num; i++)\n-    create_preheader (loops->parray[i], flags);\n-  loops->state |= LOOPS_HAVE_PREHEADERS;\n+  for (i = 1; i < current_loops->num; i++)\n+    create_preheader (current_loops->parray[i], flags);\n+  current_loops->state |= LOOPS_HAVE_PREHEADERS;\n }\n \n-/* Forces all loop latches of loops from loop tree LOOPS to have only single\n-   successor.  */\n+/* Forces all loop latches to have only single successor.  */\n+\n void\n-force_single_succ_latches (struct loops *loops)\n+force_single_succ_latches (void)\n {\n   unsigned i;\n   struct loop *loop;\n   edge e;\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (loop->latch != loop->header && single_succ_p (loop->latch))\n \tcontinue;\n \n       e = find_edge (loop->latch, loop->header);\n \n       split_edge (e);\n     }\n-  loops->state |= LOOPS_HAVE_SIMPLE_LATCHES;\n+  current_loops->state |= LOOPS_HAVE_SIMPLE_LATCHES;\n }\n \n /* This function is called from loop_version.  It splits the entry edge\n@@ -1284,7 +1282,7 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n    instruction stream, otherwise it is placed before LOOP.  */\n \n struct loop *\n-loop_version (struct loops *loops, struct loop * loop,\n+loop_version (struct loop *loop,\n \t      void *cond_expr, basic_block *condition_bb,\n \t      bool place_after)\n {\n@@ -1307,7 +1305,7 @@ loop_version (struct loops *loops, struct loop * loop,\n   first_head = entry->dest;\n \n   /* Duplicate loop.  */\n-  if (!cfg_hook_duplicate_loop_to_header_edge (loop, entry, loops, 1,\n+  if (!cfg_hook_duplicate_loop_to_header_edge (loop, entry, 1,\n \t\t\t\t\t       NULL, NULL, NULL, NULL, 0))\n     return NULL;\n \n@@ -1330,8 +1328,7 @@ loop_version (struct loops *loops, struct loop * loop,\n   latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n \n   extract_cond_bb_edges (cond_bb, &true_edge, &false_edge);\n-  nloop = loopify (loops,\n-\t\t   latch_edge,\n+  nloop = loopify (latch_edge,\n \t\t   single_pred_edge (get_bb_copy (loop->header)),\n \t\t   cond_bb, true_edge, false_edge,\n \t\t   false /* Do not redirect all edges.  */);\n@@ -1379,7 +1376,7 @@ loop_version (struct loops *loops, struct loop * loop,\n   return nloop;\n }\n \n-/* The structure of LOOPS might have changed.  Some loops might get removed\n+/* The structure of loops might have changed.  Some loops might get removed\n    (and their headers and latches were set to NULL), loop exists might get\n    removed (thus the loop nesting may be wrong), and some blocks and edges\n    were changed (so the information about bb --> loop mapping does not have\n@@ -1391,7 +1388,7 @@ loop_version (struct loops *loops, struct loop * loop,\n    marked in it.  */\n \n void\n-fix_loop_structure (struct loops *loops, bitmap changed_bbs)\n+fix_loop_structure (bitmap changed_bbs)\n {\n   basic_block bb;\n   struct loop *loop, *ploop;\n@@ -1401,14 +1398,14 @@ fix_loop_structure (struct loops *loops, bitmap changed_bbs)\n   FOR_EACH_BB (bb)\n     {\n       bb->aux = (void *) (size_t) bb->loop_father->depth;\n-      bb->loop_father = loops->tree_root;\n+      bb->loop_father = current_loops->tree_root;\n     }\n \n   /* Remove the dead loops from structures.  */\n-  loops->tree_root->num_nodes = n_basic_blocks;\n-  for (i = 1; i < loops->num; i++)\n+  current_loops->tree_root->num_nodes = n_basic_blocks;\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n@@ -1425,22 +1422,22 @@ fix_loop_structure (struct loops *loops, bitmap changed_bbs)\n \n       /* Remove the loop and free its data.  */\n       flow_loop_tree_node_remove (loop);\n-      loops->parray[loop->num] = NULL;\n+      current_loops->parray[loop->num] = NULL;\n       flow_loop_free (loop);\n     }\n \n   /* Rescan the bodies of loops, starting from the outermost.  */\n-  loop = loops->tree_root;\n+  loop = current_loops->tree_root;\n   while (1)\n     {\n       if (loop->inner)\n \tloop = loop->inner;\n       else\n \t{\n \t  while (!loop->next\n-\t\t && loop != loops->tree_root)\n+\t\t && loop != current_loops->tree_root)\n \t    loop = loop->outer;\n-\t  if (loop == loops->tree_root)\n+\t  if (loop == current_loops->tree_root)\n \t    break;\n \n \t  loop = loop->next;\n@@ -1450,9 +1447,9 @@ fix_loop_structure (struct loops *loops, bitmap changed_bbs)\n     }\n \n   /* Now fix the loop nesting.  */\n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n@@ -1474,8 +1471,8 @@ fix_loop_structure (struct loops *loops, bitmap changed_bbs)\n       bb->aux = NULL;\n     }\n \n-  if (loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n-    mark_single_exit_loops (loops);\n-  if (loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n-    mark_irreducible_loops (loops);\n+  if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n+    mark_single_exit_loops ();\n+  if (current_loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n+    mark_irreducible_loops ();\n }"}, {"sha": "602836096c57508162609fa3ada6f084c2458024", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -3857,7 +3857,7 @@ if_convert (int x_life_data_ok)\n       loop_optimizer_init (0);\n       if (current_loops)\n \t{\n-\t  mark_loop_exit_edges (current_loops);\n+\t  mark_loop_exit_edges ();\n \t  loop_optimizer_finalize ();\n \t}\n       free_dominance_info (CDI_DOMINATORS);"}, {"sha": "f16937b3cbdbdfa8556842b0eaf26511408d1ce4", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -115,8 +115,7 @@\n  Fourier-Motzkin elimination is used to compute the bounds of the base space\n  of the lattice.  */\n \n-static bool perfect_nestify (struct loops *, \n-\t\t\t     struct loop *, VEC(tree,heap) *, \n+static bool perfect_nestify (struct loop *, VEC(tree,heap) *, \n \t\t\t     VEC(tree,heap) *, VEC(int,heap) *,\n \t\t\t     VEC(tree,heap) *);\n /* Lattice stuff that is internal to the code generation algorithm.  */\n@@ -1457,8 +1456,7 @@ DEF_VEC_ALLOC_P(lambda_loop,heap);\n    during this process.  */\n \n lambda_loopnest\n-gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n-\t\t\t\t struct loop *loop_nest,\n+gcc_loopnest_to_lambda_loopnest (struct loop *loop_nest,\n \t\t\t\t VEC(tree,heap) **inductionvars,\n \t\t\t\t VEC(tree,heap) **invariants)\n {\n@@ -1493,8 +1491,8 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \n   if (!perfect_nest)\n     {\n-      if (!perfect_nestify (currloops, loop_nest, \n-\t\t\t    lboundvars, uboundvars, steps, *inductionvars))\n+      if (!perfect_nestify (loop_nest, lboundvars, uboundvars, steps,\n+\t\t\t    *inductionvars))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -2402,7 +2400,6 @@ can_convert_to_perfect_nest (struct loop *loop)\n }\n \n /* Transform the loop nest into a perfect nest, if possible.\n-   LOOPS is the current struct loops *\n    LOOP is the loop nest to transform into a perfect nest\n    LBOUNDS are the lower bounds for the loops to transform\n    UBOUNDS are the upper bounds for the loops to transform\n@@ -2439,8 +2436,7 @@ can_convert_to_perfect_nest (struct loop *loop)\n    Return FALSE if we can't make this loop into a perfect nest.  */\n \n static bool\n-perfect_nestify (struct loops *loops,\n-\t\t struct loop *loop,\n+perfect_nestify (struct loop *loop,\n \t\t VEC(tree,heap) *lbounds,\n \t\t VEC(tree,heap) *ubounds,\n \t\t VEC(int,heap) *steps,\n@@ -2514,7 +2510,7 @@ perfect_nestify (struct loops *loops,\n   make_edge (latchbb, headerbb, EDGE_FALLTHRU);\n \n   /* Update the loop structures.  */\n-  newloop = duplicate_loop (loops, loop, olddest->loop_father);  \n+  newloop = duplicate_loop (loop, olddest->loop_father);  \n   newloop->header = headerbb;\n   newloop->latch = latchbb;\n   set_single_exit (newloop, e);"}, {"sha": "3a691c24c1c47354b939d0cd07b306c9bf1d9422", "filename": "gcc/lambda.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -141,7 +141,6 @@ typedef struct\n lambda_loopnest lambda_loopnest_new (int, int);\n lambda_loopnest lambda_loopnest_transform (lambda_loopnest, lambda_trans_matrix);\n struct loop;\n-struct loops;\n bool perfect_nest_p (struct loop *);\n void print_lambda_loopnest (FILE *, lambda_loopnest, char);\n \n@@ -196,8 +195,7 @@ lambda_body_vector lambda_body_vector_new (int);\n lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix, \n \t\t\t\t\t\t   lambda_body_vector);\n void print_lambda_body_vector (FILE *, lambda_body_vector);\n-lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loops *,\n-\t\t\t\t\t\t struct loop *,\n+lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loop *,\n \t\t\t\t\t\t VEC(tree,heap) **,\n \t\t\t\t\t\t VEC(tree,heap) **);\n void lambda_loopnest_to_gcc_loopnest (struct loop *,"}, {"sha": "093ec30f7088b8c5325870bbc596abb0b3d5f688", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -616,17 +616,17 @@ doloop_optimize (struct loop *loop)\n   return true;\n }\n \n-/* This is the main entry point.  Process all LOOPS using doloop_optimize.  */\n+/* This is the main entry point.  Process all loops using doloop_optimize.  */\n \n void\n-doloop_optimize_loops (struct loops *loops)\n+doloop_optimize_loops (void)\n {\n   unsigned i;\n   struct loop *loop;\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n@@ -637,7 +637,7 @@ doloop_optimize_loops (struct loops *loops)\n \n #ifdef ENABLE_CHECKING\n   verify_dominators (CDI_DOMINATORS);\n-  verify_loop_structure (loops);\n+  verify_loop_structure ();\n #endif\n }\n #endif /* HAVE_doloop_end */"}, {"sha": "35727c06b84ddac40ab1d5d655fcf8cc02dbb10a", "filename": "gcc/loop-init.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -77,25 +77,25 @@ loop_optimizer_init (unsigned flags)\n \n   /* Create pre-headers.  */\n   if (flags & LOOPS_HAVE_PREHEADERS)\n-    create_preheaders (current_loops, CP_SIMPLE_PREHEADERS);\n+    create_preheaders (CP_SIMPLE_PREHEADERS);\n \n   /* Force all latches to have only single successor.  */\n   if (flags & LOOPS_HAVE_SIMPLE_LATCHES)\n-    force_single_succ_latches (current_loops);\n+    force_single_succ_latches ();\n \n   /* Mark irreducible loops.  */\n   if (flags & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n-    mark_irreducible_loops (current_loops);\n+    mark_irreducible_loops ();\n \n   if (flags & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n-    mark_single_exit_loops (current_loops);\n+    mark_single_exit_loops ();\n \n   /* Dump loops.  */\n-  flow_loops_dump (current_loops, dump_file, NULL, 1);\n+  flow_loops_dump (dump_file, NULL, 1);\n \n #ifdef ENABLE_CHECKING\n   verify_dominators (CDI_DOMINATORS);\n-  verify_loop_structure (current_loops);\n+  verify_loop_structure ();\n #endif\n }\n \n@@ -253,7 +253,7 @@ static unsigned int\n rtl_move_loop_invariants (void)\n {\n   if (current_loops)\n-    move_loop_invariants (current_loops);\n+    move_loop_invariants ();\n   return 0;\n }\n \n@@ -286,7 +286,7 @@ static unsigned int\n rtl_unswitch (void)\n {\n   if (current_loops)\n-    unswitch_loops (current_loops);\n+    unswitch_loops ();\n   return 0;\n }\n \n@@ -329,7 +329,7 @@ rtl_unroll_and_peel_loops (void)\n       if (flag_unroll_all_loops)\n \tflags |= UAP_UNROLL_ALL;\n \n-      unroll_and_peel_loops (current_loops, flags);\n+      unroll_and_peel_loops (flags);\n     }\n   return 0;\n }\n@@ -368,7 +368,7 @@ rtl_doloop (void)\n {\n #ifdef HAVE_doloop_end\n   if (current_loops)\n-    doloop_optimize_loops (current_loops);\n+    doloop_optimize_loops ();\n #endif\n   return 0;\n }"}, {"sha": "d4258f057c3cb74bf670ba812f5b905ed838c797", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -1312,10 +1312,10 @@ free_loop_data (struct loop *loop)\n   loop->aux = NULL;\n }\n \n-/* Move the invariants out of the LOOPS.  */\n+/* Move the invariants out of the loops.  */\n \n void\n-move_loop_invariants (struct loops *loops)\n+move_loop_invariants (void)\n {\n   struct loop *loop;\n   unsigned i;\n@@ -1324,11 +1324,11 @@ move_loop_invariants (struct loops *loops)\n   df_chain_add_problem (df, DF_UD_CHAIN);\n  \n   /* Process the loops, innermost first.  */\n-  loop = loops->tree_root;\n+  loop = current_loops->tree_root;\n   while (loop->inner)\n     loop = loop->inner;\n \n-  while (loop != loops->tree_root)\n+  while (loop != current_loops->tree_root)\n     {\n       move_single_loop_invariants (loop);\n \n@@ -1342,9 +1342,9 @@ move_loop_invariants (struct loops *loops)\n \tloop = loop->outer;\n     }\n \n-  for (i = 1; i < loops->num; i++)\n-    if (loops->parray[i])\n-      free_loop_data (loops->parray[i]);\n+  for (i = 1; i < current_loops->num; i++)\n+    if (current_loops->parray[i])\n+      free_loop_data (current_loops->parray[i]);\n \n   df_finish (df);\n   df = NULL;"}, {"sha": "776b2e1f6b15f854d14cfb6364372129a9d2fcfc", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -114,19 +114,19 @@ struct opt_info\n   basic_block loop_preheader;      /* The loop preheader basic block.  */\n };\n \n-static void decide_unrolling_and_peeling (struct loops *, int);\n-static void peel_loops_completely (struct loops *, int);\n+static void decide_unrolling_and_peeling (int);\n+static void peel_loops_completely (int);\n static void decide_peel_simple (struct loop *, int);\n static void decide_peel_once_rolling (struct loop *, int);\n static void decide_peel_completely (struct loop *, int);\n static void decide_unroll_stupid (struct loop *, int);\n static void decide_unroll_constant_iterations (struct loop *, int);\n static void decide_unroll_runtime_iterations (struct loop *, int);\n-static void peel_loop_simple (struct loops *, struct loop *);\n-static void peel_loop_completely (struct loops *, struct loop *);\n-static void unroll_loop_stupid (struct loops *, struct loop *);\n-static void unroll_loop_constant_iterations (struct loops *, struct loop *);\n-static void unroll_loop_runtime_iterations (struct loops *, struct loop *);\n+static void peel_loop_simple (struct loop *);\n+static void peel_loop_completely (struct loop *);\n+static void unroll_loop_stupid (struct loop *);\n+static void unroll_loop_constant_iterations (struct loop *);\n+static void unroll_loop_runtime_iterations (struct loop *);\n static struct opt_info *analyze_insns_in_loop (struct loop *);\n static void opt_info_start_duplication (struct opt_info *);\n static void apply_opt_in_copies (struct opt_info *, unsigned, bool, bool);\n@@ -142,24 +142,24 @@ static rtx get_expansion (struct var_to_expand *);\n \n /* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n void\n-unroll_and_peel_loops (struct loops *loops, int flags)\n+unroll_and_peel_loops (int flags)\n {\n   struct loop *loop, *next;\n   bool check;\n \n   /* First perform complete loop peeling (it is almost surely a win,\n      and affects parameters for further decision a lot).  */\n-  peel_loops_completely (loops, flags);\n+  peel_loops_completely (flags);\n \n   /* Now decide rest of unrolling and peeling.  */\n-  decide_unrolling_and_peeling (loops, flags);\n+  decide_unrolling_and_peeling (flags);\n \n-  loop = loops->tree_root;\n+  loop = current_loops->tree_root;\n   while (loop->inner)\n     loop = loop->inner;\n \n   /* Scan the loops, inner ones first.  */\n-  while (loop != loops->tree_root)\n+  while (loop != current_loops->tree_root)\n     {\n       if (loop->next)\n \t{\n@@ -178,16 +178,16 @@ unroll_and_peel_loops (struct loops *loops, int flags)\n \t  /* Already done.  */\n \t  gcc_unreachable ();\n \tcase LPT_PEEL_SIMPLE:\n-\t  peel_loop_simple (loops, loop);\n+\t  peel_loop_simple (loop);\n \t  break;\n \tcase LPT_UNROLL_CONSTANT:\n-\t  unroll_loop_constant_iterations (loops, loop);\n+\t  unroll_loop_constant_iterations (loop);\n \t  break;\n \tcase LPT_UNROLL_RUNTIME:\n-\t  unroll_loop_runtime_iterations (loops, loop);\n+\t  unroll_loop_runtime_iterations (loop);\n \t  break;\n \tcase LPT_UNROLL_STUPID:\n-\t  unroll_loop_stupid (loops, loop);\n+\t  unroll_loop_stupid (loop);\n \t  break;\n \tcase LPT_NONE:\n \t  check = false;\n@@ -199,7 +199,7 @@ unroll_and_peel_loops (struct loops *loops, int flags)\n \t{\n #ifdef ENABLE_CHECKING\n \t  verify_dominators (CDI_DOMINATORS);\n-\t  verify_loop_structure (loops);\n+\t  verify_loop_structure ();\n #endif\n \t}\n       loop = next;\n@@ -229,17 +229,17 @@ loop_exit_at_end_p (struct loop *loop)\n   return true;\n }\n \n-/* Check whether to peel LOOPS (depending on FLAGS) completely and do so.  */\n+/* Depending on FLAGS, check whether to peel loops completely and do so.  */\n static void\n-peel_loops_completely (struct loops *loops, int flags)\n+peel_loops_completely (int flags)\n {\n   struct loop *loop;\n   unsigned i;\n \n   /* Scan the loops, the inner ones first.  */\n-  for (i = loops->num - 1; i > 0; i--)\n+  for (i = current_loops->num - 1; i > 0; i--)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n@@ -258,26 +258,26 @@ peel_loops_completely (struct loops *loops, int flags)\n \n       if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n \t{\n-\t  peel_loop_completely (loops, loop);\n+\t  peel_loop_completely (loop);\n #ifdef ENABLE_CHECKING\n \t  verify_dominators (CDI_DOMINATORS);\n-\t  verify_loop_structure (loops);\n+\t  verify_loop_structure ();\n #endif\n \t}\n     }\n }\n \n-/* Decide whether unroll or peel LOOPS (depending on FLAGS) and how much.  */\n+/* Decide whether unroll or peel loops (depending on FLAGS) and how much.  */\n static void\n-decide_unrolling_and_peeling (struct loops *loops, int flags)\n+decide_unrolling_and_peeling (int flags)\n {\n-  struct loop *loop = loops->tree_root, *next;\n+  struct loop *loop = current_loops->tree_root, *next;\n \n   while (loop->inner)\n     loop = loop->inner;\n \n   /* Scan the loops, inner ones first.  */\n-  while (loop != loops->tree_root)\n+  while (loop != current_loops->tree_root)\n     {\n       if (loop->next)\n \t{\n@@ -475,7 +475,7 @@ decide_peel_completely (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n    body; i++;\n    */\n static void\n-peel_loop_completely (struct loops *loops, struct loop *loop)\n+peel_loop_completely (struct loop *loop)\n {\n   sbitmap wont_exit;\n   unsigned HOST_WIDE_INT npeel;\n@@ -504,7 +504,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n       \n       opt_info_start_duplication (opt_info);\n       ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t\t  loops, npeel,\n+\t\t\t\t\t  npeel,\n \t\t\t\t\t  wont_exit, desc->out_edge,\n \t\t\t\t\t  remove_edges, &n_remove_edges,\n \t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ\n@@ -523,7 +523,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n \n       /* Remove the exit edges.  */\n       for (i = 0; i < n_remove_edges; i++)\n-\tremove_path (loops, remove_edges[i]);\n+\tremove_path (remove_edges[i]);\n       free (remove_edges);\n     }\n \n@@ -532,7 +532,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n \n   /* Now remove the unreachable part of the last iteration and cancel\n      the loop.  */\n-  remove_path (loops, ein);\n+  remove_path (ein);\n \n   if (dump_file)\n     fprintf (dump_file, \";; Peeled loop completely, %d times\\n\", (int) npeel);\n@@ -658,7 +658,7 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n      }\n   */\n static void\n-unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n+unroll_loop_constant_iterations (struct loop *loop)\n {\n   unsigned HOST_WIDE_INT niter;\n   unsigned exit_mod;\n@@ -705,7 +705,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \t{\n \t  opt_info_start_duplication (opt_info);\n           ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t\t      loops, exit_mod,\n+\t\t\t\t\t      exit_mod,\n \t\t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t\t      remove_edges, &n_remove_edges,\n \t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ\n@@ -744,7 +744,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n          \n           opt_info_start_duplication (opt_info);\n \t  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t\t      loops, exit_mod + 1,\n+\t\t\t\t\t      exit_mod + 1,\n \t\t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t\t      remove_edges, &n_remove_edges,\n \t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ\n@@ -771,7 +771,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   \n   opt_info_start_duplication (opt_info);\n   ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\t\t\t      loops, max_unroll,\n+\t\t\t\t      max_unroll,\n \t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t      remove_edges, &n_remove_edges,\n \t\t\t\t      DLTHE_FLAG_UPDATE_FREQ\n@@ -811,7 +811,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \n   /* Remove the edges.  */\n   for (i = 0; i < n_remove_edges; i++)\n-    remove_path (loops, remove_edges[i]);\n+    remove_path (remove_edges[i]);\n   free (remove_edges);\n \n   if (dump_file)\n@@ -948,7 +948,7 @@ split_edge_and_insert (edge e, rtx insns)\n      }\n    */\n static void\n-unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n+unroll_loop_runtime_iterations (struct loop *loop)\n {\n   rtx old_niter, niter, init_code, branch_code, tmp;\n   unsigned i, j, p;\n@@ -1043,8 +1043,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n     SET_BIT (wont_exit, 1);\n   ezc_swtch = loop_preheader_edge (loop)->src;\n   ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t      loops, 1,\n-\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t      1, wont_exit, desc->out_edge,\n \t\t\t\t      remove_edges, &n_remove_edges,\n \t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n   gcc_assert (ok);\n@@ -1059,8 +1058,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       if (i != n_peel - 1 || !last_may_exit)\n \tSET_BIT (wont_exit, 1);\n       ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t\t  loops, 1,\n-\t\t\t\t\t  wont_exit, desc->out_edge,\n+\t\t\t\t\t  1, wont_exit, desc->out_edge,\n \t\t\t\t\t  remove_edges, &n_remove_edges,\n \t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ);\n       gcc_assert (ok);\n@@ -1115,7 +1113,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   opt_info_start_duplication (opt_info);\n   \n   ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\t\t\t      loops, max_unroll,\n+\t\t\t\t      max_unroll,\n \t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t      remove_edges, &n_remove_edges,\n \t\t\t\t      DLTHE_FLAG_UPDATE_FREQ\n@@ -1152,7 +1150,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n \n   /* Remove the edges.  */\n   for (i = 0; i < n_remove_edges; i++)\n-    remove_path (loops, remove_edges[i]);\n+    remove_path (remove_edges[i]);\n   free (remove_edges);\n \n   /* We must be careful when updating the number of iterations due to\n@@ -1282,7 +1280,7 @@ decide_peel_simple (struct loop *loop, int flags)\n    end: ;\n    */\n static void\n-peel_loop_simple (struct loops *loops, struct loop *loop)\n+peel_loop_simple (struct loop *loop)\n {\n   sbitmap wont_exit;\n   unsigned npeel = loop->lpt_decision.times;\n@@ -1299,7 +1297,7 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n   opt_info_start_duplication (opt_info);\n   \n   ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t      loops, npeel, wont_exit,\n+\t\t\t\t      npeel, wont_exit,\n \t\t\t\t      NULL, NULL,\n \t\t\t\t      NULL, DLTHE_FLAG_UPDATE_FREQ\n \t\t\t\t      | (opt_info\n@@ -1432,7 +1430,7 @@ decide_unroll_stupid (struct loop *loop, int flags)\n      }\n    */\n static void\n-unroll_loop_stupid (struct loops *loops, struct loop *loop)\n+unroll_loop_stupid (struct loop *loop)\n {\n   sbitmap wont_exit;\n   unsigned nunroll = loop->lpt_decision.times;\n@@ -1450,7 +1448,7 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n   opt_info_start_duplication (opt_info);\n   \n   ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\t\t\t      loops, nunroll, wont_exit,\n+\t\t\t\t      nunroll, wont_exit,\n \t\t\t\t      NULL, NULL, NULL,\n \t\t\t\t      DLTHE_FLAG_UPDATE_FREQ\n \t\t\t\t      | (opt_info"}, {"sha": "db236e89e274a861a9b10c9a5c55aaa84dd3821d", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -79,9 +79,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n   containing subloops would not be very large compared to complications\n   with handling this case.  */\n \n-static struct loop *unswitch_loop (struct loops *, struct loop *,\n-\t\t\t\t   basic_block, rtx, rtx);\n-static void unswitch_single_loop (struct loops *, struct loop *, rtx, int);\n+static struct loop *unswitch_loop (struct loop *, basic_block, rtx, rtx);\n+static void unswitch_single_loop (struct loop *, rtx, int);\n static rtx may_unswitch_on (basic_block, struct loop *, rtx *);\n \n /* Prepare a sequence comparing OP0 with OP1 using COMP and jumping to LABEL if\n@@ -135,30 +134,30 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n   return seq;\n }\n \n-/* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */\n+/* Main entry point.  Perform loop unswitching on all suitable loops.  */\n void\n-unswitch_loops (struct loops *loops)\n+unswitch_loops (void)\n {\n   int i, num;\n   struct loop *loop;\n \n   /* Go through inner loops (only original ones).  */\n-  num = loops->num;\n+  num = current_loops->num;\n \n   for (i = 1; i < num; i++)\n     {\n       /* Removed loop?  */\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n       if (loop->inner)\n \tcontinue;\n \n-      unswitch_single_loop (loops, loop, NULL_RTX, 0);\n+      unswitch_single_loop (loop, NULL_RTX, 0);\n #ifdef ENABLE_CHECKING\n       verify_dominators (CDI_DOMINATORS);\n-      verify_loop_structure (loops);\n+      verify_loop_structure ();\n #endif\n     }\n \n@@ -259,8 +258,7 @@ reversed_condition (rtx cond)\n    number of unswitchings done; do not allow it to grow too much, it is too\n    easy to create example on that the code would grow exponentially.  */\n static void\n-unswitch_single_loop (struct loops *loops, struct loop *loop,\n-\t\t      rtx cond_checked, int num)\n+unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n {\n   basic_block *bbs;\n   struct loop *nloop;\n@@ -351,15 +349,15 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n \t{\n \t  /* Remove false path.  */\n \t  e = FALLTHRU_EDGE (bbs[i]);\n-\t  remove_path (loops, e);\n+\t  remove_path (e);\n \t  free (bbs);\n \t  repeat = 1;\n \t}\n       else if (cond == const0_rtx)\n \t{\n \t  /* Remove true path.  */\n \t  e = BRANCH_EDGE (bbs[i]);\n-\t  remove_path (loops, e);\n+\t  remove_path (e);\n \t  free (bbs);\n \t  repeat = 1;\n \t}\n@@ -376,12 +374,12 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n     fprintf (dump_file, \";; Unswitching loop\\n\");\n \n   /* Unswitch the loop on this condition.  */\n-  nloop = unswitch_loop (loops, loop, bbs[i], cond, cinsn);\n+  nloop = unswitch_loop (loop, bbs[i], cond, cinsn);\n   gcc_assert (nloop);\n \n   /* Invoke itself on modified loops.  */\n-  unswitch_single_loop (loops, nloop, rconds, num + 1);\n-  unswitch_single_loop (loops, loop, conds, num + 1);\n+  unswitch_single_loop (nloop, rconds, num + 1);\n+  unswitch_single_loop (loop, conds, num + 1);\n \n   free_EXPR_LIST_node (conds);\n   if (rcond)\n@@ -398,8 +396,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n    NULL, it is the insn in that COND is compared.  */\n \n static struct loop *\n-unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n-\t       rtx cond, rtx cinsn)\n+unswitch_loop (struct loop *loop, basic_block unswitch_on, rtx cond, rtx cinsn)\n {\n   edge entry, latch_edge, true_edge, false_edge, e;\n   basic_block switch_bb, unswitch_on_alt;\n@@ -423,7 +420,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   entry->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n   zero_bitmap = sbitmap_alloc (2);\n   sbitmap_zero (zero_bitmap);\n-  if (!duplicate_loop_to_header_edge (loop, entry, loops, 1,\n+  if (!duplicate_loop_to_header_edge (loop, entry, 1,\n \tzero_bitmap, NULL, NULL, NULL, 0))\n     {\n       sbitmap_free (zero_bitmap);\n@@ -466,13 +463,13 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n     }\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n-  nloop = loopify (loops, latch_edge,\n+  nloop = loopify (latch_edge,\n \t\t   single_pred_edge (get_bb_copy (loop->header)), switch_bb,\n \t\t   BRANCH_EDGE (switch_bb), FALLTHRU_EDGE (switch_bb), true);\n \n   /* Remove branches that are now unreachable in new loops.  */\n-  remove_path (loops, true_edge);\n-  remove_path (loops, false_edge);\n+  remove_path (true_edge);\n+  remove_path (false_edge);\n \n   /* One of created loops do not have to be subloop of the outer loop now,\n      so fix its placement in loop data structure.  */"}, {"sha": "83a07eade8502bbfffc459399f824f79d8a1efa1", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -1176,8 +1176,7 @@ sms_schedule (void)\n \t\t  rtx comp_rtx = gen_rtx_fmt_ee (GT, VOIDmode, count_reg,\n \t\t\t\t\t\t GEN_INT(stage_count));\n \n-\t\t  nloop = loop_version (current_loops, loop, comp_rtx,\n-\t\t\t\t\t&condition_bb, true);\n+\t\t  nloop = loop_version (loop, comp_rtx, &condition_bb, true);\n \t\t}\n \n \t      /* Set new iteration count of loop kernel.  */"}, {"sha": "e865a6223cc71999dbf5f8a4aa9799aa02efe22f", "filename": "gcc/predict.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -74,12 +74,12 @@ static sreal real_zero, real_one, real_almost_one, real_br_prob_base,\n \n static void combine_predictions_for_insn (rtx, basic_block);\n static void dump_prediction (FILE *, enum br_predictor, int, basic_block, int);\n-static void estimate_bb_frequencies (struct loops *);\n static void predict_paths_leading_to (basic_block, int *, enum br_predictor, enum prediction);\n static bool last_basic_block_p (basic_block);\n static void compute_function_frequency (void);\n static void choose_function_section (void);\n static bool can_predict_insn_p (rtx);\n+static void estimate_bb_frequencies (void);\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -625,23 +625,22 @@ combine_predictions_for_bb (basic_block bb)\n     }\n }\n \n-/* Predict edge probabilities by exploiting loop structure.\n-   When RTLSIMPLELOOPS is set, attempt to count number of iterations by analyzing\n-   RTL otherwise use tree based approach.  */\n+/* Predict edge probabilities by exploiting loop structure.  */\n+\n static void\n-predict_loops (struct loops *loops_info)\n+predict_loops (void)\n {\n   unsigned i;\n \n-  scev_initialize (loops_info);\n+  scev_initialize ();\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n-  for (i = 1; i < loops_info->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n       basic_block bb, *bbs;\n       unsigned j, n_exits;\n-      struct loop *loop = loops_info->parray[i];\n+      struct loop *loop = current_loops->parray[i];\n       VEC (edge, heap) *exits;\n       struct tree_niter_desc niter_desc;\n       edge ex;\n@@ -1252,7 +1251,7 @@ tree_estimate_probability (void)\n \n   loop_optimizer_init (0);\n   if (current_loops && dump_file && (dump_flags & TDF_DETAILS))\n-    flow_loops_dump (current_loops, dump_file, NULL, 0);\n+    flow_loops_dump (dump_file, NULL, 0);\n \n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n@@ -1261,9 +1260,9 @@ tree_estimate_probability (void)\n \n   tree_bb_level_predictions ();\n \n-  mark_irreducible_loops (current_loops);\n+  mark_irreducible_loops ();\n   if (current_loops)\n-    predict_loops (current_loops);\n+    predict_loops ();\n \n   FOR_EACH_BB (bb)\n     {\n@@ -1325,7 +1324,7 @@ tree_estimate_probability (void)\n     combine_predictions_for_bb (bb);\n \n   strip_builtin_expect ();\n-  estimate_bb_frequencies (current_loops);\n+  estimate_bb_frequencies ();\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n   loop_optimizer_finalize ();\n@@ -1602,17 +1601,17 @@ estimate_loops_at_level (struct loop *first_loop)\n     }\n }\n \n-/* Propates frequencies through structure of LOOPS.  */\n+/* Propates frequencies through structure of loops.  */\n \n static void\n-estimate_loops (struct loops *loops)\n+estimate_loops (void)\n {\n   bitmap tovisit = BITMAP_ALLOC (NULL);\n   basic_block bb;\n \n   /* Start by estimating the frequencies in the loops.  */\n-  if (loops)\n-    estimate_loops_at_level (loops->tree_root->inner);\n+  if (current_loops)\n+    estimate_loops_at_level (current_loops->tree_root->inner);\n \n   /* Now propagate the frequencies through all the blocks.  */\n   FOR_ALL_BB (bb)\n@@ -1685,7 +1684,7 @@ expensive_function_p (int threshold)\n /* Estimate basic blocks frequency by given branch probabilities.  */\n \n static void\n-estimate_bb_frequencies (struct loops *loops)\n+estimate_bb_frequencies (void)\n {\n   basic_block bb;\n   sreal freq_max;\n@@ -1729,7 +1728,7 @@ estimate_bb_frequencies (struct loops *loops)\n \n       /* First compute probabilities locally for each loop from innermost\n          to outermost to examine probabilities for back edges.  */\n-      estimate_loops (loops);\n+      estimate_loops ();\n \n       memcpy (&freq_max, &real_zero, sizeof (real_zero));\n       FOR_EACH_BB (bb)"}, {"sha": "d13a53668d42ac49569b906531d4c6eecf12884a", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -589,7 +589,7 @@ cleanup_tree_cfg_loop (void)\n   if (changed)\n     {\n       bitmap changed_bbs = BITMAP_ALLOC (NULL);\n-      fix_loop_structure (current_loops, changed_bbs);\n+      fix_loop_structure (changed_bbs);\n       calculate_dominance_info (CDI_DOMINATORS);\n \n       /* This usually does nothing.  But sometimes parts of cfg that originally\n@@ -600,7 +600,7 @@ cleanup_tree_cfg_loop (void)\n       BITMAP_FREE (changed_bbs);\n \n #ifdef ENABLE_CHECKING\n-      verify_loop_structure (current_loops);\n+      verify_loop_structure ();\n #endif\n       scev_reset ();\n     }"}, {"sha": "6108b6210a3a111abd5091719cbe7c9b236c81d1", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -802,7 +802,7 @@ struct tree_niter_desc\n };\n \n /* In tree-vectorizer.c */\n-unsigned vectorize_loops (struct loops *);\n+unsigned vectorize_loops (void);\n extern bool vect_can_force_dr_alignment_p (tree, unsigned int);\n extern tree get_vectype_for_scalar_type (tree);\n \n@@ -811,28 +811,28 @@ bool empty_block_p (basic_block);\n \n /* In tree-ssa-loop*.c  */\n \n-void tree_ssa_lim (struct loops *);\n-unsigned int tree_ssa_unswitch_loops (struct loops *);\n-unsigned int canonicalize_induction_variables (struct loops *);\n-unsigned int tree_unroll_loops_completely (struct loops *, bool);\n-unsigned int tree_ssa_prefetch_arrays (struct loops *);\n-unsigned int remove_empty_loops (struct loops *);\n-void tree_ssa_iv_optimize (struct loops *);\n+void tree_ssa_lim (void);\n+unsigned int tree_ssa_unswitch_loops (void);\n+unsigned int canonicalize_induction_variables (void);\n+unsigned int tree_unroll_loops_completely (bool);\n+unsigned int tree_ssa_prefetch_arrays (void);\n+unsigned int remove_empty_loops (void);\n+void tree_ssa_iv_optimize (void);\n \n bool number_of_iterations_exit (struct loop *, edge,\n \t\t\t\tstruct tree_niter_desc *niter, bool);\n tree find_loop_niter (struct loop *, edge *);\n tree loop_niter_by_eval (struct loop *, edge);\n tree find_loop_niter_by_eval (struct loop *, edge *);\n-void estimate_numbers_of_iterations (struct loops *);\n+void estimate_numbers_of_iterations (void);\n bool scev_probably_wraps_p (tree, tree, tree, struct loop *, bool);\n bool convert_affine_scev (struct loop *, tree, tree *, tree *, tree, bool);\n \n bool nowrap_type_p (tree);\n enum ev_direction {EV_DIR_GROWS, EV_DIR_DECREASES, EV_DIR_UNKNOWN};\n enum ev_direction scev_direction (tree);\n \n-void free_numbers_of_iterations_estimates (struct loops *);\n+void free_numbers_of_iterations_estimates (void);\n void free_numbers_of_iterations_estimates_loop (struct loop *);\n void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n void verify_loop_closed_ssa (void);\n@@ -845,18 +845,18 @@ void standard_iv_increment_position (struct loop *, block_stmt_iterator *,\n \t\t\t\t     bool *);\n basic_block ip_end_pos (struct loop *);\n basic_block ip_normal_pos (struct loop *);\n-bool tree_duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n+bool tree_duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t unsigned int, sbitmap,\n \t\t\t\t\t edge, edge *,\n \t\t\t\t\t unsigned int *, int);\n-struct loop *tree_ssa_loop_version (struct loops *, struct loop *, tree,\n+struct loop *tree_ssa_loop_version (struct loop *, tree,\n \t\t\t\t    basic_block *);\n tree expand_simple_operations (tree);\n void substitute_in_loop_info (struct loop *, tree, tree);\n edge single_dom_exit (struct loop *);\n bool can_unroll_loop_p (struct loop *loop, unsigned factor,\n \t\t\tstruct tree_niter_desc *niter);\n-void tree_unroll_loop (struct loops *, struct loop *, unsigned,\n+void tree_unroll_loop (struct loop *, unsigned,\n \t\t       edge, struct tree_niter_desc *);\n bool contains_abnormal_ssa_name_p (tree);\n \n@@ -943,7 +943,7 @@ void sra_init_cache (void);\n bool sra_type_can_be_decomposed_p (tree);\n \n /* In tree-loop-linear.c  */\n-extern void linear_transform_loops (struct loops *);\n+extern void linear_transform_loops (void);\n \n /* In tree-ssa-loop-ivopts.c  */\n bool expr_invariant_in_loop_p (struct loop *, tree);"}, {"sha": "0c1c685d00219990e31ed2bc313f7e4925b733a1", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -236,22 +236,22 @@ try_interchange_loops (lambda_trans_matrix trans,\n   return trans;\n }\n \n-/* Perform a set of linear transforms on LOOPS.  */\n+/* Perform a set of linear transforms on loops.  */\n \n void\n-linear_transform_loops (struct loops *loops)\n+linear_transform_loops (void)\n {\n   bool modified = false;\n   unsigned int i;\n   VEC(tree,heap) *oldivs = NULL;\n   VEC(tree,heap) *invariants = NULL;\n   \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n       unsigned int depth = 0;\n       VEC (ddr_p, heap) *dependence_relations;\n       VEC (data_reference_p, heap) *datarefs;\n-      struct loop *loop_nest = loops->parray[i];\n+      struct loop *loop_nest = current_loops->parray[i];\n       struct loop *temp;\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n@@ -319,7 +319,7 @@ linear_transform_loops (struct loops *loops)\n \t  goto free_and_continue;\n \t}\n \n-      before = gcc_loopnest_to_lambda_loopnest (loops, loop_nest, &oldivs,\n+      before = gcc_loopnest_to_lambda_loopnest (loop_nest, &oldivs,\n \t\t\t\t\t\t&invariants);\n \n       if (!before)"}, {"sha": "0c5955796181b30f514d44554b0c3c0ac58c0744", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -1015,10 +1015,9 @@ get_exit_conditions_rec (struct loop *loop,\n    initializes the EXIT_CONDITIONS array.  */\n \n static void\n-select_loops_exit_conditions (struct loops *loops, \n-\t\t\t      VEC(tree,heap) **exit_conditions)\n+select_loops_exit_conditions (VEC(tree,heap) **exit_conditions)\n {\n-  struct loop *function_body = loops->parray[0];\n+  struct loop *function_body = current_loops->tree_root;\n   \n   get_exit_conditions_rec (function_body->inner, exit_conditions);\n }\n@@ -2745,20 +2744,19 @@ initialize_scalar_evolutions_analyzer (void)\n /* Initialize the analysis of scalar evolutions for LOOPS.  */\n \n void\n-scev_initialize (struct loops *loops)\n+scev_initialize (void)\n {\n   unsigned i;\n-  current_loops = loops;\n \n   scalar_evolution_info = htab_create (100, hash_scev_info,\n \t\t\t\t       eq_scev_info, del_scev_info);\n   already_instantiated = BITMAP_ALLOC (NULL);\n   \n   initialize_scalar_evolutions_analyzer ();\n \n-  for (i = 1; i < loops->num; i++)\n-    if (loops->parray[i])\n-      loops->parray[i]->nb_iterations = NULL_TREE;\n+  for (i = 1; i < current_loops->num; i++)\n+    if (current_loops->parray[i])\n+      current_loops->parray[i]->nb_iterations = NULL_TREE;\n }\n \n /* Cleans up the information cached by the scalar evolutions analysis.  */\n@@ -2850,7 +2848,7 @@ scev_analysis (void)\n   VEC(tree,heap) *exit_conditions;\n   \n   exit_conditions = VEC_alloc (tree, heap, 37);\n-  select_loops_exit_conditions (current_loops, &exit_conditions);\n+  select_loops_exit_conditions (&exit_conditions);\n \n   if (dump_file && (dump_flags & TDF_STATS))\n     analyze_scalar_evolution_for_all_loop_phi_nodes (&exit_conditions);"}, {"sha": "ad3ddd5035c6574f59999e83f3ea1f1abc9168a0", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -25,7 +25,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n extern tree number_of_iterations_in_loop (struct loop *);\n extern tree get_loop_exit_condition (struct loop *);\n \n-extern void scev_initialize (struct loops *loops);\n+extern void scev_initialize (void);\n extern void scev_reset (void);\n extern void scev_finalize (void);\n extern tree analyze_scalar_evolution (struct loop *, tree);"}, {"sha": "7b492b23e46d032f51ce6b2b55854d6f9ceee936", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -933,7 +933,7 @@ static unsigned int\n tree_ssa_dce_loop (void)\n {\n   perform_tree_ssa_dce (/*aggressive=*/false);\n-  free_numbers_of_iterations_estimates (current_loops);\n+  free_numbers_of_iterations_estimates ();\n   scev_reset ();\n   return 0;\n }"}, {"sha": "b277068934ecb7b86db431a8ff24fa2b8c31dc86", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -278,7 +278,7 @@ tree_ssa_dominator_optimize (void)\n   loop_optimizer_init (0);\n   if (current_loops)\n     {\n-      mark_loop_exit_edges (current_loops);\n+      mark_loop_exit_edges ();\n       loop_optimizer_finalize ();\n     }\n "}, {"sha": "bcbc514dfbf28be1ff909af9413981ec0f0ec7ac", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -137,7 +137,7 @@ copy_loop_headers (void)\n     return 0;\n \n #ifdef ENABLE_CHECKING\n-  verify_loop_structure (current_loops);\n+  verify_loop_structure ();\n #endif\n \n   bbs = XNEWVEC (basic_block, n_basic_blocks);"}, {"sha": "5b8d6038bcf4967b6f6b9c3ad574746b654806f2", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -1372,20 +1372,20 @@ determine_lsm_loop (struct loop *loop)\n }\n \n /* Try to perform store motion for all memory references modified inside\n-   any of LOOPS.  */\n+   loops.  */\n \n static void\n-determine_lsm (struct loops *loops)\n+determine_lsm (void)\n {\n   struct loop *loop;\n \n-  if (!loops->tree_root->inner)\n+  if (!current_loops->tree_root->inner)\n     return;\n \n   /* Pass the loops from the outermost and perform the store motion as\n      suitable.  */\n \n-  loop = loops->tree_root->inner;\n+  loop = current_loops->tree_root->inner;\n   while (1)\n     {\n       determine_lsm_loop (loop);\n@@ -1398,7 +1398,7 @@ determine_lsm (struct loops *loops)\n       while (!loop->next)\n \t{\n \t  loop = loop->outer;\n-\t  if (loop == loops->tree_root)\n+\t  if (loop == current_loops->tree_root)\n \t    {\n \t      bsi_commit_edge_inserts ();\n \t      return;\n@@ -1476,11 +1476,10 @@ fill_always_executed_in (struct loop *loop, sbitmap contains_call)\n     fill_always_executed_in (loop, contains_call);\n }\n \n-/* Compute the global information needed by the loop invariant motion pass.\n-   LOOPS is the loop tree.  */\n+/* Compute the global information needed by the loop invariant motion pass.  */\n \n static void\n-tree_ssa_lim_initialize (struct loops *loops)\n+tree_ssa_lim_initialize (void)\n {\n   sbitmap contains_call = sbitmap_alloc (last_basic_block);\n   block_stmt_iterator bsi;\n@@ -1500,7 +1499,7 @@ tree_ssa_lim_initialize (struct loops *loops)\n \tSET_BIT (contains_call, bb->index);\n     }\n \n-  for (loop = loops->tree_root->inner; loop; loop = loop->next)\n+  for (loop = current_loops->tree_root->inner; loop; loop = loop->next)\n     fill_always_executed_in (loop, contains_call);\n \n   sbitmap_free (contains_call);\n@@ -1519,13 +1518,13 @@ tree_ssa_lim_finalize (void)\n     }\n }\n \n-/* Moves invariants from LOOPS.  Only \"expensive\" invariants are moved out --\n+/* Moves invariants from loops.  Only \"expensive\" invariants are moved out --\n    i.e. those that are likely to be win regardless of the register pressure.  */\n \n void\n-tree_ssa_lim (struct loops *loops)\n+tree_ssa_lim (void)\n {\n-  tree_ssa_lim_initialize (loops);\n+  tree_ssa_lim_initialize ();\n \n   /* For each statement determine the outermost loop in that it is\n      invariant and cost for computing the invariant.  */\n@@ -1534,7 +1533,7 @@ tree_ssa_lim (struct loops *loops)\n   /* For each memory reference determine whether it is possible to hoist it\n      out of the loop.  Force the necessary invariants to be moved out of the\n      loops as well.  */\n-  determine_lsm (loops);\n+  determine_lsm ();\n \n   /* Move the expressions that are expensive enough.  */\n   move_computations ();"}, {"sha": "c4d857302afc4461bd36f55de3c14f50dd05cb57", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -154,13 +154,12 @@ estimated_unrolled_size (unsigned HOST_WIDE_INT ninsns,\n   return unr_insns;\n }\n \n-/* Tries to unroll LOOP completely, i.e. NITER times.  LOOPS is the\n-   loop tree.  UL determines which loops we are allowed to unroll. \n+/* Tries to unroll LOOP completely, i.e. NITER times.\n+   UL determines which loops we are allowed to unroll. \n    EXIT is the exit of the loop that should be eliminated.  */\n \n static bool\n-try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n-\t\t\t    struct loop *loop,\n+try_unroll_loop_completely (struct loop *loop,\n \t\t\t    edge exit, tree niter,\n \t\t\t    enum unroll_level ul)\n {\n@@ -237,7 +236,7 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n       RESET_BIT (wont_exit, 0);\n \n       if (!tree_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t\t       loops, n_unroll, wont_exit,\n+\t\t\t\t\t       n_unroll, wont_exit,\n \t\t\t\t\t       exit, edges_to_remove,\n \t\t\t\t\t       &n_to_remove,\n \t\t\t\t\t       DLTHE_FLAG_UPDATE_FREQ\n@@ -266,14 +265,14 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n   return true;\n }\n \n-/* Adds a canonical induction variable to LOOP if suitable.  LOOPS is the loops\n-   tree.  CREATE_IV is true if we may create a new iv.  UL determines \n+/* Adds a canonical induction variable to LOOP if suitable.\n+   CREATE_IV is true if we may create a new iv.  UL determines \n    which loops we are allowed to completely unroll.  If TRY_EVAL is true, we try\n    to determine the number of iterations of a loop by direct evaluation. \n    Returns true if cfg is changed.  */\n \n static bool\n-canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n+canonicalize_loop_induction_variables (struct loop *loop,\n \t\t\t\t       bool create_iv, enum unroll_level ul,\n \t\t\t\t       bool try_eval)\n {\n@@ -318,7 +317,7 @@ canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n       fprintf (dump_file, \" times.\\n\");\n     }\n \n-  if (try_unroll_loop_completely (loops, loop, exit, niter, ul))\n+  if (try_unroll_loop_completely (loop, exit, niter, ul))\n     return true;\n \n   if (create_iv)\n@@ -328,21 +327,21 @@ canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n }\n \n /* The main entry point of the pass.  Adds canonical induction variables\n-   to the suitable LOOPS.  */\n+   to the suitable loops.  */\n \n unsigned int\n-canonicalize_induction_variables (struct loops *loops)\n+canonicalize_induction_variables (void)\n {\n   unsigned i;\n   struct loop *loop;\n   bool changed = false;\n   \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n \n       if (loop)\n-\tchanged |= canonicalize_loop_induction_variables (loops, loop,\n+\tchanged |= canonicalize_loop_induction_variables (loop,\n \t\t\t\t\t\t\t  true, UL_SINGLE_ITER,\n \t\t\t\t\t\t\t  true);\n     }\n@@ -361,16 +360,16 @@ canonicalize_induction_variables (struct loops *loops)\n    size of the code does not increase.  */\n \n unsigned int\n-tree_unroll_loops_completely (struct loops *loops, bool may_increase_size)\n+tree_unroll_loops_completely (bool may_increase_size)\n {\n   unsigned i;\n   struct loop *loop;\n   bool changed = false;\n   enum unroll_level ul;\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n \n       if (!loop)\n \tcontinue;\n@@ -379,7 +378,7 @@ tree_unroll_loops_completely (struct loops *loops, bool may_increase_size)\n \tul = UL_ALL;\n       else\n \tul = UL_NO_GROWTH;\n-      changed |= canonicalize_loop_induction_variables (loops, loop,\n+      changed |= canonicalize_loop_induction_variables (loop,\n \t\t\t\t\t\t\tfalse, ul,\n \t\t\t\t\t\t\t!flag_tree_loop_ivcanon);\n     }\n@@ -562,15 +561,15 @@ try_remove_empty_loop (struct loop *loop, bool *changed)\n   return true;\n }\n \n-/* Remove the empty LOOPS.  */\n+/* Remove the empty loops.  */\n \n unsigned int\n-remove_empty_loops (struct loops *loops)\n+remove_empty_loops (void)\n {\n   bool changed = false;\n   struct loop *loop;\n \n-  for (loop = loops->tree_root->inner; loop; loop = loop->next)\n+  for (loop = current_loops->tree_root->inner; loop; loop = loop->next)\n     try_remove_empty_loop (loop, &changed);\n \n   if (changed)"}, {"sha": "40b39f9b3db4ec968e986f1ecb8a851713fc2c2f", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -5878,23 +5878,23 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   return changed;\n }\n \n-/* Main entry point.  Optimizes induction variables in LOOPS.  */\n+/* Main entry point.  Optimizes induction variables in loops.  */\n \n void\n-tree_ssa_iv_optimize (struct loops *loops)\n+tree_ssa_iv_optimize (void)\n {\n   struct loop *loop;\n   struct ivopts_data data;\n \n   tree_ssa_iv_optimize_init (&data);\n \n   /* Optimize the loops starting with the innermost ones.  */\n-  loop = loops->tree_root;\n+  loop = current_loops->tree_root;\n   while (loop->inner)\n     loop = loop->inner;\n \n   /* Scan the loops, inner ones first.  */\n-  while (loop != loops->tree_root)\n+  while (loop != current_loops->tree_root)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tflow_loop_dump (loop, dump_file, NULL, 1);"}, {"sha": "7e50b97b66007b2e4d981a69786c5ac4ee1a488e", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -562,24 +562,23 @@ copy_phi_node_args (unsigned first_new_block)\n \n bool\n tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n-\t\t\t\t    struct loops *loops,\n \t\t\t\t    unsigned int ndupl, sbitmap wont_exit,\n \t\t\t\t    edge orig, edge *to_remove,\n \t\t\t\t    unsigned int *n_to_remove, int flags)\n {\n   unsigned first_new_block;\n \n-  if (!(loops->state & LOOPS_HAVE_SIMPLE_LATCHES))\n+  if (!(current_loops->state & LOOPS_HAVE_SIMPLE_LATCHES))\n     return false;\n-  if (!(loops->state & LOOPS_HAVE_PREHEADERS))\n+  if (!(current_loops->state & LOOPS_HAVE_PREHEADERS))\n     return false;\n \n #ifdef ENABLE_CHECKING\n   verify_loop_closed_ssa ();\n #endif\n \n   first_new_block = last_basic_block;\n-  if (!duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit,\n+  if (!duplicate_loop_to_header_edge (loop, e, ndupl, wont_exit,\n \t\t\t\t      orig, to_remove, n_to_remove, flags))\n     return false;\n \n@@ -757,10 +756,9 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n   *exit_bound = bound;\n }\n \n-/* Unroll LOOP FACTOR times.  LOOPS is the loops tree.  DESC describes\n-   number of iterations of LOOP.  EXIT is the exit of the loop to that\n-   DESC corresponds.\n-   \n+/* Unroll LOOP FACTOR times.  DESC describes number of iterations of LOOP.\n+   EXIT is the exit of the loop to that DESC corresponds.\n+\n    If N is number of iterations of the loop and MAY_BE_ZERO is the condition\n    under that loop exits in the first iteration even if N != 0,\n    \n@@ -809,7 +807,7 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n      } */\n \n void\n-tree_unroll_loop (struct loops *loops, struct loop *loop, unsigned factor,\n+tree_unroll_loop (struct loop *loop, unsigned factor,\n \t\t  edge exit, struct tree_niter_desc *desc)\n {\n   tree dont_exit, exit_if, ctr_before, ctr_after;\n@@ -832,7 +830,7 @@ tree_unroll_loop (struct loops *loops, struct loop *loop, unsigned factor,\n \t\t\t     &enter_main_cond, &exit_base, &exit_step,\n \t\t\t     &exit_cmp, &exit_bound);\n \n-  new_loop = loop_version (loops, loop, enter_main_cond, NULL, true);\n+  new_loop = loop_version (loop, enter_main_cond, NULL, true);\n   gcc_assert (new_loop != NULL);\n   update_ssa (TODO_update_ssa);\n \n@@ -855,7 +853,7 @@ tree_unroll_loop (struct loops *loops, struct loop *loop, unsigned factor,\n   wont_exit = sbitmap_alloc (factor);\n   sbitmap_ones (wont_exit);\n   ok = tree_duplicate_loop_to_header_edge\n-\t  (loop, loop_latch_edge (loop), loops, factor - 1,\n+\t  (loop, loop_latch_edge (loop), factor - 1,\n \t   wont_exit, NULL, NULL, NULL, DLTHE_FLAG_UPDATE_FREQ);\n   free (wont_exit);\n   gcc_assert (ok);\n@@ -926,7 +924,7 @@ tree_unroll_loop (struct loops *loops, struct loop *loop, unsigned factor,\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n   verify_dominators (CDI_DOMINATORS);\n-  verify_loop_structure (loops);\n+  verify_loop_structure ();\n   verify_loop_closed_ssa ();\n #endif\n }"}, {"sha": "34ce6506f34f033d1d6906a8b5859cf0a67df1a4", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -2018,17 +2018,17 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n   compute_estimated_nb_iterations (loop);\n }\n \n-/* Records estimates on numbers of iterations of LOOPS.  */\n+/* Records estimates on numbers of iterations of loops.  */\n \n void\n-estimate_numbers_of_iterations (struct loops *loops)\n+estimate_numbers_of_iterations (void)\n {\n   unsigned i;\n   struct loop *loop;\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (loop)\n \testimate_numbers_of_iterations_loop (loop);\n     }\n@@ -2240,17 +2240,17 @@ free_numbers_of_iterations_estimates_loop (struct loop *loop)\n   loop->bounds = NULL;\n }\n \n-/* Frees the information on upper bounds on numbers of iterations of LOOPS.  */\n+/* Frees the information on upper bounds on numbers of iterations of loops.  */\n \n void\n-free_numbers_of_iterations_estimates (struct loops *loops)\n+free_numbers_of_iterations_estimates (void)\n {\n   unsigned i;\n   struct loop *loop;\n \n-  for (i = 1; i < loops->num; i++)\n+  for (i = 1; i < current_loops->num; i++)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (loop)\n \tfree_numbers_of_iterations_estimates_loop (loop);\n     }"}, {"sha": "07f35cf5d0ce92a0e368edf09bf3293e14ef7c31", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -936,11 +936,10 @@ determine_unroll_factor (struct loop *loop, struct mem_ref_group *refs,\n }\n \n /* Issue prefetch instructions for array references in LOOP.  Returns\n-   true if the LOOP was unrolled.  LOOPS is the array containing all\n-   loops.  */\n+   true if the LOOP was unrolled.  */\n \n static bool\n-loop_prefetch_arrays (struct loops *loops, struct loop *loop)\n+loop_prefetch_arrays (struct loop *loop)\n {\n   struct mem_ref_group *refs;\n   unsigned ahead, ninsns, unroll_factor;\n@@ -981,7 +980,7 @@ loop_prefetch_arrays (struct loops *loops, struct loop *loop)\n      iterations so that we do not issue superfluous prefetches.  */\n   if (unroll_factor != 1)\n     {\n-      tree_unroll_loop (loops, loop, unroll_factor,\n+      tree_unroll_loop (loop, unroll_factor,\n \t\t\tsingle_dom_exit (loop), &desc);\n       unrolled = true;\n     }\n@@ -994,10 +993,10 @@ loop_prefetch_arrays (struct loops *loops, struct loop *loop)\n   return unrolled;\n }\n \n-/* Issue prefetch instructions for array references in LOOPS.  */\n+/* Issue prefetch instructions for array references in loops.  */\n \n unsigned int\n-tree_ssa_prefetch_arrays (struct loops *loops)\n+tree_ssa_prefetch_arrays (void)\n {\n   unsigned i;\n   struct loop *loop;\n@@ -1044,16 +1043,16 @@ tree_ssa_prefetch_arrays (struct loops *loops)\n      here.  */\n   gcc_assert ((PREFETCH_BLOCK & (PREFETCH_BLOCK - 1)) == 0);\n \n-  for (i = loops->num - 1; i > 0; i--)\n+  for (i = current_loops->num - 1; i > 0; i--)\n     {\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Processing loop %d:\\n\", loop->num);\n \n-      unrolled |= loop_prefetch_arrays (loops, loop);\n+      unrolled |= loop_prefetch_arrays (loop);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"\\n\\n\");"}, {"sha": "3c58e8c54b790473ec1f784f8af727bf89f3a94f", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -73,34 +73,33 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    tree-ssa-loop-im.c ensures that all the suitable conditions are in this\n    shape.  */\n \n-static struct loop *tree_unswitch_loop (struct loops *, struct loop *, basic_block,\n-\t\t\t\t   tree);\n-static bool tree_unswitch_single_loop (struct loops *, struct loop *, int);\n+static struct loop *tree_unswitch_loop (struct loop *, basic_block, tree);\n+static bool tree_unswitch_single_loop (struct loop *, int);\n static tree tree_may_unswitch_on (basic_block, struct loop *);\n \n-/* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */\n+/* Main entry point.  Perform loop unswitching on all suitable loops.  */\n \n unsigned int\n-tree_ssa_unswitch_loops (struct loops *loops)\n+tree_ssa_unswitch_loops (void)\n {\n   int i, num;\n   struct loop *loop;\n   bool changed = false;\n \n   /* Go through inner loops (only original ones).  */\n-  num = loops->num;\n+  num = current_loops->num;\n \n   for (i = 1; i < num; i++)\n     {\n       /* Removed loop?  */\n-      loop = loops->parray[i];\n+      loop = current_loops->parray[i];\n       if (!loop)\n \tcontinue;\n \n       if (loop->inner)\n \tcontinue;\n \n-      changed |= tree_unswitch_single_loop (loops, loop, 0);\n+      changed |= tree_unswitch_single_loop (loop, 0);\n     }\n \n   if (changed)\n@@ -177,7 +176,7 @@ simplify_using_entry_checks (struct loop *loop, tree cond)\n    grow exponentially.  */\n \n static bool\n-tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n+tree_unswitch_single_loop (struct loop *loop, int num)\n {\n   basic_block *bbs;\n   struct loop *nloop;\n@@ -252,7 +251,7 @@ tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n \n   initialize_original_copy_tables ();\n   /* Unswitch the loop on this condition.  */\n-  nloop = tree_unswitch_loop (loops, loop, bbs[i], cond);\n+  nloop = tree_unswitch_loop (loop, bbs[i], cond);\n   if (!nloop)\n     {\n       free_original_copy_tables ();\n@@ -265,8 +264,8 @@ tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n   free_original_copy_tables ();\n \n   /* Invoke itself on modified loops.  */\n-  tree_unswitch_single_loop (loops, nloop, num + 1);\n-  tree_unswitch_single_loop (loops, loop, num + 1);\n+  tree_unswitch_single_loop (nloop, num + 1);\n+  tree_unswitch_single_loop (loop, num + 1);\n   free (bbs);\n   return true;\n }\n@@ -277,7 +276,7 @@ tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n    if impossible, new loop otherwise.  */\n \n static struct loop *\n-tree_unswitch_loop (struct loops *loops, struct loop *loop,\n+tree_unswitch_loop (struct loop *loop,\n \t\t    basic_block unswitch_on, tree cond)\n {\n   basic_block condition_bb;\n@@ -287,6 +286,6 @@ tree_unswitch_loop (struct loops *loops, struct loop *loop,\n   gcc_assert (EDGE_COUNT (unswitch_on->succs) == 2);\n   gcc_assert (loop->inner == NULL);\n \n-  return loop_version (loops, loop, unshare_expr (cond), \n+  return loop_version (loop, unshare_expr (cond), \n \t\t       &condition_bb, false);\n }"}, {"sha": "d792902c061dbee0d1c63c14c94bc8273e48eb39", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -85,7 +85,7 @@ tree_ssa_loop_init (void)\n   if (!current_loops)\n     return 0;\n \n-  scev_initialize (current_loops);\n+  scev_initialize ();\n   return 0;\n }\n   \n@@ -114,7 +114,7 @@ tree_ssa_loop_im (void)\n   if (!current_loops)\n     return 0;\n \n-  tree_ssa_lim (current_loops);\n+  tree_ssa_lim ();\n   return 0;\n }\n \n@@ -149,7 +149,7 @@ tree_ssa_loop_unswitch (void)\n   if (!current_loops)\n     return 0;\n \n-  return tree_ssa_unswitch_loops (current_loops);\n+  return tree_ssa_unswitch_loops ();\n }\n \n static bool\n@@ -180,7 +180,7 @@ struct tree_opt_pass pass_tree_unswitch =\n static unsigned int\n tree_vectorize (void)\n {\n-  return vectorize_loops (current_loops);\n+  return vectorize_loops ();\n }\n \n static bool\n@@ -214,7 +214,7 @@ tree_linear_transform (void)\n   if (!current_loops)\n     return 0;\n \n-  linear_transform_loops (current_loops);\n+  linear_transform_loops ();\n   return 0;\n }\n \n@@ -249,7 +249,7 @@ tree_ssa_loop_ivcanon (void)\n   if (!current_loops)\n     return 0;\n \n-  return canonicalize_induction_variables (current_loops);\n+  return canonicalize_induction_variables ();\n }\n \n static bool\n@@ -310,7 +310,7 @@ tree_ssa_empty_loop (void)\n   if (!current_loops)\n     return 0;\n \n-  return remove_empty_loops (current_loops);\n+  return remove_empty_loops ();\n }\n \n struct tree_opt_pass pass_empty_loop =\n@@ -338,7 +338,7 @@ tree_ssa_loop_bounds (void)\n   if (!current_loops)\n     return 0;\n \n-  estimate_numbers_of_iterations (current_loops);\n+  estimate_numbers_of_iterations ();\n   scev_reset ();\n   return 0;\n }\n@@ -368,10 +368,9 @@ tree_complete_unroll (void)\n   if (!current_loops)\n     return 0;\n \n-  return tree_unroll_loops_completely (current_loops,\n-\t\t\t\t       flag_unroll_loops\n-\t\t\t\t\t|| flag_peel_loops\n-\t\t\t\t\t|| optimize >= 3);\n+  return tree_unroll_loops_completely (flag_unroll_loops\n+\t\t\t\t       || flag_peel_loops\n+\t\t\t\t       || optimize >= 3);\n }\n \n static bool\n@@ -405,7 +404,7 @@ tree_ssa_loop_prefetch (void)\n   if (!current_loops)\n     return 0;\n \n-  return tree_ssa_prefetch_arrays (current_loops);\n+  return tree_ssa_prefetch_arrays ();\n }\n \n static bool\n@@ -439,7 +438,7 @@ tree_ssa_loop_ivopts (void)\n   if (!current_loops)\n     return 0;\n \n-  tree_ssa_iv_optimize (current_loops);\n+  tree_ssa_iv_optimize ();\n   return 0;\n }\n \n@@ -476,7 +475,7 @@ tree_ssa_loop_done (void)\n   if (!current_loops)\n     return 0;\n \n-  free_numbers_of_iterations_estimates (current_loops);\n+  free_numbers_of_iterations_estimates ();\n   scev_finalize ();\n   loop_optimizer_finalize ();\n   return 0;"}, {"sha": "5898a47797bc7214e6603cfc2c29b842f10606cd", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -70,9 +70,6 @@ static void vect_update_ivs_after_vectorizer (loop_vec_info, tree, edge);\n static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n static void vect_update_init_of_dr (struct data_reference *, tree niters);\n static void vect_update_inits_of_drs (loop_vec_info, tree);\n-static void vect_do_peeling_for_alignment (loop_vec_info, struct loops *);\n-static void vect_do_peeling_for_loop_bound \n-  (loop_vec_info, tree *, struct loops *);\n static int vect_min_worthwhile_factor (enum tree_code);\n \n \n@@ -4070,8 +4067,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n    NITERS / VECTORIZATION_FACTOR times (this value is placed into RATIO).  */\n \n static void \n-vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n-\t\t\t\tstruct loops *loops)\n+vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n {\n   tree ni_name, ratio_mult_vf_name;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -4094,7 +4090,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \t\t\t\t   &ratio_mult_vf_name, ratio);\n \n   loop_num  = loop->num; \n-  new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, single_exit (loop),\n+  new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n \t\t\t\t\t    ratio_mult_vf_name, ni_name, false);\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n@@ -4302,7 +4298,7 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n    peeling is recorded in LOOP_VINFO_UNALIGNED_DR.  */\n \n static void\n-vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n+vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree niters_of_prolog_loop, ni_name;\n@@ -4319,7 +4315,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   \n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n   new_loop = \n-\tslpeel_tree_peel_loop_to_edge (loop, loops, loop_preheader_edge (loop), \n+\tslpeel_tree_peel_loop_to_edge (loop, loop_preheader_edge (loop), \n \t\t\t\t       niters_of_prolog_loop, ni_name, true); \n   gcc_assert (new_loop);\n #ifdef ENABLE_CHECKING\n@@ -4470,8 +4466,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n    stmts in the loop, and update the loop exit condition.  */\n \n void\n-vect_transform_loop (loop_vec_info loop_vinfo, \n-\t\t     struct loops *loops ATTRIBUTE_UNUSED)\n+vect_transform_loop (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n@@ -4508,7 +4503,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n       cond_expr = vect_create_cond_for_align_checks (loop_vinfo,\n                                                      &cond_expr_stmt_list);\n       initialize_original_copy_tables ();\n-      nloop = loop_version (loops, loop, cond_expr, &condition_bb, true);\n+      nloop = loop_version (loop, cond_expr, &condition_bb, true);\n       free_original_copy_tables();\n \n       /** Loop versioning violates an assumption we try to maintain during \n@@ -4550,7 +4545,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n      Only one data ref with unknown store is allowed.  */\n \n   if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n-    vect_do_peeling_for_alignment (loop_vinfo, loops);\n+    vect_do_peeling_for_alignment (loop_vinfo);\n   \n   /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a\n      compile time constant), or it is a constant that doesn't divide by the\n@@ -4563,7 +4558,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n           && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0))\n-    vect_do_peeling_for_loop_bound (loop_vinfo, &ratio, loops);\n+    vect_do_peeling_for_loop_bound (loop_vinfo, &ratio);\n   else\n     ratio = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n \t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);"}, {"sha": "ed37d5f040be3342131040b2789190829d82fac3", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -150,8 +150,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /*************************************************************************\n   Simple Loop Peeling Utilities\n  *************************************************************************/\n-static struct loop *slpeel_tree_duplicate_loop_to_edge_cfg \n-  (struct loop *, struct loops *, edge);\n static void slpeel_update_phis_for_duplicate_loop \n   (struct loop *, struct loop *, bool after);\n static void slpeel_update_phi_nodes_for_guard1 \n@@ -823,8 +821,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n    on E which is either the entry or exit of LOOP.  */\n \n static struct loop *\n-slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops, \n-\t\t\t\t\tedge e)\n+slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n {\n   struct loop *new_loop;\n   basic_block *new_bbs, *bbs;\n@@ -848,7 +845,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n     }\n \n   /* Generate new loop structure.  */\n-  new_loop = duplicate_loop (loops, loop, loop->outer);\n+  new_loop = duplicate_loop (loop, loop->outer);\n   if (!new_loop)\n     {\n       free (bbs);\n@@ -1067,7 +1064,7 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n */\n \n struct loop*\n-slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops, \n+slpeel_tree_peel_loop_to_edge (struct loop *loop, \n \t\t\t       edge e, tree first_niters, \n \t\t\t       tree niters, bool update_first_loop_count)\n {\n@@ -1106,7 +1103,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n         orig_exit_bb:\n    */\n   \n-  if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, loops, e)))\n+  if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, e)))\n     {\n       loop_loc = find_loop_location (loop);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2156,7 +2153,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n    Entry Point to loop vectorization phase.  */\n \n unsigned\n-vectorize_loops (struct loops *loops)\n+vectorize_loops (void)\n {\n   unsigned int i;\n   unsigned int num_vectorized_loops = 0;\n@@ -2173,11 +2170,11 @@ vectorize_loops (struct loops *loops)\n   /* If some loop was duplicated, it gets bigger number \n      than all previously defined loops. This fact allows us to run \n      only over initial loops skipping newly generated ones.  */\n-  vect_loops_num = loops->num;\n+  vect_loops_num = current_loops->num;\n   for (i = 1; i < vect_loops_num; i++)\n     {\n       loop_vec_info loop_vinfo;\n-      struct loop *loop = loops->parray[i];\n+      struct loop *loop = current_loops->parray[i];\n \n       if (!loop)\n         continue;\n@@ -2189,7 +2186,7 @@ vectorize_loops (struct loops *loops)\n       if (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n \tcontinue;\n \n-      vect_transform_loop (loop_vinfo, loops);\n+      vect_transform_loop (loop_vinfo);\n       num_vectorized_loops++;\n     }\n   vect_loop_location = UNKNOWN_LOC;\n@@ -2204,7 +2201,7 @@ vectorize_loops (struct loops *loops)\n \n   for (i = 1; i < vect_loops_num; i++)\n     {\n-      struct loop *loop = loops->parray[i];\n+      struct loop *loop = current_loops->parray[i];\n       loop_vec_info loop_vinfo;\n \n       if (!loop)"}, {"sha": "d60a494d00462b1377d9f3ac59315b42b4d38882", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -347,7 +347,7 @@ extern bitmap vect_vnames_to_rename;\n    divide by the vectorization factor, and to peel the first few iterations\n    to force the alignment of data references in the loop.  */\n extern struct loop *slpeel_tree_peel_loop_to_edge \n-  (struct loop *, struct loops *, edge, tree, tree, bool);\n+  (struct loop *, edge, tree, tree, bool);\n extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (struct loop *, edge);\n #ifdef ENABLE_CHECKING\n@@ -401,7 +401,7 @@ extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_reduction (tree, block_stmt_iterator *, tree *);\n /* Driver for transformation stage.  */\n-extern void vect_transform_loop (loop_vec_info, struct loops *);\n+extern void vect_transform_loop (loop_vec_info);\n \n /*************************************************************************\n   Vectorization Debug Information - in tree-vectorizer.c"}, {"sha": "68c5435709c4f90301350e170a6bf7367dcc3c7b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73be2683d8be63e92ade52ba9613e3c7382c809/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d73be2683d8be63e92ade52ba9613e3c7382c809", "patch": "@@ -4774,7 +4774,7 @@ execute_vrp (void)\n \n   loop_optimizer_init (LOOPS_NORMAL);\n   if (current_loops)\n-    scev_initialize (current_loops);\n+    scev_initialize ();\n \n   vrp_initialize ();\n   ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);"}]}