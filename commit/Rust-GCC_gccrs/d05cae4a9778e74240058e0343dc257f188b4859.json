{"sha": "d05cae4a9778e74240058e0343dc257f188b4859", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA1Y2FlNGE5Nzc4ZTc0MjQwMDU4ZTAzNDNkYzI1N2YxODhiNDg1OQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-06-13T21:43:19Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-06-13T21:43:19Z"}, "message": "re PR debug/47624 (FAIL: gcc.dg/guality/pr43077-1.c  -O1  line 42 c == 3)\n\nPR debug/47624\n* var-tracking.c (loc_exp_dep_pool): New.\n(vt_emit_notes): Create and release the pool.\n(compute_bb_dataflow): Use value-based locations in MO_VAL_SET.\n(emit_notes_in_bb): Likewise.\n(loc_exp_dep_insert): Deal with NOT_ONEPART vars.\n(notify_dependents_of_changed_value): Likewise.\n(notify_dependents_of_resolved_value): Check that NOT_ONEPART\nvariables don't have a VAR_LOC_DEP_LST.\n(emit_note_insn_var_location): Expand NOT_ONEPART locs that are\nVALUEs or MEMs of VALUEs.\n\nFrom-SVN: r188530", "tree": {"sha": "a5eb2f0c811e8ed1770d3e4ad0ab4986ea26026b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5eb2f0c811e8ed1770d3e4ad0ab4986ea26026b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d05cae4a9778e74240058e0343dc257f188b4859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05cae4a9778e74240058e0343dc257f188b4859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05cae4a9778e74240058e0343dc257f188b4859", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05cae4a9778e74240058e0343dc257f188b4859/comments", "author": null, "committer": null, "parents": [{"sha": "29970a8ab107cbc650f6179fdee60c89d15c8fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29970a8ab107cbc650f6179fdee60c89d15c8fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29970a8ab107cbc650f6179fdee60c89d15c8fd2"}], "stats": {"total": 209, "additions": 157, "deletions": 52}, "files": [{"sha": "d07a9008f176eb7118a33a666c44fb427377f8c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05cae4a9778e74240058e0343dc257f188b4859/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05cae4a9778e74240058e0343dc257f188b4859/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d05cae4a9778e74240058e0343dc257f188b4859", "patch": "@@ -1,3 +1,17 @@\n+2012-06-13  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/47624\n+\t* var-tracking.c (loc_exp_dep_pool): New.\n+\t(vt_emit_notes): Create and release the pool.\n+\t(compute_bb_dataflow): Use value-based locations in MO_VAL_SET.\n+\t(emit_notes_in_bb): Likewise.\n+\t(loc_exp_dep_insert): Deal with NOT_ONEPART vars.\n+\t(notify_dependents_of_changed_value): Likewise.\n+\t(notify_dependents_of_resolved_value): Check that NOT_ONEPART\n+\tvariables don't have a VAR_LOC_DEP_LST.\n+\t(emit_note_insn_var_location): Expand NOT_ONEPART locs that are\n+\tVALUEs or MEMs of VALUEs.\n+\n 2012-06-13  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/52983"}, {"sha": "e001df0ab4d5bbf92644da01ed3344cc5a6d3417", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 143, "deletions": 52, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05cae4a9778e74240058e0343dc257f188b4859/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05cae4a9778e74240058e0343dc257f188b4859/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d05cae4a9778e74240058e0343dc257f188b4859", "patch": "@@ -473,6 +473,9 @@ static alloc_pool loc_chain_pool;\n /* Alloc pool for struct shared_hash_def.  */\n static alloc_pool shared_hash_pool;\n \n+/* Alloc pool for struct loc_exp_dep_s for NOT_ONEPART variables.  */\n+static alloc_pool loc_exp_dep_pool;\n+\n /* Changed variables, notes will be emitted for them.  */\n static htab_t changed_variables;\n \n@@ -6273,29 +6276,41 @@ compute_bb_dataflow (basic_block bb)\n \t    {\n \t      rtx loc = mo->u.loc;\n \t      rtx val, vloc, uloc;\n+\t      rtx dstv, srcv;\n \n \t      vloc = loc;\n \t      uloc = XEXP (vloc, 1);\n \t      val = XEXP (vloc, 0);\n \t      vloc = uloc;\n \n+\t      if (GET_CODE (uloc) == SET)\n+\t\t{\n+\t\t  dstv = SET_DEST (uloc);\n+\t\t  srcv = SET_SRC (uloc);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dstv = uloc;\n+\t\t  srcv = NULL;\n+\t\t}\n+\n \t      if (GET_CODE (val) == CONCAT)\n \t\t{\n-\t\t  vloc = XEXP (val, 1);\n+\t\t  dstv = vloc = XEXP (val, 1);\n \t\t  val = XEXP (val, 0);\n \t\t}\n \n \t      if (GET_CODE (vloc) == SET)\n \t\t{\n-\t\t  rtx vsrc = SET_SRC (vloc);\n+\t\t  srcv = SET_SRC (vloc);\n \n-\t\t  gcc_assert (val != vsrc);\n+\t\t  gcc_assert (val != srcv);\n \t\t  gcc_assert (vloc == uloc || VAL_NEEDS_RESOLUTION (loc));\n \n-\t\t  vloc = SET_DEST (vloc);\n+\t\t  dstv = vloc = SET_DEST (vloc);\n \n \t\t  if (VAL_NEEDS_RESOLUTION (loc))\n-\t\t    val_resolve (out, val, vsrc, insn);\n+\t\t    val_resolve (out, val, srcv, insn);\n \t\t}\n \t      else if (VAL_NEEDS_RESOLUTION (loc))\n \t\t{\n@@ -6311,45 +6326,53 @@ compute_bb_dataflow (basic_block bb)\n \t\t      if (REG_P (uloc))\n \t\t\tvar_reg_delete (out, uloc, true);\n \t\t      else if (MEM_P (uloc))\n-\t\t\tvar_mem_delete (out, uloc, true);\n+\t\t\t{\n+\t\t\t  gcc_assert (MEM_P (dstv));\n+\t\t\t  gcc_assert (MEM_ATTRS (dstv) == MEM_ATTRS (uloc));\n+\t\t\t  var_mem_delete (out, dstv, true);\n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      bool copied_p = VAL_EXPR_IS_COPIED (loc);\n-\t\t      rtx set_src = NULL;\n+\t\t      rtx src = NULL, dst = uloc;\n \t\t      enum var_init_status status = VAR_INIT_STATUS_INITIALIZED;\n \n \t\t      if (GET_CODE (uloc) == SET)\n \t\t\t{\n-\t\t\t  set_src = SET_SRC (uloc);\n-\t\t\t  uloc = SET_DEST (uloc);\n+\t\t\t  src = SET_SRC (uloc);\n+\t\t\t  dst = SET_DEST (uloc);\n \t\t\t}\n \n \t\t      if (copied_p)\n \t\t\t{\n \t\t\t  if (flag_var_tracking_uninit)\n \t\t\t    {\n-\t\t\t      status = find_src_status (in, set_src);\n+\t\t\t      status = find_src_status (in, src);\n \n \t\t\t      if (status == VAR_INIT_STATUS_UNKNOWN)\n-\t\t\t\tstatus = find_src_status (out, set_src);\n+\t\t\t\tstatus = find_src_status (out, src);\n \t\t\t    }\n \n-\t\t\t  set_src = find_src_set_src (in, set_src);\n+\t\t\t  src = find_src_set_src (in, src);\n \t\t\t}\n \n-\t\t      if (REG_P (uloc))\n-\t\t\tvar_reg_delete_and_set (out, uloc, !copied_p,\n-\t\t\t\t\t\tstatus, set_src);\n-\t\t      else if (MEM_P (uloc))\n-\t\t\tvar_mem_delete_and_set (out, uloc, !copied_p,\n-\t\t\t\t\t\tstatus, set_src);\n+\t\t      if (REG_P (dst))\n+\t\t\tvar_reg_delete_and_set (out, dst, !copied_p,\n+\t\t\t\t\t\tstatus, srcv);\n+\t\t      else if (MEM_P (dst))\n+\t\t\t{\n+\t\t\t  gcc_assert (MEM_P (dstv));\n+\t\t\t  gcc_assert (MEM_ATTRS (dstv) == MEM_ATTRS (dst));\n+\t\t\t  var_mem_delete_and_set (out, dstv, !copied_p,\n+\t\t\t\t\t\t  status, srcv);\n+\t\t\t}\n \t\t    }\n \t\t}\n \t      else if (REG_P (uloc))\n \t\tvar_regno_delete (out, REGNO (uloc));\n \n-\t      val_store (out, val, vloc, insn, true);\n+\t      val_store (out, val, dstv, insn, true);\n \t    }\n \t    break;\n \n@@ -7591,8 +7614,13 @@ loc_exp_insert_dep (variable var, rtx x, htab_t vars)\n   if (VAR_LOC_DEP_LST (xvar) && VAR_LOC_DEP_LST (xvar)->dv == var->dv)\n     return;\n \n-  VEC_quick_push (loc_exp_dep, VAR_LOC_DEP_VEC (var), NULL);\n-  led = VEC_last (loc_exp_dep, VAR_LOC_DEP_VEC (var));\n+  if (var->onepart == NOT_ONEPART)\n+    led = (loc_exp_dep *) pool_alloc (loc_exp_dep_pool);\n+  else\n+    {\n+      VEC_quick_push (loc_exp_dep, VAR_LOC_DEP_VEC (var), NULL);\n+      led = VEC_last (loc_exp_dep, VAR_LOC_DEP_VEC (var));\n+    }\n   led->dv = var->dv;\n   led->value = x;\n \n@@ -7668,8 +7696,12 @@ notify_dependents_of_resolved_value (variable ivar, htab_t vars)\n \n \t  gcc_checking_assert (dv_changed_p (dv));\n \t}\n-      else if (!dv_changed_p (dv))\n-\tcontinue;\n+      else\n+\t{\n+\t  gcc_checking_assert (dv_onepart_p (dv) != NOT_ONEPART);\n+\t  if (!dv_changed_p (dv))\n+\t    continue;\n+      }\n \n       var = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n \n@@ -8124,19 +8156,30 @@ emit_note_insn_var_location (void **varp, void *data)\n \t  else if (last_limit > VAR_PART_OFFSET (var, i))\n \t    continue;\n \t  offset = VAR_PART_OFFSET (var, i);\n-\t  if (!var->var_part[i].cur_loc)\n+\t  loc2 = var->var_part[i].cur_loc;\n+\t  if (loc2 && GET_CODE (loc2) == MEM\n+\t      && GET_CODE (XEXP (loc2, 0)) == VALUE)\n+\t    {\n+\t      rtx depval = XEXP (loc2, 0);\n+\n+\t      loc2 = vt_expand_loc (loc2, vars);\n+\n+\t      if (loc2)\n+\t\tloc_exp_insert_dep (var, depval, vars);\n+\t    }\n+\t  if (!loc2)\n \t    {\n \t      complete = false;\n \t      continue;\n \t    }\n+\t  gcc_checking_assert (GET_CODE (loc2) != VALUE);\n \t  for (lc = var->var_part[i].loc_chain; lc; lc = lc->next)\n \t    if (var->var_part[i].cur_loc == lc->loc)\n \t      {\n \t\tinitialized = lc->init;\n \t\tbreak;\n \t      }\n \t  gcc_assert (lc);\n-\t  loc2 = var->var_part[i].cur_loc;\n \t}\n \n       offsets[n_var_parts] = offset;\n@@ -8350,7 +8393,6 @@ notify_dependents_of_changed_value (rtx val, htab_t htab,\n   while ((led = VAR_LOC_DEP_LST (var)))\n     {\n       decl_or_value ldv = led->dv;\n-      void **islot;\n       variable ivar;\n \n       /* Deactivate and remove the backlink, as it was \u201cused up\u201d.  It\n@@ -8375,13 +8417,34 @@ notify_dependents_of_changed_value (rtx val, htab_t htab,\n \t  VEC_safe_push (rtx, stack, *changed_values_stack, dv_as_rtx (ldv));\n \t  break;\n \n-\tdefault:\n-\t  islot = htab_find_slot_with_hash (htab, ldv, dv_htab_hash (ldv),\n-\t\t\t\t\t    NO_INSERT);\n-\t  ivar = (variable) *islot;\n+\tcase ONEPART_VDECL:\n+\t  ivar = (variable) htab_find_with_hash (htab, ldv, dv_htab_hash (ldv));\n \t  gcc_checking_assert (!VAR_LOC_DEP_LST (ivar));\n \t  variable_was_changed (ivar, NULL);\n \t  break;\n+\n+\tcase NOT_ONEPART:\n+\t  pool_free (loc_exp_dep_pool, led);\n+\t  ivar = (variable) htab_find_with_hash (htab, ldv, dv_htab_hash (ldv));\n+\t  if (ivar)\n+\t    {\n+\t      int i = ivar->n_var_parts;\n+\t      while (i--)\n+\t\t{\n+\t\t  rtx loc = ivar->var_part[i].cur_loc;\n+\n+\t\t  if (loc && GET_CODE (loc) == MEM\n+\t\t      && XEXP (loc, 0) == val)\n+\t\t    {\n+\t\t      variable_was_changed (ivar, NULL);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -8718,29 +8781,41 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t    {\n \t      rtx loc = mo->u.loc;\n \t      rtx val, vloc, uloc;\n+\t      rtx dstv, srcv;\n \n \t      vloc = loc;\n \t      uloc = XEXP (vloc, 1);\n \t      val = XEXP (vloc, 0);\n \t      vloc = uloc;\n \n+\t      if (GET_CODE (uloc) == SET)\n+\t\t{\n+\t\t  dstv = SET_DEST (uloc);\n+\t\t  srcv = SET_SRC (uloc);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dstv = uloc;\n+\t\t  srcv = NULL;\n+\t\t}\n+\n \t      if (GET_CODE (val) == CONCAT)\n \t\t{\n-\t\t  vloc = XEXP (val, 1);\n+\t\t  dstv = vloc = XEXP (val, 1);\n \t\t  val = XEXP (val, 0);\n \t\t}\n \n \t      if (GET_CODE (vloc) == SET)\n \t\t{\n-\t\t  rtx vsrc = SET_SRC (vloc);\n+\t\t  srcv = SET_SRC (vloc);\n \n-\t\t  gcc_assert (val != vsrc);\n+\t\t  gcc_assert (val != srcv);\n \t\t  gcc_assert (vloc == uloc || VAL_NEEDS_RESOLUTION (loc));\n \n-\t\t  vloc = SET_DEST (vloc);\n+\t\t  dstv = vloc = SET_DEST (vloc);\n \n \t\t  if (VAL_NEEDS_RESOLUTION (loc))\n-\t\t    val_resolve (set, val, vsrc, insn);\n+\t\t    val_resolve (set, val, srcv, insn);\n \t\t}\n \t      else if (VAL_NEEDS_RESOLUTION (loc))\n \t\t{\n@@ -8756,39 +8831,47 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t\t      if (REG_P (uloc))\n \t\t\tvar_reg_delete (set, uloc, true);\n \t\t      else if (MEM_P (uloc))\n-\t\t\tvar_mem_delete (set, uloc, true);\n+\t\t\t{\n+\t\t\t  gcc_assert (MEM_P (dstv));\n+\t\t\t  gcc_assert (MEM_ATTRS (dstv) == MEM_ATTRS (uloc));\n+\t\t\t  var_mem_delete (set, dstv, true);\n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      bool copied_p = VAL_EXPR_IS_COPIED (loc);\n-\t\t      rtx set_src = NULL;\n+\t\t      rtx src = NULL, dst = uloc;\n \t\t      enum var_init_status status = VAR_INIT_STATUS_INITIALIZED;\n \n \t\t      if (GET_CODE (uloc) == SET)\n \t\t\t{\n-\t\t\t  set_src = SET_SRC (uloc);\n-\t\t\t  uloc = SET_DEST (uloc);\n+\t\t\t  src = SET_SRC (uloc);\n+\t\t\t  dst = SET_DEST (uloc);\n \t\t\t}\n \n \t\t      if (copied_p)\n \t\t\t{\n-\t\t\t  status = find_src_status (set, set_src);\n+\t\t\t  status = find_src_status (set, src);\n \n-\t\t\t  set_src = find_src_set_src (set, set_src);\n+\t\t\t  src = find_src_set_src (set, src);\n \t\t\t}\n \n-\t\t      if (REG_P (uloc))\n-\t\t\tvar_reg_delete_and_set (set, uloc, !copied_p,\n-\t\t\t\t\t\tstatus, set_src);\n-\t\t      else if (MEM_P (uloc))\n-\t\t\tvar_mem_delete_and_set (set, uloc, !copied_p,\n-\t\t\t\t\t\tstatus, set_src);\n+\t\t      if (REG_P (dst))\n+\t\t\tvar_reg_delete_and_set (set, dst, !copied_p,\n+\t\t\t\t\t\tstatus, srcv);\n+\t\t      else if (MEM_P (dst))\n+\t\t\t{\n+\t\t\t  gcc_assert (MEM_P (dstv));\n+\t\t\t  gcc_assert (MEM_ATTRS (dstv) == MEM_ATTRS (dst));\n+\t\t\t  var_mem_delete_and_set (set, dstv, !copied_p,\n+\t\t\t\t\t\t  status, srcv);\n+\t\t\t}\n \t\t    }\n \t\t}\n \t      else if (REG_P (uloc))\n \t\tvar_regno_delete (set, REGNO (uloc));\n \n-\t      val_store (set, val, vloc, insn, true);\n+\t      val_store (set, val, dstv, insn, true);\n \n \t      emit_notes_for_changes (next_insn, EMIT_NOTE_BEFORE_INSN,\n \t\t\t\t      set->vars);\n@@ -8897,9 +8980,13 @@ vt_emit_notes (void)\n   emit_notes = true;\n \n   if (MAY_HAVE_DEBUG_INSNS)\n-    dropped_values = htab_create (cselib_get_next_uid () * 2,\n-\t\t\t\t  variable_htab_hash, variable_htab_eq,\n-\t\t\t\t  variable_htab_free);\n+    {\n+      dropped_values = htab_create (cselib_get_next_uid () * 2,\n+\t\t\t\t    variable_htab_hash, variable_htab_eq,\n+\t\t\t\t    variable_htab_free);\n+      loc_exp_dep_pool = create_alloc_pool (\"loc_exp_dep pool\",\n+\t\t\t\t\t    sizeof (loc_exp_dep), 64);\n+    }\n \n   dataflow_set_init (&cur);\n \n@@ -8924,7 +9011,11 @@ vt_emit_notes (void)\n   dataflow_set_destroy (&cur);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n-    htab_delete (dropped_values);\n+    {\n+      free_alloc_pool (loc_exp_dep_pool);\n+      loc_exp_dep_pool = NULL;\n+      htab_delete (dropped_values);\n+    }\n \n   emit_notes = false;\n }"}]}