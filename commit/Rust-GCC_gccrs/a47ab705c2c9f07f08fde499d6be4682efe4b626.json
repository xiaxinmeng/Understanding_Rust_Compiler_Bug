{"sha": "a47ab705c2c9f07f08fde499d6be4682efe4b626", "node_id": "C_kwDOANBUbNoAKGE0N2FiNzA1YzJjOWYwN2YwOGZkZTQ5OWQ2YmU0NjgyZWZlNGI2MjY", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-26T22:32:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-05-04T21:59:51Z"}, "message": "c++: alias CTAD refactoring [PR104470]\n\nIn my previous PR104470 patch I added yet another place that needs to handle\ndependent member rewriting for deduction guides; this patches centralizes\nrewriting into maybe_dependent_member_ref.  tsubst_baselink still has its\nown handling because that's simpler than teaching maybe_dependent_member_ref\nabout BASELINKs.\n\n\tPR c++/104470\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (maybe_dependent_member_ref): Handle types.\n\t(tsubst, tsubst_copy): Use it.\n\t(tsubst_aggr_type, instantiate_alias_template): Don't handle\n\ttf_dguide here.", "tree": {"sha": "0ef026e9f7f65fc5da04e8a9e41efa3604083ac6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ef026e9f7f65fc5da04e8a9e41efa3604083ac6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a47ab705c2c9f07f08fde499d6be4682efe4b626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47ab705c2c9f07f08fde499d6be4682efe4b626", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a47ab705c2c9f07f08fde499d6be4682efe4b626", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47ab705c2c9f07f08fde499d6be4682efe4b626/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a98e3ff7e80bf2936f163d50309fd88d72564a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a98e3ff7e80bf2936f163d50309fd88d72564a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a98e3ff7e80bf2936f163d50309fd88d72564a0"}], "stats": {"total": 104, "additions": 54, "deletions": 50}, "files": [{"sha": "fe2608c65f1c4ebaed640131a9bb25dc275101a0", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47ab705c2c9f07f08fde499d6be4682efe4b626/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47ab705c2c9f07f08fde499d6be4682efe4b626/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=a47ab705c2c9f07f08fde499d6be4682efe4b626", "patch": "@@ -220,6 +220,7 @@ static tree make_argument_pack (tree);\n static void register_parameter_specializations (tree, tree);\n static tree enclosing_instantiation_of (tree tctx);\n static void instantiate_body (tree pattern, tree args, tree d, bool nested);\n+static tree maybe_dependent_member_ref (tree, tree, tsubst_flags_t, tree);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -13725,18 +13726,6 @@ tsubst_aggr_type (tree t,\n \t\t\t\t\t complain, in_decl);\n \t  if (argvec == error_mark_node)\n \t    r = error_mark_node;\n-\t  else if (!entering_scope && (complain & tf_dguide)\n-\t\t   && dependent_scope_p (context))\n-\t    {\n-\t      /* See maybe_dependent_member_ref.  */\n-\t      tree name = TYPE_IDENTIFIER (t);\n-\t      tree fullname = name;\n-\t      if (instantiates_primary_template_p (t))\n-\t\tfullname = build_nt (TEMPLATE_ID_EXPR, name,\n-\t\t\t\t     INNERMOST_TEMPLATE_ARGS (argvec));\n-\t      return build_typename_type (context, name, fullname,\n-\t\t\t\t\t  typename_type);\n-\t    }\n \t  else\n \t    {\n \t      r = lookup_template_class (t, argvec, in_decl, context,\n@@ -15586,6 +15575,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n   gcc_assert (type != unknown_type_node);\n \n+  if (tree d = maybe_dependent_member_ref (t, args, complain, in_decl))\n+    return d;\n+\n   /* Reuse typedefs.  We need to do this to handle dependent attributes,\n      such as attribute aligned.  */\n   if (TYPE_P (t)\n@@ -16815,16 +16807,58 @@ maybe_dependent_member_ref (tree t, tree args, tsubst_flags_t complain,\n   if (!(complain & tf_dguide))\n     return NULL_TREE;\n \n-  tree ctx = context_for_name_lookup (t);\n+  tree decl = (t && TYPE_P (t)) ? TYPE_NAME (t) : t;\n+  if (!decl || !DECL_P (decl))\n+    return NULL_TREE;\n+\n+  tree ctx = context_for_name_lookup (decl);\n   if (!CLASS_TYPE_P (ctx))\n     return NULL_TREE;\n \n   ctx = tsubst (ctx, args, complain, in_decl);\n-  if (dependent_scope_p (ctx))\n-    return build_qualified_name (NULL_TREE, ctx, DECL_NAME (t),\n-\t\t\t\t /*template_p=*/false);\n+  if (!dependent_scope_p (ctx))\n+    return NULL_TREE;\n \n-  return NULL_TREE;\n+  if (TYPE_P (t))\n+    {\n+      if (typedef_variant_p (t))\n+\tt = strip_typedefs (t);\n+      tree decl = TYPE_NAME (t);\n+      if (decl)\n+\tdecl = maybe_dependent_member_ref (decl, args, complain, in_decl);\n+      if (!decl)\n+\treturn NULL_TREE;\n+      return cp_build_qualified_type_real (TREE_TYPE (decl), cp_type_quals (t),\n+\t\t\t\t\t   complain);\n+    }\n+\n+  tree name = DECL_NAME (t);\n+  tree fullname = name;\n+  if (instantiates_primary_template_p (t))\n+    {\n+      tree tinfo = get_template_info (t);\n+      name = DECL_NAME (TI_TEMPLATE (tinfo));\n+      tree targs = INNERMOST_TEMPLATE_ARGS (TI_ARGS (tinfo));\n+      targs = tsubst_template_args (targs, args, complain, in_decl);\n+      fullname = build_nt (TEMPLATE_ID_EXPR, name, targs);\n+    }\n+\n+  if (TREE_CODE (t) == TYPE_DECL)\n+    {\n+      if (TREE_CODE (TREE_TYPE (t)) == TYPENAME_TYPE\n+\t  && TYPE_NAME (TREE_TYPE (t)) == t)\n+\t/* The TYPE_DECL for a typename has DECL_CONTEXT of the typename\n+\t   scope, but it doesn't need to be rewritten again.  */\n+\treturn NULL_TREE;\n+      tree type = build_typename_type (ctx, name, fullname, typename_type);\n+      return TYPE_NAME (type);\n+    }\n+  else if (DECL_TYPE_TEMPLATE_P (t))\n+    return make_unbound_class_template (ctx, name,\n+\t\t\t\t\tNULL_TREE, complain);\n+  else\n+    return build_qualified_name (NULL_TREE, ctx, fullname,\n+\t\t\t\t TREE_CODE (t) == TEMPLATE_DECL);\n }\n \n /* Like tsubst, but deals with expressions.  This function just replaces\n@@ -16840,6 +16874,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   if (t == NULL_TREE || t == error_mark_node || args == NULL_TREE)\n     return t;\n \n+  if (tree d = maybe_dependent_member_ref (t, args, complain, in_decl))\n+    return d;\n+\n   code = TREE_CODE (t);\n \n   switch (code)\n@@ -16885,9 +16922,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (args == NULL_TREE)\n \t  return scalar_constant_value (t);\n \n-\tif (tree ref = maybe_dependent_member_ref (t, args, complain, in_decl))\n-\t  return ref;\n-\n \t/* Unfortunately, we cannot just call lookup_name here.\n \t   Consider:\n \n@@ -16938,9 +16972,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       return t;\n \n     case VAR_DECL:\n-      if (tree ref = maybe_dependent_member_ref (t, args, complain, in_decl))\n-\treturn ref;\n-      gcc_fallthrough();\n     case FUNCTION_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n \tr = tsubst (t, args, complain, in_decl);\n@@ -17070,18 +17101,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t     have to substitute this with one having context `D<int>'.  */\n \n \t  tree context = tsubst (DECL_CONTEXT (t), args, complain, in_decl);\n-\t  if ((complain & tf_dguide) && dependent_scope_p (context))\n-\t    {\n-\t      /* When rewriting a constructor into a deduction guide, a\n-\t\t non-dependent name can become dependent, so memtmpl<args>\n-\t\t becomes context::template memtmpl<args>.  */\n-\t      if (DECL_TYPE_TEMPLATE_P (t))\n-\t\treturn make_unbound_class_template (context, DECL_NAME (t),\n-\t\t\t\t\t\t    NULL_TREE, complain);\n-\t      tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\t      return build_qualified_name (type, context, DECL_NAME (t),\n-\t\t\t\t\t   /*template*/true);\n-\t    }\n \t  return lookup_field (context, DECL_NAME(t), 0, false);\n \t}\n       else\n@@ -21711,21 +21730,6 @@ instantiate_alias_template (tree tmpl, tree args, tsubst_flags_t complain)\n   if (tmpl == error_mark_node || args == error_mark_node)\n     return error_mark_node;\n \n-  /* See maybe_dependent_member_ref.  */\n-  if (complain & tf_dguide)\n-    {\n-      tree ctx = tsubst_aggr_type (DECL_CONTEXT (tmpl), args, complain,\n-\t\t\t\t   tmpl, true);\n-      if (dependent_scope_p (ctx))\n-\t{\n-\t  tree name = DECL_NAME (tmpl);\n-\t  tree fullname = build_nt (TEMPLATE_ID_EXPR, name,\n-\t\t\t\t    INNERMOST_TEMPLATE_ARGS (args));\n-\t  tree tname = build_typename_type (ctx, name, fullname, typename_type);\n-\t  return TYPE_NAME (tname);\n-\t}\n-    }\n-\n   args =\n     coerce_innermost_template_parms (DECL_TEMPLATE_PARMS (tmpl),\n \t\t\t\t     args, tmpl, complain,"}]}