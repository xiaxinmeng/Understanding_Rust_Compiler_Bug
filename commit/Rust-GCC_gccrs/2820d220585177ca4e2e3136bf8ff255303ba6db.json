{"sha": "2820d220585177ca4e2e3136bf8ff255303ba6db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgyMGQyMjA1ODUxNzdjYTRlMmUzMTM2YmY4ZmYyNTUzMDNiYTZkYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-29T12:03:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-29T12:03:27Z"}, "message": "[multiple changes]\n\n2004-03-29  Javier Miranda  <miranda@gnat.com>\n\n\t* checks.adb (Null_Exclusion_Static_Checks): New subprogram\n\t(Install_Null_Excluding_Check): Local subprogram that determines whether\n\tan access node requires a runtime access check and if so inserts the\n\tappropriate run-time check.\n\t(Apply_Access_Check): Call Install_Null_Excluding check if required\n\t(Apply_Constraint_Check): Call Install_Null_Excluding check if required\n\n\t* checks.ads: (Null_Exclusion_Static_Checks): New subprogram\n\n\t* einfo.ads: Fix typo in comment\n\n\t* exp_ch3.adb (Build_Assignment): Generate conversion to the\n\tnull-excluding type to force the corresponding run-time check.\n\t(Expand_N_Object_Declaration): Generate conversion to the null-excluding\n\ttype to force the corresponding run-time check.\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Generate conversion to\n\tthe null-excluding type to force the corresponding run-time check.\n\n\t* exp_ch6.adb (Expand_Call): Do not generate the run-time check in\n\tcase of access types unless they have the null-excluding attribute.\n\n\t* sprint.adb (Sprint_Node_Actual): Give support to the null-exclusing\n\tpart.\n\n\t* exp_util.ads: Fix typo in comment\n\n\t* par.adb (P_Null_Exclusion): New subprogram\n\t(P_Subtype_Indication): New formal that indicates if the null-excluding\n\tpart has been scanned-out and it was present\n\n\t* par-ch3.adb, par-ch4.adb, par-ch6.adb: Give support to AI-231\n\n\t* sem_aggr.adb: (Check_Can_Never_Be_Null): New subprogram\n\t(Aggregate_Constraint_Checks): Generate conversion to the null-excluding\n\ttype to force the corresponding run-time check\n\t(Resolve_Aggregate): Propagate the null-excluding attribute to the array\n\tcomponents\n\t(Resolve_Array_Aggregate): Carry out some static checks\n\t(Resolve_Record_Aggregate.Get_Value): Carry out some static check\n\n\t* sem_ch3.adb (Access_Definition): In Ada 0Y the Can_Never_Be_Null\n\tattribute must be set only if specified by means of the null-excluding\n\tpart. In addition, we must also propagate the access-constant attribute\n\tif present.\n\t(Access_Subprogram_Declaration, Access_Type_Declaration,\n\tAnalyze_Component_Declaration, Analyze_Object_Declaration,\n\tArray_Type_Declaration, Process_Discriminants,\n\tAnalyze_Subtype_Declaration): Propagate the null-excluding attribute\n\tand carry out some static checks.\n\t(Build_Derived_Access_Type): Set the null-excluding attribute\n\t(Derived_Type_Declaration, Process_Subtype): Carry out some static\n\tchecks.\n\n\t* sem_ch4.adb (Analyze_Allocator): Carry out some static checks\n\n\t* sem_ch5.adb (Analyze_Assignment): Carry out some static checks\n\n\t* sem_ch6.adb (Process_Formals): Carry out some static checks.\n\t(Set_Actual_Subtypes): Generate null-excluding subtype if the\n\tnull-excluding part was present; it is not required to be done here in\n\tcase of anonymous access types.\n\t(Set_Formal_Mode): Ada 0Y allows anonymous access to have the null\n\tvalue.\n\n\t* sem_res.adb (Resolve_Actuals): Carry out some static check\n\t(Resolve_Null): Allow null in anonymous access\n\n\t* sinfo.adb: New subprogram Null_Exclusion_Present\n\tAll_Present and Constant_Present available on access_definition nodes\n\n\t* sinfo.ads: New flag Null_Exclusion_Present on subtype_declaration,\n\tobject_declaration, derived_type_definition, component_definition,\n\tdiscriminant_specification, access_to_object_definition,\n\taccess_function_definition, allocator, access_procedure_definition,\n\taccess_definition, parameter_specification, All_Present and\n\tConstant_Present flags available on access_definition nodes.\n\n2004-03-29  Robert Dewar  <dewar@gnat.com>\n\n\t* fname.adb, fname.ads, fname-sf.adb, fname-uf.adb, fname-uf.ads,\n\tgnat1drv.adb, lib.adb, lib.ads, lib-load.adb, lib-writ.adb,\n\topt.ads, osint.adb, osint.ads, osint-c.adb, par.adb,\n\tpar-ch10.adb, par-load.adb, par-prag.adb, sfn_scan.adb,\n\tsfn_scan.ads, sinput-l.adb, sinput-l.ads, switch-c.adb,\n\tsem_prag.adb: Updates to handle multiple units/file\n\n\t* par.adb: Change test for s-rpc to s-rp for detecting rpc and children\n\n\t* par.adb, memtrack.adb, prj-makr.adb, prj-part.adb,\n\tsem_util.adb: Minor reformatting\n\n\t* sem_ch12.adb: Add comment for previous change\n\n2004-03-29  Laurent Pautet  <pautet@act-europe.fr>\n\n\t* osint.adb (Executable_Prefix): Set Exec_Name to the current\n\texecutable name when not initialized. Otherwise, use its current value.\n\n\t* osint.ads (Exec_Name): Move Exec_Name from body to spec in order to\n\tinitialize it to another executable name than the current one. This\n\tallows to configure paths for an executable name (gnatmake) different\n\tfrom the current one (gnatdist).\n\n2004-03-29  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_ch6.adb (Expand_Call): A call to a function declared in the\n\tcurrent unit cannot be inlined if it appears in the body of a withed\n\tunit, to avoid order of elaboration problems in gigi.\n\n\t* exp_ch9.adb (Build_Protected_Sub_Specification): Generate debugging\n\tinformation for protected (wrapper) operation as well, to simplify gdb\n\tuse.\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body): For a private operation in a\n\tprotected body, indicate that the entity for the generated spec comes\n\tfrom source, to ensure that references are properly generated for it.\n\t(Build_Body_To_Inline): Do not inline a function that returns a\n\tcontrolled type.\n\n\t* sem_prag.adb (Process_Convention): If subprogram is overloaded, only\n\tapply convention to homonyms that are declared explicitly.\n\n\t* sem_res.adb (Make_Call_Into_Operator): If the operation is a function\n\tthat renames an equality operator and the operands are overloaded,\n\tresolve them with the declared formal types, before rewriting as an\n\toperator.\n\n2004-03-29  GNAT Script  <nobody@gnat.com>\n\n\t* Make-lang.in: Makefile automatically updated\n\nFrom-SVN: r80055", "tree": {"sha": "b41024c63720bbb6fd3edef3c99d72097d058a4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b41024c63720bbb6fd3edef3c99d72097d058a4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2820d220585177ca4e2e3136bf8ff255303ba6db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2820d220585177ca4e2e3136bf8ff255303ba6db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2820d220585177ca4e2e3136bf8ff255303ba6db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2820d220585177ca4e2e3136bf8ff255303ba6db/comments", "author": null, "committer": null, "parents": [{"sha": "63041e68a4c1b6043872652c07223117ebfb07f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63041e68a4c1b6043872652c07223117ebfb07f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63041e68a4c1b6043872652c07223117ebfb07f7"}], "stats": {"total": 2182, "additions": 1783, "deletions": 399}, "files": [{"sha": "26c8ef5099ad103651c202018ef7ff5bb98089ad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1,3 +1,137 @@\n+2004-03-29  Javier Miranda  <miranda@gnat.com>\n+\n+\t* checks.adb (Null_Exclusion_Static_Checks): New subprogram\n+\t(Install_Null_Excluding_Check): Local subprogram that determines whether\n+\tan access node requires a runtime access check and if so inserts the\n+\tappropriate run-time check.\n+\t(Apply_Access_Check): Call Install_Null_Excluding check if required\n+\t(Apply_Constraint_Check): Call Install_Null_Excluding check if required\n+\n+\t* checks.ads: (Null_Exclusion_Static_Checks): New subprogram\n+\n+\t* einfo.ads: Fix typo in comment\n+\n+\t* exp_ch3.adb (Build_Assignment): Generate conversion to the\n+\tnull-excluding type to force the corresponding run-time check.\n+\t(Expand_N_Object_Declaration): Generate conversion to the null-excluding\n+\ttype to force the corresponding run-time check.\n+\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Generate conversion to\n+\tthe null-excluding type to force the corresponding run-time check.\n+\n+\t* exp_ch6.adb (Expand_Call): Do not generate the run-time check in\n+\tcase of access types unless they have the null-excluding attribute.\n+\n+\t* sprint.adb (Sprint_Node_Actual): Give support to the null-exclusing\n+\tpart.\n+\n+\t* exp_util.ads: Fix typo in comment\n+\n+\t* par.adb (P_Null_Exclusion): New subprogram\n+\t(P_Subtype_Indication): New formal that indicates if the null-excluding\n+\tpart has been scanned-out and it was present\n+\n+\t* par-ch3.adb, par-ch4.adb, par-ch6.adb: Give support to AI-231\n+\n+\t* sem_aggr.adb: (Check_Can_Never_Be_Null): New subprogram\n+\t(Aggregate_Constraint_Checks): Generate conversion to the null-excluding\n+\ttype to force the corresponding run-time check\n+\t(Resolve_Aggregate): Propagate the null-excluding attribute to the array\n+\tcomponents\n+\t(Resolve_Array_Aggregate): Carry out some static checks\n+\t(Resolve_Record_Aggregate.Get_Value): Carry out some static check\n+\n+\t* sem_ch3.adb (Access_Definition): In Ada 0Y the Can_Never_Be_Null\n+\tattribute must be set only if specified by means of the null-excluding\n+\tpart. In addition, we must also propagate the access-constant attribute\n+\tif present.\n+\t(Access_Subprogram_Declaration, Access_Type_Declaration,\n+\tAnalyze_Component_Declaration, Analyze_Object_Declaration,\n+\tArray_Type_Declaration, Process_Discriminants,\n+\tAnalyze_Subtype_Declaration): Propagate the null-excluding attribute\n+\tand carry out some static checks.\n+\t(Build_Derived_Access_Type): Set the null-excluding attribute\n+\t(Derived_Type_Declaration, Process_Subtype): Carry out some static\n+\tchecks.\n+\n+\t* sem_ch4.adb (Analyze_Allocator): Carry out some static checks\n+\n+\t* sem_ch5.adb (Analyze_Assignment): Carry out some static checks\n+\n+\t* sem_ch6.adb (Process_Formals): Carry out some static checks.\n+\t(Set_Actual_Subtypes): Generate null-excluding subtype if the\n+\tnull-excluding part was present; it is not required to be done here in\n+\tcase of anonymous access types.\n+\t(Set_Formal_Mode): Ada 0Y allows anonymous access to have the null\n+\tvalue.\n+\n+\t* sem_res.adb (Resolve_Actuals): Carry out some static check\n+\t(Resolve_Null): Allow null in anonymous access\n+\n+\t* sinfo.adb: New subprogram Null_Exclusion_Present\n+\tAll_Present and Constant_Present available on access_definition nodes\n+\n+\t* sinfo.ads: New flag Null_Exclusion_Present on subtype_declaration,\n+\tobject_declaration, derived_type_definition, component_definition,\n+\tdiscriminant_specification, access_to_object_definition,\n+\taccess_function_definition, allocator, access_procedure_definition,\n+\taccess_definition, parameter_specification, All_Present and\n+\tConstant_Present flags available on access_definition nodes.\n+\n+2004-03-29  Robert Dewar  <dewar@gnat.com>\n+\n+\t* fname.adb, fname.ads, fname-sf.adb, fname-uf.adb, fname-uf.ads,\n+\tgnat1drv.adb, lib.adb, lib.ads, lib-load.adb, lib-writ.adb,\n+\topt.ads, osint.adb, osint.ads, osint-c.adb, par.adb,\n+\tpar-ch10.adb, par-load.adb, par-prag.adb, sfn_scan.adb,\n+\tsfn_scan.ads, sinput-l.adb, sinput-l.ads, switch-c.adb,\n+\tsem_prag.adb: Updates to handle multiple units/file\n+\n+\t* par.adb: Change test for s-rpc to s-rp for detecting rpc and children\n+\n+\t* par.adb, memtrack.adb, prj-makr.adb, prj-part.adb,\n+\tsem_util.adb: Minor reformatting\n+\n+\t* sem_ch12.adb: Add comment for previous change\n+\n+2004-03-29  Laurent Pautet  <pautet@act-europe.fr>\n+\n+\t* osint.adb (Executable_Prefix): Set Exec_Name to the current\n+\texecutable name when not initialized. Otherwise, use its current value.\n+\n+\t* osint.ads (Exec_Name): Move Exec_Name from body to spec in order to\n+\tinitialize it to another executable name than the current one. This\n+\tallows to configure paths for an executable name (gnatmake) different\n+\tfrom the current one (gnatdist).\n+\n+2004-03-29  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* exp_ch6.adb (Expand_Call): A call to a function declared in the\n+\tcurrent unit cannot be inlined if it appears in the body of a withed\n+\tunit, to avoid order of elaboration problems in gigi.\n+\n+\t* exp_ch9.adb (Build_Protected_Sub_Specification): Generate debugging\n+\tinformation for protected (wrapper) operation as well, to simplify gdb\n+\tuse.\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body): For a private operation in a\n+\tprotected body, indicate that the entity for the generated spec comes\n+\tfrom source, to ensure that references are properly generated for it.\n+\t(Build_Body_To_Inline): Do not inline a function that returns a\n+\tcontrolled type.\n+\n+\t* sem_prag.adb (Process_Convention): If subprogram is overloaded, only\n+\tapply convention to homonyms that are declared explicitly.\n+\n+\t* sem_res.adb (Make_Call_Into_Operator): If the operation is a function\n+\tthat renames an equality operator and the operands are overloaded,\n+\tresolve them with the declared formal types, before rewriting as an\n+\toperator.\n+\n+2004-03-29  GNAT Script  <nobody@gnat.com>\n+\n+\t* Make-lang.in: Makefile automatically updated\n+\n 2004-03-25  Vasiliy Fofanov  <fofanov@act-europe.fr>\n \n \t* memtrack.adb: Log realloc calls, which are treated as free followed"}, {"sha": "419fd0b4b1db4391fa74bde7951159b561eaa9dd", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -2211,8 +2211,8 @@ ada/fname-uf.o : ada/ada.ads ada/a-except.ads ada/a-uncdea.ads \\\n    ada/system.ads ada/s-exctab.ads ada/s-htable.ads ada/s-htable.adb \\\n    ada/s-memory.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n    ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/tree_io.ads ada/types.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/widechar.ads \n+   ada/table.adb ada/tree_io.ads ada/types.ads ada/uname.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/widechar.ads \n \n ada/fname.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/debug.ads \\\n    ada/fname.ads ada/fname.adb ada/gnat.ads ada/g-os_lib.ads \\\n@@ -2590,25 +2590,25 @@ ada/osint-b.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/debug.ads \\\n \n ada/osint-c.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/debug.ads \\\n    ada/gnat.ads ada/g-os_lib.ads ada/g-string.ads ada/gnatvsn.ads \\\n-   ada/hostparm.ads ada/namet.ads ada/opt.ads ada/osint.ads \\\n+   ada/hostparm.ads ada/namet.ads ada/namet.adb ada/opt.ads ada/osint.ads \\\n    ada/osint-c.ads ada/osint-c.adb ada/output.ads ada/system.ads \\\n    ada/s-exctab.ads ada/s-memory.ads ada/s-secsta.ads ada/s-soflin.ads \\\n    ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n    ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n    ada/table.adb ada/tree_io.ads ada/types.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads \n+   ada/unchdeal.ads ada/widechar.ads \n \n ada/osint.o : ada/ada.ads ada/a-except.ads ada/a-uncdea.ads ada/alloc.ads \\\n    ada/debug.ads ada/fmap.ads ada/gnat.ads ada/g-htable.ads \\\n    ada/g-os_lib.ads ada/g-string.ads ada/gnatvsn.ads ada/hostparm.ads \\\n-   ada/namet.ads ada/opt.ads ada/osint.ads ada/osint.adb ada/output.ads \\\n-   ada/sdefault.ads ada/system.ads ada/s-casuti.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-htable.adb ada/s-memory.ads ada/s-secsta.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-strops.ads ada/s-sopco3.ads ada/s-sopco4.ads \\\n-   ada/s-sopco5.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads \n+   ada/namet.ads ada/namet.adb ada/opt.ads ada/osint.ads ada/osint.adb \\\n+   ada/output.ads ada/sdefault.ads ada/system.ads ada/s-casuti.ads \\\n+   ada/s-exctab.ads ada/s-htable.ads ada/s-htable.adb ada/s-memory.ads \\\n+   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-strops.ads ada/s-sopco3.ads \\\n+   ada/s-sopco4.ads ada/s-sopco5.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n+   ada/types.ads ada/unchconv.ads ada/unchdeal.ads ada/widechar.ads \n \n ada/output.o : ada/gnat.ads ada/g-os_lib.ads ada/g-string.ads \\\n    ada/output.ads ada/output.adb ada/system.ads ada/s-exctab.ads \\"}, {"sha": "b16fcc18c2f961acd575595c22c56c9e0cd3bfbe", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 208, "deletions": 14, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -244,6 +244,10 @@ package body Checks is\n    --  that the access value is non-null, since the checks do not\n    --  not apply to null access values.\n \n+   procedure Install_Null_Excluding_Check (N : Node_Id);\n+   --  Determines whether an access node requires a runtime access check and\n+   --  if so inserts the appropriate run-time check\n+\n    procedure Install_Static_Check (R_Cno : Node_Id; Loc : Source_Ptr);\n    --  Called by Apply_{Length,Range}_Checks to rewrite the tree with the\n    --  Constraint_Error node.\n@@ -392,19 +396,7 @@ package body Checks is\n \n       --  Access check is required\n \n-      declare\n-         Loc : constant Source_Ptr := Sloc (N);\n-\n-      begin\n-         Insert_Action (N,\n-           Make_Raise_Constraint_Error (Sloc (N),\n-              Condition =>\n-                Make_Op_Eq (Loc,\n-                  Left_Opnd => Duplicate_Subexpr_Move_Checks (P),\n-                  Right_Opnd =>\n-                    Make_Null (Loc)),\n-              Reason => CE_Access_Check_Failed));\n-      end;\n+      Install_Null_Excluding_Check (P);\n    end Apply_Access_Check;\n \n    -------------------------------\n@@ -506,7 +498,7 @@ package body Checks is\n                  Reason => PE_Misaligned_Address_Value));\n             Error_Msg_NE\n               (\"?specified address for& not \" &\n-               \"consistent with alignment\", Expr, E);\n+               \"consistent with alignment ('R'M 13.3(27))\", Expr, E);\n          end if;\n \n       --  Here we do not know if the value is acceptable, generate\n@@ -997,6 +989,12 @@ package body Checks is\n          then\n             Apply_Discriminant_Check (N, Typ);\n          end if;\n+\n+         if Can_Never_Be_Null (Typ)\n+           and then not Can_Never_Be_Null (Etype (N))\n+         then\n+            Install_Null_Excluding_Check (N);\n+         end if;\n       end if;\n    end Apply_Constraint_Check;\n \n@@ -2193,6 +2191,170 @@ package body Checks is\n       end if;\n    end Check_Valid_Lvalue_Subscripts;\n \n+   ----------------------------------\n+   -- Null_Exclusion_Static_Checks --\n+   ----------------------------------\n+\n+   procedure Null_Exclusion_Static_Checks (N : Node_Id) is\n+      K                  : constant Node_Kind := Nkind (N);\n+      Expr               : Node_Id;\n+      Typ                : Entity_Id;\n+      Related_Nod        : Node_Id;\n+      Has_Null_Exclusion : Boolean := False;\n+\n+      --  Following declarations and subprograms are just used to qualify the\n+      --  error messages\n+\n+      type Msg_Kind is (Components, Formals, Objects);\n+      Msg_K : Msg_Kind := Objects;\n+\n+      procedure Must_Be_Initialized;\n+      procedure Null_Not_Allowed;\n+\n+      -------------------------\n+      -- Must_Be_Initialized --\n+      -------------------------\n+\n+      procedure Must_Be_Initialized is\n+      begin\n+         case Msg_K is\n+            when Components =>\n+               Error_Msg_N\n+                 (\"(Ada 0Y) null-excluding components must be initialized\",\n+                  Related_Nod);\n+\n+            when Formals =>\n+               Error_Msg_N\n+                 (\"(Ada 0Y) null-excluding formals must be initialized\",\n+                  Related_Nod);\n+\n+            when Objects =>\n+               Error_Msg_N\n+                 (\"(Ada 0Y) null-excluding objects must be initialized\",\n+                  Related_Nod);\n+         end case;\n+      end Must_Be_Initialized;\n+\n+      ----------------------\n+      -- Null_Not_Allowed --\n+      ----------------------\n+\n+      procedure Null_Not_Allowed is\n+      begin\n+         case Msg_K is\n+            when Components =>\n+               Error_Msg_N\n+                 (\"(Ada 0Y) NULL not allowed in null-excluding components\",\n+                  Expr);\n+\n+            when Formals =>\n+               Error_Msg_N\n+                 (\"(Ada 0Y) NULL not allowed in null-excluding formals\",\n+                  Expr);\n+\n+            when Objects =>\n+               Error_Msg_N\n+                 (\"(Ada 0Y) NULL not allowed in null-excluding objects\",\n+                  Expr);\n+         end case;\n+      end Null_Not_Allowed;\n+\n+   --  Start of processing for Null_Exclusion_Static_Checks\n+\n+   begin\n+      pragma Assert (K = N_Component_Declaration\n+                     or else K = N_Parameter_Specification\n+                     or else K = N_Object_Declaration\n+                     or else K = N_Discriminant_Specification\n+                     or else K = N_Allocator);\n+\n+      Expr := Expression (N);\n+\n+      case K is\n+         when N_Component_Declaration =>\n+            Msg_K               := Components;\n+            Has_Null_Exclusion  := Null_Exclusion_Present\n+                                     (Component_Definition (N));\n+            Typ                 := Etype (Subtype_Indication\n+                                           (Component_Definition (N)));\n+            Related_Nod         := Subtype_Indication\n+                                     (Component_Definition (N));\n+\n+         when N_Parameter_Specification =>\n+            Msg_K              := Formals;\n+            Has_Null_Exclusion := Null_Exclusion_Present (N);\n+            Typ                := Entity (Parameter_Type (N));\n+            Related_Nod        := Parameter_Type (N);\n+\n+         when N_Object_Declaration =>\n+            Msg_K              := Objects;\n+            Has_Null_Exclusion := Null_Exclusion_Present (N);\n+            Typ                := Entity (Object_Definition (N));\n+            Related_Nod        := Object_Definition (N);\n+\n+         when N_Discriminant_Specification =>\n+            Msg_K              := Components;\n+\n+            if Nkind (Discriminant_Type (N)) = N_Access_Definition then\n+\n+               --  This case is special. We do not want to carry out some of\n+               --  the null-excluding checks. Reason: the analysis of the\n+               --  access_definition propagates the null-excluding attribute\n+               --  to the can_never_be_null entity attribute (and thus it is\n+               --  wrong to check it now)\n+\n+               Has_Null_Exclusion := False;\n+            else\n+               Has_Null_Exclusion := Null_Exclusion_Present (N);\n+            end if;\n+\n+            Typ                := Etype (Defining_Identifier (N));\n+            Related_Nod        := Discriminant_Type (N);\n+\n+         when N_Allocator =>\n+            Msg_K              := Objects;\n+            Has_Null_Exclusion := Null_Exclusion_Present (N);\n+            Typ                := Etype (Expr);\n+\n+            if Nkind (Expr) = N_Qualified_Expression then\n+               Related_Nod     := Subtype_Mark (Expr);\n+            else\n+               Related_Nod     := Expr;\n+            end if;\n+\n+         when others =>\n+            pragma Assert (False);\n+            null;\n+      end case;\n+\n+      --  Check that the entity was already decorated\n+\n+      pragma Assert (Typ /= Empty);\n+\n+      if Has_Null_Exclusion\n+        and then not Is_Access_Type (Typ)\n+      then\n+         Error_Msg_N (\"(Ada 0Y) must be an access type\", Related_Nod);\n+\n+      elsif Has_Null_Exclusion\n+        and then Can_Never_Be_Null (Typ)\n+      then\n+         Error_Msg_N\n+           (\"(Ada 0Y) already a null-excluding type\", Related_Nod);\n+\n+      elsif (Nkind (N) = N_Component_Declaration\n+             or else Nkind (N) = N_Object_Declaration)\n+        and not Present (Expr)\n+      then\n+         Must_Be_Initialized;\n+\n+      elsif Present (Expr)\n+        and then Nkind (Expr) = N_Null\n+      then\n+         Null_Not_Allowed;\n+      end if;\n+   end Null_Exclusion_Static_Checks;\n+\n    ----------------------------------\n    -- Conditional_Statements_Begin --\n    ----------------------------------\n@@ -4192,6 +4354,38 @@ package body Checks is\n       Validity_Checks_On := True;\n    end Insert_Valid_Check;\n \n+   ----------------------------------\n+   -- Install_Null_Excluding_Check --\n+   ----------------------------------\n+\n+   procedure Install_Null_Excluding_Check (N : Node_Id) is\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Etyp : constant Entity_Id  := Etype (N);\n+\n+   begin\n+      pragma Assert (Is_Access_Type (Etyp));\n+\n+      --  Don't need access check if: 1) we are analyzing a generic, 2) it is\n+      --  known to be non-null, or 3) the check was suppressed on the type\n+\n+      if Inside_A_Generic\n+        or else Access_Checks_Suppressed (Etyp)\n+      then\n+         return;\n+\n+         --  Otherwise install access check\n+\n+      else\n+         Insert_Action (N,\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd  => Duplicate_Subexpr_Move_Checks (N),\n+                 Right_Opnd => Make_Null (Loc)),\n+             Reason    => CE_Access_Check_Failed));\n+      end if;\n+   end Install_Null_Excluding_Check;\n+\n    --------------------------\n    -- Install_Static_Check --\n    --------------------------"}, {"sha": "dcb4606775d2f65daae92b31781f55696ac0fb4a", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -616,6 +616,9 @@ package Checks is\n    --  the sense of the 'Valid attribute returning True. Constraint_Error\n    --  will be raised if the value is not valid.\n \n+   procedure Null_Exclusion_Static_Checks (N : Node_Id);\n+   --  Ada 0Y (AI-231): Check bad usages of the null-exclusion issue\n+\n    procedure Remove_Checks (Expr : Node_Id);\n    --  Remove all checks from Expr except those that are only executed\n    --  conditionally (on the right side of And Then/Or Else. This call"}, {"sha": "a8180e4c971d4f405e93b066d8ef1d5025cb5992", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1970,7 +1970,7 @@ package Einfo is\n --       Present in all entities. Relevant (and can be set True) only for\n --       objects of an access type. It is set if the object is currently\n --       known to have a non-null value (meaning that no access checks\n---       are needed). The indication can for eample3 come from assignment\n+--       are needed). The indication can for example3 come from assignment\n --       of an access parameter or an allocator.\n --\n --       Note: this flag is set according to the sequential flow of the"}, {"sha": "c8a28aab6f250ff4cc45c72ac9015de702ff8dce", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1052,7 +1052,7 @@ package body Exp_Ch3 is\n       Controller_Typ : Entity_Id;\n \n    begin\n-      --  Nothing to do if the Init_Proc is null, unless Initialize_Sclalars\n+      --  Nothing to do if the Init_Proc is null, unless Initialize_Scalars\n       --  is active (in which case we make the call anyway, since in the\n       --  actual compiled client it may be non null).\n \n@@ -1491,6 +1491,19 @@ package body Exp_Ch3 is\n             Exp := New_Copy_Tree (Original_Node (Exp));\n          end if;\n \n+         --  Ada 0Y (AI-231): Generate conversion to the null-excluding\n+         --  type to force the corresponding run-time check\n+\n+         if Extensions_Allowed\n+           and then Can_Never_Be_Null (Etype (Id))  -- Lhs\n+           and then (Present (Etype (Exp))\n+                       and then not Can_Never_Be_Null (Etype (Exp)))\n+         then\n+            Rewrite (Exp, Convert_To (Etype (Id),\n+                                      Relocate_Node (Exp)));\n+            Analyze_And_Resolve (Exp, Etype (Id));\n+         end if;\n+\n          Res := New_List (\n            Make_Assignment_Statement (Loc,\n              Name       => Lhs,\n@@ -3421,17 +3434,30 @@ package body Exp_Ch3 is\n             then\n                Set_Is_Known_Valid (Def_Id);\n \n-            --  For access types set the Is_Known_Non_Null flag if the\n-            --  initializing value is known to be non-null. We can also\n-            --  set Can_Never_Be_Null if this is a constant.\n+            elsif Is_Access_Type (Typ) then\n \n-            elsif Is_Access_Type (Typ)\n-              and then Known_Non_Null (Expr)\n-            then\n-               Set_Is_Known_Non_Null (Def_Id);\n+               --  Ada 0Y (AI-231): Generate conversion to the null-excluding\n+               --  type to force the corresponding run-time check\n \n-               if Constant_Present (N) then\n-                  Set_Can_Never_Be_Null (Def_Id);\n+               if Extensions_Allowed\n+                 and then (Can_Never_Be_Null (Def_Id)\n+                           or else Can_Never_Be_Null (Typ))\n+               then\n+                  Rewrite (Expr_Q, Convert_To (Etype (Def_Id),\n+                                               Relocate_Node (Expr_Q)));\n+                  Analyze_And_Resolve (Expr_Q, Etype (Def_Id));\n+               end if;\n+\n+               --  For access types set the Is_Known_Non_Null flag if the\n+               --  initializing value is known to be non-null. We can also\n+               --  set Can_Never_Be_Null if this is a constant.\n+\n+               if Known_Non_Null (Expr) then\n+                  Set_Is_Known_Non_Null (Def_Id);\n+\n+                  if Constant_Present (N) then\n+                     Set_Can_Never_Be_Null (Def_Id);\n+                  end if;\n                end if;\n             end if;\n "}, {"sha": "08ec7d507b51e0efa0e35d90054593d6c9092658", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1541,6 +1541,19 @@ package body Exp_Ch5 is\n            (Expression (Rhs), Designated_Type (Etype (Lhs)));\n       end if;\n \n+      --  Ada 0Y (AI-231): Generate conversion to the null-excluding\n+      --  type to force the corresponding run-time check\n+\n+      if Is_Access_Type (Typ)\n+        and then ((Is_Entity_Name (Lhs)\n+                   and then Can_Never_Be_Null (Entity (Lhs)))\n+                   or else Can_Never_Be_Null (Etype (Lhs)))\n+      then\n+         Rewrite (Rhs, Convert_To (Etype (Lhs),\n+                                   Relocate_Node (Rhs)));\n+         Analyze_And_Resolve (Rhs, Etype (Lhs));\n+      end if;\n+\n       --  If we are assigning an access type and the left side is an\n       --  entity, then make sure that Is_Known_Non_Null properly\n       --  reflects the state of the entity after the assignment"}, {"sha": "469bae6caa4c20129a803e066e1baeb1d616cfb1", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1382,7 +1382,7 @@ package body Exp_Ch6 is\n \n                --  When passing an access parameter as the actual to another\n                --  access parameter we need to pass along the actual's own\n-               --  associated access level parameter. This is done is we are\n+               --  associated access level parameter. This is done if we are\n                --  in the scope of the formal access parameter (if this is an\n                --  inlined body the extra formal is irrelevant).\n \n@@ -1516,7 +1516,12 @@ package body Exp_Ch6 is\n          elsif Convention (Subp) = Convention_Java then\n             null;\n \n-         else\n+         --  Ada 0Y (AI-231): do not force the check in case of Ada 0Y unless\n+         --  it is a null-excluding type\n+\n+         elsif not Extensions_Allowed\n+           or else Can_Never_Be_Null (Etype (Prev))\n+         then\n             Cond :=\n               Make_Op_Eq (Loc,\n                 Left_Opnd => Duplicate_Subexpr_No_Checks (Prev),\n@@ -1999,10 +2004,16 @@ package body Exp_Ch6 is\n                   --  temporaries are generated when compiling the body by\n                   --  itself. Otherwise link errors can occur.\n \n+                  --  If the function being called is itself in the main unit,\n+                  --  we cannot inline, because there is a risk of double\n+                  --  elaboration and/or circularity: the inlining can make\n+                  --  visible a private entity in the body of the main unit,\n+                  --  that gigi will see before its sees its proper definition.\n+\n                   elsif not (In_Extended_Main_Code_Unit (N))\n                     and then In_Package_Body\n                   then\n-                     Must_Inline := True;\n+                     Must_Inline := not In_Extended_Main_Source_Unit (Subp);\n                   end if;\n                end if;\n "}, {"sha": "f60980ac25fbdddefb4c80ca9b158dd001fdf0a7", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1488,6 +1488,7 @@ package body Exp_Ch9 is\n       Protnm      : constant Name_Id := Chars (Prottyp);\n       Ident       : Entity_Id;\n       Nam         : Name_Id;\n+      New_Id      : Entity_Id;\n       New_Plist   : List_Id;\n       Append_Char : Character;\n       New_Spec    : Node_Id;\n@@ -1514,20 +1515,28 @@ package body Exp_Ch9 is\n          Append_Char := 'P';\n       end if;\n \n+      New_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => Build_Selected_Name (Protnm, Nam, Append_Char));\n+\n+      --  The unprotected operation carries the user code, and debugging\n+      --  information must be generated for it, even though this spec does\n+      --  not come from source. It is also convenient to allow gdb to step\n+      --  into the protected operation, even though it only contains lock/\n+      --  unlock calls.\n+\n+      Set_Needs_Debug_Info (New_Id);\n+\n       if Nkind (Specification (Decl)) = N_Procedure_Specification then\n          return\n            Make_Procedure_Specification (Loc,\n-             Defining_Unit_Name =>\n-               Make_Defining_Identifier (Loc,\n-                 Chars => Build_Selected_Name (Protnm, Nam, Append_Char)),\n+             Defining_Unit_Name => New_Id,\n              Parameter_Specifications => New_Plist);\n \n       else\n          New_Spec :=\n            Make_Function_Specification (Loc,\n-             Defining_Unit_Name =>\n-               Make_Defining_Identifier (Loc,\n-                 Chars => Build_Selected_Name (Protnm, Nam, Append_Char)),\n+             Defining_Unit_Name => New_Id,\n              Parameter_Specifications => New_Plist,\n              Subtype_Mark => New_Copy (Subtype_Mark (Specification (Decl))));\n          Set_Return_Present (Defining_Unit_Name (New_Spec));"}, {"sha": "62568f513a1c9afe761c079a9d4c00ee5d387d5b", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -127,7 +127,7 @@ package Exp_Util is\n    --\n    --  Implementation limitation: Assoc_Node must be a statement. We can\n    --  generalize to expressions if there is a need but this is tricky to\n-   --  implement because of short-ciruits (among other things).???\n+   --  implement because of short-circuits (among other things).???\n \n    procedure Insert_Library_Level_Action (N : Node_Id);\n    --  This procedure inserts and analyzes the node N as an action at the"}, {"sha": "28977e734e4479a9a864a1dadb0ac35775a5f4b6", "filename": "gcc/ada/fname-sf.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname-sf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname-sf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-sf.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,7 +46,11 @@ package body Fname.SF is\n    -- Local Procedures --\n    ----------------------\n \n-   procedure Set_File_Name (Typ : Character; U : String; F : String);\n+   procedure Set_File_Name\n+     (Typ   : Character;\n+      U     : String;\n+      F     : String;\n+      Index : Natural);\n    --  This is a transfer function that is called from Scan_SFN_Pragmas,\n    --  and reformats its parameters appropriately for the version of\n    --  Set_File_Name found in Fname.SF.\n@@ -89,10 +93,14 @@ package body Fname.SF is\n    -- Set_File_Name --\n    -------------------\n \n-   procedure Set_File_Name (Typ : Character; U : String; F : String) is\n+   procedure Set_File_Name\n+     (Typ   : Character;\n+      U     : String;\n+      F     : String;\n+      Index : Natural)\n+   is\n       Unm : Unit_Name_Type;\n       Fnm : File_Name_Type;\n-\n    begin\n       Name_Buffer (1 .. U'Length) := U;\n       Name_Len := U'Length;\n@@ -104,7 +112,7 @@ package body Fname.SF is\n       Name_Buffer (1 .. F'Length) := F;\n       Name_Len := F'Length;\n       Fnm := Name_Find;\n-      Fname.UF.Set_File_Name (Unm, Fnm);\n+      Fname.UF.Set_File_Name (Unm, Fnm, Nat (Index));\n    end Set_File_Name;\n \n    ---------------------------"}, {"sha": "00af708cae60b80d7478333879a69c891c54fbfa", "filename": "gcc/ada/fname-uf.adb", "status": "modified", "additions": 72, "deletions": 4, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname-uf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname-uf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -32,6 +32,7 @@ with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n with Table;\n+with Uname;    use Uname;\n with Widechar; use Widechar;\n \n with GNAT.HTable;\n@@ -43,8 +44,9 @@ package body Fname.UF is\n    --------------------------------------------------------\n \n    type SFN_Entry is record\n-      U : Unit_Name_Type; -- Unit name\n-      F : File_Name_Type; -- Spec/Body file name\n+      U     : Unit_Name_Type; -- Unit name\n+      F     : File_Name_Type; -- Spec/Body file name\n+      Index : Nat;            -- Index from SFN pragma (0 if none)\n    end record;\n    --  Record single Unit_Name type call to Set_File_Name\n \n@@ -118,6 +120,53 @@ package body Fname.UF is\n       return Get_File_Name (Name_Enter, Subunit => False);\n    end File_Name_Of_Spec;\n \n+   ----------------------------\n+   -- Get_Expected_Unit_Type --\n+   ----------------------------\n+\n+   function Get_Expected_Unit_Type\n+     (Fname : File_Name_Type) return Expected_Unit_Type\n+   is\n+   begin\n+      --  In syntax checking only mode or in multiple unit per file mode,\n+      --  there can be more than one unit in a file, so the file name is\n+      --  not a useful guide to the nature of the unit.\n+\n+      if Operating_Mode = Check_Syntax\n+        or else Multiple_Unit_Index /= 0\n+      then\n+         return Unknown;\n+      end if;\n+\n+      --  Search the file mapping table, if we find an entry for this\n+      --  file we know whether it is a spec or a body.\n+\n+      for J in SFN_Table.First .. SFN_Table.Last loop\n+         if Fname = SFN_Table.Table (J).F then\n+            if Is_Body_Name (SFN_Table.Table (J).U) then\n+               return Expect_Body;\n+            else\n+               return Expect_Spec;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  If no entry in file naming table, assume .ads/.adb for spec/body\n+      --  and return unknown if we have neither of these two cases.\n+\n+      Get_Name_String (Fname);\n+\n+      if Name_Len > 4 then\n+         if Name_Buffer (Name_Len - 3 .. Name_Len) = \".ads\" then\n+            return Expect_Spec;\n+         elsif Name_Buffer (Name_Len - 3 .. Name_Len) = \".adb\" then\n+            return Expect_Body;\n+         end if;\n+      end if;\n+\n+      return Unknown;\n+   end Get_Expected_Unit_Type;\n+\n    -------------------\n    -- Get_File_Name --\n    -------------------\n@@ -457,6 +506,20 @@ package body Fname.UF is\n       end;\n    end Get_File_Name;\n \n+   --------------------\n+   -- Get_Unit_Index --\n+   --------------------\n+\n+   function Get_Unit_Index (Uname : Unit_Name_Type) return Nat is\n+      N : constant Int := SFN_HTable.Get (Uname);\n+   begin\n+      if N /= No_Entry then\n+         return SFN_Table.Table (N).Index;\n+      else\n+         return 0;\n+      end if;\n+   end Get_Unit_Index;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -496,10 +559,14 @@ package body Fname.UF is\n    -- Set_File_Name --\n    -------------------\n \n-   procedure Set_File_Name (U : Unit_Name_Type; F : File_Name_Type) is\n+   procedure Set_File_Name\n+     (U     : Unit_Name_Type;\n+      F     : File_Name_Type;\n+      Index : Nat)\n+   is\n    begin\n       SFN_Table.Increment_Last;\n-      SFN_Table.Table (SFN_Table.Last) := (U, F);\n+      SFN_Table.Table (SFN_Table.Last) := (U, F, Index);\n       SFN_HTable.Set (U, SFN_Table.Last);\n    end Set_File_Name;\n \n@@ -514,6 +581,7 @@ package body Fname.UF is\n       Cas : Casing_Type)\n    is\n       L : constant Nat := SFN_Patterns.Last;\n+\n    begin\n       SFN_Patterns.Increment_Last;\n "}, {"sha": "d829a206e243bf7d2a5ea34b56a0e08bca60e5bc", "filename": "gcc/ada/fname-uf.ads", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname-uf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname-uf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -43,6 +43,16 @@ package Fname.UF is\n    -- Subprograms --\n    -----------------\n \n+   type Expected_Unit_Type is (Expect_Body, Expect_Spec, Unknown);\n+   --  Return value from Get_Expected_Unit_Type\n+\n+   function Get_Expected_Unit_Type\n+     (Fname : File_Name_Type) return Expected_Unit_Type;\n+   --  If possible, determine whether the given file name corresponds to a unit\n+   --  that is a spec or body (e.g. by examining the extension). If this cannot\n+   --  be determined with the file naming conventions in use, then the returned\n+   --  value is set to Unknown.\n+\n    function Get_File_Name\n      (Uname    : Unit_Name_Type;\n       Subunit  : Boolean;\n@@ -52,11 +62,16 @@ package Fname.UF is\n    --  false for all other kinds of units. The caller is responsible for\n    --  ensuring that the unit name meets the requirements given in package\n    --  Uname and described above.\n+   --\n    --  When May_Fail is True, if the file cannot be found, this function\n    --  returns No_File. When it is False, if the file cannot be found,\n    --  a file name compatible with one pattern Source_File_Name pragma is\n    --  returned.\n \n+   function Get_Unit_Index (Uname : Unit_Name_Type) return Nat;\n+   --  If there is a specific Source_File_Name pragma for this unit, then\n+   --  return the corresponding unit index value. Return 0 if no index given.\n+\n    procedure Initialize;\n    --  Initialize internal tables. This is called automatically when the\n    --  package body is elaborated, so an explicit call to Initialize is\n@@ -76,9 +91,14 @@ package Fname.UF is\n    --  name. The unit name here is not encoded as a Unit_Name_Type, but is\n    --  rather just a normal form name in lower case, e.g. \"xyz.def\".\n \n-   procedure Set_File_Name (U : Unit_Name_Type; F : File_Name_Type);\n+   procedure Set_File_Name\n+     (U     : Unit_Name_Type;\n+      F     : File_Name_Type;\n+      Index : Nat);\n    --  Make association between given unit name, U, and the given file name,\n    --  F. This is the routine called to process a Source_File_Name pragma.\n+   --  Index is the value from the index parameter of the pragma if present\n+   --  and zero if no index parameter is present.\n \n    procedure Set_File_Name_Pattern\n      (Pat : String_Ptr;"}, {"sha": "fd3e92e9e0717b34ba7ef2118ba6e988e1007ae0", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,40 +59,14 @@ package body Fname is\n      Table_Initial        => Alloc.SFN_Table_Initial,\n      Table_Increment      => Alloc.SFN_Table_Increment,\n      Table_Name           => \"Fname_Dummy_Table\");\n-   ----------------------------\n-   -- Get_Expected_Unit_Type --\n-   ----------------------------\n-\n-   --  We assume that a file name whose last character is a lower case b is\n-   --  a body and a file name whose last character is a lower case s is a\n-   --  spec. If any other character is found (e.g. when we are in syntax\n-   --  checking only mode, where the file name conventions are not set),\n-   --  then we return Unknown.\n-\n-   function Get_Expected_Unit_Type\n-     (Fname : File_Name_Type)\n-      return  Expected_Unit_Type\n-   is\n-   begin\n-      Get_Name_String (Fname);\n-\n-      if Name_Buffer (Name_Len) = 'b' then\n-         return Expect_Body;\n-      elsif Name_Buffer (Name_Len) = 's' then\n-         return Expect_Spec;\n-      else\n-         return Unknown;\n-      end if;\n-   end Get_Expected_Unit_Type;\n \n    ---------------------------\n    -- Is_Internal_File_Name --\n    ---------------------------\n \n    function Is_Internal_File_Name\n      (Fname              : File_Name_Type;\n-      Renamings_Included : Boolean := True)\n-      return               Boolean\n+      Renamings_Included : Boolean := True) return Boolean\n    is\n    begin\n       if Is_Predefined_File_Name (Fname, Renamings_Included) then\n@@ -132,17 +106,15 @@ package body Fname is\n \n    function Is_Predefined_File_Name\n      (Fname              : File_Name_Type;\n-      Renamings_Included : Boolean := True)\n-      return               Boolean\n+      Renamings_Included : Boolean := True) return Boolean\n    is\n    begin\n       Get_Name_String (Fname);\n       return Is_Predefined_File_Name (Renamings_Included);\n    end Is_Predefined_File_Name;\n \n    function Is_Predefined_File_Name\n-     (Renamings_Included : Boolean := True)\n-      return               Boolean\n+     (Renamings_Included : Boolean := True) return Boolean\n    is\n       subtype Str8 is String (1 .. 8);\n "}, {"sha": "151971cf6ef89d5225a11cf6fa1485c372bd66e7", "filename": "gcc/ada/fname.ads", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Ffname.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,17 +64,6 @@ package Fname is\n    -- Subprograms --\n    -----------------\n \n-   type Expected_Unit_Type is (Expect_Body, Expect_Spec, Unknown);\n-   --  Return value from Get_Expected_Unit_Type\n-\n-   function Get_Expected_Unit_Type\n-     (Fname : File_Name_Type)\n-      return  Expected_Unit_Type;\n-   --  If possible, determine whether the given file name corresponds to a unit\n-   --  that is a spec or body (e.g. by examining the extension). If this cannot\n-   --  be determined with the file naming conventions in use, then the returned\n-   --  value is set to Unknown.\n-\n    function Is_Predefined_File_Name\n      (Fname              : File_Name_Type;\n       Renamings_Included : Boolean := True) return Boolean;\n@@ -92,8 +81,7 @@ package Fname is\n \n    function Is_Internal_File_Name\n      (Fname              : File_Name_Type;\n-      Renamings_Included : Boolean := True)\n-      return               Boolean;\n+      Renamings_Included : Boolean := True) return Boolean;\n    --  Similar to Is_Predefined_File_Name. The internal file set is a\n    --  superset of the predefined file set including children of GNAT,\n    --  and also children of DEC for the VMS case."}, {"sha": "a544e55534e30ebca48e8c78d134424bb7ff9104", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -310,7 +310,13 @@ begin\n             --  include both in a partition, this is diagnosed at bind time.\n             --  In Ada 83 mode this is not a warning case.\n \n+            --  Note: if weird file names are being used, we can have a\n+            --  situation where the file name that supposedly contains a\n+            --  body, in fact contains a spec, or we can't tell what it\n+            --  contains. Skip the error message in these cases.\n+\n             if Src_Ind /= No_Source_File\n+              and then Get_Expected_Unit_Type (Fname) = Expect_Body\n               and then not Source_File_Is_Subunit (Src_Ind)\n             then\n                Error_Msg_Name_1 := Sname;"}, {"sha": "b294a84305f5a5452d3b50ca4080d5d530d6a1e6", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -153,6 +153,7 @@ package body Lib.Load is\n         Ident_String    => Empty,\n         Loading         => False,\n         Main_Priority   => Default_Main_Priority,\n+        Munit_Index     => 0,\n         Serial_Number   => 0,\n         Source_Index    => No_Source_File,\n         Unit_File_Name  => Get_File_Name (Spec_Name, Subunit => False),\n@@ -221,9 +222,10 @@ package body Lib.Load is\n            Fatal_Error     => False,\n            Generate_Code   => False,\n            Has_RACW        => False,\n-           Loading         => True,\n            Ident_String    => Empty,\n+           Loading         => True,\n            Main_Priority   => Default_Main_Priority,\n+           Munit_Index     => 0,\n            Serial_Number   => 0,\n            Source_Index    => Main_Source_File,\n            Unit_File_Name  => Fname,\n@@ -462,7 +464,10 @@ package body Lib.Load is\n       --  then we have the problem that the file does not contain the unit that\n       --  is needed. We simply treat this as a file not found condition.\n \n-      if Unum > Units.Last then\n+      --  We skip this test in multiple unit per file mode since in this\n+      --  case we can have multiple units from the same source file.\n+\n+      if Unum > Units.Last and then Multiple_Unit_Index = 0 then\n          for J in Units.First .. Units.Last loop\n             if Fname = Units.Table (J).Unit_File_Name then\n                if Debug_Flag_L then\n@@ -473,7 +478,6 @@ package body Lib.Load is\n                end if;\n \n                if Present (Error_Node) then\n-\n                   if Is_Predefined_File_Name (Fname) then\n                      Error_Msg_Name_1 := Uname_Actual;\n                      Error_Msg\n@@ -546,7 +550,7 @@ package body Lib.Load is\n          Set_Load_Unit_Dependency (Unum);\n          return Unum;\n \n-      --  File is not already in table, so try to open it\n+      --  Unit is not already in table, so try to open the file\n \n       else\n          if Debug_Flag_L then\n@@ -580,6 +584,7 @@ package body Lib.Load is\n               Ident_String    => Empty,\n               Loading         => True,\n               Main_Priority   => Default_Main_Priority,\n+              Munit_Index     => 0,\n               Serial_Number   => 0,\n               Source_Index    => Src_Ind,\n               Unit_File_Name  => Fname,\n@@ -588,9 +593,16 @@ package body Lib.Load is\n \n             --  Parse the new unit\n \n-            Initialize_Scanner (Unum, Source_Index (Unum));\n-            Discard_List (Par (Configuration_Pragmas => False));\n-            Set_Loading (Unum, False);\n+            declare\n+               Save_Index : constant Nat := Multiple_Unit_Index;\n+            begin\n+               Multiple_Unit_Index := Get_Unit_Index (Uname_Actual);\n+               Units.Table (Unum).Munit_Index := Multiple_Unit_Index;\n+               Initialize_Scanner (Unum, Source_Index (Unum));\n+               Discard_List (Par (Configuration_Pragmas => False));\n+               Multiple_Unit_Index := Save_Index;\n+               Set_Loading (Unum, False);\n+            end;\n \n             --  If spec is irrelevant, then post errors and quit\n "}, {"sha": "bc6bfe54bf92b9024730e994878aca05dca4de2f", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -76,6 +76,7 @@ package body Lib.Writ is\n          Ident_String    => Empty,\n          Loading         => False,\n          Main_Priority   => -1,\n+         Munit_Index     => 0,\n          Serial_Number   => 0,\n          Version         => 0,\n          Error_Location  => No_Location);\n@@ -92,8 +93,6 @@ package body Lib.Writ is\n       System_Fname : File_Name_Type;\n       --  File name for system spec if needed for dummy entry\n \n-      Save_Style : constant Boolean := Style_Check;\n-\n    begin\n       --  Nothing to do if we already compiled System\n \n@@ -131,17 +130,25 @@ package body Lib.Writ is\n         Ident_String    => Empty,\n         Loading         => False,\n         Main_Priority   => -1,\n+        Munit_Index     => 0,\n         Serial_Number   => 0,\n         Version         => 0,\n         Error_Location  => No_Location);\n \n       --  Parse system.ads so that the checksum is set right\n       --  Style checks are not applied.\n \n-      Style_Check := False;\n-      Initialize_Scanner (Units.Last, System_Source_File_Index);\n-      Discard_List (Par (Configuration_Pragmas => False));\n-      Style_Check := Save_Style;\n+      declare\n+         Save_Mindex : constant Nat := Multiple_Unit_Index;\n+         Save_Style  : constant Boolean := Style_Check;\n+      begin\n+         Multiple_Unit_Index := 0;\n+         Style_Check := False;\n+         Initialize_Scanner (Units.Last, System_Source_File_Index);\n+         Discard_List (Par (Configuration_Pragmas => False));\n+         Style_Check := Save_Style;\n+         Multiple_Unit_Index := Save_Mindex;\n+      end;\n    end Ensure_System_Dependency;\n \n    ---------------\n@@ -667,11 +674,13 @@ package body Lib.Writ is\n                then\n                   Write_Info_Name (Body_Fname);\n                   Write_Info_Tab (49);\n-                  Write_Info_Name (Lib_File_Name (Body_Fname));\n+                  Write_Info_Name\n+                    (Lib_File_Name (Body_Fname, Munit_Index (Unum)));\n                else\n                   Write_Info_Name (Fname);\n                   Write_Info_Tab (49);\n-                  Write_Info_Name (Lib_File_Name (Fname));\n+                  Write_Info_Name\n+                    (Lib_File_Name (Fname, Munit_Index (Unum)));\n                end if;\n \n                if Elab_Flags (Unum) then"}, {"sha": "124ca39552de18a1e9aed8918964f66d0e46fa7d", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -133,6 +133,11 @@ package body Lib is\n       return Units.Table (U).Main_Priority;\n    end Main_Priority;\n \n+   function Munit_Index (U : Unit_Number_Type) return Nat is\n+   begin\n+      return Units.Table (U).Munit_Index;\n+   end Munit_Index;\n+\n    function Source_Index (U : Unit_Number_Type) return Source_File_Index is\n    begin\n       return Units.Table (U).Source_Index;\n@@ -596,7 +601,7 @@ package body Lib is\n       end if;\n \n       --  If S was No_Location, or was not in the table, we must be in the\n-      --  main source unit (and the value is not got put into the table yet)\n+      --  main source unit (and the value has not got put into the table yet)\n \n       return Main_Unit;\n    end Get_Source_Unit;\n@@ -798,7 +803,6 @@ package body Lib is\n \n    function Increment_Serial_Number return Nat is\n       TSN : Int renames Units.Table (Current_Sem_Unit).Serial_Number;\n-\n    begin\n       TSN := TSN + 1;\n       return TSN;"}, {"sha": "2a94f86ead9d68a289f0542e3b6dd0c46e0ccc7b", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -262,6 +262,10 @@ package Lib is\n    --      Set when the entry is created by a call to Lib.Load and then cannot\n    --      be changed.\n \n+   --    Munit_Index\n+   --      The index of the unit within the file for multiple unit per file\n+   --      mode. Set to zero in normal single unit per file mode.\n+\n    --    Error_Location\n    --      This is copied from the Sloc field of the Enode argument passed\n    --      to Load_Unit. It refers to the enclosing construct which caused\n@@ -388,6 +392,7 @@ package Lib is\n    function Has_RACW         (U : Unit_Number_Type) return Boolean;\n    function Loading          (U : Unit_Number_Type) return Boolean;\n    function Main_Priority    (U : Unit_Number_Type) return Int;\n+   function Munit_Index      (U : Unit_Number_Type) return Nat;\n    function Source_Index     (U : Unit_Number_Type) return Source_File_Index;\n    function Unit_File_Name   (U : Unit_Number_Type) return File_Name_Type;\n    function Unit_Name        (U : Unit_Number_Type) return Unit_Name_Type;\n@@ -614,6 +619,7 @@ private\n    pragma Inline (Increment_Serial_Number);\n    pragma Inline (Loading);\n    pragma Inline (Main_Priority);\n+   pragma Inline (Munit_Index);\n    pragma Inline (Set_Cunit);\n    pragma Inline (Set_Cunit_Entity);\n    pragma Inline (Set_Fatal_Error);\n@@ -629,6 +635,7 @@ private\n    type Unit_Record is record\n       Unit_File_Name   : File_Name_Type;\n       Unit_Name        : Unit_Name_Type;\n+      Munit_Index      : Nat;\n       Expected_Unit    : Unit_Name_Type;\n       Source_Index     : Source_File_Index;\n       Cunit            : Node_Id;"}, {"sha": "a36e52b88a71b62c9675ae7fcda68efd37426604", "filename": "gcc/ada/memtrack.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fmemtrack.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fmemtrack.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemtrack.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This version contains allocation tracking capability.\n+--  This version contains allocation tracking capability\n \n --  The object file corresponding to this instrumented version is to be found\n --  in libgmem.\n@@ -313,7 +313,6 @@ package body System.Memory is\n       Lock_Task.all;\n \n       if First_Call then\n-\n          First_Call := False;\n \n          --  We first log deallocation call"}, {"sha": "77468fa319c83978ae39080bd29d2f869954623d", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -659,6 +659,14 @@ package Opt is\n    --  GNATMAKE\n    --  Set to True if minimal recompilation mode requested.\n \n+   Multiple_Unit_Index : Int;\n+   --  GNAT\n+   --  This is set non-zero if the current unit is being compiled in multiple\n+   --  unit per file mode, meaning that the current unit is selected from the\n+   --  sequence of units in the current source file, using the value stored\n+   --  in this variable (e.g. 2 = select second unit in file). A value of\n+   --  zero indicates that we are in normal (one unit per file) mode.\n+\n    No_Main_Subprogram : Boolean := False;\n    --  GNATMAKE, GNATBIND\n    --  Set to True if compilation/binding of a program without main"}, {"sha": "7914b1b38051aad95898708f2696e620e7831fa0", "filename": "gcc/ada/osint-c.adb", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fosint-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fosint-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-c.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 2001-2003 Free Software Foundation, Inc.           --\n+--         Copyright (C) 2001-2004 Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,23 +43,24 @@ package body Osint.C is\n \n    function Create_Auxiliary_File\n      (Src    : File_Name_Type;\n-      Suffix : String)\n-      return   File_Name_Type;\n+      Suffix : String) return File_Name_Type;\n    --  Common processing for Creat_Repinfo_File and Create_Debug_File.\n    --  Src is the file name used to create the required output file and\n    --  Suffix is the desired suffic (dg/rep for debug/repinfo file).\n \n    procedure Set_Library_Info_Name;\n    --  Sets a default ali file name from the main compiler source name.\n    --  This is used by Create_Output_Library_Info, and by the version of\n-   --  Read_Library_Info that takes a default file name.\n+   --  Read_Library_Info that takes a default file name. The name is in\n+   --  Name_Buffer (with length in Name_Len) on return from the call\n \n    ----------------------\n    -- Close_Debug_File --\n    ----------------------\n \n    procedure Close_Debug_File is\n       Status : Boolean;\n+\n    begin\n       Close (Output_FD, Status);\n \n@@ -76,6 +77,7 @@ package body Osint.C is\n \n    procedure Close_Output_Library_Info is\n       Status : Boolean;\n+\n    begin\n       Close (Output_FD, Status);\n \n@@ -92,6 +94,7 @@ package body Osint.C is\n \n    procedure Close_Repinfo_File is\n       Status : Boolean;\n+\n    begin\n       Close (Output_FD, Status);\n \n@@ -108,8 +111,7 @@ package body Osint.C is\n \n    function Create_Auxiliary_File\n      (Src    : File_Name_Type;\n-      Suffix : String)\n-      return   File_Name_Type\n+      Suffix : String) return   File_Name_Type\n    is\n       Result : File_Name_Type;\n \n@@ -256,18 +258,36 @@ package body Osint.C is\n       --  To compare them, remove file name directories and extensions.\n \n       if Output_Object_File_Name /= null then\n+\n          --  Make sure there is a dot at Dot_Index. This may not be the case\n          --  if the source file name has no extension.\n \n          Name_Buffer (Dot_Index) := '.';\n \n+         --  If we are in multiple unit per file mode, then add ~nnn\n+         --  extension to the name before doing the comparison.\n+\n+         if Multiple_Unit_Index /= 0 then\n+            declare\n+               Exten : constant String := Name_Buffer (Dot_Index .. Name_Len);\n+            begin\n+               Name_Len := Dot_Index - 1;\n+               Add_Char_To_Name_Buffer ('~');\n+               Add_Nat_To_Name_Buffer (Multiple_Unit_Index);\n+               Dot_Index := Name_Len + 1;\n+               Add_Str_To_Name_Buffer (Exten);\n+            end;\n+         end if;\n+\n+         --  Remove extension preparing to replace it\n+\n          declare\n             Name : constant String  := Name_Buffer (1 .. Dot_Index);\n             Len  : constant Natural := Dot_Index;\n \n          begin\n-            Name_Buffer (1 .. Output_Object_File_Name'Length)\n-               := Output_Object_File_Name.all;\n+            Name_Buffer (1 .. Output_Object_File_Name'Length) :=\n+              Output_Object_File_Name.all;\n             Dot_Index := 0;\n \n             for J in reverse Output_Object_File_Name'Range loop\n@@ -277,8 +297,11 @@ package body Osint.C is\n                end if;\n             end loop;\n \n+            --  Dot_Index should be zero now (we check for extension elsewhere)\n+\n             pragma Assert (Dot_Index /= 0);\n-            --  We check for the extension elsewhere\n+\n+            --  Check name of object file is what we expect\n \n             if Name /= Name_Buffer (Dot_Index - Len + 1 .. Dot_Index) then\n                Fail (\"incorrect object file name\");"}, {"sha": "fcf4e13289d0f69c4a9ff06fc22a02312f755c2d", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -750,13 +750,11 @@ package body Osint is\n       return Name_Enter;\n    end Executable_Name;\n \n-   -------------------------\n+   -----------------------\n    -- Executable_Prefix --\n-   -------------------------\n+   -----------------------\n \n    function Executable_Prefix return String_Ptr is\n-      Exec_Name : String (1 .. Len_Arg (0));\n-\n       function Get_Install_Dir (Exec : String) return String_Ptr;\n       --  S is the executable name preceeded by the absolute or relative\n       --  path, e.g. \"c:\\usr\\bin\\gcc.exe\" or \"..\\bin\\gcc\".\n@@ -790,21 +788,25 @@ package body Osint is\n    --  Start of processing for Executable_Prefix\n \n    begin\n-      Osint.Fill_Arg (Exec_Name'Address, 0);\n+      if Exec_Name = null then\n+         Exec_Name := new String (1 .. Len_Arg (0));\n+         Osint.Fill_Arg (Exec_Name (1)'Address, 0);\n+      end if;\n \n       --  First determine if a path prefix was placed in front of the\n       --  executable name.\n \n       for J in reverse Exec_Name'Range loop\n          if Is_Directory_Separator (Exec_Name (J)) then\n-            return Get_Install_Dir (Exec_Name);\n+            return Get_Install_Dir (Exec_Name.all);\n          end if;\n       end loop;\n \n       --  If we come here, the user has typed the executable name with no\n       --  directory prefix.\n \n-      return Get_Install_Dir (GNAT.OS_Lib.Locate_Exec_On_Path (Exec_Name).all);\n+      return Get_Install_Dir\n+        (GNAT.OS_Lib.Locate_Exec_On_Path (Exec_Name.all).all);\n    end Executable_Prefix;\n \n    ------------------\n@@ -1390,27 +1392,26 @@ package body Osint is\n    -------------------\n \n    function Lib_File_Name\n-     (Source_File : File_Name_Type)\n-      return        File_Name_Type\n+     (Source_File : File_Name_Type;\n+      Munit_Index : Nat := 0) return File_Name_Type\n    is\n-      Fptr : Natural;\n-      --  Pointer to location to set extension in place\n-\n    begin\n       Get_Name_String (Source_File);\n-      Fptr := Name_Len + 1;\n \n       for J in reverse 2 .. Name_Len loop\n          if Name_Buffer (J) = '.' then\n-            Fptr := J;\n+            Name_Len := J - 1;\n             exit;\n          end if;\n       end loop;\n \n-      Name_Buffer (Fptr) := '.';\n-      Name_Buffer (Fptr + 1 .. Fptr + ALI_Suffix'Length) := ALI_Suffix.all;\n-      Name_Buffer (Fptr + ALI_Suffix'Length + 1) := ASCII.NUL;\n-      Name_Len := Fptr + ALI_Suffix'Length;\n+      if Munit_Index /= 0 then\n+         Add_Char_To_Name_Buffer ('~');\n+         Add_Nat_To_Name_Buffer (Munit_Index);\n+      end if;\n+\n+      Add_Char_To_Name_Buffer ('.');\n+      Add_Str_To_Name_Buffer (ALI_Suffix.all);\n       return Name_Find;\n    end Lib_File_Name;\n "}, {"sha": "0e87e9a4948310203fe709d65f9c3322ea90d2d5", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -235,7 +235,7 @@ package Osint is\n \n    procedure Get_Next_Dir_In_Path_Init\n      (Search_Path : String_Access);\n-   function  Get_Next_Dir_In_Path\n+   function Get_Next_Dir_In_Path\n      (Search_Path : String_Access) return String_Access;\n    --  These subprograms are used to parse out the directory names in a\n    --  search path specified by a Search_Path argument. The procedure\n@@ -271,11 +271,14 @@ package Osint is\n    --  directories. These files, located in Sdefault.Search_Dir_Prefix, do\n    --  not necessarily exist.\n \n+   Exec_Name : String_Ptr;\n+   --  Executable name as typed by the user (used to compute the\n+   --  executable prefix).\n+\n    function Read_Default_Search_Dirs\n      (Search_Dir_Prefix       : String_Access;\n       Search_File             : String_Access;\n-      Search_Dir_Default_Name : String_Access)\n-      return                    String_Access;\n+      Search_Dir_Default_Name : String_Access) return String_Access;\n    --  Read and return the default search directories from the file located\n    --  in Search_Dir_Prefix (as modified by update_path) and named Search_File.\n    --  If no such file exists or an error occurs then instead return the\n@@ -480,11 +483,15 @@ package Osint is\n    --  file directory lookup penalty is incurred every single time this\n    --  routine is called.\n \n-   function Lib_File_Name (Source_File : File_Name_Type) return File_Name_Type;\n+   function Lib_File_Name\n+     (Source_File : File_Name_Type;\n+      Munit_Index : Nat := 0) return File_Name_Type;\n    --  Given the name of a source file, returns the name of the corresponding\n    --  library information file. This may be the name of the object file, or\n    --  of a separate file used to store the library information. In either case\n    --  the returned result is suitable for use in a call to Read_Library_Info.\n+   --  The Munit_Index is the unit index in multiple unit per file mode, or\n+   --  zero in normal single unit per file mode (used to add ~nnn suffix).\n    --  Note: this subprogram is in this section because it is used by the\n    --  compiler to determine the proper library information names to be placed\n    --  in the generated library information file."}, {"sha": "985d9e328cc8c8e9430eed7fd470cd7ba7d28070", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -301,7 +301,6 @@ package body Ch10 is\n          else\n             if Operating_Mode = Check_Syntax and then Token = Tok_EOF then\n                Error_Msg_SC (\"?file contains no compilation units\");\n-\n             else\n                Error_Msg_SC (\"compilation unit expected\");\n                Cunit_Error_Flag := True;\n@@ -333,15 +332,10 @@ package body Ch10 is\n          --  contained subprogram bodies), by knowing that that the file we\n          --  are compiling has a name that requires a body to be found.\n \n-         --  However, we do not do this check if we are operating in syntax\n-         --  checking only mode, because in that case there may be multiple\n-         --  units in the same file, and the file name is not a reliable guide.\n-\n          Save_Scan_State (Scan_State);\n          Scan; -- past Package keyword\n \n          if Token /= Tok_Body\n-           and then Operating_Mode /= Check_Syntax\n            and then\n              Get_Expected_Unit_Type\n                (File_Name (Current_Source_File)) = Expect_Body\n@@ -665,13 +659,26 @@ package body Ch10 is\n          elsif Operating_Mode = Check_Syntax then\n             return Comp_Unit_Node;\n \n+         --  We also allow multiple units if we are in multiple unit mode\n+\n+         elsif Multiple_Unit_Index /= 0 then\n+\n+            --  Skip tokens to end of file, so that the -gnatl listing\n+            --  will be complete in this situation, but no need to parse\n+            --  the remaining units.\n+\n+            while Token /= Tok_EOF loop\n+               Scan;\n+            end loop;\n+\n+            return Comp_Unit_Node;\n+\n          --  Otherwise we have an error. We suppress the error message\n          --  if we already had a fatal error, since this stops junk\n          --  cascaded messages in some situations.\n \n          else\n             if not Fatal_Error (Current_Source_Unit) then\n-\n                if Token in Token_Class_Cunit then\n                   Error_Msg_SC\n                     (\"end of file expected, \" &\n@@ -706,7 +713,6 @@ package body Ch10 is\n       when Error_Resync =>\n          Set_Fatal_Error (Current_Source_Unit);\n          return Error;\n-\n    end P_Compilation_Unit;\n \n    --------------------------"}, {"sha": "7940fe4c5056657e0ba712936cd12a20965ddd66", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 169, "deletions": 46, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -387,7 +387,8 @@ package body Ch3 is\n       loop\n          case Token is\n \n-            when Tok_Access =>\n+            when Tok_Access |\n+                 Tok_Not    => --  Ada 0Y (AI-231)\n                Typedef_Node := P_Access_Type_Definition;\n                TF_Semicolon;\n                exit;\n@@ -727,8 +728,8 @@ package body Ch3 is\n    --  Error recovery: can raise Error_Resync\n \n    function P_Subtype_Declaration return Node_Id is\n-      Decl_Node : Node_Id;\n-\n+      Decl_Node        : Node_Id;\n+      Not_Null_Present : Boolean := False;\n    begin\n       Decl_Node := New_Node (N_Subtype_Declaration, Token_Ptr);\n       Scan; -- past SUBTYPE\n@@ -740,7 +741,13 @@ package body Ch3 is\n          Scan; -- past NEW\n       end if;\n \n-      Set_Subtype_Indication (Decl_Node, P_Subtype_Indication);\n+      if Extensions_Allowed then                      --  Ada 0Y (AI-231)\n+         Not_Null_Present := P_Null_Exclusion;\n+         Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n+      end if;\n+\n+      Set_Subtype_Indication\n+        (Decl_Node, P_Subtype_Indication (Not_Null_Present));\n       TF_Semicolon;\n       return Decl_Node;\n    end P_Subtype_Declaration;\n@@ -749,17 +756,43 @@ package body Ch3 is\n    -- 3.2.2  Subtype Indication --\n    -------------------------------\n \n-   --  SUBTYPE_INDICATION ::= SUBTYPE_MARK [CONSTRAINT]\n+   --  SUBTYPE_INDICATION ::=\n+   --    [NOT NULL] SUBTYPE_MARK [CONSTRAINT]\n \n    --  Error recovery: can raise Error_Resync\n \n-   function P_Subtype_Indication return Node_Id is\n-      Type_Node : Node_Id;\n+   function P_Null_Exclusion return Boolean is\n+   begin\n+      if Token /= Tok_Not then\n+         return False;\n+\n+      else\n+         if not Extensions_Allowed then\n+            Error_Msg_SP\n+              (\"null-excluding access is an Ada 0Y extension\");\n+            Error_Msg_SP (\"\\unit must be compiled with -gnatX switch\");\n+         end if;\n+\n+         Scan; --  past NOT\n+\n+         if Token = Tok_Null then\n+            Scan; --  past NULL\n+         else\n+            Error_Msg_SP (\"(Ada 0Y) missing NULL\");\n+         end if;\n+\n+         return True;\n+      end if;\n+   end P_Null_Exclusion;\n+\n+   function P_Subtype_Indication\n+     (Not_Null_Present : Boolean := False) return Node_Id is\n+      Type_Node        : Node_Id;\n \n    begin\n       if Token = Tok_Identifier or else Token = Tok_Operator_Symbol then\n          Type_Node := P_Subtype_Mark;\n-         return P_Subtype_Indication (Type_Node);\n+         return P_Subtype_Indication (Type_Node, Not_Null_Present);\n \n       else\n          --  Check for error of using record definition and treat it nicely,\n@@ -782,16 +815,22 @@ package body Ch3 is\n \n    --  Error recovery: can raise Error_Resync\n \n-   function P_Subtype_Indication (Subtype_Mark : Node_Id) return Node_Id is\n-      Indic_Node  : Node_Id;\n-      Constr_Node : Node_Id;\n+   function P_Subtype_Indication\n+     (Subtype_Mark     : Node_Id;\n+      Not_Null_Present : Boolean := False) return Node_Id is\n+      Indic_Node       : Node_Id;\n+      Constr_Node      : Node_Id;\n \n    begin\n       Constr_Node := P_Constraint_Opt;\n \n       if No (Constr_Node) then\n          return Subtype_Mark;\n       else\n+         if Not_Null_Present then\n+            Error_Msg_SP (\"(Ada 0Y) constrained null-exclusion not allowed\");\n+         end if;\n+\n          Indic_Node := New_Node (N_Subtype_Indication, Sloc (Subtype_Mark));\n          Set_Subtype_Mark (Indic_Node, Check_Subtype_Mark (Subtype_Mark));\n          Set_Constraint (Indic_Node, Constr_Node);\n@@ -1017,16 +1056,17 @@ package body Ch3 is\n       Done    : out Boolean;\n       In_Spec : Boolean)\n    is\n-      Acc_Node   : Node_Id;\n-      Decl_Node  : Node_Id;\n-      Type_Node  : Node_Id;\n-      Ident_Sloc : Source_Ptr;\n-      Scan_State : Saved_Scan_State;\n-      List_OK    : Boolean := True;\n-      Ident      : Nat;\n-      Init_Expr  : Node_Id;\n-      Init_Loc   : Source_Ptr;\n-      Con_Loc    : Source_Ptr;\n+      Acc_Node         : Node_Id;\n+      Decl_Node        : Node_Id;\n+      Type_Node        : Node_Id;\n+      Ident_Sloc       : Source_Ptr;\n+      Scan_State       : Saved_Scan_State;\n+      List_OK          : Boolean := True;\n+      Ident            : Nat;\n+      Init_Expr        : Node_Id;\n+      Init_Loc         : Source_Ptr;\n+      Con_Loc          : Source_Ptr;\n+      Not_Null_Present : Boolean := False;\n \n       Idents : array (Int range 1 .. 4096) of Entity_Id;\n       --  Used to save identifiers in the identifier list. The upper bound\n@@ -1241,13 +1281,19 @@ package body Ch3 is\n             Init_Expr := Init_Expr_Opt;\n \n             if Present (Init_Expr) then\n+               if Not_Null_Present then\n+                  Error_Msg_SP (\"(Ada 0Y) null-exclusion not allowed in \"\n+                                & \"numeric expression\");\n+               end if;\n+\n                Decl_Node := New_Node (N_Number_Declaration, Ident_Sloc);\n                Set_Expression (Decl_Node, Init_Expr);\n \n             --  Constant object declaration\n \n             else\n                Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n+               Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n                Set_Constant_Present (Decl_Node, True);\n \n                if Token_Name = Name_Aliased then\n@@ -1264,8 +1310,15 @@ package body Ch3 is\n                if Token = Tok_Array then\n                   Set_Object_Definition\n                     (Decl_Node, P_Array_Type_Definition);\n+\n                else\n-                  Set_Object_Definition (Decl_Node, P_Subtype_Indication);\n+                  if Extensions_Allowed then              --  Ada 0Y (AI-231)\n+                     Not_Null_Present := P_Null_Exclusion;\n+                     Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n+                  end if;\n+\n+                  Set_Object_Definition (Decl_Node,\n+                     P_Subtype_Indication (Not_Null_Present));\n                end if;\n \n                if Token = Tok_Renames then\n@@ -1298,6 +1351,7 @@ package body Ch3 is\n             Scan; -- past ALIASED\n             Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n             Set_Aliased_Present (Decl_Node, True);\n+            Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n \n             if Token = Tok_Constant then\n                Scan; -- past CONSTANT\n@@ -1307,8 +1361,15 @@ package body Ch3 is\n             if Token = Tok_Array then\n                Set_Object_Definition\n                  (Decl_Node, P_Array_Type_Definition);\n+\n             else\n-               Set_Object_Definition (Decl_Node, P_Subtype_Indication);\n+               if Extensions_Allowed then               --  Ada 0Y (AI-231)\n+                  Not_Null_Present := P_Null_Exclusion;\n+                  Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n+               end if;\n+\n+               Set_Object_Definition (Decl_Node,\n+                  P_Subtype_Indication (Not_Null_Present));\n             end if;\n \n          --  Array case\n@@ -1344,11 +1405,20 @@ package body Ch3 is\n          --  Subtype indication case\n \n          else\n+            if Extensions_Allowed then                   --  Ada 0Y (AI-231)\n+               Not_Null_Present := P_Null_Exclusion;\n+            end if;\n+\n             Type_Node := P_Subtype_Mark;\n \n             --  Object renaming declaration\n \n             if Token_Is_Renames then\n+               if Not_Null_Present then\n+                  Error_Msg_SP\n+                    (\"(Ada 0Y) null-exclusion not allowed in renamings\");\n+               end if;\n+\n                No_List;\n                Decl_Node :=\n                  New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n@@ -1359,8 +1429,10 @@ package body Ch3 is\n \n             else\n                Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n+               Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n                Set_Object_Definition\n-                 (Decl_Node, P_Subtype_Indication (Type_Node));\n+                 (Decl_Node,\n+                  P_Subtype_Indication (Type_Node, Not_Null_Present));\n \n                --  RENAMES at this point means that we had the combination of\n                --  a constraint on the Type_Node and renames, which is illegal\n@@ -1466,9 +1538,9 @@ package body Ch3 is\n    --  Error recovery: can raise Error_Resync;\n \n    function P_Derived_Type_Def_Or_Private_Ext_Decl return Node_Id is\n-      Typedef_Node  : Node_Id;\n-      Typedecl_Node : Node_Id;\n-\n+      Typedef_Node     : Node_Id;\n+      Typedecl_Node    : Node_Id;\n+      Not_Null_Present : Boolean := False;\n    begin\n       Typedef_Node := New_Node (N_Derived_Type_Definition, Token_Ptr);\n       T_New;\n@@ -1478,7 +1550,13 @@ package body Ch3 is\n          Scan;\n       end if;\n \n-      Set_Subtype_Indication (Typedef_Node, P_Subtype_Indication);\n+      if Extensions_Allowed then                         --  Ada 0Y (AI-231)\n+         Not_Null_Present := P_Null_Exclusion;\n+         Set_Null_Exclusion_Present (Typedef_Node, Not_Null_Present);\n+      end if;\n+\n+      Set_Subtype_Indication (Typedef_Node,\n+         P_Subtype_Indication (Not_Null_Present));\n \n       --  Deal with record extension, note that we assume that a WITH is\n       --  missing in the case of \"type X is new Y record ...\" or in the\n@@ -2045,11 +2123,12 @@ package body Ch3 is\n    --  Error recovery: can raise Error_Resync\n \n    function P_Array_Type_Definition return Node_Id is\n-      Array_Loc    : Source_Ptr;\n-      CompDef_Node : Node_Id;\n-      Def_Node     : Node_Id;\n-      Subs_List    : List_Id;\n-      Scan_State   : Saved_Scan_State;\n+      Array_Loc        : Source_Ptr;\n+      CompDef_Node     : Node_Id;\n+      Def_Node         : Node_Id;\n+      Not_Null_Present : Boolean := False;\n+      Subs_List        : List_Id;\n+      Scan_State       : Saved_Scan_State;\n \n    begin\n       Array_Loc := Token_Ptr;\n@@ -2134,7 +2213,13 @@ package body Ch3 is\n             Scan; -- past ALIASED\n          end if;\n \n-         Set_Subtype_Indication (CompDef_Node, P_Subtype_Indication);\n+         if Extensions_Allowed then                       --  Ada 0Y (AI-231)\n+            Not_Null_Present := P_Null_Exclusion;\n+            Set_Null_Exclusion_Present (CompDef_Node, Not_Null_Present);\n+         end if;\n+\n+         Set_Subtype_Indication (CompDef_Node,\n+            P_Subtype_Indication (Not_Null_Present));\n       end if;\n \n       Set_Component_Definition (Def_Node, CompDef_Node);\n@@ -2315,6 +2400,7 @@ package body Ch3 is\n       Ident_Sloc         : Source_Ptr;\n       Scan_State         : Saved_Scan_State;\n       Num_Idents         : Nat;\n+      Not_Null_Present   : Boolean;\n       Ident              : Nat;\n \n       Idents : array (Int range 1 .. 4096) of Entity_Id;\n@@ -2358,6 +2444,8 @@ package body Ch3 is\n                  New_Node (N_Discriminant_Specification, Ident_Sloc);\n                Set_Defining_Identifier (Specification_Node, Idents (Ident));\n \n+               Not_Null_Present := P_Null_Exclusion;       --  Ada 0Y (AI-231)\n+\n                if Token = Tok_Access then\n                   if Ada_83 then\n                      Error_Msg_SC\n@@ -2366,10 +2454,15 @@ package body Ch3 is\n \n                   Set_Discriminant_Type\n                     (Specification_Node, P_Access_Definition);\n+                  Set_Null_Exclusion_Present               --  Ada 0Y (AI-231)\n+                    (Discriminant_Type (Specification_Node),\n+                     Not_Null_Present);\n                else\n                   Set_Discriminant_Type\n                     (Specification_Node, P_Subtype_Mark);\n                   No_Constraint;\n+                  Set_Null_Exclusion_Present               --  Ada 0Y (AI-231)\n+                    (Specification_Node, Not_Null_Present);\n                end if;\n \n                Set_Expression\n@@ -2782,12 +2875,13 @@ package body Ch3 is\n    --  items, do we need to add this capability sometime in the future ???\n \n    procedure P_Component_Items (Decls : List_Id) is\n-      CompDef_Node : Node_Id;\n-      Decl_Node    : Node_Id;\n-      Scan_State   : Saved_Scan_State;\n-      Num_Idents   : Nat;\n-      Ident        : Nat;\n-      Ident_Sloc   : Source_Ptr;\n+      CompDef_Node     : Node_Id;\n+      Decl_Node        : Node_Id;\n+      Scan_State       : Saved_Scan_State;\n+      Not_Null_Present : Boolean := False;\n+      Num_Idents       : Nat;\n+      Ident            : Nat;\n+      Ident_Sloc       : Source_Ptr;\n \n       Idents : array (Int range 1 .. 4096) of Entity_Id;\n       --  This array holds the list of defining identifiers. The upper bound\n@@ -2844,7 +2938,7 @@ package body Ch3 is\n                if not Extensions_Allowed then\n                   Error_Msg_SP\n                     (\"Generalized use of anonymous access types \" &\n-                     \"is an Ada0X extension\");\n+                     \"is an Ada 0Y extension\");\n                   Error_Msg_SP (\"\\unit must be compiled with -gnatX switch\");\n                end if;\n \n@@ -2870,7 +2964,13 @@ package body Ch3 is\n                   raise Error_Resync;\n                end if;\n \n-               Set_Subtype_Indication (CompDef_Node, P_Subtype_Indication);\n+               if Extensions_Allowed then                 --  Ada 0Y (AI-231)\n+                  Not_Null_Present := P_Null_Exclusion;\n+                  Set_Null_Exclusion_Present (CompDef_Node, Not_Null_Present);\n+               end if;\n+\n+               Set_Subtype_Indication (CompDef_Node,\n+                  P_Subtype_Indication (Not_Null_Present));\n             end if;\n \n             Set_Component_Definition (Decl_Node, CompDef_Node);\n@@ -3134,9 +3234,10 @@ package body Ch3 is\n    --  Error recovery: can raise Error_Resync\n \n    function P_Access_Type_Definition return Node_Id is\n-      Prot_Flag     : Boolean;\n-      Access_Loc    : Source_Ptr;\n-      Type_Def_Node : Node_Id;\n+      Prot_Flag        : Boolean;\n+      Access_Loc       : Source_Ptr;\n+      Not_Null_Present : Boolean := False;\n+      Type_Def_Node    : Node_Id;\n \n       procedure Check_Junk_Subprogram_Name;\n       --  Used in access to subprogram definition cases to check for an\n@@ -3163,6 +3264,10 @@ package body Ch3 is\n    --  Start of processing for P_Access_Type_Definition\n \n    begin\n+      if Extensions_Allowed then                          --  Ada 0Y (AI-231)\n+         Not_Null_Present := P_Null_Exclusion;\n+      end if;\n+\n       Access_Loc := Token_Ptr;\n       Scan; -- past ACCESS\n \n@@ -3187,6 +3292,7 @@ package body Ch3 is\n          end if;\n \n          Type_Def_Node := New_Node (N_Access_Procedure_Definition, Access_Loc);\n+         Set_Null_Exclusion_Present (Type_Def_Node, Not_Null_Present);\n          Scan; -- past PROCEDURE\n          Check_Junk_Subprogram_Name;\n          Set_Parameter_Specifications (Type_Def_Node, P_Parameter_Profile);\n@@ -3198,6 +3304,7 @@ package body Ch3 is\n          end if;\n \n          Type_Def_Node := New_Node (N_Access_Function_Definition, Access_Loc);\n+         Set_Null_Exclusion_Present (Type_Def_Node, Not_Null_Present);\n          Scan; -- past FUNCTION\n          Check_Junk_Subprogram_Name;\n          Set_Parameter_Specifications (Type_Def_Node, P_Parameter_Profile);\n@@ -3209,6 +3316,7 @@ package body Ch3 is\n       else\n          Type_Def_Node :=\n            New_Node (N_Access_To_Object_Definition, Access_Loc);\n+         Set_Null_Exclusion_Present (Type_Def_Node, Not_Null_Present);\n \n          if Token = Tok_All or else Token = Tok_Constant then\n             if Ada_83 then\n@@ -3225,7 +3333,8 @@ package body Ch3 is\n             Scan; -- past ALL or CONSTANT\n          end if;\n \n-         Set_Subtype_Indication (Type_Def_Node, P_Subtype_Indication);\n+         Set_Subtype_Indication (Type_Def_Node,\n+            P_Subtype_Indication (Not_Null_Present));\n       end if;\n \n       return Type_Def_Node;\n@@ -3265,6 +3374,20 @@ package body Ch3 is\n    begin\n       Def_Node := New_Node (N_Access_Definition, Token_Ptr);\n       Scan; -- past ACCESS\n+\n+      --  Ada 0Y (AI-231): ACCESS [general_access_modifier] subtype_mark\n+\n+      if Extensions_Allowed then\n+         if Token = Tok_All then\n+            Scan; -- past ALL\n+            Set_All_Present (Def_Node);\n+\n+         elsif Token = Tok_Constant then\n+            Scan; -- past CONSTANT\n+            Set_Constant_Present (Def_Node);\n+         end if;\n+      end if;\n+\n       Set_Subtype_Mark (Def_Node, P_Subtype_Mark);\n       No_Constraint;\n       return Def_Node;"}, {"sha": "b56c8b0b6c836dc5f290780f0a94fb679bf468ab", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -2328,19 +2328,35 @@ package body Ch4 is\n    --  Error recovery: can raise Error_Resync\n \n    function P_Allocator return Node_Id is\n-      Alloc_Node  : Node_Id;\n-      Type_Node   : Node_Id;\n+      Alloc_Node             : Node_Id;\n+      Type_Node              : Node_Id;\n+      Null_Exclusion_Present : Boolean;\n \n    begin\n       Alloc_Node := New_Node (N_Allocator, Token_Ptr);\n       T_New;\n+\n+      --  Scan Null_Exclusion if present (Ada 0Y (AI-231))\n+\n+      if Extensions_Allowed then\n+         Null_Exclusion_Present := P_Null_Exclusion;\n+         Set_Null_Exclusion_Present (Alloc_Node, Null_Exclusion_Present);\n+\n+      --  If Ada 95, null exclusion never present\n+\n+      else\n+         Null_Exclusion_Present := False;\n+      end if;\n+\n       Type_Node := P_Subtype_Mark_Resync;\n \n       if Token = Tok_Apostrophe then\n          Scan; -- past apostrophe\n          Set_Expression (Alloc_Node, P_Qualified_Expression (Type_Node));\n       else\n-         Set_Expression (Alloc_Node, P_Subtype_Indication (Type_Node));\n+         Set_Expression\n+           (Alloc_Node,\n+            P_Subtype_Indication (Type_Node, Null_Exclusion_Present));\n       end if;\n \n       return Alloc_Node;"}, {"sha": "964a9a60aa7f306fd909f760f90a352678fa9f18", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -857,6 +857,7 @@ package body Ch6 is\n       Num_Idents         : Nat;\n       Ident              : Nat;\n       Ident_Sloc         : Source_Ptr;\n+      Not_Null_Present   : Boolean := False;\n \n       Idents : array (Int range 1 .. 4096) of Entity_Id;\n       --  This array holds the list of defining identifiers. The upper bound\n@@ -865,7 +866,6 @@ package body Ch6 is\n \n    begin\n       Specification_List := New_List;\n-\n       Specification_Loop : loop\n          begin\n             if Token = Tok_Pragma then\n@@ -953,8 +953,12 @@ package body Ch6 is\n                Specification_Node :=\n                  New_Node (N_Parameter_Specification, Ident_Sloc);\n                Set_Defining_Identifier (Specification_Node, Idents (Ident));\n+               Not_Null_Present := P_Null_Exclusion;     --  Ada 0Y (AI-231)\n \n                if Token = Tok_Access then\n+                  Set_Null_Exclusion_Present\n+                    (Specification_Node, Not_Null_Present);\n+\n                   if Ada_83 then\n                      Error_Msg_SC (\"(Ada 83) access parameters not allowed\");\n                   end if;\n@@ -963,7 +967,18 @@ package body Ch6 is\n                     (Specification_Node, P_Access_Definition);\n \n                else\n-                  P_Mode (Specification_Node);\n+                  if Token = Tok_In or else Token = Tok_Out then\n+                     if Not_Null_Present then\n+                        Error_Msg_SC\n+                          (\"ACCESS must be placed after the parameter mode\");\n+                     end if;\n+\n+                     P_Mode (Specification_Node);\n+                     Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231)\n+                  end if;\n+\n+                  Set_Null_Exclusion_Present\n+                    (Specification_Node, Not_Null_Present);\n \n                   if Token = Tok_Procedure\n                        or else"}, {"sha": "30dd830a51b372a78f5dd211780e32e9ae0e03df", "filename": "gcc/ada/par-load.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -150,14 +150,17 @@ begin\n    --  Next step, make sure that the unit name matches the file name\n    --  and issue a warning message if not. We only output this for the\n    --  main unit, since for other units it is more serious and is\n-   --  caught in a separate test below.\n+   --  caught in a separate test below. We also inhibit the message in\n+   --  multiple unit per file mode, because in this case the relation\n+   --  between file name and unit name is broken.\n \n    File_Name :=\n      Get_File_Name\n        (Unit_Name (Cur_Unum),\n         Subunit => Nkind (Unit (Cunit (Cur_Unum))) = N_Subunit);\n \n    if Cur_Unum = Main_Unit\n+     and then Multiple_Unit_Index = 0\n      and then File_Name /= Unit_File_Name (Cur_Unum)\n      and then (File_Names_Case_Sensitive\n                 or not Same_File_Name_Except_For_Case\n@@ -338,7 +341,6 @@ begin\n       if Unum /= No_Unit then\n          Set_Library_Unit (Curunit, Cunit (Unum));\n       end if;\n-\n    end if;\n \n    --  Now we load with'ed units, with style/validity checks turned off\n@@ -352,7 +354,6 @@ begin\n \n    Context_Node := First (Context_Items (Curunit));\n    while Present (Context_Node) loop\n-\n       if Nkind (Context_Node) = N_With_Clause then\n          With_Node := Context_Node;\n          Spec_Name := Get_Unit_Name (With_Node);"}, {"sha": "23f280c4abaa8bf646378c1aa71f420fc8bd5a2b", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -360,25 +360,27 @@ begin\n       --  These two pragmas have the same syntax and semantics.\n       --  There are five forms of these pragmas:\n \n-      --  pragma Source_File_Name (\n+      --  pragma Source_File_Name[_Project] (\n       --    [UNIT_NAME      =>] unit_NAME,\n-      --     BODY_FILE_NAME =>  STRING_LITERAL);\n+      --     BODY_FILE_NAME =>  STRING_LITERAL\n+      --    [, [INDEX =>] INTEGER_LITERAL]);\n \n-      --  pragma Source_File_Name (\n+      --  pragma Source_File_Name[_Project] (\n       --    [UNIT_NAME      =>] unit_NAME,\n-      --     SPEC_FILE_NAME =>  STRING_LITERAL);\n+      --     SPEC_FILE_NAME =>  STRING_LITERAL\n+      --    [, [INDEX =>] INTEGER_LITERAL]);\n \n-      --  pragma Source_File_Name (\n+      --  pragma Source_File_Name[_Project] (\n       --     BODY_FILE_NAME  => STRING_LITERAL\n       --  [, DOT_REPLACEMENT => STRING_LITERAL]\n       --  [, CASING          => CASING_SPEC]);\n \n-      --  pragma Source_File_Name (\n+      --  pragma Source_File_Name[_Project] (\n       --     SPEC_FILE_NAME  => STRING_LITERAL\n       --  [, DOT_REPLACEMENT => STRING_LITERAL]\n       --  [, CASING          => CASING_SPEC]);\n \n-      --  pragma Source_File_Name (\n+      --  pragma Source_File_Name[_Project] (\n       --     SUBUNIT_FILE_NAME  => STRING_LITERAL\n       --  [, DOT_REPLACEMENT    => STRING_LITERAL]\n       --  [, CASING             => CASING_SPEC]);\n@@ -410,6 +412,8 @@ begin\n             Dot   : String_Ptr;\n             Cas   : Casing_Type;\n             Nast  : Nat;\n+            Expr  : Node_Id;\n+            Index : Nat;\n \n             function Get_Fname (Arg : Node_Id) return Name_Id;\n             --  Process file name from unit name form of pragma\n@@ -520,7 +524,6 @@ begin\n          --  Source_File_Name_Project pragmas.\n \n          begin\n-\n             if Get_Pragma_Id (Pragma_Name) = Pragma_Source_File_Name then\n                if Project_File_In_Use = In_Use then\n                   Error_Msg\n@@ -536,7 +539,6 @@ begin\n                   Error_Msg\n                     (\"pragma Source_File_Name_Project should only be used \" &\n                      \"with a project file\", Pragma_Sloc);\n-\n                else\n                   Project_File_In_Use := In_Use;\n                end if;\n@@ -569,18 +571,43 @@ begin\n                   return Error;\n                end if;\n \n-               Check_Arg_Count (2);\n+               --  Process index argument if present\n+\n+               if Arg_Count = 3 then\n+                  Expr := Expression (Arg3);\n+\n+                  if Nkind (Expr) /= N_Integer_Literal\n+                    or else not UI_Is_In_Int_Range (Intval (Expr))\n+                    or else Intval (Expr) > 999\n+                    or else Intval (Expr) <= 0\n+                  then\n+                     Error_Msg\n+                       (\"pragma% index must be integer literal\" &\n+                        \" in range 1 .. 999\", Sloc (Expr));\n+                     raise Error_Resync;\n+                  else\n+                     Index := UI_To_Int (Intval (Expr));\n+                  end if;\n+\n+               --  No index argument present\n+\n+               else\n+                  Check_Arg_Count (2);\n+                  Index := 0;\n+               end if;\n \n                Check_Optional_Identifier (Arg1, Name_Unit_Name);\n                Unam := Get_Unit_Name (Expr1);\n \n                Check_Arg_Is_String_Literal (Arg2);\n \n                if Chars (Arg2) = Name_Spec_File_Name then\n-                  Set_File_Name (Get_Spec_Name (Unam), Get_Fname (Arg2));\n+                  Set_File_Name\n+                    (Get_Spec_Name (Unam), Get_Fname (Arg2), Index);\n \n                elsif Chars (Arg2) = Name_Body_File_Name then\n-                  Set_File_Name (Unam, Get_Fname (Arg2));\n+                  Set_File_Name\n+                    (Unam, Get_Fname (Arg2), Index);\n \n                else\n                   Error_Msg_N\n@@ -635,7 +662,6 @@ begin\n                --  Set defaults for Casing and Dot_Separator parameters\n \n                Cas := All_Lower_Case;\n-\n                Dot := new String'(\".\");\n \n                --  Process second and third arguments if present\n@@ -703,7 +729,6 @@ begin\n                  (\"file name required for first % pragma in file\",\n                   Pragma_Sloc);\n                raise Error_Resync;\n-\n             else\n                Fname := No_Name;\n             end if;"}, {"sha": "1a1d9750a96be951cac6ed096ba32d40738a0820", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 148, "deletions": 53, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,6 +46,10 @@ with Style;\n with Table;\n with Tbuild;   use Tbuild;\n \n+---------\n+-- Par --\n+---------\n+\n function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n    Num_Library_Units : Natural := 0;\n@@ -515,6 +519,10 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --  corresponding to their name, and return an ID value for the Node or\n    --  List that is created.\n \n+   -------------\n+   -- Par.Ch2 --\n+   -------------\n+\n    package Ch2 is\n       function P_Pragma                               return Node_Id;\n \n@@ -535,6 +543,10 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  Parses optional pragmas and appends them to the List\n    end Ch2;\n \n+   -------------\n+   -- Par.Ch3 --\n+   -------------\n+\n    package Ch3 is\n       Missing_Begin_Msg : Error_Msg_Id;\n       --  This variable is set by a call to P_Declarative_Part. Normally it\n@@ -560,7 +572,6 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Range_Or_Subtype_Mark                return Node_Id;\n       function P_Range_Constraint                     return Node_Id;\n       function P_Record_Definition                    return Node_Id;\n-      function P_Subtype_Indication                   return Node_Id;\n       function P_Subtype_Mark                         return Node_Id;\n       function P_Subtype_Mark_Resync                  return Node_Id;\n       function P_Unknown_Discriminant_Part_Opt        return Boolean;\n@@ -576,6 +587,15 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  treatment of errors in case a reserved word is scanned. See the\n       --  declaration of this type for details.\n \n+      function P_Null_Exclusion return Boolean;\n+      --  Ada 0Y (AI-231): Parse the null-excluding part. True indicates\n+      --  that the null-excluding part was present.\n+\n+      function P_Subtype_Indication\n+        (Not_Null_Present : Boolean := False) return Node_Id;\n+      --  Ada 0Y (AI-231): The flag Not_Null_Present indicates that the\n+      --  null-excluding part has been scanned out and it was present.\n+\n       function Init_Expr_Opt (P : Boolean := False) return Node_Id;\n       --  If an initialization expression is present (:= expression), then\n       --  it is scanned out and returned, otherwise Empty is returned if no\n@@ -590,17 +610,24 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  Token is known to be a declaration token (in Token_Class_Declk)\n       --  on entry, so there definition is a declaration to be scanned.\n \n-      function P_Subtype_Indication (Subtype_Mark : Node_Id) return Node_Id;\n+      function P_Subtype_Indication\n+        (Subtype_Mark     : Node_Id;\n+         Not_Null_Present : Boolean := False) return Node_Id;\n       --  This version of P_Subtype_Indication is called when the caller has\n       --  already scanned out the subtype mark which is passed as a parameter.\n+      --  Ada 0Y (AI-231): The flag Not_Null_Present indicates that the\n+      --  null-excluding part has been scanned out and it was present.\n \n       function P_Subtype_Mark_Attribute (Type_Node : Node_Id) return Node_Id;\n       --  Parse a subtype mark attribute. The caller has already parsed the\n       --  subtype mark, which is passed in as the argument, and has checked\n       --  that the current token is apostrophe.\n-\n    end Ch3;\n \n+   -------------\n+   -- Par.Ch4 --\n+   -------------\n+\n    package Ch4 is\n       function P_Aggregate                            return Node_Id;\n       function P_Expression                           return Node_Id;\n@@ -618,11 +645,13 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n          return         Node_Id;\n       --  This routine scans out a qualified expression when the caller has\n       --  already scanned out the name and apostrophe of the construct.\n-\n    end Ch4;\n \n-   package Ch5 is\n+   -------------\n+   -- Par.Ch5 --\n+   -------------\n \n+   package Ch5 is\n       function P_Statement_Name (Name_Node : Node_Id) return Node_Id;\n       --  Given a node representing a name (which is a call), converts it\n       --  to the syntactically corresponding procedure call statement.\n@@ -634,9 +663,12 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       procedure Parse_Decls_Begin_End (Parent : Node_Id);\n       --  Parses declarations and handled statement sequence, setting\n       --  fields of Parent node appropriately.\n-\n    end Ch5;\n \n+   -------------\n+   -- Par.Ch6 --\n+   -------------\n+\n    package Ch6 is\n       function P_Designator                           return Node_Id;\n       function P_Defining_Program_Unit_Name           return Node_Id;\n@@ -654,20 +686,31 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  PROCEDURE or FUNCTION. The parameter indicates which possible\n       --  possible kinds of construct (body, spec, instantiation etc.)\n       --  are permissible in the current context.\n-\n    end Ch6;\n \n+   -------------\n+   -- Par.Ch7 --\n+   -------------\n+\n    package Ch7 is\n       function P_Package (Pf_Flags : Pf_Rec) return Node_Id;\n       --  Scans out any construct starting with the keyword PACKAGE. The\n       --  parameter indicates which possible kinds of construct (body, spec,\n       --  instantiation etc.) are permissible in the current context.\n    end Ch7;\n \n+   -------------\n+   -- Par.Ch8 --\n+   -------------\n+\n    package Ch8 is\n       function P_Use_Clause                           return Node_Id;\n    end Ch8;\n \n+   -------------\n+   -- Par.Ch9 --\n+   -------------\n+\n    package Ch9 is\n       function P_Abort_Statement                      return Node_Id;\n       function P_Abortable_Part                       return Node_Id;\n@@ -681,6 +724,10 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Terminate_Alternative                return Node_Id;\n    end Ch9;\n \n+   --------------\n+   -- Par.Ch10 --\n+   --------------\n+\n    package Ch10 is\n       function P_Compilation_Unit                     return Node_Id;\n       --  Note: this function scans a single compilation unit, and\n@@ -692,8 +739,16 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  for end of file and there may be more compilation units to\n       --  scan. The caller can uniquely detect this situation by the\n       --  fact that Token is not set to Tok_EOF on return.\n+      --\n+      --  The Ignore parameter is normally set False. It is set True\n+      --  in multiple unit per file mode if we are skipping past a unit\n+      --  that we are not interested in.\n    end Ch10;\n \n+   --------------\n+   -- Par.Ch11 --\n+   --------------\n+\n    package Ch11 is\n       function P_Handled_Sequence_Of_Statements       return Node_Id;\n       function P_Raise_Statement                      return Node_Id;\n@@ -702,14 +757,21 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  Parses the partial construct EXCEPTION followed by a list of\n       --  exception handlers which appears in a number of productions,\n       --  and returns the list of exception handlers.\n-\n    end Ch11;\n \n+   --------------\n+   -- Par.Ch12 --\n+   --------------\n+\n    package Ch12 is\n       function P_Generic                              return Node_Id;\n       function P_Generic_Actual_Part_Opt              return List_Id;\n    end Ch12;\n \n+   --------------\n+   -- Par.Ch13 --\n+   --------------\n+\n    package Ch13 is\n       function P_Representation_Clause                return Node_Id;\n \n@@ -730,14 +792,13 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --    At clause is parsed by P_At_Clause (13.1)\n    --    Mod clause is parsed by P_Mod_Clause (13.5.1)\n \n-   ------------------\n-   -- End Handling --\n-   ------------------\n+   --------------\n+   -- Par.Endh --\n+   --------------\n \n    --  Routines for handling end lines, including scope recovery\n \n    package Endh is\n-\n       function Check_End return Boolean;\n       --  Called when an end sequence is required. In the absence of an error\n       --  situation, Token contains Tok_End on entry, but in a missing end\n@@ -765,12 +826,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  only be used in cases where the only appropriate terminator is end.\n       --  If Parent is non-empty, then if a correct END line is encountered,\n       --  the End_Label field of Parent is set appropriately.\n-\n    end Endh;\n \n-   ------------------------------------\n-   -- Resynchronization After Errors --\n-   ------------------------------------\n+   --------------\n+   -- Par.Sync --\n+   --------------\n \n    --  These procedures are used to resynchronize after errors. Following an\n    --  error which is not immediately locally recoverable, the exception\n@@ -783,7 +843,6 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --  Multiple_Errors_Per_Line is set in Options.\n \n    package Sync is\n-\n       procedure Resync_Choice;\n       --  Used if an error occurs scanning a choice. The scan pointer is\n       --  advanced to the next vertical bar, arrow, or semicolon, whichever\n@@ -828,12 +887,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       procedure Resync_Cunit;\n       --  Synchronize to next token which could be the start of a compilation\n       --  unit, or to the end of file token.\n-\n    end Sync;\n \n-   -------------------------\n-   -- Token Scan Routines --\n-   -------------------------\n+   --------------\n+   -- Par.Tchk --\n+   --------------\n \n    --  Routines to check for expected tokens\n \n@@ -900,15 +958,13 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       procedure TF_Semicolon;\n       procedure TF_Then;\n       procedure TF_Use;\n-\n    end Tchk;\n \n-   ----------------------\n-   -- Utility Routines --\n-   ----------------------\n+   --------------\n+   -- Par.Util --\n+   --------------\n \n    package Util is\n-\n       function Bad_Spelling_Of (T : Token_Type) return Boolean;\n       --  This function is called in an error situation. It checks if the\n       --  current token is an identifier whose name is a plausible bad\n@@ -1035,12 +1091,13 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n       function Token_Is_At_End_Of_Line return Boolean;\n       --  Determines if the current token is the last token on the line\n-\n    end Util;\n \n-   ---------------------------------------\n-   -- Specialized Syntax Check Routines --\n-   ---------------------------------------\n+   --------------\n+   -- Par.Prag --\n+   --------------\n+\n+   --  The processing for pragmas is split off from chapter 2\n \n    function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id;\n    --  This function is passed a tree for a pragma that has been scanned out.\n@@ -1059,9 +1116,9 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --  the scanning of the semicolon so that it will be scanned using the\n    --  settings from the Style_Checks pragma preceding it.\n \n-   -------------------------\n-   -- Subsidiary Routines --\n-   -------------------------\n+   --------------\n+   -- Par.Labl --\n+   --------------\n \n    procedure Labl;\n    --  This procedure creates implicit label declarations for all label that\n@@ -1071,6 +1128,10 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --  label is declared (e.g. a sequence of statements is not yet attached\n    --  to its containing scope at the point a label in the sequence is found)\n \n+   --------------\n+   -- Par.Load --\n+   --------------\n+\n    procedure Load;\n    --  This procedure loads all subsidiary units that are required by this\n    --  unit, including with'ed units, specs for bodies, and parents for child\n@@ -1125,14 +1186,10 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    procedure Labl is separate;\n    procedure Load is separate;\n \n-   ---------\n-   -- Par --\n-   ---------\n-\n---  This function is the parse routine called at the outer level. It parses\n---  the current compilation unit and adds implicit label declarations.\n+--  Start of processing for Par\n \n begin\n+\n    --  Deal with configuration pragmas case first\n \n    if Configuration_Pragmas then\n@@ -1194,13 +1251,12 @@ begin\n          --  that language defined units cannot be recompiled).\n \n          --  However, an exception is s-rpc, and its children. We test this\n-         --  by looking at the character after the minus, the rule is that\n-         --  System.RPC and its children are the only children in System\n-         --  whose second level name can start with the letter r.\n+         --  by looking at the characters after the minus. The rule is that\n+         --  only s-rpc and its children have names starting s-rp.\n \n          Get_Name_String (File_Name (Current_Source_File));\n \n-         if (Name_Len < 3 or else Name_Buffer (1 .. 3) /= \"s-r\")\n+         if (Name_Len < 5 or else Name_Buffer (1 .. 4) /= \"s-rp\")\n            and then Current_Source_Unit = Main_Unit\n            and then not GNAT_Mode\n            and then Operating_Mode = Generate_Code\n@@ -1209,10 +1265,12 @@ begin\n          end if;\n       end if;\n \n-      --  The following loop runs more than once only in syntax check mode\n-      --  where we allow multiple compilation units in the same file.\n+      --  The following loop runs more than once in syntax check mode\n+      --  where we allow multiple compilation units in the same file\n+      --  and in Multiple_Unit_Per_file mode where we skip units till\n+      --  we get to the unit we want.\n \n-      loop\n+      for Ucount in Pos loop\n          Set_Opt_Config_Switches\n            (Is_Internal_File_Name (File_Name (Current_Source_File)));\n \n@@ -1226,13 +1284,51 @@ begin\n          Last_Resync_Point := No_Location;\n \n          Label_List := New_Elmt_List;\n-         Discard_Node (P_Compilation_Unit);\n \n-         --  If we are not at an end of file, then this means that we are\n-         --  in syntax scan mode, and we can have another compilation unit,\n-         --  otherwise we will exit from the loop.\n+         --  If in multiple unit per file mode, skip past ignored unit\n+\n+         if Ucount < Multiple_Unit_Index then\n+\n+            --  We skip in syntax check only mode, since we don't want\n+            --  to do anything more than skip past the unit and ignore it.\n+            --  This causes processing like setting up a unit table entry\n+            --  to be skipped.\n+\n+            declare\n+               Save_Operating_Mode : constant Operating_Mode_Type :=\n+                                       Operating_Mode;\n+\n+            begin\n+               Operating_Mode := Check_Syntax;\n+               Discard_Node (P_Compilation_Unit);\n+               Operating_Mode := Save_Operating_Mode;\n+\n+               --  If we are at an end of file, and not yet at the right\n+               --  unit, then we have a fatal error. The unit is missing.\n+\n+               if Token = Tok_EOF then\n+                  Error_Msg_SC (\"file has too few compilation units\");\n+                  raise Unrecoverable_Error;\n+               end if;\n+            end;\n+\n+            --  Here if we are not skipping a file in multiple unit per file\n+            --  mode. Parse the unit that we are interested in. Note that in\n+            --  check syntax mode we are interested in all units in the file.\n+\n+         else\n+            Discard_Node (P_Compilation_Unit);\n+\n+            --  All done if at end of file\n+\n+            exit when Token = Tok_EOF;\n+\n+            --  If we are not at an end of file, it means we are in syntax\n+            --  check only mode, and we keep the loop going to parse all\n+            --  remaining units in the file.\n+\n+         end if;\n \n-         exit when Token = Tok_EOF;\n          Restore_Opt_Config_Switches (Save_Config_Switches);\n       end loop;\n \n@@ -1260,5 +1356,4 @@ begin\n       Set_Comes_From_Source_Default (False);\n       return Empty_List;\n    end if;\n-\n end Par;"}, {"sha": "6fdb3bba0e305c68a04e43c34a57fdbba919b046", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -365,6 +365,7 @@ package body Prj.Makr is\n                                     Output.Write_Str (\"(process died) \");\n                                  end if;\n                               end if;\n+\n                            else\n                               Line_Loop : while not End_Of_File (File) loop\n                                  Get_Line (File, Text_Line, Text_Last);\n@@ -376,8 +377,7 @@ package body Prj.Makr is\n                                        if J >= 13 and then\n                                          Text_Line (1 .. 4) = \"Unit\"\n                                        then\n-                                          --  Add an entry in the SFN_Pragmas\n-                                          --  table.\n+                                          --  Add entry to SFN_Pragmas table\n \n                                           Name_Len := J - 12;\n                                           Name_Buffer (1 .. Name_Len) :=\n@@ -431,25 +431,24 @@ package body Prj.Makr is\n \n                               if Project_File then\n \n-                                 --  Add the corresponding attribute in\n-                                 --  the Naming package of the naming\n-                                 --  project.\n+                                 --  Add the corresponding attribute in the\n+                                 --  Naming package of the naming project.\n \n                                  declare\n-                                    Decl_Item : constant Project_Node_Id\n-                                      := Default_Project_Node\n-                                        (Of_Kind =>\n-                                             N_Declarative_Item);\n+                                    Decl_Item : constant Project_Node_Id :=\n+                                                  Default_Project_Node\n+                                                   (Of_Kind =>\n+                                                      N_Declarative_Item);\n \n-                                    Attribute : constant Project_Node_Id\n-                                      := Default_Project_Node\n-                                        (Of_Kind =>\n-                                             N_Attribute_Declaration);\n+                                    Attribute : constant Project_Node_Id :=\n+                                                  Default_Project_Node\n+                                                   (Of_Kind =>\n+                                                      N_Attribute_Declaration);\n \n-                                    Expression : constant Project_Node_Id\n-                                      := Default_Project_Node\n-                                        (Of_Kind => N_Expression,\n-                                         And_Expr_Kind => Single);\n+                                    Expression : constant Project_Node_Id :=\n+                                                   Default_Project_Node\n+                                                    (Of_Kind => N_Expression,\n+                                                     And_Expr_Kind => Single);\n \n                                     Term : constant Project_Node_Id :=\n                                              Default_Project_Node\n@@ -458,10 +457,8 @@ package body Prj.Makr is\n \n                                     Value : constant Project_Node_Id :=\n                                               Default_Project_Node\n-                                                (Of_Kind =>\n-                                                             N_Literal_String,\n-                                                 And_Expr_Kind =>\n-                                                   Single);\n+                                                (Of_Kind => N_Literal_String,\n+                                                 And_Expr_Kind => Single);\n \n                                  begin\n                                     Set_Next_Declarative_Item\n@@ -503,8 +500,7 @@ package body Prj.Makr is\n                                       (Value, To => File_Name_Id);\n                                  end;\n \n-                                 --  Add source file name to source list\n-                                 --  file.\n+                                 --  Add source file name to source list file\n \n                                  Last := Last + 1;\n                                  Str (Last) := ASCII.LF;\n@@ -527,8 +523,7 @@ package body Prj.Makr is\n                   --  File name matches none of the regular expressions\n \n                   else\n-                     --  If the file is not excluded, look if this is a foreign\n-                     --  source.\n+                     --  If file is not excluded, see if this is foreign source\n \n                      if Matched /= Excluded then\n                         for Index in Foreign_Expressions'Range loop"}, {"sha": "c03e191bf420b21b02d0159e5200d99312117867", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -180,8 +180,7 @@ package body Prj.Part is\n \n    function Project_Path_Name_Of\n      (Project_File_Name : String;\n-      Directory         : String)\n-      return              String;\n+      Directory         : String) return String;\n    --  Returns the path name of a project file. Returns an empty string\n    --  if project file cannot be found.\n \n@@ -863,10 +862,12 @@ package body Prj.Part is\n       Extends_All := False;\n \n       declare\n-         Normed_Path : constant String := Normalize_Pathname\n-                  (Path_Name, Resolve_Links => False, Case_Sensitive => True);\n+         Normed_Path    : constant String := Normalize_Pathname\n+                            (Path_Name, Resolve_Links => False,\n+                             Case_Sensitive           => True);\n          Canonical_Path : constant String := Normalize_Pathname\n-           (Normed_Path, Resolve_Links => True, Case_Sensitive => False);\n+                            (Normed_Path, Resolve_Links => True,\n+                             Case_Sensitive             => False);\n \n       begin\n          Name_Len := Normed_Path'Length;\n@@ -1585,8 +1586,7 @@ package body Prj.Part is\n \n    function Project_Path_Name_Of\n      (Project_File_Name : String;\n-      Directory         : String)\n-      return              String\n+      Directory         : String) return String\n    is\n       Result : String_Access;\n "}, {"sha": "4d8a67d9a17760e0cc58789a2f4449d93954e717", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 92, "deletions": 12, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,6 +78,9 @@ package body Sem_Aggr is\n    --  statement of variant part will usually be small and probably in near\n    --  sorted order.\n \n+   procedure Check_Can_Never_Be_Null (N : Node_Id; Expr : Node_Id);\n+   --  Ada 0Y (AI-231): Check bad usage of the null-exclusion issue\n+\n    ------------------------------------------------------\n    -- Subprograms used for RECORD AGGREGATE Processing --\n    ------------------------------------------------------\n@@ -465,6 +468,17 @@ package body Sem_Aggr is\n             Analyze_And_Resolve (Exp, Check_Typ);\n             Check_Unset_Reference (Exp);\n          end if;\n+\n+      --  Ada 0Y (AI-231): Generate conversion to the null-excluding\n+      --  type to force the corresponding run-time check\n+\n+      elsif Is_Access_Type (Check_Typ)\n+        and then Can_Never_Be_Null (Check_Typ)\n+        and then not Can_Never_Be_Null (Exp_Typ)\n+      then\n+         Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n+         Analyze_And_Resolve (Exp, Check_Typ);\n+         Check_Unset_Reference (Exp);\n       end if;\n    end Aggregate_Constraint_Checks;\n \n@@ -867,7 +881,7 @@ package body Sem_Aggr is\n          Error_Msg_N (\"aggregate type cannot have limited component\", N);\n          Explain_Limited_Type (Typ, N);\n \n-      --  Ada0Y (AI-287): Limited aggregates allowed\n+      --  Ada 0Y (AI-287): Limited aggregates allowed\n \n       elsif Is_Limited_Type (Typ)\n         and not Extensions_Allowed\n@@ -965,6 +979,13 @@ package body Sem_Aggr is\n \n             Set_Etype (N, Aggr_Typ);  --  may be overridden later on.\n \n+            --  Ada 0Y (AI-231): Propagate the null_exclusion attribute to the\n+            --  components of the array aggregate\n+\n+            if Extensions_Allowed then\n+               Set_Can_Never_Be_Null (Aggr_Typ, Can_Never_Be_Null (Typ));\n+            end if;\n+\n             if Is_Constrained (Typ) and then\n               (Pkind = N_Assignment_Statement      or else\n                Pkind = N_Parameter_Association     or else\n@@ -1644,12 +1665,16 @@ package body Sem_Aggr is\n                   end if;\n                end loop;\n \n-               --  Ada0Y (AI-287): In case of default initialized component\n+               --  Ada 0Y (AI-231)\n+\n+               Check_Can_Never_Be_Null (N, Expression (Assoc));\n+\n+               --  Ada 0Y (AI-287): In case of default initialized component\n                --  we delay the resolution to the expansion phase\n \n                if Box_Present (Assoc) then\n \n-                  --  Ada0Y (AI-287): In case of default initialization of a\n+                  --  Ada 0Y (AI-287): In case of default initialization of a\n                   --  component the expander will generate calls to the\n                   --  corresponding initialization subprogram.\n \n@@ -1776,6 +1801,8 @@ package body Sem_Aggr is\n          while Present (Expr) loop\n             Nb_Elements := Nb_Elements + 1;\n \n+            Check_Can_Never_Be_Null (N, Expr); --  Ada 0Y (AI-231)\n+\n             if not Resolve_Aggr_Expr (Expr, Single_Elmt => True) then\n                return Failure;\n             end if;\n@@ -1786,12 +1813,14 @@ package body Sem_Aggr is\n          if Others_Present then\n             Assoc := Last (Component_Associations (N));\n \n-            --  Ada0Y (AI-287): In case of default initialized component\n+            Check_Can_Never_Be_Null (N, Expression (Assoc)); -- Ada 0Y (AI-231)\n+\n+            --  Ada 0Y (AI-287): In case of default initialized component\n             --  we delay the resolution to the expansion phase.\n \n             if Box_Present (Assoc) then\n \n-               --  Ada0Y (AI-287): In case of default initialization of a\n+               --  Ada 0Y (AI-287): In case of default initialization of a\n                --  component the expander will generate calls to the\n                --  corresponding initialization subprogram.\n \n@@ -1958,7 +1987,7 @@ package body Sem_Aggr is\n \n       elsif Is_Limited_Type (Typ) then\n \n-         --  Ada0Y (AI-287): Limited aggregates are allowed\n+         --  Ada 0Y (AI-287): Limited aggregates are allowed\n \n          if Extensions_Allowed then\n             null;\n@@ -2069,7 +2098,7 @@ package body Sem_Aggr is\n \n       Mbox_Present : Boolean := False;\n       Others_Mbox  : Boolean := False;\n-      --  Ada0Y (AI-287): Variables used in case of default initialization to\n+      --  Ada 0Y (AI-287): Variables used in case of default initialization to\n       --  provide a functionality similar to Others_Etype. Mbox_Present\n       --  indicates that the component takes its default initialization;\n       --  Others_Mbox indicates that at least one component takes its default\n@@ -2258,7 +2287,7 @@ package body Sem_Aggr is\n                and then Comes_From_Source (Compon)\n                and then not In_Instance_Body\n             then\n-               --  Ada0Y (AI-287): Limited aggregates are allowed\n+               --  Ada 0Y (AI-287): Limited aggregates are allowed\n \n                if Extensions_Allowed\n                  and then Present (Expression (Assoc))\n@@ -2298,7 +2327,7 @@ package body Sem_Aggr is\n                      --  indispensable otherwise, because each one must be\n                      --  expanded individually to preserve side-effects.\n \n-                     --  Ada0Y (AI-287): In case of default initialization of\n+                     --  Ada 0Y (AI-287): In case of default initialization of\n                      --  components, we duplicate the corresponding default\n                      --  expression (from the record type declaration).\n \n@@ -2336,10 +2365,24 @@ package body Sem_Aggr is\n                elsif Chars (Compon) = Chars (Selector_Name) then\n                   if No (Expr) then\n \n+                     --  Ada 0Y (AI-231)\n+\n+                     if Extensions_Allowed\n+                       and then Present (Expression (Assoc))\n+                       and then Nkind (Expression (Assoc)) = N_Null\n+                       and then Can_Never_Be_Null (Compon)\n+                     then\n+                        Error_Msg_N\n+                          (\"(Ada 0Y) NULL not allowed in null-excluding \" &\n+                           \"components\", Expression (Assoc));\n+                     end if;\n+\n                      --  We need to duplicate the expression when several\n                      --  components are grouped together with a \"|\" choice.\n                      --  For instance \"filed1 | filed2 => Expr\"\n \n+                     --  Ada 0Y (AI-287)\n+\n                      if Box_Present (Assoc) then\n                         Mbox_Present := True;\n \n@@ -2643,6 +2686,18 @@ package body Sem_Aggr is\n          while Present (Discrim) and then Present (Positional_Expr) loop\n             if Discr_Present (Discrim) then\n                Resolve_Aggr_Expr (Positional_Expr, Discrim);\n+\n+               --  Ada 0Y (AI-231)\n+\n+               if Extensions_Allowed\n+                 and then Nkind (Positional_Expr) = N_Null\n+                 and then Can_Never_Be_Null (Discrim)\n+               then\n+                  Error_Msg_N\n+                    (\"(Ada 0Y) NULL not allowed in null-excluding components\",\n+                     Positional_Expr);\n+               end if;\n+\n                Next (Positional_Expr);\n             end if;\n \n@@ -2874,6 +2929,16 @@ package body Sem_Aggr is\n          Component := Node (Component_Elmt);\n          Resolve_Aggr_Expr (Positional_Expr, Component);\n \n+         --  Ada 0Y (AI-231)\n+         if Extensions_Allowed\n+           and then Nkind (Positional_Expr) = N_Null\n+           and then Can_Never_Be_Null (Component)\n+         then\n+            Error_Msg_N\n+              (\"(Ada 0Y) NULL not allowed in null-excluding components\",\n+               Positional_Expr);\n+         end if;\n+\n          if Present (Get_Value (Component, Component_Associations (N))) then\n             Error_Msg_NE\n               (\"more than one value supplied for Component &\", N, Component);\n@@ -2896,7 +2961,7 @@ package body Sem_Aggr is\n \n          if Mbox_Present and then Is_Limited_Type (Etype (Component)) then\n \n-            --  Ada0Y (AI-287): In case of default initialization of a limited\n+            --  Ada 0Y (AI-287): In case of default initialization of a limited\n             --  component we pass the limited component to the expander. The\n             --  expander will generate calls to the corresponding initiali-\n             --  zation subprograms.\n@@ -2937,7 +3002,7 @@ package body Sem_Aggr is\n \n             if Nkind (Selectr) = N_Others_Choice then\n \n-               --  Ada0Y (AI-287):  others choice may have expression or mbox\n+               --  Ada 0Y (AI-287):  others choice may have expression or mbox\n \n                if No (Others_Etype)\n                   and then not Others_Mbox\n@@ -3015,6 +3080,21 @@ package body Sem_Aggr is\n       end Step_8;\n    end Resolve_Record_Aggregate;\n \n+   -----------------------------\n+   -- Check_Can_Never_Be_Null --\n+   -----------------------------\n+\n+   procedure Check_Can_Never_Be_Null (N : Node_Id; Expr : Node_Id) is\n+   begin\n+      if Extensions_Allowed\n+        and then Nkind (Expr) = N_Null\n+        and then Can_Never_Be_Null (Etype (N))\n+      then\n+         Error_Msg_N\n+           (\"(Ada 0Y) NULL not allowed in null-excluding components\", Expr);\n+      end if;\n+   end Check_Can_Never_Be_Null;\n+\n    ---------------------\n    -- Sort_Case_Table --\n    ---------------------"}, {"sha": "69930b81a0488a7615387c562bed82d1b1e25079", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6670,7 +6670,10 @@ package body Sem_Ch12 is\n       Decl_Node :=\n         Make_Subprogram_Renaming_Declaration (Loc,\n           Specification => New_Spec,\n-          Name => Nam);\n+          Name          => Nam);\n+\n+      --  If we do not have an actual and the formal specified <> then\n+      --  set to get proper default.\n \n       if No (Actual) and then Box_Present (Formal) then\n          Set_From_Default (Decl_Node);"}, {"sha": "b17f870ae12d743c402b31305ea034e651168788", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 130, "deletions": 4, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -686,6 +686,18 @@ package body Sem_Ch3 is\n       Init_Size_Align        (Anon_Type);\n       Set_Depends_On_Private (Anon_Type, Has_Private_Component (Anon_Type));\n \n+      --  Ada 0Y (AI-231): Ada 0Y semantics for anonymous access differs from\n+      --  Ada 95 semantics. In Ada 0Y, anonymous access must specify if the\n+      --  null value is allowed; in Ada 95 the null value is not allowed\n+\n+      if Extensions_Allowed\n+        and then Null_Exclusion_Present (N)\n+      then\n+         Set_Can_Never_Be_Null (Anon_Type);\n+      else\n+         Set_Can_Never_Be_Null (Anon_Type);\n+      end if;\n+\n       --  The anonymous access type is as public as the discriminated type or\n       --  subprogram that defines it. It is imported (for back-end purposes)\n       --  if the designated type is.\n@@ -697,6 +709,10 @@ package body Sem_Ch3 is\n \n       Set_From_With_Type     (Anon_Type, From_With_Type (Desig_Type));\n \n+      --  Ada 0Y (AI-231): Propagate the access-constant attribute\n+\n+      Set_Is_Access_Constant (Anon_Type, Constant_Present (N));\n+\n       --  The context is either a subprogram declaration or an access\n       --  discriminant, in a private or a full type declaration. In\n       --  the case of a subprogram, If the designated type is incomplete,\n@@ -800,6 +816,10 @@ package body Sem_Ch3 is\n       Init_Size_Align              (T_Name);\n       Set_Directly_Designated_Type (T_Name, Desig_Type);\n \n+      --  Ada 0Y (AI-231): Propagate the null-excluding attribute\n+\n+      Set_Can_Never_Be_Null (T_Name, Null_Exclusion_Present (T_Def));\n+\n       Check_Restriction (No_Access_Subprograms, T_Def);\n    end Access_Subprogram_Declaration;\n \n@@ -893,6 +913,12 @@ package body Sem_Ch3 is\n \n       Set_Has_Task (T, False);\n       Set_Has_Controlled_Component (T, False);\n+\n+      --  Ada 0Y (AI-231): Propagate the null-excluding and access-constant\n+      --  attributes\n+\n+      Set_Can_Never_Be_Null  (T, Null_Exclusion_Present (Def));\n+      Set_Is_Access_Constant (T, Constant_Present (Def));\n    end Access_Type_Declaration;\n \n    -----------------------------------\n@@ -980,6 +1006,17 @@ package body Sem_Ch3 is\n       Set_Etype (Id, T);\n       Set_Is_Aliased (Id, Aliased_Present (Component_Definition (N)));\n \n+      --  Ada 0Y (AI-231): Propagate the null-excluding attribute and carry\n+      --  out some static checks\n+\n+      if Extensions_Allowed\n+        and then (Null_Exclusion_Present (Component_Definition (N))\n+                    or else Can_Never_Be_Null (T))\n+      then\n+         Set_Can_Never_Be_Null (Id);\n+         Null_Exclusion_Static_Checks (N);\n+      end if;\n+\n       --  If this component is private (or depends on a private type),\n       --  flag the record type to indicate that some operations are not\n       --  available.\n@@ -1528,6 +1565,17 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Ada 0Y (AI-231): Propagate the null-excluding attribute and carry\n+      --  out some static checks\n+\n+      if Extensions_Allowed\n+        and then (Null_Exclusion_Present (N)\n+                    or else Can_Never_Be_Null (T))\n+      then\n+         Set_Can_Never_Be_Null (Id);\n+         Null_Exclusion_Static_Checks (N);\n+      end if;\n+\n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n \n       --  If deferred constant, make sure context is appropriate. We detect\n@@ -2359,6 +2407,23 @@ package body Sem_Ch3 is\n                Set_Directly_Designated_Type\n                                      (Id, Designated_Type       (T));\n \n+               --  Ada 0Y (AI-231): Propagate the null-excluding attribute and\n+               --  carry out some static checks\n+\n+               if Null_Exclusion_Present (N)\n+                 or else Can_Never_Be_Null (T)\n+               then\n+                  Set_Can_Never_Be_Null (Id);\n+\n+                  if Null_Exclusion_Present (N)\n+                    and then Can_Never_Be_Null (T)\n+                  then\n+                     Error_Msg_N\n+                       (\"(Ada 0Y) null exclusion not allowed if parent \"\n+                        & \"is already non-null\", Subtype_Indication (N));\n+                  end if;\n+               end if;\n+\n                --  A Pure library_item must not contain the declaration of a\n                --  named access type, except within a subprogram, generic\n                --  subprogram, task unit, or protected unit (RM 10.2.1(16)).\n@@ -2942,6 +3007,24 @@ package body Sem_Ch3 is\n          Set_Has_Aliased_Components (Etype (T));\n       end if;\n \n+      --  Ada 0Y (AI-231): Propagate the null-excluding attribute to the array\n+      --  to ensure that objects of this type are initialized\n+\n+      if Extensions_Allowed\n+        and then (Null_Exclusion_Present (Component_Definition (Def))\n+                    or else Can_Never_Be_Null (Element_Type))\n+      then\n+         Set_Can_Never_Be_Null (T);\n+\n+         if Null_Exclusion_Present (Component_Definition (Def))\n+           and then Can_Never_Be_Null (Element_Type)\n+         then\n+            Error_Msg_N\n+              (\"(Ada 0Y) already a null-excluding type\",\n+               Subtype_Indication (Component_Definition (Def)));\n+         end if;\n+      end if;\n+\n       Priv := Private_Component (Element_Type);\n \n       if Present (Priv) then\n@@ -3062,6 +3145,14 @@ package body Sem_Ch3 is\n                               Has_Private_Component (Derived_Type));\n       Conditional_Delay      (Derived_Type, Subt);\n \n+      --  Ada 0Y (AI-231). Set the null-exclusion attribute\n+\n+      if Null_Exclusion_Present (Type_Definition (N))\n+        or else Can_Never_Be_Null (Parent_Type)\n+      then\n+         Set_Can_Never_Be_Null (Derived_Type);\n+      end if;\n+\n       --  Note: we do not copy the Storage_Size_Variable, since\n       --  we always go to the root type for this information.\n \n@@ -5682,10 +5773,10 @@ package body Sem_Ch3 is\n       end loop;\n \n       --  Build an element list consisting of the expressions given in the\n-      --  discriminant constraint and apply the appropriate range\n-      --  checks. The list is constructed after resolving any named\n-      --  discriminant associations and therefore the expressions appear in\n-      --  the textual order of the discriminants.\n+      --  discriminant constraint and apply the appropriate checks. The list\n+      --  is constructed after resolving any named discriminant associations\n+      --  and therefore the expressions appear in the textual order of the\n+      --  discriminants.\n \n       Discr := First_Discriminant (T);\n       for J in Discr_Expr'Range loop\n@@ -5723,6 +5814,9 @@ package body Sem_Ch3 is\n                then\n                   null;\n \n+               elsif Is_Access_Type (Etype (Discr)) then\n+                  Apply_Constraint_Check (Discr_Expr (J), Etype (Discr));\n+\n                else\n                   Apply_Range_Check (Discr_Expr (J), Etype (Discr));\n                end if;\n@@ -9180,6 +9274,15 @@ package body Sem_Ch3 is\n \n       elsif Is_Unchecked_Union (Parent_Type) then\n          Error_Msg_N (\"cannot derive from Unchecked_Union type\", N);\n+\n+      --  Ada 0Y (AI-231)\n+\n+      elsif Is_Access_Type (Parent_Type)\n+        and then Null_Exclusion_Present (Type_Definition (N))\n+        and then Can_Never_Be_Null (Parent_Type)\n+      then\n+         Error_Msg_N (\"(Ada 0Y) null exclusion not allowed if parent is \"\n+                      & \"already non-null\", Type_Definition (N));\n       end if;\n \n       --  Only composite types other than array types are allowed to have\n@@ -11425,6 +11528,17 @@ package body Sem_Ch3 is\n             Default_Not_Present := True;\n          end if;\n \n+         --  Ada 0Y (AI-231): Set the null-excluding attribute and carry out\n+         --  some static checks\n+\n+         if Extensions_Allowed\n+           and then (Null_Exclusion_Present (Discr)\n+                       or else Can_Never_Be_Null (Discr_Type))\n+         then\n+            Set_Can_Never_Be_Null (Defining_Identifier (Discr));\n+            Null_Exclusion_Static_Checks (Discr);\n+         end if;\n+\n          Next (Discr);\n       end loop;\n \n@@ -12189,6 +12303,18 @@ package body Sem_Ch3 is\n \n          Find_Type (S);\n          Check_Incomplete (S);\n+\n+         --  Ada 0Y (AI-231)\n+\n+         if Extensions_Allowed\n+           and then Present (Parent (S))\n+           and then Null_Exclusion_Present (Parent (S))\n+           and then Nkind (Parent (S)) /= N_Access_To_Object_Definition\n+           and then not Is_Access_Type (Entity (S))\n+         then\n+            Error_Msg_N\n+              (\"(Ada 0Y) null-exclusion part requires an access type\", S);\n+         end if;\n          return Entity (S);\n \n       --  Case of constraint present, so that we have an N_Subtype_Indication"}, {"sha": "06e296a0aa41d4eb85ffc885db32270002a6b047", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -25,6 +25,7 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n+with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n@@ -437,6 +438,13 @@ package body Sem_Ch4 is\n             Set_Directly_Designated_Type (Acc_Type, Type_Id);\n             Check_Fully_Declared (Type_Id, N);\n \n+            --  Ada 0Y (AI-231)\n+\n+            if Can_Never_Be_Null (Type_Id) then\n+               Error_Msg_N (\"(Ada 0Y) qualified expression required\",\n+                            Expression (N));\n+            end if;\n+\n             --  Check restriction against dynamically allocated protected\n             --  objects. Note that when limited aggregates are supported,\n             --  a similar test should be applied to an allocator with a\n@@ -480,6 +488,15 @@ package body Sem_Ch4 is\n          Check_Restriction (No_Local_Allocators, N);\n       end if;\n \n+      --  Ada 0Y (AI-231): Static checks\n+\n+      if Extensions_Allowed\n+        and then (Null_Exclusion_Present (N)\n+                    or else Can_Never_Be_Null (Etype (N)))\n+      then\n+         Null_Exclusion_Static_Checks (N);\n+      end if;\n+\n       if Serious_Errors_Detected > Sav_Errs then\n          Set_Error_Posted (N);\n          Set_Etype (N, Any_Type);"}, {"sha": "42db6899373d1c457408aebda9a0d9ab1e6caf6f", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -397,6 +397,20 @@ package body Sem_Ch5 is\n          Propagate_Tag (Lhs, Rhs);\n       end if;\n \n+      --  Ada 0Y (AI-231)\n+\n+      if Extensions_Allowed\n+        and then Nkind (Rhs) = N_Null\n+        and then Is_Access_Type (T1)\n+        and then not Assignment_OK (Lhs)\n+        and then ((Is_Entity_Name (Lhs)\n+                     and then Can_Never_Be_Null (Entity (Lhs)))\n+                   or else Can_Never_Be_Null (Etype (Lhs)))\n+      then\n+         Error_Msg_N\n+           (\"(Ada 0Y) NULL not allowed in null-excluding objects\", Lhs);\n+      end if;\n+\n       if Is_Scalar_Type (T1) then\n          Apply_Scalar_Range_Check (Rhs, Etype (Lhs));\n "}, {"sha": "bd2a07fcd1011139c33c3ab9f68dcff4dafb8e04", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 101, "deletions": 11, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -970,8 +970,15 @@ package body Sem_Ch6 is\n               Make_Subprogram_Declaration (Loc,\n                 Specification => New_Spec);\n             Insert_Before (N, Decl);\n-            Analyze (Decl);\n             Spec_Id := Defining_Unit_Name (New_Spec);\n+\n+            --  Indicate that the entity comes from source, to ensure that\n+            --  cross-reference information is properly generated.\n+            --  The body itself is rewritten during expansion, and the\n+            --  body entity will not appear in calls to the operation.\n+\n+            Set_Comes_From_Source (Spec_Id, True);\n+            Analyze (Decl);\n             Set_Has_Completion (Spec_Id);\n             Set_Convention (Spec_Id, Convention_Protected);\n          end;\n@@ -1724,6 +1731,8 @@ package body Sem_Ch6 is\n \n       --  Functions that return unconstrained composite types will require\n       --  secondary stack handling, and cannot currently be inlined.\n+      --  Ditto for functions that return controlled types, where controlled\n+      --  actions interfere in complex ways with inlining.\n \n       elsif Ekind (Subp) = E_Function\n         and then not Is_Scalar_Type (Etype (Subp))\n@@ -1733,6 +1742,13 @@ package body Sem_Ch6 is\n          Cannot_Inline\n            (\"cannot inline & (unconstrained return type)?\", N, Subp);\n          return;\n+\n+      elsif Ekind (Subp) = E_Function\n+        and then Controlled_Type (Etype (Subp))\n+      then\n+         Cannot_Inline\n+           (\"cannot inline & (controlled return type)?\", N, Subp);\n+         return;\n       end if;\n \n       if Present (Declarations (N))\n@@ -4845,7 +4861,7 @@ package body Sem_Ch6 is\n                         and then Ekind (Root_Type (Formal_Type)) =\n                                                          E_Incomplete_Type)\n             then\n-               --  Ada0Y (AI-50217): Incomplete tagged types that are made\n+               --  Ada 0Y (AI-50217): Incomplete tagged types that are made\n                --  visible through a limited with_clause are valid formal\n                --  types.\n \n@@ -4934,6 +4950,18 @@ package body Sem_Ch6 is\n                end if;\n \n             end if;\n+\n+            --  Ada 0Y (AI-231): Static checks\n+\n+            Ptype := Parameter_Type (Param_Spec);\n+\n+            if Extensions_Allowed\n+              and then Nkind (Ptype) /= N_Access_Definition\n+              and then (Null_Exclusion_Present (Parent (Formal))\n+                        or else Can_Never_Be_Null (Entity (Ptype)))\n+            then\n+               Null_Exclusion_Static_Checks (Param_Spec);\n+            end if;\n          end if;\n \n          Next (Param_Spec);\n@@ -4976,12 +5004,13 @@ package body Sem_Ch6 is\n    -------------------------\n \n    procedure Set_Actual_Subtypes (N : Node_Id; Subp : Entity_Id) is\n-      Loc        : constant Source_Ptr := Sloc (N);\n-      Decl       : Node_Id;\n-      Formal     : Entity_Id;\n-      T          : Entity_Id;\n-      First_Stmt : Node_Id := Empty;\n-      AS_Needed  : Boolean;\n+      Loc            : constant Source_Ptr := Sloc (N);\n+      Decl           : Node_Id;\n+      Formal         : Entity_Id;\n+      T              : Entity_Id;\n+      First_Stmt     : Node_Id := Empty;\n+      AS_Needed      : Boolean;\n+      Null_Exclusion : Boolean := False;\n \n    begin\n       --  If this is an emtpy initialization procedure, no need to create\n@@ -5036,6 +5065,17 @@ package body Sem_Ch6 is\n          then\n             AS_Needed := True;\n \n+         --  Ada 0Y (AI-231)\n+\n+         elsif Extensions_Allowed\n+           and then Is_Access_Type (T)\n+           and then Null_Exclusion_Present (Parent (Formal))\n+           and then Nkind (Parameter_Type (Parent (Formal)))\n+                    /= N_Access_Definition\n+         then\n+            AS_Needed      := True;\n+            Null_Exclusion := True;\n+\n          --  All other cases do not need an actual subtype\n \n          else\n@@ -5047,7 +5087,39 @@ package body Sem_Ch6 is\n \n          if AS_Needed then\n \n-            if Nkind (N) = N_Accept_Statement then\n+            --  Ada 0Y (AI-231): Generate actual null-excluding subtype\n+\n+            if Extensions_Allowed\n+              and then Null_Exclusion\n+            then\n+               declare\n+                  Loc      : constant Source_Ptr := Sloc (Formal);\n+                  Anon     : constant Entity_Id :=\n+                               Make_Defining_Identifier (Loc,\n+                                 New_Internal_Name ('S'));\n+                  Ptype    : constant Node_Id\n+                               := Parameter_Type (Parent (Formal));\n+               begin\n+                  --  T == Etype (Formal)\n+                  Set_Is_Internal (Anon);\n+                  Decl :=\n+                    Make_Subtype_Declaration (Loc,\n+                      Defining_Identifier      => Anon,\n+                        Null_Exclusion_Present => True,\n+                        Subtype_Indication     =>\n+                          New_Occurrence_Of (Etype (Ptype), Loc));\n+                  Mark_Rewrite_Insertion (Decl);\n+                  Prepend (Decl, Declarations (Parent (N)));\n+\n+                  Rewrite (Ptype, New_Occurrence_Of (Anon, Loc));\n+                  Mark_Rewrite_Insertion (Ptype);\n+                  --   Set_Scope (Anon, Scope (Scope (Formal)));\n+\n+                  Set_Etype (Formal, Anon);\n+                  Set_Null_Exclusion_Present (Parent (Formal), False);\n+               end;\n+\n+            elsif Nkind (N) = N_Accept_Statement then\n \n                --  If expansion is active, The formal is replaced by a local\n                --  variable that renames the corresponding entry of the\n@@ -5081,6 +5153,16 @@ package body Sem_Ch6 is\n \n             Analyze (Decl);\n \n+            --  Ada 0Y (AI-231): Previous analysis leaves the entity of the\n+            --  null-excluding subtype declaration associated with the internal\n+            --  scope; because this declaration has been inserted before the\n+            --  subprogram we associate it now with the enclosing scope.\n+\n+            if Null_Exclusion then\n+               Set_Scope (Defining_Identifier (Decl),\n+                          Scope (Scope (Formal)));\n+            end if;\n+\n             --  We need to freeze manually the generated type when it is\n             --  inserted anywhere else than in a declarative part.\n \n@@ -5141,8 +5223,16 @@ package body Sem_Ch6 is\n       --  set Can_Never_Be_Null, since there is no way to change the value.\n \n       if Nkind (Parameter_Type (Spec)) = N_Access_Definition then\n-         Set_Is_Known_Non_Null (Formal_Id);\n-         Set_Can_Never_Be_Null (Formal_Id);\n+\n+         --  Ada 0Y (AI-231): This behaviour has been modified in Ada 0Y.\n+         --  It is only forced if the null_exclusion appears.\n+\n+         if not Extensions_Allowed\n+           or else Null_Exclusion_Present (Spec)\n+         then\n+            Set_Is_Known_Non_Null (Formal_Id);\n+            Set_Can_Never_Be_Null (Formal_Id);\n+         end if;\n       end if;\n \n       Set_Mechanism (Formal_Id, Default_Mechanism);"}, {"sha": "3c8ca3df41bbfe4c7668a4a34f3d3f91c5c8b9c7", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1692,7 +1692,6 @@ package body Sem_Prag is\n       is\n          Id        : Node_Id;\n          E1        : Entity_Id;\n-         Comp_Unit : Unit_Number_Type;\n          Cname     : Name_Id;\n \n          procedure Set_Convention_From_Pragma (E : Entity_Id);\n@@ -1908,12 +1907,9 @@ package body Sem_Prag is\n             end if;\n \n          --  For the subprogram case, set proper convention for all homonyms\n-         --  in same compilation unit.\n-         --  Is the test of compilation unit really necessary ???\n-         --  What about subprogram renamings here???\n+         --  in same scope.\n \n          else\n-            Comp_Unit := Get_Source_Unit (E);\n             Set_Convention_From_Pragma (E);\n \n             --  Treat a pragma Import as an implicit body, for GPS use.\n@@ -1931,7 +1927,10 @@ package body Sem_Prag is\n                --  That is deliberate, we cannot chain the rep item on more\n                --  than one Rep_Item chain, to be fixed later ???\n \n-               if Comp_Unit = Get_Source_Unit (E1) then\n+               if Comes_From_Source (E1)\n+                 and then Nkind (Original_Node (Parent (E1))) /=\n+                   N_Full_Type_Declaration\n+               then\n                   Set_Convention_From_Pragma (E1);\n \n                   if Prag_Id = Pragma_Import then\n@@ -8561,9 +8560,39 @@ package body Sem_Prag is\n          -- Source_File_Name --\n          ----------------------\n \n+         --  There are five forms for this pragma:\n+\n+         --  pragma Source_File_Name (\n+         --    [UNIT_NAME      =>] unit_NAME,\n+         --     BODY_FILE_NAME =>  STRING_LITERAL\n+         --    [, [INDEX =>] INTEGER_LITERAL]);\n+\n          --  pragma Source_File_Name (\n-         --    [UNIT_NAME =>] unit_NAME,\n-         --    [BODY_FILE_NAME | SPEC_FILE_NAME] => STRING_LITERAL);\n+         --    [UNIT_NAME      =>] unit_NAME,\n+         --     SPEC_FILE_NAME =>  STRING_LITERAL\n+         --    [, [INDEX =>] INTEGER_LITERAL]);\n+\n+         --  pragma Source_File_Name (\n+         --     BODY_FILE_NAME  => STRING_LITERAL\n+         --  [, DOT_REPLACEMENT => STRING_LITERAL]\n+         --  [, CASING          => CASING_SPEC]);\n+\n+         --  pragma Source_File_Name (\n+         --     SPEC_FILE_NAME  => STRING_LITERAL\n+         --  [, DOT_REPLACEMENT => STRING_LITERAL]\n+         --  [, CASING          => CASING_SPEC]);\n+\n+         --  pragma Source_File_Name (\n+         --     SUBUNIT_FILE_NAME  => STRING_LITERAL\n+         --  [, DOT_REPLACEMENT    => STRING_LITERAL]\n+         --  [, CASING             => CASING_SPEC]);\n+\n+         --  CASING_SPEC ::= Uppercase | Lowercase | Mixedcase\n+\n+         --  Pragma Source_File_Name_Project (SFNP) is equivalent to pragma\n+         --  Source_File_Name (SFN), however their usage is exclusive:\n+         --  SFN can only be used when no project file is used, while\n+         --  SFNP can only be used when a project file is used.\n \n          --  No processing here. Processing was completed during parsing,\n          --  since we need to have file names set as early as possible.\n@@ -8580,9 +8609,7 @@ package body Sem_Prag is\n          -- Source_File_Name_Project --\n          ------------------------------\n \n-         --  pragma Source_File_Name_Project (\n-         --    [UNIT_NAME =>] unit_NAME,\n-         --    [BODY_FILE_NAME | SPEC_FILE_NAME] => STRING_LITERAL);\n+         --  See Source_File_Name for syntax\n \n          --  No processing here. Processing was completed during parsing,\n          --  since we need to have file names set as early as possible.\n@@ -8597,6 +8624,7 @@ package body Sem_Prag is\n \n             --  Check that a pragma Source_File_Name_Project is used only\n             --  in a configuration pragmas file.\n+\n             --  Pragmas Source_File_Name_Project should only be generated\n             --  by the Project Manager in configuration pragmas files.\n "}, {"sha": "c05b81b304c4265ec9022ba744dd3fa519329b1f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -902,7 +902,8 @@ package body Sem_Res is\n       Act1      : Node_Id := First_Actual (N);\n       Act2      : Node_Id := Next_Actual (Act1);\n       Error     : Boolean := False;\n-      Is_Binary : constant Boolean := Present (Act2);\n+      Func      : constant Entity_Id := Entity (Name (N));\n+      Is_Binary : constant Boolean   := Present (Act2);\n       Op_Node   : Node_Id;\n       Opnd_Type : Entity_Id;\n       Orig_Type : Entity_Id := Empty;\n@@ -1197,6 +1198,20 @@ package body Sem_Res is\n          Set_Etype (Op_Node, Etype (N));\n       end if;\n \n+      --  If this is a call to a function that renames a predefined equality,\n+      --  the renaming declaration provides a type that must be used to\n+      --  resolve the operands. This must be done now because resolution of\n+      --  the equality node will not resolve any remaining ambiguity, and it\n+      --  assumes that the first operand is not overloaded.\n+\n+      if (Op_Name = Name_Op_Eq or else Op_Name = Name_Op_Ne)\n+        and then Ekind (Func) = E_Function\n+        and then Is_Overloaded (Act1)\n+      then\n+         Resolve (Act1, Base_Type (Etype (First_Formal (Func))));\n+         Resolve (Act2, Base_Type (Etype (First_Formal (Func))));\n+      end if;\n+\n       Set_Entity (Op_Node, Op_Id);\n       Generate_Reference (Op_Id, N, ' ');\n       Rewrite (N,  Op_Node);\n@@ -2682,6 +2697,19 @@ package body Sem_Res is\n                else\n                   Apply_Range_Check (A, F_Typ);\n                end if;\n+\n+               --  Ada 0Y (AI-231)\n+\n+               if Extensions_Allowed\n+                 and then Is_Access_Type (F_Typ)\n+                 and then (Can_Never_Be_Null (F)\n+                           or else Can_Never_Be_Null (F_Typ))\n+               then\n+                  if Nkind (A) = N_Null then\n+                     Error_Msg_NE (\"(Ada 0Y) not allowed for null-exclusion \" &\n+                                   \"formal\", A, F_Typ);\n+                  end if;\n+               end if;\n             end if;\n \n             if Ekind (F) = E_Out_Parameter\n@@ -5140,7 +5168,10 @@ package body Sem_Res is\n       --  anonymous null access values via a debug switch to allow\n       --  for easier transition.\n \n-      if not Debug_Flag_J\n+      --  Ada 0Y (AI-231): Remove restriction\n+\n+      if not Extensions_Allowed\n+        and then not Debug_Flag_J\n         and then Ekind (Typ) = E_Anonymous_Access_Type\n         and then Comes_From_Source (N)\n       then"}, {"sha": "36f165f1e3275fffcd390270f72b4e8308471341", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -3331,12 +3331,12 @@ package body Sem_Util is\n          then\n             return Is_Dependent_Component_Of_Mutable_Object (Prefix (Object));\n \n-         elsif Nkind (Object) = N_Type_Conversion then\n-            --  A type conversion that Is_Variable is a view conversion:\n-            --  go back to the denoted object.\n-            return Is_Dependent_Component_Of_Mutable_Object\n-              (Expression (Object));\n+         --  A type conversion that Is_Variable is a view conversion:\n+         --  go back to the denoted object.\n \n+         elsif Nkind (Object) = N_Type_Conversion then\n+            return\n+              Is_Dependent_Component_Of_Mutable_Object (Expression (Object));\n          end if;\n       end if;\n "}, {"sha": "0ac71ca4d42f36bed7499b48cf5be323777b2af3", "filename": "gcc/ada/sfn_scan.adb", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsfn_scan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsfn_scan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsfn_scan.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2000-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,6 +63,11 @@ package body SFN_Scan is\n    -- Local Procedures --\n    ----------------------\n \n+   function Acquire_Integer return Natural;\n+   --  This function skips white space, and then scans and returns\n+   --  an unsigned integer. Raises Error if no integer is present\n+   --  or if the integer is greater than 999.\n+\n    function Acquire_String (B : Natural; E : Natural) return String;\n    --  This function takes a string scanned out by Scan_String, strips\n    --  the enclosing quote characters and any internal doubled quote\n@@ -128,6 +133,33 @@ package body SFN_Scan is\n    --  Skips P past any white space characters (end of line\n    --  characters, spaces, comments, horizontal tab characters).\n \n+   ---------------------\n+   -- Acquire_Integer --\n+   ---------------------\n+\n+   function Acquire_Integer return Natural is\n+      N : Natural := 0;\n+\n+   begin\n+      Skip_WS;\n+\n+      if S (P) not in '0' .. '9' then\n+         Error (\"missing index parameter\");\n+      end if;\n+\n+      while S (P) in '0' .. '9' loop\n+         N := N * 10 + Character'Pos (S (P)) - Character'Pos ('0');\n+\n+         if N > 999 then\n+            Error (\"index value greater than 999\");\n+         end if;\n+\n+         P := P + 1;\n+      end loop;\n+\n+      return N;\n+   end Acquire_Integer;\n+\n    --------------------\n    -- Acquire_String --\n    --------------------\n@@ -310,6 +342,10 @@ package body SFN_Scan is\n       procedure Add_Nat (N : Natural);\n       --  Add chars of integer to error msg buffer\n \n+      -------------\n+      -- Add_Nat --\n+      -------------\n+\n       procedure Add_Nat (N : Natural) is\n       begin\n          if N > 9 then\n@@ -415,7 +451,10 @@ package body SFN_Scan is\n \n          --  Source_File_Name pragma case\n \n-         if Check_Token (\"source_file_name\") then\n+         if Check_Token (\"source_file_name\")\n+              or else\n+             Check_Token (\"source_file_name_project\")\n+         then\n             Require_Token (\"(\");\n \n             Typ := Check_File_Type;\n@@ -443,11 +482,24 @@ package body SFN_Scan is\n \n                   declare\n                      F : constant String := Acquire_String (B, E);\n+                     X : Natural;\n \n                   begin\n+                     --  Scan Index parameter if present\n+\n+                     if Check_Token (\",\") then\n+                        if Check_Token (\"index\") then\n+                           Require_Token (\"=>\");\n+                        end if;\n+\n+                        X := Acquire_Integer;\n+                     else\n+                        X := 0;\n+                     end if;\n+\n                      Require_Token (\")\");\n                      Require_Token (\";\");\n-                     SFN_Ptr.all (Typ, U, F);\n+                     SFN_Ptr.all (Typ, U, F, X);\n                   end;\n                end;\n "}, {"sha": "0b18bad2e155b577da41b1de0d072be0cc958fa6", "filename": "gcc/ada/sfn_scan.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsfn_scan.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsfn_scan.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsfn_scan.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,12 +46,17 @@ package SFN_Scan is\n    --  of these procedures:\n \n    type Set_File_Name_Ptr is access\n-     procedure (Typ : Character; U : String; F : String);\n+     procedure\n+       (Typ   : Character;\n+        U     : String;\n+        F     : String;\n+        Index : Natural);\n    --  The procedure with this profile is called when a Source_File_Name\n    --  pragma of the form having a unit name parameter. Typ is 'b' for\n    --  a body file name, and 's' for a spec file name. U is a string that\n    --  contains the unit name, exactly as it appeared in the source file,\n-   --  and F is the file taken from the second parameter.\n+   --  and F is the file taken from the second parameter. Index is taken\n+   --  from the third parameter, or is set to zero if no third parameter.\n \n    type Set_File_Name_Pattern_Ptr is access\n      procedure (Pat : String; Typ : Character; Dot : String; Cas : Character);"}, {"sha": "e19321adeb1ddba23827c3d143f16edbd3274350", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -196,6 +196,7 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition\n         or else NT (N).Nkind = N_Access_To_Object_Definition);\n       return Flag15 (N);\n    end All_Present;\n@@ -457,6 +458,7 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition\n         or else NT (N).Nkind = N_Access_To_Object_Definition\n         or else NT (N).Nkind = N_Object_Declaration);\n       return Flag17 (N);\n@@ -1832,6 +1834,24 @@ package body Sinfo is\n       return Flag13 (N);\n    end Null_Present;\n \n+   function Null_Exclusion_Present\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition\n+        or else NT (N).Nkind = N_Access_Function_Definition\n+        or else NT (N).Nkind = N_Access_Procedure_Definition\n+        or else NT (N).Nkind = N_Access_To_Object_Definition\n+        or else NT (N).Nkind = N_Allocator\n+        or else NT (N).Nkind = N_Component_Definition\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Discriminant_Specification\n+        or else NT (N).Nkind = N_Object_Declaration\n+        or else NT (N).Nkind = N_Parameter_Specification\n+        or else NT (N).Nkind = N_Subtype_Declaration);\n+      return Flag9 (N);\n+   end Null_Exclusion_Present;\n+\n    function Null_Record_Present\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2662,6 +2682,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition\n         or else NT (N).Nkind = N_Access_To_Object_Definition);\n       Set_Flag15 (N, Val);\n    end Set_All_Present;\n@@ -2923,6 +2944,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition\n         or else NT (N).Nkind = N_Access_To_Object_Definition\n         or else NT (N).Nkind = N_Object_Declaration);\n       Set_Flag17 (N, Val);\n@@ -4288,6 +4310,24 @@ package body Sinfo is\n       Set_Flag13 (N, Val);\n    end Set_Null_Present;\n \n+   procedure Set_Null_Exclusion_Present\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition\n+        or else NT (N).Nkind = N_Access_Function_Definition\n+        or else NT (N).Nkind = N_Access_Procedure_Definition\n+        or else NT (N).Nkind = N_Access_To_Object_Definition\n+        or else NT (N).Nkind = N_Allocator\n+        or else NT (N).Nkind = N_Component_Definition\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Discriminant_Specification\n+        or else NT (N).Nkind = N_Object_Declaration\n+        or else NT (N).Nkind = N_Parameter_Specification\n+        or else NT (N).Nkind = N_Subtype_Declaration);\n+      Set_Flag9 (N, Val);\n+   end Set_Null_Exclusion_Present;\n+\n    procedure Set_Null_Record_Present\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "c6ea9e863165c0e6689b38616412247663ce5a97", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -1883,6 +1883,7 @@ package Sinfo is\n       --  N_Subtype_Declaration\n       --  Sloc points to SUBTYPE\n       --  Defining_Identifier (Node1)\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Subtype_Indication (Node5)\n       --  Generic_Parent_Type (Node4-Sem) (set for an actual derived type).\n       --  Exception_Junk (Flag11-Sem)\n@@ -1989,6 +1990,7 @@ package Sinfo is\n       --  Defining_Identifier (Node1)\n       --  Aliased_Present (Flag4) set if ALIASED appears\n       --  Constant_Present (Flag17) set if CONSTANT appears\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Object_Definition (Node4) subtype indication/array type definition\n       --  Expression (Node3) (set to Empty if not present)\n       --  Handler_List_Entry (Node2-Sem)\n@@ -2044,6 +2046,7 @@ package Sinfo is\n       --  N_Derived_Type_Definition\n       --  Sloc points to NEW\n       --  Abstract_Present (Flag4)\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Subtype_Indication (Node5)\n       --  Record_Extension_Part (Node3) (set to Empty if not present)\n \n@@ -2338,6 +2341,7 @@ package Sinfo is\n       --  N_Component_Definition\n       --  Sloc points to ALIASED, ACCESS or to first token of subtype mark\n       --  Aliased_Present (Flag4)\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Subtype_Indication (Node5) (set to Empty if not present)\n       --  Access_Definition (Node3) (set to Empty if not present)\n \n@@ -2410,6 +2414,7 @@ package Sinfo is\n       --  N_Discriminant_Specification\n       --  Sloc points to first identifier\n       --  Defining_Identifier (Node1)\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Discriminant_Type (Node5) subtype mark or\n       --    access parameter definition\n       --  Expression (Node3) (set to Empty if no default expression)\n@@ -2641,6 +2646,7 @@ package Sinfo is\n       --  N_Access_To_Object_Definition\n       --  Sloc points to ACCESS\n       --  All_Present (Flag15)\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Subtype_Indication (Node5)\n       --  Constant_Present (Flag17)\n \n@@ -2668,12 +2674,14 @@ package Sinfo is\n \n       --  N_Access_Function_Definition\n       --  Sloc points to ACCESS\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Protected_Present (Flag15)\n       --  Parameter_Specifications (List3) (set to No_List if no formal part)\n       --  Subtype_Mark (Node4) result subtype\n \n       --  N_Access_Procedure_Definition\n       --  Sloc points to ACCESS\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Protected_Present (Flag15)\n       --  Parameter_Specifications (List3) (set to No_List if no formal part)\n \n@@ -2685,6 +2693,9 @@ package Sinfo is\n \n       --  N_Access_Definition\n       --  Sloc points to ACCESS\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  All_Present (Flag15)\n+      --  Constant_Present (Flag17)\n       --  Subtype_Mark (Node4)\n \n       -----------------------------------------\n@@ -3482,6 +3493,7 @@ package Sinfo is\n       --  N_Allocator\n       --  Sloc points to NEW\n       --  Expression (Node3) subtype indication or qualified expression\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Storage_Pool (Node1-Sem)\n       --  Procedure_To_Call (Node4-Sem)\n       --  No_Initialization (Flag13-Sem)\n@@ -3996,6 +4008,7 @@ package Sinfo is\n       --  Defining_Identifier (Node1)\n       --  In_Present (Flag15)\n       --  Out_Present (Flag17)\n+      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  Parameter_Type (Node2) subtype mark or access definition\n       --  Expression (Node3) (set to Empty if no default expression present)\n       --  Do_Accessibility_Check (Flag13-Sem)\n@@ -7444,6 +7457,9 @@ package Sinfo is\n    function Null_Present\n      (N : Node_Id) return Boolean;    -- Flag13\n \n+   function Null_Exclusion_Present\n+     (N : Node_Id) return Boolean;    -- Flag9\n+\n    function Null_Record_Present\n      (N : Node_Id) return Boolean;    -- Flag17\n \n@@ -8230,6 +8246,9 @@ package Sinfo is\n    procedure Set_Null_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n+   procedure Set_Null_Exclusion_Present\n+     (N : Node_Id; Val : Boolean := True);    -- Flag9\n+\n    procedure Set_Null_Record_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n@@ -8661,6 +8680,7 @@ package Sinfo is\n    pragma Inline (No_Initialization);\n    pragma Inline (No_Truncation);\n    pragma Inline (Null_Present);\n+   pragma Inline (Null_Exclusion_Present);\n    pragma Inline (Null_Record_Present);\n    pragma Inline (Object_Definition);\n    pragma Inline (OK_For_Stream);\n@@ -8919,6 +8939,7 @@ package Sinfo is\n    pragma Inline (Set_No_Initialization);\n    pragma Inline (Set_No_Truncation);\n    pragma Inline (Set_Null_Present);\n+   pragma Inline (Set_Null_Exclusion_Present);\n    pragma Inline (Set_Null_Record_Present);\n    pragma Inline (Set_Object_Definition);\n    pragma Inline (Set_OK_For_Stream);"}, {"sha": "7a2917fba1ed936963b37be5919521862306bada", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -30,7 +30,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Namet;    use Namet;\n-with Opt;\n+with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n with Prep;     use Prep;\n@@ -78,9 +78,8 @@ package body Sinput.L is\n    --  Used to initialize the preprocessor.\n \n    function Load_File\n-     (N    : File_Name_Type;\n-      T    : Osint.File_Type)\n-      return Source_File_Index;\n+     (N : File_Name_Type;\n+      T : Osint.File_Type) return Source_File_Index;\n    --  Load a source file, a configuration pragmas file or a definition file\n    --  Coding also allows preprocessing file, but not a library file ???\n \n@@ -265,8 +264,7 @@ package body Sinput.L is\n    ----------------------\n \n    function Load_Config_File\n-     (N    : File_Name_Type)\n-      return Source_File_Index\n+     (N : File_Name_Type) return Source_File_Index\n    is\n    begin\n       return Load_File (N, Osint.Config);\n@@ -277,8 +275,7 @@ package body Sinput.L is\n    --------------------------\n \n    function Load_Definition_File\n-     (N    : File_Name_Type)\n-      return Source_File_Index\n+     (N : File_Name_Type) return Source_File_Index\n    is\n    begin\n       return Load_File (N, Osint.Definition);\n@@ -289,9 +286,8 @@ package body Sinput.L is\n    ---------------\n \n    function Load_File\n-     (N :    File_Name_Type;\n-      T :    Osint.File_Type)\n-      return Source_File_Index\n+     (N : File_Name_Type;\n+      T : Osint.File_Type) return Source_File_Index\n    is\n       Src : Source_Buffer_Ptr;\n       X   : Source_File_Index;\n@@ -301,11 +297,21 @@ package body Sinput.L is\n       Preprocessing_Needed : Boolean := False;\n \n    begin\n-      for J in 1 .. Source_File.Last loop\n-         if Source_File.Table (J).File_Name = N then\n-            return J;\n-         end if;\n-      end loop;\n+      --  If already there, don't need to reload file. An exception occurs\n+      --  in multiple unit per file mode. It would be nice in this case to\n+      --  share the same source file for each unit, but this leads to many\n+      --  difficulties with assumptions (e.g. in the body of lib), that a\n+      --  unit can be found by locating its source file index. Since we do\n+      --  not expect much use of this mode, it's no big deal to waste a bit\n+      --  of space and time by reading and storing the source multiple times.\n+\n+      if Multiple_Unit_Index = 0 then\n+         for J in 1 .. Source_File.Last loop\n+            if Source_File.Table (J).File_Name = N then\n+               return J;\n+            end if;\n+         end loop;\n+      end if;\n \n       --  Here we must build a new entry in the file table\n \n@@ -584,8 +590,7 @@ package body Sinput.L is\n    ----------------------------------\n \n    function Load_Preprocessing_Data_File\n-     (N    : File_Name_Type)\n-      return Source_File_Index\n+     (N : File_Name_Type) return Source_File_Index\n    is\n    begin\n       return Load_File (N, Osint.Preprocessing_Data);\n@@ -596,8 +601,7 @@ package body Sinput.L is\n    ----------------------\n \n    function Load_Source_File\n-     (N    : File_Name_Type)\n-      return Source_File_Index\n+     (N : File_Name_Type) return Source_File_Index\n    is\n    begin\n       return Load_File (N, Osint.Source);"}, {"sha": "3d71afd0deec16bbf7abc5eab67ab22ce5210546", "filename": "gcc/ada/sinput-l.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinput-l.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsinput-l.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.ads?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,14 +54,14 @@ package Sinput.L is\n    --  The file is never preprocessed.\n \n    function Load_Definition_File\n-     (N    : File_Name_Type)\n-      return Source_File_Index;\n-   --  Needs comments ???\n+     (N : File_Name_Type) return Source_File_Index;\n+   --  Loads preprocessing definition file. Similar to Load_Source_File\n+   --  except that this file is not itself preprocessed.\n \n    function Load_Preprocessing_Data_File\n-     (N    : File_Name_Type)\n-      return Source_File_Index;\n-   --  Similar to Load_Source_File, except that the file is never preprocessed.\n+     (N : File_Name_Type) return Source_File_Index;\n+   --  Loads preprocessing data file. Similar to Load_Source_File except\n+   --  that this file is not itself preprocessed.\n \n    procedure Complete_Source_File_Entry;\n    --  Called on completing the parsing of a source file. This call completes"}, {"sha": "8c936705b47e73c1e4c28f3511d6d12f56d2ce93", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -692,10 +692,24 @@ package body Sprint is\n             Write_Char (';');\n \n          when N_Access_Definition =>\n+\n+            --  Ada 0Y (AI-231)\n+\n+            if Null_Exclusion_Present (Node) then\n+               Write_Str (\"not null \");\n+            end if;\n+\n             Write_Str_With_Col_Check_Sloc (\"access \");\n             Sprint_Node (Subtype_Mark (Node));\n \n          when N_Access_Function_Definition =>\n+\n+            --  Ada 0Y (AI-231)\n+\n+            if Null_Exclusion_Present (Node) then\n+               Write_Str (\"not null \");\n+            end if;\n+\n             Write_Str_With_Col_Check_Sloc (\"access \");\n \n             if Protected_Present (Node) then\n@@ -708,6 +722,12 @@ package body Sprint is\n             Sprint_Node (Subtype_Mark (Node));\n \n          when N_Access_Procedure_Definition =>\n+            --  Ada 0Y (AI-231)\n+\n+            if Null_Exclusion_Present (Node) then\n+               Write_Str (\"not null \");\n+            end if;\n+\n             Write_Str_With_Col_Check_Sloc (\"access \");\n \n             if Protected_Present (Node) then\n@@ -726,6 +746,12 @@ package body Sprint is\n                Write_Str_With_Col_Check (\"constant \");\n             end if;\n \n+            --  Ada 0Y (AI-231)\n+\n+            if Null_Exclusion_Present (Node) then\n+               Write_Str (\"not null \");\n+            end if;\n+\n             Sprint_Node (Subtype_Indication (Node));\n \n          when N_Aggregate =>\n@@ -774,6 +800,12 @@ package body Sprint is\n \n          when N_Allocator =>\n             Write_Str_With_Col_Check_Sloc (\"new \");\n+            --  Ada 0Y (AI-231)\n+\n+            if Null_Exclusion_Present (Node) then\n+               Write_Str (\"not null \");\n+            end if;\n+\n             Sprint_Node (Expression (Node));\n \n             if Present (Storage_Pool (Node)) then\n@@ -962,6 +994,12 @@ package body Sprint is\n                   Write_Str_With_Col_Check (\"aliased \");\n                end if;\n \n+               --  Ada 0Y (AI-231)\n+\n+               if Null_Exclusion_Present (Node) then\n+                  Write_Str (\" not null \");\n+               end if;\n+\n                Sprint_Node (Subtype_Indication (Node));\n             else\n                pragma Assert (False);\n@@ -1084,6 +1122,13 @@ package body Sprint is\n             end if;\n \n             Write_Str_With_Col_Check_Sloc (\"new \");\n+\n+            --  Ada 0Y (AI-231)\n+\n+            if Null_Exclusion_Present (Node) then\n+               Write_Str_With_Col_Check (\"not null \");\n+            end if;\n+\n             Sprint_Node (Subtype_Indication (Node));\n \n             if Present (Record_Extension_Part (Node)) then\n@@ -1117,6 +1162,11 @@ package body Sprint is\n \n             if Write_Identifiers (Node) then\n                Write_Str (\" : \");\n+\n+               if Null_Exclusion_Present (Node) then\n+                  Write_Str (\"not null \");\n+               end if;\n+\n                Sprint_Node (Discriminant_Type (Node));\n \n                if Present (Expression (Node)) then\n@@ -1688,6 +1738,12 @@ package body Sprint is\n                   Write_Str_With_Col_Check (\"constant \");\n                end if;\n \n+               --  Ada 0Y (AI-231)\n+\n+               if Null_Exclusion_Present (Node) then\n+                  Write_Str_With_Col_Check (\"not null \");\n+               end if;\n+\n                Sprint_Node (Object_Definition (Node));\n \n                if Present (Expression (Node)) then\n@@ -1942,6 +1998,12 @@ package body Sprint is\n                   Write_Str_With_Col_Check (\"out \");\n                end if;\n \n+               --  Ada 0Y (AI-231)\n+\n+               if Null_Exclusion_Present (Node) then\n+                  Write_Str (\"not null \");\n+               end if;\n+\n                Sprint_Node (Parameter_Type (Node));\n \n                if Present (Expression (Node)) then\n@@ -2326,6 +2388,13 @@ package body Sprint is\n             Write_Indent_Str_Sloc (\"subtype \");\n             Write_Id (Defining_Identifier (Node));\n             Write_Str (\" is \");\n+\n+            --  Ada 0Y (AI-231)\n+\n+            if Null_Exclusion_Present (Node) then\n+               Write_Str (\"not null \");\n+            end if;\n+\n             Sprint_Node (Subtype_Indication (Node));\n             Write_Char (';');\n "}, {"sha": "fab690a2a2f5d0a63ea6ecdcde3ebe1f935ad4bd", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2820d220585177ca4e2e3136bf8ff255303ba6db/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=2820d220585177ca4e2e3136bf8ff255303ba6db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -220,6 +220,12 @@ package body Switch.C is\n                   ASIS_Mode := True;\n                end if;\n \n+            --  Processing for C switch\n+\n+            when 'C' =>\n+               Ptr := Ptr + 1;\n+               Scan_Pos (Switch_Chars, 999, Ptr, Multiple_Unit_Index);\n+\n             --  Processing for d switch\n \n             when 'd' =>"}]}