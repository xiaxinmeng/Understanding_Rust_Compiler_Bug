{"sha": "78757caa17dac295834129518cffc87f778cf66f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg3NTdjYWExN2RhYzI5NTgzNDEyOTUxOGNmZmM4N2Y3NzhjZjY2Zg==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-05-10T11:29:53Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-05-10T11:29:53Z"}, "message": "re PR c++/9252 ([New parser] Errors due to legally used \"typename\")\n\n\tPR c++/9252\n\t* cp-tree.h (saved_scope): Remove check_access field.\n\t(tsubst_flags_t): Remove tf_parsing.\n\t* decl.c (maybe_push_to_top_level): Don't initialize\n\tscope_chain->check_access.\n\t(make_typename_type, make_unbound_class_template): Don't use\n\ttf_parsing.\n\t(register_dtor_fn): Use push/pop_deferring_access_checks\n\tinstead of scope_chain->check_access.\n\t* method.c (use_thunk): Likewise.\n\t* parser.c (cp_parser_explicit_instantiation\n\t(cp_parser_constructor_declarator_p): Don't call\n\tpush/pop_deferring_access_checks here.\n\t(cp_parser_template_argument, cp_parser_class_name): Don't use\n\ttf_parsing.\n\t(yyparse): Check flag_access_control.\n\t* pt.c (instantiate_class_template): Call\n\tpush/pop_deferring_access_checks.\n\t* semantics.c (push_deferring_access_checks): Propagate\n\tdk_no_check.\n\t(perform_or_defer_access_check): Make sure basetype_path is\n\ta type before comparison.\n\t* call.c (build_op_delete_call, build_over_call): Use\n\tperform_or_defer_access_check.\n\t* class.c (alter_access): Likewise.\n\t* init.c (build_offset_ref): Likewise.\n\t* lex.c (do_identifier): Likewise.\n\t* method.c (hack_identifier): Likewise.\n\t* search.c (lookup_member): Likewise.\n\t* semantics.c (finish_non_static_data_member): Likewise.\n\t(simplify_aggr_init_exprs_r): Use push/pop_deferring_access_checks\n\tinstead of flag_access_control.\n\n\t* g++.dg/parse/access8.C: New test.\n\t* g++.dg/parse/access9.C: New test.\n\nFrom-SVN: r66660", "tree": {"sha": "c56f80b0b8d2950e80b44d92a5f02235bdc24b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c56f80b0b8d2950e80b44d92a5f02235bdc24b54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78757caa17dac295834129518cffc87f778cf66f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78757caa17dac295834129518cffc87f778cf66f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78757caa17dac295834129518cffc87f778cf66f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78757caa17dac295834129518cffc87f778cf66f/comments", "author": null, "committer": null, "parents": [{"sha": "8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d241e0b5734bb89d46fc9b6884f78ad70ff453c"}], "stats": {"total": 175, "additions": 115, "deletions": 60}, "files": [{"sha": "81645ceeddb045a36a9bef7738f6b258d63dd138", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -1,3 +1,38 @@\n+2003-05-10  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/9252\n+\t* cp-tree.h (saved_scope): Remove check_access field.\n+\t(tsubst_flags_t): Remove tf_parsing.\n+\t* decl.c (maybe_push_to_top_level): Don't initialize\n+\tscope_chain->check_access.\n+\t(make_typename_type, make_unbound_class_template): Don't use\n+\ttf_parsing.\n+\t(register_dtor_fn): Use push/pop_deferring_access_checks\n+\tinstead of scope_chain->check_access.\n+\t* method.c (use_thunk): Likewise.\n+\t* parser.c (cp_parser_explicit_instantiation\n+\t(cp_parser_constructor_declarator_p): Don't call\n+\tpush/pop_deferring_access_checks here.\n+\t(cp_parser_template_argument, cp_parser_class_name): Don't use\n+\ttf_parsing.\n+\t(yyparse): Check flag_access_control.\n+\t* pt.c (instantiate_class_template): Call\n+\tpush/pop_deferring_access_checks.\n+\t* semantics.c (push_deferring_access_checks): Propagate\n+\tdk_no_check.\n+\t(perform_or_defer_access_check): Make sure basetype_path is\n+\ta type before comparison.\n+\t* call.c (build_op_delete_call, build_over_call): Use\n+\tperform_or_defer_access_check.\n+\t* class.c (alter_access): Likewise.\n+\t* init.c (build_offset_ref): Likewise.\n+\t* lex.c (do_identifier): Likewise.\n+\t* method.c (hack_identifier): Likewise.\n+\t* search.c (lookup_member): Likewise.\n+\t* semantics.c (finish_non_static_data_member): Likewise.\n+\t(simplify_aggr_init_exprs_r): Use push/pop_deferring_access_checks\n+\tinstead of flag_access_control.\n+\n 2003-05-10  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/9554"}, {"sha": "84bdcd640d67a941600fb762f996d07d224a7753", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -4062,7 +4062,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       /* If the FN is a member function, make sure that it is\n \t accessible.  */\n       if (DECL_CLASS_SCOPE_P (fn))\n-\tenforce_access (type, fn);\n+\tperform_or_defer_access_check (type, fn);\n \n       if (pass == 0)\n \targs = tree_cons (NULL_TREE, addr, args);\n@@ -4513,7 +4513,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       joust (cand, WRAPPER_ZC (TREE_VALUE (val)), 1);\n \n   if (DECL_FUNCTION_MEMBER_P (fn))\n-    enforce_access (cand->access_path, fn);\n+    perform_or_defer_access_check (cand->access_path, fn);\n \n   if (args && TREE_CODE (args) != TREE_LIST)\n     args = build_tree_list (NULL_TREE, args);"}, {"sha": "c693fdf8e610ec8ed5f3cbf9e27cbfd144bf8706", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -1086,7 +1086,7 @@ alter_access (tree t, tree fdecl, tree access)\n     }\n   else\n     {\n-      enforce_access (t, fdecl);\n+      perform_or_defer_access_check (t, fdecl);\n       DECL_ACCESS (fdecl) = tree_cons (t, access, DECL_ACCESS (fdecl));\n       return 1;\n     }"}, {"sha": "33983982222977006d0bd4fbc69a97d4982993e4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -696,7 +696,6 @@ struct saved_scope GTY(())\n   int x_processing_specialization;\n   bool x_processing_explicit_instantiation;\n   int need_pop_function_context;\n-  int check_access;\n \n   struct stmt_tree_s x_stmt_tree;\n \n@@ -3013,10 +3012,8 @@ typedef enum tsubst_flags_t {\n   tf_ignore_bad_quals = 1 << 3, /* ignore bad cvr qualifiers */\n   tf_keep_type_decl = 1 << 4,\t/* retain typedef type decls\n \t\t\t\t   (make_typename_type use) */\n-  tf_ptrmem_ok = 1 << 5,     /* pointers to member ok (internal\n+  tf_ptrmem_ok = 1 << 5      /* pointers to member ok (internal\n \t\t\t\tinstantiate_type use) */\n-  tf_parsing = 1 << 6\t     /* called from parser\n-\t\t\t\t(make_typename_type use) */\n } tsubst_flags_t;\n \n /* The kind of checking we can do looking in a class hierarchy.  */"}, {"sha": "4bec8a60368f1d3f521a291f3f11ec72003515ca", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -2242,7 +2242,6 @@ maybe_push_to_top_level (int pseudo)\n   s->need_pop_function_context = need_pop;\n   s->function_decl = current_function_decl;\n   s->last_parms = last_function_parms;\n-  s->check_access = flag_access_control;\n \n   scope_chain = s;\n   current_function_decl = NULL_TREE;\n@@ -5481,12 +5480,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t    }\n \n \t  if (complain & tf_error)\n-\t    {\n-\t      if (complain & tf_parsing)\n-\t\tperform_or_defer_access_check (context, tmpl);\n-\t      else\n-\t\tenforce_access (context, tmpl);\n-\t    }\n+\t    perform_or_defer_access_check (context, tmpl);\n \n \t  return lookup_template_class (tmpl,\n \t\t\t\t\tTREE_OPERAND (fullname, 1),\n@@ -5516,12 +5510,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t\t}\n \n \t      if (complain & tf_error)\n-\t\t{\n-\t      \t  if (complain & tf_parsing)\n-\t\t    perform_or_defer_access_check (context, t);\n-\t\t  else\n-\t\t    enforce_access (context, t);\n-\t\t}\n+\t\tperform_or_defer_access_check (context, t);\n \n \t      if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n \t\tt = TREE_TYPE (t);\n@@ -5578,12 +5567,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n \t}\n       \n       if (complain & tf_error)\n-\t{\n-\t  if (complain & tf_parsing)\n-\t    perform_or_defer_access_check (context, tmpl);\n-\t  else\n-\t    enforce_access (context, tmpl);\n-\t}\n+\tperform_or_defer_access_check (context, tmpl);\n \n       return tmpl;\n     }\n@@ -8447,7 +8431,6 @@ register_dtor_fn (tree decl)\n   tree compound_stmt;\n   tree args;\n   tree fcall;\n-  int saved_flag_access_control;\n \n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n@@ -8464,10 +8447,10 @@ register_dtor_fn (tree decl)\n      to the original function, rather than the anonymous one.  That\n      will make the back-end think that nested functions are in use,\n      which causes confusion.  */\n-  saved_flag_access_control = flag_access_control;\n-  scope_chain->check_access = flag_access_control = 0;\n+  \n+  push_deferring_access_checks (dk_no_check);\n   fcall = build_cleanup (decl);\n-  scope_chain->check_access = flag_access_control = saved_flag_access_control;\n+  pop_deferring_access_checks ();\n \n   /* Create the body of the anonymous function.  */\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);"}, {"sha": "4b6fdc81c865eca7133976bbf99231eb911bd45e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -1662,8 +1662,7 @@ build_offset_ref (type, name)\n \t  t = OVL_CURRENT (t);\n \n \t  /* unique functions are handled easily.  */\n-\t  if (!enforce_access (basebinfo, t))\n-\t    return error_mark_node;\n+\t  perform_or_defer_access_check (basebinfo, t);\n \t  mark_used (t);\n \t  if (DECL_STATIC_FUNCTION_P (t))\n \t    return t;"}, {"sha": "816f9e38c77f7169c8c058566db27278694cefe1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -792,7 +792,7 @@ do_identifier (token, args)\n     {\n       /* Check access.  */\n       if (IDENTIFIER_CLASS_VALUE (token) == id)\n-\tenforce_access (CP_DECL_CONTEXT(id), id);\n+\tperform_or_defer_access_check (CP_DECL_CONTEXT(id), id);\n       if (!processing_template_decl || DECL_TEMPLATE_PARM_P (id))\n \tid = DECL_INITIAL (id);\n     }"}, {"sha": "12fa9230b4cd3686af5d960a9713af90be7914a5", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -179,7 +179,7 @@ hack_identifier (tree value, tree name)\n \t{\n \t  tree path;\n \t  path = currently_open_derived_class (DECL_CONTEXT (value));\n-\t  enforce_access (path, value);\n+\t  perform_or_defer_access_check (path, value);\n \t}\n     }\n   else if (TREE_CODE (value) == TREE_LIST \n@@ -452,7 +452,6 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t doesn't work for varargs.  */\n \n       tree a, t;\n-      int saved_check_access;\n \n       if (varargs_function_p (function))\n \terror (\"generic thunk code fails for method `%#D' which uses `...'\",\n@@ -475,8 +474,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       /* We don't bother with a body block for thunks.  */\n \n       /* There's no need to check accessibility inside the thunk body.  */\n-      saved_check_access = scope_chain->check_access;\n-      scope_chain->check_access = 0;\n+      push_deferring_access_checks (dk_no_check);\n \n       t = a;\n       if (this_adjusting)\n@@ -506,7 +504,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       DECL_IGNORED_P (thunk_fndecl) = 1;\n \n       /* Re-enable access control.  */\n-      scope_chain->check_access = saved_check_access;\n+      pop_deferring_access_checks ();\n \n       expand_body (finish_function (0));\n     }"}, {"sha": "1d0ab40b4cf21a8fbe5e835fde56c5117d4a0db6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -8244,7 +8244,7 @@ cp_parser_template_argument (cp_parser* parser)\n       if (template_p)\n \targument = make_unbound_class_template (TREE_OPERAND (argument, 0),\n \t\t\t\t\t\tTREE_OPERAND (argument, 1),\n-\t\t\t\t\t\ttf_error | tf_parsing);\n+\t\t\t\t\t\ttf_error);\n       else if (TREE_CODE (argument) != TEMPLATE_DECL)\n \tcp_parser_error (parser, \"expected template-name\");\n     }\n@@ -8301,7 +8301,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n   begin_explicit_instantiation ();\n   /* [temp.explicit] says that we are supposed to ignore access\n      control while processing explicit instantiation directives.  */\n-  scope_chain->check_access = 0;\n+  push_deferring_access_checks (dk_no_check);\n   /* Parse a decl-specifier-seq.  */\n   decl_specifiers \n     = cp_parser_decl_specifier_seq (parser,\n@@ -8336,7 +8336,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n   /* We're done with the instantiation.  */\n   end_explicit_instantiation ();\n   /* Turn access control back on.  */\n-  scope_chain->check_access = flag_access_control;\n+  pop_deferring_access_checks ();\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n }\n@@ -11390,8 +11390,7 @@ cp_parser_class_name (cp_parser *parser,\n        standard does not seem to be definitive, but there is no other\n        valid interpretation of the following `::'.  Therefore, those\n        names are considered class-names.  */\n-    decl = TYPE_NAME (make_typename_type (scope, decl, \n-\t\t\t\t\t  tf_error | tf_parsing));\n+    decl = TYPE_NAME (make_typename_type (scope, decl, tf_error));\n   else if (decl == error_mark_node\n \t   || TREE_CODE (decl) != TYPE_DECL\n \t   || !IS_AGGR_TYPE (TREE_TYPE (decl)))\n@@ -11450,6 +11449,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   saved_num_template_parameter_lists \n     = parser->num_template_parameter_lists; \n   parser->num_template_parameter_lists = 0;\n+\n   /* Start the class.  */\n   type = begin_class_definition (type);\n   if (type == error_mark_node)\n@@ -13646,8 +13646,6 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n   /* Assume that we are looking at a constructor declarator.  */\n   constructor_p = true;\n \n-  push_deferring_access_checks (dk_no_check);\n-\n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser,\n \t\t\t      /*current_scope_valid_p=*/false);\n@@ -13689,8 +13687,6 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n       constructor_p = !cp_parser_error_occurred (parser);\n     }\n \n-  pop_deferring_access_checks ();\n-\n   /* If we're still considering a constructor, we have to see a `(',\n      to begin the parameter-declaration-clause, followed by either a\n      `)', an `...', or a decl-specifier.  We need to check for a\n@@ -14664,7 +14660,8 @@ yyparse (void)\n   bool error_occurred;\n \n   the_parser = cp_parser_new ();\n-  push_deferring_access_checks (dk_no_deferred);\n+  push_deferring_access_checks (flag_access_control\n+\t\t\t\t? dk_no_deferred : dk_no_check);\n   error_occurred = cp_parser_translation_unit (the_parser);\n   the_parser = NULL;\n   "}, {"sha": "972bdab265a40de8644d8311c5d152d68e5e63c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -5259,6 +5259,10 @@ instantiate_class_template (type)\n      the process of being defined.  */\n   TYPE_BEING_DEFINED (type) = 1;\n \n+  /* We may be in the middle of deferred access check.  Disable\n+     it now.  */\n+  push_deferring_access_checks (dk_no_deferred);\n+\n   maybe_push_to_top_level (uses_template_parms (type));\n \n   if (t)\n@@ -5568,6 +5572,7 @@ instantiate_class_template (type)\n \n   popclass ();\n   pop_from_top_level ();\n+  pop_deferring_access_checks ();\n   pop_tinst_level ();\n \n   if (TYPE_CONTAINS_VPTR_P (type))"}, {"sha": "f9fa16641edce9102d41a4ec417344bcc1efde72", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -913,10 +913,6 @@ accessible_p (tree type, tree decl)\n      accessibility in TYPE.  */\n   int protected_ok = 0;\n \n-  /* If we're not checking access, everything is accessible.  */\n-  if (!scope_chain->check_access)\n-    return 1;\n-\n   /* If this declaration is in a block or namespace scope, there's no\n      access control.  */\n   if (!TYPE_P (context_for_name_lookup (decl)))\n@@ -1293,9 +1289,8 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n \n      In the case of overloaded function names, access control is\n      applied to the function selected by overloaded resolution.  */\n-  if (rval && protect && !is_overloaded_fn (rval)\n-      && !enforce_access (xbasetype, rval))\n-    return error_mark_node;\n+  if (rval && protect && !is_overloaded_fn (rval))\n+    perform_or_defer_access_check (xbasetype, rval);\n \n   if (errstr && protect)\n     {"}, {"sha": "62a900a95b512293efd7fbcc128e34ee5da08a22", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -141,6 +141,12 @@ void push_deferring_access_checks (deferring_kind deferring)\n {\n   deferred_access *d;\n \n+  /* For context like template instantiation, access checking\n+     disabling applies to all nested context.  */\n+  if (deferred_access_stack\n+      && deferred_access_stack->deferring_access_checks_kind == dk_no_check)\n+    deferring = dk_no_check;\n+\n   /* Recycle previously used free store if available.  */\n   if (deferred_access_free_list)\n     {\n@@ -266,6 +272,7 @@ void perform_or_defer_access_check (tree class_type, tree decl)\n        check;\n        check = TREE_CHAIN (check))\n     if (TREE_VALUE (check) == decl\n+\t&& TYPE_P (TREE_PURPOSE (check))\n \t&& same_type_p (TREE_PURPOSE (check), class_type))\n       return;\n   /* If not, record the check.  */\n@@ -1276,7 +1283,7 @@ finish_non_static_data_member (tree decl, tree qualifying_scope)\n \t    access_type = DECL_CONTEXT (access_type);\n \t}\n \n-      enforce_access (access_type, decl);\n+      perform_or_defer_access_check (access_type, decl);\n \n       /* If the data member was named `C::M', convert `*this' to `C'\n \t first.  */\n@@ -2301,12 +2308,10 @@ simplify_aggr_init_exprs_r (tp, walk_subtrees, data)\n       /* If we're using the non-reentrant PCC calling convention, then we\n \t need to copy the returned value out of the static buffer into the\n \t SLOT.  */\n-      int old_ac = flag_access_control;\n-\n-      flag_access_control = 0;\n+      push_deferring_access_checks (dk_no_check);\n       call_expr = build_aggr_init (slot, call_expr,\n \t\t\t\t   DIRECT_BIND | LOOKUP_ONLYCONVERTING);\n-      flag_access_control = old_ac;\n+      pop_deferring_access_checks ();\n     }\n \n   /* We want to use the value of the initialized location as the"}, {"sha": "b86bff67fc33b71b6d0005d0bdb82fc5fa851731", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -1,3 +1,9 @@\n+2003-05-10  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/9252\n+\t* g++.dg/template/access8.C: New test.\n+\t* g++.dg/template/access9.C: New test.\n+\n 2003-05-10  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/9554"}, {"sha": "4bdadae3c2b08b71210c0cda81e8fa3d47e035fe", "filename": "gcc/testsuite/g++.dg/template/access8.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess8.C?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -0,0 +1,16 @@\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+// { dg-do compile }\n+\n+// Template instantiate during deferred access check\n+\n+template <class T> struct C {\n+  typedef typename T::X Y;\n+};\n+\n+class A {\n+  typedef int X;\n+  template <class T> friend struct C;\n+};\n+\n+C<A>::Y f(int);"}, {"sha": "b24c93f8d5e3789e28cd8c99daa2c8c836e5b376", "filename": "gcc/testsuite/g++.dg/template/access9.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78757caa17dac295834129518cffc87f778cf66f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78757caa17dac295834129518cffc87f778cf66f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess9.C?ref=78757caa17dac295834129518cffc87f778cf66f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+// { dg-do compile }\n+\n+// Template instantiate during deferred access check\n+\n+template <void (*)(int)> struct C {\n+  typedef int Y;\n+};\n+\n+template <class T> void f(typename T::X) {\n+}\n+\n+class A {\n+  typedef int X;\n+  template <class T> friend void f(typename T::X);\n+};\n+\n+C<&f<A> >::Y g(int);"}]}