{"sha": "820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIwNDEwZTBkNWYwNzI2YjE3Yzk4ZWQyOGZmNGJkYjUyZDRlYzNhNg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-01-12T00:17:50Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-12T00:17:50Z"}, "message": "re PR tree-optimization/29516 (gfortran miscompiled)\n\n\tPR tree-optimization/29516\n\t* tree-ssa-address.c (tree_mem_ref_addr, add_to_parts,\n\tmost_expensive_mult_to_index, addr_to_parts,\n\tcreate_mem_ref, maybe_fold_tmr): Make the type of\n\tfields of TARGET_MEM_REF sizetype.\n\t(move_fixed_address_to_symbol, move_pointer_to_base):\n\tNew functions.\n\t* tree.def (TARGET_MEM_REF): Add comment on types of\n\tthe operands.\n\t* gcc.dg/tree-ssa/loop-20.c: New test.\n\nFrom-SVN: r120695", "tree": {"sha": "4f0ceeb55e07fcd9ef99ed14270909b4ee266f73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f0ceeb55e07fcd9ef99ed14270909b4ee266f73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/comments", "author": null, "committer": null, "parents": [{"sha": "2d3cb33a102caf5615263011a3a35ff7149b482a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d3cb33a102caf5615263011a3a35ff7149b482a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d3cb33a102caf5615263011a3a35ff7149b482a"}], "stats": {"total": 282, "additions": 191, "deletions": 91}, "files": [{"sha": "db3eb04b889cd6a3a20bd95df90a4c212c7e6a51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "patch": "@@ -1,3 +1,16 @@\n+2007-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/29516\n+\t* tree-ssa-address.c (tree_mem_ref_addr, add_to_parts,\n+\tmost_expensive_mult_to_index, addr_to_parts,\n+\tcreate_mem_ref, maybe_fold_tmr): Make the type of\n+\tfields of TARGET_MEM_REF sizetype.\n+\t(move_fixed_address_to_symbol, move_pointer_to_base):\n+\tNew functions.\n+\t* tree.def (TARGET_MEM_REF): Add comment on types of\n+\tthe operands.\n+\t* gcc.dg/tree-ssa/loop-20.c: New test.\n+\n 2007-01-11  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-common.c (vector_types_convertible_p): Treat opaque types as"}, {"sha": "24524a02b4b240bd1dd9ad9b5635f0e638c90bae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-20.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-20.c?ref=820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "patch": "@@ -0,0 +1,23 @@\n+/* PR tree-optimization/29516 */\n+\n+/* { dg-do compile { target fpic } } */\n+/* { dg-options \"-O -ftree-vrp -fPIC -fdump-tree-ivopts\" } */\n+\n+typedef struct gfc_se { int pre; } gfc_se;\n+typedef struct gfc_ss_info { int dim[7]; } gfc_ss_info;\n+int gfc_rank_cst[7 + 1];\n+gfc_conv_array_transpose (gfc_se * se) {\n+  int dest, src, dest_index, src_index;\n+  gfc_ss_info *dest_info;\n+  int n;\n+  for (n = 0; n < 2; n++) {\n+    dest_info->dim[n] = n;\n+    src_index = gfc_rank_cst[1 - n];\n+    a (se->pre, b (dest, dest_index), c (src, src_index));\n+  }\n+}\n+\n+/* Ivopts should not produce multiplication by a pointer constant.  */\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\* \\[0-9\\]*B;\" 0 \"ivopts\" } } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "c103a1a161c50c221b6cfe38ba6a72237a3b19ad", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 152, "deletions": 91, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "patch": "@@ -244,54 +244,54 @@ addr_for_mem_ref (struct mem_address *addr, bool really_expand)\n tree\n tree_mem_ref_addr (tree type, tree mem_ref)\n {\n-  tree addr = NULL_TREE;\n+  tree addr;\n   tree act_elem;\n   tree step = TMR_STEP (mem_ref), offset = TMR_OFFSET (mem_ref);\n+  tree sym = TMR_SYMBOL (mem_ref), base = TMR_BASE (mem_ref);\n+  tree addr_base = NULL_TREE, addr_off = NULL_TREE;\n \n-  act_elem = TMR_INDEX (mem_ref);\n-  if (act_elem)\n+  if (sym)\n+    addr_base = fold_convert (type, build_addr (sym, current_function_decl));\n+  else if (base && POINTER_TYPE_P (TREE_TYPE (base)))\n     {\n-      act_elem = fold_convert (type, act_elem);\n-\n-      if (step)\n-\tact_elem = fold_build2 (MULT_EXPR, type, act_elem,\n-\t\t\t\tfold_convert (type, step));\n-      addr = act_elem;\n+      addr_base = fold_convert (type, base);\n+      base = NULL_TREE;\n     }\n \n-  act_elem = TMR_BASE (mem_ref);\n+  act_elem = TMR_INDEX (mem_ref);\n   if (act_elem)\n     {\n-      act_elem = fold_convert (type, act_elem);\n-\n-      if (addr)\n-\taddr = fold_build2 (PLUS_EXPR, type, addr, act_elem);\n-      else\n-\taddr = act_elem;\n+      if (step)\n+\tact_elem = fold_build2 (MULT_EXPR, sizetype, act_elem, step);\n+      addr_off = act_elem;\n     }\n \n-  act_elem = TMR_SYMBOL (mem_ref);\n+  act_elem = base;\n   if (act_elem)\n     {\n-      act_elem = fold_convert (type, build_addr (act_elem,\n-\t\t\t\t\t\t current_function_decl));\n-      if (addr)\n-\taddr = fold_build2 (PLUS_EXPR, type, addr, act_elem);\n+      if (addr_off)\n+\taddr_off = fold_build2 (PLUS_EXPR, sizetype, addr_off, act_elem);\n       else\n-\taddr = act_elem;\n+\taddr_off = act_elem;\n     }\n \n   if (offset && !integer_zerop (offset))\n     {\n-      act_elem = fold_convert (type, offset);\n-\n-      if (addr)\n-\taddr = fold_build2 (PLUS_EXPR, type, addr, act_elem);\n+      if (addr_off)\n+\taddr_off = fold_build2 (PLUS_EXPR, sizetype, addr_off, offset);\n       else\n-\taddr = act_elem;\n+\taddr_off = offset;\n     }\n \n-  if (!addr)\n+  if (addr_off)\n+    {\n+      addr = fold_convert (type, addr_off);\n+      if (addr_base)\n+\taddr = fold_build2 (PLUS_EXPR, type, addr_base, addr);\n+    }\n+  else if (addr_base)\n+    addr = addr_base;\n+  else\n     addr = build_int_cst (type, 0);\n \n   return addr;\n@@ -343,48 +343,91 @@ fixed_address_object_p (tree obj)\n \t      || DECL_EXTERNAL (obj)));\n }\n \n-/* Adds COEF * ELT to PARTS.  TYPE is the type of the address we\n-   construct.  */\n+/* If ADDR contains an address of object that is a link time constant,\n+   move it to PARTS->symbol.  */\n \n static void\n-add_to_parts (struct mem_address *parts, tree type, tree elt)\n+move_fixed_address_to_symbol (struct mem_address *parts, aff_tree *addr)\n {\n-  tree elt_core = elt;\n-  STRIP_NOPS (elt_core);\n+  unsigned i;\n+  tree val = NULL_TREE;\n \n-  /* Check if this is a symbol.  */\n-  if (!parts->symbol\n-      && TREE_CODE (elt_core) == ADDR_EXPR\n-      && fixed_address_object_p (TREE_OPERAND (elt_core, 0)))\n+  for (i = 0; i < addr->n; i++)\n     {\n-      parts->symbol = TREE_OPERAND (elt_core, 0);\n-      return;\n+      if (!double_int_one_p (addr->elts[i].coef))\n+\tcontinue;\n+\n+      val = addr->elts[i].val;\n+      if (TREE_CODE (val) == ADDR_EXPR\n+\t  && fixed_address_object_p (TREE_OPERAND (val, 0)))\n+\tbreak;\n     }\n \n-  if (!parts->base)\n+  if (i == addr->n)\n+    return;\n+\n+  parts->symbol = TREE_OPERAND (val, 0);\n+  aff_combination_remove_elt (addr, i);\n+}\n+\n+/* If ADDR contains an address of a dereferenced pointer, move it to\n+   PARTS->base.  */\n+\n+static void\n+move_pointer_to_base (struct mem_address *parts, aff_tree *addr)\n+{\n+  unsigned i;\n+  tree val = NULL_TREE;\n+\n+  for (i = 0; i < addr->n; i++)\n     {\n-      parts->base = elt;\n-      return;\n+      if (!double_int_one_p (addr->elts[i].coef))\n+\tcontinue;\n+\n+      val = addr->elts[i].val;\n+      if (POINTER_TYPE_P (TREE_TYPE (val)))\n+\tbreak;\n     }\n \n+  if (i == addr->n)\n+    return;\n+\n+  parts->base = val;\n+  aff_combination_remove_elt (addr, i);\n+}\n+\n+/* Adds ELT to PARTS.  */\n+\n+static void\n+add_to_parts (struct mem_address *parts, tree elt)\n+{\n+  tree type;\n+\n   if (!parts->index)\n     {\n       parts->index = elt;\n       return;\n     }\n \n+  if (!parts->base)\n+    {\n+      parts->base = elt;\n+      return;\n+    }\n+\n   /* Add ELT to base.  */\n-  parts->base = fold_build2 (PLUS_EXPR, type, parts->base, elt);\n+  type = TREE_TYPE (parts->base);\n+  parts->base = fold_build2 (PLUS_EXPR, type,\n+\t\t\t     parts->base,\n+\t\t\t     fold_convert (type, elt));\n }\n \n /* Finds the most expensive multiplication in ADDR that can be\n    expressed in an addressing mode and move the corresponding\n-   element(s) to PARTS.  TYPE is the type of the address we\n-   construct.  */\n+   element(s) to PARTS.  */\n \n static void\n-most_expensive_mult_to_index (struct mem_address *parts, tree type,\n-\t\t\t      aff_tree *addr)\n+most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr)\n {\n   HOST_WIDE_INT coef;\n   double_int best_mult, amult, amult_neg;\n@@ -435,18 +478,18 @@ most_expensive_mult_to_index (struct mem_address *parts, tree type,\n \t  continue;\n \t}\n   \n-      elt = fold_convert (type, addr->elts[i].val);\n+      elt = fold_convert (sizetype, addr->elts[i].val);\n       if (mult_elt)\n-\tmult_elt = fold_build2 (op_code, type, mult_elt, elt);\n+\tmult_elt = fold_build2 (op_code, sizetype, mult_elt, elt);\n       else if (op_code == PLUS_EXPR)\n \tmult_elt = elt;\n       else\n-\tmult_elt = fold_build1 (NEGATE_EXPR, type, elt);\n+\tmult_elt = fold_build1 (NEGATE_EXPR, sizetype, elt);\n     }\n   addr->n = j;\n   \n   parts->index = mult_elt;\n-  parts->step = double_int_to_tree (type, best_mult);\n+  parts->step = double_int_to_tree (sizetype, best_mult);\n }\n \n /* Splits address ADDR into PARTS.\n@@ -459,7 +502,7 @@ most_expensive_mult_to_index (struct mem_address *parts, tree type,\n    addressing modes is useless.  */\n \n static void\n-addr_to_parts (aff_tree *addr, tree type, struct mem_address *parts)\n+addr_to_parts (aff_tree *addr, struct mem_address *parts)\n {\n   tree part;\n   unsigned i;\n@@ -470,25 +513,34 @@ addr_to_parts (aff_tree *addr, tree type, struct mem_address *parts)\n   parts->step = NULL_TREE;\n \n   if (!double_int_zero_p (addr->offset))\n-    parts->offset = double_int_to_tree (type, addr->offset);\n+    parts->offset = double_int_to_tree (sizetype, addr->offset);\n   else\n     parts->offset = NULL_TREE;\n \n+  /* Try to find a symbol.  */\n+  move_fixed_address_to_symbol (parts, addr);\n+\n   /* First move the most expensive feasible multiplication\n      to index.  */\n-  most_expensive_mult_to_index (parts, type, addr);\n+  most_expensive_mult_to_index (parts, addr);\n+\n+  /* Try to find a base of the reference.  Since at the moment\n+     there is no reliable way how to distinguish between pointer and its\n+     offset, this is just a guess.  */\n+  if (!parts->symbol)\n+    move_pointer_to_base (parts, addr);\n \n   /* Then try to process the remaining elements.  */\n   for (i = 0; i < addr->n; i++)\n     {\n-      part = fold_convert (type, addr->elts[i].val);\n+      part = fold_convert (sizetype, addr->elts[i].val);\n       if (!double_int_one_p (addr->elts[i].coef))\n-\tpart = fold_build2 (MULT_EXPR, type, part,\n-\t\t\t    double_int_to_tree (type, addr->elts[i].coef));\n-      add_to_parts (parts, type, part);\n+\tpart = fold_build2 (MULT_EXPR, sizetype, part,\n+\t\t\t    double_int_to_tree (sizetype, addr->elts[i].coef));\n+      add_to_parts (parts, part);\n     }\n   if (addr->rest)\n-    add_to_parts (parts, type, addr->rest);\n+    add_to_parts (parts, fold_convert (sizetype, addr->rest));\n }\n \n /* Force the PARTS to register.  */\n@@ -512,10 +564,10 @@ tree\n create_mem_ref (block_stmt_iterator *bsi, tree type, aff_tree *addr)\n {\n   tree mem_ref, tmp;\n-  tree addr_type = build_pointer_type (type);\n+  tree addr_type = build_pointer_type (type), atype;\n   struct mem_address parts;\n \n-  addr_to_parts (addr, addr_type, &parts);\n+  addr_to_parts (addr, &parts);\n   gimplify_mem_ref_parts (bsi, &parts);\n   mem_ref = create_mem_ref_raw (type, &parts);\n   if (mem_ref)\n@@ -528,9 +580,9 @@ create_mem_ref (block_stmt_iterator *bsi, tree type, aff_tree *addr)\n       /* Move the multiplication to index.  */\n       gcc_assert (parts.index);\n       parts.index = force_gimple_operand_bsi (bsi,\n-\t\t\t\t\t      build2 (MULT_EXPR, addr_type,\n-\t\t\t\t\t\t      parts.index, parts.step),\n-\t\t\t\t\t      true, NULL_TREE);\n+\t\t\t\tfold_build2 (MULT_EXPR, sizetype,\n+\t\t\t\t\t     parts.index, parts.step),\n+\t\t\t\ttrue, NULL_TREE);\n       parts.step = NULL_TREE;\n   \n       mem_ref = create_mem_ref_raw (type, &parts);\n@@ -540,16 +592,18 @@ create_mem_ref (block_stmt_iterator *bsi, tree type, aff_tree *addr)\n \n   if (parts.symbol)\n     {\n-      tmp = build_addr (parts.symbol, current_function_decl);\n+      tmp = fold_convert (addr_type,\n+\t\t\t  build_addr (parts.symbol, current_function_decl));\n     \n       /* Add the symbol to base, eventually forcing it to register.  */\n       if (parts.base)\n \t{\n \t  if (parts.index)\n \t    parts.base = force_gimple_operand_bsi (bsi,\n-\t\t\t\t\t\t   build2 (PLUS_EXPR, addr_type,\n-\t\t\t\t\t\t\t   parts.base, tmp),\n-\t\t\t\t\t\t   true, NULL_TREE);\n+\t\t\tfold_build2 (PLUS_EXPR, addr_type,\n+\t\t\t\t     fold_convert (addr_type, parts.base),\n+\t\t\t\t     tmp),\n+\t\t\ttrue, NULL_TREE);\n \t  else\n \t    {\n \t      parts.index = parts.base;\n@@ -565,18 +619,21 @@ create_mem_ref (block_stmt_iterator *bsi, tree type, aff_tree *addr)\n \treturn mem_ref;\n     }\n \n-  if (parts.base)\n+  if (parts.index)\n     {\n-      /* Add base to index.  */\n-      if (parts.index)\n-\tparts.index = force_gimple_operand_bsi (bsi,\n-\t\t\t\t\t\tbuild2 (PLUS_EXPR, addr_type,\n-\t\t\t\t\t\t\tparts.base,\n-\t\t\t\t\t\t\tparts.index),\n-\t\t\t\t\t\ttrue, NULL_TREE);\n+      /* Add index to base.  */\n+      if (parts.base)\n+\t{\n+\t  atype = TREE_TYPE (parts.base);\n+\t  parts.base = force_gimple_operand_bsi (bsi,\n+\t\t\tfold_build2 (PLUS_EXPR, atype,\n+\t\t\t\t     parts.base,\n+\t\t\t    \t     fold_convert (atype, parts.index)),\n+\t\t\ttrue, NULL_TREE);\n+\t}\n       else\n-\tparts.index = parts.base;\n-      parts.base = NULL_TREE;\n+\tparts.base = parts.index;\n+      parts.index = NULL_TREE;\n \n       mem_ref = create_mem_ref_raw (type, &parts);\n       if (mem_ref)\n@@ -585,15 +642,18 @@ create_mem_ref (block_stmt_iterator *bsi, tree type, aff_tree *addr)\n \n   if (parts.offset && !integer_zerop (parts.offset))\n     {\n-      /* Try adding offset to index.  */\n-      if (parts.index)\n-\tparts.index = force_gimple_operand_bsi (bsi, \n-\t\t\t\t\t\tbuild2 (PLUS_EXPR, addr_type,\n-\t\t\t\t\t\t\tparts.index,\n-\t\t\t\t\t\t\tparts.offset),\n-\t\t\t\t\t\ttrue, NULL_TREE);\n+      /* Try adding offset to base.  */\n+      if (parts.base)\n+\t{\n+\t  atype = TREE_TYPE (parts.base);\n+\t  parts.base = force_gimple_operand_bsi (bsi, \n+\t\t\tfold_build2 (PLUS_EXPR, atype,\n+\t\t\t\t     parts.base,\n+\t\t\t\t     fold_convert (atype, parts.offset)),\n+\t\t\ttrue, NULL_TREE);\n+\t}\n       else\n-\tparts.index = parts.offset, bsi;\n+\tparts.base = parts.offset, bsi;\n \n       parts.offset = NULL_TREE;\n \n@@ -606,7 +666,7 @@ create_mem_ref (block_stmt_iterator *bsi, tree type, aff_tree *addr)\n      (only a register).  If we cannot create such a memory reference,\n      something is really wrong.  */\n   gcc_assert (parts.symbol == NULL_TREE);\n-  gcc_assert (parts.base == NULL_TREE);\n+  gcc_assert (parts.index == NULL_TREE);\n   gcc_assert (!parts.step || integer_onep (parts.step));\n   gcc_assert (!parts.offset || integer_zerop (parts.offset));\n   gcc_unreachable ();\n@@ -651,8 +711,9 @@ maybe_fold_tmr (tree ref)\n   if (addr.base && TREE_CODE (addr.base) == INTEGER_CST)\n     {\n       if (addr.offset)\n-\taddr.offset = fold_binary_to_constant (PLUS_EXPR, ptr_type_node,\n-\t\t\t\t\t       addr.offset, addr.base);\n+\taddr.offset = fold_binary_to_constant (PLUS_EXPR, sizetype,\n+\t\t\taddr.offset,\n+\t\t\tfold_convert (sizetype, addr.base));\n       else\n \taddr.offset = addr.base;\n \n@@ -665,14 +726,14 @@ maybe_fold_tmr (tree ref)\n       off = addr.index;\n       if (addr.step)\n \t{\n-\t  off = fold_binary_to_constant (MULT_EXPR, ptr_type_node,\n+\t  off = fold_binary_to_constant (MULT_EXPR, sizetype,\n \t\t\t\t\t off, addr.step);\n \t  addr.step = NULL_TREE;\n \t}\n \n       if (addr.offset)\n \t{\n-\t  addr.offset = fold_binary_to_constant (PLUS_EXPR, ptr_type_node,\n+\t  addr.offset = fold_binary_to_constant (PLUS_EXPR, sizetype,\n \t\t\t\t\t\t addr.offset, off);\n \t}\n       else"}, {"sha": "a85f02d72ae0f8ca4c5f21c1e538988c545fad92", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=820410e0d5f0726b17c98ed28ff4bdb52d4ec3a6", "patch": "@@ -937,6 +937,9 @@ DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n    OFFSET (integer constant).  Corresponding address is\n    SYMBOL + BASE + STEP * INDEX + OFFSET.  Only variations and values valid on\n    the target are allowed.\n+\n+   The type of STEP, INDEX and OFFSET is sizetype.  The type of BASE is\n+   sizetype or a pointer type (if SYMBOL is NULL).\n    \n    The sixth argument is the reference to the original memory access, which\n    is preserved for the purposes of the RTL alias analysis.  The seventh"}]}