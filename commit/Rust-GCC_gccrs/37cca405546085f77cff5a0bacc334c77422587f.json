{"sha": "37cca405546085f77cff5a0bacc334c77422587f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdjY2E0MDU1NDYwODVmNzdjZmY1YTBiYWNjMzM0Yzc3NDIyNTg3Zg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2005-04-11T20:17:38Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2005-04-11T20:17:38Z"}, "message": "tree-ssa-loop-im.c: Include real.h.\n\n        * tree-ssa-loop-im.c: Include real.h.\n        (determine_invariantness_stmt): If real division divisor is\n        invariant and flag_unsafe_math_optimizations enabled, generate\n        invariant reciprocal for hoisting.\n        * Makefile.in (tree-ssa-loop-im.o): Add real.h dependency.\n\nFrom-SVN: r97983", "tree": {"sha": "04f18bb925bd5e02b28ff241d3095e428e48878b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f18bb925bd5e02b28ff241d3095e428e48878b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37cca405546085f77cff5a0bacc334c77422587f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37cca405546085f77cff5a0bacc334c77422587f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37cca405546085f77cff5a0bacc334c77422587f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37cca405546085f77cff5a0bacc334c77422587f/comments", "author": null, "committer": null, "parents": [{"sha": "945891207919f9486961857c5de8db42a4771687", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/945891207919f9486961857c5de8db42a4771687", "html_url": "https://github.com/Rust-GCC/gccrs/commit/945891207919f9486961857c5de8db42a4771687"}], "stats": {"total": 54, "additions": 52, "deletions": 2}, "files": [{"sha": "60e5aa3a7d2999572f2df07788dd6e2347a3451f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37cca405546085f77cff5a0bacc334c77422587f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37cca405546085f77cff5a0bacc334c77422587f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37cca405546085f77cff5a0bacc334c77422587f", "patch": "@@ -1,3 +1,11 @@\n+2005-04-11  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* tree-ssa-loop-im.c: Include real.h.\n+\t(determine_invariantness_stmt): If real division divisor is\n+\tinvariant and flag_unsafe_math_optimizations enabled, generate\n+\tinvariant reciprocal for hoisting.\n+\t* Makefile.in (tree-ssa-loop-im.o): Add real.h dependency.\n+\n 2005-04-11  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/20926"}, {"sha": "57f3d1a5365af4e885d757acd4eeb05bbe7fce47", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37cca405546085f77cff5a0bacc334c77422587f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37cca405546085f77cff5a0bacc334c77422587f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=37cca405546085f77cff5a0bacc334c77422587f", "patch": "@@ -1761,7 +1761,7 @@ tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h $(PARAMS_H)\\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   tree-pass.h $(FLAGS_H) $(HASHTAB_H)\n+   tree-pass.h $(FLAGS_H) $(HASHTAB_H) real.h\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n    function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h \\"}, {"sha": "4e123f2c8a57a633788ed4ef33ae744e22249753", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37cca405546085f77cff5a0bacc334c77422587f/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37cca405546085f77cff5a0bacc334c77422587f/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=37cca405546085f77cff5a0bacc334c77422587f", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"flags.h\"\n+#include \"real.h\"\n \n /* TODO:  Support for predicated code motion.  I.e.\n \n@@ -562,7 +563,7 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n {\n   enum move_pos pos;\n   block_stmt_iterator bsi;\n-  tree stmt;\n+  tree stmt, rhs;\n   bool maybe_never = ALWAYS_EXECUTED_IN (bb) == NULL;\n   struct loop *outermost = ALWAYS_EXECUTED_IN (bb);\n \n@@ -588,6 +589,47 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t  continue;\n \t}\n \n+      /* If divisor is invariant, convert a/b to a*(1/b), allowing reciprocal\n+\t to be hoisted out of loop, saving expensive divide.  */\n+      if (pos == MOVE_POSSIBLE\n+\t  && (rhs = TREE_OPERAND (stmt, 1)) != NULL\n+\t  && TREE_CODE (rhs) == RDIV_EXPR\n+\t  && flag_unsafe_math_optimizations\n+\t  && outermost_invariant_loop_expr (TREE_OPERAND (rhs, 1),\n+\t\t\t\t\t    loop_containing_stmt (stmt)) != NULL\n+\t  && outermost_invariant_loop_expr (rhs,\n+\t\t\t\t\t    loop_containing_stmt (stmt)) == NULL)\n+\t{\n+\t  tree lhs, stmt1, stmt2, var, name;\n+\n+\t  lhs = TREE_OPERAND (stmt, 0);\n+\n+\t  /* stmt must be MODIFY_EXPR.  */\n+\t  var = create_tmp_var (TREE_TYPE (rhs), \"reciptmp\");\n+\t  add_referenced_tmp_var (var);\n+\n+\t  stmt1 = build2 (MODIFY_EXPR, void_type_node, var,\n+\t\t\t  build2 (RDIV_EXPR, TREE_TYPE (rhs),\n+\t\t\t\t  build_real (TREE_TYPE (rhs), dconst1),\n+\t\t\t\t  TREE_OPERAND (rhs, 1)));\n+\t  name = make_ssa_name (var, stmt1);\n+\t  TREE_OPERAND (stmt1, 0) = name;\n+\t  stmt2 = build2 (MODIFY_EXPR, void_type_node, lhs,\n+\t\t\t  build2 (MULT_EXPR, TREE_TYPE (rhs),\n+\t\t\t\t  name, TREE_OPERAND (rhs, 0)));\n+\n+\t  /* Replace division stmt with reciprocal and multiply stmts.\n+\t     The multiply stmt is not invariant, so update iterator\n+\t     and avoid rescanning.  */\n+\t  bsi_replace (&bsi, stmt1, true);\n+\t  get_stmt_operands (stmt1);  /* Should not be necessary.  */\n+\t  bsi_insert_after (&bsi, stmt2, BSI_NEW_STMT);\n+\t  SSA_NAME_DEF_STMT (lhs) = stmt2;\n+\n+\t  /* Continue processing with invariant reciprocal statment.  */\n+\t  stmt = stmt1;\n+\t}\n+\n       stmt_ann (stmt)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n       LIM_DATA (stmt)->always_executed_in = outermost;\n "}]}