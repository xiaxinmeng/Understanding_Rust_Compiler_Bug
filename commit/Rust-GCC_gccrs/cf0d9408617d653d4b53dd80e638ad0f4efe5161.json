{"sha": "cf0d9408617d653d4b53dd80e638ad0f4efe5161", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YwZDk0MDg2MTdkNjUzZDRiNTNkZDgwZTYzOGFkMGY0ZWZlNTE2MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-05T20:32:44Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-05T20:32:44Z"}, "message": "* combine.c: Fix formatting.\n\nFrom-SVN: r48569", "tree": {"sha": "44445272f1eff14b6c3c3047197bf23fbd46c9a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44445272f1eff14b6c3c3047197bf23fbd46c9a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf0d9408617d653d4b53dd80e638ad0f4efe5161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0d9408617d653d4b53dd80e638ad0f4efe5161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf0d9408617d653d4b53dd80e638ad0f4efe5161", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0d9408617d653d4b53dd80e638ad0f4efe5161/comments", "author": null, "committer": null, "parents": [{"sha": "bedca03a2ad142a03b3434962ce76d38277851af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bedca03a2ad142a03b3434962ce76d38277851af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bedca03a2ad142a03b3434962ce76d38277851af"}], "stats": {"total": 74, "additions": 39, "deletions": 35}, "files": [{"sha": "2de0708e3378afc7c388f17e2a2a9ab4e1a4327f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf0d9408617d653d4b53dd80e638ad0f4efe5161/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf0d9408617d653d4b53dd80e638ad0f4efe5161/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf0d9408617d653d4b53dd80e638ad0f4efe5161", "patch": "@@ -1,3 +1,7 @@\n+2002-01-05  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* combine.c: Fix formatting.\n+\n 2002-01-05  Craig Rodrigues  <crodrigu@bbn.com>\n \n \tPR middle-end/1557"}, {"sha": "3d6d1fe80ae11037c94398c30b77d81c9ef8fe1f", "filename": "gcc/combine.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf0d9408617d653d4b53dd80e638ad0f4efe5161/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf0d9408617d653d4b53dd80e638ad0f4efe5161/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=cf0d9408617d653d4b53dd80e638ad0f4efe5161", "patch": "@@ -1134,7 +1134,7 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \n       for (p = NEXT_INSN (insn); p != i3; p = NEXT_INSN (p))\n         if (INSN_P (p) && p != succ && volatile_refs_p (PATTERN (p)))\n-\treturn 0;\n+\t  return 0;\n     }\n \n   /* If INSN is an asm, and DEST is a hard register, reject, since it has\n@@ -1954,7 +1954,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t isn't mentioned in any SETs in NEWPAT that are field assignments.  */\n \n       if (! combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX,\n-\t\t\t      0, (rtx*)0))\n+\t\t\t      0, (rtx*) 0))\n \t{\n \t  undo_all ();\n \t  return 0;\n@@ -2011,23 +2011,23 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t  XVECEXP (newpat, 0, 0) = old;\n \t}\n \n-     if (added_sets_1)\n-       XVECEXP (newpat, 0, --total_sets)\n-\t = (GET_CODE (PATTERN (i1)) == PARALLEL\n-\t    ? gen_rtx_SET (VOIDmode, i1dest, i1src) : PATTERN (i1));\n+      if (added_sets_1)\n+\tXVECEXP (newpat, 0, --total_sets)\n+\t  = (GET_CODE (PATTERN (i1)) == PARALLEL\n+\t     ? gen_rtx_SET (VOIDmode, i1dest, i1src) : PATTERN (i1));\n \n-     if (added_sets_2)\n-       {\n-\t /* If there is no I1, use I2's body as is.  We used to also not do\n-\t    the subst call below if I2 was substituted into I3,\n-\t    but that could lose a simplification.  */\n-\t if (i1 == 0)\n-\t   XVECEXP (newpat, 0, --total_sets) = i2pat;\n-\t else\n-\t   /* See comment where i2pat is assigned.  */\n-\t   XVECEXP (newpat, 0, --total_sets)\n-\t     = subst (i2pat, i1dest, i1src, 0, 0);\n-       }\n+      if (added_sets_2)\n+\t{\n+\t  /* If there is no I1, use I2's body as is.  We used to also not do\n+\t     the subst call below if I2 was substituted into I3,\n+\t     but that could lose a simplification.  */\n+\t  if (i1 == 0)\n+\t    XVECEXP (newpat, 0, --total_sets) = i2pat;\n+\t  else\n+\t    /* See comment where i2pat is assigned.  */\n+\t    XVECEXP (newpat, 0, --total_sets)\n+\t      = subst (i2pat, i1dest, i1src, 0, 0);\n+\t}\n     }\n \n   /* We come here when we are replacing a destination in I2 with the\n@@ -2992,7 +2992,7 @@ find_split_point (loc, insn)\n \t  && GET_CODE (XEXP (SET_DEST (x), 2)) == CONST_INT\n \t  && GET_CODE (SET_SRC (x)) == CONST_INT\n \t  && ((INTVAL (XEXP (SET_DEST (x), 1))\n-\t      + INTVAL (XEXP (SET_DEST (x), 2)))\n+\t       + INTVAL (XEXP (SET_DEST (x), 2)))\n \t      <= GET_MODE_BITSIZE (GET_MODE (XEXP (SET_DEST (x), 0))))\n \t  && ! side_effects_p (XEXP (SET_DEST (x), 0)))\n \t{\n@@ -3044,7 +3044,7 @@ find_split_point (loc, insn)\n \t      && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n \t      && (pos = exact_log2 (INTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n \t      && GET_CODE (SET_DEST (x)) == REG\n-\t      && (split = find_single_use (SET_DEST (x), insn, (rtx*)0)) != 0\n+\t      && (split = find_single_use (SET_DEST (x), insn, (rtx*) 0)) != 0\n \t      && (GET_CODE (*split) == EQ || GET_CODE (*split) == NE)\n \t      && XEXP (*split, 0) == SET_DEST (x)\n \t      && XEXP (*split, 1) == const0_rtx)\n@@ -4713,8 +4713,8 @@ simplify_if_then_else (x)\n \t  simplify_gen_unary (NEG, mode,\n \t\t\t      simplify_gen_unary (ABS, mode, true_rtx, mode),\n \t\t\t      mode);\n-    default:\n-      break;\n+      default:\n+\tbreak;\n       }\n \n   /* Look for MIN or MAX.  */\n@@ -10967,19 +10967,19 @@ static enum rtx_code\n combine_reversed_comparison_code (exp)\n      rtx exp;\n {\n-   enum rtx_code code1 = reversed_comparison_code (exp, NULL);\n-   rtx x;\n-\n-   if (code1 != UNKNOWN\n-       || GET_MODE_CLASS (GET_MODE (XEXP (exp, 0))) != MODE_CC)\n-     return code1;\n-   /* Otherwise try and find where the condition codes were last set and\n-      use that.  */\n-   x = get_last_value (XEXP (exp, 0));\n-   if (!x || GET_CODE (x) != COMPARE)\n-     return UNKNOWN;\n-   return reversed_comparison_code_parts (GET_CODE (exp),\n-\t\t\t\t\t  XEXP (x, 0), XEXP (x, 1), NULL);\n+  enum rtx_code code1 = reversed_comparison_code (exp, NULL);\n+  rtx x;\n+\n+  if (code1 != UNKNOWN\n+      || GET_MODE_CLASS (GET_MODE (XEXP (exp, 0))) != MODE_CC)\n+    return code1;\n+  /* Otherwise try and find where the condition codes were last set and\n+     use that.  */\n+  x = get_last_value (XEXP (exp, 0));\n+  if (!x || GET_CODE (x) != COMPARE)\n+    return UNKNOWN;\n+  return reversed_comparison_code_parts (GET_CODE (exp),\n+\t\t\t\t\t XEXP (x, 0), XEXP (x, 1), NULL);\n }\n /* Return comparison with reversed code of EXP and operands OP0 and OP1.\n    Return NULL_RTX in case we fail to do the reversal.  */"}]}