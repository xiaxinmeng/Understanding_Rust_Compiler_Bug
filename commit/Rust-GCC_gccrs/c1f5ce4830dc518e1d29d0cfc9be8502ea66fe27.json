{"sha": "c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFmNWNlNDgzMGRjNTE4ZTFkMjlkMGNmYzliZTg1MDJlYTY2ZmUyNw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:37:26Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:37:26Z"}, "message": "Change use to type-based pool allocator in asan.c.\n\n\t* asan.c (asan_mem_ref_get_alloc_pool):Use new type-based pool allocator.\n\t(asan_mem_ref_new) Likewise.\n\t(free_mem_ref_resources) Likewise.\n\nFrom-SVN: r223948", "tree": {"sha": "8238d9390b96adc7a54dbdc1009c671d9b2b2139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8238d9390b96adc7a54dbdc1009c671d9b2b2139"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d"}], "stats": {"total": 50, "additions": 26, "deletions": 24}, "files": [{"sha": "e1bdc4e57c8353d8704dca31e8bca90f216e7842", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27", "patch": "@@ -1,3 +1,9 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* asan.c (asan_mem_ref_get_alloc_pool):Use new type-based pool allocator.\n+\t(asan_mem_ref_new) Likewise.\n+\t(free_mem_ref_resources) Likewise.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* var-tracking.c (variable_htab_free):Use new type-based pool allocator."}, {"sha": "ed5bc9e382483b846f3a156688b36ade26e1c929", "filename": "gcc/asan.c", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=c1f5ce4830dc518e1d29d0cfc9be8502ea66fe27", "patch": "@@ -176,7 +176,7 @@ along with GCC; see the file COPYING3.  If not see\n \n \twhere '(...){n}' means the content inside the parenthesis occurs 'n'\n \ttimes, with 'n' being the number of variables on the stack.\n-     \n+\n      3/ The following 8 bytes contain the PC of the current function which\n      will be used by the run-time library to print an error message.\n \n@@ -281,7 +281,7 @@ bool\n set_asan_shadow_offset (const char *val)\n {\n   char *endp;\n-  \n+\n   errno = 0;\n #ifdef HAVE_LONG_LONG\n   asan_shadow_offset_value = strtoull (val, &endp, 0);\n@@ -372,23 +372,24 @@ struct asan_mem_ref\n \n   /* The size of the access.  */\n   HOST_WIDE_INT access_size;\n-};\n \n-static alloc_pool asan_mem_ref_alloc_pool;\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n \n-/* This creates the alloc pool used to store the instances of\n-   asan_mem_ref that are stored in the hash table asan_mem_ref_ht.  */\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((asan_mem_ref *) ptr);\n+  }\n \n-static alloc_pool\n-asan_mem_ref_get_alloc_pool ()\n-{\n-  if (asan_mem_ref_alloc_pool == NULL)\n-    asan_mem_ref_alloc_pool = create_alloc_pool (\"asan_mem_ref\",\n-\t\t\t\t\t\t sizeof (asan_mem_ref),\n-\t\t\t\t\t\t 10);\n-  return asan_mem_ref_alloc_pool;\n-    \n-}\n+  /* Memory allocation pool.  */\n+  static pool_allocator<asan_mem_ref> pool;\n+};\n+\n+pool_allocator<asan_mem_ref> asan_mem_ref::pool (\"asan_mem_ref\", 10);\n \n /* Initializes an instance of asan_mem_ref.  */\n \n@@ -408,8 +409,7 @@ asan_mem_ref_init (asan_mem_ref *ref, tree start, HOST_WIDE_INT access_size)\n static asan_mem_ref*\n asan_mem_ref_new (tree start, HOST_WIDE_INT access_size)\n {\n-  asan_mem_ref *ref =\n-    (asan_mem_ref *) pool_alloc (asan_mem_ref_get_alloc_pool ());\n+  asan_mem_ref *ref = new asan_mem_ref;\n \n   asan_mem_ref_init (ref, start, access_size);\n   return ref;\n@@ -501,11 +501,7 @@ free_mem_ref_resources ()\n   delete asan_mem_ref_ht;\n   asan_mem_ref_ht = NULL;\n \n-  if (asan_mem_ref_alloc_pool)\n-    {\n-      free_alloc_pool (asan_mem_ref_alloc_pool);\n-      asan_mem_ref_alloc_pool = NULL;\n-    }\n+  asan_mem_ref::pool.release ();\n }\n \n /* Return true iff the memory reference REF has been instrumented.  */\n@@ -2035,7 +2031,7 @@ maybe_instrument_assignment (gimple_stmt_iterator *iter)\n \t\t\t is_store);\n       is_instrumented = true;\n     }\n- \n+\n   if (gimple_assign_load_p (s))\n     {\n       ref_expr = gimple_assign_rhs1 (s);"}]}