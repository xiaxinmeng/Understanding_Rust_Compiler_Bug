{"sha": "70099a6acf5169eca55ef74549fb64de14e668f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAwOTlhNmFjZjUxNjllY2E1NWVmNzQ1NDlmYjY0ZGUxNGU2NjhmMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-02-15T08:16:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-02-15T08:16:06Z"}, "message": "match.pd: Fix up A % (cast) (pow2cst << B) simplification [PR99079]\n\nThe (mod @0 (convert?@3 (power_of_two_cand@1 @2))) simplification\nuses tree_nop_conversion_p (type, TREE_TYPE (@3)) condition, but I believe\nit doesn't check what it was meant to check.  On convert?@3\nTREE_TYPE (@3) is not the type of what it has been converted from, but\nwhat it has been converted to, which needs to be (because it is operand\nof normal binary operation) equal or compatible to type of the modulo\nresult and first operand - type.\nI could fix that by using && tree_nop_conversion_p (type, TREE_TYPE (@1))\nand be done with it, but actually most of the non-nop conversions are IMHO\nok and so we would regress those optimizations.\nIn particular, if we have say narrowing conversions (foo5 and foo6 in\nthe new testcase), I think we are fine, either the shift of the power of two\nconstant after narrowing conversion is still that power of two (or negation\nof that) and then it will still work, or the result of narrowing conversion\nis 0 and then we would have UB which we can ignore.\nSimilarly, widening conversions where the shift result is unsigned are fine,\nor even widening conversions where the shift result is signed, but we sign\nextend to a signed wider divisor, the problematic case of INT_MIN will\nbecome x % (long long) INT_MIN and we can still optimize that to\nx & (long long) INT_MAX.\nWhat doesn't work is the case in the pr99079.c testcase, widening conversion\nof a signed shift result to wider unsigned divisor, where if the shift\nis negative, we end up with x % (unsigned long long) INT_MIN which is\nx % 0xffffffff80000000ULL where the divisor is not a power of two and\nwe can't optimize that to x & 0x7fffffffULL.\n\nSo, the patch rejects only the single problematic case.\n\nFurthermore, when the shift result is signed, we were introducing UB into\na program which previously didn't have one (well, left shift into the sign\nbit is UB in some language/version pairs, but it is definitely valid in\nC++20 - wonder if I shouldn't move the gcc.c-torture/execute/pr99079.c\ntestcase to g++.dg/torture/pr99079.C and use -std=c++20), by adding that\nsubtraction of 1, x % (1 << 31) in C++20 is well defined, but\nx & ((1 << 31) - 1) triggers UB on the subtraction.\nSo, the patch performs the subtraction in the unsigned type if it isn't\nwrapping.\n\n2021-02-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/99079\n\t* match.pd (A % (pow2pcst << N) -> A & ((pow2pcst << N) - 1)): Remove\n\tuseless tree_nop_conversion_p (type, TREE_TYPE (@3)) check.  Instead\n\trequire both type and TREE_TYPE (@1) to be integral types and either\n\ttype having smaller or equal precision, or TREE_TYPE (@1) being\n\tunsigned type, or type being signed type.  If TREE_TYPE (@1)\n\tdoesn't have wrapping overflow, perform the subtraction of one in\n\tunsigned type.\n\n\t* gcc.dg/fold-modpow2-2.c: New test.\n\t* gcc.c-torture/execute/pr99079.c: New test.", "tree": {"sha": "33b0aba7ef68ca1124bb5a11af2c1c0b899e10c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33b0aba7ef68ca1124bb5a11af2c1c0b899e10c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70099a6acf5169eca55ef74549fb64de14e668f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70099a6acf5169eca55ef74549fb64de14e668f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70099a6acf5169eca55ef74549fb64de14e668f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70099a6acf5169eca55ef74549fb64de14e668f0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5ae38e8dc3db44a137db30f14f1235160771eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ae38e8dc3db44a137db30f14f1235160771eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ae38e8dc3db44a137db30f14f1235160771eb2"}], "stats": {"total": 88, "additions": 82, "deletions": 6}, "files": [{"sha": "e14f69744d7e320c6289de7db6f57ab31d7c53ba", "filename": "gcc/match.pd", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70099a6acf5169eca55ef74549fb64de14e668f0/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70099a6acf5169eca55ef74549fb64de14e668f0/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=70099a6acf5169eca55ef74549fb64de14e668f0", "patch": "@@ -619,12 +619,23 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     (shift @0 (bit_and @1 (minus @2 { build_int_cst (TREE_TYPE (@2),\n \t\t\t\t\t\t      1); }))))))\n  (simplify\n-  (mod @0 (convert?@3 (power_of_two_cand@1 @2)))\n-  (if ((TYPE_UNSIGNED (type)\n-\t|| tree_expr_nonnegative_p (@0))\n-\t&& tree_nop_conversion_p (type, TREE_TYPE (@3))\n-\t&& integer_pow2p (@2) && tree_int_cst_sgn (@2) > 0)\n-   (bit_and @0 (convert (minus @1 { build_int_cst (TREE_TYPE (@1), 1); }))))))\n+  (mod @0 (convert? (power_of_two_cand@1 @2)))\n+  (if ((TYPE_UNSIGNED (type) || tree_expr_nonnegative_p (@0))\n+       /* Allow any integral conversions of the divisor, except\n+\t  conversion from narrower signed to wider unsigned type\n+\t  where if @1 would be negative power of two, the divisor\n+\t  would not be a power of two.  */\n+       && INTEGRAL_TYPE_P (type)\n+       && INTEGRAL_TYPE_P (TREE_TYPE (@1))\n+       && (TYPE_PRECISION (type) <= TYPE_PRECISION (TREE_TYPE (@1))\n+\t   || TYPE_UNSIGNED (TREE_TYPE (@1))\n+\t   || !TYPE_UNSIGNED (type))\n+       && integer_pow2p (@2) && tree_int_cst_sgn (@2) > 0)\n+   (with { tree utype = TREE_TYPE (@1);\n+\t   if (!TYPE_OVERFLOW_WRAPS (utype))\n+\t     utype = unsigned_type_for (utype); }\n+    (bit_and @0 (convert (minus (convert:utype @1)\n+\t\t\t\t{ build_one_cst (utype); })))))))\n \n /* Simplify (unsigned t * 2)/2 -> unsigned t & 0x7FFFFFFF.  */\n (simplify"}, {"sha": "78bb21866506e70a60406c8e0ddedd17d43e3073", "filename": "gcc/testsuite/gcc.c-torture/execute/pr99079.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70099a6acf5169eca55ef74549fb64de14e668f0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr99079.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70099a6acf5169eca55ef74549fb64de14e668f0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr99079.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr99079.c?ref=70099a6acf5169eca55ef74549fb64de14e668f0", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/99079 */\n+\n+__attribute__((noipa)) unsigned long long\n+foo (int x)\n+{\n+  unsigned long long s = 1 << x;\n+  return 4897637220ULL % s;\n+}\n+\n+int\n+main ()\n+{\n+  if (__SIZEOF_INT__ * __CHAR_BIT__ != 32)\n+    return 0;\n+  if (foo (31) != 4897637220ULL)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "803d52754766ee418d6420048bfd52e1664f02ea", "filename": "gcc/testsuite/gcc.dg/fold-modpow2-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70099a6acf5169eca55ef74549fb64de14e668f0/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-modpow2-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70099a6acf5169eca55ef74549fb64de14e668f0/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-modpow2-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-modpow2-2.c?ref=70099a6acf5169eca55ef74549fb64de14e668f0", "patch": "@@ -0,0 +1,47 @@\n+/* PR tree-optimization/99079 */\n+/* { dg-do compile { target { lp64 || ilp32 } } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+unsigned int\n+foo1 (unsigned int a, unsigned int b)\n+{\n+  return a % (1 << b);\n+}\n+\n+int\n+foo2 (int b)\n+{\n+  return 371 % (1U << b);\n+}\n+\n+long long\n+foo3 (int b)\n+{\n+  return 371LL % (1U << b);\n+}\n+\n+unsigned long long\n+foo4 (unsigned long long a, int b)\n+{\n+  return a % (1U << b);\n+}\n+\n+unsigned\n+foo5 (unsigned a, int b)\n+{\n+  return a % (unsigned) (1ULL << b);\n+}\n+\n+int\n+foo6 (int b)\n+{\n+  return 371 % (int) (1ULL << b);\n+}\n+\n+long long\n+foo7 (int b)\n+{\n+  return 371LL % (1 << b);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \" % \" \"optimized\" } } */"}]}