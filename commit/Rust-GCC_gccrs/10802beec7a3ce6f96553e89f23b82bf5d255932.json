{"sha": "10802beec7a3ce6f96553e89f23b82bf5d255932", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA4MDJiZWVjN2EzY2U2Zjk2NTUzZTg5ZjIzYjgyYmY1ZDI1NTkzMg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2014-08-17T23:35:30Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2014-08-17T23:35:30Z"}, "message": "rs6000.c (print_operand): New.\n\n2014-08-17  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\t* config/rs6000/rs6000.c (print_operand) <'e'>: New.\n\t<'u'>: Also support printing the low-order 16 bits.\n\t* config/rs6000/rs6000.md (iorsi3, xorsi3, *boolsi3_internal1,\n\t*boolsi3_internal2 and split, *boolsi3_internal3 and split): Delete.\n\t(iordi3, xordi3, *booldi3_internal1, *booldi3_internal2 and split,\n\t*booldi3_internal3 and split): Delete.\n\t(ior<mode>3, xor<mode>3, *bool<mode>3, *bool<mode>3_dot,\n\t*bool<mode>3_dot2): New.\n\t(two anonymous define_splits for non_logical_cint_operand): Merge.\n\nFrom-SVN: r214077", "tree": {"sha": "d143c5295c1129b68b46e0f9739e17e0f572e0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d143c5295c1129b68b46e0f9739e17e0f572e0ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10802beec7a3ce6f96553e89f23b82bf5d255932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10802beec7a3ce6f96553e89f23b82bf5d255932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10802beec7a3ce6f96553e89f23b82bf5d255932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10802beec7a3ce6f96553e89f23b82bf5d255932/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19fe965886cfe7a3073f0cf6dc2d3150c998487b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19fe965886cfe7a3073f0cf6dc2d3150c998487b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19fe965886cfe7a3073f0cf6dc2d3150c998487b"}], "stats": {"total": 370, "additions": 126, "deletions": 244}, "files": [{"sha": "4284d85fc06b3471a42ec141ad1d24643fd5c51b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10802beec7a3ce6f96553e89f23b82bf5d255932/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10802beec7a3ce6f96553e89f23b82bf5d255932/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10802beec7a3ce6f96553e89f23b82bf5d255932", "patch": "@@ -1,3 +1,15 @@\n+2014-08-17  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.c (print_operand) <'e'>: New.\n+\t<'u'>: Also support printing the low-order 16 bits.\n+\t* config/rs6000/rs6000.md (iorsi3, xorsi3, *boolsi3_internal1,\n+\t*boolsi3_internal2 and split, *boolsi3_internal3 and split): Delete.\n+\t(iordi3, xordi3, *booldi3_internal1, *booldi3_internal2 and split,\n+\t*booldi3_internal3 and split): Delete.\n+\t(ior<mode>3, xor<mode>3, *bool<mode>3, *bool<mode>3_dot,\n+\t*bool<mode>3_dot2): New.\n+\t(two anonymous define_splits for non_logical_cint_operand): Merge.\n+\n 2014-08-17  Marek Polacek  <polacek@redhat.com>\n \t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n "}, {"sha": "9821c6bc4d04afcc36928bfd8f17f40e01d19055", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10802beec7a3ce6f96553e89f23b82bf5d255932/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10802beec7a3ce6f96553e89f23b82bf5d255932/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=10802beec7a3ce6f96553e89f23b82bf5d255932", "patch": "@@ -18044,6 +18044,19 @@ print_operand (FILE *file, rtx x, int code)\n       fprintf (file, \"%d\", i + 1);\n       return;\n \n+    case 'e':\n+      /* If the low 16 bits are 0, but some other bit is set, write 's'.  */\n+      if (! INT_P (x))\n+\t{\n+\t  output_operand_lossage (\"invalid %%e value\");\n+\t  return;\n+\t}\n+\n+      uval = INTVAL (x);\n+      if ((uval & 0xffff) == 0 && uval != 0)\n+\tputc ('s', file);\n+      return;\n+\n     case 'E':\n       /* X is a CR register.  Print the number of the EQ bit of the CR */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n@@ -18346,12 +18359,19 @@ print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case 'u':\n-      /* High-order 16 bits of constant for use in unsigned operand.  */\n+      /* High-order or low-order 16 bits of constant, whichever is non-zero,\n+\t for use in unsigned operand.  */\n       if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%u value\");\n-      else\n-\tfprintf (file, HOST_WIDE_INT_PRINT_HEX,\n-\t\t (INTVAL (x) >> 16) & 0xffff);\n+\t{\n+\t  output_operand_lossage (\"invalid %%u value\");\n+\t  return;\n+\t}\n+\n+      uval = INTVAL (x);\n+      if ((uval & 0xffff) == 0)\n+\tuval >>= 16;\n+\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, uval & 0xffff);\n       return;\n \n     case 'v':"}, {"sha": "2e4df11579a01b526bbaa6ea4176bf919aa7b886", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 89, "deletions": 239, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10802beec7a3ce6f96553e89f23b82bf5d255932/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10802beec7a3ce6f96553e89f23b82bf5d255932/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=10802beec7a3ce6f96553e89f23b82bf5d255932", "patch": "@@ -3159,142 +3159,144 @@\n }\"\n   [(set_attr \"length\" \"8\")])\n \n-(define_expand \"iorsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"reg_or_logical_cint_operand\" \"\")))]\n+\n+(define_expand \"ior<mode>3\"\n+  [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n+\t(ior:SDI (match_operand:SDI 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:SDI 2 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n-  \"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && ! logical_operand (operands[2], SImode))\n+  if (<MODE>mode == DImode && !TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical (operands, IOR, false, false, false, NULL_RTX);\n+      DONE;\n+    }\n+\n+  if (non_logical_cint_operand (operands[2], <MODE>mode))\n     {\n-      HOST_WIDE_INT value = INTVAL (operands[2]);\n       rtx tmp = ((!can_create_pseudo_p ()\n \t\t  || rtx_equal_p (operands[0], operands[1]))\n-\t\t ? operands[0] : gen_reg_rtx (SImode));\n+\t\t ? operands[0] : gen_reg_rtx (<MODE>mode));\n+      HOST_WIDE_INT value = INTVAL (operands[2]);\n \n-      emit_insn (gen_iorsi3 (tmp, operands[1],\n+      emit_insn (gen_ior<mode>3 (tmp, operands[1],\n \t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-      emit_insn (gen_iorsi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n+\n+      emit_insn (gen_ior<mode>3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n-}\")\n \n-(define_expand \"xorsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"reg_or_logical_cint_operand\" \"\")))]\n+  if (!reg_or_logical_cint_operand (operands[2], <MODE>mode))\n+    operands[2] = force_reg (<MODE>mode, operands[2]);\n+})\n+\n+(define_expand \"xor<mode>3\"\n+  [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n+\t(xor:SDI (match_operand:SDI 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:SDI 2 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n-  \"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && ! logical_operand (operands[2], SImode))\n+  if (<MODE>mode == DImode && !TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical (operands, XOR, false, false, false, NULL_RTX);\n+      DONE;\n+    }\n+\n+  if (non_logical_cint_operand (operands[2], <MODE>mode))\n     {\n-      HOST_WIDE_INT value = INTVAL (operands[2]);\n       rtx tmp = ((!can_create_pseudo_p ()\n \t\t  || rtx_equal_p (operands[0], operands[1]))\n-\t\t ? operands[0] : gen_reg_rtx (SImode));\n+\t\t ? operands[0] : gen_reg_rtx (<MODE>mode));\n+      HOST_WIDE_INT value = INTVAL (operands[2]);\n \n-      emit_insn (gen_xorsi3 (tmp, operands[1],\n+      emit_insn (gen_xor<mode>3 (tmp, operands[1],\n \t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-      emit_insn (gen_xorsi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n+\n+      emit_insn (gen_xor<mode>3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n-}\")\n \n-(define_insn \"*boolsi3_internal1\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(match_operator:SI 3 \"boolean_or_operator\"\n-\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t  (match_operand:SI 2 \"logical_operand\" \"r,K,L\")]))]\n+  if (!reg_or_logical_cint_operand (operands[2], <MODE>mode))\n+    operands[2] = force_reg (<MODE>mode, operands[2]);\n+})\n+\n+(define_insn \"*bool<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(match_operator:GPR 3 \"boolean_or_operator\"\n+\t [(match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n+\t  (match_operand:GPR 2 \"logical_operand\" \"r,n\")]))]\n   \"\"\n   \"@\n    %q3 %0,%1,%2\n-   %q3i %0,%1,%b2\n-   %q3is %0,%1,%u2\")\n+   %q3i%e2 %0,%1,%u2\"\n+  [(set_attr \"type\" \"logical\")])\n \n-(define_insn \"*boolsi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (match_operator:SI 4 \"boolean_or_operator\"\n-\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+(define_insn_and_split \"*bool<mode>3_dot\"\n+  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (match_operator:GPR 3 \"boolean_or_operator\"\n+\t [(match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n+\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"r,r\")])\n \t (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r\"))]\n-  \"TARGET_32BIT\"\n+   (clobber (match_scratch:GPR 0 \"=r,r\"))]\n+  \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n-   %q4. %3,%1,%2\n+   %q3. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"logical,compare\")\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n+  [(set (match_dup 0)\n+\t(match_dup 3))\n+   (set (match_dup 4)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"logical\")\n    (set_attr \"dot\" \"yes\")\n    (set_attr \"length\" \"4,8\")])\n \n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n-\t [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"\")])\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*boolsi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n-\t [(match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\")])\n+(define_insn_and_split \"*bool<mode>3_dot2\"\n+  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (match_operator:GPR 3 \"boolean_or_operator\"\n+\t [(match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n+\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"r,r\")])\n \t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(match_dup 4))]\n-  \"TARGET_32BIT\"\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(match_dup 3))]\n+  \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n-   %q4. %0,%1,%2\n+   %q3. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"logical,compare\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (match_operator:SI 4 \"boolean_operator\"\n-\t [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"\")])\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(match_dup 4))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0) (match_dup 4))\n-   (set (match_dup 3)\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n+  [(set (match_dup 0)\n+\t(match_dup 3))\n+   (set (match_dup 4)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n-  \"\")\n+  \"\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8\")])\n \n ;; Split a logical operation that we can't do in one insn into two insns,\n ;; each of which does one 16-bit part.  This is used by combine.\n \n (define_split\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operator:SI 3 \"boolean_or_operator\"\n-\t [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:SI 2 \"non_logical_cint_operand\" \"\")]))]\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+\t(match_operator:GPR 3 \"boolean_or_operator\"\n+\t [(match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:GPR 2 \"non_logical_cint_operand\" \"\")]))]\n   \"\"\n   [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 0) (match_dup 5))]\n-\"\n {\n   rtx i;\n   i = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[3]), SImode,\n+  operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[3]), <MODE>mode,\n \t\t\t\toperands[1], i);\n   i = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[3]), SImode,\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[3]), <MODE>mode,\n \t\t\t\toperands[0], i);\n-}\")\n+})\n+\n \n (define_insn \"*boolcsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n@@ -7838,158 +7840,6 @@\n   build_mask64_2_operands (operands[2], &operands[5]);\n }\")\n \n-(define_expand \"iordi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n-  \"\"\n-{\n-  if (!TARGET_POWERPC64)\n-    {\n-      rs6000_split_logical (operands, IOR, false, false, false, NULL_RTX);\n-      DONE;\n-    }\n-  else if (!reg_or_logical_cint_operand (operands[2], DImode))\n-    operands[2] = force_reg (DImode, operands[2]);\n-  else if (non_logical_cint_operand (operands[2], DImode))\n-    {\n-      HOST_WIDE_INT value;\n-      rtx tmp = ((!can_create_pseudo_p ()\n-\t\t  || rtx_equal_p (operands[0], operands[1]))\n-\t\t ? operands[0] : gen_reg_rtx (DImode));\n-\n-      value = INTVAL (operands[2]);\n-      emit_insn (gen_iordi3 (tmp, operands[1],\n-\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-\n-      emit_insn (gen_iordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n-      DONE;\n-    }\n-})\n-\n-(define_expand \"xordi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n-  \"\"\n-{\n-  if (!TARGET_POWERPC64)\n-    {\n-      rs6000_split_logical (operands, XOR, false, false, false, NULL_RTX);\n-      DONE;\n-    }\n-  else if (!reg_or_logical_cint_operand (operands[2], DImode))\n-    operands[2] = force_reg (DImode, operands[2]);\n-  if (non_logical_cint_operand (operands[2], DImode))\n-    {\n-      HOST_WIDE_INT value;\n-      rtx tmp = ((!can_create_pseudo_p ()\n-\t\t  || rtx_equal_p (operands[0], operands[1]))\n-\t\t ? operands[0] : gen_reg_rtx (DImode));\n-\n-      value = INTVAL (operands[2]);\n-      emit_insn (gen_xordi3 (tmp, operands[1],\n-\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-\n-      emit_insn (gen_xordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"*booldi3_internal1\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(match_operator:DI 3 \"boolean_or_operator\"\n-\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t  (match_operand:DI 2 \"logical_operand\" \"r,K,JF\")]))]\n-  \"TARGET_POWERPC64\"\n-  \"@\n-   %q3 %0,%1,%2\n-   %q3i %0,%1,%b2\n-   %q3is %0,%1,%u2\")\n-\n-(define_insn \"*booldi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (match_operator:DI 4 \"boolean_or_operator\"\n-\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r\"))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   %q4. %3,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"logical,compare\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n-\t [(match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:DI 2 \"gpc_reg_operand\" \"\")])\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*booldi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (match_operator:DI 4 \"boolean_or_operator\"\n-\t [(match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")])\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(match_dup 4))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   %q4. %0,%1,%2\n-   #\"\n-  [(set_attr \"type\" \"logical,compare\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (match_operator:DI 4 \"boolean_operator\"\n-\t [(match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:DI 2 \"gpc_reg_operand\" \"\")])\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_dup 4))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0) (match_dup 4))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-;; Split a logical operation that we can't do in one insn into two insns,\n-;; each of which does one 16-bit part.  This is used by combine.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operator:DI 3 \"boolean_or_operator\"\n-\t [(match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:DI 2 \"non_logical_cint_operand\" \"\")]))]\n-  \"TARGET_POWERPC64\"\n-  [(set (match_dup 0) (match_dup 4))\n-   (set (match_dup 0) (match_dup 5))]\n-\"\n-{\n-  rtx i3,i4;\n-\n-  i3 = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n-  i4 = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-  operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[3]), DImode,\n-\t\t\t\toperands[1], i3);\n-  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[3]), DImode,\n-\t\t\t\toperands[0], i4);\n-}\")\n-\n (define_insn \"*boolcdi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(match_operator:DI 3 \"boolean_operator\""}]}