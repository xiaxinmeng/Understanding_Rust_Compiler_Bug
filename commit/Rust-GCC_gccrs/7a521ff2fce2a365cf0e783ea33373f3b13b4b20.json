{"sha": "7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E1MjFmZjJmY2UyYTM2NWNmMGU3ODNlYTMzMzczZjNiMTNiNGIyMA==", "commit": {"author": {"name": "Tobias Grosser", "email": "grosser@fim.uni-passau.de", "date": "2009-11-30T22:06:27Z"}, "committer": {"name": "Tobias Grosser", "email": "grosser@gcc.gnu.org", "date": "2009-11-30T22:06:27Z"}, "message": "Do not abuse sese for codegeneration\n\nCLooG automatically frees the names list, so sharing SESE_PARAMS_NAMES\nbetween gloog() and debug_generated_program() leads to freeing them\ntwice. As both SESE_PARAM_NAMES and SESE_PARAMS_INDEX are code\ngeneration data structures remove them and the functions working on them\nfrom sese.h and put them in clast-to-gimple.\n\n2009-11-21  Tobias Grosser  <grosser@fim.uni-passau.de>\n\n\t* graphite-clast-to-gimple.c (clast_name_index, new_clast_name_index,\n\tclast_name_to_index, save_clast_name_index, debug_clast_name_index,\n\tdebug_clast_name_indexes_1, debug_clast_name_indexes,\n\tclast_name_index_elt_info, eq_clast_name_indexes): Moved from sese.h.\n\t(clast_name_to_gcc, clast_to_gcc_expression,\n\tclast_to_gcc_expression_red, gcc_type_for_clast_expr,\n\tgcc_type_for_clast_eq, graphite_translate_clast_equation,\n\tgraphite_create_guard_cond_expr, graphite_create_new_loop,\n\ttranslate_clast): Add params_index.\n\t(initialize_cloog_names): Create parameter strings from scratch, do\n\tnot reference other strings.\n\t(create_params_index): New.\n\t(gloog): Initialize params_index.\n\t* graphite-scop-detection (free_scops_1): Removed.\n\t(limit_scops): Use normal free_scops.\n\t* graphite-sese-to-poly.c (save_var_names): Removed.\n\t(parameter_index_in_region): Do not initialize SESE_PARAM_NAMES\n\tand SESE_PARAMS_INDEX.\n\t* sese.c (new_sese, free_sese): Dito.\n\t* sese.h (struct sese): Remove params_index, params_names.\n\t(SESE_PARAMS_INDEX, SESE_PARAMS_NAMES): Removed.\n\nFrom-SVN: r154844", "tree": {"sha": "8557f4e933b1efe957ca676604b348d1e69abdc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8557f4e933b1efe957ca676604b348d1e69abdc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/comments", "author": {"login": "tobiasgrosser", "id": 521960, "node_id": "MDQ6VXNlcjUyMTk2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/521960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tobiasgrosser", "html_url": "https://github.com/tobiasgrosser", "followers_url": "https://api.github.com/users/tobiasgrosser/followers", "following_url": "https://api.github.com/users/tobiasgrosser/following{/other_user}", "gists_url": "https://api.github.com/users/tobiasgrosser/gists{/gist_id}", "starred_url": "https://api.github.com/users/tobiasgrosser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tobiasgrosser/subscriptions", "organizations_url": "https://api.github.com/users/tobiasgrosser/orgs", "repos_url": "https://api.github.com/users/tobiasgrosser/repos", "events_url": "https://api.github.com/users/tobiasgrosser/events{/privacy}", "received_events_url": "https://api.github.com/users/tobiasgrosser/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7ce0951b70d925d2c10e8927afdf74fea2669f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7ce0951b70d925d2c10e8927afdf74fea2669f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7ce0951b70d925d2c10e8927afdf74fea2669f1"}], "stats": {"total": 437, "additions": 224, "deletions": 213}, "files": [{"sha": "3f5a4313900b33696d6750551fc24a338a25d5ed", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "patch": "@@ -1,3 +1,27 @@\n+2009-11-21  Tobias Grosser  <grosser@fim.uni-passau.de>\n+\n+\t* graphite-clast-to-gimple.c (clast_name_index, new_clast_name_index,\n+\tclast_name_to_index, save_clast_name_index, debug_clast_name_index,\n+\tdebug_clast_name_indexes_1, debug_clast_name_indexes,\n+\tclast_name_index_elt_info, eq_clast_name_indexes): Moved from sese.h.\n+\t(clast_name_to_gcc, clast_to_gcc_expression,\n+\tclast_to_gcc_expression_red, gcc_type_for_clast_expr,\n+\tgcc_type_for_clast_eq, graphite_translate_clast_equation,\n+\tgraphite_create_guard_cond_expr, graphite_create_new_loop,\n+\ttranslate_clast): Add params_index.\n+\t(initialize_cloog_names): Create parameter strings from scratch, do\n+\tnot reference other strings.\n+\t(create_params_index): New.\n+\t(gloog): Initialize params_index.\n+\t* graphite-scop-detection (free_scops_1): Removed.\n+\t(limit_scops): Use normal free_scops.\n+\t* graphite-sese-to-poly.c (save_var_names): Removed.\n+\t(parameter_index_in_region): Do not initialize SESE_PARAM_NAMES\n+\tand SESE_PARAMS_INDEX.\n+\t* sese.c (new_sese, free_sese): Dito.\n+\t* sese.h (struct sese): Remove params_index, params_names.\n+\t(SESE_PARAMS_INDEX, SESE_PARAMS_NAMES): Removed.\n+\n 2009-11-20  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tRevert the following patch from 2009-09-14:"}, {"sha": "f4a784021f8d10ef455bcc1ad7171370fac82219", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 199, "deletions": 56, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "patch": "@@ -66,6 +66,106 @@ graphite_verify (void)\n #endif\n }\n \n+/* Stores the INDEX in a vector for a given clast NAME.  */\n+\n+typedef struct clast_name_index {\n+  int index;\n+  const char *name;\n+} *clast_name_index_p;\n+\n+/* Returns a pointer to a new element of type clast_name_index_p built\n+   from NAME and INDEX.  */\n+\n+static inline clast_name_index_p\n+new_clast_name_index (const char *name, int index)\n+{\n+  clast_name_index_p res = XNEW (struct clast_name_index);\n+\n+  res->name = name;\n+  res->index = index;\n+  return res;\n+}\n+\n+/* For a given clast NAME, returns -1 if it does not correspond to any\n+   parameter, or otherwise, returns the index in the PARAMS or\n+   SCATTERING_DIMENSIONS vector.  */\n+\n+static inline int\n+clast_name_to_index (const char *name, htab_t index_table)\n+{\n+  struct clast_name_index tmp;\n+  PTR *slot;\n+\n+  tmp.name = name;\n+  slot = htab_find_slot (index_table, &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((struct clast_name_index *) *slot)->index;\n+\n+  return -1;\n+}\n+\n+/* Records in INDEX_TABLE the INDEX for NAME.  */\n+\n+static inline void\n+save_clast_name_index (htab_t index_table, const char *name, int index)\n+{\n+  struct clast_name_index tmp;\n+  PTR *slot;\n+\n+  tmp.name = name;\n+  slot = htab_find_slot (index_table, &tmp, INSERT);\n+\n+  if (slot)\n+    *slot = new_clast_name_index (name, index);\n+}\n+\n+/* Print to stderr the element ELT.  */\n+\n+static inline void\n+debug_clast_name_index (clast_name_index_p elt)\n+{\n+  fprintf (stderr, \"(index = %d, name = %s)\\n\", elt->index, elt->name);\n+}\n+\n+/* Helper function for debug_rename_map.  */\n+\n+static inline int\n+debug_clast_name_indexes_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n+{\n+  struct clast_name_index *entry = (struct clast_name_index *) *slot;\n+  debug_clast_name_index (entry);\n+  return 1;\n+}\n+\n+/* Print to stderr all the elements of MAP.  */\n+\n+void\n+debug_clast_name_indexes (htab_t map)\n+{\n+  htab_traverse (map, debug_clast_name_indexes_1, NULL);\n+}\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+static inline hashval_t\n+clast_name_index_elt_info (const void *elt)\n+{\n+  return htab_hash_pointer (((const struct clast_name_index *) elt)->name);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+static inline int\n+eq_clast_name_indexes (const void *e1, const void *e2)\n+{\n+  const struct clast_name_index *elt1 = (const struct clast_name_index *) e1;\n+  const struct clast_name_index *elt2 = (const struct clast_name_index *) e2;\n+\n+  return (elt1->name == elt2->name);\n+}\n+\n+\n /* For a given loop DEPTH in the loop nest of the original black box\n    PBB, return the old induction variable associated to that loop.  */\n \n@@ -95,11 +195,10 @@ newivs_to_depth_to_newiv (VEC (tree, heap) *newivs, int depth)\n \n static tree\n clast_name_to_gcc (const char *name, sese region, VEC (tree, heap) *newivs,\n-\t\t   htab_t newivs_index)\n+\t\t   htab_t newivs_index, htab_t params_index)\n {\n   int index;\n   VEC (tree, heap) *params = SESE_PARAMS (region);\n-  htab_t params_index = SESE_PARAMS_INDEX (region);\n \n   if (params && params_index)\n     {\n@@ -128,7 +227,7 @@ max_precision_type (tree e1, tree e2)\n \n static tree\n clast_to_gcc_expression (tree, struct clast_expr *, sese, VEC (tree, heap) *,\n-\t\t\t htab_t);\n+\t\t\t htab_t, htab_t);\n \n /* Converts a Cloog reduction expression R with reduction operation OP\n    to a GCC expression tree of type TYPE.  */\n@@ -137,17 +236,17 @@ static tree\n clast_to_gcc_expression_red (tree type, enum tree_code op,\n \t\t\t     struct clast_reduction *r,\n \t\t\t     sese region, VEC (tree, heap) *newivs,\n-\t\t\t     htab_t newivs_index)\n+\t\t\t     htab_t newivs_index, htab_t params_index)\n {\n   int i;\n   tree res = clast_to_gcc_expression (type, r->elts[0], region, newivs,\n-\t\t\t\t      newivs_index);\n+\t\t\t\t      newivs_index, params_index);\n   tree operand_type = (op == POINTER_PLUS_EXPR) ? sizetype : type;\n \n   for (i = 1; i < r->n; i++)\n     {\n       tree t = clast_to_gcc_expression (operand_type, r->elts[i], region,\n-\t\t\t\t\tnewivs, newivs_index);\n+\t\t\t\t\tnewivs, newivs_index, params_index);\n       res = fold_build2 (op, type, res, t);\n     }\n \n@@ -160,7 +259,7 @@ clast_to_gcc_expression_red (tree type, enum tree_code op,\n static tree\n clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t\t\t sese region, VEC (tree, heap) *newivs,\n-\t\t\t htab_t newivs_index)\n+\t\t\t htab_t newivs_index, htab_t params_index)\n {\n   switch (e->type)\n     {\n@@ -173,21 +272,21 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t    if (value_one_p (t->val))\n \t      {\n \t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index);\n+\t\t\t\t\t       newivs_index, params_index);\n \t\treturn fold_convert (type, name);\n \t      }\n \n \t    else if (value_mone_p (t->val))\n \t      {\n \t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index);\n+\t\t\t\t\t       newivs_index, params_index);\n \t\tname = fold_convert (type, name);\n \t\treturn fold_build1 (NEGATE_EXPR, type, name);\n \t      }\n \t    else\n \t      {\n \t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index);\n+\t\t\t\t\t       newivs_index, params_index);\n \t\ttree cst = gmp_cst_to_tree (type, t->val);\n \t\tname = fold_convert (type, name);\n \t\treturn fold_build2 (MULT_EXPR, type, cst, name);\n@@ -206,15 +305,17 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t  case clast_red_sum:\n \t    return clast_to_gcc_expression_red\n \t      (type, POINTER_TYPE_P (type) ? POINTER_PLUS_EXPR : PLUS_EXPR,\n-\t       r, region, newivs, newivs_index);\n+\t       r, region, newivs, newivs_index, params_index);\n \n \t  case clast_red_min:\n \t    return clast_to_gcc_expression_red (type, MIN_EXPR, r, region,\n-\t\t\t\t\t\tnewivs, newivs_index);\n+\t\t\t\t\t\tnewivs, newivs_index,\n+\t\t\t\t\t\tparams_index);\n \n \t  case clast_red_max:\n \t    return clast_to_gcc_expression_red (type, MAX_EXPR, r, region,\n-\t\t\t\t\t\tnewivs, newivs_index);\n+\t\t\t\t\t\tnewivs, newivs_index,\n+\t\t\t\t\t\tparams_index);\n \n \t  default:\n \t    gcc_unreachable ();\n@@ -227,7 +328,7 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \tstruct clast_binary *b = (struct clast_binary *) e;\n \tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n \ttree tl = clast_to_gcc_expression (type, lhs, region, newivs,\n-\t\t\t\t\t   newivs_index);\n+\t\t\t\t\t   newivs_index, params_index);\n \ttree tr = gmp_cst_to_tree (type, b->RHS);\n \n \tswitch (b->type)\n@@ -261,7 +362,7 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n static tree\n gcc_type_for_clast_expr (struct clast_expr *e,\n \t\t\t sese region, VEC (tree, heap) *newivs,\n-\t\t\t htab_t newivs_index)\n+\t\t\t htab_t newivs_index, htab_t params_index)\n {\n   switch (e->type)\n     {\n@@ -271,7 +372,7 @@ gcc_type_for_clast_expr (struct clast_expr *e,\n \n \tif (t->var)\n \t  return TREE_TYPE (clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index));\n+\t\t\t\t\t       newivs_index, params_index));\n \telse\n \t  return NULL_TREE;\n       }\n@@ -282,14 +383,15 @@ gcc_type_for_clast_expr (struct clast_expr *e,\n \n \tif (r->n == 1)\n \t  return gcc_type_for_clast_expr (r->elts[0], region, newivs,\n-\t\t\t\t\t  newivs_index);\n+\t\t\t\t\t  newivs_index, params_index);\n \telse\n \t  {\n \t    int i;\n \t    for (i = 0; i < r->n; i++)\n \t      {\n \t\ttree type = gcc_type_for_clast_expr (r->elts[i], region,\n-\t\t\t\t\t\t     newivs, newivs_index);\n+\t\t\t\t\t\t     newivs, newivs_index,\n+\t\t\t\t\t\t     params_index);\n \t\tif (type)\n \t\t  return type;\n \t      }\n@@ -302,7 +404,7 @@ gcc_type_for_clast_expr (struct clast_expr *e,\n \tstruct clast_binary *b = (struct clast_binary *) e;\n \tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n \treturn gcc_type_for_clast_expr (lhs, region, newivs,\n-\t\t\t\t\tnewivs_index);\n+\t\t\t\t\tnewivs_index, params_index);\n       }\n \n     default:\n@@ -317,14 +419,15 @@ gcc_type_for_clast_expr (struct clast_expr *e,\n static tree\n gcc_type_for_clast_eq (struct clast_equation *cleq,\n \t\t       sese region, VEC (tree, heap) *newivs,\n-\t\t       htab_t newivs_index)\n+\t\t       htab_t newivs_index, htab_t params_index)\n {\n   tree type = gcc_type_for_clast_expr (cleq->LHS, region, newivs,\n-\t\t\t\t       newivs_index);\n+\t\t\t\t       newivs_index, params_index);\n   if (type)\n     return type;\n \n-  return gcc_type_for_clast_expr (cleq->RHS, region, newivs, newivs_index);\n+  return gcc_type_for_clast_expr (cleq->RHS, region, newivs, newivs_index,\n+\t\t\t\t  params_index);\n }\n \n /* Translates a clast equation CLEQ to a tree.  */\n@@ -333,14 +436,15 @@ static tree\n graphite_translate_clast_equation (sese region,\n \t\t\t\t   struct clast_equation *cleq,\n \t\t\t\t   VEC (tree, heap) *newivs,\n-\t\t\t\t   htab_t newivs_index)\n+\t\t\t\t   htab_t newivs_index, htab_t params_index)\n {\n   enum tree_code comp;\n-  tree type = gcc_type_for_clast_eq (cleq, region, newivs, newivs_index);\n+  tree type = gcc_type_for_clast_eq (cleq, region, newivs, newivs_index,\n+\t\t\t\t     params_index);\n   tree lhs = clast_to_gcc_expression (type, cleq->LHS, region, newivs,\n-\t\t\t\t      newivs_index);\n+\t\t\t\t      newivs_index, params_index);\n   tree rhs = clast_to_gcc_expression (type, cleq->RHS, region, newivs,\n-\t\t\t\t      newivs_index);\n+\t\t\t\t      newivs_index, params_index);\n \n   if (cleq->sign == 0)\n     comp = EQ_EXPR;\n@@ -359,15 +463,16 @@ graphite_translate_clast_equation (sese region,\n static tree\n graphite_create_guard_cond_expr (sese region, struct clast_guard *stmt,\n \t\t\t\t VEC (tree, heap) *newivs,\n-\t\t\t\t htab_t newivs_index)\n+\t\t\t\t htab_t newivs_index, htab_t params_index)\n {\n   tree cond = NULL;\n   int i;\n \n   for (i = 0; i < stmt->n; i++)\n     {\n       tree eq = graphite_translate_clast_equation (region, &stmt->eq[i],\n-\t\t\t\t\t\t   newivs, newivs_index);\n+\t\t\t\t\t\t   newivs, newivs_index,\n+\t\t\t\t\t\t   params_index);\n \n       if (cond)\n \tcond = fold_build2 (TRUTH_AND_EXPR, TREE_TYPE (eq), cond, eq);\n@@ -384,10 +489,10 @@ static edge\n graphite_create_new_guard (sese region, edge entry_edge,\n \t\t\t   struct clast_guard *stmt,\n \t\t\t   VEC (tree, heap) *newivs,\n-\t\t\t   htab_t newivs_index)\n+\t\t\t   htab_t newivs_index, htab_t params_index)\n {\n   tree cond_expr = graphite_create_guard_cond_expr (region, stmt, newivs,\n-\t\t\t\t\t\t    newivs_index);\n+\t\t\t\t\t\t    newivs_index, params_index);\n   edge exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n   return exit_edge;\n }\n@@ -460,13 +565,13 @@ static struct loop *\n graphite_create_new_loop (sese region, edge entry_edge,\n \t\t\t  struct clast_for *stmt,\n \t\t\t  loop_p outer, VEC (tree, heap) **newivs,\n-\t\t\t  htab_t newivs_index)\n+\t\t\t  htab_t newivs_index, htab_t params_index)\n {\n   tree type = gcc_type_for_iv_of_clast_loop (stmt);\n   tree lb = clast_to_gcc_expression (type, stmt->LB, region, *newivs,\n-\t\t\t\t     newivs_index);\n+\t\t\t\t     newivs_index, params_index);\n   tree ub = clast_to_gcc_expression (type, stmt->UB, region, *newivs,\n-\t\t\t\t     newivs_index);\n+\t\t\t\t     newivs_index, params_index);\n   tree stride = gmp_cst_to_tree (type, stmt->stride);\n   tree ivvar = create_tmp_var (type, \"graphite_IV\");\n   tree iv, iv_after_increment;\n@@ -488,7 +593,8 @@ graphite_create_new_loop (sese region, edge entry_edge,\n static void\n build_iv_mapping (htab_t map, sese region,\n \t\t  VEC (tree, heap) *newivs, htab_t newivs_index,\n-\t\t  struct clast_user_stmt *user_stmt)\n+\t\t  struct clast_user_stmt *user_stmt,\n+\t\t  htab_t params_index)\n {\n   struct clast_stmt *t;\n   int index = 0;\n@@ -500,10 +606,10 @@ build_iv_mapping (htab_t map, sese region,\n       struct clast_expr *expr = (struct clast_expr *)\n        ((struct clast_assignment *)t)->RHS;\n       tree type = gcc_type_for_clast_expr (expr, region, newivs,\n-\t\t\t\t\t   newivs_index);\n+\t\t\t\t\t   newivs_index, params_index);\n       tree old_name = pbb_to_depth_to_oldiv (pbb, index);\n       tree e = clast_to_gcc_expression (type, expr, region, newivs,\n-\t\t\t\t\tnewivs_index);\n+\t\t\t\t\tnewivs_index, params_index);\n       set_rename (map, old_name, e);\n     }\n }\n@@ -626,15 +732,16 @@ static edge\n translate_clast (sese region, struct loop *context_loop,\n \t\t struct clast_stmt *stmt, edge next_e,\n \t\t htab_t rename_map, VEC (tree, heap) **newivs,\n-\t\t htab_t newivs_index, htab_t bb_pbb_mapping, int level)\n+\t\t htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n+\t\t htab_t params_index)\n {\n   if (!stmt)\n     return next_e;\n \n   if (CLAST_STMT_IS_A (stmt, stmt_root))\n     return translate_clast (region, context_loop, stmt->next, next_e,\n \t\t\t    rename_map, newivs, newivs_index,\n-\t\t\t    bb_pbb_mapping, level);\n+\t\t\t    bb_pbb_mapping, level, params_index);\n \n   if (CLAST_STMT_IS_A (stmt, stmt_user))\n     {\n@@ -648,7 +755,7 @@ translate_clast (sese region, struct loop *context_loop,\n \treturn next_e;\n \n       build_iv_mapping (rename_map, region, *newivs, newivs_index,\n-\t\t\t(struct clast_user_stmt *) stmt);\n+\t\t\t(struct clast_user_stmt *) stmt, params_index);\n       next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), region,\n \t\t\t\t\t       next_e, rename_map);\n       new_bb = next_e->src;\n@@ -658,15 +765,16 @@ translate_clast (sese region, struct loop *context_loop,\n       graphite_verify ();\n       return translate_clast (region, context_loop, stmt->next, next_e,\n \t\t\t      rename_map, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level);\n+\t\t\t      bb_pbb_mapping, level, params_index);\n     }\n \n   if (CLAST_STMT_IS_A (stmt, stmt_for))\n     {\n       struct clast_for *stmtfor = (struct clast_for *)stmt;\n       struct loop *loop\n \t= graphite_create_new_loop (region, next_e, stmtfor,\n-\t\t\t\t    context_loop, newivs, newivs_index);\n+\t\t\t\t    context_loop, newivs, newivs_index,\n+\t\t\t\t    params_index);\n       edge last_e = single_exit (loop);\n       edge to_body = single_succ_edge (loop->header);\n       basic_block after = to_body->dest;\n@@ -678,7 +786,7 @@ translate_clast (sese region, struct loop *context_loop,\n       next_e = translate_clast\n \t(region, loop, ((struct clast_for *) stmt)->body,\n \t single_succ_edge (loop->header), rename_map, newivs,\n-\t newivs_index, bb_pbb_mapping, level + 1);\n+\t newivs_index, bb_pbb_mapping, level + 1, params_index);\n       redirect_edge_succ_nodup (next_e, after);\n       set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n \n@@ -695,14 +803,15 @@ translate_clast (sese region, struct loop *context_loop,\n       graphite_verify ();\n       return translate_clast (region, context_loop, stmt->next, last_e,\n \t\t\t      rename_map, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level);\n+\t\t\t      bb_pbb_mapping, level, params_index);\n     }\n \n   if (CLAST_STMT_IS_A (stmt, stmt_guard))\n     {\n       edge last_e = graphite_create_new_guard (region, next_e,\n \t\t\t\t\t       ((struct clast_guard *) stmt),\n-\t\t\t\t\t       *newivs, newivs_index);\n+\t\t\t\t\t       *newivs, newivs_index,\n+\t\t\t\t\t       params_index);\n       edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n       edge false_e = get_false_edge_from_guard_bb (next_e->dest);\n       edge exit_true_e = single_succ_edge (true_e->dest);\n@@ -714,7 +823,7 @@ translate_clast (sese region, struct loop *context_loop,\n       next_e = translate_clast (region, context_loop,\n \t\t\t\t((struct clast_guard *) stmt)->then,\n \t\t\t\ttrue_e, rename_map, newivs, newivs_index,\n-\t\t\t\tbb_pbb_mapping, level);\n+\t\t\t\tbb_pbb_mapping, level, params_index);\n       insert_guard_phis (last_e->src, exit_true_e, exit_false_e,\n \t\t\t before_guard, rename_map);\n \n@@ -724,20 +833,20 @@ translate_clast (sese region, struct loop *context_loop,\n \n       return translate_clast (region, context_loop, stmt->next, last_e,\n \t\t\t      rename_map, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level);\n+\t\t\t      bb_pbb_mapping, level, params_index);\n     }\n \n   if (CLAST_STMT_IS_A (stmt, stmt_block))\n     {\n       next_e = translate_clast (region, context_loop,\n \t\t\t\t((struct clast_block *) stmt)->body,\n \t\t\t\tnext_e, rename_map, newivs, newivs_index,\n-\t\t\t\tbb_pbb_mapping, level);\n+\t\t\t\tbb_pbb_mapping, level, params_index);\n       recompute_all_dominators ();\n       graphite_verify ();\n       return translate_clast (region, context_loop, stmt->next, next_e,\n \t\t\t      rename_map, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level);\n+\t\t\t      bb_pbb_mapping, level, params_index);\n     }\n \n   gcc_unreachable ();\n@@ -890,14 +999,30 @@ initialize_cloog_names (scop_p scop, CloogProgram *prog)\n   int i;\n   int nb_iterators = scop_max_loop_depth (scop);\n   int nb_scattering = cloog_program_nb_scattdims (prog);\n+  int nb_parameters = VEC_length (tree, SESE_PARAMS (region));\n   char **iterators = XNEWVEC (char *, nb_iterators * 2);\n   char **scattering = XNEWVEC (char *, nb_scattering);\n+  char **parameters= XNEWVEC (char *, nb_parameters);\n \n   cloog_program_set_names (prog, cloog_names_malloc ());\n-  cloog_names_set_nb_parameters (cloog_program_names (prog),\n-\t\t\t\t VEC_length (tree, SESE_PARAMS (region)));\n-  cloog_names_set_parameters (cloog_program_names (prog),\n-\t\t\t      SESE_PARAMS_NAMES (region));\n+\n+  for (i = 0; i < nb_parameters; i++)\n+    {\n+      tree param = VEC_index (tree, SESE_PARAMS(region), i);\n+      const char *name = get_name (param);\n+      int len;\n+\n+      if (!name)\n+\tname = \"T\";\n+\n+      len = strlen (name);\n+      len += 17;\n+      parameters[i] = XNEWVEC (char, len + 1);\n+      snprintf (parameters[i], len, \"%s_%d\", name, SSA_NAME_VERSION (param));\n+    }\n+\n+  cloog_names_set_nb_parameters (cloog_program_names (prog), nb_parameters);\n+  cloog_names_set_parameters (cloog_program_names (prog), parameters);\n \n   for (i = 0; i < nb_iterators; i++)\n     {\n@@ -1144,6 +1269,20 @@ debug_generated_program (scop_p scop)\n   print_generated_program (stderr, scop);\n }\n \n+/* Add CLooG names to parameter index.  The index is used to translate back from\n+ * CLooG names to GCC trees.  */\n+\n+static void\n+create_params_index (htab_t index_table, CloogProgram *prog) {\n+  CloogNames* names = cloog_program_names (prog);\n+  int nb_parameters = cloog_names_nb_parameters (names);\n+  char **parameters = cloog_names_parameters (names);\n+  int i;\n+\n+  for (i = 0; i < nb_parameters; i++)\n+    save_clast_name_index (index_table, parameters[i], i);\n+}\n+\n /* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n    the given SCOP.  Return true if code generation succeeded.\n    BB_PBB_MAPPING is a basic_block and it's related poly_bb_p mapping.\n@@ -1157,7 +1296,7 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n   loop_p context_loop;\n   sese region = SCOP_REGION (scop);\n   ifsese if_region = NULL;\n-  htab_t rename_map, newivs_index;\n+  htab_t rename_map, newivs_index, params_index;\n   cloog_prog_clast pc;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n@@ -1179,20 +1318,23 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n \t\t\t\t if_region->region->exit->src,\n \t\t\t\t if_region->false_region->exit,\n \t\t\t\t if_region->true_region->exit);\n-\n   recompute_all_dominators ();\n   graphite_verify ();\n+\n   context_loop = SESE_ENTRY (region)->src->loop_father;\n   compute_cloog_iv_types (pc.stmt);\n-\n   rename_map = htab_create (10, rename_map_elt_info, eq_rename_map_elts, free);\n   newivs_index = htab_create (10, clast_name_index_elt_info,\n \t\t\t      eq_clast_name_indexes, free);\n+  params_index = htab_create (10, clast_name_index_elt_info,\n+\t\t\t      eq_clast_name_indexes, free);\n+\n+  create_params_index (params_index, pc.prog);\n \n   new_scop_exit_edge = translate_clast (region, context_loop, pc.stmt,\n \t\t\t\t\tif_region->true_region->entry,\n \t\t\t\t\trename_map, &newivs, newivs_index,\n-\t\t\t\t\tbb_pbb_mapping, 1);\n+\t\t\t\t\tbb_pbb_mapping, 1, params_index);\n   graphite_verify ();\n   sese_adjust_liveout_phis (region, rename_map,\n \t\t\t    if_region->region->exit->src,\n@@ -1207,6 +1349,7 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n \n   htab_delete (rename_map);\n   htab_delete (newivs_index);\n+  htab_delete (params_index);\n   VEC_free (tree, heap, newivs);\n   cloog_clast_free (pc.stmt);\n   cloog_program_free (pc.prog);"}, {"sha": "02c653b69a6ef35ca8fb4a93e93fe6223e78fae3", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "patch": "@@ -1207,24 +1207,6 @@ print_graphite_statistics (FILE* file, VEC (scop_p, heap) *scops)\n     print_graphite_scop_statistics (file, scop);\n }\n \n-/* Version of free_scops special cased for limit_scops.  */\n-\n-static void\n-free_scops_1 (VEC (scop_p, heap) **scops)\n-{\n-  int i;\n-  scop_p scop;\n-\n-  for (i = 0; VEC_iterate (scop_p, *scops, i, scop); i++)\n-    {\n-      sese region = SCOP_REGION (scop);\n-      free (SESE_PARAMS_NAMES (region));\n-      SESE_PARAMS_NAMES (region) = 0;\n-    }\n-\n-  free_scops (*scops);\n-}\n-\n /* We limit all SCoPs to SCoPs, that are completely surrounded by a loop.\n \n    Example:\n@@ -1278,7 +1260,7 @@ limit_scops (VEC (scop_p, heap) **scops)\n \t  }\n     }\n \n-  free_scops_1 (scops);\n+  free_scops (*scops);\n   *scops = VEC_alloc (scop_p, heap, 3);\n \n   create_sese_edges (regions);"}, {"sha": "37b20354d6f1da6bb52c647ba1e3f533b2b09b70", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "patch": "@@ -746,26 +746,6 @@ scan_tree_for_params_int (tree cst, ppl_Linear_Expression_t expr, Value k)\n   ppl_delete_Coefficient (coef);\n }\n \n-/* Saves in NV at index I a new name for variable P.  */\n-\n-static void\n-save_var_name (char **nv, int i, tree p)\n-{\n-  const char *name = get_name (SSA_NAME_VAR (p));\n-\n-  if (name)\n-    {\n-      int len = strlen (name) + 16;\n-      nv[i] = XNEWVEC (char, len);\n-      snprintf (nv[i], len, \"%s_%d\", name, SSA_NAME_VERSION (p));\n-    }\n-  else\n-    {\n-      nv[i] = XNEWVEC (char, 16);\n-      snprintf (nv[i], 2 + 16, \"T_%d\", SSA_NAME_VERSION (p));\n-    }\n-}\n-\n /* When parameter NAME is in REGION, returns its index in SESE_PARAMS.\n    Otherwise returns -1.  */\n \n@@ -802,9 +782,6 @@ parameter_index_in_region (tree name, sese region)\n   gcc_assert (SESE_ADD_PARAMS (region));\n \n   i = VEC_length (tree, SESE_PARAMS (region));\n-  save_var_name (SESE_PARAMS_NAMES (region), i, name);\n-  save_clast_name_index (SESE_PARAMS_INDEX (region),\n-\t\t\t SESE_PARAMS_NAMES (region)[i], i);\n   VEC_safe_push (tree, heap, SESE_PARAMS (region), name);\n   return i;\n }"}, {"sha": "2c033939b7f793fa45f21a1515c5b3461d17202f", "filename": "gcc/sese.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "patch": "@@ -332,9 +332,6 @@ new_sese (edge entry, edge exit)\n   SESE_LOOP_NEST (region) = VEC_alloc (loop_p, heap, 3);\n   SESE_ADD_PARAMS (region) = true;\n   SESE_PARAMS (region) = VEC_alloc (tree, heap, 3);\n-  SESE_PARAMS_INDEX (region) = htab_create (10, clast_name_index_elt_info,\n-\t\t\t\t\t    eq_clast_name_indexes, free);\n-  SESE_PARAMS_NAMES (region) = XNEWVEC (char *, num_ssa_names);\n \n   return region;\n }\n@@ -350,11 +347,6 @@ free_sese (sese region)\n   VEC_free (tree, heap, SESE_PARAMS (region));\n   VEC_free (loop_p, heap, SESE_LOOP_NEST (region));\n \n-  if (SESE_PARAMS_INDEX (region))\n-    htab_delete (SESE_PARAMS_INDEX (region));\n-\n-  /* Do not free SESE_PARAMS_NAMES: CLooG does that.  */\n-\n   XDELETE (region);\n }\n "}, {"sha": "6763db34c27a485fd5401610d6d05c6f7baa4f28", "filename": "gcc/sese.h", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a521ff2fce2a365cf0e783ea33373f3b13b4b20/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "patch": "@@ -32,12 +32,6 @@ typedef struct sese_s\n   /* Parameters used within the SCOP.  */\n   VEC (tree, heap) *params;\n \n-  /* Used to quickly retrieve the index of a parameter in PARAMS.  */\n-  htab_t params_index;\n-\n-  /* Store the names of the parameters that are passed to CLooG.  */\n-  char **params_names;\n-\n   /* Loops completely contained in the SCOP.  */\n   bitmap loops;\n   VEC (loop_p, heap) *loop_nest;\n@@ -53,8 +47,6 @@ typedef struct sese_s\n #define SESE_EXIT(S) (S->exit)\n #define SESE_EXIT_BB(S) (S->exit->dest)\n #define SESE_PARAMS(S) (S->params)\n-#define SESE_PARAMS_INDEX(S) (S->params_index)\n-#define SESE_PARAMS_NAMES(S) (S->params_names)\n #define SESE_LOOPS(S) (S->loops)\n #define SESE_LOOP_NEST(S) (S->loop_nest)\n #define SESE_ADD_PARAMS(S) (S->add_params)\n@@ -222,105 +214,6 @@ block_before_sese (sese sese)\n   return SESE_ENTRY (sese)->src;\n }\n \n-/* Stores the INDEX in a vector for a given clast NAME.  */\n-\n-typedef struct clast_name_index {\n-  int index;\n-  const char *name;\n-} *clast_name_index_p;\n-\n-/* Returns a pointer to a new element of type clast_name_index_p built\n-   from NAME and INDEX.  */\n-\n-static inline clast_name_index_p\n-new_clast_name_index (const char *name, int index)\n-{\n-  clast_name_index_p res = XNEW (struct clast_name_index);\n-\n-  res->name = name;\n-  res->index = index;\n-  return res;\n-}\n-\n-/* For a given clast NAME, returns -1 if it does not correspond to any\n-   parameter, or otherwise, returns the index in the PARAMS or\n-   SCATTERING_DIMENSIONS vector.  */\n-\n-static inline int\n-clast_name_to_index (const char *name, htab_t index_table)\n-{\n-  struct clast_name_index tmp;\n-  PTR *slot;\n-\n-  tmp.name = name;\n-  slot = htab_find_slot (index_table, &tmp, NO_INSERT);\n-\n-  if (slot && *slot)\n-    return ((struct clast_name_index *) *slot)->index;\n-\n-  return -1;\n-}\n-\n-/* Records in INDEX_TABLE the INDEX for NAME.  */\n-\n-static inline void\n-save_clast_name_index (htab_t index_table, const char *name, int index)\n-{\n-  struct clast_name_index tmp;\n-  PTR *slot;\n-\n-  tmp.name = name;\n-  slot = htab_find_slot (index_table, &tmp, INSERT);\n-\n-  if (slot)\n-    *slot = new_clast_name_index (name, index);\n-}\n-\n-/* Print to stderr the element ELT.  */\n-\n-static inline void\n-debug_clast_name_index (clast_name_index_p elt)\n-{\n-  fprintf (stderr, \"(index = %d, name = %s)\\n\", elt->index, elt->name);\n-}\n-\n-/* Helper function for debug_rename_map.  */\n-\n-static inline int\n-debug_clast_name_indexes_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n-{\n-  struct clast_name_index *entry = (struct clast_name_index *) *slot;\n-  debug_clast_name_index (entry);\n-  return 1;\n-}\n-\n-/* Print to stderr all the elements of MAP.  */\n-\n-static inline void\n-debug_clast_name_indexes (htab_t map)\n-{\n-  htab_traverse (map, debug_clast_name_indexes_1, NULL);\n-}\n-\n-/* Computes a hash function for database element ELT.  */\n-\n-static inline hashval_t\n-clast_name_index_elt_info (const void *elt)\n-{\n-  return htab_hash_pointer (((const struct clast_name_index *) elt)->name);\n-}\n-\n-/* Compares database elements E1 and E2.  */\n-\n-static inline int\n-eq_clast_name_indexes (const void *e1, const void *e2)\n-{\n-  const struct clast_name_index *elt1 = (const struct clast_name_index *) e1;\n-  const struct clast_name_index *elt2 = (const struct clast_name_index *) e2;\n-\n-  return (elt1->name == elt2->name);\n-}\n-\n \f\n \n /* A single entry single exit specialized for conditions.  */"}]}