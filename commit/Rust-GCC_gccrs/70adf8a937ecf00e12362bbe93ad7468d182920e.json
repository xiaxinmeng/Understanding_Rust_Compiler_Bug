{"sha": "70adf8a937ecf00e12362bbe93ad7468d182920e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBhZGY4YTkzN2VjZjAwZTEyMzYyYmJlOTNhZDc0NjhkMTgyOTIwZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-02-07T20:36:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-02-07T20:36:36Z"}, "message": "cp-tree.h (struct saved_scope): Add incomplete field.\n\n        * cp-tree.h (struct saved_scope): Add incomplete field.\n        (namespace_scope_incomplete): New macro.\n        * decl.c (pushdecl): Use it.\n        (hack_incomplete_structures): Use it.  See through artificial\n        binding levels.\n        (mark_saved_scope): Mark it.\n\n        Implement access control for nested types.\n        * search.c (type_access_control): New fn.\n        (accessible_p): Now we do perform access control for types.\n        * semantics.c (deferred_type_access_control): New fn.\n        (initial_deferred_type_access_control): New fn.\n        (begin_function_definition): Call it.  Add lookups parm.\n        * decl.c (struct binding_level): Add this_class field.\n        (pushlevel_class): Set it.\n        (mark_binding_level): Mark it.\n        (lookup_name_real): Use it.  Call type_access_control.\n        (mark_saved_scope): Mark lookups field.\n        * cp-tree.h (flagged_type_tree): Add lookups field.\n        (struct saved_scope): Add lookups field.\n        (type_lookups): New macro.\n        * parse.y (declmods): Now <ftype>.\n        (parse_decl): Add lookups parm.  Call\n        initial_deferred_type_access_control.\n        (lang_extdef): Clear type_lookups.\n        (typed_declspecs, declmods, typespec): Set lookups field.\n        (initdcl): Call deferred_type_access_control.\n        (fn.def1, fn.def2, typed_declspecs1, initdcl0_innards, nomods_initdcl0,\n        component_decl_1, named_parm): Adjust.\n        * friend.c (is_friend): Nested classes are friends of their\n        enclosing classes.\n\n        * class.c (currently_open_derived_class): New fn.\n        * method.c (hack_identifier): Use it.\n\n        * lex.c (do_identifier): Remove obsolete code.\n\n        * parse.y (typed_typespecs): Propagate new_type_flag properly.\n\nFrom-SVN: r31837", "tree": {"sha": "b5ba1f06fdf738a4df46fbd5008f64ebb0936d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5ba1f06fdf738a4df46fbd5008f64ebb0936d5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70adf8a937ecf00e12362bbe93ad7468d182920e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70adf8a937ecf00e12362bbe93ad7468d182920e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70adf8a937ecf00e12362bbe93ad7468d182920e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70adf8a937ecf00e12362bbe93ad7468d182920e/comments", "author": null, "committer": null, "parents": [{"sha": "dd8216e19ee0c8f16303b8e412b8f30df82d4f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd8216e19ee0c8f16303b8e412b8f30df82d4f42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd8216e19ee0c8f16303b8e412b8f30df82d4f42"}], "stats": {"total": 2147, "additions": 1200, "deletions": 947}, "files": [{"sha": "c5fcff46f686a2875081014caf670e0b88953a6e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -1,3 +1,44 @@\n+2000-02-07  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* cp-tree.h (struct saved_scope): Add incomplete field.\n+\t(namespace_scope_incomplete): New macro.\n+\t* decl.c (pushdecl): Use it.\n+\t(hack_incomplete_structures): Use it.  See through artificial\n+\tbinding levels.\n+\t(mark_saved_scope): Mark it.\n+\n+\tImplement access control for nested types.\n+\t* search.c (type_access_control): New fn.\n+\t(accessible_p): Now we do perform access control for types.\n+\t* semantics.c (deferred_type_access_control): New fn.\n+\t(initial_deferred_type_access_control): New fn.\n+\t(begin_function_definition): Call it.  Add lookups parm.\n+\t* decl.c (struct binding_level): Add this_class field.\n+\t(pushlevel_class): Set it.\n+\t(mark_binding_level): Mark it.\n+\t(lookup_name_real): Use it.  Call type_access_control.\n+\t(mark_saved_scope): Mark lookups field.\n+\t* cp-tree.h (flagged_type_tree): Add lookups field.\n+\t(struct saved_scope): Add lookups field.\n+\t(type_lookups): New macro.\n+\t* parse.y (declmods): Now <ftype>.\n+\t(parse_decl): Add lookups parm.  Call \n+\tinitial_deferred_type_access_control.\n+\t(lang_extdef): Clear type_lookups.\n+\t(typed_declspecs, declmods, typespec): Set lookups field.\n+\t(initdcl): Call deferred_type_access_control.\n+\t(fn.def1, fn.def2, typed_declspecs1, initdcl0_innards, nomods_initdcl0,\n+\tcomponent_decl_1, named_parm): Adjust.\n+\t* friend.c (is_friend): Nested classes are friends of their\n+\tenclosing classes.\n+\n+\t* class.c (currently_open_derived_class): New fn.\n+\t* method.c (hack_identifier): Use it.\n+\n+\t* lex.c (do_identifier): Remove obsolete code.\n+\n+\t* parse.y (typed_typespecs): Propagate new_type_flag properly.\n+\n 2000-02-05  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* tinfo.h: Remove apostrophes from C++ comment (xgettext\n@@ -5481,7 +5522,7 @@ Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n 1999-06-19  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* semantics.c (finish_asm_statement): Apply decay conversions to\n+\t* semantics.c (finish_asm_stmt): Apply decay conversions to\n \tinput operands.\n \n \t* decl.c (expand_static_init): When building an anonymous function"}, {"sha": "3f8e3481103841ba4300340c94790aad7115b644", "filename": "gcc/cp/class.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -5487,7 +5487,9 @@ popclass ()\n     splay_tree_delete (current_class_stack[current_class_depth].names_used);\n }\n \n-/* Returns 1 if current_class_type is either T or a nested type of T.  */\n+/* Returns 1 if current_class_type is either T or a nested type of T.\n+   We start looking from 1 because entry 0 is from global scope, and has\n+   no type.  */\n \n int\n currently_open_class (t)\n@@ -5496,12 +5498,32 @@ currently_open_class (t)\n   int i;\n   if (t == current_class_type)\n     return 1;\n-  for (i = 0; i < current_class_depth; ++i)\n+  for (i = 1; i < current_class_depth; ++i)\n     if (current_class_stack [i].type == t)\n       return 1;\n   return 0;\n }\n \n+/* If either current_class_type or one of its enclosing classes are derived\n+   from T, return the appropriate type.  Used to determine how we found\n+   something via unqualified lookup.  */\n+\n+tree\n+currently_open_derived_class (t)\n+     tree t;\n+{\n+  int i;\n+\n+  if (DERIVED_FROM_P (t, current_class_type))\n+    return current_class_type;\n+\n+  for (i = current_class_depth - 1; i > 0; --i)\n+    if (DERIVED_FROM_P (t, current_class_stack[i].type))\n+      return current_class_stack[i].type;\n+\n+  return NULL_TREE;\n+}\n+\n /* When entering a class scope, all enclosing class scopes' names with\n    static meaning (static variables, static functions, types and enumerators)\n    have to be visible.  This recursive function calls pushclass for all"}, {"sha": "d1eedc66c64711035d127d44a65be7fe1c8591c6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -276,6 +276,7 @@ typedef struct\n {\n   tree t;\n   int new_type_flag;\n+  tree lookups;\n } flagged_type_tree;\n \n typedef struct \n@@ -714,6 +715,8 @@ struct saved_scope {\n   tree x_previous_class_type;\n   tree x_previous_class_values;\n   tree x_saved_tree;\n+  tree incomplete;\n+  tree lookups;\n \n   HOST_WIDE_INT x_processing_template_decl;\n   int x_processing_specialization;\n@@ -774,6 +777,14 @@ struct saved_scope {\n \n #define previous_class_values scope_chain->x_previous_class_values\n \n+/* A list of the declarations with incomplete type at namespace scope.  */\n+\n+#define namespace_scope_incomplete scope_chain->incomplete\n+\n+/* A list of private types mentioned, for deferred access checking.  */\n+\n+#define type_lookups scope_chain->lookups\n+\n extern struct saved_scope *scope_chain;\n \n /* Global state pertinent to the current function.  */\n@@ -3550,6 +3561,7 @@ extern tree build_vfn_ref\t\t\tPARAMS ((tree *, tree, tree));\n extern tree get_vtable_decl                     PARAMS ((tree, int));\n extern void add_method\t\t\t\tPARAMS ((tree, tree *, tree));\n extern int currently_open_class\t\t\tPARAMS ((tree));\n+extern tree currently_open_derived_class\tPARAMS ((tree));\n extern tree get_vfield_offset\t\t\tPARAMS ((tree));\n extern void duplicate_tag_error\t\t\tPARAMS ((tree));\n extern tree finish_struct\t\t\tPARAMS ((tree, tree));\n@@ -4043,6 +4055,7 @@ extern tree get_vbase\t\t\t\tPARAMS ((tree, tree));\n extern tree get_binfo\t\t\t\tPARAMS ((tree, tree, int));\n extern int get_base_distance\t\t\tPARAMS ((tree, tree, int, tree *));\n extern tree get_dynamic_cast_base_type          PARAMS ((tree, tree));\n+extern void type_access_control\t\t\tPARAMS ((tree, tree));\n extern int accessible_p                         PARAMS ((tree, tree));\n extern tree lookup_field\t\t\tPARAMS ((tree, tree, int, int));\n extern int lookup_fnfields_1                    PARAMS ((tree, tree));\n@@ -4153,7 +4166,9 @@ extern tree finish_qualified_call_expr          PARAMS ((tree, tree));\n extern tree finish_label_address_expr           PARAMS ((tree));\n extern tree finish_unary_op_expr                PARAMS ((enum tree_code, tree));\n extern tree finish_id_expr                      PARAMS ((tree));\n-extern int begin_function_definition            PARAMS ((tree, tree));\n+extern void deferred_type_access_control\tPARAMS ((void));\n+extern void initial_deferred_type_access_control PARAMS ((tree));\n+extern int begin_function_definition            PARAMS ((tree, tree, tree));\n extern tree begin_constructor_declarator        PARAMS ((tree, tree));\n extern tree finish_declarator                   PARAMS ((tree, tree, tree, tree, int));\n extern void finish_translation_unit             PARAMS ((void));"}, {"sha": "0575e487b35bd7c4182bf8e113e7cb55246464b6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 74, "deletions": 31, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -442,6 +442,9 @@ struct binding_level\n        If 0, the BLOCK is allocated (if needed) when the level is popped.  */\n     tree this_block;\n \n+    /* The _TYPE node for this level, if parm_flag == 2.  */\n+    tree this_class;\n+\n     /* The binding level which this one is contained in (inherits from).  */\n     struct binding_level *level_chain;\n \n@@ -1524,6 +1527,7 @@ pushlevel_class ()\n \n   class_binding_level = current_binding_level;\n   class_binding_level->parm_flag = 2;\n+  class_binding_level->this_class = current_class_type;\n }\n \n /* ...and a poplevel for class declarations.  */\n@@ -1837,6 +1841,7 @@ mark_binding_level (arg)\n       ggc_mark_tree (lvl->shadowed_labels);\n       ggc_mark_tree (lvl->blocks);\n       ggc_mark_tree (lvl->this_block);\n+      ggc_mark_tree (lvl->this_class);\n       ggc_mark_tree (lvl->incomplete);\n       ggc_mark_tree (lvl->dead_vars_from_for);\n \n@@ -2278,6 +2283,8 @@ mark_saved_scope (arg)\n       ggc_mark_tree (t->x_previous_class_type);\n       ggc_mark_tree (t->x_previous_class_values);\n       ggc_mark_tree (t->x_saved_tree);\n+      ggc_mark_tree (t->incomplete);\n+      ggc_mark_tree (t->lookups);\n \n       mark_stmt_tree (&t->x_stmt_tree);\n       mark_binding_level (&t->bindings);\n@@ -4033,8 +4040,14 @@ pushdecl (x)\n \t      /* RTTI TD entries are created while defining the type_info.  */\n \t      || (TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n \t\t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))))\n-\tcurrent_binding_level->incomplete\n-\t  = tree_cons (NULL_TREE, x, current_binding_level->incomplete);\n+\t{\n+\t  if (namespace_bindings_p ())\n+\t    namespace_scope_incomplete\n+\t      = tree_cons (NULL_TREE, x, namespace_scope_incomplete);\n+\t  else\n+\t    current_binding_level->incomplete\n+\t      = tree_cons (NULL_TREE, x, current_binding_level->incomplete);\n+\t}\n     }\n \n   if (need_new_binding)\n@@ -5602,7 +5615,10 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t  else if (type == current_class_type)\n \t    val = IDENTIFIER_CLASS_VALUE (name);\n \t  else\n-\t    val = lookup_member (type, name, 0, prefer_type);\n+\t    {\n+\t      val = lookup_member (type, name, 0, prefer_type);\n+\t      type_access_control (type, val);\n+\t    }\n \t}\n       else\n \tval = NULL_TREE;\n@@ -5641,6 +5657,11 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       else\n \tbinding = NULL_TREE;\n \n+      /* Handle access control on types from enclosing or base classes.  */\n+      if (binding && ! yylex\n+\t  && BINDING_LEVEL (t) && BINDING_LEVEL (t)->parm_flag == 2)\n+\ttype_access_control (BINDING_LEVEL (t)->this_class, binding);\n+\n       if (binding\n \t  && (!val || !IMPLICIT_TYPENAME_TYPE_DECL_P (binding)))\n \t{\n@@ -9118,7 +9139,7 @@ create_array_type_for_decl (name, type, size)\n    ATTRLIST is a TREE_LIST node with prefix attributes in TREE_VALUE and\n    normal attributes in TREE_PURPOSE, or NULL_TREE.\n \n-   In the TYPENAME case, DECLARATOR is really an absolute declarator.\n+   In the TYPENAME case, DECLARATOR is really an abstract declarator.\n    It may also be so in the PARM case, for a prototype where the\n    argument type is specified but not the name.\n \n@@ -14222,41 +14243,63 @@ hack_incomplete_structures (type)\n      tree type;\n {\n   tree *list;\n-\n-  if (current_binding_level->incomplete == NULL_TREE)\n-    return;\n+  struct binding_level *level;\n \n   if (!type) /* Don't do this for class templates.  */\n     return;\n \n-  for (list = &current_binding_level->incomplete; *list; )\n-    {\n-      tree decl = TREE_VALUE (*list);\n-      if ((decl && TREE_TYPE (decl) == type)\n-\t  || (TREE_TYPE (decl)\n-\t      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n-\t      && TREE_TYPE (TREE_TYPE (decl)) == type))\n-\t{\n-\t  int toplevel = toplevel_bindings_p ();\n-\t  if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n-\t      && TREE_TYPE (TREE_TYPE (decl)) == type)\n-\t    layout_type (TREE_TYPE (decl));\n-\t  layout_decl (decl, 0);\n-\t  rest_of_decl_compilation (decl, NULL_PTR, toplevel, 0);\n-\t  if (! toplevel)\n+  if (namespace_bindings_p ())\n+    {\n+      level = 0;\n+      list = &namespace_scope_incomplete;\n+    }\n+  else\n+    {\n+      level = innermost_nonclass_level ();\n+      list = &level->incomplete;\n+    }\n+\n+  while (1)\n+    {\n+      while (*list)\n+\t{\n+\t  tree decl = TREE_VALUE (*list);\n+\t  if ((decl && TREE_TYPE (decl) == type)\n+\t      || (TREE_TYPE (decl)\n+\t\t  && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n+\t\t  && TREE_TYPE (TREE_TYPE (decl)) == type))\n \t    {\n-\t      tree cleanup;\n-\t      expand_decl (decl);\n-\t      cleanup = maybe_build_cleanup (decl);\n-\t      expand_decl_init (decl);\n-\t      if (! expand_decl_cleanup (decl, cleanup))\n-\t\tcp_error (\"parser lost in parsing declaration of `%D'\",\n-\t\t\t  decl);\n+\t      int toplevel = toplevel_bindings_p ();\n+\t      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n+\t\t  && TREE_TYPE (TREE_TYPE (decl)) == type)\n+\t\tlayout_type (TREE_TYPE (decl));\n+\t      layout_decl (decl, 0);\n+\t      rest_of_decl_compilation (decl, NULL_PTR, toplevel, 0);\n+\t      if (! toplevel)\n+\t\t{\n+\t\t  tree cleanup;\n+\t\t  expand_decl (decl);\n+\t\t  cleanup = maybe_build_cleanup (decl);\n+\t\t  expand_decl_init (decl);\n+\t\t  if (! expand_decl_cleanup (decl, cleanup))\n+\t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t\t      decl);\n+\t\t}\n+\t      *list = TREE_CHAIN (*list);\n \t    }\n-\t  *list = TREE_CHAIN (*list);\n+\t  else\n+\t    list = &TREE_CHAIN (*list);\n+\t}\n+\n+      /* Keep looking through artificial binding levels generated\n+\t for local variables.  */\n+      if (level && level->keep == 2)\n+\t{\n+\t  level = level->level_chain;\n+\t  list = &level->incomplete;\n \t}\n       else\n-\tlist = &TREE_CHAIN (*list);\n+\tbreak;\n     }\n }\n "}, {"sha": "ac93bf932506ddf7b55d0b42d5e1516bf5de664d", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -101,8 +101,13 @@ is_friend (type, supplicant)\n   else\n     /* It's a type.  */\n     {\n-      if (type == supplicant)\n-\treturn 1;\n+      /* The type and its nested classes are implicitly friends, as\n+\t per core issue 45 (this is a change from the standard).  */\n+      for (context = supplicant;\n+\t   context && TYPE_P (context);\n+\t   context = TYPE_CONTEXT (context))\n+\tif (type == context)\n+\t  return 1;\n       \n       list = CLASSTYPE_FRIEND_CLASSES (TREE_TYPE (TYPE_MAIN_DECL (type)));\n       for (; list ; list = TREE_CHAIN (list))"}, {"sha": "cedb837df7d4631fd192b0a8c06d9ecbe42784d6", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -3077,12 +3077,7 @@ do_identifier (token, parsing, args)\n \n   /* Remember that this name has been used in the class definition, as per\n      [class.scope0] */\n-  if (id && parsing\n-      /* Avoid breaking if we get called for a default argument that\n-\t refers to an overloaded method.  Eventually this will not be\n-\t necessary, since default arguments shouldn't be parsed until\n-\t after the class is complete.  (jason 3/12/97) */\n-      && TREE_CODE (id) != OVERLOAD)\n+  if (id && parsing)\n     maybe_note_name_used_in_class (token, id);\n \n   if (id == error_mark_node)"}, {"sha": "ddb0842b663ca3470a34fb9b3f9ac1dad64d474d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -1978,7 +1978,7 @@ hack_identifier (value, name)\n \n   if (TREE_CODE_CLASS (TREE_CODE (value)) == 'd' && DECL_NONLOCAL (value))\n     {\n-      if (DECL_LANG_SPECIFIC (value)\n+      if (DECL_CLASS_SCOPE_P (value)\n \t  && DECL_CLASS_CONTEXT (value) != current_class_type)\n \t{\n \t  tree path;\n@@ -1987,9 +1987,8 @@ hack_identifier (value, name)\n \t      ? DECL_CLASS_CONTEXT (value)\n \t      : DECL_CONTEXT (value);\n \n-\t  get_base_distance (context, current_class_type, 0, &path);\n-\t  if (path && !enforce_access (current_class_type, value))\n-\t    return error_mark_node;\n+\t  path = currently_open_derived_class (context);\n+\t  enforce_access (path, value);\n \t}\n     }\n   else if (TREE_CODE (value) == TREE_LIST "}, {"sha": "4a2b08118211c7a624d47509e5f3964e4184cd0d", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 881, "deletions": 847, "changes": 1728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e"}, {"sha": "d1d2c1648259b00cb94ef624f91bf5917dbf5494", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 68, "deletions": 42, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -63,7 +63,7 @@ extern int end_of_file;\n static const char *cond_stmt_keyword;\n \n static tree empty_parms PARAMS ((void));\n-static void parse_decl PARAMS ((tree, tree, tree, int, tree *));\n+static void parse_decl PARAMS ((tree, tree, tree, tree, int, tree *));\n \n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n@@ -197,7 +197,6 @@ empty_parms ()\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n %type <ttype> reserved_declspecs boolean.literal\n %type <ttype> reserved_typespecquals\n-%type <ttype> declmods \n %type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier\n %type <ttype> init initlist maybeasm maybe_init defarg defarg1\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n@@ -233,6 +232,7 @@ empty_parms ()\n %type <ftype> type_id new_type_id typed_typespecs typespec typed_declspecs\n %type <ftype> typed_declspecs1 type_specifier_seq nonempty_cv_qualifiers\n %type <ftype> structsp typespecqual_reserved parm named_parm full_parm\n+%type <ftype> declmods\n \n %type <itype> extension\n \n@@ -315,13 +315,16 @@ extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n extern tree combine_strings\t\tPARAMS ((tree));\n \n static void\n-parse_decl (declarator, specs_attrs, attributes, initialized, decl)\n+parse_decl (declarator, specs_attrs, lookups, attributes, initialized, decl)\n   tree declarator;\n   tree specs_attrs;\n+  tree lookups;\n   tree attributes;\n   int initialized;\n   tree* decl;\n {\n+  initial_deferred_type_access_control (lookups);\n+\n   split_specs_attrs (specs_attrs, &current_declspecs, &prefix_attributes);\n   if (current_declspecs\n       && TREE_CODE (current_declspecs) != TREE_LIST)\n@@ -391,7 +394,8 @@ asm_keyword:\n \t;\n \n lang_extdef:\n-\t\t{ if (pending_lang_change) do_pending_lang_change(); }\n+\t\t{ if (pending_lang_change) do_pending_lang_change();\n+\t\t  type_lookups = NULL_TREE; }\n \t  extdef\n \t\t{ if (! toplevel_bindings_p ())\n \t\t  pop_everything (); }\n@@ -695,19 +699,19 @@ constructor_declarator:\n \n fn.def1:\n \t  typed_declspecs declarator\n-\t\t{ if (!begin_function_definition ($1.t, $2))\n+\t\t{ if (!begin_function_definition ($1.t, $1.lookups, $2))\n \t\t    YYERROR1; }\n \t| declmods notype_declarator\n-\t\t{ if (!begin_function_definition ($1, $2))\n+\t\t{ if (!begin_function_definition ($1.t, NULL_TREE, $2))\n \t\t    YYERROR1; }\n \t| notype_declarator\n-\t\t{ if (!begin_function_definition (NULL_TREE, $1))\n+\t\t{ if (!begin_function_definition (NULL_TREE, NULL_TREE, $1))\n \t\t    YYERROR1; }\n \t| declmods constructor_declarator\n-\t\t{ if (!begin_function_definition ($1, $2))\n+\t\t{ if (!begin_function_definition ($1.t, NULL_TREE, $2))\n \t\t    YYERROR1; }\n \t| constructor_declarator\n-\t\t{ if (!begin_function_definition (NULL_TREE, $1))\n+\t\t{ if (!begin_function_definition (NULL_TREE, NULL_TREE, $1))\n \t\t    YYERROR1; }\n \t;\n \n@@ -727,7 +731,7 @@ component_constructor_declarator:\n fn.def2:\n \t  declmods component_constructor_declarator\n \t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  attrs = build_tree_list (attrs, NULL_TREE);\n \t\t  $$ = start_method (specs, $2, attrs);\n \t\t rest_of_mdef:\n@@ -746,15 +750,15 @@ fn.def2:\n \t\t  $$ = start_method (specs, $2, attrs); goto rest_of_mdef; }\n \t| declmods notype_declarator\n \t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  attrs = build_tree_list (attrs, NULL_TREE);\n \t\t  $$ = start_method (specs, $2, attrs); goto rest_of_mdef; }\n \t| notype_declarator\n \t\t{ $$ = start_method (NULL_TREE, $$, NULL_TREE); \n \t\t  goto rest_of_mdef; }\n \t| declmods constructor_declarator\n \t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  attrs = build_tree_list (attrs, NULL_TREE);\n \t\t  $$ = start_method (specs, $2, attrs); goto rest_of_mdef; }\n \t| constructor_declarator\n@@ -1667,12 +1671,14 @@ type_id:\n \n typed_declspecs:\n \t  typed_typespecs  %prec EMPTY\n+\t\t{ $$.lookups = type_lookups; }\n \t| typed_declspecs1\n+\t\t{ $$.lookups = type_lookups; }\n \t;\n \n typed_declspecs1:\n \t  declmods typespec\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1); \n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1.t); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_declspecs  %prec HYPERUNARY\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); \n@@ -1681,14 +1687,14 @@ typed_declspecs1:\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, chainon ($2, $3)); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| declmods typespec reserved_declspecs\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); \n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals\n-\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); \n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals reserved_declspecs\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t,\n-\t\t\t\t\t chainon ($3, chainon ($4, $1))); \n+\t\t\t\t\t chainon ($3, chainon ($4, $1.t))); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t;\n \n@@ -1727,22 +1733,32 @@ reserved_declspecs:\n \n declmods:\n \t  nonempty_cv_qualifiers  %prec EMPTY\n-\t\t{ $$ = $1.t; TREE_STATIC ($$) = 1; }\n+\t\t{ $$.lookups = NULL_TREE; TREE_STATIC ($$.t) = 1; }\n \t| SCSPEC\n-\t\t{ $$ = hash_tree_cons (NULL_TREE, $$, NULL_TREE); }\n+\t\t{\n+\t\t  $$.t = hash_tree_cons (NULL_TREE, $1, NULL_TREE);\n+\t\t  $$.new_type_flag = 0; $$.lookups = NULL_TREE;\n+\t\t}\n \t| declmods CV_QUALIFIER\n-\t\t{ $$ = hash_tree_cons (NULL_TREE, $2, $$);\n-\t\t  TREE_STATIC ($$) = 1; }\n+\t\t{\n+\t\t  $$.t = hash_tree_cons (NULL_TREE, $2, $1.t);\n+\t\t  TREE_STATIC ($$.t) = 1;\n+\t\t}\n \t| declmods SCSPEC\n-\t\t{ if (extra_warnings && TREE_STATIC ($$))\n+\t\t{\n+\t\t  if (extra_warnings && TREE_STATIC ($$.t))\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = hash_tree_cons (NULL_TREE, $2, $$);\n-\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t\t  $$.t = hash_tree_cons (NULL_TREE, $2, $1.t);\n+\t\t  TREE_STATIC ($$.t) = TREE_STATIC ($1.t);\n+\t\t}\n \t| declmods attributes\n-\t\t{ $$ = hash_tree_cons ($2, NULL_TREE, $1); }\n+\t\t{ $$.t = hash_tree_cons ($2, NULL_TREE, $1.t); }\n \t| attributes  %prec EMPTY\n-\t\t{ $$ = hash_tree_cons ($1, NULL_TREE, NULL_TREE); }\n+\t\t{\n+\t\t  $$.t = hash_tree_cons ($1, NULL_TREE, NULL_TREE);\n+\t\t  $$.new_type_flag = 0; $$.lookups = NULL_TREE;\n+\t\t}\n \t;\n \n /* Used instead of declspecs where storage classes are not allowed\n@@ -1763,7 +1779,7 @@ typed_typespecs:\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_cv_qualifiers typespec reserved_typespecquals\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n-\t\t  $$.new_type_flag = $1.new_type_flag; }\n+\t\t  $$.new_type_flag = $2.new_type_flag; }\n \t;\n \n reserved_typespecquals:\n@@ -1779,20 +1795,21 @@ reserved_typespecquals:\n \n typespec:\n \t  structsp\n+\t  \t{ $$.lookups = NULL_TREE; }\n \t| TYPESPEC  %prec EMPTY\n-\t\t{ $$.t = $1; $$.new_type_flag = 0; }\n+\t\t{ $$.t = $1; $$.new_type_flag = 0; $$.lookups = NULL_TREE; }\n \t| complete_type_name\n-\t\t{ $$.t = $1; $$.new_type_flag = 0; }\n+\t\t{ $$.t = $1; $$.new_type_flag = 0; $$.lookups = NULL_TREE; }\n \t| TYPEOF '(' expr ')'\n \t\t{ $$.t = finish_typeof ($3);\n-\t\t  $$.new_type_flag = 0; }\n+\t\t  $$.new_type_flag = 0; $$.lookups = NULL_TREE; }\n \t| TYPEOF '(' type_id ')'\n \t\t{ $$.t = groktypename ($3.t);\n-\t\t  $$.new_type_flag = 0; }\n+\t\t  $$.new_type_flag = 0; $$.lookups = NULL_TREE; }\n \t| SIGOF '(' expr ')'\n \t\t{ tree type = TREE_TYPE ($3);\n \n-                  $$.new_type_flag = 0;\n+                  $$.new_type_flag = 0; $$.lookups = NULL_TREE;\n \t\t  if (IS_AGGR_TYPE (type))\n \t\t    {\n \t\t      sorry (\"sigof type specifier\");\n@@ -1807,7 +1824,7 @@ typespec:\n \t| SIGOF '(' type_id ')'\n \t\t{ tree type = groktypename ($3.t);\n \n-                  $$.new_type_flag = 0;\n+                  $$.new_type_flag = 0; $$.lookups = NULL_TREE;\n \t\t  if (IS_AGGR_TYPE (type))\n \t\t    {\n \t\t      sorry (\"sigof type specifier\");\n@@ -1858,15 +1875,21 @@ maybeasm:\n \n initdcl:\n \t  declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1,\n-\t\t\t\t\t  $3, prefix_attributes); }\n+\t\t{\n+\t\t  deferred_type_access_control ();\n+\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1,\n+\t\t\t\t\t  $3, prefix_attributes);\n+\t\t}\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ cp_finish_decl ($<ttype>5, $6, $2, LOOKUP_ONLYCONVERTING); }\n \t| declarator maybeasm maybe_attribute\n-\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0,\n+\t\t{\n+\t\t  deferred_type_access_control ();\n+\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0,\n \t\t\t\t\t  $3, prefix_attributes);\n-\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 0); }\n+\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 0);\n+\t\t}\n \t;\n \n         /* This rule assumes a certain configuration of the parser stack.\n@@ -1877,15 +1900,17 @@ initdcl:\n \t   we need that reduce so we prefer fn.def1 when appropriate.  */\n initdcl0_innards:\n \t  maybe_attribute '='\n-\t\t{ parse_decl ($<ttype>-1, $<ttype>-2, $1, 1, &$<ttype>$); }\n+\t\t{ parse_decl ($<ttype>-1, $<ftype>-2.t, $<ftype>-2.lookups,\n+\t\t\t      $1, 1, &$<ttype>$); }\n           /* Note how the declaration of the variable is in effect\n \t     while its init is parsed! */ \n \t  init\n \t\t{ cp_finish_decl ($<ttype>3, $4, $<ttype>0,\n \t\t\t\t  LOOKUP_ONLYCONVERTING); }\n \t| maybe_attribute\n \t\t{ tree d;\n-\t\t  parse_decl ($<ttype>-1, $<ttype>-2, $1, 0, &d);\n+\t\t  parse_decl ($<ttype>-1, $<ftype>-2.t, $<ftype>-2.lookups,\n+\t\t\t      $1, 0, &d);\n \t\t  cp_finish_decl (d, NULL_TREE, $<ttype>0, 0); }\n   \t;\n   \n@@ -1908,7 +1933,7 @@ nomods_initdcl0:\n             {}\n \t| constructor_declarator maybeasm maybe_attribute\n \t\t{ tree d;\n-\t\t  parse_decl($1, NULL_TREE, $3, 0, &d);\n+\t\t  parse_decl ($1, NULL_TREE, NULL_TREE, $3, 0, &d);\n \t\t  cp_finish_decl (d, NULL_TREE, $2, 0); }\n \t;\n \n@@ -2431,7 +2456,7 @@ component_decl_1:\n \t| declmods notype_components\n \t\t{ \n \t\t  if (!$2)\n-\t\t    grok_x_components ($1);\n+\t\t    grok_x_components ($1.t);\n \t\t  $$ = NULL_TREE; \n \t\t}\n \t| notype_declarator maybeasm maybe_attribute maybe_init\n@@ -2455,7 +2480,7 @@ component_decl_1:\n \t   parmlist? */\n \t| declmods component_constructor_declarator maybeasm maybe_attribute maybe_init\n \t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  $$ = grokfield ($2, specs, $5, $3,\n \t\t\t\t  build_tree_list ($4, attrs)); }\n \t| component_constructor_declarator maybeasm maybe_attribute maybe_init\n@@ -2824,6 +2849,7 @@ functional_cast:\n \t| typespec fcast_or_absdcl  %prec EMPTY\n \t\t{ $$ = reparse_absdcl_as_expr ($1.t, $2); }\n \t;\n+\n type_name:\n \t  TYPENAME\n \t| SELFNAME\n@@ -3529,7 +3555,7 @@ named_parm:\n \t\t  $$.t = build_tree_list (specs, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| declmods notype_declarator\n-\t\t{ tree specs = strip_attrs ($1);\n+\t\t{ tree specs = strip_attrs ($1.t);\n \t\t  $$.t = build_tree_list (specs, $2); \n \t\t  $$.new_type_flag = 0; }\n \t;"}, {"sha": "57b56084a9cef9248c4eea444d477ab985ff9670", "filename": "gcc/cp/search.c", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -1072,9 +1072,44 @@ friend_accessible_p (scope, type, decl, binfo)\n \n   return 0;\n }\n-   \n+\n+/* Perform access control on TYPE_DECL VAL, which was looked up in TYPE.\n+   This is fairly complex, so here's the design:\n+\n+   The lang_extdef nonterminal sets type_lookups to NULL_TREE before we\n+     start to process a top-level declaration.\n+   As we process the decl-specifier-seq for the declaration, any types we\n+     see that might need access control are passed to type_access_control,\n+     which defers checking by adding them to type_lookups.\n+   When we are done with the decl-specifier-seq, we record the lookups we've\n+     seen in the lookups field of the typed_declspecs nonterminal.\n+   When we process the first declarator, either in parse_decl or\n+     begin_function_definition, we call initial_deferred_type_access_control,\n+     which processes any lookups from within that declarator, stores the\n+     lookups from the decl-specifier-seq in current_type_lookups, and sets\n+     type_lookups to error_mark_node.\n+   Subsequent declarators process current_type_lookups again to make sure\n+     that the types are accessible to all of the declarators.  Any lookups\n+     within subsequent declarators are processed immediately.\n+   Within a function, type_lookups is error_mark_node, so all lookups are\n+     processed immediately.  */\n+\n+void\n+type_access_control (type, val)\n+     tree type, val;\n+{\n+  if (val == NULL_TREE || TREE_CODE (val) != TYPE_DECL\n+      || ! DECL_CLASS_SCOPE_P (val))\n+    return;\n+\n+  if (type_lookups == error_mark_node)\n+    enforce_access (type, val);\n+  else if (! accessible_p (type, val))\n+    type_lookups = tree_cons (type, val, type_lookups);\n+}\n+\n /* DECL is a declaration from a base class of TYPE, which was the\n-   classs used to name DECL.  Return non-zero if, in the current\n+   class used to name DECL.  Return non-zero if, in the current\n    context, DECL is accessible.  If TYPE is actually a BINFO node,\n    then we can tell in what context the access is occurring by looking\n    at the most derived class along the path indicated by BINFO.  */\n@@ -1101,10 +1136,6 @@ accessible_p (type, decl)\n   if (!TYPE_P (context_for_name_lookup (decl)))\n     return 1;\n \n-  /* We don't do access control for types yet.  */\n-  if (TREE_CODE (decl) == TYPE_DECL)\n-    return 1;\n-\n   if (!TYPE_P (type))\n     {\n       binfo = type;\n@@ -1145,8 +1176,8 @@ accessible_p (type, decl)\n     protected_ok = friend_accessible_p (current_scope (),\n \t\t\t\t\ttype, decl, binfo);\n \n-  /* Standardize on the same that will access_in_type will use.  We\n-     don't need to know what path was chosen from this point onwards.  */ \n+  /* Standardize the binfo that access_in_type will use.  We don't\n+     need to know what path was chosen from this point onwards.  */\n   binfo = TYPE_BINFO (type);\n \n   /* Compute the accessibility of DECL in the class hierarchy\n@@ -1457,7 +1488,7 @@ lookup_field_r (binfo, data)\n    1, we enforce accessibility.  If PROTECT is zero, then, for an\n    ambiguous lookup, we return NULL.  If PROTECT is 1, we issue an\n    error message.  If PROTECT is 2, we return a TREE_LIST whose\n-   TREEE_TYPE is error_mark_node and whose TREE_VALUEs are the list of\n+   TREE_TYPE is error_mark_node and whose TREE_VALUEs are the list of\n    ambiguous candidates.\n \n    WANT_TYPE is 1 when we should only return TYPE_DECLs, if no"}, {"sha": "abe9fb16d0e466b0b85b59994a64f7e65665fab8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70adf8a937ecf00e12362bbe93ad7468d182920e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=70adf8a937ecf00e12362bbe93ad7468d182920e", "patch": "@@ -1690,17 +1690,59 @@ finish_id_expr (expr)\n   return expr;\n }\n \n-/* Begin a function defniition declared with DECL_SPECS and\n+static tree current_type_lookups;\n+\n+/* Perform deferred access control for types used in the type of a\n+   declaration.  */\n+\n+void\n+deferred_type_access_control ()\n+{\n+  tree lookup = current_type_lookups;\n+\n+  if (lookup == error_mark_node)\n+    return;\n+\n+  for (; lookup; lookup = TREE_CHAIN (lookup))\n+    enforce_access (TREE_PURPOSE (lookup), TREE_VALUE (lookup));\n+}\n+\n+/* Perform deferred access control for types used in the type of a\n+   declaration.  Called for the first declarator in a declaration.  */\n+\n+void\n+initial_deferred_type_access_control (lookups)\n+     tree lookups;\n+{\n+  tree lookup = type_lookups;\n+\n+  /* First perform the checks for the current declarator; they will have\n+     been added to type_lookups since typed_declspecs saved the copy that\n+     we have been passed.  */\n+  if (lookup != error_mark_node)\n+    for (; lookup != lookups; lookup = TREE_CHAIN (lookup))\n+      enforce_access (TREE_PURPOSE (lookup), TREE_VALUE (lookup));\n+\n+  current_type_lookups = lookups;\n+  type_lookups = error_mark_node;\n+  deferred_type_access_control ();\n+}    \n+\n+/* Begin a function definition declared with DECL_SPECS and\n    DECLARATOR.  Returns non-zero if the function-declaration is\n    legal.  */\n \n int\n-begin_function_definition (decl_specs, declarator)\n+begin_function_definition (decl_specs, lookups, declarator)\n      tree decl_specs;\n+     tree lookups;\n      tree declarator;\n {\n   tree specs;\n   tree attrs;\n+\n+  initial_deferred_type_access_control (lookups);\n+  \n   split_specs_attrs (decl_specs, &specs, &attrs);\n   if (!start_function (specs, declarator, attrs, SF_DEFAULT))\n     return 0;"}]}