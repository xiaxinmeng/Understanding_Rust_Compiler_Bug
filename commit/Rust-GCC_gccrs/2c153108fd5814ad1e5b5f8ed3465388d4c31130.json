{"sha": "2c153108fd5814ad1e5b5f8ed3465388d4c31130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMxNTMxMDhmZDU4MTRhZDFlNWI1ZjhlZDM0NjUzODhkNGMzMTEzMA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-02-18T18:17:52Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-02-18T18:17:52Z"}, "message": "s390.c (s390_emit_prologue): Do not set the frame_related flag for call-clobbered registers.\n\n\t* config/s390/s390.c (s390_emit_prologue): Do not set the\n\tframe_related flag for call-clobbered registers.\n\nFrom-SVN: r49843", "tree": {"sha": "c16e8ee660f2bb706bf341e5ed7baf6187828518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c16e8ee660f2bb706bf341e5ed7baf6187828518"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c153108fd5814ad1e5b5f8ed3465388d4c31130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c153108fd5814ad1e5b5f8ed3465388d4c31130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c153108fd5814ad1e5b5f8ed3465388d4c31130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c153108fd5814ad1e5b5f8ed3465388d4c31130/comments", "author": null, "committer": null, "parents": [{"sha": "e95d6b23ae65e724b4e03b415cae12d3be49c10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95d6b23ae65e724b4e03b415cae12d3be49c10c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95d6b23ae65e724b4e03b415cae12d3be49c10c"}], "stats": {"total": 53, "additions": 43, "deletions": 10}, "files": [{"sha": "c4cab2d5d70ec995c5276e89de7a409a615ee9ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c153108fd5814ad1e5b5f8ed3465388d4c31130/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c153108fd5814ad1e5b5f8ed3465388d4c31130/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c153108fd5814ad1e5b5f8ed3465388d4c31130", "patch": "@@ -1,3 +1,8 @@\n+2002-02-18  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_emit_prologue): Do not set the\n+\tframe_related flag for call-clobbered registers.\n+\n Mon Feb 18 15:07:35 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (classify_argument): Properly classify SSE/MMX modes and VOIDmode."}, {"sha": "dcccb00b92006def1e47120dcd36eeff95b5d73e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c153108fd5814ad1e5b5f8ed3465388d4c31130/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c153108fd5814ad1e5b5f8ed3465388d4c31130/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=2c153108fd5814ad1e5b5f8ed3465388d4c31130", "patch": "@@ -2841,7 +2841,7 @@ s390_emit_prologue ()\n   struct s390_frame frame;\n   rtx insn, addr;\n   rtx temp_reg;\n-  int i, limit;\n+  int i;\n \n   /* Compute frame_info.  */\n \n@@ -2871,24 +2871,52 @@ s390_emit_prologue ()\n \t\t\t      GEN_INT (frame.last_save_gpr \n \t\t\t\t       - frame.first_save_gpr + 1)));\n \n-\t  /* Set RTX_FRAME_RELATED_P for all sets within store multiple.  */\n+\t  /* We need to set the FRAME_RELATED flag on all SETs\n+\t     inside the store-multiple pattern.\n+\n+\t     However, we must not emit DWARF records for registers 2..5\n+\t     if they are stored for use by variable arguments ...  \n+\n+\t     ??? Unfortunately, it is not enough to simply not the the\n+\t     FRAME_RELATED flags for those SETs, because the first SET\n+\t     of the PARALLEL is always treated as if it had the flag\n+\t     set, even if it does not.  Therefore we emit a new pattern\n+\t     without those registers as REG_FRAME_RELATED_EXPR note.  */\n+\n+\t  if (frame.first_save_gpr >= 6)\n+\t    {\n+\t      rtx pat = PATTERN (insn);\n+\n+\t      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n+\t\t  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n \n-\t  limit = XVECLEN (PATTERN (insn), 0);\n-\t  \n-\t  for (i = 0; i < limit; i++)\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t  else if (frame.last_save_gpr >= 6)\n \t    {\n-\t      rtx x = XVECEXP (PATTERN (insn), 0, i);\n-\t      \n-\t      if (GET_CODE (x) == SET)\n-\t\tRTX_FRAME_RELATED_P (x) = 1;\n+\t      rtx note, naddr;\n+\t      naddr = plus_constant (stack_pointer_rtx, 6 * UNITS_PER_WORD);\n+\t      note = gen_store_multiple (gen_rtx_MEM (Pmode, naddr), \n+\t\t\t\t\t gen_rtx_REG (Pmode, 6),\n+\t\t\t\t\t GEN_INT (frame.last_save_gpr - 6 + 1));\n+\t      REG_NOTES (insn) =\n+\t\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, \n+\t\t\t\t   note, REG_NOTES (insn));\n+\n+\t      for (i = 0; i < XVECLEN (note, 0); i++)\n+\t\tif (GET_CODE (XVECEXP (note, 0, i)) == SET)\n+\t\t  RTX_FRAME_RELATED_P (XVECEXP (note, 0, i)) = 1;\n+\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t}\n       else\n \t{\n \t  insn = emit_move_insn (addr, \n \t\t\t\t gen_rtx_REG (Pmode, frame.first_save_gpr));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   /* Dump constant pool and set constant pool register (13).  */"}]}