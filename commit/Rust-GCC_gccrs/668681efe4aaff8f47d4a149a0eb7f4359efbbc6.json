{"sha": "668681efe4aaff8f47d4a149a0eb7f4359efbbc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY4NjgxZWZlNGFhZmY4ZjQ3ZDRhMTQ5YTBlYjdmNDM1OWVmYmJjNg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-05-19T13:50:00Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-05-19T13:50:00Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1017", "tree": {"sha": "cda3438214b65ac53e1f6414ca5e6ccb0e6de2fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cda3438214b65ac53e1f6414ca5e6ccb0e6de2fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/668681efe4aaff8f47d4a149a0eb7f4359efbbc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668681efe4aaff8f47d4a149a0eb7f4359efbbc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/668681efe4aaff8f47d4a149a0eb7f4359efbbc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668681efe4aaff8f47d4a149a0eb7f4359efbbc6/comments", "author": null, "committer": null, "parents": [{"sha": "6639753e2647f8f9b2a573f90ea5b6635e22d55c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6639753e2647f8f9b2a573f90ea5b6635e22d55c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6639753e2647f8f9b2a573f90ea5b6635e22d55c"}], "stats": {"total": 127, "additions": 86, "deletions": 41}, "files": [{"sha": "5aeac70038fb00e7a4c44e421efc04d171b6c03f", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668681efe4aaff8f47d4a149a0eb7f4359efbbc6/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668681efe4aaff8f47d4a149a0eb7f4359efbbc6/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=668681efe4aaff8f47d4a149a0eb7f4359efbbc6", "patch": "@@ -46,7 +46,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.1.4.6 20 Apr 1992 14:30:40\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.1.11.5 19 May 1992 08:15:15\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -1350,6 +1350,8 @@ output_options (file, f_options, f_len, W_options, W_len,\n     pos = output_option (file, sep, \"-traditional\", \"\", indent, pos, max);\n   if (profile_flag)\n     pos = output_option (file, sep, \"-p\", \"\", indent, pos, max);\n+  if (profile_block_flag)\n+    pos = output_option (file, sep, \"-a\", \"\", indent, pos, max);\n \n   for (j = 0; j < f_len; j++)\n     if (*f_options[j].variable == f_options[j].on_value)\n@@ -1678,7 +1680,7 @@ m88k_layout_frame ()\n   frame_size = get_frame_size ();\n \n   /* Since profiling requires a call, make sure r1 is saved.  */\n-  if (profile_flag)\n+  if (profile_flag || profile_block_flag)\n     save_regs[1] = 1;\n \n   /* If we are producing debug information, store r1 and r30 where the\n@@ -1744,14 +1746,10 @@ m88k_layout_frame ()\n   /* The first two saved registers are placed above the new frame pointer\n      if any.  In the only case this matters, they are r1 and r30. */\n   if (frame_pointer_needed || sp_size)\n-    {\n-      m88k_fp_offset = ROUND_CALL_BLOCK_SIZE (sp_size - STARTING_FRAME_OFFSET);\n-      m88k_stack_size = m88k_fp_offset + STARTING_FRAME_OFFSET;\n-    }\n+    m88k_fp_offset = ROUND_CALL_BLOCK_SIZE (sp_size - STARTING_FRAME_OFFSET);\n   else\n-    {\n-      m88k_stack_size = m88k_fp_offset = 0;\n-    }\n+    m88k_fp_offset = -STARTING_FRAME_OFFSET;\n+  m88k_stack_size = m88k_fp_offset + STARTING_FRAME_OFFSET;\n \n   /* First, combine m88k_stack_size and size.  If m88k_stack_size is\n      non-zero, align the frame size to 8 mod 16; otherwise align the\n@@ -2455,11 +2453,21 @@ output_function_block_profiler (file, labelno)\n \t\t m88k_pound_sign, &block[1]);\n   fprintf (file, \"\\tbcnd\\t %sne0,%s,%s\\n\",\n \t\t m88k_pound_sign, reg_names[26], &label[1]);\n+  fprintf (file, \"\\tsubu\\t %s,%s,64\\n\", reg_names[31], reg_names[31]);\n+  fprintf (file, \"\\tst.d\\t %s,%s,32\\n\", reg_names[2], reg_names[31]);\n+  fprintf (file, \"\\tst.d\\t %s,%s,40\\n\", reg_names[4], reg_names[31]);\n+  fprintf (file, \"\\tst.d\\t %s,%s,48\\n\", reg_names[6], reg_names[31]);\n+  fprintf (file, \"\\tst.d\\t %s,%s,56\\n\", reg_names[8], reg_names[31]);\n   fputs (\"\\tbsr.n\\t \", file);\n   ASM_OUTPUT_LABELREF (file, \"__bb_init_func\");\n   putc ('\\n', file);\n   fprintf (file, \"\\tor\\t %s,%s,%slo16(%s)\\n\", reg_names[2], reg_names[27],\n \t\t m88k_pound_sign, &block[1]);\n+  fprintf (file, \"\\tld.d\\t %s,%s,32\\n\", reg_names[2], reg_names[31]);\n+  fprintf (file, \"\\tld.d\\t %s,%s,40\\n\", reg_names[4], reg_names[31]);\n+  fprintf (file, \"\\tld.d\\t %s,%s,48\\n\", reg_names[6], reg_names[31]);\n+  fprintf (file, \"\\tld.d\\t %s,%s,56\\n\", reg_names[8], reg_names[31]);\n+  fprintf (file, \"\\taddu\\t %s,%s,64\\n\", reg_names[31], reg_names[31]);\n   ASM_OUTPUT_INTERNAL_LABEL (file, \"LPY\", labelno);\n }\n \n@@ -2473,7 +2481,7 @@ output_block_profiler (file, blockno)\n {\n   char block[256];\n \n-  ASM_GENERATE_INTERNAL_LABEL (block, \"LPBX\", 0);\n+  ASM_GENERATE_INTERNAL_LABEL (block, \"LPBX\", 2);\n \n   /* @@ Need to deal with PIC.  I'm not sure what the requirements are on\n      register usage, so I used r26/r27 to be safe.  */"}, {"sha": "b0f216433478fdf9e263bb664692300827b8c0c8", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668681efe4aaff8f47d4a149a0eb7f4359efbbc6/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668681efe4aaff8f47d4a149a0eb7f4359efbbc6/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=668681efe4aaff8f47d4a149a0eb7f4359efbbc6", "patch": "@@ -204,9 +204,9 @@ extern char * reg_names[];\n /* Print subsidiary information on the compiler version in use.\n    Redefined in m88kv4.h, and m88kluna.h.  */\n #define VERSION_INFO1\t\"88open OCS/BCS, \"\n-#define VERSION_INFO2\t\"27 Apr 1992\"\n+#define VERSION_INFO2\t\"19 May 1992\"\n #define VERSION_STRING\tversion_string\n-#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.4.6 27 Apr 1992 16:30:45\"\n+#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.11.5 19 May 1992 09:28:04\"\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -1926,33 +1926,42 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n #define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n   fprintf (FILE, \"\\t%s\\t 0x%x\\n\", CHAR_ASM_OP, (VALUE))\n \n-/* The singl-byte pseudo-op is the default.  Override svr[34].h.  */\n+/* The single-byte pseudo-op is the default.  Override svr[34].h.  */\n #undef\tASM_BYTE_OP\n-#define ASM_BYTE_OP \"\\tbyte\"\n+#define ASM_BYTE_OP \"byte\"\n #undef\tASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii (FILE, ASCII_DATA_ASM_OP, 48, P, SIZE)\n \n+/* The case table contains either words or branch instructions.  This says\n+   which.  We always claim that the vector is PC-relative.  It is position\n+   independent when -fpic is used.  */\n+#define CASE_VECTOR_INSNS (TARGET_88100 || flag_pic)\n+\n /* Epilogue for case labels.  This jump instruction is called by casesi\n    to transfer to the appropriate branch instruction within the table.\n    The label `@L<n>e' is coined to mark the end of the table.  */\n #define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    char label[256];\t\t\t\t\t\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (label, \"L\", NUM);\t\t\t\\\n-    fprintf (FILE, \"%se:\\n\", &label[1]);\t\t\t\t\\\n-    if (! flag_delayed_branch)\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tlda\\t %s,%s[%s]\\n\", reg_names[1], reg_names[1],\t\\\n-\t       reg_names[m88k_case_index]);\t\t\t\t\\\n-    fprintf (FILE, \"\\tjmp\\t %s\\n\", reg_names[1]);\t\t\t\\\n+    if (CASE_VECTOR_INSNS)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar label[256]; \t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"L\", NUM);\t\t\t\\\n+\tfprintf (FILE, \"%se:\\n\", &label[1]);\t\t\t\t\\\n+\tif (! flag_delayed_branch)\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\tlda\\t %s,%s[%s]\\n\", reg_names[1],\t\t\\\n+\t\t   reg_names[1], reg_names[m88k_case_index]);\t\t\\\n+\tfprintf (FILE, \"\\tjmp\\t %s\\n\", reg_names[1]);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* This is how to output an element of a case-vector that is absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     char buffer[256];\t\t\t\t\t\t\t\\\n     ASM_GENERATE_INTERNAL_LABEL (buffer, \"L\", VALUE);\t\t\t\\\n-    fprintf (FILE, \"\\tbr\\t %s\\n\", &buffer[1]);\t\t\t\t\\\n+    fprintf (FILE, CASE_VECTOR_INSNS ? \"\\tbr\\t %s\\n\" : \"\\tword\\t %s\\n\",\t\\\n+\t     &buffer[1]);\t\t\t\t\t\t\\\n   } while (0)\n \n /* This is how to output an element of a case-vector that is relative.  */"}, {"sha": "1a1c946edb26e6f8865f48444a297c92e07ad3e6", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668681efe4aaff8f47d4a149a0eb7f4359efbbc6/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668681efe4aaff8f47d4a149a0eb7f4359efbbc6/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=668681efe4aaff8f47d4a149a0eb7f4359efbbc6", "patch": "@@ -28,7 +28,7 @@\n (define_expand \"m88k_sccs_id\"\n   [(match_operand:SI 0 \"\" \"\")]\n   \"\"\n-  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.1.4.3 20 Apr 1992 10:42:47\\\";\n+  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.1.11.3 19 May 1992 08:44:52\\\";\n      FAIL; }\")\n \f\n ;; Attribute specifications\n@@ -148,10 +148,15 @@\n ;\t\t\t\t\t \"!store,mstore,marith,mbit,mfp,weird\") 1 0)\n ;(define_function_unit \"alu\" 1 0 (eq_attr \"type\" \"marith,mbit,weird\") 2 0)\n \n+(define_function_unit \"alu\" 1 0\n+  (and (eq_attr \"type\" \"loada,arith,bit,mov\") (eq_attr \"cpu\" \"!m88100\")) 2 0)\n+(define_function_unit \"alu\" 1 0\n+  (and (eq_attr \"type\" \"marith,mbit,weird\") (eq_attr \"cpu\" \"!m88100\")) 4 0)\n+\n (define_function_unit \"memory\" 1 3\n   (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"m88100\")) 3 2)\n (define_function_unit \"memory\" 1 3\n-  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"!m88100\")) 2 2)\n+  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"!m88100\")) 4 2)\n \n ; The fp1 and fplast descriptions currently have no effect.\n ;(define_function_unit \"fp1\" 1 1 (eq_attr \"fpu\" \"yes\") 1 2)\n@@ -169,7 +174,7 @@\n \n (define_function_unit \"fpmul\" 1 4\n   (and (eq_attr \"type\" \"imul,spmul,dpmul,mfp\")\n-       (eq_attr \"cpu\" \"!m88100\")) 3 2)\t\t\t\t\t; 3\n+       (eq_attr \"cpu\" \"!m88100\")) 6 2)\t\t\t\t\t; 3\n \n (define_function_unit \"fpadd\" 1 3\n   (and (eq_attr \"type\" \"spadd,spcmp\") (eq_attr \"cpu\" \"m88100\")) 3 2)\t; 5-6\n@@ -183,15 +188,15 @@\n   (and (eq_attr \"type\" \"idiv\") (eq_attr \"cpu\" \"m88100\")) 38 2)\t\t; 38\n \n (define_function_unit \"fpadd\" 1 3\n-  (and (eq_attr \"type\" \"spadd,dpadd\") (eq_attr \"cpu\" \"!m88100\")) 3 2)\t; 3\n+  (and (eq_attr \"type\" \"spadd,dpadd\") (eq_attr \"cpu\" \"!m88100\")) 6 2)\t; 3\n (define_function_unit \"fpadd\" 1 3\n-  (and (eq_attr \"type\" \"spcmp,dpcmp\") (eq_attr \"cpu\" \"!m88100\")) 1 2)\t; 3\n+  (and (eq_attr \"type\" \"spcmp,dpcmp\") (eq_attr \"cpu\" \"!m88100\")) 2 2)\t; 3\n (define_function_unit \"fpadd\" 1 3\n-  (and (eq_attr \"type\" \"spdiv\") (eq_attr \"cpu\" \"!m88100\")) 13 2)\t; 13\n+  (and (eq_attr \"type\" \"spdiv\") (eq_attr \"cpu\" \"!m88100\")) 26 2)\t; 13\n (define_function_unit \"fpadd\" 1 3\n-  (and (eq_attr \"type\" \"dpdiv\") (eq_attr \"cpu\" \"!m88100\")) 23 2)\t; 23\n+  (and (eq_attr \"type\" \"dpdiv\") (eq_attr \"cpu\" \"!m88100\")) 46 2)\t; 23\n (define_function_unit \"fpadd\" 1 3\n-  (and (eq_attr \"type\" \"idiv\") (eq_attr \"cpu\" \"!m88100\")) 18 2)\t\t; 18\n+  (and (eq_attr \"type\" \"idiv\") (eq_attr \"cpu\" \"!m88100\")) 36 2)\t\t; 18\n \n ;(define_function_unit \"fplast\" 1 1 (eq_attr \"fpu\" \"yes\") 1 2)\n \n@@ -1338,7 +1343,7 @@\n    (use (match_dup 5))\n    (parallel [(call (mem:SI (match_operand 0 \"\" \"\"))\n \t\t    (const_int 0))\n-\t      (use (reg:SI 1))])]\n+\t      (clobber (reg:SI 1))])]\n   \"\"\n   \"\")\n \n@@ -1360,7 +1365,7 @@\n    (use (reg:SI 6))\n    (parallel [(call (mem:SI (match_operand 0 \"\" \"\"))\n \t\t    (const_int 0))\n-\t      (use (reg:SI 1))])]\n+\t      (clobber (reg:SI 1))])]\n   \"\"\n   \"\")\n \f\n@@ -2940,22 +2945,45 @@\n {\n   register rtx index_diff = gen_reg_rtx (SImode);\n   register rtx low = gen_rtx (CONST_INT, VOIDmode, -INTVAL (operands[1]));\n+  register rtx label = gen_rtx (LABEL_REF, VOIDmode, operands[3]);\n+  register rtx base;\n+\n+  if (! CASE_VECTOR_INSNS)\n+    /* These instructions are likely to be scheduled and made loop invariant.\n+       This decreases the cost of the dispatch at the expense of the default\n+       case.  */\n+    base = force_reg (SImode, memory_address_noforce (SImode, label));\n \n   /* Compute the index difference and handle the default case.  */\n   emit_insn (gen_addsi3 (index_diff,\n \t\t\t force_reg (SImode, operands[0]),\n \t\t\t ADD_INT (low) ? low : force_reg (SImode, low)));\n   emit_insn (gen_cmpsi (index_diff, operands[2]));\n+  /* It's possible to replace this branch with sgtu/iorsi3 and adding a -1\n+     entry to the table.  However, that doesn't seem to win on the m88110.  */\n   emit_jump_insn (gen_bgtu (operands[4]));\n \n-  /* Call the jump that will branch to the appropriate case.  */\n-  emit_jump_insn (gen_casesi_enter (gen_rtx (LABEL_REF, VOIDmode, operands[3]),\n-\t\t\t\t    index_diff,\n-\t\t\t\t    operands[3]));\n-  /* Claim that flow drops into the table so it will be adjacent.  */\n+  if (CASE_VECTOR_INSNS)\n+    /* Call the jump that will branch to the appropriate case.  */\n+    emit_jump_insn (gen_casesi_enter (label, index_diff, operands[3]));\n+  else\n+    /* Load the table entry and jump to it.  */\n+    emit_jump_insn (gen_casesi_jump (gen_reg_rtx (SImode), base, index_diff));\n+\n+  /* Claim that flow drops into the table so it will be adjacent by not\n+     emitting a barrier.  */\n   DONE;\n }\")\n \n+(define_expand \"casesi_jump\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"\" \"\")\n+\t\t\t (mult:SI (match_operand:SI 2 \"\" \"\")\n+\t\t\t\t  (const_int 4)))))\n+   (set (pc) (match_dup 0))]\n+  \"\"\n+  \"\")\n+\n ;; The bsr.n instruction is directed to the END of the table.  See\n ;; ASM_OUTPUT_CASE_END.\n \n@@ -2981,7 +3009,7 @@\n (define_expand \"call\"\n   [(parallel [(call (match_operand:SI 0 \"\" \"\")\n \t\t    (match_operand 1 \"\" \"\"))\n-\t      (use (reg:SI 1))])]\n+\t      (clobber (reg:SI 1))])]\n   \"\"\n   \"\n {\n@@ -2994,7 +3022,7 @@\n (define_insn \"\"\n   [(parallel [(call (mem:SI (match_operand:SI 0 \"call_address_operand\" \"rQ\"))\n \t\t    (match_operand 1 \"\" \"\"))\n-\t      (use (reg:SI 1))])]\n+\t      (clobber (reg:SI 1))])]\n   \"\"\n   \"* return output_call (operands, operands[0]);\"\n   [(set_attr \"type\" \"call\")])\n@@ -3003,7 +3031,7 @@\n   [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n \t\t   (call (match_operand:SI 1 \"\" \"\")\n \t\t\t (match_operand 2 \"\" \"\")))\n-\t      (use (reg:SI 1))])]\n+\t      (clobber (reg:SI 1))])]\n   \"\"\n   \"\n {\n@@ -3018,7 +3046,7 @@\n \t\t   (call (mem:SI\n \t\t\t  (match_operand:SI 1 \"call_address_operand\" \"rQ\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n-\t      (use (reg:SI 1))])]\n+\t      (clobber (reg:SI 1))])]\n   \"\"\n   \"* return output_call (operands, operands[1]);\"\n   [(set_attr \"type\" \"call\")])"}]}