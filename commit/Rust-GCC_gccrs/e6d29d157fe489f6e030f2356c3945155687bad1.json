{"sha": "e6d29d157fe489f6e030f2356c3945155687bad1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZkMjlkMTU3ZmU0ODlmNmUwMzBmMjM1NmMzOTQ1MTU1Njg3YmFkMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-27T16:09:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-27T16:09:03Z"}, "message": "arm.h (ARM_PRINT_OPERAND_ADDRESS): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/arm/arm.h (ARM_PRINT_OPERAND_ADDRESS): Use gcc_assert and\n\tgcc_unreachable as appropriate.\n\t(THUMB_PRINT_OPERAND_ADDRESS): Likewise.\n\t* config/arm/arm.c (arm_override_options, arm_compute_func_type,\n\tuse_return_insn, const_ok_for_op, arm_gen_constant,\n\tarm_canonicalize_comparison, legitimize_pic_address,\n\tthumb_find_work_register, arm_load_pic_register, arm_rtx_costs_1,\n\tarm_cirrus_insn_p, cirrus_reorg, minmax_code,\n\tload_multiple_sequence, emit_ldm_seq, store_multiple_sequence,\n\temit_stm_seq, arm_gen_movmemqi, arm_select_dominance_cc_mode,\n\tarm_select_cc_mode, arm_reload_in_hi, arm_reload_out_hi,\n\tmove_minipool_fix_forward_ref, move_minipool_fix_backward_ref,\n\tdump_minipool, create_fix_barrier, push_minipool_fix, arm_reorg,\n\tfp_immediate_constant, fp_const_from_val, vfp_output_fstmx,\n\toutput_call, output_mov_long_double_fpa_from_arm,\n\toutput_mov_long_double_arm_from_fpa,\n\toutput_mov_double_fpa_from_arm, output_mov_double_arm_from_fpa,\n\toutput_move_double, arithmetic_instr, shift_op, int_log2,\n\toutput_return_instruction, arm_output_function_prologue,\n\tarm_output_epilogue, arm_output_function_epilogue,\n\temit_multi_reg_push, arm_get_frame_offsets,\n\tarm_compute_initial_elimination_offset, arm_expand_prologue,\n\tarm_print_operand, arm_assemble_integer, get_arm_condition_code,\n\tarm_final_prescan_insn, arm_init_iwmmxt_builtins,\n\tarm_expand_binop_builtin, thumb_pushpop, thumb_far_jump_used_p,\n\tthumb_compute_initial_elimination_offset,\n\tthumb_output_function_prologue, thumb_load_double_from_address,\n\tthumb_output_move_mem_multiple, thumb_reload_out_hi,\n\tarm_emit_vector_const, arm_dbx_register_number): Likewise.\n\t* config/arm/pe.c (arm_mark_dllexport, arm_mark_dllimport): Likewise.\n\t* config/arm/arm.md (thumb_extendhisi2,\n\t*thumb_extendhisi2_insn_v6, *thumb_extendqisi2,\n\t*thumb_extendqisi2_v6, movhi, *thumb_movhi_insn,\n\tthumb_movhi_clobber, movqi, *arm_buneq, *arm_bltgt,\n\t*arm_buneq_reversed, *arm_bltgt_reversed, suneq, sltgt): Likewise.\n\t* config/arm/cirrus.md (*cirrus_arm_movdi,\n\t*cirrus_movdf_hard_insn): Likewise.\n\t* config/arm/vfp.md (*arm_movdi_vfp, *movdf_vfp): Likewise.\n\nFrom-SVN: r98850", "tree": {"sha": "db2a34cecbc3084770c726406998caa7c7176a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2a34cecbc3084770c726406998caa7c7176a2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6d29d157fe489f6e030f2356c3945155687bad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d29d157fe489f6e030f2356c3945155687bad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d29d157fe489f6e030f2356c3945155687bad1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d29d157fe489f6e030f2356c3945155687bad1/comments", "author": null, "committer": null, "parents": [{"sha": "4845b383bb6ce1141a4aac8f7eaec14e4acf8956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4845b383bb6ce1141a4aac8f7eaec14e4acf8956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4845b383bb6ce1141a4aac8f7eaec14e4acf8956"}], "stats": {"total": 909, "additions": 441, "deletions": 468}, "files": [{"sha": "fdc72d288af9d404ec6b5ebba59373e0d22a4bf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6d29d157fe489f6e030f2356c3945155687bad1", "patch": "@@ -1,3 +1,44 @@\n+2005-04-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/arm/arm.h (ARM_PRINT_OPERAND_ADDRESS): Use gcc_assert and\n+\tgcc_unreachable as appropriate.\n+\t(THUMB_PRINT_OPERAND_ADDRESS): Likewise.\n+\t* config/arm/arm.c (arm_override_options, arm_compute_func_type,\n+\tuse_return_insn, const_ok_for_op, arm_gen_constant,\n+\tarm_canonicalize_comparison, legitimize_pic_address,\n+\tthumb_find_work_register, arm_load_pic_register, arm_rtx_costs_1,\n+\tarm_cirrus_insn_p, cirrus_reorg, minmax_code,\n+\tload_multiple_sequence, emit_ldm_seq, store_multiple_sequence,\n+\temit_stm_seq, arm_gen_movmemqi, arm_select_dominance_cc_mode,\n+\tarm_select_cc_mode, arm_reload_in_hi, arm_reload_out_hi,\n+\tmove_minipool_fix_forward_ref, move_minipool_fix_backward_ref,\n+\tdump_minipool, create_fix_barrier, push_minipool_fix, arm_reorg,\n+\tfp_immediate_constant, fp_const_from_val, vfp_output_fstmx,\n+\toutput_call, output_mov_long_double_fpa_from_arm,\n+\toutput_mov_long_double_arm_from_fpa,\n+\toutput_mov_double_fpa_from_arm, output_mov_double_arm_from_fpa,\n+\toutput_move_double, arithmetic_instr, shift_op, int_log2,\n+\toutput_return_instruction, arm_output_function_prologue,\n+\tarm_output_epilogue, arm_output_function_epilogue,\n+\temit_multi_reg_push, arm_get_frame_offsets,\n+\tarm_compute_initial_elimination_offset, arm_expand_prologue,\n+\tarm_print_operand, arm_assemble_integer, get_arm_condition_code,\n+\tarm_final_prescan_insn, arm_init_iwmmxt_builtins,\n+\tarm_expand_binop_builtin, thumb_pushpop, thumb_far_jump_used_p,\n+\tthumb_compute_initial_elimination_offset,\n+\tthumb_output_function_prologue, thumb_load_double_from_address,\n+\tthumb_output_move_mem_multiple, thumb_reload_out_hi,\n+\tarm_emit_vector_const, arm_dbx_register_number): Likewise.\n+\t* config/arm/pe.c (arm_mark_dllexport, arm_mark_dllimport): Likewise.\n+\t* config/arm/arm.md (thumb_extendhisi2,\n+\t*thumb_extendhisi2_insn_v6, *thumb_extendqisi2,\n+\t*thumb_extendqisi2_v6, movhi, *thumb_movhi_insn,\n+\tthumb_movhi_clobber, movqi, *arm_buneq, *arm_bltgt,\n+\t*arm_buneq_reversed, *arm_bltgt_reversed, suneq, sltgt): Likewise.\n+\t* config/arm/cirrus.md (*cirrus_arm_movdi,\n+\t*cirrus_movdf_hard_insn): Likewise.\n+\t* config/arm/vfp.md (*arm_movdi_vfp, *movdf_vfp): Likewise.\n+\n 2005-04-27  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-flow.h (ssa_names): Change the type to VEC(tree,gc)."}, {"sha": "7345510433ac745fc535c5bf460bf43f0ee8b023", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 365, "deletions": 408, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e6d29d157fe489f6e030f2356c3945155687bad1", "patch": "@@ -909,10 +909,8 @@ arm_override_options (void)\n \t\t      }\n \t\t  }\n \n-\t      if (best_fit == NULL)\n-\t\tabort ();\n-\t      else\n-\t\tsel = best_fit;\n+\t      gcc_assert (best_fit);\n+\t      sel = best_fit;\n \t    }\n \n \t  insn_flags = sel->flags;\n@@ -924,8 +922,7 @@ arm_override_options (void)\n \n   /* The processor for which we should tune should now have been\n      chosen.  */\n-  if (arm_tune == arm_none)\n-    abort ();\n+  gcc_assert (arm_tune != arm_none);\n \n   tune_flags = all_cores[(int)arm_tune].flags;\n   if (optimize_size)\n@@ -1096,8 +1093,7 @@ arm_override_options (void)\n       else\n \tarm_fpu_tune = arm_fpu_arch;\n       arm_fp_model = fp_model_for_fpu[arm_fpu_arch];\n-      if (arm_fp_model == ARM_FP_MODEL_UNKNOWN)\n-\tabort ();\n+      gcc_assert (arm_fp_model != ARM_FP_MODEL_UNKNOWN);\n     }\n \n   if (target_float_abi_name != NULL)\n@@ -1288,8 +1284,7 @@ arm_compute_func_type (void)\n   tree a;\n   tree attr;\n \n-  if (TREE_CODE (current_function_decl) != FUNCTION_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (current_function_decl) == FUNCTION_DECL);\n \n   /* Decide if the current function is volatile.  Such functions\n      never return, and many memory cycles can be saved by not storing\n@@ -1402,8 +1397,7 @@ use_return_insn (int iscond, rtx sibling)\n \t argument ...  */\n       if (sibling)\n \t{\n-\t  if (GET_CODE (sibling) != CALL_INSN)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (sibling) == CALL_INSN);\n \n \t  if (find_regno_fusage (sibling, USE, 3))\n \t    return 0;\n@@ -1512,7 +1506,7 @@ const_ok_for_op (HOST_WIDE_INT i, enum rtx_code code)\n       return const_ok_for_arm (ARM_SIGN_EXTEND (~i));\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1712,17 +1706,15 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t\t\t\tgen_rtx_SET (VOIDmode, target, source));\n \t  return 1;\n \t}\n-      if (remainder == 0xffffffff)\n-\t{\n-\t  if (generate)\n-\t    emit_constant_insn (cond,\n-\t\t\t\tgen_rtx_SET (VOIDmode, target,\n-\t\t\t\t\t     gen_rtx_NOT (mode, source)));\n-\t  return 1;\n-\t}\n-\n-      /* We don't know how to handle this yet below.  */\n-      abort ();\n+      \n+      /* We don't know how to handle other cases yet.  */\n+      gcc_assert (remainder == 0xffffffff);\n+      \n+      if (generate)\n+\temit_constant_insn (cond,\n+\t\t\t    gen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t gen_rtx_NOT (mode, source)));\n+      return 1;\n \n     case MINUS:\n       /* We treat MINUS as (val - source), since (source - val) is always\n@@ -1749,7 +1741,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If we can do it in one insn get out quickly.  */\n@@ -2294,7 +2286,7 @@ arm_canonicalize_comparison (enum rtx_code code, rtx * op1)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return code;\n@@ -3034,10 +3026,8 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \n       if (reg == 0)\n \t{\n-\t  if (no_new_pseudos)\n-\t    abort ();\n-\t  else\n-\t    reg = gen_reg_rtx (Pmode);\n+\t  gcc_assert (!no_new_pseudos);\n+\t  reg = gen_reg_rtx (Pmode);\n \n \t  subregs = 1;\n \t}\n@@ -3088,31 +3078,24 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \n       if (reg == 0)\n \t{\n-\t  if (no_new_pseudos)\n-\t    abort ();\n-\t  else\n-\t    reg = gen_reg_rtx (Pmode);\n+\t  gcc_assert (!no_new_pseudos);\n+\t  reg = gen_reg_rtx (Pmode);\n \t}\n \n-      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n-\t{\n-\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n-\t  offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t\t   base == reg ? 0 : reg);\n-\t}\n-      else\n-\tabort ();\n+      gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n+      \n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t       base == reg ? 0 : reg);\n \n       if (GET_CODE (offset) == CONST_INT)\n \t{\n \t  /* The base register doesn't really matter, we only want to\n \t     test the index for the appropriate mode.  */\n \t  if (!arm_legitimate_index_p (mode, offset, SET, 0))\n \t    {\n-\t      if (!no_new_pseudos)\n-\t\toffset = force_reg (Pmode, offset);\n-\t      else\n-\t\tabort ();\n+\t      gcc_assert (no_new_pseudos);\n+\t      offset = force_reg (Pmode, offset);\n \t    }\n \n \t  if (GET_CODE (offset) == CONST_INT)\n@@ -3185,7 +3168,7 @@ thumb_find_work_register (unsigned long pushed_regs_mask)\n \n   /* Something went wrong - thumb_compute_save_reg_mask()\n      should have arranged for a suitable register to be pushed.  */\n-  abort ();\n+  gcc_unreachable ();\n }\n \n \n@@ -3202,8 +3185,7 @@ arm_load_pic_register (unsigned int scratch)\n   if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n     return;\n \n-  if (!flag_pic)\n-    abort ();\n+  gcc_assert (flag_pic);\n \n   l1 = gen_label_rtx ();\n \n@@ -4017,7 +3999,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \n     case MULT:\n       /* This should have been handled by the CPU specific routines.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case TRUNCATE:\n       if (arm_arch3m && mode == SImode\n@@ -4078,9 +4060,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \t    return 1;\n \n \tdefault:\n-\t  break;\n+\t  gcc_unreachable ();\n \t}\n-      abort ();\n+      gcc_unreachable ();\n \n     case CONST_INT:\n       if (const_ok_for_arm (INTVAL (x)))\n@@ -4978,7 +4960,7 @@ arm_cirrus_insn_p (rtx insn)\n {\n   enum attr_cirrus attr;\n \n-  /* get_attr aborts on USE and CLOBBER.  */\n+  /* get_attr cannot accept USE or CLOBBER.  */\n   if (!insn\n       || GET_CODE (insn) != INSN\n       || GET_CODE (PATTERN (insn)) == USE\n@@ -5050,10 +5032,11 @@ cirrus_reorg (rtx first)\n \t  /* Get Arm register number for ldr insn.  */\n \t  if (GET_CODE (lhs) == REG)\n \t    arm_regno = REGNO (lhs);\n-\t  else if (GET_CODE (rhs) == REG)\n-\t    arm_regno = REGNO (rhs);\n \t  else\n-\t    abort ();\n+\t    {\n+\t      gcc_assert (GET_CODE (rhs) == REG);\n+\t      arm_regno = REGNO (rhs);\n+\t    }\n \n \t  /* Next insn.  */\n \t  first = next_nonnote_insn (first);\n@@ -5079,7 +5062,7 @@ cirrus_reorg (rtx first)\n \t}\n     }\n \n-  /* get_attr aborts on USE and CLOBBER.  */\n+  /* get_attr cannot accept USE or CLOBBER.  */\n   if (!first\n       || GET_CODE (first) != INSN\n       || GET_CODE (PATTERN (first)) == USE\n@@ -5171,16 +5154,19 @@ minmax_code (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n \n-  if (code == SMAX)\n-    return GE;\n-  else if (code == SMIN)\n-    return LE;\n-  else if (code == UMIN)\n-    return LEU;\n-  else if (code == UMAX)\n-    return GEU;\n-\n-  abort ();\n+  switch (code)\n+    {\n+    case SMAX:\n+      return GE;\n+    case SMIN:\n+      return LE;\n+    case UMIN:\n+      return LEU;\n+    case UMAX:\n+      return GEU;\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* Return 1 if memory locations are adjacent.  */\n@@ -5260,8 +5246,7 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \n   /* Can only handle 2, 3, or 4 insns at present,\n      though could be easily extended if required.  */\n-  if (nops < 2 || nops > 4)\n-    abort ();\n+  gcc_assert (nops >= 2 && nops <= 4);\n \n   /* Loop over the operands and check that the memory references are\n      suitable (i.e. immediate offsets from the same base register).  At\n@@ -5276,8 +5261,7 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n       if (GET_CODE (operands[nops + i]) == SUBREG)\n \toperands[nops + i] = alter_subreg (operands + (nops + i));\n \n-      if (GET_CODE (operands[nops + i]) != MEM)\n-\tabort ();\n+      gcc_assert (GET_CODE (operands[nops + i]) == MEM);\n \n       /* Don't reorder volatile memory references; it doesn't seem worth\n \t looking for the case where the order is ok anyway.  */\n@@ -5461,7 +5445,7 @@ emit_ldm_seq (rtx *operands, int nops)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   sprintf (buf + strlen (buf), \"%s%s, {%s%s\", REGISTER_PREFIX,\n@@ -5489,8 +5473,7 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \n   /* Can only handle 2, 3, or 4 insns at present, though could be easily\n      extended if required.  */\n-  if (nops < 2 || nops > 4)\n-    abort ();\n+  gcc_assert (nops >= 2 && nops <= 4);\n \n   /* Loop over the operands and check that the memory references are\n      suitable (i.e. immediate offsets from the same base register).  At\n@@ -5505,8 +5488,7 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n       if (GET_CODE (operands[nops + i]) == SUBREG)\n \toperands[nops + i] = alter_subreg (operands + (nops + i));\n \n-      if (GET_CODE (operands[nops + i]) != MEM)\n-\tabort ();\n+      gcc_assert (GET_CODE (operands[nops + i]) == MEM);\n \n       /* Don't reorder volatile memory references; it doesn't seem worth\n \t looking for the case where the order is ok anyway.  */\n@@ -5638,7 +5620,7 @@ emit_stm_seq (rtx *operands, int nops)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   sprintf (buf + strlen (buf), \"%s%s, {%s%s\", REGISTER_PREFIX,\n@@ -5889,21 +5871,18 @@ arm_gen_movmemqi (rtx *operands)\n       emit_move_insn (mem, sreg);\n       in_words_to_go--;\n \n-      if (in_words_to_go)\t/* Sanity check */\n-\tabort ();\n+      gcc_assert (!in_words_to_go);\t/* Sanity check */\n     }\n \n   if (in_words_to_go)\n     {\n-      if (in_words_to_go < 0)\n-\tabort ();\n+      gcc_assert (in_words_to_go > 0);\n \n       mem = adjust_automodify_address (srcbase, SImode, src, srcoffset);\n       part_bytes_reg = copy_to_mode_reg (SImode, mem);\n     }\n \n-  if (last_bytes && part_bytes_reg == NULL)\n-    abort ();\n+  gcc_assert (!last_bytes || part_bytes_reg);\n \n   if (BYTES_BIG_ENDIAN && last_bytes)\n     {\n@@ -6032,78 +6011,108 @@ arm_select_dominance_cc_mode (rtx x, rtx y, HOST_WIDE_INT cond_or)\n   switch (cond1)\n     {\n     case EQ:\n-      if (cond2 == EQ || cond_or == DOM_CC_X_AND_Y)\n+      if (cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DEQmode;\n \n       switch (cond2)\n \t{\n+\tcase EQ: return CC_DEQmode;\n \tcase LE: return CC_DLEmode;\n \tcase LEU: return CC_DLEUmode;\n \tcase GE: return CC_DGEmode;\n \tcase GEU: return CC_DGEUmode;\n-\tdefault: break;\n+\tdefault: gcc_unreachable ();\n \t}\n \n-      break;\n-\n     case LT:\n-      if (cond2 == LT || cond_or == DOM_CC_X_AND_Y)\n+      if (cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DLTmode;\n-      if (cond2 == LE)\n-\treturn CC_DLEmode;\n-      if (cond2 == NE)\n-\treturn CC_DNEmode;\n-      break;\n+      \n+      switch (cond2)\n+\t{\n+\tcase  LT:\n+\t    return CC_DLTmode;\n+\tcase LE:\n+\t  return CC_DLEmode;\n+\tcase NE:\n+\t  return CC_DNEmode;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n     case GT:\n-      if (cond2 == GT || cond_or == DOM_CC_X_AND_Y)\n+      if (cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DGTmode;\n-      if (cond2 == GE)\n-\treturn CC_DGEmode;\n-      if (cond2 == NE)\n-\treturn CC_DNEmode;\n-      break;\n+\n+      switch (cond2)\n+\t{\n+\tcase GT:\n+\t  return CC_DGTmode;\n+\tcase GE:\n+\t  return CC_DGEmode;\n+\tcase NE:\n+\t  return CC_DNEmode;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n     case LTU:\n-      if (cond2 == LTU || cond_or == DOM_CC_X_AND_Y)\n+      if (cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DLTUmode;\n-      if (cond2 == LEU)\n-\treturn CC_DLEUmode;\n-      if (cond2 == NE)\n-\treturn CC_DNEmode;\n-      break;\n+\n+      switch (cond2)\n+\t{\n+\tcase LTU:\n+\t  return CC_DLTUmode;\n+\tcase LEU:\n+\t  return CC_DLEUmode;\n+\tcase NE:\n+\t  return CC_DNEmode;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n     case GTU:\n-      if (cond2 == GTU || cond_or == DOM_CC_X_AND_Y)\n+      if (cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DGTUmode;\n-      if (cond2 == GEU)\n-\treturn CC_DGEUmode;\n-      if (cond2 == NE)\n-\treturn CC_DNEmode;\n-      break;\n+      \n+      switch (cond2)\n+\t{\n+\tcase GTU:\n+\t  return CC_DGTUmode;\n+\tcase GEU:\n+\t  return CC_DGEUmode;\n+\tcase NE:\n+\t  return CC_DNEmode;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n     /* The remaining cases only occur when both comparisons are the\n        same.  */\n     case NE:\n+      gcc_assert (cond1 == cond2);\n       return CC_DNEmode;\n \n     case LE:\n+      gcc_assert (cond1 == cond2);\n       return CC_DLEmode;\n \n     case GE:\n+      gcc_assert (cond1 == cond2);\n       return CC_DGEmode;\n \n     case LEU:\n+      gcc_assert (cond1 == cond2);\n       return CC_DLEUmode;\n \n     case GEU:\n+      gcc_assert (cond1 == cond2);\n       return CC_DGEUmode;\n \n     default:\n-      break;\n+      gcc_unreachable ();\n     }\n-\n-  abort ();\n }\n \n enum machine_mode\n@@ -6136,7 +6145,7 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \t  return CCFPEmode;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -6323,8 +6332,7 @@ arm_reload_in_hi (rtx *operands)\n \t     ^ (HOST_WIDE_INT) 0x80000000)\n \t    - (HOST_WIDE_INT) 0x80000000);\n \n-      if (hi + lo != offset)\n-\tabort ();\n+      gcc_assert (hi + lo == offset);\n \n       if (hi != 0)\n \t{\n@@ -6470,8 +6478,7 @@ arm_reload_out_hi (rtx *operands)\n \t     ^ (HOST_WIDE_INT) 0x80000000)\n \t    - (HOST_WIDE_INT) 0x80000000);\n \n-      if (hi + lo != offset)\n-\tabort ();\n+      gcc_assert (hi + lo == offset);\n \n       if (hi != 0)\n \t{\n@@ -6821,10 +6828,8 @@ static Mnode *\n move_minipool_fix_forward_ref (Mnode *mp, Mnode *max_mp,\n \t\t\t       HOST_WIDE_INT max_address)\n {\n-  /* This should never be true and the code below assumes these are\n-     different.  */\n-  if (mp == max_mp)\n-    abort ();\n+  /* The code below assumes these are different.  */\n+  gcc_assert (mp != max_mp);\n \n   if (max_mp == NULL)\n     {\n@@ -6996,10 +7001,8 @@ move_minipool_fix_backward_ref (Mnode *mp, Mnode *min_mp,\n {\n   HOST_WIDE_INT offset;\n \n-  /* This should never be true, and the code below assumes these are\n-     different.  */\n-  if (mp == min_mp)\n-    abort ();\n+  /* The code below assumes these are different.  */\n+  gcc_assert (mp != min_mp);\n \n   if (min_mp == NULL)\n     {\n@@ -7279,8 +7282,7 @@ dump_minipool (rtx scan)\n \n #endif\n \t    default:\n-\t      abort ();\n-\t      break;\n+\t      gcc_unreachable ();\n \t    }\n \t}\n \n@@ -7352,8 +7354,7 @@ create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n \n       /* This code shouldn't have been called if there was a natural barrier\n \t within range.  */\n-      if (GET_CODE (from) == BARRIER)\n-\tabort ();\n+      gcc_assert (GET_CODE (from) != BARRIER);\n \n       /* Count the length of this insn.  */\n       count += get_attr_length (from);\n@@ -7458,10 +7459,9 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   fix->minipool = NULL;\n \n   /* If an insn doesn't have a range defined for it, then it isn't\n-     expecting to be reworked by this code.  Better to abort now than\n+     expecting to be reworked by this code.  Better to stop now than\n      to generate duff assembly code.  */\n-  if (fix->forwards == 0 && fix->backwards == 0)\n-    abort ();\n+  gcc_assert (fix->forwards || fix->backwards);\n \n   /* With AAPCS/iWMMXt enabled, the pool is aligned to an 8-byte boundary.\n      So there might be an empty word before the start of the pool.\n@@ -7644,8 +7644,7 @@ arm_reorg (void)\n   /* The first insn must always be a note, or the code below won't\n      scan it properly.  */\n   insn = get_insns ();\n-  if (GET_CODE (insn) != NOTE)\n-    abort ();\n+  gcc_assert (GET_CODE (insn) == NOTE);\n \n   /* Scan all the insns and record the operands that will need fixing.  */\n   for (insn = next_nonnote_insn (insn); insn; insn = next_nonnote_insn (insn))\n@@ -7739,8 +7738,7 @@ arm_reorg (void)\n \t  /* The last item on the list of fixes must be a barrier, so\n \t     we can never run off the end of the list of fixes without\n \t     last_barrier being set.  */\n-\t  if (ftmp == NULL)\n-\t    abort ();\n+\t  gcc_assert (ftmp);\n \n \t  max_address = minipool_vector_head->max_address;\n \t  /* Check that there isn't another fix that is in range that\n@@ -7810,7 +7808,7 @@ fp_immediate_constant (rtx x)\n     if (REAL_VALUES_EQUAL (r, values_fp[i]))\n       return strings_fp[i];\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* As for fp_immediate_constant, but value is passed directly, not in rtx.  */\n@@ -7826,7 +7824,7 @@ fp_const_from_val (REAL_VALUE_TYPE *r)\n     if (REAL_VALUES_EQUAL (*r, values_fp[i]))\n       return strings_fp[i];\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Output the operands of a LDM/STM instruction to STREAM.\n@@ -7904,8 +7902,7 @@ vfp_output_fstmx (rtx * operands)\n   strcpy (pattern, \"fstmfdx\\t%m0!, {%P1\");\n   p = strlen (pattern);\n \n-  if (GET_CODE (operands[1]) != REG)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == REG);\n \n   base = (REGNO (operands[1]) - FIRST_VFP_REGNUM) / 2;\n   for (i = 1; i < XVECLEN (operands[2], 0); i++)\n@@ -7999,8 +7996,7 @@ vfp_emit_fstmx (int base_reg, int count)\n const char *\n output_call (rtx *operands)\n {\n-  if (arm_arch5)\n-    abort ();\t\t/* Patterns should call blx <reg> directly.  */\n+  gcc_assert (!arm_arch5); /* Patterns should call blx <reg> directly.  */\n \n   /* Handle calls to lr using ip (which may be clobbered in subr anyway).  */\n   if (REGNO (operands[0]) == LR_REGNUM)\n@@ -8065,8 +8061,7 @@ output_mov_long_double_fpa_from_arm (rtx *operands)\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[3];\n \n-  if (arm_reg0 == IP_REGNUM)\n-    abort ();\n+  gcc_assert (arm_reg0 != IP_REGNUM);\n \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n@@ -8087,8 +8082,7 @@ output_mov_long_double_arm_from_fpa (rtx *operands)\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[3];\n \n-  if (arm_reg0 == IP_REGNUM)\n-    abort ();\n+  gcc_assert (arm_reg0 != IP_REGNUM);\n \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n@@ -8143,8 +8137,7 @@ output_mov_double_fpa_from_arm (rtx *operands)\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[2];\n \n-  if (arm_reg0 == IP_REGNUM)\n-    abort ();\n+  gcc_assert (arm_reg0 != IP_REGNUM);\n \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n@@ -8162,8 +8155,7 @@ output_mov_double_arm_from_fpa (rtx *operands)\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[2];\n \n-  if (arm_reg0 == IP_REGNUM)\n-    abort ();\n+  gcc_assert (arm_reg0 != IP_REGNUM);\n \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n@@ -8188,160 +8180,152 @@ output_move_double (rtx *operands)\n \n       otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n \n-      if (code1 == MEM)\n+      gcc_assert (code1 == MEM);  /* Constraints should ensure this.  */\n+\n+      switch (GET_CODE (XEXP (operands[1], 0)))\n \t{\n-\t  switch (GET_CODE (XEXP (operands[1], 0)))\n+\tcase REG:\n+\t  output_asm_insn (\"ldm%?ia\\t%m1, %M0\", operands);\n+\t  break;\n+\t  \n+\tcase PRE_INC:\n+\t  gcc_assert (TARGET_LDRD);\n+\t  output_asm_insn (\"ldr%?d\\t%0, [%m1, #8]!\", operands);\n+\t  break;\n+\t  \n+\tcase PRE_DEC:\n+\t  output_asm_insn (\"ldm%?db\\t%m1!, %M0\", operands);\n+\t  break;\n+\t  \n+\tcase POST_INC:\n+\t  output_asm_insn (\"ldm%?ia\\t%m1!, %M0\", operands);\n+\t  break;\n+\t  \n+\tcase POST_DEC:\n+\t  gcc_assert (TARGET_LDRD);\n+\t  output_asm_insn (\"ldr%?d\\t%0, [%m1], #-8\", operands);\n+\t  break;\n+\t  \n+\tcase PRE_MODIFY:\n+\tcase POST_MODIFY:\n+\t  otherops[0] = operands[0];\n+\t  otherops[1] = XEXP (XEXP (XEXP (operands[1], 0), 1), 0);\n+\t  otherops[2] = XEXP (XEXP (XEXP (operands[1], 0), 1), 1);\n+\t  \n+\t  if (GET_CODE (XEXP (operands[1], 0)) == PRE_MODIFY)\n \t    {\n-\t    case REG:\n-\t      output_asm_insn (\"ldm%?ia\\t%m1, %M0\", operands);\n-\t      break;\n-\n-  \t    case PRE_INC:\n-\t      if (!TARGET_LDRD)\n-\t\tabort (); /* Should never happen now.  */\n-\t      output_asm_insn (\"ldr%?d\\t%0, [%m1, #8]!\", operands);\n-\t      break;\n-\n-\t    case PRE_DEC:\n-\t      output_asm_insn (\"ldm%?db\\t%m1!, %M0\", operands);\n-\t      break;\n-\n-\t    case POST_INC:\n-\t      output_asm_insn (\"ldm%?ia\\t%m1!, %M0\", operands);\n-\t      break;\n-\n-\t    case POST_DEC:\n-\t      if (!TARGET_LDRD)\n-\t\tabort (); /* Should never happen now.  */\n-\t      output_asm_insn (\"ldr%?d\\t%0, [%m1], #-8\", operands);\n-\t      break;\n-\n-\t    case PRE_MODIFY:\n-\t    case POST_MODIFY:\n-\t      otherops[0] = operands[0];\n-\t      otherops[1] = XEXP (XEXP (XEXP (operands[1], 0), 1), 0);\n-\t      otherops[2] = XEXP (XEXP (XEXP (operands[1], 0), 1), 1);\n-\n-\t      if (GET_CODE (XEXP (operands[1], 0)) == PRE_MODIFY)\n+\t      if (reg_overlap_mentioned_p (otherops[0], otherops[2]))\n \t\t{\n-\t\t  if (reg_overlap_mentioned_p (otherops[0], otherops[2]))\n-\t\t    {\n-\t\t      /* Registers overlap so split out the increment.  */\n-\t\t      output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n-\t\t      output_asm_insn (\"ldr%?d\\t%0, [%1] @split\", otherops);\n-\t\t    }\n-\t\t  else\n-\t\t    output_asm_insn (\"ldr%?d\\t%0, [%1, %2]!\", otherops);\n+\t\t  /* Registers overlap so split out the increment.  */\n+\t\t  output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n+\t\t  output_asm_insn (\"ldr%?d\\t%0, [%1] @split\", otherops);\n \t\t}\n \t      else\n+\t\toutput_asm_insn (\"ldr%?d\\t%0, [%1, %2]!\", otherops);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We only allow constant increments, so this is safe.  */\n+\t      output_asm_insn (\"ldr%?d\\t%0, [%1], %2\", otherops);\n+\t    }\n+\t  break;\n+\t  \n+\tcase LABEL_REF:\n+\tcase CONST:\n+\t  output_asm_insn (\"adr%?\\t%0, %1\", operands);\n+\t  output_asm_insn (\"ldm%?ia\\t%0, %M0\", operands);\n+\t  break;\n+\t  \n+\tdefault:\n+\t  if (arm_add_operand (XEXP (XEXP (operands[1], 0), 1),\n+\t\t\t       GET_MODE (XEXP (XEXP (operands[1], 0), 1))))\n+\t    {\n+\t      otherops[0] = operands[0];\n+\t      otherops[1] = XEXP (XEXP (operands[1], 0), 0);\n+\t      otherops[2] = XEXP (XEXP (operands[1], 0), 1);\n+\t      \n+\t      if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n \t\t{\n-\t\t  /* We only allow constant increments, so this is safe.  */\n-\t\t  output_asm_insn (\"ldr%?d\\t%0, [%1], %2\", otherops);\n-\t\t}\n-\t      break;\n-\n-\t    case LABEL_REF:\n-\t    case CONST:\n-\t      output_asm_insn (\"adr%?\\t%0, %1\", operands);\n-\t      output_asm_insn (\"ldm%?ia\\t%0, %M0\", operands);\n-\t      break;\n-\n-\t    default:\n-\t      if (arm_add_operand (XEXP (XEXP (operands[1], 0), 1),\n-\t\t\t\t   GET_MODE (XEXP (XEXP (operands[1], 0), 1))))\n-\t\t{\n-\t\t  otherops[0] = operands[0];\n-\t\t  otherops[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t\t  otherops[2] = XEXP (XEXP (operands[1], 0), 1);\n-\n-\t\t  if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n+\t\t  if (GET_CODE (otherops[2]) == CONST_INT)\n \t\t    {\n-\t\t      if (GET_CODE (otherops[2]) == CONST_INT)\n+\t\t      switch ((int) INTVAL (otherops[2]))\n \t\t\t{\n-\t\t\t  switch ((int) INTVAL (otherops[2]))\n-\t\t\t    {\n-\t\t\t    case -8:\n-\t\t\t      output_asm_insn (\"ldm%?db\\t%1, %M0\", otherops);\n-\t\t\t      return \"\";\n-\t\t\t    case -4:\n-\t\t\t      output_asm_insn (\"ldm%?da\\t%1, %M0\", otherops);\n-\t\t\t      return \"\";\n-\t\t\t    case 4:\n-\t\t\t      output_asm_insn (\"ldm%?ib\\t%1, %M0\", otherops);\n-\t\t\t      return \"\";\n-\t\t\t    }\n+\t\t\tcase -8:\n+\t\t\t  output_asm_insn (\"ldm%?db\\t%1, %M0\", otherops);\n+\t\t\t  return \"\";\n+\t\t\tcase -4:\n+\t\t\t  output_asm_insn (\"ldm%?da\\t%1, %M0\", otherops);\n+\t\t\t  return \"\";\n+\t\t\tcase 4:\n+\t\t\t  output_asm_insn (\"ldm%?ib\\t%1, %M0\", otherops);\n+\t\t\t  return \"\";\n \t\t\t}\n-\t\t      if (TARGET_LDRD\n-\t\t\t  && (GET_CODE (otherops[2]) == REG\n-\t\t\t      || (GET_CODE (otherops[2]) == CONST_INT\n-\t\t\t\t  && INTVAL (otherops[2]) > -256\n-\t\t\t\t  && INTVAL (otherops[2]) < 256)))\n+\t\t    }\n+\t\t  if (TARGET_LDRD\n+\t\t      && (GET_CODE (otherops[2]) == REG\n+\t\t\t  || (GET_CODE (otherops[2]) == CONST_INT\n+\t\t\t      && INTVAL (otherops[2]) > -256\n+\t\t\t      && INTVAL (otherops[2]) < 256)))\n+\t\t    {\n+\t\t      if (reg_overlap_mentioned_p (otherops[0],\n+\t\t\t\t\t\t   otherops[2]))\n \t\t\t{\n-\t\t\t  if (reg_overlap_mentioned_p (otherops[0],\n-\t\t\t\t\t\t       otherops[2]))\n-\t\t\t    {\n-\t\t\t      /* Swap base and index registers over to\n-\t\t\t\t avoid a conflict.  */\n-\t\t\t      otherops[1] = XEXP (XEXP (operands[1], 0), 1);\n-\t\t\t      otherops[2] = XEXP (XEXP (operands[1], 0), 0);\n-\n-\t\t\t    }\n-\t\t\t  /* If both registers conflict, it will usually\n-\t\t\t     have been fixed by a splitter.  */\n-\t\t\t  if (reg_overlap_mentioned_p (otherops[0],\n-\t\t\t\t\t\t\totherops[2]))\n-\t\t\t    {\n-\t\t\t      output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n-\t\t\t      output_asm_insn (\"ldr%?d\\t%0, [%1]\",\n-\t\t\t\t\t       otherops);\n-\t\t\t      return \"\";\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      output_asm_insn (\"ldr%?d\\t%0, [%1, %2]\",\n-\t\t\t\t\t       otherops);\n-\t\t\t      return \"\";\n-\t\t\t    }\n+\t\t\t  /* Swap base and index registers over to\n+\t\t\t     avoid a conflict.  */\n+\t\t\t  otherops[1] = XEXP (XEXP (operands[1], 0), 1);\n+\t\t\t  otherops[2] = XEXP (XEXP (operands[1], 0), 0);\n+\t\t\t  \n \t\t\t}\n-\t\t      if (GET_CODE (otherops[2]) == CONST_INT)\n+\t\t      /* If both registers conflict, it will usually\n+\t\t\t have been fixed by a splitter.  */\n+\t\t      if (reg_overlap_mentioned_p (otherops[0], otherops[2]))\n \t\t\t{\n-\t\t\t  if (!(const_ok_for_arm (INTVAL (otherops[2]))))\n-\t\t\t    output_asm_insn (\"sub%?\\t%0, %1, #%n2\", otherops);\n-\t\t\t  else\n-\t\t\t    output_asm_insn (\"add%?\\t%0, %1, %2\", otherops);\n+\t\t\t  output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n+\t\t\t  output_asm_insn (\"ldr%?d\\t%0, [%1]\",\n+\t\t\t\t\t   otherops);\n \t\t\t}\n \t\t      else\n-\t\t\toutput_asm_insn (\"add%?\\t%0, %1, %2\", otherops);\n+\t\t\toutput_asm_insn (\"ldr%?d\\t%0, [%1, %2]\", otherops);\n+\t\t      return \"\";\n \t\t    }\n-\t\t  else\n-\t\t    output_asm_insn (\"sub%?\\t%0, %1, %2\", otherops);\n-\n-\t\t  return \"ldm%?ia\\t%0, %M0\";\n-                }\n-              else\n-                {\n-\t\t  otherops[1] = adjust_address (operands[1], SImode, 4);\n-\t\t  /* Take care of overlapping base/data reg.  */\n-\t\t  if (reg_mentioned_p (operands[0], operands[1]))\n+\t\t  \n+\t\t  if (GET_CODE (otherops[2]) == CONST_INT)\n \t\t    {\n-\t\t      output_asm_insn (\"ldr%?\\t%0, %1\", otherops);\n-\t\t      output_asm_insn (\"ldr%?\\t%0, %1\", operands);\n+\t\t      if (!(const_ok_for_arm (INTVAL (otherops[2]))))\n+\t\t\toutput_asm_insn (\"sub%?\\t%0, %1, #%n2\", otherops);\n+\t\t      else\n+\t\t\toutput_asm_insn (\"add%?\\t%0, %1, %2\", otherops);\n \t\t    }\n \t\t  else\n-\t\t    {\n-\t\t      output_asm_insn (\"ldr%?\\t%0, %1\", operands);\n-\t\t      output_asm_insn (\"ldr%?\\t%0, %1\", otherops);\n-\t\t    }\n+\t\t    output_asm_insn (\"add%?\\t%0, %1, %2\", otherops);\n+\t\t}\n+\t      else\n+\t\toutput_asm_insn (\"sub%?\\t%0, %1, %2\", otherops);\n+\n+\t      return \"ldm%?ia\\t%0, %M0\";\n+\t    }\n+\t  else\n+\t    {\n+\t      otherops[1] = adjust_address (operands[1], SImode, 4);\n+\t      /* Take care of overlapping base/data reg.  */\n+\t      if (reg_mentioned_p (operands[0], operands[1]))\n+\t\t{\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", otherops);\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", operands);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", operands);\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", otherops);\n \t\t}\n \t    }\n \t}\n-      else\n-\tabort ();  /* Constraints should prevent this.  */\n     }\n-  else if (code0 == MEM && code1 == REG)\n+  else\n     {\n-      if (REGNO (operands[1]) == IP_REGNUM)\n-\tabort ();\n+      /* Constraints should ensure this.  */\n+      gcc_assert (code0 == MEM && code1 == REG);\n+      gcc_assert (REGNO (operands[1]) != IP_REGNUM);\n \n       switch (GET_CODE (XEXP (operands[0], 0)))\n         {\n@@ -8350,8 +8334,7 @@ output_move_double (rtx *operands)\n \t  break;\n \n         case PRE_INC:\n-\t  if (!TARGET_LDRD)\n-\t    abort (); /* Should never happen now.  */\n+\t  gcc_assert (TARGET_LDRD);\n \t  output_asm_insn (\"str%?d\\t%1, [%m0, #8]!\", operands);\n \t  break;\n \n@@ -8364,8 +8347,7 @@ output_move_double (rtx *operands)\n \t  break;\n \n         case POST_DEC:\n-\t  if (!TARGET_LDRD)\n-\t    abort (); /* Should never happen now.  */\n+\t  gcc_assert (TARGET_LDRD);\n \t  output_asm_insn (\"str%?d\\t%1, [%m0], #-8\", operands);\n \t  break;\n \n@@ -8420,9 +8402,6 @@ output_move_double (rtx *operands)\n \t  output_asm_insn (\"str%?\\t%1, %0\", otherops);\n \t}\n     }\n-  else\n-    /* Constraints should prevent this.  */\n-    abort ();\n \n   return \"\";\n }\n@@ -8515,7 +8494,7 @@ arithmetic_instr (rtx op, int shift_first_arg)\n       return \"and\";\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -8530,12 +8509,20 @@ shift_op (rtx op, HOST_WIDE_INT *amountp)\n   const char * mnem;\n   enum rtx_code code = GET_CODE (op);\n \n-  if (GET_CODE (XEXP (op, 1)) == REG || GET_CODE (XEXP (op, 1)) == SUBREG)\n-    *amountp = -1;\n-  else if (GET_CODE (XEXP (op, 1)) == CONST_INT)\n-    *amountp = INTVAL (XEXP (op, 1));\n-  else\n-    abort ();\n+  switch (GET_CODE (XEXP (op, 1)))\n+    {\n+    case REG:\n+    case SUBREG:\n+      *amountp = -1;\n+      break;\n+\n+    case CONST_INT:\n+      *amountp = INTVAL (XEXP (op, 1));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   switch (code)\n     {\n@@ -8552,8 +8539,7 @@ shift_op (rtx op, HOST_WIDE_INT *amountp)\n       break;\n \n     case ROTATE:\n-      if (*amountp == -1)\n-\tabort ();\n+      gcc_assert (*amountp != -1);\n       *amountp = 32 - *amountp;\n \n       /* Fall through.  */\n@@ -8565,14 +8551,12 @@ shift_op (rtx op, HOST_WIDE_INT *amountp)\n     case MULT:\n       /* We never have to worry about the amount being other than a\n \t power of 2, since this case can never be reloaded from a reg.  */\n-      if (*amountp != -1)\n-\t*amountp = int_log2 (*amountp);\n-      else\n-\tabort ();\n+      gcc_assert (*amountp != -1);\n+      *amountp = int_log2 (*amountp);\n       return \"asl\";\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (*amountp != -1)\n@@ -8611,8 +8595,7 @@ int_log2 (HOST_WIDE_INT power)\n \n   while ((((HOST_WIDE_INT) 1 << shift) & power) == 0)\n     {\n-      if (shift > 31)\n-\tabort ();\n+      gcc_assert (shift <= 31);\n       shift++;\n     }\n \n@@ -8955,8 +8938,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n       return \"\";\n     }\n \n-  if (current_function_calls_alloca && !really_return)\n-    abort ();\n+  gcc_assert (!current_function_calls_alloca || really_return);\n \n   sprintf (conditional, \"%%?%%%c0\", reverse ? 'D' : 'd');\n \n@@ -8991,11 +8973,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t      live_regs_mask |=   (1 << SP_REGNUM);\n \t    }\n \t  else\n-\t    {\n-\t      if (! IS_INTERRUPT (func_type)\n-\t\t  && ! TARGET_REALLY_IWMMXT)\n-\t\tabort ();\n-\t    }\n+\t    gcc_assert (IS_INTERRUPT (func_type) || TARGET_REALLY_IWMMXT);\n \t}\n \n       /* On some ARM architectures it is faster to use LDR rather than\n@@ -9030,8 +9008,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \n \t      offsets = arm_get_frame_offsets ();\n \t      stack_adjust = offsets->outgoing_args - offsets->saved_regs;\n-\t      if (stack_adjust != 0 && stack_adjust != 4)\n-\t\tabort ();\n+\t      gcc_assert (stack_adjust == 0 || stack_adjust == 4);\n \n \t      if (stack_adjust && arm_arch5)\n \t\tsprintf (instr, \"ldm%sib\\t%%|sp, {\", conditional);\n@@ -9180,8 +9157,7 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n     }\n \n   /* Sanity check.  */\n-  if (arm_ccfsm_state || arm_target_insn)\n-    abort ();\n+  gcc_assert (!arm_ccfsm_state && !arm_target_insn);\n \n   func_type = arm_current_func_type ();\n \n@@ -9274,11 +9250,9 @@ arm_output_epilogue (rtx sibling)\n       return \"\";\n     }\n \n-  if (current_function_calls_eh_return\n-      && ! really_return)\n-    /* If we are throwing an exception, then we really must\n-       be doing a return,  so we can't tail-call.  */\n-    abort ();\n+  /* If we are throwing an exception, then we really must be doing a\n+     return, so we can't tail-call.  */\n+  gcc_assert (!current_function_calls_eh_return || really_return);\n \n   offsets = arm_get_frame_offsets ();\n   saved_regs_mask = arm_compute_save_reg_mask ();\n@@ -9399,8 +9373,7 @@ arm_output_epilogue (rtx sibling)\n \t frame generation actually contains the old stack pointer.  So a\n \t quick way to unwind the stack is just pop the IP register directly\n \t into the stack pointer.  */\n-      if ((saved_regs_mask & (1 << IP_REGNUM)) == 0)\n-\tabort ();\n+      gcc_assert (saved_regs_mask & (1 << IP_REGNUM));\n       saved_regs_mask &= ~ (1 << IP_REGNUM);\n       saved_regs_mask |=   (1 << SP_REGNUM);\n \n@@ -9620,11 +9593,10 @@ arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n       /* We need to take into account any stack-frame rounding.  */\n       offsets = arm_get_frame_offsets ();\n \n-      if (use_return_insn (FALSE, NULL)\n-\t  && return_used_this_function\n-\t  && offsets->saved_regs != offsets->outgoing_args\n-\t  && !frame_pointer_needed)\n-\tabort ();\n+      gcc_assert (!use_return_insn (FALSE, NULL)\n+\t\t  || !return_used_this_function\n+\t\t  || offsets->saved_regs == offsets->outgoing_args\n+\t\t  || frame_pointer_needed);\n \n       /* Reset the ARM-specific per-function variables.  */\n       after_arm_reorg = 0;\n@@ -9650,8 +9622,7 @@ emit_multi_reg_push (unsigned long mask)\n     if (mask & (1 << i))\n       num_regs++;\n \n-  if (num_regs == 0 || num_regs > 16)\n-    abort ();\n+  gcc_assert (num_regs && num_regs <= 16);\n \n   /* We don't record the PC in the dwarf frame information.  */\n   num_dwarf_regs = num_regs;\n@@ -9978,8 +9949,7 @@ arm_get_frame_offsets (void)\n       /* Ensure SP remains doubleword aligned.  */\n       if (offsets->outgoing_args & 7)\n \toffsets->outgoing_args += 4;\n-      if (offsets->outgoing_args & 7)\n-\tabort ();\n+      gcc_assert (!(offsets->outgoing_args & 7));\n     }\n \n   return offsets;\n@@ -10029,9 +9999,9 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \t  return offsets->outgoing_args - (offsets->saved_args + 4);\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n-      break;\n+      gcc_unreachable ();\n \n     case FRAME_POINTER_REGNUM:\n       switch (to)\n@@ -10051,17 +10021,17 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \t  return offsets->outgoing_args - offsets->soft_frame;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n-      break;\n+      gcc_unreachable ();\n \n     default:\n       /* You cannot eliminate from the stack pointer.\n \t In theory you could eliminate from the hard frame\n \t pointer to the stack pointer, but this will never\n \t happen, since if a stack frame is not needed the\n \t hard frame pointer will never be used.  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -10110,7 +10080,7 @@ arm_expand_prologue (void)\n \t     stack decrement per function, and this is not it.  If\n \t     this instruction is labeled as being part of the frame\n \t     creation sequence then dwarf2out_frame_debug_expr will\n-\t     abort when it encounters the assignment of IP to FP\n+\t     die when it encounters the assignment of IP to FP\n \t     later on, since the use of SP here establishes SP as\n \t     the CFA register and not IP.\n \n@@ -10620,8 +10590,8 @@ arm_print_operand (FILE *stream, rtx x, int code)\n     case 'X':\t\t\t/* Cirrus register in D mode.  */\n     case 'Y':\t\t\t/* Cirrus register in FX mode.  */\n     case 'Z':\t\t\t/* Cirrus register in DX mode.  */\n-      if (GET_CODE (x) != REG || REGNO_REG_CLASS (REGNO (x)) != CIRRUS_REGS)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == REG\n+\t\t  && REGNO_REG_CLASS (REGNO (x)) == CIRRUS_REGS);\n \n       fprintf (stream, \"mv%s%s\",\n \t       code == 'W' ? \"f\"\n@@ -10726,21 +10696,26 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t  return;\n \t}\n \n-      if (GET_CODE (x) == REG)\n-\tasm_fprintf (stream, \"%r\", REGNO (x));\n-      else if (GET_CODE (x) == MEM)\n+      switch (GET_CODE (x))\n \t{\n+\tcase REG:\n+\t  asm_fprintf (stream, \"%r\", REGNO (x));\n+\t  break;\n+\n+\tcase MEM:\n \t  output_memory_reference_mode = GET_MODE (x);\n \t  output_address (XEXP (x, 0));\n-\t}\n-      else if (GET_CODE (x) == CONST_DOUBLE)\n-\tfprintf (stream, \"#%s\", fp_immediate_constant (x));\n-      else if (GET_CODE (x) == NEG)\n-\tabort (); /* This should never happen now.  */\n-      else\n-\t{\n+\t  break;\n+\n+\tcase CONST_DOUBLE:\n+\t  fprintf (stream, \"#%s\", fp_immediate_constant (x));\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_assert (GET_CODE (x) != NEG);\n \t  fputc ('#', stream);\n \t  output_addr_const (stream, x);\n+\t  break;\n \t}\n     }\n }\n@@ -10778,8 +10753,7 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n     {\n       int i, units;\n \n-      if (GET_CODE (x) != CONST_VECTOR)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == CONST_VECTOR);\n \n       units = CONST_VECTOR_NUNITS (x);\n \n@@ -10789,7 +10763,7 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n \tcase V4HImode: size = 2; break;\n \tcase V8QImode: size = 1; break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       for (i = 0; i < units; i++)\n@@ -10867,8 +10841,7 @@ get_arm_condition_code (rtx comparison)\n     case CC_DLTUmode: code = ARM_CC;\n \n     dominance:\n-      if (comp_code != EQ && comp_code != NE)\n-\tabort ();\n+      gcc_assert (comp_code == EQ || comp_code == NE);\n \n       if (comp_code == EQ)\n \treturn ARM_INVERSE_CONDITION_CODE (code);\n@@ -10881,23 +10854,23 @@ get_arm_condition_code (rtx comparison)\n \tcase EQ: return ARM_EQ;\n \tcase GE: return ARM_PL;\n \tcase LT: return ARM_MI;\n-\tdefault: abort ();\n+\tdefault: gcc_unreachable ();\n \t}\n \n     case CC_Zmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;\n \tcase EQ: return ARM_EQ;\n-\tdefault: abort ();\n+\tdefault: gcc_unreachable ();\n \t}\n \n     case CC_Nmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_MI;\n \tcase EQ: return ARM_PL;\n-\tdefault: abort ();\n+\tdefault: gcc_unreachable ();\n \t}\n \n     case CCFPEmode:\n@@ -10922,7 +10895,7 @@ get_arm_condition_code (rtx comparison)\n \t  /* UNEQ and LTGT do not have a representation.  */\n \tcase UNEQ: /* Fall through.  */\n \tcase LTGT: /* Fall through.  */\n-\tdefault: abort ();\n+\tdefault: gcc_unreachable ();\n \t}\n \n     case CC_SWPmode:\n@@ -10938,15 +10911,15 @@ get_arm_condition_code (rtx comparison)\n \tcase GTU: return ARM_CC;\n \tcase LEU: return ARM_CS;\n \tcase LTU: return ARM_HI;\n-\tdefault: abort ();\n+\tdefault: gcc_unreachable ();\n \t}\n \n     case CC_Cmode:\n       switch (comp_code)\n       {\n       case LTU: return ARM_CS;\n       case GEU: return ARM_CC;\n-      default: abort ();\n+      default: gcc_unreachable ();\n       }\n \n     case CCmode:\n@@ -10962,13 +10935,11 @@ get_arm_condition_code (rtx comparison)\n \tcase GTU: return ARM_HI;\n \tcase LEU: return ARM_LS;\n \tcase LTU: return ARM_CC;\n-\tdefault: abort ();\n+\tdefault: gcc_unreachable ();\n \t}\n \n-    default: abort ();\n+    default: gcc_unreachable ();\n     }\n-\n-  abort ();\n }\n \n void\n@@ -11046,8 +11017,7 @@ arm_final_prescan_insn (rtx insn)\n \treturn;\n     }\n \n-  if (arm_ccfsm_state != 0 && !reverse)\n-    abort ();\n+  gcc_assert (!arm_ccfsm_state || reverse);\n   if (GET_CODE (insn) != JUMP_INSN)\n     return;\n \n@@ -11095,7 +11065,7 @@ arm_final_prescan_insn (rtx insn)\n \t  then_not_else = FALSE;\n         }\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       /* See how many insns this branch skips, and what kind of insns.  If all\n \t insns are okay, and the label or unconditional branch to the same\n@@ -11262,14 +11232,16 @@ arm_final_prescan_insn (rtx insn)\n \t{\n \t  if ((!seeking_return) && (arm_ccfsm_state == 1 || reverse))\n \t    arm_target_label = CODE_LABEL_NUMBER (label);\n-\t  else if (seeking_return || arm_ccfsm_state == 2)\n+\t  else\n \t    {\n+\t      gcc_assert (seeking_return || arm_ccfsm_state == 2);\n+\t      \n \t      while (this_insn && GET_CODE (PATTERN (this_insn)) == USE)\n \t        {\n \t\t  this_insn = next_nonnote_insn (this_insn);\n-\t\t  if (this_insn && (GET_CODE (this_insn) == BARRIER\n-\t\t\t\t    || GET_CODE (this_insn) == CODE_LABEL))\n-\t\t    abort ();\n+\t\t  gcc_assert (!this_insn\n+\t\t\t      || (GET_CODE (this_insn) != BARRIER\n+\t\t\t\t  && GET_CODE (this_insn) != CODE_LABEL));\n \t        }\n \t      if (!this_insn)\n \t        {\n@@ -11281,12 +11253,9 @@ arm_final_prescan_insn (rtx insn)\n \t        }\n \t      arm_target_insn = this_insn;\n \t    }\n-\t  else\n-\t    abort ();\n \t  if (jump_clobbers)\n \t    {\n-\t      if (reverse)\n-\t\tabort ();\n+\t      gcc_assert (!reverse);\n \t      arm_current_cc =\n \t\t  get_arm_condition_code (XEXP (XEXP (XEXP (SET_SRC (body),\n \t\t\t\t\t\t\t    0), 0), 1));\n@@ -11866,7 +11835,7 @@ arm_init_iwmmxt_builtins (void)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       def_mbuiltin (d->mask, d->name, type, d->code);\n@@ -12012,10 +11981,7 @@ arm_expand_binop_builtin (enum insn_code icode,\n       || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n-  /* In case the insn wants input operands in modes different from\n-     the result, abort.  */\n-  if (GET_MODE (op0) != mode0 || GET_MODE (op1) != mode1)\n-    abort ();\n+  gcc_assert (GET_MODE (op0) == mode0 && GET_MODE (op1) == mode1);\n \n   if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n@@ -12322,8 +12288,7 @@ thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n   int lo_mask = mask & 0xFF;\n   int pushed_words = 0;\n \n-  if (mask == 0)\n-    abort ();\n+  gcc_assert (mask);\n \n   if (lo_mask == 0 && !push && (mask & (1 << PC_REGNUM)))\n     {\n@@ -12779,8 +12744,7 @@ thumb_far_jump_used_p (void)\n int\n is_called_in_ARM_mode (tree func)\n {\n-  if (TREE_CODE (func) != FUNCTION_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (func) == FUNCTION_DECL);\n \n   /* Ignore the problem about functions whose address is taken.  */\n   if (TARGET_CALLEE_INTERWORKING && TREE_PUBLIC (func))\n@@ -13024,7 +12988,7 @@ thumb_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \t  return offsets->saved_regs - offsets->saved_args;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -13039,12 +13003,12 @@ thumb_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \t  return offsets->saved_regs - offsets->soft_frame;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -13262,10 +13226,9 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n     {\n       const char * name;\n \n-      if (GET_CODE (DECL_RTL (current_function_decl)) != MEM)\n-\tabort ();\n-      if (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0)) != SYMBOL_REF)\n-\tabort ();\n+      gcc_assert (GET_CODE (DECL_RTL (current_function_decl)) == MEM);\n+      gcc_assert (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0))\n+\t\t  == SYMBOL_REF);\n       name = XSTR  (XEXP (DECL_RTL (current_function_decl), 0), 0);\n \n       /* Generate code sequence to switch us into Thumb mode.  */\n@@ -13494,11 +13457,8 @@ thumb_load_double_from_address (rtx *operands)\n   rtx arg1;\n   rtx arg2;\n \n-  if (GET_CODE (operands[0]) != REG)\n-    abort ();\n-\n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == REG);\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n \n   /* Get the memory address.  */\n   addr = XEXP (operands[1], 0);\n@@ -13540,8 +13500,7 @@ thumb_load_double_from_address (rtx *operands)\n       else\n \tbase = arg1, offset = arg2;\n \n-      if (GET_CODE (base) != REG)\n-\tabort ();\n+      gcc_assert (GET_CODE (base) == REG);\n \n       /* Catch the case of <address> = <reg> + <reg> */\n       if (GET_CODE (offset) == REG)\n@@ -13598,8 +13557,7 @@ thumb_load_double_from_address (rtx *operands)\n       break;\n \n     default:\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n     }\n \n   return \"\";\n@@ -13648,7 +13606,7 @@ thumb_output_move_mem_multiple (int n, rtx *operands)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return \"\";\n@@ -13746,7 +13704,7 @@ thumb_reload_out_hi (rtx *operands)\n void\n thumb_reload_in_hi (rtx *operands ATTRIBUTE_UNUSED)\n {\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Return the length of a function name prefix\n@@ -14126,15 +14084,14 @@ arm_emit_vector_const (FILE *file, rtx x)\n   int i;\n   const char * pattern;\n \n-  if (GET_CODE (x) != CONST_VECTOR)\n-    abort ();\n+  gcc_assert (GET_CODE (x) == CONST_VECTOR);\n \n   switch (GET_MODE (x))\n     {\n     case V2SImode: pattern = \"%08x\"; break;\n     case V4HImode: pattern = \"%04x\"; break;\n     case V8QImode: pattern = \"%02x\"; break;\n-    default:       abort ();\n+    default:       gcc_unreachable ();\n     }\n \n   fprintf (file, \"0x\");\n@@ -14590,6 +14547,6 @@ arm_dbx_register_number (unsigned int regno)\n   if (IS_IWMMXT_REGNUM (regno))\n     return 112 + regno - FIRST_IWMMXT_REGNUM;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n "}, {"sha": "e6a049b90676c3e7fd95829774eae469c5dc04c6", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=e6d29d157fe489f6e030f2356c3945155687bad1", "patch": "@@ -2565,16 +2565,15 @@ extern int making_const_table;\n \t  }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  default:\t\t\t\t\t\t\t\\\n-\t    abort();\t\t\t\t\t\t\t\\\n+\t    gcc_unreachable ();\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_INC\t\t\\\n \t   || GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_DEC)\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       extern enum machine_mode output_memory_reference_mode;\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) != REG)\t\t\t\t\\\n-\tabort ();\t\t\t\t\t\t\t\\\n+      gcc_assert (GET_CODE (XEXP (X, 0)) == REG);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\t\\\n \tasm_fprintf (STREAM, \"[%r, #%s%d]!\",\t\t\t\t\\\n@@ -2618,8 +2617,7 @@ extern int making_const_table;\n     asm_fprintf (STREAM, \"%r!\", REGNO (XEXP (X, 0)));\t\\\n   else if (GET_CODE (X) == PLUS)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) != REG)\t\t\\\n-        abort ();\t\t\t\t\t\\\n+      gcc_assert (GET_CODE (XEXP (X, 0)) == REG);\t\\\n       if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\\\n \tasm_fprintf (STREAM, \"[%r, #%wd]\", \t\t\\\n \t\t     REGNO (XEXP (X, 0)),\t\t\\"}, {"sha": "ee7a1d8ff323ba4ecc81e48b219e82c42e018c3e", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=e6d29d157fe489f6e030f2356c3945155687bad1", "patch": "@@ -3614,12 +3614,8 @@\n         ops[1] = mem;\n         ops[2] = const0_rtx;\n       }\n-      \n-    if (GET_CODE (ops[1]) != REG)\n-      {\n-        debug_rtx (ops[1]);\n-        abort ();\n-      }\n+\n+    gcc_assert (GET_CODE (ops[1]) == REG);\n \n     ops[0] = operands[0];\n     ops[3] = operands[2];\n@@ -3634,7 +3630,7 @@\n ;; We used to have an early-clobber on the scratch register here.\n ;; However, there's a bug somewhere in reload which means that this\n ;; can be partially ignored during spill allocation if the memory\n-;; address also needs reloading; this causes an abort later on when\n+;; address also needs reloading; this causes us to die later on when\n ;; we try to verify the operands.  Fortunately, we don't really need\n ;; the early-clobber: we can always use operand 0 if operand 2\n ;; overlaps the address.\n@@ -3685,11 +3681,7 @@\n         ops[2] = const0_rtx;\n       }\n       \n-    if (GET_CODE (ops[1]) != REG)\n-      {\n-        debug_rtx (ops[1]);\n-        abort ();\n-      }\n+    gcc_assert (GET_CODE (ops[1]) == REG);\n \n     ops[0] = operands[0];\n     if (reg_mentioned_p (operands[2], ops[1]))\n@@ -3949,10 +3941,9 @@\n \t    else\n               output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n \t  }\n-        else if (GET_CODE (b) != REG)\n-\t  abort ();\n \telse\n           {\n+\t    gcc_assert (GET_CODE (b) == REG);\n             if (REGNO (b) == REGNO (ops[0]))\n \t      {\n                 output_asm_insn (\\\"ldrb\\\\t%0, [%2, %1]\\\", ops);\n@@ -4032,10 +4023,9 @@\n \t    else\n               output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n \t  }\n-        else if (GET_CODE (b) != REG)\n-\t  abort ();\n \telse\n           {\n+\t    gcc_assert (GET_CODE (b) == REG);\n             if (REGNO (b) == REGNO (ops[0]))\n \t      {\n                 output_asm_insn (\\\"ldrb\\\\t%0, [%2, %1]\\\", ops);\n@@ -4778,8 +4768,7 @@\n         {\n           /* Writing a constant to memory needs a scratch, which should\n \t     be handled with SECONDARY_RELOADs.  */\n-          if (GET_CODE (operands[0]) != REG)\n-\t    abort ();\n+          gcc_assert (GET_CODE (operands[0]) == REG);\n \n           operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n           emit_insn (gen_movsi (operands[0], operands[1]));\n@@ -4821,8 +4810,7 @@\n         {\n           /* Writing a constant to memory needs a scratch, which should\n \t     be handled with SECONDARY_RELOADs.  */\n-          if (GET_CODE (operands[0]) != REG)\n-\t    abort ();\n+          gcc_assert (GET_CODE (operands[0]) == REG);\n \n           operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n           emit_insn (gen_movsi (operands[0], operands[1]));\n@@ -4846,7 +4834,7 @@\n     case 3: return \\\"mov\t%0, %1\\\";\n     case 4: return \\\"mov\t%0, %1\\\";\n     case 5: return \\\"mov\t%0, %1\\\";\n-    default: abort ();\n+    default: gcc_unreachable ();\n     case 1:\n       /* The stack pointer can end up being taken as an index register.\n           Catch this case here and deal with it.  */\n@@ -4957,7 +4945,7 @@\n    (clobber (match_operand:SI 2 \"register_operand\" \"=&l\"))]\n   \"TARGET_THUMB\"\n   \"*\n-  abort ();\"\n+  gcc_unreachable ();\"\n )\n \t\n ;; We use a DImode scratch because we may occasionally need an additional\n@@ -5052,8 +5040,7 @@\n         {\n           /* Writing a constant to memory needs a scratch, which should\n \t     be handled with SECONDARY_RELOADs.  */\n-          if (GET_CODE (operands[0]) != REG)\n-\t    abort ();\n+          gcc_assert (GET_CODE (operands[0]) == REG);\n \n           operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n           emit_insn (gen_movsi (operands[0], operands[1]));\n@@ -7059,8 +7046,7 @@\n \t\t      (pc)))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n-  if (arm_ccfsm_state != 0)\n-    abort ();\n+  gcc_assert (!arm_ccfsm_state);\n \n   return \\\"bvs\\\\t%l0\\;beq\\\\t%l0\\\";\n   \"\n@@ -7076,8 +7062,7 @@\n \t\t      (pc)))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n-  if (arm_ccfsm_state != 0)\n-    abort ();\n+  gcc_assert (!arm_ccfsm_state);\n \n   return \\\"bmi\\\\t%l0\\;bgt\\\\t%l0\\\";\n   \"\n@@ -7112,8 +7097,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n-  if (arm_ccfsm_state != 0)\n-    abort ();\n+  gcc_assert (!arm_ccfsm_state);\n \n   return \\\"bmi\\\\t%l0\\;bgt\\\\t%l0\\\";\n   \"\n@@ -7129,8 +7113,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n-  if (arm_ccfsm_state != 0)\n-    abort ();\n+  gcc_assert (!arm_ccfsm_state);\n \n   return \\\"bvs\\\\t%l0\\;beq\\\\t%l0\\\";\n   \"\n@@ -7286,14 +7269,14 @@\n ;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n ; \t(uneq:SI (match_dup 1) (const_int 0)))]\n ;   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n-;   \"abort ();\"\n+;   \"gcc_unreachable ();\"\n ; )\n ;\n ; (define_expand \"sltgt\"\n ;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n ; \t(ltgt:SI (match_dup 1) (const_int 0)))]\n ;   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n-;   \"abort ();\"\n+;   \"gcc_unreachable ();\"\n ; )\n \n (define_insn \"*mov_scc\""}, {"sha": "90a27712058e1cd182c79e20d5c245d0ddb7fc73", "filename": "gcc/config/arm/cirrus.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Fcirrus.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Fcirrus.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcirrus.md?ref=e6d29d157fe489f6e030f2356c3945155687bad1", "patch": "@@ -391,7 +391,7 @@\n     /* Shifting by 0 will just copy %1 into %0.  */\n     case 7: return \\\"cfsh64%?\\\\t%V0, %V1, #0\\\";\n \n-    default: abort ();\n+    default: gcc_unreachable ();\n     }\n   }\"\n   [(set_attr \"length\"         \"  8,   8,     8,   8,     8,     4,     4,     4\")\n@@ -468,7 +468,7 @@\n     case 7: return \\\"cfmvdlr\\\\t%V0, %Q1\\;cfmvdhr%?\\\\t%V0, %R1\\\";\n     case 8: return \\\"cfmvrdl%?\\\\t%Q0, %V1\\;cfmvrdh%?\\\\t%R0, %V1\\\";\n     case 9: return \\\"cfstrd%?\\\\t%V1, %0\\\";\n-    default: abort ();\n+    default: gcc_unreachable ();\n     }\n   }\"\n   [(set_attr \"type\"           \"load1,store2,  *,store2,load1,     *,  load1,   *,     *,store2\")"}, {"sha": "471cb325d496067971bc5ad04ba3e34c77b23604", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=e6d29d157fe489f6e030f2356c3945155687bad1", "patch": "@@ -108,13 +108,11 @@ arm_mark_dllexport (decl)\n   tree idp;\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n+  \n   if (arm_dllimport_name_p (oldname))\n     oldname += 9;\n   else if (arm_dllexport_name_p (oldname))\n@@ -147,17 +145,13 @@ arm_mark_dllimport (decl)\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n   \n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n   \n-  if (arm_dllexport_name_p (oldname))\n-    abort (); /* this shouldn't happen */\n-  else if (arm_dllimport_name_p (oldname))\n+  gcc_assert (!arm_dllexport_name_p (oldname));\n+  if (arm_dllimport_name_p (oldname))\n     return; /* already done */\n \n   /* ??? One can well ask why we're making these checks here,"}, {"sha": "b67163bd98fe6f04c29b6e524b7edcc61fb5ebe2", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d29d157fe489f6e030f2356c3945155687bad1/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=e6d29d157fe489f6e030f2356c3945155687bad1", "patch": "@@ -158,7 +158,7 @@\n     case 7:\n       return \\\"fstd%?\\\\t%P1, %0\\\\t%@ int\\\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   \"\n   [(set_attr \"type\" \"*,load2,store2,r_2_f,f_2_r,ffarith,f_load,f_store\")\n@@ -217,7 +217,7 @@\n       case 7:\n         return \\\"#\\\";\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n     }\n   \""}]}