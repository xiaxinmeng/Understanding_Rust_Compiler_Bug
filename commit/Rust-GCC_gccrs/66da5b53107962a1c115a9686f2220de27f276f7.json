{"sha": "66da5b53107962a1c115a9686f2220de27f276f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZkYTViNTMxMDc5NjJhMWMxMTVhOTY4NmYyMjIwZGUyN2YyNzZmNw==", "commit": {"author": {"name": "Vlad Lazar", "email": "vlad.lazar@arm.com", "date": "2018-08-31T15:00:54Z"}, "committer": {"name": "Vlad Lazar", "email": "vladlazar@gcc.gnu.org", "date": "2018-08-31T15:00:54Z"}, "message": "[AArch64] Implement new intrinsics vabsd_s64 and vnegd_s64.\n\ngcc/\n2018-08-31  Vlad Lazar  <vlad.lazar@arm.com>\n\n\t* config/aarch64/arm_neon.h (vabsd_s64): New.\n\t(vnegd_s64): Likewise.\n\ngcc/testsuite/\n2018-08-31  Vlad Lazar  <vlad.lazar@arm.com>\n\n\t* gcc.target/aarch64/scalar_intrinsics.c (test_vnegd_s64): New.\n\t* gcc.target/aarch64/vneg_s.c (RUN_TEST_SCALAR): New.\n\t(test_vnegd_s64): Likewise.\n\t* gcc.target/aarch64/vnegd_64.c: New.\n\t* gcc.target/aarch64/vabsd_64.c: New.\n\t* gcc.tartget/aarch64/vabs_intrinsic_3.c: New\n\nFrom-SVN: r264019", "tree": {"sha": "8f3fa0eb244fa38057f4adf47f844ecda64d0e22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f3fa0eb244fa38057f4adf47f844ecda64d0e22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66da5b53107962a1c115a9686f2220de27f276f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66da5b53107962a1c115a9686f2220de27f276f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66da5b53107962a1c115a9686f2220de27f276f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66da5b53107962a1c115a9686f2220de27f276f7/comments", "author": null, "committer": null, "parents": [{"sha": "7a4e1f7d634faf92e10cf1b42ef162187ddb5f70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a4e1f7d634faf92e10cf1b42ef162187ddb5f70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a4e1f7d634faf92e10cf1b42ef162187ddb5f70"}], "stats": {"total": 196, "additions": 195, "deletions": 1}, "files": [{"sha": "1e5d1ad9c62de9bf4ce7dd5f3f6dccd978eb65a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -1,3 +1,8 @@\n+2018-08-31  Vlad Lazar  <vlad.lazar@arm.com>\n+\n+\t* config/aarch64/arm_neon.h (vabsd_s64): New.\n+\t(vnegd_s64): Likewise.\n+\n 2018-08-31  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-cp.c (estimate_local_effects): Replace wrong MAX with MIN."}, {"sha": "fc734e1aa9e93c171c0670164e5a3a54209905d3", "filename": "gcc/config/aarch64/arm_neon.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_neon.h?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -11822,6 +11822,18 @@ vabsq_s64 (int64x2_t __a)\n   return __builtin_aarch64_absv2di (__a);\n }\n \n+/* Try to avoid moving between integer and vector registers.\n+   For why the cast to unsigned is needed check the vnegd_s64 intrinsic.\n+   There is a testcase related to this issue:\n+   gcc.target/aarch64/vabsd_s64.c.  */\n+\n+__extension__ extern __inline int64_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vabsd_s64 (int64_t __a)\n+{\n+  return __a < 0 ? - (uint64_t) __a : __a;\n+}\n+\n /* vadd */\n \n __extension__ extern __inline int64_t\n@@ -22907,6 +22919,25 @@ vneg_s64 (int64x1_t __a)\n   return -__a;\n }\n \n+/* According to the ACLE, the negative of the minimum (signed)\n+   value is itself.  This leads to a semantics mismatch, as this is\n+   undefined behaviour in C.  The value range predictor is not\n+   aware that the negation of a negative number can still be negative\n+   and it may try to fold the expression.  See the test in\n+   gcc.target/aarch64/vnegd_s64.c for an example.\n+\n+   The cast below tricks the value range predictor to include\n+   INT64_MIN in the range it computes.  So for x in the range\n+   [INT64_MIN, y] the range prediction after vnegd_s64 (x) will\n+   be ~[INT64_MIN + 1, y].  */\n+\n+__extension__ extern __inline int64_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vnegd_s64 (int64_t __a)\n+{\n+  return - (uint64_t) __a;\n+}\n+\n __extension__ extern __inline float32x4_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n vnegq_f32 (float32x4_t __a)"}, {"sha": "c10f1d299c544f10e7aa114cd6603ece7b9b64cf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -1,3 +1,12 @@\n+2018-08-31  Vlad Lazar  <vlad.lazar@arm.com>\n+\n+\t* gcc.target/aarch64/scalar_intrinsics.c (test_vnegd_s64): New.\n+\t* gcc.target/aarch64/vneg_s.c (RUN_TEST_SCALAR): New.\n+\t(test_vnegd_s64): Likewise.\n+\t* gcc.target/aarch64/vnegd_64.c: New.\n+\t* gcc.target/aarch64/vabsd_64.c: New.\n+\t* gcc.tartget/aarch64/vabs_intrinsic_3.c: New.\n+\n 2018-08-31  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/87155"}, {"sha": "d943989768dd8c9aa87d9dcb899e199029ef3f8b", "filename": "gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fscalar_intrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fscalar_intrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fscalar_intrinsics.c?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -627,6 +627,14 @@ test_vqabss_s32 (int32_t a)\n   return vqabss_s32 (a);\n }\n \n+/* { dg-final { scan-assembler-times \"\\\\tneg\\\\tx\\[0-9\\]+\" 1 } } */\n+\n+int64_t\n+test_vnegd_s64 (int64_t a)\n+{\n+  return vnegd_s64 (a);\n+}\n+\n /* { dg-final { scan-assembler-times \"\\\\tsqneg\\\\tb\\[0-9\\]+\" 1 } } */\n \n int8_t"}, {"sha": "cf4e7ae4679d5b1896f35e3bf3135b0bd42befde", "filename": "gcc/testsuite/gcc.target/aarch64/vabs_intrinsic_3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvabs_intrinsic_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvabs_intrinsic_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvabs_intrinsic_3.c?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -0,0 +1,39 @@\n+/* Test the vabsd_s64 intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps -O2\" } */\n+\n+#include <arm_neon.h>\n+#include <limits.h>\n+\n+extern void abort (void);\n+\n+#define force_simd(V1)   asm volatile (\"mov %d0, %1.d[0]\"       \\\n+           : \"=w\"(V1)                                           \\\n+           : \"w\"(V1)                                            \\\n+           : /* No clobbers */);\n+\n+#define RUN_TEST(test, answ)   \\\n+{                                      \\\n+  force_simd (test);                   \\\n+  force_simd (answ);                   \\\n+  int64_t res = vabsd_s64 (test);      \\\n+  force_simd (res);                    \\\n+  if (res != answ)                     \\\n+    abort ();                          \\\n+}\n+\n+int64_t input[] = {INT64_MAX, 10, 0, -10, INT64_MIN + 1, INT64_MIN};\n+int64_t expected[] = {INT64_MAX, 10, 0, 10, INT64_MAX, INT64_MIN};\n+\n+int main (void)\n+{\n+  RUN_TEST (input[0], expected[0]);\n+  RUN_TEST (input[1], expected[1]);\n+  RUN_TEST (input[2], expected[2]);\n+  RUN_TEST (input[3], expected[3]);\n+  RUN_TEST (input[4], expected[4]);\n+  RUN_TEST (input[5], expected[5]);\n+\n+  return 0;\n+}"}, {"sha": "a0f88ee12c3ea0269041213899a68f6677d80d42", "filename": "gcc/testsuite/gcc.target/aarch64/vabsd_s64.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvabsd_s64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvabsd_s64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvabsd_s64.c?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -0,0 +1,34 @@\n+/* Check that the compiler does not optimise the vabsd_s64 call out.\n+   We need to check for this because there is a mismatch in semantics\n+   between the ACLE, which states that he absolute value of the minimum\n+   (signed) value is itself, and C, where this is undefined behaviour.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps -fno-inline -O2\" } */\n+\n+#include <arm_neon.h>\n+#include <limits.h>\n+\n+extern void abort (void);\n+\n+int\n+bar (int64_t x)\n+{\n+  if (x < (int64_t) 0)\n+    return vabsd_s64 (x) < (int64_t) 0;\n+  else\n+\treturn -1;\n+}\n+\n+int\n+main (void)\n+{\n+  int ans = 1;\n+  int res_abs = bar (INT64_MIN);\n+\n+  if (res_abs != ans)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "e7f20f2831fe0fc55356253fcc8806c5e4b4a0d4", "filename": "gcc/testsuite/gcc.target/aarch64/vneg_s.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_s.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_s.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_s.c?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -75,6 +75,18 @@ extern void abort (void);\n       }\t\t\t\t\t\t\t\t\t\\\n   }\n \n+#define RUN_TEST_SCALAR(test_val, answ_val, a, b)     \\\n+  {                                                   \\\n+    int64_t res;                                      \\\n+    INHIB_OPTIMIZATION;                               \\\n+    a = test_val;                                     \\\n+    b = answ_val;                                     \\\n+    force_simd (b);                                   \\\n+    force_simd (a);                                   \\\n+    res = vnegd_s64 (a);                              \\\n+    force_simd (res);                                 \\\n+  }\n+\n int\n test_vneg_s8 ()\n {\n@@ -177,7 +189,24 @@ test_vneg_s64 ()\n   return 0;\n }\n \n-/* { dg-final { scan-assembler-times \"neg\\\\td\\[0-9\\]+, d\\[0-9\\]+\" 8 } } */\n+int\n+test_vnegd_s64 ()\n+{\n+  int64_t a, b;\n+\n+  RUN_TEST_SCALAR (TEST0, ANSW0, a, b);\n+  RUN_TEST_SCALAR (TEST1, ANSW1, a, b);\n+  RUN_TEST_SCALAR (TEST2, ANSW2, a, b);\n+  RUN_TEST_SCALAR (TEST3, ANSW3, a, b);\n+  RUN_TEST_SCALAR (TEST4, ANSW4, a, b);\n+  RUN_TEST_SCALAR (TEST5, ANSW5, a, b);\n+  RUN_TEST_SCALAR (LLONG_MAX, LLONG_MIN + 1, a, b);\n+  RUN_TEST_SCALAR (LLONG_MIN, LLONG_MIN, a, b);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"neg\\\\td\\[0-9\\]+, d\\[0-9\\]+\" 16 } } */\n \n int\n test_vnegq_s8 ()\n@@ -283,6 +312,9 @@ main (int argc, char **argv)\n   if (test_vneg_s64 ())\n     abort ();\n \n+  if (test_vnegd_s64 ())\n+    abort ();\n+\n   if (test_vnegq_s8 ())\n     abort ();\n "}, {"sha": "73d478ff49daf758e233958d134de8fb864090c4", "filename": "gcc/testsuite/gcc.target/aarch64/vnegd_s64.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvnegd_s64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66da5b53107962a1c115a9686f2220de27f276f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvnegd_s64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvnegd_s64.c?ref=66da5b53107962a1c115a9686f2220de27f276f7", "patch": "@@ -0,0 +1,36 @@\n+/* Check that the compiler does not optimise the negation out.\n+   We need to check for this because there is a mismatch in semantics\n+   between the ACLE, which states that he negative of the minimum\n+   (signed) value is itself and C, where this is undefined behaviour.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps -O2\" } */\n+\n+#include <arm_neon.h>\n+#include <limits.h>\n+\n+extern void abort (void);\n+\n+int\n+foo (int64_t x)\n+{\n+  if (x < (int64_t) 0)\n+    return vnegd_s64 (x) < (int64_t) 0;\n+  else\n+    return -1;\n+}\n+\n+/* { dg-final { scan-assembler-times {neg\\tx[0-9]+, x[0-9]+} 1 } } */\n+\n+int\n+main (void)\n+{\n+  int ans = 1;\n+  int res = foo (INT64_MIN);\n+\n+  if (res != ans)\n+    abort ();\n+\n+  return 0;\n+}\n+"}]}