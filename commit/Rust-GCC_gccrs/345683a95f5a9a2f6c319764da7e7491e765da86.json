{"sha": "345683a95f5a9a2f6c319764da7e7491e765da86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1NjgzYTk1ZjVhOWEyZjZjMzE5NzY0ZGE3ZTc0OTFlNzY1ZGE4Ng==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-06-13T11:40:24Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-06-13T11:40:24Z"}, "message": "[PR80803 2/2] Diligent queuing in SRA grp_write prop\n\n2017-06-13  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/80803\n\tPR tree-optimization/81063\n\t* tree-sra.c (subtree_mark_written_and_enqueue): Move up in the file.\n\t(propagate_subaccesses_across_link): Enqueue subtree whneve necessary\n\tinstead of relying on the caller.\n\ntestsuite/\n\tgcc.dg/tree-ssa/pr80803.c: New test.\n\tgcc.dg/tree-ssa/pr81063.c: Likewise.\n\nFrom-SVN: r249154", "tree": {"sha": "ccaa86c7ea9c58ffef3b5ae4b86a308be277d376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccaa86c7ea9c58ffef3b5ae4b86a308be277d376"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/345683a95f5a9a2f6c319764da7e7491e765da86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345683a95f5a9a2f6c319764da7e7491e765da86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/345683a95f5a9a2f6c319764da7e7491e765da86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345683a95f5a9a2f6c319764da7e7491e765da86/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35a952ba70028b50fbd2fd19f7dc91f2da45371e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a952ba70028b50fbd2fd19f7dc91f2da45371e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35a952ba70028b50fbd2fd19f7dc91f2da45371e"}], "stats": {"total": 215, "additions": 174, "deletions": 41}, "files": [{"sha": "bf2efd50e64ccf844d898f837b3f33baebc65758", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=345683a95f5a9a2f6c319764da7e7491e765da86", "patch": "@@ -1,3 +1,11 @@\n+2017-06-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/80803\n+\tPR tree-optimization/81063\n+\t* tree-sra.c (subtree_mark_written_and_enqueue): Move up in the file.\n+\t(propagate_subaccesses_across_link): Enqueue subtree whneve necessary\n+\tinstead of relying on the caller.\n+\n 2017-06-13  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-sra.c (add_access_to_work_queue): Only enqueue accesses"}, {"sha": "d9a9fb2fa654e2e62dd1a6321c33f172c2eb8c38", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=345683a95f5a9a2f6c319764da7e7491e765da86", "patch": "@@ -1,3 +1,10 @@\n+2017-06-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/80803\n+\tPR tree-optimization/81063\n+\tgcc.dg/tree-ssa/pr80803.c: New test.\n+\tgcc.dg/tree-ssa/pr81063.c: Likewise.\n+\n 2017-06-12  Yury Gribov  <tetra2005@gmail.com>\n \n \t* c-c++-common/fold-masked-cmp-3.c: New test."}, {"sha": "66834fb31fb4d70fe5692737a02a9b1b6e50739e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr80803.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr80803.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr80803.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr80803.c?ref=345683a95f5a9a2f6c319764da7e7491e765da86", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O\" } */\n+\n+struct S0\n+{\n+  unsigned a : 15;\n+  int b;\n+  int c;\n+};\n+\n+struct S1\n+{\n+  struct S0 s0;\n+  int e;\n+};\n+\n+struct Z\n+{\n+  char c;\n+  int z;\n+} __attribute__((packed));\n+\n+union U\n+{\n+  struct S1 s1;\n+  struct Z z;\n+};\n+\n+\n+int __attribute__((noinline, noclone))\n+return_zero (void)\n+{\n+  return 0;\n+}\n+\n+volatile union U gu;\n+struct S0 gs;\n+\n+int __attribute__((noinline, noclone))\n+check_outcome ()\n+{\n+  if (gs.a != 6\n+      || gs.b != 80000)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  union U u;\n+  struct S1 m,n;\n+  struct S0 l;\n+\n+  if (return_zero ())\n+    u.z.z = 20000;\n+  else\n+    {\n+      u.s1.s0.a = 6;\n+      u.s1.s0.b = 80000;\n+      u.s1.e = 2;\n+\n+      n = u.s1;\n+      m = n;\n+      m.s0.c = 0;\n+      l = m.s0;\n+      gs = l;\n+    }\n+\n+  gu = u;\n+  check_outcome ();\n+  return 0;\n+}"}, {"sha": "399e2d19eb3495d872861b8af6be6910333b0b71", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81063.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81063.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81063.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81063.c?ref=345683a95f5a9a2f6c319764da7e7491e765da86", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O\" } */\n+\n+struct A\n+{\n+  int b;\n+  int c:2;\n+};\n+\n+struct B\n+{\n+  int e;\n+  struct A f;\n+} g = {0, {0, 1}}, j;\n+\n+struct A *h = &g.f;\n+\n+int main ()\n+{\n+  struct A k;\n+  struct B l = j, i = l;\n+  if (!i.f.b)\n+    k = i.f;\n+  *h = k;\n+  if (g.f.c != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "c9865c6eb318cd00f3e9db5a2ec47527f4a1eb1f", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345683a95f5a9a2f6c319764da7e7491e765da86/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=345683a95f5a9a2f6c319764da7e7491e765da86", "patch": "@@ -2558,9 +2558,28 @@ create_artificial_child_access (struct access *parent, struct access *model,\n }\n \n \n-/* Propagate all subaccesses of RACC across an assignment link to LACC. Return\n-   true if any new subaccess was created.  Additionally, if RACC is a scalar\n-   access but LACC is not, change the type of the latter, if possible.  */\n+/* Beginning with ACCESS, traverse its whole access subtree and mark all\n+   sub-trees as written to.  If any of them has not been marked so previously\n+   and has assignment links leading from it, re-enqueue it.  */\n+\n+static void\n+subtree_mark_written_and_enqueue (struct access *access)\n+{\n+  if (access->grp_write)\n+    return;\n+  access->grp_write = true;\n+  add_access_to_work_queue (access);\n+\n+  struct access *child;\n+  for (child = access->first_child; child; child = child->next_sibling)\n+    subtree_mark_written_and_enqueue (child);\n+}\n+\n+/* Propagate subaccesses and grp_write flags of RACC across an assignment link\n+   to LACC.  Enqueue sub-accesses as necessary so that the write flag is\n+   propagated transitively.  Return true if anything changed.  Additionally, if\n+   RACC is a scalar access but LACC is not, change the type of the latter, if\n+   possible.  */\n \n static bool\n propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n@@ -2576,7 +2595,7 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       gcc_checking_assert (!comes_initialized_p (racc->base));\n       if (racc->grp_write)\n \t{\n-\t  lacc->grp_write = true;\n+\t  subtree_mark_written_and_enqueue (lacc);\n \t  ret = true;\n \t}\n     }\n@@ -2585,13 +2604,21 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       || lacc->grp_unscalarizable_region\n       || racc->grp_unscalarizable_region)\n     {\n-      ret |= !lacc->grp_write;\n-      lacc->grp_write = true;\n+      if (!lacc->grp_write)\n+\t{\n+\t  ret = true;\n+\t  subtree_mark_written_and_enqueue (lacc);\n+\t}\n       return ret;\n     }\n \n   if (is_gimple_reg_type (racc->type))\n     {\n+      if (!lacc->grp_write)\n+\t{\n+\t  ret = true;\n+\t  subtree_mark_written_and_enqueue (lacc);\n+\t}\n       if (!lacc->first_child && !racc->first_child)\n \t{\n \t  tree t = lacc->base;\n@@ -2616,21 +2643,15 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       struct access *new_acc = NULL;\n       HOST_WIDE_INT norm_offset = rchild->offset + norm_delta;\n \n-      if (rchild->grp_unscalarizable_region)\n-\t{\n-\t  lacc->grp_write = true;\n-\t  continue;\n-\t}\n-\n       if (child_would_conflict_in_lacc (lacc, norm_offset, rchild->size,\n \t\t\t\t\t&new_acc))\n \t{\n \t  if (new_acc)\n \t    {\n-\t      if (!new_acc->grp_write\n-\t\t  && (lacc->grp_write || rchild->grp_write))\n+\t      if (!new_acc->grp_write && rchild->grp_write)\n \t\t{\n-\t\t  new_acc ->grp_write = true;\n+\t\t  gcc_assert (!lacc->grp_write);\n+\t\t  subtree_mark_written_and_enqueue (new_acc);\n \t\t  ret = true;\n \t\t}\n \n@@ -2640,44 +2661,41 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n \t\tret |= propagate_subaccesses_across_link (new_acc, rchild);\n \t    }\n \t  else\n-\t    lacc->grp_write = true;\n+\t    {\n+\t      if (rchild->grp_write && !lacc->grp_write)\n+\t\t{\n+\t\t  ret = true;\n+\t\t  subtree_mark_written_and_enqueue (lacc);\n+\t\t}\n+\t    }\n+\t  continue;\n+\t}\n+\n+      if (rchild->grp_unscalarizable_region)\n+\t{\n+\t  if (rchild->grp_write && !lacc->grp_write)\n+\t    {\n+\t      ret = true;\n+\t      subtree_mark_written_and_enqueue (lacc);\n+\t    }\n \t  continue;\n \t}\n \n       rchild->grp_hint = 1;\n       new_acc = create_artificial_child_access (lacc, rchild, norm_offset,\n \t\t\t\t\t\tlacc->grp_write\n \t\t\t\t\t\t|| rchild->grp_write);\n-      if (new_acc)\n-\t{\n-\t  ret = true;\n-\t  if (racc->first_child)\n-\t    propagate_subaccesses_across_link (new_acc, rchild);\n-\t}\n+      gcc_checking_assert (new_acc);\n+      if (racc->first_child)\n+\tpropagate_subaccesses_across_link (new_acc, rchild);\n+\n+      add_access_to_work_queue (lacc);\n+      ret = true;\n     }\n \n   return ret;\n }\n \n-/* Beginning with ACCESS, traverse its whole access subtree and mark all\n-   sub-trees as written to.  If any of them has not been marked so previously\n-   and has assignment links leading from it, re-enqueue it.  */\n-\n-static void\n-subtree_mark_written_and_enqueue (struct access *access)\n-{\n-  if (access->grp_write)\n-    return;\n-  access->grp_write = true;\n-  add_access_to_work_queue (access);\n-\n-  struct access *child;\n-  for (child = access->first_child; child; child = child->next_sibling)\n-    subtree_mark_written_and_enqueue (child);\n-}\n-\n-\n-\n /* Propagate all subaccesses across assignment links.  */\n \n static void"}]}