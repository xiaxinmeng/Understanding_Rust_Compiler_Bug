{"sha": "fbdc37805a6241c01991e37065187238934cee71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJkYzM3ODA1YTYyNDFjMDE5OTFlMzcwNjUxODcyMzg5MzRjZWU3MQ==", "commit": {"author": {"name": "Tony Reix", "email": "tony.reix@atos.net", "date": "2017-10-03T18:26:31Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2017-10-03T18:26:31Z"}, "message": "Import from libffi master repository.\n\n2017-08-31  Tony Reix  <tony.reix@atos.net>\n\n        * src/powerpc/aix.S (ffi_call_AIX): Add debugging pseudo-op and\n        labels for EH.\n        (ffi_call_go_AIX): New function.\n        (_GLOBAL__F_libffi_src_powerpc_aix): New EH frame.\n        * src/powerpc/aix_closure.S (ffi_closure_ASM): Add debugging\n        pseudo-op and labels for EH.\n        (ffi_go_closure_ASM): New function.\n        (_GLOBAL__F_libffi_src_powerpc_aix_closure): New EH frame.\n        * src/powrpc/ffi_darwin.c (ffi_call_go): New function.\n        (ffi_prep_go_closure): New function.\n        (ffi_closure_helper_common): Rename from ffi_closure_helper_DARWIN.\n        (ffi_closure_helper_DARWIN): Call ffi_closure_helper_common.\n        (ffi_go_closure_helper_DARWIN): Call ffi_closure_helper_common.\n        * src/powerpc/ffitarget.h (FFI_GO_CLOSURES): Define.\n\nFrom-SVN: r253386", "tree": {"sha": "fb0f6e252f5062e33fdeb2f8718deb2972a732a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb0f6e252f5062e33fdeb2f8718deb2972a732a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbdc37805a6241c01991e37065187238934cee71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdc37805a6241c01991e37065187238934cee71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbdc37805a6241c01991e37065187238934cee71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdc37805a6241c01991e37065187238934cee71/comments", "author": {"login": "trex58", "id": 5690106, "node_id": "MDQ6VXNlcjU2OTAxMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/5690106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/trex58", "html_url": "https://github.com/trex58", "followers_url": "https://api.github.com/users/trex58/followers", "following_url": "https://api.github.com/users/trex58/following{/other_user}", "gists_url": "https://api.github.com/users/trex58/gists{/gist_id}", "starred_url": "https://api.github.com/users/trex58/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/trex58/subscriptions", "organizations_url": "https://api.github.com/users/trex58/orgs", "repos_url": "https://api.github.com/users/trex58/repos", "events_url": "https://api.github.com/users/trex58/events{/privacy}", "received_events_url": "https://api.github.com/users/trex58/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11e3d45c7e8cbf1632f1c354ed8318034aa5b0d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e3d45c7e8cbf1632f1c354ed8318034aa5b0d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11e3d45c7e8cbf1632f1c354ed8318034aa5b0d8"}], "stats": {"total": 604, "additions": 595, "deletions": 9}, "files": [{"sha": "f7de95059b11ef9309e16cb333043f9f1d1509f0", "filename": "libffi/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdc37805a6241c01991e37065187238934cee71/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdc37805a6241c01991e37065187238934cee71/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=fbdc37805a6241c01991e37065187238934cee71", "patch": "@@ -1,3 +1,20 @@\n+2017-08-31  Tony Reix  <tony.reix@atos.net>\n+\n+\t* src/powerpc/aix.S (ffi_call_AIX): Add debugging pseudo-op and\n+\tlabels for EH.\n+\t(ffi_call_go_AIX): New function.\n+\t(_GLOBAL__F_libffi_src_powerpc_aix): New EH frame.\n+\t* src/powerpc/aix_closure.S (ffi_closure_ASM): Add debugging\n+\tpseudo-op and labels for EH.\n+\t(ffi_go_closure_ASM): New function.\n+\t(_GLOBAL__F_libffi_src_powerpc_aix_closure): New EH frame.\n+\t* src/powrpc/ffi_darwin.c (ffi_call_go): New function.\n+\t(ffi_prep_go_closure): New function.\n+\t(ffi_closure_helper_common): Rename from ffi_closure_helper_DARWIN.\n+\t(ffi_closure_helper_DARWIN): Call ffi_closure_helper_common.\n+\t(ffi_go_closure_helper_DARWIN): Call ffi_closure_helper_common.\n+\t* src/powerpc/ffitarget.h (FFI_GO_CLOSURES): Define.\n+\n 2017-01-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/79046"}, {"sha": "7ba541595f23c4e7eb4cee504ea580c945c75b34", "filename": "libffi/src/powerpc/aix.S", "status": "modified", "additions": 239, "deletions": 1, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Faix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Faix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix.S?ref=fbdc37805a6241c01991e37065187238934cee71", "patch": "@@ -106,6 +106,10 @@ ffi_call_AIX:\n \t.llong .ffi_call_AIX, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_call_AIX:\n+\t.function .ffi_call_AIX,.ffi_call_AIX,16,044,LFE..0-LFB..0\n+\t.bf __LINE__\n+\t.line 1\n+LFB..0:\n \t/* Save registers we use.  */\n \tmflr\tr0\n \n@@ -115,8 +119,10 @@ ffi_call_AIX:\n \tstd\tr31, -8(r1)\n \n \tstd\tr0, 16(r1)\n+LCFI..0:\n \tmr\tr28, r1\t\t/* our AP.  */\n \tstdux\tr1, r1, r4\n+LCFI..1:\n \n \t/* Save arguments over call...  */\n \tmr\tr31, r5\t/* flags, */\n@@ -202,12 +208,16 @@ L(fp_return_value):\n L(float_return_value):\n \tstfs\tf1, 0(r30)\n \tb\tL(done_return_value)\n-\n+LFE..0:\n #else /* ! __64BIT__ */\n \t\n \t.long .ffi_call_AIX, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_call_AIX:\n+\t.function .ffi_call_AIX,.ffi_call_AIX,16,044,LFE..0-LFB..0\n+\t.bf __LINE__\n+\t.line 1\n+LFB..0:\n \t/* Save registers we use.  */\n \tmflr\tr0\n \n@@ -217,8 +227,10 @@ L(float_return_value):\n \tstw\tr31, -4(r1)\n \n \tstw\tr0, 8(r1)\n+LCFI..0:\n \tmr\tr28, r1\t\t/* out AP.  */\n \tstwux\tr1, r1, r4\n+LCFI..1:\n \n \t/* Save arguments over call...  */\n \tmr\tr31, r5\t/* flags, */\n@@ -304,11 +316,144 @@ L(fp_return_value):\n L(float_return_value):\n \tstfs\tf1, 0(r30)\n \tb\tL(done_return_value)\n+LFE..0:\n #endif\n+\t.ef __LINE__\n \t.long 0\n \t.byte 0,0,0,1,128,4,0,0\n /* END(ffi_call_AIX) */\n \n+\t/* void ffi_call_go_AIX(extended_cif *ecif, unsigned long bytes,\n+\t *\t\t        unsigned int flags, unsigned int *rvalue,\n+\t *\t\t        void (*fn)(),\n+\t *\t\t        void (*prep_args)(extended_cif*, unsigned *const),\n+\t *                      void *closure);\n+\t * r3=ecif, r4=bytes, r5=flags, r6=rvalue, r7=fn, r8=prep_args, r9=closure\n+\t */\n+\n+.csect .text[PR]\n+\t.align 2\n+\t.globl ffi_call_go_AIX\n+\t.globl .ffi_call_go_AIX\n+.csect ffi_call_go_AIX[DS]\n+ffi_call_go_AIX:\n+#ifdef __64BIT__\n+\t.llong .ffi_call_go_AIX, TOC[tc0], 0\n+\t.csect .text[PR]\n+.ffi_call_go_AIX:\n+\t.function .ffi_call_go_AIX,.ffi_call_go_AIX,16,044,LFE..1-LFB..1\n+\t.bf __LINE__\n+\t.line 1\n+LFB..1:\n+\t/* Save registers we use.  */\n+\tmflr\tr0\n+\n+\tstd\tr28,-32(r1)\n+\tstd\tr29,-24(r1)\n+\tstd\tr30,-16(r1)\n+\tstd\tr31, -8(r1)\n+\n+\tstd\tr9, 8(r1)\t/* closure, saved in cr field. */\n+\tstd\tr0, 16(r1)\n+LCFI..2:\n+\tmr\tr28, r1\t\t/* our AP.  */\n+\tstdux\tr1, r1, r4\n+LCFI..3:\n+\n+\t/* Save arguments over call...  */\n+\tmr\tr31, r5\t/* flags, */\n+\tmr\tr30, r6\t/* rvalue, */\n+\tmr\tr29, r7\t/* function address,  */\n+\tstd\tr2, 40(r1)\n+\n+\t/* Call ffi_prep_args.  */\n+\tmr\tr4, r1\n+\tbl\t.ffi_prep_args\n+\tnop\n+\n+\t/* Now do the call.  */\n+\tld\tr0, 0(r29)\n+\tld\tr2, 8(r29)\n+\tld      r11, 8(r28)\t/* closure */\n+\t/* Set up cr1 with bits 4-7 of the flags.  */\n+\tmtcrf\t0x40, r31\n+\tmtctr\tr0\n+\t/* Load all those argument registers.  */\n+\t/* We have set up a nice stack frame, just load it into registers. */\n+\tld\tr3, 40+(1*8)(r1)\n+\tld\tr4, 40+(2*8)(r1)\n+\tld\tr5, 40+(3*8)(r1)\n+\tld\tr6, 40+(4*8)(r1)\n+\tnop\n+\tld\tr7, 40+(5*8)(r1)\n+\tld\tr8, 40+(6*8)(r1)\n+\tld\tr9, 40+(7*8)(r1)\n+\tld\tr10,40+(8*8)(r1)\n+\n+\tb\tL1\n+LFE..1:\n+#else /* ! __64BIT__ */\n+\t\n+\t.long .ffi_call_go_AIX, TOC[tc0], 0\n+\t.csect .text[PR]\n+.ffi_call_go_AIX:\n+\t.function .ffi_call_go_AIX,.ffi_call_go_AIX,16,044,LFE..1-LFB..1\n+\t.bf __LINE__\n+\t.line 1\n+\t/* Save registers we use.  */\n+LFB..1:\n+\tmflr\tr0\n+\n+\tstw\tr28,-16(r1)\n+\tstw\tr29,-12(r1)\n+\tstw\tr30, -8(r1)\n+\tstw\tr31, -4(r1)\n+\n+\tstw\tr9, 4(r1)\t/* closure, saved in cr field.  */\n+\tstw\tr0, 8(r1)\n+LCFI..2:\n+\tmr\tr28, r1\t\t/* out AP.  */\n+\tstwux\tr1, r1, r4\n+LCFI..3:\n+\n+\t/* Save arguments over call...  */\n+\tmr\tr31, r5\t/* flags, */\n+\tmr\tr30, r6\t/* rvalue, */\n+\tmr\tr29, r7\t/* function address, */\n+\tstw\tr2, 20(r1)\n+\n+\t/* Call ffi_prep_args.  */\n+\tmr\tr4, r1\n+\tbl\t.ffi_prep_args\n+\tnop\n+\n+\t/* Now do the call.  */\n+\tlwz\tr0, 0(r29)\n+\tlwz\tr2, 4(r29)\n+\tlwz\tr11, 4(r28)\t/* closure */\n+\t/* Set up cr1 with bits 4-7 of the flags.  */\n+\tmtcrf\t0x40, r31\n+\tmtctr\tr0\n+\t/* Load all those argument registers.  */\n+\t/* We have set up a nice stack frame, just load it into registers. */\n+\tlwz\tr3, 20+(1*4)(r1)\n+\tlwz\tr4, 20+(2*4)(r1)\n+\tlwz\tr5, 20+(3*4)(r1)\n+\tlwz\tr6, 20+(4*4)(r1)\n+\tnop\n+\tlwz\tr7, 20+(5*4)(r1)\n+\tlwz\tr8, 20+(6*4)(r1)\n+\tlwz\tr9, 20+(7*4)(r1)\n+\tlwz\tr10,20+(8*4)(r1)\n+\n+\tb\tL1\n+LFE..1:\n+#endif\n+\t.ef __LINE__\n+\t.long 0\n+\t.byte 0,0,0,1,128,4,0,0\n+/* END(ffi_call_go_AIX) */\n+\n .csect .text[PR]\n \t.align 2\n \t.globl ffi_call_DARWIN\n@@ -326,3 +471,96 @@ ffi_call_DARWIN:\n \t.long 0\n \t.byte 0,0,0,0,0,0,0,0\n /* END(ffi_call_DARWIN) */\n+\n+/* EH frame stuff.  */\n+\n+#define LR_REGNO\t\t0x41\t\t/* Link Register (65), see rs6000.md */\n+#ifdef __64BIT__\n+#define PTRSIZE\t\t\t8\n+#define LOG2_PTRSIZE\t\t3\n+#define FDE_ENCODING\t\t0x1c\t\t/* DW_EH_PE_pcrel|DW_EH_PE_sdata8 */\n+#define EH_DATA_ALIGN_FACT\t0x78\t\t/* LEB128 -8 */\n+#else\n+#define PTRSIZE\t\t\t4\n+#define LOG2_PTRSIZE\t\t2\n+#define FDE_ENCODING\t\t0x1b\t\t/* DW_EH_PE_pcrel|DW_EH_PE_sdata4 */\n+#define EH_DATA_ALIGN_FACT\t0x7c\t\t/* LEB128 -4 */\n+#endif\n+\t.csect\t_unwind.ro_[RO],4\n+\t.align\tLOG2_PTRSIZE\n+\t.globl\t_GLOBAL__F_libffi_src_powerpc_aix\n+_GLOBAL__F_libffi_src_powerpc_aix:\n+Lframe..1:\n+\t.vbyte\t4,LECIE..1-LSCIE..1\t/* CIE Length */\n+LSCIE..1:\n+\t.vbyte\t4,0\t\t\t/* CIE Identifier Tag */\n+\t.byte\t0x3\t\t\t/* CIE Version */\n+\t.byte\t\"zR\"\t\t\t/* CIE Augmentation */\n+\t.byte\t0\n+\t.byte\t0x1\t\t\t/* uleb128 0x1; CIE Code Alignment Factor */\n+\t.byte\tEH_DATA_ALIGN_FACT\t/* leb128 -4/-8; CIE Data Alignment Factor */\n+\t.byte\t0x41\t\t\t/* CIE RA Column */\n+\t.byte\t0x1\t\t\t/* uleb128 0x1; Augmentation size */\n+\t.byte\tFDE_ENCODING\t\t/* FDE Encoding (pcrel|sdata4/8) */\n+\t.byte\t0xc\t\t\t/* DW_CFA_def_cfa */\n+\t.byte\t0x1\t\t\t/*     uleb128 0x1; Register r1 */\n+\t.byte\t0\t\t\t/*     uleb128 0x0; Offset 0 */\n+\t.align\tLOG2_PTRSIZE\n+LECIE..1:\n+LSFDE..1:\n+\t.vbyte\t4,LEFDE..1-LASFDE..1\t/* FDE Length */\n+LASFDE..1:\n+\t.vbyte\t4,LASFDE..1-Lframe..1\t/* FDE CIE offset */\n+\t.vbyte\tPTRSIZE,LFB..0-$\t/* FDE initial location */\n+\t.vbyte\tPTRSIZE,LFE..0-LFB..0\t/* FDE address range */\n+\t.byte   0\t\t\t/* uleb128 0x0; Augmentation size */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..0-LFB..0\n+\t.byte\t0x11\t\t\t/* DW_CFA_def_offset_extended_sf */\n+\t.byte\tLR_REGNO\t\t/*     uleb128 LR_REGNO; Register LR */\n+\t.byte\t0x7e\t\t\t/*     leb128 -2; Offset -2 (8/16) */\n+\t.byte\t0x9f\t\t\t/* DW_CFA_offset Register r31 */\n+\t.byte\t0x1\t\t\t/*     uleb128 0x1; Offset 1 (-4/-8) */\n+\t.byte\t0x9e\t\t\t/* DW_CFA_offset Register r30 */\n+\t.byte\t0x2\t\t\t/*     uleb128 0x2; Offset 2 (-8/-16) */\n+\t.byte\t0x9d\t\t\t/* DW_CFA_offset Register r29 */\n+\t.byte\t0x3\t\t\t/*     uleb128 0x3; Offset 3 (-12/-24) */\n+\t.byte\t0x9c\t\t\t/* DW_CFA_offset Register r28 */\n+\t.byte\t0x4\t\t\t/*     uleb128 0x4; Offset 4 (-16/-32) */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..1-LCFI..0\n+\t.byte\t0xd\t\t\t/* DW_CFA_def_cfa_register */\n+\t.byte\t0x1c\t\t\t/*     uleb128 28; Register r28 */\n+\t.align\tLOG2_PTRSIZE\n+LEFDE..1:\n+LSFDE..2:\n+\t.vbyte\t4,LEFDE..2-LASFDE..2\t/* FDE Length */\n+LASFDE..2:\n+\t.vbyte\t4,LASFDE..2-Lframe..1\t/* FDE CIE offset */\n+\t.vbyte\tPTRSIZE,LFB..1-$\t/* FDE initial location */\n+\t.vbyte\tPTRSIZE,LFE..1-LFB..1\t/* FDE address range */\n+\t.byte   0\t\t\t/* uleb128 0x0; Augmentation size */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..2-LFB..1\n+\t.byte\t0x11\t\t\t/* DW_CFA_def_offset_extended_sf */\n+\t.byte\tLR_REGNO\t\t/*     uleb128 LR_REGNO; Register LR */\n+\t.byte\t0x7e\t\t\t/*     leb128 -2; Offset -2 (8/16) */\n+\t.byte\t0x9f\t\t\t/* DW_CFA_offset Register r31 */\n+\t.byte\t0x1\t\t\t/*     uleb128 0x1; Offset 1 (-4/-8) */\n+\t.byte\t0x9e\t\t\t/* DW_CFA_offset Register r30 */\n+\t.byte\t0x2\t\t\t/*     uleb128 0x2; Offset 2 (-8/-16) */\n+\t.byte\t0x9d\t\t\t/* DW_CFA_offset Register r29 */\n+\t.byte\t0x3\t\t\t/*     uleb128 0x3; Offset 3 (-12/-24) */\n+\t.byte\t0x9c\t\t\t/* DW_CFA_offset Register r28 */\n+\t.byte\t0x4\t\t\t/*     uleb128 0x4; Offset 4 (-16/-32) */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..3-LCFI..2\n+\t.byte\t0xd\t\t\t/* DW_CFA_def_cfa_register */\n+\t.byte\t0x1c\t\t\t/*     uleb128 28; Register r28 */\n+\t.align\tLOG2_PTRSIZE\n+LEFDE..2:\n+\t.vbyte\t4,0\t\t\t/* End of FDEs */\n+\n+\t.csect\t.text[PR]\n+\t.ref\t_GLOBAL__F_libffi_src_powerpc_aix\t/* Prevents garbage collection by AIX linker */\n+"}, {"sha": "132c785eddc8551afc3f9f34f376d65db65b9ed6", "filename": "libffi/src/powerpc/aix_closure.S", "status": "modified", "additions": 250, "deletions": 3, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=fbdc37805a6241c01991e37065187238934cee71", "patch": "@@ -80,6 +80,7 @@\n \t.set f21,21\n \n \t.extern .ffi_closure_helper_DARWIN\n+\t.extern .ffi_go_closure_helper_DARWIN\n \n #define LIBFFI_ASM\n #define JUMPTARGET(name) name\n@@ -101,6 +102,10 @@ ffi_closure_ASM:\n \t.llong .ffi_closure_ASM, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_closure_ASM:\n+\t.function .ffi_closure_ASM,.ffi_closure_ASM,16,044,LFE..0-LFB..0\n+\t.bf __LINE__\n+\t.line 1\n+LFB..0:\n /* we want to build up an area for the parameters passed */\n /* in registers (both floating point and integer) */\n \n@@ -117,8 +122,7 @@ ffi_closure_ASM:\n \tstd   r9, 48+(6*8)(r1)\n \tstd   r10, 48+(7*8)(r1)\n \tstd   r0, 16(r1)\t/* save the return address */\n-\n-\n+LCFI..0:\n \t/* 48  Bytes (Linkage Area) */\n \t/* 64  Bytes (params) */\n \t/* 16  Bytes (result) */\n@@ -128,6 +132,7 @@ ffi_closure_ASM:\n \n \tstdu  r1, -240(r1)\t/* skip over caller save area\n \t\t\t\t   keep stack aligned to 16  */\n+LCFI..1:\n \n \t/* next save fpr 1 to fpr 13 (aligned to 8) */\n \tstfd  f1, 128+(0*8)(r1)\n@@ -161,6 +166,8 @@ ffi_closure_ASM:\n \tbl .ffi_closure_helper_DARWIN\n \tnop\n \n+.Ldoneclosure:\n+\n \t/* now r3 contains the return type */\n \t/* so use it to look up in a table */\n \t/* so we know how to deal with each type */\n@@ -270,12 +277,17 @@ L..finish:\n \tmtlr r0\n \taddi r1, r1, 240\n \tblr\n+LFE..0:\n \n #else /* ! __64BIT__ */\n \t\n \t.long .ffi_closure_ASM, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_closure_ASM:\n+\t.function .ffi_closure_ASM,.ffi_closure_ASM,16,044,LFE..0-LFB..0\n+\t.bf __LINE__\n+\t.line 1\n+LFB..0:\n /* we want to build up an area for the parameters passed */\n /* in registers (both floating point and integer) */\n \n@@ -292,7 +304,7 @@ L..finish:\n \tstw   r9, 24+(6*4)(r1)\n \tstw   r10, 24+(7*4)(r1)\n \tstw   r0, 8(r1)\n-\n+LCFI..0:\n \t/* 24 Bytes (Linkage Area) */\n \t/* 32 Bytes (params) */\n \t/* 16  Bytes (result) */\n@@ -301,6 +313,7 @@ L..finish:\n \n \tstwu  r1, -176(r1)\t/* skip over caller save area\n \t\t\t\t   keep stack aligned to 16  */\n+LCFI..1:\n \n \t/* next save fpr 1 to fpr 13 (aligned to 8) */\n \tstfd  f1, 72+(0*8)(r1)\n@@ -334,6 +347,8 @@ L..finish:\n \tbl .ffi_closure_helper_DARWIN\n \tnop\n \n+.Ldoneclosure:\n+\n \t/* now r3 contains the return type */\n \t/* so use it to look up in a table */\n \t/* so we know how to deal with each type */\n@@ -443,5 +458,237 @@ L..60:\n L..finish:\n \taddi r1, r1, 176\n \tblr\n+LFE..0:\n #endif\n+\t.ef __LINE__\n /* END(ffi_closure_ASM) */\n+\n+\n+.csect .text[PR]\n+\t.align 2\n+\t.globl ffi_go_closure_ASM\n+\t.globl .ffi_go_closure_ASM\n+.csect ffi_go_closure_ASM[DS]\n+ffi_go_closure_ASM:\n+#ifdef __64BIT__\n+\t.llong .ffi_go_closure_ASM, TOC[tc0], 0\n+\t.csect .text[PR]\n+.ffi_go_closure_ASM:\n+\t.function .ffi_go_closure_ASM,.ffi_go_closure_ASM,16,044,LFE..1-LFB..1\n+\t.bf __LINE__\n+\t.line 1\n+LFB..1:\n+/* we want to build up an area for the parameters passed */\n+/* in registers (both floating point and integer) */\n+\n+\t/* we store gpr 3 to gpr 10 (aligned to 4)\n+\tin the parents outgoing area  */\n+\tstd   r3, 48+(0*8)(r1)\n+\tstd   r4, 48+(1*8)(r1)\n+\tstd   r5, 48+(2*8)(r1)\n+\tstd   r6, 48+(3*8)(r1)\n+\tmflr  r0\n+\n+\tstd   r7, 48+(4*8)(r1)\n+\tstd   r8, 48+(5*8)(r1)\n+\tstd   r9, 48+(6*8)(r1)\n+\tstd   r10, 48+(7*8)(r1)\n+\tstd   r0, 16(r1)\t/* save the return address */\n+LCFI..2:\n+\t/* 48  Bytes (Linkage Area) */\n+\t/* 64  Bytes (params) */\n+\t/* 16  Bytes (result) */\n+\t/* 104 Bytes (13*8 from FPR) */\n+\t/* 8   Bytes (alignment) */\n+\t/* 240 Bytes */\n+\n+\tstdu  r1, -240(r1)\t/* skip over caller save area\n+\t\t\t\t   keep stack aligned to 16  */\n+LCFI..3:\n+\n+\t/* next save fpr 1 to fpr 13 (aligned to 8) */\n+\tstfd  f1, 128+(0*8)(r1)\n+\tstfd  f2, 128+(1*8)(r1)\n+\tstfd  f3, 128+(2*8)(r1)\n+\tstfd  f4, 128+(3*8)(r1)\n+\tstfd  f5, 128+(4*8)(r1)\n+\tstfd  f6, 128+(5*8)(r1)\n+\tstfd  f7, 128+(6*8)(r1)\n+\tstfd  f8, 128+(7*8)(r1)\n+\tstfd  f9, 128+(8*8)(r1)\n+\tstfd  f10, 128+(9*8)(r1)\n+\tstfd  f11, 128+(10*8)(r1)\n+\tstfd  f12, 128+(11*8)(r1)\n+\tstfd  f13, 128+(12*8)(r1)\n+\n+\t/* set up registers for the routine that actually does the work */\n+\tmr r3, r11\t/* go closure */\n+\n+\t/* now load up the pointer to the result storage */\n+\taddi r4, r1, 112\n+\n+\t/* now load up the pointer to the saved gpr registers */\n+\taddi r5, r1, 288\n+\n+\t/* now load up the pointer to the saved fpr registers */\n+\taddi r6, r1, 128\n+\n+\t/* make the call */\n+\tbl .ffi_go_closure_helper_DARWIN\n+\tnop\n+\n+\tb .Ldoneclosure\n+LFE..1:\n+\n+#else /* ! __64BIT__ */\n+\t\n+\t.long .ffi_go_closure_ASM, TOC[tc0], 0\n+\t.csect .text[PR]\n+.ffi_go_closure_ASM:\n+\t.function .ffi_go_closure_ASM,.ffi_go_closure_ASM,16,044,LFE..1-LFB..1\n+\t.bf __LINE__\n+\t.line 1\n+LFB..1:\n+/* we want to build up an area for the parameters passed */\n+/* in registers (both floating point and integer) */\n+\n+\t/* we store gpr 3 to gpr 10 (aligned to 4)\n+\tin the parents outgoing area  */\n+\tstw   r3, 24+(0*4)(r1)\n+\tstw   r4, 24+(1*4)(r1)\n+\tstw   r5, 24+(2*4)(r1)\n+\tstw   r6, 24+(3*4)(r1)\n+\tmflr  r0\n+\n+\tstw   r7, 24+(4*4)(r1)\n+\tstw   r8, 24+(5*4)(r1)\n+\tstw   r9, 24+(6*4)(r1)\n+\tstw   r10, 24+(7*4)(r1)\n+\tstw   r0, 8(r1)\n+LCFI..2:\n+\t/* 24 Bytes (Linkage Area) */\n+\t/* 32 Bytes (params) */\n+\t/* 16  Bytes (result) */\n+\t/* 104 Bytes (13*8 from FPR) */\n+\t/* 176 Bytes */\n+\n+\tstwu  r1, -176(r1)\t/* skip over caller save area\n+\t\t\t\t   keep stack aligned to 16  */\n+LCFI..3:\n+\n+\t/* next save fpr 1 to fpr 13 (aligned to 8) */\n+\tstfd  f1, 72+(0*8)(r1)\n+\tstfd  f2, 72+(1*8)(r1)\n+\tstfd  f3, 72+(2*8)(r1)\n+\tstfd  f4, 72+(3*8)(r1)\n+\tstfd  f5, 72+(4*8)(r1)\n+\tstfd  f6, 72+(5*8)(r1)\n+\tstfd  f7, 72+(6*8)(r1)\n+\tstfd  f8, 72+(7*8)(r1)\n+\tstfd  f9, 72+(8*8)(r1)\n+\tstfd  f10, 72+(9*8)(r1)\n+\tstfd  f11, 72+(10*8)(r1)\n+\tstfd  f12, 72+(11*8)(r1)\n+\tstfd  f13, 72+(12*8)(r1)\n+\n+\t/* set up registers for the routine that actually does the work */\n+\tmr   r3, 11\t/* go closure */\n+\n+\t/* now load up the pointer to the result storage */\n+\taddi r4, r1, 56\n+\n+\t/* now load up the pointer to the saved gpr registers */\n+\taddi r5, r1, 200\n+\n+\t/* now load up the pointer to the saved fpr registers */\n+\taddi r6, r1, 72\n+\n+\t/* make the call */\n+\tbl .ffi_go_closure_helper_DARWIN\n+\tnop\n+\n+\tb    .Ldoneclosure\n+LFE..1:\n+#endif\n+\t.ef __LINE__\n+/* END(ffi_go_closure_ASM) */\n+\n+/* EH frame stuff.  */\n+\n+#define LR_REGNO\t\t0x41\t\t/* Link Register (65), see rs6000.md */\n+#ifdef __64BIT__\n+#define PTRSIZE\t\t\t8\n+#define LOG2_PTRSIZE\t\t3\n+#define CFA_OFFSET\t\t0xf0,0x01\t/* LEB128 240 */\n+#define FDE_ENCODING\t\t0x1c\t\t/* DW_EH_PE_pcrel|DW_EH_PE_sdata8 */\n+#define EH_DATA_ALIGN_FACT\t0x78\t\t/* LEB128 -8 */\n+#else\n+#define PTRSIZE\t\t\t4\n+#define LOG2_PTRSIZE\t\t2\n+#define CFA_OFFSET\t\t0xb0,0x01\t/* LEB128 176 */\n+#define FDE_ENCODING\t\t0x1b\t\t/* DW_EH_PE_pcrel|DW_EH_PE_sdata4 */\n+#define EH_DATA_ALIGN_FACT\t0x7c\t\t/* LEB128 -4 */\n+#endif\n+\n+\t.csect\t_unwind.ro_[RO],4\n+\t.align\tLOG2_PTRSIZE\n+\t.globl\t_GLOBAL__F_libffi_src_powerpc_aix_closure\n+_GLOBAL__F_libffi_src_powerpc_aix_closure:\n+Lframe..1:\n+\t.vbyte\t4,LECIE..1-LSCIE..1\t/* CIE Length */\n+LSCIE..1:\n+\t.vbyte\t4,0\t\t\t/* CIE Identifier Tag */\n+\t.byte\t0x3\t\t\t/* CIE Version */\n+\t.byte\t\"zR\"\t\t\t/* CIE Augmentation */\n+\t.byte\t0\n+\t.byte\t0x1\t\t\t/* uleb128 0x1; CIE Code Alignment Factor */\n+\t.byte\tEH_DATA_ALIGN_FACT\t/* leb128 -4/-8; CIE Data Alignment Factor */\n+\t.byte\tLR_REGNO\t\t/* CIE RA Column */\n+\t.byte\t0x1\t\t\t/* uleb128 0x1; Augmentation size */\n+\t.byte\tFDE_ENCODING\t\t/* FDE Encoding (pcrel|sdata4/8) */\n+\t.byte\t0xc\t\t\t/* DW_CFA_def_cfa */\n+\t.byte\t0x1\t\t\t/*     uleb128 0x1; Register r1 */\n+\t.byte\t0\t\t\t/*     uleb128 0x0; Offset 0 */\n+\t.align\tLOG2_PTRSIZE\n+LECIE..1:\n+LSFDE..1:\n+\t.vbyte\t4,LEFDE..1-LASFDE..1\t/* FDE Length */\n+LASFDE..1:\n+\t.vbyte\t4,LASFDE..1-Lframe..1\t/* FDE CIE offset */\n+\t.vbyte\tPTRSIZE,LFB..0-$\t/* FDE initial location */\n+\t.vbyte\tPTRSIZE,LFE..0-LFB..0\t/* FDE address range */\n+\t.byte\t0\t\t\t/* uleb128 0x0; Augmentation size */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..1-LCFI..0\n+\t.byte\t0xe\t\t\t/* DW_CFA_def_cfa_offset */\n+\t.byte\tCFA_OFFSET\t\t/*     uleb128 176/240 */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..0-LFB..0\n+\t.byte\t0x11\t\t\t/* DW_CFA_offset_extended_sf */\n+\t.byte\tLR_REGNO\t\t/*     uleb128 LR_REGNO; Register LR */\n+\t.byte\t0x7e\t\t\t/*     leb128 -2; Offset -2 (8/16) */\n+\t.align\tLOG2_PTRSIZE\n+LEFDE..1:\n+LSFDE..2:\n+\t.vbyte\t4,LEFDE..2-LASFDE..2\t/* FDE Length */\n+LASFDE..2:\n+\t.vbyte\t4,LASFDE..2-Lframe..1\t/* FDE CIE offset */\n+\t.vbyte\tPTRSIZE,LFB..1-$\t/* FDE initial location */\n+\t.vbyte\tPTRSIZE,LFE..1-LFB..1\t/* FDE address range */\n+\t.byte\t0\t\t\t/* uleb128 0x0; Augmentation size */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..3-LCFI..2\n+\t.byte\t0xe\t\t\t/* DW_CFA_def_cfa_offset */\n+\t.byte\tCFA_OFFSET\t\t/*     uleb128 176/240 */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.vbyte\t4,LCFI..2-LFB..1\n+\t.byte\t0x11\t\t\t/* DW_CFA_offset_extended_sf */\n+\t.byte\tLR_REGNO\t\t/*     uleb128 LR_REGNO; Register LR */\n+\t.byte\t0x7e\t\t\t/*     leb128 -2; Offset -2 (8/16) */\n+\t.align\tLOG2_PTRSIZE\n+LEFDE..2:\n+\t.vbyte\t4,0\t\t\t/* End of FDEs */\n+\n+\t.csect\t.text[PR]\n+\t.ref\t_GLOBAL__F_libffi_src_powerpc_aix_closure\t/* Prevents garbage collection by AIX linker */\n+"}, {"sha": "6588e3cad0832e231b72eb70b23cc30fca11c7c0", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 86, "deletions": 5, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=fbdc37805a6241c01991e37065187238934cee71", "patch": "@@ -33,6 +33,7 @@\n #include <stdlib.h>\n \n extern void ffi_closure_ASM (void);\n+extern void ffi_go_closure_ASM (void);\n \n enum {\n   /* The assembly depends on these exact flags.  \n@@ -908,6 +909,9 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n extern void ffi_call_AIX(extended_cif *, long, unsigned, unsigned *,\n \t\t\t void (*fn)(void), void (*fn2)(void));\n \n+extern void ffi_call_go_AIX(extended_cif *, long, unsigned, unsigned *,\n+\t\t\t    void (*fn)(void), void (*fn2)(void), void *closure);\n+\n extern void ffi_call_DARWIN(extended_cif *, long, unsigned, unsigned *,\n \t\t\t    void (*fn)(void), void (*fn2)(void), ffi_type*);\n \n@@ -946,6 +950,38 @@ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     }\n }\n \n+void\n+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,\n+\t     void *closure)\n+{\n+  extended_cif ecif;\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+\n+  /* If the return value is a struct and we don't have a return\n+     value address then we need to make one.  */\n+\n+  if ((rvalue == NULL) &&\n+      (cif->rtype->type == FFI_TYPE_STRUCT))\n+    {\n+      ecif.rvalue = alloca (cif->rtype->size);\n+    }\n+  else\n+    ecif.rvalue = rvalue;\n+\n+  switch (cif->abi)\n+    {\n+    case FFI_AIX:\n+      ffi_call_go_AIX(&ecif, -(long)cif->bytes, cif->flags, ecif.rvalue, fn,\n+\t\t      FFI_FN(ffi_prep_args), closure);\n+      break;\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+}\n+\n static void flush_icache(char *);\n static void flush_range(char *, int);\n \n@@ -1074,6 +1110,30 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   return FFI_OK;\n }\n \n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure* closure,\n+\t\t     ffi_cif* cif,\n+\t\t     void (*fun)(ffi_cif*, void*, void**, void*))\n+{\n+  switch (cif->abi)\n+    {\n+      case FFI_AIX:\n+\n+        FFI_ASSERT (cif->abi == FFI_AIX);\n+\n+        closure->tramp = (void *)ffi_go_closure_ASM;\n+        closure->cif = cif;\n+        closure->fun = fun;\n+        return FFI_OK;\n+      \n+      // For now, ffi_prep_go_closure is only implemented for AIX, not for Darwin\n+      default:\n+        return FFI_BAD_ABI;\n+        break;\n+    }\n+  return FFI_OK;\n+}\n+\n static void\n flush_icache(char *addr)\n {\n@@ -1108,15 +1168,21 @@ ffi_type *\n ffi_closure_helper_DARWIN (ffi_closure *, void *,\n \t\t\t   unsigned long *, ffi_dblfl *);\n \n+ffi_type *\n+ffi_go_closure_helper_DARWIN (ffi_go_closure*, void *,\n+\t\t\t      unsigned long *, ffi_dblfl *);\n+\n /* Basically the trampoline invokes ffi_closure_ASM, and on\n    entry, r11 holds the address of the closure.\n    After storing the registers that could possibly contain\n    parameters to be passed into the stack frame and setting\n    up space for a return value, ffi_closure_ASM invokes the\n    following helper function to do most of the work.  */\n \n-ffi_type *\n-ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n+static ffi_type *\n+ffi_closure_helper_common (ffi_cif* cif,\n+\t\t\t   void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t\t   void *user_data, void *rvalue,\n \t\t\t   unsigned long *pgr, ffi_dblfl *pfr)\n {\n   /* rvalue is the pointer to space for return value in closure assembly\n@@ -1134,14 +1200,12 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n   void **          avalue;\n   ffi_type **      arg_types;\n   long             i, avn;\n-  ffi_cif *        cif;\n   ffi_dblfl *      end_pfr = pfr + NUM_FPR_ARG_REGISTERS;\n   unsigned         size_al;\n #if defined(POWERPC_DARWIN64)\n   unsigned \t   fpsused = 0;\n #endif\n \n-  cif = closure->cif;\n   avalue = alloca (cif->nargs * sizeof(void *));\n \n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n@@ -1352,8 +1416,25 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n       i++;\n     }\n \n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+  (fun) (cif, rvalue, avalue, user_data);\n \n   /* Tell ffi_closure_ASM to perform return type promotions.  */\n   return cif->rtype;\n }\n+\n+ffi_type *\n+ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n+\t\t\t   unsigned long *pgr, ffi_dblfl *pfr)\n+{\n+  return ffi_closure_helper_common (closure->cif, closure->fun,\n+\t\t\t\t    closure->user_data, rvalue, pgr, pfr);\n+}\n+\n+ffi_type *\n+ffi_go_closure_helper_DARWIN (ffi_go_closure *closure, void *rvalue,\n+\t\t\t      unsigned long *pgr, ffi_dblfl *pfr)\n+{\n+  return ffi_closure_helper_common (closure->cif, closure->fun,\n+\t\t\t\t    closure, rvalue, pgr, pfr);\n+}\n+"}, {"sha": "90aa36b0fce48ec827c2eafae94ee68f7dcf2afd", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdc37805a6241c01991e37065187238934cee71/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=fbdc37805a6241c01991e37065187238934cee71", "patch": "@@ -142,6 +142,9 @@ typedef enum ffi_abi {\n # define FFI_TARGET_SPECIFIC_VARIADIC 1\n # define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs\n #endif\n+#if defined (POWERPC_AIX)\n+# define FFI_GO_CLOSURES 1\n+#endif\n \n /* ppc_closure.S and linux64_closure.S expect this.  */\n #define FFI_PPC_TYPE_LAST FFI_TYPE_POINTER"}]}