{"sha": "200674232e05d09888ff21965b0ed12c6f54f7ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAwNjc0MjMyZTA1ZDA5ODg4ZmYyMTk2NWIwZWQxMmM2ZjU0ZjdjYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-01-29T14:57:35Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-01-29T14:57:35Z"}, "message": "alloc_traits.h (allocator_traits::_S_allocate): Do not use varargs when argument could be non-POD.\n\n\t* include/bits/alloc_traits.h (allocator_traits::_S_allocate): Do\n\tnot use varargs when argument could be non-POD.\n\t(__alloctr_rebind_helper): Eliminate static const bool member by\n\tusing true_type and false_type.\n\t(allocator_traits::__allocate_helper): Likewise.\n\t(allocator_traits::__construct_helper): Likewise.\n\t(allocator_traits::__destroy_helper): Likewise.\n\t(allocator_traits::__maxsize_helper): Likewise.\n\t(allocator_traits::__select_helper): Likewise.\n\t* include/bits/ptr_traits.h (__ptrtr_rebind_helper): Likewise.\n\t* include/bits/stl_tree.h (_Rb_tree::operator=(const _Rb_tree&)):\n\tRemove redundant condition.\n\t* include/bits/stl_vector.h (vector::operator=(const vector&)):\n\tLikewise.\n\t(_Vector_impl::_M_allocate, _Vector_impl::_M_deallocate): Use\n\tindirection through __alloc_traits.\n\t* include/ext/alloc_traits.h (__allocator_always_compares_equal):\n\tEliminate static const bool members by using true_type and false_type.\n\t(__gnu_cxx::__alloc_traits::__is_custom_pointer): Optimize.\n\t* testsuite/util/testsuite_allocator.h (PointerBase): Define.\n\t* testsuite/20_util/allocator_traits/members/allocate_hint_nonpod.cc:\n\tNew.\n\t* testsuite/20_util/allocator_traits/requirements/typedefs2.cc: New.\n\nFrom-SVN: r207240", "tree": {"sha": "9e1fd6bd9e76ef396f73230c2bc16361ea341289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e1fd6bd9e76ef396f73230c2bc16361ea341289"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/200674232e05d09888ff21965b0ed12c6f54f7ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200674232e05d09888ff21965b0ed12c6f54f7ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200674232e05d09888ff21965b0ed12c6f54f7ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200674232e05d09888ff21965b0ed12c6f54f7ca/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77574c353464b38f98b7d69a5fb555b6888701a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77574c353464b38f98b7d69a5fb555b6888701a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77574c353464b38f98b7d69a5fb555b6888701a3"}], "stats": {"total": 530, "additions": 386, "deletions": 144}, "files": [{"sha": "9618c9eb275eeacac7c5a52ef6a848a779c456ec", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -1,3 +1,29 @@\n+2014-01-28  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/alloc_traits.h (allocator_traits::_S_allocate): Do\n+\tnot use varargs when argument could be non-POD.\n+\t(__alloctr_rebind_helper): Eliminate static const bool member by\n+\tusing true_type and false_type.\n+\t(allocator_traits::__allocate_helper): Likewise.\n+\t(allocator_traits::__construct_helper): Likewise.\n+\t(allocator_traits::__destroy_helper): Likewise.\n+\t(allocator_traits::__maxsize_helper): Likewise.\n+\t(allocator_traits::__select_helper): Likewise.\n+\t* include/bits/ptr_traits.h (__ptrtr_rebind_helper): Likewise.\n+\t* include/bits/stl_tree.h (_Rb_tree::operator=(const _Rb_tree&)):\n+\tRemove redundant condition.\n+\t* include/bits/stl_vector.h (vector::operator=(const vector&)):\n+\tLikewise.\n+\t(_Vector_impl::_M_allocate, _Vector_impl::_M_deallocate): Use\n+\tindirection through __alloc_traits.\n+\t* include/ext/alloc_traits.h (__allocator_always_compares_equal):\n+\tEliminate static const bool members by using true_type and false_type.\n+\t(__gnu_cxx::__alloc_traits::__is_custom_pointer): Optimize.\n+\t* testsuite/util/testsuite_allocator.h (PointerBase): Define.\n+\t* testsuite/20_util/allocator_traits/members/allocate_hint_nonpod.cc:\n+\tNew.\n+\t* testsuite/20_util/allocator_traits/requirements/typedefs2.cc: New.\n+\n 2014-01-28  Jonathan Wakely  <jwakely@redhat.com>\n \t    Kyle Lippincott  <spectral@google.com>\n "}, {"sha": "23fe8de0947e5e795a4ce1334cc18025f5acaaed", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 71, "deletions": 86, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -44,24 +44,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class __alloctr_rebind_helper\n     {\n       template<typename _Alloc2, typename _Tp2>\n-\tstatic constexpr bool\n-       \t_S_chk(typename _Alloc2::template rebind<_Tp2>::other*)\n-\t{ return true; }\n+\tstatic constexpr true_type\n+\t_S_chk(typename _Alloc2::template rebind<_Tp2>::other*);\n \n       template<typename, typename>\n-        static constexpr bool\n-       \t_S_chk(...)\n-       \t{ return false; }\n+\tstatic constexpr false_type\n+\t_S_chk(...);\n \n     public:\n-      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);\n+      using __type = decltype(_S_chk<_Alloc, _Tp>(nullptr));\n     };\n \n-  template<typename _Alloc, typename _Tp>\n-    const bool __alloctr_rebind_helper<_Alloc, _Tp>::__value;\n-\n   template<typename _Alloc, typename _Tp,\n-           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>\n+\t   bool = __alloctr_rebind_helper<_Alloc, _Tp>::__type::value>\n     struct __alloctr_rebind;\n \n   template<typename _Alloc, typename _Tp>\n@@ -71,7 +66,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<template<typename, typename...> class _Alloc, typename _Tp,\n-            typename _Up, typename... _Args>\n+\t   typename _Up, typename... _Args>\n     struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>\n     {\n       typedef _Alloc<_Tp, _Args...> __type;\n@@ -140,7 +135,7 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(const_void_pointer,\n       typedef __const_void_pointer const_void_pointer;\n \n _GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,\n-                              typename pointer_traits<pointer>::difference_type)\n+\t\t\t      typename pointer_traits<pointer>::difference_type)\n \n       /**\n        * @brief   The allocator's difference type\n@@ -151,7 +146,7 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,\n       typedef __difference_type difference_type;\n \n _GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,\n-                              typename make_unsigned<difference_type>::type)\n+\t\t\t      typename make_unsigned<difference_type>::type)\n \n       /**\n        * @brief   The allocator's size type\n@@ -162,7 +157,7 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,\n       typedef __size_type size_type;\n \n _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,\n-                              false_type)\n+\t\t\t      false_type)\n \n       /**\n        * @brief   How the allocator is propagated on copy assignment\n@@ -171,10 +166,10 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,\n        * otherwise @c false_type\n       */\n       typedef __propagate_on_container_copy_assignment\n-       \tpropagate_on_container_copy_assignment;\n+\tpropagate_on_container_copy_assignment;\n \n _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,\n-                              false_type)\n+\t\t\t      false_type)\n \n       /**\n        * @brief   How the allocator is propagated on move assignment\n@@ -183,10 +178,10 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,\n        * otherwise @c false_type\n       */\n       typedef __propagate_on_container_move_assignment\n-       \tpropagate_on_container_move_assignment;\n+\tpropagate_on_container_move_assignment;\n \n _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n-                              false_type)\n+\t\t\t      false_type)\n \n       /**\n        * @brief   How the allocator is propagated on swap\n@@ -199,9 +194,9 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n #undef _GLIBCXX_ALLOC_TR_NESTED_TYPE\n \n       template<typename _Tp>\n-        using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;\n+\tusing rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;\n       template<typename _Tp>\n-        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n+\tusing rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n \n     private:\n       template<typename _Alloc2>\n@@ -216,20 +211,22 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n \t  template<typename>\n \t    static false_type __test(...);\n \n-\t  typedef decltype(__test<_Alloc>(0)) type;\n-\t  static const bool value = type::value;\n+\t  using type = decltype(__test<_Alloc>(0));\n \t};\n \n       template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<__allocate_helper<_Alloc2>::value, pointer>::type\n-       \t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)\n+\tusing __has_allocate = typename __allocate_helper<_Alloc2>::type;\n+\n+      template<typename _Alloc2,\n+\t       typename = _Require<__has_allocate<_Alloc2>>>\n+\tstatic pointer\n+\t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)\n \t{ return __a.allocate(__n, __hint); }\n \n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<!__allocate_helper<_Alloc2>::value, pointer>::type\n-       \t_S_allocate(_Alloc2& __a, size_type __n, ...)\n+      template<typename _Alloc2, typename _UnusedHint,\n+\t       typename = _Require<__not_<__has_allocate<_Alloc2>>>>\n+\tstatic pointer\n+\t_S_allocate(_Alloc2& __a, size_type __n, _UnusedHint)\n \t{ return __a.allocate(__n); }\n \n       template<typename _Tp, typename... _Args>\n@@ -243,21 +240,23 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n \t  template<typename>\n \t    static false_type __test(...);\n \n-\t  typedef decltype(__test<_Alloc>(0)) type;\n-\t  static const bool value = type::value;\n+\t  using type = decltype(__test<_Alloc>(0));\n \t};\n \n       template<typename _Tp, typename... _Args>\n-\tstatic typename\n-       \tenable_if<__construct_helper<_Tp, _Args...>::value, void>::type\n-       \t_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n+\tusing __has_construct\n+\t  = typename __construct_helper<_Tp, _Args...>::type;\n+\n+      template<typename _Tp, typename... _Args>\n+\tstatic _Require<__has_construct<_Tp, _Args...>>\n+\t_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n \t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n \n       template<typename _Tp, typename... _Args>\n-\tstatic typename\n-\tenable_if<__and_<__not_<__construct_helper<_Tp, _Args...>>,\n-\t\t\t is_constructible<_Tp, _Args...>>::value, void>::type\n-       \t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n+\tstatic\n+\t_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,\n+\t\t\t       is_constructible<_Tp, _Args...>>>\n+\t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n \t{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n \n       template<typename _Tp>\n@@ -271,18 +270,20 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n \t  template<typename>\n \t    static false_type __test(...);\n \n-\t  typedef decltype(__test<_Alloc>(0)) type;\n-\t  static const bool value = type::value;\n+\t  using type = decltype(__test<_Alloc>(0));\n \t};\n \n       template<typename _Tp>\n-\tstatic typename enable_if<__destroy_helper<_Tp>::value, void>::type\n-       \t_S_destroy(_Alloc& __a, _Tp* __p)\n+\tusing __has_destroy = typename __destroy_helper<_Tp>::type;\n+\n+      template<typename _Tp>\n+\tstatic _Require<__has_destroy<_Tp>>\n+\t_S_destroy(_Alloc& __a, _Tp* __p)\n \t{ __a.destroy(__p); }\n \n       template<typename _Tp>\n-\tstatic typename enable_if<!__destroy_helper<_Tp>::value, void>::type\n-       \t_S_destroy(_Alloc&, _Tp* __p)\n+\tstatic _Require<__not_<__has_destroy<_Tp>>>\n+\t_S_destroy(_Alloc&, _Tp* __p)\n \t{ __p->~_Tp(); }\n \n       template<typename _Alloc2>\n@@ -295,20 +296,22 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n \t  template<typename>\n \t    static false_type __test(...);\n \n-\t  typedef decltype(__test<_Alloc2>(0)) type;\n-\t  static const bool value = type::value;\n+\t  using type = decltype(__test<_Alloc2>(0));\n \t};\n \n       template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<__maxsize_helper<_Alloc2>::value, size_type>::type\n-       \t_S_max_size(_Alloc2& __a)\n+\tusing __has_max_size = typename __maxsize_helper<_Alloc2>::type;\n+\n+      template<typename _Alloc2,\n+\t       typename = _Require<__has_max_size<_Alloc2>>>\n+\tstatic size_type\n+\t_S_max_size(_Alloc2& __a, int)\n \t{ return __a.max_size(); }\n \n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<!__maxsize_helper<_Alloc2>::value, size_type>::type\n-\t_S_max_size(_Alloc2&)\n+      template<typename _Alloc2,\n+\t       typename = _Require<__not_<__has_max_size<_Alloc2>>>>\n+\tstatic size_type\n+\t_S_max_size(_Alloc2&, ...)\n \t{ return __gnu_cxx::__numeric_traits<size_type>::__max; }\n \n       template<typename _Alloc2>\n@@ -322,19 +325,22 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n \t  template<typename>\n \t    static false_type __test(...);\n \n-\t  typedef decltype(__test<_Alloc2>(0)) type;\n-\t  static const bool value = type::value;\n+\t  using type = decltype(__test<_Alloc2>(0));\n \t};\n+\n       template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<__select_helper<_Alloc2>::value, _Alloc2>::type\n-       \t_S_select(_Alloc2& __a)\n+\tusing __has_soccc = typename __select_helper<_Alloc2>::type;\n+\n+      template<typename _Alloc2,\n+\t       typename = _Require<__has_soccc<_Alloc2>>>\n+\tstatic _Alloc2\n+\t_S_select(_Alloc2& __a, int)\n \t{ return __a.select_on_container_copy_construction(); }\n \n-      template<typename _Alloc2>\n-\tstatic typename\n-       \tenable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type\n-       \t_S_select(_Alloc2& __a)\n+      template<typename _Alloc2,\n+\t       typename = _Require<__not_<__has_soccc<_Alloc2>>>>\n+\tstatic _Alloc2\n+\t_S_select(_Alloc2& __a, ...)\n \t{ return __a; }\n \n     public:\n@@ -413,7 +419,7 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n        *  otherwise returns @c numeric_limits<size_type>::max()\n       */\n       static size_type max_size(const _Alloc& __a) noexcept\n-      { return _S_max_size(__a); }\n+      { return _S_max_size(__a, 0); }\n \n       /**\n        *  @brief  Obtain an allocator to use when copying a container.\n@@ -425,30 +431,9 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n       */\n       static _Alloc\n       select_on_container_copy_construction(const _Alloc& __rhs)\n-      { return _S_select(__rhs); }\n+      { return _S_select(__rhs, 0); }\n     };\n \n-  template<typename _Alloc>\n-  template<typename _Alloc2>\n-    const bool allocator_traits<_Alloc>::__allocate_helper<_Alloc2>::value;\n-\n-  template<typename _Alloc>\n-  template<typename _Tp, typename... _Args>\n-    const bool\n-    allocator_traits<_Alloc>::__construct_helper<_Tp, _Args...>::value;\n-\n-  template<typename _Alloc>\n-  template<typename _Tp>\n-    const bool allocator_traits<_Alloc>::__destroy_helper<_Tp>::value;\n-\n-  template<typename _Alloc>\n-  template<typename _Alloc2>\n-    const bool allocator_traits<_Alloc>::__maxsize_helper<_Alloc2>::value;\n-\n-  template<typename _Alloc>\n-  template<typename _Alloc2>\n-    const bool allocator_traits<_Alloc>::__select_helper<_Alloc2>::value;\n-\n   template<typename _Alloc>\n     inline void\n     __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)"}, {"sha": "94995c8fb2eeaf6858ca032119efe738687178fa", "filename": "libstdc++-v3/include/bits/ptr_traits.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -73,24 +73,19 @@ _GLIBCXX_HAS_NESTED_TYPE(difference_type)\n     class __ptrtr_rebind_helper\n     {\n       template<typename _Ptr2, typename _Up2>\n-\tstatic constexpr bool\n-       \t_S_chk(typename _Ptr2::template rebind<_Up2>*)\n-       \t{ return true; }\n+\tstatic constexpr true_type\n+\t_S_chk(typename _Ptr2::template rebind<_Up2>*);\n \n       template<typename, typename>\n-        static constexpr bool\n-       \t_S_chk(...)\n-       \t{ return false; }\n+\tstatic constexpr false_type\n+\t_S_chk(...);\n \n     public:\n-      static const bool __value = _S_chk<_Ptr, _Up>(nullptr);\n+      using __type = decltype(_S_chk<_Ptr, _Up>(nullptr));\n     };\n \n-  template<typename _Ptr, typename _Up>\n-    const bool __ptrtr_rebind_helper<_Ptr, _Up>::__value;\n-\n   template<typename _Tp, typename _Up,\n-           bool = __ptrtr_rebind_helper<_Tp, _Up>::__value>\n+           bool = __ptrtr_rebind_helper<_Tp, _Up>::__type::value>\n     struct __ptrtr_rebind;\n \n   template<typename _Tp, typename _Up>"}, {"sha": "4bc3c602c2008c9188e4a86dff61943422abb0e4", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -1080,9 +1080,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  clear();\n \t  if (__x._M_root() != 0)\n \t    _M_move_data(__x, std::true_type());\n-\t  if (_Alloc_traits::_S_propagate_on_move_assign())\n-\t    std::__alloc_on_move(_M_get_Node_allocator(),\n-\t\t\t\t __x._M_get_Node_allocator());\n+\t  std::__alloc_on_move(_M_get_Node_allocator(),\n+\t\t\t       __x._M_get_Node_allocator());\n \t  return true;\n \t}\n       return false;"}, {"sha": "98ac708e8f16ee9ad452c279c484380ae3f5f521", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -165,13 +165,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       pointer\n       _M_allocate(size_t __n)\n-      { return __n != 0 ? _M_impl.allocate(__n) : 0; }\n+      {\n+\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n+\treturn __n != 0 ? _Tr::allocate(_M_impl, __n) : 0;\n+      }\n \n       void\n       _M_deallocate(pointer __p, size_t __n)\n       {\n+\ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n \tif (__p)\n-\t  _M_impl.deallocate(__p, __n);\n+\t  _Tr::deallocate(_M_impl, __p, __n);\n       }\n \n     private:\n@@ -1446,9 +1450,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tvector __tmp(get_allocator());\n \tthis->_M_impl._M_swap_data(__tmp._M_impl);\n \tthis->_M_impl._M_swap_data(__x._M_impl);\n-\tif (_Alloc_traits::_S_propagate_on_move_assign())\n-\t  std::__alloc_on_move(_M_get_Tp_allocator(),\n-\t\t\t       __x._M_get_Tp_allocator());\n+\tstd::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());\n       }\n \n       // Do move assignment when it might not be possible to move source"}, {"sha": "14fbc4359ec9f834e884767326a9e34ff3df3582", "filename": "libstdc++-v3/include/ext/alloc_traits.h", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Falloc_traits.h?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -44,73 +44,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #if __cplusplus >= 201103L\n   template<typename _Alloc>\n-    struct __allocator_always_compares_equal\n-    { static const bool value = false; };\n-\n-  template<typename _Alloc>\n-    const bool __allocator_always_compares_equal<_Alloc>::value;\n+    struct __allocator_always_compares_equal : std::false_type { };\n \n   template<typename _Tp>\n     struct __allocator_always_compares_equal<std::allocator<_Tp>>\n-    { static const bool value = true; };\n-\n-  template<typename _Tp>\n-    const bool __allocator_always_compares_equal<std::allocator<_Tp>>::value;\n+    : std::true_type { };\n \n   template<typename, typename> struct array_allocator;\n \n   template<typename _Tp, typename _Array>\n     struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>\n-    { static const bool value = true; };\n-\n-  template<typename _Tp, typename _Array>\n-    const bool\n-    __allocator_always_compares_equal<array_allocator<_Tp, _Array>>::value;\n+    : std::true_type { };\n \n   template<typename> struct bitmap_allocator;\n \n   template<typename _Tp>\n     struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>\n-    { static const bool value = true; };\n-\n-  template<typename _Tp>\n-    const bool __allocator_always_compares_equal<bitmap_allocator<_Tp>>::value;\n+    : std::true_type { };\n \n   template<typename> struct malloc_allocator;\n \n   template<typename _Tp>\n     struct __allocator_always_compares_equal<malloc_allocator<_Tp>>\n-    { static const bool value = true; };\n-\n-  template<typename _Tp>\n-    const bool __allocator_always_compares_equal<malloc_allocator<_Tp>>::value;\n+    : std::true_type { };\n \n   template<typename> struct mt_allocator;\n \n   template<typename _Tp>\n     struct __allocator_always_compares_equal<mt_allocator<_Tp>>\n-    { static const bool value = true; };\n-\n-  template<typename _Tp>\n-    const bool __allocator_always_compares_equal<mt_allocator<_Tp>>::value;\n+    : std::true_type { };\n \n   template<typename> struct new_allocator;\n \n   template<typename _Tp>\n     struct __allocator_always_compares_equal<new_allocator<_Tp>>\n-    { static const bool value = true; };\n-\n-  template<typename _Tp>\n-    const bool __allocator_always_compares_equal<new_allocator<_Tp>>::value;\n+    : std::true_type { };\n \n   template<typename> struct pool_allocator;\n \n   template<typename _Tp>\n     struct __allocator_always_compares_equal<pool_allocator<_Tp>>\n-    { static const bool value = true; };\n-\n-  template<typename _Tp>\n-    const bool __allocator_always_compares_equal<pool_allocator<_Tp>>::value;\n+    : std::true_type { };\n #endif\n \n /**\n@@ -131,7 +105,7 @@ template<typename _Alloc>\n     typedef typename _Base_type::const_pointer      const_pointer;\n     typedef typename _Base_type::size_type          size_type;\n     typedef typename _Base_type::difference_type    difference_type;\n-    // C++0x allocators do not define reference or const_reference\n+    // C++11 allocators do not define reference or const_reference\n     typedef value_type&                             reference;\n     typedef const value_type&                       const_reference;\n     using _Base_type::allocate;\n@@ -142,10 +116,9 @@ template<typename _Alloc>\n \n   private:\n     template<typename _Ptr>\n-      struct __is_custom_pointer\n-      : std::integral_constant<bool, std::is_same<pointer, _Ptr>::value\n-                                     && !std::is_pointer<_Ptr>::value>\n-      { };\n+      using __is_custom_pointer\n+\t= std::__and_<std::is_same<pointer, _Ptr>,\n+\t\t      std::__not_<std::is_pointer<_Ptr>>>;\n \n   public:\n     // overload construct for non-standard pointer types"}, {"sha": "b5883dcccce65a70e85df3f5c00a1e9eb15d5ccd", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/allocate_hint_nonpod.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fallocate_hint_nonpod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fallocate_hint_nonpod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fallocate_hint_nonpod.cc?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_allocator.h>\n+\n+// User-defined pointer type with non-trivial destructor.\n+template<typename T>\n+struct Pointer : __gnu_test::PointerBase<Pointer<T>, T>\n+{\n+  using __gnu_test::PointerBase<Pointer<T>, T>::PointerBase;\n+\n+  ~Pointer() { /* non-trivial */ }\n+};\n+\n+// Minimal allocator with user-defined pointer type.\n+template<typename T>\n+struct Alloc\n+{\n+  typedef T value_type;\n+  typedef Pointer<T> pointer;\n+\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U>&) { }\n+\n+  pointer allocate(std::size_t n)  // does not take a hint\n+  { return pointer(std::allocator<T>().allocate(n)); }\n+\n+  void deallocate(pointer p, std::size_t n)\n+  { std::allocator<T>().deallocate(p.value, n); }\n+};\n+\n+template<typename T>\n+bool operator==(Alloc<T> l, Alloc<T> r) { return true; }\n+\n+template<typename T>\n+bool operator!=(Alloc<T> l, Alloc<T> r) { return false; }\n+\n+void test01()\n+{\n+  typedef std::allocator_traits<Alloc<int>> traits_type;\n+  traits_type::allocator_type a;\n+  traits_type::const_void_pointer v;\n+  traits_type::pointer p = traits_type::allocate(a, 1, v);\n+  traits_type::deallocate(a, p, 1);\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "04521a269c895a3b4af85e4549ae7f6bb5c52950", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/requirements/typedefs2.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Ftypedefs2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Ftypedefs2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Ftypedefs2.cc?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -0,0 +1,93 @@\n+// { dg-options \"-std=gnu++11\" }\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_allocator.h>\n+\n+// { dg-do compile }\n+\n+template<typename T>\n+struct ptr\n+{\n+  ptr() = default;\n+  template<typename U>\n+    ptr(ptr<U> const& p) { }\n+};\n+\n+// This doesn't meet the allocator requirements, it's only to check\n+// that allocator_traits finds the right nested types.\n+template<typename T>\n+struct alloc\n+{\n+  typedef T value_type;\n+\n+  typedef ptr<T> pointer;\n+  typedef ptr<const T> const_pointer;\n+  typedef ptr<void> void_pointer;\n+  typedef ptr<const void> const_void_pointer;\n+  typedef int difference_type;\n+  typedef int size_type;\n+\n+  typedef std::false_type propagate_on_container_copy_assignment;\n+  typedef std::false_type propagate_on_container_move_assignment;\n+  typedef std::false_type propagate_on_container_swap;\n+};\n+\n+typedef alloc<int> alloc_type;\n+typedef std::allocator_traits<alloc_type> traits;\n+\n+using std::is_same;\n+\n+static_assert( is_same<traits::pointer, alloc_type::pointer>::value,\n+               \"pointer\" );\n+\n+static_assert( is_same<traits::const_pointer,\n+                       alloc_type::const_pointer>::value,\n+               \"const_pointer\" );\n+\n+static_assert( is_same<traits::void_pointer, alloc_type::void_pointer>::value,\n+               \"void_pointer\" );\n+\n+static_assert( is_same<traits::const_void_pointer,\n+                       alloc_type::const_void_pointer>::value,\n+               \"const_void_pointer\");\n+\n+static_assert( is_same<traits::difference_type,\n+                       alloc_type::difference_type>::value,\n+               \"difference_type\" );\n+\n+static_assert( is_same<traits::size_type, alloc_type::size_type>::value,\n+               \"size_type\" );\n+\n+static_assert( is_same<traits::size_type, alloc_type::size_type>::value,\n+               \"size_type\" );\n+\n+static_assert( is_same<traits::propagate_on_container_copy_assignment,\n+                       alloc_type::propagate_on_container_copy_assignment\n+                      >::value,\n+               \"propagate_on_container_copy_assignment\" );\n+\n+static_assert( is_same<traits::propagate_on_container_move_assignment,\n+                       alloc_type::propagate_on_container_move_assignment\n+                      >::value,\n+               \"propagate_on_container_move_assignment\" );\n+\n+static_assert( is_same<traits::propagate_on_container_swap,\n+                       alloc_type::propagate_on_container_swap>::value,\n+               \"propagate_on_container_swap\" );"}, {"sha": "822a025f4fa25428cf2b274074e57506b032227e", "filename": "libstdc++-v3/testsuite/util/testsuite_allocator.h", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200674232e05d09888ff21965b0ed12c6f54f7ca/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h?ref=200674232e05d09888ff21965b0ed12c6f54f7ca", "patch": "@@ -517,6 +517,106 @@ namespace __gnu_test\n       void deallocate(pointer p, std::size_t n)\n       { std::allocator<Tp>::deallocate(std::addressof(*p), n); }\n     };\n+\n+  // Utility for use as CRTP base class of custom pointer types\n+  template<typename Derived, typename T>\n+    struct PointerBase\n+    {\n+      typedef T element_type;\n+\n+      // typedefs for iterator_traits\n+      typedef T value_type;\n+      typedef std::ptrdiff_t difference_type;\n+      typedef std::random_access_iterator_tag iterator_category;\n+      typedef Derived pointer;\n+      typedef T& reference;\n+\n+      T* value;\n+\n+      explicit PointerBase(T* p = nullptr) : value(p) { }\n+\n+      template<typename D, typename U,\n+\t       typename = decltype(static_cast<T*>(std::declval<U*>()))>\n+\tPointerBase(const PointerBase<D, U>& p) : value(p.value) { }\n+\n+      T& operator*() const { return *value; }\n+      T* operator->() const { return value; }\n+\n+      Derived& operator++() { ++value; return derived(); }\n+      Derived operator++(int) { Derived tmp(derived()); ++value; return tmp; }\n+      Derived& operator--() { --value; return derived(); }\n+      Derived operator--(int) { Derived tmp(derived()); --value; return tmp; }\n+\n+      Derived& operator+=(difference_type n) { value += n; return derived(); }\n+      Derived& operator-=(difference_type n) { value -= n; return derived(); }\n+\n+      explicit operator bool() const { return value != nullptr; }\n+\n+      Derived\n+      operator+(difference_type n) const\n+      {\n+\tDerived p(derived());\n+\treturn p += n;\n+      }\n+\n+      Derived\n+      operator-(difference_type n) const\n+      {\n+\tDerived p(derived());\n+\treturn p -= n;\n+      }\n+\n+    private:\n+      Derived& derived() { return static_cast<Derived&>(*this); }\n+    };\n+\n+    template<typename D, typename T>\n+    std::ptrdiff_t operator-(PointerBase<D, T> l, PointerBase<D, T> r)\n+    { return l.value - r.value; }\n+\n+    template<typename D, typename T>\n+    bool operator==(PointerBase<D, T> l, PointerBase<D, T> r)\n+    { return l.value == r.value; }\n+\n+    template<typename D, typename T>\n+    bool operator!=(PointerBase<D, T> l, PointerBase<D, T> r)\n+    { return l.value != r.value; }\n+\n+    // implementation for void specializations\n+    template<typename T>\n+    struct PointerBase_void\n+    {\n+      typedef T element_type;\n+\n+      // typedefs for iterator_traits\n+      typedef T value_type;\n+      typedef std::ptrdiff_t difference_type;\n+      typedef std::random_access_iterator_tag iterator_category;\n+\n+      T* value;\n+\n+      explicit PointerBase_void(T* p = nullptr) : value(p) { }\n+\n+      template<typename D, typename U,\n+\t       typename = decltype(static_cast<T*>(std::declval<U*>()))>\n+\tPointerBase_void(const PointerBase<D, U>& p) : value(p.value) { }\n+\n+      explicit operator bool() const { return value != nullptr; }\n+    };\n+\n+    template<typename Derived>\n+    struct PointerBase<Derived, void> : PointerBase_void<void>\n+    {\n+      using PointerBase_void::PointerBase_void;\n+      typedef Derived pointer;\n+    };\n+\n+    template<typename Derived>\n+    struct PointerBase<Derived, const void> : PointerBase_void<const void>\n+    {\n+      using PointerBase_void::PointerBase_void;\n+      typedef Derived pointer;\n+    };\n #endif\n \n } // namespace __gnu_test"}]}