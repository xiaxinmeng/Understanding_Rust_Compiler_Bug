{"sha": "22e89283f7807e9c1d17c5f817f2dca13bb544c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlODkyODNmNzgwN2U5YzFkMTdjNWY4MTdmMmRjYTEzYmI1NDRjMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T08:17:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T08:17:51Z"}, "message": "[multiple changes]\n\n2015-05-26  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Aggregate, Resolve_Extension_Aggregate):\n\tCode cleanup.\n\t* sem_ch3.adb (Build_Derived_Record_Type,\n\tRecord_Type_Declaration): Code cleanup.\n\t* sem_ch4.adb (Has_Arbitrary_Evaluation_Order,\n\tStop_Subtree_Climbind): Tables which speed up the identification\n\tof dangerous calls to Ada 2012 functions with writable actuals\n\t(AI05-0144).\n\t(Analyze_Arithmetic_Op, Analyze_Call, Analyze_Comparison_Op,\n\tAnalyze_Equality_Op, Analyze_Logical_Op, Analyze_Membership_Op,\n\tAnalyze_Range): Code cleanup.\n\t(Is_Arbitrary_Evaluation_Order_Construct): Removed.\n\t(Check_Writable_Actuals): Code cleanup using the added tables.\n\t* sem_util.adb (Check_Function_Writable_Actuals): Return\n\timmediately if the node does not have the flag Check_Actuals\n\tset to True.\n\n2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch6.adb (Add_Call_By_Copy_Code): Remove restrictive\n\tcondition in the detection of the effects of Remove_Side_Effects.\n\t* exp_util.ads (Remove_Side_Effects): Add general and historical note.\n\t* exp_util.adb (Is_Name_Reference): New predicate.\n\t(Remove_Side_Effects): Use it in lieu of Is_Object_Reference\n\tin order to decide whether to use the renaming to capture the\n\tside effects of the subexpression.\n\t(Side_Effect_Free): Remove obsolete test.\n\nFrom-SVN: r223668", "tree": {"sha": "ddb06711d4fae03d8c6bdc9bb5a2c77e1b2f751d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddb06711d4fae03d8c6bdc9bb5a2c77e1b2f751d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22e89283f7807e9c1d17c5f817f2dca13bb544c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e89283f7807e9c1d17c5f817f2dca13bb544c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e89283f7807e9c1d17c5f817f2dca13bb544c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e89283f7807e9c1d17c5f817f2dca13bb544c1/comments", "author": null, "committer": null, "parents": [{"sha": "c859345327b2c2858ae8a120d2b714d928b43130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c859345327b2c2858ae8a120d2b714d928b43130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c859345327b2c2858ae8a120d2b714d928b43130"}], "stats": {"total": 440, "additions": 268, "deletions": 172}, "files": [{"sha": "396f789b75614dbaf2d7eb431056bbfe648baa5a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -1,3 +1,33 @@\n+2015-05-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Aggregate, Resolve_Extension_Aggregate):\n+\tCode cleanup.\n+\t* sem_ch3.adb (Build_Derived_Record_Type,\n+\tRecord_Type_Declaration): Code cleanup.\n+\t* sem_ch4.adb (Has_Arbitrary_Evaluation_Order,\n+\tStop_Subtree_Climbind): Tables which speed up the identification\n+\tof dangerous calls to Ada 2012 functions with writable actuals\n+\t(AI05-0144).\n+\t(Analyze_Arithmetic_Op, Analyze_Call, Analyze_Comparison_Op,\n+\tAnalyze_Equality_Op, Analyze_Logical_Op, Analyze_Membership_Op,\n+\tAnalyze_Range): Code cleanup.\n+\t(Is_Arbitrary_Evaluation_Order_Construct): Removed.\n+\t(Check_Writable_Actuals): Code cleanup using the added tables.\n+\t* sem_util.adb (Check_Function_Writable_Actuals): Return\n+\timmediately if the node does not have the flag Check_Actuals\n+\tset to True.\n+\n+2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch6.adb (Add_Call_By_Copy_Code): Remove restrictive\n+\tcondition in the detection of the effects of Remove_Side_Effects.\n+\t* exp_util.ads (Remove_Side_Effects): Add general and historical note.\n+\t* exp_util.adb (Is_Name_Reference): New predicate.\n+\t(Remove_Side_Effects): Use it in lieu of Is_Object_Reference\n+\tin order to decide whether to use the renaming to capture the\n+\tside effects of the subexpression.\n+\t(Side_Effect_Free): Remove obsolete test.\n+\n 2015-05-26  Robert Dewar  <dewar@adacore.com>\n \n \t* aspects.ads, aspects.adb: Add aspect Disable_Controlled."}, {"sha": "78bd94cdc865d9536d284fbf64b4532c9b2729ec", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -1257,7 +1257,6 @@ package body Exp_Ch6 is\n             begin\n                if Is_Renaming_Of_Object (Var)\n                  and then Nkind (Renamed_Object (Var)) = N_Selected_Component\n-                 and then Is_Entity_Name (Prefix (Renamed_Object (Var)))\n                  and then Nkind (Original_Node (Prefix (Renamed_Object (Var))))\n                    = N_Indexed_Component\n                  and then"}, {"sha": "d0c5d4ee05592a0f384c45143fcc270b2304ca69", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 91, "deletions": 74, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -7428,6 +7428,12 @@ package body Exp_Util is\n       --  is present (xxx is taken from the Chars field of Related_Nod),\n       --  otherwise it generates an internal temporary.\n \n+      function Is_Name_Reference (N : Node_Id) return Boolean;\n+      --  Determine if the tree referenced by N represents a name. This is\n+      --  similar to Is_Object_Reference but returns true only if N can be\n+      --  renamed without the need for a temporary, the typical example of\n+      --  an object not in this category being a function call.\n+\n       ---------------------\n       -- Build_Temporary --\n       ---------------------\n@@ -7458,6 +7464,58 @@ package body Exp_Util is\n          end if;\n       end Build_Temporary;\n \n+      -----------------------\n+      -- Is_Name_Reference --\n+      -----------------------\n+\n+      function Is_Name_Reference (N : Node_Id) return Boolean is\n+      begin\n+         if Is_Entity_Name (N) then\n+            return Present (Entity (N)) and then Is_Object (Entity (N));\n+         end if;\n+\n+         case Nkind (N) is\n+            when N_Indexed_Component | N_Slice =>\n+               return\n+                 Is_Name_Reference (Prefix (N))\n+                   or else Is_Access_Type (Etype (Prefix (N)));\n+\n+            --  Attributes 'Input, 'Old and 'Result produce objects\n+\n+            when N_Attribute_Reference =>\n+               return\n+                 Nam_In\n+                   (Attribute_Name (N), Name_Input, Name_Old, Name_Result);\n+\n+            when N_Selected_Component =>\n+               return\n+                 Is_Name_Reference (Selector_Name (N))\n+                   and then\n+                     (Is_Name_Reference (Prefix (N))\n+                       or else Is_Access_Type (Etype (Prefix (N))));\n+\n+            when N_Explicit_Dereference =>\n+               return True;\n+\n+            --  A view conversion of a tagged name is a name reference\n+\n+            when N_Type_Conversion =>\n+               return Is_Tagged_Type (Etype (Subtype_Mark (N)))\n+                 and then Is_Tagged_Type (Etype (Expression (N)))\n+                 and then Is_Name_Reference (Expression (N));\n+\n+            --  An unchecked type conversion is considered to be a name if\n+            --  the operand is a name (this construction arises only as a\n+            --  result of expansion activities).\n+\n+            when N_Unchecked_Type_Conversion =>\n+               return Is_Name_Reference (Expression (N));\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end Is_Name_Reference;\n+\n       --  Local variables\n \n       Loc          : constant Source_Ptr      := Sloc (Exp);\n@@ -7498,34 +7556,25 @@ package body Exp_Util is\n          return;\n       end if;\n \n-      --  The remaining procesaing is done with all checks suppressed\n+      --  The remaining processing is done with all checks suppressed\n \n       --  Note: from now on, don't use return statements, instead do a goto\n       --  Leave, to ensure that we properly restore Scope_Suppress.Suppress.\n \n       Scope_Suppress.Suppress := (others => True);\n \n-      --  If it is a scalar type and we need to capture the value, just make\n-      --  a copy. Likewise for a function call, an attribute reference, a\n-      --  conditional expression, an allocator, or an operator. And if we have\n-      --  a volatile reference and Name_Req is not set (see comments for\n-      --  Side_Effect_Free).\n+      --  If it is an elementary type and we need to capture the value, just\n+      --  make a constant. Likewise if this is not a name reference, except\n+      --  for a type conversion because we would enter an infinite recursion\n+      --  with Checks.Apply_Predicate_Check if the target type has predicates.\n+      --  And type conversions need a specific treatment anyway, see below.\n+      --  Also do it if we have a volatile reference and Name_Req is not set\n+      --  (see comments for Side_Effect_Free).\n \n       if Is_Elementary_Type (Exp_Type)\n-\n-        --  Note: this test is rather mysterious??? Why can't we just test ONLY\n-        --  Is_Elementary_Type and be done with it. If we try that approach, we\n-        --  get some failures (infinite recursions) from the Duplicate_Subexpr\n-        --  call at the end of Checks.Apply_Predicate_Check. To be\n-        --  investigated ???\n-\n         and then (Variable_Ref\n-                   or else Nkind_In (Exp, N_Attribute_Reference,\n-                                          N_Allocator,\n-                                          N_Case_Expression,\n-                                          N_If_Expression,\n-                                          N_Function_Call)\n-                   or else Nkind (Exp) in N_Op\n+                   or else (not Is_Name_Reference (Exp)\n+                             and then Nkind (Exp) /= N_Type_Conversion)\n                    or else (not Name_Req\n                              and then Is_Volatile_Reference (Exp)))\n       then\n@@ -7645,20 +7694,13 @@ package body Exp_Util is\n             Insert_Action (Exp, E);\n          end if;\n \n-      --  For expressions that denote objects, we can use a renaming scheme.\n+      --  For expressions that denote names, we can use a renaming scheme.\n       --  This is needed for correctness in the case of a volatile object of\n       --  a non-volatile type because the Make_Reference call of the \"default\"\n       --  approach would generate an illegal access value (an access value\n       --  cannot designate such an object - see Analyze_Reference).\n \n-      elsif Is_Object_Reference (Exp)\n-        and then Nkind (Exp) /= N_Function_Call\n-\n-        --  In Ada 2012 a qualified expression is an object, but for purposes\n-        --  of removing side effects it still need to be transformed into a\n-        --  separate declaration, particularly in the case of an aggregate.\n-\n-        and then Nkind (Exp) /= N_Qualified_Expression\n+      elsif Is_Name_Reference (Exp)\n \n         --  We skip using this scheme if we have an object of a volatile\n         --  type and we do not have Name_Req set true (see comments for\n@@ -7667,37 +7709,13 @@ package body Exp_Util is\n         and then (Name_Req or else not Treat_As_Volatile (Exp_Type))\n       then\n          Def_Id := Build_Temporary (Loc, 'R', Exp);\n+         Res := New_Occurrence_Of (Def_Id, Loc);\n \n-         if Nkind (Exp) = N_Selected_Component\n-           and then Nkind (Prefix (Exp)) = N_Function_Call\n-           and then Is_Array_Type (Exp_Type)\n-         then\n-            --  Avoid generating a variable-sized temporary, by generating\n-            --  the renaming declaration just for the function call. The\n-            --  transformation could be refined to apply only when the array\n-            --  component is constrained by a discriminant???\n-\n-            Res :=\n-              Make_Selected_Component (Loc,\n-                Prefix => New_Occurrence_Of (Def_Id, Loc),\n-                Selector_Name => Selector_Name (Exp));\n-\n-            Insert_Action (Exp,\n-              Make_Object_Renaming_Declaration (Loc,\n-                Defining_Identifier => Def_Id,\n-                Subtype_Mark        =>\n-                  New_Occurrence_Of (Base_Type (Etype (Prefix (Exp))), Loc),\n-                Name                => Relocate_Node (Prefix (Exp))));\n-\n-         else\n-            Res := New_Occurrence_Of (Def_Id, Loc);\n-\n-            Insert_Action (Exp,\n-              Make_Object_Renaming_Declaration (Loc,\n-                Defining_Identifier => Def_Id,\n-                Subtype_Mark        => New_Occurrence_Of (Exp_Type, Loc),\n-                Name                => Relocate_Node (Exp)));\n-         end if;\n+         Insert_Action (Exp,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Def_Id,\n+             Subtype_Mark        => New_Occurrence_Of (Exp_Type, Loc),\n+             Name                => Relocate_Node (Exp)));\n \n          --  If this is a packed reference, or a selected component with\n          --  a non-standard representation, a reference to the temporary\n@@ -7715,7 +7733,19 @@ package body Exp_Util is\n             Set_Is_Renaming_Of_Object (Def_Id, False);\n          end if;\n \n-      --  Otherwise we generate a reference to the value\n+      --  Avoid generating a variable-sized temporary, by generating the\n+      --  reference just for the function call. The transformation could be\n+      --  refined to apply only when the array component is constrained by a\n+      --  discriminant???\n+\n+      elsif Nkind (Exp) = N_Selected_Component\n+        and then Nkind (Prefix (Exp)) = N_Function_Call\n+        and then Is_Array_Type (Exp_Type)\n+      then\n+         Remove_Side_Effects (Prefix (Exp), Name_Req, Variable_Ref);\n+         goto Leave;\n+\n+      --  Otherwise we generate a reference to the expression\n \n       else\n          --  An expression which is in SPARK mode is considered side effect\n@@ -8974,23 +9004,10 @@ package body Exp_Util is\n             return Side_Effect_Free (Expression (N), Name_Req, Variable_Ref);\n \n          --  A selected component is side effect free only if it is a side\n-         --  effect free prefixed reference. If it designates a component\n-         --  with a rep. clause it must be treated has having a potential\n-         --  side effect, because it may be modified through a renaming, and\n-         --  a subsequent use of the renaming as a macro will yield the\n-         --  wrong value. This complex interaction between renaming and\n-         --  removing side effects is a reminder that the latter has become\n-         --  a headache to maintain, and that it should be removed in favor\n-         --  of the gcc mechanism to capture values ???\n+         --  effect free prefixed reference.\n \n          when N_Selected_Component =>\n-            if Nkind (Parent (N)) = N_Explicit_Dereference\n-              and then Has_Non_Standard_Rep (Designated_Type (Typ))\n-            then\n-               return False;\n-            else\n-               return Safe_Prefixed_Reference (N);\n-            end if;\n+            return Safe_Prefixed_Reference (N);\n \n          --  A range is side effect free if the bounds are side effect free\n "}, {"sha": "a7b942a7569b67fc7a50e6f5068ef01d79cf4388", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -872,8 +872,8 @@ package Exp_Util is\n    --  call and is analyzed and resolved on return. Name_Req may only be set to\n    --  True if Exp has the form of a name, and the effect is to guarantee that\n    --  any replacement maintains the form of name. If Renaming_Req is set to\n-   --  TRUE, the routine produces an object renaming reclaration capturing the\n-   --  expression. If Variable_Ref is set to TRUE, a variable is considered as\n+   --  True, the routine produces an object renaming reclaration capturing the\n+   --  expression. If Variable_Ref is set to True, a variable is considered as\n    --  side effect (used in implementing Force_Evaluation). Note: after call to\n    --  Remove_Side_Effects, it is safe to call New_Copy_Tree to obtain a copy\n    --  of the resulting expression.\n@@ -885,6 +885,26 @@ package Exp_Util is\n    --  Chars (Related_Id)_FIRST/_LAST. If Related_Id is set, then exactly one\n    --  of the Is_xxx_Bound flags must be set. For use of these parameters see\n    --  the warning in the body of Sem_Ch3.Process_Range_Expr_In_Decl.\n+   --\n+   --  The side effects are captured using one of the following methods:\n+   --\n+   --    1) a constant initialized with the value of the subexpression\n+   --    2) a renaming of the subexpression\n+   --    3) a reference to the subexpression\n+   --\n+   --  For elementary types, methods 1) and 2) are used; for composite types,\n+   --  methods 2) and 3) are used. The renaming (method 2) is used only when\n+   --  the subexpression denotes a name, so that it can be elaborated by gigi\n+   --  without evaluating the subexpression.\n+   --\n+   --  Historical note: the reference (method 3) used to be the common fallback\n+   --  method but it gives rise to aliasing issues if the subexpression denotes\n+   --  a name that is not aliased, since it is equivalent to taking the address\n+   --  in this case. The renaming (method 2) used to be applied to any objects\n+   --  in the RM sense, that is to say to the cases where a renaming is legal\n+   --  in Ada. But for some of these cases, most notably functions calls, the\n+   --  renaming cannot be elaborated without evaluating the subexpression, so\n+   --  gigi would resort to method 1) or 3) under the hood for them.\n \n    function Represented_As_Scalar (T : Entity_Id) return Boolean;\n    --  Returns True iff the implementation of this type in code generation"}, {"sha": "f841b422e50218cbe98ecd95d0248039f0f3dbf7", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -1161,9 +1161,7 @@ package body Sem_Aggr is\n          Set_Analyzed (N);\n       end if;\n \n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Resolve_Aggregate;\n \n    -----------------------------\n@@ -2906,9 +2904,7 @@ package body Sem_Aggr is\n          Error_Msg_N (\"no unique type for this aggregate\",  A);\n       end if;\n \n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Resolve_Extension_Aggregate;\n \n    ------------------------------"}, {"sha": "54ea4429f9a3cca995596a3649855b0c9452eb04", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -8955,9 +8955,7 @@ package body Sem_Ch3 is\n            (Class_Wide_Type (Derived_Type), Last_Entity (Derived_Type));\n       end if;\n \n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Build_Derived_Record_Type;\n \n    ------------------------\n@@ -21122,9 +21120,7 @@ package body Sem_Ch3 is\n          Derive_Progenitor_Subprograms (T, T);\n       end if;\n \n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Record_Type_Declaration;\n \n    ----------------------------"}, {"sha": "2da3fa6735f8437aed1611e73a9160bad6ef0731", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 117, "deletions": 80, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -65,6 +65,110 @@ with Uintp;    use Uintp;\n \n package body Sem_Ch4 is\n \n+   --  Tables which speed up the identification of dangerous calls to Ada 2012\n+   --  functions with writable actuals (AI05-0144).\n+\n+   --  The following table enumerates the Ada constructs which may evaluate in\n+   --  arbitrary order. It does not cover all the language constructs which can\n+   --  be evaluated in arbitrary order but the subset needed for AI05-0144.\n+\n+   Has_Arbitrary_Evaluation_Order : constant array (Node_Kind) of Boolean :=\n+     (N_Aggregate                      => True,\n+      N_Assignment_Statement           => True,\n+      N_Entry_Call_Statement           => True,\n+      N_Extension_Aggregate            => True,\n+      N_Full_Type_Declaration          => True,\n+      N_Indexed_Component              => True,\n+      N_Object_Declaration             => True,\n+      N_Pragma                         => True,\n+      N_Range                          => True,\n+      N_Slice                          => True,\n+\n+      --  N_Array_Type_Definition\n+\n+      --  why not\n+      --  N_Array_Type_Definition      => True,\n+      --  etc ???\n+\n+      N_Constrained_Array_Definition   => True,\n+      N_Unconstrained_Array_Definition => True,\n+\n+      --  N_Membership_Test\n+\n+      N_In                             => True,\n+      N_Not_In                         => True,\n+\n+      --  N_Binary_Op\n+\n+      N_Op_Add                         => True,\n+      N_Op_Concat                      => True,\n+      N_Op_Expon                       => True,\n+      N_Op_Subtract                    => True,\n+\n+      N_Op_Divide                      => True,\n+      N_Op_Mod                         => True,\n+      N_Op_Multiply                    => True,\n+      N_Op_Rem                         => True,\n+\n+      N_Op_And                         => True,\n+\n+      N_Op_Eq                          => True,\n+      N_Op_Ge                          => True,\n+      N_Op_Gt                          => True,\n+      N_Op_Le                          => True,\n+      N_Op_Lt                          => True,\n+      N_Op_Ne                          => True,\n+\n+      N_Op_Or                          => True,\n+      N_Op_Xor                         => True,\n+\n+      N_Op_Rotate_Left                 => True,\n+      N_Op_Rotate_Right                => True,\n+      N_Op_Shift_Left                  => True,\n+      N_Op_Shift_Right                 => True,\n+      N_Op_Shift_Right_Arithmetic      => True,\n+\n+      N_Op_Not                         => True,\n+      N_Op_Plus                        => True,\n+\n+      --  N_Subprogram_Call\n+\n+      N_Function_Call                  => True,\n+      N_Procedure_Call_Statement       => True,\n+\n+      others                           => False);\n+\n+   --  The following table enumerates the nodes on which we stop climbing when\n+   --  locating the outermost Ada construct that can be evaluated in arbitrary\n+   --  order.\n+\n+   Stop_Subtree_Climbing : constant array (Node_Kind) of Boolean :=\n+     (N_Aggregate                    => True,\n+      N_Assignment_Statement         => True,\n+      N_Entry_Call_Statement         => True,\n+      N_Extended_Return_Statement    => True,\n+      N_Extension_Aggregate          => True,\n+      N_Full_Type_Declaration        => True,\n+      N_Object_Declaration           => True,\n+      N_Object_Renaming_Declaration  => True,\n+      N_Package_Specification        => True,\n+      N_Pragma                       => True,\n+      N_Procedure_Call_Statement     => True,\n+      N_Simple_Return_Statement      => True,\n+\n+      --  N_Has_Condition\n+\n+      N_Exit_Statement               => True,\n+      N_If_Statement                 => True,\n+\n+      N_Accept_Alternative           => True,\n+      N_Delay_Alternative            => True,\n+      N_Elsif_Part                   => True,\n+      N_Entry_Body_Formal_Part       => True,\n+      N_Iteration_Scheme             => True,\n+\n+      others                         => False);\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -830,10 +934,7 @@ package body Sem_Ch4 is\n       end if;\n \n       Operator_Check (N);\n-\n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Analyze_Arithmetic_Op;\n \n    ------------------\n@@ -945,40 +1046,6 @@ package body Sem_Ch4 is\n       --  enabled.\n \n       procedure Check_Writable_Actuals (N : Node_Id) is\n-\n-         function Is_Arbitrary_Evaluation_Order_Construct\n-           (N : Node_Id) return Boolean;\n-         --  Return True if N is an Ada construct which may be evaluated in\n-         --  an arbitrary order. This function does not cover all the language\n-         --  constructs that can be evaluated in arbitrary order, but only the\n-         --  subset needed for AI05-0144.\n-\n-         ---------------------------------------------\n-         -- Is_Arbitrary_Evaluation_Order_Construct --\n-         ---------------------------------------------\n-\n-         function Is_Arbitrary_Evaluation_Order_Construct\n-           (N : Node_Id) return Boolean is\n-         begin\n-            return Nkind (N) = N_Aggregate\n-               or else Nkind (N) = N_Assignment_Statement\n-               or else Nkind (N) = N_Full_Type_Declaration\n-               or else Nkind (N) = N_Entry_Call_Statement\n-               or else Nkind (N) = N_Extension_Aggregate\n-               or else Nkind (N) = N_Indexed_Component\n-               or else Nkind (N) = N_Object_Declaration\n-               or else Nkind (N) = N_Pragma\n-               or else Nkind (N) = N_Range\n-               or else Nkind (N) = N_Slice\n-\n-               or else Nkind (N) in N_Array_Type_Definition\n-               or else Nkind (N) in N_Membership_Test\n-               or else Nkind (N) in N_Op\n-               or else Nkind (N) in N_Subprogram_Call;\n-         end Is_Arbitrary_Evaluation_Order_Construct;\n-\n-      --  Start of processing for Check_Writable_Actuals\n-\n       begin\n          if Comes_From_Source (N)\n            and then Present (Get_Subprogram_Entity (N))\n@@ -1010,31 +1077,19 @@ package body Sem_Ch4 is\n                      --  to the routine that will later take care of\n                      --  performing the writable actuals check.\n \n-                     if Is_Arbitrary_Evaluation_Order_Construct (P)\n-                       and then Nkind (P) /= N_Assignment_Statement\n-                       and then Nkind (P) /= N_Object_Declaration\n+                     if Has_Arbitrary_Evaluation_Order (Nkind (P))\n+                       and then not Nkind_In (P, N_Assignment_Statement,\n+                                                 N_Object_Declaration)\n                      then\n                         Outermost := P;\n                      end if;\n \n                      --  Avoid climbing more than needed!\n \n-                     exit when Nkind (P) = N_Aggregate\n-                       or else Nkind (P) = N_Assignment_Statement\n-                       or else Nkind (P) = N_Entry_Call_Statement\n-                       or else Nkind (P) = N_Extended_Return_Statement\n-                       or else Nkind (P) = N_Extension_Aggregate\n-                       or else Nkind (P) = N_Full_Type_Declaration\n-                       or else Nkind (P) = N_Object_Declaration\n-                       or else Nkind (P) = N_Object_Renaming_Declaration\n-                       or else Nkind (P) = N_Package_Specification\n-                       or else Nkind (P) = N_Pragma\n-                       or else Nkind (P) = N_Procedure_Call_Statement\n-                       or else Nkind (P) = N_Simple_Return_Statement\n+                     exit when Stop_Subtree_Climbing (Nkind (P))\n                        or else (Nkind (P) = N_Range\n                                  and then not\n-                                   Nkind_In (Parent (P), N_In, N_Not_In))\n-                       or else Nkind (P) in N_Has_Condition;\n+                                   Nkind_In (Parent (P), N_In, N_Not_In));\n \n                      P := Parent (P);\n                   end loop;\n@@ -1411,9 +1466,7 @@ package body Sem_Ch4 is\n          --  an arbitrary order is precisely this call, then check all its\n          --  actuals.\n \n-         if Check_Actuals (N) then\n-            Check_Function_Writable_Actuals (N);\n-         end if;\n+         Check_Function_Writable_Actuals (N);\n       end if;\n    end Analyze_Call;\n \n@@ -1632,10 +1685,7 @@ package body Sem_Ch4 is\n       end if;\n \n       Operator_Check (N);\n-\n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Analyze_Comparison_Op;\n \n    ---------------------------\n@@ -1883,10 +1933,7 @@ package body Sem_Ch4 is\n       end if;\n \n       Operator_Check (N);\n-\n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Analyze_Equality_Op;\n \n    ----------------------------------\n@@ -2710,10 +2757,7 @@ package body Sem_Ch4 is\n       end if;\n \n       Operator_Check (N);\n-\n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Analyze_Logical_Op;\n \n    ---------------------------\n@@ -2869,10 +2913,7 @@ package body Sem_Ch4 is\n \n       if No (R) and then Ada_Version >= Ada_2012 then\n          Analyze_Set_Membership;\n-\n-         if Check_Actuals (N) then\n-            Check_Function_Writable_Actuals (N);\n-         end if;\n+         Check_Function_Writable_Actuals (N);\n \n          return;\n       end if;\n@@ -2946,9 +2987,7 @@ package body Sem_Ch4 is\n          Error_Msg_N (\"membership test not applicable to cpp-class types\", N);\n       end if;\n \n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Analyze_Membership_Op;\n \n    -----------------\n@@ -4028,9 +4067,7 @@ package body Sem_Ch4 is\n          Check_Universal_Expression (H);\n       end if;\n \n-      if Check_Actuals (N) then\n-         Check_Function_Writable_Actuals (N);\n-      end if;\n+      Check_Function_Writable_Actuals (N);\n    end Analyze_Range;\n \n    -----------------------"}, {"sha": "dde67258d254237fb87ad293aa89666d28dd6a2c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e89283f7807e9c1d17c5f817f2dca13bb544c1/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=22e89283f7807e9c1d17c5f817f2dca13bb544c1", "patch": "@@ -2324,11 +2324,12 @@ package body Sem_Util is\n    --  Start of processing for Check_Function_Writable_Actuals\n \n    begin\n-      --  The check only applies to Ada 2012 code, and only to constructs that\n-      --  have multiple constituents whose order of evaluation is not specified\n-      --  by the language.\n+      --  The check only applies to Ada 2012 code on which Check_Actuals has\n+      --  been set, and only to constructs that have multiple constituents\n+      --  whose order of evaluation is not specified by the language.\n \n       if Ada_Version < Ada_2012\n+        or else not Check_Actuals (N)\n         or else (not (Nkind (N) in N_Op)\n                   and then not (Nkind (N) in N_Membership_Test)\n                   and then not Nkind_In (N, N_Range,"}]}