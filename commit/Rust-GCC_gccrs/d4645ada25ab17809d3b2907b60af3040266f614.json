{"sha": "d4645ada25ab17809d3b2907b60af3040266f614", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ2NDVhZGEyNWFiMTc4MDlkM2IyOTA3YjYwYWYzMDQwMjY2ZjYxNA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-14T20:52:10Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-14T20:52:10Z"}, "message": "selector.c: Reindented some code and tidied up comments.\n\n2010-12-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * selector.c: Reindented some code and tidied up comments.  No\n        actual code changes.\n\nFrom-SVN: r167815", "tree": {"sha": "2f5c49ac5bbfea316c0a8df7c7b05347ad92a37b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f5c49ac5bbfea316c0a8df7c7b05347ad92a37b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4645ada25ab17809d3b2907b60af3040266f614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4645ada25ab17809d3b2907b60af3040266f614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4645ada25ab17809d3b2907b60af3040266f614", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4645ada25ab17809d3b2907b60af3040266f614/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "993acb366ebf8a43f66669950b385710eba931cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/993acb366ebf8a43f66669950b385710eba931cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/993acb366ebf8a43f66669950b385710eba931cb"}], "stats": {"total": 175, "additions": 93, "deletions": 82}, "files": [{"sha": "99f8e23928934e3975cf969d4ba9645b4e65d982", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4645ada25ab17809d3b2907b60af3040266f614/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4645ada25ab17809d3b2907b60af3040266f614/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=d4645ada25ab17809d3b2907b60af3040266f614", "patch": "@@ -1,3 +1,8 @@\n+2010-12-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* selector.c: Reindented some code and tidied up comments.  No\n+\tactual code changes.\n+\n 2010-12-13  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* encoding.c (_darwin_rs6000_special_round_type_align): New."}, {"sha": "f978dd02c966a31bada438e32a0a48e869629e54", "filename": "libobjc/selector.c", "status": "modified", "additions": 88, "deletions": 82, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4645ada25ab17809d3b2907b60af3040266f614/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4645ada25ab17809d3b2907b60af3040266f614/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=d4645ada25ab17809d3b2907b60af3040266f614", "patch": "@@ -31,15 +31,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc-private/sarray.h\"\n #include \"objc/encoding.h\"\n \n-/* Initial selector hash table size. Value doesn't matter much */\n+/* Initial selector hash table size. Value doesn't matter much.  */\n #define SELECTOR_HASH_SIZE 128\n \n-/* Tables mapping selector names to uid and opposite */\n+/* Tables mapping selector names to uid and opposite.  */\n static struct sarray *__objc_selector_array = 0; /* uid -> sel  !T:MUTEX */\n static struct sarray *__objc_selector_names = 0; /* uid -> name !T:MUTEX */\n static cache_ptr      __objc_selector_hash  = 0; /* name -> uid !T:MUTEX */\n \n-/* Number of selectors stored in each of the above tables */\n+/* Number of selectors stored in each of the above tables.  */\n unsigned int __objc_selector_max_index = 0;     /* !T:MUTEX */\n \n void __objc_init_selector_tables (void)\n@@ -52,8 +52,8 @@ void __objc_init_selector_tables (void)\n \t\t     (compare_func_type) objc_compare_strings);\n }  \n \n-/* This routine is given a class and records all of the methods in its class\n-   structure in the record table.  */\n+/* This routine is given a class and records all of the methods in its\n+   class structure in the record table.  */\n void\n __objc_register_selectors_from_class (Class class)\n {\n@@ -68,13 +68,12 @@ __objc_register_selectors_from_class (Class class)\n }\n \n \n-/* This routine is given a list of methods and records each of the methods in\n-   the record table.  This is the routine that does the actual recording\n-   work.\n+/* This routine is given a list of methods and records each of the\n+   methods in the record table.  This is the routine that does the\n+   actual recording work.\n \n    The name and type pointers in the method list must be permanent and\n-   immutable.\n-   */\n+   immutable.  */\n void\n __objc_register_selectors_from_list (MethodList_t method_list)\n {\n@@ -107,8 +106,7 @@ struct objc_method_description_list\n /* The same as __objc_register_selectors_from_list, but works on a\n    struct objc_method_description_list* instead of a struct\n    objc_method_list*.  This is only used for protocols, which have\n-   lists of method descriptions, not methods.\n-   */\n+   lists of method descriptions, not methods.  */\n void\n __objc_register_selectors_from_description_list \n (struct objc_method_description_list *method_list)\n@@ -130,7 +128,7 @@ __objc_register_selectors_from_description_list\n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n-/* Register instance methods as class methods for root classes */\n+/* Register instance methods as class methods for root classes.  */\n void __objc_register_instance_methods_to_class (Class class)\n {\n   MethodList_t method_list;\n@@ -143,57 +141,57 @@ void __objc_register_instance_methods_to_class (Class class)\n   if (class->super_class)\n     return;\n \n-  /* Allocate a method list to hold the new class methods */\n+  /* Allocate a method list to hold the new class methods.  */\n   new_list = objc_calloc (sizeof (struct objc_method_list)\n-\t\t\t    + sizeof (struct objc_method[max_methods_no]), 1);\n+\t\t\t  + sizeof (struct objc_method[max_methods_no]), 1);\n   method_list = class->methods;\n   class_method_list = class->class_pointer->methods;\n   curr_method = &new_list->method_list[0];\n-\n-  /* Iterate through the method lists for the class */\n+  \n+  /* Iterate through the method lists for the class.  */\n   while (method_list)\n     {\n       int i;\n-\n-      /* Iterate through the methods from this method list */\n+      \n+      /* Iterate through the methods from this method list.  */\n       for (i = 0; i < method_list->method_count; i++)\n \t{\n \t  Method_t mth = &method_list->method_list[i];\n \t  if (mth->method_name\n \t      && ! search_for_method_in_list (class_method_list,\n \t\t\t\t\t      mth->method_name))\n \t    {\n-\t      /* This instance method isn't a class method. \n-\t\t  Add it into the new_list. */\n+\t      /* This instance method isn't a class method.  Add it\n+\t\t into the new_list. */\n \t      *curr_method = *mth;\n-  \n-\t      /* Reallocate the method list if necessary */\n+\t      \n+\t      /* Reallocate the method list if necessary.  */\n \t      if (++new_list->method_count == max_methods_no)\n \t\tnew_list =\n \t\t  objc_realloc (new_list, sizeof (struct objc_method_list)\n \t\t\t\t+ sizeof (struct \n-\t\t\t\t\tobjc_method[max_methods_no += 16]));\n+\t\t\t\t\t  objc_method[max_methods_no += 16]));\n \t      curr_method = &new_list->method_list[new_list->method_count];\n \t    }\n \t}\n \n       method_list = method_list->method_next;\n     }\n \n-  /* If we created any new class methods\n-     then attach the method list to the class */\n+  /* If we created any new class methods then attach the method list\n+     to the class.  */\n   if (new_list->method_count)\n     {\n       new_list =\n  \tobjc_realloc (new_list, sizeof (struct objc_method_list)\n-\t\t     + sizeof (struct objc_method[new_list->method_count]));\n+\t\t      + sizeof (struct objc_method[new_list->method_count]));\n       new_list->method_next = class->class_pointer->methods;\n       class->class_pointer->methods = new_list;\n     }\n   else\n     objc_free(new_list);\n-\n-    __objc_update_dispatch_table_for_class (class->class_pointer);\n+  \n+  __objc_update_dispatch_table_for_class (class->class_pointer);\n }\n \n BOOL\n@@ -205,8 +203,8 @@ sel_isEqual (SEL s1, SEL s2)\n     return s1->sel_id == s2->sel_id;\n }\n \n-/* Returns YES iff t1 and t2 have same method types, but we ignore\n-   the argframe layout */\n+/* Return YES iff t1 and t2 have same method types.  Ignore the\n+   argframe layout.  */\n BOOL\n sel_types_match (const char *t1, const char *t2)\n {\n@@ -219,7 +217,7 @@ sel_types_match (const char *t1, const char *t2)\n       while (isdigit ((unsigned char) *t1)) t1++;\n       while (isdigit ((unsigned char) *t2)) t2++;\n       /* xxx Remove these next two lines when qualifiers are put in\n-\t all selectors, not just Protocol selectors. */\n+\t all selectors, not just Protocol selectors.  */\n       t1 = objc_skip_type_qualifiers (t1);\n       t2 = objc_skip_type_qualifiers (t2);\n       if (! *t1 && ! *t2)\n@@ -232,7 +230,7 @@ sel_types_match (const char *t1, const char *t2)\n   return NO;\n }\n \n-/* return selector representing name */\n+/* Return selector representing name.  */\n SEL\n sel_get_typed_uid (const char *name, const char *types)\n {\n@@ -271,7 +269,8 @@ sel_get_typed_uid (const char *name, const char *types)\n   return 0;\n }\n \n-/* Return selector representing name; prefer a selector with non-NULL type */\n+/* Return selector representing name; prefer a selector with non-NULL\n+   type.  */\n SEL\n sel_get_any_typed_uid (const char *name)\n {\n@@ -303,7 +302,7 @@ sel_get_any_typed_uid (const char *name)\n   return s;\n }\n \n-/* return selector representing name */\n+/* Return selector representing name.  */\n SEL\n sel_get_any_uid (const char *name)\n {\n@@ -328,15 +327,15 @@ sel_get_any_uid (const char *name)\n   return (SEL) l->head;\n }\n \n-/* Get name of selector.  If selector is unknown, the empty string \"\" \n-   is returned */ \n+/* Get the name of a selector.  If the selector is unknown, the empty\n+   string \"\" is returned.  */ \n const char *sel_getName (SEL selector)\n {\n   const char *ret;\n \n   if (selector == NULL)\n     return \"<null selector>\";\n-\n+  \n   objc_mutex_lock (__objc_runtime_mutex);\n   if ((soffset_decode ((sidx)selector->sel_id) > 0)\n       && (soffset_decode ((sidx)selector->sel_id) <= __objc_selector_max_index))\n@@ -377,22 +376,22 @@ const char *sel_get_type (SEL selector)\n   return sel_getType (selector);\n }\n \n-/* The uninstalled dispatch table */\n+/* The uninstalled dispatch table.  */\n extern struct sarray *__objc_uninstalled_dtable;\n \n /* __sel_register_typed_name allocates lots of struct objc_selector:s\n-   of 8 (16, if pointers are 64 bits) bytes at startup. To reduce the number\n-   of malloc calls and memory lost to malloc overhead, we allocate\n-   objc_selector:s in blocks here. This is only called from\n-   __sel_register_typed_name, and __sel_register_typed_name may only be\n-   called when __objc_runtime_mutex is locked.\n-\n-   Note that the objc_selector:s allocated from __sel_register_typed_name\n-   are never freed.\n-\n-   62 because 62 * sizeof (struct objc_selector) = 496 (992). This should\n-   let malloc add some overhead and use a nice, round 512 (1024) byte chunk.\n-   */\n+   of 8 (16, if pointers are 64 bits) bytes at startup. To reduce the\n+   number of malloc calls and memory lost to malloc overhead, we\n+   allocate objc_selector:s in blocks here. This is only called from\n+   __sel_register_typed_name, and __sel_register_typed_name may only\n+   be called when __objc_runtime_mutex is locked.\n+\n+   Note that the objc_selector:s allocated from\n+   __sel_register_typed_name are never freed.\n+\n+   62 because 62 * sizeof (struct objc_selector) = 496 (992). This\n+   should let malloc add some overhead and use a nice, round 512\n+   (1024) byte chunk.  */\n #define SELECTOR_POOL_SIZE 62\n static struct objc_selector *selector_pool;\n static int selector_pool_left;\n@@ -409,13 +408,13 @@ pool_alloc_selector(void)\n   return &selector_pool[--selector_pool_left];\n }\n \n-/* Store the passed selector name in the selector record and return its\n-   selector value (value returned by sel_get_uid).\n-   Assumes that the calling function has locked down __objc_runtime_mutex. */\n-/* is_const parameter tells us if the name and types parameters\n-   are really constant or not.  If YES then they are constant and\n-   we can just store the pointers.  If NO then we need to copy\n-   name and types because the pointers may disappear later on. */\n+/* Store the passed selector name in the selector record and return\n+   its selector value (value returned by sel_get_uid).  Assume that\n+   the calling function has locked down __objc_runtime_mutex.  The\n+   is_const parameter tells us if the name and types parameters are\n+   really constant or not.  If YES then they are constant and we can\n+   just store the pointers.  If NO then we need to copy name and types\n+   because the pointers may disappear later on.  */\n SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig, BOOL is_const)\n@@ -459,15 +458,17 @@ __sel_register_typed_name (const char *name, const char *types,\n \tj = orig;\n       else\n \tj = pool_alloc_selector ();\n-\n+      \n       j->sel_id = (void *) i;\n-      /* Can we use the pointer or must copy types?  Don't copy if NULL */\n+      /* Can we use the pointer or must copy types?  Don't copy if\n+\t NULL.  */\n       if ((is_const) || (types == 0))\n \tj->sel_types = (const char *) types;\n-      else {\n-\tj->sel_types = (char *) objc_malloc (strlen (types) + 1);\n-\tstrcpy ((char *) j->sel_types, types);\n-      }\n+      else\n+\t{\n+\t  j->sel_types = (char *) objc_malloc (strlen (types) + 1);\n+\t  strcpy ((char *) j->sel_types, types);\n+\t}\n       l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n     }\n   else\n@@ -478,15 +479,17 @@ __sel_register_typed_name (const char *name, const char *types,\n \tj = orig;\n       else\n \tj = pool_alloc_selector ();\n-\t\n+      \n       j->sel_id = (void *) i;\n-      /* Can we use the pointer or must copy types?  Don't copy if NULL */\n+      /* Can we use the pointer or must copy types?  Don't copy if\n+\t NULL.  */\n       if ((is_const) || (types == 0))\n \tj->sel_types = (const char *) types;\n-      else {\n-\tj->sel_types = (char *) objc_malloc (strlen (types) + 1);\n-\tstrcpy ((char *) j->sel_types, types);\n-      }\n+      else\n+\t{\n+\t  j->sel_types = (char *) objc_malloc (strlen (types) + 1);\n+\t  strcpy ((char *) j->sel_types, types);\n+\t}\n       l = 0;\n     }\n \n@@ -497,23 +500,25 @@ __sel_register_typed_name (const char *name, const char *types,\n     int is_new = (l == 0);\n     const char *new_name;\n \n-    /* Can we use the pointer or must copy name?  Don't copy if NULL */\n+    /* Can we use the pointer or must copy name?  Don't copy if\n+       NULL.  */\n     if ((is_const) || (name == 0))\n       new_name = name;\n-    else {\n-      new_name = (char *) objc_malloc (strlen (name) + 1);\n-      strcpy ((char *) new_name, name);\n-    }\n-\n+    else\n+      {\n+\tnew_name = (char *) objc_malloc (strlen (name) + 1);\n+\tstrcpy ((char *) new_name, name);\n+      }\n+    \n     l = list_cons ((void *) j, l);\n     sarray_at_put_safe (__objc_selector_names, i, (void *) new_name);\n     sarray_at_put_safe (__objc_selector_array, i, (void *) l);\n     if (is_new)\n       objc_hash_add (&__objc_selector_hash, (void *) new_name, (void *) i);\n   }\n-\n+  \n   sarray_realloc (__objc_uninstalled_dtable, __objc_selector_max_index + 1);\n-\n+  \n   return (SEL) j;\n }\n \n@@ -524,7 +529,7 @@ sel_registerName (const char *name)\n     \n   objc_mutex_lock (__objc_runtime_mutex);\n   /* Assume that name is not constant static memory and needs to be\n-     copied before put into a runtime structure.  is_const == NO */\n+     copied before put into a runtime structure.  is_const == NO.  */\n   ret = __sel_register_typed_name (name, 0, 0, NO);\n   objc_mutex_unlock (__objc_runtime_mutex);\n   \n@@ -544,8 +549,9 @@ sel_registerTypedName (const char *name, const char *type)\n   SEL ret;\n \n   objc_mutex_lock (__objc_runtime_mutex);\n-  /* Assume that name and type are not constant static memory and need to\n-     be copied before put into a runtime structure.  is_const == NO */\n+  /* Assume that name and type are not constant static memory and need\n+     to be copied before put into a runtime structure.  is_const ==\n+     NO.  */\n   ret = __sel_register_typed_name (name, type, 0, NO);\n   objc_mutex_unlock (__objc_runtime_mutex);\n   \n@@ -558,7 +564,7 @@ sel_register_typed_name (const char *name, const char *type)\n   return sel_registerTypedName (name, type);\n }\n \n-/* return selector representing name */\n+/* Return the selector representing name.  */\n SEL\n sel_getUid (const char *name)\n {"}]}