{"sha": "cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I3ZmRkZTJkN2MyOTdiYTlhNzM2ZThkZmM5ZGU0YTQ1NjBhNzYzNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-05-12T10:41:31Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-05-12T10:41:31Z"}, "message": "cp-tree.h (ptrmemfunc_vbit_where_t): Declare type.\n\n* cp-tree.h (ptrmemfunc_vbit_where_t): Declare type.\n* typeck.c (get_member_function_from_ptrfunc,\nbuild_ptrmemfunc, expand_ptrmemfunc_cst): Take\nTARGET_PTRMEMFUNC_VBIT_LOCATION into account.\n\nFrom-SVN: r41990", "tree": {"sha": "efe6294b4f0878077cd2207e8ab373069a36bb66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efe6294b4f0878077cd2207e8ab373069a36bb66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634/comments", "author": null, "committer": null, "parents": [{"sha": "f3c55c97be3655882c12b1f76548694575a301f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c55c97be3655882c12b1f76548694575a301f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3c55c97be3655882c12b1f76548694575a301f2"}], "stats": {"total": 92, "additions": 76, "deletions": 16}, "files": [{"sha": "4dffdff322e4b528087dbf69e8b01e180eb3734d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634", "patch": "@@ -1,4 +1,9 @@\n-2001-05-11  Alexandre Oliva  <aoliva@redhat.com>\n+2001-05-12  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* cp-tree.h (ptrmemfunc_vbit_where_t): Declare type.\n+\t* typeck.c (get_member_function_from_ptrfunc,\n+\tbuild_ptrmemfunc, expand_ptrmemfunc_cst): Take\n+\tTARGET_PTRMEMFUNC_VBIT_LOCATION into account.\n \n \tReverted Geoff Keating's 2001-05-03's patch.\n "}, {"sha": "d313fcd1df74ba8acc7b5011b0ea20fb1ea69808", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634", "patch": "@@ -2673,7 +2673,19 @@ extern int flag_new_for_scope;\n    (We don't need DELTA2, because the vtable is always the first thing\n    in the object.)  If the function is virtual, then PFN is one plus\n    twice the index into the vtable; otherwise, it is just a pointer to\n-   the function.  */\n+   the function.\n+\n+   Unfortunately, using the lowest bit of PFN doesn't work in\n+   architectures that don't impose alignment requirements on function\n+   addresses, or that use the lowest bit to tell one ISA from another,\n+   for example.  For such architectures, we use the lowest bit of\n+   DELTA instead of the lowest bit of the PFN, and DELTA will be\n+   multiplied by 2.  */\n+enum ptrmemfunc_vbit_where_t\n+{\n+  ptrmemfunc_vbit_in_pfn,\n+  ptrmemfunc_vbit_in_delta\n+};\n \n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,"}, {"sha": "209b682ef8af2835e62695aa091360c6cba616e1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cb7fdde2d7c297ba9a736e8dfc9de4a4560a7634", "patch": "@@ -2894,6 +2894,11 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n       e3 = PFN_FROM_PTRMEMFUNC (function);\n \n+      vtbl = convert_pointer_to (ptr_type_node, instance);\n+      delta = cp_convert (ptrdiff_type_node,\n+\t\t\t  build_component_ref (function, delta_identifier,\n+\t\t\t\t\t       NULL_TREE, 0));\n+\n       /* This used to avoid checking for virtual functions if basetype\n \t has no virtual functions, according to an earlier ANSI draft.\n \t With the final ISO C++ rules, such an optimization is\n@@ -2906,14 +2911,31 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t load-with-sign-extend, while the second used normal load then\n \t shift to sign-extend.  An optimizer flaw, perhaps, but it's\n \t easier to make this change.  */\n-      idx = cp_build_binary_op (TRUNC_DIV_EXPR, \n-\t\t\t\tbuild1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t\tTYPE_SIZE_UNIT (vtable_entry_type));\n-      e1 = cp_build_binary_op (BIT_AND_EXPR,\n-\t\t\t       build1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t       integer_one_node);\n+      switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n+\t{\n+\tcase ptrmemfunc_vbit_in_pfn:\n+\t  idx = cp_build_binary_op (TRUNC_DIV_EXPR, \n+\t\t\t\t    build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\t    TYPE_SIZE_UNIT (vtable_entry_type));\n+\t  e1 = cp_build_binary_op (BIT_AND_EXPR,\n+\t\t\t\t   build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\t   integer_one_node);\n+\t  break;\n+\n+\tcase ptrmemfunc_vbit_in_delta:\n+\t  idx = build1 (NOP_EXPR, vtable_index_type, e3);\n+\t  e1 = cp_build_binary_op (BIT_AND_EXPR,\n+\t\t\t\t   delta, integer_one_node);\n+\t  delta = cp_build_binary_op (RSHIFT_EXPR,\n+\t\t\t\t      build1 (NOP_EXPR, vtable_index_type,\n+\t\t\t\t\t      delta),\n+\t\t\t\t      integer_one_node);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n \n-      vtbl = convert_pointer_to (ptr_type_node, instance);\n       delta = cp_convert (ptrdiff_type_node,\n \t\t\t  build_component_ref (function, delta_identifier,\n \t\t\t\t\t       NULL_TREE, 0));\n@@ -6085,6 +6107,8 @@ build_ptrmemfunc (type, pfn, force)\n       /* Under the new ABI, the conversion is easy.  Just adjust\n \t the DELTA field.  */\n       delta = cp_convert (ptrdiff_type_node, delta);\n+      if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_delta)\n+\tn = cp_build_binary_op (LSHIFT_EXPR, n, integer_one_node);\n       delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n       return build_ptrmemfunc1 (to_type, delta, npfn);\n     }\n@@ -6146,13 +6170,32 @@ expand_ptrmemfunc_cst (cst, delta, pfn)\n       *delta = fold (build (PLUS_EXPR, TREE_TYPE (*delta),\n \t\t\t    *delta, BINFO_OFFSET (binfo)));\n \n-      /* Under the new ABI, we set PFN to the vtable offset, plus\n-\t one, at which the function can be found.  */\n-      *pfn = fold (build (MULT_EXPR, integer_type_node,\n-\t\t\t  DECL_VINDEX (fn), \n-\t\t\t  TYPE_SIZE_UNIT (vtable_entry_type)));\n-      *pfn = fold (build (PLUS_EXPR, integer_type_node, *pfn,\n-\t\t\t  integer_one_node));\n+      /* Under the new ABI, we set PFN to the vtable offset at\n+\t which the function can be found, plus one (unless\n+\t ptrmemfunc_vbit_in_delta, in which case delta is shifted\n+\t left, and then incremented).  */\n+      *pfn = DECL_VINDEX (fn);\n+\n+      switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n+\t{\n+\tcase ptrmemfunc_vbit_in_pfn:\n+\t  *pfn = fold (build (MULT_EXPR, integer_type_node, *pfn,\n+\t\t\t      TYPE_SIZE_UNIT (vtable_entry_type)));\n+\t  *pfn = fold (build (PLUS_EXPR, integer_type_node, *pfn,\n+\t\t\t      integer_one_node));\n+\t  break;\n+\n+\tcase ptrmemfunc_vbit_in_delta:\n+\t  *delta = fold (build (LSHIFT_EXPR, TREE_TYPE (*delta),\n+\t\t\t\t*delta, integer_one_node));\n+\t  *delta = fold (build (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t\t\t*delta, integer_one_node));\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n       *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),\n \t\t\t   *pfn));\n     }"}]}