{"sha": "6feee1e1b878d0418ab1a42d12eb30436c81c1c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZlZWUxZTFiODc4ZDA0MThhYjFhNDJkMTJlYjMwNDM2YzgxYzFjOQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2018-11-18T23:39:16Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-11-18T23:39:16Z"}, "message": "Remove unused modules from libphobos std.internal package.\n\nlibphobos/ChangeLog:\n\n2018-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* src/Makefile.am: Remove std.internal.digest.sha_SSSE3 and\n\tstd.internal.math.biguintx86 modules.\n\t* src/Makefile.in: Rebuild.\n\t* src/std/internal/digest/sha_SSSE3.d: Remove.\n\t* src/std/internal/math/biguintx86.d: Remove.\n\nFrom-SVN: r266256", "tree": {"sha": "dad1d358dee9b634663a5a7da658844748866bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dad1d358dee9b634663a5a7da658844748866bea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6feee1e1b878d0418ab1a42d12eb30436c81c1c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6feee1e1b878d0418ab1a42d12eb30436c81c1c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6feee1e1b878d0418ab1a42d12eb30436c81c1c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6feee1e1b878d0418ab1a42d12eb30436c81c1c9/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bee39274cb9ffb5415ab50fa102673b0394d4f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee39274cb9ffb5415ab50fa102673b0394d4f39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bee39274cb9ffb5415ab50fa102673b0394d4f39"}], "stats": {"total": 2115, "additions": 12, "deletions": 2103}, "files": [{"sha": "58754bc35afaf9b3fcfcda520d0efdbdc7df36d0", "filename": "libphobos/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feee1e1b878d0418ab1a42d12eb30436c81c1c9/libphobos%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feee1e1b878d0418ab1a42d12eb30436c81c1c9/libphobos%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2FChangeLog?ref=6feee1e1b878d0418ab1a42d12eb30436c81c1c9", "patch": "@@ -1,3 +1,11 @@\n+2018-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* src/Makefile.am: Remove std.internal.digest.sha_SSSE3 and\n+\tstd.internal.math.biguintx86 modules.\n+\t* src/Makefile.in: Rebuild.\n+\t* src/std/internal/digest/sha_SSSE3.d: Remove.\n+\t* src/std/internal/math/biguintx86.d: Remove.\n+\n 2018-11-02  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \tPR d/87827"}, {"sha": "c5b36aea0cbe21a98d4aa4e8ea66e08b58a6014c", "filename": "libphobos/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feee1e1b878d0418ab1a42d12eb30436c81c1c9/libphobos%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feee1e1b878d0418ab1a42d12eb30436c81c1c9/libphobos%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.am?ref=6feee1e1b878d0418ab1a42d12eb30436c81c1c9", "patch": "@@ -156,9 +156,8 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/sqlite3.d etc/c/zlib.d \\\n \tstd/experimental/logger/multilogger.d \\\n \tstd/experimental/logger/nulllogger.d std/experimental/logger/package.d \\\n \tstd/experimental/typecons.d std/file.d std/format.d std/functional.d \\\n-\tstd/getopt.d std/internal/cstring.d std/internal/digest/sha_SSSE3.d \\\n-\tstd/internal/math/biguintcore.d std/internal/math/biguintnoasm.d \\\n-\tstd/internal/math/biguintx86.d std/internal/math/errorfunction.d \\\n+\tstd/getopt.d std/internal/cstring.d std/internal/math/biguintcore.d \\\n+\tstd/internal/math/biguintnoasm.d std/internal/math/errorfunction.d \\\n \tstd/internal/math/gammafunction.d std/internal/scopebuffer.d \\\n \tstd/internal/test/dummyrange.d std/internal/test/range.d \\\n \tstd/internal/test/uda.d std/internal/unicode_comp.d \\"}, {"sha": "08470abba3ec77f23b881cd459727ad8236ff90c", "filename": "libphobos/src/Makefile.in", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feee1e1b878d0418ab1a42d12eb30436c81c1c9/libphobos%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feee1e1b878d0418ab1a42d12eb30436c81c1c9/libphobos%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.in?ref=6feee1e1b878d0418ab1a42d12eb30436c81c1c9", "patch": "@@ -193,10 +193,8 @@ am__objects_1 = etc/c/curl.lo etc/c/sqlite3.lo etc/c/zlib.lo \\\n \tstd/experimental/logger/package.lo \\\n \tstd/experimental/typecons.lo std/file.lo std/format.lo \\\n \tstd/functional.lo std/getopt.lo std/internal/cstring.lo \\\n-\tstd/internal/digest/sha_SSSE3.lo \\\n \tstd/internal/math/biguintcore.lo \\\n \tstd/internal/math/biguintnoasm.lo \\\n-\tstd/internal/math/biguintx86.lo \\\n \tstd/internal/math/errorfunction.lo \\\n \tstd/internal/math/gammafunction.lo std/internal/scopebuffer.lo \\\n \tstd/internal/test/dummyrange.lo std/internal/test/range.lo \\\n@@ -282,10 +280,8 @@ am__DEPENDENCIES_1 = etc/c/curl.t.lo etc/c/sqlite3.t.lo \\\n \tstd/experimental/logger/package.t.lo \\\n \tstd/experimental/typecons.t.lo std/file.t.lo std/format.t.lo \\\n \tstd/functional.t.lo std/getopt.t.lo std/internal/cstring.t.lo \\\n-\tstd/internal/digest/sha_SSSE3.t.lo \\\n \tstd/internal/math/biguintcore.t.lo \\\n \tstd/internal/math/biguintnoasm.t.lo \\\n-\tstd/internal/math/biguintx86.t.lo \\\n \tstd/internal/math/errorfunction.t.lo \\\n \tstd/internal/math/gammafunction.t.lo \\\n \tstd/internal/scopebuffer.t.lo \\\n@@ -392,10 +388,8 @@ am__DEPENDENCIES_4 = etc/c/curl.t.o etc/c/sqlite3.t.o etc/c/zlib.t.o \\\n \tstd/experimental/logger/package.t.o \\\n \tstd/experimental/typecons.t.o std/file.t.o std/format.t.o \\\n \tstd/functional.t.o std/getopt.t.o std/internal/cstring.t.o \\\n-\tstd/internal/digest/sha_SSSE3.t.o \\\n \tstd/internal/math/biguintcore.t.o \\\n \tstd/internal/math/biguintnoasm.t.o \\\n-\tstd/internal/math/biguintx86.t.o \\\n \tstd/internal/math/errorfunction.t.o \\\n \tstd/internal/math/gammafunction.t.o \\\n \tstd/internal/scopebuffer.t.o std/internal/test/dummyrange.t.o \\\n@@ -788,9 +782,8 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/sqlite3.d etc/c/zlib.d \\\n \tstd/experimental/logger/multilogger.d \\\n \tstd/experimental/logger/nulllogger.d std/experimental/logger/package.d \\\n \tstd/experimental/typecons.d std/file.d std/format.d std/functional.d \\\n-\tstd/getopt.d std/internal/cstring.d std/internal/digest/sha_SSSE3.d \\\n-\tstd/internal/math/biguintcore.d std/internal/math/biguintnoasm.d \\\n-\tstd/internal/math/biguintx86.d std/internal/math/errorfunction.d \\\n+\tstd/getopt.d std/internal/cstring.d std/internal/math/biguintcore.d \\\n+\tstd/internal/math/biguintnoasm.d std/internal/math/errorfunction.d \\\n \tstd/internal/math/gammafunction.d std/internal/scopebuffer.d \\\n \tstd/internal/test/dummyrange.d std/internal/test/range.d \\\n \tstd/internal/test/uda.d std/internal/unicode_comp.d \\\n@@ -1032,16 +1025,11 @@ std/internal/$(am__dirstamp):\n \t@$(MKDIR_P) std/internal\n \t@: > std/internal/$(am__dirstamp)\n std/internal/cstring.lo: std/internal/$(am__dirstamp)\n-std/internal/digest/$(am__dirstamp):\n-\t@$(MKDIR_P) std/internal/digest\n-\t@: > std/internal/digest/$(am__dirstamp)\n-std/internal/digest/sha_SSSE3.lo: std/internal/digest/$(am__dirstamp)\n std/internal/math/$(am__dirstamp):\n \t@$(MKDIR_P) std/internal/math\n \t@: > std/internal/math/$(am__dirstamp)\n std/internal/math/biguintcore.lo: std/internal/math/$(am__dirstamp)\n std/internal/math/biguintnoasm.lo: std/internal/math/$(am__dirstamp)\n-std/internal/math/biguintx86.lo: std/internal/math/$(am__dirstamp)\n std/internal/math/errorfunction.lo: std/internal/math/$(am__dirstamp)\n std/internal/math/gammafunction.lo: std/internal/math/$(am__dirstamp)\n std/internal/scopebuffer.lo: std/internal/$(am__dirstamp)\n@@ -1174,8 +1162,6 @@ mostlyclean-compile:\n \t-rm -f std/experimental/logger/*.lo\n \t-rm -f std/internal/*.$(OBJEXT)\n \t-rm -f std/internal/*.lo\n-\t-rm -f std/internal/digest/*.$(OBJEXT)\n-\t-rm -f std/internal/digest/*.lo\n \t-rm -f std/internal/math/*.$(OBJEXT)\n \t-rm -f std/internal/math/*.lo\n \t-rm -f std/internal/test/*.$(OBJEXT)\n@@ -1401,7 +1387,6 @@ clean-libtool:\n \t-rm -rf std/experimental/allocator/building_blocks/.libs std/experimental/allocator/building_blocks/_libs\n \t-rm -rf std/experimental/logger/.libs std/experimental/logger/_libs\n \t-rm -rf std/internal/.libs std/internal/_libs\n-\t-rm -rf std/internal/digest/.libs std/internal/digest/_libs\n \t-rm -rf std/internal/math/.libs std/internal/math/_libs\n \t-rm -rf std/internal/test/.libs std/internal/test/_libs\n \t-rm -rf std/internal/windows/.libs std/internal/windows/_libs\n@@ -1529,7 +1514,6 @@ distclean-generic:\n \t-rm -f std/experimental/allocator/building_blocks/$(am__dirstamp)\n \t-rm -f std/experimental/logger/$(am__dirstamp)\n \t-rm -f std/internal/$(am__dirstamp)\n-\t-rm -f std/internal/digest/$(am__dirstamp)\n \t-rm -f std/internal/math/$(am__dirstamp)\n \t-rm -f std/internal/test/$(am__dirstamp)\n \t-rm -f std/internal/windows/$(am__dirstamp)"}, {"sha": "4060f34a063f9e865488927ec06475fe5f9fc255", "filename": "libphobos/src/std/internal/digest/sha_SSSE3.d", "status": "removed", "additions": 0, "deletions": 729, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee39274cb9ffb5415ab50fa102673b0394d4f39/libphobos%2Fsrc%2Fstd%2Finternal%2Fdigest%2Fsha_SSSE3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee39274cb9ffb5415ab50fa102673b0394d4f39/libphobos%2Fsrc%2Fstd%2Finternal%2Fdigest%2Fsha_SSSE3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Fdigest%2Fsha_SSSE3.d?ref=bee39274cb9ffb5415ab50fa102673b0394d4f39", "patch": "@@ -1,729 +0,0 @@\n-// Written in the D programming language.\n-\n-/**\n- * Computes SHA1 digests of arbitrary data, using an optimized algorithm with SSSE3 instructions.\n- *\n- * Authors:\n- * The general idea is described by Dean Gaudet.\n- * Another important observation is published by Max Locktyukhin.\n- * (Both implementations are public domain.)\n- * Translation to X86 and D by Kai Nacke <kai@redstar.de>\n- *\n- * References:\n- *      $(LINK2 http://arctic.org/~dean/crypto/sha1.html)\n- *      $(LINK2 http://software.intel.com/en-us/articles/improving-the-performance-of-the-secure-hash-algorithm-1/, Fast implementation of SHA1)\n- */\n-module std.internal.digest.sha_SSSE3;\n-\n-version (D_InlineAsm_X86)\n-{\n-    version (D_PIC) {} // Bugzilla 9378\n-    else\n-    {\n-        private version = USE_SSSE3;\n-        private version = _32Bit;\n-    }\n-}\n-else version (D_InlineAsm_X86_64)\n-{\n-    private version = USE_SSSE3;\n-    private version = _64Bit;\n-}\n-\n-/*\n- * The idea is quite simple. The SHA-1 specification defines the following message schedule:\n- *     W[i] = (W[i-3] ^ W[i-8]  ^ W[i-14] ^ W[i-16]) rol 1\n- *\n- * To employ SSE, simply write down the formula four times:\n- *     W[i  ] = (W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16]) rol 1\n- *     W[i+1] = (W[i-2] ^ W[i-7] ^ W[i-13] ^ W[i-15]) rol 1\n- *     W[i+2] = (W[i-1] ^ W[i-6] ^ W[i-12] ^ W[i-14]) rol 1\n- *     W[i+3] = (W[i  ] ^ W[i-5] ^ W[i-11] ^ W[i-13]) rol 1\n- * The last formula requires value W[i] computed with the first formula.\n- * Because the xor operation and the rotate operation are commutative, we can replace the\n- * last formula with\n- *     W[i+3] = (     0 ^ W[i-5] ^ W[i-11] ^ W[i-13]) rol 1\n- * and then calculate\n- *     W[i+3] ^= W[i] rol 1\n- * which unfortunately requires many additional operations. This approach was described by\n- * Dean Gaudet.\n- *\n- * Max Locktyukhin observed that\n- *     W[i] = W[i-A] ^ W[i-B]\n- * is equivalent to\n- *     W[i] = W[i-2*A] ^ W[i-2*B]\n- * (if the indices are still in valid ranges). Using this observation, the formula is\n- * translated to\n- *     W[i] = (W[i-6] ^ W[i-16] ^ W[i-28] ^ W[i-32]) rol 2\n- * Again, to employ SSE the formula is used four times.\n- *\n- * Later on, the expression W[i] + K(i) is used. (K(i) is the constant used in round i.)\n- * Once the 4 W[i] are calculated, we can also add the four K(i) values with one SSE instruction.\n- *\n- * The 32bit and 64bit implementations are almost identical. The main difference is that there\n- * are only 8 XMM registers in 32bit mode. Therefore, space on the stack is needed to save\n- * computed values.\n- */\n-\n-version (USE_SSSE3)\n-{\n-    /*\n-     * The general idea is to use the XMM registers as a sliding window over\n-     * message schedule. XMM0 to XMM7 are used to store the last 64 byte of\n-     * the message schedule. In 64 bit mode this is fine because of the number of\n-     * registers. The main difference of the 32 bit code is that a part of the\n-     * calculated message schedule is saved on the stack because 2 temporary\n-     * registers are needed.\n-     */\n-\n-    /* Number of message words we are precalculating. */\n-    private immutable int PRECALC_AHEAD = 16;\n-\n-    /* T1 and T2 are used for intermediate results of computations. */\n-    private immutable string T1 = \"EAX\";\n-    private immutable string T2 = \"EBX\";\n-\n-    /* The registers used for the SHA-1 variables. */\n-    private immutable string A = \"ECX\";\n-    private immutable string B = \"ESI\";\n-    private immutable string C = \"EDI\";\n-    private immutable string D = \"EBP\";\n-    private immutable string E = \"EDX\";\n-\n-    /* */\n-    version (_32Bit)\n-    {\n-        private immutable string SP = \"ESP\";\n-        private immutable string BUFFER_PTR = \"EAX\";\n-        private immutable string STATE_PTR = \"EBX\";\n-\n-        // Control byte for shuffle instruction (only used in round 0-15)\n-        private immutable string X_SHUFFLECTL = \"XMM6\";\n-\n-        // Round constant (only used in round 0-15)\n-        private immutable string X_CONSTANT = \"XMM7\";\n-    }\n-    version (_64Bit)\n-    {\n-        private immutable string SP = \"RSP\";\n-        private immutable string BUFFER_PTR = \"R9\";\n-        private immutable string STATE_PTR = \"R8\";\n-        private immutable string CONSTANTS_PTR = \"R10\";\n-\n-        // Registers for temporary results (XMM10 and XMM11 are also used temporary)\n-        private immutable string W_TMP = \"XMM8\";\n-        private immutable string W_TMP2 = \"XMM9\";\n-\n-        // Control byte for shuffle instruction (only used in round 0-15)\n-        private immutable string X_SHUFFLECTL = \"XMM12\";\n-\n-        // Round constant\n-        private immutable string X_CONSTANT = \"XMM13\";\n-    }\n-\n-    /* The control words for the byte shuffle instruction and the round constants. */\n-    align(16) public immutable uint[20] constants =\n-    [\n-        // The control words for the byte shuffle instruction.\n-        0x0001_0203, 0x0405_0607, 0x0809_0a0b, 0x0c0d_0e0f,\n-        // Constants for round 0-19\n-        0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,\n-        // Constants for round 20-39\n-        0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,\n-        // Constants for round 40-59\n-        0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,\n-        // Constants for round 60-79\n-        0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6\n-    ];\n-\n-    /** Simple version to produce numbers < 100 as string. */\n-    private nothrow pure string to_string(uint i)\n-    {\n-        if (i < 10)\n-            return \"0123456789\"[i .. i + 1];\n-\n-        assert(i < 100);\n-        char[2] s;\n-        s[0] = cast(char)(i / 10 + '0');\n-        s[1] = cast(char)(i % 10 + '0');\n-        return s.idup;\n-    }\n-\n-    /** Returns the reference to the byte shuffle control word. */\n-    private nothrow pure string bswap_shufb_ctl()\n-    {\n-        version (_64Bit)\n-            return \"[\"~CONSTANTS_PTR~\"]\";\n-        else\n-            return \"[constants]\";\n-    }\n-\n-    /** Returns the reference to constant used in round i. */\n-    private nothrow pure string constant(uint i)\n-    {\n-        version (_64Bit)\n-            return \"16 + 16*\"~to_string(i/20)~\"[\"~CONSTANTS_PTR~\"]\";\n-        else\n-            return \"[constants + 16 + 16*\"~to_string(i/20)~\"]\";\n-    }\n-\n-    /** Returns the XMM register number used in round i */\n-    private nothrow pure uint regno(uint i)\n-    {\n-        return (i/4)&7;\n-    }\n-\n-    /** Returns reference to storage of vector W[i .. i+4]. */\n-    private nothrow pure string WiV(uint i)\n-    {\n-        return \"[\"~SP~\" + WI_PTR + \"~to_string((i/4)&7)~\"*16]\";\n-    }\n-\n-    /** Returns reference to storage of vector (W + K)[i .. i+4]. */\n-    private nothrow pure string WiKiV(uint i)\n-    {\n-        return \"[\"~SP~\" + WI_PLUS_KI_PTR + \"~to_string((i/4)&3)~\"*16]\";\n-    }\n-\n-    /** Returns reference to storage of value W[i] + K[i]. */\n-    private nothrow pure string WiKi(uint i)\n-    {\n-        return \"[\"~SP~\" + WI_PLUS_KI_PTR + 4*\"~to_string(i&15)~\"]\";\n-    }\n-\n-    /**\n-     * Chooses the instruction sequence based on the 32bit or 64bit model.\n-     */\n-    private nothrow pure string[] swt3264(string[] insn32, string[] insn64)\n-    {\n-        version (_32Bit)\n-        {\n-            return insn32;\n-        }\n-        version (_64Bit)\n-        {\n-            return insn64;\n-        }\n-    }\n-\n-    /**\n-     * Flattens the instruction sequence and wraps it in an asm block.\n-     */\n-    private nothrow pure string wrap(string[] insn)\n-    {\n-        string s = \"asm pure nothrow @nogc {\";\n-        foreach (t; insn) s ~= (t ~ \"; \\n\");\n-        s ~= \"}\";\n-        return s;\n-        // Is not CTFE:\n-        // return \"asm pure nothrow @nogc { \" ~ join(insn, \"; \\n\") ~ \"}\";\n-    }\n-\n-    /**\n-     * Weaves the 2 instruction sequences together.\n-     */\n-    private nothrow pure string[] weave(string[] seq1, string[] seq2, uint dist = 1)\n-    {\n-        string[] res = [];\n-        auto i1 = 0, i2 = 0;\n-        while (i1 < seq1.length || i2 < seq2.length)\n-        {\n-            if (i2 < seq2.length)\n-            {\n-                res ~= seq2[i2 .. i2+1];\n-                i2 += 1;\n-            }\n-            if (i1 < seq1.length)\n-            {\n-                import std.algorithm.comparison : min;\n-\n-                res ~= seq1[i1 .. min(i1+dist, $)];\n-                i1 += dist;\n-            }\n-        }\n-        return res;\n-    }\n-\n-    /**\n-     * Generates instructions to load state from memory into registers.\n-     */\n-    private nothrow pure string[] loadstate(string base, string a, string b, string c, string d, string e)\n-    {\n-        return [\"mov \"~a~\",[\"~base~\" + 0*4]\",\n-                \"mov \"~b~\",[\"~base~\" + 1*4]\",\n-                \"mov \"~c~\",[\"~base~\" + 2*4]\",\n-                \"mov \"~d~\",[\"~base~\" + 3*4]\",\n-                \"mov \"~e~\",[\"~base~\" + 4*4]\" ];\n-    }\n-\n-    /**\n-     * Generates instructions to update state from registers, saving result in memory.\n-     */\n-    private nothrow pure string[] savestate(string base, string a, string b, string c, string d, string e)\n-    {\n-        return [\"add [\"~base~\" + 0*4],\"~a,\n-                \"add [\"~base~\" + 1*4],\"~b,\n-                \"add [\"~base~\" + 2*4],\"~c,\n-                \"add [\"~base~\" + 3*4],\"~d,\n-                \"add [\"~base~\" + 4*4],\"~e ];\n-    }\n-\n-    /** Calculates Ch(x, y, z) = z ^ (x & (y ^ z)) */\n-    private nothrow pure string[] Ch(string x, string y, string z)\n-    {\n-        return [\"mov \"~T1~\",\"~y,\n-                \"xor \"~T1~\",\"~z,\n-                \"and \"~T1~\",\"~x,\n-                \"xor \"~T1~\",\"~z ];\n-    }\n-\n-    /** Calculates Parity(x, y, z) = x ^ y ^ z */\n-    private nothrow pure string[] Parity(string x, string y, string z)\n-    {\n-        return [\"mov \"~T1~\",\"~z,\n-                \"xor \"~T1~\",\"~y,\n-                \"xor \"~T1~\",\"~x ];\n-    }\n-\n-    /** Calculates Maj(x, y, z) = (x & y) | (z & (x ^ y)) */\n-    private nothrow pure string[] Maj(string x, string y, string z)\n-    {\n-        return [\"mov \"~T1~\",\"~y,\n-                \"mov \"~T2~\",\"~x,\n-                \"or  \"~T1~\",\"~x,\n-                \"and \"~T2~\",\"~y,\n-                \"and \"~T1~\",\"~z,\n-                \"or  \"~T1~\",\"~T2 ];\n-    }\n-\n-    /** Returns function for round i. Function returns result in T1 and may destroy T2. */\n-    private nothrow pure string[] F(int i, string b, string c, string d)\n-    {\n-        string[] insn;\n-        if (i >=  0 && i <= 19) insn = Ch(b, c, d);\n-        else if (i >= 20 && i <= 39) insn = Parity(b, c, d);\n-        else if (i >= 40 && i <= 59) insn = Maj(b, c, d);\n-        else if (i >= 60 && i <= 79) insn = Parity(b, c, d);\n-        else assert(false, \"Coding error\");\n-        return insn;\n-    }\n-\n-    /** Returns instruction used to setup a round. */\n-    private nothrow pure string[] xsetup(int i)\n-    {\n-        if (i == 0)\n-        {\n-            return swt3264([\"movdqa \"~X_SHUFFLECTL~\",\"~bswap_shufb_ctl(),\n-                             \"movdqa \"~X_CONSTANT~\",\"~constant(i)],\n-                            [\"movdqa \"~X_SHUFFLECTL~\",\"~bswap_shufb_ctl(),\n-                             \"movdqa \"~X_CONSTANT~\",\"~constant(i)]);\n-        }\n-        version (_64Bit)\n-        {\n-            if (i%20 == 0)\n-            {\n-                return [\"movdqa \"~X_CONSTANT~\",\"~constant(i)];\n-            }\n-        }\n-        return [];\n-    }\n-\n-    /**\n-     * Loads the message words and performs the little to big endian conversion.\n-     * Requires that the shuffle control word and the round constant is loaded\n-     * into required XMM register. The BUFFER_PTR register must point to the\n-     * buffer.\n-     */\n-    private nothrow pure string[] precalc_00_15(int i)\n-    {\n-        int regno = regno(i);\n-\n-        string W = \"XMM\" ~ to_string(regno);\n-        version (_32Bit)\n-        {\n-            string W_TMP = \"XMM\" ~ to_string(regno+2);\n-        }\n-        version (_64Bit)\n-        {\n-            string W_TMP = \"XMM\" ~ to_string(regno+8);\n-        }\n-\n-        if ((i & 3) == 0)\n-        {\n-            return [\"movdqu \"~W~\",[\"~BUFFER_PTR~\" + \"~to_string(regno)~\"*16]\"];\n-        }\n-        else if ((i & 3) == 1)\n-        {\n-            return [\"pshufb \"~W~\",\"~X_SHUFFLECTL] ~\n-                    swt3264([\"movdqa \"~WiV(i)~\",\"~W], []);\n-        }\n-        else if ((i & 3) == 2)\n-        {\n-            return [\"movdqa \"~W_TMP~\",\"~W,\n-                    \"paddd \"~W_TMP~\",\"~X_CONSTANT,\n-                   ];\n-        }\n-        else\n-        {\n-            return [\"movdqa \"~WiKiV(i)~\",\"~W_TMP,\n-                   ];\n-        }\n-    }\n-\n-    /**\n-     * Done on 4 consequtive W[i] values in a single XMM register\n-     *  W[i  ] = (W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16]) rol 1\n-     *  W[i+1] = (W[i-2] ^ W[i-7] ^ W[i-13] ^ W[i-15]) rol 1\n-     *  W[i+2] = (W[i-1] ^ W[i-6] ^ W[i-12] ^ W[i-14]) rol 1\n-     *  W[i+3] = (   0   ^ W[i-5] ^ W[i-11] ^ W[i-13]) rol 1\n-     *\n-     * This additional calculation unfortunately requires many additional operations\n-     *  W[i+3] ^= W[i] rol 1\n-     *\n-     * Once we have 4 W[i] values in XMM we can also add four K values with one instruction\n-     *   W[i:i+3] += {K,K,K,K}\n-     */\n-    private nothrow pure string[] precalc_16_31(int i)\n-    {\n-        int regno = regno(i);\n-\n-        string W = \"XMM\" ~ to_string(regno);\n-        string W_minus_4 = \"XMM\" ~ to_string((regno-1)&7);\n-        string W_minus_8 = \"XMM\" ~ to_string((regno-2)&7);\n-        string W_minus_12 = \"XMM\" ~ to_string((regno-3)&7);\n-        string W_minus_16 = \"XMM\" ~ to_string((regno-4)&7);\n-        version (_32Bit)\n-        {\n-            string W_TMP = \"XMM\" ~ to_string((regno+1)&7);\n-            string W_TMP2 = \"XMM\" ~ to_string((regno+2)&7);\n-        }\n-\n-        if ((i & 3) == 0)\n-        {\n-            return [\"movdqa \"~W~\",\"~W_minus_12,\n-                    \"palignr \"~W~\",\"~W_minus_16~\",8\",   // W[i] = W[i-14]\n-                    \"pxor \"~W~\",\"~W_minus_16,           // W[i] ^= W[i-16]\n-                    \"pxor \"~W~\",\"~W_minus_8,            // W[i] ^= W[i-8]\n-                    \"movdqa \"~W_TMP~\",\"~W_minus_4,\n-            ];\n-        }\n-        else if ((i & 3) == 1)\n-        {\n-            return [\"psrldq \"~W_TMP~\",4\",               // W[i-3]\n-                    \"pxor \"~W~\",\"~W_TMP,                // W[i] ^= W[i-3]\n-                    \"movdqa \"~W_TMP~\",\"~W,\n-                    \"psrld \"~W~\",31\",\n-                    \"pslld \"~W_TMP~\",1\",\n-            ];\n-        }\n-        else if ((i & 3) == 2)\n-        {\n-            return [\"por \"~W~\",\"~W_TMP,\n-                    \"movdqa \"~W_TMP~\",\"~W,\n-                    \"pslldq \"~W_TMP~\",12\",\n-                    \"movdqa \"~W_TMP2~\",\"~W_TMP,\n-                    \"pslld \"~W_TMP~\",1\",\n-            ];\n-        }\n-        else\n-        {\n-            return [\"psrld \"~W_TMP2~\",31\",\n-                    \"por \"~W_TMP~\",\"~W_TMP2,\n-                    \"pxor \"~W~\",\"~W_TMP,\n-                    \"movdqa \"~W_TMP~\",\"~W ] ~\n-                   swt3264([\"movdqa \"~WiV(i)~\",\"~W,\n-                            \"paddd \"~W_TMP~\",\"~constant(i) ],\n-                           [\"paddd \"~W_TMP~\",\"~X_CONSTANT ]) ~\n-                   [\"movdqa \"~WiKiV(i)~\",\"~W_TMP];\n-        }\n-    }\n-\n-    /** Performs the main calculation as decribed above. */\n-    private nothrow pure string[] precalc_32_79(int i)\n-    {\n-        int regno = regno(i);\n-\n-        string W = \"XMM\" ~ to_string(regno);\n-        string W_minus_4 = \"XMM\" ~ to_string((regno-1)&7);\n-        string W_minus_8 = \"XMM\" ~ to_string((regno-2)&7);\n-        string W_minus_16 = \"XMM\" ~ to_string((regno-4)&7);\n-        version (_32Bit)\n-        {\n-            string W_minus_28 = \"[ESP + WI_PTR + \"~ to_string((regno-7)&7)~\"*16]\";\n-            string W_minus_32 = \"[ESP + WI_PTR + \"~ to_string((regno-8)&7)~\"*16]\";\n-            string W_TMP = \"XMM\" ~ to_string((regno+1)&7);\n-            string W_TMP2 = \"XMM\" ~ to_string((regno+2)&7);\n-        }\n-        version (_64Bit)\n-        {\n-            string W_minus_28 = \"XMM\" ~ to_string((regno-7)&7);\n-            string W_minus_32 = \"XMM\" ~ to_string((regno-8)&7);\n-        }\n-\n-        if ((i & 3) == 0)\n-        {\n-            return swt3264([\"movdqa \"~W~\",\"~W_minus_32], []) ~\n-                   [\"movdqa \"~W_TMP~\",\"~W_minus_4,\n-                    \"pxor \"~W~\",\"~W_minus_28,         // W is W_minus_32 before xor\n-                    \"palignr \"~W_TMP~\",\"~W_minus_8~\",8\",\n-            ];\n-        }\n-        else if ((i & 3) == 1)\n-        {\n-            return [\"pxor \"~W~\",\"~W_minus_16,\n-                    \"pxor \"~W~\",\"~W_TMP,\n-                    \"movdqa \"~W_TMP~\",\"~W,\n-            ];\n-        }\n-        else if ((i & 3) == 2)\n-        {\n-            return [\"psrld \"~W~\",30\",\n-                    \"pslld \"~W_TMP~\",2\",\n-                    \"por \"~W_TMP~\",\"~W,\n-            ];\n-        }\n-        else\n-        {\n-            if (i < 76)\n-                return [\"movdqa \"~W~\",\"~W_TMP] ~\n-                       swt3264([\"movdqa \"~WiV(i)~\",\"~W,\n-                                \"paddd \"~W_TMP~\",\"~constant(i)],\n-                               [\"paddd \"~W_TMP~\",\"~X_CONSTANT]) ~\n-                       [\"movdqa \"~WiKiV(i)~\",\"~W_TMP];\n-            else\n-                return swt3264([\"paddd \"~W_TMP~\",\"~constant(i)],\n-                               [\"paddd \"~W_TMP~\",\"~X_CONSTANT]) ~\n-                       [\"movdqa \"~WiKiV(i)~\",\"~W_TMP];\n-        }\n-    }\n-\n-    /** Choose right precalc method. */\n-    private nothrow pure string[] precalc(int i)\n-    {\n-        if (i >= 0 && i < 16) return precalc_00_15(i);\n-        if (i >= 16 && i < 32) return precalc_16_31(i);\n-        if (i >= 32 && i < 80) return precalc_32_79(i);\n-        return [];\n-    }\n-\n-    /**\n-     * Return code for round i and i+1.\n-     * Performs the following rotation:\n-     * in=>out: A=>D, B=>E, C=>A, D=>B, E=>C\n-     */\n-    private nothrow pure string[] round(int i, string a, string b, string c, string d, string e)\n-    {\n-        return xsetup(PRECALC_AHEAD + i) ~\n-               weave(F(i, b, c, d) ~ // Returns result in T1; may destroy T2\n-               [\"add \"~e~\",\"~WiKi(i),\n-                \"ror \"~b~\",2\",\n-                \"mov \"~T2~\",\"~a,\n-                \"add \"~d~\",\"~WiKi(i+1),\n-                \"rol \"~T2~\",5\",\n-                \"add \"~e~\",\"~T1 ],\n-                precalc(PRECALC_AHEAD + i), 2) ~\n-               weave(\n-               [\"add \"~T2~\",\"~e,  // T2 = (A <<< 5) + F(B, C, D) + Wi + Ki + E\n-                \"mov \"~e~\",\"~T2,\n-                \"rol \"~T2~\",5\",\n-                \"add \"~d~\",\"~T2 ] ~\n-               F(i+1, a, b, c) ~ // Returns result in T1; may destroy T2\n-               [\"add \"~d~\",\"~T1,\n-                \"ror \"~a~\",2\"],\n-                precalc(PRECALC_AHEAD + i+1), 2);\n-    }\n-\n-    // Offset into stack (see below)\n-    version (_32Bit)\n-    {\n-        private enum { STATE_OFS = 4, WI_PLUS_KI_PTR = 8, WI_PTR = 72 };\n-    }\n-    version (_64Bit)\n-    {\n-        private enum { WI_PLUS_KI_PTR = 0 };\n-    }\n-\n-    /** The prologue sequence. */\n-    private nothrow pure string[] prologue()\n-    {\n-        version (_32Bit)\n-        {\n-            /*\n-             * Parameters:\n-             *   EAX contains pointer to input buffer\n-             *\n-             * Stack layout as follows:\n-             * +----------------+\n-             * | ptr to state   |\n-             * +----------------+\n-             * | return address |\n-             * +----------------+\n-             * | EBP            |\n-             * +----------------+\n-             * | ESI            |\n-             * +----------------+\n-             * | EDI            |\n-             * +----------------+\n-             * | EBX            |\n-             * +----------------+\n-             * | Space for      |\n-             * | Wi             | <- ESP+72\n-             * +----------------+\n-             * | Space for      |\n-             * | Wi+Ki          | <- ESP+8\n-             * +----------------+ <- 16byte aligned\n-             * | ptr to state   | <- ESP+4\n-             * +----------------+\n-             * | old ESP        | <- ESP\n-             * +----------------+\n-             */\n-            static assert(BUFFER_PTR == \"EAX\");\n-            static assert(STATE_PTR == \"EBX\");\n-            return [// Save registers according to calling convention\n-                    \"push EBP\",\n-                    \"push ESI\",\n-                    \"push EDI\",\n-                    \"push EBX\",\n-                    // Load parameters\n-                    \"mov EBX, [ESP + 5*4]\", //pointer to state\n-                    // Align stack\n-                    \"mov EBP, ESP\",\n-                    \"sub ESP, 4*16 + 8*16\",\n-                    \"and ESP, 0xffff_fff0\",\n-                    \"push EBX\",\n-                    \"push EBP\",\n-            ];\n-        }\n-        version (_64Bit)\n-        {\n-            /*\n-             * Parameters:\n-             *   RDX contains pointer to state\n-             *   RSI contains pointer to input buffer\n-             *   RDI contains pointer to constants\n-             *\n-             * Stack layout as follows:\n-             * +----------------+\n-             * | return address |\n-             * +----------------+\n-             * | RBP            |\n-             * +----------------+\n-             * | RBX            |\n-             * +----------------+\n-             * | Unused         |\n-             * +----------------+\n-             * | Space for      |\n-             * | Wi+Ki          | <- RSP\n-             * +----------------+ <- 16byte aligned\n-             */\n-            return [// Save registers according to calling convention\n-                    \"push RBP\",\n-                    \"push RBX\",\n-                    // Save parameters\n-                    \"mov \"~STATE_PTR~\", RDX\", //pointer to state\n-                    \"mov \"~BUFFER_PTR~\", RSI\", //pointer to buffer\n-                    \"mov \"~CONSTANTS_PTR~\", RDI\", //pointer to constants to avoid absolute addressing\n-                    // Align stack\n-                    \"sub RSP, 4*16+8\",\n-            ];\n-        }\n-    }\n-\n-    /**\n-      * The epilogue sequence. Just pop the saved registers from stack and return to caller.\n-      */\n-    private nothrow pure string[] epilogue()\n-    {\n-        version (_32Bit)\n-        {\n-            return [\"pop ESP\",\n-                    \"pop EBX\",\n-                    \"pop EDI\",\n-                    \"pop ESI\",\n-                    \"pop EBP\",\n-                    \"ret 4\",\n-                   ];\n-        }\n-        version (_64Bit)\n-        {\n-            return [\"add RSP,4*16+8\",\n-                    \"pop RBX\",\n-                    \"pop RBP\",\n-                    \"ret 0\",\n-                   ];\n-        }\n-    }\n-\n-    // constants as extra argument for PIC, see Bugzilla 9378\n-    import std.meta : AliasSeq;\n-    version (_64Bit)\n-        alias ExtraArgs = AliasSeq!(typeof(&constants));\n-    else\n-        alias ExtraArgs = AliasSeq!();\n-\n-    /**\n-     *\n-     */\n-    public void transformSSSE3(uint[5]* state, const(ubyte[64])* buffer, ExtraArgs) pure nothrow @nogc\n-    {\n-        mixin(wrap([\"naked;\"] ~ prologue()));\n-        // Precalc first 4*16=64 bytes\n-        mixin(wrap(xsetup(0)));\n-        mixin(wrap(weave(precalc(0)~precalc(1)~precalc(2)~precalc(3),\n-                         precalc(4)~precalc(5)~precalc(6)~precalc(7))));\n-        mixin(wrap(weave(loadstate(STATE_PTR, A, B, C, D, E),\n-                   weave(precalc(8)~precalc(9)~precalc(10)~precalc(11),\n-                         precalc(12)~precalc(13)~precalc(14)~precalc(15)))));\n-        // Round 1\n-        mixin(wrap(round( 0, A, B, C, D, E)));\n-        mixin(wrap(round( 2, D, E, A, B, C)));\n-        mixin(wrap(round( 4, B, C, D, E, A)));\n-        mixin(wrap(round( 6, E, A, B, C, D)));\n-        mixin(wrap(round( 8, C, D, E, A, B)));\n-        mixin(wrap(round(10, A, B, C, D, E)));\n-        mixin(wrap(round(12, D, E, A, B, C)));\n-        mixin(wrap(round(14, B, C, D, E, A)));\n-        mixin(wrap(round(16, E, A, B, C, D)));\n-        mixin(wrap(round(18, C, D, E, A, B)));\n-        // Round 2\n-        mixin(wrap(round(20, A, B, C, D, E)));\n-        mixin(wrap(round(22, D, E, A, B, C)));\n-        mixin(wrap(round(24, B, C, D, E, A)));\n-        mixin(wrap(round(26, E, A, B, C, D)));\n-        mixin(wrap(round(28, C, D, E, A, B)));\n-        mixin(wrap(round(30, A, B, C, D, E)));\n-        mixin(wrap(round(32, D, E, A, B, C)));\n-        mixin(wrap(round(34, B, C, D, E, A)));\n-        mixin(wrap(round(36, E, A, B, C, D)));\n-        mixin(wrap(round(38, C, D, E, A, B)));\n-        // Round 3\n-        mixin(wrap(round(40, A, B, C, D, E)));\n-        mixin(wrap(round(42, D, E, A, B, C)));\n-        mixin(wrap(round(44, B, C, D, E, A)));\n-        mixin(wrap(round(46, E, A, B, C, D)));\n-        mixin(wrap(round(48, C, D, E, A, B)));\n-        mixin(wrap(round(50, A, B, C, D, E)));\n-        mixin(wrap(round(52, D, E, A, B, C)));\n-        mixin(wrap(round(54, B, C, D, E, A)));\n-        mixin(wrap(round(56, E, A, B, C, D)));\n-        mixin(wrap(round(58, C, D, E, A, B)));\n-        // Round 4\n-        mixin(wrap(round(60, A, B, C, D, E)));\n-        mixin(wrap(round(62, D, E, A, B, C)));\n-        mixin(wrap(round(64, B, C, D, E, A)));\n-        mixin(wrap(round(66, E, A, B, C, D)));\n-        mixin(wrap(round(68, C, D, E, A, B)));\n-        mixin(wrap(round(70, A, B, C, D, E)));\n-        mixin(wrap(round(72, D, E, A, B, C)));\n-        mixin(wrap(round(74, B, C, D, E, A)));\n-        mixin(wrap(round(76, E, A, B, C, D)));\n-        mixin(wrap(round(78, C, D, E, A, B)));\n-        version (_32Bit)\n-        {\n-            // Load pointer to state\n-            mixin(wrap([\"mov \"~STATE_PTR~\",[ESP + STATE_OFS]\"]));\n-        }\n-        mixin(wrap(savestate(STATE_PTR, A, B, C, D, E)));\n-        mixin(wrap(epilogue()));\n-    }\n-}"}, {"sha": "bd03d2e6fe9bfc5e906ae37ceaff5d9ef5ae4d64", "filename": "libphobos/src/std/internal/math/biguintx86.d", "status": "removed", "additions": 0, "deletions": 1353, "changes": 1353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee39274cb9ffb5415ab50fa102673b0394d4f39/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintx86.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee39274cb9ffb5415ab50fa102673b0394d4f39/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintx86.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintx86.d?ref=bee39274cb9ffb5415ab50fa102673b0394d4f39", "patch": "@@ -1,1353 +0,0 @@\n-/** Optimised asm arbitrary precision arithmetic ('bignum')\n- * routines for X86 processors.\n- *\n- * All functions operate on arrays of uints, stored LSB first.\n- * If there is a destination array, it will be the first parameter.\n- * Currently, all of these functions are subject to change, and are\n- * intended for internal use only.\n- * The symbol [#] indicates an array of machine words which is to be\n- * interpreted as a multi-byte number.\n- */\n-\n-/*          Copyright Don Clugston 2008 - 2010.\n- * Distributed under the Boost Software License, Version 1.0.\n- *    (See accompanying file LICENSE_1_0.txt or copy at\n- *          http://www.boost.org/LICENSE_1_0.txt)\n- */\n-/**\n- * In simple terms, there are 3 modern x86 microarchitectures:\n- * (a) the P6 family (Pentium Pro, PII, PIII, PM, Core), produced by Intel;\n- * (b) the K6, Athlon, and AMD64 families, produced by AMD; and\n- * (c) the Pentium 4, produced by Marketing.\n- *\n- * This code has been optimised for the Intel P6 family.\n- * Generally the code remains near-optimal for Intel Core2/Corei7, after\n- * translating EAX-> RAX, etc, since all these CPUs use essentially the same\n- * pipeline, and are typically limited by memory access.\n- * The code uses techniques described in Agner Fog's superb Pentium manuals\n- * available at www.agner.org.\n- * Not optimised for AMD, which can do two memory loads per cycle (Intel\n- * CPUs can only do one). Despite this, performance is superior on AMD.\n- * Performance is dreadful on P4.\n- *\n- *  Timing results (cycles per int)\n- *              --Intel Pentium--  --AMD--\n- *              PM     P4   Core2   K7\n- *  +,-         2.25  15.6   2.25   1.5\n- *  <<,>>       2.0    6.6   2.0    5.0\n- *    (<< MMX)  1.7    5.3   1.5    1.2\n- *  *           5.0   15.0   4.0    4.3\n- *  mulAdd      5.7   19.0   4.9    4.0\n- *  div        30.0   32.0  32.0   22.4\n- *  mulAcc(32)  6.5   20.0   5.4    4.9\n- *\n- * mulAcc(32) is multiplyAccumulate() for a 32*32 multiply. Thus it includes\n- * function call overhead.\n- * The timing for Div is quite unpredictable, but it's probably too slow\n- * to be useful. On 64-bit processors, these times should\n- * halve if run in 64-bit mode, except for the MMX functions.\n- */\n-\n-module std.internal.math.biguintx86;\n-\n-@system:\n-pure:\n-nothrow:\n-\n-/*\n-  Naked asm is used throughout, because:\n-  (a) it frees up the EBP register\n-  (b) compiler bugs prevent the use of .ptr when a frame pointer is used.\n-*/\n-\n-version (D_InlineAsm_X86)\n-{\n-\n-private:\n-\n-/* Duplicate string s, with n times, substituting index for '@'.\n- *\n- * Each instance of '@' in s is replaced by 0,1,...n-1. This is a helper\n- * function for some of the asm routines.\n- */\n-string indexedLoopUnroll(int n, string s) pure @safe\n-{\n-    string u;\n-    for (int i = 0; i<n; ++i)\n-    {\n-        string nstr= (i>9 ? \"\"~ cast(char)('0'+i/10) : \"\") ~ cast(char)('0' + i%10);\n-\n-        int last = 0;\n-        for (int j = 0; j<s.length; ++j)\n-        {\n-            if (s[j]=='@')\n-            {\n-                u ~= s[last .. j] ~ nstr;\n-                last = j+1;\n-            }\n-        }\n-        if (last<s.length) u = u ~ s[last..$];\n-\n-    }\n-    return u;\n-}\n-@safe unittest\n-{\n-    assert(indexedLoopUnroll(3, \"@*23;\")==\"0*23;1*23;2*23;\");\n-}\n-\n-public:\n-\n-alias BigDigit = uint; // A Bignum is an array of BigDigits. Usually the machine word size.\n-\n-// Limits for when to switch between multiplication algorithms.\n-enum : int { KARATSUBALIMIT = 18 }; // Minimum value for which Karatsuba is worthwhile.\n-enum : int { KARATSUBASQUARELIMIT=26 }; // Minimum value for which square Karatsuba is worthwhile\n-\n-/** Multi-byte addition or subtraction\n- *    dest[#] = src1[#] + src2[#] + carry (0 or 1).\n- * or dest[#] = src1[#] - src2[#] - carry (0 or 1).\n- * Returns carry or borrow (0 or 1).\n- * Set op == '+' for addition, '-' for subtraction.\n- */\n-uint multibyteAddSub(char op)(uint[] dest, const uint [] src1, const uint []\n-        src2, uint carry) pure\n-{\n-    // Timing:\n-    // Pentium M: 2.25/int\n-    // P6 family, Core2 have a partial flags stall when reading the carry flag in\n-    // an ADC, SBB operation after an operation such as INC or DEC which\n-    // modifies some, but not all, flags. We avoid this by storing carry into\n-    // a resister (AL), and restoring it after the branch.\n-\n-    enum { LASTPARAM = 4*4 } // 3* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-        push EDI;\n-        push EBX;\n-        push ESI;\n-        mov ECX, [ESP + LASTPARAM + 4*4]; // dest.length;\n-        mov EDX, [ESP + LASTPARAM + 3*4]; // src1.ptr\n-        mov ESI, [ESP + LASTPARAM + 1*4]; // src2.ptr\n-        mov EDI, [ESP + LASTPARAM + 5*4]; // dest.ptr\n-             // Carry is in EAX\n-        // Count UP to zero (from -len) to minimize loop overhead.\n-        lea EDX, [EDX + 4*ECX]; // EDX = end of src1.\n-        lea ESI, [ESI + 4*ECX]; // EBP = end of src2.\n-        lea EDI, [EDI + 4*ECX]; // EDI = end of dest.\n-\n-        neg ECX;\n-        add ECX, 8;\n-        jb L2;  // if length < 8 , bypass the unrolled loop.\n-L_unrolled:\n-        shr AL, 1; // get carry from EAX\n-    }\n-    mixin(\" asm pure nothrow {\"\n-        ~ indexedLoopUnroll( 8,\n-        \"mov EAX, [@*4-8*4+EDX+ECX*4];\"\n-        ~ ( op == '+' ? \"adc\" : \"sbb\" ) ~ \" EAX, [@*4-8*4+ESI+ECX*4];\"\n-        ~ \"mov [@*4-8*4+EDI+ECX*4], EAX;\")\n-        ~ \"}\");\n-    asm pure nothrow {\n-        setc AL; // save carry\n-        add ECX, 8;\n-        ja L_unrolled;\n-L2:     // Do the residual 1 .. 7 ints.\n-\n-        sub ECX, 8;\n-        jz done;\n-L_residual:\n-        shr AL, 1; // get carry from EAX\n-    }\n-    mixin(\" asm pure nothrow {\"\n-        ~ indexedLoopUnroll( 1,\n-        \"mov EAX, [@*4+EDX+ECX*4];\"\n-        ~ ( op == '+' ? \"adc\" : \"sbb\" ) ~ \" EAX, [@*4+ESI+ECX*4];\"\n-        ~ \"mov [@*4+EDI+ECX*4], EAX;\") ~ \"}\");\n-    asm pure nothrow {\n-        setc AL; // save carry\n-        add ECX, 1;\n-        jnz L_residual;\n-done:\n-        and EAX, 1; // make it O or 1.\n-        pop ESI;\n-        pop EBX;\n-        pop EDI;\n-        ret 6*4;\n-    }\n-}\n-\n-@system unittest\n-{\n-    uint [] a = new uint[40];\n-    uint [] b = new uint[40];\n-    uint [] c = new uint[40];\n-    for (int i=0; i<a.length; ++i)\n-    {\n-        if (i&1) a[i]=0x8000_0000 + i;\n-        else a[i]=i;\n-        b[i]= 0x8000_0003;\n-    }\n-    c[19]=0x3333_3333;\n-    uint carry = multibyteAddSub!('+')(c[0 .. 18], a[0 .. 18], b[0 .. 18], 0);\n-    assert(carry == 1);\n-    assert(c[0]==0x8000_0003);\n-    assert(c[1]==4);\n-    assert(c[19]==0x3333_3333); // check for overrun\n-    for (int i=0; i<a.length; ++i)\n-    {\n-        a[i]=b[i]=c[i]=0;\n-    }\n-    a[8]=0x048D159E;\n-    b[8]=0x048D159E;\n-    a[10]=0x1D950C84;\n-    b[10]=0x1D950C84;\n-    a[5] =0x44444444;\n-    carry = multibyteAddSub!('-')(a[0 .. 12], a[0 .. 12], b[0 .. 12], 0);\n-    assert(a[11]==0);\n-    for (int i=0; i<10; ++i) if (i != 5) assert(a[i]==0);\n-\n-    for (int q=3; q<36;++q)\n-    {\n-        for (int i=0; i<a.length; ++i)\n-        {\n-            a[i]=b[i]=c[i]=0;\n-        }\n-        a[q-2]=0x040000;\n-        b[q-2]=0x040000;\n-       carry = multibyteAddSub!('-')(a[0 .. q], a[0 .. q], b[0 .. q], 0);\n-       assert(a[q-2]==0);\n-    }\n-}\n-\n-/** dest[#] += carry, or dest[#] -= carry.\n- *  op must be '+' or '-'\n- *  Returns final carry or borrow (0 or 1)\n- */\n-uint multibyteIncrementAssign(char op)(uint[] dest, uint carry) pure\n-{\n-    enum { LASTPARAM = 1*4 } // 0* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-        mov ECX, [ESP + LASTPARAM + 0*4]; // dest.length;\n-        mov EDX, [ESP + LASTPARAM + 1*4]; // dest.ptr\n-        // EAX  = carry\n-L1: ;\n-    }\n-    static if (op=='+')\n-        asm pure nothrow { add [EDX], EAX; }\n-    else\n-        asm pure nothrow { sub [EDX], EAX; }\n-    asm pure nothrow {\n-        mov EAX, 1;\n-        jnc L2;\n-        add EDX, 4;\n-        dec ECX;\n-        jnz L1;\n-        mov EAX, 2;\n-L2:     dec EAX;\n-        ret 2*4;\n-    }\n-}\n-\n-/** dest[#] = src[#] << numbits\n- *  numbits must be in the range 1 .. 31\n- *  Returns the overflow\n- */\n-uint multibyteShlNoMMX(uint [] dest, const uint [] src, uint numbits) pure\n-{\n-    // Timing: Optimal for P6 family.\n-    // 2.0 cycles/int on PPro .. PM (limited by execution port p0)\n-    // 5.0 cycles/int on Athlon, which has 7 cycles for SHLD!!\n-    enum { LASTPARAM = 4*4 } // 3* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-        mov EDI, [ESP + LASTPARAM + 4*3]; //dest.ptr;\n-        mov EBX, [ESP + LASTPARAM + 4*2]; //dest.length;\n-        mov ESI, [ESP + LASTPARAM + 4*1]; //src.ptr;\n-        mov ECX, EAX; // numbits;\n-\n-        mov EAX, [-4+ESI + 4*EBX];\n-        mov EDX, 0;\n-        shld EDX, EAX, CL;\n-        push EDX; // Save return value\n-        cmp EBX, 1;\n-        jz L_last;\n-        mov EDX, [-4+ESI + 4*EBX];\n-        test EBX, 1;\n-        jz L_odd;\n-        sub EBX, 1;\n-L_even:\n-        mov EDX, [-4+ ESI + 4*EBX];\n-        shld EAX, EDX, CL;\n-        mov [EDI+4*EBX], EAX;\n-L_odd:\n-        mov EAX, [-8+ESI + 4*EBX];\n-        shld EDX, EAX, CL;\n-        mov [-4+EDI + 4*EBX], EDX;\n-        sub EBX, 2;\n-        jg L_even;\n-L_last:\n-        shl EAX, CL;\n-        mov [EDI], EAX;\n-        pop EAX; // pop return value\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 4*4;\n-    }\n-}\n-\n-/** dest[#] = src[#] >> numbits\n- *  numbits must be in the range 1 .. 31\n- * This version uses MMX.\n- */\n-uint multibyteShl(uint [] dest, const uint [] src, uint numbits) pure\n-{\n-    // Timing:\n-    // K7 1.2/int. PM 1.7/int P4 5.3/int\n-    enum { LASTPARAM = 4*4 } // 3* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-        mov EDI, [ESP + LASTPARAM + 4*3]; //dest.ptr;\n-        mov EBX, [ESP + LASTPARAM + 4*2]; //dest.length;\n-        mov ESI, [ESP + LASTPARAM + 4*1]; //src.ptr;\n-\n-        movd MM3, EAX; // numbits = bits to shift left\n-        xor EAX, 63;\n-        align   16;\n-        inc EAX;\n-        movd MM4, EAX ; // 64-numbits = bits to shift right\n-\n-        // Get the return value into EAX\n-        and EAX, 31; // EAX = 32-numbits\n-        movd MM2, EAX; // 32-numbits\n-        movd MM1, [ESI+4*EBX-4];\n-        psrlq MM1, MM2;\n-        movd EAX, MM1;  // EAX = return value\n-        test EBX, 1;\n-        jz L_even;\n-L_odd:\n-        cmp EBX, 1;\n-        jz L_length1;\n-\n-         // deal with odd lengths\n-        movq MM1, [ESI+4*EBX-8];\n-        psrlq MM1, MM2;\n-        movd    [EDI +4*EBX-4], MM1;\n-        sub EBX, 1;\n-L_even: // It's either singly or doubly even\n-        movq    MM2, [ESI + 4*EBX - 8];\n-        psllq   MM2, MM3;\n-        sub EBX, 2;\n-        jle L_last;\n-        movq MM1, MM2;\n-        add EBX, 2;\n-        test EBX, 2;\n-        jz L_onceeven;\n-        sub EBX, 2;\n-\n-        // MAIN LOOP -- 128 bytes per iteration\n- L_twiceeven:      // here MM2 is the carry\n-        movq    MM0, [ESI + 4*EBX-8];\n-        psrlq   MM0, MM4;\n-        movq    MM1, [ESI + 4*EBX-8];\n-        psllq   MM1, MM3;\n-        por     MM2, MM0;\n-        movq    [EDI +4*EBX], MM2;\n-L_onceeven:        // here MM1 is the carry\n-        movq    MM0, [ESI + 4*EBX-16];\n-        psrlq   MM0, MM4;\n-        movq    MM2, [ESI + 4*EBX-16];\n-        por     MM1, MM0;\n-        movq    [EDI +4*EBX-8], MM1;\n-        psllq   MM2, MM3;\n-        sub EBX, 4;\n-        jg L_twiceeven;\n-L_last:\n-        movq    [EDI +4*EBX], MM2;\n-L_alldone:\n-        emms;  // NOTE: costs 6 cycles on Intel CPUs\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 4*4;\n-\n-L_length1:\n-        // length 1 is a special case\n-        movd MM1, [ESI];\n-        psllq MM1, MM3;\n-        movd [EDI], MM1;\n-        jmp L_alldone;\n-    }\n-}\n-\n-void multibyteShr(uint [] dest, const uint [] src, uint numbits) pure\n-{\n-    enum { LASTPARAM = 4*4 } // 3* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-        mov EDI, [ESP + LASTPARAM + 4*3]; //dest.ptr;\n-        mov EBX, [ESP + LASTPARAM + 4*2]; //dest.length;\n-align 16;\n-        mov ESI, [ESP + LASTPARAM + 4*1]; //src.ptr;\n-        lea EDI, [EDI + 4*EBX]; // EDI = end of dest\n-        lea ESI, [ESI + 4*EBX]; // ESI = end of src\n-        neg EBX;                // count UP to zero.\n-\n-        movd MM3, EAX; // numbits = bits to shift right\n-        xor EAX, 63;\n-        inc EAX;\n-        movd MM4, EAX ; // 64-numbits = bits to shift left\n-\n-        test EBX, 1;\n-        jz L_even;\n-L_odd:\n-         // deal with odd lengths\n-        and EAX, 31; // EAX = 32-numbits\n-        movd MM2, EAX; // 32-numbits\n-        cmp EBX, -1;\n-        jz L_length1;\n-\n-        movq MM0, [ESI+4*EBX];\n-        psrlq MM0, MM3;\n-        movd    [EDI +4*EBX], MM0;\n-        add EBX, 1;\n-L_even:\n-        movq    MM2, [ESI + 4*EBX];\n-        psrlq   MM2, MM3;\n-\n-        movq MM1, MM2;\n-        add EBX, 4;\n-        cmp EBX, -2+4;\n-        jz L_last;\n-        // It's either singly or doubly even\n-        sub EBX, 2;\n-        test EBX, 2;\n-        jnz L_onceeven;\n-        add EBX, 2;\n-\n-        // MAIN LOOP -- 128 bytes per iteration\n- L_twiceeven:      // here MM2 is the carry\n-        movq    MM0, [ESI + 4*EBX-8];\n-        psllq   MM0, MM4;\n-        movq    MM1, [ESI + 4*EBX-8];\n-        psrlq   MM1, MM3;\n-        por     MM2, MM0;\n-        movq    [EDI +4*EBX-16], MM2;\n-L_onceeven:        // here MM1 is the carry\n-        movq    MM0, [ESI + 4*EBX];\n-        psllq   MM0, MM4;\n-        movq    MM2, [ESI + 4*EBX];\n-        por     MM1, MM0;\n-        movq    [EDI +4*EBX-8], MM1;\n-        psrlq   MM2, MM3;\n-        add EBX, 4;\n-        jl L_twiceeven;\n-L_last:\n-        movq    [EDI +4*EBX-16], MM2;\n-L_alldone:\n-        emms;  // NOTE: costs 6 cycles on Intel CPUs\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 4*4;\n-\n-L_length1:\n-        // length 1 is a special case\n-        movd MM1, [ESI+4*EBX];\n-        psrlq MM1, MM3;\n-        movd    [EDI +4*EBX], MM1;\n-        jmp L_alldone;\n-\n-    }\n-}\n-\n-/** dest[#] = src[#] >> numbits\n- *  numbits must be in the range 1 .. 31\n- */\n-void multibyteShrNoMMX(uint [] dest, const uint [] src, uint numbits) pure\n-{\n-    // Timing: Optimal for P6 family.\n-    // 2.0 cycles/int on PPro .. PM (limited by execution port p0)\n-    // Terrible performance on AMD64, which has 7 cycles for SHRD!!\n-    enum { LASTPARAM = 4*4 } // 3* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-        mov EDI, [ESP + LASTPARAM + 4*3]; //dest.ptr;\n-        mov EBX, [ESP + LASTPARAM + 4*2]; //dest.length;\n-        mov ESI, [ESP + LASTPARAM + 4*1]; //src.ptr;\n-        mov ECX, EAX; // numbits;\n-\n-        lea EDI, [EDI + 4*EBX]; // EDI = end of dest\n-        lea ESI, [ESI + 4*EBX]; // ESI = end of src\n-        neg EBX;                // count UP to zero.\n-        mov EAX, [ESI + 4*EBX];\n-        cmp EBX, -1;\n-        jz L_last;\n-        mov EDX, [ESI + 4*EBX];\n-        test EBX, 1;\n-        jz L_odd;\n-        add EBX, 1;\n-L_even:\n-        mov EDX, [ ESI + 4*EBX];\n-        shrd EAX, EDX, CL;\n-        mov [-4 + EDI+4*EBX], EAX;\n-L_odd:\n-        mov EAX, [4 + ESI + 4*EBX];\n-        shrd EDX, EAX, CL;\n-        mov [EDI + 4*EBX], EDX;\n-        add EBX, 2;\n-        jl L_even;\n-L_last:\n-        shr EAX, CL;\n-        mov [-4 + EDI], EAX;\n-\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 4*4;\n-    }\n-}\n-\n-@system unittest\n-{\n-\n-    uint [] aa = [0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    multibyteShr(aa[0..$-1], aa, 4);\n-    assert(aa[0] == 0x6122_2222 && aa[1]==0xA455_5555\n-        && aa[2]==0xD899_9999 && aa[3]==0x0BCC_CCCC);\n-\n-    aa = [0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    multibyteShr(aa[2..$-1], aa[2..$-1], 4);\n-    assert(aa[0] == 0x1222_2223 && aa[1]==0x4555_5556\n-        && aa[2]==0xD899_9999 && aa[3]==0x0BCC_CCCC);\n-\n-    aa = [0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    multibyteShr(aa[0..$-2], aa, 4);\n-    assert(aa[1]==0xA455_5555 && aa[2]==0x0899_9999);\n-    assert(aa[0]==0x6122_2222);\n-    assert(aa[3]==0xBCCC_CCCD);\n-\n-\n-    aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    uint r = multibyteShl(aa[2 .. 4], aa[2 .. 4], 4);\n-    assert(aa[0] == 0xF0FF_FFFF && aa[1]==0x1222_2223\n-        && aa[2]==0x5555_5560 && aa[3]==0x9999_99A4 && aa[4]==0xBCCC_CCCD);\n-    assert(r == 8);\n-\n-    aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    r = multibyteShl(aa[1 .. 4], aa[1 .. 4], 4);\n-    assert(aa[0] == 0xF0FF_FFFF\n-        && aa[2]==0x5555_5561);\n-        assert(aa[3]==0x9999_99A4 && aa[4]==0xBCCC_CCCD);\n-    assert(r == 8);\n-        assert(aa[1]==0x2222_2230);\n-\n-    aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    r = multibyteShl(aa[0 .. 4], aa[1 .. 5], 31);\n-}\n-\n-/** dest[#] = src[#] * multiplier + carry.\n- * Returns carry.\n- */\n-uint multibyteMul(uint[] dest, const uint[] src, uint multiplier, uint carry)\n-    pure\n-{\n-    // Timing: definitely not optimal.\n-    // Pentium M: 5.0 cycles/operation, has 3 resource stalls/iteration\n-    // Fastest implementation found was 4.6 cycles/op, but not worth the complexity.\n-\n-    enum { LASTPARAM = 4*4 } // 4* pushes + return address.\n-    // We'll use p2 (load unit) instead of the overworked p0 or p1 (ALU units)\n-    // when initializing variables to zero.\n-    version (D_PIC)\n-    {\n-        enum { zero = 0 }\n-    }\n-    else\n-    {\n-        __gshared int zero = 0;\n-    }\n-    asm pure nothrow {\n-        naked;\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-\n-        mov EDI, [ESP + LASTPARAM + 4*4]; // dest.ptr\n-        mov EBX, [ESP + LASTPARAM + 4*3]; // dest.length\n-        mov ESI, [ESP + LASTPARAM + 4*2];  // src.ptr\n-        align 16;\n-        lea EDI, [EDI + 4*EBX]; // EDI = end of dest\n-        lea ESI, [ESI + 4*EBX]; // ESI = end of src\n-        mov ECX, EAX; // [carry]; -- last param is in EAX.\n-        neg EBX;                // count UP to zero.\n-        test EBX, 1;\n-        jnz L_odd;\n-        add EBX, 1;\n- L1:\n-        mov EAX, [-4 + ESI + 4*EBX];\n-        mul int ptr [ESP+LASTPARAM]; //[multiplier];\n-        add EAX, ECX;\n-        mov ECX, zero;\n-        mov [-4+EDI + 4*EBX], EAX;\n-        adc ECX, EDX;\n-L_odd:\n-        mov EAX, [ESI + 4*EBX];  // p2\n-        mul int ptr [ESP+LASTPARAM]; //[multiplier]; // p0*3,\n-        add EAX, ECX;\n-        mov ECX, zero;\n-        adc ECX, EDX;\n-        mov [EDI + 4*EBX], EAX;\n-        add EBX, 2;\n-        jl L1;\n-\n-        mov EAX, ECX; // get final carry\n-\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 5*4;\n-    }\n-}\n-\n-@system unittest\n-{\n-    uint [] aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    multibyteMul(aa[1 .. 4], aa[1 .. 4], 16, 0);\n-    assert(aa[0] == 0xF0FF_FFFF && aa[1] == 0x2222_2230 &&\n-        aa[2]==0x5555_5561 && aa[3]==0x9999_99A4 && aa[4]==0x0BCCC_CCCD);\n-}\n-\n-// The inner multiply-and-add loop, together with the Even entry point.\n-// Multiples by M_ADDRESS which should be \"ESP+LASTPARAM\" or \"ESP\". OP must be \"add\" or \"sub\"\n-// This is the most time-critical code in the BigInt library.\n-// It is used by both MulAdd, multiplyAccumulate, and triangleAccumulate\n-string asmMulAdd_innerloop(string OP, string M_ADDRESS) pure {\n-    // The bottlenecks in this code are extremely complicated. The MUL, ADD, and ADC\n-    // need 4 cycles on each of the ALUs units p0 and p1. So we use memory load\n-    // (unit p2) for initializing registers to zero.\n-    // There are also dependencies between the instructions, and we run up against the\n-    // ROB-read limit (can only read 2 registers per cycle).\n-    // We also need the number of uops in the loop to be a multiple of 3.\n-    // The only available execution unit for this is p3 (memory write). Unfortunately we can't do that\n-        // if Position-Independent Code is required.\n-\n-        // Register usage\n-    // ESI = end of src\n-    // EDI = end of dest\n-    // EBX = index. Counts up to zero (in steps of 2).\n-    // EDX:EAX = scratch, used in multiply.\n-    // ECX = carry1.\n-    // EBP = carry2.\n-        // ESP = points to the multiplier.\n-\n-        // The first member of 'dest' which will be modified is [EDI+4*EBX].\n-        // EAX must already contain the first member of 'src', [ESI+4*EBX].\n-\n-    version (D_PIC) { bool using_PIC = true; } else { bool using_PIC = false; }\n-    return \"\n-        // Entry point for even length\n-        add EBX, 1;\n-        mov EBP, ECX; // carry\n-\n-        mul int ptr [\" ~ M_ADDRESS ~ \"]; // M\n-        mov ECX, 0;\n-\n-        add EBP, EAX;\n-        mov EAX, [ESI+4*EBX];\n-        adc ECX, EDX;\n-\n-        mul int ptr [\" ~ M_ADDRESS ~ \"]; // M\n-        \" ~ OP ~ \" [-4+EDI+4*EBX], EBP;\n-        mov EBP, zero;\n-\n-        adc ECX, EAX;\n-        mov EAX, [4+ESI+4*EBX];\n-\n-        adc EBP, EDX;\n-        add EBX, 2;\n-        jnl L_done;\n-L1:\n-        mul int ptr [\" ~ M_ADDRESS ~ \"];\n-        \" ~ OP ~ \" [-8+EDI+4*EBX], ECX;\n-        adc EBP, EAX;\n-        mov ECX, zero;\n-        mov EAX, [ESI+4*EBX];\n-        adc ECX, EDX;\n-\" ~\n-        (using_PIC ? \"\" : \"   mov storagenop, EDX; \") // make #uops in loop a multiple of 3, can't do this in PIC mode.\n-~ \"\n-        mul int ptr [\" ~ M_ADDRESS ~ \"];\n-        \" ~ OP ~ \" [-4+EDI+4*EBX], EBP;\n-        mov EBP, zero;\n-\n-        adc ECX, EAX;\n-        mov EAX, [4+ESI+4*EBX];\n-\n-        adc EBP, EDX;\n-        add EBX, 2;\n-        jl L1;\n-L_done: \" ~ OP ~ \" [-8+EDI+4*EBX], ECX;\n-        adc EBP, 0;\n-\";\n-                // final carry is now in EBP\n-}\n-\n-string asmMulAdd_enter_odd(string OP, string M_ADDRESS) pure\n-{\n-    return \"\n-        mul int ptr [\" ~M_ADDRESS ~\"];\n-        mov EBP, zero;\n-        add ECX, EAX;\n-        mov EAX, [4+ESI+4*EBX];\n-\n-        adc EBP, EDX;\n-        add EBX, 2;\n-        jl L1;\n-        jmp L_done;\n-\";\n-}\n-\n-\n-\n-/**\n- * dest[#] += src[#] * multiplier OP carry(0 .. FFFF_FFFF).\n- * where op == '+' or '-'\n- * Returns carry out of MSB (0 .. FFFF_FFFF).\n- */\n-uint multibyteMulAdd(char op)(uint [] dest, const uint [] src, uint\n-        multiplier, uint carry) pure {\n-    // Timing: This is the most time-critical bignum function.\n-    // Pentium M: 5.4 cycles/operation, still has 2 resource stalls + 1load block/iteration\n-\n-    // The main loop is pipelined and unrolled by 2,\n-    //   so entry to the loop is also complicated.\n-\n-    // Register usage\n-    // EDX:EAX = multiply\n-    // EBX = counter\n-    // ECX = carry1\n-    // EBP = carry2\n-    // EDI = dest\n-    // ESI = src\n-\n-    enum string OP = (op=='+')? \"add\" : \"sub\";\n-    version (D_PIC)\n-    {\n-        enum { zero = 0 }\n-    }\n-    else\n-    {\n-        // use p2 (load unit) instead of the overworked p0 or p1 (ALU units)\n-        // when initializing registers to zero.\n-        __gshared int zero = 0;\n-        // use p3/p4 units\n-        __gshared int storagenop; // write-only\n-    }\n-\n-    enum { LASTPARAM = 5*4 } // 4* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-        push EBP;\n-        mov EDI, [ESP + LASTPARAM + 4*4]; // dest.ptr\n-        mov EBX, [ESP + LASTPARAM + 4*3]; // dest.length\n-        align 16;\n-        nop;\n-        mov ESI, [ESP + LASTPARAM + 4*2];  // src.ptr\n-        lea EDI, [EDI + 4*EBX]; // EDI = end of dest\n-        lea ESI, [ESI + 4*EBX]; // ESI = end of src\n-        mov EBP, 0;\n-        mov ECX, EAX; // ECX = input carry.\n-        neg EBX;                // count UP to zero.\n-        mov EAX, [ESI+4*EBX];\n-        test EBX, 1;\n-        jnz L_enter_odd;\n-    }\n-    // Main loop, with entry point for even length\n-    mixin(\"asm pure nothrow {\" ~ asmMulAdd_innerloop(OP, \"ESP+LASTPARAM\") ~ \"}\");\n-    asm pure nothrow {\n-        mov EAX, EBP; // get final carry\n-        pop EBP;\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 5*4;\n-    }\n-L_enter_odd:\n-    mixin(\"asm pure nothrow {\" ~ asmMulAdd_enter_odd(OP, \"ESP+LASTPARAM\") ~ \"}\");\n-}\n-\n-@system unittest\n-{\n-\n-    uint [] aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];\n-    uint [] bb = [0x1234_1234, 0xF0F0_F0F0, 0x00C0_C0C0, 0xF0F0_F0F0, 0xC0C0_C0C0];\n-    multibyteMulAdd!('+')(bb[1..$-1], aa[1..$-2], 16, 5);\n-    assert(bb[0] == 0x1234_1234 && bb[4] == 0xC0C0_C0C0);\n-    assert(bb[1] == 0x2222_2230 + 0xF0F0_F0F0+5 && bb[2] == 0x5555_5561+0x00C0_C0C0+1\n-         && bb[3] == 0x9999_99A4+0xF0F0_F0F0 );\n-}\n-\n-/**\n-   Sets result[#] = result[0 .. left.length] + left[#] * right[#]\n-\n-   It is defined in this way to allow cache-efficient multiplication.\n-   This function is equivalent to:\n-    ----\n-    for (int i = 0; i< right.length; ++i)\n-    {\n-        dest[left.length + i] = multibyteMulAdd(dest[i .. left.length+i],\n-                left, right[i], 0);\n-    }\n-    ----\n- */\n-void multibyteMultiplyAccumulate(uint [] dest, const uint[] left,\n-        const uint [] right) pure {\n-    // Register usage\n-    // EDX:EAX = used in multiply\n-    // EBX = index\n-    // ECX = carry1\n-    // EBP = carry2\n-    // EDI = end of dest for this pass through the loop. Index for outer loop.\n-    // ESI = end of left. never changes\n-    // [ESP] = M = right[i] = multiplier for this pass through the loop.\n-    // right.length is changed into dest.ptr+dest.length\n-    version (D_PIC)\n-    {\n-        enum { zero = 0 }\n-    }\n-    else\n-    {\n-        // use p2 (load unit) instead of the overworked p0 or p1 (ALU units)\n-        // when initializing registers to zero.\n-        __gshared int zero = 0;\n-        // use p3/p4 units\n-        __gshared int storagenop; // write-only\n-    }\n-\n-    enum { LASTPARAM = 6*4 } // 4* pushes + local + return address.\n-    asm pure nothrow {\n-        naked;\n-\n-        push ESI;\n-        push EDI;\n-        align 16;\n-        push EBX;\n-        push EBP;\n-        push EAX;    // local variable M\n-        mov EDI, [ESP + LASTPARAM + 4*5]; // dest.ptr\n-        mov EBX, [ESP + LASTPARAM + 4*2]; // left.length\n-        mov ESI, [ESP + LASTPARAM + 4*3];  // left.ptr\n-        lea EDI, [EDI + 4*EBX]; // EDI = end of dest for first pass\n-\n-        mov EAX, [ESP + LASTPARAM + 4*0]; // right.length\n-        lea EAX, [EDI + 4*EAX];\n-        mov [ESP + LASTPARAM + 4*0], EAX; // last value for EDI\n-\n-        lea ESI, [ESI + 4*EBX]; // ESI = end of left\n-        mov EAX, [ESP + LASTPARAM + 4*1]; // right.ptr\n-        mov EAX, [EAX];\n-        mov [ESP], EAX; // M\n-outer_loop:\n-        mov EBP, 0;\n-        mov ECX, 0; // ECX = input carry.\n-        neg EBX;                // count UP to zero.\n-        mov EAX, [ESI+4*EBX];\n-        test EBX, 1;\n-        jnz L_enter_odd;\n-    }\n-    // -- Inner loop, with even entry point\n-    mixin(\"asm pure nothrow { \" ~ asmMulAdd_innerloop(\"add\", \"ESP\") ~ \"}\");\n-    asm pure nothrow {\n-        mov [-4+EDI+4*EBX], EBP;\n-        add EDI, 4;\n-        cmp EDI, [ESP + LASTPARAM + 4*0]; // is EDI = &dest[$]?\n-        jz outer_done;\n-        mov EAX, [ESP + LASTPARAM + 4*1]; // right.ptr\n-        mov EAX, [EAX+4];                 // get new M\n-        mov [ESP], EAX;                   // save new M\n-        add int ptr [ESP + LASTPARAM + 4*1], 4; // right.ptr\n-        mov EBX, [ESP + LASTPARAM + 4*2]; // left.length\n-        jmp outer_loop;\n-outer_done:\n-        pop EAX;\n-        pop EBP;\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 6*4;\n-    }\n-L_enter_odd:\n-    mixin(\"asm pure nothrow {\" ~ asmMulAdd_enter_odd(\"add\", \"ESP\") ~ \"}\");\n-}\n-\n-/**  dest[#] /= divisor.\n- * overflow is the initial remainder, and must be in the range 0 .. divisor-1.\n- * divisor must not be a power of 2 (use right shift for that case;\n- * A division by zero will occur if divisor is a power of 2).\n- * Returns the final remainder\n- *\n- * Based on public domain code by Eric Bainville.\n- * (http://www.bealto.com/) Used with permission.\n- */\n-uint multibyteDivAssign(uint [] dest, uint divisor, uint overflow) pure\n-{\n-    // Timing: limited by a horrible dependency chain.\n-    // Pentium M: 18 cycles/op, 8 resource stalls/op.\n-    // EAX, EDX = scratch, used by MUL\n-    // EDI = dest\n-    // CL = shift\n-    // ESI = quotient\n-    // EBX = remainderhi\n-    // EBP = remainderlo\n-    // [ESP-4] = mask\n-    // [ESP] = kinv (2^64 /divisor)\n-    enum { LASTPARAM = 5*4 } // 4* pushes + return address.\n-    enum { LOCALS = 2*4} // MASK, KINV\n-    asm pure nothrow {\n-        naked;\n-\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-        push EBP;\n-\n-        mov EDI, [ESP + LASTPARAM + 4*2]; // dest.ptr\n-        mov EBX, [ESP + LASTPARAM + 4*1]; // dest.length\n-\n-        // Loop from msb to lsb\n-        lea     EDI, [EDI + 4*EBX];\n-        mov EBP, EAX; // rem is the input remainder, in 0 .. divisor-1\n-        // Build the pseudo-inverse of divisor k: 2^64/k\n-        // First determine the shift in ecx to get the max number of bits in kinv\n-        xor     ECX, ECX;\n-        mov     EAX, [ESP + LASTPARAM]; //divisor;\n-        mov     EDX, 1;\n-kinv1:\n-        inc     ECX;\n-        ror     EDX, 1;\n-        shl     EAX, 1;\n-        jnc     kinv1;\n-        dec     ECX;\n-        // Here, ecx is a left shift moving the msb of k to bit 32\n-\n-        mov     EAX, 1;\n-        shl     EAX, CL;\n-        dec     EAX;\n-        ror     EAX, CL ; //ecx bits at msb\n-        push    EAX; // MASK\n-\n-        // Then divide 2^(32+cx) by divisor (edx already ok)\n-        xor     EAX, EAX;\n-        div     int ptr [ESP + LASTPARAM +  LOCALS-4*1]; //divisor;\n-        push    EAX; // kinv\n-        align   16;\n-L2:\n-        // Get 32 bits of quotient approx, multiplying\n-        // most significant word of (rem*2^32+input)\n-        mov     EAX, [ESP+4]; //MASK;\n-        and     EAX, [EDI - 4];\n-        or      EAX, EBP;\n-        rol     EAX, CL;\n-        mov     EBX, EBP;\n-        mov     EBP, [EDI - 4];\n-        mul     int ptr [ESP]; //KINV;\n-\n-        shl     EAX, 1;\n-        rcl     EDX, 1;\n-\n-        // Multiply by k and subtract to get remainder\n-        // Subtraction must be done on two words\n-        mov     EAX, EDX;\n-        mov     ESI, EDX; // quot = high word\n-        mul     int ptr [ESP + LASTPARAM+LOCALS]; //divisor;\n-        sub     EBP, EAX;\n-        sbb     EBX, EDX;\n-        jz      Lb;  // high word is 0, goto adjust on single word\n-\n-        // Adjust quotient and remainder on two words\n-Ld:     inc     ESI;\n-        sub     EBP, [ESP + LASTPARAM+LOCALS]; //divisor;\n-        sbb     EBX, 0;\n-        jnz     Ld;\n-\n-        // Adjust quotient and remainder on single word\n-Lb:     cmp     EBP, [ESP + LASTPARAM+LOCALS]; //divisor;\n-        jc      Lc; // rem in 0 .. divisor-1, OK\n-        sub     EBP, [ESP + LASTPARAM+LOCALS]; //divisor;\n-        inc     ESI;\n-        jmp     Lb;\n-\n-        // Store result\n-Lc:\n-        mov     [EDI - 4], ESI;\n-        lea     EDI, [EDI - 4];\n-        dec     int ptr [ESP + LASTPARAM + 4*1+LOCALS]; // len\n-        jnz    L2;\n-\n-        pop EAX; // discard kinv\n-        pop EAX; // discard mask\n-\n-        mov     EAX, EBP; // return final remainder\n-        pop     EBP;\n-        pop     EBX;\n-        pop     EDI;\n-        pop     ESI;\n-        ret     3*4;\n-    }\n-}\n-\n-@system unittest\n-{\n-    uint [] aa = new uint[101];\n-    for (int i=0; i<aa.length; ++i) aa[i] = 0x8765_4321 * (i+3);\n-    uint overflow = multibyteMul(aa, aa, 0x8EFD_FCFB, 0x33FF_7461);\n-    uint r = multibyteDivAssign(aa, 0x8EFD_FCFB, overflow);\n-    for (int i=0; i<aa.length-1; ++i) assert(aa[i] == 0x8765_4321 * (i+3));\n-    assert(r == 0x33FF_7461);\n-}\n-\n-// Set dest[2*i .. 2*i+1]+=src[i]*src[i]\n-void multibyteAddDiagonalSquares(uint [] dest, const uint [] src) pure\n-{\n-    /* Unlike mulAdd, the carry is only 1 bit,\n-           since FFFF*FFFF+FFFF_FFFF = 1_0000_0000.\n-           Note also that on the last iteration, no carry can occur.\n-           As for multibyteAdd, we save & restore carry flag through the loop.\n-\n-           The timing is entirely dictated by the dependency chain. We could\n-           improve it by moving the mov EAX after the adc [EDI], EAX. Probably not worthwhile.\n-    */\n-    enum { LASTPARAM = 4*5 } // 4* pushes + return address.\n-    asm pure nothrow {\n-        naked;\n-        push ESI;\n-        push EDI;\n-        push EBX;\n-            push ECX;\n-        mov EDI, [ESP + LASTPARAM + 4*3]; //dest.ptr;\n-        mov EBX, [ESP + LASTPARAM + 4*0]; //src.length;\n-        mov ESI, [ESP + LASTPARAM + 4*1]; //src.ptr;\n-        lea EDI, [EDI + 8*EBX];      // EDI = end of dest\n-        lea ESI, [ESI + 4*EBX];      // ESI = end of src\n-        neg EBX;                     // count UP to zero.\n-        xor ECX, ECX;             // initial carry = 0.\n-L1:\n-        mov EAX, [ESI + 4*EBX];\n-        mul EAX, EAX;\n-        shr CL, 1;                 // get carry\n-        adc [EDI + 8*EBX], EAX;\n-        adc [EDI + 8*EBX + 4], EDX;\n-        setc CL;                   // save carry\n-        inc EBX;\n-        jnz L1;\n-\n-        pop ECX;\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 4*4;\n-    }\n-}\n-\n-@system unittest\n-{\n-    uint [] aa = new uint[13];\n-        uint [] bb = new uint[6];\n-    for (int i=0; i<aa.length; ++i) aa[i] = 0x8000_0000;\n-    for (int i=0; i<bb.length; ++i) bb[i] = i;\n-        aa[$-1]= 7;\n-    multibyteAddDiagonalSquares(aa[0..$-1], bb);\n-        assert(aa[$-1]==7);\n-        for (int i=0; i<bb.length; ++i) { assert(aa[2*i]==0x8000_0000+i*i); assert(aa[2*i+1]==0x8000_0000); }\n-}\n-\n-void multibyteTriangleAccumulateD(uint[] dest, uint[] x) pure\n-{\n-    for (int i = 0; i < x.length-3; ++i)\n-    {\n-        dest[i+x.length] = multibyteMulAdd!('+')(\n-             dest[i+i+1 .. i+x.length], x[i+1..$], x[i], 0);\n-    }\n-    ulong c = cast(ulong)(x[$-3]) * x[$-2] + dest[$-5];\n-    dest[$-5] = cast(uint) c;\n-    c >>= 32;\n-    c += cast(ulong)(x[$-3]) * x[$-1] + dest[$-4];\n-    dest[$-4] = cast(uint) c;\n-    c >>= 32;\n-length2:\n-    c += cast(ulong)(x[$-2]) * x[$-1];\n-        dest[$-3] = cast(uint) c;\n-        c >>= 32;\n-        dest[$-2] = cast(uint) c;\n-}\n-\n-//dest += src[0]*src[1...$] + src[1]*src[2..$] + ... + src[$-3]*src[$-2..$]+ src[$-2]*src[$-1]\n-// assert(dest.length = src.length*2);\n-// assert(src.length >= 3);\n-void multibyteTriangleAccumulateAsm(uint[] dest, const uint[] src) pure\n-{\n-    // Register usage\n-    // EDX:EAX = used in multiply\n-    // EBX = index\n-    // ECX = carry1\n-    // EBP = carry2\n-    // EDI = end of dest for this pass through the loop. Index for outer loop.\n-    // ESI = end of src. never changes\n-    // [ESP] = M = src[i] = multiplier for this pass through the loop.\n-    // dest.length is changed into dest.ptr+dest.length\n-    version (D_PIC)\n-    {\n-        enum { zero = 0 }\n-    }\n-    else\n-    {\n-        // use p2 (load unit) instead of the overworked p0 or p1 (ALU units)\n-        // when initializing registers to zero.\n-        __gshared int zero = 0;\n-        // use p3/p4 units\n-        __gshared int storagenop; // write-only\n-    }\n-\n-    enum { LASTPARAM = 6*4 } // 4* pushes + local + return address.\n-    asm pure nothrow {\n-        naked;\n-\n-        push ESI;\n-        push EDI;\n-        align 16;\n-        push EBX;\n-        push EBP;\n-        push EAX;    // local variable M= src[i]\n-        mov EDI, [ESP + LASTPARAM + 4*3]; // dest.ptr\n-        mov EBX, [ESP + LASTPARAM + 4*0]; // src.length\n-        mov ESI, [ESP + LASTPARAM + 4*1];  // src.ptr\n-\n-        lea ESI, [ESI + 4*EBX]; // ESI = end of left\n-        add int ptr [ESP + LASTPARAM + 4*1], 4; // src.ptr, used for getting M\n-\n-        // local variable [ESP + LASTPARAM + 4*2] = last value for EDI\n-        lea EDI, [EDI + 4*EBX]; // EDI = end of dest for first pass\n-\n-        lea EAX, [EDI + 4*EBX-3*4]; // up to src.length - 3\n-        mov [ESP + LASTPARAM + 4*2], EAX; // last value for EDI  = &dest[src.length*2 -3]\n-\n-        cmp EBX, 3;\n-        jz length_is_3;\n-\n-        // We start at src[1], not src[0].\n-        dec EBX;\n-        mov [ESP + LASTPARAM + 4*0], EBX;\n-\n-outer_loop:\n-        mov EBX, [ESP + LASTPARAM + 4*0]; // src.length\n-        mov EBP, 0;\n-        mov ECX, 0; // ECX = input carry.\n-        dec [ESP + LASTPARAM + 4*0]; // Next time, the length will be shorter by 1.\n-        neg EBX;                // count UP to zero.\n-\n-        mov EAX, [ESI + 4*EBX - 4*1]; // get new M\n-        mov [ESP], EAX;                   // save new M\n-\n-        mov EAX, [ESI+4*EBX];\n-        test EBX, 1;\n-        jnz L_enter_odd;\n-    }\n-    // -- Inner loop, with even entry point\n-    mixin(\"asm pure nothrow { \" ~ asmMulAdd_innerloop(\"add\", \"ESP\") ~ \"}\");\n-    asm pure nothrow {\n-        mov [-4+EDI+4*EBX], EBP;\n-        add EDI, 4;\n-        cmp EDI, [ESP + LASTPARAM + 4*2]; // is EDI = &dest[$-3]?\n-        jnz outer_loop;\n-length_is_3:\n-        mov EAX, [ESI - 4*3];\n-        mul EAX, [ESI - 4*2];\n-        mov ECX, 0;\n-        add [EDI-2*4], EAX;  // ECX:dest[$-5] += x[$-3] * x[$-2]\n-        adc ECX, EDX;\n-\n-        mov EAX, [ESI - 4*3];\n-        mul EAX, [ESI - 4*1]; // x[$-3] * x[$-1]\n-        add EAX, ECX;\n-        mov ECX, 0;\n-        adc EDX, 0;\n-        // now EDX: EAX = c + x[$-3] * x[$-1]\n-        add [EDI-1*4], EAX; // ECX:dest[$-4] += (EDX:EAX)\n-        adc ECX, EDX;  //  ECX holds dest[$-3], it acts as carry for the last row\n-// do length == 2\n-        mov EAX, [ESI - 4*2];\n-        mul EAX, [ESI - 4*1];\n-        add ECX, EAX;\n-        adc EDX, 0;\n-        mov [EDI - 0*4], ECX; // dest[$-2:$-3] = c + x[$-2] * x[$-1];\n-        mov [EDI + 1*4], EDX;\n-\n-        pop EAX;\n-        pop EBP;\n-        pop EBX;\n-        pop EDI;\n-        pop ESI;\n-        ret 4*4;\n-    }\n-L_enter_odd:\n-    mixin(\"asm pure nothrow {\" ~ asmMulAdd_enter_odd(\"add\", \"ESP\") ~ \"}\");\n-}\n-\n-@system unittest\n-{\n-   uint [] aa = new uint[200];\n-   uint [] a  = aa[0 .. 100];\n-   uint [] b  = new uint [100];\n-   aa[] = 761;\n-   a[] = 0;\n-   b[] = 0;\n-   a[3] = 6;\n-   b[0]=1;\n-   b[1] = 17;\n-   b[50 .. 100]=78;\n-   multibyteTriangleAccumulateAsm(a, b[0 .. 50]);\n-   uint [] c = new uint[100];\n-   c[] = 0;\n-   c[1] = 17;\n-   c[3] = 6;\n-   assert(a[]==c[]);\n-   assert(a[0]==0);\n-   aa[] = 0xFFFF_FFFF;\n-   a[] = 0;\n-   b[] = 0;\n-   b[0]= 0xbf6a1f01;\n-   b[1]=  0x6e38ed64;\n-   b[2]=  0xdaa797ed;\n-   b[3] = 0;\n-\n-   multibyteTriangleAccumulateAsm(a[0 .. 8], b[0 .. 4]);\n-   assert(a[1]==0x3a600964);\n-   assert(a[2]==0x339974f6);\n-   assert(a[3]==0x46736fce);\n-   assert(a[4]==0x5e24a2b4);\n-\n-   b[3] = 0xe93ff9f4;\n-   b[4] = 0x184f03;\n-   a[]=0;\n-   multibyteTriangleAccumulateAsm(a[0 .. 14], b[0 .. 7]);\n-   assert(a[3]==0x79fff5c2);\n-   assert(a[4]==0xcf384241);\n-   assert(a[5]== 0x4a17fc8);\n-   assert(a[6]==0x4d549025);\n-}\n-\n-\n-void multibyteSquare(BigDigit[] result, const BigDigit [] x) pure\n-{\n-    if (x.length < 4)\n-    {\n-        // Special cases, not worth doing triangular.\n-        result[x.length] = multibyteMul(result[0 .. x.length], x, x[0], 0);\n-        multibyteMultiplyAccumulate(result[1..$], x, x[1..$]);\n-        return;\n-    }\n-    //  Do half a square multiply.\n-    //  dest += src[0]*src[1...$] + src[1]*src[2..$] + ... + src[$-3]*src[$-2..$]+ src[$-2]*src[$-1]\n-    result[x.length] = multibyteMul(result[1 .. x.length], x[1..$], x[0], 0);\n-    multibyteTriangleAccumulateAsm(result[2..$], x[1..$]);\n-    // Multiply by 2\n-    result[$-1] = multibyteShlNoMMX(result[1..$-1], result[1..$-1], 1);\n-    // And add the diagonal elements\n-    result[0] = 0;\n-    multibyteAddDiagonalSquares(result, x);\n-}\n-\n-version (BignumPerformanceTest)\n-{\n-import core.stdc.stdio;\n-int clock() { asm { push EBX; xor EAX, EAX; cpuid; pop EBX; rdtsc; } }\n-\n-__gshared uint [2200] X1;\n-__gshared uint [2200] Y1;\n-__gshared uint [4000] Z1;\n-\n-void testPerformance() pure\n-{\n-    // The performance results at the top of this file were obtained using\n-    // a Windows device driver to access the CPU performance counters.\n-    // The code below is less accurate but more widely usable.\n-    // The value for division is quite inconsistent.\n-    for (int i=0; i<X1.length; ++i) { X1[i]=i; Y1[i]=i; Z1[i]=i; }\n-    int t, t0;\n-    multibyteShl(Z1[0 .. 2000], X1[0 .. 2000], 7);\n-    t0 = clock();\n-    multibyteShl(Z1[0 .. 1000], X1[0 .. 1000], 7);\n-    t = clock();\n-    multibyteShl(Z1[0 .. 2000], X1[0 .. 2000], 7);\n-    auto shltime = (clock() - t) - (t - t0);\n-    t0 = clock();\n-    multibyteShr(Z1[2 .. 1002], X1[4 .. 1004], 13);\n-    t = clock();\n-    multibyteShr(Z1[2 .. 2002], X1[4 .. 2004], 13);\n-    auto shrtime = (clock() - t) - (t - t0);\n-    t0 = clock();\n-    multibyteAddSub!('+')(Z1[0 .. 1000], X1[0 .. 1000], Y1[0 .. 1000], 0);\n-    t = clock();\n-    multibyteAddSub!('+')(Z1[0 .. 2000], X1[0 .. 2000], Y1[0 .. 2000], 0);\n-    auto addtime = (clock() - t) - (t-t0);\n-    t0 = clock();\n-    multibyteMul(Z1[0 .. 1000], X1[0 .. 1000], 7, 0);\n-    t = clock();\n-    multibyteMul(Z1[0 .. 2000], X1[0 .. 2000], 7, 0);\n-    auto multime = (clock() - t) - (t - t0);\n-    multibyteMulAdd!('+')(Z1[0 .. 2000], X1[0 .. 2000], 217, 0);\n-    t0 = clock();\n-    multibyteMulAdd!('+')(Z1[0 .. 1000], X1[0 .. 1000], 217, 0);\n-    t = clock();\n-    multibyteMulAdd!('+')(Z1[0 .. 2000], X1[0 .. 2000], 217, 0);\n-    auto muladdtime = (clock() - t) - (t - t0);\n-    multibyteMultiplyAccumulate(Z1[0 .. 64], X1[0 .. 32], Y1[0 .. 32]);\n-    t = clock();\n-    multibyteMultiplyAccumulate(Z1[0 .. 64], X1[0 .. 32], Y1[0 .. 32]);\n-    auto accumtime = clock() - t;\n-    t0 = clock();\n-    multibyteDivAssign(Z1[0 .. 2000], 217, 0);\n-    t = clock();\n-    multibyteDivAssign(Z1[0 .. 1000], 37, 0);\n-    auto divtime = (t - t0) - (clock() - t);\n-        t= clock();\n-    multibyteSquare(Z1[0 .. 64], X1[0 .. 32]);\n-    auto squaretime = clock() - t;\n-\n-    printf(\"-- BigInt asm performance (cycles/int) --\\n\");\n-    printf(\"Add:        %.2f\\n\", addtime/1000.0);\n-    printf(\"Shl:        %.2f\\n\", shltime/1000.0);\n-    printf(\"Shr:        %.2f\\n\", shrtime/1000.0);\n-    printf(\"Mul:        %.2f\\n\", multime/1000.0);\n-    printf(\"MulAdd:     %.2f\\n\", muladdtime/1000.0);\n-    printf(\"Div:        %.2f\\n\", divtime/1000.0);\n-    printf(\"MulAccum32: %.2f*n*n (total %d)\\n\", accumtime/(32.0*32.0), accumtime);\n-    printf(\"Square32: %.2f*n*n (total %d)\\n\\n\", squaretime/(32.0*32.0), squaretime);\n-}\n-\n-static this()\n-{\n-    testPerformance();\n-}\n-}\n-\n-} // version (D_InlineAsm_X86)"}]}