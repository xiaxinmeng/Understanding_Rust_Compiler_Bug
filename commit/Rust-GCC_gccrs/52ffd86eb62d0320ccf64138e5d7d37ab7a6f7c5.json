{"sha": "52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJmZmQ4NmViNjJkMDMyMGNjZjY0MTM4ZTVkN2QzN2FiN2E2ZjdjNQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@apple.com", "date": "2006-05-18T18:22:12Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2006-05-18T18:22:12Z"}, "message": "Fix up vla, vm and [*] sematics.\n\n\tPR c/18740\n\tPR c/7948\n\tPR c/25802\n\t* c-tree.h (struct c_arg_info): Add had_vla_unspec.\n\t(c_vla_unspec_p): Add.\n\t(c_vla_type_p): Add.\n\t* c-decl.c (struct c_scope): Add had_vla_unspec.\n\t(build_array_declarator): Add support for [*].\n\t(grokdeclarator): Likewise.\n\t(grokparms): Likewise.\n\t(get_parm_info): Likewise.\n\t* c-objc-common.c (c_vla_unspec_p): Likewise.\n\t* c-objc-common.h (LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P): Likewise.\n\t* c-parser.c (c_parser_typeof_specifier): Evaluate arguments to\n\ttypeof when argument is a variably modified type not inside sizeof or alignof.\n\t(c_parser_direct_declarator_inner): Propagate errors.\n\t(c_parser_sizeof_expression): Add support for [*].\n\t* c-typeck.c (c_vla_type_p): Add.\n\t(composite_type): Add support for vla compositing.\n\t(comptypes_internal): Add support for vla compatibility.\n\t(c_expr_sizeof_expr): Evaluate vla arguments.\n\t* tree.c (variably_modified_type_p): Update comment for [*].\n\ntestsuite:\n\t* gcc.dg/c90-arraydecl-1.c: Update for vla, vm [*] fixups.\n\t* gcc.dg/vla-4.c: Add.\n\t* gcc.dg/vla-5.c: Add.\n\t* gcc.dg/vla-6.c: Add.\n\nFrom-SVN: r113888", "tree": {"sha": "3393aa88e335ad0c151ee642c9e17e8807ed52e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3393aa88e335ad0c151ee642c9e17e8807ed52e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/comments", "author": null, "committer": null, "parents": [{"sha": "4f9533c7722fa07511a94d005227961f4a4dec23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f9533c7722fa07511a94d005227961f4a4dec23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f9533c7722fa07511a94d005227961f4a4dec23"}], "stats": {"total": 292, "additions": 263, "deletions": 29}, "files": [{"sha": "3f95910f694daf205122478f91c5a3f291146623", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -1,3 +1,30 @@\n+2006-05-18  Mike Stump  <mrs@apple.com>\n+\n+\tFix up vla, vm and [*] sematics.\n+\n+\tPR c/18740\n+\tPR c/7948\n+\tPR c/25802\n+\t* c-tree.h (struct c_arg_info): Add had_vla_unspec.\n+\t(c_vla_unspec_p): Add.\n+\t(c_vla_type_p): Add.\n+\t* c-decl.c (struct c_scope): Add had_vla_unspec.\n+\t(build_array_declarator): Add support for [*].\n+\t(grokdeclarator): Likewise.\n+\t(grokparms): Likewise.\n+\t(get_parm_info): Likewise.\n+\t* c-objc-common.c (c_vla_unspec_p): Likewise.\n+\t* c-objc-common.h (LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P): Likewise.\n+\t* c-parser.c (c_parser_typeof_specifier): Evaluate arguments to\n+\ttypeof when argument is a variably modified type not inside sizeof or alignof.\n+\t(c_parser_direct_declarator_inner): Propagate errors.\n+\t(c_parser_sizeof_expression): Add support for [*].\n+\t* c-typeck.c (c_vla_type_p): Add.\n+\t(composite_type): Add support for vla compositing.\n+\t(comptypes_internal): Add support for vla compatibility.\n+\t(c_expr_sizeof_expr): Evaluate vla arguments.\n+\t* tree.c (variably_modified_type_p): Update comment for [*].\n+\n 2006-05-18  Michael Matz  <matz@suse.de>\n \n \tPR target/27599"}, {"sha": "ea1a8c41beb8fbe541fca43ccf129c3a3c960bbe", "filename": "gcc/c-decl.c", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -331,6 +331,10 @@ struct c_scope GTY((chain_next (\"%h.outer\")))\n      declarations.  */\n   BOOL_BITFIELD parm_flag : 1;\n \n+  /* True if we saw [*] in this scope.  Used to give an error messages\n+     if these appears in a function definition.  */\n+  BOOL_BITFIELD had_vla_unspec : 1;\n+\n   /* True if we already complained about forward parameter decls\n      in this scope.  This prevents double warnings on\n      foo (int a; int b; ...)  */\n@@ -3007,14 +3011,14 @@ quals_from_declspecs (const struct c_declspecs *specs)\n   return quals;\n }\n \n-/* Construct an array declarator.  EXPR is the expression inside [], or\n-   NULL_TREE.  QUALS are the type qualifiers inside the [] (to be applied\n-   to the pointer to which a parameter array is converted).  STATIC_P is\n-   true if \"static\" is inside the [], false otherwise.  VLA_UNSPEC_P\n-   is true if the array is [*], a VLA of unspecified length which is\n-   nevertheless a complete type (not currently implemented by GCC),\n-   false otherwise.  The field for the contained declarator is left to be\n-   filled in by set_array_declarator_inner.  */\n+/* Construct an array declarator.  EXPR is the expression inside [],\n+   or NULL_TREE.  QUALS are the type qualifiers inside the [] (to be\n+   applied to the pointer to which a parameter array is converted).\n+   STATIC_P is true if \"static\" is inside the [], false otherwise.\n+   VLA_UNSPEC_P is true if the array is [*], a VLA of unspecified\n+   length which is nevertheless a complete type, false otherwise.  The\n+   field for the contained declarator is left to be filled in by\n+   set_array_declarator_inner.  */\n \n struct c_declarator *\n build_array_declarator (tree expr, struct c_declspecs *quals, bool static_p,\n@@ -3046,7 +3050,16 @@ build_array_declarator (tree expr, struct c_declspecs *quals, bool static_p,\n \tpedwarn (\"ISO C90 does not support %<[*]%> array declarators\");\n     }\n   if (vla_unspec_p)\n-    warning (0, \"GCC does not yet properly implement %<[*]%> array declarators\");\n+    {\n+      if (!current_scope->parm_flag)\n+\t{\n+\t  /* C99 6.7.5.2p4 */\n+\t  error (\"%<[*]%> not allowed in other than function prototype scope\");\n+\t  declarator->u.array.vla_unspec_p = false;\n+\t  return NULL;\n+\t}\n+      current_scope->had_vla_unspec = true;\n+    }\n   return declarator;\n }\n \n@@ -3858,20 +3871,21 @@ grokdeclarator (const struct c_declarator *declarator,\n   int type_quals = TYPE_UNQUALIFIED;\n   const char *name, *orig_name;\n   tree typedef_type = 0;\n-  int funcdef_flag = 0;\n+  bool funcdef_flag = false;\n   bool funcdef_syntax = false;\n   int size_varies = 0;\n   tree decl_attr = declspecs->decl_attr;\n   int array_ptr_quals = TYPE_UNQUALIFIED;\n   tree array_ptr_attrs = NULL_TREE;\n   int array_parm_static = 0;\n+  bool array_parm_vla_unspec_p = false;\n   tree returned_attrs = NULL_TREE;\n   bool bitfield = width != NULL;\n   tree element_type;\n   struct c_arg_info *arg_info = 0;\n \n   if (decl_context == FUNCDEF)\n-    funcdef_flag = 1, decl_context = NORMAL;\n+    funcdef_flag = true, decl_context = NORMAL;\n \n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n@@ -4137,7 +4151,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    array_ptr_quals = declarator->u.array.quals;\n \t    array_ptr_attrs = declarator->u.array.attrs;\n \t    array_parm_static = declarator->u.array.static_p;\n-\t    \n+\t    array_parm_vla_unspec_p = declarator->u.array.vla_unspec_p;\n+\n \t    declarator = declarator->declarator;\n \n \t    /* Check for some types that there cannot be arrays of.  */\n@@ -4262,6 +4277,20 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t   identical to GCC's zero-length array extension.  */\n \t\titype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n \t      }\n+\t    else if (decl_context == PARM)\n+\t      {\n+\t\tif (array_parm_vla_unspec_p)\n+\t\t  {\n+\t\t    if (! orig_name)\n+\t\t      {\n+\t\t\t/* C99 6.7.5.2p4 */\n+\t\t\terror (\"%<[*]%> not allowed in other than a declaration\");\n+\t\t      }\n+\n+\t\t    itype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n+\t\t    size_varies = 1;\n+\t\t  }\n+\t      }\n \n \t     /* Complain about arrays of incomplete types.  */\n \t    if (!COMPLETE_TYPE_P (type))\n@@ -4275,7 +4304,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (type != error_mark_node)\n \t      {\n \t\tif (size_varies)\n-\t\tC_TYPE_VARIABLE_SIZE (type) = 1;\n+\t\t  C_TYPE_VARIABLE_SIZE (type) = 1;\n \n \t\t/* The GCC extension for zero-length arrays differs from\n \t\t   ISO flexible array members in that sizeof yields\n@@ -4285,6 +4314,12 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    TYPE_SIZE (type) = bitsize_zero_node;\n \t\t    TYPE_SIZE_UNIT (type) = size_zero_node;\n \t\t  }\n+\t\tif (array_parm_vla_unspec_p)\n+\t\t  {\n+\t\t    /* The type is complete.  C99 6.7.5.2p4  */\n+\t\t    TYPE_SIZE (type) = bitsize_zero_node;\n+\t\t    TYPE_SIZE_UNIT (type) = size_zero_node;\n+\t\t  }\n \t      }\n \n \t    if (decl_context != PARM\n@@ -4472,6 +4507,13 @@ grokdeclarator (const struct c_declarator *declarator,\n       return type;\n     }\n \n+  if (pedantic && decl_context == FIELD\n+      && variably_modified_type_p (type, NULL_TREE))\n+    {\n+      /* C99 6.7.2.1p8 */\n+      pedwarn (\"a member of a structure or union cannot have a variably modified type\");\n+    }\n+\n   /* Aside from typedefs and type names (handle above),\n      `void' at top level (not within pointer)\n      is allowed only in public variables.\n@@ -4737,6 +4779,13 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  }\n       }\n \n+    if (storage_class == csc_extern\n+\t&& variably_modified_type_p (type, NULL_TREE))\n+      {\n+\t/* C99 6.7.5.2p2 */\n+\terror (\"object with variably modified type must have no linkage\");\n+      }\n+\n     /* Record `register' declaration for warnings on &\n        and in case doing stupid register allocation.  */\n \n@@ -4778,7 +4827,7 @@ grokdeclarator (const struct c_declarator *declarator,\n }\n \f\n /* Decode the parameter-list info for a function type or function definition.\n-   The argument is the value returned by `get_parm_info' (or made in parse.y\n+   The argument is the value returned by `get_parm_info' (or made in c-parse.c\n    if there is an identifier list instead of a parameter decl list).\n    These two functions are separate because when a function returns\n    or receives functions then each is called multiple times but the order\n@@ -4796,6 +4845,13 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n {\n   tree arg_types = arg_info->types;\n \n+  if (funcdef_flag && arg_info->had_vla_unspec)\n+    {\n+      /* A function definition isn't function prototype scope C99 6.2.1p4.  */\n+      /* C99 6.7.5.2p4 */\n+      error (\"%<[*]%> not allowed in other than function prototype scope\");\n+    }\n+\n   if (arg_types == 0 && !funcdef_flag && !in_system_header)\n     warning (OPT_Wstrict_prototypes,\n \t     \"function declaration isn%'t a prototype\");\n@@ -4892,6 +4948,7 @@ get_parm_info (bool ellipsis)\n   arg_info->tags = 0;\n   arg_info->types = 0;\n   arg_info->others = 0;\n+  arg_info->had_vla_unspec = current_scope->had_vla_unspec;\n \n   /* The bindings in this scope must not get put into a block.\n      We will take care of deleting the binding nodes.  */\n@@ -5541,7 +5598,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n   /* If we're inside a function proper, i.e. not file-scope and not still\n      parsing parameters, then arrange for the size of a variable sized type\n      to be bound now.  */\n-  if (cur_stmt_list && variably_modified_type_p (t, NULL))\n+  if (cur_stmt_list && variably_modified_type_p (t, NULL_TREE))\n     add_stmt (build_stmt (DECL_EXPR, build_decl (TYPE_DECL, NULL, t)));\n \n   return t;"}, {"sha": "facaeafd82e985672212ca27a8a792c04e91c69c", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -257,3 +257,11 @@ c_types_compatible_p (tree x, tree y)\n {\n     return comptypes (TYPE_MAIN_VARIANT (x), TYPE_MAIN_VARIANT (y));\n }\n+\n+/* Determine if the type is a vla type for the backend.  */\n+\n+bool\n+c_vla_unspec_p (tree x, tree fn ATTRIBUTE_UNUSED)\n+{\n+  return c_vla_type_p (x);\n+}"}, {"sha": "49f9ce428b164a173adf8975a5ba8e41108721f4", "filename": "gcc/c-objc-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.h?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -137,4 +137,7 @@ extern void c_initialize_diagnostics (diagnostic_context *);\n #undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING c_omp_predetermined_sharing\n \n+#undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P\n+#define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P c_vla_unspec_p\n+\n #endif /* GCC_C_OBJC_COMMON */"}, {"sha": "5a67653d8926afecfcab8aa7f479f6696a9a683f", "filename": "gcc/c-parser.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -2148,14 +2148,21 @@ c_parser_typeof_specifier (c_parser *parser)\n     }\n   else\n     {\n+      bool was_vm;\n       struct c_expr expr = c_parser_expression (parser);\n       skip_evaluation--;\n       in_typeof--;\n       if (TREE_CODE (expr.value) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))\n \terror (\"%<typeof%> applied to a bit-field\");\n       ret.spec = TREE_TYPE (expr.value);\n-      pop_maybe_used (variably_modified_type_p (ret.spec, NULL_TREE));\n+      was_vm = variably_modified_type_p (ret.spec, NULL_TREE);\n+      /* This should be returned with the type so that when the type\n+\t is evaluated, this can be evaluated.  For now, we avoid\n+\t evaluation when the context might.  */\n+      if (!skip_evaluation && was_vm)\n+\tc_finish_expr_stmt (expr.value);\n+      pop_maybe_used (was_vm);\n     }\n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n   return ret;\n@@ -2451,6 +2458,8 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t}\n       declarator = build_array_declarator (dimen, quals_attrs, static_seen,\n \t\t\t\t\t   star_seen);\n+      if (declarator == NULL)\n+\treturn NULL;\n       inner = set_array_declarator_inner (declarator, inner, !id_present);\n       return c_parser_direct_declarator_inner (parser, id_present, inner);\n     }\n@@ -4868,6 +4877,12 @@ c_parser_sizeof_expression (c_parser *parser)\n       /* sizeof ( type-name ).  */\n       skip_evaluation--;\n       in_sizeof--;\n+      if (type_name->declarator->kind == cdk_array\n+\t  && type_name->declarator->u.array.vla_unspec_p)\n+\t{\n+\t  /* C99 6.7.5.2p4 */\n+\t  error (\"%<[*]%> not allowed in other than a declaration\");\n+\t}\n       return c_expr_sizeof_type (type_name);\n     }\n   else"}, {"sha": "9b24daa79f5fff13ab6d7dc2710d8c048f874efa", "filename": "gcc/c-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -309,6 +309,8 @@ struct c_arg_info {\n   /* A list of non-parameter decls (notably enumeration constants)\n      defined with the parameters.  */\n   tree others;\n+  /* True when these arguments had [*].  */\n+  BOOL_BITFIELD had_vla_unspec : 1;\n };\n \n /* A declarator.  */\n@@ -506,6 +508,7 @@ extern bool c_missing_noreturn_ok_p (tree);\n extern tree c_objc_common_truthvalue_conversion (tree expr);\n extern bool c_warn_unused_global_decl (tree);\n extern void c_initialize_diagnostics (diagnostic_context *);\n+extern bool c_vla_unspec_p (tree x, tree fn);\n \n #define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n   c_build_qualified_type ((TYPE),\t\t\t\t  \\\n@@ -524,6 +527,7 @@ extern struct c_label_context_vm *label_context_stack_vm;\n extern tree require_complete_type (tree);\n extern int same_translation_unit_p (tree, tree);\n extern int comptypes (tree, tree);\n+extern bool c_vla_type_p (tree);\n extern bool c_mark_addressable (tree);\n extern void c_incomplete_type_error (tree, tree);\n extern tree c_type_promotes_to (tree);"}, {"sha": "4cf50acecbc947eb4166408e56caeec2e0ac5298", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -253,6 +253,17 @@ qualify_type (tree type, tree like)\n   return c_build_qualified_type (type,\n \t\t\t\t TYPE_QUALS (type) | TYPE_QUALS (like));\n }\n+\n+/* Return true iff the given tree T is a variable length array.  */\n+\n+bool\n+c_vla_type_p (tree t)\n+{\n+  if (TREE_CODE (t) == ARRAY_TYPE\n+      && C_TYPE_VARIABLE_SIZE (t))\n+    return true;\n+  return false;\n+}\n \f\n /* Return the composite type of two compatible types.\n \n@@ -330,6 +341,8 @@ composite_type (tree t1, tree t2)\n \td2_variable = (!d2_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST));\n+\td1_variable = d1_variable || (d1_zero && c_vla_type_p (t1));\n+\td2_variable = d2_variable || (d2_zero && c_vla_type_p (t2));\n \n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1)\n@@ -834,6 +847,8 @@ comptypes_internal (tree type1, tree type2)\n \td2_variable = (!d2_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST));\n+\td1_variable = d1_variable || (d1_zero && c_vla_type_p (t1));\n+\td2_variable = d2_variable || (d2_zero && c_vla_type_p (t2));\n \n \tif (d1_variable || d2_variable)\n \t  break;\n@@ -2116,6 +2131,11 @@ c_expr_sizeof_expr (struct c_expr expr)\n     {\n       ret.value = c_sizeof (TREE_TYPE (expr.value));\n       ret.original_code = ERROR_MARK;\n+      if (c_vla_type_p (TREE_TYPE (expr.value)))\n+\t{\n+\t  /* sizeof is evaluated when given a vla (C99 6.5.3.4p2).  */\n+\t  ret.value = build2 (COMPOUND_EXPR, TREE_TYPE (ret.value), expr.value, ret.value);\n+\t}\n       pop_maybe_used (C_TYPE_VARIABLE_SIZE (TREE_TYPE (expr.value)));\n     }\n   return ret;"}, {"sha": "8c1700f9c701db706c5e7a3e1acf438168a6c7de", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -1,3 +1,10 @@\n+2006-05-18  Mike Stump  <mrs@apple.com>\n+\n+\t* gcc.dg/c90-arraydecl-1.c: Update for vla, vm [*] fixups.\n+\t* gcc.dg/vla-4.c: Add.\n+\t* gcc.dg/vla-5.c: Add.\n+\t* gcc.dg/vla-6.c: Add.\n+\n 2006-05-12  Stuart Hastings  <stuart@apple.com>\n \n \t* testsuite/gcc.target/i386/20060512-1.c: New."}, {"sha": "97dc1eee663a1a133089f79600e308db56100d38", "filename": "gcc/testsuite/gcc.dg/c90-arraydecl-1.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-arraydecl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-arraydecl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-arraydecl-1.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -9,23 +9,22 @@\n    that we get just one error and no warnings.  */\n \n void foo0 (int a, int b[*]); /* { dg-error \"ISO C90\" \"\\[*\\] not in C90\" } */\n-/* { dg-warning \"implement\" \"\\[*\\] not implemented\" { target *-*-* } 11 } */\n void foo1 (int, int [*]); /* { dg-error \"ISO C90\" \"\\[*\\] not in C90\" } */\n-/* { dg-warning \"implement\" \"\\[*\\] not implemented\" { target *-*-* } 13 } */\n+/* { dg-error \"allowed\" \"\\'\\[*\\]\\' not allowed in other than a declaration\" { target *-*-* } 12 } */\n \n /* Use of static and type qualifiers (not allowed with abstract declarators)\n    is a C99 feature.  */\n \n void bar0 (int a[const]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"ISO C90\" \"\\[quals\\] not in C90\" { target *-*-* } 19 } */\n+/* { dg-error \"ISO C90\" \"\\[quals\\] not in C90\" { target *-*-* } 18 } */\n void bar1 (int a[const 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"ISO C90\" \"\\[quals expr\\] not in C90\" { target *-*-* } 21 } */\n+/* { dg-error \"ISO C90\" \"\\[quals expr\\] not in C90\" { target *-*-* } 20 } */\n void bar2 (int a[static 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"ISO C90\" \"\\[static expr\\] not in C90\" { target *-*-* } 23 } */\n+/* { dg-error \"ISO C90\" \"\\[static expr\\] not in C90\" { target *-*-* } 22 } */\n void bar3 (int a[static const 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"ISO C90\" \"\\[static quals expr\\] not in C90\" { target *-*-* } 25 } */\n+/* { dg-error \"ISO C90\" \"\\[static quals expr\\] not in C90\" { target *-*-* } 24 } */\n void bar4 (int a[const static 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"ISO C90\" \"\\[quals static expr\\] not in C90\" { target *-*-* } 27 } */\n+/* { dg-error \"ISO C90\" \"\\[quals static expr\\] not in C90\" { target *-*-* } 26 } */\n \n /* Because [*] isn't properly implemented and so warns, we don't test here\n    for [const *] yet.  */"}, {"sha": "7ffbfb31b8e4b47a4585bf4c5800995ad5611c2f", "filename": "gcc/testsuite/gcc.dg/vla-4.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-4.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+/* PR c/18740 */\n+\n+static int i;\n+\n+int foo(int n)\n+{\n+  int (*t)[n];\n+  i = 0;\n+  int j = 0;\n+  char b[1][n+3];\t\t\t/* Variable length array.  */\n+  int d[3][n];\t\t\t\t/* Variable length array.  */\n+  sizeof (b[i++ + sizeof(j++)]);\t/* Outer sizeof is evaluated for vla, but not the inner one.  */\n+  if (i != 1 || j != 0)\n+    return 1;\n+  __typeof__(b[i++]) c1;\t\t/* typeof is evauluated when given a vm */\n+  if (i != 2)\n+    return 1;\n+  __typeof__(t + (i++,0)) c2;\t\t/* typeof is evauluated when given a vm */\n+  if (i != 3)\n+    return 1;\n+  __typeof__(i + (i++,0)) c3;\t\t/* typeof is not evauluated when not given a vm */\n+  if (i != 3)\n+    return 1;\n+  sizeof (d[i++]);\t\t\t/* sizeof is evaluated for vla.  */\n+  if (i != 4)\n+    return 1;\n+  __alignof__(__typeof__(t + (i++,0)));\t/* typeof is not evauluated when given a vm inside alignof*/\n+  if (i != 4)\n+    return 1;\n+  sizeof(__typeof__(t + (i++,0)));\t/* typeof is not evauluated when given a vm inside sizeof*/\n+  if (i != 4)\n+    return 1;\n+  return 0;\n+}\n+\n+int foo6(int a, int b[a][a], int (*c)[sizeof(*b)]) {\n+  return sizeof (*c);\n+}\n+\n+int main() {\n+  int b[10][10];\n+  int (*c)[sizeof(int)*10];\n+  if (foo6(10, b, c) != 10*sizeof(int)*sizeof(int))\n+    return 1;\n+  return foo(10);\n+}"}, {"sha": "f5256c4c4a37bb394532c24829b47a8b199b0ad5", "filename": "gcc/testsuite/gcc.dg/vla-5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-5.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+void foo1(int (*o)(int p[*])) { }\n+\n+void foo2(int o[*]);\n+void foo3(int o[4][*]);\n+\n+void foo4(int j, int a[j]);\n+void foo4(int, int a[*]);\n+void foo4(int, int a[]);\n+void foo4(int j, int a[j]) {\n+}\n+\n+int foo5(int a, int b[*][*], int c[static sizeof(*b)]);\n+int foo5(int a, int b[10][10], int c[400]) {\n+  return sizeof (c);\n+}\n+\n+int foo6(int a, int b[*][*], int c[static sizeof(*b)]);\n+int foo6(int a, int b[a][a], int c[sizeof(*b)]) {\n+  return sizeof (c);\n+}\n+\n+void foo7(__typeof__ (int (*)(int o[*])) i);"}, {"sha": "b7bdb31eeca507d2ce8993421a727dfc87087833", "filename": "gcc/testsuite/gcc.dg/vla-6.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-6.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+int a[*];\t\t\t/* { dg-error \"not allowed in other than function prototype scope\" } */\n+void foo1() { int a[*]; }\t/* { dg-error \"not allowed in other than function prototype scope\" } */\n+void foo2() { int a[*]; }\t/* { dg-error \"not allowed in other than function prototype scope\" } */\n+int foo3(int i)[*];\t\t/* { dg-error \"not allowed in other than function prototype scope\" } */\n+void foo4(int o[*][4]) { }\t/* { dg-error \"not allowed in other than function prototype scope\" } */\n+void foo5(int o[4][*]) { }\t/* { dg-error \"not allowed in other than function prototype scope\" } */\n+\n+/* [*] can't be used in a type that's not a declaration */\n+void foo11(int x[sizeof(int (*)[*])]);\t/* { dg-error \"not allowed in other than a declaration\" } */\n+void foo12(int [*]);\t\t/* { dg-error \"not allowed in other than a declaration\" } */\n+\n+extern int n;\n+int B[100];\n+void foo10(int m) {\n+  typedef int (*vla)[m];\n+  struct tag {\n+    vla x;\t\t\t/* { dg-error \"a member of a structure or union cannot have a variably modified type\" } */\n+    /* PR c/7948 */\n+    int (*y)[n];\t\t/* { dg-error \"a member of a structure or union cannot have a variably modified type\" } */\n+    int z[n];\t\t\t/* { dg-error \"a member of a structure or union cannot have a variably modified type\" } */\n+  };\n+  /* PR c/25802 */\n+  extern int (*r)[m];\t\t/* { dg-error \"variably modified type must have no linkage\" } */\n+}"}, {"sha": "c369d604e476face6b8533d497823a274cdf3f36", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=52ffd86eb62d0320ccf64138e5d7d37ab7a6f7c5", "patch": "@@ -5629,11 +5629,7 @@ variably_modified_type_p (tree type, tree fn)\n   if (type == error_mark_node)\n     return false;\n \n-  /* If TYPE itself has variable size, it is variably modified.\n-\n-     We do not yet have a representation of the C99 '[*]' syntax.\n-     When a representation is chosen, this function should be modified\n-     to test for that case as well.  */\n+  /* If TYPE itself has variable size, it is variably modified.  */\n   RETURN_TRUE_IF_VAR (TYPE_SIZE (type));\n   RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT (type));\n \n@@ -5673,7 +5669,7 @@ variably_modified_type_p (tree type, tree fn)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      /* We can't see if any of the field are variably-modified by the\n+      /* We can't see if any of the fields are variably-modified by the\n \t definition we normally use, since that would produce infinite\n \t recursion via pointers.  */\n       /* This is variably modified if some field's type is.  */"}]}