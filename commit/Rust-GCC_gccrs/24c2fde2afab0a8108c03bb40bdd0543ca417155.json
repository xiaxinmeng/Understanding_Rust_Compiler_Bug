{"sha": "24c2fde2afab0a8108c03bb40bdd0543ca417155", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRjMmZkZTJhZmFiMGE4MTA4YzAzYmI0MGJkZDA1NDNjYTQxNzE1NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-10-06T17:06:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-10-06T17:06:12Z"}, "message": "re PR target/23706 (ICE in rtl_verify_flow_info_1)\n\n        PR 23706\n        * mode-switching.c (optimize_mode_switching): Clear transp bit\n        for block with incomming abnormal edges.\n\n        * config/sh/sh.c (fpscr_values, emit_fpu_switch): New.\n        (fpscr_set_from_mem): Use them.\n        * config/sh/sh.md (fpu_switch0, fpu_switch1): Remove.\n        (fpscr postinc splitters): Rewrite as peephole2+split.\n\nFrom-SVN: r105045", "tree": {"sha": "f953ff122d8b829c0e015af9f0055db1bc7929f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f953ff122d8b829c0e015af9f0055db1bc7929f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24c2fde2afab0a8108c03bb40bdd0543ca417155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c2fde2afab0a8108c03bb40bdd0543ca417155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c2fde2afab0a8108c03bb40bdd0543ca417155", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c2fde2afab0a8108c03bb40bdd0543ca417155/comments", "author": null, "committer": null, "parents": [{"sha": "27f0fe7f6eff528edc9c34025a96ff21fa1f0d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27f0fe7f6eff528edc9c34025a96ff21fa1f0d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27f0fe7f6eff528edc9c34025a96ff21fa1f0d35"}], "stats": {"total": 137, "additions": 88, "deletions": 49}, "files": [{"sha": "c8a51f005b2e58647bc2acc67d95491e3ca02363", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24c2fde2afab0a8108c03bb40bdd0543ca417155", "patch": "@@ -1,3 +1,14 @@\n+2005-10-06  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 23706\n+\t* mode-switching.c (optimize_mode_switching): Clear transp bit\n+\tfor block with incomming abnormal edges.\n+\n+\t* config/sh/sh.c (fpscr_values, emit_fpu_switch): New.\n+\t(fpscr_set_from_mem): Use them.\n+\t* config/sh/sh.md (fpu_switch0, fpu_switch1): Remove.\n+\t(fpscr postinc splitters): Rewrite as peephole2+split.\n+\n 2005-10-06  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.md (eq<mode>): Add !TARGET_POWER."}, {"sha": "f1ac27c617da7e0e094d7cdc5b47ec8587a2a1e2", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=24c2fde2afab0a8108c03bb40bdd0543ca417155", "patch": "@@ -7854,6 +7854,44 @@ get_fpscr_rtx (void)\n   return fpscr_rtx;\n }\n \n+static GTY(()) tree fpscr_values;\n+\n+static void\n+emit_fpu_switch (rtx scratch, int index)\n+{\n+  rtx dst, src;\n+\n+  if (fpscr_values == NULL)\n+    {\n+      tree t;\n+\n+      t = build_index_type (integer_one_node);\n+      t = build_array_type (integer_type_node, t);\n+      t = build_decl (VAR_DECL, get_identifier (\"__fpscr_values\"), t);\n+      DECL_ARTIFICIAL (t) = 1;\n+      DECL_IGNORED_P (t) = 1;\n+      DECL_EXTERNAL (t) = 1;\n+      TREE_STATIC (t) = 1;\n+      TREE_USED (t) = 1;\n+\n+      fpscr_values = t;\n+    }\n+\n+  src = DECL_RTL (fpscr_values);\n+  if (no_new_pseudos)\n+    {\n+      emit_move_insn (scratch, XEXP (src, 0));\n+      if (index != 0)\n+\temit_insn (gen_addsi3 (scratch, scratch, GEN_INT (index * 4)));\n+      src = adjust_automodify_address (src, PSImode, scratch, index * 4);\n+    }\n+  else\n+    src = adjust_address (src, PSImode, index * 4);\n+\n+  dst = get_fpscr_rtx ();\n+  emit_move_insn (dst, src);\n+}\n+\n void\n emit_sf_insn (rtx pat)\n {\n@@ -8006,12 +8044,10 @@ void\n fpscr_set_from_mem (int mode, HARD_REG_SET regs_live)\n {\n   enum attr_fp_mode fp_mode = mode;\n+  enum attr_fp_mode norm_mode = ACTUAL_NORMAL_MODE (FP_MODE);\n   rtx addr_reg = get_free_reg (regs_live);\n \n-  if (fp_mode == (enum attr_fp_mode) ACTUAL_NORMAL_MODE (FP_MODE))\n-    emit_insn (gen_fpu_switch1 (addr_reg));\n-  else\n-    emit_insn (gen_fpu_switch0 (addr_reg));\n+  emit_fpu_switch (addr_reg, fp_mode == norm_mode);\n }\n \n /* Is the given character a logical line separator for the assembler?  */"}, {"sha": "42e05bce806ee02fbb096c19ae8f8c073f6b4799", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=24c2fde2afab0a8108c03bb40bdd0543ca417155", "patch": "@@ -9760,34 +9760,6 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n ;; ??? All patterns should have a type attribute.\n \n-(define_expand \"fpu_switch0\"\n-  [(set (match_operand:SI 0 \"\" \"\") (match_dup 2))\n-   (set (match_dup 1) (mem:PSI (match_dup 0)))]\n-  \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\"\n-  \"\n-{\n-  operands[1] = get_fpscr_rtx ();\n-  operands[2] = gen_rtx_SYMBOL_REF (SImode, \\\"__fpscr_values\\\");\n-  if (flag_pic)\n-    operands[2] = legitimize_pic_address (operands[2], SImode,\n-\t\t\t\t\t  no_new_pseudos ? operands[0] : 0);\n-}\")\n-\n-(define_expand \"fpu_switch1\"\n-  [(set (match_operand:SI 0 \"\" \"\") (match_dup 2))\n-   (set (match_dup 3) (plus:SI (match_dup 0) (const_int 4)))\n-   (set (match_dup 1) (mem:PSI (match_dup 3)))]\n-  \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\"\n-  \"\n-{\n-  operands[1] = get_fpscr_rtx ();\n-  operands[2] = gen_rtx_SYMBOL_REF (SImode, \\\"__fpscr_values\\\");\n-  if (flag_pic)\n-    operands[2] = legitimize_pic_address (operands[2], SImode,\n-\t\t\t\t\t  no_new_pseudos ? operands[0] : 0);\n-  operands[3] = no_new_pseudos ? operands[0] : gen_reg_rtx (SImode);\n-}\")\n-\n (define_expand \"movpsi\"\n   [(set (match_operand:PSI 0 \"register_operand\" \"\")\n \t(match_operand:PSI 1 \"general_movsrc_operand\" \"\"))]\n@@ -9822,35 +9794,43 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(set_attr \"length\" \"0,2,2,4,2,2,2,2,2\")\n    (set_attr \"type\" \"nil,mem_fpscr,load,mem_fpscr,gp_fpscr,move,store,mac_gp,store\")])\n \n-(define_split\n+(define_peephole2\n   [(set (reg:PSI FPSCR_REG)\n \t(mem:PSI (match_operand:SI 0 \"register_operand\" \"\")))]\n-  \"(TARGET_SH4 || TARGET_SH2A_DOUBLE) && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(set (match_dup 0) (match_dup 0))]\n-  \"\n+  \"(TARGET_SH4 || TARGET_SH2A_DOUBLE) && peep2_reg_dead_p (1, operands[0])\"\n+  [(const_int 0)]\n {\n-  rtx mem, insn;\n+  rtx fpscr, mem, new_insn;\n \n+  fpscr = SET_DEST (PATTERN (curr_insn));\n   mem = SET_SRC (PATTERN (curr_insn));\n-  mem = change_address (mem, PSImode, gen_rtx_POST_INC (Pmode, operands[0]));\n-  insn = emit_insn (gen_fpu_switch (get_fpscr_rtx (), mem));\n-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, operands[0], NULL_RTX);\n-}\")\n+  mem = replace_equiv_address (mem, gen_rtx_POST_INC (Pmode, operands[0]));\n+\n+  new_insn = emit_insn (gen_fpu_switch (fpscr, mem));\n+  REG_NOTES (new_insn) = gen_rtx_EXPR_LIST (REG_INC, operands[0], NULL_RTX);\n+  DONE;\n+})\n \n (define_split\n   [(set (reg:PSI FPSCR_REG)\n \t(mem:PSI (match_operand:SI 0 \"register_operand\" \"\")))]\n-  \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\"\n-  [(set (match_dup 0) (plus:SI (match_dup 0) (const_int -4)))]\n-  \"\n+  \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\n+   && (flag_peephole2 ? flow2_completed : reload_completed)\"\n+  [(const_int 0)]\n {\n-  rtx mem, insn;\n+  rtx fpscr, mem, new_insn;\n \n+  fpscr = SET_DEST (PATTERN (curr_insn));\n   mem = SET_SRC (PATTERN (curr_insn));\n-  mem = change_address (mem, PSImode, gen_rtx_POST_INC (Pmode, operands[0]));\n-  insn = emit_insn (gen_fpu_switch (get_fpscr_rtx (), mem));\n-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, operands[0], NULL_RTX);\n-}\")\n+  mem = replace_equiv_address (mem, gen_rtx_POST_INC (Pmode, operands[0]));\n+\n+  new_insn = emit_insn (gen_fpu_switch (fpscr, mem));\n+  REG_NOTES (new_insn) = gen_rtx_EXPR_LIST (REG_INC, operands[0], NULL_RTX);\n+\n+  if (!find_regno_note (curr_insn, REG_DEAD, true_regnum (operands[0])))\n+    emit_insn (gen_addsi3 (operands[0], operands[0], GEN_INT (-4)));\n+  DONE;\n+})\n \n ;; ??? This uses the fp unit, but has no type indicating that.\n ;; If we did that, this would either give a bogus latency or introduce"}, {"sha": "30ad3a833576c9753cf794f233a142fc1dcf3372", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c2fde2afab0a8108c03bb40bdd0543ca417155/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=24c2fde2afab0a8108c03bb40bdd0543ca417155", "patch": "@@ -456,6 +456,18 @@ optimize_mode_switching (FILE *file)\n \n \t  REG_SET_TO_HARD_REG_SET (live_now,\n \t\t\t\t   bb->il.rtl->global_live_at_start);\n+\n+\t  /* Pretend the mode is clobbered across abnormal edges.  */\n+\t  {\n+\t    edge_iterator ei;\n+\t    edge e;\n+\t    FOR_EACH_EDGE (e, ei, bb->preds)\n+\t      if (e->flags & EDGE_COMPLEX)\n+\t\tbreak;\n+\t    if (e)\n+\t      RESET_BIT (transp[bb->index], j);\n+\t  }\n+\n \t  for (insn = BB_HEAD (bb);\n \t       insn != NULL && insn != NEXT_INSN (BB_END (bb));\n \t       insn = NEXT_INSN (insn))"}]}