{"sha": "d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ4MWI2OWI1ZTNkMWVhNDJkOWIzNmM2NTJhYTNjOWFiNWMzNTQwNA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-16T02:10:34Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-16T02:10:34Z"}, "message": "cpphash.h (SYNTAX_INCLUDE, [...]): new.\n\n        * cpphash.h (SYNTAX_INCLUDE, SYNTAX_ASSERT, directive_handler): new.\n        * cpplib.c: Add new syntax flags to directive table, and\n        supporting macros.\n\nFrom-SVN: r33179", "tree": {"sha": "8fdf961b2c1bfe9fafba9596042a1e5b2e031689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fdf961b2c1bfe9fafba9596042a1e5b2e031689"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404/comments", "author": null, "committer": null, "parents": [{"sha": "422b914d92aa9e387a70de73a8ed5359cf9de9b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422b914d92aa9e387a70de73a8ed5359cf9de9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422b914d92aa9e387a70de73a8ed5359cf9de9b6"}], "stats": {"total": 87, "additions": 52, "deletions": 35}, "files": [{"sha": "65c76e8ae78caad1b1b7d1f1c2a7364135482390", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "patch": "@@ -1,3 +1,9 @@\n+2004-04-16  Neil Booth  <NeilB@earthling.net>\n+\n+        * cpphash.h (SYNTAX_INCLUDE, SYNTAX_ASSERT, directive_handler): new.\n+        * cpplib.c: Add new syntax flags to directive table, and\n+        supporting macros.\n+\n 2000-04-15  Ulrich Drepper  <drepper@redhat.com>\n \n \t* i386.c (ix86_expand_epilogue): Yes, the x86 can pop 64k at once"}, {"sha": "b8f3ba9381baf38781e9d63735d77f27419ee818", "filename": "gcc/cpphash.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "patch": "@@ -120,6 +120,12 @@ struct hashnode\n   enum node_type type;\t\t/* type of special token */\n };\n \n+/* Directive flags.  */\n+\n+#define SYNTAX_INCLUDE (1 << 8)\n+#define SYNTAX_ASSERT  (1 << 9)\n+typedef int (* directive_handler) PARAMS ((cpp_reader *));\n+\n /* List of directories to look for include files in. */\n struct file_name_list\n {"}, {"sha": "cd8285b0d59895953e283da9760821725f5f79f5", "filename": "gcc/cpplib.c", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "patch": "@@ -32,11 +32,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n struct directive\n {\n-  int (*func)\t\t\t/* Function to handle directive */\n-    PARAMS ((cpp_reader *));\n-  const char *name;\t\t/* Name of directive */\n-  unsigned short length;\t/* Length of name */\n-  unsigned short origin;\t/* Origin of this directive */\n+  directive_handler func;\t/* Function to handle directive.  */\n+  const char *name;\t\t/* Name of directive.  */\n+  unsigned short length;\t/* Length of name.  */\n+  unsigned short flags;\t        /* Flags describing this directive.  */\n };\n \n /* Stack of conditionals currently in progress\n@@ -68,14 +67,20 @@ static int consider_directive_while_skipping\n \t\t\t\t\tPARAMS ((cpp_reader *, IF_STACK *));\n static int get_macro_name\t\tPARAMS ((cpp_reader *));\n \n-/* Values for the \"origin\" field of the table below.  KANDR and COND\n+/* Values for the flags field of the table below.  KANDR and COND\n    directives come from traditional (K&R) C.  The difference is, if we\n    care about it while skipping a failed conditional block, its origin\n    is COND.  STDC89 directives come from the 1989 C standard.\n    EXTENSION directives are extensions, with origins noted below.  */\n-enum { KANDR = 0, COND, STDC89, EXTENSION };\n \n-#define TRAD_DIRECT_P(x) ((x) == KANDR || (x) == COND)\n+#define KANDR       0\n+#define COND        1\n+#define STDC89      2\n+#define EXTENSION   3\n+\n+#define ORIGIN_MASK 3\n+#define ORIGIN(f) ((f) & ORIGIN_MASK)\n+#define TRAD_DIRECT_P(f) (ORIGIN (f) == KANDR || ORIGIN (f) == COND)\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n@@ -94,25 +99,25 @@ enum { KANDR = 0, COND, STDC89, EXTENSION };\n # define SCCS_ENTRY /* nothing */\n #endif\n \n-#define DIRECTIVE_TABLE\t\t\t\t\t\t\t\\\n-D(define,\tT_DEFINE = 0,\tKANDR)\t\t/* 270554 */\t\t\\\n-D(include,\tT_INCLUDE,\tKANDR)\t\t/*  52262 */\t\t\\\n-D(endif,\tT_ENDIF,\tCOND)\t\t/*  45855 */\t\t\\\n-D(ifdef,\tT_IFDEF,\tCOND)\t\t/*  22000 */\t\t\\\n-D(if,\t\tT_IF,\t\tCOND)\t\t/*  18162 */\t\t\\\n-D(else,\t\tT_ELSE,\t\tCOND)\t\t/*   9863 */\t\t\\\n-D(ifndef,\tT_IFNDEF,\tCOND)\t\t/*   9675 */\t\t\\\n-D(undef,\tT_UNDEF,\tKANDR)\t\t/*   4837 */\t\t\\\n-D(line,\t\tT_LINE,\t\tKANDR)\t\t/*   2465 */\t\t\\\n-D(elif,\t\tT_ELIF,\t\tCOND)\t\t/*    610 */\t\t\\\n-D(error,\tT_ERROR,\tSTDC89)\t\t/*    475 */\t\t\\\n-D(pragma,\tT_PRAGMA,\tSTDC89)\t\t/*    195 */\t\t\\\n-D(warning,\tT_WARNING,\tEXTENSION)\t/*     22 - GNU   */\t\\\n-D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION)\t/*     19 - GNU   */\t\\\n-D(ident,\tT_IDENT,\tEXTENSION)\t/*     11 - SVR4  */\t\\\n-D(import,\tT_IMPORT,\tEXTENSION)\t/*      0 - ObjC  */\t\\\n-D(assert,\tT_ASSERT,\tEXTENSION)\t/*      0 - SVR4  */\t\\\n-D(unassert,\tT_UNASSERT,\tEXTENSION)\t/*      0 - SVR4  */\t\\\n+#define DIRECTIVE_TABLE\t\t\t\t\t\t\t \\\n+D(define,\tT_DEFINE = 0,\tKANDR)\t\t           /* 270554 */ \\\n+D(include,\tT_INCLUDE,\tKANDR | SYNTAX_INCLUDE)    /*  52262 */ \\\n+D(endif,\tT_ENDIF,\tCOND)\t\t           /*  45855 */ \\\n+D(ifdef,\tT_IFDEF,\tCOND)\t\t\t   /*  22000 */ \\\n+D(if,\t\tT_IF,\t\tCOND)\t\t\t   /*  18162 */ \\\n+D(else,\t\tT_ELSE,\t\tCOND)\t\t\t    /*  9863 */ \\\n+D(ifndef,\tT_IFNDEF,\tCOND)\t\t\t    /*  9675 */ \\\n+D(undef,\tT_UNDEF,\tKANDR)\t\t\t    /*  4837 */ \\\n+D(line,\t\tT_LINE,\t\tKANDR)\t\t\t    /*  2465 */ \\\n+D(elif,\t\tT_ELIF,\t\tCOND)\t\t\t    /*   610 */ \\\n+D(error,\tT_ERROR,\tSTDC89)\t\t\t    /*   475 */ \\\n+D(pragma,\tT_PRAGMA,\tSTDC89)\t\t\t    /*   195 */ \\\n+D(warning,\tT_WARNING,\tEXTENSION)\t\t    /*    22 GNU */ \\\n+D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION | SYNTAX_INCLUDE) /*    19 GNU */ \\\n+D(ident,\tT_IDENT,\tEXTENSION)\t\t    /*    11 SVR4 */ \\\n+D(import,\tT_IMPORT,\tEXTENSION | SYNTAX_INCLUDE) /*     0 ObjC */ \\\n+D(assert,\tT_ASSERT,\tEXTENSION | SYNTAX_ASSERT)  /*     0 SVR4 */ \\\n+D(unassert,\tT_UNASSERT,\tEXTENSION | SYNTAX_ASSERT)  /*     0 SVR4 */ \\\n SCCS_ENTRY\n \n /* Use the table to generate a series of prototypes, an enum for the\n@@ -123,11 +128,11 @@ SCCS_ENTRY\n    pointers to functions returning void.  */\n \n /* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n-#define D(name, t, o) static int CONCAT2(do_,name) PARAMS ((cpp_reader *));\n+#define D(name, t, f) static int CONCAT2(do_,name) PARAMS ((cpp_reader *));\n DIRECTIVE_TABLE\n #undef D\n \n-#define D(n, tag, o) tag,\n+#define D(n, tag, f) tag,\n enum\n {\n   DIRECTIVE_TABLE\n@@ -136,8 +141,8 @@ enum\n #undef D\n \n /* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n-#define D(name, t, origin) \\\n-{ CONCAT2(do_,name), STRINGX(name), sizeof STRINGX(name) - 1, origin },\n+#define D(name, t, flags) \\\n+{ CONCAT2(do_,name), STRINGX(name), sizeof STRINGX(name) - 1, flags },\n static const struct directive dtable[] =\n {\n DIRECTIVE_TABLE\n@@ -249,17 +254,17 @@ _cpp_handle_directive (pfile)\n     }\n \n   /* Issue -pedantic warnings for extended directives.   */\n-  if (CPP_PEDANTIC (pfile) && dtable[i].origin == EXTENSION)\n+  if (CPP_PEDANTIC (pfile) && ORIGIN (dtable[i].flags) == EXTENSION)\n     cpp_pedwarn (pfile, \"ISO C does not allow #%s\", dtable[i].name);\n \n   /* -Wtraditional gives warnings about directives with inappropriate\n      indentation of #.  */\n   if (CPP_WTRADITIONAL (pfile))\n     {\n-      if (!hash_at_bol && TRAD_DIRECT_P (dtable[i].origin))\n+      if (!hash_at_bol && TRAD_DIRECT_P (dtable[i].flags))\n \tcpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n \t\t     dtable[i].name);\n-      else if (hash_at_bol && ! TRAD_DIRECT_P (dtable[i].origin))\n+      else if (hash_at_bol && ! TRAD_DIRECT_P (dtable[i].flags))\n \tcpp_warning (pfile,\n \t\t\"suggest hiding #%s from traditional C with an indented #\",\n \t\t     dtable[i].name);\n@@ -1331,7 +1336,7 @@ consider_directive_while_skipping (pfile, stack)\n  real_directive:\n \n   /* If it's not a directive of interest to us, return now.  */\n-  if (dtable[i].origin != COND)\n+  if (ORIGIN (dtable[i].flags) != COND)\n     return 0;\n \n   /* First, deal with -traditional and -Wtraditional."}]}