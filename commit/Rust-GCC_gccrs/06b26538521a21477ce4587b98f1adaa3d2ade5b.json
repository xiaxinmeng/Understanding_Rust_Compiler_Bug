{"sha": "06b26538521a21477ce4587b98f1adaa3d2ade5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiMjY1Mzg1MjFhMjE0NzdjZTQ1ODdiOThmMWFkYWEzZDJhZGU1Yg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-12-22T14:14:44Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-12-22T14:14:44Z"}, "message": "re PR fortran/85544 (ICE in gfc_conv_scalarized_array_ref, at fortran/trans-array.c:3385)\n\n2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/85544\n\t* frontend-passes.c (optimize_power): Remove.\n\t(optimize_op): Remove call to optimize_power.\n\t* trans-expr.c (gfc_conv_power_op): Handle cases of 1**integer,\n\t(2|4|8|16) ** integer and (-1) ** integer.\n\n2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/85544\n\t* gfortran.dg/power_7.f90: New test.\n\nFrom-SVN: r267347", "tree": {"sha": "4b6ba2a548b8eba7e69ff750a4a2d1fb4b501dd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b6ba2a548b8eba7e69ff750a4a2d1fb4b501dd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06b26538521a21477ce4587b98f1adaa3d2ade5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b26538521a21477ce4587b98f1adaa3d2ade5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06b26538521a21477ce4587b98f1adaa3d2ade5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b26538521a21477ce4587b98f1adaa3d2ade5b/comments", "author": null, "committer": null, "parents": [{"sha": "91c02f863e86aa81d003c6382ede715cffdfffc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c02f863e86aa81d003c6382ede715cffdfffc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c02f863e86aa81d003c6382ede715cffdfffc8"}], "stats": {"total": 166, "additions": 85, "deletions": 81}, "files": [{"sha": "e960cc749762b51d901caf468859b92a5c4cceca", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b26538521a21477ce4587b98f1adaa3d2ade5b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b26538521a21477ce4587b98f1adaa3d2ade5b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=06b26538521a21477ce4587b98f1adaa3d2ade5b", "patch": "@@ -1,3 +1,11 @@\n+2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/85544\n+\t* frontend-passes.c (optimize_power): Remove.\n+\t(optimize_op): Remove call to optimize_power.\n+\t* trans-expr.c (gfc_conv_power_op): Handle cases of 1**integer,\n+\t(2|4|8|16) ** integer and (-1) ** integer.\n+\n 2018-12-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/87881"}, {"sha": "91d216b778f84211068bf62ceb145d073fb7f28f", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b26538521a21477ce4587b98f1adaa3d2ade5b/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b26538521a21477ce4587b98f1adaa3d2ade5b/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=06b26538521a21477ce4587b98f1adaa3d2ade5b", "patch": "@@ -1863,84 +1863,6 @@ combine_array_constructor (gfc_expr *e)\n   return true;\n }\n \n-/* Change (-1)**k into 1-ishift(iand(k,1),1) and\n- 2**k into ishift(1,k) */\n-\n-static bool\n-optimize_power (gfc_expr *e)\n-{\n-  gfc_expr *op1, *op2;\n-  gfc_expr *iand, *ishft;\n-\n-  if (e->ts.type != BT_INTEGER)\n-    return false;\n-\n-  op1 = e->value.op.op1;\n-\n-  if (op1 == NULL || op1->expr_type != EXPR_CONSTANT)\n-    return false;\n-\n-  if (mpz_cmp_si (op1->value.integer, -1L) == 0)\n-    {\n-      gfc_free_expr (op1);\n-\n-      op2 = e->value.op.op2;\n-\n-      if (op2 == NULL)\n-\treturn false;\n-\n-      iand = gfc_build_intrinsic_call (current_ns, GFC_ISYM_IAND,\n-\t\t\t\t       \"_internal_iand\", e->where, 2, op2,\n-\t\t\t\t       gfc_get_int_expr (e->ts.kind,\n-\t\t\t\t\t\t\t &e->where, 1));\n-\n-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,\n-\t\t\t\t\t\"_internal_ishft\", e->where, 2, iand,\n-\t\t\t\t\tgfc_get_int_expr (e->ts.kind,\n-\t\t\t\t\t\t\t  &e->where, 1));\n-\n-      e->value.op.op = INTRINSIC_MINUS;\n-      e->value.op.op1 = gfc_get_int_expr (e->ts.kind, &e->where, 1);\n-      e->value.op.op2 = ishft;\n-      return true;\n-    }\n-  else if (mpz_cmp_si (op1->value.integer, 2L) == 0)\n-    {\n-      gfc_free_expr (op1);\n-\n-      op2 = e->value.op.op2;\n-      if (op2 == NULL)\n-\treturn false;\n-\n-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,\n-\t\t\t\t\t\"_internal_ishft\", e->where, 2,\n-\t\t\t\t\tgfc_get_int_expr (e->ts.kind,\n-\t\t\t\t\t\t\t  &e->where, 1),\n-\t\t\t\t\top2);\n-      *e = *ishft;\n-      return true;\n-    }\n-\n-  else if (mpz_cmp_si (op1->value.integer, 1L) == 0)\n-    {\n-      op2 = e->value.op.op2;\n-      if (op2 == NULL)\n-\treturn false;\n-\n-      gfc_free_expr (op1);\n-      gfc_free_expr (op2);\n-\n-      e->expr_type = EXPR_CONSTANT;\n-      e->value.op.op1 = NULL;\n-      e->value.op.op2 = NULL;\n-      mpz_init_set_si (e->value.integer, 1);\n-      /* Typespec and location are still OK.  */\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n /* Recursive optimization of operators.  */\n \n static bool\n@@ -2001,9 +1923,6 @@ optimize_op (gfc_expr *e)\n     case INTRINSIC_DIVIDE:\n       return combine_array_constructor (e) || changed;\n \n-    case INTRINSIC_POWER:\n-      return optimize_power (e);\n-\n     default:\n       break;\n     }"}, {"sha": "a2fd53cc1f3dfe8632f960199add3a4a7c887351", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b26538521a21477ce4587b98f1adaa3d2ade5b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b26538521a21477ce4587b98f1adaa3d2ade5b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=06b26538521a21477ce4587b98f1adaa3d2ade5b", "patch": "@@ -3056,6 +3056,83 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n     if (gfc_conv_cst_int_power (se, lse.expr, rse.expr))\n       return;\n \n+  if (INTEGER_CST_P (lse.expr)\n+      && TREE_CODE (TREE_TYPE (rse.expr)) == INTEGER_TYPE)\n+    {\n+      wi::tree_to_wide_ref wlhs = wi::to_wide (lse.expr);\n+      HOST_WIDE_INT v;\n+      v = wlhs.to_shwi ();\n+      if (v == 1)\n+\t{\n+\t  /* 1**something is always 1.  */\n+\t  se->expr = build_int_cst (TREE_TYPE (lse.expr), 1);\n+\t  return;\n+\t}\n+      else if (v == 2 || v == 4 || v == 8 || v == 16)\n+\t{\n+\t  /* 2**n = 1<<n, 4**n = 1<<(n+n), 8**n = 1 <<(3*n), 16**n =\n+\t   1<<(4*n), but we have to make sure to return zero if the\n+\t   number of bits is too large. */\n+\t  tree lshift;\n+\t  tree type;\n+\t  tree shift;\n+\t  tree ge;\n+\t  tree cond;\n+\t  tree num_bits;\n+\t  tree cond2;\n+\n+\t  type = TREE_TYPE (lse.expr);\n+\n+\t  if (v == 2)\n+\t    shift = rse.expr;\n+\t  else if (v == 4)\n+\t    shift = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t     TREE_TYPE (rse.expr),\n+\t\t\t\t       rse.expr, rse.expr);\n+\t  else if (v == 8)\n+\t    shift = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     TREE_TYPE (rse.expr),\n+\t\t\t\t     build_int_cst (TREE_TYPE (rse.expr), 3),\n+\t\t\t\t     rse.expr);\n+\t  else if (v == 16)\n+\t    shift = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     TREE_TYPE (rse.expr),\n+\t\t\t\t     build_int_cst (TREE_TYPE (rse.expr), 4),\n+\t\t\t\t     rse.expr);\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  lshift = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t\t    build_int_cst (type, 1), shift);\n+\t  ge = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n+\t\t\t\trse.expr, build_int_cst (type, 0));\n+\t  cond = fold_build3_loc (input_location, COND_EXPR, type, ge, lshift,\n+\t\t\t\t build_int_cst (type, 0));\n+\t  num_bits = build_int_cst (TREE_TYPE (rse.expr), TYPE_PRECISION (type));\n+\t  cond2 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n+\t\t\t\t   rse.expr, num_bits);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond2,\n+\t\t\t\t      build_int_cst (type, 0), cond);\n+\t  return;\n+\t}\n+      else if (v == -1)\n+\t{\n+\t  /* (-1)**n is 1 - ((n & 1) << 1) */\n+\t  tree type;\n+\t  tree tmp;\n+\n+\t  type = TREE_TYPE (lse.expr);\n+\t  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type,\n+\t\t\t\t rse.expr, build_int_cst (type, 1));\n+\t  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t\t tmp, build_int_cst (type, 1));\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, type,\n+\t\t\t\t build_int_cst (type, 1), tmp);\n+\t  se->expr = tmp;\n+\t  return;\n+\t}\n+    }\n+\n   gfc_int4_type_node = gfc_get_int_type (4);\n \n   /* In case of integer operands with kinds 1 or 2, we call the integer kind 4"}]}