{"sha": "28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1OTFmNGE4Y2JmYWIwNjY5MmRjZDhhZTlhNjllZjk1ZWNkZjM3OA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-08-27T21:13:07Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-08-27T21:13:07Z"}, "message": "re PR target/46254 (ICE: in find_reloads, at reload.c:3806 (unable to generate reloads) with -fPIC -mcmodel={medium|large} and __sync_val_compare_and_swap)\n\n\tPR target/46254\n\t* config/i386/predicates.md (cmpxchg8b_pic_memory_operand): Return\n\ttrue for TARGET_64BIT or !flag_pic.\n\t* config/i386/sync.md (*atomic_compare_and_swap_doubledi_pic): Remove.\n\t(atomic_compare_and_swap_double<mode>): Change operand 2 predicate\n\tto cmpxchg8b_pic_memory_operand.  Use DWIH mode iterator.\n\tAdd insn constraint.  Conditionally emit xchg asm insns.\n\t(atomic_compare_and_swap<mode>): Update calls.  Check only\n\tcmpxchg8b_pic_memory_operand in memory address fixup.\n\t(DCASMODE): Remove.\n\t(CASHMODE): Rename from DCASHMODE.\n\t(doublemodesuffix): Update modes.\n\t(regprefix): New mode attribute.\n\n\t(unspecv) <UNSPECV_CMPXCHG_{1,2,3,4}>: Remove.\n\t<UNSPECV_CMPXCHG>: New constant.\n\t(atomic_compare_and_swap<mode>_1): Rename from\n\tatomic_compare_and_swap_single<mode>.  Update calls and\n\tunspec_volatile constants.\n\t(atomic_compare_and_swap<mode>_doubleword): Rename from\n\tatomic_compare_and_swap_double<mode>.  Update calls and\n\tunspec_volatile constants.\n\ntestsuite/ChangeLog:\n\n\tPR target/46254\n\t* gcc.target/i386/pr46254.c: New test.\n\nFrom-SVN: r190732", "tree": {"sha": "b4bfc575aa3d64996935f92d5870b3d297d870c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4bfc575aa3d64996935f92d5870b3d297d870c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/comments", "author": null, "committer": null, "parents": [{"sha": "d7920cf0719e3cc28e61a98d640f6d1cb46d797e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7920cf0719e3cc28e61a98d640f6d1cb46d797e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7920cf0719e3cc28e61a98d640f6d1cb46d797e"}], "stats": {"total": 173, "additions": 102, "deletions": 71}, "files": [{"sha": "5139e98cc96a8f19e9acf67a1426538166cf2f72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "patch": "@@ -1,3 +1,28 @@\n+2012-08-27  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/46254\n+\t* config/i386/predicates.md (cmpxchg8b_pic_memory_operand): Return\n+\ttrue for TARGET_64BIT or !flag_pic.\n+\t* config/i386/sync.md (*atomic_compare_and_swap_doubledi_pic): Remove.\n+\t(atomic_compare_and_swap_double<mode>): Change operand 2 predicate\n+\tto cmpxchg8b_pic_memory_operand.  Use DWIH mode iterator.\n+\tAdd insn constraint.  Conditionally emit xchg asm insns.\n+\t(atomic_compare_and_swap<mode>): Update calls.  Check only\n+\tcmpxchg8b_pic_memory_operand in memory address fixup.\n+\t(DCASMODE): Remove.\n+\t(CASHMODE): Rename from DCASHMODE.\n+\t(doublemodesuffix): Update modes.\n+\t(regprefix): New mode attribute.\n+\n+\t(unspecv) <UNSPECV_CMPXCHG_{1,2,3,4}>: Remove.\n+\t<UNSPECV_CMPXCHG>: New constant.\n+\t(atomic_compare_and_swap<mode>_1): Rename from\n+\tatomic_compare_and_swap_single<mode>.  Update calls and\n+\tunspec_volatile constants.\n+\t(atomic_compare_and_swap<mode>_doubleword): Rename from\n+\tatomic_compare_and_swap_double<mode>.  Update calls and\n+\tunspec_volatile constants.\n+\n 2012-08-27  Walter Lee  <walt@tilera.com>\n \n \t* doc/md.texi (TILE-Gx): Fix typo.\n@@ -6,9 +31,9 @@\n \n \t* config/tilegx/tilegx.c (tilegx_function_profiler): Fix typo.\n \tconfig/tilepro/tilepro.c (tilepro_function_profiler): Ditto.\n-\t\n+\n 2012-08-27  Walter Lee  <walt@tilera.com>\n-\t\n+\n \t* config/tilegx/tilegx.md (*bfins): Rename to insn_bfins.\n \t(insn_bfins): Delete.\n \n@@ -80,12 +105,12 @@\n \tthis section.\n \n 2012-08-26  Gerald Pfeifer  <gerald@pfeifer.com>\n-\t\n+\n \t* doc/tm.texi.in (Misc): Move descriptions of NO_DOLLAR_IN_LABEL\n \tand NO_DOT_IN_LABEL from here...\n \t(Label Output): ...to here.\n \t* doc/tm.texi: Regenerate.\n-\t\t\t\n+\n 2012-08-26  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/invoke.texi (C++ Dialect Options): Add missing space.\n@@ -100,7 +125,7 @@\n \t* doc/extend.texi (__atomic Builtins): Remove space before comma.\n \n 2012-08-25  Richard Sandiford  <rdsandiford@googlemail.com>\n-            Andrew Pinski  <apinski@cavium.com>\n+\t    Andrew Pinski  <apinski@cavium.com>\n \n \t* config/mips/mips.h (CASE_VECTOR_MODE): For not\n \tTARGET_MIPS16_SHORT_JUMP_TABLES use ptr_mode."}, {"sha": "55e4b5610dfac1b8111b0cbac59a51501ed93b0a", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "patch": "@@ -971,6 +971,9 @@\n   struct ix86_address parts;\n   int ok;\n \n+  if (TARGET_64BIT || !flag_pic)\n+    return true;\n+\n   ok = ix86_decompose_address (XEXP (op, 0), &parts);\n   gcc_assert (ok);\n "}, {"sha": "50bedcf0dff320027b88ecdb314354b1bf08bddf", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "patch": "@@ -28,10 +28,7 @@\n ])\n \n (define_c_enum \"unspecv\" [\n-  UNSPECV_CMPXCHG_1\n-  UNSPECV_CMPXCHG_2\n-  UNSPECV_CMPXCHG_3\n-  UNSPECV_CMPXCHG_4\n+  UNSPECV_CMPXCHG\n   UNSPECV_XCHG\n   UNSPECV_LOCK\n ])\n@@ -316,7 +313,7 @@\n   \"TARGET_CMPXCHG\"\n {\n   emit_insn\n-   (gen_atomic_compare_and_swap_single<mode>\n+   (gen_atomic_compare_and_swap<mode>_1\n     (operands[1], operands[2], operands[3], operands[4], operands[6]));\n   ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n \t\t     const0_rtx);\n@@ -326,11 +323,7 @@\n (define_mode_iterator CASMODE\n   [(DI \"TARGET_64BIT || TARGET_CMPXCHG8B\")\n    (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n-(define_mode_iterator DCASMODE\n-  [(DI \"!TARGET_64BIT && TARGET_CMPXCHG8B && !flag_pic\")\n-   (TI \"TARGET_64BIT && TARGET_CMPXCHG16B\")])\n-(define_mode_attr doublemodesuffix [(DI \"8\") (TI \"16\")])\n-(define_mode_attr DCASHMODE [(DI \"SI\") (TI \"DI\")])\n+(define_mode_attr CASHMODE [(DI \"SI\") (TI \"DI\")])\n \n (define_expand \"atomic_compare_and_swap<mode>\"\n   [(match_operand:QI 0 \"register_operand\")\t;; bool success output\n@@ -346,12 +339,12 @@\n   if (<MODE>mode == DImode && TARGET_64BIT)\n     {\n       emit_insn\n-       (gen_atomic_compare_and_swap_singledi\n+       (gen_atomic_compare_and_swapdi_1\n \t(operands[1], operands[2], operands[3], operands[4], operands[6]));\n     }\n   else\n     {\n-      enum machine_mode hmode = <DCASHMODE>mode;\n+      enum machine_mode hmode = <CASHMODE>mode;\n       rtx lo_o, lo_e, lo_n, hi_o, hi_e, hi_n, mem;\n \n       lo_o = operands[1];\n@@ -365,32 +358,31 @@\n       lo_e = gen_lowpart (hmode, lo_e);\n       lo_n = gen_lowpart (hmode, lo_n);\n \n-      if (<MODE>mode == DImode\n-\t  && !TARGET_64BIT\n-\t  && flag_pic\n-\t  && !cmpxchg8b_pic_memory_operand (mem, DImode))\n-\tmem = replace_equiv_address (mem, force_reg (Pmode, XEXP (mem, 0)));\n+      if (!cmpxchg8b_pic_memory_operand (mem, <MODE>mode))\n+ \tmem = replace_equiv_address (mem, force_reg (Pmode, XEXP (mem, 0)));\n \n-      emit_insn (gen_atomic_compare_and_swap_double<mode>\n-\t\t (lo_o, hi_o, mem, lo_e, hi_e, lo_n, hi_n, operands[6]));\n+      emit_insn\n+       (gen_atomic_compare_and_swap<mode>_doubleword\n+        (lo_o, hi_o, mem, lo_e, hi_e, lo_n, hi_n, operands[6]));\n     }\n+\n   ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n \t\t     const0_rtx);\n   DONE;\n })\n \n-(define_insn \"atomic_compare_and_swap_single<mode>\"\n+(define_insn \"atomic_compare_and_swap<mode>_1\"\n   [(set (match_operand:SWI 0 \"register_operand\" \"=a\")\n \t(unspec_volatile:SWI\n \t  [(match_operand:SWI 1 \"memory_operand\" \"+m\")\n \t   (match_operand:SWI 2 \"register_operand\" \"0\")\n \t   (match_operand:SWI 3 \"register_operand\" \"<r>\")\n \t   (match_operand:SI 4 \"const_int_operand\")]\n-\t  UNSPECV_CMPXCHG_1))\n+\t  UNSPECV_CMPXCHG))\n    (set (match_dup 1)\n-\t(unspec_volatile:SWI [(const_int 0)] UNSPECV_CMPXCHG_2))\n+\t(unspec_volatile:SWI [(const_int 0)] UNSPECV_CMPXCHG))\n    (set (reg:CCZ FLAGS_REG)\n-        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_3))]\n+        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG))]\n   \"TARGET_CMPXCHG\"\n   \"lock{%;} %K4cmpxchg{<imodesuffix>}\\t{%3, %1|%1, %3}\")\n \n@@ -399,52 +391,47 @@\n ;; not match the gcc register numbering, so the pair must be CX:BX.\n ;; That said, in order to take advantage of possible lower-subreg opts,\n ;; treat all of the integral operands in the same way.\n-(define_insn \"atomic_compare_and_swap_double<mode>\"\n-  [(set (match_operand:<DCASHMODE> 0 \"register_operand\" \"=a\")\n-\t(unspec_volatile:<DCASHMODE>\n-\t  [(match_operand:DCASMODE 2 \"memory_operand\" \"+m\")\n-\t   (match_operand:<DCASHMODE> 3 \"register_operand\" \"0\")\n-\t   (match_operand:<DCASHMODE> 4 \"register_operand\" \"1\")\n-\t   (match_operand:<DCASHMODE> 5 \"register_operand\" \"b\")\n-\t   (match_operand:<DCASHMODE> 6 \"register_operand\" \"c\")\n-\t   (match_operand:SI 7 \"const_int_operand\")]\n-\t  UNSPECV_CMPXCHG_1))\n-   (set (match_operand:<DCASHMODE> 1 \"register_operand\" \"=d\")\n-\t(unspec_volatile:<DCASHMODE> [(const_int 0)] UNSPECV_CMPXCHG_2))\n-   (set (match_dup 2)\n-\t(unspec_volatile:DCASMODE [(const_int 0)] UNSPECV_CMPXCHG_3))\n-   (set (reg:CCZ FLAGS_REG)\n-        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_4))]\n-  \"\"\n-  \"lock{%;} %K7cmpxchg<doublemodesuffix>b\\t%2\")\n-\n-;; Theoretically we'd like to use constraint \"r\" (any reg) for op5,\n-;; but that includes ecx.  If op5 and op6 are the same (like when\n-;; the input is -1LL) GCC might chose to allocate op5 to ecx, like\n-;; op6.  This breaks, as the xchg will move the PIC register contents\n-;; to %ecx then --> boom.  Operands 5 and 6 really need to be different\n-;; registers, which in this case means op5 must not be ecx.  Instead\n-;; of playing tricks with fake early clobbers or the like we just\n-;; enumerate all regs possible here, which (as this is !TARGET_64BIT)\n-;; are just esi and edi.\n-(define_insn \"*atomic_compare_and_swap_doubledi_pic\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(unspec_volatile:SI\n-\t  [(match_operand:DI 2 \"cmpxchg8b_pic_memory_operand\" \"+m\")\n-\t   (match_operand:SI 3 \"register_operand\" \"0\")\n-\t   (match_operand:SI 4 \"register_operand\" \"1\")\n-\t   (match_operand:SI 5 \"register_operand\" \"SD\")\n-\t   (match_operand:SI 6 \"register_operand\" \"c\")\n+\n+;; Operands 5 and 6 really need to be different registers, which in\n+;; this case means op5 must not be ecx.  If op5 and op6 are the same\n+;; (like when the input is -1LL) GCC might chose to allocate op5 to ecx,\n+;; like op6.  This breaks, as the xchg will move the PIC register\n+;; contents to %ecx then --> boom.\n+\n+(define_mode_attr doublemodesuffix [(SI \"8\") (DI \"16\")])\n+(define_mode_attr regprefix [(SI \"e\") (DI \"r\")])\n+\n+(define_insn \"atomic_compare_and_swap<dwi>_doubleword\"\n+  [(set (match_operand:DWIH 0 \"register_operand\" \"=a,a\")\n+\t(unspec_volatile:DWIH\n+\t  [(match_operand:<DWI> 2 \"cmpxchg8b_pic_memory_operand\" \"+m,m\")\n+\t   (match_operand:DWIH 3 \"register_operand\" \"0,0\")\n+\t   (match_operand:DWIH 4 \"register_operand\" \"1,1\")\n+\t   (match_operand:DWIH 5 \"register_operand\" \"b,!*r\")\n+\t   (match_operand:DWIH 6 \"register_operand\" \"c,c\")\n \t   (match_operand:SI 7 \"const_int_operand\")]\n-\t  UNSPECV_CMPXCHG_1))\n-   (set (match_operand:SI 1 \"register_operand\" \"=d\")\n-\t(unspec_volatile:SI [(const_int 0)] UNSPECV_CMPXCHG_2))\n+\t  UNSPECV_CMPXCHG))\n+   (set (match_operand:DWIH 1 \"register_operand\" \"=d,d\")\n+\t(unspec_volatile:DWIH [(const_int 0)] UNSPECV_CMPXCHG))\n    (set (match_dup 2)\n-\t(unspec_volatile:DI [(const_int 0)] UNSPECV_CMPXCHG_3))\n+\t(unspec_volatile:<DWI> [(const_int 0)] UNSPECV_CMPXCHG))\n    (set (reg:CCZ FLAGS_REG)\n-        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG_4))]\n-  \"!TARGET_64BIT && TARGET_CMPXCHG8B && flag_pic\"\n-  \"xchg{l}\\t%%ebx, %5\\;lock{%;} %K7cmpxchg8b\\t%2\\;xchg{l}\\t%%ebx, %5\")\n+        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG))\n+   (clobber (match_scratch:DWIH 8 \"=X,&5\"))]\n+  \"TARGET_CMPXCHG<doublemodesuffix>B\"\n+{\n+  bool swap = REGNO (operands[5]) != BX_REG;\n+\n+  if (swap)\n+    output_asm_insn (\"xchg{<imodesuffix>}\\t%%<regprefix>bx, %5\", operands);\n+\n+  output_asm_insn (\"lock{%;} %K7cmpxchg<doublemodesuffix>b\\t%2\", operands);\n+\n+  if (swap)\n+    output_asm_insn (\"xchg{<imodesuffix>}\\t%%<regprefix>bx, %5\", operands);\n+\n+  return \"\";\n+})\n \n ;; For operand 2 nonmemory_operand predicate is used instead of\n ;; register_operand to allow combiner to better optimize atomic"}, {"sha": "6f292861348171325dec8c580c173c03ef7165df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "patch": "@@ -1,3 +1,8 @@\n+2012-08-27  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/46254\n+\t* gcc.target/i386/pr46254.c: New test.\n+\n 2012-08-27  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.target/mips/ext_ins.c, gcc.target/mips/octeon-pop-2.c,"}, {"sha": "512287a5b390f4ed0ed83f2c0b0b96c75b269366", "filename": "gcc/testsuite/gcc.target/i386/pr46254.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46254.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28591f4a8cbfab06692dcd8ae9a69ef95ecdf378/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46254.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46254.c?ref=28591f4a8cbfab06692dcd8ae9a69ef95ecdf378", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target fpic } */\n+/* { dg-options \"-O2 -mcx16 -fpic -mcmodel=large\" } */\n+\n+__int128 i;\n+\n+void test ()\n+{\n+  __sync_val_compare_and_swap (&i, i, i);\n+}"}]}