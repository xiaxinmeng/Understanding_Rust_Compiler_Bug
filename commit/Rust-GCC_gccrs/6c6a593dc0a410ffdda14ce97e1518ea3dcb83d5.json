{"sha": "6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM2YTU5M2RjMGE0MTBmZmRkYTE0Y2U5N2UxNTE4ZWEzZGNiODNkNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-12-07T21:55:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-12-07T21:55:47Z"}, "message": "compare-elim.c: Fix head comment.\n\n\t* compare-elim.c: Fix head comment.\n\t(conforming_compare): Remove redundant test.\n\t(can_eliminate_compare): New function extracted from...\n\t(before_dom_children): ...here.  Use it, replace direct uses of\n\tflag_non_call_exceptions and tidy up.\n\t(maybe_select_cc_mode): Tidy up.\n\nFrom-SVN: r218468", "tree": {"sha": "9771543510a64886dece0bd4ed92d8c2cc4011ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9771543510a64886dece0bd4ed92d8c2cc4011ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5/comments", "author": null, "committer": null, "parents": [{"sha": "bbea402544b0c98388fc9922eab978ee8ae6f092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbea402544b0c98388fc9922eab978ee8ae6f092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbea402544b0c98388fc9922eab978ee8ae6f092"}], "stats": {"total": 116, "additions": 62, "deletions": 54}, "files": [{"sha": "46e41ec9892cfa0d52fbd3dc920aca9ea90cdb76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5", "patch": "@@ -1,3 +1,12 @@\n+2014-12-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* compare-elim.c: Fix head comment.\n+\t(conforming_compare): Remove redundant test.\n+\t(can_eliminate_compare): New function extracted from...\n+\t(before_dom_children): ...here.  Use it, replace direct uses of\n+\tflag_non_call_exceptions and tidy up.\n+\t(maybe_select_cc_mode): Tidy up.\n+\n 2014-12-07  Felix Yang  <felix.yang@huawei.com>\n \t    Shanyao Chen  <chenshanyao@huawei.com>\n "}, {"sha": "4b307807c4ef6675316a785c01704a7fc9f14227", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=6c6a593dc0a410ffdda14ce97e1518ea3dcb83d5", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    (1) All comparison patterns are represented as\n \n-\t[(set (reg:CC) (compare:CC (reg) (immediate)))]\n+\t[(set (reg:CC) (compare:CC (reg) (reg_or_immediate)))]\n \n    (2) All insn patterns that modify the flags are represented as\n \n@@ -157,7 +157,6 @@ conforming_compare (rtx_insn *insn)\n     return NULL;\n \n   if (REG_P (XEXP (src, 0))\n-      && REG_P (XEXP (src, 0))\n       && (REG_P (XEXP (src, 1)) || CONSTANT_P (XEXP (src, 1))))\n     return src;\n \n@@ -266,6 +265,45 @@ class find_comparison_dom_walker : public dom_walker\n   virtual void before_dom_children (basic_block);\n };\n \n+/* Return true if conforming COMPARE with EH_NOTE is redundant with comparison\n+   CMP and can thus be eliminated.  */\n+\n+static bool\n+can_eliminate_compare (rtx compare, rtx eh_note, struct comparison *cmp)\n+{\n+  /* Take care that it's in the same EH region.  */\n+  if (cfun->can_throw_non_call_exceptions\n+      && !rtx_equal_p (eh_note, cmp->eh_note))\n+    return false;\n+\n+  /* Make sure the compare is redundant with the previous.  */\n+  if (!rtx_equal_p (XEXP (compare, 0), cmp->in_a)\n+      || !rtx_equal_p (XEXP (compare, 1), cmp->in_b))\n+    return false;\n+\n+  /* New mode must be compatible with the previous compare mode.  */\n+  enum machine_mode new_mode\n+    = targetm.cc_modes_compatible (GET_MODE (compare), cmp->orig_mode);\n+\n+  if (new_mode == VOIDmode)\n+    return false;\n+\n+  if (cmp->orig_mode != new_mode)\n+    {\n+      /* Generate new comparison for substitution.  */\n+      rtx flags = gen_rtx_REG (new_mode, targetm.flags_regnum);\n+      rtx x = gen_rtx_COMPARE (new_mode, cmp->in_a, cmp->in_b);\n+      x = gen_rtx_SET (VOIDmode, flags, x);\n+\n+      if (!validate_change (cmp->insn, &PATTERN (cmp->insn), x, false))\n+\treturn false;\n+\n+      cmp->orig_mode = new_mode;\n+    }\n+\n+  return true;\n+}\n+\n /* Identify comparison instructions within BB.  If the flags from the last\n    compare in the BB is live at the end of the block, install the compare\n    in BB->AUX.  Called via dom_walker.walk ().  */\n@@ -317,62 +355,26 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n       src = conforming_compare (insn);\n       if (src)\n \t{\n-\t  machine_mode src_mode = GET_MODE (src);\n \t  rtx eh_note = NULL;\n \n-\t  if (flag_non_call_exceptions)\n+\t  if (cfun->can_throw_non_call_exceptions)\n \t    eh_note = find_reg_note (insn, REG_EH_REGION, NULL);\n \n-\t  if (!last_cmp_valid)\n-\t    goto dont_delete;\n-\n-\t  /* Take care that it's in the same EH region.  */\n-\t  if (flag_non_call_exceptions\n-\t      && !rtx_equal_p (eh_note, last_cmp->eh_note))\n-\t    goto dont_delete;\n-\n-\t  /* Make sure the compare is redundant with the previous.  */\n-\t  if (!rtx_equal_p (last_cmp->in_a, XEXP (src, 0))\n-\t      || !rtx_equal_p (last_cmp->in_b, XEXP (src, 1)))\n-\t    goto dont_delete;\n-\n-\t  /* New mode must be compatible with the previous compare mode.  */\n-\t  {\n-\t    machine_mode new_mode\n-\t      = targetm.cc_modes_compatible (last_cmp->orig_mode, src_mode);\n-\t    if (new_mode == VOIDmode)\n-\t      goto dont_delete;\n-\n-\t    if (new_mode != last_cmp->orig_mode)\n-\t      {\n-\t\trtx x, flags = gen_rtx_REG (src_mode, targetm.flags_regnum);\n-\n-\t\t/* Generate new comparison for substitution.  */\n-\t\tx = gen_rtx_COMPARE (new_mode, XEXP (src, 0), XEXP (src, 1));\n-\t\tx = gen_rtx_SET (VOIDmode, flags, x);\n-\n-\t\tif (!validate_change (last_cmp->insn,\n-\t\t\t\t      &PATTERN (last_cmp->insn), x, false))\n-\t\t  goto dont_delete;\n-\n-\t\tlast_cmp->orig_mode = new_mode;\n-\t      }\n-\t  }\n-\n-\t  /* All tests and substitutions succeeded!  */\n-\t  if (eh_note)\n-\t    need_purge = true;\n-\t  delete_insn (insn);\n-\t  continue;\n+\t  if (last_cmp_valid && can_eliminate_compare (src, eh_note, last_cmp))\n+\t    {\n+\t      if (eh_note)\n+\t\tneed_purge = true;\n+\t      delete_insn (insn);\n+\t      continue;\n+\t    }\n \n-\tdont_delete:\n \t  last_cmp = XCNEW (struct comparison);\n \t  last_cmp->insn = insn;\n \t  last_cmp->prev_clobber = last_clobber;\n \t  last_cmp->in_a = XEXP (src, 0);\n \t  last_cmp->in_b = XEXP (src, 1);\n \t  last_cmp->eh_note = eh_note;\n-\t  last_cmp->orig_mode = src_mode;\n+\t  last_cmp->orig_mode = GET_MODE (src);\n \t  all_compares.safe_push (last_cmp);\n \n \t  /* It's unusual, but be prepared for comparison patterns that\n@@ -391,7 +393,6 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \t  /* In either case, the previous compare is no longer valid.  */\n \t  last_cmp = NULL;\n \t  last_cmp_valid = false;\n-\t  continue;\n \t}\n \n       /* Notice if this instruction uses the flags register.  */\n@@ -425,8 +426,7 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      basic_block dest = e->dest;\n-\t      if (bitmap_bit_p (df_get_live_in (bb),\n-\t\t\t\ttargetm.flags_regnum)\n+\t      if (bitmap_bit_p (df_get_live_in (bb), targetm.flags_regnum)\n \t\t  && !single_pred_p (dest))\n \t\t{\n \t\t  last_cmp->missing_uses = true;\n@@ -498,16 +498,15 @@ maybe_select_cc_mode (struct comparison *cmp, rtx a ATTRIBUTE_UNUSED,\n       sel_mode = SELECT_CC_MODE (cmp->uses[0].code, a, b);\n       for (i = 1; i < n; ++i)\n \t{\n-\t  machine_mode new_mode;\n-\t  new_mode = SELECT_CC_MODE (cmp->uses[i].code, a, b);\n+\t  machine_mode new_mode = SELECT_CC_MODE (cmp->uses[i].code, a, b);\n \t  if (new_mode != sel_mode)\n \t    {\n \t      sel_mode = targetm.cc_modes_compatible (sel_mode, new_mode);\n \t      if (sel_mode == VOIDmode)\n \t\treturn NULL;\n \t    }\n \t}\n-      \n+\n       if (sel_mode != cmp->orig_mode)\n \t{\n \t  flags = gen_rtx_REG (sel_mode, targetm.flags_regnum);\n@@ -633,7 +632,7 @@ try_eliminate_compare (struct comparison *cmp)\n   validate_change (insn, &XVECEXP (PATTERN (insn), 0, 1), x, true);\n   if (!apply_change_group ())\n     return false;\n- \n+\n   /* Success.  Delete the compare insn...  */\n   delete_insn (cmp->insn);\n "}]}