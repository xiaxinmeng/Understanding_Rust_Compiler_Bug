{"sha": "fdce7209c23212b50f08604f242e9bbb5281818b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjZTcyMDljMjMyMTJiNTBmMDg2MDRmMjQyZTliYmI1MjgxODE4Yg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-01-20T01:32:48Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-01-20T01:32:48Z"}, "message": "New jit API entrypoint: gcc_jit_context_compile_to_file\n\ngcc/jit/ChangeLog:\n\t* docs/cp/topics/results.rst: Rename to...\n\t* docs/cp/topics/compilation.rst: ...this, and add section on\n\tahead-of-time compilation.\n\t* docs/cp/topics/index.rst: Update for renaming of results.rst\n\tto compilation.rst.\n\t* docs/examples/emit-alphabet.bf: New file, a sample \"brainf\"\n\tscript.\n\t* docs/examples/tut05-bf.c: New file, implementing a compiler\n\tfor \"brainf\".\n\t* docs/internals/test-hello-world.exe.log.txt: Update to reflect\n\tchanges to logger output.\n\t* docs/intro/index.rst: Add tutorial05.rst\n\t* docs/intro/tutorial05.rst: New file.\n\t* docs/topics/results.rst: Rename to...\n\t* docs/topics/compilation.rst: ...this, and add section on\n\tahead-of-time compilation.\n\t* docs/topics/index.rst: Update for renaming of results.rst to\n\tcompilation.rst.\n\t* jit-playback.c (gcc::jit::playback::context::compile): Convert\n\treturn type from result * to void.  Move the code to convert to\n\tdso and dlopen the result to a new pure virtual \"postprocess\"\n\tmethod.\n\t(gcc::jit::playback::compile_to_memory::compile_to_memory): New\n\tfunction.\n\t(gcc::jit::playback::compile_to_memory::postprocess): New\n\tfunction, based on playback::context::compile.\n\t(gcc::jit::playback::compile_to_file::compile_to_file): New\n\tfunction.\n\t(gcc::jit::playback::compile_to_file::postprocess): New function.\n\t(gcc::jit::playback::compile_to_file::copy_file): New function.\n\t(gcc::jit::playback::context::convert_to_dso): Move internals\n\tto...\n\t(gcc::jit::playback::context::invoke_driver): New method.  Add\n\t\"-shared\" and \"-c\" options to driver's argv as needed.\n\t* jit-playback.h: Include \"timevar.h\".\n\t(gcc::jit::playback::context::compile): Convert return type from\n\tresult * to void.\n\t(gcc::jit::playback::context::postprocess): New pure virtual\n\tfunction, making this an abstract base class.\n\t(gcc::jit::playback::context::get_tempdir): New accessor.\n\t(gcc::jit::playback::context::invoke_driver): New function.\n\t(class gcc::jit::playback::compile_to_memory): New subclass of\n\tplayback::context.\n\t(class gcc::jit::playback::compile_to_file): Likewise.\n\t* jit-recording.c (gcc::jit::recording::context::compile): Use a\n\tplayback::compile_to_memory, and extract its result.\n\t(gcc::jit::recording::context::compile_to_file): New function.\n\t* jit-recording.h (gcc::jit::recording::context::compile_to_file):\n\tNew function.\n\t* libgccjit++.h (gccjit::context::compile_to_file): New method.\n\t* libgccjit.c (gcc_jit_context_compile): Update log message to\n\tclarify that this is an in-memory compile.\n\t(gcc_jit_context_compile_to_file): New function.\n\t* libgccjit.h (gcc_jit_context): Clarify that you can compile\n\ta context more than once, and that you can compile to a file\n\tas well as to memory.\n\t(gcc_jit_result): Clarify that this is the result of an\n\tin-memory compilation.\n\t(gcc_jit_context_compile): Clarify that you can compile, and that\n\tthis is an in-memory compilation.\n\t(enum gcc_jit_output_kind): New enum.\n\t(gcc_jit_context_compile_to_file): New function.\n\t(gcc_jit_context_enable_dump): Clarify comment to cover both forms\n\tof compilation.\n\t* libgccjit.map (gcc_jit_context_compile_to_file): New API\n\tentrypoint.\n\t* notes.txt: Update to show the playback::context::postprocess\n\tvirtual function.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/harness.h: Include <unistd.h>.\n\t(CHECK_NO_ERRORS): New.\n\t(verify_code): Wrap prototype in #ifndef TEST_COMPILING_TO_FILE.\n\t(test_jit): Support new macro TEST_COMPILING_TO_FILE for exercising\n\tgcc_jit_context_compile_to_file.\n\t* jit.dg/jit.exp (fixed_host_execute): Fix the code for passing on\n\targs to the spawned executable.\n\t(jit-expand-vars): New function.\n\t(jit-exe-params): New variable.\n\t(dg-jit-set-exe-params): New function.\n\t(jit-dg-test): Detect testcases that use\n\tjit-verify-compile-to-file and call jit-setup-compile-to-file.\n\tSet arguments of spawned process to jit-exe-params.\n\t(jit-get-output-filename): New function.\n\t(jit-setup-compile-to-file): New function.\n\t(jit-verify-compile-to-file): New function.\n\t(jit-run-executable): New function.\n\t(jit-verify-executable): New function.\n\t* jit.dg/test-compile-to-assembler.c: New testcase.\n\t* jit.dg/test-compile-to-dynamic-library.c: New testcase.\n\t* jit.dg/test-compile-to-executable.c: New testcase.\n\t* jit.dg/test-compile-to-object.c: New testcase.\n\nFrom-SVN: r219876", "tree": {"sha": "474c9e2fbfe804a349ce0083fd02f728b0475514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/474c9e2fbfe804a349ce0083fd02f728b0475514"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdce7209c23212b50f08604f242e9bbb5281818b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdce7209c23212b50f08604f242e9bbb5281818b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdce7209c23212b50f08604f242e9bbb5281818b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdce7209c23212b50f08604f242e9bbb5281818b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb22ab4164a2140fa7ec38cd929d464224d9c222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb22ab4164a2140fa7ec38cd929d464224d9c222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb22ab4164a2140fa7ec38cd929d464224d9c222"}], "stats": {"total": 4091, "additions": 3505, "deletions": 586}, "files": [{"sha": "e5750749aac80305481be91d85050c7d2bbecba0", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -1,3 +1,75 @@\n+2015-01-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/cp/topics/results.rst: Rename to...\n+\t* docs/cp/topics/compilation.rst: ...this, and add section on\n+\tahead-of-time compilation.\n+\t* docs/cp/topics/index.rst: Update for renaming of results.rst\n+\tto compilation.rst.\n+\t* docs/examples/emit-alphabet.bf: New file, a sample \"brainf\"\n+\tscript.\n+\t* docs/examples/tut05-bf.c: New file, implementing a compiler\n+\tfor \"brainf\".\n+\t* docs/internals/test-hello-world.exe.log.txt: Update to reflect\n+\tchanges to logger output.\n+\t* docs/intro/index.rst: Add tutorial05.rst\n+\t* docs/intro/tutorial05.rst: New file.\n+\t* docs/topics/results.rst: Rename to...\n+\t* docs/topics/compilation.rst: ...this, and add section on\n+\tahead-of-time compilation.\n+\t* docs/topics/index.rst: Update for renaming of results.rst to\n+\tcompilation.rst.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* jit-playback.c (gcc::jit::playback::context::compile): Convert\n+\treturn type from result * to void.  Move the code to convert to\n+\tdso and dlopen the result to a new pure virtual \"postprocess\"\n+\tmethod.\n+\t(gcc::jit::playback::compile_to_memory::compile_to_memory): New\n+\tfunction.\n+\t(gcc::jit::playback::compile_to_memory::postprocess): New\n+\tfunction, based on playback::context::compile.\n+\t(gcc::jit::playback::compile_to_file::compile_to_file): New\n+\tfunction.\n+\t(gcc::jit::playback::compile_to_file::postprocess): New function.\n+\t(gcc::jit::playback::compile_to_file::copy_file): New function.\n+\t(gcc::jit::playback::context::convert_to_dso): Move internals\n+\tto...\n+\t(gcc::jit::playback::context::invoke_driver): New method.  Add\n+\t\"-shared\" and \"-c\" options to driver's argv as needed.\n+\t* jit-playback.h: Include \"timevar.h\".\n+\t(gcc::jit::playback::context::compile): Convert return type from\n+\tresult * to void.\n+\t(gcc::jit::playback::context::postprocess): New pure virtual\n+\tfunction, making this an abstract base class.\n+\t(gcc::jit::playback::context::get_tempdir): New accessor.\n+\t(gcc::jit::playback::context::invoke_driver): New function.\n+\t(class gcc::jit::playback::compile_to_memory): New subclass of\n+\tplayback::context.\n+\t(class gcc::jit::playback::compile_to_file): Likewise.\n+\t* jit-recording.c (gcc::jit::recording::context::compile): Use a\n+\tplayback::compile_to_memory, and extract its result.\n+\t(gcc::jit::recording::context::compile_to_file): New function.\n+\t* jit-recording.h (gcc::jit::recording::context::compile_to_file):\n+\tNew function.\n+\t* libgccjit++.h (gccjit::context::compile_to_file): New method.\n+\t* libgccjit.c (gcc_jit_context_compile): Update log message to\n+\tclarify that this is an in-memory compile.\n+\t(gcc_jit_context_compile_to_file): New function.\n+\t* libgccjit.h (gcc_jit_context): Clarify that you can compile\n+\ta context more than once, and that you can compile to a file\n+\tas well as to memory.\n+\t(gcc_jit_result): Clarify that this is the result of an\n+\tin-memory compilation.\n+\t(gcc_jit_context_compile): Clarify that you can compile, and that\n+\tthis is an in-memory compilation.\n+\t(enum gcc_jit_output_kind): New enum.\n+\t(gcc_jit_context_compile_to_file): New function.\n+\t(gcc_jit_context_enable_dump): Clarify comment to cover both forms\n+\tof compilation.\n+\t* libgccjit.map (gcc_jit_context_compile_to_file): New API\n+\tentrypoint.\n+\t* notes.txt: Update to show the playback::context::postprocess\n+\tvirtual function.\n+\n 2015-01-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-recording.c"}, {"sha": "83710ff159d9985eb63dc3b311ffb7bb721233bd", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 1504, "deletions": 466, "changes": 1970, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=fdce7209c23212b50f08604f242e9bbb5281818b"}, {"sha": "05917e8ff0c4a25801e96acff7d0164e52deffb3", "filename": "gcc/jit/docs/cp/topics/compilation.rst", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcompilation.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcompilation.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcompilation.rst?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,58 @@\n+.. Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Compiling a context\n+===================\n+\n+Once populated, a :class:`gccjit::context` can be compiled to\n+machine code, either in-memory via :func:`gccjit::context::compile` or\n+to disk via :func:`gccjit::context::compile_to_file`.\n+\n+You can compile a context multiple times (using either form of\n+compilation), although any errors that occur on the context will\n+prevent any future compilation of that context.\n+\n+In-memory compilation\n+*********************\n+\n+.. function:: gcc_jit_result *\\\n+              gccjit::context::compile ()\n+\n+   This calls into GCC and builds the code, returning a\n+   `gcc_jit_result *`.\n+\n+   This is a thin wrapper around the\n+   :c:func:`gcc_jit_context_compile` API entrypoint.\n+\n+Ahead-of-time compilation\n+*************************\n+\n+Although libgccjit is primarily aimed at just-in-time compilation, it\n+can also be used for implementing more traditional ahead-of-time\n+compilers, via the :func:`gccjit::context::compile_to_file` method.\n+\n+.. function:: void \\\n+              gccjit::context::compile_to_file (enum gcc_jit_output_kind,\\\n+                                                const char *output_path)\n+\n+   Compile the :class:`gccjit::context` to a file of the given\n+   kind.\n+\n+   This is a thin wrapper around the\n+   :c:func:`gcc_jit_context_compile_to_file` API entrypoint."}, {"sha": "4ebb623de0b13a7314cbcc3e9091eb766af4b8b1", "filename": "gcc/jit/docs/cp/topics/index.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -27,4 +27,4 @@ Topic Reference\n    expressions.rst\n    functions.rst\n    locations.rst\n-   results.rst\n+   compilation.rst"}, {"sha": "a48339a6fd7177216a30425f4049e51c221e86b2", "filename": "gcc/jit/docs/cp/topics/results.rst", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb22ab4164a2140fa7ec38cd929d464224d9c222/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fresults.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb22ab4164a2140fa7ec38cd929d464224d9c222/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fresults.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fresults.rst?ref=cb22ab4164a2140fa7ec38cd929d464224d9c222", "patch": "@@ -1,48 +0,0 @@\n-.. Copyright (C) 2014-2015 Free Software Foundation, Inc.\n-   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n-\n-   This is free software: you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation, either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see\n-   <http://www.gnu.org/licenses/>.\n-\n-.. default-domain:: cpp\n-\n-Compilation results\n-===================\n-\n-.. type:: gcc_jit_result\n-\n-  A `gcc_jit_result` encapsulates the result of compiling a context.\n-\n-.. function:: gcc_jit_result *\\\n-              gccjit::context::compile ()\n-\n-   This calls into GCC and builds the code, returning a\n-   `gcc_jit_result *`.\n-\n-\n-.. function:: void *\\\n-              gcc_jit_result_get_code (gcc_jit_result *result,\\\n-                                       const char *funcname)\n-\n-   Locate a given function within the built machine code.\n-   This will need to be cast to a function pointer of the\n-   correct type before it can be called.\n-\n-\n-.. function:: void\\\n-              gcc_jit_result_release (gcc_jit_result *result)\n-\n-   Once we're done with the code, this unloads the built .so file.\n-   This cleans up the result; after calling this, it's no longer\n-   valid to use the result."}, {"sha": "6863273ee8c76d3bbcdbbff6e576ff3db5b3bc10", "filename": "gcc/jit/docs/examples/emit-alphabet.bf", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fexamples%2Femit-alphabet.bf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fexamples%2Femit-alphabet.bf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Femit-alphabet.bf?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,17 @@\n+[\n+  Emit the uppercase alphabet\n+]\n+\n+cell 0 = 26\n+++++++++++++++++++++++++++\n+\n+cell 1 = 65\n+>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n+\n+while cell#0 != 0\n+[\n+ >\n+ .      emit cell#1\n+ +      increment cell@1\n+ <-     decrement cell@0\n+]"}, {"sha": "f948ede796a48dbae6e903c3b4b99cf2d5d4a103", "filename": "gcc/jit/docs/examples/tut05-bf.c", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut05-bf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut05-bf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut05-bf.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,446 @@\n+/* A compiler for the \"bf\" language.  */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+#include \"libgccjit.h\"\n+\n+/* Make \"main\" function:\n+     int\n+     main (int argc, char **argv)\n+     {\n+       ...\n+     }\n+*/\n+static gcc_jit_function *\n+make_main (gcc_jit_context *ctxt)\n+{\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_param *param_argc =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"argc\");\n+  gcc_jit_type *char_ptr_ptr_type =\n+    gcc_jit_type_get_pointer (\n+      gcc_jit_type_get_pointer (\n+\tgcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR)));\n+  gcc_jit_param *param_argv =\n+    gcc_jit_context_new_param (ctxt, NULL, char_ptr_ptr_type, \"argv\");\n+  gcc_jit_param *params[2] = {param_argc, param_argv};\n+  gcc_jit_function *func_main =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  int_type,\n+\t\t\t\t  \"main\",\n+\t\t\t\t  2, params,\n+\t\t\t\t  0);\n+  return func_main;\n+}\n+\n+#define MAX_OPEN_PARENS 16\n+\n+typedef struct bf_compiler\n+{\n+  const char *filename;\n+  int line;\n+  int column;\n+\n+  gcc_jit_context *ctxt;\n+\n+  gcc_jit_type *void_type;\n+  gcc_jit_type *int_type;\n+  gcc_jit_type *byte_type;\n+  gcc_jit_type *array_type;\n+\n+  gcc_jit_function *func_getchar;\n+  gcc_jit_function *func_putchar;\n+\n+  gcc_jit_function *func;\n+  gcc_jit_block *curblock;\n+\n+  gcc_jit_rvalue *int_zero;\n+  gcc_jit_rvalue *int_one;\n+  gcc_jit_rvalue *byte_zero;\n+  gcc_jit_rvalue *byte_one;\n+  gcc_jit_lvalue *data_cells;\n+  gcc_jit_lvalue *idx;\n+\n+  int num_open_parens;\n+  gcc_jit_block *paren_test[MAX_OPEN_PARENS];\n+  gcc_jit_block *paren_body[MAX_OPEN_PARENS];\n+  gcc_jit_block *paren_after[MAX_OPEN_PARENS];\n+\n+} bf_compiler;\n+\n+/* Bail out, with a message on stderr.  */\n+\n+static void\n+fatal_error (bf_compiler *bfc, const char *msg)\n+{\n+  fprintf (stderr,\n+\t   \"%s:%i:%i: %s\",\n+\t   bfc->filename, bfc->line, bfc->column, msg);\n+  abort ();\n+}\n+\n+/* Get \"data_cells[idx]\" as an lvalue.  */\n+\n+static gcc_jit_lvalue *\n+bf_get_current_data (bf_compiler *bfc, gcc_jit_location *loc)\n+{\n+  return gcc_jit_context_new_array_access (\n+    bfc->ctxt,\n+    loc,\n+    gcc_jit_lvalue_as_rvalue (bfc->data_cells),\n+    gcc_jit_lvalue_as_rvalue (bfc->idx));\n+}\n+\n+/* Get \"data_cells[idx] == 0\" as a boolean rvalue.  */\n+\n+static gcc_jit_rvalue *\n+bf_current_data_is_zero (bf_compiler *bfc, gcc_jit_location *loc)\n+{\n+  return gcc_jit_context_new_comparison (\n+    bfc->ctxt,\n+    loc,\n+    GCC_JIT_COMPARISON_EQ,\n+    gcc_jit_lvalue_as_rvalue (bf_get_current_data (bfc, loc)),\n+    bfc->byte_zero);\n+}\n+\n+/* Compile one bf character.  */\n+\n+static void\n+bf_compile_char (bf_compiler *bfc,\n+\t\t unsigned char ch)\n+{\n+  gcc_jit_location *loc =\n+    gcc_jit_context_new_location (bfc->ctxt,\n+\t\t\t\t  bfc->filename,\n+\t\t\t\t  bfc->line,\n+\t\t\t\t  bfc->column);\n+\n+  /* Turn this on to trace execution, by injecting putchar ()\n+     of each source char. */\n+  if (0)\n+    {\n+      gcc_jit_rvalue *arg =\n+\tgcc_jit_context_new_rvalue_from_int (\n+\t\t\t\t\t     bfc->ctxt,\n+\t\t\t\t\t     bfc->int_type,\n+\t\t\t\t\t     ch);\n+      gcc_jit_rvalue *call =\n+\tgcc_jit_context_new_call (bfc->ctxt,\n+\t\t\t\t  loc,\n+\t\t\t\t  bfc->func_putchar,\n+\t\t\t\t  1, &arg);\n+      gcc_jit_block_add_eval (bfc->curblock,\n+\t\t\t      loc,\n+\t\t\t      call);\n+    }\n+\n+  switch (ch)\n+    {\n+      case '>':\n+\tgcc_jit_block_add_comment (bfc->curblock,\n+\t\t\t\t   loc,\n+\t\t\t\t   \"'>': idx += 1;\");\n+\tgcc_jit_block_add_assignment_op (bfc->curblock,\n+\t\t\t\t\t loc,\n+\t\t\t\t\t bfc->idx,\n+\t\t\t\t\t GCC_JIT_BINARY_OP_PLUS,\n+\t\t\t\t\t bfc->int_one);\n+\tbreak;\n+\n+      case '<':\n+\tgcc_jit_block_add_comment (bfc->curblock,\n+\t\t\t\t   loc,\n+\t\t\t\t   \"'<': idx -= 1;\");\n+\tgcc_jit_block_add_assignment_op (bfc->curblock,\n+\t\t\t\t\t loc,\n+\t\t\t\t\t bfc->idx,\n+\t\t\t\t\t GCC_JIT_BINARY_OP_MINUS,\n+\t\t\t\t\t bfc->int_one);\n+\tbreak;\n+\n+      case '+':\n+\tgcc_jit_block_add_comment (bfc->curblock,\n+\t\t\t\t   loc,\n+\t\t\t\t   \"'+': data[idx] += 1;\");\n+\tgcc_jit_block_add_assignment_op (bfc->curblock,\n+\t\t\t\t\t loc,\n+\t\t\t\t\t bf_get_current_data (bfc, loc),\n+\t\t\t\t\t GCC_JIT_BINARY_OP_PLUS,\n+\t\t\t\t\t bfc->byte_one);\n+\tbreak;\n+\n+      case '-':\n+\tgcc_jit_block_add_comment (bfc->curblock,\n+\t\t\t\t   loc,\n+\t\t\t\t   \"'-': data[idx] -= 1;\");\n+\tgcc_jit_block_add_assignment_op (bfc->curblock,\n+\t\t\t\t\t loc,\n+\t\t\t\t\t bf_get_current_data (bfc, loc),\n+\t\t\t\t\t GCC_JIT_BINARY_OP_MINUS,\n+\t\t\t\t\t bfc->byte_one);\n+\tbreak;\n+\n+      case '.':\n+\t{\n+\t  gcc_jit_rvalue *arg =\n+\t    gcc_jit_context_new_cast (\n+\t      bfc->ctxt,\n+\t      loc,\n+\t      gcc_jit_lvalue_as_rvalue (bf_get_current_data (bfc, loc)),\n+\t      bfc->int_type);\n+\t  gcc_jit_rvalue *call =\n+\t    gcc_jit_context_new_call (bfc->ctxt,\n+\t\t\t\t      loc,\n+\t\t\t\t      bfc->func_putchar,\n+\t\t\t\t      1, &arg);\n+\t  gcc_jit_block_add_comment (bfc->curblock,\n+\t\t\t\t     loc,\n+\t\t\t\t     \"'.': putchar ((int)data[idx]);\");\n+\t  gcc_jit_block_add_eval (bfc->curblock,\n+\t\t\t\t  loc,\n+\t\t\t\t  call);\n+\t}\n+\tbreak;\n+\n+      case ',':\n+\t{\n+\t  gcc_jit_rvalue *call =\n+\t    gcc_jit_context_new_call (bfc->ctxt,\n+\t\t\t\t      loc,\n+\t\t\t\t      bfc->func_getchar,\n+\t\t\t\t      0, NULL);\n+\t  gcc_jit_block_add_comment (\n+\t    bfc->curblock,\n+\t    loc,\n+\t    \"',': data[idx] = (unsigned char)getchar ();\");\n+\t  gcc_jit_block_add_assignment (bfc->curblock,\n+\t\t\t\t\tloc,\n+\t\t\t\t\tbf_get_current_data (bfc, loc),\n+\t\t\t\t\tgcc_jit_context_new_cast (\n+\t\t\t\t\t  bfc->ctxt,\n+\t\t\t\t\t  loc,\n+\t\t\t\t\t  call,\n+\t\t\t\t\t  bfc->byte_type));\n+\t}\n+\tbreak;\n+\n+      case '[':\n+\t{\n+\t  gcc_jit_block *loop_test =\n+\t    gcc_jit_function_new_block (bfc->func, NULL);\n+\t  gcc_jit_block *on_zero =\n+\t    gcc_jit_function_new_block (bfc->func, NULL);\n+\t  gcc_jit_block *on_non_zero =\n+\t    gcc_jit_function_new_block (bfc->func, NULL);\n+\n+\t  if (bfc->num_open_parens == MAX_OPEN_PARENS)\n+\t    fatal_error (bfc, \"too many open parens\");\n+\n+\t  gcc_jit_block_end_with_jump (\n+\t    bfc->curblock,\n+\t    loc,\n+\t    loop_test);\n+\n+\t  gcc_jit_block_add_comment (\n+\t    loop_test,\n+\t    loc,\n+\t    \"'['\");\n+\t  gcc_jit_block_end_with_conditional (\n+\t    loop_test,\n+\t    loc,\n+\t    bf_current_data_is_zero (bfc, loc),\n+\t    on_zero,\n+\t    on_non_zero);\n+\t  bfc->paren_test[bfc->num_open_parens] = loop_test;\n+\t  bfc->paren_body[bfc->num_open_parens] = on_non_zero;\n+\t  bfc->paren_after[bfc->num_open_parens] = on_zero;\n+\t  bfc->num_open_parens += 1;\n+\t  bfc->curblock = on_non_zero;\n+\t}\n+\tbreak;\n+\n+      case ']':\n+\t{\n+\t  gcc_jit_block_add_comment (\n+\t    bfc->curblock,\n+\t    loc,\n+\t    \"']'\");\n+\n+\t  if (bfc->num_open_parens == 0)\n+\t    fatal_error (bfc, \"mismatching parens\");\n+\t  bfc->num_open_parens -= 1;\n+\t  gcc_jit_block_end_with_jump (\n+\t    bfc->curblock,\n+\t    loc,\n+\t    bfc->paren_test[bfc->num_open_parens]);\n+\t  bfc->curblock = bfc->paren_after[bfc->num_open_parens];\n+\t}\n+\tbreak;\n+\n+    case '\\n':\n+      bfc->line +=1;\n+      bfc->column = 0;\n+      break;\n+    }\n+\n+  if (ch != '\\n')\n+    bfc->column += 1;\n+}\n+\n+/* Compile the given .bf file into a gcc_jit_context, containing a\n+   single \"main\" function suitable for compiling into an executable.  */\n+\n+gcc_jit_context *\n+bf_compile (const char *filename)\n+{\n+  bf_compiler bfc;\n+  FILE *f_in;\n+  int ch;\n+\n+  memset (&bfc, 0, sizeof (bfc));\n+\n+  bfc.filename = filename;\n+  f_in = fopen (filename, \"r\");\n+  if (!f_in)\n+    fatal_error (&bfc, \"unable to open file\");\n+  bfc.line = 1;\n+\n+  bfc.ctxt = gcc_jit_context_acquire ();\n+\n+  gcc_jit_context_set_int_option (\n+    bfc.ctxt,\n+    GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+    3);\n+  gcc_jit_context_set_bool_option (\n+    bfc.ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+    0);\n+  gcc_jit_context_set_bool_option (\n+    bfc.ctxt,\n+    GCC_JIT_BOOL_OPTION_DEBUGINFO,\n+    1);\n+  gcc_jit_context_set_bool_option (\n+    bfc.ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING,\n+    0);\n+  gcc_jit_context_set_bool_option (\n+    bfc.ctxt,\n+    GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES,\n+    0);\n+\n+  bfc.void_type =\n+    gcc_jit_context_get_type (bfc.ctxt, GCC_JIT_TYPE_VOID);\n+  bfc.int_type =\n+    gcc_jit_context_get_type (bfc.ctxt, GCC_JIT_TYPE_INT);\n+  bfc.byte_type =\n+    gcc_jit_context_get_type (bfc.ctxt, GCC_JIT_TYPE_UNSIGNED_CHAR);\n+  bfc.array_type =\n+    gcc_jit_context_new_array_type (bfc.ctxt,\n+\t\t\t\t    NULL,\n+\t\t\t\t    bfc.byte_type,\n+\t\t\t\t    30000);\n+\n+  bfc.func_getchar =\n+    gcc_jit_context_new_function (bfc.ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  bfc.int_type,\n+\t\t\t\t  \"getchar\",\n+\t\t\t\t  0, NULL,\n+\t\t\t\t  0);\n+\n+  gcc_jit_param *param_c =\n+    gcc_jit_context_new_param (bfc.ctxt, NULL, bfc.int_type, \"c\");\n+  bfc.func_putchar =\n+    gcc_jit_context_new_function (bfc.ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  bfc.void_type,\n+\t\t\t\t  \"putchar\",\n+\t\t\t\t  1, &param_c,\n+\t\t\t\t  0);\n+\n+  bfc.func = make_main (bfc.ctxt);\n+   bfc.curblock =\n+    gcc_jit_function_new_block (bfc.func, \"initial\");\n+  bfc.int_zero = gcc_jit_context_zero (bfc.ctxt, bfc.int_type);\n+  bfc.int_one = gcc_jit_context_one (bfc.ctxt, bfc.int_type);\n+  bfc.byte_zero = gcc_jit_context_zero (bfc.ctxt, bfc.byte_type);\n+  bfc.byte_one = gcc_jit_context_one (bfc.ctxt, bfc.byte_type);\n+\n+  bfc.data_cells =\n+    gcc_jit_context_new_global (bfc.ctxt, NULL,\n+\t\t\t\t GCC_JIT_GLOBAL_INTERNAL,\n+\t\t\t\t bfc.array_type,\n+\t\t\t\t \"data_cells\");\n+  bfc.idx =\n+    gcc_jit_function_new_local (bfc.func, NULL,\n+\t\t\t\tbfc.int_type,\n+\t\t\t\t\"idx\");\n+\n+  gcc_jit_block_add_comment (bfc.curblock,\n+\t\t\t     NULL,\n+\t\t\t     \"idx = 0;\");\n+  gcc_jit_block_add_assignment (bfc.curblock,\n+\t\t\t\tNULL,\n+\t\t\t\tbfc.idx,\n+\t\t\t\tbfc.int_zero);\n+\n+  bfc.num_open_parens = 0;\n+\n+  while ( EOF != (ch = fgetc (f_in)))\n+    bf_compile_char (&bfc, (unsigned char)ch);\n+\n+  gcc_jit_block_end_with_return (bfc.curblock, NULL, bfc.int_zero);\n+\n+  fclose (f_in);\n+\n+  return bfc.ctxt;\n+}\n+\n+/* Entrypoint to the compiler.  */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  const char *input_file;\n+  const char *output_file;\n+  gcc_jit_context *ctxt;\n+  const char *err;\n+\n+  if (argc != 3)\n+    {\n+      fprintf (stderr, \"%s: INPUT_FILE OUTPUT_FILE\\n\", argv[0]);\n+      return 1;\n+    }\n+\n+  input_file = argv[1];\n+  output_file = argv[2];\n+  ctxt = bf_compile (input_file);\n+\n+  gcc_jit_context_compile_to_file (ctxt,\n+\t\t\t\t   GCC_JIT_OUTPUT_KIND_EXECUTABLE,\n+\t\t\t\t   output_file);\n+\n+  err = gcc_jit_context_get_first_error (ctxt);\n+\n+  if (err)\n+    {\n+      gcc_jit_context_release (ctxt);\n+      return 1;\n+    }\n+\n+  gcc_jit_context_release (ctxt);\n+  return 0;\n+}\n+\n+/* Use the built compiler to compile the example to an executable:\n+\n+     { dg-jit-set-exe-params SRCDIR/gcc/jit/docs/examples/emit-alphabet.bf emit-alphabet.bf.exe }\n+\n+   Then run the executable, and verify that it emits the alphabet:\n+\n+     { dg-final { jit-run-executable emit-alphabet.bf.exe \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" } } */"}, {"sha": "205b6b47558d7d909cc3079a5f87acebf3067ff8", "filename": "gcc/jit/docs/internals/test-hello-world.exe.log.txt", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -38,14 +38,20 @@ JIT: entering: gcc_jit_block_add_eval\n JIT: exiting: gcc_jit_block_add_eval\n JIT: entering: gcc_jit_block_end_with_void_return\n JIT: exiting: gcc_jit_block_end_with_void_return\n+JIT: entering: gcc_jit_context_dump_reproducer_to_file\n+JIT:  entering: void gcc::jit::recording::context::dump_reproducer_to_file(const char*)\n+JIT:  exiting: void gcc::jit::recording::context::dump_reproducer_to_file(const char*)\n+JIT: exiting: gcc_jit_context_dump_reproducer_to_file\n JIT: entering: gcc_jit_context_compile\n-JIT:  compiling ctxt: 0x1283e20\n+JIT:  in-memory compile of ctxt: 0x1283e20\n JIT:  entering: gcc::jit::result* gcc::jit::recording::context::compile()\n JIT:   entering: void gcc::jit::recording::context::validate()\n JIT:   exiting: void gcc::jit::recording::context::validate()\n JIT:   entering: gcc::jit::playback::context::context(gcc::jit::recording::context*)\n JIT:   exiting: gcc::jit::playback::context::context(gcc::jit::recording::context*)\n-JIT:   entering: gcc::jit::result* gcc::jit::playback::context::compile()\n+JIT:   entering: gcc::jit::playback::compile_to_memory::compile_to_memory(gcc::jit::recording::context*)\n+JIT:   exiting: gcc::jit::playback::compile_to_memory::compile_to_memory(gcc::jit::recording::context*)\n+JIT:   entering: void gcc::jit::playback::context::compile()\n JIT:    entering: gcc::jit::tempdir::tempdir(gcc::jit::logger*, int)\n JIT:    exiting: gcc::jit::tempdir::tempdir(gcc::jit::logger*, int)\n JIT:    entering: bool gcc::jit::tempdir::create()\n@@ -86,29 +92,37 @@ JIT:      entering: void gcc::jit::playback::function::postprocess()\n JIT:      exiting: void gcc::jit::playback::function::postprocess()\n JIT:     exiting: void gcc::jit::playback::context::replay()\n JIT:     entering: void jit_langhook_write_globals()\n+JIT:      entering: void gcc::jit::playback::context::write_global_decls_1()\n+JIT:      exiting: void gcc::jit::playback::context::write_global_decls_1()\n+JIT:      entering: void gcc::jit::playback::context::write_global_decls_2()\n+JIT:      exiting: void gcc::jit::playback::context::write_global_decls_2()\n JIT:     exiting: void jit_langhook_write_globals()\n JIT:    exiting: toplev::main\n JIT:    entering: void gcc::jit::playback::context::extract_any_requested_dumps(vec<gcc::jit::recording::requested_dump>*)\n JIT:    exiting: void gcc::jit::playback::context::extract_any_requested_dumps(vec<gcc::jit::recording::requested_dump>*)\n JIT:    entering: toplev::finalize\n JIT:    exiting: toplev::finalize\n-JIT:    entering: void gcc::jit::playback::context::convert_to_dso(const char*)\n-JIT:     argv[0]: x86_64-unknown-linux-gnu-gcc-5.0.0\n-JIT:     argv[1]: -shared\n-JIT:     argv[2]: /tmp/libgccjit-CKq1M9/fake.s\n-JIT:     argv[3]: -o\n-JIT:     argv[4]: /tmp/libgccjit-CKq1M9/fake.so\n-JIT:     argv[5]: -fno-use-linker-plugin\n-JIT:     argv[6]: (null)\n-JIT:    exiting: void gcc::jit::playback::context::convert_to_dso(const char*)\n-JIT:    entering: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\n-JIT:     GCC_JIT_BOOL_OPTION_DEBUGINFO was set: handing over tempdir to jit::result\n-JIT:     entering: gcc::jit::result::result(gcc::jit::logger*, void*, gcc::jit::tempdir*)\n-JIT:     exiting: gcc::jit::result::result(gcc::jit::logger*, void*, gcc::jit::tempdir*)\n-JIT:    exiting: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\n+JIT:    entering: virtual void gcc::jit::playback::compile_to_memory::postprocess(const char*)\n+JIT:     entering: void gcc::jit::playback::context::convert_to_dso(const char*)\n+JIT:      entering: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)\n+JIT:       argv[0]: x86_64-unknown-linux-gnu-gcc-5.0.0\n+JIT:       argv[1]: -shared\n+JIT:       argv[2]: /tmp/libgccjit-CKq1M9/fake.s\n+JIT:       argv[3]: -o\n+JIT:       argv[4]: /tmp/libgccjit-CKq1M9/fake.so\n+JIT:       argv[5]: -fno-use-linker-plugin\n+JIT:       argv[6]: (null)\n+JIT:      exiting: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)\n+JIT:     exiting: void gcc::jit::playback::context::convert_to_dso(const char*)\n+JIT:     entering: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\n+JIT:      GCC_JIT_BOOL_OPTION_DEBUGINFO was set: handing over tempdir to jit::result\n+JIT:      entering: gcc::jit::result::result(gcc::jit::logger*, void*, gcc::jit::tempdir*)\n+JIT:      exiting: gcc::jit::result::result(gcc::jit::logger*, void*, gcc::jit::tempdir*)\n+JIT:     exiting: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\n+JIT:    exiting: virtual void gcc::jit::playback::compile_to_memory::postprocess(const char*)\n JIT:    entering: void gcc::jit::playback::context::release_mutex()\n JIT:    exiting: void gcc::jit::playback::context::release_mutex()\n-JIT:   exiting: gcc::jit::result* gcc::jit::playback::context::compile()\n+JIT:   exiting: void gcc::jit::playback::context::compile()\n JIT:   entering: gcc::jit::playback::context::~context()\n JIT:   exiting: gcc::jit::playback::context::~context()\n JIT:  exiting: gcc::jit::result* gcc::jit::recording::context::compile()"}, {"sha": "0f5177797caec07d332e7f516ce92c1ec110a2ca", "filename": "gcc/jit/docs/intro/index.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fintro%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fintro%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Findex.rst?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -25,3 +25,4 @@ Tutorial\n    tutorial02.rst\n    tutorial03.rst\n    tutorial04.rst\n+   tutorial05.rst"}, {"sha": "0de21a20abbde01213da91914f63d91505ec318a", "filename": "gcc/jit/docs/intro/tutorial05.rst", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial05.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial05.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial05.rst?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,256 @@\n+.. Copyright (C) 2015 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Tutorial part 5: Implementing an Ahead-of-Time compiler\n+-------------------------------------------------------\n+\n+If you have a pre-existing language frontend that's compatible with\n+libgccjit's license, it's possible to hook it up to libgccjit as a\n+backend.  In the previous example we showed\n+how to do that for in-memory JIT-compilation, but libgccjit can also\n+compile code directly to a file, allowing you to implement a more\n+traditional ahead-of-time compiler (\"JIT\" is something of a misnomer\n+for this use-case).\n+\n+The essential difference is to compile the context using\n+:c:func:`gcc_jit_context_compile_to_file` rather than\n+:c:func:`gcc_jit_context_compile`.\n+\n+The \"brainf\" language\n+*********************\n+\n+In this example we use libgccjit to construct an ahead-of-time compiler\n+for an esoteric programming language that we shall refer to as \"brainf\".\n+\n+brainf scripts operate on an array of bytes, with a notional data pointer\n+within the array.\n+\n+brainf is hard for humans to read, but it's trivial to write a parser for\n+it, as there is no lexing; just a stream of bytes.  The operations are:\n+\n+====================== =============================\n+Character              Meaning\n+====================== =============================\n+``>``                  ``idx += 1``\n+``<``                  ``idx -= 1``\n+``+``                  ``data[idx] += 1``\n+``-``                  ``data[idx] -= 1``\n+``.``                  ``output (data[idx])``\n+``,``                  ``data[idx] = input ()``\n+``[``                  loop until ``data[idx] == 0``\n+``]``                  end of loop\n+Anything else          ignored\n+====================== =============================\n+\n+Unlike the previous example, we'll implement an ahead-of-time compiler,\n+which reads ``.bf`` scripts and outputs executables (though it would\n+be trivial to have it run them JIT-compiled in-process).\n+\n+Here's what a simple ``.bf`` script looks like:\n+\n+   .. literalinclude:: ../examples/emit-alphabet.bf\n+    :lines: 1-\n+\n+.. note::\n+\n+   This example makes use of whitespace and comments for legibility, but\n+   could have been written as::\n+\n+     ++++++++++++++++++++++++++\n+     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n+     [>.+<-]\n+\n+   It's not a particularly useful language, except for providing\n+   compiler-writers with a test case that's easy to parse.  The point\n+   is that you can use :c:func:`gcc_jit_context_compile_to_file`\n+   to use libgccjit as a backend for a pre-existing language frontend\n+   (provided that the pre-existing frontend is compatible with libgccjit's\n+   license).\n+\n+Converting a brainf script to libgccjit IR\n+******************************************\n+\n+As before we write simple code to populate a :c:type:`gcc_jit_context *`.\n+\n+   .. literalinclude:: ../examples/tut05-bf.c\n+    :start-after: #define MAX_OPEN_PARENS 16\n+    :end-before: /* Entrypoint to the compiler.  */\n+    :language: c\n+\n+Compiling a context to a file\n+*****************************\n+\n+Unlike the previous tutorial, this time we'll compile the context\n+directly to an executable, using :c:func:`gcc_jit_context_compile_to_file`:\n+\n+.. code-block:: c\n+\n+    gcc_jit_context_compile_to_file (ctxt,\n+                                     GCC_JIT_OUTPUT_KIND_EXECUTABLE,\n+                                     output_file);\n+\n+Here's the top-level of the compiler, which is what actually calls into\n+:c:func:`gcc_jit_context_compile_to_file`:\n+\n+ .. literalinclude:: ../examples/tut05-bf.c\n+    :start-after: /* Entrypoint to the compiler.  */\n+    :end-before: /* Use the built compiler to compile the example to an executable:\n+    :language: c\n+\n+Note how once the context is populated you could trivially instead compile\n+it to memory using :c:func:`gcc_jit_context_compile` and run it in-process\n+as in the previous tutorial.\n+\n+To create an executable, we need to export a ``main`` function.  Here's\n+how to create one from the JIT API:\n+\n+ .. literalinclude:: ../examples/tut05-bf.c\n+    :start-after: #include \"libgccjit.h\"\n+    :end-before: #define MAX_OPEN_PARENS 16\n+    :language: c\n+\n+.. note::\n+\n+   The above implementation ignores ``argc`` and ``argv``, but you could\n+   make use of them by exposing ``param_argc`` and ``param_argv`` to the\n+   caller.\n+\n+Upon compiling this C code, we obtain a bf-to-machine-code compiler;\n+let's call it ``bfc``:\n+\n+.. code-block:: console\n+\n+  $ gcc \\\n+      tut05-bf.c \\\n+      -o bfc \\\n+      -lgccjit\n+\n+We can now use ``bfc`` to compile .bf files into machine code executables:\n+\n+.. code-block:: console\n+\n+  $ ./bfc \\\n+       emit-alphabet.bf \\\n+       a.out\n+\n+which we can run directly:\n+\n+.. code-block:: console\n+\n+  $ ./a.out\n+  ABCDEFGHIJKLMNOPQRSTUVWXYZ\n+\n+Success!\n+\n+We can also inspect the generated executable using standard tools:\n+\n+.. code-block:: console\n+\n+  $ objdump -d a.out |less\n+\n+which shows that libgccjit has managed to optimize the function\n+somewhat (for example, the runs of 26 and 65 increment operations\n+have become integer constants 0x1a and 0x41):\n+\n+.. code-block:: console\n+\n+  0000000000400620 <main>:\n+    400620:     80 3d 39 0a 20 00 00    cmpb   $0x0,0x200a39(%rip)        # 601060 <data\n+    400627:     74 07                   je     400630 <main\n+    400629:     eb fe                   jmp    400629 <main+0x9>\n+    40062b:     0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)\n+    400630:     48 83 ec 08             sub    $0x8,%rsp\n+    400634:     0f b6 05 26 0a 20 00    movzbl 0x200a26(%rip),%eax        # 601061 <data_cells+0x1>\n+    40063b:     c6 05 1e 0a 20 00 1a    movb   $0x1a,0x200a1e(%rip)       # 601060 <data_cells>\n+    400642:     8d 78 41                lea    0x41(%rax),%edi\n+    400645:     40 88 3d 15 0a 20 00    mov    %dil,0x200a15(%rip)        # 601061 <data_cells+0x1>\n+    40064c:     0f 1f 40 00             nopl   0x0(%rax)\n+    400650:     40 0f b6 ff             movzbl %dil,%edi\n+    400654:     e8 87 fe ff ff          callq  4004e0 <putchar@plt>\n+    400659:     0f b6 05 01 0a 20 00    movzbl 0x200a01(%rip),%eax        # 601061 <data_cells+0x1>\n+    400660:     80 2d f9 09 20 00 01    subb   $0x1,0x2009f9(%rip)        # 601060 <data_cells>\n+    400667:     8d 78 01                lea    0x1(%rax),%edi\n+    40066a:     40 88 3d f0 09 20 00    mov    %dil,0x2009f0(%rip)        # 601061 <data_cells+0x1>\n+    400671:     75 dd                   jne    400650 <main+0x30>\n+    400673:     31 c0                   xor    %eax,%eax\n+    400675:     48 83 c4 08             add    $0x8,%rsp\n+    400679:     c3                      retq\n+    40067a:     66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)\n+\n+We also set up debugging information (via\n+:c:func:`gcc_jit_context_new_location` and\n+:c:macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO`), so it's possible to use ``gdb``\n+to singlestep through the generated binary and inspect the internal\n+state ``idx`` and ``data_cells``:\n+\n+.. code-block:: console\n+\n+  (gdb) break main\n+  Breakpoint 1 at 0x400790\n+  (gdb) run\n+  Starting program: a.out\n+\n+  Breakpoint 1, 0x0000000000400790 in main (argc=1, argv=0x7fffffffe448)\n+  (gdb) stepi\n+  0x0000000000400797 in main (argc=1, argv=0x7fffffffe448)\n+  (gdb) stepi\n+  0x00000000004007a0 in main (argc=1, argv=0x7fffffffe448)\n+  (gdb) stepi\n+  9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n+  (gdb) list\n+  4\n+  5     cell 0 = 26\n+  6     ++++++++++++++++++++++++++\n+  7\n+  8     cell 1 = 65\n+  9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n+  10\n+  11    while cell#0 != 0\n+  12    [\n+  13     >\n+  (gdb) n\n+  6     ++++++++++++++++++++++++++\n+  (gdb) n\n+  9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n+  (gdb) p idx\n+  $1 = 1\n+  (gdb) p data_cells\n+  $2 = \"\\032\", '\\000' <repeats 29998 times>\n+  (gdb) p data_cells[0]\n+  $3 = 26 '\\032'\n+  (gdb) p data_cells[1]\n+  $4 = 0 '\\000'\n+  (gdb) list\n+  4\n+  5     cell 0 = 26\n+  6     ++++++++++++++++++++++++++\n+  7\n+  8     cell 1 = 65\n+  9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n+  10\n+  11    while cell#0 != 0\n+  12    [\n+  13     >\n+\n+\n+Other forms of ahead-of-time-compilation\n+****************************************\n+\n+The above demonstrates compiling a :c:type:`gcc_jit_context *` directly\n+to an executable.  It's also possible to compile it to an object file,\n+and to a dynamic library.  See the documentation of\n+:c:func:`gcc_jit_context_compile_to_file` for more information."}, {"sha": "bf59cc25a934eced57042dcd3aeda4916e0289d1", "filename": "gcc/jit/docs/topics/compilation.rst", "status": "renamed", "additions": 77, "deletions": 5, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompilation.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompilation.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompilation.rst?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -17,14 +17,19 @@\n \n .. default-domain:: c\n \n-Compilation results\n+Compiling a context\n ===================\n \n-.. type:: gcc_jit_result\n+Once populated, a :c:type:`gcc_jit_context *` can be compiled to\n+machine code, either in-memory via :c:func:`gcc_jit_context_compile` or\n+to disk via :c:func:`gcc_jit_context_compile_to_file`.\n+\n+You can compile a context multiple times (using either form of\n+compilation), although any errors that occur on the context will\n+prevent any future compilation of that context.\n \n-  A `gcc_jit_result` encapsulates the result of compiling a context,\n-  and the lifetimes of any machine code functions or globals that are\n-  within it.\n+In-memory compilation\n+*********************\n \n .. function:: gcc_jit_result *\\\n               gcc_jit_context_compile (gcc_jit_context *ctxt)\n@@ -36,6 +41,12 @@ Compilation results\n    calling :func:`gcc_jit_result_release` on it once they're done\n    with it.\n \n+.. type:: gcc_jit_result\n+\n+  A `gcc_jit_result` encapsulates the result of compiling a context\n+  in-memory, and the lifetimes of any machine code functions or globals\n+  that are within the resuilt.\n+\n .. function:: void *\\\n               gcc_jit_result_get_code (gcc_jit_result *result,\\\n                                        const char *funcname)\n@@ -125,3 +136,64 @@ Compilation results\n    valid to use the result, or any code or globals that were obtained\n    by calling :func:`gcc_jit_result_get_code` or\n    :func:`gcc_jit_result_get_global` on it.\n+\n+\n+Ahead-of-time compilation\n+*************************\n+\n+Although libgccjit is primarily aimed at just-in-time compilation, it\n+can also be used for implementing more traditional ahead-of-time\n+compilers, via the :c:func:`gcc_jit_context_compile_to_file`\n+API entrypoint.\n+\n+.. function:: void \\\n+              gcc_jit_context_compile_to_file (gcc_jit_context *ctxt, \\\n+                                               enum gcc_jit_output_kind output_kind,\\\n+                                               const char *output_path)\n+\n+   Compile the :c:type:`gcc_jit_context *` to a file of the given\n+   kind.\n+\n+:c:func:`gcc_jit_context_compile_to_file` ignores the suffix of\n+``output_path``, and insteads uses the given\n+:c:type:`enum gcc_jit_output_kind` to decide what to do.\n+\n+.. note::\n+\n+   This is different from the ``gcc`` program, which does make use of the\n+   suffix of the output file when determining what to do.\n+\n+.. type:: enum gcc_jit_output_kind\n+\n+The available kinds of output are:\n+\n+==============================================  ==============\n+Output kind                                     Typical suffix\n+==============================================  ==============\n+:c:macro:`GCC_JIT_OUTPUT_KIND_ASSEMBLER`        .s\n+:c:macro:`GCC_JIT_OUTPUT_KIND_OBJECT_FILE`      .o\n+:c:macro:`GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY`  .so or .dll\n+:c:macro:`GCC_JIT_OUTPUT_KIND_EXECUTABLE`       None, or .exe\n+==============================================  ==============\n+\n+.. c:macro:: GCC_JIT_OUTPUT_KIND_ASSEMBLER\n+\n+   Compile the context to an assembler file.\n+\n+.. c:macro:: GCC_JIT_OUTPUT_KIND_OBJECT_FILE\n+\n+   Compile the context to an object file.\n+\n+.. c:macro:: GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY\n+\n+   Compile the context to a dynamic library.\n+\n+   There is currently no support for specifying other libraries to link\n+   against.\n+\n+.. c:macro:: GCC_JIT_OUTPUT_KIND_EXECUTABLE\n+\n+   Compile the context to an executable.\n+\n+   There is currently no support for specifying libraries to link\n+   against.", "previous_filename": "gcc/jit/docs/topics/results.rst"}, {"sha": "4ebb623de0b13a7314cbcc3e9091eb766af4b8b1", "filename": "gcc/jit/docs/topics/index.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -27,4 +27,4 @@ Topic Reference\n    expressions.rst\n    functions.rst\n    locations.rst\n-   results.rst\n+   compilation.rst"}, {"sha": "b4f20738ae59ae7b04c2d05f123de40702917cf8", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 288, "deletions": 20, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -1668,26 +1668,37 @@ auto_argvec::~auto_argvec ()\n \n    - Use the context's options to cconstruct command-line options, and\n      call into the rest of GCC (toplev::main).\n-   - Assuming it succeeds, we have a .s file; we want a .so file.\n-     Invoke another gcc to convert the .s file to a .so file.\n-   - dlopen the .so file\n-   - Wrap the result up as a playback::result and return it.  */\n+   - Assuming it succeeds, we have a .s file.\n+   - We then run the \"postprocess\" vfunc:\n \n-result *\n+     (A) In-memory compile (\"gcc_jit_context_compile\")\n+\n+       For an in-memory compile we have the playback::compile_to_memory\n+       subclass; \"postprocess\" will convert the .s file to a .so DSO,\n+       and load it in memory (via dlopen), wrapping the result up as\n+       a jit::result and returning it.\n+\n+     (B) Compile to file (\"gcc_jit_context_compile_to_file\")\n+\n+       When compiling to a file, we have the playback::compile_to_file\n+       subclass; \"postprocess\" will either copy the .s file to the\n+       destination (for GCC_JIT_OUTPUT_KIND_ASSEMBLER), or invoke\n+       the driver to convert it as necessary, copying the result.  */\n+\n+void\n playback::context::\n compile ()\n {\n   JIT_LOG_SCOPE (get_logger ());\n \n   const char *ctxt_progname;\n-  result *result_obj = NULL;\n \n   int keep_intermediates =\n     get_bool_option (GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES);\n \n   m_tempdir = new tempdir (get_logger (), keep_intermediates);\n   if (!m_tempdir->create ())\n-    return NULL;\n+    return;\n \n   /* Call into the rest of gcc.\n      For now, we have to assemble command-line options to pass into\n@@ -1706,7 +1717,7 @@ compile ()\n   auto_argvec fake_args;\n   make_fake_args (&fake_args, ctxt_progname, &requested_dumps);\n   if (errors_occurred ())\n-    return NULL;\n+    return;\n \n   /* Acquire the JIT mutex and set \"this\" as the active playback ctxt.  */\n   acquire_mutex ();\n@@ -1737,24 +1748,258 @@ compile ()\n   if (errors_occurred ())\n     {\n       release_mutex ();\n-      return NULL;\n+      return;\n     }\n \n   if (get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE))\n     dump_generated_code ();\n \n+  /* We now have a .s file.\n+\n+     Run any postprocessing steps.  This will either convert the .s file to\n+     a .so DSO, and load it in memory (playback::compile_to_memory), or\n+     convert the .s file to the requested output format, and copy it to a\n+     given file (playback::compile_to_file).  */\n+  postprocess (ctxt_progname);\n+\n+  release_mutex ();\n+}\n+\n+/* Implementation of class gcc::jit::playback::compile_to_memory,\n+   a subclass of gcc::jit::playback::context.  */\n+\n+/*  playback::compile_to_memory's trivial constructor. */\n+\n+playback::compile_to_memory::compile_to_memory (recording::context *ctxt) :\n+  playback::context (ctxt),\n+  m_result (NULL)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+}\n+\n+/*  Implementation of the playback::context::process vfunc for compiling\n+    to memory.\n+\n+    Convert the .s file to a .so DSO, and load it in memory (via dlopen),\n+    wrapping the result up as a jit::result and returning it.  */\n+\n+void\n+playback::compile_to_memory::postprocess (const char *ctxt_progname)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n   convert_to_dso (ctxt_progname);\n   if (errors_occurred ())\n+    return;\n+  m_result = dlopen_built_dso ();\n+}\n+\n+/* Implementation of class gcc::jit::playback::compile_to_file,\n+   a subclass of gcc::jit::playback::context.  */\n+\n+/*  playback::compile_to_file's trivial constructor. */\n+\n+playback::compile_to_file::compile_to_file (recording::context *ctxt,\n+\t\t\t\t\t    enum gcc_jit_output_kind output_kind,\n+\t\t\t\t\t    const char *output_path) :\n+  playback::context (ctxt),\n+  m_output_kind (output_kind),\n+  m_output_path (output_path)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+}\n+\n+/*  Implementation of the playback::context::process vfunc for compiling\n+    to a file.\n+\n+    Either copy the .s file to the given destination (for\n+    GCC_JIT_OUTPUT_KIND_ASSEMBLER), or invoke the driver to convert it\n+    as necessary, copying the result.  */\n+\n+void\n+playback::compile_to_file::postprocess (const char *ctxt_progname)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+\n+  /* The driver takes different actions based on the filename, so\n+     we provide a filename with an appropriate suffix for the\n+     output kind, and then copy it up to the user-provided path,\n+     rather than directly compiling it to the requested output path.  */\n+\n+  switch (m_output_kind)\n     {\n-      release_mutex ();\n-      return NULL;\n+    default:\n+      gcc_unreachable ();\n+\n+    case GCC_JIT_OUTPUT_KIND_ASSEMBLER:\n+      copy_file (get_tempdir ()->get_path_s_file (),\n+\t\t m_output_path);\n+      break;\n+\n+    case GCC_JIT_OUTPUT_KIND_OBJECT_FILE:\n+      {\n+\tchar *tmp_o_path = ::concat (get_tempdir ()->get_path (),\n+\t\t\t\t     \"/fake.o\",\n+\t\t\t\t     NULL);\n+\tinvoke_driver (ctxt_progname,\n+\t\t       get_tempdir ()->get_path_s_file (),\n+\t\t       tmp_o_path,\n+\t\t       TV_ASSEMBLE,\n+\t\t       false, /* bool shared, */\n+\t\t       false);/* bool run_linker */\n+\tif (!errors_occurred ())\n+\t  copy_file (tmp_o_path,\n+\t\t     m_output_path);\n+\tfree (tmp_o_path);\n+      }\n+      break;\n+\n+    case GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY:\n+      invoke_driver (ctxt_progname,\n+\t\t     get_tempdir ()->get_path_s_file (),\n+\t\t     get_tempdir ()->get_path_so_file (),\n+\t\t     TV_ASSEMBLE,\n+\t\t     true, /* bool shared, */\n+\t\t     true);/* bool run_linker */\n+      if (!errors_occurred ())\n+\tcopy_file (get_tempdir ()->get_path_so_file (),\n+\t\t   m_output_path);\n+      break;\n+\n+    case GCC_JIT_OUTPUT_KIND_EXECUTABLE:\n+      {\n+\tchar *tmp_exe_path = ::concat (get_tempdir ()->get_path (),\n+\t\t\t\t     \"/fake.exe\",\n+\t\t\t\t     NULL);\n+\tinvoke_driver (ctxt_progname,\n+\t\t       get_tempdir ()->get_path_s_file (),\n+\t\t       tmp_exe_path,\n+\t\t       TV_ASSEMBLE,\n+\t\t       false, /* bool shared, */\n+\t\t       true);/* bool run_linker */\n+\tif (!errors_occurred ())\n+\t  copy_file (tmp_exe_path,\n+\t\t     m_output_path);\n+\tfree (tmp_exe_path);\n+      }\n+      break;\n+\n     }\n \n-  result_obj = dlopen_built_dso ();\n+}\n+\n+/* Copy SRC_PATH to DST_PATH, preserving permission bits (in particular,\n+   the \"executable\" bits).\n \n-  release_mutex ();\n+   Any errors that occur are reported on the context and hence count as\n+   a failure of the compile.\n \n-  return result_obj;\n+   We can't in general hardlink or use \"rename\" from the tempdir since\n+   it might be on a different filesystem to the destination.  For example,\n+   I get EXDEV: \"Invalid cross-device link\".  */\n+\n+void\n+playback::compile_to_file::copy_file (const char *src_path,\n+\t\t\t\t      const char *dst_path)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+  if (get_logger ())\n+    {\n+      get_logger ()->log (\"src_path: %s\", src_path);\n+      get_logger ()->log (\"dst_path: %s\", dst_path);\n+    }\n+\n+  FILE *f_in = NULL;\n+  FILE *f_out = NULL;\n+  size_t total_sz_in = 0;\n+  size_t total_sz_out = 0;\n+  char buf[4096];\n+  size_t sz_in;\n+  struct stat stat_buf;\n+\n+  f_in = fopen (src_path, \"rb\");\n+  if (!f_in)\n+    {\n+      add_error (NULL,\n+\t\t \"unable to open %s for reading: %s\",\n+\t\t src_path,\n+\t\t xstrerror (errno));\n+      return;\n+    }\n+\n+  /* Use stat on the filedescriptor to get the mode,\n+     so that we can copy it over (in particular, the\n+     \"executable\" bits).  */\n+  if (-1 == fstat (fileno (f_in), &stat_buf))\n+    {\n+      add_error (NULL,\n+\t\t \"unable to fstat %s: %s\",\n+\t\t src_path,\n+\t\t xstrerror (errno));\n+      fclose (f_in);\n+      return;\n+    }\n+\n+  f_out = fopen (dst_path, \"wb\");\n+  if (!f_out)\n+    {\n+      add_error (NULL,\n+\t\t \"unable to open %s for writing: %s\",\n+\t\t dst_path,\n+\t\t xstrerror (errno));\n+      fclose (f_in);\n+      return;\n+    }\n+\n+  while ( (sz_in = fread (buf, 1, sizeof (buf), f_in)) )\n+    {\n+      total_sz_in += sz_in;\n+      size_t sz_out_remaining = sz_in;\n+      size_t sz_out_so_far = 0;\n+      while (sz_out_remaining)\n+\t{\n+\t  size_t sz_out = fwrite (buf + sz_out_so_far,\n+\t\t\t\t  1,\n+\t\t\t\t  sz_out_remaining,\n+\t\t\t\t  f_out);\n+\t  gcc_assert (sz_out <= sz_out_remaining);\n+\t  if (!sz_out)\n+\t    {\n+\t      add_error (NULL,\n+\t\t\t \"error writing to %s: %s\",\n+\t\t\t dst_path,\n+\t\t\t xstrerror (errno));\n+\t      fclose (f_in);\n+\t      fclose (f_out);\n+\t      return;\n+\t    }\n+\t  total_sz_out += sz_out;\n+\t  sz_out_so_far += sz_out;\n+\t  sz_out_remaining -= sz_out;\n+\t}\n+      gcc_assert (sz_out_so_far == sz_in);\n+    }\n+\n+  if (!feof (f_in))\n+    add_error (NULL,\n+\t       \"error reading from %s: %s\",\n+\t       src_path,\n+\t       xstrerror (errno));\n+\n+  fclose (f_in);\n+\n+  gcc_assert (total_sz_in == total_sz_out);\n+  if (get_logger ())\n+    get_logger ()->log (\"total bytes copied: %ld\", total_sz_out);\n+\n+  /* Set the permissions of the copy to those of the original file,\n+     in particular the \"executable\" bits.  */\n+  if (-1 == fchmod (fileno (f_out), stat_buf.st_mode))\n+    add_error (NULL,\n+\t       \"error setting mode of %s: %s\",\n+\t       dst_path,\n+\t       xstrerror (errno));\n+\n+  fclose (f_out);\n }\n \n /* Helper functions for gcc::jit::playback::context::compile.  */\n@@ -1973,11 +2218,30 @@ playback::context::read_dump_file (const char *path)\n void\n playback::context::\n convert_to_dso (const char *ctxt_progname)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+\n+  invoke_driver (ctxt_progname,\n+\t\t m_tempdir->get_path_s_file (),\n+\t\t m_tempdir->get_path_so_file (),\n+\t\t TV_ASSEMBLE,\n+\t\t true, /* bool shared, */\n+\t\t true);/* bool run_linker */\n+}\n+\n+void\n+playback::context::\n+invoke_driver (const char *ctxt_progname,\n+\t       const char *input_file,\n+\t       const char *output_file,\n+\t       timevar_id_t tv_id,\n+\t       bool shared,\n+\t       bool run_linker)\n {\n   JIT_LOG_SCOPE (get_logger ());\n   /* Currently this lumps together both assembling and linking into\n      TV_ASSEMBLE.  */\n-  auto_timevar assemble_timevar (TV_ASSEMBLE);\n+  auto_timevar assemble_timevar (tv_id);\n   const char *errmsg;\n   auto_vec <const char *> argvec;\n #define ADD_ARG(arg) argvec.safe_push (arg)\n@@ -1986,12 +2250,16 @@ convert_to_dso (const char *ctxt_progname)\n   const char *gcc_driver_name = GCC_DRIVER_NAME;\n \n   ADD_ARG (gcc_driver_name);\n-  ADD_ARG (\"-shared\");\n-  /* The input: assembler.  */\n-  ADD_ARG (m_tempdir->get_path_s_file ());\n-  /* The output: shared library.  */\n+\n+  if (shared)\n+    ADD_ARG (\"-shared\");\n+\n+  if (!run_linker)\n+    ADD_ARG (\"-c\");\n+\n+  ADD_ARG (input_file);\n   ADD_ARG (\"-o\");\n-  ADD_ARG (m_tempdir->get_path_so_file ());\n+  ADD_ARG (output_file);\n \n   /* Don't use the linker plugin.\n      If running with just a \"make\" and not a \"make install\", then we'd"}, {"sha": "e9832f0378ebb6c60e3bb11e9586f79a16c43180", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #include <utility> // for std::pair\n \n+#include \"timevar.h\"\n+\n #include \"jit-recording.h\"\n \n namespace gcc {\n@@ -35,6 +37,12 @@ namespace jit {\n \n namespace playback {\n \n+/* playback::context is an abstract base class.\n+\n+   The two concrete subclasses are:\n+   - playback::compile_to_memory\n+   - playback::compile_to_file.  */\n+\n class context : public log_user\n {\n public:\n@@ -174,7 +182,7 @@ class context : public log_user\n     return m_recording_ctxt->get_builtins_manager ();\n   }\n \n-  result *\n+  void\n   compile ();\n \n   void\n@@ -252,9 +260,22 @@ class context : public log_user\n   char *\n   read_dump_file (const char *path);\n \n+  virtual void postprocess (const char *ctxt_progname) = 0;\n+\n+protected:\n+  tempdir *get_tempdir () { return m_tempdir; }\n+\n   void\n   convert_to_dso (const char *ctxt_progname);\n \n+  void\n+  invoke_driver (const char *ctxt_progname,\n+\t\t const char *input_file,\n+\t\t const char *output_file,\n+\t\t timevar_id_t tv_id,\n+\t\t bool shared,\n+\t\t bool run_linker);\n+\n   result *\n   dlopen_built_dso ();\n \n@@ -274,6 +295,37 @@ class context : public log_user\n   auto_vec<std::pair<tree, location *> > m_cached_locations;\n };\n \n+class compile_to_memory : public context\n+{\n+ public:\n+  compile_to_memory (recording::context *ctxt);\n+  void postprocess (const char *ctxt_progname);\n+\n+  result *get_result_obj () const { return m_result; }\n+\n+ private:\n+  result *m_result;\n+};\n+\n+class compile_to_file : public context\n+{\n+ public:\n+  compile_to_file (recording::context *ctxt,\n+\t\t   enum gcc_jit_output_kind output_kind,\n+\t\t   const char *output_path);\n+  void postprocess (const char *ctxt_progname);\n+\n+ private:\n+  void\n+  copy_file (const char *src_path,\n+\t     const char *dst_path);\n+\n+ private:\n+  enum gcc_jit_output_kind m_output_kind;\n+  const char *m_output_path;\n+};\n+\n+\n /* A temporary wrapper object.\n    These objects are (mostly) only valid during replay.\n    We allocate them on the GC heap, so that they will be cleaned"}, {"sha": "1077f2732e9049c7ffebbbae594c728aa60388c0", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -1152,8 +1152,8 @@ recording::context::enable_dump (const char *dumpname,\n   m_requested_dumps.safe_push (d);\n }\n \n-/* Validate this context, and if it passes, compile it within a\n-   mutex.\n+/* Validate this context, and if it passes, compile it to memory\n+   (within a mutex).\n \n    Implements the post-error-checking part of\n    gcc_jit_context_compile.  */\n@@ -1168,13 +1168,41 @@ recording::context::compile ()\n   if (errors_occurred ())\n     return NULL;\n \n-  /* Set up a playback context.  */\n-  ::gcc::jit::playback::context replayer (this);\n+  /* Set up a compile_to_memory playback context.  */\n+  ::gcc::jit::playback::compile_to_memory replayer (this);\n \n   /* Use it.  */\n-  result *result_obj = replayer.compile ();\n+  replayer.compile ();\n \n-  return result_obj;\n+  /* Get the jit::result (or NULL) from the\n+     compile_to_memory playback context.  */\n+  return replayer.get_result_obj ();\n+}\n+\n+/* Validate this context, and if it passes, compile it to a file\n+   (within a mutex).\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_context_compile_to_file.  */\n+\n+void\n+recording::context::compile_to_file (enum gcc_jit_output_kind output_kind,\n+\t\t\t\t     const char *output_path)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+\n+  validate ();\n+\n+  if (errors_occurred ())\n+    return;\n+\n+  /* Set up a compile_to_file playback context.  */\n+  ::gcc::jit::playback::compile_to_file replayer (this,\n+\t\t\t\t\t\t  output_kind,\n+\t\t\t\t\t\t  output_path);\n+\n+  /* Use it.  */\n+  replayer.compile ();\n }\n \n /* Format the given error using printf's conventions, print"}, {"sha": "0dd3164008504a32b6ec4c9d728c478cb7af2509", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -220,6 +220,10 @@ class context : public log_user\n   result *\n   compile ();\n \n+  void\n+  compile_to_file (enum gcc_jit_output_kind output_kind,\n+\t\t   const char *output_path);\n+\n   void\n   add_error (location *loc, const char *fmt, ...)\n       GNU_PRINTF(3, 4);"}, {"sha": "62ef6a432efabf124cf21d7023231c5bdbeda1e3", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -99,6 +99,9 @@ namespace gccjit\n \n     gcc_jit_result *compile ();\n \n+    void compile_to_file (enum gcc_jit_output_kind output_kind,\n+\t\t\t  const char *output_path);\n+\n     void dump_to_file (const std::string &path,\n \t\t       bool update_locations);\n \n@@ -540,6 +543,15 @@ context::compile ()\n   return result;\n }\n \n+inline void\n+context::compile_to_file (enum gcc_jit_output_kind output_kind,\n+\t\t\t  const char *output_path)\n+{\n+  gcc_jit_context_compile_to_file (m_inner_ctxt,\n+\t\t\t\t   output_kind,\n+\t\t\t\t   output_path);\n+}\n+\n inline void\n context::dump_to_file (const std::string &path,\n \t\t       bool update_locations)"}, {"sha": "7eb66bdae506ddb4be89d16d3d9824f5929c5ef9", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -2196,7 +2196,7 @@ gcc_jit_context_compile (gcc_jit_context *ctxt)\n \n   JIT_LOG_FUNC (ctxt->get_logger ());\n \n-  ctxt->log (\"compiling ctxt: %p\", (void *)ctxt);\n+  ctxt->log (\"in-memory compile of ctxt: %p\", (void *)ctxt);\n \n   gcc_jit_result *result = (gcc_jit_result *)ctxt->compile ();\n \n@@ -2206,6 +2206,35 @@ gcc_jit_context_compile (gcc_jit_context *ctxt)\n   return result;\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::compile_to_file method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_context_compile_to_file (gcc_jit_context *ctxt,\n+\t\t\t\t enum gcc_jit_output_kind output_kind,\n+\t\t\t\t const char *output_path)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_IF_FAIL_PRINTF1 (\n+    ((output_kind >= GCC_JIT_OUTPUT_KIND_ASSEMBLER)\n+     && (output_kind <= GCC_JIT_OUTPUT_KIND_EXECUTABLE)),\n+    ctxt, NULL,\n+    \"unrecognized output_kind: %i\",\n+    output_kind);\n+  RETURN_IF_FAIL (output_path, ctxt, NULL, \"NULL output_path\");\n+\n+  ctxt->log (\"compile_to_file of ctxt: %p\", (void *)ctxt);\n+  ctxt->log (\"output_kind: %i\", output_kind);\n+  ctxt->log (\"output_path: %s\", output_path);\n+\n+  ctxt->compile_to_file (output_kind, output_path);\n+}\n+\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the"}, {"sha": "12514bab3e4fc8116abbd0b9b49ca98e031f02a2", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -36,17 +36,20 @@ extern \"C\" {\n    the API below.\n \n    Invoking gcc_jit_context_compile on it gives you a gcc_jit_result *\n-   (or NULL).\n+   (or NULL), representing in-memory machine code.\n \n    You can call gcc_jit_context_compile repeatedly on one context, giving\n    multiple independent results.\n \n+   Similarly, you can call gcc_jit_context_compile_to_file on a context\n+   to compile to disk.\n+\n    Eventually you can call gcc_jit_context_release to clean up the\n-   context; any results created from it are still usable, and should be\n-   cleaned up via gcc_jit_result_release.  */\n+   context; any in-memory results created from it are still usable, and\n+   should be cleaned up via gcc_jit_result_release.  */\n typedef struct gcc_jit_context gcc_jit_context;\n \n-/* A gcc_jit_result encapsulates the result of a compilation.  */\n+/* A gcc_jit_result encapsulates the result of an in-memory compilation.  */\n typedef struct gcc_jit_result gcc_jit_result;\n \n /* An object created within a context.  Such objects are automatically\n@@ -240,12 +243,42 @@ gcc_jit_context_set_bool_option (gcc_jit_context *ctxt,\n \t\t\t\t enum gcc_jit_bool_option opt,\n \t\t\t\t int value);\n \n-/* This actually calls into GCC and runs the build, all\n-   in a mutex for now.  The result is a wrapper around a .so file.\n-   It can only be called once on a given context.  */\n+/* Compile the context to in-memory machine code.\n+\n+   This can be called more that once on a given context,\n+   although any errors that occur will block further compilation.  */\n+\n extern gcc_jit_result *\n gcc_jit_context_compile (gcc_jit_context *ctxt);\n \n+/* Kinds of ahead-of-time compilation, for use with\n+   gcc_jit_context_compile_to_file.  */\n+\n+enum gcc_jit_output_kind\n+{\n+  /* Compile the context to an assembler file.  */\n+  GCC_JIT_OUTPUT_KIND_ASSEMBLER,\n+\n+  /* Compile the context to an object file.  */\n+  GCC_JIT_OUTPUT_KIND_OBJECT_FILE,\n+\n+  /* Compile the context to a dynamic library.  */\n+  GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY,\n+\n+  /* Compile the context to an executable.  */\n+  GCC_JIT_OUTPUT_KIND_EXECUTABLE\n+};\n+\n+/* Compile the context to a file of the given kind.\n+\n+   This can be called more that once on a given context,\n+   although any errors that occur will block further compilation.  */\n+\n+extern void\n+gcc_jit_context_compile_to_file (gcc_jit_context *ctxt,\n+\t\t\t\t enum gcc_jit_output_kind output_kind,\n+\t\t\t\t const char *output_path);\n+\n /* To help with debugging: dump a C-like representation to the given path,\n    describing what's been set up on the context.\n \n@@ -1079,14 +1112,15 @@ gcc_jit_context_dump_reproducer_to_file (gcc_jit_context *ctxt,\n    The context directly stores the dumpname as a (const char *), so the\n    passed string must outlive the context.\n \n-   gcc_jit_context_compile will capture the dump as a\n-   dynamically-allocated buffer, writing it to ``*out_ptr``.\n+   gcc_jit_context_compile and gcc_jit_context_to_file\n+   will capture the dump as a dynamically-allocated buffer, writing\n+   it to ``*out_ptr``.\n \n    The caller becomes responsible for calling\n       free (*out_ptr)\n-   each time that gcc_jit_context_compile is called.  *out_ptr will be\n-   written to, either with the address of a buffer, or with NULL if an\n-   error occurred.\n+   each time that gcc_jit_context_compile or gcc_jit_context_to_file\n+   are called.  *out_ptr will be written to, either with the address of a\n+   buffer, or with NULL if an error occurred.\n \n    This API entrypoint is likely to be less stable than the others.\n    In particular, both the precise dumpnames, and the format and content"}, {"sha": "89bd57be4f55b34ccdabfa359d52c85549243197", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -32,6 +32,7 @@\n     gcc_jit_block_get_function;\n     gcc_jit_context_acquire;\n     gcc_jit_context_compile;\n+    gcc_jit_context_compile_to_file;\n     gcc_jit_context_dump_to_file;\n     gcc_jit_context_dump_reproducer_to_file;\n     gcc_jit_context_enable_dump;"}, {"sha": "e92c6651f00001a4157f36ed6e6232764badb28d", "filename": "gcc/jit/notes.txt", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fnotes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Fjit%2Fnotes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fnotes.txt?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -74,9 +74,16 @@ Client Code   . Generated .            libgccjit.so\n               .           .          .               . \u2502   (purge internal state)\n               .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 end of toplev::finalize\n               .           .    \u2502     .               .\n-              .           .    \u2502 Convert assembler to DSO (\"fake.so\")\n-              .           .    \u2502     .               .\n-              .           .    \u2502 Load DSO (dlopen \"fake.so\")\n+              .           .    V\u2500> playback::context::postprocess:\n+              .           .      \u2502   .               .\n+              .           .      \u2502   (assuming an in-memory compile):\n+              .           .      \u2502   .               .\n+              .           .      \u2502   . Convert assembler to DSO (\"fake.so\")\n+              .           .      \u2502   .               .\n+              .           .      \u2502   . Load DSO (dlopen \"fake.so\")\n+              .           .      \u2502   .               .\n+              .           .      \u2502   . Bundle it up in a jit::result\n+              .           .    <\u2500\u2500   .               .\n               .           .    \u2502     .               .\n               .           .    \u2502 RELEASE MUTEX       .\n               .           .    \u2502     .               ."}, {"sha": "6dc5125ebb819dcf76314ae4b0f219a4fa6624b6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -1,3 +1,28 @@\n+2015-01-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h: Include <unistd.h>.\n+\t(CHECK_NO_ERRORS): New.\n+\t(verify_code): Wrap prototype in #ifndef TEST_COMPILING_TO_FILE.\n+\t(test_jit): Support new macro TEST_COMPILING_TO_FILE for exercising\n+\tgcc_jit_context_compile_to_file.\n+\t* jit.dg/jit.exp (fixed_host_execute): Fix the code for passing on\n+\targs to the spawned executable.\n+\t(jit-expand-vars): New function.\n+\t(jit-exe-params): New variable.\n+\t(dg-jit-set-exe-params): New function.\n+\t(jit-dg-test): Detect testcases that use\n+\tjit-verify-compile-to-file and call jit-setup-compile-to-file.\n+\tSet arguments of spawned process to jit-exe-params.\n+\t(jit-get-output-filename): New function.\n+\t(jit-setup-compile-to-file): New function.\n+\t(jit-verify-compile-to-file): New function.\n+\t(jit-run-executable): New function.\n+\t(jit-verify-executable): New function.\n+\t* jit.dg/test-compile-to-assembler.c: New testcase.\n+\t* jit.dg/test-compile-to-dynamic-library.c: New testcase.\n+\t* jit.dg/test-compile-to-executable.c: New testcase.\n+\t* jit.dg/test-compile-to-object.c: New testcase.\n+\n 2015-01-19  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/64652"}, {"sha": "a702a23a27b01ff981e32c2fd6f885813e666e2c", "filename": "gcc/testsuite/jit.dg/harness.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -7,12 +7,14 @@\n     extern void\n     create_code (gcc_jit_context *ctxt, void * user_data);\n \n+  and, #ifndef TEST_COMPILING_TO_FILE,\n+\n     extern void\n     verify_code (gcc_jit_context *ctxt, gcc_jit_result *result);\n-\n  */\n #include <stdlib.h>\n #include <stdio.h>\n+#include <unistd.h>\n \n /* test-threads.c use threads, but dejagnu.h isn't thread-safe; there's a\n    shared \"buffer\", and the counts of passed/failed etc are globals.\n@@ -106,12 +108,23 @@ static char test[1024];\n       }\t\t\t\t\\\n   } while (0)\n \n+#define CHECK_NO_ERRORS(CTXT) \\\n+  do { \\\n+    const char *err = gcc_jit_context_get_first_error (CTXT); \\\n+    if (err) \\\n+      fail (\"error unexpectedly occurred: %s\", err); \\\n+    else \\\n+      pass (\"no errors occurred\"); \\\n+  } while (0)\n+\n /* Hooks that testcases should provide.  */\n extern void\n create_code (gcc_jit_context *ctxt, void * user_data);\n \n+#ifndef TEST_COMPILING_TO_FILE\n extern void\n verify_code (gcc_jit_context *ctxt, gcc_jit_result *result);\n+#endif\n \n extern void check_string_value (const char *funcname,\n \t\t\t\tconst char *actual, const char *expected);\n@@ -322,7 +335,13 @@ test_jit (const char *argv0, void *user_data)\n {\n   gcc_jit_context *ctxt;\n   FILE *logfile;\n+#ifndef TEST_COMPILING_TO_FILE\n   gcc_jit_result *result;\n+#endif\n+\n+#ifdef TEST_COMPILING_TO_FILE\n+  unlink (OUTPUT_FILENAME);\n+#endif\n \n   ctxt = gcc_jit_context_acquire ();\n   if (!ctxt)\n@@ -339,16 +358,24 @@ test_jit (const char *argv0, void *user_data)\n \n   dump_reproducer (ctxt, argv0);\n \n+#ifdef TEST_COMPILING_TO_FILE\n+  gcc_jit_context_compile_to_file (ctxt,\n+\t\t\t\t   (OUTPUT_KIND),\n+\t\t\t\t   (OUTPUT_FILENAME));\n+#else /* #ifdef TEST_COMPILING_TO_FILE */\n   /* This actually calls into GCC and runs the build, all\n      in a mutex for now.  */\n   result = gcc_jit_context_compile (ctxt);\n \n   verify_code (ctxt, result);\n+#endif\n \n   gcc_jit_context_release (ctxt);\n \n+#ifndef TEST_COMPILING_TO_FILE\n   /* Once we're done with the code, this unloads the built .so file: */\n   gcc_jit_result_release (result);\n+#endif\n \n   if (logfile)\n     fclose (logfile);"}, {"sha": "c853f22addecdb802b6a3b03b1a02959e9dd9493", "filename": "gcc/testsuite/jit.dg/jit.exp", "status": "modified", "additions": 205, "deletions": 4, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -139,6 +139,8 @@ proc fixed_host_execute {args} {\n     global text\n     global spawn_id\n \n+    verbose \"fixed_host_execute: $args\"\n+\n     set timeoutmsg \"Timed out: Never got started, \"\n     set timeout 100\n     set file all\n@@ -148,9 +150,8 @@ proc fixed_host_execute {args} {\n     if { [llength $args] == 0} {\n \tset executable $args\n     } else {\n-\tset executable [string trimleft [lindex [split $args \" \"] 0] \"\\{\"]\n-\tset params [string trimleft [lindex [split $args \" \"] 1] \"\\{\"]\n-\tset params [string trimright $params \"\\}\"]\n+\tset executable [lindex $args 0]\n+\tset params [lindex $args 1]\n     }\n \n     verbose \"The executable is $executable\" 2\n@@ -159,6 +160,8 @@ proc fixed_host_execute {args} {\n \treturn \"No source file found\"\n     }\n \n+    verbose \"params: $params\" 2\n+\n     # spawn the executable and look for the DejaGnu output messages from the\n     # test case.\n     # spawn -noecho -open [open \"|./${executable}\" \"r\"]\n@@ -328,6 +331,39 @@ proc get_path_of_driver {} {\n     return [file dirname $binary]\n }\n \n+# Expand \"SRCDIR\" within ARG to the location of the top-level\n+# src directory\n+\n+proc jit-expand-vars {arg} {\n+    verbose \"jit-expand-vars: $arg\"\n+    global srcdir\n+    verbose \" srcdir: $srcdir\"\n+    # \"srcdir\" is that of the gcc/testsuite directory, so\n+    # we need to go up two levels.\n+    set arg [string map [list \"SRCDIR\" $srcdir/../..] $arg]\n+    verbose \" new arg: $arg\"\n+    return $arg\n+}\n+\n+# Parameters used when invoking the executables built from the test cases.\n+\n+global jit-exe-params\n+set jit-exe-params {}\n+\n+# Set \"jit-exe-params\", expanding \"SRCDIR\" in each arg to the location of\n+# the top-level srcdir.\n+\n+proc dg-jit-set-exe-params { args } {\n+    verbose \"dg-jit-set-exe-params: $args\"\n+\n+    global jit-exe-params\n+    set jit-exe-params {}\n+    # Skip initial arg (line number)\n+    foreach arg [lrange $args 1 [llength $args] ] {\n+\tlappend jit-exe-params [jit-expand-vars $arg]\n+    }\n+}\n+\n proc jit-dg-test { prog do_what extra_tool_flags } {\n     verbose \"within jit-dg-test...\"\n     verbose \"  prog: $prog\"\n@@ -339,6 +375,15 @@ proc jit-dg-test { prog do_what extra_tool_flags } {\n \tappend extra_tool_flags \" -lpthread\"\n     }\n \n+    # Any test case that uses\n+    #   { dg-final { jit-verify-compile-to-file FOO } }\n+    # needs to call jit-setup-compile-to-file here.\n+    # (is there a better way to handle setup/finish pairs in dg?)\n+    set tmp [grep $prog \"jit-verify-compile-to-file\"]\n+    if {![string match \"\" $tmp]} {\n+\tjit-setup-compile-to-file $prog\n+    }\n+\n     # Determine what to name the built executable.\n     #\n     # We simply append .exe to the filename, e.g.\n@@ -464,7 +509,12 @@ proc jit-dg-test { prog do_what extra_tool_flags } {\n     #  http://lists.gnu.org/archive/html/dejagnu/2014-10/msg00000.html\n     # We instead call a patched local copy, \"fixed_host_execute\", defined\n     # above.\n-    set result [fixed_host_execute $output_file]\n+\n+    global jit-exe-params\n+    set args ${jit-exe-params}\n+    set jit-exe-params {}\n+\n+    set result [fixed_host_execute $output_file $args ]\n     verbose \"result: $result\"\n \n     # Restore PATH\n@@ -530,6 +580,157 @@ proc jit-dg-test { prog do_what extra_tool_flags } {\n     return [list $comp_output $output_file]\n }\n \n+# Given source file PROG, scrape out the value of\n+#   #define OUTPUT_FILENAME\n+# failing if it's not found.\n+\n+proc jit-get-output-filename {prog} {\n+    set tmp [grep $prog \"#define OUTPUT_FILENAME (.*)\"]\n+    if {![string match \"\" $tmp]} {\n+\tforeach i $tmp {\n+\t    verbose \"i: $i\"\n+\t    if {[regexp \"^\\#define OUTPUT_FILENAME\\[ \\t\\]\\+\\\"(.*)\\\"$\" $i i group] } {\n+\t\tverbose \"group: '$group'\"\n+\t\treturn $group\n+\t    } else {\n+\t\tfail \"Unable to parse line: $i\"\n+\t    }\n+\t}\n+    }\n+    fail \"Unable to locate OUTPUT_FILENAME\"\n+    return \"\"\n+}\n+\n+# For testcases that use jit-verify-compile-to-file,\n+# delete OUTPUT_FILENAME beforehand, to ensure that the\n+# testcase is indeed creating it.\n+\n+proc jit-setup-compile-to-file { prog } {\n+    verbose \"jit-setup-compile-to-file: $prog\"\n+    set output_filename [jit-get-output-filename $prog]\n+    verbose \"  output_filename: $output_filename\"\n+    if {![string match \"\" $output_filename]} {\n+\tcatch \"exec rm -f $output_filename\"\n+    }\n+}\n+\n+# Locate OUTPUT_FILENAME within the testcase.  Verify\n+# that a file with that name was created, and that\n+# the output of running the \"file\" utility on it\n+# matches the given regex.\n+# For use by the various test-compile-to-*.c testcases.\n+\n+proc jit-verify-compile-to-file {args} {\n+    verbose \"jit-verify-compile-to-file: $args\"\n+\n+    set file_regex [lindex $args 0]\n+    verbose \"file_regex: $file_regex\"\n+\n+    upvar 2 prog prog\n+    verbose \"prog: $prog\"\n+    set output_filename [jit-get-output-filename $prog]\n+    verbose \"  output_filename: $output_filename\"\n+\n+    # Verify that the expected file was written out\n+    if { [file exists $output_filename] == 1} {\n+\tpass \"$output_filename exists\"\n+    } else {\n+\tfail \"$output_filename does not exist\"\n+\treturn\n+    }\n+\n+    # Run \"file\" on OUTPUT_FILENAME, and verify that the output\n+    # matches $file_regex.\n+    spawn -noecho \"file\" $output_filename\n+    set file_id $spawn_id\n+    expect \"\\n\" {\n+\tverbose \"got newline: $expect_out(buffer)\"\n+\tset classification $expect_out(buffer)\n+\tverbose \"classification: $classification\"\n+\tif { [regexp $file_regex $classification] } {\n+\t    pass \"'file' output on $output_filename matched: $file_regex\"\n+\t} else {\n+\t    fail \"'file' output on $output_filename did not match: $file_regex\"\n+\t}\n+    }\n+    set $spawn_id $file_id\n+    close\n+}\n+\n+# Verify that the given file exists, and is executable.\n+# Attempt to execute it, and verify that its stdout matches\n+# the given regex.\n+\n+proc jit-run-executable { args } {\n+    verbose \"jit-run-executable: $args\"\n+\n+    set executable-name [lindex $args 0]\n+    verbose \"executable-name: ${executable-name}\"\n+\n+    set dg-output-text [lindex $args 1]\n+    verbose \"dg-output-text: ${dg-output-text}\"\n+\n+    if { [file executable ${executable-name}] } {\n+\tpass \"${executable-name} has executable bit set\"\n+    } else {\n+\tfail \"${executable-name} does not have executable bit set\"\n+    }\n+\n+    # Attempt to run the executable; adapted from dg.exp's dg-test\n+    set status -1\n+    set result [jit_load ./${executable-name}]\n+    set status [lindex $result 0]\n+    set output [lindex $result 1]\n+    verbose \"  status: $status\"\n+    verbose \"  output: $output\"\n+    # send_user \"After exec, status: $status\\n\"\n+    if { \"$status\" == \"pass\" } {\n+\tpass \"${executable-name} execution test\"\n+\tverbose \"Exec succeeded.\" 3\n+\tset texttmp ${dg-output-text}\n+\tif { ![regexp $texttmp ${output}] } {\n+\t    fail \"${executable-name} output pattern test, is ${output}, should match $texttmp\"\n+\t    verbose \"Failed test for output pattern $texttmp\" 3\n+\t} else {\n+\t    pass \"${executable-name} output pattern test, $texttmp\"\n+\t    verbose \"Passed test for output pattern $texttmp\" 3\n+\t}\n+\tunset texttmp\n+    } elseif { \"$status\" == \"fail\" } {\n+\t# It would be nice to get some info out of errorCode.\n+\tif {[info exists errorCode]} {\n+\t    verbose \"Exec failed, errorCode: $errorCode\" 3\n+\t} else {\n+\t    verbose \"Exec failed, errorCode not defined!\" 3\n+\t}\n+\tfail \"${executable-name} execution test\"\n+    } else {\n+\t$status \"${executable-name} execution test\"\n+    }\n+}\n+\n+# A way to invoke \"jit-run-executable\" with the given regex,\n+# using OUTPUT_FILENAME within the testcase to determine\n+# the name of the executable to run.\n+# For use by the test-compile-to-executable.c testcase.\n+\n+proc jit-verify-executable { args } {\n+    verbose \"jit-verify-executable: $args\"\n+\n+    set dg-output-text [lindex $args 0]\n+    verbose \"dg-output-text: ${dg-output-text}\"\n+\n+    upvar 2 name name\n+    verbose \"name: $name\"\n+\n+    upvar 2 prog prog\n+    verbose \"prog: $prog\"\n+    set output_filename [jit-get-output-filename $prog]\n+    verbose \"  output_filename: $output_filename\"\n+\n+    jit-run-executable $output_filename ${dg-output-text}\n+}\n+\n # We need to link with --export-dynamic for test-calling-external-function.c\n # so that the JIT-built code can call into functions from the main program.\n set DEFAULT_CFLAGS \"-I$srcdir/../jit -lgccjit -g -Wall -Werror -Wl,--export-dynamic\""}, {"sha": "c5b282c28704d46a511c991eb04feaf0238ec111", "filename": "gcc/testsuite/jit.dg/test-compile-to-assembler.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-assembler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-assembler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-assembler.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,65 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#define TEST_COMPILING_TO_FILE\n+#define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_ASSEMBLER\n+#define OUTPUT_FILENAME  \"output-of-test-compile-to-assembler.c.s\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     void\n+     hello_world (const char *name)\n+     {\n+       // a test comment\n+       printf (\"hello %s\\n\", name);\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *const_char_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_param *param_name =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"hello_world\",\n+\t\t\t\t  1, &param_name,\n+\t\t\t\t  0);\n+\n+  gcc_jit_param *param_format =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n+  gcc_jit_function *printf_func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  gcc_jit_context_get_type (\n+\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n+\t\t\t\t  \"printf\",\n+\t\t\t\t  1, &param_format,\n+\t\t\t\t  1);\n+  gcc_jit_rvalue *args[2];\n+  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n+  args[1] = gcc_jit_param_as_rvalue (param_name);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+  gcc_jit_block_add_comment (\n+    block, NULL,\n+    \"a test comment\");\n+\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt,\n+\t\t\t      NULL,\n+\t\t\t      printf_func,\n+\t\t\t      2, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+/* { dg-final { jit-verify-compile-to-file \"assembler source text\" } } */"}, {"sha": "095f75127f3cf5963fa38e418da421f3d41e7c79", "filename": "gcc/testsuite/jit.dg/test-compile-to-dynamic-library.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-dynamic-library.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-dynamic-library.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-dynamic-library.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,65 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#define TEST_COMPILING_TO_FILE\n+#define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY\n+#define OUTPUT_FILENAME  \"output-of-test-compile-to-dynamic-library.c.so\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     void\n+     hello_world (const char *name)\n+     {\n+       // a test comment\n+       printf (\"hello %s\\n\", name);\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *const_char_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_param *param_name =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"hello_world\",\n+\t\t\t\t  1, &param_name,\n+\t\t\t\t  0);\n+\n+  gcc_jit_param *param_format =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n+  gcc_jit_function *printf_func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  gcc_jit_context_get_type (\n+\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n+\t\t\t\t  \"printf\",\n+\t\t\t\t  1, &param_format,\n+\t\t\t\t  1);\n+  gcc_jit_rvalue *args[2];\n+  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n+  args[1] = gcc_jit_param_as_rvalue (param_name);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+  gcc_jit_block_add_comment (\n+    block, NULL,\n+    \"a test comment\");\n+\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt,\n+\t\t\t      NULL,\n+\t\t\t      printf_func,\n+\t\t\t      2, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+/* { dg-final { jit-verify-compile-to-file \"shared object.+dynamically linked\" } } */"}, {"sha": "8d7b428b89f3ba0b607d459a5e773ca8b4a5c43d", "filename": "gcc/testsuite/jit.dg/test-compile-to-executable.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-executable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-executable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-executable.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,110 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#define TEST_COMPILING_TO_FILE\n+#define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_EXECUTABLE\n+#define OUTPUT_FILENAME  \"output-of-test-compile-to-executable.c.exe\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     static void\n+     hello_world (const char *name)\n+     {\n+       // a test comment\n+       printf (\"hello %s\\n\", name);\n+     }\n+\n+     extern int\n+     main (int argc, char **argv)\n+     {\n+       hello_world (argv[0]);\n+       return 0;\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *const_char_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_param *param_name =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_INTERNAL,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"hello_world\",\n+\t\t\t\t  1, &param_name,\n+\t\t\t\t  0);\n+\n+  gcc_jit_param *param_format =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n+  gcc_jit_function *printf_func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  gcc_jit_context_get_type (\n+\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n+\t\t\t\t  \"printf\",\n+\t\t\t\t  1, &param_format,\n+\t\t\t\t  1);\n+  gcc_jit_rvalue *args[2];\n+  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n+  args[1] = gcc_jit_param_as_rvalue (param_name);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+  gcc_jit_block_add_comment (\n+    block, NULL,\n+    \"a test comment\");\n+\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt,\n+\t\t\t      NULL,\n+\t\t\t      printf_func,\n+\t\t\t      2, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_param *param_argc =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"argc\");\n+  gcc_jit_type *char_ptr_ptr_type =\n+    gcc_jit_type_get_pointer (\n+      gcc_jit_type_get_pointer (\n+\tgcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR)));\n+  gcc_jit_param *param_argv =\n+    gcc_jit_context_new_param (ctxt, NULL, char_ptr_ptr_type, \"argv\");\n+  gcc_jit_param *params[2] = {param_argc, param_argv};\n+  gcc_jit_function *func_main =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  int_type,\n+\t\t\t\t  \"main\",\n+\t\t\t\t  2, params,\n+\t\t\t\t  0);\n+  block = gcc_jit_function_new_block (func_main, NULL);\n+  gcc_jit_rvalue *zero = gcc_jit_context_zero (ctxt, int_type);\n+  args[0] = gcc_jit_context_new_cast (\n+\tctxt,\n+\tNULL,\n+\tgcc_jit_lvalue_as_rvalue (\n+\t  gcc_jit_context_new_array_access (\n+\t    ctxt,\n+\t    NULL,\n+\t    gcc_jit_param_as_rvalue (param_argv),\n+\t    zero)),\n+\tconst_char_ptr_type);\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt,\n+\t\t\t      NULL,\n+\t\t\t      func,\n+\t\t\t      1, args));\n+  gcc_jit_block_end_with_return (block, NULL, zero);\n+}\n+\n+/* { dg-final { jit-verify-compile-to-file \"executable\" } } */\n+/* { dg-final { jit-verify-executable \"hello .*\" } } */"}, {"sha": "1f7fcc6e549ae6a073018fbd43f0cc3b4550114a", "filename": "gcc/testsuite/jit.dg/test-compile-to-object.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdce7209c23212b50f08604f242e9bbb5281818b/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-object.c?ref=fdce7209c23212b50f08604f242e9bbb5281818b", "patch": "@@ -0,0 +1,65 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#define TEST_COMPILING_TO_FILE\n+#define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_OBJECT_FILE\n+#define OUTPUT_FILENAME  \"output-of-test-compile-to-object.c.o\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     void\n+     hello_world (const char *name)\n+     {\n+       // a test comment\n+       printf (\"hello %s\\n\", name);\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *const_char_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_param *param_name =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"hello_world\",\n+\t\t\t\t  1, &param_name,\n+\t\t\t\t  0);\n+\n+  gcc_jit_param *param_format =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n+  gcc_jit_function *printf_func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  gcc_jit_context_get_type (\n+\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n+\t\t\t\t  \"printf\",\n+\t\t\t\t  1, &param_format,\n+\t\t\t\t  1);\n+  gcc_jit_rvalue *args[2];\n+  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n+  args[1] = gcc_jit_param_as_rvalue (param_name);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+  gcc_jit_block_add_comment (\n+    block, NULL,\n+    \"a test comment\");\n+\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt,\n+\t\t\t      NULL,\n+\t\t\t      printf_func,\n+\t\t\t      2, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+/* { dg-final { jit-verify-compile-to-file \"relocatable\" } } */"}]}