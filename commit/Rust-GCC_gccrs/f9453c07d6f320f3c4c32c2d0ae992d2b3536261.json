{"sha": "f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk0NTNjMDdkNmYzMjBmM2M0YzMyYzJkMGFlOTkyZDJiMzUzNjI2MQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-06-26T16:27:50Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-06-26T16:27:50Z"}, "message": "tree-pass.h (pass_strength_reduction): New decl.\n\ngcc:\n\n2012-06-26  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* tree-pass.h (pass_strength_reduction): New decl.\n\t* tree-ssa-loop-ivopts.c (initialize_costs): Make non-static.\n\t(finalize_costs): Likewise.\n\t* timevar.def (TV_TREE_SLSR): New timevar.\n\t* gimple-ssa-strength-reduction.c: New.\n\t* tree-flow.h (initialize_costs): New decl.\n\t(finalize_costs): Likewise.\n\t* Makefile.in (tree-ssa-strength-reduction.o): New dependencies.\n\t* passes.c (init_optimization_passes): Add pass_strength_reduction.\n\ngcc/testsuite:\n\n2012-06-26  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* gcc.dg/tree-ssa/slsr-1.c: New test.\n\t* gcc.dg/tree-ssa/slsr-2.c: Likewise.\n\t* gcc.dg/tree-ssa/slsr-3.c: Likewise.\n\t* gcc.dg/tree-ssa/slsr-4.c: Likewise.\n\nFrom-SVN: r188989", "tree": {"sha": "a5e851050aaa607e1d45d0f74177b12f8e52507b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5e851050aaa607e1d45d0f74177b12f8e52507b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/comments", "author": null, "committer": null, "parents": [{"sha": "703ae70c629650dce1ca4a8383fdabbf422973bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703ae70c629650dce1ca4a8383fdabbf422973bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703ae70c629650dce1ca4a8383fdabbf422973bb"}], "stats": {"total": 1655, "additions": 1653, "deletions": 2}, "files": [{"sha": "7de929835af9470776fafeba547be862adc5241c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -1,3 +1,15 @@\n+2012-06-26  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* tree-pass.h (pass_strength_reduction): New decl.\n+\t* tree-ssa-loop-ivopts.c (initialize_costs): Make non-static.\n+\t(finalize_costs): Likewise.\n+\t* timevar.def (TV_TREE_SLSR): New timevar.\n+\t* gimple-ssa-strength-reduction.c: New.\n+\t* tree-flow.h (initialize_costs): New decl.\n+\t(finalize_costs): Likewise.\n+\t* Makefile.in (tree-ssa-strength-reduction.o): New dependencies.\n+\t* passes.c (init_optimization_passes): Add pass_strength_reduction.\n+\n 2012-06-26  Matt Turner  <mattst88@gmail.com>\n \n \t* doc/extend.texi (__builtin_arm_tinsrb): Add missing second"}, {"sha": "c400e02b1c92ee77d39c97481d01afa7d43b8805", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -1243,6 +1243,7 @@ OBJS = \\\n \tgimple-fold.o \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n+\tgimple-ssa-strength-reduction.o \\\n \tgimple-streamer-in.o \\\n \tgimple-streamer-out.o \\\n \tgimplify.o \\\n@@ -2432,6 +2433,11 @@ tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) langhooks.h $(HASHTAB_H) $(GIMPLE_H) \\\n    $(TREE_INLINE_H) tree-iterator.h tree-ssa-propagate.h tree-ssa-sccvn.h \\\n    $(PARAMS_H) $(GIMPLE_PRETTY_PRINT_H) gimple-fold.h\n+gimple-ssa-strength-reduction.o : gimple-ssa-strength-reduction.c $(CONFIG_H) \\\n+   $(SYSTEM_H) coretypes.h $(TREE_H) $(GIMPLE_H) $(BASIC_BLOCK_H) \\\n+   $(TREE_PASS_H) $(TIMEVAR_H) $(CFGLOOP_H) $(TREE_PRETTY_PRINT_H) \\\n+   $(GIMPLE_PRETTY_PRINT_H) alloc-pool.h $(TREE_FLOW_H) domwalk.h \\\n+   pointer-set.h\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\"}, {"sha": "f68562a9e501761f38cfe6549728b74cfae4b3cf", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "added", "additions": 1526, "deletions": 0, "changes": 1526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -0,0 +1,1526 @@\n+/* Straight-line strength reduction.\n+   Copyright (C) 2012  Free Software Foundation, Inc.\n+   Contributed by Bill Schmidt, IBM <wschmidt@linux.ibm.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* There are many algorithms for performing strength reduction on\n+   loops.  This is not one of them.  IVOPTS handles strength reduction\n+   of induction variables just fine.  This pass is intended to pick\n+   up the crumbs it leaves behind, by considering opportunities for\n+   strength reduction along dominator paths.\n+\n+   Strength reduction will be implemented in four stages, gradually\n+   adding more complex candidates:\n+\n+   1) Explicit multiplies, known constant multipliers, no\n+      conditional increments. (complete)\n+   2) Explicit multiplies, unknown constant multipliers,\n+      no conditional increments. (data gathering complete,\n+      replacements pending)\n+   3) Implicit multiplies in addressing expressions. (pending)\n+   4) Explicit multiplies, conditional increments. (pending)\n+\n+   It would also be possible to apply strength reduction to divisions\n+   and modulos, but such opportunities are relatively uncommon.\n+\n+   Strength reduction is also currently restricted to integer operations.\n+   If desired, it could be extended to floating-point operations under\n+   control of something like -funsafe-math-optimizations.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"basic-block.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-flow.h\"\n+#include \"domwalk.h\"\n+#include \"pointer-set.h\"\n+\f\n+/* Information about a strength reduction candidate.  Each statement\n+   in the candidate table represents an expression of one of the\n+   following forms (the special case of CAND_REF will be described\n+   later):\n+\n+   (CAND_MULT)  S1:  X = (B + i) * S\n+   (CAND_ADD)   S1:  X = B + (i * S)\n+\n+   Here X and B are SSA names, i is an integer constant, and S is\n+   either an SSA name or a constant.  We call B the \"base,\" i the\n+   \"index\", and S the \"stride.\"\n+\n+   Any statement S0 that dominates S1 and is of the form:\n+\n+   (CAND_MULT)  S0:  Y = (B + i') * S\n+   (CAND_ADD)   S0:  Y = B + (i' * S)\n+\n+   is called a \"basis\" for S1.  In both cases, S1 may be replaced by\n+   \n+                S1':  X = Y + (i - i') * S,\n+\n+   where (i - i') * S is folded to the extent possible.\n+\n+   All gimple statements are visited in dominator order, and each\n+   statement that may contribute to one of the forms of S1 above is\n+   given at least one entry in the candidate table.  Such statements\n+   include addition, pointer addition, subtraction, multiplication,\n+   negation, copies, and nontrivial type casts.  If a statement may\n+   represent more than one expression of the forms of S1 above, \n+   multiple \"interpretations\" are stored in the table and chained\n+   together.  Examples:\n+\n+   * An add of two SSA names may treat either operand as the base.\n+   * A multiply of two SSA names, likewise.\n+   * A copy or cast may be thought of as either a CAND_MULT with\n+     i = 0 and S = 1, or as a CAND_ADD with i = 0 or S = 0.\n+\n+   Candidate records are allocated from an obstack.  They are addressed\n+   both from a hash table keyed on S1, and from a vector of candidate\n+   pointers arranged in predominator order.\n+\n+   Opportunity note\n+   ----------------\n+   Currently we don't recognize:\n+\n+     S0: Y = (S * i') - B\n+     S1: X = (S * i) - B\n+\n+   as a strength reduction opportunity, even though this S1 would\n+   also be replaceable by the S1' above.  This can be added if it\n+   comes up in practice.  */\n+\n+\n+/* Index into the candidate vector, offset by 1.  VECs are zero-based,\n+   while cand_idx's are one-based, with zero indicating null.  */\n+typedef unsigned cand_idx;\n+\n+/* The kind of candidate.  */\n+enum cand_kind\n+{\n+  CAND_MULT,\n+  CAND_ADD\n+};\n+\n+struct slsr_cand_d\n+{\n+  /* The candidate statement S1.  */\n+  gimple cand_stmt;\n+\n+  /* The base SSA name B.  */\n+  tree base_name;\n+\n+  /* The stride S.  */\n+  tree stride;\n+\n+  /* The index constant i.  */\n+  double_int index;\n+\n+  /* The type of the candidate.  This is normally the type of base_name,\n+     but casts may have occurred when combining feeding instructions.\n+     A candidate can only be a basis for candidates of the same final type.  */\n+  tree cand_type;\n+\n+  /* The kind of candidate (CAND_MULT, etc.).  */\n+  enum cand_kind kind;\n+\n+  /* Index of this candidate in the candidate vector.  */\n+  cand_idx cand_num;\n+\n+  /* Index of the next candidate record for the same statement.\n+     A statement may be useful in more than one way (e.g., due to\n+     commutativity).  So we can have multiple \"interpretations\"\n+     of a statement.  */\n+  cand_idx next_interp;\n+\n+  /* Index of the basis statement S0, if any, in the candidate vector.  */\n+  cand_idx basis;\n+\n+  /* First candidate for which this candidate is a basis, if one exists.  */\n+  cand_idx dependent;\n+\n+  /* Next candidate having the same basis as this one.  */\n+  cand_idx sibling;\n+\n+  /* If this is a conditional candidate, the defining PHI statement\n+     for the base SSA name B.  For future use; always NULL for now.  */\n+  gimple def_phi;\n+\n+  /* Savings that can be expected from eliminating dead code if this\n+     candidate is replaced.  */\n+  int dead_savings;\n+};\n+\n+typedef struct slsr_cand_d slsr_cand, *slsr_cand_t;\n+typedef const struct slsr_cand_d *const_slsr_cand_t;\n+\n+/* Pointers to candidates are chained together as part of a mapping\n+   from SSA names to the candidates that use them as a base name.  */\n+\n+struct cand_chain_d\n+{\n+  /* SSA name that serves as a base name for the chain of candidates.  */\n+  tree base_name;\n+\n+  /* Pointer to a candidate.  */\n+  slsr_cand_t cand;\n+\n+  /* Chain pointer.  */\n+  struct cand_chain_d *next;\n+\n+};\n+\n+typedef struct cand_chain_d cand_chain, *cand_chain_t;\n+typedef const struct cand_chain_d *const_cand_chain_t;\n+\n+/* Candidates are maintained in a vector.  If candidate X dominates\n+   candidate Y, then X appears before Y in the vector; but the\n+   converse does not necessarily hold.  */\n+DEF_VEC_P (slsr_cand_t);\n+DEF_VEC_ALLOC_P (slsr_cand_t, heap);\n+static VEC (slsr_cand_t, heap) *cand_vec;\n+\n+enum cost_consts\n+{\n+  COST_NEUTRAL = 0,\n+  COST_INFINITE = 1000\n+};\n+\n+/* Pointer map embodying a mapping from statements to candidates.  */\n+static struct pointer_map_t *stmt_cand_map;\n+\n+/* Obstack for candidates.  */\n+static struct obstack cand_obstack;\n+\n+/* Array mapping from base SSA names to chains of candidates.  */\n+static cand_chain_t *base_cand_map;\n+\n+/* Obstack for candidate chains.  */\n+static struct obstack chain_obstack;\n+\f\n+/* Produce a pointer to the IDX'th candidate in the candidate vector.  */\n+\n+static slsr_cand_t\n+lookup_cand (cand_idx idx)\n+{\n+  return VEC_index (slsr_cand_t, cand_vec, idx - 1);\n+}\n+\n+/* Use the base name from candidate C to look for possible candidates\n+   that can serve as a basis for C.  Each potential basis must also\n+   appear in a block that dominates the candidate statement and have\n+   the same stride and type.  If more than one possible basis exists,\n+   the one with highest index in the vector is chosen; this will be\n+   the most immediately dominating basis.  */\n+\n+static int\n+find_basis_for_candidate (slsr_cand_t c)\n+{\n+  cand_chain_t chain;\n+  slsr_cand_t basis = NULL;\n+\n+  gcc_assert (TREE_CODE (c->base_name) == SSA_NAME);\n+  chain = base_cand_map[SSA_NAME_VERSION (c->base_name)];\n+\n+  for (; chain; chain = chain->next)\n+    {\n+      slsr_cand_t one_basis = chain->cand;\n+\n+      if (one_basis->kind != c->kind\n+\t  || !operand_equal_p (one_basis->stride, c->stride, 0)\n+\t  || !types_compatible_p (one_basis->cand_type, c->cand_type)\n+\t  || !dominated_by_p (CDI_DOMINATORS,\n+\t\t\t      gimple_bb (c->cand_stmt),\n+\t\t\t      gimple_bb (one_basis->cand_stmt)))\n+\tcontinue;\n+\n+      if (!basis || basis->cand_num < one_basis->cand_num)\n+\tbasis = one_basis;\n+    }\n+\n+  if (basis)\n+    {\n+      c->sibling = basis->dependent;\n+      basis->dependent = c->cand_num;\n+      return basis->cand_num;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Record a mapping from the base name of C to C itself, indicating that\n+   C may potentially serve as a basis using that base name.  */\n+\n+static void\n+record_potential_basis (slsr_cand_t c)\n+{\n+  cand_chain_t node, head;\n+  int index;\n+\n+  node = (cand_chain_t) obstack_alloc (&chain_obstack, sizeof (cand_chain));\n+  node->base_name = c->base_name;\n+  node->cand = c;\n+  node->next = NULL;\n+  index = SSA_NAME_VERSION (c->base_name);\n+  head = base_cand_map[index];\n+\n+  if (head)\n+    {\n+      node->next = head->next;\n+      head->next = node;\n+    }\n+  else\n+    base_cand_map[index] = node;\n+}\n+\n+/* Allocate storage for a new candidate and initialize its fields.\n+   Attempt to find a basis for the candidate.  */\n+\n+static slsr_cand_t\n+alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base, \n+\t\t\t   double_int index, tree stride, tree ctype,\n+\t\t\t   unsigned savings)\n+{\n+  slsr_cand_t c = (slsr_cand_t) obstack_alloc (&cand_obstack,\n+\t\t\t\t\t       sizeof (slsr_cand));\n+  c->cand_stmt = gs;\n+  c->base_name = base;\n+  c->stride = stride;\n+  c->index = index;\n+  c->cand_type = ctype;\n+  c->kind = kind;\n+  c->cand_num = VEC_length (slsr_cand_t, cand_vec) + 1;\n+  c->next_interp = 0;\n+  c->dependent = 0;\n+  c->sibling = 0;\n+  c->def_phi = NULL;\n+  c->dead_savings = savings;\n+\n+  VEC_safe_push (slsr_cand_t, heap, cand_vec, c);\n+  c->basis = find_basis_for_candidate (c);\n+  record_potential_basis (c);\n+\n+  return c;\n+}\n+\n+/* Determine the target cost of statement GS when compiling according\n+   to SPEED.  */\n+\n+static int\n+stmt_cost (gimple gs, bool speed)\n+{\n+  tree lhs, rhs1, rhs2;\n+  enum machine_mode lhs_mode;\n+\n+  gcc_assert (is_gimple_assign (gs));\n+  lhs = gimple_assign_lhs (gs);\n+  rhs1 = gimple_assign_rhs1 (gs);\n+  lhs_mode = TYPE_MODE (TREE_TYPE (lhs));\n+  \n+  switch (gimple_assign_rhs_code (gs))\n+    {\n+    case MULT_EXPR:\n+      rhs2 = gimple_assign_rhs2 (gs);\n+\n+      if (host_integerp (rhs2, 0))\n+\treturn multiply_by_const_cost (TREE_INT_CST_LOW (rhs2), lhs_mode,\n+\t\t\t\t       speed);\n+\n+      gcc_assert (TREE_CODE (rhs1) != INTEGER_CST);\n+      return multiply_regs_cost (TYPE_MODE (TREE_TYPE (lhs)), speed);\n+\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case MINUS_EXPR:\n+      rhs2 = gimple_assign_rhs2 (gs);\n+\n+      if (host_integerp (rhs2, 0))\n+\treturn add_const_cost (TYPE_MODE (TREE_TYPE (rhs1)), speed);\n+\n+      gcc_assert (TREE_CODE (rhs1) != INTEGER_CST);\n+      return add_regs_cost (lhs_mode, speed);\n+\n+    case NEGATE_EXPR:\n+      return negate_reg_cost (lhs_mode, speed);\n+\n+    case NOP_EXPR:\n+      return extend_or_trunc_reg_cost (TREE_TYPE (lhs), TREE_TYPE (rhs1),\n+\t\t\t\t       speed);\n+\n+    /* Note that we don't assign costs to copies that in most cases\n+       will go away.  */\n+    default:\n+      ;\n+    }\n+  \n+  gcc_unreachable ();\n+  return 0;\n+}\n+\n+/* Look up the defining statement for BASE_IN and return a pointer\n+   to its candidate in the candidate table, if any; otherwise NULL.\n+   Only CAND_ADD and CAND_MULT candidates are returned.  */\n+\n+static slsr_cand_t\n+base_cand_from_table (tree base_in)\n+{\n+  slsr_cand_t *result;\n+\n+  gimple def = SSA_NAME_DEF_STMT (base_in);\n+  if (!def)\n+    return (slsr_cand_t) NULL;\n+\n+  result = (slsr_cand_t *) pointer_map_contains (stmt_cand_map, def);\n+  if (!result)\n+    return (slsr_cand_t) NULL;\n+\n+  return *result;\n+}\n+\n+/* Add an entry to the statement-to-candidate mapping.  */\n+\n+static void\n+add_cand_for_stmt (gimple gs, slsr_cand_t c)\n+{\n+  void **slot = pointer_map_insert (stmt_cand_map, gs);\n+  gcc_assert (!*slot);\n+  *slot = c;\n+}\n+\f\n+/* Create a candidate entry for a statement GS, where GS multiplies\n+   two SSA names BASE_IN and STRIDE_IN.  Propagate any known information\n+   about the two SSA names into the new candidate.  Return the new\n+   candidate.  */\n+\n+static slsr_cand_t\n+create_mul_ssa_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n+{\n+  tree base = NULL_TREE, stride = NULL_TREE, ctype = NULL_TREE;\n+  double_int index;\n+  unsigned savings = 0;\n+  slsr_cand_t c;\n+  slsr_cand_t base_cand = base_cand_from_table (base_in);\n+\n+  /* Look at all interpretations of the base candidate, if necessary,\n+     to find information to propagate into this candidate.  */\n+  while (base_cand && !base)\n+    {\n+\n+      if (base_cand->kind == CAND_MULT\n+\t  && operand_equal_p (base_cand->stride, integer_one_node, 0))\n+\t{\n+\t  /* Y = (B + i') * 1\n+\t     X = Y * Z\n+\t     ================\n+\t     X = (B + i') * Z  */\n+\t  base = base_cand->base_name;\n+\t  index = base_cand->index;\n+\t  stride = stride_in;\n+\t  ctype = base_cand->cand_type;\n+\t  if (has_single_use (base_in))\n+\t    savings = (base_cand->dead_savings \n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\t}\n+      else if (base_cand->kind == CAND_ADD\n+\t       && TREE_CODE (base_cand->stride) == INTEGER_CST)\n+\t{\n+\t  /* Y = B + (i' * S), S constant\n+\t     X = Y * Z\n+\t     ============================\n+\t     X = B + ((i' * S) * Z)  */\n+\t  base = base_cand->base_name;\n+\t  index = double_int_mul (base_cand->index,\n+\t\t\t\t  tree_to_double_int (base_cand->stride));\n+\t  stride = stride_in;\n+\t  ctype = base_cand->cand_type;\n+\t  if (has_single_use (base_in))\n+\t    savings = (base_cand->dead_savings\n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\t}\n+\n+      if (base_cand->next_interp)\n+\tbase_cand = lookup_cand (base_cand->next_interp);\n+      else\n+\tbase_cand = NULL;\n+    }\n+\n+  if (!base)\n+    {\n+      /* No interpretations had anything useful to propagate, so\n+\t produce X = (Y + 0) * Z.  */\n+      base = base_in;\n+      index = double_int_zero;\n+      stride = stride_in;\n+      ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n+    }\n+\n+  c = alloc_cand_and_find_basis (CAND_MULT, gs, base, index, stride,\n+\t\t\t\t ctype, savings);\n+  return c;\n+}\n+\n+/* Create a candidate entry for a statement GS, where GS multiplies\n+   SSA name BASE_IN by constant STRIDE_IN.  Propagate any known\n+   information about BASE_IN into the new candidate.  Return the new\n+   candidate.  */\n+\n+static slsr_cand_t\n+create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n+{\n+  tree base = NULL_TREE, stride = NULL_TREE, ctype = NULL_TREE;\n+  double_int index, temp;\n+  unsigned savings = 0;\n+  slsr_cand_t c;\n+  slsr_cand_t base_cand = base_cand_from_table (base_in);\n+\n+  /* Look at all interpretations of the base candidate, if necessary,\n+     to find information to propagate into this candidate.  */\n+  while (base_cand && !base)\n+    {\n+      if (base_cand->kind == CAND_MULT\n+\t  && TREE_CODE (base_cand->stride) == INTEGER_CST)\n+\t{\n+\t  /* Y = (B + i') * S, S constant\n+\t     X = Y * c\n+\t     ============================\n+\t     X = (B + i') * (S * c)  */\n+\t  base = base_cand->base_name;\n+\t  index = base_cand->index;\n+\t  temp = double_int_mul (tree_to_double_int (base_cand->stride),\n+\t\t\t\t tree_to_double_int (stride_in));\n+\t  stride = double_int_to_tree (TREE_TYPE (stride_in), temp);\n+\t  ctype = base_cand->cand_type;\n+\t  if (has_single_use (base_in))\n+\t    savings = (base_cand->dead_savings \n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\t}\n+      else if (base_cand->kind == CAND_ADD\n+\t       && operand_equal_p (base_cand->stride, integer_one_node, 0))\n+\t{\n+\t  /* Y = B + (i' * 1)\n+\t     X = Y * c\n+\t     ===========================\n+\t     X = (B + i') * c  */\n+\t  base = base_cand->base_name;\n+\t  index = base_cand->index;\n+\t  stride = stride_in;\n+\t  ctype = base_cand->cand_type;\n+\t  if (has_single_use (base_in))\n+\t    savings = (base_cand->dead_savings\n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\t}\n+      else if (base_cand->kind == CAND_ADD\n+\t       && double_int_one_p (base_cand->index)\n+\t       && TREE_CODE (base_cand->stride) == INTEGER_CST)\n+\t{\n+\t  /* Y = B + (1 * S), S constant\n+\t     X = Y * c\n+\t     ===========================\n+\t     X = (B + S) * c  */\n+\t  base = base_cand->base_name;\n+\t  index = tree_to_double_int (base_cand->stride);\n+\t  stride = stride_in;\n+\t  ctype = base_cand->cand_type;\n+\t  if (has_single_use (base_in))\n+\t    savings = (base_cand->dead_savings\n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\t}\n+\n+      if (base_cand->next_interp)\n+\tbase_cand = lookup_cand (base_cand->next_interp);\n+      else\n+\tbase_cand = NULL;\n+    }\n+\n+  if (!base)\n+    {\n+      /* No interpretations had anything useful to propagate, so\n+\t produce X = (Y + 0) * c.  */\n+      base = base_in;\n+      index = double_int_zero;\n+      stride = stride_in;\n+      ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n+    }\n+\n+  c = alloc_cand_and_find_basis (CAND_MULT, gs, base, index, stride,\n+\t\t\t\t ctype, savings);\n+  return c;\n+}\n+\n+/* Given GS which is a multiply of scalar integers, make an appropriate\n+   entry in the candidate table.  If this is a multiply of two SSA names,\n+   create two CAND_MULT interpretations and attempt to find a basis for\n+   each of them.  Otherwise, create a single CAND_MULT and attempt to\n+   find a basis.  */\n+\n+static void\n+slsr_process_mul (gimple gs, tree rhs1, tree rhs2, bool speed)\n+{\n+  slsr_cand_t c, c2;\n+\n+  /* If this is a multiply of an SSA name with itself, it is highly\n+     unlikely that we will get a strength reduction opportunity, so\n+     don't record it as a candidate.  This simplifies the logic for\n+     finding a basis, so if this is removed that must be considered.  */\n+  if (rhs1 == rhs2)\n+    return;\n+\n+  if (TREE_CODE (rhs2) == SSA_NAME)\n+    {\n+      /* Record an interpretation of this statement in the candidate table\n+\t assuming RHS1 is the base name and RHS2 is the stride.  */\n+      c = create_mul_ssa_cand (gs, rhs1, rhs2, speed);\n+\n+      /* Add the first interpretation to the statement-candidate mapping.  */\n+      add_cand_for_stmt (gs, c);\n+\n+      /* Record another interpretation of this statement assuming RHS1\n+\t is the stride and RHS2 is the base name.  */\n+      c2 = create_mul_ssa_cand (gs, rhs2, rhs1, speed);\n+      c->next_interp = c2->cand_num;\n+    }\n+  else\n+    {\n+      /* Record an interpretation for the multiply-immediate.  */\n+      c = create_mul_imm_cand (gs, rhs1, rhs2, speed);\n+\n+      /* Add the interpretation to the statement-candidate mapping.  */\n+      add_cand_for_stmt (gs, c);\n+    }\n+}\n+\n+/* Create a candidate entry for a statement GS, where GS adds two\n+   SSA names BASE_IN and ADDEND_IN if SUBTRACT_P is false, and\n+   subtracts ADDEND_IN from BASE_IN otherwise.  Propagate any known\n+   information about the two SSA names into the new candidate.\n+   Return the new candidate.  */\n+\n+static slsr_cand_t\n+create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n+\t\t     bool subtract_p, bool speed)\n+{\n+  tree base = NULL_TREE, stride = NULL_TREE, ctype = NULL;\n+  double_int index;\n+  unsigned savings = 0;\n+  slsr_cand_t c;\n+  slsr_cand_t base_cand = base_cand_from_table (base_in);\n+  slsr_cand_t addend_cand = base_cand_from_table (addend_in);\n+\n+  /* The most useful transformation is a multiply-immediate feeding\n+     an add or subtract.  Look for that first.  */\n+  while (addend_cand && !base)\n+    {\n+      if (addend_cand->kind == CAND_MULT\n+\t  && double_int_zero_p (addend_cand->index)\n+\t  && TREE_CODE (addend_cand->stride) == INTEGER_CST)\n+\t{\n+\t  /* Z = (B + 0) * S, S constant\n+\t     X = Y +/- Z\n+\t     ===========================\n+\t     X = Y + ((+/-1 * S) * B)  */\n+\t  base = base_in;\n+\t  index = tree_to_double_int (addend_cand->stride);\n+\t  if (subtract_p)\n+\t    index = double_int_neg (index);\n+\t  stride = addend_cand->base_name;\n+\t  ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n+\t  if (has_single_use (addend_in))\n+\t    savings = (addend_cand->dead_savings\n+\t\t       + stmt_cost (addend_cand->cand_stmt, speed));\n+\t}\n+\n+      if (addend_cand->next_interp)\n+\taddend_cand = lookup_cand (addend_cand->next_interp);\n+      else\n+\taddend_cand = NULL;\n+    }\n+\n+  while (base_cand && !base)\n+    {\n+      if (base_cand->kind == CAND_ADD\n+\t  && (double_int_zero_p (base_cand->index)\n+\t      || operand_equal_p (base_cand->stride,\n+\t\t\t\t  integer_zero_node, 0)))\n+\t{\n+\t  /* Y = B + (i' * S), i' * S = 0\n+\t     X = Y +/- Z\n+\t     ============================\n+\t     X = B + (+/-1 * Z)  */\n+\t  base = base_cand->base_name;\n+\t  index = subtract_p ? double_int_minus_one : double_int_one;\n+\t  stride = addend_in;\n+\t  ctype = base_cand->cand_type;\n+\t  if (has_single_use (base_in))\n+\t    savings = (base_cand->dead_savings\n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\t}\n+      else if (subtract_p)\n+\t{\n+\t  slsr_cand_t subtrahend_cand = base_cand_from_table (addend_in);\n+\n+\t  while (subtrahend_cand && !base)\n+\t    {\n+\t      if (subtrahend_cand->kind == CAND_MULT\n+\t\t  && double_int_zero_p (subtrahend_cand->index)\n+\t\t  && TREE_CODE (subtrahend_cand->stride) == INTEGER_CST)\n+\t\t{\n+\t\t  /* Z = (B + 0) * S, S constant\n+\t\t     X = Y - Z\n+\t\t     ===========================\n+\t\t     Value:  X = Y + ((-1 * S) * B)  */\n+\t\t  base = base_in;\n+\t\t  index = tree_to_double_int (subtrahend_cand->stride);\n+\t\t  index = double_int_neg (index);\n+\t\t  stride = subtrahend_cand->base_name;\n+\t\t  ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n+\t\t  if (has_single_use (addend_in))\n+\t\t    savings = (subtrahend_cand->dead_savings \n+\t\t\t       + stmt_cost (subtrahend_cand->cand_stmt, speed));\n+\t\t}\n+\t      \n+\t      if (subtrahend_cand->next_interp)\n+\t\tsubtrahend_cand = lookup_cand (subtrahend_cand->next_interp);\n+\t      else\n+\t\tsubtrahend_cand = NULL;\n+\t    }\n+\t}\n+      \n+      if (base_cand->next_interp)\n+\tbase_cand = lookup_cand (base_cand->next_interp);\n+      else\n+\tbase_cand = NULL;\n+    }\n+\n+  if (!base)\n+    {\n+      /* No interpretations had anything useful to propagate, so\n+\t produce X = Y + (1 * Z).  */\n+      base = base_in;\n+      index = subtract_p ? double_int_minus_one : double_int_one;\n+      stride = addend_in;\n+      ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n+    }\n+\n+  c = alloc_cand_and_find_basis (CAND_ADD, gs, base, index, stride,\n+\t\t\t\t ctype, savings);\n+  return c;\n+}\n+\n+/* Create a candidate entry for a statement GS, where GS adds SSA\n+   name BASE_IN to constant INDEX_IN.  Propagate any known information\n+   about BASE_IN into the new candidate.  Return the new candidate.  */\n+\n+static slsr_cand_t\n+create_add_imm_cand (gimple gs, tree base_in, double_int index_in, bool speed)\n+{\n+  enum cand_kind kind = CAND_ADD;\n+  tree base = NULL_TREE, stride = NULL_TREE, ctype = NULL_TREE;\n+  double_int index, multiple;\n+  unsigned savings = 0;\n+  slsr_cand_t c;\n+  slsr_cand_t base_cand = base_cand_from_table (base_in);\n+\n+  while (base_cand && !base)\n+    {\n+      bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (base_cand->stride));\n+\n+      if (TREE_CODE (base_cand->stride) == INTEGER_CST\n+\t  && double_int_multiple_of (index_in,\n+\t\t\t\t     tree_to_double_int (base_cand->stride),\n+\t\t\t\t     unsigned_p,\n+\t\t\t\t     &multiple))\n+\t{\n+\t  /* Y = (B + i') * S, S constant, c = kS for some integer k\n+\t     X = Y + c\n+\t     ============================\n+\t     X = (B + (i'+ k)) * S  \n+\t  OR\n+\t     Y = B + (i' * S), S constant, c = kS for some integer k\n+\t     X = Y + c\n+\t     ============================\n+\t     X = (B + (i'+ k)) * S  */\n+\t  kind = base_cand->kind;\n+\t  base = base_cand->base_name;\n+\t  index = double_int_add (base_cand->index, multiple);\n+\t  stride = base_cand->stride;\n+\t  ctype = base_cand->cand_type;\n+\t  if (has_single_use (base_in))\n+\t    savings = (base_cand->dead_savings \n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\t}\n+\n+      if (base_cand->next_interp)\n+\tbase_cand = lookup_cand (base_cand->next_interp);\n+      else\n+\tbase_cand = NULL;\n+    }\n+\n+  if (!base)\n+    {\n+      /* No interpretations had anything useful to propagate, so\n+\t produce X = Y + (c * 1).  */\n+      kind = CAND_ADD;\n+      base = base_in;\n+      index = index_in;\n+      stride = integer_one_node;\n+      ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n+    }\n+\n+  c = alloc_cand_and_find_basis (kind, gs, base, index, stride,\n+\t\t\t\t ctype, savings);\n+  return c;\n+}\n+\n+/* Given GS which is an add or subtract of scalar integers or pointers,\n+   make at least one appropriate entry in the candidate table.  */\n+\n+static void\n+slsr_process_add (gimple gs, tree rhs1, tree rhs2, bool speed)\n+{\n+  bool subtract_p = gimple_assign_rhs_code (gs) == MINUS_EXPR;\n+  slsr_cand_t c = NULL, c2;\n+\n+  if (TREE_CODE (rhs2) == SSA_NAME)\n+    {\n+      /* First record an interpretation assuming RHS1 is the base name\n+\t and RHS2 is the stride.  But it doesn't make sense for the\n+\t stride to be a pointer, so don't record a candidate in that case.  */\n+      if (!POINTER_TYPE_P (TREE_TYPE (SSA_NAME_VAR (rhs2))))\n+\t{\n+\t  c = create_add_ssa_cand (gs, rhs1, rhs2, subtract_p, speed);\n+\n+\t  /* Add the first interpretation to the statement-candidate\n+\t     mapping.  */\n+\t  add_cand_for_stmt (gs, c);\n+\t}\n+\n+      /* If the two RHS operands are identical, or this is a subtract,\n+\t we're done.  */\n+      if (operand_equal_p (rhs1, rhs2, 0) || subtract_p)\n+\treturn;\n+\n+      /* Otherwise, record another interpretation assuming RHS2 is the\n+\t base name and RHS1 is the stride, again provided that the\n+\t stride is not a pointer.  */\n+      if (!POINTER_TYPE_P (TREE_TYPE (SSA_NAME_VAR (rhs1))))\n+\t{\n+\t  c2 = create_add_ssa_cand (gs, rhs2, rhs1, false, speed);\n+\t  if (c)\n+\t    c->next_interp = c2->cand_num;\n+\t  else\n+\t    add_cand_for_stmt (gs, c2);\n+\t}\n+    }\n+  else\n+    {\n+      double_int index;\n+\n+      /* Record an interpretation for the add-immediate.  */\n+      index = tree_to_double_int (rhs2);\n+      if (subtract_p)\n+\tindex = double_int_neg (index);\n+\n+      c = create_add_imm_cand (gs, rhs1, index, speed);\n+\n+      /* Add the interpretation to the statement-candidate mapping.  */\n+      add_cand_for_stmt (gs, c);\n+    }\n+}\n+\n+/* Given GS which is a negate of a scalar integer, make an appropriate\n+   entry in the candidate table.  A negate is equivalent to a multiply\n+   by -1.  */\n+\n+static void\n+slsr_process_neg (gimple gs, tree rhs1, bool speed)\n+{\n+  /* Record a CAND_MULT interpretation for the multiply by -1.  */\n+  slsr_cand_t c = create_mul_imm_cand (gs, rhs1, integer_minus_one_node, speed);\n+\n+  /* Add the interpretation to the statement-candidate mapping.  */\n+  add_cand_for_stmt (gs, c);\n+}\n+\n+/* Return TRUE if GS is a statement that defines an SSA name from\n+   a conversion and is legal for us to combine with an add and multiply\n+   in the candidate table.  For example, suppose we have:\n+\n+     A = B + i;\n+     C = (type) A;\n+     D = C * S;\n+\n+   Without the type-cast, we would create a CAND_MULT for D with base B,\n+   index i, and stride S.  We want to record this candidate only if it\n+   is equivalent to apply the type cast following the multiply:\n+\n+     A = B + i;\n+     E = A * S;\n+     D = (type) E;\n+\n+   We will record the type with the candidate for D.  This allows us\n+   to use a similar previous candidate as a basis.  If we have earlier seen\n+\n+     A' = B + i';\n+     C' = (type) A';\n+     D' = C' * S;\n+\n+   we can replace D with\n+\n+     D = D' + (i - i') * S;\n+\n+   But if moving the type-cast would change semantics, we mustn't do this.\n+\n+   This is legitimate for casts from a non-wrapping integral type to\n+   any integral type of the same or larger size.  It is not legitimate\n+   to convert a wrapping type to a non-wrapping type, or to a wrapping\n+   type of a different size.  I.e., with a wrapping type, we must\n+   assume that the addition B + i could wrap, in which case performing\n+   the multiply before or after one of the \"illegal\" type casts will\n+   have different semantics.  */\n+\n+static bool\n+legal_cast_p (gimple gs, tree rhs)\n+{\n+  tree lhs, lhs_type, rhs_type;\n+  unsigned lhs_size, rhs_size;\n+  bool lhs_wraps, rhs_wraps;\n+\n+  if (!is_gimple_assign (gs)\n+      || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (gs)))\n+    return false;\n+\n+  lhs = gimple_assign_lhs (gs);\n+  lhs_type = TREE_TYPE (lhs);\n+  rhs_type = TREE_TYPE (rhs);\n+  lhs_size = TYPE_PRECISION (lhs_type);\n+  rhs_size = TYPE_PRECISION (rhs_type);\n+  lhs_wraps = TYPE_OVERFLOW_WRAPS (lhs_type);\n+  rhs_wraps = TYPE_OVERFLOW_WRAPS (rhs_type);\n+\n+  if (lhs_size < rhs_size\n+      || (rhs_wraps && !lhs_wraps)\n+      || (rhs_wraps && lhs_wraps && rhs_size != lhs_size))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Given GS which is a cast to a scalar integer type, determine whether\n+   the cast is legal for strength reduction.  If so, make at least one\n+   appropriate entry in the candidate table.  */\n+\n+static void\n+slsr_process_cast (gimple gs, tree rhs1, bool speed)\n+{\n+  tree lhs, ctype;\n+  slsr_cand_t base_cand, c, c2;\n+  unsigned savings = 0;\n+\n+  if (!legal_cast_p (gs, rhs1))\n+    return;\n+\n+  lhs = gimple_assign_lhs (gs);\n+  base_cand = base_cand_from_table (rhs1);\n+  ctype = TREE_TYPE (lhs);\n+\n+  if (base_cand)\n+    {\n+      while (base_cand)\n+\t{\n+\t  /* Propagate all data from the base candidate except the type,\n+\t     which comes from the cast, and the base candidate's cast,\n+\t     which is no longer applicable.  */\n+\t  if (has_single_use (rhs1))\n+\t    savings = (base_cand->dead_savings \n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\n+\t  c = alloc_cand_and_find_basis (base_cand->kind, gs,\n+\t\t\t\t\t base_cand->base_name,\n+\t\t\t\t\t base_cand->index, base_cand->stride,\n+\t\t\t\t\t ctype, savings);\n+\t  if (base_cand->next_interp)\n+\t    base_cand = lookup_cand (base_cand->next_interp);\n+\t  else\n+\t    base_cand = NULL;\n+\t}\n+    }\n+  else \n+    {\n+      /* If nothing is known about the RHS, create fresh CAND_ADD and\n+\t CAND_MULT interpretations:\n+\n+\t X = Y + (0 * 1)\n+\t X = (Y + 0) * 1\n+\n+\t The first of these is somewhat arbitrary, but the choice of\n+\t 1 for the stride simplifies the logic for propagating casts\n+\t into their uses.  */\n+      c = alloc_cand_and_find_basis (CAND_ADD, gs, rhs1, double_int_zero,\n+\t\t\t\t     integer_one_node, ctype, 0);\n+      c2 = alloc_cand_and_find_basis (CAND_MULT, gs, rhs1, double_int_zero,\n+\t\t\t\t      integer_one_node, ctype, 0);\n+      c->next_interp = c2->cand_num;\n+    }\n+\n+  /* Add the first (or only) interpretation to the statement-candidate\n+     mapping.  */\n+  add_cand_for_stmt (gs, c);\n+}\n+\n+/* Given GS which is a copy of a scalar integer type, make at least one\n+   appropriate entry in the candidate table.\n+\n+   This interface is included for completeness, but is unnecessary\n+   if this pass immediately follows a pass that performs copy \n+   propagation, such as DOM.  */\n+\n+static void\n+slsr_process_copy (gimple gs, tree rhs1, bool speed)\n+{\n+  slsr_cand_t base_cand, c, c2;\n+  unsigned savings = 0;\n+\n+  base_cand = base_cand_from_table (rhs1);\n+\n+  if (base_cand)\n+    {\n+      while (base_cand)\n+\t{\n+\t  /* Propagate all data from the base candidate.  */\n+\t  if (has_single_use (rhs1))\n+\t    savings = (base_cand->dead_savings \n+\t\t       + stmt_cost (base_cand->cand_stmt, speed));\n+\n+\t  c = alloc_cand_and_find_basis (base_cand->kind, gs,\n+\t\t\t\t\t base_cand->base_name,\n+\t\t\t\t\t base_cand->index, base_cand->stride,\n+\t\t\t\t\t base_cand->cand_type, savings);\n+\t  if (base_cand->next_interp)\n+\t    base_cand = lookup_cand (base_cand->next_interp);\n+\t  else\n+\t    base_cand = NULL;\n+\t}\n+    }\n+  else \n+    {\n+      /* If nothing is known about the RHS, create fresh CAND_ADD and\n+\t CAND_MULT interpretations:\n+\n+\t X = Y + (0 * 1)\n+\t X = (Y + 0) * 1\n+\n+\t The first of these is somewhat arbitrary, but the choice of\n+\t 1 for the stride simplifies the logic for propagating casts\n+\t into their uses.  */\n+      c = alloc_cand_and_find_basis (CAND_ADD, gs, rhs1, double_int_zero,\n+\t\t\t\t     integer_one_node, TREE_TYPE (rhs1), 0);\n+      c2 = alloc_cand_and_find_basis (CAND_MULT, gs, rhs1, double_int_zero,\n+\t\t\t\t      integer_one_node, TREE_TYPE (rhs1), 0);\n+      c->next_interp = c2->cand_num;\n+    }\n+\n+  /* Add the first (or only) interpretation to the statement-candidate\n+     mapping.  */\n+  add_cand_for_stmt (gs, c);\n+}\n+\f\n+/* Find strength-reduction candidates in block BB.  */\n+\n+static void\n+find_candidates_in_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t  basic_block bb)\n+{\n+  bool speed = optimize_bb_for_speed_p (bb);\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple gs = gsi_stmt (gsi);\n+\n+      if (is_gimple_assign (gs)\n+\t  && SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (gimple_assign_lhs (gs)))))\n+\t{\n+\t  tree rhs1 = NULL_TREE, rhs2 = NULL_TREE;\n+\n+\t  switch (gimple_assign_rhs_code (gs))\n+\t    {\n+\t    case MULT_EXPR:\n+\t    case PLUS_EXPR:\n+\t      rhs1 = gimple_assign_rhs1 (gs);\n+\t      rhs2 = gimple_assign_rhs2 (gs);\n+\t      /* Should never happen, but currently some buggy situations\n+\t\t in earlier phases put constants in rhs1.  */\n+\t      if (TREE_CODE (rhs1) != SSA_NAME)\n+\t\tcontinue;\n+\t      break;\n+\n+\t    /* Possible future opportunity: rhs1 of a ptr+ can be\n+\t       an ADDR_EXPR.  */\n+\t    case POINTER_PLUS_EXPR:\n+\t    case MINUS_EXPR:\n+\t      rhs2 = gimple_assign_rhs2 (gs);\n+\t      /* Fall-through.  */\n+\n+\t    case NOP_EXPR:\n+\t    case MODIFY_EXPR:\n+\t    case NEGATE_EXPR:\n+\t      rhs1 = gimple_assign_rhs1 (gs);\n+\t      if (TREE_CODE (rhs1) != SSA_NAME)\n+\t\tcontinue;\n+\t      break;\n+\n+\t    default:\n+\t      ;\n+\t    }\n+\n+\t  switch (gimple_assign_rhs_code (gs))\n+\t    {\n+\t    case MULT_EXPR:\n+\t      slsr_process_mul (gs, rhs1, rhs2, speed);\n+\t      break;\n+\n+\t    case PLUS_EXPR:\n+\t    case POINTER_PLUS_EXPR:\n+\t    case MINUS_EXPR:\n+\t      slsr_process_add (gs, rhs1, rhs2, speed);\n+\t      break;\n+\n+\t    case NEGATE_EXPR:\n+\t      slsr_process_neg (gs, rhs1, speed);\n+\t      break;\n+\n+\t    case NOP_EXPR:\n+\t      slsr_process_cast (gs, rhs1, speed);\n+\t      break;\n+\n+\t    case MODIFY_EXPR:\n+\t      slsr_process_copy (gs, rhs1, speed);\n+\t      break;\n+\n+\t    default:\n+\t      ;\n+\t    }\n+\t}\n+    }\n+}\n+\f\n+/* Dump a candidate for debug.  */\n+\n+static void\n+dump_candidate (slsr_cand_t c)\n+{\n+  fprintf (dump_file, \"%3d  [%d] \", c->cand_num,\n+\t   gimple_bb (c->cand_stmt)->index);\n+  print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);\n+  switch (c->kind)\n+    {\n+    case CAND_MULT:\n+      fputs (\"     MULT : (\", dump_file);\n+      print_generic_expr (dump_file, c->base_name, 0);\n+      fputs (\" + \", dump_file);\n+      dump_double_int (dump_file, c->index, false);\n+      fputs (\") * \", dump_file);\n+      print_generic_expr (dump_file, c->stride, 0);\n+      fputs (\" : \", dump_file);\n+      break;\n+    case CAND_ADD:\n+      fputs (\"     ADD  : \", dump_file);\n+      print_generic_expr (dump_file, c->base_name, 0);\n+      fputs (\" + (\", dump_file);\n+      dump_double_int (dump_file, c->index, false);\n+      fputs (\" * \", dump_file);\n+      print_generic_expr (dump_file, c->stride, 0);\n+      fputs (\") : \", dump_file);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  print_generic_expr (dump_file, c->cand_type, 0);\n+  fprintf (dump_file, \"\\n     basis: %d  dependent: %d  sibling: %d\\n\",\n+\t   c->basis, c->dependent, c->sibling);\n+  fprintf (dump_file, \"     next-interp: %d  dead-savings: %d\\n\",\n+\t   c->next_interp, c->dead_savings);\n+  if (c->def_phi)\n+    {\n+      fputs (\"     phi:  \", dump_file);\n+      print_gimple_stmt (dump_file, c->def_phi, 0, 0);\n+    }\n+  fputs (\"\\n\", dump_file);\n+}\n+\n+/* Dump the candidate vector for debug.  */\n+\n+static void\n+dump_cand_vec (void)\n+{\n+  unsigned i;\n+  slsr_cand_t c;\n+\n+  fprintf (dump_file, \"\\nStrength reduction candidate vector:\\n\\n\");\n+  \n+  FOR_EACH_VEC_ELT (slsr_cand_t, cand_vec, i, c)\n+    dump_candidate (c);\n+}\n+\n+/* Dump the candidate chains.  */\n+\n+static void\n+dump_cand_chains (void)\n+{\n+  unsigned i;\n+\n+  fprintf (dump_file, \"\\nStrength reduction candidate chains:\\n\\n\");\n+\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      const_cand_chain_t chain = base_cand_map[i];\n+\n+      if (chain)\n+\t{\n+\t  cand_chain_t p;\n+\n+\t  print_generic_expr (dump_file, chain->base_name, 0);\n+\t  fprintf (dump_file, \" -> %d\", chain->cand->cand_num);\n+\n+\t  for (p = chain->next; p; p = p->next)\n+\t    fprintf (dump_file, \" -> %d\", p->cand->cand_num);\n+\n+\t  fputs (\"\\n\", dump_file);\n+\t}\n+    }\n+\n+  fputs (\"\\n\", dump_file);\n+}\n+\n+\f\n+/* Recursive helper for unconditional_cands_with_known_stride_p.\n+   Returns TRUE iff C, its siblings, and its dependents are all\n+   unconditional candidates.  */\n+\n+static bool\n+unconditional_cands (slsr_cand_t c)\n+{\n+  if (c->def_phi)\n+    return false;\n+\n+  if (c->sibling && !unconditional_cands (lookup_cand (c->sibling)))\n+    return false;\n+\n+  if (c->dependent && !unconditional_cands (lookup_cand (c->dependent)))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Determine whether or not the tree of candidates rooted at\n+   ROOT consists entirely of unconditional increments with\n+   an INTEGER_CST stride.  */\n+\n+static bool\n+unconditional_cands_with_known_stride_p (slsr_cand_t root)\n+{\n+  /* The stride is identical for all related candidates, so\n+     check it once.  */\n+  if (TREE_CODE (root->stride) != INTEGER_CST)\n+    return false;\n+\n+  return unconditional_cands (lookup_cand (root->dependent));\n+}\n+\n+/* Calculate the increment required for candidate C relative to \n+   its basis.  */\n+\n+static double_int\n+cand_increment (slsr_cand_t c)\n+{\n+  slsr_cand_t basis;\n+\n+  /* If the candidate doesn't have a basis, just return its own\n+     index.  This is useful in record_increments to help us find\n+     an existing initializer.  */\n+  if (!c->basis)\n+    return c->index;\n+\n+  basis = lookup_cand (c->basis);\n+  gcc_assert (operand_equal_p (c->base_name, basis->base_name, 0));\n+  return double_int_sub (c->index, basis->index);\n+}\n+\n+/* Return TRUE iff candidate C has already been replaced under\n+   another interpretation.  */\n+\n+static inline bool\n+cand_already_replaced (slsr_cand_t c)\n+{\n+  return (gimple_bb (c->cand_stmt) == 0);\n+}\n+\n+/* Helper routine for replace_dependents, doing the work for a \n+   single candidate C.  */\n+\n+static void\n+replace_dependent (slsr_cand_t c, enum tree_code cand_code)\n+{\n+  double_int stride = tree_to_double_int (c->stride);\n+  double_int bump = double_int_mul (cand_increment (c), stride);\n+  gimple stmt_to_print = NULL;\n+  slsr_cand_t basis;\n+  tree basis_name, incr_type, bump_tree;\n+  enum tree_code code;\n+  \n+  /* It is highly unlikely, but possible, that the resulting\n+     bump doesn't fit in a HWI.  Abandon the replacement\n+     in this case.  Restriction to signed HWI is conservative\n+     for unsigned types but allows for safe negation without\n+     twisted logic.  */\n+  if (!double_int_fits_in_shwi_p (bump))\n+    return;\n+\n+  basis = lookup_cand (c->basis);\n+  basis_name = gimple_assign_lhs (basis->cand_stmt);\n+  incr_type = TREE_TYPE (gimple_assign_rhs1 (c->cand_stmt));\n+  code = PLUS_EXPR;\n+\n+  if (double_int_negative_p (bump))\n+    {\n+      code = MINUS_EXPR;\n+      bump = double_int_neg (bump);\n+    }\n+\n+  bump_tree = double_int_to_tree (incr_type, bump);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"Replacing: \", dump_file);\n+      print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);\n+    }\n+\n+  if (double_int_zero_p (bump))\n+    {\n+      tree lhs = gimple_assign_lhs (c->cand_stmt);\n+      gimple copy_stmt = gimple_build_assign (lhs, basis_name);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+      gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n+      gsi_replace (&gsi, copy_stmt, false);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tstmt_to_print = copy_stmt;\n+    }\n+  else\n+    {\n+      tree rhs1 = gimple_assign_rhs1 (c->cand_stmt);\n+      tree rhs2 = gimple_assign_rhs2 (c->cand_stmt);\n+      if (cand_code != NEGATE_EXPR\n+\t  && ((operand_equal_p (rhs1, basis_name, 0)\n+\t       && operand_equal_p (rhs2, bump_tree, 0))\n+\t      || (operand_equal_p (rhs1, bump_tree, 0)\n+\t\t  && operand_equal_p (rhs2, basis_name, 0))))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fputs (\"(duplicate, not actually replacing)\", dump_file);\n+\t      stmt_to_print = c->cand_stmt;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+\t  gimple_assign_set_rhs_with_ops (&gsi, code, basis_name, bump_tree);\n+\t  update_stmt (gsi_stmt (gsi));\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    stmt_to_print = gsi_stmt (gsi);\n+\t}\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"With: \", dump_file);\n+      print_gimple_stmt (dump_file, stmt_to_print, 0, 0);\n+      fputs (\"\\n\", dump_file);\n+    }\n+}\n+\n+/* Replace candidate C, each sibling of candidate C, and each\n+   dependent of candidate C with an add or subtract.  Note that we\n+   only operate on CAND_MULTs with known strides, so we will never\n+   generate a POINTER_PLUS_EXPR.  Each candidate X = (B + i) * S is\n+   replaced by X = Y + ((i - i') * S), as described in the module\n+   commentary.  The folded value ((i - i') * S) is referred to here\n+   as the \"bump.\"  */\n+\n+static void\n+replace_dependents (slsr_cand_t c)\n+{\n+  enum tree_code cand_code = gimple_assign_rhs_code (c->cand_stmt);\n+\n+  /* It is not useful to replace casts, copies, or adds of an SSA name\n+     and a constant.  Also skip candidates that have already been\n+     replaced under another interpretation.  */\n+  if (cand_code != MODIFY_EXPR\n+      && cand_code != NOP_EXPR\n+      && c->kind == CAND_MULT\n+      && !cand_already_replaced (c))\n+    replace_dependent (c, cand_code);\n+\n+  if (c->sibling)\n+    replace_dependents (lookup_cand (c->sibling));\n+\n+  if (c->dependent)\n+    replace_dependents (lookup_cand (c->dependent));\n+}\n+\f\n+/* Analyze costs of related candidates in the candidate vector,\n+   and make beneficial replacements.  */\n+\n+static void\n+analyze_candidates_and_replace (void)\n+{\n+  unsigned i;\n+  slsr_cand_t c;\n+\n+  /* Each candidate that has a null basis and a non-null\n+     dependent is the root of a tree of related statements.\n+     Analyze each tree to determine a subset of those\n+     statements that can be replaced with maximum benefit.  */\n+  FOR_EACH_VEC_ELT (slsr_cand_t, cand_vec, i, c)\n+    {\n+      slsr_cand_t first_dep;\n+\n+      if (c->basis != 0 || c->dependent == 0)\n+\tcontinue;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"\\nProcessing dependency tree rooted at %d.\\n\",\n+\t\t c->cand_num);\n+\n+      first_dep = lookup_cand (c->dependent);\n+\n+      /* If the common stride of all related candidates is a\n+\t known constant, and none of these has a phi-dependence,\n+\t then all replacements are considered profitable.\n+\t Each replaces a multiply by a single add, with the\n+\t possibility that a feeding add also goes dead as a\n+\t result.  */\n+      if (unconditional_cands_with_known_stride_p (c))\n+\treplace_dependents (first_dep);\n+\n+      /* TODO:  When the stride is an SSA name, it may still be\n+\t profitable to replace some or all of the dependent\n+\t candidates, depending on whether the introduced increments\n+\t can be reused, or are less expensive to calculate than\n+\t the replaced statements.  */\n+\n+      /* TODO:  Strength-reduce data references with implicit\n+\t multiplication in their addressing expressions.  */\n+\n+      /* TODO:  When conditional increments occur so that a \n+\t candidate is dependent upon a phi-basis, the cost of\n+\t introducing a temporary must be accounted for.  */\n+    }\n+}\n+\n+static unsigned\n+execute_strength_reduction (void)\n+{\n+  struct dom_walk_data walk_data;\n+\n+  /* Create the obstack where candidates will reside.  */\n+  gcc_obstack_init (&cand_obstack);\n+\n+  /* Allocate the candidate vector.  */\n+  cand_vec = VEC_alloc (slsr_cand_t, heap, 128);\n+\n+  /* Allocate the mapping from statements to candidate indices.  */\n+  stmt_cand_map = pointer_map_create ();\n+\n+  /* Create the obstack where candidate chains will reside.  */\n+  gcc_obstack_init (&chain_obstack);\n+\n+  /* Allocate the mapping from base names to candidate chains.  */\n+  base_cand_map = XNEWVEC (cand_chain_t, num_ssa_names);\n+  memset (base_cand_map, 0, num_ssa_names * sizeof (cand_chain_t));\n+\n+  /* Initialize the loop optimizer.  We need to detect flow across\n+     back edges, and this gives us dominator information as well.  */\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+\n+  /* Initialize costs tables in IVOPTS.  */\n+  initialize_costs ();\n+\n+  /* Set up callbacks for the generic dominator tree walker.  */\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children = find_candidates_in_block;\n+  walk_data.after_dom_children = NULL;\n+  walk_data.global_data = NULL;\n+  walk_data.block_local_data_size = 0;\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Walk the CFG in predominator order looking for strength reduction\n+     candidates.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      dump_cand_vec ();\n+      dump_cand_chains ();\n+    }\n+\n+  /* Analyze costs and make appropriate replacements.  */\n+  analyze_candidates_and_replace ();\n+\n+  /* Free resources.  */\n+  fini_walk_dominator_tree (&walk_data);\n+  loop_optimizer_finalize ();\n+  free (base_cand_map);\n+  obstack_free (&chain_obstack, NULL);\n+  pointer_map_destroy (stmt_cand_map);\n+  VEC_free (slsr_cand_t, heap, cand_vec);\n+  obstack_free (&cand_obstack, NULL);\n+  finalize_costs ();\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_strength_reduction (void)\n+{\n+  return optimize > 0;\n+}\n+\n+struct gimple_opt_pass pass_strength_reduction =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"slsr\",\t\t\t\t/* name */\n+  gate_strength_reduction,\t\t/* gate */\n+  execute_strength_reduction,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_GIMPLE_SLSR,\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_verify_ssa\t\t\t/* todo_flags_finish */\n+ }\n+};"}, {"sha": "474d003db06daa273dd024f0c5e0c82274e4da5c", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -1463,6 +1463,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_cse_reciprocals);\n       NEXT_PASS (pass_reassoc);\n       NEXT_PASS (pass_vrp);\n+      NEXT_PASS (pass_strength_reduction);\n       NEXT_PASS (pass_dominator);\n       /* The only const/copy propagation opportunities left after\n \t DOM should be due to degenerate PHI nodes.  So rather than"}, {"sha": "0c45409a69a0c0b920527209145f63f3b145d072", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -1,3 +1,10 @@\n+2012-06-26  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* gcc.dg/tree-ssa/slsr-1.c: New test.\n+\t* gcc.dg/tree-ssa/slsr-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/slsr-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/slsr-4.c: Likewise.\n+\n 2012-06-26  Matt Turner  <mattst88@gmail.com>\n \n \tPR target/35294"}, {"sha": "f8c33191b7beb61836df832501f679765baccdef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-1.c?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+extern void foo (int);\n+\n+void\n+f (int *p, unsigned int n)\n+{\n+  foo (*(p + n * 4));\n+  foo (*(p + 32 + n * 4));\n+  if (n > 3)\n+    foo (*(p + 16 + n * 4));\n+  else\n+    foo (*(p + 48 + n * 4));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 128\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 64\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 192\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6709ee0f77a4200e4448badcf0869be2ba2a7a24", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-2.c?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+extern void foo (int);\n+\n+void\n+f (int *p, int n)\n+{\n+  foo (*(p + n++ * 4));\n+  foo (*(p + 32 + n++ * 4));\n+  foo (*(p + 16 + n * 4));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 144\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 96\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a21ee4d8c267a8d6408964ebbfe034476cbcad53", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-3.c?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+foo (int a[], int b[], int i)\n+{\n+  a[i] = b[i] + 2;\n+  i++;\n+  a[i] = b[i] + 2;\n+  i++;\n+  a[i] = b[i] + 2;\n+  i++;\n+  a[i] = b[i] + 2;\n+  i++;\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\* 4\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 4\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 8\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 12\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "413a1cc27abd5bb6759476d566c2b184f6494530", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-4.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-4.c?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-slsr -fdump-tree-optimized\" } */\n+\n+void foo (int);\n+\n+int\n+f (int i)\n+{\n+  int x, y;\n+\n+  x = i * 4;\n+  y = x * 10;\n+  foo (y);\n+\n+  i = i + 5;\n+  x = i * 4;\n+  y = x * 10;\n+  foo (y);\n+\n+  i = i - 4;\n+  x = i * 4;\n+  y = x * 10;\n+  foo (y);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\* 4\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\* 10\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 20;\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 200\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\- 16;\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\- 160\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\* 4\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\* 10\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 200\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 40\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"slsr\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "18d419daa47a66e4f904e30ab7941a757d65521c", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -257,6 +257,7 @@ DEFTIMEVAR (TV_TREE_IFCOMBINE        , \"tree if-combine\")\n DEFTIMEVAR (TV_TREE_UNINIT           , \"uninit var analysis\")\n DEFTIMEVAR (TV_PLUGIN_INIT           , \"plugin initialization\")\n DEFTIMEVAR (TV_PLUGIN_RUN            , \"plugin execution\")\n+DEFTIMEVAR (TV_GIMPLE_SLSR           , \"straight-line strength reduction\")\n \n /* Everything else in rest_of_compilation not included above.  */\n DEFTIMEVAR (TV_EARLY_LOCAL\t     , \"early local passes\")"}, {"sha": "cf7883985c2671c2d83f7197e9ca2b3649749f3c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -810,6 +810,8 @@ bool expr_invariant_in_loop_p (struct loop *, tree);\n bool stmt_invariant_in_loop_p (struct loop *, gimple);\n bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,\n \t\t\t\t      addr_space_t);\n+void initialize_costs (void);\n+void finalize_costs (void);\n unsigned multiply_by_const_cost (HOST_WIDE_INT, enum machine_mode, bool);\n unsigned add_regs_cost (enum machine_mode, bool);\n unsigned multiply_regs_cost (enum machine_mode, bool);"}, {"sha": "1c771d27e84c0861a0b4e9e0ca34f6653993f84e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -452,6 +452,7 @@ extern struct gimple_opt_pass pass_tm_memopt;\n extern struct gimple_opt_pass pass_tm_edges;\n extern struct gimple_opt_pass pass_split_functions;\n extern struct gimple_opt_pass pass_feedback_split_functions;\n+extern struct gimple_opt_pass pass_strength_reduction;\n \n /* IPA Passes */\n extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;"}, {"sha": "0abbaff0f5fcba2f0440323922f0173ff3fd9ab2", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9453c07d6f320f3c4c32c2d0ae992d2b3536261/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f9453c07d6f320f3c4c32c2d0ae992d2b3536261", "patch": "@@ -856,7 +856,7 @@ htab_inv_expr_hash (const void *ent)\n \n /* Allocate data structures for the cost model.  */\n \n-static void\n+void\n initialize_costs (void)\n {\n   mult_costs[0] = htab_create (100, mbc_entry_hash, mbc_entry_eq, free);\n@@ -866,7 +866,7 @@ initialize_costs (void)\n \n /* Release data structures for the cost model.  */\n \n-static void\n+void\n finalize_costs (void)\n {\n   cost_tables_exist = false;"}]}