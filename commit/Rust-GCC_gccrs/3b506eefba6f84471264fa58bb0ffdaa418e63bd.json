{"sha": "3b506eefba6f84471264fa58bb0ffdaa418e63bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I1MDZlZWZiYTZmODQ0NzEyNjRmYTU4YmIwZmZkYWE0MThlNjNiZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2015-01-30T11:02:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-30T11:02:18Z"}, "message": "sem_disp.adb: Minor reformatting.\n\n2015-01-30  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_disp.adb: Minor reformatting.\n\t* sem_disp.ads: Documentation update.\n\nFrom-SVN: r220278", "tree": {"sha": "d872a81d67758347cc0a096e1f8a010f6ad9b5a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d872a81d67758347cc0a096e1f8a010f6ad9b5a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b506eefba6f84471264fa58bb0ffdaa418e63bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b506eefba6f84471264fa58bb0ffdaa418e63bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b506eefba6f84471264fa58bb0ffdaa418e63bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b506eefba6f84471264fa58bb0ffdaa418e63bd/comments", "author": null, "committer": null, "parents": [{"sha": "089ad47399b946baeb5c6b62a97d6f1e5339e2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089ad47399b946baeb5c6b62a97d6f1e5339e2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089ad47399b946baeb5c6b62a97d6f1e5339e2bf"}], "stats": {"total": 84, "additions": 50, "deletions": 34}, "files": [{"sha": "9fc99b8f8c13579ef1836eb83a7f3df230488d6d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b506eefba6f84471264fa58bb0ffdaa418e63bd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b506eefba6f84471264fa58bb0ffdaa418e63bd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3b506eefba6f84471264fa58bb0ffdaa418e63bd", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_disp.adb: Minor reformatting.\n+\t* sem_disp.ads: Documentation update.\n+\n 2015-01-30  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_disp.adb (Is_Dynamically_Tagged): when applied to an entity"}, {"sha": "b49913dd57a2be8d3950a4570c3f064e9933a2dd", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b506eefba6f84471264fa58bb0ffdaa418e63bd/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b506eefba6f84471264fa58bb0ffdaa418e63bd/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=3b506eefba6f84471264fa58bb0ffdaa418e63bd", "patch": "@@ -563,8 +563,8 @@ package body Sem_Disp is\n                null;\n \n             elsif Ekind (Current_Scope) = E_Function\n-              and then Nkind (Unit_Declaration_Node (Current_Scope))\n-                 = N_Generic_Subprogram_Declaration\n+              and then Nkind (Unit_Declaration_Node (Current_Scope)) =\n+                                          N_Generic_Subprogram_Declaration\n             then\n                null;\n \n@@ -2172,7 +2172,7 @@ package body Sem_Disp is\n       elsif Present (Find_Controlling_Arg (N)) then\n          return True;\n \n-      --  Special cases : entities, and calls that dispatch on result.\n+      --  Special cases: entities, and calls that dispatch on result\n \n       elsif Is_Entity_Name (N) then\n          return Is_Class_Wide_Type (Etype (N));\n@@ -2182,7 +2182,7 @@ package body Sem_Disp is\n       then\n          return True;\n \n-      --  Otherwise check whether call has controlling argument.\n+      --  Otherwise check whether call has controlling argument\n \n       else\n          return False;"}, {"sha": "21d1da5fe39cdca54efe5bba58677783ea3f74d0", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b506eefba6f84471264fa58bb0ffdaa418e63bd/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b506eefba6f84471264fa58bb0ffdaa418e63bd/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=3b506eefba6f84471264fa58bb0ffdaa418e63bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,26 +30,27 @@ with Types; use Types;\n package Sem_Disp is\n \n    procedure Check_Controlling_Formals (Typ : Entity_Id; Subp : Entity_Id);\n-   --  Check that all controlling parameters of Subp are of type Typ,\n-   --  that defaults for controlling parameters are tag-indeterminate,\n-   --  and that the nominal subtype of the parameters and result\n-   --  statically match the first subtype of the controlling type.\n+   --  Check that all controlling parameters of Subp are of type Typ, that\n+   --  defaults for controlling parameters are tag-indeterminate, and that the\n+   --  nominal subtype of the parameters and result statically match the first\n+   --  subtype of the controlling type. Issues appropriate error messages if\n+   --  any of these requirements is not met.\n \n    procedure Check_Dispatching_Call (N : Node_Id);\n-   --  Check if a call is a dispatching call. The subprogram is known to\n-   --  be a dispatching operation. The call is dispatching if all the\n-   --  controlling actuals are dynamically tagged. This procedure is called\n-   --  after overload resolution, so the call is known to be unambiguous.\n+   --  Check if the call N is a dispatching call. The subprogram is known to be\n+   --  a dispatching operation. The call is dispatching if all the controlling\n+   --  actuals are dynamically tagged. This procedure is called after overload\n+   --  resolution, so the call is known to be unambiguous.\n \n    procedure Check_Dispatching_Operation (Subp, Old_Subp : Entity_Id);\n-   --  Add \"Subp\" to the list of primitive operations of the corresponding type\n+   --  Add Subp to the list of primitive operations of the corresponding type\n    --  if it has a parameter of this type and is defined at a proper place for\n    --  primitive operations (new primitives are only defined in package spec,\n    --  overridden operation can be defined in any scope). If Old_Subp is not\n    --  Empty we are in the overriding case. If the tagged type associated with\n    --  Subp is a concurrent type (case that occurs when the type is declared in\n    --  a generic because the analysis of generics disables generation of the\n-   --  corresponding record) then this routine does does not add \"Subp\" to the\n+   --  corresponding record) then this routine does does not add Subp to the\n    --  list of primitive operations but leaves Subp decorated as dispatching\n    --  operation to enable checks associated with the Object.Operation notation\n \n@@ -59,34 +60,37 @@ package Sem_Disp is\n    --  If a primitive operation was defined for the incomplete view of the\n    --  type, and the full type declaration is a derived type definition,\n    --  the operation may override an inherited one.\n+   --  Need more description here, what are the parameters, and what does\n+   --  this call actually do???\n \n    procedure Check_Operation_From_Private_View (Subp, Old_Subp : Entity_Id);\n-   --  Add \"Old_Subp\" to the list of primitive operations of the corresponding\n+   --  Add Old_Subp to the list of primitive operations of the corresponding\n    --  tagged type if it is the full view of a private tagged type. The Alias\n-   --  of \"OldSubp\" is adjusted to point to the inherited procedure of the\n+   --  of Old_Subp is adjusted to point to the inherited procedure of the\n    --  full view because it is always this one which has to be called.\n+   --  What is Subp used for???\n \n    function Covers_Some_Interface (Prim : Entity_Id) return Boolean;\n    --  Returns true if Prim covers some interface primitive of its associated\n    --  tagged type. The tagged type of Prim must be frozen when this function\n    --  is invoked.\n \n    function Find_Controlling_Arg (N : Node_Id) return Node_Id;\n-   --  Returns the actual controlling argument if N is dynamically tagged,\n-   --  and Empty if it is not dynamically tagged.\n+   --  Returns the actual controlling argument if N is dynamically tagged, and\n+   --  Empty if it is not dynamically tagged.\n \n    function Find_Dispatching_Type (Subp : Entity_Id) return Entity_Id;\n-   --  Check whether a subprogram is dispatching, and find the tagged type of\n-   --  the controlling argument or arguments. Returns Empty if Subp is not a\n-   --  dispatching operation.\n+   --  Check whether the subprogram Subp is dispatching, and find the tagged\n+   --  type of the controlling argument or arguments. Returns Empty if Subp\n+   --  is not a dispatching operation.\n \n    function Find_Primitive_Covering_Interface\n      (Tagged_Type : Entity_Id;\n       Iface_Prim  : Entity_Id) return Entity_Id;\n-   --  Search in the homonym chain for the primitive of Tagged_Type that covers\n+   --  Search the homonym chain for the primitive of Tagged_Type that covers\n    --  Iface_Prim. The homonym chain traversal is required to catch primitives\n    --  associated with the partial view of private types when processing the\n-   --  corresponding full view. If the entity is not found then search for it\n+   --  corresponding full view. If the entity is not found, then search for it\n    --  in the list of primitives of Tagged_Type. This latter search is needed\n    --  when the interface primitive is covered by a private subprogram. If the\n    --  primitive has not been covered yet then return the entity that will be\n@@ -115,32 +119,39 @@ package Sem_Disp is\n    --  and Interfaces_Only should be True.\n \n    function Is_Dynamically_Tagged (N : Node_Id) return Boolean;\n-   --  Used to determine whether a call is dispatching, i.e. if is an\n+   --  Used to determine whether a call is dispatching, i.e. if it is\n    --  an expression of a class_Wide type, or a call to a function with\n    --  controlling result where at least one operand is dynamically tagged.\n+   --  Also used to determine whether an entity has a class-wide type, or a\n+   --  function call that dispatches on the result. Used to verify that all the\n+   --  dependent expressions in a conditional expression are equally tagged.\n \n    function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean;\n    --  Returns True if E is a null procedure that is an interface primitive\n \n    function Is_Tag_Indeterminate (N : Node_Id) return Boolean;\n-   --  An expression is tag-indeterminate if it is a call that dispatches\n-   --  on result, and all controlling operands are also indeterminate.\n-   --  Such a function call may inherit a tag from an enclosing call.\n+   --  Returns true if the expression N is tag-indeterminate. An expression\n+   --  is tag-indeterminate if it is a call that dispatches on result, and all\n+   --  controlling operands are also indeterminate. Such a function call may\n+   --  inherit a tag from an enclosing call.\n \n    procedure Override_Dispatching_Operation\n      (Tagged_Type : Entity_Id;\n       Prev_Op     : Entity_Id;\n       New_Op      : Entity_Id;\n       Is_Wrapper  : Boolean := False);\n-   --  Replace an implicit dispatching operation with an explicit one.\n-   --  Prev_Op is an inherited primitive operation which is overridden\n-   --  by the explicit declaration of New_Op. Is_Wrapper is True when\n-   --  New_Op is an internally generated wrapper of a controlling function.\n+   --  Replace an implicit dispatching operation of the type Tagged_Type\n+   --  with an explicit one. Prev_Op is an inherited primitive operation which\n+   --  is overridden by the explicit declaration of New_Op. Is_Wrapper is\n+   --  True when New_Op is an internally generated wrapper of a controlling\n+   --  function. The caller checks that Tagged_Type is indeed a tagged type.\n \n    procedure Propagate_Tag (Control : Node_Id; Actual : Node_Id);\n-   --  If a function call is tag-indeterminate,  its controlling argument is\n-   --  found in the context;  either an enclosing call, or the left-hand side\n+   --  If a function call is tag-indeterminate, its controlling argument is\n+   --  found in the context: either an enclosing call, or the left-hand side\n    --  of the enclosing assignment statement. The tag must be propagated\n    --  recursively to the tag-indeterminate actuals of the call.\n+   --  Need clear description of the parameters Control and Actual, especially\n+   --  since the comments above refer to actuals in the plural ???\n \n end Sem_Disp;"}]}