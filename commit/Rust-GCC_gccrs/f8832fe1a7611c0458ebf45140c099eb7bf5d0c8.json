{"sha": "f8832fe1a7611c0458ebf45140c099eb7bf5d0c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4MzJmZTFhNzYxMWMwNDU4ZWJmNDUxNDBjMDk5ZWI3YmY1ZDBjOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:52:04Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:52:04Z"}, "message": "poly_int: create_integer_operand\n\nThis patch generalises create_integer_operand so that it accepts\npoly_int64s rather than HOST_WIDE_INTs.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* optabs.h (expand_operand): Add an int_value field.\n\t(create_expand_operand): Add an int_value parameter and use it\n\tto initialize the new expand_operand field.\n\t(create_integer_operand): Replace with a declaration of a function\n\tthat accepts poly_int64s.  Move the implementation to...\n\t* optabs.c (create_integer_operand): ...here.\n\t(maybe_legitimize_operand): For EXPAND_INTEGER, check whether\n\tthe mode preserves the value of int_value, instead of calling\n\tconst_int_operand on the rtx.  Use gen_int_mode to generate\n\tthe new rtx.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255865", "tree": {"sha": "454adbe03c8aa8c6dd94e3a936168631193be885", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/454adbe03c8aa8c6dd94e3a936168631193be885"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8/comments", "author": null, "committer": null, "parents": [{"sha": "dc3f38050535e8904dce2fd02c6efb6cf91eea3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3f38050535e8904dce2fd02c6efb6cf91eea3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3f38050535e8904dce2fd02c6efb6cf91eea3d"}], "stats": {"total": 57, "additions": 42, "deletions": 15}, "files": [{"sha": "5f26d1bcf8b0134832910d51c4bea4b89d32c8e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8832fe1a7611c0458ebf45140c099eb7bf5d0c8", "patch": "@@ -1,3 +1,18 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* optabs.h (expand_operand): Add an int_value field.\n+\t(create_expand_operand): Add an int_value parameter and use it\n+\tto initialize the new expand_operand field.\n+\t(create_integer_operand): Replace with a declaration of a function\n+\tthat accepts poly_int64s.  Move the implementation to...\n+\t* optabs.c (create_integer_operand): ...here.\n+\t(maybe_legitimize_operand): For EXPAND_INTEGER, check whether\n+\tthe mode preserves the value of int_value, instead of calling\n+\tconst_int_operand on the rtx.  Use gen_int_mode to generate\n+\tthe new rtx.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "9fd0f823060db693dcacdf37b0faa2ab90772127", "filename": "gcc/optabs.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f8832fe1a7611c0458ebf45140c099eb7bf5d0c8", "patch": "@@ -6979,6 +6979,20 @@ valid_multiword_target_p (rtx target)\n   return true;\n }\n \n+/* Make OP describe an input operand that has value INTVAL and that has\n+   no inherent mode.  This function should only be used for operands that\n+   are always expand-time constants.  The backend may request that INTVAL\n+   be copied into a different kind of rtx, but it must specify the mode\n+   of that rtx if so.  */\n+\n+void\n+create_integer_operand (struct expand_operand *op, poly_int64 intval)\n+{\n+  create_expand_operand (op, EXPAND_INTEGER,\n+\t\t\t gen_int_mode (intval, MAX_MODE_INT),\n+\t\t\t VOIDmode, false, intval);\n+}\n+\n /* Like maybe_legitimize_operand, but do not change the code of the\n    current rtx value.  */\n \n@@ -7091,8 +7105,13 @@ maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n \n     case EXPAND_INTEGER:\n       mode = insn_data[(int) icode].operand[opno].mode;\n-      if (mode != VOIDmode && const_int_operand (op->value, mode))\n-\tgoto input;\n+      if (mode != VOIDmode\n+\t  && known_eq (trunc_int_for_mode (op->int_value, mode),\n+\t\t       op->int_value))\n+\t{\n+\t  op->value = gen_int_mode (op->int_value, mode);\n+\t  goto input;\n+\t}\n       break;\n     }\n   return insn_operand_matches (icode, opno, op->value);"}, {"sha": "388f828428c1a80704f3cf340033796e1c08cd8e", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8832fe1a7611c0458ebf45140c099eb7bf5d0c8/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=f8832fe1a7611c0458ebf45140c099eb7bf5d0c8", "patch": "@@ -60,6 +60,9 @@ struct expand_operand {\n \n   /* The value of the operand.  */\n   rtx value;\n+\n+  /* The value of an EXPAND_INTEGER operand.  */\n+  poly_int64 int_value;\n };\n \n /* Initialize OP with the given fields.  Initialise the other fields\n@@ -69,13 +72,14 @@ static inline void\n create_expand_operand (struct expand_operand *op,\n \t\t       enum expand_operand_type type,\n \t\t       rtx value, machine_mode mode,\n-\t\t       bool unsigned_p)\n+\t\t       bool unsigned_p, poly_int64 int_value = 0)\n {\n   op->type = type;\n   op->unsigned_p = unsigned_p;\n   op->unused = 0;\n   op->mode = mode;\n   op->value = value;\n+  op->int_value = int_value;\n }\n \n /* Make OP describe an operand that must use rtx X, even if X is volatile.  */\n@@ -142,18 +146,7 @@ create_address_operand (struct expand_operand *op, rtx value)\n   create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);\n }\n \n-/* Make OP describe an input operand that has value INTVAL and that has\n-   no inherent mode.  This function should only be used for operands that\n-   are always expand-time constants.  The backend may request that INTVAL\n-   be copied into a different kind of rtx, but it must specify the mode\n-   of that rtx if so.  */\n-\n-static inline void\n-create_integer_operand (struct expand_operand *op, HOST_WIDE_INT intval)\n-{\n-  create_expand_operand (op, EXPAND_INTEGER, GEN_INT (intval), VOIDmode, false);\n-}\n-\n+extern void create_integer_operand (struct expand_operand *, poly_int64);\n \n /* Passed to expand_simple_binop and expand_binop to say which options\n    to try to use if the requested operation can't be open-coded on the"}]}