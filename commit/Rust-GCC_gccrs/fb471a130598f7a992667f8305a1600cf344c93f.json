{"sha": "fb471a130598f7a992667f8305a1600cf344c93f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI0NzFhMTMwNTk4ZjdhOTkyNjY3ZjgzMDVhMTYwMGNmMzQ0YzkzZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-12-24T15:32:11Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-12-24T15:32:11Z"}, "message": "gimple-fold.c (get_range_strlen_tree): Factored out of get_range_strlen.\n\n\t* gimple-fold.c (get_range_strlen_tree): Factored out of\n\tget_range_strlen.  Minor comment updates/additions.  Assert\n\targument is not a simple SSA_NAME.\n\t(get_range_strlen): Call get_range_strlen_tree as appropriate.\n\tMinor comment updates/additions.\n\nFrom-SVN: r267412", "tree": {"sha": "6a622f17cec6c39a7542d303c1f2a539cdbbb50e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a622f17cec6c39a7542d303c1f2a539cdbbb50e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb471a130598f7a992667f8305a1600cf344c93f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb471a130598f7a992667f8305a1600cf344c93f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb471a130598f7a992667f8305a1600cf344c93f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb471a130598f7a992667f8305a1600cf344c93f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63"}], "stats": {"total": 398, "additions": 216, "deletions": 182}, "files": [{"sha": "15d43d257748135a2fcadadc7346bd1330cc911f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb471a130598f7a992667f8305a1600cf344c93f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb471a130598f7a992667f8305a1600cf344c93f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb471a130598f7a992667f8305a1600cf344c93f", "patch": "@@ -1,3 +1,11 @@\n+2018-12-24  Martin Sebor  <msebor@redhat.com>\n+\n+\t* gimple-fold.c (get_range_strlen_tree): Factored out of\n+\tget_range_strlen.  Minor comment updates/additions.  Assert\n+\targument is not a simple SSA_NAME.\n+\t(get_range_strlen): Call get_range_strlen_tree as appropriate.\n+\tMinor comment updates/additions.\n+\n 2018-12-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-devirt.c (dump_targets): Cap number of targets printed."}, {"sha": "4f84f0c0cc3221ab76fc0cf14f022d40063e577d", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 208, "deletions": 182, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb471a130598f7a992667f8305a1600cf344c93f/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb471a130598f7a992667f8305a1600cf344c93f/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=fb471a130598f7a992667f8305a1600cf344c93f", "patch": "@@ -66,6 +66,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vector-builder.h\"\n #include \"tree-ssa-strlen.h\"\n \n+static bool get_range_strlen (tree, tree[2], bitmap *, int,\n+\t\t  int, bool *, unsigned, tree *);\n+\n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n    We can get declarations that are not possible to reference for various\n@@ -1258,222 +1261,243 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n   return true;\n }\n \n-\n-/* Obtain the minimum and maximum string length or minimum and maximum\n-   value of ARG in LENGTH[0] and LENGTH[1], respectively.\n-   If ARG is an SSA name variable, follow its use-def chains.  When\n-   TYPE == 0, if LENGTH[1] is not equal to the length we determine or\n-   if we are unable to determine the length or value, return false.\n-   VISITED is a bitmap of visited variables.\n-   TYPE is 0 if string length should be obtained, 1 for maximum string\n-   length and 2 for maximum value ARG can have.\n-   When FUZZY is non-zero and the length of a string cannot be determined,\n-   the function instead considers as the maximum possible length the\n-   size of a character array it may refer to.  If FUZZY is 2, it will handle\n-   PHIs and COND_EXPRs optimistically, if we can determine string length\n-   minimum and maximum, it will use the minimum from the ones where it\n-   can be determined.\n-   Set *FLEXP to true if the range of the string lengths has been\n-   obtained from the upper bound of an array at the end of a struct.\n-   Such an array may hold a string that's longer than its upper bound\n-   due to it being used as a poor-man's flexible array member.\n-   Pass NONSTR through to children.\n-   ELTSIZE is 1 for normal single byte character strings, and 2 or\n-   4 for wide characer strings.  ELTSIZE is by default 1.  */\n+/* Helper of get_range_strlen for ARG that is not an SSA_NAME.  */\n \n static bool\n-get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n-\t\t  int fuzzy, bool *flexp, unsigned eltsize, tree *nonstr)\n+get_range_strlen_tree (tree arg, tree length[2], bitmap *visited, int type,\n+\t\t       int fuzzy, bool *flexp, unsigned eltsize, tree *nonstr)\n {\n-  tree var, val = NULL_TREE;\n-  gimple *def_stmt;\n-\n+  gcc_assert (TREE_CODE (arg) != SSA_NAME);\n+ \n   /* The minimum and maximum length.  */\n   tree *const minlen = length;\n   tree *const maxlen = length + 1;\n \n-  if (TREE_CODE (arg) != SSA_NAME)\n+  /* The length computed by this invocation of the function.  */\n+  tree val = NULL_TREE;\n+\n+  /* We can end up with &(*iftmp_1)[0] here as well, so handle it.  */\n+  if (TREE_CODE (arg) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF)\n     {\n-      /* We can end up with &(*iftmp_1)[0] here as well, so handle it.  */\n-      if (TREE_CODE (arg) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF)\n+      tree op = TREE_OPERAND (arg, 0);\n+      if (integer_zerop (TREE_OPERAND (op, 1)))\n \t{\n-\t  tree op = TREE_OPERAND (arg, 0);\n-\t  if (integer_zerop (TREE_OPERAND (op, 1)))\n-\t    {\n-\t      tree aop0 = TREE_OPERAND (op, 0);\n-\t      if (TREE_CODE (aop0) == INDIRECT_REF\n-\t\t  && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n-\t\treturn get_range_strlen (TREE_OPERAND (aop0, 0), length,\n-\t\t\t\t\t visited, type, fuzzy, flexp,\n-\t\t\t\t\t eltsize, nonstr);\n-\t    }\n-\t  else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF && fuzzy)\n-\t    {\n-\t      /* Fail if an array is the last member of a struct object\n-\t\t since it could be treated as a (fake) flexible array\n-\t\t member.  */\n-\t      tree idx = TREE_OPERAND (op, 1);\n-\n-\t      arg = TREE_OPERAND (op, 0);\n-\t      tree optype = TREE_TYPE (arg);\n-\t      if (tree dom = TYPE_DOMAIN (optype))\n-\t\tif (tree bound = TYPE_MAX_VALUE (dom))\n-\t\t  if (TREE_CODE (bound) == INTEGER_CST\n-\t\t      && TREE_CODE (idx) == INTEGER_CST\n-\t\t      && tree_int_cst_lt (bound, idx))\n-\t\t    return false;\n-\t    }\n+\t  tree aop0 = TREE_OPERAND (op, 0);\n+\t  if (TREE_CODE (aop0) == INDIRECT_REF\n+\t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n+\t    return get_range_strlen (TREE_OPERAND (aop0, 0), length,\n+\t\t\t\t     visited, type, fuzzy, flexp,\n+\t\t\t\t     eltsize, nonstr);\n \t}\n-\n-      if (type == 2)\n+      else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF && fuzzy)\n \t{\n-\t  val = arg;\n-\t  if (TREE_CODE (val) != INTEGER_CST\n-\t      || tree_int_cst_sgn (val) < 0)\n-\t    return false;\n+\t  /* Fail if an array is the last member of a struct object\n+\t     since it could be treated as a (fake) flexible array\n+\t     member.  */\n+\t  tree idx = TREE_OPERAND (op, 1);\n+\n+\t  arg = TREE_OPERAND (op, 0);\n+\t  tree optype = TREE_TYPE (arg);\n+\t  if (tree dom = TYPE_DOMAIN (optype))\n+\t    if (tree bound = TYPE_MAX_VALUE (dom))\n+\t      if (TREE_CODE (bound) == INTEGER_CST\n+\t\t  && TREE_CODE (idx) == INTEGER_CST\n+\t\t  && tree_int_cst_lt (bound, idx))\n+\t\treturn false;\n \t}\n-      else\n-\t{\n-\t  c_strlen_data lendata = { };\n-\t  val = c_strlen (arg, 1, &lendata, eltsize);\n+    }\n \n-\t  /* If we potentially had a non-terminated string, then\n-\t     bubble that information up to the caller.  */\n-\t  if (!val && lendata.decl)\n-\t    {\n-\t      *nonstr = lendata.decl;\n-\t      *minlen = lendata.minlen;\n-\t      *maxlen = lendata.minlen;\n-\t      return type == 0 ? false : true;\n-\t    }\n+  if (type == 2)\n+    {\n+      /* We are computing the maximum value (not string length).  */\n+      val = arg;\n+      if (TREE_CODE (val) != INTEGER_CST\n+\t  || tree_int_cst_sgn (val) < 0)\n+\treturn false;\n+    }\n+  else\n+    {\n+      c_strlen_data lendata = { };\n+      val = c_strlen (arg, 1, &lendata, eltsize);\n+\n+      /* If we potentially had a non-terminated string, then\n+\t bubble that information up to the caller.  */\n+      if (!val && lendata.decl)\n+\t{\n+\t  *nonstr = lendata.decl;\n+\t  *minlen = lendata.minlen;\n+\t  *maxlen = lendata.minlen;\n+\t  return type == 0 ? false : true;\n \t}\n+    }\n+\n+  if (!val && fuzzy)\n+    {\n+      if (TREE_CODE (arg) == ADDR_EXPR)\n+\treturn get_range_strlen (TREE_OPERAND (arg, 0), length,\n+\t\t\t\t visited, type, fuzzy, flexp,\n+\t\t\t\t eltsize, nonstr);\n \n-      if (!val && fuzzy)\n+      if (TREE_CODE (arg) == ARRAY_REF)\n \t{\n-\t  if (TREE_CODE (arg) == ADDR_EXPR)\n-\t    return get_range_strlen (TREE_OPERAND (arg, 0), length,\n-\t\t\t\t     visited, type, fuzzy, flexp,\n-\t\t\t\t     eltsize, nonstr);\n+\t  tree optype = TREE_TYPE (TREE_OPERAND (arg, 0));\n \n-\t  if (TREE_CODE (arg) == ARRAY_REF)\n-\t    {\n-\t      tree optype = TREE_TYPE (TREE_OPERAND (arg, 0));\n+\t  /* Determine the \"innermost\" array type.  */\n+\t  while (TREE_CODE (optype) == ARRAY_TYPE\n+\t\t && TREE_CODE (TREE_TYPE (optype)) == ARRAY_TYPE)\n+\t    optype = TREE_TYPE (optype);\n \n-\t      /* Determine the \"innermost\" array type.  */\n-\t      while (TREE_CODE (optype) == ARRAY_TYPE\n-\t\t     && TREE_CODE (TREE_TYPE (optype)) == ARRAY_TYPE)\n-\t\toptype = TREE_TYPE (optype);\n+\t  /* Avoid arrays of pointers.  */\n+\t  tree eltype = TREE_TYPE (optype);\n+\t  if (TREE_CODE (optype) != ARRAY_TYPE\n+\t      || !INTEGRAL_TYPE_P (eltype))\n+\t    return false;\n \n-\t      /* Avoid arrays of pointers.  */\n-\t      tree eltype = TREE_TYPE (optype);\n-\t      if (TREE_CODE (optype) != ARRAY_TYPE\n-\t\t  || !INTEGRAL_TYPE_P (eltype))\n-\t\treturn false;\n+\t  /* Fail when the array bound is unknown or zero.  */\n+\t  val = TYPE_SIZE_UNIT (optype);\n+\t  if (!val || integer_zerop (val))\n+\t    return false;\n \n-\t      /* Fail when the array bound is unknown or zero.  */\n-\t      val = TYPE_SIZE_UNIT (optype);\n-\t      if (!val || integer_zerop (val))\n-\t\treturn false;\n+\t  val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n+\t\t\t      integer_one_node);\n \n-\t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n-\t\t\t\t integer_one_node);\n-\t      /* Set the minimum size to zero since the string in\n-\t\t the array could have zero length.  */\n-\t      *minlen = ssize_int (0);\n+\t  /* Set the minimum size to zero since the string in\n+\t     the array could have zero length.  */\n+\t  *minlen = ssize_int (0);\n \n-\t      if (TREE_CODE (TREE_OPERAND (arg, 0)) == COMPONENT_REF\n-\t\t  && optype == TREE_TYPE (TREE_OPERAND (arg, 0))\n-\t\t  && array_at_struct_end_p (TREE_OPERAND (arg, 0)))\n-\t\t*flexp = true;\n-\t    }\n-\t  else if (TREE_CODE (arg) == COMPONENT_REF\n-\t\t   && (TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 1)))\n-\t\t       == ARRAY_TYPE))\n+\t  if (TREE_CODE (TREE_OPERAND (arg, 0)) == COMPONENT_REF\n+\t      && optype == TREE_TYPE (TREE_OPERAND (arg, 0))\n+\t      && array_at_struct_end_p (TREE_OPERAND (arg, 0)))\n+\t    *flexp = true;\n+\t}\n+      else if (TREE_CODE (arg) == COMPONENT_REF\n+\t       && (TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 1)))\n+\t\t   == ARRAY_TYPE))\n+\t{\n+\t  /* Use the type of the member array to determine the upper\n+\t     bound on the length of the array.  This may be overly\n+\t     optimistic if the array itself isn't NUL-terminated and\n+\t     the caller relies on the subsequent member to contain\n+\t     the NUL but that would only be considered valid if\n+\t     the array were the last member of a struct.\n+\t      Set *FLEXP to true if the array whose bound is being\n+\t     used is at the end of a struct.  */\n+\t  if (array_at_struct_end_p (arg))\n+\t    *flexp = true;\n+\n+\t  tree fld = TREE_OPERAND (arg, 1);\n+\n+\t  tree optype = TREE_TYPE (fld);\n+\n+\t  /* Determine the \"innermost\" array type.  */\n+\t  while (TREE_CODE (optype) == ARRAY_TYPE\n+\t\t && TREE_CODE (TREE_TYPE (optype)) == ARRAY_TYPE)\n+\t    optype = TREE_TYPE (optype);\n+\n+\t  /* Fail when the array bound is unknown or zero.  */\n+\t  val = TYPE_SIZE_UNIT (optype);\n+\t  if (!val || integer_zerop (val))\n+\t    return false;\n+\t  val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n+\t\t\t     integer_one_node);\n+\n+\t  /* Set the minimum size to zero since the string in\n+\t     the array could have zero length.  */\n+\t  *minlen = ssize_int (0);\n+\t}\n+\n+      if (VAR_P (arg))\n+\t{\n+\t  tree type = TREE_TYPE (arg);\n+\t  if (POINTER_TYPE_P (type))\n+\t    type = TREE_TYPE (type);\n+\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n \t    {\n-\t      /* Use the type of the member array to determine the upper\n-\t\t bound on the length of the array.  This may be overly\n-\t\t optimistic if the array itself isn't NUL-terminated and\n-\t\t the caller relies on the subsequent member to contain\n-\t\t the NUL but that would only be considered valid if\n-\t\t the array were the last member of a struct.\n-\t\t Set *FLEXP to true if the array whose bound is being\n-\t\t used is at the end of a struct.  */\n-\t      if (array_at_struct_end_p (arg))\n-\t\t*flexp = true;\n-\n-\t      tree fld = TREE_OPERAND (arg, 1);\n-\n-\t      tree optype = TREE_TYPE (fld);\n-\n-\t      /* Determine the \"innermost\" array type.  */\n-\t      while (TREE_CODE (optype) == ARRAY_TYPE\n-\t\t     && TREE_CODE (TREE_TYPE (optype)) == ARRAY_TYPE)\n-\t\toptype = TREE_TYPE (optype);\n-\n-\t      /* Fail when the array bound is unknown or zero.  */\n-\t      val = TYPE_SIZE_UNIT (optype);\n-\t      if (!val || integer_zerop (val))\n+\t      val = TYPE_SIZE_UNIT (type);\n+\t      if (!val\n+\t\t  || TREE_CODE (val) != INTEGER_CST\n+\t\t  || integer_zerop (val))\n \t\treturn false;\n-\t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n-\t\t\t\t integer_one_node);\n+\t      val = wide_int_to_tree (TREE_TYPE (val),\n+\t\t\t\t      wi::sub (wi::to_wide (val), 1));\n+\n \t      /* Set the minimum size to zero since the string in\n \t\t the array could have zero length.  */\n \t      *minlen = ssize_int (0);\n \t    }\n-\n-\t  if (VAR_P (arg))\n-\t    {\n-\t      tree type = TREE_TYPE (arg);\n-\t      if (POINTER_TYPE_P (type))\n-\t\ttype = TREE_TYPE (type);\n-\n-\t      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t\t{\n-\t\t  val = TYPE_SIZE_UNIT (type);\n-\t\t  if (!val\n-\t\t      || TREE_CODE (val) != INTEGER_CST\n-\t\t      || integer_zerop (val))\n-\t\t    return false;\n-\t\t  val = wide_int_to_tree (TREE_TYPE (val),\n-\t\t\t\t\t  wi::sub (wi::to_wide (val), 1));\n-\t\t  /* Set the minimum size to zero since the string in\n-\t\t     the array could have zero length.  */\n-\t\t  *minlen = ssize_int (0);\n-\t\t}\n-\t    }\n \t}\n+    }\n \n-      if (!val)\n-\treturn false;\n+  if (!val)\n+    return false;\n \n-      if (!*minlen\n-\t  || (type > 0\n-\t      && TREE_CODE (*minlen) == INTEGER_CST\n-\t      && TREE_CODE (val) == INTEGER_CST\n-\t      && tree_int_cst_lt (val, *minlen)))\n-\t*minlen = val;\n+  /* Adjust the lower bound on the string length as necessary.  */\n+  if (!*minlen\n+      || (type > 0\n+\t  && TREE_CODE (*minlen) == INTEGER_CST\n+\t  && TREE_CODE (val) == INTEGER_CST\n+\t  && tree_int_cst_lt (val, *minlen)))\n+    *minlen = val;\n \n-      if (*maxlen)\n+  if (*maxlen)\n+    {\n+      /* Adjust the more conservative bound if possible/necessary\n+\t and fail otherwise.  */\n+      if (type > 0)\n \t{\n-\t  if (type > 0)\n-\t    {\n-\t      if (TREE_CODE (*maxlen) != INTEGER_CST\n-\t\t  || TREE_CODE (val) != INTEGER_CST)\n-\t\treturn false;\n-\n-\t      if (tree_int_cst_lt (*maxlen, val))\n-\t\t*maxlen = val;\n-\t      return true;\n-\t    }\n-\t  else if (simple_cst_equal (val, *maxlen) != 1)\n+\t  if (TREE_CODE (*maxlen) != INTEGER_CST\n+\t      || TREE_CODE (val) != INTEGER_CST)\n \t    return false;\n-\t}\n \n-      *maxlen = val;\n-      return true;\n+\t  if (tree_int_cst_lt (*maxlen, val))\n+\t    *maxlen = val;\n+\t  return true;\n+\t}\n+      else if (simple_cst_equal (val, *maxlen) != 1)\n+\t{\n+\t  /* Fail if the length of this ARG is different from that\n+\t     previously determined from another ARG.  */\n+\t  return false;\n+\t}\n     }\n \n+  *maxlen = val;\n+  return true;\n+}\n+\n+/* Obtain the minimum and maximum string length or minimum and maximum\n+   value of ARG in LENGTH[0] and LENGTH[1], respectively.\n+   If ARG is an SSA name variable, follow its use-def chains.  When\n+   TYPE == 0, if LENGTH[1] is not equal to the length we determine or\n+   if we are unable to determine the length or value, return false.\n+   VISITED is a bitmap of visited variables.\n+   TYPE is 0 if string length should be obtained, 1 for maximum string\n+   length and 2 for maximum value ARG can have.\n+   When FUZZY is non-zero and the length of a string cannot be determined,\n+   the function instead considers as the maximum possible length the\n+   size of a character array it may refer to.  If FUZZY is 2, it will handle\n+   PHIs and COND_EXPRs optimistically, if we can determine string length\n+   minimum and maximum, it will use the minimum from the ones where it\n+   can be determined.\n+   Set *FLEXP to true if the range of the string lengths has been\n+   obtained from the upper bound of an array at the end of a struct.\n+   Such an array may hold a string that's longer than its upper bound\n+   due to it being used as a poor-man's flexible array member.\n+   Pass NONSTR through to children.\n+   ELTSIZE is 1 for normal single byte character strings, and 2 or\n+   4 for wide characer strings.  ELTSIZE is by default 1.  */\n+\n+static bool\n+get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n+\t\t  int fuzzy, bool *flexp, unsigned eltsize, tree *nonstr)\n+{\n+\n+  if (TREE_CODE (arg) != SSA_NAME)\n+    return get_range_strlen_tree (arg, length, visited, type, fuzzy, flexp,\n+\t\t\t\t  eltsize, nonstr);\n+\n   /* If ARG is registered for SSA update we cannot look at its defining\n      statement.  */\n   if (name_registered_for_update_p (arg))\n@@ -1485,8 +1509,11 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n   if (!bitmap_set_bit (*visited, SSA_NAME_VERSION (arg)))\n     return true;\n \n-  var = arg;\n-  def_stmt = SSA_NAME_DEF_STMT (var);\n+  tree var = arg;\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+\n+  /* The minimum and maximum length.  */\n+  tree *const maxlen = length + 1;\n \n   switch (gimple_code (def_stmt))\n     {\n@@ -1550,7 +1577,6 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n         return false;\n     }\n }\n-\n /* Determine the minimum and maximum value or string length that ARG\n    refers to and store each in the first two elements of MINMAXLEN.\n    For expressions that point to strings of unknown lengths that are"}]}