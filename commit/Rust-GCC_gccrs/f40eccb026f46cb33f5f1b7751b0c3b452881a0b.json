{"sha": "f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwZWNjYjAyNmY0NmNiMzNmNWYxYjc3NTFiMGMzYjQ1Mjg4MWEwYg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-04-19T21:55:24Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-04-19T21:55:24Z"}, "message": "re PR target/35944 (wrong result for MOD with kind=10 for some array argument values)\n\n2008-04-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35944\n\tPR fortran/35946\n\tPR fortran/35947\n\t* trans_array.c (gfc_trans_array_constructor): Temporarily\n\trealign loop, if loop->from is not zero, before creating\n\tthe temporary array and provide an offset.\n\n\tPR fortran/35959\n\t* trans-decl.c (gfc_init_default_dt): Add gfc_ prefix to name\n\tand allow for NULL body.  Change all references from\n\tinit_default_dt to gfc_init_default_dt.\n\t* trans.h : Add prototype for gfc_init_default_dt.\n\t* trans-array.c (gfc_trans_deferred_vars): After nullification\n\tcall gfc_init_default_dt for derived types with allocatable\n\tcomponents.\n\n2008-04-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35944\n\tPR fortran/35946\n\tPR fortran/35947\n\t* gfortran.dg/array_constructor_23.f: New test.\n\n\tPR fortran/35959\n\t* gfortran.dg/alloc_comp_default_init_2.f90: New test.\n\t* gfortran.dg/alloc_comp_basics_1.f90: Change occurrences of\n\t\"builtin_free\" to 27.\n\t* gfortran.dg/alloc_comp_constructor_1.f90: Change occurrences\n\tof \"builtin_free\" to 21.\n\nFrom-SVN: r134472", "tree": {"sha": "497527fc5bf28773356dc116b6c7ffad50bcf3c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497527fc5bf28773356dc116b6c7ffad50bcf3c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/comments", "author": null, "committer": null, "parents": [{"sha": "476924c9e097b4d5f0179c2835bb34d288f92561", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476924c9e097b4d5f0179c2835bb34d288f92561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476924c9e097b4d5f0179c2835bb34d288f92561"}], "stats": {"total": 159, "additions": 148, "deletions": 11}, "files": [{"sha": "abcc336e4d1349772881df7998b1146a49b8d2a8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -1,3 +1,21 @@\n+2008-04-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35944\n+\tPR fortran/35946\n+\tPR fortran/35947\n+\t* trans_array.c (gfc_trans_array_constructor): Temporarily\n+\trealign loop, if loop->from is not zero, before creating\n+\tthe temporary array and provide an offset.\n+\n+\tPR fortran/35959\n+\t* trans-decl.c (gfc_init_default_dt): Add gfc_ prefix to name\n+\tand allow for NULL body.  Change all references from\n+\tinit_default_dt to gfc_init_default_dt.\n+\t* trans.h : Add prototype for gfc_init_default_dt.\n+\t* trans-array.c (gfc_trans_deferred_vars): After nullification\n+\tcall gfc_init_default_dt for derived types with allocatable\n+\tcomponents.\n+\n 2008-04-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/35892"}, {"sha": "7bac68dd650ec240a4f42c1473a5838543142ed0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -1679,6 +1679,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n   tree offsetvar;\n   tree desc;\n   tree type;\n+  tree loopfrom;\n   bool dynamic;\n \n   if (flag_bounds_check && ss->expr->ts.type == BT_CHARACTER)\n@@ -1757,9 +1758,34 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n \t}\n     }\n \n+  /* Temporarily reset the loop variables, so that the returned temporary\n+     has the right size and bounds.  This seems only to be necessary for\n+     1D arrays.  */\n+  if (!integer_zerop (loop->from[0]) && loop->dimen == 1)\n+    {\n+      loopfrom = loop->from[0];\n+      loop->from[0] = gfc_index_zero_node;\n+      loop->to[0] = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t loop->to[0], loopfrom);\n+    }\n+  else\n+    loopfrom = NULL_TREE;\n+\n   gfc_trans_create_temp_array (&loop->pre, &loop->post, loop, &ss->data.info,\n \t\t\t       type, dynamic, true, false);\n \n+  if (loopfrom != NULL_TREE)\n+    {\n+      loop->from[0] = loopfrom;\n+      loop->to[0] = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t loop->to[0], loopfrom);\n+      /* In the case of a non-zero from, the temporary needs an offset\n+\t so that subsequent indexing is correct.  */\n+      ss->data.info.offset = fold_build1 (NEGATE_EXPR,\n+\t\t\t\t\t  gfc_array_index_type,\n+\t\t\t\t\t  loop->from[0]);\n+    }\n+\n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n   offsetvar = gfc_create_var_np (gfc_array_index_type, \"offset\");\n@@ -5569,6 +5595,11 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \t  rank = sym->as ? sym->as->rank : 0;\n \t  tmp = gfc_nullify_alloc_comp (sym->ts.derived, descriptor, rank);\n \t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t  if (sym->value)\n+\t    {\n+\t      tmp = gfc_init_default_dt (sym, NULL);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n \t}\n     }\n   else if (!GFC_DESCRIPTOR_TYPE_P (type))"}, {"sha": "e693f729ba46e1063b68350f137ac19a2498d4d8", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -512,9 +512,6 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n      SAVE_EXPLICIT.  */\n   if (!sym->attr.use_assoc\n \t&& (sym->attr.save != SAVE_NONE || sym->attr.data\n-\t      || (sym->ts.type == BT_DERIVED\n-\t\t    && sym->ts.derived->attr.alloc_comp\n-\t\t    && sym->value)\n \t      || (sym->value && sym->ns->proc_name->attr.is_main_program)))\n     TREE_STATIC (decl) = 1;\n \n@@ -2532,8 +2529,8 @@ gfc_trans_vla_type_sizes (gfc_symbol *sym, stmtblock_t *body)\n \n /* Initialize a derived type by building an lvalue from the symbol\n    and using trans_assignment to do the work.  */\n-static tree\n-init_default_dt (gfc_symbol * sym, tree body)\n+tree\n+gfc_init_default_dt (gfc_symbol * sym, tree body)\n {\n   stmtblock_t fnblock;\n   gfc_expr *e;\n@@ -2553,7 +2550,8 @@ init_default_dt (gfc_symbol * sym, tree body)\n     }\n   gfc_add_expr_to_block (&fnblock, tmp);\n   gfc_free_expr (e);\n-  gfc_add_expr_to_block (&fnblock, body);\n+  if (body)\n+    gfc_add_expr_to_block (&fnblock, body);\n   return gfc_finish_block (&fnblock);\n }\n \n@@ -2571,7 +2569,7 @@ init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n \t  && f->sym->ts.type == BT_DERIVED\n \t  && !f->sym->ts.derived->attr.alloc_comp\n \t  && f->sym->value)\n-      body = init_default_dt (f->sym, body);\n+      body = gfc_init_default_dt (f->sym, body);\n \n   gfc_add_expr_to_block (&fnblock, body);\n   return gfc_finish_block (&fnblock);\n@@ -2672,7 +2670,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t\t\t     && sym->value\n \t\t\t     && !sym->attr.data\n \t\t\t     && sym->attr.save == SAVE_NONE)\n-\t\t    fnbody = init_default_dt (sym, fnbody);\n+\t\t    fnbody = gfc_init_default_dt (sym, fnbody);\n \n \t\t  gfc_get_backend_locus (&loc);\n \t\t  gfc_set_backend_locus (&sym->declared_at);\n@@ -2732,7 +2730,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t\t && sym->value\n \t\t && !sym->attr.data\n \t\t && sym->attr.save == SAVE_NONE)\n-\tfnbody = init_default_dt (sym, fnbody);\n+\tfnbody = gfc_init_default_dt (sym, fnbody);\n       else\n \tgcc_unreachable ();\n     }"}, {"sha": "1dfb0a59dab85e73b99972a79f8d1bb3c99f6bf9", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -405,6 +405,9 @@ tree gfc_get_symbol_decl (gfc_symbol *);\n /* Build a static initializer.  */\n tree gfc_conv_initializer (gfc_expr *, gfc_typespec *, tree, bool, bool);\n \n+/* Assign a default initializer to a derived type.  */\n+tree gfc_init_default_dt (gfc_symbol *, tree);\n+\n /* Substitute a temporary variable in place of the real one.  */\n void gfc_shadow_sym (gfc_symbol *, tree, gfc_saved_var *);\n "}, {"sha": "2d3ab1903f3fcf8ff6eec0f3a755e621f8383ac5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -1,3 +1,17 @@\n+2008-04-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35944\n+\tPR fortran/35946\n+\tPR fortran/35947\n+\t* gfortran.dg/array_constructor_23.f: New test.\n+\n+\tPR fortran/35959\n+\t* gfortran.dg/alloc_comp_default_init_2.f90: New test.\n+\t* gfortran.dg/alloc_comp_basics_1.f90: Change occurrences of\n+\t\"builtin_free\" to 27.\n+\t* gfortran.dg/alloc_comp_constructor_1.f90: Change occurrences\n+\tof \"builtin_free\" to 21.\n+\n 2008-04-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/35892"}, {"sha": "11f655e320bfd2f6485205348bfb624d654b2b51", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -139,6 +139,6 @@ subroutine check_alloc2(b)\n     end subroutine check_alloc2\n \n end program alloc\n-! { dg-final { scan-tree-dump-times \"builtin_free\" 24 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 27 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n ! { dg-final { cleanup-modules \"alloc_m\" } }"}, {"sha": "91145e7c246a44eb937245bbfe5592ca63499f7f", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -104,5 +104,5 @@ function blaha()\n     end function blaha\r\n \r\n end program test_constructor\r\n-! { dg-final { scan-tree-dump-times \"builtin_free\" 19 \"original\" } }\r\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 21 \"original\" } }\r\n ! { dg-final { cleanup-tree-dump \"original\" } }\r"}, {"sha": "db106ccee910647588fc90da258f069f5dad17bf", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_default_init_2.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_default_init_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_default_init_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_default_init_2.f90?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! Tests the fix for PR35959, in which the structure subpattern was declared static\n+! so that this test faied on the second recursive call.\n+!\n+! Contributed by Micha\ufffdl Baudin <michael.baudin@gmail.com>\n+!\n+program testprog\n+  type :: t_type\n+    integer, dimension(:), allocatable :: chars\n+  end type t_type\n+  integer, save :: callnb = 0\n+  type(t_type) :: this\n+  allocate ( this % chars ( 4))\n+  if (.not.recursivefunc (this) .or. (callnb .ne. 10)) call abort ()\n+contains\n+  recursive function recursivefunc ( this ) result ( match )\n+    type(t_type), intent(in) :: this\n+    type(t_type) :: subpattern\n+    logical :: match\n+    callnb = callnb + 1\n+    match = (callnb == 10)\n+    if ((.NOT. allocated (this % chars)) .OR. match) return\n+    allocate ( subpattern % chars ( 4 ) )\n+    match = recursivefunc ( subpattern )\n+  end function recursivefunc\n+end program testprog"}, {"sha": "3eeedbabd584cddf6d2df1dc80f3479d5f8cec66", "filename": "gcc/testsuite/gfortran.dg/array_constructor_23.f", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_23.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40eccb026f46cb33f5f1b7751b0c3b452881a0b/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_23.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_23.f?ref=f40eccb026f46cb33f5f1b7751b0c3b452881a0b", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! Tests the fix for PR35944/6/7, in which the variable array constructors below\n+! were incorrectly translated and wrong code was produced.\n+!\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+!\n+      program try_fa6013\n+      call fa6013 (10, 1, -1)\n+      call fa6077 (10, 1, -1, (/1,2,3,4,5,6,7,8,9,10/))\n+      call fa2083\n+      end program\n+\n+      subroutine  FA6013 (nf10, nf1, mf1)\n+      integer, parameter :: kv = 4\n+      REAL(KV) DDA1(10)\n+      REAL(KV) DDA2(10)\n+      REAL(KV) DDA(10), dval\n+      dda = (/1,2,3,4,5,6,7,8,9,10/)\n+      DDA1 = ATAN2 ((/(REAL(J1,KV),J1=1,10)/),\n+     $                 REAL((/(J1,J1=nf10,nf1,mf1)/), KV))   !fails\n+      DDA2 = ATAN2 (DDA, DDA(10:1:-1))\n+      if (any (DDA1 .ne. DDA2)) call abort ()\n+      END\n+\n+      subroutine FA6077 (nf10,nf1,mf1, ida)\n+      INTEGER IDA1(10)\n+      INTEGER IDA2(10), ida(10)\n+      IDA1 = IEOR((/1,2,3,4,5,6,7,8,9,10/),\n+     $            (/(IDA(J1),J1=10,1,-1)/) )\n+      IDA2 = IEOR ((/1,2,3,4,5,6,7,8,9,10/), (/10,9,8,7,6,5,4,3,2,1/) )\n+      if (any (ida1 .ne. ida2)) call abort ()\n+      END SUBROUTINE\n+\n+      subroutine fa2083\n+      implicit none\n+      integer j1,k\n+      parameter (k=10)              !failed\n+      REAL(k) QDA1(10)\n+      REAL(k) QDA(10), qval\n+      qda = (/ 1,2,3,4,5,6,7,8,9,10 /)\n+      QDA1 = MOD ( 1.1_k*( QDA(1) -5.0_k), P=( QDA -2.5_k))\n+      DO J1 = 1,10\n+        QVAL = MOD(1.1_k*(QDA(1)-5.0_k),P=(QDA(J1)-2.5_k))\n+        if (qval .ne. qda1(j1)) call abort ()\n+      ENDDO\n+      END\n+"}]}