{"sha": "6727c729849dc2feca833ecc874b6a0aef520acd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyN2M3Mjk4NDlkYzJmZWNhODMzZWNjODc0YjZhMGFlZjUyMGFjZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-05-16T15:33:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-05-16T15:33:01Z"}, "message": "tree-ssa-alias.c (alias_stats): Add aliasing_component_refs_p_may_alias and aliasing_component_refs_p_no_alias.\n\n\n\t* tree-ssa-alias.c (alias_stats): Add\n\taliasing_component_refs_p_may_alias and\n\taliasing_component_refs_p_no_alias.\n\t(dump_alias_stats): Print aliasing_component_refs_p stats.\n\t(aliasing_component_refs_p): Update stats.\n\nFrom-SVN: r271292", "tree": {"sha": "6d6cbb8ae82002432d1702061492c417ccc97b47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d6cbb8ae82002432d1702061492c417ccc97b47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6727c729849dc2feca833ecc874b6a0aef520acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6727c729849dc2feca833ecc874b6a0aef520acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6727c729849dc2feca833ecc874b6a0aef520acd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6727c729849dc2feca833ecc874b6a0aef520acd/comments", "author": null, "committer": null, "parents": [{"sha": "eba20412b43dbb36c57f4235e3a3fff2eb88ba9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eba20412b43dbb36c57f4235e3a3fff2eb88ba9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eba20412b43dbb36c57f4235e3a3fff2eb88ba9a"}], "stats": {"total": 60, "additions": 52, "deletions": 8}, "files": [{"sha": "6bff09cb2017a43f17845a9c514955b5f101548b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6727c729849dc2feca833ecc874b6a0aef520acd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6727c729849dc2feca833ecc874b6a0aef520acd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6727c729849dc2feca833ecc874b6a0aef520acd", "patch": "@@ -1,3 +1,11 @@\n+2019-05-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (alias_stats): Add\n+\taliasing_component_refs_p_may_alias and\n+\taliasing_component_refs_p_no_alias.\n+\t(dump_alias_stats): Print aliasing_component_refs_p stats.\n+\t(aliasing_component_refs_p): Update stats.\n+\n 2019-05-16  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/90500"}, {"sha": "895c03881a983e33f4d04f318c380f52fc181e9e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6727c729849dc2feca833ecc874b6a0aef520acd/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6727c729849dc2feca833ecc874b6a0aef520acd/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=6727c729849dc2feca833ecc874b6a0aef520acd", "patch": "@@ -98,6 +98,8 @@ static struct {\n   unsigned HOST_WIDE_INT ref_maybe_used_by_call_p_no_alias;\n   unsigned HOST_WIDE_INT call_may_clobber_ref_p_may_alias;\n   unsigned HOST_WIDE_INT call_may_clobber_ref_p_no_alias;\n+  unsigned HOST_WIDE_INT aliasing_component_refs_p_may_alias;\n+  unsigned HOST_WIDE_INT aliasing_component_refs_p_no_alias;\n } alias_stats;\n \n void\n@@ -122,6 +124,12 @@ dump_alias_stats (FILE *s)\n \t   alias_stats.call_may_clobber_ref_p_no_alias,\n \t   alias_stats.call_may_clobber_ref_p_no_alias\n \t   + alias_stats.call_may_clobber_ref_p_may_alias);\n+  fprintf (s, \"  aliasing_component_ref_p: \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n+\t   alias_stats.aliasing_component_refs_p_no_alias,\n+\t   alias_stats.aliasing_component_refs_p_no_alias\n+\t   + alias_stats.aliasing_component_refs_p_may_alias);\n   dump_alias_stats_in_alias_c (s);\n }\n \n@@ -822,7 +830,16 @@ aliasing_component_refs_p (tree ref1,\n       offset2 -= offadj;\n       get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp, &reverse);\n       offset1 -= offadj;\n-      return ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2);\n+      if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+\t{\n+\t  ++alias_stats.aliasing_component_refs_p_may_alias;\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  ++alias_stats.aliasing_component_refs_p_no_alias;\n+\t  return false;\n+\t}\n     }\n \n   /* If we didn't find a common base, try the other way around.  */\n@@ -840,14 +857,25 @@ aliasing_component_refs_p (tree ref1,\n       offset1 -= offadj;\n       get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n       offset2 -= offadj;\n-      return ranges_maybe_overlap_p (offset1, max_size1,\n-\t\t\t\t     offset2, max_size2);\n+      if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+\t{\n+\t  ++alias_stats.aliasing_component_refs_p_may_alias;\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  ++alias_stats.aliasing_component_refs_p_no_alias;\n+\t  return false;\n+\t}\n     }\n \n   /* In the remaining test we assume that there is no overlapping type\n      at all.  So if we are unsure, we need to give up.  */\n   if (same_p == -1 || same_p2 == -1)\n-    return true;\n+    {\n+      ++alias_stats.aliasing_component_refs_p_may_alias;\n+      return true;\n+    }\n \n   /* If we have two type access paths B1.path1 and B2.path2 they may\n      only alias if either B1 is in B2.path2 or B2 is in B1.path1.\n@@ -857,11 +885,19 @@ aliasing_component_refs_p (tree ref1,\n      tail of path2.  */\n   if (base1_alias_set == ref2_alias_set\n       || alias_set_subset_of (base1_alias_set, ref2_alias_set))\n-    return true;\n+    {\n+      ++alias_stats.aliasing_component_refs_p_may_alias;\n+      return true;\n+    }\n   /* If this is ptr vs. decl then we know there is no ptr ... decl path.  */\n-  if (!ref2_is_decl)\n-    return (base2_alias_set == ref1_alias_set\n-\t    || alias_set_subset_of (base2_alias_set, ref1_alias_set));\n+  if (!ref2_is_decl\n+      && (base2_alias_set == ref1_alias_set\n+\t  || alias_set_subset_of (base2_alias_set, ref1_alias_set)))\n+    {\n+      ++alias_stats.aliasing_component_refs_p_may_alias;\n+      return true;\n+    }\n+  ++alias_stats.aliasing_component_refs_p_no_alias;\n   return false;\n }\n "}]}