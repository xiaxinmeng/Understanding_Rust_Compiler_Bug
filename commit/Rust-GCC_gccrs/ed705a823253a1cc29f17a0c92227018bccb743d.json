{"sha": "ed705a823253a1cc29f17a0c92227018bccb743d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ3MDVhODIzMjUzYTFjYzI5ZjE3YTBjOTIyMjcwMThiY2NiNzQzZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1999-01-04T12:38:22Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1999-01-04T12:38:22Z"}, "message": "cpplib.c (skip_if_group): Split out the logic that handles directive recognition to its own function.\n\n1998-12-21 18:03 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n\t* cpplib.c (skip_if_group): Split out the logic that handles\n\tdirective recognition to its own function.  Don't use\n\tparse markers; use a bare pointer into the buffer.  Use\n\tcopy/skip_rest_of_line instead of doing it by hand.  Remove\n\t`return on any directive' mode which was never used, and take\n\tonly one argument.\n\t(consider_directive_while_skipping): New function, subroutine\n\tof skip_if_group.  Logic streamlined a bit.\n\t(conditional_skip, do_elif, do_else): Call skip_if_group with\n\tonly one argument.\n\nFrom-SVN: r24485", "tree": {"sha": "0a1bc5987f74612eb68088d8ed1418adfe74ce1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a1bc5987f74612eb68088d8ed1418adfe74ce1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed705a823253a1cc29f17a0c92227018bccb743d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed705a823253a1cc29f17a0c92227018bccb743d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed705a823253a1cc29f17a0c92227018bccb743d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed705a823253a1cc29f17a0c92227018bccb743d/comments", "author": null, "committer": null, "parents": [{"sha": "16deb3fb8f0ab29d3a16fd73e5a005e5805f3308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16deb3fb8f0ab29d3a16fd73e5a005e5805f3308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16deb3fb8f0ab29d3a16fd73e5a005e5805f3308"}], "stats": {"total": 301, "additions": 151, "deletions": 150}, "files": [{"sha": "f7785e6f1535b4e0d2623bbb51dd149d15e19a9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed705a823253a1cc29f17a0c92227018bccb743d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed705a823253a1cc29f17a0c92227018bccb743d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed705a823253a1cc29f17a0c92227018bccb743d", "patch": "@@ -299,6 +299,19 @@ Tue Dec 22 13:02:22 1998  Michael Meissner  <meissner@cygnus.com>\n \t* toplev.c (main): Delete handling of -dM as a preprocessor\n \toption.\n \n+1998-12-21 18:03 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+\t* cpplib.c (skip_if_group): Split out the logic that handles\n+\tdirective recognition to its own function.  Don't use\n+\tparse markers; use a bare pointer into the buffer.  Use\n+\tcopy/skip_rest_of_line instead of doing it by hand.  Remove\n+\t`return on any directive' mode which was never used, and take\n+\tonly one argument.\n+\t(consider_directive_while_skipping): New function, subroutine\n+\tof skip_if_group.  Logic streamlined a bit.\n+\t(conditional_skip, do_elif, do_else): Call skip_if_group with\n+\tonly one argument.\n+\n Mon Dec 21 17:39:38 1998  Michael Meissner  <meissner@cygnus.com>\n \n \t* toplev.c (main): Don't emit any warnings when using -dD, -dM, or"}, {"sha": "f9990c85125862f909e32708f16ef46babe54e60", "filename": "gcc/cpplib.c", "status": "modified", "additions": 138, "deletions": 150, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed705a823253a1cc29f17a0c92227018bccb743d/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed705a823253a1cc29f17a0c92227018bccb743d/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ed705a823253a1cc29f17a0c92227018bccb743d", "patch": "@@ -160,8 +160,8 @@ static void push_macro_expansion PARAMS ((cpp_reader *,\n static struct cpp_pending *nreverse_pending PARAMS ((struct cpp_pending *));\n \n static void conditional_skip\t\tPROTO ((cpp_reader *, int,\n-\t\t\t\t\t       enum node_type, U_CHAR *));\n-static void skip_if_group\t\tPROTO ((cpp_reader *, int));\n+\t\t\t\t\t\tenum node_type, U_CHAR *));\n+static void skip_if_group\t\tPROTO ((cpp_reader *));\n static int parse_name                   PARAMS ((cpp_reader *, int));\n static void print_help                  PROTO ((void));\n \n@@ -3549,11 +3549,11 @@ do_elif (pfile, keyword)\n   }\n \n   if (pfile->if_stack->if_succeeded)\n-    skip_if_group (pfile, 0);\n+    skip_if_group (pfile);\n   else {\n     HOST_WIDE_INT value = eval_if_expression (pfile);\n     if (value == 0)\n-      skip_if_group (pfile, 0);\n+      skip_if_group (pfile);\n     else {\n       ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n       output_line_command (pfile, 1, same_file);\n@@ -3695,175 +3695,163 @@ conditional_skip (pfile, skip, type, control_macro)\n   pfile->if_stack->type = type;\n \n   if (skip != 0) {\n-    skip_if_group (pfile, 0);\n+    skip_if_group (pfile);\n     return;\n   } else {\n     ++pfile->if_stack->if_succeeded;\n     output_line_command (pfile, 1, same_file);\n   }\n }\n \n-/*\n- * skip to #endif, #else, or #elif.  adjust line numbers, etc.\n+/* Subroutine of skip_if_group.\t Examine one preprocessing directive and\n+   return 0 if skipping should continue, 1 if it should halt.  Also\n+   adjusts the if_stack as appropriate.\n+   The `#' has been read, but not the identifier. */\n+\n+static int\n+consider_directive_while_skipping (pfile, stack)\n+    cpp_reader *pfile;\n+    IF_STACK_FRAME *stack; \n+{\n+  long ident_len, ident;\n+  struct directive *kt;\n+  IF_STACK_FRAME *temp;\n+    \n+  cpp_skip_hspace (pfile);\n+\n+  ident = CPP_WRITTEN (pfile);\n+  parse_name (pfile, GETC());\n+  ident_len = CPP_WRITTEN (pfile) - ident;\n+\n+  CPP_SET_WRITTEN (pfile, ident);\n+\n+  for (kt = directive_table; kt->length >= 0; kt++)\n+    if (kt->length == ident_len\n+\t&& strncmp (pfile->token_buffer + ident, kt->name, kt->length) == 0)\n+      switch (kt->type)\n+\t{\n+\tcase T_IF:\n+\tcase T_IFDEF:\n+\tcase T_IFNDEF:\n+\t    temp = (IF_STACK_FRAME *) xmalloc (sizeof (IF_STACK_FRAME));\n+\t    temp->next = pfile->if_stack;\n+\t    pfile->if_stack = temp;\n+\t    temp->fname = CPP_BUFFER(pfile)->nominal_fname;\n+\t    temp->type = kt->type;\n+\t    return 0;\n+\n+\tcase T_ELSE:\n+\t    if (CPP_PEDANTIC (pfile) && pfile->if_stack != stack)\n+\t      validate_else (pfile, \"#else\");\n+\t    /* fall through */\n+\tcase T_ELIF:\n+\t    if (pfile->if_stack->type == T_ELSE)\n+\t      cpp_error (pfile, \"`%s' after `#else'\", kt->name);\n+\t    \n+\t    if (pfile->if_stack == stack)\n+\t      return 1;\n+\t    else\n+\t      {\n+\t\tpfile->if_stack->type = kt->type;\n+\t\treturn 0;\n+\t      }\n+\n+\t    case T_ENDIF:\n+\t\tif (CPP_PEDANTIC (pfile) && pfile->if_stack != stack)\n+\t\t  validate_else (pfile, \"#endif\");\n+\n+\t\tif (pfile->if_stack == stack)\n+\t\t  return 1;\n+\t\t    \n+\t\ttemp = pfile->if_stack;\n+\t\tpfile->if_stack = temp->next;\n+\t\tfree (temp);\n+\t\treturn 0;\n+\n+\t    default:\n+\t\treturn 0;\n+\t    }\n+\n+    /* Don't let erroneous code go by.\t*/\n+    if (!CPP_OPTIONS (pfile)->lang_asm && CPP_PEDANTIC (pfile))\n+\tcpp_pedwarn (pfile, \"invalid preprocessor directive name\");\n+    return 0;\n+}\n+\n+/* skip to #endif, #else, or #elif.  adjust line numbers, etc.\n  * leaves input ptr at the sharp sign found.\n- * If ANY is nonzero, return at next directive of any sort.\n  */\n-\n static void\n-skip_if_group (pfile, any)\n-     cpp_reader *pfile;\n-     int any;\n+skip_if_group (pfile)\n+    cpp_reader *pfile;\n {\n   int c;\n-  struct directive *kt;\n   IF_STACK_FRAME *save_if_stack = pfile->if_stack; /* don't pop past here */\n-#if 0\n-  U_CHAR *beg_of_line = bp;\n-#endif\n-  register int ident_length;\n-  U_CHAR *ident;\n-  struct parse_marker line_start_mark;\n-\n-  parse_set_mark (&line_start_mark, pfile);\n-\n-  if (CPP_OPTIONS (pfile)->output_conditionals) {\n-    static char failed[] = \"#failed\\n\";\n-    CPP_PUTS (pfile, failed, sizeof(failed)-1);\n-    pfile->lineno++;\n-    output_line_command (pfile, 1, same_file);\n-  }\n+  U_CHAR *beg_of_line;\n+  long old_written;\n \n- beg_of_line:\n   if (CPP_OPTIONS (pfile)->output_conditionals)\n     {\n-      cpp_buffer *pbuf = CPP_BUFFER (pfile);\n-      U_CHAR *start_line = pbuf->buf + line_start_mark.position;\n-      CPP_PUTS (pfile, start_line, pbuf->cur - start_line);\n+      CPP_PUTS (pfile, \"#failed\\n\", 8);\n+      pfile->lineno++;\n+      output_line_command (pfile, 1, same_file);\n     }\n-  parse_move_mark (&line_start_mark, pfile);\n-  if (!CPP_TRADITIONAL (pfile))\n-      cpp_skip_hspace (pfile);\n-  c  = GETC();\n-  if (c == '#')\n-    {\n-      int old_written = CPP_WRITTEN (pfile);\n-      cpp_skip_hspace (pfile);\n \n-      parse_name (pfile, GETC());\n-      ident_length = CPP_WRITTEN (pfile) - old_written;\n-      ident = pfile->token_buffer + old_written;\n-      pfile->limit = ident;\n-#if 0\n-      if (ident_length == 0)\n-\tgoto not_a_directive;\n-\n-      /* Handle # followed by a line number.  */\n-\n-      /* Avoid error for `###' and similar cases unless -pedantic.  */\n-#endif\n+  old_written = CPP_WRITTEN (pfile);\n+  \n+  for (;;)\n+    {\n+      beg_of_line = CPP_BUFFER (pfile)->cur;\n \n-      for (kt = directive_table; kt->length >= 0; kt++)\n+      if (! CPP_TRADITIONAL (pfile))\n+\tcpp_skip_hspace (pfile);\n+      c = GETC();\n+      if (c == '\\n')\n \t{\n-\t  IF_STACK_FRAME *temp;\n-\t  if (ident_length == kt->length\n-\t      && strncmp (ident, kt->name, kt->length) == 0)\n-\t    {\n-\t      /* If we are asked to return on next directive, do so now.  */\n-\t      if (any)\n-\t\tgoto done;\n-\n-\t      switch (kt->type)\n-\t\t{\n-\t\tcase T_IF:\n-\t\tcase T_IFDEF:\n-\t\tcase T_IFNDEF:\n-\t\t  temp\n-\t\t    = (IF_STACK_FRAME *) xcalloc (1, sizeof (IF_STACK_FRAME));\n-\t\t  temp->next = pfile->if_stack;\n-\t\t  pfile->if_stack = temp;\n-#if 0\n-\t\t  temp->lineno = CPP_BUFFER(pfile)->lineno;\n-#endif\n-\t\t  temp->fname = CPP_BUFFER(pfile)->nominal_fname;\n-\t\t  temp->type = kt->type;\n-\t\t  break;\n-\t\tcase T_ELSE:\n-\t\tcase T_ENDIF:\n-\t\t  if (CPP_PEDANTIC (pfile) && pfile->if_stack != save_if_stack)\n-\t\t    validate_else (pfile,\n-\t\t\t\t   kt->type == T_ELSE ? \"#else\" : \"#endif\");\n-\t\tcase T_ELIF:\n-\t\t  if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n-\t\t    {\n-\t\t      cpp_error (pfile,\n-\t\t\t\t \"`#%s' not within a conditional\", kt->name);\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (pfile->if_stack == save_if_stack)\n-\t\t    goto done;\t\t/* found what we came for */\n+\t  if (CPP_OPTIONS (pfile)->output_conditionals)\n+\t    CPP_PUTC (pfile, c);\n+\t  continue;\n+\t}\n+      else if (c == '#')\n+\t{\n+\t  if (consider_directive_while_skipping (pfile, save_if_stack))\n+\t    break;\n+\t}\n+      else if (c == EOF)\n+\treturn;\t /* Caller will issue error. */\n \n-\t\t  if (kt->type != T_ENDIF)\n-\t\t    {\n-\t\t      if (pfile->if_stack->type == T_ELSE)\n-\t\t\tcpp_error (pfile, \"`#else' or `#elif' after `#else'\");\n-\t\t      pfile->if_stack->type = kt->type;\n-\t\t      break;\n-\t\t    }\n+      FORWARD(-1);\n+      if (CPP_OPTIONS (pfile)->output_conditionals)\n+\t{\n+\t  CPP_PUTS (pfile, beg_of_line, CPP_BUFFER (pfile)->cur - beg_of_line);\n+\t  copy_rest_of_line (pfile);\n+\t}\n+      else\n+\t{\n+\t  copy_rest_of_line (pfile);\n+\t  CPP_SET_WRITTEN (pfile, old_written);\t /* discard it */\n+\t}\n \n-\t\t  temp = pfile->if_stack;\n-\t\t  pfile->if_stack = temp->next;\n-\t\t  free (temp);\n-\t\t  break;\n-\t      default: ;\n-\t\t}\n-\t      break;\n-\t    }\n-\t  /* Don't let erroneous code go by.  */\n-\t  if (kt->length < 0 && !CPP_OPTIONS (pfile)->lang_asm\n-\t      && CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile, \"invalid preprocessor directive name\");\n+      c = GETC();\n+      if (c == EOF)\n+\treturn;\t /* Caller will issue error. */\n+      else\n+\t{\n+\t  /* \\n */\n+\t  if (CPP_OPTIONS (pfile)->output_conditionals)\n+\t    CPP_PUTC (pfile, c);\n \t}\n-      c = GETC ();\n-    }\n-  /* We're in the middle of a line.  Skip the rest of it.  */\n-  for (;;) {\n-    switch (c)\n-      {\n-\tlong old;\n-      case EOF:\n-\tgoto done;\n-      case '/':\t\t\t/* possible comment */\n-\tc = skip_comment (pfile, NULL);\n-\tif (c == EOF)\n-\t  goto done;\n-\tbreak;\n-      case '\\\"':\n-      case '\\'':\n-\tFORWARD(-1);\n-\told = CPP_WRITTEN (pfile);\n-\tcpp_get_token (pfile);\n-\tCPP_SET_WRITTEN (pfile, old);\n-\tbreak;\n-      case '\\\\':\n-\t/* Char after backslash loses its special meaning.  */\n-\tif (PEEKC() == '\\n')\n-\t  FORWARD (1);\n-\tbreak;\n-      case '\\n':\n-\tgoto beg_of_line;\n-\tbreak;\n-      }\n-    c = GETC ();\n-  }\n- done:\n-  if (CPP_OPTIONS (pfile)->output_conditionals) {\n-    static char end_failed[] = \"#endfailed\\n\";\n-    CPP_PUTS (pfile, end_failed, sizeof(end_failed)-1);\n-    pfile->lineno++;\n-  }\n+    }\t  \n+\n+  /* Back up to the beginning of this line.  Caller will process the\n+     directive. */\n+  CPP_BUFFER (pfile)->cur = beg_of_line;\n   pfile->only_seen_white = 1;\n-  parse_goto_mark (&line_start_mark, pfile);\n-  parse_clear_mark (&line_start_mark);\n+  if (CPP_OPTIONS (pfile)->output_conditionals)\n+    {\n+      CPP_PUTS (pfile, \"#endfailed\\n\", 11);\n+      pfile->lineno++;\n+    }\n }\n \n /*\n@@ -3903,7 +3891,7 @@ do_else (pfile, keyword)\n   }\n \n   if (pfile->if_stack->if_succeeded)\n-    skip_if_group (pfile, 0);\n+    skip_if_group (pfile);\n   else {\n     ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n     output_line_command (pfile, 1, same_file);"}]}