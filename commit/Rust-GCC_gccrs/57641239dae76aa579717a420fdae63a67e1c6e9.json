{"sha": "57641239dae76aa579717a420fdae63a67e1c6e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc2NDEyMzlkYWU3NmFhNTc5NzE3YTQyMGZkYWU2M2E2N2UxYzZlOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-19T13:24:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-19T13:24:56Z"}, "message": "(struct case_node): New member balance.\n\n(add_case_node): New function.\n(pushcase, pushcase_range): Use it.\n(case_tree2list): New function.\n(expand_end_case): Use it.\n\nFrom-SVN: r11565", "tree": {"sha": "c8bde45efdf311202f6364ab8c366dd3530522c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8bde45efdf311202f6364ab8c366dd3530522c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57641239dae76aa579717a420fdae63a67e1c6e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57641239dae76aa579717a420fdae63a67e1c6e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57641239dae76aa579717a420fdae63a67e1c6e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57641239dae76aa579717a420fdae63a67e1c6e9/comments", "author": null, "committer": null, "parents": [{"sha": "314d1f3c2883033de837657a272eeb26e22e441d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314d1f3c2883033de837657a272eeb26e22e441d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/314d1f3c2883033de837657a272eeb26e22e441d"}], "stats": {"total": 309, "additions": 248, "deletions": 61}, "files": [{"sha": "cf37bb7888ddaf0478e22636a40a644e0b1cdbaa", "filename": "gcc/stmt.c", "status": "modified", "additions": 248, "deletions": 61, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57641239dae76aa579717a420fdae63a67e1c6e9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57641239dae76aa579717a420fdae63a67e1c6e9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=57641239dae76aa579717a420fdae63a67e1c6e9", "patch": "@@ -168,6 +168,7 @@ struct case_node\n   tree\t\t\tlow;\t/* Lowest index value for this label */\n   tree\t\t\thigh;\t/* Highest index value for this label */\n   tree\t\t\tcode_label; /* Label to jump to when node matches */\n+  int\t\t\tbalance;\n };\n \n typedef struct case_node case_node;\n@@ -285,10 +286,9 @@ struct nesting\n \t     A label is needed for skipping over this block. It is only\n \t     used when generating bytecodes. */\n \t  rtx skip_label;\n-\t  /* A list of case labels, kept in ascending order by value\n-\t     as the list is built.\n-\t     During expand_end_case, this list may be rearranged into a\n-\t     nearly balanced binary tree.  */\n+\t  /* A list of case labels; it is first built as an AVL tree.\n+\t     During expand_end_case, this is converted to a list, and may be\n+\t     rearranged into a nearly balanced binary tree.  */\n \t  struct case_node *case_list;\n \t  /* Label to jump to if no case matches.  */\n \t  tree default_label;\n@@ -462,6 +462,8 @@ static int node_has_high_bound\t\tPROTO((case_node_ptr, tree));\n static int node_is_bounded\t\tPROTO((case_node_ptr, tree));\n static void emit_jump_if_reachable\tPROTO((rtx));\n static void emit_case_nodes\t\tPROTO((rtx, case_node_ptr, rtx, tree));\n+static int add_case_node\t\tPROTO((tree, tree, tree, tree *));\n+static struct case_node *case_tree2list\tPROTO((case_node *, case_node *));\n \n extern rtx bc_allocate_local ();\n extern rtx bc_allocate_variable_array ();\n@@ -4096,36 +4098,7 @@ pushcase (value, converter, label, duplicate)\n       case_stack->data.case_stmt.default_label = label;\n     }\n   else\n-    {\n-      /* Find the elt in the chain before which to insert the new value,\n-\t to keep the chain sorted in increasing order.\n-\t But report an error if this element is a duplicate.  */\n-      for (l = &case_stack->data.case_stmt.case_list;\n-\t   /* Keep going past elements distinctly less than VALUE.  */\n-\t   *l != 0 && tree_int_cst_lt ((*l)->high, value);\n-\t   l = &(*l)->right)\n-\t;\n-      if (*l)\n-\t{\n-\t  /* Element we will insert before must be distinctly greater;\n-\t     overlap means error.  */\n-\t  if (! tree_int_cst_lt (value, (*l)->low))\n-\t    {\n-\t      *duplicate = (*l)->code_label;\n-\t      return 2;\n-\t    }\n-\t}\n-\n-      /* Add this label to the chain, and succeed.\n-\t Copy VALUE so it is on temporary rather than momentary\n-\t obstack and will thus survive till the end of the case statement.  */\n-      n = (struct case_node *) oballoc (sizeof (struct case_node));\n-      n->left = 0;\n-      n->right = *l;\n-      n->high = n->low = copy_node (value);\n-      n->code_label = label;\n-      *l = n;\n-    }\n+    return add_case_node (value, value, label, duplicate);\n \n   expand_label (label);\n   return 0;\n@@ -4205,49 +4178,237 @@ pushcase_range (value1, value2, converter, label, duplicate)\n   if (tree_int_cst_lt (value2, value1))\n     return 4;\n \n-  /* If the bounds are equal, turn this into the one-value case.  */\n-  if (tree_int_cst_equal (value1, value2))\n-    return pushcase (value1, converter, label, duplicate);\n-\n-  /* Find the elt in the chain before which to insert the new value,\n-     to keep the chain sorted in increasing order.\n-     But report an error if this element is a duplicate.  */\n-  for (l = &case_stack->data.case_stmt.case_list;\n-       /* Keep going past elements distinctly less than this range.  */\n-       *l != 0 && tree_int_cst_lt ((*l)->high, value1);\n-       l = &(*l)->right)\n-    ;\n-  if (*l)\n+  return add_case_node (value1, value2, label, duplicate);\n+}\n+\n+/* Do the actual insertion of a case label for pushcase and pushcase_range\n+   into case_stack->data.case_stmt.case_list.  Use an AVL tree to avoid\n+   slowdown for large switch statements.  */\n+\n+static int\n+add_case_node (low, high, label, duplicate)\n+     tree low, high;\n+     tree label;\n+     tree *duplicate;\n+{\n+  struct case_node *p, **q, *r;\n+\n+  q = &case_stack->data.case_stmt.case_list;\n+  p = *q;\n+\n+  while (r = *q)\n     {\n-      /* Element we will insert before must be distinctly greater;\n-\t overlap means error.  */\n-      if (! tree_int_cst_lt (value2, (*l)->low))\n+      p = r;\n+\n+      /* Keep going past elements distinctly greater than HIGH.  */\n+      if (tree_int_cst_lt (high, p->low))\n+\tq = &p->left;\n+\n+      /* or distinctly less than LOW.  */\n+      else if (tree_int_cst_lt (p->high, low))\n+\tq = &p->right;\n+\n+      else\n \t{\n-\t  *duplicate = (*l)->code_label;\n+\t  /* We have an overlap; this is an error.  */\n+\t  *duplicate = p->code_label;\n \t  return 2;\n \t}\n     }\n \n   /* Add this label to the chain, and succeed.\n-     Copy VALUE1, VALUE2 so they are on temporary rather than momentary\n+     Copy LOW, HIGH so they are on temporary rather than momentary\n      obstack and will thus survive till the end of the case statement.  */\n \n-  n = (struct case_node *) oballoc (sizeof (struct case_node));\n-  n->left = 0;\n-  n->right = *l;\n-  n->low = copy_node (value1);\n-  n->high = copy_node (value2);\n-  n->code_label = label;\n-  *l = n;\n+  r = (struct case_node *) oballoc (sizeof (struct case_node));\n+  r->low = copy_node (low);\n \n+  /* If the bounds are equal, turn this into the one-value case.  */\n+\n+  if (tree_int_cst_equal (low, high))\n+    r->high = r->low;\n+  else\n+    {\n+      r->high = copy_node (high);\n+      case_stack->data.case_stmt.num_ranges++;\n+    }\n+\n+  r->code_label = label;\n   expand_label (label);\n \n-  case_stack->data.case_stmt.num_ranges++;\n+  *q = r;\n+  r->parent = p;\n+  r->left = 0;\n+  r->right = 0;\n+  r->balance = 0;\n+\n+  while (p)\n+    {\n+      struct case_node *s;\n+\n+      if (r == p->left)\n+\t{\n+\t  int b;\n+\n+\t  if (! (b = p->balance))\n+\t    /* Growth propagation from left side.  */\n+\t    p->balance = -1;\n+\t  else if (b < 0)\n+\t    {\n+\t      if (r->balance < 0)\n+\t\t{\n+\t\t  /* R-Rotation */\n+\t\t  if (p->left = s = r->right)\n+\t\t    s->parent = p;\n+\n+\t\t  r->right = p;\n+\t\t  p->balance = 0;\n+\t\t  r->balance = 0;\n+\t\t  s = p->parent;\n+\t\t  p->parent = r;\n+\n+\t\t  if (r->parent = s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = r;\n+\t\t      else\n+\t\t\ts->right = r;\n+\t\t    }\n+\t\t  else\n+\t\t    case_stack->data.case_stmt.case_list = r;\n+\t\t}\n+\t      else\n+\t\t/* r->balance == +1 */\n+\t\t{\n+\t\t  int b2;\n+\t\t  struct case_node *t = r->right;\n+\n+\t\t  if (p->left = s = t->right)\n+\t\t    s->parent = p;\n+\n+\t\t  t->right = p;\n+\t\t  if (r->right = s = t->left)\n+\t\t    s->parent = r;\n+\n+\t\t  t->left = r;\n+\t\t  b = t->balance;\n+\t\t  b2 = b < 0;\n+\t\t  p->balance = b2;\n+\t\t  b2 = -b2 - b;\n+\t\t  r->balance = b2;\n+\t\t  t->balance = 0;\n+\t\t  s = p->parent;\n+\t\t  p->parent = t;\n+\t\t  r->parent = t;\n+\n+\t\t  if (t->parent = s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = t;\n+\t\t      else\n+\t\t\ts->right = t;\n+\t\t    }\n+\t\t  else\n+\t\t    case_stack->data.case_stmt.case_list = t;\n+\t\t}\n+\t      break;\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      /* p->balance == +1; growth of left side balances the node.  */\n+\t      p->balance = 0;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t/* r == p->right */\n+\t{\n+\t  int b;\n+\n+\t  if (! (b = p->balance))\n+\t    /* Growth propagation from right side.  */\n+\t    p->balance++;\n+\t  else if (b > 0)\n+\t    {\n+\t      if (r->balance > 0)\n+\t\t{\n+\t\t  /* L-Rotation */\n+\n+\t\t  if (p->right = s = r->left)\n+\t\t    s->parent = p;\n+\n+\t\t  r->left = p;\n+\t\t  p->balance = 0;\n+\t\t  r->balance = 0;\n+\t\t  s = p->parent;\n+\t\t  p->parent = r;\n+\t\t  if (r->parent = s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = r;\n+\t\t      else\n+\t\t\ts->right = r;\n+\t\t    }\n+\n+\t\t  else\n+\t\t    case_stack->data.case_stmt.case_list = r;\n+\t\t}\n+\n+\t      else\n+\t\t/* r->balance == -1 */\n+\t\t{\n+\t\t  /* RL-Rotation */\n+\t\t  int b2;\n+\t\t  struct case_node *t = r->left;\n+\n+\t\t  if (p->right = s = t->left)\n+\t\t    s->parent = p;\n+\n+\t\t  t->left = p;\n+\n+\t\t  if (r->left = s = t->right)\n+\t\t    s->parent = r;\n+\n+\t\t  t->right = r;\n+\t\t  b = t->balance;\n+\t\t  b2 = b < 0;\n+\t\t  r->balance = b2;\n+\t\t  b2 = -b2 - b;\n+\t\t  p->balance = b2;\n+\t\t  t->balance = 0;\n+\t\t  s = p->parent;\n+\t\t  p->parent = t;\n+\t\t  r->parent = t;\n+\n+\t\t  if (t->parent = s)\n+\t\t    {\n+\t\t      if (s->left == p)\n+\t\t\ts->left = t;\n+\t\t      else\n+\t\t\ts->right = t;\n+\t\t    }\n+\n+\t\t  else\n+\t\t    case_stack->data.case_stmt.case_list = t;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* p->balance == -1; growth of right side balances the node.  */\n+\t      p->balance = 0;\n+\t      break;\n+\t    }\n+\t}\n+\n+      r = p;\n+      p = p->parent;\n+    }\n \n   return 0;\n }\n \n-\n /* Accumulate one case or default label; VALUE is the value of the\n    case, or nil for a default label.  If not currently inside a case,\n    return 1 and do nothing.  If VALUE is a duplicate or overlaps, return\n@@ -4747,6 +4908,10 @@ expand_end_case (orig_index)\n \n       before_case = get_last_insn ();\n \n+      if (thiscase->data.case_stmt.case_list)\n+\tthiscase->data.case_stmt.case_list\n+\t  = case_tree2list(thiscase->data.case_stmt.case_list, 0);\n+\n       /* Simplify the case-list before we count it.  */\n       group_case_nodes (thiscase->data.case_stmt.case_list);\n \n@@ -5066,6 +5231,28 @@ expand_end_case (orig_index)\n   free_temp_slots ();\n }\n \n+/* Convert the tree NODE into a list linked by the right field, with the left\n+   field zeroed.  RIGHT is used for recursion; it is a list to be placed\n+   rightmost in the resulting list.  */\n+\n+static struct case_node *\n+case_tree2list (node, right)\n+     struct case_node *node, *right;\n+{\n+  struct case_node *left;\n+\n+  if (node->right)\n+    right = case_tree2list (node->right, right);\n+\n+  node->right = right;\n+  if (left = node->left)\n+    {\n+      node->left = 0;\n+      return case_tree2list (left, node);\n+    }\n+\n+  return node;\n+}\n \n /* Terminate a case statement.  EXPR is the original index\n    expression.  */"}]}