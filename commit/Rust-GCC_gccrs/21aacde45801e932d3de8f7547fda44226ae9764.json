{"sha": "21aacde45801e932d3de8f7547fda44226ae9764", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFhYWNkZTQ1ODAxZTkzMmQzZGU4Zjc1NDdmZGE0NDIyNmFlOTc2NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-24T12:36:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-24T12:36:00Z"}, "message": "fold-const.c (fold_binary_loc): Move simplifying of comparisons against the highest or lowest possible integer ...\n\n2015-07-24  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (fold_binary_loc): Move simplifying of comparisons\n\tagainst the highest or lowest possible integer ...\n\t* match.pd: ... as patterns here.\n\nFrom-SVN: r226153", "tree": {"sha": "8948aaf78d810c2c69d7460cb413fab878376c75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8948aaf78d810c2c69d7460cb413fab878376c75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21aacde45801e932d3de8f7547fda44226ae9764", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21aacde45801e932d3de8f7547fda44226ae9764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21aacde45801e932d3de8f7547fda44226ae9764", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21aacde45801e932d3de8f7547fda44226ae9764/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa138f6efd4329d7c27f1614efe14c49780b0d64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa138f6efd4329d7c27f1614efe14c49780b0d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa138f6efd4329d7c27f1614efe14c49780b0d64"}], "stats": {"total": 190, "additions": 73, "deletions": 117}, "files": [{"sha": "d7f6ca5c77c99016355769e7693aefa4743b3d8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21aacde45801e932d3de8f7547fda44226ae9764/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21aacde45801e932d3de8f7547fda44226ae9764/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21aacde45801e932d3de8f7547fda44226ae9764", "patch": "@@ -1,3 +1,9 @@\n+2015-07-24  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (fold_binary_loc): Move simplifying of comparisons\n+\tagainst the highest or lowest possible integer ...\n+\t* match.pd: ... as patterns here.\n+\n 2015-07-24  Richard Biener  <rguenther@suse.de>\n \n \t* genmatch.c (struct capture_info): Add same_as field."}, {"sha": "739a3a98e29e73a95f1686f10cf7cc9dbd292b84", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21aacde45801e932d3de8f7547fda44226ae9764/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21aacde45801e932d3de8f7547fda44226ae9764/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=21aacde45801e932d3de8f7547fda44226ae9764", "patch": "@@ -11617,123 +11617,6 @@ fold_binary_loc (location_t loc,\n \t    }\n \t}\n \n-      /* Comparisons with the highest or lowest possible integer of\n-\t the specified precision will have known values.  */\n-      {\n-\ttree arg1_type = TREE_TYPE (arg1);\n-\tunsigned int prec = TYPE_PRECISION (arg1_type);\n-\n-\tif (TREE_CODE (arg1) == INTEGER_CST\n-\t    && (INTEGRAL_TYPE_P (arg1_type) || POINTER_TYPE_P (arg1_type)))\n-\t  {\n-\t    wide_int max = wi::max_value (arg1_type);\n-\t    wide_int signed_max = wi::max_value (prec, SIGNED);\n-\t    wide_int min = wi::min_value (arg1_type);\n-\n-\t    if (wi::eq_p (arg1, max))\n-\t      switch (code)\n-\t\t{\n-\t\tcase GT_EXPR:\n-\t\t  return omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n-\n-\t\tcase GE_EXPR:\n-\t\t  return fold_build2_loc (loc, EQ_EXPR, type, op0, op1);\n-\n-\t\tcase LE_EXPR:\n-\t\t  return omit_one_operand_loc (loc, type, integer_one_node, arg0);\n-\n-\t\tcase LT_EXPR:\n-\t\t  return fold_build2_loc (loc, NE_EXPR, type, op0, op1);\n-\n-\t\t/* The GE_EXPR and LT_EXPR cases above are not normally\n-\t\t   reached because of previous transformations.  */\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    else if (wi::eq_p (arg1, max - 1))\n-\t      switch (code)\n-\t\t{\n-\t\tcase GT_EXPR:\n-\t\t  arg1 = const_binop (PLUS_EXPR, arg1,\n-\t\t\t\t      build_int_cst (TREE_TYPE (arg1), 1));\n-\t\t  return fold_build2_loc (loc, EQ_EXPR, type,\n-\t\t\t\t      fold_convert_loc (loc,\n-\t\t\t\t\t\t\tTREE_TYPE (arg1), arg0),\n-\t\t\t\t      arg1);\n-\t\tcase LE_EXPR:\n-\t\t  arg1 = const_binop (PLUS_EXPR, arg1,\n-\t\t\t\t      build_int_cst (TREE_TYPE (arg1), 1));\n-\t\t  return fold_build2_loc (loc, NE_EXPR, type,\n-\t\t\t\t      fold_convert_loc (loc, TREE_TYPE (arg1),\n-\t\t\t\t\t\t\targ0),\n-\t\t\t\t      arg1);\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    else if (wi::eq_p (arg1, min))\n-\t      switch (code)\n-\t\t{\n-\t\tcase LT_EXPR:\n-\t\t  return omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n-\n-\t\tcase LE_EXPR:\n-\t\t  return fold_build2_loc (loc, EQ_EXPR, type, op0, op1);\n-\n-\t\tcase GE_EXPR:\n-\t\t  return omit_one_operand_loc (loc, type, integer_one_node, arg0);\n-\n-\t\tcase GT_EXPR:\n-\t\t  return fold_build2_loc (loc, NE_EXPR, type, op0, op1);\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    else if (wi::eq_p (arg1, min + 1))\n-\t      switch (code)\n-\t\t{\n-\t\tcase GE_EXPR:\n-\t\t  arg1 = const_binop (MINUS_EXPR, arg1,\n-\t\t\t\t      build_int_cst (TREE_TYPE (arg1), 1));\n-\t\t  return fold_build2_loc (loc, NE_EXPR, type,\n-\t\t\t\t      fold_convert_loc (loc,\n-\t\t\t\t\t\t\tTREE_TYPE (arg1), arg0),\n-\t\t\t\t      arg1);\n-\t\tcase LT_EXPR:\n-\t\t  arg1 = const_binop (MINUS_EXPR, arg1,\n-\t\t\t\t      build_int_cst (TREE_TYPE (arg1), 1));\n-\t\t  return fold_build2_loc (loc, EQ_EXPR, type,\n-\t\t\t\t      fold_convert_loc (loc, TREE_TYPE (arg1),\n-\t\t\t\t\t\t\targ0),\n-\t\t\t\t      arg1);\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\n-\t    else if (wi::eq_p (arg1, signed_max)\n-\t\t     && TYPE_UNSIGNED (arg1_type)\n-\t\t     /* We will flip the signedness of the comparison operator\n-\t\t\tassociated with the mode of arg1, so the sign bit is\n-\t\t\tspecified by this mode.  Check that arg1 is the signed\n-\t\t\tmax associated with this sign bit.  */\n-\t\t     && prec == GET_MODE_PRECISION (TYPE_MODE (arg1_type))\n-\t\t     /* signed_type does not work on pointer types.  */\n-\t\t     && INTEGRAL_TYPE_P (arg1_type))\n-\t      {\n-\t\t/* The following case also applies to X < signed_max+1\n-\t\t   and X >= signed_max+1 because previous transformations.  */\n-\t\tif (code == LE_EXPR || code == GT_EXPR)\n-\t\t  {\n-\t\t    tree st = signed_type_for (arg1_type);\n-\t\t    return fold_build2_loc (loc,\n-\t\t\t\t\tcode == LE_EXPR ? GE_EXPR : LT_EXPR,\n-\t\t\t\t\ttype, fold_convert_loc (loc, st, arg0),\n-\t\t\t\t\tbuild_int_cst (st, 0));\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n       /* If we are comparing an ABS_EXPR with a constant, we can\n \t convert all the cases into explicit comparisons, but they may\n \t well not be faster than doing the ABS and one comparison."}, {"sha": "3d53abffe25712ef18aa36171a928a8d055ee608", "filename": "gcc/match.pd", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21aacde45801e932d3de8f7547fda44226ae9764/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21aacde45801e932d3de8f7547fda44226ae9764/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=21aacde45801e932d3de8f7547fda44226ae9764", "patch": "@@ -1824,6 +1824,73 @@ along with GCC; see the file COPYING3.  If not see\n    { constant_boolean_node (cmp == NE_EXPR, type); })))\n \n \n+/* Non-equality compare simplifications from fold_binary  */\n+(for cmp (lt gt le ge)\n+ /* Comparisons with the highest or lowest possible integer of\n+    the specified precision will have known values.  */\n+ (simplify\n+  (cmp (convert?@2 @0) INTEGER_CST@1)\n+  (if ((INTEGRAL_TYPE_P (TREE_TYPE (@1)) || POINTER_TYPE_P (TREE_TYPE (@1)))\n+       && tree_nop_conversion_p (TREE_TYPE (@2), TREE_TYPE (@0)))\n+   (with\n+    {\n+      tree arg1_type = TREE_TYPE (@1);\n+      unsigned int prec = TYPE_PRECISION (arg1_type);\n+      wide_int max = wi::max_value (arg1_type);\n+      wide_int signed_max = wi::max_value (prec, SIGNED);\n+      wide_int min = wi::min_value (arg1_type);\n+    }\n+    (switch\n+     (if (wi::eq_p (@1, max))\n+      (switch\n+       (if (cmp == GT_EXPR)\n+\t{ constant_boolean_node (false, type); })\n+       (if (cmp == GE_EXPR)\n+\t(eq @2 @1))\n+       (if (cmp == LE_EXPR)\n+\t{ constant_boolean_node (true, type); })\n+       (if (cmp == LT_EXPR)\n+\t(ne @2 @1))))\n+     (if (wi::eq_p (@1, max - 1))\n+      (switch\n+       (if (cmp == GT_EXPR)\n+        (eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::add (@1, 1)); }))\n+       (if (cmp == LE_EXPR)\n+        (ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::add (@1, 1)); }))))\n+     (if (wi::eq_p (@1, min))\n+      (switch\n+       (if (cmp == LT_EXPR)\n+        { constant_boolean_node (false, type); })\n+       (if (cmp == LE_EXPR)\n+        (eq @2 @1))\n+       (if (cmp == GE_EXPR)\n+        { constant_boolean_node (true, type); })\n+       (if (cmp == GT_EXPR)\n+        (ne @2 @1))))\n+     (if (wi::eq_p (@1, min + 1))\n+      (switch\n+       (if (cmp == GE_EXPR)\n+        (ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::sub (@1, 1)); }))\n+       (if (cmp == LT_EXPR)\n+        (eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::sub (@1, 1)); }))))\n+     (if (wi::eq_p (@1, signed_max)\n+\t  && TYPE_UNSIGNED (arg1_type)\n+\t  /* We will flip the signedness of the comparison operator\n+\t     associated with the mode of @1, so the sign bit is\n+\t     specified by this mode.  Check that @1 is the signed\n+\t     max associated with this sign bit.  */\n+\t  && prec == GET_MODE_PRECISION (TYPE_MODE (arg1_type))\n+\t  /* signed_type does not work on pointer types.  */\n+\t  && INTEGRAL_TYPE_P (arg1_type))\n+      /* The following case also applies to X < signed_max+1\n+\t and X >= signed_max+1 because previous transformations.  */\n+      (if (cmp == LE_EXPR || cmp == GT_EXPR)\n+       (with { tree st = signed_type_for (arg1_type); }\n+        (if (cmp == LE_EXPR)\n+\t (ge (convert:st @0) { build_zero_cst (st); })\n+\t (lt (convert:st @0) { build_zero_cst (st); }))))))))))\n+ \n+\n /* bool_var != 0 becomes bool_var.  */\n (simplify\n  (ne @0 integer_zerop@1)"}]}