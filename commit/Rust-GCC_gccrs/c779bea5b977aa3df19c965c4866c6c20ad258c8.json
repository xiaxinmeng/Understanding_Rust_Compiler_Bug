{"sha": "c779bea5b977aa3df19c965c4866c6c20ad258c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc3OWJlYTViOTc3YWEzZGYxOWM5NjVjNDg2NmM2YzIwYWQyNThjOA==", "commit": {"author": {"name": "Yury Gribov", "email": "tetra2005@gmail.com", "date": "2017-08-04T20:29:12Z"}, "committer": {"name": "Yury Gribov", "email": "ygribov@gcc.gnu.org", "date": "2017-08-04T20:29:12Z"}, "message": "Remove useless floating point casts in comparisons.\n\n2017-08-04  Yury Gribov  <tetra2005@gmail.com>\n\n\tPR tree-optimization/57371\n\ngcc/\n\t* match.pd: New pattern.\n\ngcc/testsuite/\n\t* c-c++-common/pr57371-1.c: New test.\n\t* c-c++-common/pr57371-2.c: New test.\n\t* c-c++-common/pr57371-3.c: New test.\n\t* c-c++-common/pr57371-4.c: New test.\n\t* gcc.dg/pr57371-5.c: New test.\n\nFrom-SVN: r250877", "tree": {"sha": "1d204f2e5879f51d432b6570c00672fc37d7a27d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d204f2e5879f51d432b6570c00672fc37d7a27d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c779bea5b977aa3df19c965c4866c6c20ad258c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c779bea5b977aa3df19c965c4866c6c20ad258c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c779bea5b977aa3df19c965c4866c6c20ad258c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c779bea5b977aa3df19c965c4866c6c20ad258c8/comments", "author": {"login": "yugr", "id": 1101391, "node_id": "MDQ6VXNlcjExMDEzOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1101391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yugr", "html_url": "https://github.com/yugr", "followers_url": "https://api.github.com/users/yugr/followers", "following_url": "https://api.github.com/users/yugr/following{/other_user}", "gists_url": "https://api.github.com/users/yugr/gists{/gist_id}", "starred_url": "https://api.github.com/users/yugr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yugr/subscriptions", "organizations_url": "https://api.github.com/users/yugr/orgs", "repos_url": "https://api.github.com/users/yugr/repos", "events_url": "https://api.github.com/users/yugr/events{/privacy}", "received_events_url": "https://api.github.com/users/yugr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e52341f1613a7589425d6eba31a6d5e0500465bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52341f1613a7589425d6eba31a6d5e0500465bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e52341f1613a7589425d6eba31a6d5e0500465bd"}], "stats": {"total": 541, "additions": 541, "deletions": 0}, "files": [{"sha": "ea3b2e327bde420d5895e25125dd2254f06decb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -1,3 +1,8 @@\n+2017-08-04  Yury Gribov  <tetra2005@gmail.com>\n+\n+\tPR tree-optimization/57371\n+\t* match.pd: New pattern.\n+\n 2017-08-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR middle-end/81695"}, {"sha": "0e36f46b914bc63c257cef47152ab1aa507963e5", "filename": "gcc/match.pd", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -2899,6 +2899,80 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       (if (! HONOR_NANS (@0))\n \t(cmp @0 @1))))))\n \n+/* Optimize various special cases of (FTYPE) N CMP CST.  */\n+(for cmp  (lt le eq ne ge gt)\n+     icmp (le le eq ne ge ge)\n+ (simplify\n+  (cmp (float @0) REAL_CST@1)\n+   (if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (@1))\n+\t&& ! DECIMAL_FLOAT_TYPE_P (TREE_TYPE (@1)))\n+    (with\n+     {\n+       tree itype = TREE_TYPE (@0);\n+       signop isign = TYPE_SIGN (itype);\n+       format_helper fmt (REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (@1))));\n+       const REAL_VALUE_TYPE *cst = TREE_REAL_CST_PTR (@1);\n+       /* Be careful to preserve any potential exceptions due to\n+\t  NaNs.  qNaNs are ok in == or != context.\n+\t  TODO: relax under -fno-trapping-math or\n+\t  -fno-signaling-nans.  */\n+       bool exception_p\n+         = real_isnan (cst) && (cst->signalling\n+\t\t\t\t|| (cmp != EQ_EXPR || cmp != NE_EXPR));\n+       /* INT?_MIN is power-of-two so it takes\n+\t  only one mantissa bit.  */\n+       bool signed_p = isign == SIGNED;\n+       bool itype_fits_ftype_p\n+\t = TYPE_PRECISION (itype) - signed_p <= significand_size (fmt);\n+     }\n+     /* TODO: allow non-fitting itype and SNaNs when\n+\t-fno-trapping-math.  */\n+     (if (itype_fits_ftype_p && ! exception_p)\n+      (with\n+       {\n+\t REAL_VALUE_TYPE imin, imax;\n+\t real_from_integer (&imin, fmt, wi::min_value (itype), isign);\n+\t real_from_integer (&imax, fmt, wi::max_value (itype), isign);\n+\n+\t REAL_VALUE_TYPE icst;\n+\t if (cmp == GT_EXPR || cmp == GE_EXPR)\n+\t   real_ceil (&icst, fmt, cst);\n+\t else if (cmp == LT_EXPR || cmp == LE_EXPR)\n+\t   real_floor (&icst, fmt, cst);\n+\t else\n+\t   real_trunc (&icst, fmt, cst);\n+\n+\t bool cst_int_p = real_identical (&icst, cst);\n+\n+\t bool overflow_p = false;\n+\t wide_int icst_val\n+\t   = real_to_integer (&icst, &overflow_p, TYPE_PRECISION (itype));\n+       }\n+       (switch\n+\t/* Optimize cases when CST is outside of ITYPE's range.  */\n+\t(if (real_compare (LT_EXPR, cst, &imin))\n+\t { constant_boolean_node (cmp == GT_EXPR || cmp == GE_EXPR || cmp == NE_EXPR,\n+\t\t\t\t  type); })\n+\t(if (real_compare (GT_EXPR, cst, &imax))\n+\t { constant_boolean_node (cmp == LT_EXPR || cmp == LE_EXPR || cmp == NE_EXPR,\n+\t\t\t\t  type); })\n+\t/* Remove cast if CST is an integer representable by ITYPE.  */\n+\t(if (cst_int_p)\n+\t (cmp @0 { gcc_assert (!overflow_p);\n+\t\t   wide_int_to_tree (itype, icst_val); })\n+\t)\n+\t/* When CST is fractional, optimize\n+\t    (FTYPE) N == CST -> 0\n+\t    (FTYPE) N != CST -> 1.  */\n+\t(if (cmp == EQ_EXPR || cmp == NE_EXPR)\n+\t { constant_boolean_node (cmp == NE_EXPR, type); }) \n+\t/* Otherwise replace with sensible integer constant.  */\n+\t(with\n+\t {\n+\t   gcc_checking_assert (!overflow_p);\n+\t }\n+\t (icmp @0 { wide_int_to_tree (itype, icst_val); })))))))))\n+\n /* Fold A /[ex] B CMP C to A CMP B * C.  */\n (for cmp (eq ne)\n  (simplify"}, {"sha": "4203037994dcdddf8f6480a1d5c3418361ecc3e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -1,3 +1,12 @@\n+2017-08-04  Yury Gribov  <tetra2005@gmail.com>\n+\n+\tPR tree-optimization/57371\n+\t* c-c++-common/pr57371-1.c: New test.\n+\t* c-c++-common/pr57371-2.c: New test.\n+\t* c-c++-common/pr57371-3.c: New test.\n+\t* c-c++-common/pr57371-4.c: New test.\n+\t* gcc.dg/pr57371-5.c: New test.\n+\n 2017-08-04  Carl Love  <cel@us.ibm.com>\n \n \t* gcc.target/powerpc/builtins-3.c: Remove ISA 3.0 word variant"}, {"sha": "1bac81184060be54bc769e5a4724f30c96bc509d", "filename": "gcc/testsuite/c-c++-common/pr57371-1.c", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-1.c?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -0,0 +1,341 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-original\" } */\n+\n+#include <limits.h>\n+\n+/* Original testcase from PR.  */\n+\n+int foo1 (short x) {\n+  return (double) x != 0;\n+  /* { dg-final { scan-tree-dump \"return (<retval> = )?x != 0\" \"original\" } } */\n+}\n+\n+int foo2 (short x) {\n+  return (float) x != 0;\n+  /* { dg-final { scan-tree-dump \"return (<retval> = )?x != 0\" \"original\" } } */\n+}\n+\n+int foo3 (int x) {\n+  return (double) x != 0;\n+  /* { dg-final { scan-tree-dump \"return (<retval> = )?x != 0\" \"original\" } } */\n+}\n+\n+/* Tests when RHS is within range of integer type.  */\n+\n+void in_range (unsigned short x)\n+{\n+  {\n+    volatile int in_range_1;\n+    in_range_1 = (float) x > 100.0f;\n+    /* { dg-final { scan-tree-dump \"in_range_1 = x > 100\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int in_range_2;\n+    in_range_2 = (float) x < 100.0f;\n+    /* { dg-final { scan-tree-dump \"in_range_2 = x <= 99\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int in_range_3;\n+    in_range_3 = (float) x > 100.5f;\n+    /* { dg-final { scan-tree-dump \"in_range_3 = x (>= 101|> 100)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int in_range_4;\n+    in_range_4 = (float) x < 100.5f;\n+    /* { dg-final { scan-tree-dump \"in_range_4 = x <= 100\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int in_range_5;\n+    in_range_5 = (float) x == 100.0f;\n+    /* { dg-final { scan-tree-dump \"in_range_5 = x == 100\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int in_range_6;\n+    in_range_6 = (float) x != 100.0f;\n+    /* { dg-final { scan-tree-dump \"in_range_6 = x != 100\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int in_range_7;\n+    in_range_7 = (float) x == 100.5f;\n+    /* { dg-final { scan-tree-dump \"in_range_7 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int in_range_8;\n+    in_range_8 = (float) x != 100.5f;\n+    /* { dg-final { scan-tree-dump \"in_range_8 = 1\" \"original\" } } */\n+  }\n+}\n+\n+/* Tests for cases where RHS is out of range of integer type.  */\n+\n+void out_range (unsigned short x)\n+{\n+  {\n+    volatile int out_range_1;\n+    out_range_1 = (float) x > -100.5f;\n+    /* { dg-final { scan-tree-dump \"out_range_1 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int out_range_2;\n+    out_range_2 = (float) x >= -100.5f;\n+    /* { dg-final { scan-tree-dump \"out_range_2 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int out_range_3;\n+    out_range_3 = (float) x < -100.5f;\n+    /* { dg-final { scan-tree-dump \"out_range_3 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int out_range_4;\n+    out_range_4 = (float) x <= -100.5f;\n+    /* { dg-final { scan-tree-dump \"out_range_4 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int out_range_5;\n+    out_range_5 = (float) x == -100.5f;\n+    /* { dg-final { scan-tree-dump \"out_range_5 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int out_range_6;\n+    out_range_6 = (float) x != -100.5f;\n+    /* { dg-final { scan-tree-dump \"out_range_6 = 1\" \"original\" } } */\n+  }\n+}\n+\n+/* Tests when RHS is at boundary of integer type.  */\n+\n+void lo_bounds (unsigned short x)\n+{\n+  {\n+    volatile int lo_bounds_1;\n+    lo_bounds_1 = (float) x > 0x0;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_1 = x (>|!=) 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_2;\n+    lo_bounds_2 = (float) x >= 0x0;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_2 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_3;\n+    lo_bounds_3 = (float) x < 0x0;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_3 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_4;\n+    lo_bounds_4 = (float) x <= 0x0;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_4 = x (<=|==) 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_5;\n+    lo_bounds_5 = (float) x > 0x0 - 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_5 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_6;\n+    lo_bounds_6 = (float) x >= 0x0 - 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_6 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_7;\n+    lo_bounds_7 = (float) x < 0x0 - 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_7 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_8;\n+    lo_bounds_8 = (float) x <= 0x0 - 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_8 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_9;\n+    lo_bounds_9 = (float) x > 0x0 + 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_9 = x (>= 1|!= 0)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_10;\n+    lo_bounds_10 = (float) x >= 0x0 + 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_10 = x (>= 1|!= 0)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_11;\n+    lo_bounds_11 = (float) x < 0x0 + 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_11 = x (<=|==) 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int lo_bounds_12;\n+    lo_bounds_12 = (float) x <= 0x0 + 0.5f;\n+    /* { dg-final { scan-tree-dump \"lo_bounds_12 = x (<=|==) 0\" \"original\" } } */\n+  }\n+}\n+\n+void hi_bounds (unsigned short x)\n+{\n+  {\n+    volatile int hi_bounds_1;\n+    hi_bounds_1 = (float) x > USHRT_MAX;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_1 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_2;\n+    hi_bounds_2 = (float) x >= USHRT_MAX;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_2 = x (>=|==) 65535\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_3;\n+    hi_bounds_3 = (float) x < USHRT_MAX;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_3 = x (<|!=) 65535\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_4;\n+    hi_bounds_4 = (float) x <= USHRT_MAX;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_4 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_5;\n+    hi_bounds_5 = (float) x > USHRT_MAX - 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_5 = x (>=|==) 65535\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_6;\n+    hi_bounds_6 = (float) x >= USHRT_MAX - 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_6 = x (>=|==) 65535\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_7;\n+    hi_bounds_7 = (float) x < USHRT_MAX - 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_7 = x (<= 65534|!= 65535)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_8;\n+    hi_bounds_8 = (float) x <= USHRT_MAX - 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_8 = x (<= 65534|!= 65535)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_9;\n+    hi_bounds_9 = (float) x > USHRT_MAX + 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_9 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_10;\n+    hi_bounds_10 = (float) x >= USHRT_MAX + 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_10 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_11;\n+    hi_bounds_11 = (float) x < USHRT_MAX + 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_11 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int hi_bounds_12;\n+    hi_bounds_12 = (float) x <= USHRT_MAX + 0.5f;\n+    /* { dg-final { scan-tree-dump \"hi_bounds_12 = 1\" \"original\" } } */\n+  }\n+}\n+\n+/* Tests with non-finite float consts.  */\n+\n+void nonfinite (unsigned short x)\n+{\n+#define INFINITY __builtin_inff ()\n+\n+  {\n+    volatile int nonfinite_1;\n+    nonfinite_1 = (float) x > INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_1 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_2;\n+    nonfinite_2 = (float) x >= INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_2 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_3;\n+    nonfinite_3 = (float) x < INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_3 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_4;\n+    nonfinite_4 = (float) x <= INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_4 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_5;\n+    nonfinite_5 = (float) x > -INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_5 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_6;\n+    nonfinite_6 = (float) x >= -INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_6 = 1\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_7;\n+    nonfinite_7 = (float) x < -INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_7 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_8;\n+    nonfinite_8 = (float) x <= -INFINITY;\n+    /* { dg-final { scan-tree-dump \"nonfinite_8 = 0\" \"original\" } } */\n+  }\n+\n+#define QNAN __builtin_nanf (\"0\")\n+\n+  /* Even for qNaNs, only == and != are quiet.  */\n+\n+  {\n+    volatile int nonfinite_9;\n+    nonfinite_9 = (float) x == QNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_9 = 0\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_10;\n+    nonfinite_10 = (float) x != QNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_10 = 1\" \"original\" } } */\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"\\\\(float\\\\)\" \"original\" } } */\n+/* { dg-final { scan-tree-dump-not \"\\\\(double\\\\)\" \"original\" } } */"}, {"sha": "d07cff318c25c1a4db7246c827f0440f25984f33", "filename": "gcc/testsuite/c-c++-common/pr57371-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-2.c?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+/* We can not get rid of comparison in tests below because of\n+   potential inexact exception.\n+\n+   TODO: enable when -fno-trapping-math.  */\n+\n+int foo1(int x) {\n+  return (float) x != 0;\n+  /* { dg-final { scan-tree-dump \"\\\\(float\\\\)\" \"optimized\" } } */\n+}\n+\n+int foo2(long long x) {\n+  /* { dg-final { scan-tree-dump \"\\\\(double\\\\)\" \"optimized\" } } */\n+  return (double) x != 0;\n+}"}, {"sha": "973baacbb18dc46b2a4173c9c613a34f58ac3075", "filename": "gcc/testsuite/c-c++-common/pr57371-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-3.c?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+/* { dg-require-effective-target int128 } */\n+\n+/* We can not get rid of comparison in tests below because of\n+   potential overflow exception.\n+\n+   TODO: enable when -fno-trapping-math.  */\n+\n+int foo(__int128_t x) {\n+  /* { dg-final { scan-tree-dump \"\\\\(float\\\\)\" \"optimized\" } } */\n+  return (float) x != 0;\n+}"}, {"sha": "6265f520f9300aef5a4c1e79e79f3a094ceaf500", "filename": "gcc/testsuite/c-c++-common/pr57371-4.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr57371-4.c?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fsignaling-nans -fdump-tree-original\" } */\n+\n+/* We can not get rid of comparison in tests below because of\n+   pending NaN exceptions.\n+\n+   TODO: avoid under -fno-trapping-math.  */\n+\n+#define QNAN __builtin_nanf (\"0\")\n+#define SNAN __builtin_nansf (\"0\")\n+\n+void nonfinite(unsigned short x) {\n+  {\n+    volatile int nonfinite_1;\n+    nonfinite_1 = (float) x > QNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_1 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_2;\n+    nonfinite_2 = (float) x >= QNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_2 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_3;\n+    nonfinite_3 = (float) x < QNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_3 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_4;\n+    nonfinite_4 = (float) x <= QNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_4 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_5;\n+    nonfinite_5 = (float) x > SNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_5 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_6;\n+    nonfinite_6 = (float) x >= SNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_6 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_7;\n+    nonfinite_7 = (float) x < SNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_7 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_8;\n+    nonfinite_8 = (float) x <= SNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_8 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_9;\n+    nonfinite_9 = (float) x == SNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_9 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+\n+  {\n+    volatile int nonfinite_10;\n+    nonfinite_10 = (float) x != SNAN;\n+    /* { dg-final { scan-tree-dump \"nonfinite_10 = \\\\(float\\\\)\" \"original\" } } */\n+  }\n+}"}, {"sha": "ddad25db622550c19d03e2e2eb200a2057c51ba4", "filename": "gcc/testsuite/gcc.dg/pr57371-5.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57371-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779bea5b977aa3df19c965c4866c6c20ad258c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57371-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57371-5.c?ref=c779bea5b977aa3df19c965c4866c6c20ad258c8", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+/* { dg-require-effective-target dfp } */\n+\n+/* We do not support DFPs.  */\n+\n+int foo(short x) {\n+  /* { dg-final { scan-tree-dump \"\\\\(_Decimal32\\\\)\" \"optimized\" } } */\n+  return (_Decimal32) x != 0;\n+}"}]}