{"sha": "3d6efb77de361ca80a8988350863ef02499148ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2ZWZiNzdkZTM2MWNhODBhODk4ODM1MDg2M2VmMDI0OTkxNDhlZQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-04-06T09:17:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:17:23Z"}, "message": "a-tags.ads, a-tags.adb (Object_Specific_Data): Remove component Num_Prim_Ops.\n\n2007-04-06  Javier Miranda  <miranda@adacore.com>\n\n\t* a-tags.ads, a-tags.adb (Object_Specific_Data): Remove\n\tcomponent Num_Prim_Ops.\n\t(Set_Num_Prim_Ops): Removed.\n\tRemove all the assertions because all the routines of this\n\tpackage are inline always.\n\t(Get_Offset_Index): Add support to primary dispatch tables.\n\tMove the documentation about the dispatch table to a-tags.ads\n\t(Set_External_Tag): Removed\n\t(Inherit_TSD): Removed.\n\t(Interface_Data_Element, Interfaces_Array, Interface_Data): Declarations\n\tmoved to a-tags.ads\n\t(Displace, IW_Membership, Inherit_TSD, Interface_Ancestor_Tags,\n\tRegister_Interface_Tag, Set_Offset_To_Top): Update all the occurrences\n\tof the TSD field \"Table\" because this field has been renamed to\n\t\"Ifaces_Table\".\n\t(Inherit_CPP_DT): Removed.\n\t(K_Typeinfo, K_Offset_To_Top, K_Tagged_Kind, K_Signature,\n\tCstring, Tag_Table, Type_Specific_Data, Dispatch_Table): These\n\tdeclarations have been moved to a-tags.ads\n\t(Check_Size): Removed.\n\t(Expanded_Name): Updated to get access to the new field of TSD\n\tcontaining the address of the expanded name.\n\t(Get_Access_Level/Set_Access_Level): Removed.\n\t(Get_Predefined_Prim_Op_Address): Removed.\n\t(Set_Predefined_Prim_Op_Address): Removed.\n\t(Get_Prim_Op_Address/Set_Prim_Op_Address): Removed.\n\t(Get_Remotely_Callable/Set_Remotely_Callable): Removed.\n\t(Set_Expanded_Name): Removed.\n\t(Inherit_DT): Removed.\n\t(Inherit_CPP_DT): Removed.\n\t(Set_RC_Offset): Removed.\n\t(Set_TSD): Removed.\n\t(Base_Address): New function that displaces \"this\" to point to the base\n\tof the object (that is, to point to the primary tag of the object).\n\nFrom-SVN: r123550", "tree": {"sha": "c2b54fce109984e51262a08fa7d77502126db115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2b54fce109984e51262a08fa7d77502126db115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d6efb77de361ca80a8988350863ef02499148ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6efb77de361ca80a8988350863ef02499148ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6efb77de361ca80a8988350863ef02499148ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6efb77de361ca80a8988350863ef02499148ee/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9887261389bdb5f7799e10d7c7bb2c39364e4d45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9887261389bdb5f7799e10d7c7bb2c39364e4d45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9887261389bdb5f7799e10d7c7bb2c39364e4d45"}], "stats": {"total": 1294, "additions": 339, "deletions": 955}, "files": [{"sha": "556265ac2fac2f2ae53589c6c9367b8589c9807b", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 32, "deletions": 729, "changes": 761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6efb77de361ca80a8988350863ef02499148ee/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6efb77de361ca80a8988350863ef02499148ee/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=3d6efb77de361ca80a8988350863ef02499148ee", "patch": "@@ -41,185 +41,11 @@ pragma Elaborate_All (System.HTable);\n \n package body Ada.Tags is\n \n---  Structure of the GNAT Primary Dispatch Table\n-\n---           +----------------------+\n---           |       table of       |\n---           : predefined primitive :\n---           |     ops pointers     |\n---           +----------------------+\n---           |       Signature      |\n---           +----------------------+\n---           |      Tagged_Kind     |\n---           +----------------------+\n---           |     Offset_To_Top    |\n---           +----------------------+\n---           | Typeinfo_Ptr/TSD_Ptr ---> Type Specific Data\n---  Tag ---> +----------------------+   +-------------------+\n---           |       table of       |   | inheritance depth |\n---           :    primitive ops     :   +-------------------+\n---           |       pointers       |   |   access level    |\n---           +----------------------+   +-------------------+\n---                                      |   expanded name   |\n---                                      +-------------------+\n---                                      |   external tag    |\n---                                      +-------------------+\n---                                      |   hash table link |\n---                                      +-------------------+\n---                                      | remotely callable |\n---                                      +-------------------+\n---                                      | rec ctrler offset |\n---                                      +-------------------+\n---                                      |   num prim ops    |\n---                                      +-------------------+\n---                                      |  Ifaces_Table_Ptr --> Interface Data\n---                                      +-------------------+   +------------+\n---            Select Specific Data  <----     SSD_Ptr       |   |  table     |\n---           +--------------------+     +-------------------+   :    of      :\n---           | table of primitive |     | table of          |   | interfaces |\n---           :    operation       :     :    ancestor       :   +------------+\n---           |       kinds        |     |       tags        |\n---           +--------------------+     +-------------------+\n---           | table of           |\n---           :    entry           :\n---           |       indices      |\n---           +--------------------+\n-\n---  Structure of the GNAT Secondary Dispatch Table\n-\n---           +-----------------------+\n---           |       table of        |\n---           :  predefined primitive :\n---           |     ops pointers      |\n---           +-----------------------+\n---           |       Signature       |\n---           +-----------------------+\n---           |      Tagged_Kind      |\n---           +-----------------------+\n---           |     Offset_To_Top     |\n---           +-----------------------+\n---           |        OSD_Ptr        |---> Object Specific Data\n---  Tag ---> +-----------------------+      +---------------+\n---           |        table of       |      | num prim ops  |\n---           :      primitive op     :      +---------------+\n---           |     thunk pointers    |      | table of      |\n---           +-----------------------+      +   primitive   |\n---                                          |    op offsets |\n---                                          +---------------+\n-\n-   ----------------------------------\n-   -- GNAT Dispatch Table Prologue --\n-   ----------------------------------\n-\n-   --  GNAT's Dispatch Table prologue contains several fields which are hidden\n-   --  in order to preserve compatibility with C++. These fields are accessed\n-   --  by address calculations performed in the following manner:\n-\n-   --     Field : Field_Type :=\n-   --               (To_Address (Tag) - Sum_Of_Preceding_Field_Sizes).all;\n-\n-   --  The bracketed subtraction shifts the pointer (Tag) from the table of\n-   --  primitive operations (or thunks) to the field in question. Since the\n-   --  result of the subtraction is an address, dereferencing it will obtain\n-   --  the actual value of the field.\n-\n-   --  Guidelines for addition of new hidden fields\n-\n-   --     Define a Field_Type and Field_Type_Ptr (access to Field_Type) in\n-   --     A-Tags.ads for the newly introduced field.\n-\n-   --     Defined the size of the new field as a constant Field_Name_Size\n-\n-   --     Introduce an Unchecked_Conversion from System.Address to\n-   --     Field_Type_Ptr in A-Tags.ads.\n-\n-   --     Define the specifications of Get_<Field_Name> and Set_<Field_Name>\n-   --     in a-tags.ads.\n-\n-   --     Update the GNAT Dispatch Table structure in a-tags.adb\n-\n-   --     Provide bodies to the Get_<Field_Name> and Set_<Field_Name> routines.\n-   --     The profile of a Get_<Field_Name> routine should resemble:\n-\n-   --        function Get_<Field_Name> (T : Tag; ...) return Field_Type is\n-   --           Field : constant System.Address :=\n-   --                     To_Address (T) - <Sum_Of_Previous_Field_Sizes>;\n-   --        begin\n-   --           pragma Assert (Check_Signature (T, <Applicable_DT>));\n-   --           <Additional_Assertions>\n-\n-   --           return To_Field_Type_Ptr (Field).all;\n-   --        end Get_<Field_Name>;\n-\n-   --     The profile of a Set_<Field_Name> routine should resemble:\n-\n-   --        procedure Set_<Field_Name> (T : Tag; ..., Value : Field_Type) is\n-   --           Field : constant System.Address :=\n-   --                     To_Address (T) - <Sum_Of_Previous_Field_Sizes>;\n-   --           begin\n-   --           pragma Assert (Check_Signature (T, <Applicable_DT>));\n-   --           <Additional_Assertions>\n-\n-   --           To_Field_Type_Ptr (Field).all := Value;\n-   --        end Set_<Field_Name>;\n-\n-   --  NOTE: For each field in the prologue which precedes the newly added\n-   --  one, find and update its respective Sum_Of_Previous_Field_Sizes by\n-   --  subtractind Field_Name_Size from it. Falure to do so will clobber the\n-   --  previous prologue field.\n-\n-   K_Typeinfo      : constant SSE.Storage_Count := DT_Typeinfo_Ptr_Size;\n-\n-   K_Offset_To_Top : constant SSE.Storage_Count :=\n-                       K_Typeinfo + DT_Offset_To_Top_Size;\n-\n-   K_Tagged_Kind   : constant SSE.Storage_Count :=\n-                       K_Offset_To_Top + DT_Tagged_Kind_Size;\n-\n-   K_Signature     : constant SSE.Storage_Count :=\n-                       K_Tagged_Kind + DT_Signature_Size;\n-\n-   subtype Cstring is String (Positive);\n-   type Cstring_Ptr is access all Cstring;\n-\n-   --  We suppress index checks because the declared size in the record below\n-   --  is a dummy size of one (see below).\n-\n-   type Tag_Table is array (Natural range <>) of Tag;\n-   pragma Suppress_Initialization (Tag_Table);\n-   pragma Suppress (Index_Check, On => Tag_Table);\n-\n-   --  Declarations for the table of interfaces\n-\n-   type Interface_Data_Element is record\n-      Iface_Tag            : Tag;\n-      Static_Offset_To_Top : Boolean;\n-      Offset_To_Top_Value  : System.Storage_Elements.Storage_Offset;\n-      Offset_To_Top_Func   : System.Address;\n-   end record;\n-   --  If some ancestor of the tagged type has discriminants the field\n-   --  Static_Offset_To_Top is False and the field Offset_To_Top_Func\n-   --  is used to store the address of the function generated by the\n-   --  expander which provides this value; otherwise Static_Offset_To_Top\n-   --  is True and such value is stored in the Offset_To_Top_Value field.\n-\n-   type Interfaces_Array is\n-     array (Natural range <>) of Interface_Data_Element;\n-\n-   type Interface_Data (Nb_Ifaces : Positive) is record\n-      Table : Interfaces_Array (1 .. Nb_Ifaces);\n-   end record;\n-\n-   --  Object specific data types\n+   --  Object specific data types (see description in a-tags.ads)\n \n    type Object_Specific_Data_Array is array (Positive range <>) of Positive;\n \n    type Object_Specific_Data (Nb_Prim : Positive) is record\n-      Num_Prim_Ops : Natural;\n-      --  Number of primitive operations of the dispatch table. This field is\n-      --  used by the run-time check routines that are activated when the\n-      --  run-time is compiled with assertions enabled.\n-\n       OSD_Table : Object_Specific_Data_Array (1 .. Nb_Prim);\n       --  Table used in secondary DT to reference their counterpart in the\n       --  select specific data (in the TSD of the primary DT). This construct\n@@ -242,112 +68,6 @@ package body Ada.Tags is\n       --  NOTE: Nb_Prim is the number of non-predefined primitive operations\n    end record;\n \n-   --  Type specific data types\n-\n-   type Type_Specific_Data is record\n-      Idepth : Natural;\n-      --  Inheritance Depth Level: Used to implement the membership test\n-      --  associated with single inheritance of tagged types in constant-time.\n-      --  In addition it also indicates the size of the first table stored in\n-      --  the Tags_Table component (see comment below).\n-\n-      Access_Level : Natural;\n-      --  Accessibility level required to give support to Ada 2005 nested type\n-      --  extensions. This feature allows safe nested type extensions by\n-      --  shifting the accessibility checks to certain operations, rather than\n-      --  being enforced at the type declaration. In particular, by performing\n-      --  run-time accessibility checks on class-wide allocators, class-wide\n-      --  function return, and class-wide stream I/O, the danger of objects\n-      --  outliving their type declaration can be eliminated (Ada 2005: AI-344)\n-\n-      Expanded_Name : Cstring_Ptr;\n-      External_Tag  : Cstring_Ptr;\n-      HT_Link       : Tag;\n-      --  Components used to give support to the Ada.Tags subprograms described\n-      --  in ARM 3.9\n-\n-      Remotely_Callable : Boolean;\n-      --  Used to check ARM E.4 (18)\n-\n-      RC_Offset : SSE.Storage_Offset;\n-      --  Controller Offset: Used to give support to tagged controlled objects\n-      --  (see Get_Deep_Controller at s-finimp)\n-\n-      Ifaces_Table_Ptr : System.Address;\n-      --  Pointer to the table of interface tags. It is used to implement the\n-      --  membership test associated with interfaces and also for backward\n-      --  abstract interface type conversions (Ada 2005:AI-251)\n-\n-      Num_Prim_Ops : Natural;\n-      --  Number of primitive operations of the dispatch table. This field is\n-      --  used for additional run-time checks when the run-time is compiled\n-      --  with assertions enabled.\n-\n-      SSD_Ptr : System.Address;\n-      --  Pointer to a table of records used in dispatching selects. This\n-      --  field has a meaningful value for all tagged types that implement\n-      --  a limited, protected, synchronized or task interfaces and have\n-      --  non-predefined primitive operations.\n-\n-      Tags_Table : Tag_Table (0 .. 1);\n-      --  The size of the Tags_Table array actually depends on the tagged type\n-      --  to which it applies. The compiler ensures that has enough space to\n-      --  store all the entries of the two tables phisically stored there: the\n-      --  \"table of ancestor tags\" and the \"table of interface tags\". For this\n-      --  purpose we are using the same mechanism as for the Prims_Ptr array in\n-      --  the Dispatch_Table record. See comments below on Prims_Ptr for\n-      --  further details.\n-   end record;\n-\n-   type Dispatch_Table is record\n-\n-      --  According to the C++ ABI the components Offset_To_Top and\n-      --  Typeinfo_Ptr are stored just \"before\" the dispatch table (that is,\n-      --  the Prims_Ptr table), and they are referenced with negative offsets\n-      --  referring to the base of the dispatch table. The _Tag (or the\n-      --  VTable_Ptr in C++ terminology) must point to the base of the virtual\n-      --  table, just after these components, to point to the Prims_Ptr table.\n-      --  For this purpose the expander generates a Prims_Ptr table that has\n-      --  enough space for these additional components, and generates code that\n-      --  displaces the _Tag to point after these components.\n-\n-      --  Signature     : Signature_Kind;\n-      --  Tagged_Kind   : Tagged_Kind;\n-      --  Offset_To_Top : Natural;\n-      --  Typeinfo_Ptr  : System.Address;\n-\n-      Prims_Ptr : Address_Array (1 .. 1);\n-      --  The size of the Prims_Ptr array actually depends on the tagged type\n-      --  to which it applies. For each tagged type, the expander computes the\n-      --  actual array size, allocates the Dispatch_Table record accordingly,\n-      --  and generates code that displaces the base of the record after the\n-      --  Typeinfo_Ptr component. For this reason the first two components have\n-      --  been commented in the previous declaration. The access to these\n-      --  components is done by means of local functions.\n-      --\n-      --  To avoid the use of discriminants to define the actual size of the\n-      --  dispatch table, we used to declare the tag as a pointer to a record\n-      --  that contains an arbitrary array of addresses, using Positive as its\n-      --  index. This ensures that there are never range checks when accessing\n-      --  the dispatch table, but it prevents GDB from displaying tagged types\n-      --  properly. A better approach is to declare this record type as holding\n-      --  small number of addresses, and to explicitly suppress checks on it.\n-      --\n-      --  Note that in both cases, this type is never allocated, and serves\n-      --  only to declare the corresponding access type.\n-   end record;\n-\n-   type Signature_Type is\n-      (Must_Be_Primary_DT,\n-       Must_Be_Secondary_DT,\n-       Must_Be_Primary_Or_Secondary_DT,\n-       Must_Be_Interface,\n-       Must_Be_Primary_Or_Interface);\n-   --  Type of signature accepted by primitives in this package that are called\n-   --  during the elaboration of tagged types. This type is used by the routine\n-   --  Check_Signature that is called only when the run-time is compiled with\n-   --  assertions enabled.\n-\n    ---------------------------------------------\n    -- Unchecked Conversions for String Fields --\n    ---------------------------------------------\n@@ -388,19 +108,6 @@ package body Ada.Tags is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Check_Signature (T : Tag; Kind : Signature_Type) return Boolean;\n-   --  Check that the signature of T is valid and corresponds with the subset\n-   --  specified by the signature Kind.\n-\n-   function Check_Size\n-     (Old_T       : Tag;\n-      New_T       : Tag;\n-      Entry_Count : Natural) return Boolean;\n-   --  Verify that Old_T and New_T have at least Entry_Count entries\n-\n-   function Get_Num_Prim_Ops (T : Tag) return Natural;\n-   --  Retrieve the number of primitive operations in the dispatch table of T\n-\n    function Is_Primary_DT (T : Tag) return Boolean;\n    pragma Inline_Always (Is_Primary_DT);\n    --  Given a tag returns True if it has the signature of a primary dispatch\n@@ -512,78 +219,6 @@ package body Ada.Tags is\n \n    end HTable_Subprograms;\n \n-   ---------------------\n-   -- Check_Signature --\n-   ---------------------\n-\n-   function Check_Signature (T : Tag; Kind : Signature_Type) return Boolean is\n-      Signature : constant Storage_Offset_Ptr :=\n-                    To_Storage_Offset_Ptr (To_Address (T) - K_Signature);\n-\n-      Sig_Values : constant Signature_Values :=\n-                     To_Signature_Values (Signature.all);\n-\n-      Signature_Id : Signature_Kind;\n-\n-   begin\n-      if Sig_Values (1) /= Valid_Signature then\n-         Signature_Id := Unknown;\n-\n-      elsif Sig_Values (2) in Primary_DT .. Abstract_Interface then\n-         Signature_Id := Sig_Values (2);\n-\n-      else\n-         Signature_Id := Unknown;\n-      end if;\n-\n-      case Signature_Id is\n-         when Primary_DT         =>\n-            if Kind = Must_Be_Secondary_DT\n-              or else Kind = Must_Be_Interface\n-            then\n-               return False;\n-            end if;\n-\n-         when Secondary_DT       =>\n-            if Kind = Must_Be_Primary_DT\n-              or else Kind = Must_Be_Interface\n-            then\n-               return False;\n-            end if;\n-\n-         when Abstract_Interface =>\n-            if Kind = Must_Be_Primary_DT\n-              or else Kind = Must_Be_Secondary_DT\n-              or else Kind = Must_Be_Primary_Or_Secondary_DT\n-            then\n-               return False;\n-            end if;\n-\n-         when others =>\n-            return False;\n-\n-      end case;\n-\n-      return True;\n-   end Check_Signature;\n-\n-   ----------------\n-   -- Check_Size --\n-   ----------------\n-\n-   function Check_Size\n-     (Old_T       : Tag;\n-      New_T       : Tag;\n-      Entry_Count : Natural) return Boolean\n-   is\n-      Max_Entries_Old : constant Natural := Get_Num_Prim_Ops (Old_T);\n-      Max_Entries_New : constant Natural := Get_Num_Prim_Ops (New_T);\n-\n-   begin\n-      return Entry_Count <= Max_Entries_Old\n-        and then Entry_Count <= Max_Entries_New;\n-   end Check_Size;\n-\n    -------------------\n    -- CW_Membership --\n    -------------------\n@@ -607,12 +242,19 @@ package body Ada.Tags is\n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean is\n       Pos : Integer;\n    begin\n-      pragma Assert (Check_Signature (Obj_Tag, Must_Be_Primary_DT));\n-      pragma Assert (Check_Signature (Typ_Tag, Must_Be_Primary_DT));\n       Pos := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n       return Pos >= 0 and then TSD (Obj_Tag).Tags_Table (Pos) = Typ_Tag;\n    end CW_Membership;\n \n+   ------------------\n+   -- Base_Address --\n+   ------------------\n+\n+   function Base_Address (This : System.Address) return System.Address is\n+   begin\n+      return This - Offset_To_Top (This);\n+   end Base_Address;\n+\n    --------------\n    -- Displace --\n    --------------\n@@ -621,36 +263,26 @@ package body Ada.Tags is\n      (This : System.Address;\n       T    : Tag) return System.Address\n    is\n-      Curr_DT     : constant Tag := To_Tag_Ptr (This).all;\n       Iface_Table : Interface_Data_Ptr;\n       Obj_Base    : System.Address;\n       Obj_DT      : Tag;\n       Obj_TSD     : Type_Specific_Data_Ptr;\n \n    begin\n-      pragma Assert\n-        (Check_Signature (Curr_DT, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert\n-        (Check_Signature (T, Must_Be_Interface));\n-\n       Obj_Base    := This - Offset_To_Top (This);\n       Obj_DT      := To_Tag_Ptr (Obj_Base).all;\n-\n-      pragma Assert\n-        (Check_Signature (Obj_DT, Must_Be_Primary_DT));\n-\n       Obj_TSD     := TSD (Obj_DT);\n       Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n \n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n-            if Iface_Table.Table (Id).Iface_Tag = T then\n+            if Iface_Table.Ifaces_Table (Id).Iface_Tag = T then\n \n                --  Case of Static value of Offset_To_Top\n \n-               if Iface_Table.Table (Id).Static_Offset_To_Top then\n-                  Obj_Base :=\n-                    Obj_Base + Iface_Table.Table (Id).Offset_To_Top_Value;\n+               if Iface_Table.Ifaces_Table (Id).Static_Offset_To_Top then\n+                  Obj_Base := Obj_Base +\n+                    Iface_Table.Ifaces_Table (Id).Offset_To_Top_Value;\n \n                --  Otherwise we call the function generated by the expander\n                --  to provide us with this value\n@@ -659,15 +291,11 @@ package body Ada.Tags is\n                   Obj_Base :=\n                     Obj_Base +\n                       To_Offset_To_Top_Function_Ptr\n-                        (Iface_Table.Table (Id).Offset_To_Top_Func).all\n+                        (Iface_Table.Ifaces_Table (Id).Offset_To_Top_Func).all\n                           (Obj_Base);\n                end if;\n \n                Obj_DT := To_Tag_Ptr (Obj_Base).all;\n-\n-               pragma Assert\n-                 (Check_Signature (Obj_DT, Must_Be_Secondary_DT));\n-\n                return Obj_Base;\n             end if;\n          end loop;\n@@ -700,35 +328,25 @@ package body Ada.Tags is\n    --  that are contained in the dispatch table referenced by Obj'Tag.\n \n    function IW_Membership (This : System.Address; T : Tag) return Boolean is\n-      Curr_DT     : constant Tag := To_Tag_Ptr (This).all;\n       Iface_Table : Interface_Data_Ptr;\n       Last_Id     : Natural;\n       Obj_Base    : System.Address;\n       Obj_DT      : Tag;\n       Obj_TSD     : Type_Specific_Data_Ptr;\n \n    begin\n-      pragma Assert\n-        (Check_Signature (Curr_DT, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert\n-        (Check_Signature (T, Must_Be_Primary_Or_Interface));\n-\n       Obj_Base := This - Offset_To_Top (This);\n       Obj_DT   := To_Tag_Ptr (Obj_Base).all;\n-\n-      pragma Assert\n-        (Check_Signature (Obj_DT, Must_Be_Primary_DT));\n-\n-      Obj_TSD := TSD (Obj_DT);\n-      Last_Id := Obj_TSD.Idepth;\n+      Obj_TSD  := TSD (Obj_DT);\n+      Last_Id  := Obj_TSD.Idepth;\n \n       --  Look for the tag in the table of interfaces\n \n       Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n \n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n-            if Iface_Table.Table (Id).Iface_Tag = T then\n+            if Iface_Table.Ifaces_Table (Id).Iface_Tag = T then\n                return True;\n             end if;\n          end loop;\n@@ -751,13 +369,9 @@ package body Ada.Tags is\n    --------------------\n \n    function Descendant_Tag (External : String; Ancestor : Tag) return Tag is\n-      Int_Tag : Tag;\n+      Int_Tag : constant Tag := Internal_Tag (External);\n \n    begin\n-      pragma Assert (Check_Signature (Ancestor, Must_Be_Primary_DT));\n-      Int_Tag := Internal_Tag (External);\n-      pragma Assert (Check_Signature (Int_Tag, Must_Be_Primary_DT));\n-\n       if not Is_Descendant_At_Same_Level (Int_Tag, Ancestor) then\n          raise Tag_Error;\n       end if;\n@@ -777,7 +391,6 @@ package body Ada.Tags is\n          raise Tag_Error;\n       end if;\n \n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       Result := TSD (T).Expanded_Name;\n       return Result (1 .. Length (Result));\n    end Expanded_Name;\n@@ -794,30 +407,16 @@ package body Ada.Tags is\n          raise Tag_Error;\n       end if;\n \n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       Result := TSD (T).External_Tag;\n-\n       return Result (1 .. Length (Result));\n    end External_Tag;\n \n-   ----------------------\n-   -- Get_Access_Level --\n-   ----------------------\n-\n-   function Get_Access_Level (T : Tag) return Natural is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      return TSD (T).Access_Level;\n-   end Get_Access_Level;\n-\n    ---------------------\n    -- Get_Entry_Index --\n    ---------------------\n \n    function Get_Entry_Index (T : Tag; Position : Positive) return Positive is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n       return SSD (T).SSD_Table (Position).Index;\n    end Get_Entry_Index;\n \n@@ -827,53 +426,9 @@ package body Ada.Tags is\n \n    function Get_External_Tag (T : Tag) return System.Address is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return To_Address (TSD (T).External_Tag);\n    end Get_External_Tag;\n \n-   ----------------------\n-   -- Get_Num_Prim_Ops --\n-   ----------------------\n-\n-   function Get_Num_Prim_Ops (T : Tag) return Natural is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-\n-      if Is_Primary_DT (T) then\n-         return TSD (T).Num_Prim_Ops;\n-      else\n-         return OSD (T).Num_Prim_Ops;\n-      end if;\n-   end Get_Num_Prim_Ops;\n-\n-   --------------------------------\n-   -- Get_Predef_Prim_Op_Address --\n-   --------------------------------\n-\n-   function Get_Predefined_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive) return System.Address\n-   is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Position <= Default_Prim_Op_Count);\n-      return Predefined_DT (T).Prims_Ptr (Position);\n-   end Get_Predefined_Prim_Op_Address;\n-\n-   -------------------------\n-   -- Get_Prim_Op_Address --\n-   -------------------------\n-\n-   function Get_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive) return System.Address\n-   is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n-      return T.Prims_Ptr (Position);\n-   end Get_Prim_Op_Address;\n-\n    ----------------------\n    -- Get_Prim_Op_Kind --\n    ----------------------\n@@ -883,8 +438,6 @@ package body Ada.Tags is\n       Position : Positive) return Prim_Op_Kind\n    is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n       return SSD (T).SSD_Table (Position).Kind;\n    end Get_Prim_Op_Kind;\n \n@@ -897,9 +450,11 @@ package body Ada.Tags is\n       Position : Positive) return Positive\n    is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n-      return OSD (T).OSD_Table (Position);\n+      if Is_Primary_DT (T) then\n+         return Position;\n+      else\n+         return OSD (T).OSD_Table (Position);\n+      end if;\n    end Get_Offset_Index;\n \n    -------------------\n@@ -908,20 +463,9 @@ package body Ada.Tags is\n \n    function Get_RC_Offset (T : Tag) return SSE.Storage_Offset is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return TSD (T).RC_Offset;\n    end Get_RC_Offset;\n \n-   ---------------------------\n-   -- Get_Remotely_Callable --\n-   ---------------------------\n-\n-   function Get_Remotely_Callable (T : Tag) return Boolean is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      return TSD (T).Remotely_Callable;\n-   end Get_Remotely_Callable;\n-\n    ---------------------\n    -- Get_Tagged_Kind --\n    ---------------------\n@@ -930,113 +474,9 @@ package body Ada.Tags is\n       Tagged_Kind_Ptr : constant System.Address :=\n                           To_Address (T) - K_Tagged_Kind;\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n       return To_Tagged_Kind_Ptr (Tagged_Kind_Ptr).all;\n    end Get_Tagged_Kind;\n \n-   --------------------\n-   -- Inherit_CPP_DT --\n-   --------------------\n-\n-   procedure Inherit_CPP_DT\n-     (Old_T       : Tag;\n-      New_T       : Tag;\n-      Entry_Count : Natural)\n-   is\n-   begin\n-      New_T.Prims_Ptr (1 .. Entry_Count) := Old_T.Prims_Ptr (1 .. Entry_Count);\n-   end Inherit_CPP_DT;\n-\n-   ----------------\n-   -- Inherit_DT --\n-   ----------------\n-\n-   procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural) is\n-      subtype All_Predefined_Prims is\n-        Positive range 1 .. Default_Prim_Op_Count;\n-\n-   begin\n-      pragma Assert (Check_Signature (Old_T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Check_Signature (New_T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Check_Size (Old_T, New_T, Entry_Count));\n-\n-      if Old_T /= null then\n-\n-         --  Inherit the primitives of the parent\n-\n-         New_T.Prims_Ptr (1 .. Entry_Count) :=\n-           Old_T.Prims_Ptr (1 .. Entry_Count);\n-\n-         --  Inherit the predefined primitives of the parent\n-\n-         --  NOTE: In the following assignment we have to unactivate a warning\n-         --  generated by the compiler because of the following declaration of\n-         --  the Dispatch_Table:\n-\n-         --      Prims_Ptr : Address_Array (1 .. 1);\n-\n-         --  This is a dummy declaration that is expanded by the frontend to\n-         --  the correct size of the dispatch table corresponding with each\n-         --  tagged type. As a consequence, if we try to use a constant to\n-         --  copy the predefined elements (ie.  Prims_Ptr (1 .. 15) := ...)\n-         --  the compiler generates a warning indicating that Constraint_Error\n-         --  will be raised at run-time (which is not true in this specific\n-         --  case).\n-\n-         pragma Warnings (Off);\n-         Predefined_DT (New_T).Prims_Ptr (All_Predefined_Prims) :=\n-           Predefined_DT (Old_T).Prims_Ptr (All_Predefined_Prims);\n-         pragma Warnings (On);\n-      end if;\n-   end Inherit_DT;\n-\n-   -----------------\n-   -- Inherit_TSD --\n-   -----------------\n-\n-   procedure Inherit_TSD (Old_Tag : Tag; New_Tag : Tag) is\n-      New_TSD_Ptr         : Type_Specific_Data_Ptr;\n-      New_Iface_Table_Ptr : Interface_Data_Ptr;\n-      Old_TSD_Ptr         : Type_Specific_Data_Ptr;\n-      Old_Iface_Table_Ptr : Interface_Data_Ptr;\n-\n-   begin\n-      pragma Assert (Check_Signature (New_Tag, Must_Be_Primary_Or_Interface));\n-      New_TSD_Ptr := TSD (New_Tag);\n-\n-      if Old_Tag /= null then\n-         pragma Assert\n-           (Check_Signature (Old_Tag, Must_Be_Primary_Or_Interface));\n-         Old_TSD_Ptr := TSD (Old_Tag);\n-         New_TSD_Ptr.Idepth := Old_TSD_Ptr.Idepth + 1;\n-\n-         --  Copy the \"table of ancestor tags\" plus the \"table of interfaces\"\n-         --  of the parent.\n-\n-         New_TSD_Ptr.Tags_Table (1 .. New_TSD_Ptr.Idepth) :=\n-           Old_TSD_Ptr.Tags_Table (0 .. Old_TSD_Ptr.Idepth);\n-\n-         --  Copy the table of interfaces of the parent\n-\n-         if not System.\"=\" (Old_TSD_Ptr.Ifaces_Table_Ptr,\n-                            System.Null_Address)\n-         then\n-            Old_Iface_Table_Ptr :=\n-              To_Interface_Data_Ptr (Old_TSD_Ptr.Ifaces_Table_Ptr);\n-            New_Iface_Table_Ptr :=\n-              To_Interface_Data_Ptr (New_TSD_Ptr.Ifaces_Table_Ptr);\n-\n-            New_Iface_Table_Ptr.Table (1 .. Old_Iface_Table_Ptr.Nb_Ifaces) :=\n-              Old_Iface_Table_Ptr.Table (1 .. Old_Iface_Table_Ptr.Nb_Ifaces);\n-         end if;\n-\n-      else\n-         New_TSD_Ptr.Idepth := 0;\n-      end if;\n-\n-      New_TSD_Ptr.Tags_Table (0) := New_Tag;\n-   end Inherit_TSD;\n-\n    -----------------------------\n    -- Interface_Ancestor_Tags --\n    -----------------------------\n@@ -1058,7 +498,7 @@ package body Ada.Tags is\n             Table : Tag_Array (1 .. Iface_Table.Nb_Ifaces);\n          begin\n             for J in 1 .. Iface_Table.Nb_Ifaces loop\n-               Table (J) := Iface_Table.Table (J).Iface_Tag;\n+               Table (J) := Iface_Table.Ifaces_Table (J).Iface_Tag;\n             end loop;\n \n             return Table;\n@@ -1167,7 +607,6 @@ package body Ada.Tags is\n       OSD_Ptr : constant Addr_Ptr :=\n                   To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n       return To_Object_Specific_Data_Ptr (OSD_Ptr.all);\n    end OSD;\n \n@@ -1194,7 +633,6 @@ package body Ada.Tags is\n       --  Access to the _size primitive of the parent\n \n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       Parent_Tag := TSD (T).Tags_Table (Parent_Slot);\n       F := To_Acc_Size (Predefined_DT (Parent_Tag).Prims_Ptr (Size_Slot));\n \n@@ -1213,8 +651,6 @@ package body Ada.Tags is\n          raise Tag_Error;\n       end if;\n \n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-\n       --  The Parent_Tag of a root-level tagged type is defined to be No_Tag.\n       --  The first entry in the Ancestors_Tags array will be null for such\n       --  a type, but it's better to be explicit about returning No_Tag in\n@@ -1249,14 +685,9 @@ package body Ada.Tags is\n       Iface_Table : Interface_Data_Ptr;\n \n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n-      pragma Assert (Check_Signature (Interface_T, Must_Be_Interface));\n-\n       New_T_TSD   := TSD (T);\n       Iface_Table := To_Interface_Data_Ptr (New_T_TSD.Ifaces_Table_Ptr);\n-\n-      pragma Assert (Position <= Iface_Table.Nb_Ifaces);\n-      Iface_Table.Table (Position).Iface_Tag := Interface_T;\n+      Iface_Table.Ifaces_Table (Position).Iface_Tag := Interface_T;\n    end Register_Interface_Tag;\n \n    ------------------\n@@ -1268,16 +699,6 @@ package body Ada.Tags is\n       External_Tag_HTable.Set (T);\n    end Register_Tag;\n \n-   ----------------------\n-   -- Set_Access_Level --\n-   ----------------------\n-\n-   procedure Set_Access_Level (T : Tag; Value : Natural) is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      TSD (T).Access_Level := Value;\n-   end Set_Access_Level;\n-\n    ---------------------\n    -- Set_Entry_Index --\n    ---------------------\n@@ -1288,57 +709,18 @@ package body Ada.Tags is\n       Value    : Positive)\n    is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n       SSD (T).SSD_Table (Position).Index := Value;\n    end Set_Entry_Index;\n \n-   -----------------------\n-   -- Set_Expanded_Name --\n-   -----------------------\n-\n-   procedure Set_Expanded_Name (T : Tag; Value : System.Address) is\n-   begin\n-      pragma Assert\n-        (Check_Signature (T, Must_Be_Primary_Or_Interface));\n-      TSD (T).Expanded_Name := To_Cstring_Ptr (Value);\n-   end Set_Expanded_Name;\n-\n-   ----------------------\n-   -- Set_External_Tag --\n-   ----------------------\n-\n-   procedure Set_External_Tag (T : Tag; Value : System.Address) is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n-      TSD (T).External_Tag := To_Cstring_Ptr (Value);\n-   end Set_External_Tag;\n-\n    -------------------------\n    -- Set_Interface_Table --\n    -------------------------\n \n    procedure Set_Interface_Table (T : Tag; Value : System.Address) is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       TSD (T).Ifaces_Table_Ptr := Value;\n    end Set_Interface_Table;\n \n-   ----------------------\n-   -- Set_Num_Prim_Ops --\n-   ----------------------\n-\n-   procedure Set_Num_Prim_Ops (T : Tag; Value : Natural) is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-\n-      if Is_Primary_DT (T) then\n-         TSD (T).Num_Prim_Ops := Value;\n-      else\n-         OSD (T).Num_Prim_Ops := Value;\n-      end if;\n-   end Set_Num_Prim_Ops;\n-\n    ----------------------\n    -- Set_Offset_Index --\n    ----------------------\n@@ -1349,8 +731,6 @@ package body Ada.Tags is\n       Value    : Positive)\n    is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n       OSD (T).OSD_Table (Position) := Value;\n    end Set_Offset_Index;\n \n@@ -1373,10 +753,6 @@ package body Ada.Tags is\n       Obj_TSD       : Type_Specific_Data_Ptr;\n    begin\n       if System.\"=\" (This, System.Null_Address) then\n-         pragma Assert\n-           (Check_Signature (Interface_T, Must_Be_Primary_DT));\n-         pragma Assert (Offset_Value = 0);\n-\n          Offset_To_Top :=\n            To_Storage_Offset_Ptr (To_Address (Interface_T) - K_Offset_To_Top);\n          Offset_To_Top.all := Offset_Value;\n@@ -1388,9 +764,6 @@ package body Ada.Tags is\n \n       Prim_DT  := To_Tag_Ptr (This).all;\n \n-      pragma Assert\n-        (Check_Signature (Prim_DT, Must_Be_Primary_DT));\n-\n       --  Save the offset to top field in the secondary dispatch table.\n \n       if Offset_Value /= 0 then\n@@ -1399,9 +772,6 @@ package body Ada.Tags is\n          Offset_To_Top :=\n            To_Storage_Offset_Ptr (To_Address (Sec_DT) - K_Offset_To_Top);\n \n-         pragma Assert\n-           (Check_Signature (Sec_DT, Must_Be_Secondary_DT));\n-\n          if Is_Static then\n             Offset_To_Top.all := Offset_Value;\n          else\n@@ -1420,13 +790,15 @@ package body Ada.Tags is\n \n       if Iface_Table /= null then\n          for Id in 1 .. Iface_Table.Nb_Ifaces loop\n-            if Iface_Table.Table (Id).Iface_Tag = Interface_T then\n-               Iface_Table.Table (Id).Static_Offset_To_Top := Is_Static;\n+            if Iface_Table.Ifaces_Table (Id).Iface_Tag = Interface_T then\n+               Iface_Table.Ifaces_Table (Id).Static_Offset_To_Top := Is_Static;\n \n                if Is_Static then\n-                  Iface_Table.Table (Id).Offset_To_Top_Value := Offset_Value;\n+                  Iface_Table.Ifaces_Table (Id).Offset_To_Top_Value\n+                    := Offset_Value;\n                else\n-                  Iface_Table.Table (Id).Offset_To_Top_Func := Offset_Func;\n+                  Iface_Table.Ifaces_Table (Id).Offset_To_Top_Func\n+                    := Offset_Func;\n                end if;\n \n                return;\n@@ -1447,40 +819,9 @@ package body Ada.Tags is\n       OSD_Ptr : constant Addr_Ptr :=\n                   To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n       OSD_Ptr.all := Value;\n    end Set_OSD;\n \n-   ------------------------------------\n-   -- Set_Predefined_Prim_Op_Address --\n-   ------------------------------------\n-\n-   procedure Set_Predefined_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive;\n-      Value    : System.Address)\n-   is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Position >= 1 and then Position <= Default_Prim_Op_Count);\n-      Predefined_DT (T).Prims_Ptr (Position) := Value;\n-   end Set_Predefined_Prim_Op_Address;\n-\n-   -------------------------\n-   -- Set_Prim_Op_Address --\n-   -------------------------\n-\n-   procedure Set_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive;\n-      Value    : System.Address)\n-   is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n-      T.Prims_Ptr (Position) := Value;\n-   end Set_Prim_Op_Address;\n-\n    ----------------------\n    -- Set_Prim_Op_Kind --\n    ----------------------\n@@ -1491,31 +832,9 @@ package body Ada.Tags is\n       Value    : Prim_Op_Kind)\n    is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      pragma Assert (Position <= Get_Num_Prim_Ops (T));\n       SSD (T).SSD_Table (Position).Kind := Value;\n    end Set_Prim_Op_Kind;\n \n-   -------------------\n-   -- Set_RC_Offset --\n-   -------------------\n-\n-   procedure Set_RC_Offset (T : Tag; Value : SSE.Storage_Offset) is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      TSD (T).RC_Offset := Value;\n-   end Set_RC_Offset;\n-\n-   ---------------------------\n-   -- Set_Remotely_Callable --\n-   ---------------------------\n-\n-   procedure Set_Remotely_Callable (T : Tag; Value : Boolean) is\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n-      TSD (T).Remotely_Callable := Value;\n-   end Set_Remotely_Callable;\n-\n    -------------------\n    -- Set_Signature --\n    -------------------\n@@ -1535,7 +854,6 @@ package body Ada.Tags is\n \n    procedure Set_SSD (T : Tag; Value : System.Address) is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       TSD (T).SSD_Ptr := Value;\n    end Set_SSD;\n \n@@ -1547,29 +865,15 @@ package body Ada.Tags is\n       Tagged_Kind_Ptr : constant System.Address :=\n                           To_Address (T) - K_Tagged_Kind;\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n       To_Tagged_Kind_Ptr (Tagged_Kind_Ptr).all := Value;\n    end Set_Tagged_Kind;\n \n-   -------------\n-   -- Set_TSD --\n-   -------------\n-\n-   procedure Set_TSD (T : Tag; Value : System.Address) is\n-      TSD_Ptr : Addr_Ptr;\n-   begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n-      TSD_Ptr := To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n-      TSD_Ptr.all := Value;\n-   end Set_TSD;\n-\n    ---------\n    -- SSD --\n    ---------\n \n    function SSD (T : Tag) return Select_Specific_Data_Ptr is\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return To_Select_Specific_Data_Ptr (TSD (T).SSD_Ptr);\n    end SSD;\n \n@@ -1592,7 +896,6 @@ package body Ada.Tags is\n       TSD_Ptr : constant Addr_Ptr :=\n                   To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       return To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n    end TSD;\n "}, {"sha": "bc39cd509e2f2d6bc098be5505fe880b45b1f423", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 307, "deletions": 226, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6efb77de361ca80a8988350863ef02499148ee/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6efb77de361ca80a8988350863ef02499148ee/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=3d6efb77de361ca80a8988350863ef02499148ee", "patch": "@@ -81,40 +81,213 @@ package Ada.Tags is\n    Tag_Error : exception;\n \n private\n-   --  The following subprogram specifications are placed here instead of\n-   --  the package body to see them from the frontend through rtsfind.\n-\n-   ---------------------------------------------------------------\n-   -- Abstract Procedural Interface For The GNAT Dispatch Table --\n-   ---------------------------------------------------------------\n-\n-   --  GNAT's Dispatch Table format is customizable in order to match the\n-   --  format used in another language. GNAT supports programs that use two\n-   --  different dispatch table formats at the same time: the native format\n-   --  that supports Ada 95 tagged types and which is described in Ada.Tags,\n-   --  and a foreign format for types that are imported from some other\n-   --  language (typically C++) which is described in Interfaces.CPP. The\n-   --  runtime information kept for each tagged type is separated into two\n+   --  Structure of the GNAT Primary Dispatch Table\n+\n+   --           +--------------------+\n+   --           |      table of      |\n+   --           :predefined primitive:\n+   --           |    ops pointers    |\n+   --           +--------------------+\n+   --           |      Signature     |\n+   --           +--------------------+\n+   --           |     Tagged_Kind    |\n+   --           +--------------------+\n+   --           |    Offset_To_Top   |\n+   --           +--------------------+\n+   --           |Typeinfo_Ptr/TSD_Ptr---> Type Specific Data\n+   --  Tag ---> +--------------------+   +-------------------+\n+   --           |      table of      |   | inheritance depth |\n+   --           :   primitive ops    :   +-------------------+\n+   --           |      pointers      |   |   access level    |\n+   --           +--------------------+   +-------------------+\n+   --                                    |   expanded name   |\n+   --                                    +-------------------+\n+   --                                    |   external tag    |\n+   --                                    +-------------------+\n+   --                                    |   hash table link |\n+   --                                    +-------------------+\n+   --                                    | remotely callable |\n+   --                                    +-------------------+\n+   --                                    | rec ctrler offset |\n+   --                                    +-------------------+\n+   --                                    |   num prim ops    |\n+   --                                    +-------------------+\n+   --                                    |  Ifaces_Table_Ptr --> Interface Data\n+   --                                    +-------------------+   +------------+\n+   --         Select Specific Data  <----     SSD_Ptr        |   |  table     |\n+   --         +------------------+       +-------------------+   :    of      :\n+   --         |table of primitive|       | table of          |   | interfaces |\n+   --         :   operation      :       :    ancestor       :   +------------+\n+   --         |      kinds       |       |       tags        |\n+   --         +------------------+       +-------------------+\n+   --         |table of          |\n+   --         :   entry          :\n+   --         |      indices     |\n+   --         +------------------+\n+\n+   --  Structure of the GNAT Secondary Dispatch Table\n+\n+   --           +-----------------------+\n+   --           |       table of        |\n+   --           :  predefined primitive :\n+   --           |     ops pointers      |\n+   --           +-----------------------+\n+   --           |       Signature       |\n+   --           +-----------------------+\n+   --           |      Tagged_Kind      |\n+   --           +-----------------------+\n+   --           |     Offset_To_Top     |\n+   --           +-----------------------+\n+   --           |        OSD_Ptr        |---> Object Specific Data\n+   --  Tag ---> +-----------------------+      +---------------+\n+   --           |        table of       |      | num prim ops  |\n+   --           :      primitive op     :      +---------------+\n+   --           |     thunk pointers    |      | table of      |\n+   --           +-----------------------+      +   primitive   |\n+   --                                          |    op offsets |\n+   --                                          +---------------+\n+\n+   --  The runtime information kept for each tagged type is separated into two\n    --  objects: the Dispatch Table and the Type Specific Data record. These\n    --  two objects are allocated statically using the constants:\n \n    --      DT Size  = DT_Prologue_Size  + Nb_Prim * DT_Entry_Size\n-   --      TSD Size = TSD_Prologue_Size + (1 + Idepth)  * TSD_Entry_Size\n \n    --  where Nb_prim is the number of primitive operations of the given\n    --  type and Idepth its inheritance depth.\n \n-   --  In order to set or retrieve information from the Dispatch Table or\n-   --  the Type Specific Data record, GNAT generates calls to Set_XXX or\n-   --  Get_XXX routines, where XXX is the name of the field of interest.\n+   type Address_Array is array (Natural range <>) of System.Address;\n+   pragma Suppress (Index_Check, On => Address_Array);\n+   --  The reason we suppress index checks is that in the dispatch table,\n+   --  the component of this type is declared with a dummy size of 1, the\n+   --  actual size depending on the number of primitive operations.\n+\n+   type Dispatch_Table is record\n+\n+      --  According to the C++ ABI the components Offset_To_Top and\n+      --  Typeinfo_Ptr are stored just \"before\" the dispatch table (that is,\n+      --  the Prims_Ptr table), and they are referenced with negative offsets\n+      --  referring to the base of the dispatch table. The _Tag (or the\n+      --  VTable_Ptr in C++ terminology) must point to the base of the virtual\n+      --  table, just after these components, to point to the Prims_Ptr table.\n+      --  For this purpose the expander generates a Prims_Ptr table that has\n+      --  enough space for these additional components, and generates code that\n+      --  displaces the _Tag to point after these components.\n+\n+      --  Signature     : Signature_Kind;\n+      --  Tagged_Kind   : Tagged_Kind;\n+      --  Offset_To_Top : Natural;\n+      --  Typeinfo_Ptr  : System.Address;\n+\n+      Prims_Ptr : Address_Array (1 .. 1);\n+      --  The size of the Prims_Ptr array actually depends on the tagged type\n+      --  to which it applies. For each tagged type, the expander computes the\n+      --  actual array size, allocates the Dispatch_Table record accordingly,\n+      --  and generates code that displaces the base of the record after the\n+      --  Typeinfo_Ptr component. For this reason the first two components have\n+      --  been commented in the previous declaration. The access to these\n+      --  components is done by means of local functions.\n+      --\n+      --  To avoid the use of discriminants to define the actual size of the\n+      --  dispatch table, we used to declare the tag as a pointer to a record\n+      --  that contains an arbitrary array of addresses, using Positive as its\n+      --  index. This ensures that there are never range checks when accessing\n+      --  the dispatch table, but it prevents GDB from displaying tagged types\n+      --  properly. A better approach is to declare this record type as holding\n+      --  small number of addresses, and to explicitly suppress checks on it.\n+      --\n+      --  Note that in both cases, this type is never allocated, and serves\n+      --  only to declare the corresponding access type.\n+   end record;\n+\n+   subtype Cstring is String (Positive);\n+   type Cstring_Ptr is access all Cstring;\n+   pragma No_Strict_Aliasing (Cstring_Ptr);\n+\n+   --  We suppress index checks because the declared size in the record below\n+   --  is a dummy size of one (see below).\n+\n+   type Tag_Table is array (Natural range <>) of Tag;\n+   pragma Suppress_Initialization (Tag_Table);\n+   pragma Suppress (Index_Check, On => Tag_Table);\n+\n+   package SSE renames System.Storage_Elements;\n+\n+   --  Type specific data types\n+\n+   type Type_Specific_Data (Idepth : Natural) is record\n+      --  Inheritance Depth Level: Used to implement the membership test\n+      --  associated with single inheritance of tagged types in constant-time.\n+      --  It also indicates the size of the Tags_Table component.\n+\n+      Access_Level : Natural;\n+      --  Accessibility level required to give support to Ada 2005 nested type\n+      --  extensions. This feature allows safe nested type extensions by\n+      --  shifting the accessibility checks to certain operations, rather than\n+      --  being enforced at the type declaration. In particular, by performing\n+      --  run-time accessibility checks on class-wide allocators, class-wide\n+      --  function return, and class-wide stream I/O, the danger of objects\n+      --  outliving their type declaration can be eliminated (Ada 2005: AI-344)\n+\n+      Expanded_Name : Cstring_Ptr;\n+      External_Tag  : Cstring_Ptr;\n+      HT_Link       : Tag;\n+      --  Components used to support to the Ada.Tags subprograms in RM 3.9.\n+      --  Note: Expanded_Name is referenced by GDB ???\n+\n+      Remotely_Callable : Boolean;\n+      --  Used to check ARM E.4 (18)\n+\n+      RC_Offset : SSE.Storage_Offset;\n+      --  Controller Offset: Used to give support to tagged controlled objects\n+      --  (see Get_Deep_Controller at s-finimp)\n+\n+      Ifaces_Table_Ptr : System.Address;\n+      --  Pointer to the table of interface tags. It is used to implement the\n+      --  membership test associated with interfaces and also for backward\n+      --  abstract interface type conversions (Ada 2005:AI-251)\n+\n+      SSD_Ptr : System.Address;\n+      --  Pointer to a table of records used in dispatching selects. This\n+      --  field has a meaningful value for all tagged types that implement\n+      --  a limited, protected, synchronized or task interfaces and have\n+      --  non-predefined primitive operations.\n+\n+      Tags_Table : Tag_Table (0 .. Idepth);\n+      --  Table of ancestor tags. Its size actually depends on the inheritance\n+      --  depth level of the tagged type.\n+   end record;\n+\n+   --  Declarations for the table of interfaces\n+\n+   type Interface_Data_Element is record\n+      Iface_Tag            : Tag;\n+      Static_Offset_To_Top : Boolean;\n+      Offset_To_Top_Value  : System.Storage_Elements.Storage_Offset;\n+      Offset_To_Top_Func   : System.Address;\n+   end record;\n+   --  If some ancestor of the tagged type has discriminants the field\n+   --  Static_Offset_To_Top is False and the field Offset_To_Top_Func\n+   --  is used to store the address of the function generated by the\n+   --  expander which provides this value; otherwise Static_Offset_To_Top\n+   --  is True and such value is stored in the Offset_To_Top_Value field.\n+\n+   type Interfaces_Array is\n+     array (Natural range <>) of Interface_Data_Element;\n+\n+   type Interface_Data (Nb_Ifaces : Positive) is record\n+      Ifaces_Table : Interfaces_Array (1 .. Nb_Ifaces);\n+   end record;\n+\n+   --  Declaration of tag types\n \n-   type Dispatch_Table;\n    type Tag is access all Dispatch_Table;\n+   type Tag_Ptr is access Tag;\n    type Interface_Tag is access all Dispatch_Table;\n+   type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n \n    No_Tag : constant Tag := null;\n \n-   type Interface_Data (Nb_Ifaces : Positive);\n    type Interface_Data_Ptr is access all Interface_Data;\n    --  Table of abstract interfaces used to give support to backward interface\n    --  conversions and also to IW_Membership.\n@@ -132,9 +305,6 @@ private\n    --  type. This construct is used in the handling of dispatching triggers\n    --  in select statements.\n \n-   type Type_Specific_Data;\n-   type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n-\n    --  Primitive operation kinds. These values differentiate the kinds of\n    --  callable entities stored in the dispatch table. Certain kinds may\n    --  not be used, but are added for completeness.\n@@ -162,8 +332,7 @@ private\n    type Tagged_Kind_Ptr is access all Tagged_Kind;\n \n    Default_Prim_Op_Count : constant Positive := 15;\n-   --  Number of predefined primitive operations added by the Expander for a\n-   --  tagged type (must match Exp_Disp.Default_Prim_Op_Count).\n+   --  Maximum number of predefined primitive operations of a tagged type.\n \n    type Signature_Kind is\n       (Unknown,\n@@ -183,68 +352,101 @@ private\n    --  range Primary_DT .. Abstract_Interface. The Unknown value is used by\n    --  the Check_XXX routines to indicate that the signature is wrong.\n \n-   package SSE renames System.Storage_Elements;\n+   DT_Min_Prologue_Size : constant SSE.Storage_Count :=\n+                            SSE.Storage_Count\n+                              (2 * (Standard'Address_Size /\n+                                      System.Storage_Unit));\n+   --  Size of the hidden part of the dispatch table used when the program\n+   --  is compiled under restriction No_Dispatching_Calls. It contains the\n+   --  pointer to the TSD record plus a dummy entry whose address is used\n+   --  at run-time as the Tag.\n+\n+   DT_Prologue_Size : constant SSE.Storage_Count :=\n+                        SSE.Storage_Count\n+                          ((Default_Prim_Op_Count + 4) *\n+                            (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of the hidden part of the dispatch table. It contains the table of\n+   --  predefined primitive operations plus the C++ ABI header.\n+\n+   DT_Signature_Size : constant SSE.Storage_Count :=\n+                         SSE.Storage_Count\n+                           (1 * (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of the Signature field of the dispatch table\n+\n+   DT_Tagged_Kind_Size : constant SSE.Storage_Count :=\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of the Tagged_Type_Kind field of the dispatch table\n+\n+   DT_Offset_To_Top_Size : constant SSE.Storage_Count :=\n+                             SSE.Storage_Count\n+                               (1 * (Standard'Address_Size /\n+                                       System.Storage_Unit));\n+   --  Size of the Offset_To_Top field of the Dispatch Table\n+\n+   DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n+                            SSE.Storage_Count\n+                              (1 * (Standard'Address_Size /\n+                                      System.Storage_Unit));\n+   --  Size of the Typeinfo_Ptr field of the Dispatch Table\n+\n+   DT_Entry_Size : constant SSE.Storage_Count :=\n+                     SSE.Storage_Count\n+                       (1 * (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of each primitive operation entry in the Dispatch Table\n+\n+   Tag_Size : constant SSE.Storage_Count :=\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of each tag\n+\n+   --  Constants used by the code generated by the frontend to get access\n+   --  to the header of the dispatch table.\n+\n+   K_Typeinfo      : constant SSE.Storage_Count := DT_Typeinfo_Ptr_Size;\n+   K_Offset_To_Top : constant SSE.Storage_Count :=\n+                       System.Storage_Elements.\"+\"\n+                         (K_Typeinfo, DT_Offset_To_Top_Size);\n+   K_Tagged_Kind   : constant SSE.Storage_Count :=\n+                       System.Storage_Elements.\"+\"\n+                         (K_Offset_To_Top, DT_Tagged_Kind_Size);\n+   K_Signature     : constant SSE.Storage_Count :=\n+                       System.Storage_Elements.\"+\"\n+                         (K_Tagged_Kind, DT_Signature_Size);\n+\n+   --  The following subprogram specifications are placed here instead of\n+   --  the package body to see them from the frontend through rtsfind.\n+\n+   function Base_Address (This : System.Address) return System.Address;\n+   --  Ada 2005 (AI-251): Displace \"This\" to point to the base address of\n+   --  the object (that is, the address of the primary tag of the object).\n \n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean;\n    --  Given the tag of an object and the tag associated to a type, return\n    --  true if Obj is in Typ'Class.\n \n-   function IW_Membership (This : System.Address; T : Tag) return Boolean;\n-   --  Ada 2005 (AI-251): General routine that checks if a given object\n-   --  implements a tagged type. Its common usage is to check if Obj is in\n-   --  Iface'Class, but it is also used to check if a class-wide interface\n-   --  implements a given type (Iface_CW_Typ in T'Class). For example:\n-   --\n-   --      type I is interface;\n-   --      type T is tagged ...\n-   --\n-   --      function Test (O : I'Class) is\n-   --      begin\n-   --         return O in T'Class.\n-   --      end Test;\n-\n    function Displace (This : System.Address; T : Tag) return System.Address;\n-   --  (Ada 2005 (AI-251): Displace \"This\" to point to the secondary dispatch\n+   --  Ada 2005 (AI-251): Displace \"This\" to point to the secondary dispatch\n    --  table of T.\n \n-   function Get_Access_Level (T : Tag) return Natural;\n-   --  Given the tag associated with a type, returns the accessibility level\n-   --  of the type.\n-\n    function Get_Entry_Index (T : Tag; Position : Positive) return Positive;\n-   --  Return a primitive operation's entry index (if entry) given a dispatch\n-   --  table T and a position of a primitive operation in T.\n+   --  Ada 2005 (AI-251): Return a primitive operation's entry index (if entry)\n+   --  given a dispatch table T and a position of a primitive operation in T.\n \n    function Get_External_Tag (T : Tag) return System.Address;\n-   --  Retrieve the address of a null terminated string containing\n-   --  the external name.\n+   --  Returns address of a null terminated string containing the external name\n \n    function Get_Offset_Index\n      (T        : Tag;\n       Position : Positive) return Positive;\n-   --  Given a pointer to a secondary dispatch table (T) and a position of an\n-   --  operation in the DT, retrieve the corresponding operation's position in\n-   --  the primary dispatch table from the Offset Specific Data table of T.\n-\n-   function Get_Predefined_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive) return System.Address;\n-   --  Given a pointer to a dispatch table (T) and a position in the DT\n-   --  this function returns the address of the virtual function stored\n-   --  in it (used for dispatching calls).\n-\n-   function Get_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive) return System.Address;\n-   --  Given a pointer to a dispatch table (T) and a position in the DT\n-   --  this function returns the address of the virtual function stored\n-   --  in it (used for dispatching calls).\n+   --  Ada 2005 (AI-251): Given a pointer to a secondary dispatch table (T) and\n+   --  a position of an operation in the DT, retrieve the corresponding\n+   --  operation's position in the primary dispatch table from the Offset\n+   --  Specific Data table of T.\n \n    function Get_Prim_Op_Kind\n      (T        : Tag;\n       Position : Positive) return Prim_Op_Kind;\n-   --  Return a primitive operation's kind given a dispatch table T and a\n-   --  position of a primitive operation in T.\n+   --  Ada 2005 (AI-251): Return a primitive operation's kind given a dispatch\n+   --  table T and a position of a primitive operation in T.\n \n    function Get_RC_Offset (T : Tag) return SSE.Storage_Offset;\n    --  Return the Offset of the implicit record controller when the object\n@@ -255,37 +457,35 @@ private\n    --  it is exported manually in order to avoid changing completely the\n    --  organization of the run time.\n \n-   function Get_Remotely_Callable (T : Tag) return Boolean;\n-   --  Return the value previously set by Set_Remotely_Callable\n-\n    function Get_Tagged_Kind (T : Tag) return Tagged_Kind;\n-   --  Given a pointer to either a primary or a secondary dispatch table,\n-   --  return the tagged kind of a type in the context of concurrency and\n-   --  limitedness.\n-\n-   procedure Inherit_CPP_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural);\n-   --  Entry point used to initialize the DT of a type knowing the tag\n-   --  of the direct CPP ancestor and the number of primitive ops that\n-   --  are inherited (Entry_Count).\n-\n-   procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural);\n-   --  Entry point used to initialize the DT of a type knowing the tag\n-   --  of the direct ancestor and the number of primitive ops that are\n-   --  inherited (Entry_Count).\n+   --  Ada 2005 (AI-345): Given a pointer to either a primary or a secondary\n+   --  dispatch table, return the tagged kind of a type in the context of\n+   --  concurrency and limitedness.\n \n-   procedure Inherit_TSD (Old_Tag : Tag; New_Tag : Tag);\n-   --  Initialize the TSD of a type knowing the tag of the direct ancestor\n+   function IW_Membership (This : System.Address; T : Tag) return Boolean;\n+   --  Ada 2005 (AI-251): General routine that checks if a given object\n+   --  implements a tagged type. Its common usage is to check if Obj is in\n+   --  Iface'Class, but it is also used to check if a class-wide interface\n+   --  implements a given type (Iface_CW_Typ in T'Class). For example:\n+   --\n+   --      type I is interface;\n+   --      type T is tagged ...\n+   --\n+   --      function Test (O : I'Class) is\n+   --      begin\n+   --         return O in T'Class.\n+   --      end Test;\n \n    function Offset_To_Top\n      (This : System.Address) return System.Storage_Elements.Storage_Offset;\n-   --  Returns the current value of the offset_to_top component available in\n-   --  the prologue of the dispatch table. If the parent of the tagged type\n-   --  has discriminants this value is stored in a record component just\n-   --  immediately after the tag component.\n+   --  Ada 2005 (AI-251): Returns the current value of the offset_to_top\n+   --  component available in the prologue of the dispatch table. If the parent\n+   --  of the tagged type has discriminants this value is stored in a record\n+   --  component just immediately after the tag component.\n \n    function OSD (T : Tag) return Object_Specific_Data_Ptr;\n    --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n-   --  retrieve the address of the record containing the Objet Specific\n+   --  retrieve the address of the record containing the Object Specific\n    --  Data table.\n \n    function Parent_Size\n@@ -311,36 +511,20 @@ private\n    --  Insert the Tag and its associated external_tag in a table for the\n    --  sake of Internal_Tag\n \n-   procedure Set_Access_Level (T : Tag; Value : Natural);\n-   --  Sets the accessibility level of the tagged type associated with T\n-   --  in its TSD.\n-\n    procedure Set_Entry_Index (T : Tag; Position : Positive; Value : Positive);\n-   --  Set the entry index of a primitive operation in T's TSD table indexed\n-   --  by Position.\n-\n-   procedure Set_Expanded_Name (T : Tag; Value : System.Address);\n-   --  Set the address of the string containing the expanded name\n-   --  in the Dispatch table.\n-\n-   procedure Set_External_Tag (T : Tag; Value : System.Address);\n-   --  Set the address of the string containing the external tag\n-   --  in the Dispatch table.\n+   --  Ada 2005 (AI-345): Set the entry index of a primitive operation in T's\n+   --  TSD table indexed by Position.\n \n    procedure Set_Interface_Table (T : Tag; Value : System.Address);\n    --  Ada 2005 (AI-251): Given a pointer T to a dispatch Table, stores the\n    --  pointer to the table of interfaces.\n \n-   procedure Set_Num_Prim_Ops (T : Tag; Value : Natural);\n-   --  Set the number of primitive operations in the dispatch table of T. This\n-   --  is used for debugging purposes.\n-\n    procedure Set_Offset_Index\n      (T        : Tag;\n       Position : Positive;\n       Value    : Positive);\n-   --  Set the offset value of a primitive operation in a secondary dispatch\n-   --  table denoted by T, indexed by Position.\n+   --  Ada 2005 (AI-345): Set the offset value of a primitive operation in a\n+   --  secondary dispatch table denoted by T, indexed by Position.\n \n    procedure Set_Offset_To_Top\n      (This         : System.Address;\n@@ -358,121 +542,40 @@ private\n    --  secondary dispatch table.\n \n    procedure Set_OSD (T : Tag; Value : System.Address);\n-   --  Given a pointer T to a secondary dispatch table, store the pointer to\n-   --  the record containing the Object Specific Data generated by GNAT.\n-\n-   procedure Set_Predefined_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive;\n-      Value    : System.Address);\n-   --  Given a pointer to a dispatch Table (T) and a position in the dispatch\n-   --  table associated with a predefined primitive operation, put the address\n-   --  of the virtual function in it (used for overriding).\n-\n-   procedure Set_Prim_Op_Address\n-     (T        : Tag;\n-      Position : Positive;\n-      Value    : System.Address);\n-   --  Given a pointer to a dispatch Table (T) and a position in the dispatch\n-   --  Table put the address of the virtual function in it (used for\n-   --  overriding).\n+   --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n+   --  store the pointer to the record containing the Object Specific Data\n+   --  generated by GNAT.\n \n    procedure Set_Prim_Op_Kind\n      (T        : Tag;\n       Position : Positive;\n       Value    : Prim_Op_Kind);\n-   --  Set the kind of a primitive operation in T's TSD table indexed by\n-   --  Position.\n-\n-   procedure Set_RC_Offset (T : Tag; Value : SSE.Storage_Offset);\n-   --  Sets the Offset of the implicit record controller when the object\n-   --  has controlled components. Set to O otherwise.\n-\n-   procedure Set_Remotely_Callable (T : Tag; Value : Boolean);\n-   --  Set to true if the type has been declared in a context described\n-   --  in E.4 (18).\n+   --  Ada 2005 (AI-251): Set the kind of a primitive operation in T's TSD\n+   --  table indexed by Position.\n \n    procedure Set_Signature (T : Tag; Value : Signature_Kind);\n    --  Given a pointer T to a dispatch table, store the signature id\n \n    procedure Set_SSD (T : Tag; Value : System.Address);\n-   --  Given a pointer T to a dispatch Table, stores the pointer to the record\n-   --  containing the Select Specific Data generated by GNAT.\n+   --  Ada 2005 (AI-345): Given a pointer T to a dispatch Table, stores the\n+   --  pointer to the record containing the Select Specific Data generated by\n+   --  GNAT.\n \n    procedure Set_Tagged_Kind (T : Tag; Value : Tagged_Kind);\n-   --  Set the tagged kind of a type in either a primary or a secondary\n-   --  dispatch table denoted by T.\n-\n-   procedure Set_TSD (T : Tag; Value : System.Address);\n-   --  Given a pointer T to a dispatch Table, stores the address of the record\n-   --  containing the Type Specific Data generated by GNAT.\n+   --  Ada 2005 (AI-345): Set the tagged kind of a type in either a primary or\n+   --  a secondary dispatch table denoted by T.\n \n    function SSD (T : Tag) return Select_Specific_Data_Ptr;\n-   --  Given a pointer T to a dispatch Table, retrieves the address of the\n-   --  record containing the Select Specific Data in T's TSD.\n+   --  Ada 2005 (AI-251): Given a pointer T to a dispatch Table, retrieves the\n+   --  address of the record containing the Select Specific Data in T's TSD.\n \n    function TSD (T : Tag) return Type_Specific_Data_Ptr;\n    --  Given a pointer T to a dispatch Table, retrieves the address of the\n    --  record containing the Type Specific Data generated by GNAT.\n \n-   DT_Prologue_Size : constant SSE.Storage_Count :=\n-                        SSE.Storage_Count\n-                          ((Default_Prim_Op_Count + 4) *\n-                            (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of the hidden part of the dispatch table. It contains the table of\n-   --  predefined primitive operations plus the C++ ABI header.\n-\n-   DT_Signature_Size : constant SSE.Storage_Count :=\n-                         SSE.Storage_Count\n-                           (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of the Signature field of the dispatch table\n-\n-   DT_Tagged_Kind_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of the Tagged_Type_Kind field of the dispatch table\n-\n-   DT_Offset_To_Top_Size : constant SSE.Storage_Count :=\n-                             SSE.Storage_Count\n-                               (1 * (Standard'Address_Size /\n-                                       System.Storage_Unit));\n-   --  Size of the Offset_To_Top field of the Dispatch Table\n-\n-   DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n-                            SSE.Storage_Count\n-                              (1 * (Standard'Address_Size /\n-                                      System.Storage_Unit));\n-   --  Size of the Typeinfo_Ptr field of the Dispatch Table\n-\n-   DT_Entry_Size : constant SSE.Storage_Count :=\n-                     SSE.Storage_Count\n-                       (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of each primitive operation entry in the Dispatch Table\n-\n-   Tag_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of each tag\n-\n-   TSD_Prologue_Size : constant SSE.Storage_Count :=\n-                         SSE.Storage_Count\n-                           (10 * (Standard'Address_Size /\n-                                   System.Storage_Unit));\n-   --  Size of the first part of the type specific data\n-\n-   TSD_Entry_Size : constant SSE.Storage_Count :=\n-                      SSE.Storage_Count\n-                        (1 * (Standard'Address_Size / System.Storage_Unit));\n-   --  Size of each ancestor tag entry in the TSD\n-\n-   type Address_Array is array (Natural range <>) of System.Address;\n-   pragma Suppress (Index_Check, On => Address_Array);\n-   --  The reason we suppress index checks is that in the body, objects\n-   --  of this type are declared with a dummy size of 1, the actual size\n-   --  depending on the number of primitive operations.\n-\n    --  Unchecked Conversions\n \n    type Addr_Ptr is access System.Address;\n-   type Tag_Ptr  is access Tag;\n \n    type Signature_Values is\n       array (1 .. DT_Signature_Size) of Signature_Kind;\n@@ -486,15 +589,9 @@ private\n    function To_Type_Specific_Data_Ptr is\n      new Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n \n-   function To_Address is\n-     new Unchecked_Conversion (Interface_Tag, System.Address);\n-\n    function To_Address is\n      new Unchecked_Conversion (Tag, System.Address);\n \n-   function To_Address is\n-     new Unchecked_Conversion (Type_Specific_Data_Ptr, System.Address);\n-\n    function To_Interface_Data_Ptr is\n      new Unchecked_Conversion (System.Address, Interface_Data_Ptr);\n \n@@ -527,37 +624,21 @@ private\n    pragma Inline_Always (CW_Membership);\n    pragma Inline_Always (Displace);\n    pragma Inline_Always (IW_Membership);\n-   pragma Inline_Always (Get_Access_Level);\n    pragma Inline_Always (Get_Entry_Index);\n    pragma Inline_Always (Get_Offset_Index);\n-   pragma Inline_Always (Get_Predefined_Prim_Op_Address);\n-   pragma Inline_Always (Get_Prim_Op_Address);\n    pragma Inline_Always (Get_Prim_Op_Kind);\n-   pragma Inline_Always (Get_RC_Offset);\n-   pragma Inline_Always (Get_Remotely_Callable);\n    pragma Inline_Always (Get_Tagged_Kind);\n-   pragma Inline_Always (Inherit_DT);\n-   pragma Inline_Always (Inherit_TSD);\n    pragma Inline_Always (OSD);\n    pragma Inline_Always (Register_Interface_Tag);\n    pragma Inline_Always (Register_Tag);\n-   pragma Inline_Always (Set_Access_Level);\n    pragma Inline_Always (Set_Entry_Index);\n-   pragma Inline_Always (Set_Expanded_Name);\n-   pragma Inline_Always (Set_External_Tag);\n    pragma Inline_Always (Set_Interface_Table);\n-   pragma Inline_Always (Set_Num_Prim_Ops);\n    pragma Inline_Always (Set_Offset_Index);\n    pragma Inline_Always (Set_Offset_To_Top);\n-   pragma Inline_Always (Set_Predefined_Prim_Op_Address);\n-   pragma Inline_Always (Set_Prim_Op_Address);\n    pragma Inline_Always (Set_Prim_Op_Kind);\n-   pragma Inline_Always (Set_RC_Offset);\n-   pragma Inline_Always (Set_Remotely_Callable);\n    pragma Inline_Always (Set_Signature);\n    pragma Inline_Always (Set_OSD);\n    pragma Inline_Always (Set_SSD);\n-   pragma Inline_Always (Set_TSD);\n    pragma Inline_Always (Set_Tagged_Kind);\n    pragma Inline_Always (SSD);\n    pragma Inline_Always (TSD);"}]}