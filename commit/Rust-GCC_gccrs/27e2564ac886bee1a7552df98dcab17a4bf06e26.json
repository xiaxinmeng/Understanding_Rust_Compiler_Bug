{"sha": "27e2564ac886bee1a7552df98dcab17a4bf06e26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdlMjU2NGFjODg2YmVlMWE3NTUyZGY5OGRjYWIxN2E0YmYwNmUyNg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-27T08:00:04Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-27T08:00:04Z"}, "message": "c-lex.c (cb_enter_file, [...]): Combine into the new function cb_change_file.\n\n        * c-lex.c (cb_enter_file, cb_leave_file, cb_rename_file):\n        Combine into the new function cb_change_file.\n        (init_c_lex): Update.\n        * cppfiles.c (stack_include_file): Use _cpp_do_file_change.\n        (cpp_syshdr_flags): Delete.\n        * cpphash.h (_cpp_do_file_change): New prototype.\n        Move struct cpp_buffer here from...\n        * cpplib.h (struct cpp_buffer): ... here.\n        (enum cpp_fc_reason, struct cpp_file_loc,\n        struct_cpp_file_change, change_file): New.\n        (enter_file, leave_file, rename_file, cpp_syshdr_flags): Delete.\n        * cpplib.c (do_line): Update for new cb_change_file callback.\n        (_cpp_do_file_change): New function.\n        (_cpp_pop_buffer): Update to use it.\n        * cppmain.c (move_printer): Delete.\n        (main): Set up single callback cb_change_file.\n        (cb_enter_file, cb_leave_file, cb_rename_file): Delete.\n        (cb_change_file): New.\n        * fix-header.c (cur_file, cb_change_file): New.\n        (recognized_function, read_scan_file): Update.\n        * scan-decls.c (scan_decls): Update.\n        * scan.h (recognized_function): Update prototype.\n\nFrom-SVN: r37784", "tree": {"sha": "6ecb94c4e9edb0c2004142e389531669ea20c416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ecb94c4e9edb0c2004142e389531669ea20c416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27e2564ac886bee1a7552df98dcab17a4bf06e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e2564ac886bee1a7552df98dcab17a4bf06e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e2564ac886bee1a7552df98dcab17a4bf06e26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e2564ac886bee1a7552df98dcab17a4bf06e26/comments", "author": null, "committer": null, "parents": [{"sha": "9ccb25d582aba15db6bb27944085c7478d532ade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccb25d582aba15db6bb27944085c7478d532ade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccb25d582aba15db6bb27944085c7478d532ade"}], "stats": {"total": 729, "additions": 262, "deletions": 467}, "files": [{"sha": "df1f036d042167053b1af5d9ee387dd1a6428651", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -1,3 +1,28 @@\n+2000-11-27  Neil Booth  <neilb@earthling.net>\n+\n+        * c-lex.c (cb_enter_file, cb_leave_file, cb_rename_file):\n+        Combine into the new function cb_change_file.\n+        (init_c_lex): Update.\n+        * cppfiles.c (stack_include_file): Use _cpp_do_file_change.\n+        (cpp_syshdr_flags): Delete.\n+        * cpphash.h (_cpp_do_file_change): New prototype.\n+        Move struct cpp_buffer here from...\n+        * cpplib.h (struct cpp_buffer): ... here.\n+        (enum cpp_fc_reason, struct cpp_file_loc,\n+        struct_cpp_file_change, change_file): New.\n+        (enter_file, leave_file, rename_file, cpp_syshdr_flags): Delete.\n+        * cpplib.c (do_line): Update for new cb_change_file callback.\n+        (_cpp_do_file_change): New function.\n+        (_cpp_pop_buffer): Update to use it.\n+        * cppmain.c (move_printer): Delete.\n+        (main): Set up single callback cb_change_file.\n+        (cb_enter_file, cb_leave_file, cb_rename_file): Delete.\n+        (cb_change_file): New.\n+        * fix-header.c (cur_file, cb_change_file): New.\n+        (recognized_function, read_scan_file): Update.\n+        * scan-decls.c (scan_decls): Update.\n+        * scan.h (recognized_function): Update prototype.\n+\n 2000-11-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.h (mark_tree_hashtable): New function."}, {"sha": "959b10331b5a3a41c4d733182ca3c113c6f516eb", "filename": "gcc/c-lex.c", "status": "modified", "additions": 46, "deletions": 305, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -93,9 +93,7 @@ static tree lex_charconst\tPARAMS ((const char *, unsigned int, int));\n static void update_header_times\tPARAMS ((const char *));\n static int dump_one_header\tPARAMS ((splay_tree_node, void *));\n static void cb_ident\t\tPARAMS ((cpp_reader *, const cpp_string *));\n-static void cb_enter_file\tPARAMS ((cpp_reader *));\n-static void cb_leave_file\tPARAMS ((cpp_reader *));\n-static void cb_rename_file\tPARAMS ((cpp_reader *));\n+static void cb_change_file    PARAMS ((cpp_reader *, const cpp_file_change *));\n static void cb_def_pragma\tPARAMS ((cpp_reader *));\n \f\n const char *\n@@ -125,9 +123,7 @@ init_c_lex (filename)\n #endif\n \n   parse_in.cb.ident = cb_ident;\n-  parse_in.cb.enter_file = cb_enter_file;\n-  parse_in.cb.leave_file = cb_leave_file;\n-  parse_in.cb.rename_file = cb_rename_file;\n+  parse_in.cb.change_file = cb_change_file;\n   parse_in.cb.def_pragma = cb_def_pragma;\n \n   /* Make sure parse_in.digraphs matches flag_digraphs.  */\n@@ -218,203 +214,63 @@ dump_time_statistics ()\n   splay_tree_foreach (file_info_tree, dump_one_header, 0);\n }\n \n-#if 0 /* Keep this code for a while for reference.  */\n+/* Not yet handled: #pragma, #define, #undef.\n+   No need to deal with linemarkers under normal conditions.  */\n+\n static void\n-process_directive ()\n+cb_ident (pfile, str)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const cpp_string *str;\n {\n-  enum cpp_ttype token;\n-  tree value;\n-  int saw_line;\n-  enum { act_none, act_push, act_pop } action;\n-  int action_number, l;\n-  const char *new_file;\n-#ifndef NO_IMPLICIT_EXTERN_C\n-  int entering_c_header = 0;\n-#endif\n-  \n-  /* Don't read beyond this line.  */\n-  saw_line = 0;\n-  linemode = 1;\n-  \n-  token = c_lex (&value);\n-\n-  if (token == CPP_NAME)\n-    {\n-      /* If a letter follows, then if the word here is `line', skip\n-\t it and ignore it; otherwise, ignore the line, with an error\n-\t if the word isn't `pragma'.  */\n-\n-      const char *name = IDENTIFIER_POINTER (value);\n-\n-      if (!strcmp (name, \"pragma\"))\n-\t{\n-\t  dispatch_pragma ();\n-\t  goto skipline;\n-\t}\n-      else if (!strcmp (name, \"define\"))\n-\t{\n-\t  debug_define (lex_lineno, GET_DIRECTIVE_LINE ());\n-\t  goto skipline;\n-\t}\n-      else if (!strcmp (name, \"undef\"))\n-\t{\n-\t  debug_undef (lex_lineno, GET_DIRECTIVE_LINE ());\n-\t  goto skipline;\n-\t}\n-      else if (!strcmp (name, \"line\"))\n-\t{\n-\t  saw_line = 1;\n-\t  token = c_lex (&value);\n-\t  goto linenum;\n-\t}\n-      else if (!strcmp (name, \"ident\"))\n-\t{\n-\t  /* #ident.  We expect a string constant here.\n-\t     The pedantic warning and syntax error are now in cpp.  */\n-\n-\t  token = c_lex (&value);\n-\t  if (token != CPP_STRING || TREE_CODE (value) != STRING_CST)\n-\t    goto skipline;\n-\n #ifdef ASM_OUTPUT_IDENT\n-\t  if (! flag_no_ident)\n-\t    {\n-\t      ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (value));\n-\t    }\n-#endif\n-\n-\t  /* Skip the rest of this line.  */\n-\t  goto skipline;\n-\t}\n-\n-      error (\"undefined or invalid # directive `%s'\", name);\n-      goto skipline;\n-    }\n-\n-  /* If the # is the only nonwhite char on the line,\n-     just ignore it.  Check the new newline.  */\n-  if (token == CPP_EOF)\n-    goto skipline;\n-\n-linenum:\n-  /* Here we have either `#line' or `# <nonletter>'.\n-     In either case, it should be a line number; a digit should follow.  */\n-\n-  if (token != CPP_NUMBER || TREE_CODE (value) != INTEGER_CST)\n-    {\n-      error (\"invalid #-line\");\n-      goto skipline;\n-    }\n-\n-  /* subtract one, because it is the following line that\n-     gets the specified number */\n-\n-  l = TREE_INT_CST_LOW (value) - 1;\n-\n-  /* More follows: it must be a string constant (filename).\n-     It would be neat to use cpplib to quickly process the string, but\n-     (1) we don't have a handy tokenization of the string, and\n-     (2) I don't know how well that would work in the presense\n-     of filenames that contain wide characters.  */\n-\n-  if (saw_line)\n-    {\n-      /* Don't treat \\ as special if we are processing #line 1 \"...\".\n-\t If you want it to be treated specially, use # 1 \"...\".  */\n-      ignore_escape_flag = 1;\n-    }\n-\n-  /* Read the string constant.  */\n-  token = c_lex (&value);\n-\n-  ignore_escape_flag = 0;\n-\n-  if (token == CPP_EOF)\n-    {\n-      /* No more: store the line number and check following line.  */\n-      lex_lineno = l;\n-      goto skipline;\n-    }\n-\n-  if (token != CPP_STRING || TREE_CODE (value) != STRING_CST)\n-    {\n-      error (\"invalid #line\");\n-      goto skipline;\n-    }\n-\n-  new_file = TREE_STRING_POINTER (value);\n-\n-  if (main_input_filename == 0)\n-    main_input_filename = new_file;\n-\n-  action = act_none;\n-  action_number = 0;\n-\n-  /* Each change of file name\n-     reinitializes whether we are now in a system header.  */\n-  in_system_header = 0;\n-\n-  if (!read_line_number (&action_number))\n-    {\n-      /* Update the name in the top element of input_file_stack.  */\n-      if (input_file_stack)\n-\tinput_file_stack->name = input_filename;\n-    }\n-\n-  /* `1' after file name means entering new file.\n-     `2' after file name means just left a file.  */\n-\n-  if (action_number == 1)\n-    {\n-      action = act_push;\n-      read_line_number (&action_number);\n-    }\n-  else if (action_number == 2)\n-    {\n-      action = act_pop;\n-      read_line_number (&action_number);\n-    }\n-  if (action_number == 3)\n-    {\n-      /* `3' after file name means this is a system header file.  */\n-      in_system_header = 1;\n-      read_line_number (&action_number);\n-    }\n-#ifndef NO_IMPLICIT_EXTERN_C\n-  if (action_number == 4)\n+  if (! flag_no_ident)\n     {\n-      /* `4' after file name means this is a C header file.  */\n-      entering_c_header = 1;\n-      read_line_number (&action_number);\n+      /* Convert escapes in the string.  */\n+      tree value = lex_string ((const char *)str->text, str->len, 0);\n+      ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (value));\n     }\n #endif\n+}\n+\n+static void\n+cb_change_file (pfile, fc)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const cpp_file_change *fc;\n+{\n+  if (fc->from.filename == 0)\n+    main_input_filename = fc->to.filename;\n+  in_system_header = fc->sysp;\n \n   /* Do the actions implied by the preceding numbers.  */\n-  if (action == act_push)\n+  if (fc->reason == FC_ENTER)\n     {\n-      lineno = lex_lineno;\n-      push_srcloc (input_filename, 1);\n-      input_file_stack->indent_level = indent_level;\n-      debug_start_source_file (input_filename);\n-#ifndef NO_IMPLICIT_EXTERN_C\n-      if (c_header_level)\n-\t++c_header_level;\n-      else if (entering_c_header)\n+      /* FIXME.  Don't stack the main buffer on the input stack.  */\n+      if (fc->from.filename)\n \t{\n-\t  c_header_level = 1;\n-\t  ++pending_lang_change;\n-\t}\n+\t  lineno = lex_lineno;\n+\t  push_srcloc (fc->to.filename, 1);\n+\t  input_file_stack->indent_level = indent_level;\n+\t  debug_start_source_file (fc->to.filename);\n+#ifndef NO_IMPLICIT_EXTERN_C\n+\t  if (c_header_level)\n+\t    ++c_header_level;\n+\t  else if (fc->externc)\n+\t    {\n+\t      c_header_level = 1;\n+\t      ++pending_lang_change;\n+\t    }\n #endif\n+\t}\n     }\n-  else if (action == act_pop)\n+  else if (fc->reason == FC_LEAVE)\n     {\n       /* Popping out of a file.  */\n       if (input_file_stack->next)\n \t{\n #ifndef NO_IMPLICIT_EXTERN_C\n \t  if (c_header_level && --c_header_level == 0)\n \t    {\n-\t      if (entering_c_header)\n+\t      if (fc->externc)\n \t\twarning (\"badly nested C headers from preprocessor\");\n \t      --pending_lang_change;\n \t    }\n@@ -433,131 +289,16 @@ process_directive ()\n \t  debug_end_source_file (input_file_stack->line);\n \t}\n       else\n-\terror (\"#-lines for entering and leaving files don't match\");\n-    }\n-\n-  update_header_times (new_file);\n-\n-  input_filename = new_file;\n-  lex_lineno = l;\n-\n-  /* Hook for C++.  */\n-  extract_interface_info ();\n-\n-  /* skip the rest of this line.  */\n- skipline:\n-  linemode = 0;\n-\n-  while (getch () != '\\n');\n-}\n-#endif\n-\n-/* Not yet handled: #pragma, #define, #undef.\n-   No need to deal with linemarkers under normal conditions.  */\n-\n-static void\n-cb_ident (pfile, str)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     const cpp_string *str;\n-{\n-#ifdef ASM_OUTPUT_IDENT\n-  if (! flag_no_ident)\n-    {\n-      /* Convert escapes in the string.  */\n-      tree value = lex_string ((const char *)str->text, str->len, 0);\n-      ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (value));\n-    }\n-#endif\n-}\n-\n-static void\n-cb_enter_file (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-  /* Bleah, need a better interface to this.  */\n-  const char *flags = cpp_syshdr_flags (pfile, ip);\n-\n-  /* Mustn't stack the main buffer on the input stack.  (Ick.)  */\n-  if (ip->prev)\n-    {\n-      lex_lineno = lineno = ip->prev->lineno - 1;\n-      push_srcloc (ip->nominal_fname, 1);\n-      input_file_stack->indent_level = indent_level;\n-      debug_start_source_file (ip->nominal_fname);\n+\terror (\"leaving more files than we entered\");\n     }\n-  else\n-    lex_lineno = 1;\n+  else if (fc->reason == FC_RENAME)\n+    input_filename = fc->to.filename;\n \n-  update_header_times (ip->nominal_fname);\n+  update_header_times (fc->to.filename);\n \n-  /* Hook for C++.  */\n-  extract_interface_info ();\n+  input_filename = fc->to.filename;\n+  lex_lineno = fc->to.lineno;\n \n-  in_system_header = (flags[0] != 0);\n-#ifndef NO_IMPLICIT_EXTERN_C\n-  if (c_header_level)\n-    ++c_header_level;\n-  else if (in_system_header && flags[1] != 0 && flags[2] != 0)\n-    {\n-      c_header_level = 1;\n-      ++pending_lang_change;\n-    }\n-#endif\n-}\n-\n-static void\n-cb_leave_file (pfile)\n-     cpp_reader *pfile;\n-{\n-  /* Bleah, need a better interface to this.  */\n-  const char *flags = cpp_syshdr_flags (pfile, CPP_BUFFER (pfile));\n-\n-  if (input_file_stack->next)\n-    {\n-#ifndef NO_IMPLICIT_EXTERN_C\n-      if (c_header_level && --c_header_level == 0)\n-\t{\n-\t  if (flags[2] != 0)\n-\t    warning (\"badly nested C headers from preprocessor\");\n-\t  --pending_lang_change;\n-\t}\n-#endif\n-#if 0\n-      if (indent_level != input_file_stack->indent_level)\n-\t{\n-\t  warning_with_file_and_line\n-\t    (input_filename, lex_lineno,\n-\t     \"This file contains more '%c's than '%c's.\",\n-\t     indent_level > input_file_stack->indent_level ? '{' : '}',\n-\t     indent_level > input_file_stack->indent_level ? '}' : '{');\n-\t}\n-#endif\n-      /* We get called for the main buffer, but we mustn't pop it.  */\n-      pop_srcloc ();\n-      debug_end_source_file (input_file_stack->line);\n-    }\n-\n-  in_system_header = (flags[0] != 0);\n-  lex_lineno = CPP_BUFFER (pfile)->lineno;\n-\n-  update_header_times (input_file_stack->name);\n-  /* Hook for C++.  */\n-  extract_interface_info ();\n-}\n-\n-static void\n-cb_rename_file (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-  /* Bleah, need a better interface to this.  */\n-  const char *flags = cpp_syshdr_flags (pfile, ip);\n-  input_filename = ip->nominal_fname;\n-  lex_lineno = ip->lineno;\n-  in_system_header = (flags[0] != 0);\n-\n-  update_header_times (ip->nominal_fname);\n   /* Hook for C++.  */\n   extract_interface_info ();\n }"}, {"sha": "9af0c396cd791a150d4015d9084aaeb82ea9847a", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -212,8 +212,16 @@ stack_include_file (pfile, inc)\n      cpp_reader *pfile;\n      struct include_file *inc;\n {\n+  const char *filename = 0;\n+  unsigned int lineno = 0;\n   cpp_buffer *fp;\n \n+  if (pfile->buffer)\n+    {\n+      filename = pfile->buffer->nominal_fname;\n+      lineno = pfile->buffer->lineno;\n+    }\n+\n   if (pfile->context->prev)\n     cpp_ice (pfile, \"attempt to push file buffer with contexts stacked\");\n \n@@ -237,7 +245,7 @@ stack_include_file (pfile, inc)\n   fp->buf = inc->buffer;\n   fp->rlimit = fp->buf + inc->st.st_size;\n   fp->cur = fp->buf;\n-  fp->lineno = 1;\n+  fp->lineno = 0;\n   fp->line_base = fp->buf;\n \n   /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n@@ -249,9 +257,9 @@ stack_include_file (pfile, inc)\n   pfile->include_depth++;\n   pfile->input_stack_listing_current = 0;\n \n-  if (pfile->cb.enter_file)\n-    (*pfile->cb.enter_file) (pfile);\n+  _cpp_do_file_change (pfile, FC_ENTER, filename, lineno);\n \n+  fp->lineno = 1;\n   return 1;\n }\n \n@@ -531,20 +539,6 @@ cpp_make_system_header (pfile, pbuf, flag)\n     pbuf->inc->sysp = flag;\n }\n \n-const char *\n-cpp_syshdr_flags (pfile, pbuf)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     cpp_buffer *pbuf;\n-{\n-#ifndef NO_IMPLICIT_EXTERN_C\n-  if (CPP_OPTION (pfile, cplusplus) && pbuf->inc->sysp == 2)\n-    return \" 3 4\";\n-#endif\n-  if (pbuf->inc->sysp)\n-    return \" 3\";\n-  return \"\";\n-}\n-\n /* Report on all files that might benefit from a multiple include guard.\n    Triggered by -H.  */\n void"}, {"sha": "698f545cae2db1bd2a7fe0de625a891e5fb17db7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -98,6 +98,58 @@ struct include_file\n ((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n \t\t   || ((inc)->cmacro->type == NT_MACRO) == (inc)->defined))\n \n+struct cpp_buffer\n+{\n+  const unsigned char *cur;\t /* current position */\n+  const unsigned char *rlimit; /* end of valid data */\n+  const unsigned char *line_base; /* start of current line */\n+  cppchar_t read_ahead;\t\t/* read ahead character */\n+  cppchar_t extra_char;\t\t/* extra read-ahead for long tokens.  */\n+\n+  struct cpp_reader *pfile;\t/* Owns this buffer.  */\n+  struct cpp_buffer *prev;\n+\n+  const unsigned char *buf;\t /* entire buffer */\n+\n+  /* Filename specified with #line command.  */\n+  const char *nominal_fname;\n+\n+  /* Actual directory of this file, used only for \"\" includes */\n+  struct file_name_list *actual_dir;\n+\n+  /* Pointer into the include table.  Used for include_next and\n+     to record control macros. */\n+  struct include_file *inc;\n+\n+  /* Value of if_stack at start of this file.\n+     Used to prohibit unmatched #endif (etc) in an include file.  */\n+  struct if_stack *if_stack;\n+\n+  /* Token column position adjustment owing to tabs in whitespace.  */\n+  unsigned int col_adjust;\n+\n+  /* Line number at line_base (above). */\n+  unsigned int lineno;\n+\n+  /* Because of the way the lexer works, -Wtrigraphs can sometimes\n+     warn twice for the same trigraph.  This helps prevent that.  */\n+  const unsigned char *last_Wtrigraphs;\n+\n+  /* True if we have already warned about C++ comments in this file.\n+     The warning happens only for C89 extended mode with -pedantic on,\n+     or for -Wtraditional, and only once per file (otherwise it would\n+     be far too noisy).  */\n+  unsigned char warned_cplusplus_comments;\n+\n+  /* True if we don't process trigraphs and escaped newlines.  True\n+     for preprocessed input, command line directives, and _Pragma\n+     buffers.  */\n+  unsigned char from_stage3;\n+\n+  /* Temporary storage for pfile->skipping whilst in a directive.  */\n+  unsigned char was_skipping;\n+};\n+\n /* Character classes.\n    If the definition of `numchar' looks odd to you, please look up the\n    definition of a pp-number in the C standard [section 6.4.8 of C99].\n@@ -208,6 +260,8 @@ extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n extern void _cpp_init_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n+extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum cpp_fc_reason,\n+\t\t\t\t\t const char *, unsigned int));\n \n /* Utility routines and macros.  */\n #define DSC(str) (const U_CHAR *)str, sizeof str - 1"}, {"sha": "de72e989d34e384b0b16cf9f49749b554236c5c8", "filename": "gcc/cpplib.c", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -718,13 +718,17 @@ static void\n do_line (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n+  cpp_buffer *buffer = pfile->buffer;\n+  const char *filename = buffer->nominal_fname;\n+  unsigned int lineno = buffer->lineno;\n+  enum cpp_fc_reason reason = (enum cpp_fc_reason) -1;\n   unsigned long new_lineno;\n-  /* C99 raised the minimum limit on #line numbers.  */\n-  unsigned int cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n-  int enter = 0, leave = 0, rename = 0;\n+  unsigned int cap;\n   cpp_token token;\n \n+  /* C99 raised the minimum limit on #line numbers.  */\n+  cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n+\n   /* #line commands expand macros.  */\n   cpp_get_token (pfile, &token);\n   if (token.type != CPP_NUMBER\n@@ -739,32 +743,24 @@ do_line (pfile)\n     cpp_pedwarn (pfile, \"line number out of range\");\n \n   cpp_get_token (pfile, &token);\n-\n-  if (token.type != CPP_EOF)\n+  if (token.type == CPP_STRING)\n     {\n       char *fname;\n       unsigned int len;\n       int action_number = 0;\n \n-      if (token.type != CPP_STRING)\n-\t{\n-\t  cpp_error (pfile, \"\\\"%s\\\" is not a valid filename\",\n-\t\t     cpp_token_as_text (pfile, &token));\n-\t  return;\n-\t}\n-\n       len = token.val.str.len;\n       fname = alloca (len + 1);\n       memcpy (fname, token.val.str.text, len);\n       fname[len] = '\\0';\n     \n-      if (strcmp (fname, ip->nominal_fname))\n+      if (strcmp (fname, buffer->nominal_fname))\n \t{\n-\t  rename = 1;\n-\t  if (!strcmp (fname, ip->inc->name))\n-\t    ip->nominal_fname = ip->inc->name;\n+\t  reason = FC_RENAME;\n+\t  if (!strcmp (fname, buffer->inc->name))\n+\t    buffer->nominal_fname = buffer->inc->name;\n \t  else\n-\t    ip->nominal_fname = _cpp_fake_include (pfile, fname);\n+\t    buffer->nominal_fname = _cpp_fake_include (pfile, fname);\n \t}\n \n       if (read_line_number (pfile, &action_number) != 0)\n@@ -774,39 +770,66 @@ do_line (pfile)\n \n \t  if (action_number == 1)\n \t    {\n-\t      enter = 1;\n-\t      cpp_make_system_header (pfile, ip, 0);\n+\t      reason = FC_ENTER;\n+\t      cpp_make_system_header (pfile, buffer, 0);\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  else if (action_number == 2)\n \t    {\n-\t      leave = 1;\n-\t      cpp_make_system_header (pfile, ip, 0);\n+\t      reason = FC_LEAVE;\n+\t      cpp_make_system_header (pfile, buffer, 0);\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  if (action_number == 3)\n \t    {\n-\t      cpp_make_system_header (pfile, ip, 1);\n+\t      cpp_make_system_header (pfile, buffer, 1);\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  if (action_number == 4)\n \t    {\n-\t      cpp_make_system_header (pfile, ip, 2);\n+\t      cpp_make_system_header (pfile, buffer, 2);\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t}\n+\n       check_eol (pfile);\n     }\n+  else if (token.type != CPP_EOF)\n+    {\n+      cpp_error (pfile, \"\\\"%s\\\" is not a valid filename\",\n+\t\t cpp_token_as_text (pfile, &token));\n+      return;\n+    }\n \n   /* Our line number is incremented after the directive is processed.  */\n-  ip->lineno = new_lineno - 1;\n-  pfile->lexer_pos.output_line = ip->lineno;\n-  if (enter && pfile->cb.enter_file)\n-    (*pfile->cb.enter_file) (pfile);\n-  if (leave && pfile->cb.leave_file)\n-    (*pfile->cb.leave_file) (pfile);\n-  if (rename && pfile->cb.rename_file)\n-    (*pfile->cb.rename_file) (pfile);\n+  buffer->lineno = new_lineno - 1;\n+  if (reason != (enum cpp_fc_reason) -1)\n+    _cpp_do_file_change (pfile, reason, filename, lineno);\n+}\n+\n+/* Arrange the file_change callback.  The assumption is that the\n+   current buffer's lineno is one less than the next line.  */\n+void\n+_cpp_do_file_change (pfile, reason, from_file, from_lineno)\n+     cpp_reader *pfile;\n+     enum cpp_fc_reason reason;\n+     const char *from_file;\n+     unsigned int from_lineno;\n+{\n+  if (pfile->cb.change_file)\n+    {\n+      cpp_file_change fc;\n+      cpp_buffer *buffer = pfile->buffer;\n+\n+      fc.reason = reason;\n+      fc.from.filename = from_file;\n+      fc.from.lineno = from_lineno;\n+      fc.to.filename = buffer->nominal_fname;\n+      fc.to.lineno = buffer->lineno + 1;\n+      fc.sysp = buffer->inc->sysp;\n+      fc.externc = CPP_OPTION (pfile, cplusplus) && buffer->inc->sysp == 2;\n+      pfile->cb.change_file (pfile, &fc);\n+    }\n }\n \n /*\n@@ -1745,25 +1768,26 @@ cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n+  const char *filename = buffer->nominal_fname;\n+  unsigned int lineno = buffer->lineno;\n   struct if_stack *ifs = buffer->if_stack;\n-  int wfb;\n+  int wfb = (buffer->inc != 0);\n \n   /* Walk back up the conditional stack till we reach its level at\n      entry to this file, issuing error messages.  */\n   for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n     cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n \t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n-  wfb = (buffer->inc != 0);\n   if (wfb)\n     _cpp_pop_file_buffer (pfile, buffer);\n \n   pfile->buffer = buffer->prev;\n   obstack_free (pfile->buffer_ob, buffer);\n   pfile->buffer_stack_depth--;\n \n-  if (pfile->buffer && wfb && pfile->cb.leave_file)\n-    (*pfile->cb.leave_file) (pfile);\n+  if (pfile->buffer && wfb)\n+    _cpp_do_file_change (pfile, FC_LEAVE, filename, lineno);\n   \n   return pfile->buffer;\n }"}, {"sha": "18ad1cd29b2609a804834cea6054712446c21813", "filename": "gcc/cpplib.h", "status": "modified", "additions": 20, "deletions": 56, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -249,58 +249,6 @@ struct cpp_context\n    same reason we use unsigned char - to avoid signedness issues.  */\n typedef int cppchar_t;\n \n-struct cpp_buffer\n-{\n-  const unsigned char *cur;\t /* current position */\n-  const unsigned char *rlimit; /* end of valid data */\n-  const unsigned char *line_base; /* start of current line */\n-  cppchar_t read_ahead;\t\t/* read ahead character */\n-  cppchar_t extra_char;\t\t/* extra read-ahead for long tokens.  */\n-\n-  struct cpp_reader *pfile;\t/* Owns this buffer.  */\n-  struct cpp_buffer *prev;\n-\n-  const unsigned char *buf;\t /* entire buffer */\n-\n-  /* Filename specified with #line command.  */\n-  const char *nominal_fname;\n-\n-  /* Actual directory of this file, used only for \"\" includes */\n-  struct file_name_list *actual_dir;\n-\n-  /* Pointer into the include table.  Used for include_next and\n-     to record control macros. */\n-  struct include_file *inc;\n-\n-  /* Value of if_stack at start of this file.\n-     Used to prohibit unmatched #endif (etc) in an include file.  */\n-  struct if_stack *if_stack;\n-\n-  /* Token column position adjustment owing to tabs in whitespace.  */\n-  unsigned int col_adjust;\n-\n-  /* Line number at line_base (above). */\n-  unsigned int lineno;\n-\n-  /* Because of the way the lexer works, -Wtrigraphs can sometimes\n-     warn twice for the same trigraph.  This helps prevent that.  */\n-  const unsigned char *last_Wtrigraphs;\n-\n-  /* True if we have already warned about C++ comments in this file.\n-     The warning happens only for C89 extended mode with -pedantic on,\n-     or for -Wtraditional, and only once per file (otherwise it would\n-     be far too noisy).  */\n-  unsigned char warned_cplusplus_comments;\n-\n-  /* True if we don't process trigraphs and escaped newlines.  True\n-     for preprocessed input, command line directives, and _Pragma\n-     buffers.  */\n-  unsigned char from_stage3;\n-\n-  /* Temporary storage for pfile->skipping whilst in a directive.  */\n-  unsigned char was_skipping;\n-};\n-\n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n@@ -523,6 +471,25 @@ struct spec_nodes\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n };\n \n+/* This structure is passed to the call back when changing file.  */\n+enum cpp_fc_reason {FC_ENTER = 0, FC_LEAVE, FC_RENAME};\n+\n+struct cpp_file_loc\n+{\n+  const char *filename;\n+  unsigned int lineno;\n+};\n+\n+typedef struct cpp_file_change cpp_file_change;\n+struct cpp_file_change\n+{\n+  struct cpp_file_loc from;\t/* Line of #include or #line.  */\n+  struct cpp_file_loc to;\t/* Line after #include or #line, or start.  */\n+  enum cpp_fc_reason reason;\t/* Reason for change.  */\n+  unsigned char sysp;\t\t/* Nonzero if system header.  */\n+  unsigned char externc;\t/* Nonzero if wrapper needed.  */\n+};\n+\n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n    Applying cpp_get_token repeatedly yields a stream of pre-processor\n    tokens.  Usually, there is only one cpp_reader object active.  */\n@@ -624,9 +591,7 @@ struct cpp_reader\n \n   /* Call backs.  */\n   struct {\n-    void (*enter_file) PARAMS ((cpp_reader *));\n-    void (*leave_file) PARAMS ((cpp_reader *));\n-    void (*rename_file) PARAMS ((cpp_reader *));\n+    void (*change_file) PARAMS ((cpp_reader *, const cpp_file_change *));\n     void (*include) PARAMS ((cpp_reader *, const unsigned char *,\n \t\t\t     const cpp_token *));\n     void (*define) PARAMS ((cpp_reader *, cpp_hashnode *));\n@@ -826,7 +791,6 @@ extern void cpp_stop_lookahead\t\tPARAMS ((cpp_reader *, int));\n extern int cpp_included\tPARAMS ((cpp_reader *, const char *));\n extern int cpp_read_file PARAMS ((cpp_reader *, const char *));\n extern void cpp_make_system_header PARAMS ((cpp_reader *, cpp_buffer *, int));\n-extern const char *cpp_syshdr_flags PARAMS ((cpp_reader *, cpp_buffer *));\n \n /* These are inline functions instead of macros so we can get type\n    checking.  */"}, {"sha": "7a597fbbaafaf356d3d4a733f2cb92099fae93b3", "filename": "gcc/cppmain.c", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -46,7 +46,6 @@ static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n \n static void print_line PARAMS ((const char *));\n static void maybe_print_line PARAMS ((unsigned int));\n-static void move_printer PARAMS ((cpp_reader *, unsigned int, const char *));\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n@@ -55,9 +54,7 @@ static void cb_undef\tPARAMS ((cpp_reader *, cpp_hashnode *));\n static void cb_include\tPARAMS ((cpp_reader *, const unsigned char *,\n \t\t\t\t const cpp_token *));\n static void cb_ident\t  PARAMS ((cpp_reader *, const cpp_string *));\n-static void cb_enter_file PARAMS ((cpp_reader *));\n-static void cb_leave_file PARAMS ((cpp_reader *));\n-static void cb_rename_file PARAMS ((cpp_reader *));\n+static void cb_change_file PARAMS ((cpp_reader *, const cpp_file_change *));\n static void cb_def_pragma PARAMS ((cpp_reader *));\n static void do_pragma_implementation PARAMS ((cpp_reader *));\n \n@@ -108,11 +105,7 @@ main (argc, argv)\n       pfile->cb.ident      = cb_ident;\n       pfile->cb.def_pragma = cb_def_pragma;\n       if (! CPP_OPTION (pfile, no_line_commands))\n-\t{\n-\t  pfile->cb.enter_file = cb_enter_file;\n-\t  pfile->cb.leave_file = cb_leave_file;\n-\t  pfile->cb.rename_file = cb_rename_file;\n-\t}\n+\tpfile->cb.change_file = cb_change_file;\n     }\n \n   if (CPP_OPTION (pfile, dump_includes))\n@@ -285,18 +278,6 @@ print_line (special_flags)\n \t   print.lineno, print.last_fname, special_flags, print.syshdr_flags);\n }\n \n-static void\n-move_printer (pfile, line, special_flags)\n-     cpp_reader *pfile;\n-     unsigned int line;\n-     const char *special_flags;\n-{\n-  print.lineno = line;\n-  print.last_fname = pfile->buffer->nominal_fname;\n-  print.syshdr_flags = cpp_syshdr_flags (pfile, pfile->buffer);\n-  print_line (special_flags);\n-}\n-\n /* Callbacks */\n \n static void\n@@ -354,29 +335,33 @@ cb_include (pfile, dir, header)\n }\n \n static void\n-cb_enter_file (pfile)\n-     cpp_reader *pfile;\n+cb_change_file (pfile, fc)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const cpp_file_change *fc;\n {\n-  /* Bring current file to correct line (except main file).  FIXME: we\n-     may be using the same buffer via a # NUMBER \"file\" 1 directive.  */\n-  if (pfile->done_initializing && pfile->buffer->prev)\n-    maybe_print_line (pfile->buffer->prev->lineno);\n-\n-  move_printer (pfile, 1, pfile->done_initializing ? \" 1\": \"\");\n-}\n+  const char *flags;\n+\n+  /* Bring current file to correct line (except first file).  */\n+  if (fc->reason == FC_ENTER && fc->from.filename)\n+    maybe_print_line (fc->from.lineno);\n+\n+  print.lineno = fc->to.lineno;\n+  print.last_fname = fc->to.filename;\n+  if (fc->externc)\n+    print.syshdr_flags = \" 3 4\";\n+  else if (fc->sysp)\n+    print.syshdr_flags = \" 3\";\n+  else\n+    print.syshdr_flags = \"\";\n \n-static void\n-cb_leave_file (pfile)\n-     cpp_reader *pfile;\n-{\n-  move_printer (pfile, pfile->buffer->lineno + 1, \" 2\");\n-}\n+  switch (fc->reason)\n+    {\n+    case FC_ENTER : flags = fc->from.filename ? \" 1\": \"\"; break;\n+    case FC_LEAVE : flags = \" 2\"; break;\n+    case FC_RENAME: flags = \"\"; break;\n+    }\n \n-static void\n-cb_rename_file (pfile)\n-     cpp_reader *pfile;\n-{\n-  move_printer (pfile, pfile->buffer->lineno + 1, \"\");\n+  print_line (flags);\n }\n \n static void"}, {"sha": "5fb2c6a2916d3cd767261671e168618675ff4a00", "filename": "gcc/fix-header.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -114,6 +114,7 @@ static char *files_to_ignore[] = {\n char *inf_buffer;\n char *inf_limit;\n char *inf_ptr;\n+static const char *cur_file;\n \n /* Certain standard files get extra treatment */\n \n@@ -198,6 +199,7 @@ static int inf_skip_spaces PARAMS ((int));\n static int inf_read_upto PARAMS ((sstring *, int));\n static int inf_scan_ident PARAMS ((sstring *, int));\n static int check_protection PARAMS ((int *, int *));\n+static void cb_change_file PARAMS ((cpp_reader *, const cpp_file_change *));\n \n static void\n add_symbols (flags, names)\n@@ -511,18 +513,16 @@ recognized_extern (name)\n }\n \n /* Called by scan_decls if it saw a function definition for a function\n-   named FNAME, in source file FILE_SEEN on line LINE_SEEN.  KIND is\n-   'I' for an inline function; 'F' if a normal function declaration\n-   preceded by 'extern \"C\"' (or nested inside 'extern \"C\"' braces); or\n-   'f' for other function declarations.  */\n+   named FNAME.  KIND is 'I' for an inline function; 'F' if a normal\n+   function declaration preceded by 'extern \"C\"' (or nested inside\n+   'extern \"C\"' braces); or 'f' for other function declarations.  */\n \n void\n-recognized_function (fname, line, kind, have_arg_list, file_seen)\n+recognized_function (fname, line, kind, have_arg_list)\n      const cpp_token *fname;\n      unsigned int line;\n      int kind; /* One of 'f' 'F' or 'I' */\n      int have_arg_list;\n-     const char *file_seen;\n {\n   struct partial_proto *partial;\n   int i;\n@@ -552,9 +552,9 @@ recognized_function (fname, line, kind, have_arg_list, file_seen)\n \n   /* If the partial prototype was included from some other file,\n      we don't need to patch it up (in this run).  */\n-  i = strlen (file_seen);\n+  i = strlen (cur_file);\n   if (i < inc_filename_length\n-      || strcmp (inc_filename, file_seen + (i - inc_filename_length)) != 0)\n+      || strcmp (inc_filename, cur_file + (i - inc_filename_length)) != 0)\n     return;\n \n   if (fn == NULL)\n@@ -597,6 +597,15 @@ check_macro_names (pfile, names)\n     }\n }\n \n+static void\n+cb_change_file (pfile, fc)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const cpp_file_change *fc;\n+{\n+  /* Just keep track of current file name.  */\n+  cur_file = fc->to.filename;\n+}\n+\n static void\n read_scan_file (in_fname, argc, argv)\n      char *in_fname;\n@@ -612,6 +621,7 @@ read_scan_file (in_fname, argc, argv)\n \n   cpp_init ();\t\t\t/* Initialize cpplib.   */\n   cpp_reader_init (&scan_in, CLK_GNUC89);\n+  scan_in.cb.change_file = cb_change_file;\n \n   /* We are going to be scanning a header file out of its proper context,\n      so ignore warnings and errors.  */"}, {"sha": "cd92cdd8aa5f58fefa1466436d0661bfba9c6a8c", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -181,8 +181,7 @@ scan_decls (pfile, argc, argv)\n \t\t\t\t   cpp_get_line (pfile)->line,\n \t\t\t\t   (saw_inline ? 'I'\n \t\t\t\t    : in_extern_C_brace || current_extern_C\n-\t\t\t\t    ? 'F' : 'f'), have_arg_list,\n-\t\t\t\t   CPP_BUFFER (pfile)->nominal_fname);\n+\t\t\t\t    ? 'F' : 'f'), have_arg_list);\n \t      cpp_get_token (pfile, &token);\n \t      if (token.type == CPP_OPEN_BRACE)\n \t\t{"}, {"sha": "8d19b1ef463221a7a32950743fec027219092514", "filename": "gcc/scan.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e2564ac886bee1a7552df98dcab17a4bf06e26/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=27e2564ac886bee1a7552df98dcab17a4bf06e26", "patch": "@@ -61,8 +61,7 @@ extern int scan_string _PARAMS((FILE *, sstring *, int));\n extern int read_upto _PARAMS((FILE *, sstring *, int));\n extern unsigned long hash _PARAMS((const char *));\n extern void recognized_function _PARAMS((const struct cpp_token *,\n-\t\t\t\t\t unsigned int, int, int,\n-\t\t\t\t\t const char *));\n+\t\t\t\t\t unsigned int, int, int));\n extern void recognized_extern _PARAMS((const struct cpp_token *));\n extern unsigned int hashstr _PARAMS((const char *, unsigned int));\n "}]}