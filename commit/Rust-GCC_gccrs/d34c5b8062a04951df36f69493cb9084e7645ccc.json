{"sha": "d34c5b8062a04951df36f69493cb9084e7645ccc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM0YzViODA2MmEwNDk1MWRmMzZmNjk0OTNjYjkwODRlNzY0NWNjYw==", "commit": {"author": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2001-05-02T18:21:06Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2001-05-02T18:21:06Z"}, "message": "[multiple changes]\n\n2001-05-02  David Edelsohn  <edelsohn@gnu.org>\n\n\t* config/rs6000/rs6000.c (rs6000_emit_move): Merge\n\tspecial_constant conditional blocks together.\n\n2001-05-02  Dale Johannesen  <dalej@apple.com>\n\n\t* config/rs6000/rs6000.h (RS6000_ARG_SIZE): Remove unused NAMED\n\tparameter.\n\t(STRICT_ARGUMENT_NAMING): Define.\n\t* config/rs6000/rs6000.c (function_arg_advance, function_arg,\n\tfunction_arg_partial_nregs, setup_incoming_varargs): Remove\n\targs logic which depends on \"named\" now that STRICT_ARGUMENT_NAMING\n\tis defined.\n\nFrom-SVN: r41771", "tree": {"sha": "2d05818a0d92ccb7b9b49c5b6d229fe38bdca9f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d05818a0d92ccb7b9b49c5b6d229fe38bdca9f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d34c5b8062a04951df36f69493cb9084e7645ccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34c5b8062a04951df36f69493cb9084e7645ccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d34c5b8062a04951df36f69493cb9084e7645ccc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34c5b8062a04951df36f69493cb9084e7645ccc/comments", "author": null, "committer": null, "parents": [{"sha": "80f5bb34eb5fc1e916ae2983e86876f0ecb6651c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f5bb34eb5fc1e916ae2983e86876f0ecb6651c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f5bb34eb5fc1e916ae2983e86876f0ecb6651c"}], "stats": {"total": 103, "additions": 50, "deletions": 53}, "files": [{"sha": "eded70f6b529fad2737b3f694addf5f9569370b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34c5b8062a04951df36f69493cb9084e7645ccc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34c5b8062a04951df36f69493cb9084e7645ccc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d34c5b8062a04951df36f69493cb9084e7645ccc", "patch": "@@ -1,3 +1,18 @@\n+2001-05-02  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Merge\n+\tspecial_constant conditional blocks together.\n+\n+2001-05-02  Dale Johannesen  <dalej@apple.com>\n+\n+\t* config/rs6000/rs6000.h (RS6000_ARG_SIZE): Remove unused NAMED\n+\tparameter.\n+\t(STRICT_ARGUMENT_NAMING): Define.\n+\t* config/rs6000/rs6000.c (function_arg_advance, function_arg,\n+\tfunction_arg_partial_nregs, setup_incoming_varargs): Remove\n+\targs logic which depends on \"named\" now that STRICT_ARGUMENT_NAMING\n+\tis defined.\n+\n Wed May  2 13:09:36 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* config/i386/i386.h (FUNCTION_BOUNDARY): Result is unsigned."}, {"sha": "d89e6875cd47b82e6e85efb0e608de44d4aad76c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 50, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34c5b8062a04951df36f69493cb9084e7645ccc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34c5b8062a04951df36f69493cb9084e7645ccc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d34c5b8062a04951df36f69493cb9084e7645ccc", "patch": "@@ -1721,8 +1721,6 @@ rs6000_emit_move (dest, source, mode)\n \t       && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n \t       && ! TOC_RELATIVE_EXPR_P (operands[1]))\n \t{\n-\t  int special_constant_p = 0;\n-\n \t  /* Emit a USE operation so that the constant isn't deleted if\n \t     expensive optimizations are turned on because nobody\n \t     references it.  This should only be done for operands that\n@@ -1773,18 +1771,10 @@ rs6000_emit_move (dest, source, mode)\n \t  operands[1] = force_const_mem (mode, operands[1]);\n \n \t  if (TARGET_TOC \n-\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0)))\n-\t    {\n-\t      rtx constant;\n-\t      enum machine_mode cmode;\n-\n-\t      constant = get_pool_constant (XEXP (operands[1], 0));\n-\t      cmode = get_pool_mode (XEXP (operands[1], 0));\n-\t      special_constant_p = \n-\t\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P (constant, cmode);\n-\t    }\n-\n-\t  if (special_constant_p)\n+\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n+\t      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (\n+\t\t\tget_pool_constant (XEXP (operands[1], 0)),\n+\t\t\tget_pool_mode (XEXP (operands[1], 0))))\n \t    {\n \t      operands[1] = gen_rtx_MEM (mode,\n \t\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n@@ -1952,7 +1942,7 @@ function_arg_advance (cum, mode, type, named)\n \t    {\n \t      if (mode == DFmode)\n \t        cum->words += cum->words & 1;\n-\t      cum->words += RS6000_ARG_SIZE (mode, type, 1);\n+\t      cum->words += RS6000_ARG_SIZE (mode, type);\n \t    }\n \t}\n       else\n@@ -1965,7 +1955,7 @@ function_arg_advance (cum, mode, type, named)\n \t      || mode == TFmode)\n \t    n_words = 1;\n \t  else \n-\t    n_words = RS6000_ARG_SIZE (mode, type, 1);\n+\t    n_words = RS6000_ARG_SIZE (mode, type);\n \n \t  /* Long long is put in odd registers.  */\n \t  if (n_words == 2 && (gregno & 1) == 0)\n@@ -2000,14 +1990,10 @@ function_arg_advance (cum, mode, type, named)\n     {\n       int align = (TARGET_32BIT && (cum->words & 1) != 0\n \t\t   && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n-      cum->words += align;\n+      cum->words += align + RS6000_ARG_SIZE (mode, type);\n \n-      if (named)\n-\t{\n-\t  cum->words += RS6000_ARG_SIZE (mode, type, named);\n-\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_HARD_FLOAT)\n-\t    cum->fregno++;\n-\t}\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_HARD_FLOAT)\n+\tcum->fregno++;\n \n       if (TARGET_DEBUG_ARG)\n \t{\n@@ -2048,7 +2034,7 @@ function_arg (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n      enum machine_mode mode;\n      tree type;\n-     int named;\n+     int named ATTRIBUTE_UNUSED;\n {\n   enum rs6000_abi abi = DEFAULT_ABI;\n \n@@ -2092,7 +2078,7 @@ function_arg (cum, mode, type, named)\n \t      || mode == TFmode)\n \t    n_words = 1;\n \t  else \n-\t    n_words = RS6000_ARG_SIZE (mode, type, 1);\n+\t    n_words = RS6000_ARG_SIZE (mode, type);\n \n \t  /* Long long is put in odd registers.  */\n \t  if (n_words == 2 && (gregno & 1) == 0)\n@@ -2111,9 +2097,6 @@ function_arg (cum, mode, type, named)\n \t           && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n       int align_words = cum->words + align;\n \n-      if (! named)\n-\treturn NULL_RTX;\n-\n       if (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n         return NULL_RTX;\n \n@@ -2135,7 +2118,7 @@ function_arg (cum, mode, type, named)\n \t\t\t\t((align_words >= GP_ARG_NUM_REG)\n \t\t\t\t ? NULL_RTX\n \t\t\t\t : (align_words\n-\t\t\t\t    + RS6000_ARG_SIZE (mode, type, named)\n+\t\t\t\t    + RS6000_ARG_SIZE (mode, type)\n \t\t\t\t    > GP_ARG_NUM_REG\n \t\t\t\t    /* If this is partially on the stack, then\n \t\t\t\t       we only include the portion actually\n@@ -2165,11 +2148,8 @@ function_arg_partial_nregs (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n      enum machine_mode mode;\n      tree type;\n-     int named;\n+     int named ATTRIBUTE_UNUSED;\n {\n-  if (! named)\n-    return 0;\n-\n   if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n     return 0;\n \n@@ -2180,7 +2160,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n     }\n \n   if (cum->words < GP_ARG_NUM_REG\n-      && GP_ARG_NUM_REG < (cum->words + RS6000_ARG_SIZE (mode, type, named)))\n+      && GP_ARG_NUM_REG < (cum->words + RS6000_ARG_SIZE (mode, type)))\n     {\n       int ret = GP_ARG_NUM_REG - cum->words;\n       if (ret && TARGET_DEBUG_ARG)\n@@ -2247,23 +2227,22 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   rtx save_area = NULL_RTX, mem;\n   int first_reg_offset, set;\n+  tree fntype;\n+  int stdarg_p;\n \n-  if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-    {\n-      tree fntype;\n-      int stdarg_p;\n-\n-      fntype = TREE_TYPE (current_function_decl);\n-      stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n-\t\t  && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n-\t\t      != void_type_node));\n+  fntype = TREE_TYPE (current_function_decl);\n+  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n+\t      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t  != void_type_node));\n \n-      /* For varargs, we do not want to skip the dummy va_dcl argument.\n-         For stdargs, we do want to skip the last named argument.  */\n-      next_cum = *cum;\n-      if (stdarg_p)\n-\tfunction_arg_advance (&next_cum, mode, type, 1);\n+  /* For varargs, we do not want to skip the dummy va_dcl argument.\n+     For stdargs, we do want to skip the last named argument.  */\n+  next_cum = *cum;\n+  if (stdarg_p)\n+    function_arg_advance (&next_cum, mode, type, 1);\n \n+  if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+    {\n       /* Indicate to allocate space on the stack for varargs save area.  */\n       /* ??? Does this really have to be located at a magic spot on the\n \t stack, or can we allocate this with assign_stack_local instead.  */\n@@ -2276,12 +2255,12 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n     }\n   else\n     {\n+      first_reg_offset = next_cum.words;\n       save_area = virtual_incoming_args_rtx;\n       cfun->machine->sysv_varargs_p = 0;\n \n-      first_reg_offset = cum->words;\n       if (MUST_PASS_IN_STACK (mode, type))\n-\tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (type), type, 1);\n+\tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (type), type);\n     }\n \n   set = get_varargs_alias_set ();"}, {"sha": "cf3f9474813a3f15294f4606c8bc62f23ffeec54", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34c5b8062a04951df36f69493cb9084e7645ccc/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34c5b8062a04951df36f69493cb9084e7645ccc/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d34c5b8062a04951df36f69493cb9084e7645ccc", "patch": "@@ -1432,9 +1432,8 @@ typedef struct rs6000_args\n /* Define intermediate macro to compute the size (in registers) of an argument\n    for the RS/6000.  */\n \n-#define RS6000_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n-(! (NAMED) ? 0\t\t\t\t\t\t\t\t\\\n- : (MODE) != BLKmode\t\t\t\t\t\t\t\\\n+#define RS6000_ARG_SIZE(MODE, TYPE)\t\t\t\t\t\\\n+((MODE) != BLKmode\t\t\t\t\t\t\t\\\n  ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD\t\\\n  : ((unsigned HOST_WIDE_INT) int_size_in_bytes (TYPE) \t\t\t\\\n     + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n@@ -1550,6 +1549,10 @@ typedef struct rs6000_args\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   rs6000_va_arg (valist, type)\n \n+/* Define this macro to be a nonzero value if the location where a function\n+   argument is passed depends on whether or not it is a named argument.  */\n+#define STRICT_ARGUMENT_NAMING 1\n+\n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to allocate."}]}