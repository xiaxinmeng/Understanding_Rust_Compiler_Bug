{"sha": "7b56a91b90d4fba29abe58603373a67cc8ad5358", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I1NmE5MWI5MGQ0ZmJhMjlhYmU1ODYwMzM3M2E2N2NjOGFkNTM1OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T13:46:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T13:46:14Z"}, "message": "[multiple changes]\n\n2013-10-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.adb: Minor reformatting.\n\n2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_dim.adb (Process_Minus, Process_Divide): Label dimension\n\texpression with standard operator and type, for pretty-printing\n\tuse.\n\n2013-10-17  Bob Duff  <duff@adacore.com>\n\n\t* gnat_ugn.texi: Document --pp-new and --pp-old switches.\n\n2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Flag 159 is now known as From_Limited_With. Replace\n\tall references to attribute From_With_Type with From_Limited_With.\n\t(From_With_Type): Renamed to From_Limited_With.\n\t(Set_From_With_Type): Renamd to Set_From_Limited_With.\n\t* einfo.ads: Remove attribute From_With_Type and occurrences in\n\tnodes.\tAdd attribute From_Limited_With along with occurrences\n\tin nodes.\n\t(From_With_Type): Renamed to From_Limited_With along with pragma Inline.\n\t(Set_From_With_Type): Renamed to\n\tSet_From_Limited_With along with pragma Inline.\n\t* sem_ch7.adb, sem_ch8.adb, sem_ch12.adb, sem_ch13.adb, sem_disp.adb,\n\tsem_res.adb, sem_type.adb, sem_util.adb, sem_warn.adb,\n\texp_attr.adb, exp_disp.adb, freeze.adb, itypes.adb, layout.adb,\n\tlib-writ.adb, rtsfind.adb, sem_attr.adb, sem_aux.adb, sem_ch3.adb,\n\tsem_ch4.adb: Replace all references to attribute From_With_Type\n\twith From_Limited_With.\n\t* sem_ch6.adb: Replace all references to attribute From_With_Type\n\twith From_Limited_With.\n\t(Designates_From_With_Type): Renamed to Designates_From_Limited_With.\n\t(Process_Formals): Update the call to Designates_From_With_Type.\n\t* sem_ch10.adb: Replace all references to attribute From_With_Type\n\twith From_Limited_With.\n\t(Build_Limited_Views): Reimplemented.\n\t* gcc-interface/decl.c Replace all references to attribute\n\tFrom_With_Type with From_Limited_With.\n\t(finalize_from_with_types): Renamed to finalize_from_limited_with.\n\t* gcc-interface/gigi.h (finalize_from_with_types): Renamed to\n\tfinalize_from_limited_with.\n\t* gcc-interface/trans.c: Replace all references to attribute\n\tFrom_With_Type with From_Limited_With.\n\t(Compilation_Unit_to_gnu): Update the call to finalize_from_with_types.\n\n2013-10-17  Pascal Obry  <obry@adacore.com>\n\n\t* projects.texi: Update VCS_Kind documentation.\n\n2013-10-17  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-convec.adb, a-coinve.adb, a-cobove.adb (Insert, Insert_Space):\n\tInspect value range before converting type.\n\n2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Flag the use of pragma Refined_Pre as\n\tillegal.\n\nFrom-SVN: r203755", "tree": {"sha": "1b3e345826e9ac68cec23a5403d16d84add13cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b3e345826e9ac68cec23a5403d16d84add13cc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b56a91b90d4fba29abe58603373a67cc8ad5358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b56a91b90d4fba29abe58603373a67cc8ad5358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b56a91b90d4fba29abe58603373a67cc8ad5358", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b56a91b90d4fba29abe58603373a67cc8ad5358/comments", "author": null, "committer": null, "parents": [{"sha": "8a7c04004682aa23bf2dbcfaabac0de5b27c8a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7c04004682aa23bf2dbcfaabac0de5b27c8a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a7c04004682aa23bf2dbcfaabac0de5b27c8a52"}], "stats": {"total": 1060, "additions": 588, "deletions": 472}, "files": [{"sha": "7777a8a833db890815189a22b605adeaf41edf78", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1,3 +1,65 @@\n+2013-10-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch7.adb: Minor reformatting.\n+\n+2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_dim.adb (Process_Minus, Process_Divide): Label dimension\n+\texpression with standard operator and type, for pretty-printing\n+\tuse.\n+\n+2013-10-17  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_ugn.texi: Document --pp-new and --pp-old switches.\n+\n+2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb: Flag 159 is now known as From_Limited_With. Replace\n+\tall references to attribute From_With_Type with From_Limited_With.\n+\t(From_With_Type): Renamed to From_Limited_With.\n+\t(Set_From_With_Type): Renamd to Set_From_Limited_With.\n+\t* einfo.ads: Remove attribute From_With_Type and occurrences in\n+\tnodes.\tAdd attribute From_Limited_With along with occurrences\n+\tin nodes.\n+\t(From_With_Type): Renamed to From_Limited_With along with pragma Inline.\n+\t(Set_From_With_Type): Renamed to\n+\tSet_From_Limited_With along with pragma Inline.\n+\t* sem_ch7.adb, sem_ch8.adb, sem_ch12.adb, sem_ch13.adb, sem_disp.adb,\n+\tsem_res.adb, sem_type.adb, sem_util.adb, sem_warn.adb,\n+\texp_attr.adb, exp_disp.adb, freeze.adb, itypes.adb, layout.adb,\n+\tlib-writ.adb, rtsfind.adb, sem_attr.adb, sem_aux.adb, sem_ch3.adb,\n+\tsem_ch4.adb: Replace all references to attribute From_With_Type\n+\twith From_Limited_With.\n+\t* sem_ch6.adb: Replace all references to attribute From_With_Type\n+\twith From_Limited_With.\n+\t(Designates_From_With_Type): Renamed to Designates_From_Limited_With.\n+\t(Process_Formals): Update the call to Designates_From_With_Type.\n+\t* sem_ch10.adb: Replace all references to attribute From_With_Type\n+\twith From_Limited_With.\n+\t(Build_Limited_Views): Reimplemented.\n+\t* gcc-interface/decl.c Replace all references to attribute\n+\tFrom_With_Type with From_Limited_With.\n+\t(finalize_from_with_types): Renamed to finalize_from_limited_with.\n+\t* gcc-interface/gigi.h (finalize_from_with_types): Renamed to\n+\tfinalize_from_limited_with.\n+\t* gcc-interface/trans.c: Replace all references to attribute\n+\tFrom_With_Type with From_Limited_With.\n+\t(Compilation_Unit_to_gnu): Update the call to finalize_from_with_types.\n+\n+2013-10-17  Pascal Obry  <obry@adacore.com>\n+\n+\t* projects.texi: Update VCS_Kind documentation.\n+\n+2013-10-17  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-convec.adb, a-coinve.adb, a-cobove.adb (Insert, Insert_Space):\n+\tInspect value range before converting type.\n+\n+2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Flag the use of pragma Refined_Pre as\n+\tillegal.\n+\n 2013-10-17  Vincent Celier  <celier@adacore.com>\n \n \t* gnat_ugn.texi: Remove VMS conversion of -gnatet and -gnateT,"}, {"sha": "bcd6118e607abc9b50b26e8e07f8097c2d0acb14", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1227,7 +1227,22 @@ package body Ada.Containers.Bounded_Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n          end if;\n \n       elsif Index_Type'First <= 0 then\n@@ -1685,7 +1700,22 @@ package body Ada.Containers.Bounded_Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n          end if;\n \n       elsif Index_Type'First <= 0 then"}, {"sha": "677fd97e09dd647d044af6de564f68b69a139e96", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1734,7 +1734,22 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n          end if;\n \n       elsif Index_Type'First <= 0 then\n@@ -2504,7 +2519,22 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n          end if;\n \n       elsif Index_Type'First <= 0 then"}, {"sha": "0f4bc19bcba6ed645da5cafcd28f338bb0daf5e8", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1386,7 +1386,22 @@ package body Ada.Containers.Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n          end if;\n \n       elsif Index_Type'First <= 0 then\n@@ -2033,7 +2048,22 @@ package body Ada.Containers.Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n          end if;\n \n       elsif Index_Type'First <= 0 then"}, {"sha": "5a8757bac4074327ac674235b5dc4d3129a57dd7", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -437,7 +437,7 @@ package body Einfo is\n    --    Referenced                      Flag156\n    --    Has_Pragma_Inline               Flag157\n    --    Finalize_Storage_Only           Flag158\n-   --    From_With_Type                  Flag159\n+   --    From_Limited_With               Flag159\n    --    Is_Package_Body_Entity          Flag160\n \n    --    Has_Qualified_Name              Flag161\n@@ -1242,10 +1242,10 @@ package body Einfo is\n       return Node7 (Id);\n    end Freeze_Node;\n \n-   function From_With_Type (Id : E) return B is\n+   function From_Limited_With (Id : E) return B is\n    begin\n       return Flag159 (Id);\n-   end From_With_Type;\n+   end From_Limited_With;\n \n    function Full_View (Id : E) return E is\n    begin\n@@ -3863,13 +3863,11 @@ package body Einfo is\n       Set_Node7 (Id, V);\n    end Set_Freeze_Node;\n \n-   procedure Set_From_With_Type (Id : E; V : B := True) is\n+   procedure Set_From_Limited_With (Id : E; V : B := True) is\n    begin\n-      pragma Assert\n-        (Is_Type (Id)\n-           or else Ekind (Id) = E_Package);\n+      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Package);\n       Set_Flag159 (Id, V);\n-   end Set_From_With_Type;\n+   end Set_From_Limited_With;\n \n    procedure Set_Full_View (Id : E; V : E) is\n    begin\n@@ -7899,7 +7897,7 @@ package body Einfo is\n          --  view then we return the Underlying_Type of its non-limited\n          --  view.\n \n-         elsif From_With_Type (Id)\n+         elsif From_Limited_With (Id)\n            and then Present (Non_Limited_View (Id))\n          then\n             return Underlying_Type (Non_Limited_View (Id));\n@@ -8002,7 +8000,7 @@ package body Einfo is\n       W (\"Entry_Accepted\",                  Flag152 (Id));\n       W (\"Can_Use_Internal_Rep\",            Flag229 (Id));\n       W (\"Finalize_Storage_Only\",           Flag158 (Id));\n-      W (\"From_With_Type\",                  Flag159 (Id));\n+      W (\"From_Limited_With\",               Flag159 (Id));\n       W (\"Has_Aliased_Components\",          Flag135 (Id));\n       W (\"Has_Alignment_Clause\",            Flag46  (Id));\n       W (\"Has_All_Calls_Remote\",            Flag79  (Id));\n@@ -8698,14 +8696,13 @@ package body Einfo is\n    procedure Write_Field16_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-\n-         when E_Abstract_State                             =>\n-            Write_Str (\"Body_References\");\n-\n          when E_Record_Type                                |\n               E_Record_Type_With_Private                   =>\n             Write_Str (\"Access_Disp_Table\");\n \n+         when E_Abstract_State                             =>\n+            Write_Str (\"Body_References\");\n+\n          when E_Record_Subtype                             |\n               E_Class_Wide_Subtype                         =>\n             Write_Str (\"Cloned_Subtype\");\n@@ -8794,7 +8791,7 @@ package body Einfo is\n             Write_Str (\"Non_Limited_View\");\n \n          when E_Incomplete_Subtype                         =>\n-            if From_With_Type (Id) then\n+            if From_Limited_With (Id) then\n                Write_Str (\"Non_Limited_View\");\n             end if;\n "}, {"sha": "0eaf13b43f183b12ca1160edeb1045f8e4b2a802", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1315,19 +1315,11 @@ package Einfo is\n --       associated with the entity, then this field is Empty. See package\n --       Freeze for further details.\n \n---    From_With_Type (Flag159)\n---       Defined in package and type entities. Indicates that the entity\n---       appears in a With_Type clause in the context of some other unit,\n---       either as the prefix (which must be a package), or as a type name.\n---       The package can only be used to retrieve such a type, and the type\n---       can be used only in component declarations and access definitions.\n---       The With_Type clause is used to construct mutually recursive\n---       types, i.e. record types (Java classes) that hold pointers to each\n---       other. If such a type is an access type, it has no explicit freeze\n---       node, so that the back-end does not attempt to elaborate it.\n---       Currently this flag is also used to implement Ada 2005 (AI-50217).\n---       It will be renamed to From_Limited_With after removal of the current\n---       GNAT with_type clause???\n+--    From_Limited_With (Flag159)\n+--       Defined in package and type entities. Set to True when the related\n+--       entity is generated by the expansion of a limited with clause. Such\n+--       an entity is said to be a \"shadow\" - it acts as the incomplete view\n+--       of a type by inheriting relevant attributes from the said type.\n \n --    Full_View (Node11)\n --       Defined in all type and subtype entities and in deferred constants.\n@@ -5049,7 +5041,7 @@ package Einfo is\n    --    Depends_On_Private                  (Flag14)\n    --    Discard_Names                       (Flag88)\n    --    Finalize_Storage_Only               (Flag158)  (base type only)\n-   --    From_With_Type                      (Flag159)\n+   --    From_Limited_With                   (Flag159)\n    --    Has_Aliased_Components              (Flag135)  (base type only)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)   (base type only)\n@@ -5662,7 +5654,7 @@ package Einfo is\n    --    Discard_Names                       (Flag88)\n    --    Elaboration_Entity_Required         (Flag174)\n    --    Elaborate_Body_Desirable            (Flag210)  (non-generic case only)\n-   --    From_With_Type                      (Flag159)\n+   --    From_Limited_With                   (Flag159)\n    --    Has_All_Calls_Remote                (Flag79)\n    --    Has_Anonymous_Master                (Flag253)\n    --    Has_Completion                      (Flag26)\n@@ -6327,7 +6319,7 @@ package Einfo is\n    function First_Rep_Item                      (Id : E) return N;\n    function Float_Rep                           (Id : E) return F;\n    function Freeze_Node                         (Id : E) return N;\n-   function From_With_Type                      (Id : E) return B;\n+   function From_Limited_With                   (Id : E) return B;\n    function Full_View                           (Id : E) return E;\n    function Generic_Homonym                     (Id : E) return E;\n    function Generic_Renamings                   (Id : E) return L;\n@@ -6946,7 +6938,7 @@ package Einfo is\n    procedure Set_First_Rep_Item                  (Id : E; V : N);\n    procedure Set_Float_Rep                       (Id : E; V : F);\n    procedure Set_Freeze_Node                     (Id : E; V : N);\n-   procedure Set_From_With_Type                  (Id : E; V : B := True);\n+   procedure Set_From_Limited_With               (Id : E; V : B := True);\n    procedure Set_Full_View                       (Id : E; V : E);\n    procedure Set_Generic_Homonym                 (Id : E; V : E);\n    procedure Set_Generic_Renamings               (Id : E; V : L);\n@@ -7666,7 +7658,7 @@ package Einfo is\n    pragma Inline (First_Private_Entity);\n    pragma Inline (First_Rep_Item);\n    pragma Inline (Freeze_Node);\n-   pragma Inline (From_With_Type);\n+   pragma Inline (From_Limited_With);\n    pragma Inline (Full_View);\n    pragma Inline (Generic_Homonym);\n    pragma Inline (Generic_Renamings);\n@@ -8129,7 +8121,7 @@ package Einfo is\n    pragma Inline (Set_First_Private_Entity);\n    pragma Inline (Set_First_Rep_Item);\n    pragma Inline (Set_Freeze_Node);\n-   pragma Inline (Set_From_With_Type);\n+   pragma Inline (Set_From_Limited_With);\n    pragma Inline (Set_Full_View);\n    pragma Inline (Set_Generic_Homonym);\n    pragma Inline (Set_Generic_Renamings);"}, {"sha": "bd193598b0de8af58b7d1f1e2afc6806b12cb7fe", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1296,14 +1296,14 @@ package body Exp_Attr is\n             --  Handle designated types that come from the limited view\n \n             if Ekind (Btyp_DDT) = E_Incomplete_Type\n-              and then From_With_Type (Btyp_DDT)\n+              and then From_Limited_With (Btyp_DDT)\n               and then Present (Non_Limited_View (Btyp_DDT))\n             then\n                Btyp_DDT := Non_Limited_View (Btyp_DDT);\n \n             elsif Is_Class_Wide_Type (Btyp_DDT)\n                and then Ekind (Etype (Btyp_DDT)) = E_Incomplete_Type\n-               and then From_With_Type (Etype (Btyp_DDT))\n+               and then From_Limited_With (Etype (Btyp_DDT))\n                and then Present (Non_Limited_View (Etype (Btyp_DDT)))\n                and then Present (Class_Wide_Type\n                                   (Non_Limited_View (Etype (Btyp_DDT))))"}, {"sha": "9d76d2c9f01591720098359782df085d1bfce57b", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -310,11 +310,11 @@ package body Exp_Ch7 is\n       Defer_Abort : Boolean;\n       Fin_Id      : out Entity_Id);\n    --  N may denote an accept statement, block, entry body, package body,\n-   --  package spec, protected body, subprogram body, and a task body. Create\n+   --  package spec, protected body, subprogram body, or a task body. Create\n    --  a procedure which contains finalization calls for all controlled objects\n    --  declared in the declarative or statement region of N. The calls are\n    --  built in reverse order relative to the original declarations. In the\n-   --  case of a tack body, the routine delays the creation of the finalizer\n+   --  case of a task body, the routine delays the creation of the finalizer\n    --  until all statements have been moved to the task body procedure.\n    --  Clean_Stmts may contain additional context-dependent code used to abort\n    --  asynchronous calls or complete tasks (see Build_Cleanup_Statements)."}, {"sha": "8ba4704328af85643b769d4c0fde91ae9a2ab2d7", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1568,7 +1568,7 @@ package body Exp_Disp is\n             else\n                Actual_Dup := Relocate_Node (Actual);\n \n-               if From_With_Type (Actual_Typ) then\n+               if From_Limited_With (Actual_Typ) then\n \n                   --  If the type of the actual parameter comes from a limited\n                   --  with-clause and the non-limited view is already available\n@@ -1983,7 +1983,7 @@ package body Exp_Disp is\n \n    begin\n       if Ekind (Typ) = E_Incomplete_Type then\n-         if From_With_Type (Typ) then\n+         if From_Limited_With (Typ) then\n             Typ := Non_Limited_View (Typ);\n          else\n             Typ := Full_View (Typ);"}, {"sha": "f9691d726d3aa6f000856362f4d97898c170d9c4", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -3549,7 +3549,7 @@ package body Freeze is\n \n                      if Is_Incomplete_Type (F_Type)\n                        and then Present (Full_View (F_Type))\n-                       and then not From_With_Type (F_Type)\n+                       and then not From_Limited_With (F_Type)\n                      then\n                         F_Type := Full_View (F_Type);\n                         Set_Etype (Formal, F_Type);\n@@ -3699,7 +3699,7 @@ package body Freeze is\n                         Error_Msg_Qual_Level := 0;\n                      end if;\n \n-                     if not From_With_Type (F_Type) then\n+                     if not From_Limited_With (F_Type) then\n                         if Is_Access_Type (F_Type) then\n                            F_Type := Designated_Type (F_Type);\n                         end if;\n@@ -3736,7 +3736,7 @@ package body Freeze is\n \n                      if Ekind (R_Type) = E_Incomplete_Type\n                        and then Present (Full_View (R_Type))\n-                       and then not From_With_Type (R_Type)\n+                       and then not From_Limited_With (R_Type)\n                      then\n                         R_Type := Full_View (R_Type);\n                         Set_Etype (E, R_Type);"}, {"sha": "8fa7349266744132a8ce184ee8db792c318f9165", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -98,7 +98,7 @@ struct incomplete\n static int defer_incomplete_level = 0;\n static struct incomplete *defer_incomplete_list;\n \n-/* This variable is used to delay expanding From_With_Type types until the\n+/* This variable is used to delay expanding From_Limited_With types until the\n    end of the spec.  */\n static struct incomplete *defer_limited_with;\n \n@@ -3738,7 +3738,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Whether it comes from a limited with.  */\n \tbool is_from_limited_with\n \t  = (IN (Ekind (gnat_desig_equiv), Incomplete_Kind)\n-\t     && From_With_Type (gnat_desig_equiv));\n+\t     && From_Limited_With (gnat_desig_equiv));\n \t/* The \"full view\" of the designated type.  If this is an incomplete\n \t   entity from a limited with, treat its non-limited view as the full\n \t   view.  Otherwise, if this is an incomplete or private type, use the\n@@ -4230,7 +4230,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       we are only annotating types, break circularities here.  */\n \t    if (type_annotate_only\n \t\t&& IN (Ekind (gnat_return_type), Incomplete_Kind)\n-\t        && From_With_Type (gnat_return_type)\n+\t        && From_Limited_With (gnat_return_type)\n \t\t&& In_Extended_Main_Code_Unit\n \t\t   (Non_Limited_View (gnat_return_type))\n \t\t&& !present_gnu_tree (Non_Limited_View (gnat_return_type)))\n@@ -4343,7 +4343,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       we are only annotating types, break circularities here.  */\n \t    if (type_annotate_only\n \t\t&& IN (Ekind (gnat_param_type), Incomplete_Kind)\n-\t        && From_With_Type (Etype (gnat_param_type))\n+\t        && From_Limited_With (Etype (gnat_param_type))\n \t\t&& In_Extended_Main_Code_Unit\n \t\t   (Non_Limited_View (gnat_param_type))\n \t\t&& !present_gnu_tree (Non_Limited_View (gnat_param_type)))\n@@ -4738,7 +4738,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   full view, whichever is present.  This is used in all the tests\n \t   below.  */\n \tEntity_Id full_view\n-\t  = (IN (kind, Incomplete_Kind) && From_With_Type (gnat_entity))\n+\t  = (IN (kind, Incomplete_Kind) && From_Limited_With (gnat_entity))\n \t    ? Non_Limited_View (gnat_entity)\n \t    : Present (Full_View (gnat_entity))\n \t      ? Full_View (gnat_entity)\n@@ -5490,10 +5490,10 @@ is_cplusplus_method (Entity_Id gnat_entity)\n   return false;\n }\n \n-/* Finalize the processing of From_With_Type incomplete types.  */\n+/* Finalize the processing of From_Limited_With incomplete types.  */\n \n void\n-finalize_from_with_types (void)\n+finalize_from_limited_with (void)\n {\n   struct incomplete *p, *next;\n "}, {"sha": "832803ccfc340b71b0e54fc4f0e91d654e884bff", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -93,8 +93,8 @@ do {\t\t\t\t\t\\\n     mark_visited (EXP);\t\t\t\\\n } while (0)\n \n-/* Finalize the processing of From_With_Type incomplete types.  */\n-extern void finalize_from_with_types (void);\n+/* Finalize the processing of From_Limited_With incomplete types.  */\n+extern void finalize_from_limited_with (void);\n \n /* Return the equivalent type to be used for GNAT_ENTITY, if it's a\n    kind of type (such E_Task_Type) that has a different type which Gigi"}, {"sha": "388345fa7dd4a277e543daf55529832f727c9a6b", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -5009,7 +5009,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   /* Process any pragmas and actions following the unit.  */\n   add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_node)));\n   add_stmt_list (Actions (Aux_Decls_Node (gnat_node)));\n-  finalize_from_with_types ();\n+  finalize_from_limited_with ();\n \n   /* Save away what we've made so far and record this potential elaboration\n      procedure.  */\n@@ -6629,15 +6629,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   Present (gnat_temp);\n \t   gnat_temp = Next_Formal_With_Extras (gnat_temp))\n \tif (Is_Itype (Etype (gnat_temp))\n-\t    && !From_With_Type (Etype (gnat_temp)))\n+\t    && !From_Limited_With (Etype (gnat_temp)))\n \t  gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, 0);\n \n       /* Then the result type, set to Standard_Void_Type for procedures.  */\n       {\n \tEntity_Id gnat_temp_type\n \t  = Etype (Defining_Entity (Specification (gnat_node)));\n \n-\tif (Is_Itype (gnat_temp_type) && !From_With_Type (gnat_temp_type))\n+\tif (Is_Itype (gnat_temp_type) && !From_Limited_With (gnat_temp_type))\n \t  gnat_to_gnu_entity (Etype (gnat_temp_type), NULL_TREE, 0);\n       }\n "}, {"sha": "d9c693c65489d67aa8169c1b170e02b99ba63b39", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -13822,6 +13822,14 @@ version as output.\n You can specify various style directives via switches; e.g.,\n identifier case conventions, rules of indentation, and comment layout.\n \n+Note: A newly-redesigned set of formatting algorithms used by gnatpp\n+is now available.\n+To invoke the new experimental formatting algorithms, use the\n+@option{--pp-new} switch.\n+The default is @option{--pp-old}; that is, gnatpp uses the old\n+formatting algorithms by default.\n+We intend to make @option{--pp-new} the default at some point.\n+\n To produce a reformatted file, @command{gnatpp} generates and uses the ASIS\n tree for the input source and thus requires the input to be syntactically and\n semantically legal.\n@@ -14430,6 +14438,14 @@ Display Copyright and version, then exit disregarding all other options.\n @cindex @option{--help} @command{gnatpp}\n Display usage, then exit disregarding all other options.\n \n+@item --pp-new\n+@cindex @option{--pp-new} @command{gnatpp}\n+Use the new experimental formatting algorithms.\n+\n+@item --pp-old\n+@cindex @option{--pp-old} @command{gnatpp}\n+Use the old formatting algorithms. This is the default.\n+\n @item ^-files @var{filename}^/FILES=@var{filename}^\n @cindex @option{^-files^/FILES^} (@code{gnatpp})\n Take the argument source files from the specified file. This file should be an"}, {"sha": "20915bc42c3092a701ef93d712e95ceb1e261980", "filename": "gcc/ada/itypes.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fitypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fitypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -105,7 +105,7 @@ package body Itypes is\n       Set_Etype                    (I_Typ, Base_Type (T));\n       Set_Depends_On_Private       (I_Typ, Depends_On_Private (T));\n       Set_Is_Public                (I_Typ, Is_Public          (T));\n-      Set_From_With_Type           (I_Typ, From_With_Type     (T));\n+      Set_From_Limited_With        (I_Typ, From_Limited_With  (T));\n       Set_Is_Access_Constant       (I_Typ, Is_Access_Constant (T));\n       Set_Is_Generic_Type          (I_Typ, Is_Generic_Type    (T));\n       Set_Is_Volatile              (I_Typ, Is_Volatile        (T));"}, {"sha": "ff49104e066057a78bc285e07ccadf9a255ea170", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2388,7 +2388,7 @@ package body Layout is\n          --  If we only have a limited view of the type, see whether the\n          --  non-limited view is available.\n \n-         if From_With_Type (Designated_Type (E))\n+         if From_Limited_With (Designated_Type (E))\n            and then Ekind (Designated_Type (E)) = E_Incomplete_Type\n            and then Present (Non_Limited_View (Designated_Type (E)))\n          then"}, {"sha": "f794162e20b52d64afbc6f42f1a776656691dfbe", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -282,7 +282,7 @@ package body Lib.Writ is\n                   end if;\n \n                else\n-                  Set_From_With_Type (Cunit_Entity (Unum));\n+                  Set_From_Limited_With (Cunit_Entity (Unum));\n                end if;\n \n                if Implicit_With (Unum) /= Yes then\n@@ -810,7 +810,7 @@ package body Lib.Writ is\n                Write_Info_Initiate ('Z');\n \n             elsif Ekind (Cunit_Entity (Unum)) = E_Package\n-              and then From_With_Type (Cunit_Entity (Unum))\n+              and then From_Limited_With (Cunit_Entity (Unum))\n             then\n                Write_Info_Initiate ('Y');\n \n@@ -878,7 +878,7 @@ package body Lib.Writ is\n                end if;\n \n                if Ekind (Cunit_Entity (Unum)) = E_Package\n-                  and then From_With_Type (Cunit_Entity (Unum))\n+                  and then From_Limited_With (Cunit_Entity (Unum))\n                then\n                   null;\n                else\n@@ -960,7 +960,7 @@ package body Lib.Writ is\n \n       for Unum in Units.First .. Last_Unit loop\n          if Cunit_Entity (Unum) = Empty\n-           or else not From_With_Type (Cunit_Entity (Unum))\n+           or else not From_Limited_With (Cunit_Entity (Unum))\n          then\n             Num_Sdep := Num_Sdep + 1;\n             Sdep_Table (Num_Sdep) := Unum;"}, {"sha": "4a6f0533eb40a9c8b97621e01314cf2fb5a44746", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -4708,7 +4708,9 @@ to be used to retrieve information about the predefined path; for example,\n @item @b{VCS_Kind}: single\n \n Value is a string used to specify the Version Control System (VCS) to be used\n-for this project, for example CVS, RCS, ClearCase or Perforce.\n+for this project, for example \"Subversion\", \"ClearCase\". If the\n+value is set to \"Auto\", the IDE will try to detect the actual VCS used\n+on the list of supported ones.\n \n @item @b{VCS_File_Check}: single\n "}, {"sha": "75c4c5a5969429db4c8ac4e8887edbe49fffd098", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -760,7 +760,7 @@ package body Rtsfind is\n             --  a real semantic dependence when the purpose of the limited_with\n             --  is precisely to avoid such.\n \n-            if From_With_Type (Cunit_Entity (U.Unum)) then\n+            if From_Limited_With (Cunit_Entity (U.Unum)) then\n                null;\n \n             else\n@@ -1120,7 +1120,7 @@ package body Rtsfind is\n             --  only has a limited view, scan the corresponding list of\n             --  incomplete types.\n \n-            if From_With_Type (U.Entity) then\n+            if From_Limited_With (U.Entity) then\n                Pkg_Ent := First_Entity (Limited_View (U.Entity));\n             else\n                Pkg_Ent := First_Entity (U.Entity);"}, {"sha": "5234d47db6e22b72d8a110d17ed2d29e3337fb3f", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1636,7 +1636,7 @@ package body Sem_Attr is\n \n             Typ := Etype (E);\n \n-            if From_With_Type (Typ) then\n+            if From_Limited_With (Typ) then\n                Error_Attr_P\n                  (\"prefix of % attribute cannot be an incomplete type\");\n \n@@ -1655,7 +1655,7 @@ package body Sem_Attr is\n                --  entities may occur in subprogram formals.\n \n                if Is_Incomplete_Type (Typ)\n-                 and then From_With_Type (Typ)\n+                 and then From_Limited_With (Typ)\n                  and then Present (Non_Limited_View (Typ))\n                  and then Is_Legal_Shadow_Entity_In_Body (Typ)\n                then\n@@ -9705,7 +9705,7 @@ package body Sem_Attr is\n                --  use of it. If it is an incomplete subtype, use the base type\n                --  in any case.\n \n-               if From_With_Type (Des_Btyp)\n+               if From_Limited_With (Des_Btyp)\n                  and then Present (Non_Limited_View (Des_Btyp))\n                then\n                   Des_Btyp := Non_Limited_View (Des_Btyp);"}, {"sha": "4e6fc1c7c2ec522fc9bf308ed2ab39d20627ab05", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -91,7 +91,7 @@ package body Sem_Aux is\n \n       elsif Is_Class_Wide_Type (Typ)\n         and then Is_Incomplete_Type (Etype (Typ))\n-        and then From_With_Type (Etype (Typ))\n+        and then From_Limited_With (Etype (Typ))\n         and then Present (Non_Limited_View (Etype (Typ)))\n       then\n          return Class_Wide_Type (Non_Limited_View (Etype (Typ)));"}, {"sha": "78520f8b0a163a6276f17eaadeff1a230726d6a1", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 260, "deletions": 328, "changes": 588, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -3897,7 +3897,7 @@ package body Sem_Ch10 is\n                  and then\n                    Ekind (Defining_Identifier (Decl)) = E_Incomplete_Subtype\n                  and then\n-                   From_With_Type (Defining_Identifier (Decl))\n+                   From_Limited_With (Defining_Identifier (Decl))\n                then\n                   Def_Id := Defining_Identifier (Decl);\n                   Non_Lim_View := Non_Limited_View (Def_Id);\n@@ -5076,7 +5076,7 @@ package body Sem_Ch10 is\n       end if;\n \n       Set_Entity (Name (N), P);\n-      Set_From_With_Type (P);\n+      Set_From_Limited_With (P);\n    end Install_Limited_Withed_Unit;\n \n    -------------------------\n@@ -5192,7 +5192,7 @@ package body Sem_Ch10 is\n       --   tions on the use of package entities.\n \n       if Ekind (Uname) = E_Package then\n-         Set_From_With_Type (Uname, False);\n+         Set_From_Limited_With (Uname, False);\n       end if;\n \n       --  Ada 2005 (AI-377): it is illegal for a with_clause to name a child\n@@ -5379,328 +5379,262 @@ package body Sem_Ch10 is\n    -------------------------\n \n    procedure Build_Limited_Views (N : Node_Id) is\n+      Nam  : constant Node_Id          := Name (N);\n       Unum : constant Unit_Number_Type := Get_Source_Unit (Library_Unit (N));\n-      P    : constant Entity_Id        := Cunit_Entity (Unum);\n-\n-      Spec     : Node_Id;            --  To denote a package specification\n-      Lim_Typ  : Entity_Id;          --  To denote shadow entities\n-      Comp_Typ : Entity_Id;          --  To denote real entities\n-\n-      Lim_Header     : Entity_Id;          --  Package entity\n-      Last_Lim_E     : Entity_Id := Empty; --  Last limited entity built\n-      Last_Pub_Lim_E : Entity_Id;          --  To set the first private entity\n-\n-      procedure Decorate_Incomplete_Type (E : Entity_Id; Scop : Entity_Id);\n-      --  Add attributes of an incomplete type to a shadow entity. The same\n-      --  attributes are placed on the real entity, so that gigi receives\n-      --  a consistent view.\n-\n-      procedure Decorate_Package_Specification (P : Entity_Id);\n-      --  Add attributes of a package entity to the entity in a package\n-      --  declaration\n-\n-      procedure Decorate_Tagged_Type\n-        (Loc  : Source_Ptr;\n-         T    : Entity_Id;\n-         Scop : Entity_Id;\n-         Mark : Boolean := False);\n-      --  Set basic attributes of tagged type T, including its class-wide type.\n-      --  The parameters Loc, Scope are used to decorate the class-wide type.\n-      --  Use flag Mark to label the class-wide type as Materialize_Entity.\n-\n-      procedure Build_Chain (Scope : Entity_Id; First_Decl : Node_Id);\n-      --  Construct list of shadow entities and attach it to entity of\n-      --  package that is mentioned in a limited_with clause.\n-\n-      function New_Internal_Shadow_Entity\n-        (Kind       : Entity_Kind;\n-         Sloc_Value : Source_Ptr;\n-         Id_Char    : Character) return Entity_Id;\n-      --  Build a new internal entity and append it to the list of shadow\n-      --  entities available through the limited-header\n-\n-      -----------------\n-      -- Build_Chain --\n-      -----------------\n-\n-      procedure Build_Chain (Scope : Entity_Id; First_Decl : Node_Id) is\n-         Analyzed_Unit : constant Boolean := Analyzed (Cunit (Unum));\n-         Is_Tagged     : Boolean;\n-         Decl          : Node_Id;\n+      Pack : constant Entity_Id        := Cunit_Entity (Unum);\n+\n+      Shadow_Pack : Entity_Id;\n+      --  The corresponding shadow entity of the withed package. This entity\n+      --  offers incomplete views of all types and visible packages declared\n+      --  within.\n+\n+      Last_Shadow : Entity_Id := Empty;\n+      --  The last shadow entity created by routine Build_Shadow_Entity\n+\n+      function Build_Shadow_Entity\n+        (Ent       : Entity_Id;\n+         Scop      : Entity_Id;\n+         Is_Tagged : Boolean := False) return Entity_Id;\n+      --  Create a shadow entity that hides Ent and offers an incomplete view\n+      --  of Ent. Scop is the proper scope. Flag Is_Tagged should be set when\n+      --  Ent is a tagged type. The generated entity is added to Lim_Header.\n+      --  This routine updates the value of Last_Shadow.\n+\n+      procedure Decorate_Package (Ent : Entity_Id; Scop : Entity_Id);\n+      --  Perform minimal decoration of a package or its corresponding shadow\n+      --  entity denoted by Ent. Scop is the proper scope.\n+\n+      procedure Decorate_Type\n+        (Ent         : Entity_Id;\n+         Scop        : Entity_Id;\n+         Is_Tagged   : Boolean := False;\n+         Materialize : Boolean := False);\n+      --  Perform minimal decoration of a type or its corresponding shadow\n+      --  entity denoted by Ent. Scop is the proper scope. Flag Is_Tagged\n+      --  should be set when Ent is a tagged type. Flag Materialize should be\n+      --  set when Ent is a tagged type and its class-wide type needs to appear\n+      --  in the tree.\n+\n+      procedure Process_Declarations (Decls : List_Id; Scop : Entity_Id);\n+      --  Inspect declarative list Decls and create shadow entities for all\n+      --  types and packages encountered. Scop is the proper scope.\n+\n+      -------------------------\n+      -- Build_Shadow_Entity --\n+      -------------------------\n+\n+      function Build_Shadow_Entity\n+        (Ent       : Entity_Id;\n+         Scop      : Entity_Id;\n+         Is_Tagged : Boolean := False) return Entity_Id\n+      is\n+         Shadow : constant Entity_Id := Make_Temporary (Sloc (Ent), 'Z');\n \n       begin\n-         Decl := First_Decl;\n-         while Present (Decl) loop\n+         --  The shadow entity must share the same name and parent as the\n+         --  entity it hides.\n \n-            --  For each library_package_declaration in the environment, there\n-            --  is an implicit declaration of a *limited view* of that library\n-            --  package. The limited view of a package contains:\n-\n-            --   * For each nested package_declaration, a declaration of the\n-            --     limited view of that package, with the same defining-\n-            --     program-unit name.\n-\n-            --   * For each type_declaration in the visible part, an incomplete\n-            --     type-declaration with the same defining_identifier, whose\n-            --     completion is the type_declaration. If the type_declaration\n-            --     is tagged, then the incomplete_type_declaration is tagged\n-            --     incomplete.\n-\n-            --     The partial view is tagged if the declaration has the\n-            --     explicit keyword, or else if it is a type extension, both\n-            --     of which can be ascertained syntactically.\n-\n-            if Nkind (Decl) = N_Full_Type_Declaration then\n-               Is_Tagged :=\n-                  (Nkind (Type_Definition (Decl)) = N_Record_Definition\n-                    and then Tagged_Present (Type_Definition (Decl)))\n-                 or else\n-                   (Nkind (Type_Definition (Decl)) = N_Derived_Type_Definition\n-                     and then\n-                       Present\n-                         (Record_Extension_Part (Type_Definition (Decl))));\n+         Set_Chars             (Shadow, Chars (Ent));\n+         Set_Parent            (Shadow, Parent (Ent));\n+         Set_Ekind             (Shadow, Ekind (Ent));\n+         Set_Is_Internal       (Shadow);\n+         Set_From_Limited_With (Shadow);\n \n-               Comp_Typ := Defining_Identifier (Decl);\n+         --  Add the new shadow entity to the limited view of the package\n \n-               if not Analyzed_Unit then\n-                  if Is_Tagged then\n-                     Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope, True);\n-                  else\n-                     Decorate_Incomplete_Type (Comp_Typ, Scope);\n-                  end if;\n-               end if;\n+         Last_Shadow := Shadow;\n+         Append_Entity (Shadow, Shadow_Pack);\n \n-               --  Create shadow entity for type\n+         if Is_Type (Ent) then\n+            Decorate_Type (Shadow, Scop, Is_Tagged);\n \n-               Lim_Typ :=\n-                 New_Internal_Shadow_Entity\n-                   (Kind       => Ekind (Comp_Typ),\n-                    Sloc_Value => Sloc (Comp_Typ),\n-                    Id_Char    => 'Z');\n+            if Is_Incomplete_Or_Private_Type (Ent) then\n+               Set_Private_Dependents (Shadow, New_Elmt_List);\n+            end if;\n \n-               Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n-               Set_Parent (Lim_Typ, Parent (Comp_Typ));\n-               Set_From_With_Type (Lim_Typ);\n+            Set_Non_Limited_View (Shadow, Ent);\n \n-               if Is_Tagged then\n-                  Decorate_Tagged_Type (Sloc (Decl), Lim_Typ, Scope);\n-               else\n-                  Decorate_Incomplete_Type (Lim_Typ, Scope);\n-               end if;\n+         elsif Ekind (Ent) = E_Package then\n+            Decorate_Package (Shadow, Scop);\n+         end if;\n \n-               Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n-               Set_Private_Dependents (Lim_Typ, New_Elmt_List);\n+         return Shadow;\n+      end Build_Shadow_Entity;\n \n-            elsif Nkind_In (Decl, N_Private_Type_Declaration,\n-                                  N_Incomplete_Type_Declaration,\n-                                  N_Task_Type_Declaration,\n-                                  N_Protected_Type_Declaration)\n-            then\n-               Comp_Typ := Defining_Identifier (Decl);\n+      ----------------------\n+      -- Decorate_Package --\n+      ----------------------\n \n-               Is_Tagged :=\n-                 Nkind_In (Decl, N_Private_Type_Declaration,\n-                                 N_Incomplete_Type_Declaration)\n-                 and then Tagged_Present (Decl);\n+      procedure Decorate_Package (Ent : Entity_Id; Scop : Entity_Id) is\n+      begin\n+         Set_Ekind (Ent, E_Package);\n+         Set_Etype (Ent, Standard_Void_Type);\n+         Set_Scope (Ent, Scop);\n+      end Decorate_Package;\n+\n+      -------------------\n+      -- Decorate_Type --\n+      -------------------\n+\n+      procedure Decorate_Type\n+        (Ent         : Entity_Id;\n+         Scop        : Entity_Id;\n+         Is_Tagged   : Boolean := False;\n+         Materialize : Boolean := False)\n+      is\n+         CW_Typ : Entity_Id;\n \n-               if not Analyzed_Unit then\n-                  if Is_Tagged then\n-                     Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope, True);\n-                  else\n-                     Decorate_Incomplete_Type (Comp_Typ, Scope);\n-                  end if;\n-               end if;\n+      begin\n+         --  An unanalyzed type or a shadow entity of a type is treated as an\n+         --  incomplete type.\n+\n+         Set_Ekind             (Ent, E_Incomplete_Type);\n+         Set_Etype             (Ent, Ent);\n+         Set_Scope             (Ent, Scop);\n+         Set_Is_First_Subtype  (Ent);\n+         Set_Stored_Constraint (Ent, No_Elist);\n+         Set_Full_View         (Ent, Empty);\n+         Init_Size_Align       (Ent);\n+\n+         --  A tagged type and its corresponding shadow entity share one common\n+         --  class-wide type.\n+\n+         if Is_Tagged then\n+            Set_Is_Tagged_Type (Ent);\n+\n+            if No (Class_Wide_Type (Ent)) then\n+               CW_Typ :=\n+                 New_External_Entity\n+                   (E_Void, Scope (Ent), Sloc (Ent), Ent, 'C', 0, 'T');\n+\n+               Set_Class_Wide_Type (Ent, CW_Typ);\n+\n+               --  Set parent to be the same as the parent of the tagged type.\n+               --  We need a parent field set, and it is supposed to point to\n+               --  the declaration of the type. The tagged type declaration\n+               --  essentially declares two separate types, the tagged type\n+               --  itself and the corresponding class-wide type, so it is\n+               --  reasonable for the parent fields to point to the declaration\n+               --  in both cases.\n+\n+               Set_Parent (CW_Typ, Parent (Ent));\n+\n+               Set_Ekind                     (CW_Typ, E_Class_Wide_Type);\n+               Set_Etype                     (CW_Typ, Ent);\n+               Set_Scope                     (CW_Typ, Scop);\n+               Set_Is_Tagged_Type            (CW_Typ);\n+               Set_Is_First_Subtype          (CW_Typ);\n+               Init_Size_Align               (CW_Typ);\n+               Set_Has_Unknown_Discriminants (CW_Typ);\n+               Set_Class_Wide_Type           (CW_Typ, CW_Typ);\n+               Set_Equivalent_Type           (CW_Typ, Empty);\n+               Set_From_Limited_With         (CW_Typ, From_Limited_With (Ent));\n+               Set_Materialize_Entity        (CW_Typ, Materialize);\n+            end if;\n+         end if;\n+      end Decorate_Type;\n \n-               Lim_Typ :=\n-                 New_Internal_Shadow_Entity\n-                   (Kind       => Ekind (Comp_Typ),\n-                    Sloc_Value => Sloc (Comp_Typ),\n-                    Id_Char    => 'Z');\n+      --------------------------\n+      -- Process_Declarations --\n+      --------------------------\n \n-               Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n-               Set_Parent (Lim_Typ, Parent (Comp_Typ));\n-               Set_From_With_Type (Lim_Typ);\n+      procedure Process_Declarations (Decls : List_Id; Scop : Entity_Id) is\n+         Is_Analyzed : constant Boolean := Analyzed (Cunit (Unum));\n+         Is_Tagged   : Boolean;\n+         Decl        : Node_Id;\n+         Def         : Node_Id;\n+         Pack        : Entity_Id;\n+         Shadow      : Entity_Id;\n+         Typ         : Entity_Id;\n \n-               if Is_Tagged then\n-                  Decorate_Tagged_Type (Sloc (Decl), Lim_Typ, Scope);\n-               else\n-                  Decorate_Incomplete_Type (Lim_Typ, Scope);\n-               end if;\n+      begin\n+         --  Inspect the declarative list, looking for type declarations and\n+         --  nested packages.\n \n-               Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n+         Decl := First (Decls);\n+         while Present (Decl) loop\n \n-               --  Initialize Private_Depedents, so the field has the proper\n-               --  type, even though the list will remain empty.\n+            --  Types\n \n-               Set_Private_Dependents (Lim_Typ, New_Elmt_List);\n+            if Nkind_In (Decl, N_Full_Type_Declaration,\n+                               N_Incomplete_Type_Declaration,\n+                               N_Private_Extension_Declaration,\n+                               N_Private_Type_Declaration,\n+                               N_Protected_Type_Declaration,\n+                               N_Task_Type_Declaration)\n+            then\n+               Typ := Defining_Entity (Decl);\n \n-            elsif Nkind (Decl) = N_Private_Extension_Declaration then\n-               Comp_Typ := Defining_Identifier (Decl);\n+               --  Determine whether the type is tagged. Note that packages\n+               --  included via a limited with clause are not always analyzed,\n+               --  hence the tree lookup rather than the use of attribute\n+               --  Is_Tagged_Type.\n \n-               if not Analyzed_Unit then\n-                  Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope, True);\n-               end if;\n+               if Nkind (Decl) = N_Full_Type_Declaration then\n+                  Def := Type_Definition (Decl);\n \n-               --  Create shadow entity for type\n+                  Is_Tagged :=\n+                     (Nkind (Def) = N_Record_Definition\n+                        and then Tagged_Present (Def))\n+                    or else\n+                     (Nkind (Def) = N_Derived_Type_Definition\n+                        and then Present (Record_Extension_Part (Def)));\n \n-               Lim_Typ :=\n-                 New_Internal_Shadow_Entity\n-                   (Kind       => Ekind (Comp_Typ),\n-                    Sloc_Value => Sloc (Comp_Typ),\n-                    Id_Char    => 'Z');\n+               elsif Nkind_In (Decl, N_Incomplete_Type_Declaration,\n+                                     N_Private_Type_Declaration)\n+               then\n+                  Is_Tagged := Tagged_Present (Decl);\n \n-               Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n-               Set_Parent (Lim_Typ, Parent (Comp_Typ));\n-               Set_From_With_Type (Lim_Typ);\n+               elsif Nkind (Decl) = N_Private_Extension_Declaration then\n+                  Is_Tagged := True;\n \n-               Decorate_Tagged_Type (Sloc (Decl), Lim_Typ, Scope);\n-               Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n+               else\n+                  Is_Tagged := False;\n+               end if;\n \n-            elsif Nkind (Decl) = N_Package_Declaration then\n+               --  Perform minor decoration when the withed package has not\n+               --  been analyzed.\n \n-               --  Local package\n+               if not Is_Analyzed then\n+                  Decorate_Type (Typ, Scop, Is_Tagged, True);\n+               end if;\n \n-               declare\n-                  Spec : constant Node_Id := Specification (Decl);\n+               --  Create a shadow entity that hides the type and offers an\n+               --  incomplete view of the said type.\n \n-               begin\n-                  Comp_Typ := Defining_Unit_Name (Spec);\n+               Shadow := Build_Shadow_Entity (Typ, Scop, Is_Tagged);\n \n-                  if not Analyzed (Cunit (Unum)) then\n-                     Decorate_Package_Specification (Comp_Typ);\n-                     Set_Scope (Comp_Typ, Scope);\n-                  end if;\n+            --  Packages\n+\n+            elsif Nkind (Decl) = N_Package_Declaration then\n+               Pack := Defining_Entity (Decl);\n \n-                  Lim_Typ :=\n-                    New_Internal_Shadow_Entity\n-                      (Kind       => Ekind (Comp_Typ),\n-                       Sloc_Value => Sloc (Comp_Typ),\n-                       Id_Char    => 'Z');\n+               --  Perform minor decoration when the withed package has not\n+               --  been analyzed.\n \n-                  Decorate_Package_Specification (Lim_Typ);\n-                  Set_Scope (Lim_Typ, Scope);\n+               if not Is_Analyzed then\n+                  Decorate_Package (Pack, Scop);\n+               end if;\n \n-                  Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n-                  Set_Parent (Lim_Typ, Parent (Comp_Typ));\n-                  Set_From_With_Type (Lim_Typ);\n+               --  Create a shadow entity that offers a limited view of all\n+               --  visible types declared within.\n \n-                  --  Note: The non_limited_view attribute is not used\n-                  --  for local packages.\n+               Shadow := Build_Shadow_Entity (Pack, Scop);\n \n-                  Build_Chain\n-                    (Scope      => Lim_Typ,\n-                     First_Decl => First (Visible_Declarations (Spec)));\n-               end;\n+               Process_Declarations\n+                 (Decls => Visible_Declarations (Specification (Decl)),\n+                  Scop  => Shadow);\n             end if;\n \n             Next (Decl);\n          end loop;\n-      end Build_Chain;\n-\n-      ------------------------------\n-      -- Decorate_Incomplete_Type --\n-      ------------------------------\n-\n-      procedure Decorate_Incomplete_Type (E : Entity_Id; Scop : Entity_Id) is\n-      begin\n-         Set_Ekind             (E, E_Incomplete_Type);\n-         Set_Scope             (E, Scop);\n-         Set_Etype             (E, E);\n-         Set_Is_First_Subtype  (E, True);\n-         Set_Stored_Constraint (E, No_Elist);\n-         Set_Full_View         (E, Empty);\n-         Init_Size_Align       (E);\n-      end Decorate_Incomplete_Type;\n-\n-      --------------------------\n-      -- Decorate_Tagged_Type --\n-      --------------------------\n-\n-      procedure Decorate_Tagged_Type\n-        (Loc  : Source_Ptr;\n-         T    : Entity_Id;\n-         Scop : Entity_Id;\n-         Mark : Boolean := False)\n-      is\n-         CW : Entity_Id;\n+      end Process_Declarations;\n \n-      begin\n-         Decorate_Incomplete_Type (T, Scop);\n-         Set_Is_Tagged_Type (T);\n-\n-         --  Build corresponding class_wide type, if not previously done\n-\n-         --  Note: The class-wide entity is shared by the limited-view\n-         --  and the full-view.\n-\n-         if No (Class_Wide_Type (T)) then\n-            CW := New_External_Entity (E_Void, Scope (T), Loc, T, 'C', 0, 'T');\n-\n-            --  Set parent to be the same as the parent of the tagged type.\n-            --  We need a parent field set, and it is supposed to point to\n-            --  the declaration of the type. The tagged type declaration\n-            --  essentially declares two separate types, the tagged type\n-            --  itself and the corresponding class-wide type, so it is\n-            --  reasonable for the parent fields to point to the declaration\n-            --  in both cases.\n-\n-            Set_Parent (CW, Parent (T));\n-\n-            --  Set remaining fields of classwide type\n-\n-            Set_Ekind                     (CW, E_Class_Wide_Type);\n-            Set_Etype                     (CW, T);\n-            Set_Scope                     (CW, Scop);\n-            Set_Is_Tagged_Type            (CW);\n-            Set_Is_First_Subtype          (CW, True);\n-            Init_Size_Align               (CW);\n-            Set_Has_Unknown_Discriminants (CW, True);\n-            Set_Class_Wide_Type           (CW, CW);\n-            Set_Equivalent_Type           (CW, Empty);\n-            Set_From_With_Type            (CW, From_With_Type (T));\n-            Set_Materialize_Entity        (CW, Mark);\n-\n-            --  Link type to its class-wide type\n-\n-            Set_Class_Wide_Type           (T, CW);\n-         end if;\n-      end Decorate_Tagged_Type;\n-\n-      ------------------------------------\n-      -- Decorate_Package_Specification --\n-      ------------------------------------\n-\n-      procedure Decorate_Package_Specification (P : Entity_Id) is\n-      begin\n-         --  Place only the most basic attributes\n-\n-         Set_Ekind (P, E_Package);\n-         Set_Etype (P, Standard_Void_Type);\n-      end Decorate_Package_Specification;\n-\n-      --------------------------------\n-      -- New_Internal_Shadow_Entity --\n-      --------------------------------\n-\n-      function New_Internal_Shadow_Entity\n-        (Kind       : Entity_Kind;\n-         Sloc_Value : Source_Ptr;\n-         Id_Char    : Character) return Entity_Id\n-      is\n-         E : constant Entity_Id := Make_Temporary (Sloc_Value, Id_Char);\n-\n-      begin\n-         Set_Ekind       (E, Kind);\n-         Set_Is_Internal (E, True);\n-\n-         if Kind in Type_Kind then\n-            Init_Size_Align (E);\n-         end if;\n+      --  Local variables\n \n-         Append_Entity (E, Lim_Header);\n-         Last_Lim_E := E;\n-         return E;\n-      end New_Internal_Shadow_Entity;\n+      Last_Public_Shadow : Entity_Id := Empty;\n+      Private_Shadow     : Entity_Id;\n+      Spec               : Node_Id;\n \n    --  Start of processing for Build_Limited_Views\n \n@@ -5716,49 +5650,51 @@ package body Sem_Ch10 is\n             null;\n \n          when N_Subprogram_Declaration =>\n-            Error_Msg_N (\"subprograms not allowed in \"\n-                         & \"limited with_clauses\", N);\n+            Error_Msg_N (\"subprograms not allowed in limited with_clauses\", N);\n             return;\n \n          when N_Generic_Package_Declaration |\n               N_Generic_Subprogram_Declaration =>\n-            Error_Msg_N (\"generics not allowed in \"\n-                         & \"limited with_clauses\", N);\n+            Error_Msg_N (\"generics not allowed in limited with_clauses\", N);\n             return;\n \n          when N_Generic_Instantiation =>\n-            Error_Msg_N (\"generic instantiations not allowed in \"\n-                         & \"limited with_clauses\", N);\n+            Error_Msg_N\n+              (\"generic instantiations not allowed in limited with_clauses\",\n+               N);\n             return;\n \n          when N_Generic_Renaming_Declaration =>\n-            Error_Msg_N (\"generic renamings not allowed in \"\n-                         & \"limited with_clauses\", N);\n+            Error_Msg_N\n+              (\"generic renamings not allowed in limited with_clauses\", N);\n             return;\n \n          when N_Subprogram_Renaming_Declaration =>\n-            Error_Msg_N (\"renamed subprograms not allowed in \"\n-                         & \"limited with_clauses\", N);\n+            Error_Msg_N\n+              (\"renamed subprograms not allowed in limited with_clauses\", N);\n             return;\n \n          when N_Package_Renaming_Declaration =>\n-            Error_Msg_N (\"renamed packages not allowed in \"\n-                         & \"limited with_clauses\", N);\n+            Error_Msg_N\n+              (\"renamed packages not allowed in limited with_clauses\", N);\n             return;\n \n          when others =>\n             raise Program_Error;\n       end case;\n \n-      --  The limited unit is not analyzed but the with clause must be\n-      --  minimally decorated so that checks on unused with clause also work\n-      --  with limited with clauses.\n+      --  The withed unit may not be analyzed, but the with calause itself\n+      --  must be minimally decorated. This ensures that the checks on unused\n+      --  with clauses also process limieted withs.\n+\n+      Set_Ekind (Pack, E_Package);\n+      Set_Etype (Pack, Standard_Void_Type);\n \n-      if Is_Entity_Name (Name (N)) then\n-         Set_Entity (Name (N), P);\n+      if Is_Entity_Name (Nam) then\n+         Set_Entity (Nam, Pack);\n \n-      elsif Nkind (Name (N)) = N_Selected_Component then\n-         Set_Entity (Selector_Name (Name (N)), P);\n+      elsif Nkind (Nam) = N_Selected_Component then\n+         Set_Entity (Selector_Name (Nam), Pack);\n       end if;\n \n       --  Check if the chain is already built\n@@ -5769,41 +5705,37 @@ package body Sem_Ch10 is\n          return;\n       end if;\n \n-      Set_Ekind (P, E_Package);\n-\n-      --  Build the header of the limited_view\n-\n-      Lim_Header := Make_Temporary (Sloc (N), 'Z');\n-      Set_Ekind (Lim_Header, E_Package);\n-      Set_Is_Internal (Lim_Header);\n-      Set_Limited_View (P, Lim_Header);\n+      --  Create the shadow package wich hides the withed unit and provides\n+      --  incomplete view of all types and packages declared within.\n \n-      --  Create the auxiliary chain. All the shadow entities are appended to\n-      --  the list of entities of the limited-view header\n+      Shadow_Pack := Make_Temporary (Sloc (N), 'Z');\n+      Set_Ekind        (Shadow_Pack, E_Package);\n+      Set_Is_Internal  (Shadow_Pack);\n+      Set_Limited_View (Pack, Shadow_Pack);\n \n-      Build_Chain\n-        (Scope      => P,\n-         First_Decl => First (Visible_Declarations (Spec)));\n+      --  Inspect the visible declarations of the withed unit and create shadow\n+      --  entities that hide existing types and packages.\n \n-      --  Save the last built shadow entity. It is needed later to set the\n-      --  reference to the first shadow entity in the private part\n+      Process_Declarations\n+        (Decls => Visible_Declarations (Spec),\n+         Scop  => Pack);\n \n-      Last_Pub_Lim_E := Last_Lim_E;\n+      Last_Public_Shadow := Last_Shadow;\n \n-      --  Ada 2005 (AI-262): Add the limited view of the private declarations\n-      --  Required to give support to limited-private-with clauses\n+      --  Ada 2005 (AI-262): Build the limited view of the private declarations\n+      --  to accomodate limited private with clauses.\n \n-      Build_Chain (Scope      => P,\n-                   First_Decl => First (Private_Declarations (Spec)));\n+      Process_Declarations\n+        (Decls => Private_Declarations (Spec),\n+         Scop  => Pack);\n \n-      if Last_Pub_Lim_E /= Empty then\n-         Set_First_Private_Entity\n-           (Lim_Header, Next_Entity (Last_Pub_Lim_E));\n+      if Present (Last_Public_Shadow) then\n+         Private_Shadow := Next_Entity (Last_Public_Shadow);\n       else\n-         Set_First_Private_Entity\n-           (Lim_Header, First_Entity (P));\n+         Private_Shadow := First_Entity (Shadow_Pack);\n       end if;\n \n+      Set_First_Private_Entity (Shadow_Pack, Private_Shadow);\n       Set_Limited_View_Installed (Spec);\n    end Build_Limited_Views;\n \n@@ -6118,7 +6050,7 @@ package body Sem_Ch10 is\n \n       --  Indicate that the limited view of the package is not installed\n \n-      Set_From_With_Type         (P, False);\n+      Set_From_Limited_With      (P, False);\n       Set_Limited_View_Installed (N, False);\n    end Remove_Limited_With_Clause;\n "}, {"sha": "4ce3fd69f9de8e3cfa80d4e212cf4fdcef30b049", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -3477,7 +3477,7 @@ package body Sem_Ch12 is\n \n          --  Ada 2005 (AI-50217): Cannot use instance in limited with_clause\n \n-         if From_With_Type (Gen_Unit) then\n+         if From_Limited_With (Gen_Unit) then\n             Error_Msg_N\n               (\"cannot instantiate a limited withed package\", Gen_Id);\n          else\n@@ -10610,7 +10610,7 @@ package body Sem_Ch12 is\n          --  with clause, in which case retrieve the non-limited view. This\n          --  applies to incomplete types as well as to class-wide types.\n \n-         if From_With_Type (Desig_Act) then\n+         if From_Limited_With (Desig_Act) then\n             Desig_Act := Available_View (Desig_Act);\n          end if;\n "}, {"sha": "4e3fcacedc385e5136a8bfaca5d80ff7ffb177cd", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -10208,7 +10208,7 @@ package body Sem_Ch13 is\n         --  Exclude imported types, which may be frozen if they appear in a\n         --  representation clause for a local type.\n \n-        and then not From_With_Type (T)\n+        and then not From_Limited_With (T)\n \n         --  Exclude generated entities (not coming from source). The common\n         --  case is when we generate a renaming which prematurely freezes the"}, {"sha": "50ef808e0137540de77de234d57f2a8b45fbe374", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -896,7 +896,7 @@ package body Sem_Ch3 is\n       --  (which is declared elsewhere in some other scope).\n \n       if Ekind (Desig_Type) = E_Incomplete_Type\n-        and then not From_With_Type (Desig_Type)\n+        and then not From_Limited_With (Desig_Type)\n         and then Is_Overloadable (Current_Scope)\n       then\n          Append_Elmt (Current_Scope, Private_Dependents (Desig_Type));\n@@ -950,7 +950,7 @@ package body Sem_Ch3 is\n       --  generic formal, because no use of it will reach the backend.\n \n       elsif Nkind (Related_Nod) = N_Function_Specification\n-        and then not From_With_Type (Desig_Type)\n+        and then not From_Limited_With (Desig_Type)\n         and then not Is_Generic_Type (Desig_Type)\n       then\n          if Present (Enclosing_Prot_Type) then\n@@ -1131,7 +1131,7 @@ package body Sem_Ch3 is\n                        Scope_Id    => Current_Scope));\n \n                else\n-                  if From_With_Type (Typ) then\n+                  if From_Limited_With (Typ) then\n \n                      --  AI05-151: Incomplete types are allowed in all basic\n                      --  declarations, including access to subprograms.\n@@ -1360,7 +1360,7 @@ package body Sem_Ch3 is\n       --  If the type has appeared already in a with_type clause, it is frozen\n       --  and the pointer size is already set. Else, initialize.\n \n-      if not From_With_Type (T) then\n+      if not From_Limited_With (T) then\n          Init_Size_Align (T);\n       end if;\n \n@@ -2546,7 +2546,7 @@ package body Sem_Ch3 is\n          --  finalization list at the point the access type is frozen, to\n          --  prevent unsatisfied references at link time.\n \n-         if not From_With_Type (T) or else Is_Access_Type (T) then\n+         if not From_Limited_With (T) or else Is_Access_Type (T) then\n             Set_Has_Delayed_Freeze (T);\n          end if;\n       end;\n@@ -4466,11 +4466,11 @@ package body Sem_Ch3 is\n                   --  Ada 2005 (AI-412): Decorate an incomplete subtype of an\n                   --  incomplete type visible through a limited with clause.\n \n-                  if From_With_Type (T)\n+                  if From_Limited_With (T)\n                     and then Present (Non_Limited_View (T))\n                   then\n-                     Set_From_With_Type   (Id);\n-                     Set_Non_Limited_View (Id, Non_Limited_View (T));\n+                     Set_From_Limited_With (Id);\n+                     Set_Non_Limited_View  (Id, Non_Limited_View (T));\n \n                   --  Ada 2005 (AI-412): Add the regular incomplete subtype\n                   --  to the private dependents of the original incomplete\n@@ -11933,13 +11933,12 @@ package body Sem_Ch3 is\n          --  incomplete type or imported via a limited with clause.\n \n          if Has_Discriminants (T)\n-           or else\n-             (From_With_Type (T)\n-                and then Present (Non_Limited_View (T))\n-                and then Nkind (Parent (Non_Limited_View (T))) =\n-                           N_Full_Type_Declaration\n-                and then Present (Discriminant_Specifications\n-                          (Parent (Non_Limited_View (T)))))\n+           or else (From_Limited_With (T)\n+                     and then Present (Non_Limited_View (T))\n+                     and then Nkind (Parent (Non_Limited_View (T))) =\n+                                               N_Full_Type_Declaration\n+                     and then Present (Discriminant_Specifications\n+                                         (Parent (Non_Limited_View (T)))))\n          then\n             Error_Msg_N\n               (\"(Ada 2005) incomplete subtype may not be constrained\", C);"}, {"sha": "52aa233746b442c225c2d2f818a07d46a6a5cba7", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1861,8 +1861,8 @@ package body Sem_Ch4 is\n                --  incomplete type imported through a limited_with clause,\n                --  if the full view is visible.\n \n-               if From_With_Type (DT)\n-                 and then not From_With_Type (Scope (DT))\n+               if From_Limited_With (DT)\n+                 and then not From_Limited_With (Scope (DT))\n                  and then\n                    (Is_Immediately_Visible (Scope (DT))\n                      or else\n@@ -4073,7 +4073,7 @@ package body Sem_Ch4 is\n       --  full view if available.\n \n       if Is_Incomplete_Type (Prefix_Type)\n-        and then From_With_Type (Prefix_Type)\n+        and then From_Limited_With (Prefix_Type)\n         and then Present (Non_Limited_View (Prefix_Type))\n       then\n          Prefix_Type := Get_Full_View (Non_Limited_View (Prefix_Type));\n@@ -4083,7 +4083,7 @@ package body Sem_Ch4 is\n          end if;\n \n       elsif Ekind (Prefix_Type) = E_Class_Wide_Type\n-        and then From_With_Type (Prefix_Type)\n+        and then From_Limited_With (Prefix_Type)\n         and then Present (Non_Limited_View (Etype (Prefix_Type)))\n       then\n          Prefix_Type :=\n@@ -4191,7 +4191,7 @@ package body Sem_Ch4 is\n                --    end Pkg;                       --  Comp is not visible\n \n                if Nkind (Name) = N_Explicit_Dereference\n-                 and then From_With_Type (Etype (Prefix (Name)))\n+                 and then From_Limited_With (Etype (Prefix (Name)))\n                  and then not Is_Potentially_Use_Visible (Etype (Name))\n                  and then Nkind (Parent (Cunit_Entity (Current_Sem_Unit))) =\n                             N_Package_Specification\n@@ -4644,7 +4644,7 @@ package body Sem_Ch4 is\n                   Inc : constant Entity_Id := First_Subtype (Type_To_Use);\n \n                begin\n-                  if From_With_Type (Scope (Type_To_Use)) then\n+                  if From_Limited_With (Scope (Type_To_Use)) then\n                      Error_Msg_NE\n                        (\"\\limited view of& has no components\", N, Inc);\n \n@@ -5364,7 +5364,7 @@ package body Sem_Ch4 is\n             --  usage of an entity from the limited view.\n \n             if not Analyzed (Etype (Actual))\n-             and then From_With_Type (Etype (Actual))\n+             and then From_Limited_With (Etype (Actual))\n             then\n                Error_Msg_Qual_Level := 1;\n                Error_Msg_NE\n@@ -6525,8 +6525,8 @@ package body Sem_Ch4 is\n       --  incomplete type imported through a limited_with clause,\n       --  if the full view is visible.\n \n-      if From_With_Type (Typ)\n-        and then not From_With_Type (Scope (Typ))\n+      if From_Limited_With (Typ)\n+        and then not From_Limited_With (Scope (Typ))\n         and then\n           (Is_Immediately_Visible (Scope (Typ))\n             or else\n@@ -7753,7 +7753,7 @@ package body Sem_Ch4 is\n          --  non-limited view. If still incomplete, retrieve full view.\n \n          if Ekind (Obj_Type) = E_Incomplete_Type\n-           and then From_With_Type (Obj_Type)\n+           and then From_Limited_With (Obj_Type)\n          then\n             Obj_Type := Get_Full_View (Non_Limited_View (Obj_Type));\n          end if;"}, {"sha": "1ad5f2d525e76b56079ddaf1042cf21a12a35412", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -2500,7 +2500,7 @@ package body Sem_Ch6 is\n \n          begin\n             if Ekind (Typ) = E_Incomplete_Type\n-              and then From_With_Type (Typ)\n+              and then From_Limited_With (Typ)\n               and then Present (Non_Limited_View (Typ))\n             then\n                Set_Etype (Id, Non_Limited_View (Typ));\n@@ -3058,7 +3058,9 @@ package body Sem_Ch6 is\n             if Ekind (Rtyp) = E_Anonymous_Access_Type then\n                Etyp := Directly_Designated_Type (Rtyp);\n \n-               if Is_Class_Wide_Type (Etyp) and then From_With_Type (Etyp) then\n+               if Is_Class_Wide_Type (Etyp)\n+                 and then From_Limited_With (Etyp)\n+               then\n                   Set_Directly_Designated_Type\n                     (Etype (Current_Scope), Available_View (Etyp));\n                end if;\n@@ -6547,7 +6549,9 @@ package body Sem_Ch6 is\n          then\n             Set_Has_Delayed_Freeze (Designator);\n \n-         elsif Ekind (T) = E_Incomplete_Type and then From_With_Type (T) then\n+         elsif Ekind (T) = E_Incomplete_Type\n+           and then From_Limited_With (T)\n+         then\n             Set_Has_Delayed_Freeze (Designator);\n \n          --  AI05-0151: In Ada 2012, Incomplete types can appear in the profile\n@@ -7711,14 +7715,14 @@ package body Sem_Ch6 is\n          --  access-to-class-wide type in a formal. Both entities designate the\n          --  same type.\n \n-         if From_With_Type (T1) and then T2 = Available_View (T1) then\n+         if From_Limited_With (T1) and then T2 = Available_View (T1) then\n             return True;\n \n-         elsif From_With_Type (T2) and then T1 = Available_View (T2) then\n+         elsif From_Limited_With (T2) and then T1 = Available_View (T2) then\n             return True;\n \n-         elsif From_With_Type (T1)\n-           and then From_With_Type (T2)\n+         elsif From_Limited_With (T1)\n+           and then From_Limited_With (T2)\n            and then Available_View (T1) = Available_View (T2)\n          then\n             return True;\n@@ -8212,7 +8216,8 @@ package body Sem_Ch6 is\n             --  the designated type comes from the limited view (for back-end\n             --  purposes).\n \n-            Set_From_With_Type (Formal_Typ, From_With_Type (Result_Subt));\n+            Set_From_Limited_With\n+              (Formal_Typ, From_Limited_With (Result_Subt));\n \n             Layout_Type (Formal_Typ);\n \n@@ -10946,7 +10951,7 @@ package body Sem_Ch6 is\n       First_Out_Param : Entity_Id := Empty;\n       --  Used for setting Is_Only_Out_Parameter\n \n-      function Designates_From_With_Type (Typ : Entity_Id) return Boolean;\n+      function Designates_From_Limited_With (Typ : Entity_Id) return Boolean;\n       --  Determine whether an access type designates a type coming from a\n       --  limited view.\n \n@@ -10955,11 +10960,11 @@ package body Sem_Ch6 is\n       --  default has the type of the formal, so we must also check explicitly\n       --  for an access attribute.\n \n-      -------------------------------\n-      -- Designates_From_With_Type --\n-      -------------------------------\n+      ----------------------------------\n+      -- Designates_From_Limited_With --\n+      ----------------------------------\n \n-      function Designates_From_With_Type (Typ : Entity_Id) return Boolean is\n+      function Designates_From_Limited_With (Typ : Entity_Id) return Boolean is\n          Desig : Entity_Id := Typ;\n \n       begin\n@@ -10972,8 +10977,9 @@ package body Sem_Ch6 is\n          end if;\n \n          return\n-           Ekind (Desig) = E_Incomplete_Type and then From_With_Type (Desig);\n-      end Designates_From_With_Type;\n+           Ekind (Desig) = E_Incomplete_Type\n+             and then From_Limited_With (Desig);\n+      end Designates_From_Limited_With;\n \n       ---------------------------\n       -- Is_Class_Wide_Default --\n@@ -11031,7 +11037,7 @@ package body Sem_Ch6 is\n \n                if Is_Tagged_Type (Formal_Type) then\n                   if Ekind (Scope (Current_Scope)) = E_Package\n-                    and then not From_With_Type (Formal_Type)\n+                    and then not From_Limited_With (Formal_Type)\n                     and then not Is_Generic_Type (Formal_Type)\n                     and then not Is_Class_Wide_Type (Formal_Type)\n                   then\n@@ -11214,7 +11220,7 @@ package body Sem_Ch6 is\n             --  is also class-wide.\n \n             if Ekind (Formal_Type) = E_Anonymous_Access_Type\n-              and then not Designates_From_With_Type (Formal_Type)\n+              and then not Designates_From_Limited_With (Formal_Type)\n               and then Is_Class_Wide_Default (Default)\n               and then not Is_Class_Wide_Type (Designated_Type (Formal_Type))\n             then"}, {"sha": "e9f32ede00451a5443419ef1e5ae15804c113d72", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -804,7 +804,7 @@ package body Sem_Ch7 is\n       --     limited with Pkg; -- ERROR\n       --     package Pkg is ...\n \n-      if From_With_Type (Id) then\n+      if From_Limited_With (Id) then\n          return;\n       end if;\n \n@@ -1580,7 +1580,7 @@ package body Sem_Ch7 is\n       E := First_Entity (Spec_Id);\n       while Present (E) loop\n          if Ekind (E) = E_Anonymous_Access_Type\n-           and then From_With_Type (E)\n+           and then From_Limited_With (E)\n          then\n             IR := Make_Itype_Reference (Sloc (P_Body));\n             Set_Itype (IR, E);"}, {"sha": "34b52593db59367e3be5090bc88286193bd9aa47", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -4104,7 +4104,7 @@ package body Sem_Ch8 is\n \n          T := Entity (Id);\n \n-         if T = Any_Type or else From_With_Type (T) then\n+         if T = Any_Type or else From_Limited_With (T) then\n             null;\n \n          --  Note that the use_type clause may mention a subtype of the type\n@@ -5221,7 +5221,7 @@ package body Sem_Ch8 is\n             --  The non-limited view may itself be incomplete, in which case\n             --  get the full view if available.\n \n-            elsif From_With_Type (Id)\n+            elsif From_Limited_With (Id)\n               and then Is_Type (Id)\n               and then Ekind (Id) = E_Incomplete_Type\n               and then Present (Non_Limited_View (Id))\n@@ -5519,8 +5519,8 @@ package body Sem_Ch8 is\n \n       --  Ada 2005 (AI-50217): Check usage of entities in limited withed units\n \n-      if Ekind (P_Name) = E_Package and then From_With_Type (P_Name) then\n-         if From_With_Type (Id)\n+      if Ekind (P_Name) = E_Package and then From_Limited_With (P_Name) then\n+         if From_Limited_With (Id)\n            or else Is_Type (Id)\n            or else Ekind (Id) = E_Package\n          then\n@@ -6328,7 +6328,7 @@ package body Sem_Ch8 is\n                      --  tagged if the type itself has an untagged incomplete\n                      --  type view in its package.\n \n-                     if From_With_Type (T)\n+                     if From_Limited_With (T)\n                        and then not Is_Tagged_Type (Available_View (T))\n                      then\n                         Error_Msg_N\n@@ -6519,7 +6519,7 @@ package body Sem_Ch8 is\n             --  Ada 2005 (AI-251, AI-50217): Handle interfaces visible through\n             --  limited-with clauses\n \n-            if From_With_Type (T_Name)\n+            if From_Limited_With (T_Name)\n               and then Ekind (T_Name) in Incomplete_Kind\n               and then Present (Non_Limited_View (T_Name))\n               and then Is_Interface (Non_Limited_View (T_Name))\n@@ -7097,7 +7097,7 @@ package body Sem_Ch8 is\n            or else (Is_Private_Type (T1) and then Has_Discriminants (T1))\n            or else (Is_Task_Type (T1) and then Has_Discriminants (T1))\n            or else (Is_Incomplete_Type (T1)\n-                     and then From_With_Type (T1)\n+                     and then From_Limited_With (T1)\n                      and then Present (Non_Limited_View (T1))\n                      and then Is_Record_Type\n                                 (Get_Full_View (Non_Limited_View (T1))));\n@@ -7878,7 +7878,7 @@ package body Sem_Ch8 is\n \n       --  Ada 2005 (AI-50217): Check restriction\n \n-      if From_With_Type (P) then\n+      if From_Limited_With (P) then\n          Error_Msg_N (\"limited withed package cannot appear in use clause\", N);\n       end if;\n \n@@ -8201,7 +8201,7 @@ package body Sem_Ch8 is\n       --  a limited view unless we only have a limited view of its enclosing\n       --  package.\n \n-      elsif From_With_Type (T) and then From_With_Type (Scope (T)) then\n+      elsif From_Limited_With (T) and then From_Limited_With (Scope (T)) then\n          Error_Msg_N\n            (\"incomplete type from limited view \"\n             & \"cannot appear in use clause\", Id);"}, {"sha": "233e30168a23cd53434be3ca830aa04a9c7e8171", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -2277,6 +2277,12 @@ package body Sem_Dim is\n             Result := No_Rational;\n          end if;\n \n+         --  Provide minimal semantic information on dimension expressions,\n+         --  even though they have no run-time existence. This is for use by\n+         --  ASIS tools, in particular pretty-printing.\n+\n+         Set_Entity (N, Standard_Op_Minus);\n+         Set_Etype  (N, Standard_Integer);\n          return Result;\n       end Process_Minus;\n \n@@ -2302,6 +2308,12 @@ package body Sem_Dim is\n             Result := Left_Rat / Right_Rat;\n          end if;\n \n+         --  Provide minimal semantic information on dimension expressions,\n+         --  even though they have no run-time existence. This is for use by\n+         --  ASIS tools, in particular pretty-printing.\n+\n+         Set_Entity (N, Standard_Op_Divide);\n+         Set_Etype  (N, Standard_Integer);\n          return Result;\n       end Process_Divide;\n "}, {"sha": "7b815812a3263cca277c315b5366814a1eae6b09", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -331,7 +331,7 @@ package body Sem_Disp is\n \n          --  Ada 2005 (AI-50217)\n \n-         elsif From_With_Type (Designated_Type (T))\n+         elsif From_Limited_With (Designated_Type (T))\n            and then Present (Non_Limited_View (Designated_Type (T)))\n            and then Scope (Designated_Type (T)) = Scope (Subp)\n          then"}, {"sha": "15b13ffd605b81a5577b27d127ad95978c19c6a9", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -17218,6 +17218,14 @@ package body Sem_Prag is\n             Spec_Id : Entity_Id;\n \n          begin\n+            --  Disable the support for pragma Refined_Pre as its static and\n+            --  runtime semantics are still under heavy design.\n+\n+            if Pname = Name_Refined_Pre then\n+               Error_Pragma (\"pragma % is not supported\");\n+               return;\n+            end if;\n+\n             Analyze_Refined_Pragma (Spec_Id, Body_Id, Legal);\n \n             --  Analyze the boolean expression as a \"spec expression\""}, {"sha": "8b610126159486d92d19f4c8b64a49be360ec567", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -9858,7 +9858,7 @@ package body Sem_Res is\n \n                --  Ada 2005 (AI-217): Handle entities from limited views\n \n-               if From_With_Type (Opnd) then\n+               if From_Limited_With (Opnd) then\n                   Error_Msg_Qual_Level := 99;\n                   Error_Msg_NE -- CODEFIX\n                     (\"missing WITH clause on package &\", N,\n@@ -9867,7 +9867,7 @@ package body Sem_Res is\n                     (\"type conversions require visibility of the full view\",\n                      N);\n \n-               elsif From_With_Type (Target)\n+               elsif From_Limited_With (Target)\n                  and then not\n                    (Is_Access_Type (Target_Typ)\n                       and then Present (Non_Limited_View (Etype (Target))))\n@@ -10871,7 +10871,7 @@ package body Sem_Res is\n          --  it to determine whether the conversion is legal.\n \n          elsif Is_Class_Wide_Type (Opnd_Type)\n-           and then From_With_Type (Opnd_Type)\n+           and then From_Limited_With (Opnd_Type)\n            and then Present (Non_Limited_View (Etype (Opnd_Type)))\n            and then Is_Interface (Non_Limited_View (Etype (Opnd_Type)))\n          then\n@@ -11346,7 +11346,7 @@ package body Sem_Res is\n                --  Handle the limited view of a type\n \n                if Is_Incomplete_Type (Desig)\n-                 and then From_With_Type (Desig)\n+                 and then From_Limited_With (Desig)\n                  and then Present (Non_Limited_View (Desig))\n                then\n                   return Available_View (Desig);"}, {"sha": "8e0fd5fa80d98f30ff9ee0a27d4a190dbb65b8da", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1127,7 +1127,7 @@ package body Sem_Type is\n       then\n          return Covers (Designated_Type (T1), Designated_Type (T2))\n           or else\n-            (From_With_Type (Designated_Type (T1))\n+            (From_Limited_With (Designated_Type (T1))\n               and then Covers (Designated_Type (T2), Designated_Type (T1)));\n \n       --  A boolean operation on integer literals is compatible with modular\n@@ -1205,7 +1205,7 @@ package body Sem_Type is\n       --  Ada 2005 (AI-50217): Additional branches to make the shadow entity\n       --  obtained through a limited_with compatible with its real entity.\n \n-      elsif From_With_Type (T1) then\n+      elsif From_Limited_With (T1) then\n \n          --  If the expected type is the non-limited view of a type, the\n          --  expression may have the limited view. If that one in turn is\n@@ -1221,7 +1221,7 @@ package body Sem_Type is\n             return False;\n          end if;\n \n-      elsif From_With_Type (T2) then\n+      elsif From_Limited_With (T2) then\n \n          --  If units in the context have Limited_With clauses on each other,\n          --  either type might have a limited view. Checks performed elsewhere"}, {"sha": "15e6a641a06ebacc06306ed6087a9442e901eff5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -1445,7 +1445,7 @@ package body Sem_Util is\n          --  Ada 2005 (AI-50217): If the type is available through a limited\n          --  with_clause, verify that its full view has been analyzed.\n \n-         if From_With_Type (T)\n+         if From_Limited_With (T)\n            and then Present (Non_Limited_View (T))\n            and then Ekind (Non_Limited_View (T)) /= E_Incomplete_Type\n          then\n@@ -9150,7 +9150,7 @@ package body Sem_Util is\n    begin\n       return\n         Is_Class_Wide_Type (Typ)\n-          and then (Is_Limited_Type (Typ) or else From_With_Type (Typ));\n+          and then (Is_Limited_Type (Typ) or else From_Limited_With (Typ));\n    end Is_Limited_Class_Wide_Type;\n \n    ---------------------------------\n@@ -15419,7 +15419,7 @@ package body Sem_Util is\n               (\"\\\\found an access type with designated}!\",\n                 Expr, Designated_Type (Found_Type));\n          else\n-            if From_With_Type (Found_Type) then\n+            if From_Limited_With (Found_Type) then\n                Error_Msg_NE (\"\\\\found incomplete}!\", Expr, Found_Type);\n                Error_Msg_Qual_Level := 99;\n                Error_Msg_NE -- CODEFIX"}, {"sha": "493c5e4f517dd26a34c702fc9ba1dac98bd8bdd6", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b56a91b90d4fba29abe58603373a67cc8ad5358/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=7b56a91b90d4fba29abe58603373a67cc8ad5358", "patch": "@@ -2434,7 +2434,7 @@ package body Sem_Warn is\n                           or else Referenced_As_LHS_Check_Spec (Ent)\n                           or else Referenced_As_Out_Parameter_Check_Spec (Ent)\n                           or else\n-                            (From_With_Type (Ent)\n+                            (From_Limited_With (Ent)\n                               and then Is_Incomplete_Type (Ent)\n                               and then Present (Non_Limited_View (Ent))\n                               and then Referenced (Non_Limited_View (Ent)))"}]}