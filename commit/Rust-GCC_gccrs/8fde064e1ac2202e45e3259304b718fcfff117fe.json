{"sha": "8fde064e1ac2202e45e3259304b718fcfff117fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkZTA2NGUxYWMyMjAyZTQ1ZTMyNTkzMDRiNzE4ZmNmZmYxMTdmZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T09:34:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T09:34:38Z"}, "message": "[multiple changes]\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.ads: Minor reformatting.\n\t* sem_eval.adb (Why_Not_Static): Now issues continuation messages\n\t(Why_Not_Static): Test for aggregates behind string literals.\n\t* sem_eval.ads (Why_Not_Static): Now issues continuation messages.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenation): Wrap expansion in\n\tExpressions_With_Actions.\n\n2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Base_Types_Match): For an actual type in an\n\tinstance, the base type may itself be a subtype, so find true\n\tbase type to determine compatibility.\n\nFrom-SVN: r197745", "tree": {"sha": "c6a67e5823b05f4b5240ea682c04450ce56d2362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6a67e5823b05f4b5240ea682c04450ce56d2362"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fde064e1ac2202e45e3259304b718fcfff117fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fde064e1ac2202e45e3259304b718fcfff117fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fde064e1ac2202e45e3259304b718fcfff117fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fde064e1ac2202e45e3259304b718fcfff117fe/comments", "author": null, "committer": null, "parents": [{"sha": "354c3840c8ff64c615c7365c5b0c1b04d2a38189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354c3840c8ff64c615c7365c5b0c1b04d2a38189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354c3840c8ff64c615c7365c5b0c1b04d2a38189"}], "stats": {"total": 478, "additions": 285, "deletions": 193}, "files": [{"sha": "d72ad62485d1cdb751da459a7e8707f36c43206a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8fde064e1ac2202e45e3259304b718fcfff117fe", "patch": "@@ -1,3 +1,21 @@\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* errout.ads: Minor reformatting.\n+\t* sem_eval.adb (Why_Not_Static): Now issues continuation messages\n+\t(Why_Not_Static): Test for aggregates behind string literals.\n+\t* sem_eval.ads (Why_Not_Static): Now issues continuation messages.\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenation): Wrap expansion in\n+\tExpressions_With_Actions.\n+\n+2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Base_Types_Match): For an actual type in an\n+\tinstance, the base type may itself be a subtype, so find true\n+\tbase type to determine compatibility.\n+\n 2013-04-11  Robert Dewar  <dewar@adacore.com>\n \n \t* s-osprim-mingw.adb, sem_ch3.adb, sem_prag.adb, sem_util.adb."}, {"sha": "1e95b173f5a1c1f54c796f966fd201474d0f8fb1", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=8fde064e1ac2202e45e3259304b718fcfff117fe", "patch": "@@ -242,7 +242,7 @@ package Errout is\n    --      messages starting with the \\ insertion character). The effect of the\n    --      use of ! in a parent message automatically applies to all of its\n    --      continuation messages (since we clearly don't want any case in which\n-   --      continuations are separated from the parent message. It is allowable\n+   --      continuations are separated from the main message). It is allowable\n    --      to put ! in continuation messages, and the usual style is to include\n    --      it, since it makes it clear that the continuation is part of an\n    --      unconditional message."}, {"sha": "c20c8568eafadbd5f1f7f5b0eda584d7fa6e71de", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8fde064e1ac2202e45e3259304b718fcfff117fe", "patch": "@@ -3017,6 +3017,8 @@ package body Exp_Ch4 is\n \n    --  Start of processing for Expand_Concatenate\n \n+   --  Kirtchev\n+\n    begin\n       --  Choose an appropriate computational type\n \n@@ -3233,7 +3235,6 @@ package body Exp_Ch4 is\n                    Prefix         =>\n                      Duplicate_Subexpr (Opnd, Name_Req => True),\n                    Attribute_Name => Name_First);\n-               Set_Parent (Opnd_Low_Bound (NN), Opnd);\n \n                --  Capture last operand bounds if result could be null\n \n@@ -3244,15 +3245,13 @@ package body Exp_Ch4 is\n                         Prefix         =>\n                           Duplicate_Subexpr (Opnd, Name_Req => True),\n                         Attribute_Name => Name_First));\n-                  Set_Parent (Last_Opnd_Low_Bound, Opnd);\n \n                   Last_Opnd_High_Bound :=\n                     Convert_To (Ityp,\n                       Make_Attribute_Reference (Loc,\n                         Prefix         =>\n                           Duplicate_Subexpr (Opnd, Name_Req => True),\n                         Attribute_Name => Name_Last));\n-                  Set_Parent (Last_Opnd_High_Bound, Opnd);\n                end if;\n \n                --  Capture length of operand in entity\n@@ -5182,6 +5181,10 @@ package body Exp_Ch4 is\n                Desig_Typ := Obj_Typ;\n             end if;\n \n+            --  Kirtchev J730-020\n+\n+            Desig_Typ := Base_Type (Desig_Typ);\n+\n             --  Generate:\n             --    Ann : access [all] <Desig_Typ>;\n \n@@ -6721,6 +6724,8 @@ package body Exp_Ch4 is\n       --  Node which is to be replaced by the result of concatenating the nodes\n       --  in the list Opnds.\n \n+   --  Kirtchev\n+\n    begin\n       --  Ensure validity of both operands\n \n@@ -6748,7 +6753,6 @@ package body Exp_Ch4 is\n \n       --  Now Cnode is the deepest concatenation, and its parents are the\n       --  concatenation nodes above, so now we process bottom up, doing the\n-      --  operations. We gather a string that is as long as possible up to five\n       --  operands.\n \n       --  The outer loop runs more than once if more than one concatenation\n@@ -6768,7 +6772,27 @@ package body Exp_Ch4 is\n             Append (Right_Opnd (Cnode), Opnds);\n          end loop Inner;\n \n-         Expand_Concatenate (Cnode, Opnds);\n+         --  Wrap the node to concatenate into an expression actions node to\n+         --  keep it nicely packaged. This is useful in the case of an assert\n+         --  pragma with a concatenation where we want to be able to delete\n+         --  the concatenation and all its expansion stuff.\n+\n+         declare\n+            Cnod : constant Node_Id   := Relocate_Node (Cnode);\n+            Typ  : constant Entity_Id := Base_Type (Etype (Cnode));\n+\n+         begin\n+            --  Note: use Rewrite rather than Replace here, so that for example\n+            --  Why_Not_Static can find the original concatenation node OK!\n+\n+            Rewrite (Cnode,\n+              Make_Expression_With_Actions (Sloc (Cnode),\n+                Actions    => New_List (Make_Null_Statement (Sloc (Cnode))),\n+                Expression => Cnod));\n+\n+            Expand_Concatenate (Cnod, Opnds);\n+            Analyze_And_Resolve (Cnode, Typ);\n+         end;\n \n          exit Outer when Cnode = N;\n          Cnode := Parent (Cnode);"}, {"sha": "7b31ff572e6ae8857723a8170bc028347a9b4437", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 105, "deletions": 137, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8fde064e1ac2202e45e3259304b718fcfff117fe", "patch": "@@ -362,9 +362,7 @@ package body Sem_Ch6 is\n          Analyze (New_Body);\n          Set_Is_Inlined (Prev);\n \n-      elsif Present (Prev)\n-        and then Comes_From_Source (Prev)\n-      then\n+      elsif Present (Prev) and then Comes_From_Source (Prev) then\n          Set_Has_Completion (Prev, False);\n \n          --  For navigation purposes, indicate that the function is a body\n@@ -436,9 +434,9 @@ package body Sem_Ch6 is\n \n          begin\n             if Nkind (Par) = N_Package_Specification\n-               and then Decls = Visible_Declarations (Par)\n-               and then Present (Private_Declarations (Par))\n-               and then not Is_Empty_List (Private_Declarations (Par))\n+              and then Decls = Visible_Declarations (Par)\n+              and then Present (Private_Declarations (Par))\n+              and then not Is_Empty_List (Private_Declarations (Par))\n             then\n                Decls := Private_Declarations (Par);\n             end if;\n@@ -882,7 +880,7 @@ package body Sem_Ch6 is\n \n       if Present (Expr)\n \n-         --  Defend against previous errors\n+        --  Defend against previous errors\n \n         and then Nkind (Expr) /= N_Empty\n         and then Present (Etype (Expr))\n@@ -1220,7 +1218,7 @@ package body Sem_Ch6 is\n \n    begin\n       if        (Nkind (Par) = N_Function_Call\n-                   and then N = Name (Par))\n+                  and then N = Name (Par))\n         or else  Nkind (Par) = N_Function_Instantiation\n         or else (Nkind (Par) = N_Indexed_Component\n                    and then N = Prefix (Par))\n@@ -1322,8 +1320,8 @@ package body Sem_Ch6 is\n       --  Special processing for Elab_Spec, Elab_Body and Elab_Subp_Body calls\n \n       if Nkind (P) = N_Attribute_Reference\n-        and then (Attribute_Name (P) = Name_Elab_Spec or else\n-                  Attribute_Name (P) = Name_Elab_Body or else\n+        and then (Attribute_Name (P) = Name_Elab_Spec      or else\n+                  Attribute_Name (P) = Name_Elab_Body      or else\n                   Attribute_Name (P) = Name_Elab_Subp_Body)\n       then\n          if Present (Actuals) then\n@@ -1410,11 +1408,9 @@ package body Sem_Ch6 is\n       --  function, the context will select the operation whose type is Void.\n \n       elsif Nkind (P) = N_Selected_Component\n-        and then (Ekind (Entity (Selector_Name (P))) = E_Entry\n-                    or else\n-                  Ekind (Entity (Selector_Name (P))) = E_Procedure\n-                    or else\n-                  Ekind (Entity (Selector_Name (P))) = E_Function)\n+        and then Ekind_In (Entity (Selector_Name (P)), E_Entry,\n+                                                       E_Procedure,\n+                                                       E_Function)\n       then\n          Analyze_Call_And_Resolve;\n \n@@ -1490,8 +1486,8 @@ package body Sem_Ch6 is\n       Returns_Object : constant Boolean :=\n                          Nkind (N) = N_Extended_Return_Statement\n                            or else\n-                            (Nkind (N) = N_Simple_Return_Statement\n-                              and then Present (Expression (N)));\n+                             (Nkind (N) = N_Simple_Return_Statement\n+                               and then Present (Expression (N)));\n       --  True if we're returning something; that is, \"return <expression>;\"\n       --  or \"return Result : T [:= ...]\". False for \"return;\". Used for error\n       --  checking: If Returns_Object is True, N should apply to a function\n@@ -1685,9 +1681,7 @@ package body Sem_Ch6 is\n \n             --  Unconstrained array as result is not allowed in SPARK\n \n-            if Is_Array_Type (Typ)\n-              and then not Is_Constrained (Typ)\n-            then\n+            if Is_Array_Type (Typ) and then not Is_Constrained (Typ) then\n                Check_SPARK_Restriction\n                  (\"returning an unconstrained array is not allowed\",\n                   Result_Definition (N));\n@@ -1703,9 +1697,7 @@ package body Sem_Ch6 is\n             --  right before this, because they don't get applied to types that\n             --  do not come from source.\n \n-            if Is_Access_Type (Typ)\n-              and then Null_Exclusion_Present (N)\n-            then\n+            if Is_Access_Type (Typ) and then Null_Exclusion_Present (N) then\n                Set_Etype  (Designator,\n                  Create_Null_Excluding_Itype\n                   (T           => Typ,\n@@ -1752,8 +1744,7 @@ package body Sem_Ch6 is\n \n             elsif Ekind (Typ) = E_Incomplete_Type\n               or else (Is_Class_Wide_Type (Typ)\n-                         and then\n-                           Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n+                         and then Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n             then\n                --  AI05-0151: Tagged incomplete types are allowed in all formal\n                --  parts. Untagged incomplete types are not allowed in bodies.\n@@ -1952,7 +1943,7 @@ package body Sem_Ch6 is\n                         Is_Limited_Record (Designated_Type (Etype (Scop)))))\n            and then Expander_Active\n \n-            --  Avoid cases with no tasking support\n+           --  Avoid cases with no tasking support\n \n            and then RTE_Available (RE_Current_Master)\n            and then not Restriction_Active (No_Task_Hierarchy)\n@@ -2019,14 +2010,14 @@ package body Sem_Ch6 is\n             return\n               Nkind (N) = N_Pragma\n                 and then\n-                   (Pragma_Name (N) = Name_Inline_Always\n-                     or else\n+                  (Pragma_Name (N) = Name_Inline_Always\n+                    or else\n                       (Front_End_Inlining\n                         and then Pragma_Name (N) = Name_Inline))\n                 and then\n-                   Chars\n-                     (Expression (First (Pragma_Argument_Associations (N))))\n-                        = Chars (Body_Id);\n+                  Chars\n+                    (Expression (First (Pragma_Argument_Associations (N)))) =\n+                                                              Chars (Body_Id);\n          end Is_Inline_Pragma;\n \n       --  Start of processing for Check_Inline_Pragma\n@@ -2490,9 +2481,7 @@ package body Sem_Ch6 is\n       --  part of the context of one of its subunits. No need to redo the\n       --  analysis.\n \n-      elsif Prev_Id = Body_Id\n-        and then Has_Completion (Body_Id)\n-      then\n+      elsif Prev_Id = Body_Id and then Has_Completion (Body_Id) then\n          return;\n \n       else\n@@ -2658,8 +2647,8 @@ package body Sem_Ch6 is\n                 (Nkind (Original_Node (Spec_Decl)) =\n                                         N_Subprogram_Renaming_Declaration\n                    or else (Present (Corresponding_Body (Spec_Decl))\n-                              and then\n-                                Nkind (Unit_Declaration_Node\n+                             and then\n+                               Nkind (Unit_Declaration_Node\n                                         (Corresponding_Body (Spec_Decl))) =\n                                            N_Subprogram_Renaming_Declaration))\n             then\n@@ -2821,9 +2810,7 @@ package body Sem_Ch6 is\n       --  is the limited view of a class-wide type and the non-limited view is\n       --  available, update the return type accordingly.\n \n-      if Ada_Version >= Ada_2005\n-        and then Comes_From_Source (N)\n-      then\n+      if Ada_Version >= Ada_2005 and then Comes_From_Source (N) then\n          declare\n             Etyp : Entity_Id;\n             Rtyp : Entity_Id;\n@@ -2834,9 +2821,7 @@ package body Sem_Ch6 is\n             if Ekind (Rtyp) = E_Anonymous_Access_Type then\n                Etyp := Directly_Designated_Type (Rtyp);\n \n-               if Is_Class_Wide_Type (Etyp)\n-                 and then From_With_Type (Etyp)\n-               then\n+               if Is_Class_Wide_Type (Etyp) and then From_With_Type (Etyp) then\n                   Set_Directly_Designated_Type\n                     (Etype (Current_Scope), Available_View (Etyp));\n                end if;\n@@ -2898,7 +2883,7 @@ package body Sem_Ch6 is\n            and then Expander_Active\n            and then\n              (Has_Pragma_Inline_Always (Spec_Id)\n-                or else (Has_Pragma_Inline (Spec_Id) and Front_End_Inlining))\n+               or else (Has_Pragma_Inline (Spec_Id) and Front_End_Inlining))\n          then\n             Build_Body_To_Inline (N, Spec_Id);\n          end if;\n@@ -3373,7 +3358,7 @@ package body Sem_Ch6 is\n             if Is_Interface (Etyp)\n               and then not Is_Abstract_Subprogram (Designator)\n               and then not (Ekind (Designator) = E_Procedure\n-                              and then Null_Present (Specification (N)))\n+                             and then Null_Present (Specification (N)))\n             then\n                Error_Msg_Name_1 := Chars (Defining_Entity (N));\n \n@@ -3401,10 +3386,9 @@ package body Sem_Ch6 is\n          Set_Kill_Elaboration_Checks (Designator);\n       end if;\n \n-      if Scop /= Standard_Standard\n-        and then not Is_Child_Unit (Designator)\n-      then\n+      if Scop /= Standard_Standard and then not Is_Child_Unit (Designator) then\n          Set_Categorization_From_Scope (Designator, Scop);\n+\n       else\n          --  For a compilation unit, check for library-unit pragmas\n \n@@ -3890,7 +3874,7 @@ package body Sem_Ch6 is\n \n                elsif No (Expression (N))\n                  and then Nkind (Parent (Parent (N))) =\n-                 N_Extended_Return_Statement\n+                                         N_Extended_Return_Statement\n                then\n                   return OK;\n \n@@ -3932,7 +3916,7 @@ package body Sem_Ch6 is\n             return Present (Declarations (N))\n               and then Present (First (Declarations (N)))\n               and then Chars (Expression (Return_Statement)) =\n-                 Chars (Defining_Identifier (First (Declarations (N))));\n+                       Chars (Defining_Identifier (First (Declarations (N))));\n          end if;\n       end Has_Single_Return;\n \n@@ -4809,8 +4793,8 @@ package body Sem_Ch6 is\n          May_Inline : constant Boolean :=\n                         Has_Pragma_Inline_Always (Spec_Id)\n                           or else (Has_Pragma_Inline (Spec_Id)\n-                                     and then ((Optimization_Level > 0\n-                                                  and then Ekind (Spec_Id)\n+                                    and then ((Optimization_Level > 0\n+                                                and then Ekind (Spec_Id)\n                                                              = E_Function)\n                                                or else Front_End_Inlining));\n          Body_To_Analyze : Node_Id;\n@@ -5493,10 +5477,9 @@ package body Sem_Ch6 is\n          if Ada_Version >= Ada_2005\n            and then Ekind (Etype (Old_Type)) = E_Anonymous_Access_Type\n            and then\n-             (Can_Never_Be_Null (Old_Type)\n-                /= Can_Never_Be_Null (New_Type)\n-              or else Is_Access_Constant (Etype (Old_Type))\n-                        /= Is_Access_Constant (Etype (New_Type)))\n+             (Can_Never_Be_Null (Old_Type) /= Can_Never_Be_Null (New_Type)\n+               or else Is_Access_Constant (Etype (Old_Type)) /=\n+                       Is_Access_Constant (Etype (New_Type)))\n          then\n             Conformance_Error (\"\\return type does not match!\", New_Id);\n             return;\n@@ -5519,7 +5502,6 @@ package body Sem_Ch6 is\n \n       if Ctype >= Subtype_Conformant then\n          if Convention (Old_Id) /= Convention (New_Id) then\n-\n             if not Is_Frozen (New_Id) then\n                null;\n \n@@ -5646,35 +5628,35 @@ package body Sem_Ch6 is\n \n          Access_Types_Match := Ada_Version >= Ada_2005\n \n-            --  Ensure that this rule is only applied when New_Id is a\n-            --  renaming of Old_Id.\n+           --  Ensure that this rule is only applied when New_Id is a\n+           --  renaming of Old_Id.\n \n            and then Nkind (Parent (Parent (New_Id))) =\n                       N_Subprogram_Renaming_Declaration\n            and then Nkind (Name (Parent (Parent (New_Id)))) in N_Has_Entity\n            and then Present (Entity (Name (Parent (Parent (New_Id)))))\n            and then Entity (Name (Parent (Parent (New_Id)))) = Old_Id\n \n-            --  Now handle the allowed access-type case\n+           --  Now handle the allowed access-type case\n \n            and then Is_Access_Type (Old_Formal_Base)\n            and then Is_Access_Type (New_Formal_Base)\n \n-            --  The type kinds must match. The only exception occurs with\n-            --  multiple generics of the form:\n+           --  The type kinds must match. The only exception occurs with\n+           --  multiple generics of the form:\n \n-            --   generic                    generic\n-            --     type F is private;         type A is private;\n-            --     type F_Ptr is access F;    type A_Ptr is access A;\n-            --     with proc F_P (X : F_Ptr); with proc A_P (X : A_Ptr);\n-            --   package F_Pack is ...      package A_Pack is\n-            --                                package F_Inst is\n-            --                                  new F_Pack (A, A_Ptr, A_P);\n+           --   generic                    generic\n+           --     type F is private;         type A is private;\n+           --     type F_Ptr is access F;    type A_Ptr is access A;\n+           --     with proc F_P (X : F_Ptr); with proc A_P (X : A_Ptr);\n+           --   package F_Pack is ...      package A_Pack is\n+           --                                package F_Inst is\n+           --                                  new F_Pack (A, A_Ptr, A_P);\n \n-            --  When checking for conformance between the parameters of A_P\n-            --  and F_P, the type kinds of F_Ptr and A_Ptr will not match\n-            --  because the compiler has transformed A_Ptr into a subtype of\n-            --  F_Ptr. We catch this case in the code below.\n+           --  When checking for conformance between the parameters of A_P\n+           --  and F_P, the type kinds of F_Ptr and A_Ptr will not match\n+           --  because the compiler has transformed A_Ptr into a subtype of\n+           --  F_Ptr. We catch this case in the code below.\n \n            and then (Ekind (Old_Formal_Base) = Ekind (New_Formal_Base)\n                   or else\n@@ -5684,7 +5666,7 @@ package body Sem_Ch6 is\n                        and then Etype (Etype (New_Formal_Base)) =\n                                   Old_Formal_Base))\n            and then Directly_Designated_Type (Old_Formal_Base) =\n-                      Directly_Designated_Type (New_Formal_Base)\n+                    Directly_Designated_Type (New_Formal_Base)\n            and then ((Is_Itype (Old_Formal_Base)\n                        and then Can_Never_Be_Null (Old_Formal_Base))\n                     or else\n@@ -6116,17 +6098,13 @@ package body Sem_Ch6 is\n       --  done for delayed_freeze subprograms because the underlying\n       --  returned type may not be known yet (for private types)\n \n-      if not Has_Delayed_Freeze (Designator)\n-        and then Expander_Active\n-      then\n+      if not Has_Delayed_Freeze (Designator) and then Expander_Active then\n          declare\n             Typ  : constant Entity_Id := Etype (Designator);\n             Utyp : constant Entity_Id := Underlying_Type (Typ);\n-\n          begin\n             if Is_Immutably_Limited_Type (Typ) then\n                Set_Returns_By_Ref (Designator);\n-\n             elsif Present (Utyp) and then CW_Or_Has_Controlled_Part (Utyp) then\n                Set_Returns_By_Ref (Designator);\n             end if;\n@@ -6190,7 +6168,7 @@ package body Sem_Ch6 is\n             --  with partial declaration.\n \n             if Is_Access_Type (New_Discr_Type)\n-                 and then Null_Exclusion_Present (New_Discr)\n+              and then Null_Exclusion_Present (New_Discr)\n             then\n                New_Discr_Type :=\n                  Create_Null_Excluding_Itype\n@@ -6678,9 +6656,7 @@ package body Sem_Ch6 is\n          --  sequences (which were the original sequences of statements in\n          --  the exception handlers) and check them.\n \n-         if Nkind (Last_Stm) = N_Label\n-           and then Exception_Junk (Last_Stm)\n-         then\n+         if Nkind (Last_Stm) = N_Label and then Exception_Junk (Last_Stm) then\n             Stm := Last_Stm;\n             loop\n                Prev (Stm);\n@@ -6721,7 +6697,7 @@ package body Sem_Ch6 is\n              (Nkind_In (Last_Stm, N_Goto_Statement,\n                                    N_Label,\n                                    N_Object_Declaration)\n-                and then Exception_Junk (Last_Stm))\n+               and then Exception_Junk (Last_Stm))\n            or else Nkind (Last_Stm) in N_Push_xxx_Label\n            or else Nkind (Last_Stm) in N_Pop_xxx_Label\n \n@@ -7511,11 +7487,14 @@ package body Sem_Ch6 is\n       ----------------------\n \n       function Base_Types_Match (T1, T2 : Entity_Id) return Boolean is\n+         BT1 : constant Entity_Id := Base_Type (T1);\n+         BT2 : constant Entity_Id := Base_Type (T2);\n+\n       begin\n          if T1 = T2 then\n             return True;\n \n-         elsif Base_Type (T1) = Base_Type (T2) then\n+         elsif BT1 = BT2 then\n \n             --  The following is too permissive. A more precise test should\n             --  check that the generic actual is an ancestor subtype of the\n@@ -7528,6 +7507,16 @@ package body Sem_Ch6 is\n               or else not Is_Generic_Actual_Type (T2)\n               or else Scope (T1) /= Scope (T2);\n \n+         --  If T2 is a generic actual type it is declared as the subtype of\n+         --  the actual.  If that actual is itself a subtype we need to use\n+         --  its own base type to check for compatibility.\n+\n+         elsif Ekind (BT2) = Ekind (T2) and then BT1 = Base_Type (BT2) then\n+            return True;\n+\n+         elsif Ekind (BT1) = Ekind (T1) and then BT2 = Base_Type (BT1) then\n+            return True;\n+\n          else\n             return False;\n          end if;\n@@ -7572,14 +7561,10 @@ package body Sem_Ch6 is\n          --  access-to-class-wide type in a formal. Both entities designate the\n          --  same type.\n \n-         if From_With_Type (T1)\n-           and then T2 = Available_View (T1)\n-         then\n+         if From_With_Type (T1) and then T2 = Available_View (T1) then\n             return True;\n \n-         elsif From_With_Type (T2)\n-           and then T1 = Available_View (T2)\n-         then\n+         elsif From_With_Type (T2) and then T1 = Available_View (T2) then\n             return True;\n \n          elsif From_With_Type (T1)\n@@ -7596,10 +7581,9 @@ package body Sem_Ch6 is\n    --  Start of processing for Conforming_Types\n \n    begin\n-      --  The context is an instance association for a formal\n-      --  access-to-subprogram type; the formal parameter types require\n-      --  mapping because they may denote other formal parameters of the\n-      --  generic unit.\n+      --  The context is an instance association for a formal access-to-\n+      --  subprogram type; the formal parameter types require mapping because\n+      --  they may denote other formal parameters of the generic unit.\n \n       if Get_Inst then\n          Type_1 := Get_Instance_Of (T1);\n@@ -7645,9 +7629,8 @@ package body Sem_Ch6 is\n       Are_Anonymous_Access_To_Subprogram_Types :=\n         Ekind (Type_1) = Ekind (Type_2)\n           and then\n-            (Ekind (Type_1) = E_Anonymous_Access_Subprogram_Type\n-             or else\n-               Ekind (Type_1) = E_Anonymous_Access_Protected_Subprogram_Type);\n+            Ekind_In (Type_1, E_Anonymous_Access_Subprogram_Type,\n+                              E_Anonymous_Access_Protected_Subprogram_Type);\n \n       --  Test anonymous access type case. For this case, static subtype\n       --  matching is required for mode conformance (RM 6.3.1(15)). We check\n@@ -7657,7 +7640,10 @@ package body Sem_Ch6 is\n       if (Ekind (Base_Type (Type_1)) = E_Anonymous_Access_Type\n             and then\n           Ekind (Base_Type (Type_2)) = E_Anonymous_Access_Type)\n-        or else Are_Anonymous_Access_To_Subprogram_Types -- Ada 2005 (AI-254)\n+\n+        -- Ada 2005 (AI-254)\n+\n+        or else Are_Anonymous_Access_To_Subprogram_Types\n       then\n          declare\n             Desig_1 : Entity_Id;\n@@ -7725,8 +7711,8 @@ package body Sem_Ch6 is\n             else\n                return Base_Type (Desig_1) = Base_Type (Desig_2)\n                 and then (Ctype = Type_Conformant\n-                            or else\n-                          Subtypes_Statically_Match (Desig_1, Desig_2));\n+                           or else\n+                             Subtypes_Statically_Match (Desig_1, Desig_2));\n             end if;\n          end;\n \n@@ -7736,7 +7722,7 @@ package body Sem_Ch6 is\n          if ((Ekind (Type_1) = E_Anonymous_Access_Type\n                and then Is_Access_Type (Type_2))\n             or else (Ekind (Type_2) = E_Anonymous_Access_Type\n-                       and then Is_Access_Type (Type_1)))\n+                      and then Is_Access_Type (Type_1)))\n            and then\n              Conforming_Types\n                (Designated_Type (Type_1), Designated_Type (Type_2), Ctype)\n@@ -7826,8 +7812,8 @@ package body Sem_Ch6 is\n    --  Start of processing for Create_Extra_Formals\n \n    begin\n-      --  We never generate extra formals if expansion is not active\n-      --  because we don't need them unless we are generating code.\n+      --  We never generate extra formals if expansion is not active because we\n+      --  don't need them unless we are generating code.\n \n       if not Expander_Active then\n          return;\n@@ -7852,9 +7838,7 @@ package body Sem_Ch6 is\n       --  situation may arise for subprogram types created as part of\n       --  dispatching calls (see Expand_Dispatching_Call)\n \n-      if Present (Last_Extra) and then\n-        Present (Extra_Formal (Last_Extra))\n-      then\n+      if Present (Last_Extra) and then Present (Extra_Formal (Last_Extra)) then\n          return;\n       end if;\n \n@@ -8093,9 +8077,7 @@ package body Sem_Ch6 is\n       --  Chain new entity if front of homonym in current scope, so that\n       --  homonyms are contiguous.\n \n-      if Present (E)\n-        and then E /= C_E\n-      then\n+      if Present (E) and then E /= C_E then\n          while Homonym (C_E) /= E loop\n             C_E := Homonym (C_E);\n          end loop;\n@@ -8606,14 +8588,10 @@ package body Sem_Ch6 is\n          return Nkind (Selector_Name (E1)) = N_Character_Literal\n            and then Chars (E2) = Chars (Selector_Name (E1));\n \n-      elsif Nkind (E1) in N_Op\n-        and then Nkind (E2) = N_Function_Call\n-      then\n+      elsif Nkind (E1) in N_Op and then Nkind (E2) = N_Function_Call then\n          return FCO (E1, E2);\n \n-      elsif Nkind (E2) in N_Op\n-        and then Nkind (E1) = N_Function_Call\n-      then\n+      elsif Nkind (E2) in N_Op and then Nkind (E1) = N_Function_Call then\n          return FCO (E2, E1);\n \n       --  Otherwise we must have the same syntactic entity\n@@ -9319,8 +9297,8 @@ package body Sem_Ch6 is\n                        and then No (N_Formal)\n                        and then (Ekind (New_E) /= E_Function\n                                   or else\n-                                 Types_Correspond\n-                                   (Etype (P_Prim), Etype (New_E)))\n+                                    Types_Correspond\n+                                      (Etype (P_Prim), Etype (New_E)))\n                      then\n                         return False;\n                      end if;\n@@ -9615,12 +9593,8 @@ package body Sem_Ch6 is\n                     (\"abstract subprograms must be visible \"\n                      & \"(RM 3.9.3(10))!\", S);\n \n-               elsif Ekind (S) = E_Function\n-                 and then not Is_Overriding\n-               then\n-                  if Is_Tagged_Type (T)\n-                    and then T = Base_Type (Etype (S))\n-                  then\n+               elsif Ekind (S) = E_Function and then not Is_Overriding then\n+                  if Is_Tagged_Type (T) and then T = Base_Type (Etype (S)) then\n                      Error_Msg_N\n                        (\"private function with tagged result must\"\n                         & \" override visible-part function\", S);\n@@ -10038,7 +10012,7 @@ package body Sem_Ch6 is\n                --  interface procedures.\n \n                elsif (Ekind (Def_Id) = E_Procedure\n-                        or else Ekind (Def_Id) = E_Entry)\n+                       or else Ekind (Def_Id) = E_Entry)\n                  and then Ekind (Subp) = E_Procedure\n                  and then Matches_Prefixed_View_Profile\n                             (Parameter_Specifications (Parent (Def_Id)),\n@@ -10059,13 +10033,12 @@ package body Sem_Ch6 is\n                      --  routine must be of mode \"out\", \"in out\" or\n                      --  access-to-variable.\n \n-                     if (Ekind (Candidate) = E_Entry\n-                         or else Ekind (Candidate) = E_Procedure)\n+                     if Ekind_In (Candidate, E_Entry, E_Procedure)\n                        and then Is_Protected_Type (Typ)\n                        and then Ekind (Formal) /= E_In_Out_Parameter\n                        and then Ekind (Formal) /= E_Out_Parameter\n-                       and then Nkind (Parameter_Type (Parent (Formal)))\n-                                  /= N_Access_Definition\n+                       and then Nkind (Parameter_Type (Parent (Formal))) /=\n+                                                          N_Access_Definition\n                      then\n                         null;\n \n@@ -10453,9 +10426,7 @@ package body Sem_Ch6 is\n \n                   begin\n                      Prev := First_Entity (Current_Scope);\n-                     while Present (Prev)\n-                       and then Next_Entity (Prev) /= E\n-                     loop\n+                     while Present (Prev) and then Next_Entity (Prev) /= E loop\n                         Next_Entity (Prev);\n                      end loop;\n \n@@ -10798,8 +10769,7 @@ package body Sem_Ch6 is\n          end if;\n \n          return\n-           Ekind (Desig) = E_Incomplete_Type\n-             and then From_With_Type (Desig);\n+           Ekind (Desig) = E_Incomplete_Type and then From_With_Type (Desig);\n       end Designates_From_With_Type;\n \n       ---------------------------\n@@ -10842,7 +10812,7 @@ package body Sem_Ch6 is\n             if Is_Incomplete_Type (Formal_Type)\n               or else\n                (Is_Class_Wide_Type (Formal_Type)\n-                  and then Is_Incomplete_Type (Root_Type (Formal_Type)))\n+                 and then Is_Incomplete_Type (Root_Type (Formal_Type)))\n             then\n                --  Ada 2005 (AI-326): Tagged incomplete types allowed in\n                --  primitive operations, as long as their completion is\n@@ -12515,9 +12485,7 @@ package body Sem_Ch6 is\n       --  If this is an empty initialization procedure, no need to create\n       --  actual subtypes (small optimization).\n \n-      if Ekind (Subp) = E_Procedure\n-        and then Is_Null_Init_Proc (Subp)\n-      then\n+      if Ekind (Subp) = E_Procedure and then Is_Null_Init_Proc (Subp) then\n          return;\n       end if;\n "}, {"sha": "254f47a9a15410bf3ee5e83025cfde4bfd5238fb", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 120, "deletions": 38, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=8fde064e1ac2202e45e3259304b718fcfff117fe", "patch": "@@ -5495,8 +5495,8 @@ package body Sem_Eval is\n \n          if Raises_Constraint_Error (Expr) then\n             Error_Msg_N\n-              (\"expression raises exception, cannot be static \" &\n-               \"(RM 4.9(34))!\", N);\n+              (\"\\expression raises exception, cannot be static \" &\n+               \"(RM 4.9(34))\", N);\n             return;\n          end if;\n \n@@ -5516,46 +5516,103 @@ package body Sem_Eval is\n            and then not Is_RTE (Typ, RE_Bignum)\n          then\n             Error_Msg_N\n-              (\"static expression must have scalar or string type \" &\n-               \"(RM 4.9(2))!\", N);\n+              (\"\\static expression must have scalar or string type \" &\n+               \"(RM 4.9(2))\", N);\n             return;\n          end if;\n       end if;\n \n       --  If we got through those checks, test particular node kind\n \n       case Nkind (N) is\n+\n+         --  Entity name\n+\n          when N_Expanded_Name | N_Identifier | N_Operator_Symbol =>\n             E := Entity (N);\n \n             if Is_Named_Number (E) then\n                null;\n \n             elsif Ekind (E) = E_Constant then\n-               if not Is_Static_Expression (Constant_Value (E)) then\n-                  Error_Msg_NE\n-                    (\"& is not a static constant (RM 4.9(5))!\", N, E);\n-               end if;\n+\n+               --  One case we can give a metter message is when we have a\n+               --  string literal created by concatenating an aggregate with\n+               --  an others expression.\n+\n+               Entity_Case : declare\n+                  CV : constant Node_Id := Constant_Value (E);\n+                  CO : constant Node_Id := Original_Node (CV);\n+\n+                  function Is_Aggregate (N : Node_Id) return Boolean;\n+                  --  See if node N came from an others aggregate, if so\n+                  --  return True and set Error_Msg_Sloc to aggregate.\n+\n+                  ------------------\n+                  -- Is_Aggregate --\n+                  ------------------\n+\n+                  function Is_Aggregate (N : Node_Id) return Boolean is\n+                  begin\n+                     if Nkind (Original_Node (N)) = N_Aggregate then\n+                        Error_Msg_Sloc := Sloc (Original_Node (N));\n+                        return True;\n+                     elsif Is_Entity_Name (N)\n+                       and then Ekind (Entity (N)) = E_Constant\n+                       and then\n+                         Nkind (Original_Node (Constant_Value (Entity (N)))) =\n+                                                                  N_Aggregate\n+                     then\n+                        Error_Msg_Sloc :=\n+                          Sloc (Original_Node (Constant_Value (Entity (N))));\n+                        return True;\n+                     else\n+                        return False;\n+                     end if;\n+                  end Is_Aggregate;\n+\n+               --  Start of processing for Entity_Case\n+\n+               begin\n+                  if Is_Aggregate (CV)\n+                    or else (Nkind (CO) = N_Op_Concat\n+                              and then (Is_Aggregate (Left_Opnd (CO))\n+                                          or else\n+                                        Is_Aggregate (Right_Opnd (CO))))\n+                  then\n+                     Error_Msg_N (\"\\aggregate (#) is never static\", N);\n+\n+                  elsif not Is_Static_Expression (CV) then\n+                     Error_Msg_NE\n+                       (\"\\& is not a static constant (RM 4.9(5))\", N, E);\n+                  end if;\n+               end Entity_Case;\n \n             else\n                Error_Msg_NE\n-                 (\"& is not static constant or named number \" &\n-                  \"(RM 4.9(5))!\", N, E);\n+                 (\"\\& is not static constant or named number \"\n+                  & \"(RM 4.9(5))\", N, E);\n             end if;\n \n+         --  Binary operator\n+\n          when N_Binary_Op | N_Short_Circuit | N_Membership_Test =>\n             if Nkind (N) in N_Op_Shift then\n                Error_Msg_N\n-                (\"shift functions are never static (RM 4.9(6,18))!\", N);\n+                (\"\\shift functions are never static (RM 4.9(6,18))\", N);\n \n             else\n                Why_Not_Static (Left_Opnd (N));\n                Why_Not_Static (Right_Opnd (N));\n             end if;\n \n+         --  Unary operator\n+\n          when N_Unary_Op =>\n             Why_Not_Static (Right_Opnd (N));\n \n+         --  Attribute reference\n+\n          when N_Attribute_Reference =>\n             Why_Not_Static_List (Expressions (N));\n \n@@ -5569,8 +5626,8 @@ package body Sem_Eval is\n \n             if Attribute_Name (N) = Name_Size then\n                Error_Msg_N\n-                 (\"size attribute is only static for static scalar type \" &\n-                  \"(RM 4.9(7,8))\", N);\n+                 (\"\\size attribute is only static for static scalar type \"\n+                  & \"(RM 4.9(7,8))\", N);\n \n             --  Flag array cases\n \n@@ -5582,15 +5639,15 @@ package body Sem_Eval is\n                   Attribute_Name (N) /= Name_Length\n                then\n                   Error_Msg_N\n-                    (\"static array attribute must be Length, First, or Last \" &\n-                     \"(RM 4.9(8))!\", N);\n+                    (\"\\static array attribute must be Length, First, or Last \"\n+                     & \"(RM 4.9(8))\", N);\n \n                --  Since we know the expression is not-static (we already\n                --  tested for this, must mean array is not static).\n \n                else\n                   Error_Msg_N\n-                    (\"prefix is non-static array (RM 4.9(8))!\", Prefix (N));\n+                    (\"\\prefix is non-static array (RM 4.9(8))\", Prefix (N));\n                end if;\n \n                return;\n@@ -5603,30 +5660,36 @@ package body Sem_Eval is\n                   Is_Generic_Type (E)\n             then\n                Error_Msg_N\n-                 (\"attribute of generic type is never static \" &\n-                  \"(RM 4.9(7,8))!\", N);\n+                 (\"\\attribute of generic type is never static \"\n+                  & \"(RM 4.9(7,8))\", N);\n \n             elsif Is_Static_Subtype (E) then\n                null;\n \n             elsif Is_Scalar_Type (E) then\n                Error_Msg_N\n-                 (\"prefix type for attribute is not static scalar subtype \" &\n-                  \"(RM 4.9(7))!\", N);\n+                 (\"\\prefix type for attribute is not static scalar subtype \"\n+                  & \"(RM 4.9(7))\", N);\n \n             else\n                Error_Msg_N\n-                 (\"static attribute must apply to array/scalar type \" &\n-                  \"(RM 4.9(7,8))!\", N);\n+                 (\"\\static attribute must apply to array/scalar type \"\n+                  & \"(RM 4.9(7,8))\", N);\n             end if;\n \n+         --  String literal\n+\n          when N_String_Literal =>\n             Error_Msg_N\n-              (\"subtype of string literal is non-static (RM 4.9(4))!\", N);\n+              (\"\\subtype of string literal is non-static (RM 4.9(4))\", N);\n+\n+         --  Explicit dereference\n \n          when N_Explicit_Dereference =>\n             Error_Msg_N\n-              (\"explicit dereference is never static (RM 4.9)!\", N);\n+              (\"\\explicit dereference is never static (RM 4.9)\", N);\n+\n+         --  Function call\n \n          when N_Function_Call =>\n             Why_Not_Static_List (Parameter_Associations (N));\n@@ -5636,44 +5699,59 @@ package body Sem_Eval is\n             --  scalar arithmetic operation.\n \n             if not Is_RTE (Typ, RE_Bignum) then\n-               Error_Msg_N (\"non-static function call (RM 4.9(6,18))!\", N);\n+               Error_Msg_N (\"\\non-static function call (RM 4.9(6,18))\", N);\n             end if;\n \n+         --  Parameter assocation (test actual parameter)\n+\n          when N_Parameter_Association =>\n             Why_Not_Static (Explicit_Actual_Parameter (N));\n \n+         --  Indexed component\n+\n          when N_Indexed_Component =>\n-            Error_Msg_N\n-              (\"indexed component is never static (RM 4.9)!\", N);\n+            Error_Msg_N (\"\\indexed component is never static (RM 4.9)\", N);\n+\n+         --  Procedure call\n \n          when N_Procedure_Call_Statement =>\n-            Error_Msg_N\n-              (\"procedure call is never static (RM 4.9)!\", N);\n+            Error_Msg_N (\"\\procedure call is never static (RM 4.9)\", N);\n+\n+         --  Qualified expression (test expression)\n \n          when N_Qualified_Expression =>\n             Why_Not_Static (Expression (N));\n \n+         --  Aggregate\n+\n          when N_Aggregate | N_Extension_Aggregate =>\n-            Error_Msg_N\n-              (\"an aggregate is never static (RM 4.9)!\", N);\n+            Error_Msg_N (\"\\an aggregate is never static (RM 4.9)\", N);\n+\n+         --  Range\n \n          when N_Range =>\n             Why_Not_Static (Low_Bound (N));\n             Why_Not_Static (High_Bound (N));\n \n+         --  Range constraint, test range expression\n+\n          when N_Range_Constraint =>\n             Why_Not_Static (Range_Expression (N));\n \n+         --  Subtype indication, test constraint\n+\n          when N_Subtype_Indication =>\n             Why_Not_Static (Constraint (N));\n \n+         --  Selected component\n+\n          when N_Selected_Component =>\n-            Error_Msg_N\n-              (\"selected component is never static (RM 4.9)!\", N);\n+            Error_Msg_N (\"\\selected component is never static (RM 4.9)\", N);\n+\n+         --  Slice\n \n          when N_Slice =>\n-            Error_Msg_N\n-              (\"slice is never static (RM 4.9)!\", N);\n+            Error_Msg_N (\"\\slice is never static (RM 4.9)\", N);\n \n          when N_Type_Conversion =>\n             Why_Not_Static (Expression (N));\n@@ -5682,13 +5760,17 @@ package body Sem_Eval is\n               or else not Is_Static_Subtype (Entity (Subtype_Mark (N)))\n             then\n                Error_Msg_N\n-                 (\"static conversion requires static scalar subtype result \" &\n-                  \"(RM 4.9(9))!\", N);\n+                 (\"\\static conversion requires static scalar subtype result \"\n+                  & \"(RM 4.9(9))\", N);\n             end if;\n \n+         --  Unchecked type conversion\n+\n          when N_Unchecked_Type_Conversion =>\n             Error_Msg_N\n-              (\"unchecked type conversion is never static (RM 4.9)!\", N);\n+              (\"\\unchecked type conversion is never static (RM 4.9)\", N);\n+\n+         --  All other cases, no reason to give\n \n          when others =>\n             null;"}, {"sha": "66a9e3ecc65725552570a83c97432e3a6590977e", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fde064e1ac2202e45e3259304b718fcfff117fe/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=8fde064e1ac2202e45e3259304b718fcfff117fe", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -417,17 +417,17 @@ package Sem_Eval is\n \n    procedure Why_Not_Static (Expr : Node_Id);\n    --  This procedure may be called after generating an error message that\n-   --  complains that something is non-static. If it finds good reasons, it\n-   --  generates one or more error messages pointing the appropriate offending\n-   --  component of the expression. If no good reasons can be figured out, then\n-   --  no messages are generated. The expectation here is that the caller has\n-   --  already issued a message complaining that the expression is non-static.\n-   --  Note that this message should be placed using Error_Msg_F or\n-   --  Error_Msg_FE, so that it will sort before any messages placed by this\n-   --  call. Note that it is fine to call Why_Not_Static with something that is\n-   --  not an expression, and usually this has no effect, but in some cases\n-   --  (N_Parameter_Association or N_Range), it makes sense for the internal\n-   --  recursive calls.\n+   --  complains that something is non-static. If it finds good reasons,\n+   --  it generates one or more continuation error messages pointing the\n+   --  appropriate offending component of the expression. If no good reasons\n+   --  can be figured out, then no messages are generated. The expectation here\n+   --  is that the caller has already issued a message complaining that the\n+   --  expression is non-static. Note that this message should be placed using\n+   --  Error_Msg_F or Error_Msg_FE, so that it will sort before any messages\n+   --  placed by this call. Note that it is fine to call Why_Not_Static with\n+   --  something that is not an expression, and usually this has no effect, but\n+   --  in some cases (N_Parameter_Association or N_Range), it makes sense for\n+   --  the internal recursive calls.\n \n    procedure Initialize;\n    --  Initializes the internal data structures. Must be called before each"}]}