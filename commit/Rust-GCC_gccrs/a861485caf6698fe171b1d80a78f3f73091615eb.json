{"sha": "a861485caf6698fe171b1d80a78f3f73091615eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg2MTQ4NWNhZjY2OThmZTE3MWIxZDgwYTc4ZjNmNzMwOTE2MTVlYg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-26T15:36:52Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-26T15:36:52Z"}, "message": "re PR tree-optimization/21137 (Convert (a >> 2) & 1 != 0 into a & 4 != 0)\n\n2006-02-26  Roger Sayle  <roger@eyesopen.com>\n\t    James A. Morrison  <phython@gcc.gnu.org>\n\n\tPR middle-end/21137\n\t* fold-const.c (fold_binary) <EQ_EXPR>:  Fold ((X>>C1)&C2) eq/ne 0,\n\twhen C2 is a power of two, as either (X&(C2<<C1)) eq/ne 0 if the\n\tnew constant C2<<C1, or as (X<0) or (X,false) depending upon the\n\tsignedness of the shift operation.\n\n\t* gcc.dg/fold-eqandshift-1.c: New test case.\n\n\nCo-Authored-By: James A. Morrison <phython@gcc.gnu.org>\n\nFrom-SVN: r111453", "tree": {"sha": "54fbe907a418470a9df428739064819f26fcfdfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54fbe907a418470a9df428739064819f26fcfdfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a861485caf6698fe171b1d80a78f3f73091615eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a861485caf6698fe171b1d80a78f3f73091615eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a861485caf6698fe171b1d80a78f3f73091615eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a861485caf6698fe171b1d80a78f3f73091615eb/comments", "author": null, "committer": null, "parents": [{"sha": "cd683f6da56b08d6cde14e25cd453ea0cc88521f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd683f6da56b08d6cde14e25cd453ea0cc88521f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd683f6da56b08d6cde14e25cd453ea0cc88521f"}], "stats": {"total": 106, "additions": 106, "deletions": 0}, "files": [{"sha": "ead872d398c85034f10bac04e3bf18c7703cb3f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a861485caf6698fe171b1d80a78f3f73091615eb", "patch": "@@ -1,3 +1,12 @@\n+2006-02-26  Roger Sayle  <roger@eyesopen.com>\n+\t    James A. Morrison  <phython@gcc.gnu.org>\n+\n+\tPR middle-end/21137\n+\t* fold-const.c (fold_binary) <EQ_EXPR>:  Fold ((X>>C1)&C2) eq/ne 0,\n+\twhen C2 is a power of two, as either (X&(C2<<C1)) eq/ne 0 if the\n+\tnew constant C2<<C1, or as (X<0) or (X,false) depending upon the\n+\tsignedness of the shift operation.\n+\n 2006-02-26  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/26359"}, {"sha": "7eb4d914e92baf12433beb057d855fceaea1657d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a861485caf6698fe171b1d80a78f3f73091615eb", "patch": "@@ -9653,6 +9653,52 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t      fold_convert (newtype, arg1));\n \t}\n \n+      /* Fold ((X >> C1) & C2) == 0 and ((X >> C1) & C2) != 0 where\n+\t C1 is a valid shift constant, and C2 is a power of two, i.e.\n+\t a single bit.  */\n+      if (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == RSHIFT_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n+\t     == INTEGER_CST\n+\t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n+\t  && integer_zerop (arg1))\n+\t{\n+\t  tree itype = TREE_TYPE (arg0);\n+\t  unsigned HOST_WIDE_INT prec = TYPE_PRECISION (itype);\n+\t  tree arg001 = TREE_OPERAND (TREE_OPERAND (arg0, 0), 1);\n+\n+\t  /* Check for a valid shift count.  */\n+\t  if (TREE_INT_CST_HIGH (arg001) == 0\n+\t      && TREE_INT_CST_LOW (arg001) < prec)\n+\t    {\n+\t      tree arg01 = TREE_OPERAND (arg0, 1);\n+\t      tree arg000 = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t      unsigned HOST_WIDE_INT log2 = tree_log2 (arg01);\n+\t      /* If (C2 << C1) doesn't overflow, then ((X >> C1) & C2) != 0\n+\t\t can be rewritten as (X & (C2 << C1)) != 0.  */\n+\t      if ((log2 + TREE_INT_CST_LOW (arg01)) < prec)\n+\t\t{\n+\t\t  tem = fold_build2 (LSHIFT_EXPR, itype, arg01, arg001);\n+\t\t  tem = fold_build2 (BIT_AND_EXPR, itype, arg000, tem);\n+\t\t  return fold_build2 (code, type, tem, arg1);\n+\t\t}\n+\t      /* Otherwise, for signed (arithmetic) shifts,\n+\t\t ((X >> C1) & C2) != 0 is rewritten as X < 0, and\n+\t\t ((X >> C1) & C2) == 0 is rewritten as X >= 0.  */\n+\t      else if (!TYPE_UNSIGNED (itype))\n+\t\treturn fold_build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR, type,\n+\t\t\t\t    arg000, build_int_cst (itype, 0));\n+\t      /* Otherwise, of unsigned (logical) shifts,\n+\t\t ((X >> C1) & C2) != 0 is rewritten as (X,false), and\n+\t\t ((X >> C1) & C2) == 0 is rewritten as (X,true).  */\n+\t      else\n+\t\treturn omit_one_operand (type,\n+\t\t\t\t\t code == EQ_EXPR ? integer_one_node\n+\t\t\t\t\t\t\t : integer_zero_node,\n+\t\t\t\t\t arg000);\n+\t    }\n+\t}\n+\n       /* If this is an NE comparison of zero with an AND of one, remove the\n \t comparison since the AND will give the correct value.  */\n       if (code == NE_EXPR"}, {"sha": "deb3000d167b21e3c4b26157c3dc7e85edd2d91d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a861485caf6698fe171b1d80a78f3f73091615eb", "patch": "@@ -1,3 +1,8 @@\n+2006-02-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/21137\n+\t* gcc.dg/fold-eqandshift-1.c: New test case.\n+\n 2006-02-26  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/25125"}, {"sha": "6de71165e9d6f377b9371a8df6811d6b1b9aaf2a", "filename": "gcc/testsuite/gcc.dg/fold-eqandshift-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqandshift-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a861485caf6698fe171b1d80a78f3f73091615eb/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqandshift-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqandshift-1.c?ref=a861485caf6698fe171b1d80a78f3f73091615eb", "patch": "@@ -0,0 +1,46 @@\n+/* PR middle-end/21137  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-original\" } */\n+extern void foo();\n+\n+void test1(int a)\n+{\n+  if ((a >> 3) & 1)\n+    foo ();\n+}\n+\n+void test2(int b)\n+{\n+  if ((b >> 3) & 4)\n+    foo ();\n+}\n+\n+int test3(int c)\n+{\n+  return (c >> 3) & 1;\n+}\n+\n+int test4(int d)\n+{\n+  return (d >> 3) & 4;\n+}\n+\n+#if 0\n+void test5(int e)\n+{\n+  if ((e >> 31) & 64)\n+    foo();\n+}\n+\n+void test6(unsigned int f)\n+{\n+  if ((f >> 31) & 64)\n+    foo();\n+}\n+#endif\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\(a \\& 8\\\\) != 0\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\(b \\& 32\\\\) != 0\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"c >> 3 \\& 1\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"d >> 3 \\& 4\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}]}