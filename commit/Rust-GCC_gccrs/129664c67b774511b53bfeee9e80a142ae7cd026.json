{"sha": "129664c67b774511b53bfeee9e80a142ae7cd026", "node_id": "C_kwDOANBUbNoAKDEyOTY2NGM2N2I3NzQ1MTFiNTNiZmVlZTllODBhMTQyYWU3Y2QwMjY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-13T18:53:04Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-13T18:53:04Z"}, "message": "testsuite: add test coverage for PR analyzer/108045\n\nPR analyzer/108045 reports a leak false positive from -fanalyzer.\n\nThe false +ve as reported seems to have been fixed by\nr13-6589-g14f5e56a8a766c, but with -fanalyzer-call-summaries there are\ntwo additional false +ves which aren't fixed by that commit.\n\nThis patch adds test coverage for these cases.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108045\n\t* gcc.dg/analyzer/leak-pr108045-with-call-summaries.c: New test.\n\t* gcc.dg/analyzer/leak-pr108045-without-call-summaries.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "c023e181f0bed543f42b385a6db474644e90c034", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c023e181f0bed543f42b385a6db474644e90c034"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/129664c67b774511b53bfeee9e80a142ae7cd026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/129664c67b774511b53bfeee9e80a142ae7cd026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/129664c67b774511b53bfeee9e80a142ae7cd026", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/129664c67b774511b53bfeee9e80a142ae7cd026/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa9d3aa67894c8cadf9840be424b566a8c53c8e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9d3aa67894c8cadf9840be424b566a8c53c8e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa9d3aa67894c8cadf9840be424b566a8c53c8e4"}], "stats": {"total": 213, "additions": 213, "deletions": 0}, "files": [{"sha": "d63be06a9bbbfc0683ae7e8aec68577692df708a", "filename": "gcc/testsuite/gcc.dg/analyzer/leak-pr108045-with-call-summaries.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129664c67b774511b53bfeee9e80a142ae7cd026/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr108045-with-call-summaries.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129664c67b774511b53bfeee9e80a142ae7cd026/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr108045-with-call-summaries.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr108045-with-call-summaries.c?ref=129664c67b774511b53bfeee9e80a142ae7cd026", "patch": "@@ -0,0 +1,106 @@\n+/* { dg-additional-options \"-fanalyzer-call-summaries\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *)0)\n+\n+/* data structures */\n+\n+struct screen_s {\n+\tsize_t rows;\n+\tsize_t cols;\n+\tchar **data;\n+};\n+\n+struct context_s {\n+\tstruct screen_s *scr;\n+};\n+\n+/* global context variable */\n+\n+static struct context_s *ctx;\n+\n+/* prototypes */\n+\n+struct screen_s *screen_create(size_t cols, size_t rows);\n+void screen_destroy(struct screen_s *scr);\n+void resize_screen(size_t cols, size_t rows);\n+\n+/* functions */\n+\n+struct screen_s *screen_create(size_t cols, size_t rows)\n+{\n+\tstruct screen_s *result = NULL;\n+\n+\tresult = __builtin_calloc(1, sizeof(*result));\n+\tif (!result)\n+\t\treturn NULL;\n+\n+\tresult->cols = cols;\n+\tresult->rows = rows;\n+\n+\t/* make one allocation which will be accessed like a 2D array */\n+\tresult->data = __builtin_calloc(rows, sizeof(result->data) + sizeof(*result->data) * cols);\n+\tif (!result->data) {\n+\t\t__builtin_free(result);\n+\t\treturn NULL;\n+\t}\n+\n+\t/* obtain pointer to start of data area */\n+\tchar *ptr = (char *)(result->data + rows);\n+\n+\t/* setup pointers for each row of data to allow 2D array access */\n+\tfor (size_t row = 0; row < rows; row++)\n+\t\tresult->data[row] = (ptr + row * cols);\n+\t/* array can now be accessed like data[row][col] */\n+\n+\treturn result;\n+}\n+\n+void screen_destroy(struct screen_s *scr)\n+{\n+\tif (!scr)\n+\t\treturn;\n+\n+\t__builtin_free(scr->data);\n+\n+\tscr->data = NULL;\n+\tscr->rows = 0;\n+\tscr->cols = 0;\n+\n+\t__builtin_free(scr);\n+}\n+\n+void resize_screen(size_t cols, size_t rows)\n+{\n+\t/* create a new screen */\n+\tstruct screen_s *new_scr = NULL;\n+\tnew_scr = screen_create(cols, rows); /* { dg-bogus \"leak\" \"PR 108045\" { xfail *-*-* } } */\n+\tif (!new_scr) {\n+\t\treturn;\n+\t}\n+\n+\t/* swap the old screen with the new one */\n+\tstruct screen_s *old_scr = ctx->scr;\n+\tctx->scr = new_scr;\n+\n+\t/* omitted: copy the old screen contents to the new screen */\n+\n+\t/* free the old screen */\n+\tscreen_destroy(old_scr);\n+}\n+\n+int main(void)\n+{\n+\tctx = __builtin_calloc(1, sizeof(*ctx));\n+\tif (!ctx)\n+\t\t__builtin_abort();\n+\n+\tctx->scr = screen_create(80, 25); /* { dg-bogus \"leak\" \"PR 108045\" { xfail *-*-* } } */\n+\tresize_screen(100, 20);\n+\n+\t/* tidy up and quit */\n+\tscreen_destroy(ctx->scr);\n+\t__builtin_free(ctx);\n+\tctx = NULL;\n+\treturn 0;\n+}"}, {"sha": "ae7a7d5c1594a6c0282406b875d5c60b08638815", "filename": "gcc/testsuite/gcc.dg/analyzer/leak-pr108045-without-call-summaries.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/129664c67b774511b53bfeee9e80a142ae7cd026/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr108045-without-call-summaries.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/129664c67b774511b53bfeee9e80a142ae7cd026/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr108045-without-call-summaries.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr108045-without-call-summaries.c?ref=129664c67b774511b53bfeee9e80a142ae7cd026", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries\" } */\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *)0)\n+\n+/* data structures */\n+\n+struct screen_s {\n+\tsize_t rows;\n+\tsize_t cols;\n+\tchar **data;\n+};\n+\n+struct context_s {\n+\tstruct screen_s *scr;\n+};\n+\n+/* global context variable */\n+\n+static struct context_s *ctx;\n+\n+/* prototypes */\n+\n+struct screen_s *screen_create(size_t cols, size_t rows);\n+void screen_destroy(struct screen_s *scr);\n+void resize_screen(size_t cols, size_t rows);\n+\n+/* functions */\n+\n+struct screen_s *screen_create(size_t cols, size_t rows)\n+{\n+\tstruct screen_s *result = NULL;\n+\n+\tresult = __builtin_calloc(1, sizeof(*result));\n+\tif (!result)\n+\t\treturn NULL;\n+\n+\tresult->cols = cols;\n+\tresult->rows = rows;\n+\n+\t/* make one allocation which will be accessed like a 2D array */\n+\tresult->data = __builtin_calloc(rows, sizeof(result->data) + sizeof(*result->data) * cols);\n+\tif (!result->data) {\n+\t\t__builtin_free(result);\n+\t\treturn NULL;\n+\t}\n+\n+\t/* obtain pointer to start of data area */\n+\tchar *ptr = (char *)(result->data + rows);\n+\n+\t/* setup pointers for each row of data to allow 2D array access */\n+\tfor (size_t row = 0; row < rows; row++)\n+\t\tresult->data[row] = (ptr + row * cols);\n+\t/* array can now be accessed like data[row][col] */\n+\n+\treturn result;\n+}\n+\n+void screen_destroy(struct screen_s *scr)\n+{\n+\tif (!scr)\n+\t\treturn;\n+\n+\t__builtin_free(scr->data);\n+\n+\tscr->data = NULL;\n+\tscr->rows = 0;\n+\tscr->cols = 0;\n+\n+\t__builtin_free(scr); /* { dg-bogus \"leak\" } */\n+}\n+\n+void resize_screen(size_t cols, size_t rows)\n+{\n+\t/* create a new screen */\n+\tstruct screen_s *new_scr = NULL;\n+\tnew_scr = screen_create(cols, rows); /* { dg-bogus \"leak\" } */\n+\tif (!new_scr) {\n+\t\treturn;\n+\t}\n+\n+\t/* swap the old screen with the new one */\n+\tstruct screen_s *old_scr = ctx->scr;\n+\tctx->scr = new_scr;\n+\n+\t/* omitted: copy the old screen contents to the new screen */\n+\n+\t/* free the old screen */\n+\tscreen_destroy(old_scr);\n+}\n+\n+int main(void)\n+{\n+\tctx = __builtin_calloc(1, sizeof(*ctx));\n+\tif (!ctx)\n+\t\t__builtin_abort();\n+\n+\tctx->scr = screen_create(80, 25); /* { dg-bogus \"leak\" } */\n+\tresize_screen(100, 20);\n+\n+\t/* tidy up and quit */\n+\tscreen_destroy(ctx->scr);\n+\t__builtin_free(ctx);\n+\tctx = NULL;\n+\treturn 0;\n+}"}]}