{"sha": "852a971c260cc5b6c6f3e0c5568db683fe3526c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyYTk3MWMyNjBjYzViNmM2ZjNlMGM1NTY4ZGI2ODNmZTM1MjZjOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-11-06T21:35:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-11-06T21:35:27Z"}, "message": "Implement std::pmr::unsynchronized_pool_resource\n\n\tImplement std::pmr::unsynchronized_pool_resource\n\t* config/abi/pre/gnu.ver: Add new symbols.\n\t* include/std/memory_resource (std::pmr::__pool_resource): New class.\n\t(std::pmr::unsynchronized_pool_resource): New class.\n\t* src/c++17/Makefile.am: Add -fimplicit-templates to flags for\n\tmemory_resource.cc\n\t* src/c++17/Makefile.in: Regenerate.\n\t* src/c++17/memory_resource.cc (bitset, chunk, big_block): New\n\tinternal classes.\n\t(__pool_resource::_Pool): Define new class.\n\t(munge_options, pool_index, select_num_pools): New internal functions.\n\t(__pool_resource::__pool_resource, __pool_resource::~__pool_resource)\n\t(__pool_resource::allocate, __pool_resource::deallocate)\n\t(__pool_resource::_M_alloc_pools): Define member functions.\n\t(unsynchronized_pool_resource::unsynchronized_pool_resource)\n\t(unsynchronized_pool_resource::~unsynchronized_pool_resource)\n\t(unsynchronized_pool_resource::release)\n\t(unsynchronized_pool_resource::_M_find_pool)\n\t(unsynchronized_pool_resource::do_allocate)\n\t(unsynchronized_pool_resource::do_deallocate): Define member\n\tfunctions.\n\t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc: New\n\ttest.\n\t* testsuite/20_util/unsynchronized_pool_resource/is_equal.cc: New\n\ttest.\n\t* testsuite/20_util/unsynchronized_pool_resource/options.cc: New\n\ttest.\n\t* testsuite/20_util/unsynchronized_pool_resource/release.cc: New\n\ttest.\n\nFrom-SVN: r265853", "tree": {"sha": "070cdd50d35ed6bc1e887d3d545f4e29b62a7008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/070cdd50d35ed6bc1e887d3d545f4e29b62a7008"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/852a971c260cc5b6c6f3e0c5568db683fe3526c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852a971c260cc5b6c6f3e0c5568db683fe3526c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852a971c260cc5b6c6f3e0c5568db683fe3526c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852a971c260cc5b6c6f3e0c5568db683fe3526c8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd1501c5ab12b94f986d7c9ea55f8b3c0c7383c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd1501c5ab12b94f986d7c9ea55f8b3c0c7383c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd1501c5ab12b94f986d7c9ea55f8b3c0c7383c6"}], "stats": {"total": 1290, "additions": 1285, "deletions": 5}, "files": [{"sha": "0231623db836f65f473366ca98b597097a298be2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -1,3 +1,35 @@\n+2018-11-06  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tImplement std::pmr::unsynchronized_pool_resource\n+\t* config/abi/pre/gnu.ver: Add new symbols.\n+\t* include/std/memory_resource (std::pmr::__pool_resource): New class.\n+\t(std::pmr::unsynchronized_pool_resource): New class.\n+\t* src/c++17/Makefile.am: Add -fimplicit-templates to flags for\n+\tmemory_resource.cc\n+\t* src/c++17/Makefile.in: Regenerate.\n+\t* src/c++17/memory_resource.cc (bitset, chunk, big_block): New\n+\tinternal classes.\n+\t(__pool_resource::_Pool): Define new class.\n+\t(munge_options, pool_index, select_num_pools): New internal functions.\n+\t(__pool_resource::__pool_resource, __pool_resource::~__pool_resource)\n+\t(__pool_resource::allocate, __pool_resource::deallocate)\n+\t(__pool_resource::_M_alloc_pools): Define member functions.\n+\t(unsynchronized_pool_resource::unsynchronized_pool_resource)\n+\t(unsynchronized_pool_resource::~unsynchronized_pool_resource)\n+\t(unsynchronized_pool_resource::release)\n+\t(unsynchronized_pool_resource::_M_find_pool)\n+\t(unsynchronized_pool_resource::do_allocate)\n+\t(unsynchronized_pool_resource::do_deallocate): Define member\n+\tfunctions.\n+\t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc: New\n+\ttest.\n+\t* testsuite/20_util/unsynchronized_pool_resource/is_equal.cc: New\n+\ttest.\n+\t* testsuite/20_util/unsynchronized_pool_resource/options.cc: New\n+\ttest.\n+\t* testsuite/20_util/unsynchronized_pool_resource/release.cc: New\n+\ttest.\n+\n 2018-11-06  John Bytheway  <jbytheway@gmail.com>\n \n \tPR libstdc++/87872"}, {"sha": "b55038b8845ee4db18e84f3fd9ab6f488e6f68a5", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -2055,6 +2055,15 @@ GLIBCXX_3.4.26 {\n     _ZNSt13basic_filebufI[cw]St11char_traitsI[cw]EE4openEPKwSt13_Ios_Openmode;\n \n     _ZN11__gnu_debug25_Safe_local_iterator_base16_M_attach_singleEPNS_19_Safe_sequence_baseEb;\n+\n+    # <memory_resource> members\n+    _ZTINSt3pmr28unsynchronized_pool_resourceE;\n+    _ZNSt3pmr28unsynchronized_pool_resourceC[12]ERKNS_12pool_optionsEPNS_15memory_resourceE;\n+    _ZNSt3pmr28unsynchronized_pool_resourceD[12]Ev;\n+    _ZNSt3pmr28unsynchronized_pool_resource7releaseEv;\n+    _ZNSt3pmr28unsynchronized_pool_resource11do_allocateEmm;\n+    _ZNSt3pmr28unsynchronized_pool_resource13do_deallocateEPvmm;\n+\n } GLIBCXX_3.4.25;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "40486af82fecbe616aedcacbf2a836c0d988172a", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -33,9 +33,9 @@\n \n #if __cplusplus >= 201703L\n \n-#include <bit>\t\t\t\t// __ceil2, __log2p1\n #include <memory>\t\t\t// align, allocator_arg_t, __uses_alloc\n #include <utility>\t\t\t// pair, index_sequence\n+#include <vector>\t\t\t// vector\n #include <cstddef>\t\t\t// size_t, max_align_t\n #include <debug/assertions.h>\n \n@@ -296,8 +296,107 @@ namespace pmr\n     size_t largest_required_pool_block = 0;\n   };\n \n-  // TODO class synchronized_pool_resource;\n-  // TODO class unsynchronized_pool_resource;\n+  // Common implementation details for unsynchronized/synchronized pool resources.\n+  class __pool_resource\n+  {\n+    friend class synchronized_pool_resource;\n+    friend class unsynchronized_pool_resource;\n+\n+    __pool_resource(const pool_options& __opts, memory_resource* __upstream);\n+\n+    ~__pool_resource();\n+\n+    __pool_resource(const __pool_resource&) = delete;\n+    __pool_resource& operator=(const __pool_resource&) = delete;\n+\n+    // Allocate a large unpooled block.\n+    void*\n+    allocate(size_t __bytes, size_t __alignment);\n+\n+    // Deallocate a large unpooled block.\n+    void\n+    deallocate(void* __p, size_t __bytes, size_t __alignment);\n+\n+\n+    // Deallocate unpooled memory.\n+    void release() noexcept;\n+\n+    memory_resource* resource() const noexcept\n+    { return _M_unpooled.get_allocator().resource(); }\n+\n+    struct _Pool;\n+\n+    _Pool* _M_alloc_pools();\n+\n+    const pool_options _M_opts;\n+\n+    struct _BigBlock;\n+    // Collection of blocks too big for any pool, sorted by address.\n+    // This also stores the only copy of the upstream memory resource pointer.\n+    pmr::vector<_BigBlock> _M_unpooled;\n+\n+    const int _M_npools;\n+  };\n+\n+  // TODO class synchronized_pool_resource\n+\n+  /// A non-thread-safe memory resource that manages pools of fixed-size blocks.\n+  class unsynchronized_pool_resource : public memory_resource\n+  {\n+  public:\n+    [[__gnu__::__nonnull__]]\n+    unsynchronized_pool_resource(const pool_options& __opts,\n+\t\t\t\t memory_resource* __upstream);\n+\n+    unsynchronized_pool_resource()\n+    : unsynchronized_pool_resource(pool_options(), get_default_resource())\n+    { }\n+\n+    [[__gnu__::__nonnull__]]\n+    explicit\n+    unsynchronized_pool_resource(memory_resource* __upstream)\n+    : unsynchronized_pool_resource(pool_options(), __upstream)\n+    { }\n+\n+    explicit\n+    unsynchronized_pool_resource(const pool_options& __opts)\n+    : unsynchronized_pool_resource(__opts, get_default_resource()) { }\n+\n+    unsynchronized_pool_resource(const unsynchronized_pool_resource&) = delete;\n+\n+    virtual ~unsynchronized_pool_resource();\n+\n+    unsynchronized_pool_resource&\n+    operator=(const unsynchronized_pool_resource&) = delete;\n+\n+    void release();\n+\n+    [[__gnu__::__returns_nonnull__]]\n+    memory_resource*\n+    upstream_resource() const noexcept\n+    { return _M_impl.resource(); }\n+\n+    pool_options options() const noexcept { return _M_impl._M_opts; }\n+\n+  protected:\n+    void*\n+    do_allocate(size_t __bytes, size_t __alignment) override;\n+\n+    void\n+    do_deallocate(void* __p, size_t __bytes, size_t __alignment) override;\n+\n+    bool\n+    do_is_equal(const memory_resource& __other) const noexcept override\n+    { return this == &__other; }\n+\n+  private:\n+    using _Pool = __pool_resource::_Pool;\n+\n+    auto _M_find_pool(size_t) noexcept;\n+\n+    __pool_resource _M_impl;\n+    _Pool* _M_pools = nullptr;\n+  };\n \n   class monotonic_buffer_resource : public memory_resource\n   {"}, {"sha": "c748f50be164229ef2d5edaea5b719ce9020e7fc", "filename": "libstdc++-v3/src/c++17/Makefile.am", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -63,6 +63,11 @@ AM_CXXFLAGS = \\\n AM_MAKEFLAGS = \\\n \t\"gxx_include_dir=$(gxx_include_dir)\"\n \n+memory_resource.lo: memory_resource.cc\n+\t$(LTCXXCOMPILE) -fimplicit-templates -c $< -o $@\n+memory_resource.o: memory_resource.cc\n+\t$(CXXCOMPILE) -fimplicit-templates -c $< -o $@\n+\n # Libtool notes\n \n # 1) In general, libtool expects an argument such as `--tag=CXX' when"}, {"sha": "287b4b8bb69ade0c710a16e1e4ee90ad4350d048", "filename": "libstdc++-v3/src/c++17/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -731,6 +731,11 @@ uninstall-am:\n \n vpath % $(top_srcdir)/src/c++17\n \n+memory_resource.lo: memory_resource.cc\n+\t$(LTCXXCOMPILE) -fimplicit-templates -c $< -o $@\n+memory_resource.o: memory_resource.cc\n+\t$(CXXCOMPILE) -fimplicit-templates -c $< -o $@\n+\n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded.\n .NOEXPORT:"}, {"sha": "781bdada381f7ec2b0d4991c270e8e78f6a4846e", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 784, "deletions": 2, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -23,7 +23,9 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <memory_resource>\n+#include <algorithm>\t\t\t// lower_bound, rotate\n #include <atomic>\n+#include <bit>\t\t\t\t// __ceil2, __log2p1\n #include <new>\n #if ATOMIC_POINTER_LOCK_FREE != 2\n # include <bits/std_mutex.h>\t// std::mutex, std::lock_guard\n@@ -246,8 +248,788 @@ namespace pmr\n     _Chunk::release(_M_head, _M_upstream);\n   }\n \n+  // Helper types for synchronized_pool_resource & unsynchronized_pool_resource\n+\n+  namespace {\n+\n+  // Simple bitset with runtime size. Tracks used blocks in a pooled chunk.\n+  struct bitset\n+  {\n+    using word = uint64_t;\n+    using size_type = uint32_t;\n+\n+    static constexpr unsigned bits_per_word = numeric_limits<word>::digits;\n+\n+    // The bitset does not own p\n+    bitset(void* p, size_type num_blocks)\n+    : _M_words(static_cast<word*>(p)), _M_size(num_blocks),\n+      _M_next_word(0)\n+    {\n+      const size_type last_word = num_blocks / bits_per_word;\n+      __builtin_memset(_M_words, 0, last_word * sizeof(*_M_words));\n+      // Set bits beyond _M_size, so they are not treated as free blocks:\n+      if (const size_type extra_bits = num_blocks % bits_per_word)\n+\t_M_words[last_word] = (word)-1 << extra_bits;\n+      __glibcxx_assert( empty() );\n+      __glibcxx_assert( free() == num_blocks );\n+    }\n+\n+    bitset() = default;\n+    ~bitset() = default;\n+\n+    // Number of blocks\n+    size_t size() const noexcept { return _M_size; }\n+\n+    // Number of unset bits\n+    size_t free() const noexcept\n+    {\n+      size_t n = 0;\n+      for (size_type i = _M_next_word; i < nwords(); ++i)\n+\tn += (bits_per_word - std::__popcount(_M_words[i]));\n+      return n;\n+    }\n+\n+    // True if all bits are set\n+    bool full() const noexcept { return _M_next_word >= nwords(); }\n+\n+    // True if size() != 0 and no bits are set.\n+    bool empty() const noexcept\n+    {\n+      if (nwords() == 0)\n+\treturn false;\n+      if (_M_next_word != 0)\n+\treturn false;\n+      for (size_type i = 0; i < nwords() - 1; ++i)\n+\tif (_M_words[i] != 0)\n+\t  return false;\n+      word last = _M_words[nwords() - 1];\n+      if (const size_type extra_bits = size() % bits_per_word)\n+\tlast <<= (bits_per_word - extra_bits);\n+      return last == 0;\n+    }\n+\n+    void reset() noexcept\n+    {\n+      _M_words = nullptr;\n+      _M_size = _M_next_word = 0;\n+    }\n+\n+    bool operator[](size_type n) const noexcept\n+    {\n+      __glibcxx_assert( n < _M_size );\n+      const size_type wd = n / bits_per_word;\n+      const word bit = word(1) << (n % bits_per_word);\n+      return _M_words[wd] & bit;\n+    }\n+\n+    size_type find_first_unset() const noexcept\n+    {\n+      for (size_type i = _M_next_word; i < nwords(); ++i)\n+\t{\n+\t  const size_type n = std::__countr_one(_M_words[i]);\n+\t  if (n < bits_per_word)\n+\t    return (i * bits_per_word) + n;\n+\t}\n+      return size_type(-1);\n+    }\n+\n+    size_type get_first_unset() noexcept\n+    {\n+      for (size_type i = _M_next_word; i < nwords(); ++i)\n+\t{\n+\t  const size_type n = std::__countr_one(_M_words[i]);\n+\t  if (n < bits_per_word)\n+\t    {\n+\t      const word bit = word(1) << n;\n+\t      _M_words[i] |= bit;\n+\t      if (i == _M_next_word)\n+\t\t{\n+\t\t  while (_M_words[_M_next_word] == word(-1)\n+\t\t      && ++_M_next_word != nwords())\n+\t\t    { }\n+\t\t}\n+\t      return (i * bits_per_word) + n;\n+\t    }\n+\t}\n+      return size_type(-1);\n+    }\n+\n+    void set(size_type n) noexcept\n+    {\n+      __glibcxx_assert( n < _M_size );\n+      const size_type wd = n / bits_per_word;\n+      const word bit = word(1) << (n % bits_per_word);\n+      _M_words[wd] |= bit;\n+      if (wd == _M_next_word)\n+\t{\n+\t  while (_M_words[_M_next_word] == word(-1)\n+\t      && ++_M_next_word != nwords())\n+\t    { }\n+\t}\n+    }\n+\n+    void clear(size_type n) noexcept\n+    {\n+      __glibcxx_assert( n < _M_size );\n+      const size_type wd = n / bits_per_word;\n+      const word bit = word(1) << (n % bits_per_word);\n+      _M_words[wd] &= ~bit;\n+      if (wd < _M_next_word)\n+\t_M_next_word = wd;\n+    }\n+\n+    void swap(bitset& b) noexcept\n+    {\n+      std::swap(_M_words, b._M_words);\n+      size_type tmp = _M_size;\n+      _M_size = b._M_size;\n+      b._M_size = tmp;\n+      tmp = _M_next_word;\n+      _M_next_word = b._M_next_word;\n+      b._M_next_word = tmp;\n+    }\n+\n+    size_type nwords() const noexcept\n+    { return (_M_size + bits_per_word - 1) / bits_per_word; }\n+\n+    // Maximum value that can be stored in bitset::_M_size member (approx 500k)\n+    static constexpr size_t max_blocks_per_chunk() noexcept\n+    { return (1ull << _S_size_digits) - 1; }\n+\n+    word* data() const noexcept { return _M_words; }\n+\n+  private:\n+    static constexpr unsigned _S_size_digits\n+      = (numeric_limits<size_type>::digits\n+\t  + std::__log2p1(bits_per_word) - 1) / 2;\n+\n+    word* _M_words = nullptr;\n+    // Number of blocks represented by the bitset:\n+    size_type _M_size : _S_size_digits;\n+    // Index of the first word with unset bits:\n+    size_type _M_next_word : numeric_limits<size_type>::digits - _S_size_digits;\n+  };\n+\n+  // A \"chunk\" belonging to a pool.\n+  // A chunk contains many blocks of the same size.\n+  // Derived from bitset to reuse its tail-padding.\n+  struct chunk : bitset\n+  {\n+    chunk() = default;\n+\n+    // p points to the start of a chunk of size bytes in length.\n+    // The chunk has space for n blocks, followed by a bitset of size n\n+    // that begins at address words.\n+    // This object does not own p or words, the caller will free it.\n+    chunk(void* p, size_t bytes, void* words, size_t n)\n+    : bitset(words, n),\n+      _M_bytes(bytes),\n+      _M_p(static_cast<std::byte*>(p))\n+    { }\n+\n+    chunk(chunk&& c) noexcept\n+    : bitset(std::move(c)), _M_bytes(c._M_bytes), _M_p(c._M_p)\n+    {\n+      c._M_bytes = 0;\n+      c._M_p = nullptr;\n+      c.reset();\n+    }\n+\n+    chunk& operator=(chunk&& c) noexcept\n+    {\n+      swap(c);\n+      return *this;\n+    }\n+\n+    // Allocated size of chunk:\n+    unsigned _M_bytes = 0;\n+    // Start of allocated chunk:\n+    std::byte* _M_p = nullptr;\n+\n+    // True if there are free blocks in this chunk\n+    using bitset::full;\n+    // Number of blocks in this chunk\n+    using bitset::size;\n+\n+    // Determine if block with address p and size block_size\n+    // is contained within this chunk.\n+    bool owns(void* p, size_t block_size)\n+    {\n+      std::less_equal<uintptr_t> less_equal;\n+      return less_equal(reinterpret_cast<uintptr_t>(_M_p),\n+\t\t\treinterpret_cast<uintptr_t>(p))\n+\t&& less_equal(reinterpret_cast<uintptr_t>(p) + block_size,\n+\t\t      reinterpret_cast<uintptr_t>(bitset::data()));\n+    }\n+\n+    // Allocate next available block of block_size bytes from this chunk.\n+    void* reserve(size_t block_size) noexcept\n+    {\n+      const size_type n = get_first_unset();\n+      if (n == size_type(-1))\n+\treturn nullptr;\n+      return _M_p + (n * block_size);\n+    }\n+\n+    // Deallocate a single block of block_size bytes\n+    void release(void* vp, size_t block_size)\n+    {\n+      __glibcxx_assert( owns(vp, block_size) );\n+      const size_t offset = static_cast<std::byte*>(vp) - _M_p;\n+      // Pointer is correctly aligned for a block in this chunk:\n+      __glibcxx_assert( (offset % block_size) == 0 );\n+      // Block has been allocated:\n+      __glibcxx_assert( (*this)[offset / block_size] == true );\n+      bitset::clear(offset / block_size);\n+    }\n+\n+    // Deallocate a single block if it belongs to this chunk.\n+    bool try_release(void* p, size_t block_size)\n+    {\n+      if (!owns(p, block_size))\n+\treturn false;\n+      release(p, block_size);\n+      return true;\n+    }\n+\n+    void swap(chunk& c) noexcept\n+    {\n+      std::swap(_M_bytes, c._M_bytes);\n+      std::swap(_M_p, c._M_p);\n+      bitset::swap(c);\n+    }\n+\n+    bool operator<(const chunk& c) const noexcept\n+    { return std::less<const void*>{}(_M_p, c._M_p); }\n+\n+    friend void swap(chunk& l, chunk& r) { l.swap(r); }\n+\n+    friend bool operator<(const void* p, const chunk& c) noexcept\n+    { return std::less<const void*>{}(p, c._M_p); }\n+  };\n+\n+#ifdef __LP64__\n+  // TODO pad up to 4*sizeof(void*) to avoid splitting across cache lines?\n+  static_assert(sizeof(chunk) == (3 * sizeof(void*)), \"\");\n+#else\n+  static_assert(sizeof(chunk) == (4 * sizeof(void*)), \"\");\n+#endif\n+\n+  // An oversized allocation that doesn't fit in a pool.\n+  struct big_block\n+  {\n+    static constexpr unsigned _S_alignbits\n+      = std::__log2p1((unsigned)numeric_limits<size_t>::digits) - 1;\n+    static constexpr unsigned _S_sizebits\n+      = numeric_limits<size_t>::digits - _S_alignbits;\n+    // The maximum value that can be stored in _S_size\n+    static constexpr size_t all_ones = (1ul << _S_sizebits) - 1u;\n+    // The minimum size of a big block\n+    static constexpr size_t min = 1u << _S_alignbits;\n+\n+    big_block(size_t bytes, size_t alignment)\n+    : _M_size((bytes + min - 1u) >> _S_alignbits),\n+      _M_align_exp(std::__log2p1(alignment) - 1u)\n+    {\n+      if (__builtin_expect(std::__countl_one(bytes) == _S_sizebits, false))\n+\t_M_size = all_ones;\n+    }\n+\n+    void* pointer = nullptr;\n+    size_t _M_size : numeric_limits<size_t>::digits - _S_alignbits;\n+    size_t _M_align_exp : _S_alignbits;\n+\n+    size_t size() const noexcept\n+    {\n+      if (__builtin_expect(_M_size == all_ones, false))\n+\treturn (size_t)-1;\n+      else\n+\treturn _M_size << _S_alignbits;\n+    }\n+\n+    size_t align() const noexcept { return 1ul << _M_align_exp; }\n+\n+    friend bool operator<(void* p, const big_block& b) noexcept\n+    { return less<void*>{}(p, b.pointer); }\n+\n+    friend bool operator<(const big_block& b, void* p) noexcept\n+    { return less<void*>{}(b.pointer, p); }\n+  };\n+\n+  static_assert(sizeof(big_block) == (2 * sizeof(void*)));\n+\n+  } // namespace\n+\n+  // A pool that serves blocks of a particular size.\n+  // Each pool manages a number of chunks.\n+  // When a pool is full it is replenished by allocating another chunk.\n+  struct __pool_resource::_Pool\n+  {\n+    // Smallest supported block size\n+    static constexpr unsigned _S_min_block\n+      = std::max(sizeof(void*), alignof(bitset::word));\n+\n+    _Pool(size_t __block_size, size_t __blocks_per_chunk)\n+    : _M_chunks(),\n+      _M_block_sz(__block_size),\n+      _M_blocks_per_chunk(__blocks_per_chunk)\n+    {\n+      __glibcxx_assert(block_size() == __block_size);\n+    }\n+\n+    // Must call release(r) before destruction!\n+    ~_Pool() { __glibcxx_assert(_M_chunks.empty()); }\n+\n+    _Pool(_Pool&&) noexcept = default;\n+    _Pool& operator=(_Pool&&) noexcept = default;\n+\n+    // Size of blocks in this pool\n+    size_t block_size() const noexcept\n+#if POW2_BLKSZ\n+    { return _S_min_block << _M_blksize_mul; }\n+#else\n+    { return _M_block_sz; }\n+#endif\n+\n+    // Allocate a block if the pool is not full, otherwise return null.\n+    void* try_allocate() noexcept\n+    {\n+      const size_t blocksz = block_size();\n+      if (!_M_chunks.empty())\n+\t{\n+\t  auto& last = _M_chunks.back();\n+\t  if (void* p = last.reserve(blocksz))\n+\t    return p;\n+\t  // TODO last is full, so move another chunk to the back instead?\n+\t  for (auto it = _M_chunks.begin(); it != &last; ++it)\n+\t    if (void* p = it->reserve(blocksz))\n+\t      return p;\n+\t}\n+      return nullptr;\n+    }\n+\n+    // Allocate a block from the pool, replenishing from upstream if needed.\n+    void* allocate(memory_resource* r, const pool_options& opts)\n+    {\n+      if (void* p = try_allocate())\n+\treturn p;\n+      replenish(r, opts);\n+      return _M_chunks.back().reserve(block_size());\n+    }\n+\n+    // Return a block to the pool.\n+    bool deallocate(memory_resource*, void* p)\n+    {\n+      const size_t blocksz = block_size();\n+      if (__builtin_expect(!_M_chunks.empty(), true))\n+\t{\n+\t  auto& last = _M_chunks.back();\n+\t  if (last.try_release(p, blocksz))\n+\t    return true;\n+\t  auto it = std::upper_bound(_M_chunks.begin(), &last, p);\n+\t  if (it != _M_chunks.begin())\n+\t    {\n+\t      it--;\n+\t      if (it->try_release(p, blocksz))\n+\t\t// If chunk is empty could return to upstream, but we don't\n+\t\t// currently do that. Pools only increase in size.\n+\t\treturn true;\n+\t    }\n+\t}\n+      return false;\n+    }\n+\n+    void replenish(memory_resource* __r, const pool_options& __opts)\n+    {\n+      using word = chunk::word;\n+      const size_t __blocks\n+\t= std::min<size_t>(__opts.max_blocks_per_chunk, _M_blocks_per_chunk);\n+      const auto __bits = chunk::bits_per_word;\n+      const size_t __words = (__blocks + __bits - 1) / __bits;\n+      const size_t __block_size = block_size();\n+      size_t __bytes = __blocks * __block_size + __words * sizeof(word);\n+      size_t __alignment = std::__ceil2(__block_size);\n+      void* __p = __r->allocate(__bytes, __alignment);\n+      __try\n+\t{\n+\t  size_t __n = __blocks * __block_size;\n+\t  void* __pwords = static_cast<char*>(__p) + __n;\n+\t  _M_chunks.insert(chunk(__p, __bytes, __pwords, __blocks), __r);\n+\t}\n+      __catch (...)\n+\t{\n+\t  __r->deallocate(__p, __bytes, __alignment);\n+\t}\n+      if (_M_blocks_per_chunk < __opts.max_blocks_per_chunk)\n+\t_M_blocks_per_chunk *= 2;\n+    }\n+\n+    void release(memory_resource* __r)\n+    {\n+      const size_t __alignment = std::__ceil2(block_size());\n+      for (auto& __c : _M_chunks)\n+\tif (__c._M_p)\n+\t  __r->deallocate(__c._M_p, __c._M_bytes, __alignment);\n+      _M_chunks.clear(__r);\n+    }\n+\n+    // A \"resourceless vector\" instead of pmr::vector, to save space.\n+    // All resize operations need to be passed a memory resource, which\n+    // obviously needs to be the same one every time.\n+    // Chunks are kept sorted by address of their first block, except for\n+    // the most recently-allocated Chunk which is at the end of the vector.\n+    struct vector\n+    {\n+      using value_type = chunk;\n+      using size_type = unsigned;\n+      using iterator = value_type*;\n+\n+      // A vector owns its data pointer but not memory held by its elements.\n+      chunk* data = nullptr;\n+      size_type size = 0;\n+      size_type capacity = 0;\n+\n+      vector() = default;\n+\n+      vector(size_type __n, memory_resource* __r)\n+      : data(polymorphic_allocator<value_type>(__r).allocate(__n)),\n+\tcapacity(__n)\n+      { }\n+\n+      // Must call clear(r) before destruction!\n+      ~vector() { __glibcxx_assert(data == nullptr); }\n+\n+      vector(vector&& __rval) noexcept\n+\t: data(__rval.data), size(__rval.size), capacity(__rval.capacity)\n+      {\n+\t__rval.data = nullptr;\n+\t__rval.capacity = __rval.size = 0;\n+      }\n+\n+      vector& operator=(vector&& __rval) noexcept\n+      {\n+\t__glibcxx_assert(data == nullptr);\n+\tdata = __rval.data;\n+\tsize = __rval.size;\n+\tcapacity = __rval.capacity;\n+\t__rval.data = nullptr;\n+\t__rval.capacity = __rval.size = 0;\n+\treturn *this;\n+      }\n+\n+      // void resize(size_type __n, memory_resource* __r);\n+      // void reserve(size_type __n, memory_resource* __r);\n+\n+      void clear(memory_resource* __r)\n+      {\n+\tif (!data)\n+\t  return;\n+\t// Chunks must be individually freed before clearing the vector.\n+\tstd::destroy(begin(), end());\n+\tpolymorphic_allocator<value_type>(__r).deallocate(data, capacity);\n+\tdata = nullptr;\n+\tcapacity = size = 0;\n+      }\n+\n+      // Sort existing elements then insert new one at the end.\n+      iterator insert(chunk&& c, memory_resource* r)\n+      {\n+\tif (size < capacity)\n+\t  {\n+\t    if (size > 1)\n+\t      {\n+\t\tauto mid = end() - 1;\n+\t\tstd::rotate(std::lower_bound(begin(), mid, *mid), mid, end());\n+\t      }\n+\t  }\n+\telse if (size > 0)\n+\t  {\n+\t    polymorphic_allocator<value_type> __alloc(r);\n+\t    auto __mid = std::lower_bound(begin(), end() - 1, back());\n+\t    auto __p = __alloc.allocate(capacity * 1.5);\n+\t    // move [begin,__mid) to new storage\n+\t    auto __p2 = std::move(begin(), __mid, __p);\n+\t    // move end-1 to new storage\n+\t    *__p2 = std::move(back());\n+\t    // move [__mid,end-1) to new storage\n+\t    std::move(__mid, end() - 1, ++__p2);\n+\t    std::destroy(begin(), end());\n+\t    __alloc.deallocate(data, capacity);\n+\t    data = __p;\n+\t    capacity *= 1.5;\n+\t  }\n+\telse\n+\t  {\n+\t    polymorphic_allocator<value_type> __alloc(r);\n+\t    data = __alloc.allocate(capacity = 8);\n+\t  }\n+\tauto back = ::new (data + size) chunk(std::move(c));\n+\t__glibcxx_assert(std::is_sorted(begin(), back));\n+\t++size;\n+\treturn back;\n+      }\n+\n+      iterator begin() const { return data; }\n+      iterator end() const { return data + size; }\n+\n+      bool empty() const noexcept { return size == 0; }\n+\n+      value_type& back() { return data[size - 1]; }\n+    };\n+\n+    vector _M_chunks;\n+    unsigned _M_block_sz; \t// size of blocks allocated from this pool\n+    unsigned _M_blocks_per_chunk;\t// number of blocks to allocate next\n+  };\n+\n+  // An oversized allocation that doesn't fit in a pool.\n+  struct __pool_resource::_BigBlock : big_block\n+  {\n+    using big_block::big_block;\n+  };\n+\n+  namespace {\n+\n+  pool_options\n+  munge_options(pool_options opts)\n+  {\n+    // The values in the returned struct may differ from those supplied\n+    // to the pool resource constructor in that values of zero will be\n+    // replaced with implementation-defined defaults, and sizes may be\n+    // rounded to unspecified granularity.\n+\n+    // Absolute maximum. Each pool might have a smaller maximum.\n+    if (opts.max_blocks_per_chunk == 0)\n+      {\n+\topts.max_blocks_per_chunk = 1024 * 10; // TODO a good default?\n+      }\n+    else\n+      {\n+\t// TODO round to preferred granularity ?\n+      }\n+\n+    if (opts.max_blocks_per_chunk > chunk::max_blocks_per_chunk())\n+      {\n+\topts.max_blocks_per_chunk = chunk::max_blocks_per_chunk();\n+      }\n+\n+    // Absolute minimum. Likely to be much larger in practice.\n+    if (opts.largest_required_pool_block == 0)\n+      {\n+\topts.largest_required_pool_block = 4096; // TODO a good default?\n+      }\n+    else\n+      {\n+\t// TODO round to preferred granularity ?\n+      }\n+\n+    if (opts.largest_required_pool_block < big_block::min)\n+      {\n+\topts.largest_required_pool_block = big_block::min;\n+      }\n+    return opts;\n+  }\n+\n+  const size_t pool_sizes[] = {\n+      8, 16, 24,\n+      32, 48,\n+      64, 80, 96, 112,\n+      128, 192,\n+      256, 320, 384, 448,\n+      512, 768,\n+      1024, 1536,\n+      2048, 3072,\n+      1<<12, 1<<13, 1<<14, 1<<15, 1<<16, 1<<17,\n+      1<<20, 1<<21, 1<<22 // 4MB should be enough for anybody\n+  };\n+\n+  inline int\n+  pool_index(size_t block_size, int npools)\n+  {\n+    auto p = std::lower_bound(pool_sizes, pool_sizes + npools, block_size);\n+    int n = p - pool_sizes;\n+    if (n != npools)\n+      return n;\n+    return -1;\n+  }\n+\n+  inline int\n+  select_num_pools(const pool_options& opts)\n+  {\n+    auto p = std::lower_bound(std::begin(pool_sizes), std::end(pool_sizes),\n+\t\t\t      opts.largest_required_pool_block);\n+    if (int npools = p - std::begin(pool_sizes))\n+      return npools;\n+    return 1;\n+  }\n+\n+  } // namespace\n+\n+  __pool_resource::\n+  __pool_resource(const pool_options& opts, memory_resource* upstream)\n+  : _M_opts(munge_options(opts)), _M_unpooled(upstream),\n+    _M_npools(select_num_pools(_M_opts))\n+  { }\n+\n+  __pool_resource::~__pool_resource() { release(); }\n+\n+  void\n+  __pool_resource::release() noexcept\n+  {\n+    memory_resource* res = resource();\n+    // deallocate oversize allocations\n+    for (auto& b : _M_unpooled)\n+      res->deallocate(b.pointer, b.size(), b.align());\n+    pmr::vector<_BigBlock>{res}.swap(_M_unpooled);\n+  }\n+\n+  void*\n+  __pool_resource::allocate(size_t bytes, size_t alignment)\n+  {\n+    auto& b = _M_unpooled.emplace_back(bytes, alignment);\n+    __try {\n+      void* p = resource()->allocate(b.size(), alignment);\n+      b.pointer = p;\n+      if (_M_unpooled.size() > 1)\n+\t{\n+\t  const auto mid = _M_unpooled.end() - 1;\n+\t  // move to right position in vector\n+\t  std::rotate(std::lower_bound(_M_unpooled.begin(), mid, p),\n+\t\t      mid, _M_unpooled.end());\n+\t}\n+      return p;\n+    } __catch(...) {\n+      _M_unpooled.pop_back();\n+      __throw_exception_again;\n+    }\n+  }\n+\n+  void\n+  __pool_resource::deallocate(void* p, size_t bytes [[maybe_unused]],\n+\t\t\t      size_t alignment [[maybe_unused]])\n+  {\n+    const auto it\n+      = std::lower_bound(_M_unpooled.begin(), _M_unpooled.end(), p);\n+    __glibcxx_assert(it != _M_unpooled.end() && it->pointer == p);\n+    if (it != _M_unpooled.end() && it->pointer == p) // [[likely]]\n+      {\n+\tconst auto b = *it;\n+\t__glibcxx_assert(b.size() == bytes);\n+\t__glibcxx_assert(b.align() == alignment);\n+\t_M_unpooled.erase(it);\n+\tresource()->deallocate(p, b.size(), b.align());\n+      }\n+  }\n+\n+  // Create array of pools, allocated from upstream resource.\n+  auto\n+  __pool_resource::_M_alloc_pools()\n+  -> _Pool*\n+  {\n+    polymorphic_allocator<_Pool> alloc{resource()};\n+    _Pool* p = alloc.allocate(_M_npools);\n+    for (int i = 0; i < _M_npools; ++i)\n+      {\n+\tconst size_t block_size = pool_sizes[i];\n+\t// Decide on initial number of blocks per chunk.\n+\t// Always have at least 16 blocks per chunk:\n+\tconst size_t min_blocks_per_chunk = 16;\n+\t// But for smaller blocks, use a larger initial size:\n+\tsize_t blocks_per_chunk\n+\t  = std::max(1024 / block_size, min_blocks_per_chunk);\n+\t// But don't exceed the requested max_blocks_per_chunk:\n+\tblocks_per_chunk\n+\t  = std::min(blocks_per_chunk, _M_opts.max_blocks_per_chunk);\n+\t// Allow space for bitset to track which blocks are used/unused:\n+\tblocks_per_chunk *= 1 - 1.0 / (__CHAR_BIT__ * block_size);\n+\t// Construct a _Pool for the given block size and initial chunk size:\n+\talloc.construct(p + i, block_size, blocks_per_chunk);\n+      }\n+    return p;\n+  }\n+\n+  // unsynchronized_pool_resource member functions\n+\n+  // Constructor\n+  unsynchronized_pool_resource::\n+  unsynchronized_pool_resource(const pool_options& opts,\n+\t\t\t       memory_resource* upstream)\n+  : _M_impl(opts, upstream), _M_pools(_M_impl._M_alloc_pools())\n+  { }\n+\n+  // Destructor\n+  unsynchronized_pool_resource::~unsynchronized_pool_resource()\n+  { release(); }\n+\n+  // Return all memory to upstream resource.\n+  void\n+  unsynchronized_pool_resource::release()\n+  {\n+    // release pooled memory\n+    if (_M_pools)\n+      {\n+\tmemory_resource* res = upstream_resource();\n+\tpolymorphic_allocator<_Pool> alloc{res};\n+\tfor (int i = 0; i < _M_impl._M_npools; ++i)\n+\t  {\n+\t    _M_pools[i].release(res);\n+\t    alloc.destroy(_M_pools + i);\n+\t  }\n+\talloc.deallocate(_M_pools, _M_impl._M_npools);\n+\t_M_pools = nullptr;\n+      }\n+\n+    // release unpooled memory\n+    _M_impl.release();\n+  }\n+\n+  // Find the right pool for a block of size block_size.\n+  auto\n+  unsynchronized_pool_resource::_M_find_pool(size_t block_size) noexcept\n+  {\n+    __pool_resource::_Pool* pool = nullptr;\n+    if (_M_pools) // [[likely]]\n+      {\n+\tint index = pool_index(block_size, _M_impl._M_npools);\n+\tif (index != -1)\n+\t  pool = _M_pools + index;\n+      }\n+    return pool;\n+  }\n+\n+  // Override for memory_resource::do_allocate\n+  void*\n+  unsynchronized_pool_resource::do_allocate(size_t bytes, size_t alignment)\n+  {\n+    const auto block_size = std::max(bytes, alignment);\n+    if (block_size <= _M_impl._M_opts.largest_required_pool_block)\n+      {\n+\t// Recreate pools if release() has been called:\n+\tif (__builtin_expect(_M_pools == nullptr, false))\n+\t  _M_pools = _M_impl._M_alloc_pools();\n+\tif (auto pool = _M_find_pool(block_size))\n+\t  return pool->allocate(upstream_resource(), _M_impl._M_opts);\n+      }\n+    return _M_impl.allocate(bytes, alignment);\n+  }\n+\n+  // Override for memory_resource::do_deallocate\n+  void\n+  unsynchronized_pool_resource::\n+  do_deallocate(void* p, size_t bytes, size_t alignment)\n+  {\n+    size_t block_size = std::max(bytes, alignment);\n+    if (block_size <= _M_impl._M_opts.largest_required_pool_block)\n+      {\n+\tif (auto pool = _M_find_pool(block_size))\n+\t  {\n+\t    pool->deallocate(upstream_resource(), p);\n+\t    return;\n+\t  }\n+      }\n+    _M_impl.deallocate(p, bytes, alignment);\n+  }\n+\n } // namespace pmr\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n-\n-"}, {"sha": "ce9be2f6c49a4cb7b8406d30c28d1af0be44baa1", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -0,0 +1,155 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <cstring>\n+#include <testsuite_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  {\n+    std::pmr::unsynchronized_pool_resource r(&test_mr);\n+    void* p1 = r.allocate(1, 1);\n+    VERIFY( p1 != nullptr );\n+    auto n = test_mr.number_of_active_allocations();\n+    VERIFY( n > 0 );\n+    // Ensure memory region can be written to (without corrupting heap!)\n+    std::memset(p1, 0xff, 1);\n+    void* p2 = r.allocate(1, 1);\n+    VERIFY( p2 != nullptr );\n+    VERIFY( p2 != p1 );\n+    VERIFY( test_mr.number_of_active_allocations() == n );\n+    std::memset(p1, 0xff, 1);\n+    r.deallocate(p1, 1, 1);\n+    // Returning single blocks to the pool doesn't return them upstream:\n+    VERIFY( test_mr.number_of_active_allocations() == n );\n+    r.deallocate(p2, 1, 1);\n+    VERIFY( test_mr.number_of_active_allocations() == n );\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  struct nullable_memory_resource : public std::pmr::memory_resource\n+  {\n+    void*\n+    do_allocate(std::size_t bytes, std::size_t alignment) override\n+    { return upstream->allocate(bytes, alignment); }\n+\n+    void\n+    do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override\n+    { upstream->deallocate(p, bytes, alignment); }\n+\n+    bool\n+    do_is_equal(const memory_resource& r) const noexcept override\n+    { return &r == this; }\n+\n+    std::pmr::memory_resource* upstream = std::pmr::get_default_resource();\n+  };\n+\n+  nullable_memory_resource test_mr;\n+  std::pmr::unsynchronized_pool_resource r(&test_mr);\n+  void* p1 = r.allocate(8, 1);\n+  VERIFY( p1 != nullptr );\n+  std::memset(p1, 0xff, 8);\n+  test_mr.upstream = nullptr;\n+  void* p2 = r.allocate(8, 1); //should not need to replenish\n+  VERIFY( p2 != nullptr );\n+  VERIFY( p2 != p1 );\n+  std::memset(p1, 0xff, 8);\n+  r.deallocate(p1, 8, 1); // should not use upstream\n+  r.deallocate(p2, 8, 1); // should not use upstream\n+\n+  // Destructor will return memory upstream, so restore the upstream resource:\n+  test_mr.upstream = std::pmr::get_default_resource();\n+}\n+\n+void\n+test03()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  {\n+    std::pmr::unsynchronized_pool_resource r({10, 16}, &test_mr);\n+    std::size_t largest_pool = r.options().largest_required_pool_block;\n+    void* p1 = r.allocate(2 * largest_pool);\n+    VERIFY( p1 != nullptr );\n+    const std::size_t n = test_mr.number_of_active_allocations();\n+    // Allocation of pools + allocation of pmr::vector + oversize allocation:\n+    VERIFY( n >= 1 );\n+    std::memset(p1, 0xff, 2 * largest_pool);\n+    void* p2 = r.allocate(3 * largest_pool);\n+    VERIFY( p2 != nullptr );\n+    VERIFY( p2 != p1 );\n+    VERIFY( test_mr.number_of_active_allocations() == n + 1 );\n+    std::memset(p2, 0xff, 3 * largest_pool);\n+    r.deallocate(p1, 2 * largest_pool);\n+    VERIFY( test_mr.number_of_active_allocations() ==  n );\n+    r.deallocate(p2, 3 * largest_pool);\n+    VERIFY( test_mr.number_of_active_allocations() == n - 1 );\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::unsynchronized_pool_resource r({16, 16}, &test_mr);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2 * r.options().largest_required_pool_block);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+void\n+test04()\n+{\n+  std::pmr::unsynchronized_pool_resource r({256, 256});\n+  // Check alignment\n+  void* p1 = r.allocate(2, 64);\n+  VERIFY( (std::uintptr_t)p1 % 64 == 0 );\n+  void* p2 = r.allocate(2, 128);\n+  VERIFY( (std::uintptr_t)p2 % 128 == 0 );\n+  void* p3 = r.allocate(2, 256);\n+  VERIFY( (std::uintptr_t)p3 % 256 == 0 );\n+  const std::size_t largest_pool = r.options().largest_required_pool_block;\n+  void* p4 = r.allocate(2 * largest_pool, 1024);\n+  VERIFY( (std::uintptr_t)p4 % 1024 == 0 );\n+  r.deallocate(p1, 2, 64);\n+  r.deallocate(p2, 2, 128);\n+  r.deallocate(p3, 2, 256);\n+  r.deallocate(p4, 2 * largest_pool, 1024);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "789e7bb27244fbc27f8450fa2fa5ada259a5147d", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/is_equal.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fis_equal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fis_equal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fis_equal.cc?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::pmr::unsynchronized_pool_resource r1;\n+  VERIFY( r1 == r1 );\n+  std::pmr::unsynchronized_pool_resource r2;\n+  VERIFY( r1 != r2 );\n+  VERIFY( r2 != r1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "bfa8a8ce23c3a91bab44cf13a60b5b170803d645", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/options.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Foptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Foptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Foptions.cc?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::pmr::unsynchronized_pool_resource r0;\n+  const std::pmr::pool_options opts = r0.options();\n+  VERIFY( opts.max_blocks_per_chunk != 0 );\n+  VERIFY( opts.largest_required_pool_block != 0 );\n+\n+  std::pmr::unsynchronized_pool_resource r1(opts);\n+  auto [max_blocks_per_chunk, largest_required_pool_block ] = r1.options();\n+  VERIFY( max_blocks_per_chunk == opts.max_blocks_per_chunk );\n+  VERIFY( largest_required_pool_block == opts.largest_required_pool_block );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "e28ec479e7a3e862c9c10764995ce98b73e3decb", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/release.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Frelease.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852a971c260cc5b6c6f3e0c5568db683fe3526c8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Frelease.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Frelease.cc?ref=852a971c260cc5b6c6f3e0c5568db683fe3526c8", "patch": "@@ -0,0 +1,113 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  std::pmr::unsynchronized_pool_resource r(&test_mr);\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  (void) r.allocate(1);\n+  VERIFY( test_mr.number_of_active_allocations() != 0 );\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  struct nullable_memory_resource : public std::pmr::memory_resource\n+  {\n+    void*\n+    do_allocate(std::size_t bytes, std::size_t alignment) override\n+    { return upstream->allocate(bytes, alignment); }\n+\n+    void\n+    do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override\n+    { upstream->deallocate(p, bytes, alignment); }\n+\n+    bool\n+    do_is_equal(const memory_resource& r) const noexcept override\n+    { return &r == this; }\n+\n+    std::pmr::memory_resource* upstream = std::pmr::get_default_resource();\n+  };\n+\n+  nullable_memory_resource test_mr;\n+  std::pmr::unsynchronized_pool_resource r(&test_mr);\n+  r.release();\n+  test_mr.upstream = nullptr;\n+  r.release(); // should not need to call anything through upstream pointer\n+}\n+\n+void\n+test03()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  {\n+    std::pmr::unsynchronized_pool_resource r(&test_mr);\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::unsynchronized_pool_resource r(&test_mr);\n+    (void) r.allocate(1);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::unsynchronized_pool_resource r({10, 16}, &test_mr);\n+    (void) r.allocate(2 * r.options().largest_required_pool_block);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::unsynchronized_pool_resource r({16, 16}, &test_mr);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2 * r.options().largest_required_pool_block);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}