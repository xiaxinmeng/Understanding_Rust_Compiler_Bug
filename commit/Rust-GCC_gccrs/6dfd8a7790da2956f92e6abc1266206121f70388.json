{"sha": "6dfd8a7790da2956f92e6abc1266206121f70388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmZDhhNzc5MGRhMjk1NmY5MmU2YWJjMTI2NjIwNjEyMWY3MDM4OA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-06-20T13:30:14Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-06-20T13:30:14Z"}, "message": "ThreadGroup.java: Merged with classpath.\n\n2000-06-20  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* java/lang/ThreadGroup.java: Merged with classpath.\n\t* prims.cc (_Jv_RunMain): Don't use \rain_group'.\n\t* gnu/gcj/runtime/FirstThread.java: Remove ThreadGroup constructor\n\targument.\n\t* java/lang/Thread.java (Thread): Bootstrap initial thread from\n\tThreadGroup.root if Thread.currentThread is null. Honour the\n\tThreadGroup's max priority setting.\n\nFrom-SVN: r34615", "tree": {"sha": "5edeb41dea7e82739902a97679205e7fb75f32d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5edeb41dea7e82739902a97679205e7fb75f32d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dfd8a7790da2956f92e6abc1266206121f70388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dfd8a7790da2956f92e6abc1266206121f70388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dfd8a7790da2956f92e6abc1266206121f70388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dfd8a7790da2956f92e6abc1266206121f70388/comments", "author": null, "committer": null, "parents": [{"sha": "83fb52d8bb04d35f802af3c92a65669f259e3203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83fb52d8bb04d35f802af3c92a65669f259e3203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83fb52d8bb04d35f802af3c92a65669f259e3203"}], "stats": {"total": 748, "additions": 457, "deletions": 291}, "files": [{"sha": "55ef4ce6fb22859681acc547ea9c7e9b3e3ea011", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6dfd8a7790da2956f92e6abc1266206121f70388", "patch": "@@ -1,3 +1,13 @@\n+2000-06-20  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/lang/ThreadGroup.java: Merged with classpath.\n+\t* prims.cc (_Jv_RunMain): Don't use `main_group'.\n+\t* gnu/gcj/runtime/FirstThread.java: Remove ThreadGroup constructor\n+\targument.\n+\t* java/lang/Thread.java (Thread): Bootstrap initial thread from \n+\tThreadGroup.root if Thread.currentThread is null. Honour the \n+\tThreadGroup's max priority setting.\n+\n 2000-06-18  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/lang/natClass.cc (forName): Removed dead code.  Initialize"}, {"sha": "c7f521c5fc99db1e43262518dc91c657899927ab", "filename": "libjava/gnu/gcj/runtime/FirstThread.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fgnu%2Fgcj%2Fruntime%2FFirstThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fgnu%2Fgcj%2Fruntime%2FFirstThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FFirstThread.java?ref=6dfd8a7790da2956f92e6abc1266206121f70388", "patch": "@@ -21,17 +21,17 @@ final class FirstThread extends Thread\n {\n   public native void run ();\n \n-  public FirstThread (ThreadGroup g, Class k, Object o)\n+  public FirstThread (Class k, Object o)\n   {\n-    super (g, null, \"main\");\n+    super (null, null, \"main\");\n     klass = k;\n     klass_name = null;\n     args = o;\n   }\n \n-  public FirstThread (ThreadGroup g, String class_name, Object o)\n+  public FirstThread (String class_name, Object o)\n   {\n-    super (g, null, \"main\");\n+    super (null, null, \"main\");\n     klass = null;\n     klass_name = class_name;\n     args = o;"}, {"sha": "8be7f60379806582205fa4ae27f2e25c41e7c545", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=6dfd8a7790da2956f92e6abc1266206121f70388", "patch": "@@ -198,28 +198,29 @@ private final synchronized static String gen_name ()\n \n   public Thread (ThreadGroup g, Runnable r, String n)\n   {\n-    // Note that CURRENT can be null when we are creating the very\n-    // first thread.  That's why we check it below.\n     Thread current = currentThread ();\n-\n-    if (g != null)\n+          \n+    if (g == null)\n       {\n-\t// If CURRENT is null, then we are creating the first thread.\n-\t// In this case we don't do the security check.\n-\tif (current != null)\n-\t  g.checkAccess();\n+\t// If CURRENT is null, then we are bootstrapping the first thread. \n+\t// Use ThreadGroup.root, the main threadgroup.\n+\tif (current == null)\n+\t  group = ThreadGroup.root;\n+\telse\n+\t  group = current.getThreadGroup();\n       }\n     else\n-      g = current.getThreadGroup();\n+      group = g;\n+      \n+    group.checkAccess();\n \n     // The Class Libraries book says ``threadName cannot be null''.  I\n     // take this to mean NullPointerException.\n     if (n == null)\n       throw new NullPointerException ();\n \n     name = n;\n-    group = g;\n-    g.add(this);\n+    group.add(this);\n     runnable = r;\n \n     data = null;\n@@ -230,7 +231,9 @@ public Thread (ThreadGroup g, Runnable r, String n)\n     if (current != null)\n       {\n \tdaemon_flag = current.isDaemon();\n-\tpriority = current.getPriority();\n+        int gmax = group.getMaxPriority();\n+\tint pri = current.getPriority();\n+\tpriority = (gmax < pri ? gmax : pri);\n       }\n     else\n       {"}, {"sha": "52d82d79823119688dbe5d7780f3179b3a612bb2", "filename": "libjava/java/lang/ThreadGroup.java", "status": "modified", "additions": 426, "deletions": 266, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fjava%2Flang%2FThreadGroup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fjava%2Flang%2FThreadGroup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThreadGroup.java?ref=6dfd8a7790da2956f92e6abc1266206121f70388", "patch": "@@ -1,402 +1,562 @@\n-// ThreadGroup.java - ThreadGroup class.\n-\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n+/* java.lang.ThreadGroup\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+ \n+This file is part of libgcj.\n \n This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n-\n+ \n package java.lang;\n \n-import java.util.Enumeration;\n import java.util.Vector;\n-\n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date August 25, 1998 \n- */\n+import java.util.Enumeration;\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Complete for 1.1.  Parts from the JDK 1.0 spec only are\n- * not implemented.  Parts of the 1.2 spec are also not implemented.\n+ * Status:  Complete for 1.2.  Parts from the JDK 1.0 spec only are\n+ * not implemented. \n+ */\n+ \n+/**\n+ * ThreadGroup allows you to group Threads together.  There is a\n+ * hierarchy of ThreadGroups, and only the initial ThreadGroup has\n+ * no parent.  A Thread may access information about its own\n+ * ThreadGroup, but not its parents or others outside the tree.\n+ *\n+ * @author John Keiser\n+ * @author Tom Tromey\n+ * @version 1.2.0, June 20, 2000\n+ * @since JDK1.0\n  */\n \n public class ThreadGroup\n {\n-  public int activeCount ()\n-  {\n-    int ac = threads.size();\n-    Enumeration e = groups.elements();\n-    while (e.hasMoreElements())\n-      {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tac += g.activeCount();\n-      }\n-    return ac;\n-  }\n+  /* The Initial, top-level ThreadGroup. */\n+  static ThreadGroup root = new ThreadGroup();\n \n-  public int activeGroupCount ()\n-  {\n-    int ac = groups.size();\n-    Enumeration e = groups.elements();\n-    while (e.hasMoreElements())\n-      {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tac += g.activeGroupCount();\n-      }\n-    return ac;\n-  }\n+  private ThreadGroup parent;\n+  private String name;\n+  private Vector threads = new Vector();\n+  private Vector groups = new Vector();\n+  private boolean daemon_flag = false;\n+  private boolean destroyed_flag = false;\n+\n+  int maxpri = Thread.MAX_PRIORITY;\n \n-  // Deprecated in 1.2.\n-  public boolean allowThreadSuspension (boolean allow)\n+  private ThreadGroup()\n   {\n-    // There is no way for a Java program to determine whether this\n-    // has any effect whatsoever.  We don't need it.\n-    return true;\n+    name = \"main\";    \n   }\n \n-  public final void checkAccess ()\n+  /** Create a new ThreadGroup using the given name and the\n+   *  current thread's ThreadGroup as a parent.\n+   *  @param name the name to use for the ThreadGroup.\n+   */\n+  public ThreadGroup(String name)\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkAccess(this);\n+    this (Thread.currentThread().getThreadGroup(), name);\n   }\n \n-  // This is called to remove a ThreadGroup from our internal list.\n-  private final void remove (ThreadGroup g)\n+  /** Create a new ThreadGroup using the given name and\n+   *  parent group.\n+   *  @param name the name to use for the ThreadGroup.\n+   *  @param parent the ThreadGroup to use as a parent.\n+   *  @exception NullPointerException if parent is null.\n+   *  @exception SecurityException if you cannot change\n+   *             the intended parent group.\n+   */\n+  public ThreadGroup(ThreadGroup parent, String name)\n   {\n-    groups.removeElement(g);\n-    if (daemon_flag && groups.size() == 0 && threads.size() == 0)\n-      {\n-\t// We inline destroy to avoid the access check.\n-\tdestroyed_flag = true;\n-\tif (parent != null)\n-\t  parent.remove(this);\n-      }\n+    parent.checkAccess();\n+    this.parent = parent;\n+    if (parent.destroyed_flag)\n+      throw new IllegalArgumentException ();\n+    this.name = name;\n+    maxpri = parent.maxpri;\n+    daemon_flag = parent.daemon_flag;\n+    parent.add(this);\n   }\n \n-  // This is called by the Thread code to remove a Thread from our\n-  // internal list.\n-  final void remove (Thread t)\n+  /** Get the name of this ThreadGroup.\n+   *  @return the name of this ThreadGroup.\n+   */\n+  public final String getName()\n   {\n-    threads.removeElement(t);\n-    if (daemon_flag && groups.size() == 0 && threads.size() == 0)\n-      {\n-\t// We inline destroy to avoid the access check.\n-\tdestroyed_flag = true;\n-\tif (parent != null)\n-\t  parent.remove(this);\n-      }\n+    return name;\n   }\n \n-  // This is called by the Thread code to add a Thread to our internal\n-  // list.\n-  final void add (Thread t)\n+  /** Get the parent of this ThreadGroup.\n+   *  @return the parent of this ThreadGroup.\n+   */\n+  public final ThreadGroup getParent()\n   {\n-    if (destroyed_flag)\n-      throw new IllegalThreadStateException ();\n-\n-    threads.addElement(t);\n+    return parent;\n   }\n \n-  // This is a helper that is used to implement the destroy method.\n-  private final boolean canDestroy ()\n+  /** Set the maximum priority for Threads in this ThreadGroup. setMaxPriority\n+   *  can only be used to reduce the current maximum. If maxpri\n+   *  is greater than the current Maximum, the current value is not changed.\n+   *  Calling this does not effect threads already in this ThreadGroup.\n+   *  @param maxpri the new maximum priority for this ThreadGroup.\n+   *  @exception SecurityException if you cannoy modify this ThreadGroup.\n+   */\n+  public final void setMaxPriority(int maxpri)\n   {\n-    if (! threads.isEmpty())\n-      return false;\n-    Enumeration e = groups.elements();\n-    while (e.hasMoreElements())\n+    checkAccess();\n+    if (maxpri < this.maxpri\n+        && maxpri >= Thread.MIN_PRIORITY\n+\t&& maxpri <= Thread.MAX_PRIORITY)\n       {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tif (! g.canDestroy())\n-\t  return false;\n-      }\n-    return true;\n+\tthis.maxpri = maxpri;        \n+      }  \n   }\n \n-  public final void destroy ()\n+  /** Get the maximum priority of Threads in this ThreadGroup.\n+   *  @return the maximum priority of Threads in this ThreadGroup.\n+   */\n+  public final int getMaxPriority()\n   {\n-    checkAccess ();\n-    if (! canDestroy ())\n-      throw new IllegalThreadStateException ();\n-    destroyed_flag = true;\n-    if (parent != null)\n-      parent.remove(this);\n+    return maxpri;\n   }\n \n-  // This actually implements enumerate.\n-  private final int enumerate (Thread[] ts, int next_index, boolean recurse)\n+  /** Set whether this ThreadGroup is a daemon group.  A daemon\n+   *  group will be destroyed when its last thread is stopped and\n+   *  its last thread group is destroyed.\n+   *  @specnote The Java API docs indicate that the group is destroyed\n+   * \t\twhen either of those happen, but that doesn't make\n+   * \t\tsense.\n+   *  @param daemon whether this ThreadGroup should be a daemon group.\n+   *  @exception SecurityException if you cannoy modify this ThreadGroup.\n+   */\n+  public final void setDaemon (boolean daemon)\n   {\n-    Enumeration e = threads.elements();\n-    while (e.hasMoreElements() && next_index < ts.length)\n-      ts[next_index++] = (Thread) e.nextElement();\n-    if (recurse && next_index != ts.length)\n-      {\n-\te = groups.elements();\n-\twhile (e.hasMoreElements() && next_index < ts.length)\n-\t  {\n-\t    ThreadGroup g = (ThreadGroup) e.nextElement();\n-\t    next_index = g.enumerate(ts, next_index, true);\n-\t  }\n-      }\n-    return next_index;\n+    checkAccess();\n+    daemon_flag = daemon;\n   }\n-\n-  public int enumerate (Thread[] ts)\n+   \n+  /** Tell whether this ThreadGroup is a daemon group.  A daemon\n+    * group will be destroyed when its last thread is stopped and\n+    * its last thread group is destroyed.\n+    * @specnote The Java API docs indicate that the group is destroyed\n+    *\t\twhen either of those happen, but that doesn't make\n+    *\t\tsense.\n+    * @return whether this ThreadGroup is a daemon group.\n+    */\n+  public final boolean isDaemon()\n   {\n-    return enumerate (ts, 0, true);\n+    return daemon_flag;\n   }\n \n-  public int enumerate (Thread[] ts, boolean recurse)\n+  /** Tell whether this ThreadGroup has been destroyed or not.\n+    * @return whether this ThreadGroup has been destroyed or not.\n+    */\n+  public boolean isDestroyed()\n   {\n-    return enumerate (ts, 0, recurse);\n+    return destroyed_flag;\n   }\n \n-  // This actually implements enumerate.\n-  private final int enumerate (ThreadGroup[] ts, int next_index,\n-\t\t\t       boolean recurse)\n+  /** Check whether this ThreadGroup is an ancestor of the\n+    * specified ThreadGroup, or if they are the same.\n+    *\n+    * @param g the group to test on.\n+    * @return whether this ThreadGroup is a parent of the\n+    *\t      specified group.\n+    */\n+  public final boolean parentOf(ThreadGroup tg)\n   {\n-    Enumeration e = groups.elements();\n-    while (e.hasMoreElements() && next_index < ts.length)\n+    while (tg != null)\n       {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tts[next_index++] = g;\n-\tif (recurse && next_index != ts.length)\n-\t  next_index = g.enumerate(ts, next_index, true);\n+        if (tg == this)\n+          return true;\n+        tg = tg.parent;\n       }\n-    return next_index;\n+    return false;\n   }\n \n-  public int enumerate (ThreadGroup[] gs)\n-  {\n-    return enumerate (gs, 0, true);\n+  /** Return the total number of active threads in this ThreadGroup\n+    * and all its descendants.<P>\n+    *\n+    * This cannot return an exact number, since the status of threads\n+    * may change after they were counted.  But it should be pretty\n+    * close.<P>\n+    *\n+    * @return the number of active threads in this ThreadGroup and\n+    *\t      its descendants.\n+    */\n+  public synchronized int activeCount()\n+  {\n+    int total = threads.size();\n+    for (int i=0; i < groups.size(); i++)\n+      {\n+        ThreadGroup g = (ThreadGroup) groups.elementAt(i);\n+        total += g.activeCount();\n+      }\n+    return total;\n   }\n \n-  public int enumerate (ThreadGroup[] gs, boolean recurse)\n+  /** Get the number of active groups in this ThreadGroup.  This group\n+    * itself is not included in the count.\n+    * @specnote it is unclear what exactly constitutes an\n+    *\t\tactive ThreadGroup.  Currently we assume that\n+    *\t\tall sub-groups are active.\n+    * @return the number of active groups in this ThreadGroup.\n+    */\n+  public int activeGroupCount()\n   {\n-    return enumerate (gs, 0, recurse);\n+    int total = groups.size();\n+    for (int i=0; i < groups.size(); i++)\n+      {\n+\tThreadGroup g = (ThreadGroup) groups.elementAt(i);\n+\ttotal += g.activeGroupCount();\n+      }      \n+    return total;\n   }\n \n-  public final int getMaxPriority ()\n+  /** Copy all of the active Threads from this ThreadGroup and\n+    * its descendants into the specified array.  If the array is\n+    * not big enough to hold all the Threads, extra Threads will\n+    * simply not be copied.\n+    *\n+    * @param threads the array to put the threads into.\n+    * @return the number of threads put into the array.\n+    */\n+  public int enumerate(Thread[] threads)\n   {\n-    return maxpri;\n+    return enumerate(threads, true);\n   }\n \n-  public final String getName ()\n+  /** Copy all of the active Threads from this ThreadGroup and,\n+    * if desired, from its descendants, into the specified array.\n+    * If the array is not big enough to hold all the Threads,\n+    * extra Threads will simply not be copied.\n+    *\n+    * @param threads the array to put the threads into.\n+    * @param useDescendants whether to count Threads in this\n+    *\t     ThreadGroup's descendants or not.\n+    * @return the number of threads put into the array.\n+    */\n+  public int enumerate(Thread[] threads, boolean useDescendants)\n   {\n-    return name;\n+    return enumerate(threads, 0, useDescendants);\n   }\n \n-  public final ThreadGroup getParent ()\n+  // This actually implements enumerate.\n+  private int enumerate (Thread[] list, int next_index, boolean recurse)\n   {\n-    return parent;\n+    Enumeration e = threads.elements();\n+    while (e.hasMoreElements() && next_index < list.length)\n+      list[next_index++] = (Thread) e.nextElement();\n+    if (recurse && next_index != list.length)\n+      {\n+\te = groups.elements();\n+\twhile (e.hasMoreElements() && next_index < list.length)\n+\t  {\n+\t    ThreadGroup g = (ThreadGroup) e.nextElement();\n+\t    next_index = g.enumerate(list, next_index, true);\n+\t  }\n+      }\n+    return next_index;\n   }\n \n-  // JDK 1.2.\n-  // public void interrupt ();\n+  /** Copy all active ThreadGroups that are descendants of this\n+    * ThreadGroup into the specified array.  If the array is not\n+    * large enough to hold all active ThreadGroups, extra\n+    * ThreadGroups simply will not be copied.\n+    *\n+    * @param groups the array to put the ThreadGroups into.\n+    * @return the number of ThreadGroups copied into the array.\n+    */\n+  public int enumerate(ThreadGroup[] groups)\n+  {\n+    return enumerate(groups, false);\n+  }\n \n-  public final boolean isDaemon ()\n+  /** Copy all active ThreadGroups that are children of this\n+    * ThreadGroup into the specified array, and if desired, also\n+    * copy all active descendants into the array.  If the array\n+    * is not large enough to hold all active ThreadGroups, extra\n+    * ThreadGroups simply will not be copied.\n+    *\n+    * @param groups the array to put the ThreadGroups into.\n+    * @param useDescendants whether to include all descendants\n+    *\t     of this ThreadGroup's children in determining\n+    *\t     activeness.\n+    * @return the number of ThreadGroups copied into the array.\n+    */\n+  public int enumerate(ThreadGroup[] groups, boolean useDescendants)\n   {\n-    return daemon_flag;\n+    return enumerate(groups, 0, useDescendants);\n   }\n \n-  public synchronized boolean isDestroyed ()\n+  // This actually implements enumerate.\n+  private int enumerate (ThreadGroup[] list, int next_index, boolean recurse)\n   {\n-    return destroyed_flag;\n+    Enumeration e = groups.elements();\n+    while (e.hasMoreElements() && next_index < list.length)\n+      {\n+\tThreadGroup g = (ThreadGroup) e.nextElement();\n+\tlist[next_index++] = g;\n+\tif (recurse && next_index != list.length)\n+\t  next_index = g.enumerate(list, next_index, true);\n+      }\n+    return next_index;\n   }\n \n-  private final void list (String indentation)\n+  /** Interrupt all Threads in this ThreadGroup and its sub-groups.\n+    * @exception SecurityException if you cannot modify this\n+    *\t\t ThreadGroup or any of its Threads or children\n+    *\t\t ThreadGroups.\n+    * @since JDK1.2\n+    */\n+  public final void interrupt()\n   {\n-    System.out.print(indentation);\n-    System.out.println(toString ());\n-    String sub = indentation + \"    \";\n-    Enumeration e = threads.elements();\n-    while (e.hasMoreElements())\n+    checkAccess();\n+    for (int i=0; i < threads.size(); i++)\n       {\n-\tThread t = (Thread) e.nextElement();\n-\tSystem.out.print(sub);\n-\tSystem.out.println(t.toString());\n+        Thread t = (Thread) threads.elementAt(i);\n+        t.interrupt();\n       }\n-    e = groups.elements();\n-    while (e.hasMoreElements())\n+    for (int i=0; i < groups.size(); i++)\n       {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tg.list(sub);\n+        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n+        tg.interrupt();\n       }\n   }\n \n-  public void list ()\n+  /** Stop all Threads in this ThreadGroup and its descendants.\n+    * @exception SecurityException if you cannot modify this\n+    *\t\t ThreadGroup or any of its Threads or children\n+    *\t\t ThreadGroups.\n+    * @deprecated This method calls Thread.stop(), which is dangerous.\n+    */\n+  public final void stop()\n   {\n-    list (\"\");\n+    checkAccess();\n+    for (int i=0; i<threads.size(); i++)\n+      {\n+        Thread t = (Thread) threads.elementAt(i);\n+\tt.stop();\n+      }\n+    for (int i=0; i < groups.size(); i++)\n+      {\n+        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n+        tg.stop();\n+      }\n   }\n \n-  public final boolean parentOf (ThreadGroup g)\n+  /** Suspend all Threads in this ThreadGroup and its descendants.\n+    * @exception SecurityException if you cannot modify this\n+    *\t\t ThreadGroup or any of its Threads or children\n+    *\t\t ThreadGroups.\n+    * @deprecated This method calls Thread.suspend(), which is dangerous.\n+    */\n+  public final void suspend()\n   {\n-    while (g != null)\n+    checkAccess();\n+    for (int i=0; i<threads.size(); i++)\n       {\n-\tif (this == g)\n-\t  return true;\n-\tg = g.parent;\n+        Thread t = (Thread) threads.elementAt(i);\n+        t.suspend();\n+      }\n+    for (int i=0; i < groups.size(); i++)\n+      {\n+        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n+        tg.suspend();\n       }\n-    return false;\n   }\n \n-  // Deprecated in 1.2.\n-  public final void resume ()\n+  /** Resume all Threads in this ThreadGroup and its descendants.\n+    * @exception SecurityException if you cannot modify this\n+    *\t\t ThreadGroup or any of its Threads or children\n+    *\t\t ThreadGroups.\n+    * @deprecated This method relies on Thread.suspend(), which is dangerous.\n+    */\n+  public final void resume()\n   {\n-    checkAccess ();\n-    Enumeration e = threads.elements();\n-    while (e.hasMoreElements())\n+    checkAccess();\n+    for (int i=0; i < threads.size(); i++)\n       {\n-\tThread t = (Thread) e.nextElement();\n+        Thread t = (Thread) threads.elementAt(i);\n \tt.resume();\n       }\n-    e = groups.elements();\n-    while (e.hasMoreElements())\n+    for (int i=0; i < groups.size(); i++)\n       {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tg.resume();\n+        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n+        tg.resume();\n       }\n   }\n \n-  public final void setDaemon (boolean daemon)\n+  // This is a helper that is used to implement the destroy method.\n+  private final void checkDestroy ()\n   {\n-    checkAccess ();\n-    daemon_flag = daemon;\n-    // FIXME: the docs don't say you are supposed to do this.  But\n-    // they don't say you aren't, either.\n-    if (groups.size() == 0 && threads.size() == 0)\n-      destroy ();\n+    if (! threads.isEmpty())\n+      throw new IllegalThreadStateException (\"ThreadGroup has threads\");\n+    for (int i=0; i < groups.size(); i++)\n+      {\n+        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n+\ttg.checkDestroy();\n+      }\n   }\n \n-  public final void setMaxPriority (int pri)\n+  /** Destroy this ThreadGroup.  There can be no Threads in it,\n+    * and none of its descendants (sub-groups) may have Threads in them.\n+    * All its descendants will be destroyed as well.\n+    * @exception IllegalThreadStateException if the ThreadGroup or\n+    *\t\t its descendants have Threads remaining in them, or\n+    *\t\t if the ThreadGroup in question is already destroyed.\n+    * @exception SecurityException if you cannot modify this\n+    *\t\t ThreadGroup or any of its descendants.\n+    */\n+  public final void destroy()\n   {\n-    checkAccess ();\n+    checkAccess();\n+    if (destroyed_flag)\n+      throw new IllegalThreadStateException(\"Already destroyed.\");\n+    checkDestroy ();\n+    if (parent != null)\n+      parent.remove(this);\n+    destroyed_flag = true;\n+    parent = null;\n \n-    // FIXME: JDK 1.2 behaviour is different: if the newMaxPriority\n-    // argument is < MIN_PRIORITY or > MAX_PRIORITY an\n-    // IllegalArgumentException should be thrown.\n-    if (pri >= Thread.MIN_PRIORITY && pri <= maxpri)\n+    for (int i=0; i < groups.size(); i++)\n       {\n-\tmaxpri = pri;\n-\t\n-\tEnumeration e = groups.elements();\n-\twhile (e.hasMoreElements())\n-\t  {\n-\t    ThreadGroup g = (ThreadGroup) e.nextElement();\n-\t    g.setMaxPriority (maxpri);\n-\t  }\n+        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n+\ttg.destroy();\n       }\n   }\n+  \n+  /** Print out information about this ThreadGroup to System.out.\n+    */\n+  public void list()\n+  {\n+    list(\"\");\n+  }\n \n-  // Deprecated in 1.2.\n-  public final void stop ()\n+  private final void list (String indentation)\n   {\n-    checkAccess ();\n-    Enumeration e = threads.elements();\n-    while (e.hasMoreElements())\n+    System.out.print(indentation);\n+    System.out.println(toString ());\n+    String sub = indentation + \"    \";\n+    for (int i=0; i < threads.size(); i++)\n       {\n-\tThread t = (Thread) e.nextElement();\n-\tt.stop();\n+        Thread t = (Thread) threads.elementAt(i);\n+\tSystem.out.print(sub);\n+\tSystem.out.println(t.toString());\n       }\n-    e = groups.elements();\n-    while (e.hasMoreElements())\n+    for (int i=0; i < groups.size(); i++)\n       {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tg.stop();\n+        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n+\ttg.list(sub);\n       }\n   }\n \n-  // Deprecated in 1.2.\n-  public final void suspend ()\n+  /** When a Thread in this ThreadGroup does not catch an exception,\n+    * this method of the ThreadGroup is called.<P>\n+    *\n+    * ThreadGroup's implementation does the following:<BR>\n+    * <OL>\n+    * <LI>If there is a parent ThreadGroup, call uncaughtException()\n+    *\t  in the parent.</LI>\n+    * <LI>If the Throwable passed is a ThreadDeath, don't do\n+    *\t  anything.</LI>\n+    * <LI>Otherwise, call <CODE>exception.printStackTrace().</CODE></LI>\n+    * </OL>\n+    *\n+    * @param thread the thread that exited.\n+    * @param exception the uncaught exception.\n+    */\n+  public void uncaughtException(Thread thread, Throwable t)\n   {\n-    checkAccess ();\n-    Enumeration e = threads.elements();\n-    while (e.hasMoreElements())\n-      {\n-\tThread t = (Thread) e.nextElement();\n-\tt.suspend();\n-      }\n-    e = groups.elements();\n-    while (e.hasMoreElements())\n-      {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tg.suspend();\n-      }\n+    if (parent != null)\n+      parent.uncaughtException (thread, t);\n+    else if (! (t instanceof ThreadDeath))\n+      t.printStackTrace();\n   }\n \n-  // This constructor appears in the Class Libraries book but in\n-  // neither the Language Spec nor the 1.2 docs.\n-  public ThreadGroup ()\n+  /** Tell the VM whether it may suspend Threads in low memory\n+    * situations.\n+    * @deprecated This method is unimplemented, because it would rely on\n+    *\t\t  suspend(), which is deprecated. There is no way for a Java\n+    *\t\t  program to determine whether this has any effect whatsoever,\n+    *\t\t  so we don't need it.\n+    * @return false\n+    */\n+  public boolean allowThreadSuspension(boolean allow)\n   {\n-    this (Thread.currentThread().getThreadGroup(), null);\n+    return false;\n   }\n \n-  public ThreadGroup (String n)\n+  /** Get a human-readable representation of this ThreadGroup.\n+    * @return a String representing this ThreadGroup.\n+    * @specnote Language Spec and Class Libraries book disagree a bit here.\n+    *\t\tWe follow the Spec, but add \"ThreadGroup\" per the book.  We\n+    *\t\tinclude \"java.lang\" based on the list() example in the Class\n+    *\t\tLibraries book.\n+    */\n+  public String toString ()\n   {\n-    this (Thread.currentThread().getThreadGroup(), n);\n+    return \"java.lang.ThreadGroup[name=\" + name + \n+           \",maxpri=\" + maxpri + \"]\";\n   }\n \n-  public ThreadGroup (ThreadGroup p, String n)\n+  /** Find out if the current Thread can modify this ThreadGroup.\n+    * Calls the current SecurityManager's checkAccess() method to\n+    * find out.  If there is none, it assumes everything's OK.\n+    * @exception SecurityException if the current Thread cannot\n+    *\t\t modify this ThreadGroup.\n+    */\n+  public final void checkAccess()\n   {\n-    checkAccess ();\n-    if (p.destroyed_flag)\n-      throw new IllegalArgumentException ();\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkAccess(this);\n+  }\n \n-    parent = p;\n-    name = n;\n-    maxpri = p.maxpri;\n-    threads = new Vector ();\n-    groups = new Vector ();\n-    daemon_flag = p.daemon_flag;\n-    destroyed_flag = false;\n-    p.groups.addElement(this);\n+  // This is called to add a Thread to our internal list.\n+  final void add(Thread t)\n+  {\n+    if (destroyed_flag)\n+      throw new IllegalThreadStateException (\"ThreadGroup is destroyed\");\n+  \n+    threads.addElement(t);\n   }\n \n-  // This is the constructor that is used when creating the very first\n-  // ThreadGroup.  We have an arbitrary argument here just to\n-  // differentiate this constructor from the others.\n-  ThreadGroup (int dummy)\n+  // This is called to remove a Thread from our internal list.\n+  final void remove(Thread t)\n   {\n-    parent = null;\n-    name = \"main\";\n-    maxpri = Thread.MAX_PRIORITY;\n-    threads = new Vector ();\n-    groups = new Vector ();\n-    daemon_flag = false;\n-    destroyed_flag = false;\n+    if (destroyed_flag)\n+      throw new IllegalThreadStateException ();\n+  \n+    threads.removeElement(t);\n+    // Daemon groups are automatically destroyed when all their threads die.\n+    if (daemon_flag && groups.size() == 0 && threads.size() == 0)\n+      {\n+\t// We inline destroy to avoid the access check.\n+\tif (parent != null)\n+\t  parent.remove(this);\n+\tdestroyed_flag = true;\n+      }\n   }\n \n-  public String toString ()\n+  // This is called to add a ThreadGroup to our internal list.\n+  final void add(ThreadGroup g)\n   {\n-    // Language Spec and Class Libraries book disagree a bit here.  We\n-    // follow the Spec, but add \"ThreadGroup\" per the book.  We\n-    // include \"java.lang\" based on the list() example in the Class\n-    // Libraries book.\n-    return \"java.lang.ThreadGroup[name=\" + name + \",maxpri=\" + maxpri + \"]\";\n+    groups.addElement(g);\n   }\n \n-  public void uncaughtException (Thread thread, Throwable e)\n+  // This is called to remove a ThreadGroup from our internal list.\n+  final void remove(ThreadGroup g)\n   {\n-    // FIXME: in 1.2, this has different semantics.  In particular if\n-    // this group has a parent, the exception is passed upwards and\n-    // not processed locally.\n-    if (! (e instanceof ThreadDeath))\n+    groups.removeElement(g);\n+    // Daemon groups are automatically destroyed when all their threads die.\n+    if (daemon_flag && groups.size() == 0 && threads.size() == 0)\n       {\n-\te.printStackTrace();\n+\t// We inline destroy to avoid the access check.\n+\tif (parent != null)\n+\t  parent.remove(this);\t\n+\tdestroyed_flag = true;\n       }\n   }\n-\n-  // Private data.\n-  private ThreadGroup parent;\n-  private String name;\n-  private int maxpri;\n-  private Vector threads;\n-  private Vector groups;\n-  private boolean daemon_flag;\n-  private boolean destroyed_flag;\n }"}, {"sha": "817b0a8a46a9981471773fa5032d347c9c684275", "filename": "libjava/prims.cc", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfd8a7790da2956f92e6abc1266206121f70388/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=6dfd8a7790da2956f92e6abc1266206121f70388", "patch": "@@ -637,9 +637,6 @@ JvConvertArgv (int argc, const char **argv)\n // Command line arguments.\n static jobject arg_vec;\n \n-// The primary threadgroup.\n-static java::lang::ThreadGroup *main_group;\n-\n // The primary thread.\n static java::lang::Thread *main_thread;\n \n@@ -882,9 +879,7 @@ JvRunMain (jclass klass, int argc, const char **argv)\n #endif\n \n   arg_vec = JvConvertArgv (argc - 1, argv + 1);\n-  main_group = new java::lang::ThreadGroup (23);\n-  main_thread = new gnu::gcj::runtime::FirstThread (main_group, \n-\t\t\t\t\t\t    klass, arg_vec);\n+  main_thread = new gnu::gcj::runtime::FirstThread (klass, arg_vec);\n \n   main_thread->start();\n   _Jv_ThreadWait ();\n@@ -906,9 +901,7 @@ _Jv_RunMain (const char *class_name, int argc, const char **argv)\n #endif\n \n   arg_vec = JvConvertArgv (argc - 1, argv + 1);\n-  main_group = new java::lang::ThreadGroup (23);\n-  main_thread = new gnu::gcj::runtime::FirstThread (main_group,\n-\t\t\t\t\t\t    JvNewStringLatin1 (class_name),\n+  main_thread = new gnu::gcj::runtime::FirstThread (JvNewStringLatin1 (class_name),\n \t\t\t\t\t\t    arg_vec);\n   main_thread->start();\n   _Jv_ThreadWait ();"}]}