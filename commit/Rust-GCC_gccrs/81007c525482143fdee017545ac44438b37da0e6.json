{"sha": "81007c525482143fdee017545ac44438b37da0e6", "node_id": "C_kwDOANBUbNoAKDgxMDA3YzUyNTQ4MjE0M2ZkZWUwMTc1NDVhYzQ0NDM4YjM3ZGEwZTY", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:20:58Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:20:58Z"}, "message": "Merge commit '95dc11475dac06b5eecd904079de8aa94827a36a^' into HEAD", "tree": {"sha": "eb3910b6002d21d3652fd7b706f05da75432d93c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb3910b6002d21d3652fd7b706f05da75432d93c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81007c525482143fdee017545ac44438b37da0e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81007c525482143fdee017545ac44438b37da0e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81007c525482143fdee017545ac44438b37da0e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81007c525482143fdee017545ac44438b37da0e6/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a8c8d0d41b57fbb49ab39715b70495d5d1e8dd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8c8d0d41b57fbb49ab39715b70495d5d1e8dd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a8c8d0d41b57fbb49ab39715b70495d5d1e8dd1"}, {"sha": "e165214777acfe5621ad36e55b16e098d50e1596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e165214777acfe5621ad36e55b16e098d50e1596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e165214777acfe5621ad36e55b16e098d50e1596"}], "stats": {"total": 3059, "additions": 2684, "deletions": 375}, "files": [{"sha": "bd099b4757c37f85cd057c06a81e15edbfb03949", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,3 +1,8 @@\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* Makefile.def: Add Rust language.\n+\t* Makefile.in: Regenerate via autogen.\n+\n 2022-12-09  Martin Liska  <mliska@suse.cz>\n \n \t* MAINTAINERS: Fix spacing."}, {"sha": "5dea8a05c0c26eef0ba4557e3b9f090e4bdaf30c", "filename": "contrib/mklog.py", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/contrib%2Fmklog.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/contrib%2Fmklog.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fmklog.py?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -186,8 +186,9 @@ def generate_changelog(data, no_functions=False, fill_pr_titles=False,\n             # contains commented code which a note that it\n             # has not been tested due to a certain PR or DR.\n             this_file_prs = []\n-            if not file.is_binary_file:\n-                for line in list(file)[0][0:10]:\n+            hunks = list(file)\n+            if hunks:\n+                for line in hunks[0][0:10]:\n                     m = pr_regex.search(line.value)\n                     if m:\n                         pr = m.group('pr')"}, {"sha": "46b85d5bad1c5fe485a3c4564d2f593582f06ab3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,3 +1,210 @@\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-param-manipulation.cc\n+\t(ipa_param_body_adjustments::modify_expression): Bail out early if\n+\tthere are no replacements.\n+\t(ipa_param_body_adjustments::modify_assignment): Likewise.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-sra.cc (isra_param_desc): New fields safe_size,\n+\tconditionally_dereferenceable and safe_size_set.\n+\t(struct gensum_param_desc): New field conditionally_dereferenceable.\n+\t(struct isra_param_flow): Updated comment of field unit_size.\n+\t(ipa_sra_function_summaries::duplicate): Copy the new fields.\n+\t(isra_call_summary::dump): Dump unit_size when representing safe_size.\n+\t(dump_gensum_param_descriptor): Dump new flag.\n+\t(dump_isra_param_descriptor): Dump new fields.\n+\t(isra_analyze_call): Fill unit_size when it represents known safe\n+\tsize.\n+\t(check_gensum_access): Instead of disqualifying pointers which are not\n+\talways dereference, mark them as conditionally dereferencable if loads\n+\tare frequent enough.\n+\t(process_scan_results): Copy the conditionally_dereferenceable flag.\n+\t(isra_write_node_summary): Stream new fields, or assert they are not\n+\tinitialized yet.\n+\t(isra_read_node_info): Stream new fields.\n+\t(update_safe_size): New function.\n+\t(propagate_param_hints_accross_call): Propagate safe_sizes.\n+\t(propagate_hints_to_all_callees): New function.\n+\t(adjust_parameter_descriptions): Check conditionally_dereferenceable\n+\tcandidates, rework dumping.\n+\t(ipa_sra_analysis): Move most of hint propagation for one node to\n+\tpropagate_hints_to_all_callees.  Add another loop to stabilize within\n+\tSCCs and another one to verify.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-sra.cc (isra_param_desc): New field not_specially_constructed.\n+\t(struct isra_param_flow): New field constructed_for_calls.\n+\t(isra_call_summary::dump): Dump the new flag.\n+\t(loaded_decls): New variable.\n+\t(dump_isra_param_descriptor): New parameter hints, dump\n+\tnot_specially_constructed if it is true.\n+\t(dump_isra_param_descriptors): New parameter hints, pass it to\n+\tdump_isra_param_descriptor.\n+\t(ipa_sra_function_summaries::duplicate): Duplicate new flag.\n+\t(create_parameter_descriptors): Adjust comment.\n+\t(get_gensum_param_desc): Bail out when decl2desc is NULL.\n+\t(scan_expr_access): Add loaded local variables to loaded_decls.\n+\t(scan_function): Survive if final_bbs is NULL.\n+\t(isra_analyze_call): Compute constructed_for_calls flag.\n+\t(process_scan_results): Be optimistic about size limits.  Do not dump\n+\tcomputed param hints when dumpint IPA-SRA structures.\n+\t(isra_write_edge_summary): Stream constructed_for_calls.\n+\t(isra_read_edge_summary): Likewise.\n+\t(ipa_sra_dump_all_summaries): New parameter hints, pass it to\n+\tdump_isra_param_descriptor.\n+\t(flip_all_hints_pessimistic): New function.\n+\t(flip_all_param_hints_pessimistic): Likewise.\n+\t(propagate_param_hints): Likewise.\n+\t(disable_unavailable_parameters): Renamed to\n+\tadjust_parameter_descriptions.  Expand size limits for parameters\n+\twhich are specially contstructed by all callers.  Check limits again.p\n+\t(ipa_sra_analysis): Pass required hints to ipa_sra_dump_all_summaries.\n+\tAdd hint propagation.\n+\t(ipa_sra_summarize_function): Initialize and destory loaded_decls,\n+\trearrange so that scan_function is called even when there are no\n+\tcandidates.\n+\t* params.opt (ipa-sra-ptrwrap-growth-factor): New parameter.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-sra.cc (ipa_sra_analysis): Move top-down analysis before\n+\tbottom-up analysis.  Replace FOR_EACH_VEC_ELT with C++11 iteration.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/103585\n+\t* params.opt (ipa-sra-deref-prob-threshold): New parameter.\n+\t* doc/invoke.texi (ipa-sra-deref-prob-threshold): Document it.\n+\t* ipa-sra.cc (struct gensum_param_access): New field load_count.\n+\t(struct gensum_param_desc): New field safe_ref, adjusted comments.\n+\t(by_ref_count): Renamed to unsafe_by_ref_count, adjusted all uses.\n+\t(dump_gensum_access): Dump the new field.\n+\t(dump_gensum_param_descriptor): Likewise.\n+\t(create_parameter_descriptors): Set safe_ref field, move setting\n+\tby_ref forward.  Only increment unsafe_by_ref_count for unsafe\n+\tby_ref parameters.\n+\t(allocate_access): Initialize new field.\n+\t(mark_param_dereference): Adjust indentation.  Only add data to\n+\tbb_dereferences for unsafe by_ref parameters.\n+\t(scan_expr_access): For loads, accumulate BB counts.\n+\t(dereference_probable_p): New function.\n+\t(check_gensum_access): Fix leading comment, add parameter FUN.\n+\tCheck cumulative counts of loads for safe by_ref accesses instead\n+\tof dereferences.\n+\t(process_scan_results): Do not propagate dereference distances for\n+\tsafe by_ref parameters.  Pass fun to check_gensum_access.  Safe\n+\tby_ref params do not need the postdominance check.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-cp.cc (clone_for_param_removal_p): New function.\n+\t(estimate_local_effects): Call it before considering cloning\n+\tjust to remove unused parameters.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/103227\n+\t* ipa-param-manipulation.h (class ipa_param_adjustments): Removed\n+\tmember function get_updated_index_or_split.\n+\t(class ipa_param_body_adjustments): New overload of\n+\tregister_replacement, new member function append_init_stmts, new\n+\tmember m_split_agg_csts_inits.\n+\t* ipa-param-manipulation.cc: Include ipa-prop.h.\n+\t(ipa_param_adjustments::get_updated_index_or_split): Removed.\n+\t(ipa_param_body_adjustments::register_replacement): New overload, use\n+\tit from the older one.\n+\t(ipa_param_body_adjustments::common_initialization): Added the\n+\tcapability to create replacements for conflicting IPA-CP discovered\n+\tconstants.\n+\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Construct\n+\tthe new member.\n+\t(ipa_param_body_adjustments::append_init_stmts): New function.\n+\t* ipa-sra.cc: Include ipa-prop.h.\n+\t(push_param_adjustments_for_index): Require IPA-CP transformation\n+\tsummary as a parameter, do not create replacements which are known to\n+\thave constant values.\n+\t(process_isra_node_results): Find and pass to the above function the\n+\tIPA-CP transformation summary.\n+\t* ipa-prop.cc (adjust_agg_replacement_values): Remove the\n+\tfunctionality replacing IPA-SRA created scalar parameters with\n+\tconstants.  Simplify, do not require parameter descriptors, do not\n+\treturn anything.\n+\t(ipcp_transform_function): Simplify now that\n+\tadjust_agg_replacement_values does not change cfg.  Move definition\n+\tand initialization of descriptors lower.\n+\t* tree-inline.cc (tree_function_versioning): Call append_init_stmts of\n+\tparam_body_adjs, if there are any.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.cc (useful_ipcp_transformation_info_p): New function.\n+\t(write_ipcp_transformation_info): Added a parameter, simplified\n+\tgiven that is known not to be NULL.\n+\t(ipcp_write_transformation_summaries): Write out all useful\n+\ttransformation summaries.\n+\t(read_ipcp_transformation_info): Simplify given that some info\n+\twill be read.\n+\t(read_replacements_section): Remove assert.\n+\t* lto-cgraph.cc (add_node_to): Also set encode_body for clones.\n+\t* lto-streamer-out.cc (lto_output): Do not output virtual clones.\n+\n+2022-12-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/108044\n+\t* config/i386/i386.md (*concat<half><mode>3_5, *concat<mode><dwi>3_6,\n+\t*concat<mode><dwi>3_7): Split alternative with =ro output constraint\n+\tinto =r,o,o and use Wd input constraint for the last alternative which\n+\tis enabled for TARGET_64BIT.  Reject ix86_endbr_immediate_operand\n+\tin the input constant.\n+\n+2022-12-13  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* config/aarch64/aarch64.md (tbranch_<code><mode>3): Use gen_int_mode.\n+\n+2022-12-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108064\n+\t* tree-vect-patterns.cc (vect_recog_rotate_pattern): Pass uvectype\n+\tas 4th argument to append_pattern_def_seq for statements with lhs\n+\twith utype type.\n+\n+2022-12-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/105801\n+\t* tree-ssa-ccp.cc (likely_value): .DEFERRED_INIT produces\n+\tUNDEFINED.\n+\t* doc/invoke.texi (ftrivial-auto-var-init): Explicitely\n+\tmention we treat variables without an initializer as\n+\tundefined also for optimization purposes.\n+\n+2022-12-13  Tom Tromey  <tom@tromey.com>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\t    Marc Poulhi\u00e8s  <dkm@kataplop.net>\n+\n+\t* dwarf2out.cc (is_rust): New.\n+\t(base_type_die): Use DW_ATE_UTF for the Rust 'char' type.\n+\t(gen_compile_unit_die): Handle \"GNU Rust\".\n+\n+2022-12-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108076\n+\t* tree-if-conv.cc (if_convertible_loop_p_1): Reject blocks\n+\twith non-local or forced labels that we later remove\n+\tlabels from.\n+\n+2022-12-13  Haochen Gui  <guihaoc@gcc.gnu.org>\n+\n+\t* config/rs6000/rs6000.md (cbranchcc4): New expander.\n+\n+2022-12-13  Haochen Gui  <guihaoc@gcc.gnu.org>\n+\n+\t* optabs.cc (prepare_cmp_insn): Return a NULL rtx other than\n+\tassertion failure when targets don't have cbranch optab or\n+\tpredicate check fails.\n+\n 2022-12-12  Wilco Dijkstra  <wilco.dijkstra@arm.com>\n \n \t* config/aarch64/aarch64.cc (aarch64_rtx_costs): Add correct costs"}, {"sha": "fb5d5da64c6041f451d36bf192bb628a05f0741f", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1 +1 @@\n-20221213\n+20221214"}, {"sha": "6c27fb89e663d6ed845b41daf32476c2a58a169c", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -957,7 +957,7 @@\n {\n   rtx bitvalue = gen_reg_rtx (<ZEROM>mode);\n   rtx reg = gen_lowpart (<ZEROM>mode, operands[0]);\n-  rtx val = GEN_INT (1UL << UINTVAL (operands[1]));\n+  rtx val = gen_int_mode (HOST_WIDE_INT_1U << UINTVAL (operands[1]), <MODE>mode);\n   emit_insn (gen_and<zerom>3 (bitvalue, reg, val));\n   operands[1] = const0_rtx;\n   operands[0] = aarch64_gen_compare_reg (<CODE>, bitvalue,"}, {"sha": "06267529245f298033a263011a20124e252a3f53", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -11470,19 +11470,24 @@\n })\n \n (define_insn_and_split \"*concat<half><mode>3_5\"\n-  [(set (match_operand:DWI 0 \"nonimmediate_operand\" \"=ro\")\n+  [(set (match_operand:DWI 0 \"nonimmediate_operand\" \"=r,o,o\")\n \t(any_or_plus:DWI\n-\t  (ashift:DWI (match_operand:DWI 1 \"register_operand\" \"r\")\n+\t  (ashift:DWI (match_operand:DWI 1 \"register_operand\" \"r,r,r\")\n \t\t      (match_operand:DWI 2 \"const_int_operand\"))\n-\t  (match_operand:DWI 3 \"const_scalar_int_operand\")))]\n+\t  (match_operand:DWI 3 \"const_scalar_int_operand\" \"n,n,Wd\")))]\n   \"INTVAL (operands[2]) == <MODE_SIZE> * BITS_PER_UNIT / 2\n    && (<MODE>mode == DImode\n        ? CONST_INT_P (operands[3])\n \t && (UINTVAL (operands[3]) & ~GET_MODE_MASK (SImode)) == 0\n        : CONST_INT_P (operands[3])\n        ? INTVAL (operands[3]) >= 0\n        : CONST_WIDE_INT_NUNITS (operands[3]) == 2\n-\t && CONST_WIDE_INT_ELT (operands[3], 1) == 0)\"\n+\t && CONST_WIDE_INT_ELT (operands[3], 1) == 0)\n+   && !(CONST_INT_P (operands[3])\n+\t? ix86_endbr_immediate_operand (operands[3], VOIDmode)\n+\t: ix86_endbr_immediate_operand (GEN_INT (CONST_WIDE_INT_ELT (operands[3],\n+\t\t\t\t\t\t\t\t     0)),\n+\t\t\t\t\tVOIDmode))\"\n   \"#\"\n   \"&& reload_completed\"\n   [(clobber (const_int 0))]\n@@ -11491,45 +11496,56 @@\n   split_double_concat (<MODE>mode, operands[0], op3,\n \t\t       gen_lowpart (<HALF>mode, operands[1]));\n   DONE;\n-})\n+}\n+  [(set_attr \"isa\" \"*,nox64,x64\")])\n \n (define_insn_and_split \"*concat<mode><dwi>3_6\"\n-  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r\")\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=r,o,o,r\")\n \t(any_or_plus:<DWI>\n \t  (ashift:<DWI>\n \t    (zero_extend:<DWI>\n-\t      (match_operand:DWIH 1 \"nonimmediate_operand\" \"r,m\"))\n+\t      (match_operand:DWIH 1 \"nonimmediate_operand\" \"r,r,r,m\"))\n \t    (match_operand:<DWI> 2 \"const_int_operand\"))\n-\t  (match_operand:<DWI> 3 \"const_scalar_int_operand\")))]\n+\t  (match_operand:<DWI> 3 \"const_scalar_int_operand\" \"n,n,Wd,n\")))]\n   \"INTVAL (operands[2]) == <MODE_SIZE> * BITS_PER_UNIT\n    && (<DWI>mode == DImode\n        ? CONST_INT_P (operands[3])\n \t && (UINTVAL (operands[3]) & ~GET_MODE_MASK (SImode)) == 0\n        : CONST_INT_P (operands[3])\n        ? INTVAL (operands[3]) >= 0\n        : CONST_WIDE_INT_NUNITS (operands[3]) == 2\n-\t && CONST_WIDE_INT_ELT (operands[3], 1) == 0)\"\n+\t && CONST_WIDE_INT_ELT (operands[3], 1) == 0)\n+   && !(CONST_INT_P (operands[3])\n+\t? ix86_endbr_immediate_operand (operands[3], VOIDmode)\n+\t: ix86_endbr_immediate_operand (GEN_INT (CONST_WIDE_INT_ELT (operands[3],\n+\t\t\t\t\t\t\t\t     0)),\n+\t\t\t\t\tVOIDmode))\"\n   \"#\"\n   \"&& reload_completed\"\n   [(clobber (const_int 0))]\n {\n   rtx op3 = simplify_subreg (<MODE>mode, operands[3], <DWI>mode, 0);\n   split_double_concat (<DWI>mode, operands[0], op3, operands[1]);\n   DONE;\n-})\n+}\n+  [(set_attr \"isa\" \"*,nox64,x64,*\")])\n \n (define_insn_and_split \"*concat<mode><dwi>3_7\"\n-  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r\")\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=r,o,o,r\")\n \t(any_or_plus:<DWI>\n \t  (zero_extend:<DWI>\n-\t    (match_operand:DWIH 1 \"nonimmediate_operand\" \"r,m\"))\n-\t  (match_operand:<DWI> 2 \"const_scalar_int_operand\")))]\n+\t    (match_operand:DWIH 1 \"nonimmediate_operand\" \"r,r,r,m\"))\n+\t  (match_operand:<DWI> 2 \"const_scalar_int_operand\" \"n,n,Wd,n\")))]\n   \"<DWI>mode == DImode\n    ? CONST_INT_P (operands[2])\n      && (UINTVAL (operands[2]) & GET_MODE_MASK (SImode)) == 0\n+     && !ix86_endbr_immediate_operand (operands[2], VOIDmode)\n    : CONST_WIDE_INT_P (operands[2])\n      && CONST_WIDE_INT_NUNITS (operands[2]) == 2\n-     && CONST_WIDE_INT_ELT (operands[2], 0) == 0\"\n+     && CONST_WIDE_INT_ELT (operands[2], 0) == 0\n+     && !ix86_endbr_immediate_operand (GEN_INT (CONST_WIDE_INT_ELT (operands[2],\n+\t\t\t\t\t\t\t\t    1)),\n+\t\t\t\t       VOIDmode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(clobber (const_int 0))]\n@@ -11541,7 +11557,8 @@\n     op2 = gen_int_mode (CONST_WIDE_INT_ELT (operands[2], 1), <MODE>mode);\n   split_double_concat (<DWI>mode, operands[0], operands[1], op2);\n   DONE;\n-})\n+}\n+  [(set_attr \"isa\" \"*,nox64,x64,*\")])\n \f\n ;; Negation instructions\n "}, {"sha": "7dc1d45e2750b464425a31c894ada56bd9255860", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -13208,7 +13208,8 @@ disclosure and use.\n GCC still considers an automatic variable that doesn't have an explicit\n initializer as uninitialized, @option{-Wuninitialized} and\n @option{-Wanalyzer-use-of-uninitialized-value} will still report\n-warning messages on such automatic variables.\n+warning messages on such automatic variables and the compiler will\n+perform optimization as if the variable were uninitialized.\n With this option, GCC will also initialize any padding of automatic variables\n that have structure or union types to zeroes.\n However, the current implementation cannot initialize automatic variables that\n@@ -15508,12 +15509,22 @@ the parameter is reserved exclusively for debug insns created by\n @option{-fvar-tracking-assignments}, but debug insns may get\n (non-overlapping) uids above it if the reserved range is exhausted.\n \n+@item ipa-sra-deref-prob-threshold\n+IPA-SRA replaces a pointer which is known not be NULL with one or more\n+new parameters only when the probability (in percent, relative to\n+function entry) of it being dereferenced is higher than this parameter.\n+\n @item ipa-sra-ptr-growth-factor\n IPA-SRA replaces a pointer to an aggregate with one or more new\n parameters only when their cumulative size is less or equal to\n @option{ipa-sra-ptr-growth-factor} times the size of the original\n pointer parameter.\n \n+@item ipa-sra-ptrwrap-growth-factor\n+Additional maximum allowed growth of total size of new parameters\n+that ipa-sra replaces a pointer to an aggregate with,\n+if it points to a local variable that the caller never writes to.\n+\n @item ipa-sra-max-replacements\n Maximum pieces of an aggregate that IPA-SRA tracks.  As a\n consequence, it is also the maximum number of replacements of a formal"}, {"sha": "cbb0ecfbe6994832fd4794fa54bd302994a3eff3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,3 +1,9 @@\n+2022-12-13  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/107423\n+\t* parse.cc (parse_spec): Avoid NULL pointer dereference when parsing\n+\ta function and an error occured.\n+\n 2022-12-12  Harald Anlauf  <anlauf@gmx.de>\n \n \tPR fortran/102180"}, {"sha": "bc2b2188eea7f97509770f29d8e7f832a8b66e35", "filename": "gcc/fortran/parse.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ffortran%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ffortran%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -4015,7 +4015,7 @@ parse_spec (gfc_statement st)\n       gfc_symbol* proc = gfc_current_ns->proc_name;\n       gcc_assert (proc);\n \n-      if (proc->result->ts.type == BT_UNKNOWN)\n+      if (proc->result && proc->result->ts.type == BT_UNKNOWN)\n \tfunction_result_typed = true;\n     }\n "}, {"sha": "300bec54bbdee4a3876ef25901e34260949e1cb9", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -3700,6 +3700,29 @@ get_max_overall_size (cgraph_node *node)\n   return max_new_size;\n }\n \n+/* Return true if NODE should be cloned just for a parameter removal, possibly\n+   dumping a reason if not.  */\n+\n+static bool\n+clone_for_param_removal_p (cgraph_node *node)\n+{\n+  if (!node->can_change_signature)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  Not considering cloning to remove parameters, \"\n+\t\t \"function cannot change signature.\\n\");\n+      return false;\n+    }\n+  if (node->can_be_local_p ())\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  Not considering cloning to remove parameters, \"\n+\t\t \"IPA-SRA can do it potentially better.\\n\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Iterate over known values of parameters of NODE and estimate the local\n    effects in terms of time and size they have.  */\n \n@@ -3722,7 +3745,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t\t\t\t\t    &removable_params_cost);\n   int devirt_bonus = devirtualization_time_bonus (node, &avals);\n   if (always_const || devirt_bonus\n-      || (removable_params_cost && node->can_change_signature))\n+      || (removable_params_cost && clone_for_param_removal_p (node)))\n     {\n       struct caller_statistics stats;\n       ipa_call_estimates estimates;"}, {"sha": "da19d64cbceb4bb66b290ceefb9503b85887fe97", "filename": "gcc/ipa-param-manipulation.cc", "status": "modified", "additions": 98, "deletions": 55, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-param-manipulation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-param-manipulation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-phinodes.h\"\n #include \"cfgexpand.h\"\n #include \"attribs.h\"\n-\n+#include \"ipa-prop.h\"\n \n /* Actual prefixes of different newly synthetized parameters.  Keep in sync\n    with IPA_PARAM_PREFIX_* defines.  */\n@@ -449,39 +449,6 @@ ipa_param_adjustments::get_updated_indices (vec<int> *new_indices)\n     }\n }\n \n-/* If a parameter with original INDEX has survived intact, return its new\n-   index.  Otherwise return -1.  In that case, if it has been split and there\n-   is a new parameter representing a portion at unit OFFSET for which a value\n-   of a TYPE can be substituted, store its new index into SPLIT_INDEX,\n-   otherwise store -1 there.  */\n-int\n-ipa_param_adjustments::get_updated_index_or_split (int index,\n-\t\t\t\t\t\t   unsigned unit_offset,\n-\t\t\t\t\t\t   tree type, int *split_index)\n-{\n-  unsigned adj_len = vec_safe_length (m_adj_params);\n-  for (unsigned i = 0; i < adj_len ; i++)\n-    {\n-      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n-      if (apm->base_index != index)\n-\tcontinue;\n-      if (apm->op == IPA_PARAM_OP_COPY)\n-\treturn i;\n-      if (apm->op == IPA_PARAM_OP_SPLIT\n-\t  && apm->unit_offset == unit_offset)\n-\t{\n-\t  if (useless_type_conversion_p (apm->type, type))\n-\t    *split_index = i;\n-\t  else\n-\t    *split_index = -1;\n-\t  return -1;\n-\t}\n-    }\n-\n-  *split_index = -1;\n-  return -1;\n-}\n-\n /* Return the original index for the given new parameter index.  Return a\n    negative number if not available.  */\n \n@@ -1020,6 +987,21 @@ ipa_param_adjustments::debug ()\n   dump (stderr);\n }\n \n+/* Register a REPLACEMENT for accesses to BASE at UNIT_OFFSET.  */\n+\n+void\n+ipa_param_body_adjustments::register_replacement (tree base,\n+\t\t\t\t\t\t  unsigned unit_offset,\n+\t\t\t\t\t\t  tree replacement)\n+{\n+  ipa_param_body_replacement psr;\n+  psr.base = base;\n+  psr.repl = replacement;\n+  psr.dummy = NULL_TREE;\n+  psr.unit_offset = unit_offset;\n+  m_replacements.safe_push (psr);\n+}\n+\n /* Register that REPLACEMENT should replace parameter described in APM.  */\n \n void\n@@ -1029,12 +1011,8 @@ ipa_param_body_adjustments::register_replacement (ipa_adjusted_param *apm,\n   gcc_checking_assert (apm->op == IPA_PARAM_OP_SPLIT\n \t\t       || apm->op == IPA_PARAM_OP_NEW);\n   gcc_checking_assert (!apm->prev_clone_adjustment);\n-  ipa_param_body_replacement psr;\n-  psr.base = m_oparms[apm->prev_clone_index];\n-  psr.repl = replacement;\n-  psr.dummy = NULL_TREE;\n-  psr.unit_offset = apm->unit_offset;\n-  m_replacements.safe_push (psr);\n+  register_replacement (m_oparms[apm->prev_clone_index], apm->unit_offset,\n+\t\t\treplacement);\n }\n \n /* Copy or not, as appropriate given m_id and decl context, a pre-existing\n@@ -1386,23 +1364,73 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \tgcc_unreachable ();\n     }\n \n-  if (tree_map)\n+  auto_vec <int, 16> index_mapping;\n+  bool need_remap = false;\n+  if (m_id)\n     {\n-      /* Do not treat parameters which were replaced with a constant as\n-\t completely vanished.  */\n-      auto_vec <int, 16> index_mapping;\n-      bool need_remap = false;\n+      clone_info *cinfo = clone_info::get (m_id->src_node);\n+      if (cinfo && cinfo->param_adjustments)\n+\t{\n+\t  cinfo->param_adjustments->get_updated_indices (&index_mapping);\n+\t  need_remap = true;\n+\t}\n \n-      if (m_id)\n+      if (ipcp_transformation *ipcp_ts\n+\t  = ipcp_get_transformation_summary (m_id->src_node))\n \t{\n-\t  clone_info *cinfo = clone_info::get (m_id->src_node);\n-\t  if (cinfo && cinfo->param_adjustments)\n+\t  for (const ipa_argagg_value &av : ipcp_ts->m_agg_values)\n \t    {\n-\t      cinfo->param_adjustments->get_updated_indices (&index_mapping);\n-\t      need_remap = true;\n+\t      int parm_num = av.index;\n+\n+\t      if (need_remap)\n+\t\t{\n+\t\t  /* FIXME: We cannot handle the situation when IPA-CP\n+\t\t     identified that a parameter is a pointer to a global\n+\t\t     variable and at the same time the variable has some known\n+\t\t     constant contents (PR 107640).  The best place to make\n+\t\t     sure we don't drop such constants on the floor probably is\n+\t\t     not here, but we have to make sure that it does not\n+\t\t     confuse the remapping.  */\n+\t\t  if (parm_num >= (int) index_mapping.length ())\n+\t\t    continue;\n+\t\t  parm_num = index_mapping[parm_num];\n+\t\t  if (parm_num < 0)\n+\t\t    continue;\n+\t\t}\n+\n+\t      if (!kept[parm_num])\n+\t\t{\n+\t\t  /* IPA-CP has detected an aggregate constant in a parameter\n+\t\t     that will not be kept, which means that IPA-SRA would have\n+\t\t     split it if there wasn't a constant.  Because we are about\n+\t\t     to remove the original, this is the last chance where we\n+\t\t     can substitute the uses with a constant (for values passed\n+\t\t     by reference) or do the split but initialize the\n+\t\t     replacement with a constant (for split aggregates passed\n+\t\t     by value).  */\n+\n+\t\t  tree repl;\n+\t\t  if (av.by_ref)\n+\t\t    repl = av.value;\n+\t\t  else\n+\t\t    {\n+\t\t      repl = create_tmp_var (TREE_TYPE (av.value),\n+\t\t\t\t\t     \"removed_ipa_cp\");\n+\t\t      gimple *init_stmt = gimple_build_assign (repl, av.value);\n+\t\t      m_split_agg_csts_inits.safe_push (init_stmt);\n+\t\t    }\n+\t\t  register_replacement (m_oparms[parm_num], av.unit_offset,\n+\t\t\t\t\trepl);\n+\t\t  split[parm_num] = true;\n+\t\t}\n \t    }\n \t}\n+    }\n \n+  if (tree_map)\n+    {\n+      /* Do not treat parameters which were replaced with a constant as\n+\t completely vanished.  */\n       for (unsigned i = 0; i < tree_map->length (); i++)\n \t{\n \t  int parm_num = (*tree_map)[i]->parm_num;\n@@ -1473,8 +1501,9 @@ ::ipa_param_body_adjustments (vec<ipa_adjusted_param, va_gc> *adj_params,\n   : m_adj_params (adj_params), m_adjustments (NULL), m_reset_debug_decls (),\n     m_dead_stmts (), m_dead_ssas (), m_dead_ssa_debug_equiv (),\n     m_dead_stmt_debug_equiv (), m_fndecl (fndecl), m_id (NULL), m_oparms (),\n-    m_new_decls (), m_new_types (), m_replacements (), m_removed_decls (),\n-    m_removed_map (), m_method2func (false)\n+    m_new_decls (), m_new_types (), m_replacements (),\n+    m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1491,7 +1520,8 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n     m_reset_debug_decls (), m_dead_stmts (), m_dead_ssas (),\n     m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (), m_fndecl (fndecl),\n     m_id (NULL), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n-    m_removed_decls (), m_removed_map (), m_method2func (false)\n+    m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1514,7 +1544,8 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n     m_reset_debug_decls (), m_dead_stmts (), m_dead_ssas (),\n     m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (), m_fndecl (fndecl),\n     m_id (id), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n-    m_removed_decls (), m_removed_map (), m_method2func (false)\n+    m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (old_fndecl, vars, tree_map);\n }\n@@ -1731,6 +1762,8 @@ ipa_param_body_adjustments::modify_expression (tree *expr_p, bool convert)\n {\n   tree expr = *expr_p;\n \n+  if (m_replacements.is_empty ())\n+    return false;\n   if (TREE_CODE (expr) == BIT_FIELD_REF\n       || TREE_CODE (expr) == IMAGPART_EXPR\n       || TREE_CODE (expr) == REALPART_EXPR)\n@@ -1778,7 +1811,7 @@ ipa_param_body_adjustments::modify_assignment (gimple *stmt,\n   tree *lhs_p, *rhs_p;\n   bool any;\n \n-  if (!gimple_assign_single_p (stmt))\n+  if (m_replacements.is_empty () || !gimple_assign_single_p (stmt))\n     return false;\n \n   rhs_p = gimple_assign_rhs1_ptr (stmt);\n@@ -2383,6 +2416,16 @@ ipa_param_body_adjustments::perform_cfun_body_modifications ()\n }\n \n \n+/* If there are any initialization statements that need to be emitted into\n+   the basic block BB right at ther start of the new function, do so.  */\n+void\n+ipa_param_body_adjustments::append_init_stmts (basic_block bb)\n+{\n+  gimple_stmt_iterator si = gsi_last_bb (bb);\n+  while (!m_split_agg_csts_inits.is_empty ())\n+    gsi_insert_after (&si, m_split_agg_csts_inits.pop (), GSI_NEW_STMT);\n+}\n+\n /* Deallocate summaries which otherwise stay alive until the end of\n    compilation.  */\n "}, {"sha": "e20d34918b30ba8aa32ffbd17bee16550a007aba", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -236,13 +236,6 @@ class GTY(()) ipa_param_adjustments\n   void get_surviving_params (vec<bool> *surviving_params);\n   /* Fill a vector with new indices of surviving original parameters.  */\n   void get_updated_indices (vec<int> *new_indices);\n-  /* If a parameter with original INDEX has survived intact, return its new\n-     index.  Otherwise return -1.  In that case, if it has been split and there\n-     is a new parameter representing a portion at UNIT_OFFSET for which a value\n-     of a TYPE can be substituted, store its new index into SPLIT_INDEX,\n-     otherwise store -1 there.  */\n-  int get_updated_index_or_split (int index, unsigned unit_offset, tree type,\n-\t\t\t\t  int *split_index);\n   /* Return the original index for the given new parameter index.  Return a\n      negative number if not available.  */\n   int get_original_index (int newidx);\n@@ -321,6 +314,8 @@ class ipa_param_body_adjustments\n \n   /* Change the PARM_DECLs.  */\n   void modify_formal_parameters ();\n+  /* Register a REPLACEMENT for accesses to BASE at UNIT_OFFSET.  */\n+  void register_replacement (tree base, unsigned unit_offset, tree replacement);\n   /* Register a replacement decl for the transformation done in APM.  */\n   void register_replacement (ipa_adjusted_param *apm, tree replacement);\n   /* Lookup a replacement for a given offset within a given parameter.  */\n@@ -340,6 +335,10 @@ class ipa_param_body_adjustments\n      they are mapped to.  */\n   void remap_with_debug_expressions (tree *t);\n \n+  /* If there are any initialization statements that need to be emitted into\n+     the basic block BB right at ther start of the new function, do so.  */\n+  void append_init_stmts (basic_block bb);\n+\n   /* Pointers to data structures defining how the function should be\n      modified.  */\n   vec<ipa_adjusted_param, va_gc> *m_adj_params;\n@@ -405,6 +404,12 @@ class ipa_param_body_adjustments\n \n   auto_vec<ipa_param_body_replacement, 16> m_replacements;\n \n+  /* List of initialization assignments to be put at the beginning of the\n+     cloned function to deal with split aggregates which however have known\n+     constant value and so their PARM_DECL disappears.  */\n+\n+  auto_vec<gimple *, 8> m_split_agg_csts_inits;\n+\n   /* Vector for remapping SSA_BASES from old parameter declarations that are\n      being removed as a part of the transformation.  Before a new VAR_DECL is\n      created, it holds the old PARM_DECL, once the variable is built it is"}, {"sha": "08c7f97efb9642bc47145636f02ee9abee7c8886", "filename": "gcc/ipa-prop.cc", "status": "modified", "additions": 88, "deletions": 121, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-prop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-prop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -5279,80 +5279,72 @@ ipa_prop_read_jump_functions (void)\n     }\n }\n \n-void\n-write_ipcp_transformation_info (output_block *ob, cgraph_node *node)\n+/* Return true if the IPA-CP transformation summary TS is non-NULL and contains\n+   useful info.  */\n+static bool\n+useful_ipcp_transformation_info_p (ipcp_transformation *ts)\n {\n-  int node_ref;\n-  unsigned int count = 0;\n-  lto_symtab_encoder_t encoder;\n+  if (!ts)\n+    return false;\n+  if (!vec_safe_is_empty (ts->m_agg_values)\n+      || !vec_safe_is_empty (ts->bits)\n+      || !vec_safe_is_empty (ts->m_vr))\n+    return true;\n+  return false;\n+}\n \n-  encoder = ob->decl_state->symtab_node_encoder;\n-  node_ref = lto_symtab_encoder_encode (encoder, node);\n+/* Write into OB IPA-CP transfromation summary TS describing NODE.  */\n+\n+void\n+write_ipcp_transformation_info (output_block *ob, cgraph_node *node,\n+\t\t\t\tipcp_transformation *ts)\n+{\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n+  int node_ref = lto_symtab_encoder_encode (encoder, node);\n   streamer_write_uhwi (ob, node_ref);\n \n-  ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n-  if (ts && !vec_safe_is_empty (ts->m_agg_values))\n+  streamer_write_uhwi (ob, vec_safe_length (ts->m_agg_values));\n+  for (const ipa_argagg_value &av : ts->m_agg_values)\n     {\n-      streamer_write_uhwi (ob, ts->m_agg_values->length ());\n-      for (const ipa_argagg_value &av : ts->m_agg_values)\n-\t{\n-\t  struct bitpack_d bp;\n+      struct bitpack_d bp;\n \n-\t  stream_write_tree (ob, av.value, true);\n-\t  streamer_write_uhwi (ob, av.unit_offset);\n-\t  streamer_write_uhwi (ob, av.index);\n+      stream_write_tree (ob, av.value, true);\n+      streamer_write_uhwi (ob, av.unit_offset);\n+      streamer_write_uhwi (ob, av.index);\n \n-\t  bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, av.by_ref, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t}\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, av.by_ref, 1);\n+      streamer_write_bitpack (&bp);\n     }\n-  else\n-    streamer_write_uhwi (ob, 0);\n \n-  if (ts && vec_safe_length (ts->m_vr) > 0)\n+  streamer_write_uhwi (ob, vec_safe_length (ts->m_vr));\n+  for (const ipa_vr &parm_vr : ts->m_vr)\n     {\n-      count = ts->m_vr->length ();\n-      streamer_write_uhwi (ob, count);\n-      for (unsigned i = 0; i < count; ++i)\n+      struct bitpack_d bp;\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, parm_vr.known, 1);\n+      streamer_write_bitpack (&bp);\n+      if (parm_vr.known)\n \t{\n-\t  struct bitpack_d bp;\n-\t  ipa_vr *parm_vr = &(*ts->m_vr)[i];\n-\t  bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, parm_vr->known, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t  if (parm_vr->known)\n-\t    {\n-\t      streamer_write_enum (ob->main_stream, value_rang_type,\n-\t\t\t\t   VR_LAST, parm_vr->type);\n-\t      streamer_write_wide_int (ob, parm_vr->min);\n-\t      streamer_write_wide_int (ob, parm_vr->max);\n-\t    }\n+\t  streamer_write_enum (ob->main_stream, value_rang_type,\n+\t\t\t       VR_LAST, parm_vr.type);\n+\t  streamer_write_wide_int (ob, parm_vr.min);\n+\t  streamer_write_wide_int (ob, parm_vr.max);\n \t}\n     }\n-  else\n-    streamer_write_uhwi (ob, 0);\n \n-  if (ts && vec_safe_length (ts->bits) > 0)\n+  streamer_write_uhwi (ob, vec_safe_length (ts->bits));\n+  for (const ipa_bits *bits_jfunc : ts->bits)\n     {\n-      count = ts->bits->length ();\n-      streamer_write_uhwi (ob, count);\n-\n-      for (unsigned i = 0; i < count; ++i)\n+      struct bitpack_d bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, !!bits_jfunc, 1);\n+      streamer_write_bitpack (&bp);\n+      if (bits_jfunc)\n \t{\n-\t  const ipa_bits *bits_jfunc = (*ts->bits)[i];\n-\t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, !!bits_jfunc, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t  if (bits_jfunc)\n-\t    {\n-\t      streamer_write_widest_int (ob, bits_jfunc->value);\n-\t      streamer_write_widest_int (ob, bits_jfunc->mask);\n-\t    }\n+\t  streamer_write_widest_int (ob, bits_jfunc->value);\n+\t  streamer_write_widest_int (ob, bits_jfunc->mask);\n \t}\n     }\n-  else\n-    streamer_write_uhwi (ob, 0);\n }\n \n /* Stream in the aggregate value replacement chain for NODE from IB.  */\n@@ -5362,12 +5354,12 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n \t\t\t       data_in *data_in)\n {\n   unsigned int count, i;\n+  ipcp_transformation_initialize ();\n+  ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n \n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n-      ipcp_transformation_initialize ();\n-      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n       vec_safe_grow_cleared (ts->m_agg_values, count, true);\n       for (i = 0; i <count; i++)\n \t{\n@@ -5385,8 +5377,6 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n-      ipcp_transformation_initialize ();\n-      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n       vec_safe_grow_cleared (ts->m_vr, count, true);\n       for (i = 0; i < count; i++)\n \t{\n@@ -5407,10 +5397,7 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n-      ipcp_transformation_initialize ();\n-      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n       vec_safe_grow_cleared (ts->bits, count, true);\n-\n       for (i = 0; i < count; i++)\n \t{\n \t  struct bitpack_d bp = streamer_read_bitpack (ib);\n@@ -5432,31 +5419,38 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n void\n ipcp_write_transformation_summaries (void)\n {\n-  struct cgraph_node *node;\n   struct output_block *ob;\n   unsigned int count = 0;\n-  lto_symtab_encoder_iterator lsei;\n   lto_symtab_encoder_t encoder;\n \n   ob = create_output_block (LTO_section_ipcp_transform);\n   encoder = ob->decl_state->symtab_node_encoder;\n   ob->symbol = NULL;\n-  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_function_in_partition (&lsei))\n+\n+  for (int i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lsei_cgraph_node (lsei);\n-      if (node->has_gimple_body_p ())\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n+      if (!cnode)\n+\tcontinue;\n+      ipcp_transformation *ts = ipcp_get_transformation_summary (cnode);\n+      if (useful_ipcp_transformation_info_p (ts)\n+\t  && lto_symtab_encoder_encode_body_p (encoder, cnode))\n \tcount++;\n     }\n \n   streamer_write_uhwi (ob, count);\n \n-  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_function_in_partition (&lsei))\n+  for (int i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lsei_cgraph_node (lsei);\n-      if (node->has_gimple_body_p ())\n-\twrite_ipcp_transformation_info (ob, node);\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n+      if (!cnode)\n+\tcontinue;\n+      ipcp_transformation *ts = ipcp_get_transformation_summary (cnode);\n+      if (useful_ipcp_transformation_info_p (ts)\n+\t  && lto_symtab_encoder_encode_body_p (encoder, cnode))\n+\twrite_ipcp_transformation_info (ob, cnode, ts);\n     }\n   streamer_write_char_stream (ob->main_stream, 0);\n   produce_asm (ob, NULL);\n@@ -5497,7 +5491,6 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n       encoder = file_data->symtab_node_encoder;\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n-      gcc_assert (node->definition);\n       read_ipcp_transformation_info (&ib_main, node, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n@@ -5525,43 +5518,32 @@ ipcp_read_transformation_summaries (void)\n     }\n }\n \n-/* Adjust the aggregate replacements in TS to reflect parameters skipped in\n-   NODE but also if any parameter was IPA-SRAed into a scalar go ahead with\n-   substitution of the default_definitions of that new param with the\n-   appropriate constant.\n+/* Adjust the aggregate replacements in TS to reflect any parameter removals\n+   which might have already taken place.  If after adjustments there are no\n+   aggregate replacements left, the m_agg_values will be set to NULL.  In other\n+   cases, it may be shrunk.  */\n \n-   If after adjustments there are no aggregate replacements left, the\n-   m_agg_values will be set to NULL.  In other cases, it may be shrunk.\n-\n-   Return true if any values were already substituted for scalarized parameters\n-   and update_cfg shuld be run after replace_uses_by.  */\n-\n-static bool\n-adjust_agg_replacement_values (cgraph_node *node,\n-\t\t\t       ipcp_transformation *ts,\n-\t\t\t       const vec<ipa_param_descriptor, va_gc>\n-\t\t\t         &descriptors)\n+static void\n+adjust_agg_replacement_values (cgraph_node *node, ipcp_transformation *ts)\n {\n   clone_info *cinfo = clone_info::get (node);\n   if (!cinfo || !cinfo->param_adjustments)\n-    return false;\n+    return;\n \n+  auto_vec<int, 16> new_indices;\n+  cinfo->param_adjustments->get_updated_indices (&new_indices);\n   bool removed_item = false;\n-  bool done_replacement = false;\n   unsigned dst_index = 0;\n   unsigned count = ts->m_agg_values->length ();\n   for (unsigned i = 0; i < count; i++)\n     {\n       ipa_argagg_value *v = &(*ts->m_agg_values)[i];\n       gcc_checking_assert (v->index >= 0);\n \n-      tree cst_type = TREE_TYPE (v->value);\n-      int split_idx;\n-      int new_idx\n-\t= cinfo->param_adjustments->get_updated_index_or_split (v->index,\n-\t\t\t\t\t\t\t\tv->unit_offset,\n-\t\t\t\t\t\t\t\tcst_type,\n-\t\t\t\t\t\t\t\t&split_idx);\n+      int new_idx = -1;\n+      if ((unsigned) v->index < new_indices.length ())\n+\tnew_idx = new_indices[v->index];\n+\n       if (new_idx >= 0)\n \t{\n \t  v->index = new_idx;\n@@ -5570,19 +5552,7 @@ adjust_agg_replacement_values (cgraph_node *node,\n \t  dst_index++;\n \t}\n       else\n-\t{\n-\t  removed_item = true;\n-\t  if (split_idx >= 0)\n-\t    {\n-\t      tree parm = ipa_get_param (descriptors, split_idx);\n-\t      tree ddef = ssa_default_def (cfun, parm);\n-\t      if (ddef)\n-\t\t{\n-\t\t  replace_uses_by (ddef, v->value);\n-\t\t  done_replacement = true;\n-\t\t}\n-\t    }\n-\t}\n+\tremoved_item = true;\n     }\n \n   if (dst_index == 0)\n@@ -5593,7 +5563,7 @@ adjust_agg_replacement_values (cgraph_node *node,\n   else if (removed_item)\n     ts->m_agg_values->truncate (dst_index);\n \n-  return done_replacement;\n+  return;\n }\n \n /* Dominator walker driving the ipcp modification phase.  */\n@@ -5962,7 +5932,6 @@ ipcp_update_vr (struct cgraph_node *node)\n unsigned int\n ipcp_transform_function (struct cgraph_node *node)\n {\n-  vec<ipa_param_descriptor, va_gc> *descriptors = NULL;\n   struct ipa_func_body_info fbi;\n   int param_count;\n \n@@ -5981,18 +5950,13 @@ ipcp_transform_function (struct cgraph_node *node)\n   param_count = count_formal_params (node->decl);\n   if (param_count == 0)\n     return 0;\n-  vec_safe_grow_cleared (descriptors, param_count, true);\n-  ipa_populate_param_decls (node, *descriptors);\n \n-  bool cfg_changed = adjust_agg_replacement_values (node, ts, *descriptors);\n+  adjust_agg_replacement_values (node, ts);\n   if (vec_safe_is_empty (ts->m_agg_values))\n     {\n-      vec_free (descriptors);\n       if (dump_file)\n \tfprintf (dump_file, \"  All affected aggregate parameters were either \"\n \t\t \"removed or converted into scalars, phase done.\\n\");\n-      if (cfg_changed)\n-\tdelete_unreachable_blocks_update_callgraph (node, false);\n       return 0;\n     }\n   if (dump_file)\n@@ -6009,12 +5973,15 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.param_count = param_count;\n   fbi.aa_walk_budget = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \n+  vec<ipa_param_descriptor, va_gc> *descriptors = NULL;\n+  vec_safe_grow_cleared (descriptors, param_count, true);\n+  ipa_populate_param_decls (node, *descriptors);\n   bool modified_mem_access = false;\n   calculate_dominance_info (CDI_DOMINATORS);\n   ipcp_modif_dom_walker walker (&fbi, descriptors, ts, &modified_mem_access);\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   free_dominance_info (CDI_DOMINATORS);\n-  cfg_changed |= walker.cleanup_eh ();\n+  bool cfg_changed = walker.cleanup_eh ();\n \n   int i;\n   struct ipa_bb_info *bi;"}, {"sha": "93f5e34b15c15de7fd834a10fc7c7e833e17d1c9", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 536, "deletions": 159, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"symtab-clones.h\"\n #include \"attribs.h\"\n+#include \"ipa-prop.h\"\n \n static void ipa_sra_summarize_function (cgraph_node *);\n \n@@ -150,6 +151,8 @@ struct gensum_param_access\n      arguments.  */\n   tree alias_ptr_type;\n \n+  /* Cumulative count of all loads. */\n+  profile_count load_count;\n   /* Have there been writes to or reads from this exact location except for as\n      arguments to a function call that can be tracked.  */\n   bool nonarg;\n@@ -170,6 +173,10 @@ struct GTY(()) isra_param_desc\n   unsigned param_size_limit : ISRA_ARG_SIZE_LIMIT_BITS;\n   /* Sum of unit sizes of all certain replacements.  */\n   unsigned size_reached : ISRA_ARG_SIZE_LIMIT_BITS;\n+  /* Minimum offset that is known to be safe to dereference because of callers\n+     pass pointers to DECLs of at least this size or because of dereferences in\n+     callers.  */\n+  unsigned safe_size : ISRA_ARG_SIZE_LIMIT_BITS;\n \n   /* A parameter that is used only in call arguments and can be removed if all\n      concerned actual arguments are removed.  */\n@@ -178,6 +185,16 @@ struct GTY(()) isra_param_desc\n   unsigned split_candidate : 1;\n   /* Is this a parameter passing stuff by reference?  */\n   unsigned by_ref : 1;\n+  /* Parameter hint set during IPA analysis when there is a caller which does\n+     not construct the argument just to pass it to calls.  Only meaningful for\n+     by_ref parameters.  */\n+  unsigned not_specially_constructed : 1;\n+  /* Only meaningful for by_ref parameters.  If set, this parameter can only be\n+     a split candidate if all callers pass pointers that are known to point to\n+     a chunk of memory large enough to contain all accesses.  */\n+  unsigned conditionally_dereferenceable : 1;\n+  /* Set when safe_size has been updated from at least one caller.  */\n+  unsigned safe_size_set : 1;\n };\n \n /* Structure used when generating summaries that describes a parameter.  */\n@@ -206,8 +223,17 @@ struct gensum_param_desc\n      by reference that is a candidate for being converted to a set of\n      parameters passing those data by value.  */\n   bool split_candidate;\n-  /* Is this a parameter passing stuff by reference?  */\n+  /* Is this a parameter passing stuff by reference (either a pointer or a\n+     source language reference type)?  */\n   bool by_ref;\n+  /* If this parameter passes stuff by reference, can it be safely dereferenced\n+     without performing further checks (for example because it is a\n+     REFERENCE_TYPE)?  */\n+  bool safe_ref;\n+  /* Only meaningful for by_ref parameters.  If set, this parameter can only be\n+     a split candidate if all callers pass pointers that are known to point to\n+     a chunk of memory large enough to contain all accesses.  */\n+  bool conditionally_dereferenceable;\n \n   /* The number of this parameter as they are ordered in function decl.  */\n   int param_number;\n@@ -320,10 +346,12 @@ struct isra_param_flow\n \n   /* Offset within the formal parameter.  */\n   unsigned unit_offset;\n-  /* Size of the portion of the formal parameter that is being passed.  */\n+  /* When aggregate_pass_through is set, this is the size of the portion of an\n+     aggregate formal parameter that is being passed.  Otherwise, this is size\n+     of pointed to memory that is known to be valid be dereferenced.  */\n   unsigned unit_size : ISRA_ARG_SIZE_LIMIT_BITS;\n \n-  /* True when the value of this actual copy is a portion of a formal\n+  /* True when the value of this actual argument is a portion of a formal\n      parameter.  */\n   unsigned aggregate_pass_through : 1;\n   /* True when the value of this actual copy is a verbatim pass through of an\n@@ -332,6 +360,10 @@ struct isra_param_flow\n   /* True when it is safe to copy access candidates here from the callee, which\n      would mean introducing dereferences into callers of the caller.  */\n   unsigned safe_to_import_accesses : 1;\n+  /* True when the passed value is an address of a structure that has been\n+     constructed in the caller just to be passed by reference to functions\n+     (i.e. is never read).  */\n+  unsigned constructed_for_calls : 1;\n };\n \n /* Structure used to convey information about calls from the intra-procedural\n@@ -409,9 +441,13 @@ ipa_sra_function_summaries::duplicate (cgraph_node *, cgraph_node *,\n \n       d->param_size_limit = s->param_size_limit;\n       d->size_reached = s->size_reached;\n+      d->safe_size = s->safe_size;\n       d->locally_unused = s->locally_unused;\n       d->split_candidate = s->split_candidate;\n       d->by_ref = s->by_ref;\n+      d->not_specially_constructed = s->not_specially_constructed;\n+      d->conditionally_dereferenceable = s->conditionally_dereferenceable;\n+      d->safe_size_set = s->safe_size_set;\n \n       unsigned acc_count = vec_safe_length (s->accesses);\n       vec_safe_reserve_exact (d->accesses, acc_count);\n@@ -520,9 +556,14 @@ isra_call_summary::dump (FILE *f)\n \tfprintf (f, \"      Aggregate pass through from the param given above, \"\n \t\t \"unit offset: %u , unit size: %u\\n\",\n \t\t ipf->unit_offset, ipf->unit_size);\n+      else if (ipf->unit_size > 0)\n+\tfprintf (f, \"      Known dereferenceable size: %u\\n\", ipf->unit_size);\n       if (ipf->pointer_pass_through)\n \tfprintf (f, \"      Pointer pass through from the param given above, \"\n \t\t \"safe_to_import_accesses: %u\\n\", ipf->safe_to_import_accesses);\n+      if (ipf->constructed_for_calls)\n+\tfprintf (f, \"      Variable constructed just to be passed to \"\n+\t\t \"calls.\\n\");\n     }\n }\n \n@@ -551,6 +592,10 @@ namespace {\n \n hash_map<tree, gensum_param_desc *> *decl2desc;\n \n+/* All local DECLs ever loaded from.  */\n+\n+hash_set <tree> *loaded_decls;\n+\n /* Countdown of allowed Alias Analysis steps during summary building.  */\n \n int aa_walking_limit;\n@@ -560,7 +605,7 @@ int aa_walking_limit;\n    accessed in that BB.  */\n HOST_WIDE_INT *bb_dereferences = NULL;\n /* How many by-reference parameters there are in the current function.  */\n-int by_ref_count;\n+int unsafe_by_ref_count;\n \n /* Bitmap of BBs that can cause the function to \"stop\" progressing by\n    returning, throwing externally, looping infinitely or calling a function\n@@ -642,6 +687,8 @@ dump_gensum_access (FILE *f, gensum_param_access *access, unsigned indent)\n   print_generic_expr (f, access->type);\n   fprintf (f, \", alias_ptr_type: \");\n   print_generic_expr (f, access->alias_ptr_type);\n+  fprintf (f, \", load_count: \");\n+  access->load_count.dump (f);\n   fprintf (f, \", nonarg: %u, reverse: %u\\n\", access->nonarg, access->reverse);\n   for (gensum_param_access *ch = access->first_child;\n        ch;\n@@ -691,7 +738,11 @@ dump_gensum_param_descriptor (FILE *f, gensum_param_desc *desc)\n       return;\n     }\n   if (desc->by_ref)\n-    fprintf (f, \"    by_ref with %u pass throughs\\n\", desc->ptr_pt_count);\n+    fprintf (f, \"    %s%s by_ref with %u pass throughs\\n\",\n+\t     desc->safe_ref ? \"safe\" : \"unsafe\",\n+\t     desc->conditionally_dereferenceable\n+\t     ? \" conditionally_dereferenceable\" : \" ok\",\n+\t     desc->ptr_pt_count);\n \n   for (gensum_param_access *acc = desc->accesses; acc; acc = acc->next_sibling)\n     dump_gensum_access (f, acc, 2);\n@@ -717,23 +768,37 @@ dump_gensum_param_descriptors (FILE *f, tree fndecl,\n }\n \n \n-/* Dump DESC to F.   */\n+/* Dump DESC to F.  If HINTS is true, also dump IPA-analysis computed\n+   hints.  */\n \n static void\n-dump_isra_param_descriptor (FILE *f, isra_param_desc *desc)\n+dump_isra_param_descriptor (FILE *f, isra_param_desc *desc, bool hints)\n {\n   if (desc->locally_unused)\n     {\n       fprintf (f, \"    (locally) unused\\n\");\n     }\n   if (!desc->split_candidate)\n     {\n-      fprintf (f, \"    not a candidate for splitting\\n\");\n+      fprintf (f, \"    not a candidate for splitting\");\n+      if (hints && desc->by_ref && desc->safe_size_set)\n+\tfprintf (f, \", safe_size: %u\", (unsigned) desc->safe_size);\n+      fprintf (f, \"\\n\");\n       return;\n     }\n-  fprintf (f, \"    param_size_limit: %u, size_reached: %u%s\\n\",\n+  fprintf (f, \"    param_size_limit: %u, size_reached: %u%s\",\n \t   desc->param_size_limit, desc->size_reached,\n \t   desc->by_ref ? \", by_ref\" : \"\");\n+  if (desc->by_ref && desc->conditionally_dereferenceable)\n+    fprintf (f, \", conditionally_dereferenceable\");\n+  if (hints)\n+    {\n+      if (desc->by_ref && !desc->not_specially_constructed)\n+\tfprintf (f, \", args_specially_constructed\");\n+      if (desc->by_ref && desc->safe_size_set)\n+\tfprintf (f, \", safe_size: %u\", (unsigned) desc->safe_size);\n+    }\n+  fprintf (f, \"\\n\");\n \n   for (unsigned i = 0; i < vec_safe_length (desc->accesses); ++i)\n     {\n@@ -742,12 +807,12 @@ dump_isra_param_descriptor (FILE *f, isra_param_desc *desc)\n     }\n }\n \n-/* Dump all parameter descriptors in IFS, assuming it describes FNDECL, to\n-   F.  */\n+/* Dump all parameter descriptors in IFS, assuming it describes FNDECL, to F.\n+   If HINTS is true, also dump IPA-analysis computed hints.  */\n \n static void\n-dump_isra_param_descriptors (FILE *f, tree fndecl,\n-\t\t\t     isra_func_summary *ifs)\n+dump_isra_param_descriptors (FILE *f, tree fndecl, isra_func_summary *ifs,\n+\t\t\t     bool hints)\n {\n   tree parm = DECL_ARGUMENTS (fndecl);\n   if (!ifs->m_parameters)\n@@ -763,7 +828,7 @@ dump_isra_param_descriptors (FILE *f, tree fndecl,\n       fprintf (f, \"  Descriptor for parameter %i \", i);\n       print_generic_expr (f, parm, TDF_UID);\n       fprintf (f, \"\\n\");\n-      dump_isra_param_descriptor (f, &(*ifs->m_parameters)[i]);\n+      dump_isra_param_descriptor (f, &(*ifs->m_parameters)[i], hints);\n     }\n }\n \n@@ -1075,7 +1140,7 @@ ptr_parm_has_nonarg_uses (cgraph_node *node, function *fun, tree parm,\n /* Initialize vector of parameter descriptors of NODE.  Return true if there\n    are any candidates for splitting or unused aggregate parameter removal (the\n    function may return false if there are candidates for removal of register\n-   parameters) and function body must be scanned.  */\n+   parameters).  */\n \n static bool\n create_parameter_descriptors (cgraph_node *node,\n@@ -1139,6 +1204,8 @@ create_parameter_descriptors (cgraph_node *node,\n \n       if (POINTER_TYPE_P (type))\n \t{\n+\t  desc->by_ref = true;\n+\t  desc->safe_ref = (TREE_CODE (type) == REFERENCE_TYPE);\n \t  type = TREE_TYPE (type);\n \n \t  if (TREE_CODE (type) == FUNCTION_TYPE\n@@ -1186,7 +1253,6 @@ create_parameter_descriptors (cgraph_node *node,\n \t\t\t \"nonarg uses\\n\");\n \t      continue;\n \t    }\n-\t  desc->by_ref = true;\n \t}\n       else if (!AGGREGATE_TYPE_P (type))\n \t{\n@@ -1230,8 +1296,8 @@ create_parameter_descriptors (cgraph_node *node,\n \n       ret = true;\n       desc->split_candidate = true;\n-      if (desc->by_ref)\n-\tdesc->deref_index = by_ref_count++;\n+      if (desc->by_ref && !desc->safe_ref)\n+\tdesc->deref_index = unsafe_by_ref_count++;\n     }\n   return ret;\n }\n@@ -1242,6 +1308,8 @@ create_parameter_descriptors (cgraph_node *node,\n static gensum_param_desc *\n get_gensum_param_desc (tree decl)\n {\n+  if (!decl2desc)\n+    return NULL;\n   gcc_checking_assert (TREE_CODE (decl) == PARM_DECL);\n   gensum_param_desc **slot = decl2desc->get (decl);\n   if (!slot)\n@@ -1300,6 +1368,7 @@ allocate_access (gensum_param_desc *desc,\n   memset (access, 0, sizeof (*access));\n   access->offset = offset;\n   access->size = size;\n+  access->load_count = profile_count::zero ();\n   return access;\n }\n \n@@ -1554,15 +1623,16 @@ asm_visit_addr (gimple *, tree op, tree, void *)\n \n static void\n mark_param_dereference (gensum_param_desc *desc, HOST_WIDE_INT dist,\n-\t\t       basic_block bb)\n+\t\t\tbasic_block bb)\n {\n   gcc_assert (desc->by_ref);\n   gcc_checking_assert (desc->split_candidate);\n \n-  if (bitmap_bit_p (final_bbs, bb->index))\n+  if (desc->safe_ref\n+      || bitmap_bit_p (final_bbs, bb->index))\n     return;\n \n-  int idx = bb->index * by_ref_count + desc->deref_index;\n+  int idx = bb->index * unsafe_by_ref_count + desc->deref_index;\n   if (bb_dereferences[idx] < dist)\n     bb_dereferences[idx] = dist;\n }\n@@ -1691,6 +1761,12 @@ scan_expr_access (tree expr, gimple *stmt, isra_scan_context ctx,\n \treturn;\n       deref = true;\n     }\n+  else if (TREE_CODE (base) == VAR_DECL\n+\t   && !TREE_STATIC (base)\n+\t   && (ctx == ISRA_CTX_ARG\n+\t       || ctx == ISRA_CTX_LOAD))\n+    loaded_decls->add (base);\n+\n   if (TREE_CODE (base) != PARM_DECL)\n     return;\n \n@@ -1810,6 +1886,8 @@ scan_expr_access (tree expr, gimple *stmt, isra_scan_context ctx,\n \t   other.  */\n \taccess->nonarg = true;\n     }\n+  else if (ctx == ISRA_CTX_LOAD && bb->count.initialized_p ())\n+    access->load_count += bb->count;\n \n   if (!access->type)\n     {\n@@ -1868,7 +1946,7 @@ scan_function (cgraph_node *node, struct function *fun)\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n \n-\t  if (stmt_can_throw_external (fun, stmt))\n+\t  if (final_bbs && stmt_can_throw_external (fun, stmt))\n \t    bitmap_set_bit (final_bbs, bb->index);\n \t  switch (gimple_code (stmt))\n \t    {\n@@ -1877,7 +1955,8 @@ scan_function (cgraph_node *node, struct function *fun)\n \t\ttree t = gimple_return_retval (as_a <greturn *> (stmt));\n \t\tif (t != NULL_TREE)\n \t\t  scan_expr_access (t, stmt, ISRA_CTX_LOAD, bb);\n-\t\tbitmap_set_bit (final_bbs, bb->index);\n+\t\tif (final_bbs)\n+\t\t  bitmap_set_bit (final_bbs, bb->index);\n \t      }\n \t      break;\n \n@@ -1922,8 +2001,9 @@ scan_function (cgraph_node *node, struct function *fun)\n \t\tif (lhs)\n \t\t  scan_expr_access (lhs, stmt, ISRA_CTX_STORE, bb);\n \t\tint flags = gimple_call_flags (stmt);\n-\t\tif (((flags & (ECF_CONST | ECF_PURE)) == 0)\n-\t\t    || (flags & ECF_LOOPING_CONST_OR_PURE))\n+\t\tif (final_bbs\n+\t\t    && (((flags & (ECF_CONST | ECF_PURE)) == 0)\n+\t\t\t|| (flags & ECF_LOOPING_CONST_OR_PURE)))\n \t\t  bitmap_set_bit (final_bbs, bb->index);\n \t      }\n \t      break;\n@@ -1933,7 +2013,8 @@ scan_function (cgraph_node *node, struct function *fun)\n \t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n \t\twalk_stmt_load_store_addr_ops (asm_stmt, NULL, NULL, NULL,\n \t\t\t\t\t       asm_visit_addr);\n-\t\tbitmap_set_bit (final_bbs, bb->index);\n+\t\tif (final_bbs)\n+\t\t  bitmap_set_bit (final_bbs, bb->index);\n \n \t\tfor (unsigned i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n \t\t  {\n@@ -2029,6 +2110,34 @@ isra_analyze_call (cgraph_edge *cs)\n   for (unsigned i = 0; i < count; i++)\n     {\n       tree arg = gimple_call_arg (call_stmt, i);\n+      if (TREE_CODE (arg) == ADDR_EXPR)\n+\t{\n+\t  poly_int64 poffset, psize, pmax_size;\n+\t  bool reverse;\n+\t  tree base = get_ref_base_and_extent (TREE_OPERAND (arg, 0), &poffset,\n+\t\t\t\t\t       &psize, &pmax_size, &reverse);\n+\t  HOST_WIDE_INT offset;\n+\t  unsigned HOST_WIDE_INT ds;\n+\t  if (DECL_P (base)\n+\t      && (poffset.is_constant (&offset))\n+\t      && tree_fits_uhwi_p (DECL_SIZE (base))\n+\t      && ((ds = tree_to_uhwi (DECL_SIZE (base)) - offset)\n+\t\t  < ISRA_ARG_SIZE_LIMIT * BITS_PER_UNIT))\n+\t    {\n+\t      csum->init_inputs (count);\n+\t      gcc_assert (!csum->m_arg_flow[i].aggregate_pass_through);\n+\t      csum->m_arg_flow[i].unit_size = ds / BITS_PER_UNIT;\n+\t    }\n+\n+\t  if (TREE_CODE (base) == VAR_DECL\n+\t      && !TREE_STATIC (base)\n+\t      && !loaded_decls->contains (base))\n+\t    {\n+\t      csum->init_inputs (count);\n+\t      csum->m_arg_flow[i].constructed_for_calls = true;\n+\t    }\n+\t}\n+\n       if (is_gimple_reg (arg))\n \tcontinue;\n \n@@ -2091,9 +2200,9 @@ dump_dereferences_table (FILE *f, struct function *fun, const char *str)\n       if (bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n \t{\n \t  int i;\n-\t  for (i = 0; i < by_ref_count; i++)\n+\t  for (i = 0; i < unsafe_by_ref_count; i++)\n \t    {\n-\t      int idx = bb->index * by_ref_count + i;\n+\t      int idx = bb->index * unsafe_by_ref_count + i;\n \t      fprintf (f, \" %4\" HOST_WIDE_INT_PRINT \"d\", bb_dereferences[idx]);\n \t    }\n \t}\n@@ -2138,15 +2247,15 @@ propagate_dereference_distances (struct function *fun)\n       if (bitmap_bit_p (final_bbs, bb->index))\n \tcontinue;\n \n-      for (i = 0; i < by_ref_count; i++)\n+      for (i = 0; i < unsafe_by_ref_count; i++)\n \t{\n-\t  int idx = bb->index * by_ref_count + i;\n+\t  int idx = bb->index * unsafe_by_ref_count + i;\n \t  bool first = true;\n \t  HOST_WIDE_INT inh = 0;\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t  {\n-\t    int succ_idx = e->dest->index * by_ref_count + i;\n+\t    int succ_idx = e->dest->index * unsafe_by_ref_count + i;\n \n \t    if (e->dest == EXIT_BLOCK_PTR_FOR_FN (fun))\n \t      continue;\n@@ -2183,13 +2292,24 @@ propagate_dereference_distances (struct function *fun)\n \t\t\t     \"Dereference table after propagation:\\n\");\n }\n \n-/* Perform basic checks on ACCESS to PARM described by DESC and all its\n-   children, return true if the parameter cannot be split, otherwise return\n-   true and update *TOTAL_SIZE and *ONLY_CALLS.  ENTRY_BB_INDEX must be the\n-   index of the entry BB in the function of PARM.  */\n+/* Return true if the ACCESS loads happen frequently enough in FUN to risk\n+   moving them to the caller and only pass the result.  */\n \n static bool\n-check_gensum_access (tree parm, gensum_param_desc *desc,\n+dereference_probable_p (struct function *fun, gensum_param_access *access)\n+{\n+  int threshold = opt_for_fn (fun->decl, param_ipa_sra_deref_prob_threshold);\n+  return access->load_count\n+    >= ENTRY_BLOCK_PTR_FOR_FN (fun)->count.apply_scale (threshold, 100);\n+}\n+\n+/* Perform basic checks on ACCESS to PARM (of FUN) described by DESC and all\n+   its children, return true if the parameter cannot be split, otherwise return\n+   false and update *NONARG_ACC_SIZE and *ONLY_CALLS.  ENTRY_BB_INDEX must be\n+   the index of the entry BB in the function of PARM.  */\n+\n+static bool\n+check_gensum_access (struct function *fun, tree parm, gensum_param_desc *desc,\n \t\t     gensum_param_access *access,\n \t\t     HOST_WIDE_INT *nonarg_acc_size, bool *only_calls,\n \t\t     int entry_bb_index)\n@@ -2217,19 +2337,36 @@ check_gensum_access (tree parm, gensum_param_desc *desc,\n \n   if (desc->by_ref)\n     {\n-      int idx = (entry_bb_index * by_ref_count + desc->deref_index);\n-      if ((access->offset + access->size) > bb_dereferences[idx])\n+      if (desc->safe_ref)\n \t{\n-\t  disqualify_split_candidate (desc, \"Would create a possibly \"\n-\t\t\t\t      \"illegal dereference in a caller.\");\n-\t  return true;\n+\t  if (!dereference_probable_p (fun, access))\n+\t    {\n+\t      disqualify_split_candidate (desc, \"Dereferences in callers \"\n+\t\t\t\t\t  \"would happen much more frequently.\");\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  int idx = (entry_bb_index * unsafe_by_ref_count + desc->deref_index);\n+\t  if ((access->offset + access->size) > bb_dereferences[idx])\n+\t    {\n+\t      if (!dereference_probable_p (fun, access))\n+\t\t{\n+\t\t  disqualify_split_candidate (desc, \"Would create a possibly \"\n+\t\t\t\t\t      \"illegal dereference in a \"\n+\t\t\t\t\t      \"caller.\");\n+\t\t  return true;\n+\t\t}\n+\t      desc->conditionally_dereferenceable = true;\n+\t    }\n \t}\n     }\n \n   for (gensum_param_access *ch = access->first_child;\n        ch;\n        ch = ch->next_sibling)\n-    if (check_gensum_access (parm, desc, ch, nonarg_acc_size, only_calls,\n+    if (check_gensum_access (fun, parm, desc, ch, nonarg_acc_size, only_calls,\n \t\t\t     entry_bb_index))\n       return true;\n \n@@ -2287,6 +2424,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \n       if (!dereferences_propagated\n \t  && desc->by_ref\n+\t  && !desc->safe_ref\n \t  && desc->accesses)\n \t{\n \t  propagate_dereference_distances (fun);\n@@ -2301,8 +2439,8 @@ process_scan_results (cgraph_node *node, struct function *fun,\n       for (gensum_param_access *acc = desc->accesses;\n \t   acc;\n \t   acc = acc->next_sibling)\n-\tif (check_gensum_access (parm, desc, acc, &nonarg_acc_size, &only_calls,\n-\t\t\t\t entry_bb_index))\n+\tif (check_gensum_access (fun, parm, desc, acc, &nonarg_acc_size,\n+\t\t\t\t &only_calls, entry_bb_index))\n \t  {\n \t    check_failed = true;\n \t    break;\n@@ -2315,18 +2453,28 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \n       HOST_WIDE_INT cur_param_size\n \t= tree_to_uhwi (TYPE_SIZE (TREE_TYPE (parm)));\n-      HOST_WIDE_INT param_size_limit;\n+      HOST_WIDE_INT param_size_limit, optimistic_limit;\n       if (!desc->by_ref || optimize_function_for_size_p (fun))\n-\tparam_size_limit = cur_param_size;\n+\t{\n+\t  param_size_limit = cur_param_size;\n+\t  optimistic_limit = cur_param_size;\n+\t}\n       else\n+\t{\n \t  param_size_limit\n \t    = opt_for_fn (node->decl,\n \t\t\t  param_ipa_sra_ptr_growth_factor) * cur_param_size;\n-      if (nonarg_acc_size > param_size_limit\n+\t  optimistic_limit\n+\t    = (opt_for_fn (node->decl, param_ipa_sra_ptrwrap_growth_factor)\n+\t       * param_size_limit);\n+\t}\n+\n+      if (nonarg_acc_size > optimistic_limit\n \t  || (!desc->by_ref && nonarg_acc_size == param_size_limit))\n \t{\n \t  disqualify_split_candidate (desc, \"Would result into a too big set \"\n-\t\t\t\t      \"of replacements.\");\n+\t\t\t\t      \"of replacements even in best \"\n+\t\t\t\t      \"scenarios.\");\n \t}\n       else\n \t{\n@@ -2393,6 +2541,12 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \t    if (!uses_memory_as_obtained)\n \t      continue;\n \n+\t    if (desc->safe_ref)\n+\t      {\n+\t\tcsum->m_arg_flow[argidx].safe_to_import_accesses = true;\n+\t\tcontinue;\n+\t      }\n+\n \t    /* Post-dominator check placed last, hoping that it usually won't\n \t       be needed.  */\n \t    if (!pdoms_calculated)\n@@ -2433,6 +2587,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n       d->locally_unused = s->locally_unused;\n       d->split_candidate = s->split_candidate;\n       d->by_ref = s->by_ref;\n+      d->conditionally_dereferenceable = s->conditionally_dereferenceable;\n \n       for (gensum_param_access *acc = s->accesses;\n \t   acc;\n@@ -2441,7 +2596,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n     }\n \n   if (dump_file)\n-    dump_isra_param_descriptors (dump_file, node->decl, ifs);\n+    dump_isra_param_descriptors (dump_file, node->decl, ifs, false);\n }\n \n /* Return true if there are any overlaps among certain accesses of DESC.  If\n@@ -2542,6 +2697,7 @@ isra_write_edge_summary (output_block *ob, cgraph_edge *e)\n       bp_pack_value (&bp, ipf->aggregate_pass_through, 1);\n       bp_pack_value (&bp, ipf->pointer_pass_through, 1);\n       bp_pack_value (&bp, ipf->safe_to_import_accesses, 1);\n+      bp_pack_value (&bp, ipf->constructed_for_calls, 1);\n       streamer_write_bitpack (&bp);\n       streamer_write_uhwi (ob, ipf->unit_offset);\n       streamer_write_uhwi (ob, ipf->unit_size);\n@@ -2586,10 +2742,14 @@ isra_write_node_summary (output_block *ob, cgraph_node *node)\n \t}\n       streamer_write_uhwi (ob, desc->param_size_limit);\n       streamer_write_uhwi (ob, desc->size_reached);\n+      gcc_assert (desc->safe_size == 0);\n       bitpack_d bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, desc->locally_unused, 1);\n       bp_pack_value (&bp, desc->split_candidate, 1);\n       bp_pack_value (&bp, desc->by_ref, 1);\n+      gcc_assert (!desc->not_specially_constructed);\n+      bp_pack_value (&bp, desc->conditionally_dereferenceable, 1);\n+      gcc_assert (!desc->safe_size_set);\n       streamer_write_bitpack (&bp);\n     }\n   bitpack_d bp = bitpack_create (ob->main_stream);\n@@ -2663,6 +2823,7 @@ isra_read_edge_summary (struct lto_input_block *ib, cgraph_edge *cs)\n       ipf->aggregate_pass_through = bp_unpack_value (&bp, 1);\n       ipf->pointer_pass_through = bp_unpack_value (&bp, 1);\n       ipf->safe_to_import_accesses = bp_unpack_value (&bp, 1);\n+      ipf->constructed_for_calls = bp_unpack_value (&bp, 1);\n       ipf->unit_offset = streamer_read_uhwi (ib);\n       ipf->unit_size = streamer_read_uhwi (ib);\n     }\n@@ -2705,10 +2866,14 @@ isra_read_node_info (struct lto_input_block *ib, cgraph_node *node,\n \t}\n       desc->param_size_limit = streamer_read_uhwi (ib);\n       desc->size_reached = streamer_read_uhwi (ib);\n+      desc->safe_size = 0;\n       bitpack_d bp = streamer_read_bitpack (ib);\n       desc->locally_unused = bp_unpack_value (&bp, 1);\n       desc->split_candidate = bp_unpack_value (&bp, 1);\n       desc->by_ref = bp_unpack_value (&bp, 1);\n+      desc->not_specially_constructed = 0;\n+      desc->conditionally_dereferenceable = bp_unpack_value (&bp, 1);\n+      desc->safe_size_set = 0;\n     }\n   bitpack_d bp = streamer_read_bitpack (ib);\n   ifs->m_candidate = bp_unpack_value (&bp, 1);\n@@ -2791,10 +2956,11 @@ ipa_sra_read_summary (void)\n     }\n }\n \n-/* Dump all IPA-SRA summary data for all cgraph nodes and edges to file F.  */\n+/* Dump all IPA-SRA summary data for all cgraph nodes and edges to file F.  If\n+   HINTS is true, also dump IPA-analysis computed hints.  */\n \n static void\n-ipa_sra_dump_all_summaries (FILE *f)\n+ipa_sra_dump_all_summaries (FILE *f, bool hints)\n {\n   cgraph_node *node;\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n@@ -2817,7 +2983,7 @@ ipa_sra_dump_all_summaries (FILE *f)\n \t    for (unsigned i = 0; i < ifs->m_parameters->length (); ++i)\n \t      {\n \t\tfprintf (f, \"  Descriptor for parameter %i:\\n\", i);\n-\t\tdump_isra_param_descriptor (f, &(*ifs->m_parameters)[i]);\n+\t\tdump_isra_param_descriptor (f, &(*ifs->m_parameters)[i], hints);\n \t      }\n \t  fprintf (f, \"\\n\");\n \t}\n@@ -3154,6 +3320,130 @@ isra_mark_caller_param_used (isra_func_summary *from_ifs, int input_idx,\n     }\n }\n \n+/* Combine safe_size of DESC with SIZE and return true if it has changed.  */\n+\n+static bool\n+update_safe_size (isra_param_desc *desc, unsigned size)\n+{\n+  if (!desc->safe_size_set)\n+    {\n+      desc->safe_size_set = 1;\n+      desc->safe_size = size;\n+      return true;\n+    }\n+  if (desc->safe_size <= size)\n+    return false;\n+  desc->safe_size = size;\n+  return true;\n+}\n+\n+/* Set all param hints in DESC to the pessimistic values.  Return true if any\n+   hints that need to potentially trigger further propagation have changed.  */\n+\n+static bool\n+flip_all_hints_pessimistic (isra_param_desc *desc)\n+{\n+  desc->not_specially_constructed = true;\n+  return update_safe_size (desc, 0);\n+}\n+\n+/* Because we have not analyzed or otherwise problematic caller, go over all\n+   parameter int flags of IFS describing a call graph node of a calllee and\n+   turn them pessimistic.  Return true if any hints that need to potentially\n+   trigger further propagation have changed.  */\n+\n+static bool\n+flip_all_param_hints_pessimistic (isra_func_summary *ifs)\n+{\n+  if (!ifs || !ifs->m_candidate)\n+    return false;\n+\n+  bool ret = false;\n+  unsigned param_count = vec_safe_length (ifs->m_parameters);\n+\n+  for (unsigned i = 0; i < param_count; i++)\n+    ret |= flip_all_hints_pessimistic (&(*ifs->m_parameters)[i]);\n+\n+  return ret;\n+}\n+\n+/* Propagate hints accross edge CS which ultimately leads to a node described\n+   by TO_IFS.  Return true if any hints of the callee which should potentially\n+   trigger further propagation have changed.  */\n+\n+static bool\n+propagate_param_hints_accross_call (cgraph_edge *cs, isra_func_summary *to_ifs)\n+{\n+  if (!to_ifs || !to_ifs->m_candidate)\n+    return false;\n+\n+  isra_call_summary *csum = call_sums->get (cs);\n+  bool ret = false;\n+  unsigned args_count = csum->m_arg_flow.length ();\n+  unsigned param_count = vec_safe_length (to_ifs->m_parameters);\n+\n+  for (unsigned i = 0; i < param_count; i++)\n+    {\n+      isra_param_desc *desc = &(*to_ifs->m_parameters)[i];\n+      if (i >= args_count)\n+\t{\n+\t  ret |= flip_all_hints_pessimistic (desc);\n+\t  continue;\n+\t}\n+\n+      if (desc->by_ref)\n+\t{\n+\t  isra_param_flow *ipf = &csum->m_arg_flow[i];\n+\n+\t  if (!ipf->constructed_for_calls)\n+\t    desc->not_specially_constructed = true;\n+\n+\t  if (ipf->pointer_pass_through)\n+\t    {\n+\t      isra_func_summary *from_ifs = func_sums->get (cs->caller);\n+\t      int srcidx = get_single_param_flow_source (ipf);\n+\t      if (vec_safe_length (from_ifs->m_parameters) > (unsigned) srcidx)\n+\t\t{\n+\t\t  isra_param_desc *src_d = &(*from_ifs->m_parameters)[srcidx];\n+\t\t  if (src_d->safe_size_set)\n+\t\t    ret |= update_safe_size (desc, src_d->safe_size);\n+\t\t}\n+\t      else\n+\t\tret |= update_safe_size (desc, 0);\n+\t    }\n+\t  else if (!ipf->aggregate_pass_through)\n+\t    ret |= update_safe_size (desc, ipf->unit_size);\n+\t  else\n+\t    /* LTOing type-mismatched programs can end up here.  */\n+\t    ret |= update_safe_size (desc, 0);\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Propagate hints from NODE described by FROM_IFS to all its (dorect) callees,\n+   push those that may need re-visiting onto STACK.  */\n+\n+static void\n+propagate_hints_to_all_callees (cgraph_node *node, isra_func_summary *from_ifs,\n+\t\t\t\tvec<cgraph_node *> *stack)\n+{\n+  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n+    {\n+      enum availability availability;\n+      cgraph_node *callee = cs->callee->function_symbol (&availability);\n+      isra_func_summary *to_ifs = func_sums->get (callee);\n+      if (!from_ifs)\n+\t{\n+\t  if (flip_all_param_hints_pessimistic (to_ifs)\n+\t      && ipa_edge_within_scc (cs))\n+\t    isra_push_node_to_stack (callee, to_ifs, stack);\n+\t}\n+      else if (propagate_param_hints_accross_call (cs, to_ifs)\n+\t       && ipa_edge_within_scc (cs))\n+\tisra_push_node_to_stack (callee, to_ifs, stack);\n+    }\n+}\n \n /* Propagate information that any parameter is not used only locally within a\n    SCC across CS to the caller, which must be in the same SCC as the\n@@ -3605,13 +3895,16 @@ retval_used_p (cgraph_node *node, void *)\n /* Push into NEW_PARAMS all required parameter adjustment entries to copy or\n    modify parameter which originally had index BASE_INDEX, in the adjustment\n    vector of parent clone (if any) had PREV_CLONE_INDEX and was described by\n-   PREV_ADJUSTMENT.  If the parent clone is the original function,\n-   PREV_ADJUSTMENT is NULL and PREV_CLONE_INDEX is equal to BASE_INDEX.  */\n+   PREV_ADJUSTMENT.  If IPA-CP has created a transformation summary for the\n+   original node, it needs to be passed in IPCP_TS, otherwise it should be\n+   NULL.  If the parent clone is the original function, PREV_ADJUSTMENT is NULL\n+   and PREV_CLONE_INDEX is equal to BASE_INDEX.  */\n \n static void\n push_param_adjustments_for_index (isra_func_summary *ifs, unsigned base_index,\n \t\t\t\t  unsigned prev_clone_index,\n \t\t\t\t  ipa_adjusted_param *prev_adjustment,\n+\t\t\t\t  ipcp_transformation *ipcp_ts,\n \t\t\t\t  vec<ipa_adjusted_param, va_gc> **new_params)\n {\n   isra_param_desc *desc = &(*ifs->m_parameters)[base_index];\n@@ -3652,6 +3945,23 @@ push_param_adjustments_for_index (isra_func_summary *ifs, unsigned base_index,\n       param_access *pa = (*desc->accesses)[j];\n       if (!pa->certain)\n \tcontinue;\n+\n+      if (ipcp_ts)\n+\t{\n+\t  ipa_argagg_value_list avl (ipcp_ts);\n+\t  tree value = avl.get_value (base_index, pa->unit_offset);\n+\t  if (value\n+\t      && (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (value))) / BITS_PER_UNIT\n+\t\t  == pa->unit_size))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    - omitting component at byte \"\n+\t\t\t \"offset %u which is known to have a constant value\\n \",\n+\t\t\t pa->unit_offset);\n+\t      continue;\n+\t    }\n+\t}\n+\n       if (dump_file)\n \tfprintf (dump_file, \"    - component at byte offset %u, \"\n \t\t \"size %u\\n\", pa->unit_offset, pa->unit_size);\n@@ -3732,6 +4042,7 @@ process_isra_node_results (cgraph_node *node,\n \tfprintf (dump_file, \"  Will remove return value.\\n\");\n     }\n \n+  ipcp_transformation *ipcp_ts = ipcp_get_transformation_summary (node);\n   vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n   if (ipa_param_adjustments *old_adjustments\n \t = cinfo ? cinfo->param_adjustments : NULL)\n@@ -3741,12 +4052,12 @@ process_isra_node_results (cgraph_node *node,\n \t{\n \t  ipa_adjusted_param *old_adj = &(*old_adjustments->m_adj_params)[i];\n \t  push_param_adjustments_for_index (ifs, old_adj->base_index, i,\n-\t\t\t\t\t    old_adj, &new_params);\n+\t\t\t\t\t    old_adj, ipcp_ts, &new_params);\n \t}\n     }\n   else\n     for (unsigned i = 0; i < param_count; i++)\n-      push_param_adjustments_for_index (ifs, i, i, NULL, &new_params);\n+      push_param_adjustments_for_index (ifs, i, i, NULL, ipcp_ts, &new_params);\n \n   ipa_param_adjustments *new_adjustments\n     = (new (ggc_alloc <ipa_param_adjustments> ())\n@@ -3783,10 +4094,12 @@ process_isra_node_results (cgraph_node *node,\n /* Check which parameters of NODE described by IFS have survived until IPA-SRA\n    and disable transformations for those which have not or which should not\n    transformed because the associated debug counter reached its limit.  Return\n-   true if none survived or if there were no candidates to begin with.  */\n+   true if none survived or if there were no candidates to begin with.\n+   Additionally, also adjust parameter descriptions based on debug counters and\n+   hints propagated earlier.  */\n \n static bool\n-disable_unavailable_parameters (cgraph_node *node, isra_func_summary *ifs)\n+adjust_parameter_descriptions (cgraph_node *node, isra_func_summary *ifs)\n {\n   bool ret = true;\n   unsigned len = vec_safe_length (ifs->m_parameters);\n@@ -3801,7 +4114,8 @@ disable_unavailable_parameters (cgraph_node *node, isra_func_summary *ifs)\n       check_surviving = true;\n       cinfo->param_adjustments->get_surviving_params (&surviving_params);\n     }\n-  bool dumped_first = false;\n+  auto_vec <unsigned> dump_dead_indices;\n+  auto_vec <unsigned> dump_bad_cond_indices;\n   for (unsigned i = 0; i < len; i++)\n     {\n       isra_param_desc *desc = &(*ifs->m_parameters)[i];\n@@ -3820,23 +4134,56 @@ disable_unavailable_parameters (cgraph_node *node, isra_func_summary *ifs)\n \t  desc->split_candidate = false;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    dump_dead_indices.safe_push (i);\n+\t}\n+      else\n+\t{\n+\t  if (desc->split_candidate && desc->conditionally_dereferenceable)\n+\t    {\n+\t      gcc_assert (desc->safe_size_set);\n+\t      for (param_access *pa : *desc->accesses)\n+\t\tif ((pa->unit_offset + pa->unit_size) > desc->safe_size)\n+\t\t  {\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      dump_bad_cond_indices.safe_push (i);\n+\t\t    desc->split_candidate = false;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\n+\t  if (desc->split_candidate)\n \t    {\n-\t      if (!dumped_first)\n+\t      if (desc->by_ref && !desc->not_specially_constructed)\n \t\t{\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"The following parameters of %s are dead on \"\n-\t\t\t   \"arrival:\", node->dump_name ());\n-\t\t  dumped_first = true;\n+\t\t  int extra_factor\n+\t\t    = opt_for_fn (node->decl,\n+\t\t\t\t  param_ipa_sra_ptrwrap_growth_factor);\n+\t\t  desc->param_size_limit = extra_factor * desc->param_size_limit;\n \t\t}\n-\t      fprintf (dump_file, \" %u\", i);\n+\t      if (size_would_violate_limit_p (desc, desc->size_reached))\n+\t\tdesc->split_candidate = false;\n \t    }\n+\t  if (desc->locally_unused || desc->split_candidate)\n+\t    ret = false;\n \t}\n-      else if (desc->locally_unused || desc->split_candidate)\n-\tret = false;\n     }\n \n-  if (dumped_first)\n-    fprintf (dump_file, \"\\n\");\n+  if (!dump_dead_indices.is_empty ())\n+    {\n+      fprintf (dump_file, \"The following parameters of %s are dead on arrival:\",\n+\t       node->dump_name ());\n+      for (unsigned i : dump_dead_indices)\n+\tfprintf (dump_file, \" %u\", i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  if (!dump_bad_cond_indices.is_empty ())\n+    {\n+      fprintf (dump_file, \"The following parameters of %s are not safe to \"\n+\t       \"derefernce in all callers:\", node->dump_name ());\n+      for (unsigned i : dump_bad_cond_indices)\n+\tfprintf (dump_file, \" %u\", i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n   return ret;\n }\n@@ -3850,7 +4197,7 @@ ipa_sra_analysis (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\n========== IPA-SRA IPA stage ==========\\n\");\n-      ipa_sra_dump_all_summaries (dump_file);\n+      ipa_sra_dump_all_summaries (dump_file, false);\n     }\n \n   gcc_checking_assert (func_sums);\n@@ -3859,28 +4206,92 @@ ipa_sra_analysis (void)\n   auto_vec <cgraph_node *, 16> stack;\n   int node_scc_count = ipa_reduced_postorder (order, true, NULL);\n \n-  /* One sweep from callees to callers for parameter removal and splitting.  */\n-  for (int i = 0; i < node_scc_count; i++)\n+  /* One sweep from callers to callees for return value removal.  */\n+  for (int i = node_scc_count - 1; i >= 0 ; i--)\n     {\n       cgraph_node *scc_rep = order[i];\n       vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (scc_rep);\n-      unsigned j;\n \n-      /* Preliminary IPA function level checks and first step of parameter\n-\t removal.  */\n-      cgraph_node *v;\n-      FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+      /* Preliminary IPA function level checks.  */\n+      for (cgraph_node *v : cycle_nodes)\n \t{\n \t  isra_func_summary *ifs = func_sums->get (v);\n \t  if (!ifs || !ifs->m_candidate)\n \t    continue;\n \t  if (!ipa_sra_ipa_function_checks (v)\n \t      || check_all_callers_for_issues (v))\n-\t    {\n-\t      ifs->zap ();\n-\t      continue;\n-\t    }\n-\t  if (disable_unavailable_parameters (v, ifs))\n+\t    ifs->zap ();\n+\t}\n+\n+      for (cgraph_node *v : cycle_nodes)\n+\t{\n+\t  isra_func_summary *ifs = func_sums->get (v);\n+\t  if (!ifs || !ifs->m_candidate)\n+\t    continue;\n+\t  bool return_needed\n+\t    = (ifs->m_returns_value\n+\t       && (!dbg_cnt (ipa_sra_retvalues)\n+\t\t   || v->call_for_symbol_and_aliases (retval_used_p,\n+\t\t\t\t\t\t      NULL, true)));\n+\t  ifs->m_return_ignored = !return_needed;\n+\t  if (return_needed)\n+\t    isra_push_node_to_stack (v, ifs, &stack);\n+\t}\n+\n+      while (!stack.is_empty ())\n+\t{\n+\t  cgraph_node *node = stack.pop ();\n+\t  isra_func_summary *ifs = func_sums->get (node);\n+\t  gcc_checking_assert (ifs && ifs->m_queued);\n+\t  ifs->m_queued = false;\n+\n+\t  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n+\t    if (ipa_edge_within_scc (cs)\n+\t\t&& call_sums->get (cs)->m_return_returned)\n+\t      {\n+\t\tenum availability av;\n+\t\tcgraph_node *callee = cs->callee->function_symbol (&av);\n+\t\tisra_func_summary *to_ifs = func_sums->get (callee);\n+\t\tif (to_ifs && to_ifs->m_return_ignored)\n+\t\t  {\n+\t\t    to_ifs->m_return_ignored = false;\n+\t\t    isra_push_node_to_stack (callee, to_ifs, &stack);\n+\t\t  }\n+\t      }\n+\t}\n+\n+      /* Parameter hint propagation.  */\n+      for (cgraph_node *v : cycle_nodes)\n+\t{\n+\t  isra_func_summary *ifs = func_sums->get (v);\n+\t  propagate_hints_to_all_callees (v, ifs, &stack);\n+\t}\n+\n+      while (!stack.is_empty ())\n+\t{\n+\t  cgraph_node *node = stack.pop ();\n+\t  isra_func_summary *ifs = func_sums->get (node);\n+\t  gcc_checking_assert (ifs && ifs->m_queued);\n+\t  ifs->m_queued = false;\n+\t  propagate_hints_to_all_callees (node, ifs, &stack);\n+\t}\n+\n+      cycle_nodes.release ();\n+    }\n+\n+  /* One sweep from callees to callers for parameter removal and splitting.  */\n+  for (int i = 0; i < node_scc_count; i++)\n+    {\n+      cgraph_node *scc_rep = order[i];\n+      vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (scc_rep);\n+\n+      /* First step of parameter removal.  */\n+      for (cgraph_node *v : cycle_nodes)\n+\t{\n+\t  isra_func_summary *ifs = func_sums->get (v);\n+\t  if (!ifs || !ifs->m_candidate)\n+\t    continue;\n+\t  if (adjust_parameter_descriptions (v, ifs))\n \t    continue;\n \t  for (cgraph_edge *cs = v->indirect_calls; cs; cs = cs->next_callee)\n \t    process_edge_to_unknown_caller (cs);\n@@ -3892,7 +4303,7 @@ ipa_sra_analysis (void)\n       /* Look at edges within the current SCC and propagate used-ness across\n \t them, pushing onto the stack all notes which might need to be\n \t revisited.  */\n-      FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+      for (cgraph_node *v : cycle_nodes)\n \tv->call_for_symbol_thunks_and_aliases (propagate_used_to_scc_callers,\n \t\t\t\t\t       &stack, true);\n \n@@ -3913,7 +4324,7 @@ ipa_sra_analysis (void)\n       do\n \t{\n \t  repeat_scc_access_propagation = false;\n-\t  FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+\t  for (cgraph_node *v : cycle_nodes)\n \t    {\n \t      isra_func_summary *ifs = func_sums->get (v);\n \t      if (!ifs\n@@ -3928,60 +4339,12 @@ ipa_sra_analysis (void)\n       while (repeat_scc_access_propagation);\n \n       if (flag_checking)\n-\tFOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+\tfor (cgraph_node *v : cycle_nodes)\n \t  verify_splitting_accesses (v, true);\n \n       cycle_nodes.release ();\n     }\n \n-  /* One sweep from caller to callees for result removal.  */\n-  for (int i = node_scc_count - 1; i >= 0 ; i--)\n-    {\n-      cgraph_node *scc_rep = order[i];\n-      vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (scc_rep);\n-      unsigned j;\n-\n-      cgraph_node *v;\n-      FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n-\t{\n-\t  isra_func_summary *ifs = func_sums->get (v);\n-\t  if (!ifs || !ifs->m_candidate)\n-\t    continue;\n-\n-\t  bool return_needed\n-\t    = (ifs->m_returns_value\n-\t       && (!dbg_cnt (ipa_sra_retvalues)\n-\t\t   || v->call_for_symbol_and_aliases (retval_used_p,\n-\t\t\t\t\t\t      NULL, true)));\n-\t  ifs->m_return_ignored = !return_needed;\n-\t  if (return_needed)\n-\t    isra_push_node_to_stack (v, ifs, &stack);\n-\t}\n-\n-      while (!stack.is_empty ())\n-\t{\n-\t  cgraph_node *node = stack.pop ();\n-\t  isra_func_summary *ifs = func_sums->get (node);\n-\t  gcc_checking_assert (ifs && ifs->m_queued);\n-\t  ifs->m_queued = false;\n-\n-\t  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n-\t    if (ipa_edge_within_scc (cs)\n-\t\t&& call_sums->get (cs)->m_return_returned)\n-\t      {\n-\t\tenum availability av;\n-\t\tcgraph_node *callee = cs->callee->function_symbol (&av);\n-\t\tisra_func_summary *to_ifs = func_sums->get (callee);\n-\t\tif (to_ifs && to_ifs->m_return_ignored)\n-\t\t  {\n-\t\t    to_ifs->m_return_ignored = false;\n-\t\t    isra_push_node_to_stack (callee, to_ifs, &stack);\n-\t\t  }\n-\t      }\n-\t}\n-      cycle_nodes.release ();\n-    }\n-\n   ipa_free_postorder_info ();\n   free (order);\n \n@@ -3991,7 +4354,7 @@ ipa_sra_analysis (void)\n \t{\n \t  fprintf (dump_file, \"\\n========== IPA-SRA propagation final state \"\n \t\t   \" ==========\\n\");\n-\t  ipa_sra_dump_all_summaries (dump_file);\n+\t  ipa_sra_dump_all_summaries (dump_file, true);\n \t}\n       fprintf (dump_file, \"\\n========== IPA-SRA decisions ==========\\n\");\n     }\n@@ -4072,48 +4435,57 @@ ipa_sra_summarize_function (cgraph_node *node)\n   if (dump_file)\n     fprintf (dump_file, \"Creating summary for %s/%i:\\n\", node->name (),\n \t     node->order);\n-  if (!ipa_sra_preliminary_function_checks (node))\n-    {\n-      isra_analyze_all_outgoing_calls (node);\n-      return;\n-    }\n   gcc_obstack_init (&gensum_obstack);\n-  isra_func_summary *ifs = func_sums->get_create (node);\n-  ifs->m_candidate = true;\n-  tree ret = TREE_TYPE (TREE_TYPE (node->decl));\n-  ifs->m_returns_value = (TREE_CODE (ret) != VOID_TYPE);\n+  loaded_decls = new hash_set<tree>;\n \n-  decl2desc = new hash_map<tree, gensum_param_desc *>;\n+  isra_func_summary *ifs = NULL;\n   unsigned count = 0;\n-  for (tree parm = DECL_ARGUMENTS (node->decl); parm; parm = DECL_CHAIN (parm))\n-    count++;\n+  if (ipa_sra_preliminary_function_checks (node))\n+    {\n+      ifs = func_sums->get_create (node);\n+      ifs->m_candidate = true;\n+      tree ret = TREE_TYPE (TREE_TYPE (node->decl));\n+      ifs->m_returns_value = (TREE_CODE (ret) != VOID_TYPE);\n+      for (tree parm = DECL_ARGUMENTS (node->decl);\n+\t   parm;\n+\t   parm = DECL_CHAIN (parm))\n+\tcount++;\n+    }\n+  auto_vec<gensum_param_desc, 16> param_descriptions (count);\n \n+  struct function *fun = DECL_STRUCT_FUNCTION (node->decl);\n+  bool cfun_pushed = false;\n   if (count > 0)\n     {\n-      auto_vec<gensum_param_desc, 16> param_descriptions (count);\n+      decl2desc = new hash_map<tree, gensum_param_desc *>;\n       param_descriptions.reserve_exact (count);\n       param_descriptions.quick_grow_cleared (count);\n \n-      bool cfun_pushed = false;\n-      struct function *fun = DECL_STRUCT_FUNCTION (node->decl);\n       if (create_parameter_descriptors (node, &param_descriptions))\n \t{\n \t  push_cfun (fun);\n \t  cfun_pushed = true;\n \t  final_bbs = BITMAP_ALLOC (NULL);\n \t  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n-\t\t\t\t      by_ref_count\n+\t\t\t\t      unsafe_by_ref_count\n \t\t\t\t      * last_basic_block_for_fn (fun));\n \t  aa_walking_limit = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n-\t  scan_function (node, fun);\n+\t}\n+    }\n+  /* Scan function is run even when there are no removal or splitting\n+     candidates so that we can calculate hints on call edges which can be\n+     useful in callees. */\n+  scan_function (node, fun);\n \n-\t  if (dump_file)\n-\t    {\n-\t      dump_gensum_param_descriptors (dump_file, node->decl,\n-\t\t\t\t\t     &param_descriptions);\n-\t      fprintf (dump_file, \"----------------------------------------\\n\");\n-\t    }\n+  if (count > 0)\n+    {\n+      if (dump_file)\n+\t{\n+\t  dump_gensum_param_descriptors (dump_file, node->decl,\n+\t\t\t\t\t &param_descriptions);\n+\t  fprintf (dump_file, \"----------------------------------------\\n\");\n \t}\n+\n       process_scan_results (node, fun, ifs, &param_descriptions);\n \n       if (cfun_pushed)\n@@ -4128,8 +4500,13 @@ ipa_sra_summarize_function (cgraph_node *node)\n     }\n   isra_analyze_all_outgoing_calls (node);\n \n-  delete decl2desc;\n-  decl2desc = NULL;\n+  delete loaded_decls;\n+  loaded_decls = NULL;\n+  if (decl2desc)\n+    {\n+      delete decl2desc;\n+      decl2desc = NULL;\n+    }\n   obstack_free (&gensum_obstack, NULL);\n   if (dump_file)\n     fprintf (dump_file, \"\\n\\n\");"}, {"sha": "e1236dec575457b03f0b5ad055105afb20d8fa8a", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -806,6 +806,15 @@ class vector_type : public decorated_type\n \n   void replay_into (replayer *) final override;\n \n+  bool is_same_type_as (type *other) final override\n+  {\n+    vector_type *other_vec_type = other->dyn_cast_vector_type ();\n+    if (other_vec_type == NULL)\n+      return false;\n+    return get_num_units () == other_vec_type->get_num_units ()\n+      && get_element_type () == other_vec_type->get_element_type ();\n+  }\n+\n   vector_type *is_vector () final override { return this; }\n \n private:"}, {"sha": "11079b0f0f0b6ac54094612aea0e28778119e94b", "filename": "gcc/lto-cgraph.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Flto-cgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Flto-cgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -797,7 +797,7 @@ add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n {\n   if (node->clone_of)\n     add_node_to (encoder, node->clone_of, include_body);\n-  else if (include_body)\n+  if (include_body)\n     lto_set_symtab_encoder_encode_body (encoder, node);\n   lto_symtab_encoder_encode (encoder, node);\n }"}, {"sha": "08f75b092041dab8a4aa8ced193c6c76e5e8c866", "filename": "gcc/lto-streamer-out.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Flto-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Flto-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -2752,7 +2752,8 @@ lto_output (void)\n \tcontinue;\n       if (cgraph_node *node = dyn_cast <cgraph_node *> (snode))\n \t{\n-\t  if (lto_symtab_encoder_encode_body_p (encoder, node))\n+\t  if (lto_symtab_encoder_encode_body_p (encoder, node)\n+\t      && !node->clone_of)\n \t    symbols_to_copy.safe_push (node);\n \t}\n       else if (varpool_node *node = dyn_cast <varpool_node *> (snode))"}, {"sha": "e0fd05fb44ab55d0996538e70e7ff26c645b2fc8", "filename": "gcc/params.opt", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -282,13 +282,21 @@ Maximum number of different predicates used to track properties of loops in IPA\n Common Joined UInteger Var(param_ipa_max_switch_predicate_bounds) Init(5) Param Optimization\n Maximal number of boundary endpoints of case ranges of switch statement used during IPA function summary generation.\n \n+-param=ipa-sra-deref-prob-threshold=\n+Common Joined UInteger Var(param_ipa_sra_deref_prob_threshold) Init(50) IntegerRange(0, 100) Param Optimization\n+Minimum probability (in percent) of dereferencing of a function pointer parameter for it to be considered for replacement with simple values.\n+\n -param=ipa-sra-max-replacements=\n Common Joined UInteger Var(param_ipa_sra_max_replacements) Optimization Init(8) IntegerRange(0, 16) Param\n Maximum pieces that IPA-SRA tracks per formal parameter, as a consequence, also the maximum number of replacements of a formal parameter.\n \n -param=ipa-sra-ptr-growth-factor=\n Common Joined UInteger Var(param_ipa_sra_ptr_growth_factor) Init(2) Param Optimization\n-Maximum allowed growth of number and total size of new parameters that ipa-sra replaces a pointer to an aggregate with.\n+Maximum allowed growth of total size of new parameters that ipa-sra replaces a pointer to an aggregate with.\n+\n+-param=ipa-sra-ptrwrap-growth-factor=\n+Common Joined UInteger Var(param_ipa_sra_ptrwrap_growth_factor) Init(4) IntegerRange(1, 8) Param Optimization\n+Additional maximum allowed growth of total size of new parameters that ipa-sra replaces a pointer to an aggregate with, if it points to a local variable that the caller never writes to.\n \n -param=ira-loop-reserved-regs=\n Common Joined UInteger Var(param_ira_loop_reserved_regs) Init(2) Param Optimization"}, {"sha": "acd36bf7ce4053b63e08eb15460dd56421626f3f", "filename": "gcc/rust/ChangeLog", "status": "modified", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Frust%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Frust%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FChangeLog?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,3 +1,394 @@\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* CONTRIBUTING.md: New.\n+\t* README.md: New.\n+\t* logo.png: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* config-lang.in: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* lang.opt (-frust-incomplete-and-experimental-compiler-do-not-use):\n+\tNew.\n+\t* rust-session-manager.cc (Session::compile_crate): Check it.\n+\t* Make-lang.in (RUST_SELFTEST_FLAGS): Add it.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* Make-lang.in: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* lang.opt: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* lang-specs.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* rust-lang.cc: New.\n+\t* rust-session-manager.cc: New.\n+\t* rust-session-manager.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* rustspec.cc: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* rust-diagnostics.cc: New.\n+\t* rust-diagnostics.h: New.\n+\t* rust-gcc-diagnostics.cc: New.\n+\t* rust-linemap.cc: New.\n+\t* rust-linemap.h: New.\n+\t* rust-location.h: New.\n+\t* rust-system.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\t    David Faust  <david.faust@oracle.com>\n+\t    Faisal Abbas  <90.abbasfaisal@gmail.com>\n+\n+\t* backend/rust-compile-context.cc: New.\n+\t* backend/rust-compile-context.h: New.\n+\t* backend/rust-compile.cc: New.\n+\t* backend/rust-compile.h: New.\n+\t* backend/rust-constexpr.cc: New.\n+\t* backend/rust-constexpr.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\t    David Faust  <david.faust@oracle.com>\n+\n+\t* backend/rust-compile-block.cc: New.\n+\t* backend/rust-compile-block.h: New.\n+\t* backend/rust-compile-expr.cc: New.\n+\t* backend/rust-compile-expr.h: New.\n+\t* backend/rust-compile-extern.h: New.\n+\t* backend/rust-compile-fnparam.cc: New.\n+\t* backend/rust-compile-fnparam.h: New.\n+\t* backend/rust-compile-implitem.cc: New.\n+\t* backend/rust-compile-implitem.h: New.\n+\t* backend/rust-compile-intrinsic.cc: New.\n+\t* backend/rust-compile-intrinsic.h: New.\n+\t* backend/rust-compile-item.cc: New.\n+\t* backend/rust-compile-item.h: New.\n+\t* backend/rust-compile-pattern.cc: New.\n+\t* backend/rust-compile-pattern.h: New.\n+\t* backend/rust-compile-resolve-path.cc: New.\n+\t* backend/rust-compile-resolve-path.h: New.\n+\t* backend/rust-compile-stmt.cc: New.\n+\t* backend/rust-compile-stmt.h: New.\n+\t* backend/rust-compile-struct-field-expr.cc: New.\n+\t* backend/rust-compile-struct-field-expr.h: New.\n+\t* backend/rust-compile-type.cc: New.\n+\t* backend/rust-compile-type.h: New.\n+\t* backend/rust-compile-var-decl.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\t    David Faust  <david.faust@oracle.com>\n+\n+\t* backend/rust-builtins.h: New.\n+\t* backend/rust-compile-base.cc: New.\n+\t* backend/rust-compile-base.h: New.\n+\t* backend/rust-mangle.cc: New.\n+\t* backend/rust-mangle.h: New.\n+\t* backend/rust-tree.cc: New.\n+\t* backend/rust-tree.h: New.\n+\t* rust-backend.h: New.\n+\t* rust-gcc.cc: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* metadata/rust-export-metadata.cc: New.\n+\t* metadata/rust-export-metadata.h: New.\n+\t* metadata/rust-extern-crate.cc: New.\n+\t* metadata/rust-extern-crate.h: New.\n+\t* metadata/rust-import-archive.cc: New.\n+\t* metadata/rust-imports.cc: New.\n+\t* metadata/rust-imports.h: New.\n+\t* rust-object-export.cc: New.\n+\t* rust-object-export.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* checks/lints/rust-lint-unused-var.cc: New.\n+\t* checks/lints/rust-lint-unused-var.h: New.\n+\n+2022-12-13  Thomas Young  <wenzhang5800@gmail.com>\n+\n+\t* checks/lints/rust-lint-marklive-base.h: New.\n+\t* checks/lints/rust-lint-marklive.cc: New.\n+\t* checks/lints/rust-lint-marklive.h: New.\n+\t* checks/lints/rust-lint-scan-deadcode.h: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* checks/errors/privacy/rust-privacy-check.cc: New.\n+\t* checks/errors/privacy/rust-privacy-check.h: New.\n+\t* checks/errors/privacy/rust-privacy-common.h: New.\n+\t* checks/errors/privacy/rust-privacy-ctx.cc: New.\n+\t* checks/errors/privacy/rust-privacy-ctx.h: New.\n+\t* checks/errors/privacy/rust-privacy-reporter.cc: New.\n+\t* checks/errors/privacy/rust-privacy-reporter.h: New.\n+\t* checks/errors/privacy/rust-pub-restricted-visitor.cc: New.\n+\t* checks/errors/privacy/rust-pub-restricted-visitor.h: New.\n+\t* checks/errors/privacy/rust-reachability.cc: New.\n+\t* checks/errors/privacy/rust-reachability.h: New.\n+\t* checks/errors/privacy/rust-visibility-resolver.cc: New.\n+\t* checks/errors/privacy/rust-visibility-resolver.h: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* checks/errors/rust-const-checker.cc: New.\n+\t* checks/errors/rust-const-checker.h: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* checks/errors/rust-unsafe-checker.cc: New.\n+\t* checks/errors/rust-unsafe-checker.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* typecheck/rust-autoderef.cc: New.\n+\t* typecheck/rust-autoderef.h: New.\n+\t* typecheck/rust-casts.cc: New.\n+\t* typecheck/rust-casts.h: New.\n+\t* typecheck/rust-coercion.cc: New.\n+\t* typecheck/rust-coercion.h: New.\n+\t* typecheck/rust-hir-dot-operator.cc: New.\n+\t* typecheck/rust-hir-dot-operator.h: New.\n+\t* typecheck/rust-hir-inherent-impl-overlap.h: New.\n+\t* typecheck/rust-hir-path-probe.h: New.\n+\t* typecheck/rust-hir-trait-ref.h: New.\n+\t* typecheck/rust-hir-type-bounds.h: New.\n+\t* typecheck/rust-substitution-mapper.cc: New.\n+\t* typecheck/rust-substitution-mapper.h: New.\n+\t* typecheck/rust-tycheck-dump.h: New.\n+\t* typecheck/rust-tyctx.cc: New.\n+\t* typecheck/rust-tyty-bounds.cc: New.\n+\t* typecheck/rust-tyty-call.cc: New.\n+\t* typecheck/rust-tyty-call.h: New.\n+\t* typecheck/rust-tyty-cmp.h: New.\n+\t* typecheck/rust-tyty-rules.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* typecheck/rust-tyty.cc: New.\n+\t* typecheck/rust-tyty.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* typecheck/rust-hir-trait-resolve.cc: New.\n+\t* typecheck/rust-hir-trait-resolve.h: New.\n+\t* typecheck/rust-hir-type-check-base.cc: New.\n+\t* typecheck/rust-hir-type-check-base.h: New.\n+\t* typecheck/rust-hir-type-check-enumitem.cc: New.\n+\t* typecheck/rust-hir-type-check-enumitem.h: New.\n+\t* typecheck/rust-hir-type-check-expr.cc: New.\n+\t* typecheck/rust-hir-type-check-expr.h: New.\n+\t* typecheck/rust-hir-type-check-implitem.cc: New.\n+\t* typecheck/rust-hir-type-check-implitem.h: New.\n+\t* typecheck/rust-hir-type-check-item.cc: New.\n+\t* typecheck/rust-hir-type-check-item.h: New.\n+\t* typecheck/rust-hir-type-check-path.cc: New.\n+\t* typecheck/rust-hir-type-check-pattern.cc: New.\n+\t* typecheck/rust-hir-type-check-pattern.h: New.\n+\t* typecheck/rust-hir-type-check-stmt.cc: New.\n+\t* typecheck/rust-hir-type-check-stmt.h: New.\n+\t* typecheck/rust-hir-type-check-struct-field.h: New.\n+\t* typecheck/rust-hir-type-check-struct.cc: New.\n+\t* typecheck/rust-hir-type-check-toplevel.cc: New.\n+\t* typecheck/rust-hir-type-check-toplevel.h: New.\n+\t* typecheck/rust-hir-type-check-type.cc: New.\n+\t* typecheck/rust-hir-type-check-type.h: New.\n+\t* typecheck/rust-hir-type-check-util.cc: New.\n+\t* typecheck/rust-hir-type-check-util.h: New.\n+\t* typecheck/rust-hir-type-check.cc: New.\n+\t* typecheck/rust-hir-type-check.h: New.\n+\t* typecheck/rust-tyty-visitor.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* util/rust-canonical-path.h: New.\n+\t* util/rust-common.h: New.\n+\t* util/rust-hir-map.cc: New.\n+\t* util/rust-hir-map.h: New.\n+\t* util/rust-identifier.h: New.\n+\t* util/rust-lang-item.h: New.\n+\t* util/rust-mapping-common.h: New.\n+\t* util/rust-stacked-contexts.h: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* util/rust-attributes.cc: New.\n+\t* util/rust-attributes.h: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* util/rust-optional-test.cc: New.\n+\t* util/rust-optional.h: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* util/rust-base62.cc: New.\n+\t* util/rust-base62.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* util/rust-abi.cc: New.\n+\t* util/rust-abi.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* util/fnv-hash.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* util/rust-make-unique.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* hir/rust-ast-lower-base.cc: New.\n+\t* hir/rust-ast-lower-base.h: New.\n+\t* hir/rust-ast-lower-block.h: New.\n+\t* hir/rust-ast-lower-enumitem.h: New.\n+\t* hir/rust-ast-lower-expr.h: New.\n+\t* hir/rust-ast-lower-extern.h: New.\n+\t* hir/rust-ast-lower-implitem.h: New.\n+\t* hir/rust-ast-lower-item.cc: New.\n+\t* hir/rust-ast-lower-item.h: New.\n+\t* hir/rust-ast-lower-pattern.cc: New.\n+\t* hir/rust-ast-lower-pattern.h: New.\n+\t* hir/rust-ast-lower-stmt.h: New.\n+\t* hir/rust-ast-lower-struct-field-expr.h: New.\n+\t* hir/rust-ast-lower-type.h: New.\n+\t* hir/rust-ast-lower.cc: New.\n+\t* hir/rust-ast-lower.h: New.\n+\t* hir/rust-hir-dump.cc: New.\n+\t* hir/rust-hir-dump.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* hir/tree/rust-hir-full-decls.h: New.\n+\t* hir/tree/rust-hir-full-test.cc: New.\n+\t* hir/tree/rust-hir-full.h: New.\n+\t* hir/tree/rust-hir-visitor.h: New.\n+\t* hir/tree/rust-hir.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* hir/tree/rust-hir-expr.h: New.\n+\t* hir/tree/rust-hir-item.h: New.\n+\t* hir/tree/rust-hir-path.h: New.\n+\t* hir/tree/rust-hir-pattern.h: New.\n+\t* hir/tree/rust-hir-stmt.h: New.\n+\t* hir/tree/rust-hir-type.h: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* resolve/rust-ast-resolve-base.cc: New.\n+\t* resolve/rust-ast-resolve-base.h: New.\n+\t* resolve/rust-ast-resolve-expr.cc: New.\n+\t* resolve/rust-ast-resolve-expr.h: New.\n+\t* resolve/rust-ast-resolve-implitem.h: New.\n+\t* resolve/rust-ast-resolve-item.cc: New.\n+\t* resolve/rust-ast-resolve-item.h: New.\n+\t* resolve/rust-ast-resolve-path.cc: New.\n+\t* resolve/rust-ast-resolve-path.h: New.\n+\t* resolve/rust-ast-resolve-pattern.cc: New.\n+\t* resolve/rust-ast-resolve-pattern.h: New.\n+\t* resolve/rust-ast-resolve-stmt.cc: New.\n+\t* resolve/rust-ast-resolve-stmt.h: New.\n+\t* resolve/rust-ast-resolve-struct-expr-field.cc: New.\n+\t* resolve/rust-ast-resolve-struct-expr-field.h: New.\n+\t* resolve/rust-ast-resolve-toplevel.h: New.\n+\t* resolve/rust-ast-resolve-type.cc: New.\n+\t* resolve/rust-ast-resolve-type.h: New.\n+\t* resolve/rust-ast-resolve.cc: New.\n+\t* resolve/rust-ast-resolve.h: New.\n+\t* resolve/rust-ast-verify-assignee.h: New.\n+\t* resolve/rust-name-resolver.cc: New.\n+\t* resolve/rust-name-resolver.h: New.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\t    Joel Phillips  <simplytheother@gmail.com>\n+\n+\t* expand/rust-attribute-visitor.cc: New.\n+\t* expand/rust-attribute-visitor.h: New.\n+\t* expand/rust-macro-builtins.cc: New.\n+\t* expand/rust-macro-builtins.h: New.\n+\t* expand/rust-macro-expand.cc: New.\n+\t* expand/rust-macro-expand.h: New.\n+\t* expand/rust-macro-invoc-lexer.cc: New.\n+\t* expand/rust-macro-invoc-lexer.h: New.\n+\t* expand/rust-macro-substitute-ctx.cc: New.\n+\t* expand/rust-macro-substitute-ctx.h: New.\n+\n+2022-12-13  Joel Phillips  <simplytheother@gmail.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\t    Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* parse/rust-parse-impl.h: New, second half.\n+\n+2022-12-13  Joel Phillips  <simplytheother@gmail.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\t    Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* parse/rust-cfg-parser.cc: New.\n+\t* parse/rust-cfg-parser.h: New.\n+\t* parse/rust-parse-impl.h: New.\n+\t* parse/rust-parse.cc: New.\n+\t* parse/rust-parse.h: New.\n+\n+2022-12-13  Joel Phillips  <simplytheother@gmail.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\t    Arthur Cohen  <arthur.cohen@embecosm.com>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\n+\t* lex/rust-codepoint.h: New.\n+\t* lex/rust-lex.cc: New.\n+\t* lex/rust-lex.h: New.\n+\t* lex/rust-token.cc: New.\n+\t* lex/rust-token.h: New.\n+\t* rust-buffered-queue.h: New.\n+\n+2022-12-13  Joel Phillips  <simplytheother@gmail.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\t    Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* ast/rust-ast-dump.cc: New.\n+\t* ast/rust-ast-dump.h: New.\n+\t* ast/rust-ast-visitor.h: New.\n+\t* ast/rust-cond-compilation.h: New.\n+\n+2022-12-13  Joel Phillips  <simplytheother@gmail.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* ast/rust-expr.h: New.\n+\t* ast/rust-macro.h: New.\n+\t* ast/rust-path.h: New.\n+\t* ast/rust-pattern.h: New.\n+\t* ast/rust-stmt.h: New.\n+\t* ast/rust-type.h: New.\n+\n+2022-12-13  Joel Phillips  <simplytheother@gmail.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* ast/rust-item.h: New.\n+\n+2022-12-13  Joel Phillips  <simplytheother@gmail.com>\n+\t    Philip Herron  <philip.herron@embecosm.com>\n+\t    Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* ast/rust-ast-full-decls.h: New.\n+\t* ast/rust-ast-full-test.cc: New.\n+\t* ast/rust-ast-full.h: New.\n+\t* ast/rust-ast.h: New.\n+\t* operator.h: New.\n+\n \f\n Copyright (C) 2022 Free Software Foundation, Inc.\n "}, {"sha": "c36a2aea9401066b1a4db71c1a892a3c9be167cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 763, "deletions": 0, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,3 +1,766 @@\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/ipa-sra-26.c: New test.\n+\t* gcc.dg/ipa/ipa-sra-27.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-28.c: Likewise.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gfortran.dg/pr48636-2.f90: Disable IPA-SRA.\n+\t* gfortran.dg/ipa-sra-1.f90: New test.\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/ipa-sra-25.c: New test\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/ipa-sra-5.C: New test\n+\n+2022-12-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/103227\n+\tPR ipa/107640\n+\t* gcc.dg/ipa/pr107640-2.c: New test.\n+\n+2022-12-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/108044\n+\t* gcc.target/i386/pr108044-1.c: New test.\n+\t* gcc.target/i386/pr108044-2.c: New test.\n+\t* gcc.target/i386/pr108044-3.c: New test.\n+\t* gcc.target/i386/pr108044-4.c: New test.\n+\n+2022-12-13  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/107423\n+\t* gfortran.dg/pr107423.f90: New test.\n+\n+2022-12-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108064\n+\t* gcc.c-torture/execute/pr108064.c: New test.\n+\n+2022-12-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/105801\n+\t* gcc.dg/tree-ssa/ssa-ccp-43.c: New testcase.\n+\n+2022-12-13  Arthur Cohen  <arthur.cohen@embecosm.com>\n+\n+\t* lib/rust.exp (rust_init): Add\n+\t'-frust-incomplete-and-experimental-compiler-do-not-use'.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\t    Arthur Cohen  <arthur.cohen@embecosm.com>\n+\t    Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\t    Marc Poulhi\u00e8s  <dkm@kataplop.net>\n+\n+\t* rust/execute/torture/block_expr1.rs: New.\n+\t* rust/execute/torture/builtin_macro_cfg.rs: New.\n+\t* rust/execute/torture/builtin_macro_concat.rs: New.\n+\t* rust/execute/torture/builtin_macro_env.rs: New.\n+\t* rust/execute/torture/builtin_macro_include_bytes.rs: New.\n+\t* rust/execute/torture/builtin_macro_include_str.rs: New.\n+\t* rust/execute/torture/builtin_macro_line.rs: New.\n+\t* rust/execute/torture/builtin_macros1.rs: New.\n+\t* rust/execute/torture/builtin_macros3.rs: New.\n+\t* rust/execute/torture/cfg1.rs: New.\n+\t* rust/execute/torture/cfg2.rs: New.\n+\t* rust/execute/torture/cfg3.rs: New.\n+\t* rust/execute/torture/cfg4.rs: New.\n+\t* rust/execute/torture/cfg5.rs: New.\n+\t* rust/execute/torture/coercion1.rs: New.\n+\t* rust/execute/torture/coercion2.rs: New.\n+\t* rust/execute/torture/const_fold1.rs: New.\n+\t* rust/execute/torture/const_fold2.rs: New.\n+\t* rust/execute/torture/copy_nonoverlapping1.rs: New.\n+\t* rust/execute/torture/empty_main.rs: New.\n+\t* rust/execute/torture/execute.exp: New.\n+\t* rust/execute/torture/exit_error.rs: New.\n+\t* rust/execute/torture/extern_mod4.rs: New.\n+\t* rust/execute/torture/func1.rs: New.\n+\t* rust/execute/torture/helloworld1.rs: New.\n+\t* rust/execute/torture/helloworld2.rs: New.\n+\t* rust/execute/torture/include.txt: New.\n+\t* rust/execute/torture/index1.rs: New.\n+\t* rust/execute/torture/issue-1120.rs: New.\n+\t* rust/execute/torture/issue-1133.rs: New.\n+\t* rust/execute/torture/issue-1198.rs: New.\n+\t* rust/execute/torture/issue-1231.rs: New.\n+\t* rust/execute/torture/issue-1232.rs: New.\n+\t* rust/execute/torture/issue-1249.rs: New.\n+\t* rust/execute/torture/issue-1436.rs: New.\n+\t* rust/execute/torture/issue-1496.rs: New.\n+\t* rust/execute/torture/issue-647.rs: New.\n+\t* rust/execute/torture/issue-845.rs: New.\n+\t* rust/execute/torture/issue-851.rs: New.\n+\t* rust/execute/torture/issue-858.rs: New.\n+\t* rust/execute/torture/issue-976.rs: New.\n+\t* rust/execute/torture/issue-995.rs: New.\n+\t* rust/execute/torture/macros1.rs: New.\n+\t* rust/execute/torture/macros10.rs: New.\n+\t* rust/execute/torture/macros11.rs: New.\n+\t* rust/execute/torture/macros12.rs: New.\n+\t* rust/execute/torture/macros13.rs: New.\n+\t* rust/execute/torture/macros14.rs: New.\n+\t* rust/execute/torture/macros16.rs: New.\n+\t* rust/execute/torture/macros17.rs: New.\n+\t* rust/execute/torture/macros18.rs: New.\n+\t* rust/execute/torture/macros19.rs: New.\n+\t* rust/execute/torture/macros2.rs: New.\n+\t* rust/execute/torture/macros20.rs: New.\n+\t* rust/execute/torture/macros21.rs: New.\n+\t* rust/execute/torture/macros22.rs: New.\n+\t* rust/execute/torture/macros23.rs: New.\n+\t* rust/execute/torture/macros24.rs: New.\n+\t* rust/execute/torture/macros25.rs: New.\n+\t* rust/execute/torture/macros26.rs: New.\n+\t* rust/execute/torture/macros27.rs: New.\n+\t* rust/execute/torture/macros28.rs: New.\n+\t* rust/execute/torture/macros29.rs: New.\n+\t* rust/execute/torture/macros3.rs: New.\n+\t* rust/execute/torture/macros30.rs: New.\n+\t* rust/execute/torture/macros31.rs: New.\n+\t* rust/execute/torture/macros4.rs: New.\n+\t* rust/execute/torture/macros5.rs: New.\n+\t* rust/execute/torture/macros6.rs: New.\n+\t* rust/execute/torture/macros7.rs: New.\n+\t* rust/execute/torture/macros8.rs: New.\n+\t* rust/execute/torture/macros9.rs: New.\n+\t* rust/execute/torture/match1.rs: New.\n+\t* rust/execute/torture/match2.rs: New.\n+\t* rust/execute/torture/match3.rs: New.\n+\t* rust/execute/torture/match_bool1.rs: New.\n+\t* rust/execute/torture/match_byte1.rs: New.\n+\t* rust/execute/torture/match_char1.rs: New.\n+\t* rust/execute/torture/match_int1.rs: New.\n+\t* rust/execute/torture/match_loop1.rs: New.\n+\t* rust/execute/torture/match_range1.rs: New.\n+\t* rust/execute/torture/match_range2.rs: New.\n+\t* rust/execute/torture/match_tuple1.rs: New.\n+\t* rust/execute/torture/method1.rs: New.\n+\t* rust/execute/torture/method2.rs: New.\n+\t* rust/execute/torture/method3.rs: New.\n+\t* rust/execute/torture/method4.rs: New.\n+\t* rust/execute/torture/mod1.rs: New.\n+\t* rust/execute/torture/modules/mod.rs: New.\n+\t* rust/execute/torture/operator_overload_1.rs: New.\n+\t* rust/execute/torture/operator_overload_10.rs: New.\n+\t* rust/execute/torture/operator_overload_11.rs: New.\n+\t* rust/execute/torture/operator_overload_12.rs: New.\n+\t* rust/execute/torture/operator_overload_2.rs: New.\n+\t* rust/execute/torture/operator_overload_3.rs: New.\n+\t* rust/execute/torture/operator_overload_4.rs: New.\n+\t* rust/execute/torture/operator_overload_5.rs: New.\n+\t* rust/execute/torture/operator_overload_6.rs: New.\n+\t* rust/execute/torture/operator_overload_7.rs: New.\n+\t* rust/execute/torture/operator_overload_8.rs: New.\n+\t* rust/execute/torture/operator_overload_9.rs: New.\n+\t* rust/execute/torture/slice-magic.rs: New.\n+\t* rust/execute/torture/slice-magic2.rs: New.\n+\t* rust/execute/torture/slice1.rs: New.\n+\t* rust/execute/torture/str-layout1.rs: New.\n+\t* rust/execute/torture/str-zero.rs: New.\n+\t* rust/execute/torture/trait1.rs: New.\n+\t* rust/execute/torture/trait10.rs: New.\n+\t* rust/execute/torture/trait11.rs: New.\n+\t* rust/execute/torture/trait12.rs: New.\n+\t* rust/execute/torture/trait13.rs: New.\n+\t* rust/execute/torture/trait2.rs: New.\n+\t* rust/execute/torture/trait3.rs: New.\n+\t* rust/execute/torture/trait4.rs: New.\n+\t* rust/execute/torture/trait5.rs: New.\n+\t* rust/execute/torture/trait6.rs: New.\n+\t* rust/execute/torture/trait7.rs: New.\n+\t* rust/execute/torture/trait8.rs: New.\n+\t* rust/execute/torture/trait9.rs: New.\n+\t* rust/execute/torture/transmute1.rs: New.\n+\t* rust/execute/torture/wrapping_op1.rs: New.\n+\t* rust/execute/torture/wrapping_op2.rs: New.\n+\t* rust/execute/xfail/macro1.rs: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\t    Arthur Cohen  <arthur.cohen@embecosm.com>\n+\t    Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\t    Marc Poulhi\u00e8s  <dkm@kataplop.net>\n+\n+\t* rust/compile/abi-options1.rs: New.\n+\t* rust/compile/array3.rs: New.\n+\t* rust/compile/array_empty_list.rs: New.\n+\t* rust/compile/arrays1.rs: New.\n+\t* rust/compile/arrays2.rs: New.\n+\t* rust/compile/attr-mismatch-crate-name.rs: New.\n+\t* rust/compile/attr_cold.rs: New.\n+\t* rust/compile/attr_deprecated.rs: New.\n+\t* rust/compile/attr_deprecated_2.rs: New.\n+\t* rust/compile/bad-crate-name.rs: New.\n+\t* rust/compile/bad=file-name.rs: New.\n+\t* rust/compile/bad_as_bool_char.rs: New.\n+\t* rust/compile/bad_file_name.txt.rs: New.\n+\t* rust/compile/bad_inner_doc.rs: New.\n+\t* rust/compile/bad_pub_enumitems.rs: New.\n+\t* rust/compile/bad_stmt_enums.rs: New.\n+\t* rust/compile/bad_toplevel_enums.rs: New.\n+\t* rust/compile/bad_tuple_index.rs: New.\n+\t* rust/compile/bad_type1.rs: New.\n+\t* rust/compile/bad_type2.rs: New.\n+\t* rust/compile/break1.rs: New.\n+\t* rust/compile/break2.rs: New.\n+\t* rust/compile/builtin_macro_compile_error.rs: New.\n+\t* rust/compile/builtin_macro_concat.rs: New.\n+\t* rust/compile/builtin_macro_env.rs: New.\n+\t* rust/compile/builtin_macro_include_bytes.rs: New.\n+\t* rust/compile/builtin_macro_include_str.rs: New.\n+\t* rust/compile/builtin_macro_not_found.rs: New.\n+\t* rust/compile/bytecharstring.rs: New.\n+\t* rust/compile/canonical_paths1.rs: New.\n+\t* rust/compile/cast1.rs: New.\n+\t* rust/compile/cfg1.rs: New.\n+\t* rust/compile/cfg2.rs: New.\n+\t* rust/compile/cfg3.rs: New.\n+\t* rust/compile/cfg4.rs: New.\n+\t* rust/compile/cfg5.rs: New.\n+\t* rust/compile/compile.exp: New.\n+\t* rust/compile/complex-path1.rs: New.\n+\t* rust/compile/const-issue1440.rs: New.\n+\t* rust/compile/const1.rs: New.\n+\t* rust/compile/const2.rs: New.\n+\t* rust/compile/const3.rs: New.\n+\t* rust/compile/const_generics_1.rs: New.\n+\t* rust/compile/const_generics_2.rs: New.\n+\t* rust/compile/const_generics_3.rs: New.\n+\t* rust/compile/const_generics_4.rs: New.\n+\t* rust/compile/const_generics_5.rs: New.\n+\t* rust/compile/const_generics_6.rs: New.\n+\t* rust/compile/continue1.rs: New.\n+\t* rust/compile/deadcode_err1.rs: New.\n+\t* rust/compile/deadcode_err2.rs: New.\n+\t* rust/compile/debug-diagnostics-default.rs: New.\n+\t* rust/compile/debug-diagnostics-off.rs: New.\n+\t* rust/compile/debug-diagnostics-on.rs: New.\n+\t* rust/compile/doc_isolated_cr_block_comment.rs: New.\n+\t* rust/compile/doc_isolated_cr_inner_block_comment.rs: New.\n+\t* rust/compile/doc_isolated_cr_inner_line_comment.rs: New.\n+\t* rust/compile/doc_isolated_cr_line_comment.rs: New.\n+\t* rust/compile/dup_fields.rs: New.\n+\t* rust/compile/empty_comment_before_match.rs: New.\n+\t* rust/compile/expected_type_args2.rs: New.\n+\t* rust/compile/expected_type_args3.rs: New.\n+\t* rust/compile/func1.rs: New.\n+\t* rust/compile/func2.rs: New.\n+\t* rust/compile/func3.rs: New.\n+\t* rust/compile/func4.rs: New.\n+\t* rust/compile/func5.rs: New.\n+\t* rust/compile/generic-default1.rs: New.\n+\t* rust/compile/generics1.rs: New.\n+\t* rust/compile/generics10.rs: New.\n+\t* rust/compile/generics11.rs: New.\n+\t* rust/compile/generics12.rs: New.\n+\t* rust/compile/generics13.rs: New.\n+\t* rust/compile/generics2.rs: New.\n+\t* rust/compile/generics3.rs: New.\n+\t* rust/compile/generics4.rs: New.\n+\t* rust/compile/generics5.rs: New.\n+\t* rust/compile/generics6.rs: New.\n+\t* rust/compile/generics7.rs: New.\n+\t* rust/compile/generics8.rs: New.\n+\t* rust/compile/generics9.rs: New.\n+\t* rust/compile/implicit_returns_err1.rs: New.\n+\t* rust/compile/implicit_returns_err2.rs: New.\n+\t* rust/compile/implicit_returns_err3.rs: New.\n+\t* rust/compile/implicit_returns_err4.rs: New.\n+\t* rust/compile/infer-crate-name.rs: New.\n+\t* rust/compile/inline_1.rs: New.\n+\t* rust/compile/inline_2.rs: New.\n+\t* rust/compile/issue-1005.rs: New.\n+\t* rust/compile/issue-1019.rs: New.\n+\t* rust/compile/issue-1023.rs: New.\n+\t* rust/compile/issue-1031.rs: New.\n+\t* rust/compile/issue-1034.rs: New.\n+\t* rust/compile/issue-1089.rs: New.\n+\t* rust/compile/issue-1128.rs: New.\n+\t* rust/compile/issue-1129-1.rs: New.\n+\t* rust/compile/issue-1129-2.rs: New.\n+\t* rust/compile/issue-1130.rs: New.\n+\t* rust/compile/issue-1131.rs: New.\n+\t* rust/compile/issue-1152.rs: New.\n+\t* rust/compile/issue-1165.rs: New.\n+\t* rust/compile/issue-1173.rs: New.\n+\t* rust/compile/issue-1226.rs: New.\n+\t* rust/compile/issue-1234.rs: New.\n+\t* rust/compile/issue-1235.rs: New.\n+\t* rust/compile/issue-1237.rs: New.\n+\t* rust/compile/issue-1251.rs: New.\n+\t* rust/compile/issue-1271.rs: New.\n+\t* rust/compile/issue-1289.rs: New.\n+\t* rust/compile/issue-1323-1.rs: New.\n+\t* rust/compile/issue-1323-2.rs: New.\n+\t* rust/compile/issue-1383.rs: New.\n+\t* rust/compile/issue-1393.rs: New.\n+\t* rust/compile/issue-1447.rs: New.\n+\t* rust/compile/issue-407-2.rs: New.\n+\t* rust/compile/issue-407.rs: New.\n+\t* rust/compile/issue-557.rs: New.\n+\t* rust/compile/issue-635-1.rs: New.\n+\t* rust/compile/issue-635-2.rs: New.\n+\t* rust/compile/lookup_err1.rs: New.\n+\t* rust/compile/macro-issue1053-2.rs: New.\n+\t* rust/compile/macro-issue1053.rs: New.\n+\t* rust/compile/macro-issue1224.rs: New.\n+\t* rust/compile/macro-issue1233.rs: New.\n+\t* rust/compile/macro-issue1395-2.rs: New.\n+\t* rust/compile/macro-issue1395.rs: New.\n+\t* rust/compile/macro-issue1400-2.rs: New.\n+\t* rust/compile/macro-issue1400.rs: New.\n+\t* rust/compile/macro1.rs: New.\n+\t* rust/compile/macro10.rs: New.\n+\t* rust/compile/macro11.rs: New.\n+\t* rust/compile/macro12.rs: New.\n+\t* rust/compile/macro13.rs: New.\n+\t* rust/compile/macro14.rs: New.\n+\t* rust/compile/macro15.rs: New.\n+\t* rust/compile/macro16.rs: New.\n+\t* rust/compile/macro17.rs: New.\n+\t* rust/compile/macro18.rs: New.\n+\t* rust/compile/macro19.rs: New.\n+\t* rust/compile/macro2.rs: New.\n+\t* rust/compile/macro20.rs: New.\n+\t* rust/compile/macro21.rs: New.\n+\t* rust/compile/macro22.rs: New.\n+\t* rust/compile/macro23.rs: New.\n+\t* rust/compile/macro25.rs: New.\n+\t* rust/compile/macro26.rs: New.\n+\t* rust/compile/macro27.rs: New.\n+\t* rust/compile/macro28.rs: New.\n+\t* rust/compile/macro29.rs: New.\n+\t* rust/compile/macro3.rs: New.\n+\t* rust/compile/macro30.rs: New.\n+\t* rust/compile/macro31.rs: New.\n+\t* rust/compile/macro32.rs: New.\n+\t* rust/compile/macro33.rs: New.\n+\t* rust/compile/macro34.rs: New.\n+\t* rust/compile/macro35.rs: New.\n+\t* rust/compile/macro36.rs: New.\n+\t* rust/compile/macro37.rs: New.\n+\t* rust/compile/macro38.rs: New.\n+\t* rust/compile/macro39.rs: New.\n+\t* rust/compile/macro4.rs: New.\n+\t* rust/compile/macro40.rs: New.\n+\t* rust/compile/macro41.rs: New.\n+\t* rust/compile/macro42.rs: New.\n+\t* rust/compile/macro5.rs: New.\n+\t* rust/compile/macro6.rs: New.\n+\t* rust/compile/macro7.rs: New.\n+\t* rust/compile/macro8.rs: New.\n+\t* rust/compile/macro9.rs: New.\n+\t* rust/compile/macro_return.rs: New.\n+\t* rust/compile/match1.rs: New.\n+\t* rust/compile/match2.rs: New.\n+\t* rust/compile/match3.rs: New.\n+\t* rust/compile/match4.rs: New.\n+\t* rust/compile/match5.rs: New.\n+\t* rust/compile/match6.rs: New.\n+\t* rust/compile/match7.rs: New.\n+\t* rust/compile/method1.rs: New.\n+\t* rust/compile/method2.rs: New.\n+\t* rust/compile/mismatch-crate-name.rs: New.\n+\t* rust/compile/missing_middle/both_path.rs: New.\n+\t* rust/compile/missing_middle/explicit.not.rs: New.\n+\t* rust/compile/missing_middle/inner_path.rs: New.\n+\t* rust/compile/missing_middle/other.rs: New.\n+\t* rust/compile/missing_middle/outer_path.rs: New.\n+\t* rust/compile/missing_middle/sub/mod.rs: New.\n+\t* rust/compile/missing_return1.rs: New.\n+\t* rust/compile/mod_missing_middle.rs: New.\n+\t* rust/compile/never_type_err1.rs: New.\n+\t* rust/compile/privacy1.rs: New.\n+\t* rust/compile/privacy2.rs: New.\n+\t* rust/compile/privacy3.rs: New.\n+\t* rust/compile/privacy4.rs: New.\n+\t* rust/compile/privacy5.rs: New.\n+\t* rust/compile/privacy6.rs: New.\n+\t* rust/compile/pub_restricted_1.rs: New.\n+\t* rust/compile/pub_restricted_2.rs: New.\n+\t* rust/compile/pub_restricted_3.rs: New.\n+\t* rust/compile/raw_identifiers_bad_keywords.rs: New.\n+\t* rust/compile/raw_identifiers_underscore.rs: New.\n+\t* rust/compile/redef_error1.rs: New.\n+\t* rust/compile/redef_error2.rs: New.\n+\t* rust/compile/redef_error3.rs: New.\n+\t* rust/compile/redef_error4.rs: New.\n+\t* rust/compile/redef_error5.rs: New.\n+\t* rust/compile/redef_error6.rs: New.\n+\t* rust/compile/reference1.rs: New.\n+\t* rust/compile/self-path1.rs: New.\n+\t* rust/compile/self-path2.rs: New.\n+\t* rust/compile/shadow1.rs: New.\n+\t* rust/compile/specify-crate-name.rs: New.\n+\t* rust/compile/static_var1.rs: New.\n+\t* rust/compile/stmt_with_block_err1.rs: New.\n+\t* rust/compile/struct_align1.rs: New.\n+\t* rust/compile/struct_align2.rs: New.\n+\t* rust/compile/struct_init1.rs: New.\n+\t* rust/compile/struct_pack1.rs: New.\n+\t* rust/compile/struct_pack2.rs: New.\n+\t* rust/compile/syntax-only.rs: New.\n+\t* rust/compile/test_mod.rs: New.\n+\t* rust/compile/torture/all_doc_comment_line_blocks.rs: New.\n+\t* rust/compile/torture/all_doc_comment_line_blocks_crlf.rs: New.\n+\t* rust/compile/torture/arithmetic_expressions1.rs: New.\n+\t* rust/compile/torture/array_const_fold_1.rs: New.\n+\t* rust/compile/torture/array_const_fold_2.rs: New.\n+\t* rust/compile/torture/array_function.rs: New.\n+\t* rust/compile/torture/array_type_infer.rs: New.\n+\t* rust/compile/torture/array_zero_length.rs: New.\n+\t* rust/compile/torture/arrays1.rs: New.\n+\t* rust/compile/torture/arrays2.rs: New.\n+\t* rust/compile/torture/arrays3.rs: New.\n+\t* rust/compile/torture/arrays4.rs: New.\n+\t* rust/compile/torture/arrays5.rs: New.\n+\t* rust/compile/torture/arrays6.rs: New.\n+\t* rust/compile/torture/arrays_index1.rs: New.\n+\t* rust/compile/torture/arrays_index2.rs: New.\n+\t* rust/compile/torture/arrays_index3.rs: New.\n+\t* rust/compile/torture/as_bool_char.rs: New.\n+\t* rust/compile/torture/associated_types1.rs: New.\n+\t* rust/compile/torture/autoderef1.rs: New.\n+\t* rust/compile/torture/block_expr1.rs: New.\n+\t* rust/compile/torture/block_expr2.rs: New.\n+\t* rust/compile/torture/block_expr3.rs: New.\n+\t* rust/compile/torture/block_expr4.rs: New.\n+\t* rust/compile/torture/block_expr5.rs: New.\n+\t* rust/compile/torture/block_expr_parser_bug.rs: New.\n+\t* rust/compile/torture/bom.rs: New.\n+\t* rust/compile/torture/bom_comment.rs: New.\n+\t* rust/compile/torture/bom_shebang.rs: New.\n+\t* rust/compile/torture/bom_whitespace.rs: New.\n+\t* rust/compile/torture/bools_eq.rs: New.\n+\t* rust/compile/torture/borrow1.rs: New.\n+\t* rust/compile/torture/borrow_function.rs: New.\n+\t* rust/compile/torture/break_function.rs: New.\n+\t* rust/compile/torture/byte_char_str.rs: New.\n+\t* rust/compile/torture/byte_str.rs: New.\n+\t* rust/compile/torture/cast1.rs: New.\n+\t* rust/compile/torture/cast2.rs: New.\n+\t* rust/compile/torture/cast3.rs: New.\n+\t* rust/compile/torture/cfg_attr.rs: New.\n+\t* rust/compile/torture/char1.rs: New.\n+\t* rust/compile/torture/check-doc-attr-string.rs: New.\n+\t* rust/compile/torture/coercion1.rs: New.\n+\t* rust/compile/torture/coercion2.rs: New.\n+\t* rust/compile/torture/comparison_expr1.rs: New.\n+\t* rust/compile/torture/compile.exp: New.\n+\t* rust/compile/torture/compound_assignment_expr1.rs: New.\n+\t* rust/compile/torture/conditional.rs: New.\n+\t* rust/compile/torture/constant1.rs: New.\n+\t* rust/compile/torture/constant2.rs: New.\n+\t* rust/compile/torture/constant3.rs: New.\n+\t* rust/compile/torture/deadcode1.rs: New.\n+\t* rust/compile/torture/deadcode2.rs: New.\n+\t* rust/compile/torture/deref1.rs: New.\n+\t* rust/compile/torture/deref_function.rs: New.\n+\t* rust/compile/torture/doc_comment.rs: New.\n+\t* rust/compile/torture/enum1.rs: New.\n+\t* rust/compile/torture/extern_mod1.rs: New.\n+\t* rust/compile/torture/extern_mod2.rs: New.\n+\t* rust/compile/torture/float1.rs: New.\n+\t* rust/compile/torture/float_types.rs: New.\n+\t* rust/compile/torture/forward_decl_1.rs: New.\n+\t* rust/compile/torture/forward_decl_2.rs: New.\n+\t* rust/compile/torture/forward_decl_3-unsafe.rs: New.\n+\t* rust/compile/torture/forward_decl_3.rs: New.\n+\t* rust/compile/torture/forward_decl_4.rs: New.\n+\t* rust/compile/torture/forward_decl_5.rs: New.\n+\t* rust/compile/torture/func1.rs: New.\n+\t* rust/compile/torture/func2.rs: New.\n+\t* rust/compile/torture/function_reference1.rs: New.\n+\t* rust/compile/torture/function_reference2.rs: New.\n+\t* rust/compile/torture/function_reference3.rs: New.\n+\t* rust/compile/torture/function_reference4.rs: New.\n+\t* rust/compile/torture/generics1.rs: New.\n+\t* rust/compile/torture/generics10.rs: New.\n+\t* rust/compile/torture/generics11.rs: New.\n+\t* rust/compile/torture/generics12.rs: New.\n+\t* rust/compile/torture/generics13.rs: New.\n+\t* rust/compile/torture/generics14.rs: New.\n+\t* rust/compile/torture/generics15.rs: New.\n+\t* rust/compile/torture/generics16.rs: New.\n+\t* rust/compile/torture/generics17.rs: New.\n+\t* rust/compile/torture/generics18.rs: New.\n+\t* rust/compile/torture/generics19.rs: New.\n+\t* rust/compile/torture/generics2.rs: New.\n+\t* rust/compile/torture/generics20.rs: New.\n+\t* rust/compile/torture/generics21.rs: New.\n+\t* rust/compile/torture/generics22.rs: New.\n+\t* rust/compile/torture/generics23.rs: New.\n+\t* rust/compile/torture/generics24.rs: New.\n+\t* rust/compile/torture/generics25.rs: New.\n+\t* rust/compile/torture/generics26.rs: New.\n+\t* rust/compile/torture/generics27.rs: New.\n+\t* rust/compile/torture/generics28.rs: New.\n+\t* rust/compile/torture/generics29.rs: New.\n+\t* rust/compile/torture/generics3.rs: New.\n+\t* rust/compile/torture/generics30.rs: New.\n+\t* rust/compile/torture/generics31.rs: New.\n+\t* rust/compile/torture/generics32.rs: New.\n+\t* rust/compile/torture/generics4.rs: New.\n+\t* rust/compile/torture/generics5.rs: New.\n+\t* rust/compile/torture/generics6.rs: New.\n+\t* rust/compile/torture/generics7.rs: New.\n+\t* rust/compile/torture/generics8.rs: New.\n+\t* rust/compile/torture/generics9.rs: New.\n+\t* rust/compile/torture/grouped_expr_function.rs: New.\n+\t* rust/compile/torture/identifier-missing-impl-1.rs: New.\n+\t* rust/compile/torture/if.rs: New.\n+\t* rust/compile/torture/if_elif.rs: New.\n+\t* rust/compile/torture/if_elif_else_expr1.rs: New.\n+\t* rust/compile/torture/if_else.rs: New.\n+\t* rust/compile/torture/ifunaryexpr.rs: New.\n+\t* rust/compile/torture/impl_block1.rs: New.\n+\t* rust/compile/torture/impl_block2.rs: New.\n+\t* rust/compile/torture/impl_block3.rs: New.\n+\t* rust/compile/torture/impl_block_unused.rs: New.\n+\t* rust/compile/torture/implicit_returns1.rs: New.\n+\t* rust/compile/torture/infer_type1.rs: New.\n+\t* rust/compile/torture/inner_attributes.rs: New.\n+\t* rust/compile/torture/integer_inference_var1.rs: New.\n+\t* rust/compile/torture/integer_inference_var2.rs: New.\n+\t* rust/compile/torture/integer_inference_var3.rs: New.\n+\t* rust/compile/torture/integer_inference_var4.rs: New.\n+\t* rust/compile/torture/integer_inference_var5.rs: New.\n+\t* rust/compile/torture/integer_types.rs: New.\n+\t* rust/compile/torture/intrinsics-1.rs: New.\n+\t* rust/compile/torture/intrinsics-2.rs: New.\n+\t* rust/compile/torture/isolated_cr_block_comment.rs: New.\n+\t* rust/compile/torture/isolated_cr_line_comment.rs: New.\n+\t* rust/compile/torture/issue-1024.rs: New.\n+\t* rust/compile/torture/issue-1075.rs: New.\n+\t* rust/compile/torture/issue-1432.rs: New.\n+\t* rust/compile/torture/issue-1434.rs: New.\n+\t* rust/compile/torture/issue-368.rs: New.\n+\t* rust/compile/torture/issue-808.rs: New.\n+\t* rust/compile/torture/issue-862.rs: New.\n+\t* rust/compile/torture/issue-893-2.rs: New.\n+\t* rust/compile/torture/issue-893.rs: New.\n+\t* rust/compile/torture/lazybooleanexpr_function.rs: New.\n+\t* rust/compile/torture/lifetime1.rs: New.\n+\t* rust/compile/torture/literals1.rs: New.\n+\t* rust/compile/torture/loop1.rs: New.\n+\t* rust/compile/torture/loop2.rs: New.\n+\t* rust/compile/torture/loop3.rs: New.\n+\t* rust/compile/torture/loop4.rs: New.\n+\t* rust/compile/torture/loop5.rs: New.\n+\t* rust/compile/torture/loop6.rs: New.\n+\t* rust/compile/torture/loop7.rs: New.\n+\t* rust/compile/torture/macro-issue1403.rs: New.\n+\t* rust/compile/torture/macro-issue1426.rs: New.\n+\t* rust/compile/torture/macro_as_expr.rs: New.\n+\t* rust/compile/torture/match1.rs: New.\n+\t* rust/compile/torture/methods1.rs: New.\n+\t* rust/compile/torture/methods2.rs: New.\n+\t* rust/compile/torture/methods3.rs: New.\n+\t* rust/compile/torture/mod-nameresolve.rs: New.\n+\t* rust/compile/torture/mod1.rs: New.\n+\t* rust/compile/torture/mod2.rs: New.\n+\t* rust/compile/torture/mod3.rs: New.\n+\t* rust/compile/torture/modules/mod.rs: New.\n+\t* rust/compile/torture/modules/valid_path.rs: New.\n+\t* rust/compile/torture/must_use1.rs: New.\n+\t* rust/compile/torture/must_use2.rs: New.\n+\t* rust/compile/torture/name_resolve1.rs: New.\n+\t* rust/compile/torture/negation_function.rs: New.\n+\t* rust/compile/torture/nested_fn1.rs: New.\n+\t* rust/compile/torture/nested_fn2.rs: New.\n+\t* rust/compile/torture/nested_struct1.rs: New.\n+\t* rust/compile/torture/never_type1.rs: New.\n+\t* rust/compile/torture/not_shebang.rs: New.\n+\t* rust/compile/torture/not_shebang_block_comment.rs: New.\n+\t* rust/compile/torture/not_shebang_comment.rs: New.\n+\t* rust/compile/torture/not_shebang_multiline_comment.rs: New.\n+\t* rust/compile/torture/not_shebang_spaces.rs: New.\n+\t* rust/compile/torture/parameter_usage1.rs: New.\n+\t* rust/compile/torture/parens1.rs: New.\n+\t* rust/compile/torture/pointer1.rs: New.\n+\t* rust/compile/torture/primconsts.rs: New.\n+\t* rust/compile/torture/prims_struct_eq.rs: New.\n+\t* rust/compile/torture/range-lang-item1.rs: New.\n+\t* rust/compile/torture/raw_identifiers.rs: New.\n+\t* rust/compile/torture/raw_identifiers_keywords.rs: New.\n+\t* rust/compile/torture/recursive_fn1.rs: New.\n+\t* rust/compile/torture/return_function.rs: New.\n+\t* rust/compile/torture/scoping1.rs: New.\n+\t* rust/compile/torture/self_type1.rs: New.\n+\t* rust/compile/torture/shadow1.rs: New.\n+\t* rust/compile/torture/shadow2.rs: New.\n+\t* rust/compile/torture/shebang.rs: New.\n+\t* rust/compile/torture/shebang_plus_attr.rs: New.\n+\t* rust/compile/torture/shebang_plus_attr2.rs: New.\n+\t* rust/compile/torture/static_function.rs: New.\n+\t* rust/compile/torture/static_var1.rs: New.\n+\t* rust/compile/torture/stmt_with_block1.rs: New.\n+\t* rust/compile/torture/str1.rs: New.\n+\t* rust/compile/torture/struct_access1.rs: New.\n+\t* rust/compile/torture/struct_base_init_1.rs: New.\n+\t* rust/compile/torture/struct_decl.rs: New.\n+\t* rust/compile/torture/struct_init.rs: New.\n+\t* rust/compile/torture/struct_init_10.rs: New.\n+\t* rust/compile/torture/struct_init_11.rs: New.\n+\t* rust/compile/torture/struct_init_2.rs: New.\n+\t* rust/compile/torture/struct_init_3.rs: New.\n+\t* rust/compile/torture/struct_init_4.rs: New.\n+\t* rust/compile/torture/struct_init_5.rs: New.\n+\t* rust/compile/torture/struct_init_6.rs: New.\n+\t* rust/compile/torture/struct_init_7.rs: New.\n+\t* rust/compile/torture/struct_init_8.rs: New.\n+\t* rust/compile/torture/struct_init_9.rs: New.\n+\t* rust/compile/torture/top_attr.rs: New.\n+\t* rust/compile/torture/traits1.rs: New.\n+\t* rust/compile/torture/traits10.rs: New.\n+\t* rust/compile/torture/traits11.rs: New.\n+\t* rust/compile/torture/traits12.rs: New.\n+\t* rust/compile/torture/traits13.rs: New.\n+\t* rust/compile/torture/traits14.rs: New.\n+\t* rust/compile/torture/traits15.rs: New.\n+\t* rust/compile/torture/traits16.rs: New.\n+\t* rust/compile/torture/traits17.rs: New.\n+\t* rust/compile/torture/traits18.rs: New.\n+\t* rust/compile/torture/traits19.rs: New.\n+\t* rust/compile/torture/traits2.rs: New.\n+\t* rust/compile/torture/traits3.rs: New.\n+\t* rust/compile/torture/traits4.rs: New.\n+\t* rust/compile/torture/traits5.rs: New.\n+\t* rust/compile/torture/traits6.rs: New.\n+\t* rust/compile/torture/traits7.rs: New.\n+\t* rust/compile/torture/traits8.rs: New.\n+\t* rust/compile/torture/traits9.rs: New.\n+\t* rust/compile/torture/transmute-size-check-1.rs: New.\n+\t* rust/compile/torture/transmute1.rs: New.\n+\t* rust/compile/torture/tuple1.rs: New.\n+\t* rust/compile/torture/tuple2.rs: New.\n+\t* rust/compile/torture/tuple3.rs: New.\n+\t* rust/compile/torture/tuple_enum_variants.rs: New.\n+\t* rust/compile/torture/tuple_field_access.rs: New.\n+\t* rust/compile/torture/tuple_function.rs: New.\n+\t* rust/compile/torture/tuple_index.rs: New.\n+\t* rust/compile/torture/tuple_struct1.rs: New.\n+\t* rust/compile/torture/tuple_struct2.rs: New.\n+\t* rust/compile/torture/tuple_struct_unit.rs: New.\n+\t* rust/compile/torture/tuple_struct_unused.rs: New.\n+\t* rust/compile/torture/type-alias1.rs: New.\n+\t* rust/compile/torture/type-alias2.rs: New.\n+\t* rust/compile/torture/type_infer1.rs: New.\n+\t* rust/compile/torture/type_infer2.rs: New.\n+\t* rust/compile/torture/type_infer3.rs: New.\n+\t* rust/compile/torture/type_infer4.rs: New.\n+\t* rust/compile/torture/type_infer5.rs: New.\n+\t* rust/compile/torture/type_infer6.rs: New.\n+\t* rust/compile/torture/unary_operators.rs: New.\n+\t* rust/compile/torture/undended-string-1.rs: New.\n+\t* rust/compile/torture/undended-string-2.rs: New.\n+\t* rust/compile/torture/underscore_id.rs: New.\n+\t* rust/compile/torture/union.rs: New.\n+\t* rust/compile/torture/union_union.rs: New.\n+\t* rust/compile/torture/unit_type1.rs: New.\n+\t* rust/compile/torture/unit_type2.rs: New.\n+\t* rust/compile/torture/unit_type3.rs: New.\n+\t* rust/compile/torture/unit_type4.rs: New.\n+\t* rust/compile/torture/unit_type5.rs: New.\n+\t* rust/compile/torture/unsafe1.rs: New.\n+\t* rust/compile/torture/unsafe2.rs: New.\n+\t* rust/compile/torture/unsafe3.rs: New.\n+\t* rust/compile/torture/unsafe4.rs: New.\n+\t* rust/compile/torture/unused.rs: New.\n+\t* rust/compile/torture/unused1.rs: New.\n+\t* rust/compile/torture/unused_struct.rs: New.\n+\t* rust/compile/torture/unused_struct_field.rs: New.\n+\t* rust/compile/torture/usize1.rs: New.\n+\t* rust/compile/torture/very-broken-attr-string.rs: New.\n+\t* rust/compile/torture/while_function.rs: New.\n+\t* rust/compile/traits1.rs: New.\n+\t* rust/compile/traits10.rs: New.\n+\t* rust/compile/traits11.rs: New.\n+\t* rust/compile/traits12.rs: New.\n+\t* rust/compile/traits2.rs: New.\n+\t* rust/compile/traits3.rs: New.\n+\t* rust/compile/traits4.rs: New.\n+\t* rust/compile/traits5.rs: New.\n+\t* rust/compile/traits6.rs: New.\n+\t* rust/compile/traits7.rs: New.\n+\t* rust/compile/traits8.rs: New.\n+\t* rust/compile/traits9.rs: New.\n+\t* rust/compile/tuple1.rs: New.\n+\t* rust/compile/tuple_struct1.rs: New.\n+\t* rust/compile/tuple_struct2.rs: New.\n+\t* rust/compile/tuple_struct3.rs: New.\n+\t* rust/compile/type-alias1.rs: New.\n+\t* rust/compile/type-bindings1.rs: New.\n+\t* rust/compile/unary_negation.rs: New.\n+\t* rust/compile/unary_not.rs: New.\n+\t* rust/compile/unconstrained_type_param.rs: New.\n+\t* rust/compile/unicode_escape.rs: New.\n+\t* rust/compile/unsafe1.rs: New.\n+\t* rust/compile/unsafe10.rs: New.\n+\t* rust/compile/unsafe2.rs: New.\n+\t* rust/compile/unsafe3.rs: New.\n+\t* rust/compile/unsafe4.rs: New.\n+\t* rust/compile/unsafe5.rs: New.\n+\t* rust/compile/unsafe6.rs: New.\n+\t* rust/compile/unsafe7.rs: New.\n+\t* rust/compile/unsafe8.rs: New.\n+\t* rust/compile/unsafe9.rs: New.\n+\t* rust/compile/unterminated_c_comment.rs: New.\n+\t* rust/compile/use_1.rs: New.\n+\t* rust/compile/usize1.rs: New.\n+\t* rust/compile/xfail/lifetime_param.rs: New.\n+\t* rust/compile/xfail/struct_field_vis.rs: New.\n+\t* rust/compile/xfail/xfail.exp: New.\n+\t* rust/compile/rawbytestring.rs: New file.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\n+\t* rust/link/generic_function_0.rs: New.\n+\t* rust/link/generic_function_1.rs: New.\n+\t* rust/link/link.exp: New.\n+\t* rust/link/simple_function_0.rs: New.\n+\t* rust/link/simple_function_1.rs: New.\n+\t* rust/link/trait_import_0.rs: New.\n+\t* rust/link/trait_import_1.rs: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\t    Tom Tromey  <tom@tromey.com>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\t    Marc Poulhi\u00e8s  <dkm@kataplop.net>\n+\n+\t* rust/debug/chartype.rs: New.\n+\t* rust/debug/custom_link_section.rs: New.\n+\t* rust/debug/debug.exp: New.\n+\t* rust/debug/i8u8.rs: New.\n+\t* rust/debug/lang.rs: New.\n+\t* rust/debug/no_mangle.rs: New.\n+\t* rust/debug/oldlang.rs: New.\n+\t* rust/debug/tuple.rs: New.\n+\t* rust/debug/win64-abi.rs: New.\n+\n+2022-12-13  Philip Herron  <philip.herron@embecosm.com>\n+\t    Marc Poulhi\u00e8s  <dkm@kataplop.net>\n+\t    Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* lib/rust-dg.exp: New.\n+\t* lib/rust.exp: New.\n+\n+2022-12-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108076\n+\t* gcc.dg/torture/pr108076.c: New testcase.\n+\n+2022-12-13  Haochen Gui  <guihaoc@gcc.gnu.org>\n+\n+\t* gcc.target/powerpc/cbranchcc4-1.c: New.\n+\t* gcc.target/powerpc/cbranchcc4-2.c: New.\n+\n 2022-12-12  Jason Merrill  <jason@redhat.com>\n \n \tRevert:"}, {"sha": "26a221e1734e4fa28fc5ba05ca7f197e7f0defe1", "filename": "gcc/testsuite/g++.dg/ipa/ipa-sra-5.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-5.C?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra\"  } */\n+\n+volatile int vi;\n+\n+static void __attribute__((noinline))\n+foo (int c, int &r)\n+{\n+  int i;\n+  if (c)\n+    i = r;\n+  else\n+    i = 0;\n+  vi = i;\n+}\n+\n+void\n+bar (int c, int j)\n+{\n+  foo (c, j);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Will split parameter\" \"sra\" } } */"}, {"sha": "a7170bcf17bf0108f587d532b17f17b20e01ba06", "filename": "gcc/testsuite/gcc.c-torture/execute/pr108064.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108064.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108064.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108064.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,28 @@\n+/* PR tree-optimization/108064 */\n+\n+static inline short\n+foo (short value)\n+{\n+  return ((value >> 8) & 0xff) | ((value & 0xff) << 8);\n+}\n+\n+__attribute__((noipa))\n+void\n+bar (short *d, const short *s)\n+{\n+  for (unsigned long i = 0; i < 4; i++)\n+    d[i] = foo (s[i]);\n+}\n+\n+int\n+main ()\n+{\n+  short a[4] __attribute__((aligned (16))) = { 0xff, 0, 0, 0 };\n+  short b[4] __attribute__((aligned (16)));\n+  short c[4] __attribute__((aligned (16)));\n+\n+  bar (b, a);\n+  bar (c, b);\n+  if (a[0] != c[0])\n+    __builtin_abort ();\n+}"}, {"sha": "46fc1a5457180fbdc3ea924635f8a0d46ad71996", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-25.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-25.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wmaybe-uninitialized -Werror\"  } */\n+\n+int cbos();\n+static int aos() {\n+  cbos();\n+  return 0;\n+}\n+int cbos_ptr;\n+long cbos_psize;\n+int cbos() {\n+  if (cbos_ptr)\n+    return aos();\n+  if (cbos_psize)\n+    return 1;\n+  return 0;\n+}"}, {"sha": "08a40da1482845c271bd8f356115178b6b312ed0", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-26.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-26.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra-details\"  } */\n+\n+struct S\n+{\n+  short a, b, c;\n+};\n+\n+extern int gc;\n+extern int *arr;\n+\n+static void __attribute__((noinline))\n+foo (struct S *p)\n+{\n+  for (int i = 0; i < gc; i++)\n+    arr += p->b;\n+}\n+\n+void\n+bar (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  foo (&s);\n+  return;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Will split parameter\" \"sra\" } } */\n+"}, {"sha": "b815e8a83b17011e2942b5d688ecae0811e37f41", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-27.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-27.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra-details\"  } */\n+\n+struct S\n+{\n+  short a, b, c;\n+};\n+\n+extern int gc;\n+extern int *arr;\n+\n+static void __attribute__((noinline))\n+foo (struct S *p)\n+{\n+  for (int i = 0; i < gc; i++)\n+    arr += p->b;\n+}\n+\n+static void __attribute__((noinline))\n+baz (struct S *p)\n+{\n+  foo (p);\n+  gc = p->a + p->c;\n+}\n+\n+void\n+bar (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  foo (&s);\n+  return;\n+}\n+\n+void\n+bar2 (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  baz (&s);\n+  return;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 2 \"sra\" } } */\n+"}, {"sha": "d77d33a36083156dedd8c2a026be5a038443e1fe", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-28.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-28.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra-details\"  } */\n+\n+struct S\n+{\n+  short a, b, c;\n+};\n+\n+volatile int gc;\n+volatile int *arr;\n+\n+static void __attribute__((noinline))\n+foo (struct S *p)\n+{\n+  for (int i = 0; i < gc; i++)\n+    arr += p->b;\n+}\n+\n+void\n+bar (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  foo (&s);\n+  return;\n+}\n+\n+void\n+baz (void)\n+{\n+  foo ((struct S *) 0);\n+}\n+\n+void __attribute__((noipa))\n+confuse (void)\n+{\n+  gc = 0;\n+  baz ();\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  confuse ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-not \"Will split parameter\" \"sra\" } } */\n+"}, {"sha": "94cbe02860d30233f9dc859354081cc9cd17968b", "filename": "gcc/testsuite/gcc.dg/ipa/pr107640-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr107640-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr107640-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr107640-2.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized-slim\"  } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+int ellide (int c);\n+volatile short gi;\n+\n+void __attribute__((noipa))\n+consume_s (struct S *p)\n+{\n+  gi = p->a;\n+}\n+\n+static void __attribute__((noinline))\n+foo (struct S *p, short *r)\n+{\n+  gi = *r;\n+  if (!__builtin_constant_p (p->b))\n+    ellide (1);\n+  consume_s (p);\n+}\n+\n+static void __attribute__((noinline))\n+bar (short *r, struct S *p)\n+{\n+  gi = *r;\n+  if (!__builtin_constant_p (p->c))\n+    ellide (2);\n+  consume_s (p);\n+}\n+\n+struct S gs;\n+\n+int main (int argc, char *argv[])\n+{\n+  short i = 42;\n+  gs.a = 10;\n+  gs.b = 20;\n+  foo (&gs, &i);\n+  gs.b = 30;\n+  gs.c = 40;\n+  bar (&i, &gs);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"ellide\" \"optimized\" { xfail *-*-* } } } */"}, {"sha": "3e0a3d659d1d1c89d7902800e8b095182aefd2dd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-43.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-43.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -ftrivial-auto-var-init=zero -fdump-tree-ccp1\" } */\n+\n+int foo (int flag)\n+{\n+  int i;\n+  if (flag)\n+    i = 1;\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 1;\" \"ccp1\" } } */"}, {"sha": "3fd32bc5bb1d2453e3a70a0b46ff13793f9fa0c2", "filename": "gcc/testsuite/gcc.target/i386/pr108044-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-1.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,33 @@\n+/* PR target/108044 */\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2\" } */\n+\n+static inline unsigned __int128\n+foo (unsigned long long x, unsigned long long y)\n+{\n+  return ((unsigned __int128) x << 64) | y;\n+}\n+\n+void\n+bar (unsigned __int128 *p, unsigned long long x)\n+{\n+  p[0] = foo (x, 0xdeadbeefcafebabeULL);\n+}\n+\n+void\n+baz (unsigned __int128 *p, unsigned long long x)\n+{\n+  p[0] = foo (0xdeadbeefcafebabeULL, x);\n+}\n+\n+void\n+qux (unsigned __int128 *p, unsigned long long x)\n+{\n+  p[0] = foo (x, 0xffffffffcafebabeULL);\n+}\n+\n+void\n+corge (unsigned __int128 *p, unsigned long long x)\n+{\n+  p[0] = foo (0xffffffffcafebabeULL, x);\n+}"}, {"sha": "0adb0dddf7a098487eb111e939c61e7763b5062b", "filename": "gcc/testsuite/gcc.target/i386/pr108044-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-2.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,21 @@\n+/* PR target/108044 */\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2\" } */\n+\n+static inline unsigned long long\n+foo (unsigned int x, unsigned int y)\n+{\n+  return ((unsigned long long) x << 32) | y;\n+}\n+\n+void\n+bar (unsigned long long *p, unsigned int x)\n+{\n+  p[0] = foo (x, 0xcafebabeU);\n+}\n+\n+void\n+baz (unsigned long long *p, unsigned int x)\n+{\n+  p[0] = foo (0xcafebabeU, x);\n+}"}, {"sha": "70ba9f2f5700c31999932d230c93774347029459", "filename": "gcc/testsuite/gcc.target/i386/pr108044-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-3.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,33 @@\n+/* PR target/108044 */\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -fcf-protection=branch\" } */\n+\n+static inline unsigned __int128\n+foo (unsigned long long x, unsigned long long y)\n+{\n+  return ((unsigned __int128) x << 64) | y;\n+}\n+\n+unsigned __int128\n+bar (unsigned long long x)\n+{\n+  return foo (x, 0xfa1e0ff3ULL);\n+}\n+\n+unsigned __int128\n+baz (unsigned long long x)\n+{\n+  return foo (0xfa1e0ff3ULL, x);\n+}\n+\n+unsigned __int128\n+qux (unsigned long long x)\n+{\n+  return foo (x, 0xffbafa1e0ff3abdeULL);\n+}\n+\n+unsigned __int128\n+corge (unsigned long long x)\n+{\n+  return foo (0xffbafa1e0ff3abdeULL, x);\n+}"}, {"sha": "4880e249319bc97e2d2f09641c953bf72fb06326", "filename": "gcc/testsuite/gcc.target/i386/pr108044-4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108044-4.c?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,21 @@\n+/* PR target/108044 */\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -fcf-protection=branch\" } */\n+\n+static inline unsigned long long\n+foo (unsigned int x, unsigned int y)\n+{\n+  return ((unsigned long long) x << 32) | y;\n+}\n+\n+unsigned long long\n+bar (unsigned int x)\n+{\n+  return foo (x, 0xfa1e0ff3U);\n+}\n+\n+unsigned long long\n+baz (unsigned int x)\n+{\n+  return foo (0xfa1e0ff3U, x);\n+}"}, {"sha": "0c916c76148497c6072dba34470632eb6695bc47", "filename": "gcc/testsuite/gfortran.dg/ipa-sra-1.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fipa-sra-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fipa-sra-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fipa-sra-1.f90?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fno-inline -fno-ipa-cp -fwhole-program -fdump-ipa-sra-details\" }\n+\n+module foo\n+  implicit none\n+contains\n+  subroutine bar(a,x)\n+    real, dimension(:,:), intent(in) :: a\n+    real, intent(out) :: x\n+    integer :: i,j\n+\n+    x = 0\n+    do j=1,ubound(a,2)\n+       do i=1,ubound(a,1)\n+          x = x + a(i,j)**2\n+       end do\n+    end do\n+  end subroutine bar\n+end module foo\n+\n+program main\n+  use foo\n+  implicit none\n+  real, dimension(2,3) :: a\n+  real :: x\n+  integer :: i\n+\n+  data a /1.0, 2.0, 3.0, -1.0, -2.0, -3.0/\n+\n+  do i=1,2000000\n+     call bar(a,x)\n+  end do\n+  print *,x\n+end program main\n+\n+! { dg-final { scan-ipa-dump \"Created new node.*bar\\\\.isra\" \"sra\" } }\n+! { dg-final { scan-ipa-dump-times \"IPA_PARAM_OP_SPLIT\" 7 \"sra\" } }"}, {"sha": "9ae64c94ae0f7943223c8ebd4e30fef87baac9de", "filename": "gcc/testsuite/gfortran.dg/pr107423.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr107423.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr107423.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr107423.f90?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+! PR fortran/107423 - ICE in parse_spec\n+! Contributed by G.Steinmetz\n+\n+program p\n+  type t(k)\n+     integer, kind :: k          ! { dg-error \"Fortran 2003\" }\n+     integer :: a\n+  end type\n+contains\n+  function f()\n+    type(t(4)), allocatable :: x ! { dg-error \"Invalid character\" }\n+    allocate (t(4) :: x)         ! { dg-error \"cannot be used\" }\n+  end   ! { dg-error \"END\" }\n+end     ! { dg-error \"END\" }\n+\n+! { dg-prune-output \"Unexpected end of file\" }"}, {"sha": "4d2bd69b47e16548b89aa95db17b8d9bcdbc6cdf", "filename": "gcc/testsuite/gfortran.dg/pr48636-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline\" }\n+! { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline -fno-ipa-sra\" }\n \n module foo\n   implicit none"}, {"sha": "5661d1b9eb4fb2a0671380731a1fccc8740e0b57", "filename": "gcc/testsuite/jit.dg/test-vector-types.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fjit.dg%2Ftest-vector-types.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftestsuite%2Fjit.dg%2Ftest-vector-types.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-vector-types.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -105,6 +105,19 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n \t\t v4f_type, GCC_JIT_BINARY_OP_MULT);\n   create_vec_fn (ctxt, \"jit_v4f_div\",\n \t\t v4f_type, GCC_JIT_BINARY_OP_DIVIDE);\n+\n+  // Checking compatibility between types.\n+  CHECK_VALUE(gcc_jit_compatible_types(v4si_type, v4ui_type), 0);\n+  CHECK_VALUE(gcc_jit_compatible_types(v4si_type, v4f_type), 0);\n+  CHECK_VALUE(gcc_jit_compatible_types(v4ui_type, v4f_type), 0);\n+\n+  gcc_jit_type *v4si_type2 = gcc_jit_type_get_vector (int_type, 4);\n+  gcc_jit_type *v4ui_type2 = gcc_jit_type_get_vector (unsigned_type, 4);\n+  gcc_jit_type *v4f_type2 = gcc_jit_type_get_vector (float_type, 4);\n+\n+  CHECK_VALUE(gcc_jit_compatible_types(v4si_type, v4si_type2), 1);\n+  CHECK_VALUE(gcc_jit_compatible_types(v4ui_type, v4ui_type2), 1);\n+  CHECK_VALUE(gcc_jit_compatible_types(v4f_type, v4f_type2), 1);\n }\n \n template <typename T>"}, {"sha": "15a1a3894931456b67cd8ff47b30bb848893b8b0", "filename": "gcc/tree-inline.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-inline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-inline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -6377,6 +6377,8 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n   while (init_stmts.length ())\n     insert_init_stmt (&id, bb, init_stmts.pop ());\n+  if (param_body_adjs)\n+    param_body_adjs->append_init_stmts (bb);\n   update_clone_info (&id);\n \n   /* Remap the nonlocal_goto_save_area, if any.  */"}, {"sha": "0d47289b31d8f358cc7eefd52a851be819ce7857", "filename": "gcc/tree-ssa-ccp.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-ssa-ccp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-ssa-ccp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -722,6 +722,10 @@ likely_value (gimple *stmt)\n   if (gimple_has_volatile_ops (stmt))\n     return VARYING;\n \n+  /* .DEFERRED_INIT produces undefined.  */\n+  if (gimple_call_internal_p (stmt, IFN_DEFERRED_INIT))\n+    return UNDEFINED;\n+\n   /* Arrive here for more complex cases.  */\n   has_constant_operand = false;\n   has_undefined_operand = false;"}, {"sha": "fa2f65df159330cf884350d22edd859bbde5faa3", "filename": "gcc/tree-ssa-sccvn.cc", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-ssa-sccvn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-ssa-sccvn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -2090,7 +2090,7 @@ vn_walk_cb_data::push_partial_def (pd_data pd,\n \t    len = ROUND_UP (pd.size, BITS_PER_UNIT) / BITS_PER_UNIT;\n \t  memset (this_buffer, 0, len);\n \t}\n-      else\n+      else if (pd.rhs_off >= 0)\n \t{\n \t  len = native_encode_expr (pd.rhs, this_buffer, bufsize,\n \t\t\t\t    (MAX (0, -pd.offset)\n@@ -2105,6 +2105,24 @@ vn_walk_cb_data::push_partial_def (pd_data pd,\n \t      return (void *)-1;\n \t    }\n \t}\n+      else /* negative pd.rhs_off indicates we want to chop off first bits */\n+\t{\n+\t  if (-pd.rhs_off >= bufsize)\n+\t    return (void *)-1;\n+\t  len = native_encode_expr (pd.rhs,\n+\t\t\t\t    this_buffer + -pd.rhs_off / BITS_PER_UNIT,\n+\t\t\t\t    bufsize - -pd.rhs_off / BITS_PER_UNIT,\n+\t\t\t\t    MAX (0, -pd.offset) / BITS_PER_UNIT);\n+\t  if (len <= 0\n+\t      || len < (ROUND_UP (pd.size, BITS_PER_UNIT) / BITS_PER_UNIT\n+\t\t\t- MAX (0, -pd.offset) / BITS_PER_UNIT))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Failed to encode %u \"\n+\t\t\t \"partial definitions\\n\", ndefs);\n+\t      return (void *)-1;\n+\t    }\n+\t}\n \n       unsigned char *p = buffer;\n       HOST_WIDE_INT size = pd.size;\n@@ -3349,10 +3367,13 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t}\n \t      else if (fn == IFN_LEN_STORE)\n \t\t{\n-\t\t  pd.rhs_off = 0;\n \t\t  pd.offset = offset2i;\n \t\t  pd.size = (tree_to_uhwi (len)\n \t\t\t     + -tree_to_shwi (bias)) * BITS_PER_UNIT;\n+\t\t  if (BYTES_BIG_ENDIAN)\n+\t\t    pd.rhs_off = pd.size - tree_to_uhwi (TYPE_SIZE (vectype));\n+\t\t  else\n+\t\t    pd.rhs_off = 0;\n \t\t  if (ranges_known_overlap_p (offset, maxsize,\n \t\t\t\t\t      pd.offset, pd.size))\n \t\t    return data->push_partial_def (pd, set, set,"}, {"sha": "32f95a7a40979f4503446404b503ec84d5837521", "filename": "gcc/tree-vect-patterns.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-vect-patterns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/gcc%2Ftree-vect-patterns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.cc?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -3113,7 +3113,7 @@ vect_recog_rotate_pattern (vec_info *vinfo,\n     {\n       def = vect_recog_temp_ssa_var (utype, NULL);\n       def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd0);\n-      append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt);\n+      append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt, uvectype);\n       oprnd0 = def;\n     }\n \n@@ -3137,7 +3137,7 @@ vect_recog_rotate_pattern (vec_info *vinfo,\n     {\n       def = vect_recog_temp_ssa_var (utype, NULL);\n       def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd1);\n-      append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt);\n+      append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt, uvectype);\n     }\n   stype = TREE_TYPE (def);\n \n@@ -3185,13 +3185,13 @@ vect_recog_rotate_pattern (vec_info *vinfo,\n   def_stmt = gimple_build_assign (var1, rhs_code == LROTATE_EXPR\n \t\t\t\t\t? LSHIFT_EXPR : RSHIFT_EXPR,\n \t\t\t\t  oprnd0, def);\n-  append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt);\n+  append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt, uvectype);\n \n   var2 = vect_recog_temp_ssa_var (utype, NULL);\n   def_stmt = gimple_build_assign (var2, rhs_code == LROTATE_EXPR\n \t\t\t\t\t? RSHIFT_EXPR : LSHIFT_EXPR,\n \t\t\t\t  oprnd0, def2);\n-  append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt);\n+  append_pattern_def_seq (vinfo, stmt_vinfo, def_stmt, uvectype);\n \n   /* Pattern detected.  */\n   vect_pattern_detected (\"vect_recog_rotate_pattern\", last_stmt);\n@@ -3202,7 +3202,7 @@ vect_recog_rotate_pattern (vec_info *vinfo,\n \n   if (!useless_type_conversion_p (type, utype))\n     {\n-      append_pattern_def_seq (vinfo, stmt_vinfo, pattern_stmt);\n+      append_pattern_def_seq (vinfo, stmt_vinfo, pattern_stmt, uvectype);\n       tree result = vect_recog_temp_ssa_var (type, NULL);\n       pattern_stmt = gimple_build_assign (result, NOP_EXPR, var);\n     }"}, {"sha": "b2a765c229a2bde357ce013898a79aa587bfc986", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,3 +1,8 @@\n+2022-12-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/108072\n+\t* libbacktrace/backtrace-rename.h (backtrace_uncompress_zstd): Define.\n+\n 2022-12-09  liuhongt  <hongtao.liu@intel.com>\n \n \t* configure.tgt: Enable hwasan for x86-64."}, {"sha": "bf77f8073f865a9b24c32298ecd6667f494884c4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -1,3 +1,8 @@\n+2022-12-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* src/libbacktrace/backtrace-rename.h (backtrace_uncompress_zstd):\n+\tDefine.\n+\n 2022-12-12  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/20_util/duration/arithmetic/overflow_c++20.cc: New"}, {"sha": "5417532480e1c8f2a2bdc1bdabbf413efef9de9a", "filename": "libstdc++-v3/src/libbacktrace/backtrace-rename.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81007c525482143fdee017545ac44438b37da0e6/libstdc%2B%2B-v3%2Fsrc%2Flibbacktrace%2Fbacktrace-rename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81007c525482143fdee017545ac44438b37da0e6/libstdc%2B%2B-v3%2Fsrc%2Flibbacktrace%2Fbacktrace-rename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flibbacktrace%2Fbacktrace-rename.h?ref=81007c525482143fdee017545ac44438b37da0e6", "patch": "@@ -16,6 +16,7 @@\n #define backtrace_syminfo __glibcxx_backtrace_syminfo\n #define backtrace_uncompress_lzma __glibcxx_backtrace_uncompress_lzma\n #define backtrace_uncompress_zdebug __glibcxx_backtrace_uncompress_zdebug\n+#define backtrace_uncompress_zstd __glibcxx_backtrace_uncompress_zstd\n #define backtrace_vector_finish __glibcxx_backtrace_vector_finish\n #define backtrace_vector_grow __glibcxx_backtrace_vector_grow\n #define backtrace_vector_release __glibcxx_backtrace_vector_release"}]}