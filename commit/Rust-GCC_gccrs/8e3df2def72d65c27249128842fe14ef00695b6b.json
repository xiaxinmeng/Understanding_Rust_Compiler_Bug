{"sha": "8e3df2def72d65c27249128842fe14ef00695b6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUzZGYyZGVmNzJkNjVjMjcyNDkxMjg4NDJmZTE0ZWYwMDY5NWI2Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-10-11T16:50:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-10-11T16:50:44Z"}, "message": "NEWS: Document removal of \"new X = ...\" extension.\n\n\t* NEWS: Document removal of \"new X = ...\" extension.\n\t* class.c (initialize_array): Set TREE_HAS_CONSTRUCTOR on\n\tbrace-enclosed initializers.\n\t* cp-tree.h (CP_AGGREGATE_TYPE_P): New macro.\n\t(initialize_local_var): Remove declaration.\n\t(expand_static_init): Likewise.\n\t* decl.c (next_initializable_field): New function.\n\t(reshape_init): Likewise.\n\t(check_initializer): Use them.  Build dynamic initializer for\n\taggregates here too.\n\t(initialize_local_var): Simplify, and incorporate cleanup\n\tinsertion code as well.\n\t(destroy_local_var): Remove.\n\t(cp_finish_decl): Tidy.\n\t(expand_static_init): Fold checks for whether or not a variable\n\tneeds initialization into this function.  Simplify.\n\t* decl2.c (do_static_initialization): Simplify.\n\t* init.c (build_init): Do not set TREE_SIDE_EFFECTS when it will\n\tbe done for us automatically.\n\t(expand_default_init): Handle brace-enclosed initializers\n\tcorrectly.\n\t(expand_aggr_init_1): Remove RTL-generation code.\n\t(build_vec_init): Remove \"new X = ...\" support.\n\t* parse.y (new_initializer): Likewise.\n\t* rtti.c (get_pseudo_ti_init): Set TREE_HAS_CONSTRUCTOR on\n\tbrace-enclosed initializer.\n\t(create_pseudo_type_info): Likewise.\n\t* typeck2.c (store_init_value): Don't try to handle digest_init\n\tbeing called more than once.\n\t(digest_init): Tidy handling of brace-enclosed initializers.\n\n\t* g++.dg/init/array1.C: Remove invalid braces.\n\t* g++.dg/init/brace1.C: New test.\n\t* g++.dg/init/copy2.C: Likewise.\n\t* g++.dg/init/copy3.C: Likewise.\n\t* g++.old-deja/g++.ext/arrnew.C: Change WARNING to ERROR.\n\t* g++.old-deja/g++.mike/p9129.C: Add ERROR on invalid use of\n\tbraces.\n\nFrom-SVN: r58053", "tree": {"sha": "9c2e122fd8114e13c9a7e7b1f586fcf1e369c77d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c2e122fd8114e13c9a7e7b1f586fcf1e369c77d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e3df2def72d65c27249128842fe14ef00695b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3df2def72d65c27249128842fe14ef00695b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e3df2def72d65c27249128842fe14ef00695b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3df2def72d65c27249128842fe14ef00695b6b/comments", "author": null, "committer": null, "parents": [{"sha": "98ddd678f0a8bee7c9a0673089f14c4d0448f6cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ddd678f0a8bee7c9a0673089f14c4d0448f6cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ddd678f0a8bee7c9a0673089f14c4d0448f6cd"}], "stats": {"total": 635, "additions": 441, "deletions": 194}, "files": [{"sha": "c2a44c397a7ab17d98341cdc94d1a0e0d40f4c72", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -1,3 +1,36 @@\n+2002-10-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* NEWS: Document removal of \"new X = ...\" extension.\n+\t* class.c (initialize_array): Set TREE_HAS_CONSTRUCTOR on\n+\tbrace-enclosed initializers.\n+\t* cp-tree.h (CP_AGGREGATE_TYPE_P): New macro.\n+\t(initialize_local_var): Remove declaration.\n+\t(expand_static_init): Likewise.\n+\t* decl.c (next_initializable_field): New function.\n+\t(reshape_init): Likewise.\n+\t(check_initializer): Use them.  Build dynamic initializer for\n+\taggregates here too.\n+\t(initialize_local_var): Simplify, and incorporate cleanup\n+\tinsertion code as well.\n+\t(destroy_local_var): Remove.\n+\t(cp_finish_decl): Tidy.\n+\t(expand_static_init): Fold checks for whether or not a variable\n+\tneeds initialization into this function.  Simplify.\n+\t* decl2.c (do_static_initialization): Simplify.\n+\t* init.c (build_init): Do not set TREE_SIDE_EFFECTS when it will\n+\tbe done for us automatically.\n+\t(expand_default_init): Handle brace-enclosed initializers\n+\tcorrectly.\n+\t(expand_aggr_init_1): Remove RTL-generation code.\n+\t(build_vec_init): Remove \"new X = ...\" support.\n+\t* parse.y (new_initializer): Likewise.\n+\t* rtti.c (get_pseudo_ti_init): Set TREE_HAS_CONSTRUCTOR on\n+\tbrace-enclosed initializer.\n+\t(create_pseudo_type_info): Likewise.\n+\t* typeck2.c (store_init_value): Don't try to handle digest_init\n+\tbeing called more than once.\n+\t(digest_init): Tidy handling of brace-enclosed initializers.\n+\t\n 2002-10-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl.c (typename_hash): Use htab_hash_pointer."}, {"sha": "85642b587d9fc3a51478d819fba932e4b87e0105", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -1,3 +1,7 @@\n+*** Changes in GCC 3.3:\n+\n+* The \"new X = 3\" extension has been removed; you must now use \"new X(3)\".\n+\n *** Changes in GCC 3.1:\n \n * -fhonor-std and -fno-honor-std have been removed. -fno-honor-std was"}, {"sha": "5b5332579b1d7889ce5d5571b80b17675b1b68c5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -6994,6 +6994,7 @@ initialize_array (decl, inits)\n   context = DECL_CONTEXT (decl);\n   DECL_CONTEXT (decl) = NULL_TREE;\n   DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE, inits);\n+  TREE_HAS_CONSTRUCTOR (DECL_INITIAL (decl)) = 1;\n   cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n   DECL_CONTEXT (decl) = context;\n }"}, {"sha": "97b7177d14b9a373dfe3563c26c8c541e200a188", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -2437,8 +2437,18 @@ struct lang_decl GTY(())\n    || TYPE_PTRMEM_P (TYPE)\t\t\t\\\n    || TYPE_PTRMEMFUNC_P (TYPE))\n \n-/* Nonzero for _TYPE means that the _TYPE defines\n-   at least one constructor.  */\n+/* [dcl.init.aggr]\n+\n+   An aggregate is an array or a class with no user-declared\n+   constructors, no private or protected non-static data members, no\n+   base classes, and no virtual functions.  */\n+#define CP_AGGREGATE_TYPE_P(TYPE)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   || (CLASS_TYPE_P (TYPE)\t\t\t\\\n+       && !CLASSTYPE_NON_AGGREGATE (TYPE)))\n+\n+/* Nonzero for a class type means that the class type has a\n+   user-declared constructor.  */\n #define TYPE_HAS_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1 (NODE))\n \n /* When appearing in an INDIRECT_REF, it means that the tree structure\n@@ -3667,8 +3677,6 @@ extern void start_decl_1\t\t\tPARAMS ((tree));\n extern void cp_finish_decl\t\t\tPARAMS ((tree, tree, tree, int));\n extern void finish_decl\t\t\t\tPARAMS ((tree, tree, tree));\n extern void maybe_inject_for_scope_var          PARAMS ((tree));\n-extern void initialize_local_var                PARAMS ((tree, tree, int));\n-extern void expand_static_init\t\t\tPARAMS ((tree, tree));\n extern tree start_handler_parms                 PARAMS ((tree, tree));\n extern int complete_array_type\t\t\tPARAMS ((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPARAMS ((tree));"}, {"sha": "f4651dbefcd2be79ad868303b21e60bfcc538964", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 317, "deletions": 119, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -121,11 +121,10 @@ static void pop_labels PARAMS ((tree));\n static void maybe_deduce_size_from_array_init PARAMS ((tree, tree));\n static void layout_var_decl PARAMS ((tree));\n static void maybe_commonize_var PARAMS ((tree));\n-static tree check_initializer PARAMS ((tree, tree));\n+static tree check_initializer (tree, tree, int);\n static void make_rtl_for_nonlocal_decl PARAMS ((tree, tree, const char *));\n static void save_function_data PARAMS ((tree));\n static void check_function_type PARAMS ((tree, tree));\n-static void destroy_local_var PARAMS ((tree));\n static void begin_constructor_body PARAMS ((void));\n static void finish_constructor_body PARAMS ((void));\n static void begin_destructor_body PARAMS ((void));\n@@ -143,6 +142,10 @@ static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n static void store_parm_decls PARAMS ((tree));\n static int cp_missing_noreturn_ok_p PARAMS ((tree));\n+static void initialize_local_var (tree, tree);\n+static void expand_static_init (tree, tree);\n+static tree next_initializable_field (tree);\n+static tree reshape_init (tree, tree *);\n \n #if defined (DEBUG_BINDING_LEVELS)\n static void indent PARAMS ((void));\n@@ -7727,14 +7730,220 @@ check_for_uninitialized_const_var (decl)\n     error (\"uninitialized const `%D'\", decl);\n }\n \n+/* FIELD is a FIELD_DECL or NULL.  In the former case, the value\n+   returned is the next FIELD_DECL (possibly FIELD itself) that can be\n+   initialized.  If there are no more such fields, the return value\n+   will be NULL.  */\n+\n+static tree\n+next_initializable_field (tree field)\n+{\n+  while (field\n+\t && (TREE_CODE (field) != FIELD_DECL\n+\t     || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field))\n+\t     || DECL_ARTIFICIAL (field)))\n+    field = TREE_CHAIN (field);\n+\n+  return field;\n+}\n+\n+/* Undo the brace-elision allowed by [dcl.init.aggr] in a\n+   brace-enclosed aggregate initializer.\n+\n+   *INITP is one of a list of initializers describing a brace-enclosed\n+   initializer for an entity of the indicated aggregate TYPE.  It may\n+   not presently match the shape of the TYPE; for example:\n+   \n+     struct S { int a; int b; };\n+     struct S a[] = { 1, 2, 3, 4 };\n+\n+   Here *INITP will point to TREE_LIST of four elements, rather than a\n+   list of two elements, each itself a list of two elements.  This\n+   routine transforms INIT from the former form into the latter.  The\n+   revised initializer is returned.  */\n+\n+static tree\n+reshape_init (tree type, tree *initp)\n+{\n+  tree inits;\n+  tree old_init;\n+  tree old_init_value;\n+  tree new_init;\n+  bool brace_enclosed_p;\n+\n+  old_init = *initp;\n+  old_init_value = (TREE_CODE (*initp) == TREE_LIST\n+\t\t    ? TREE_VALUE (*initp) : old_init);\n+\n+  /* If the initializer is brace-enclosed, pull initializers from the\n+     enclosed elements.  Advance past the brace-enclosed initializer\n+     now.  */\n+  if (TREE_CODE (old_init_value) == CONSTRUCTOR \n+      && TREE_HAS_CONSTRUCTOR (old_init_value))\n+    {\n+      *initp = TREE_CHAIN (old_init);\n+      TREE_CHAIN (old_init) = NULL_TREE;\n+      inits = CONSTRUCTOR_ELTS (old_init_value);\n+      initp = &inits;\n+      brace_enclosed_p = true;\n+    }\n+  else\n+    {\n+      inits = NULL_TREE;\n+      brace_enclosed_p = false;\n+    }\n+\n+  /* A non-aggregate type is always initialized with a single\n+     initializer.  */\n+  if (!CP_AGGREGATE_TYPE_P (type))\n+      {\n+\t*initp = TREE_CHAIN (old_init);\n+\tTREE_CHAIN (old_init) = NULL_TREE;\n+\t/* It is invalid to initialize a non-aggregate type with a\n+\t   brace-enclosed initializer.  */\n+\tif (brace_enclosed_p)\n+\t  {\n+\t    error (\"brace-enclosed initializer used to initialize `%T'\",\n+\t\t   type);\n+\t    if (TREE_CODE (old_init) == TREE_LIST)\n+\t      TREE_VALUE (old_init) = error_mark_node;\n+\t    else\n+\t      old_init = error_mark_node;\n+\t  }\n+\t\n+\treturn old_init;\n+      }\n+\n+  /* [dcl.init.aggr]\n+\n+     All implicit type conversions (clause _conv_) are considered when\n+     initializing the aggregate member with an initializer from an\n+     initializer-list.  If the initializer can initialize a member,\n+     the member is initialized.  Otherwise, if the member is itself a\n+     non-empty subaggregate, brace elision is assumed and the\n+     initializer is considered for the initialization of the first\n+     member of the subaggregate.  */\n+  if (CLASS_TYPE_P (type) \n+      && !brace_enclosed_p\n+      && can_convert_arg (type, TREE_TYPE (old_init_value), old_init_value))\n+    {\n+      *initp = TREE_CHAIN (old_init);\n+      TREE_CHAIN (old_init) = NULL_TREE;\n+      return old_init;\n+    }\n+\n+  if (TREE_CODE (old_init) == STRING_CST\n+      && TREE_CODE (type) == ARRAY_TYPE\n+      && char_type_p (TREE_TYPE (type)))\n+    {\n+      /* [dcl.init.string]\n+\n+\t A char array (whether plain char, signed char, or unsigned char)\n+\t can be initialized by a string-literal (optionally enclosed in\n+\t braces); a wchar_t array can be initialized by a wide\n+\t string-literal (optionally enclosed in braces).  */\n+      new_init = old_init;\n+      /* Move past the initializer.  */\n+      *initp = TREE_CHAIN (old_init);\n+      TREE_CHAIN (old_init) = NULL_TREE;\n+    }\n+  else\n+    {\n+      /* Build a CONSTRUCTOR to hold the contents of the aggregate.  */  \n+      new_init = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n+      TREE_HAS_CONSTRUCTOR (new_init) = 1;\n+\n+      if (CLASS_TYPE_P (type))\n+\t{\n+\t  tree field;\n+\n+\t  field = next_initializable_field (TYPE_FIELDS (type));\n+\n+\t  if (!field)\n+\t    {\n+\t      /* [dcl.init.aggr]\n+\t      \n+\t\t An initializer for an aggregate member that is an\n+\t\t empty class shall have the form of an empty\n+\t\t initializer-list {}.  */\n+\t      if (!brace_enclosed_p)\n+\t\terror (\"initializer for `%T' must be brace-enclosed\",\n+\t\t       type);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Loop through the initializable fields, gathering\n+\t\t initializers.  */\n+\t      while (*initp && field)\n+\t\t{\n+\t\t  tree field_init;\n+\n+\t\t  field_init = reshape_init (TREE_TYPE (field), initp);\n+\t\t  TREE_CHAIN (field_init) = CONSTRUCTOR_ELTS (new_init);\n+\t\t  CONSTRUCTOR_ELTS (new_init) = field_init;\n+\t\t  /* [dcl.init.aggr] \n+\n+\t\t     When a union  is  initialized with a brace-enclosed\n+\t\t     initializer, the braces shall only contain an\n+\t\t     initializer for the first member of the union.  */\n+\t\t  if (TREE_CODE (type) == UNION_TYPE)\n+\t\t    break;\n+\t\t  if (TREE_PURPOSE (field_init))\n+\t\t    field = TREE_PURPOSE (field_init);\n+\t\t  field = next_initializable_field (TREE_CHAIN (field));\n+\t\t}\n+\t    }\n+\t}\n+      else if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  tree index;\n+\t  tree max_index;\n+\n+\t  /* If the bound of the array is known, take no more initializers\n+\t     than are allowed.  */\n+\t  max_index = (TYPE_DOMAIN (type) \n+\t\t       ? array_type_nelts (type) : NULL_TREE);\n+\t  /* Loop through the array elements, gathering initializers.  */\n+\t  for (index = size_zero_node;\n+\t       *initp && (!max_index || !tree_int_cst_lt (max_index, index));\n+\t       index = size_binop (PLUS_EXPR, index, size_one_node))\n+\t    {\n+\t      tree element_init;\n+\n+\t      element_init = reshape_init (TREE_TYPE (type), initp);\n+\t      TREE_CHAIN (element_init) = CONSTRUCTOR_ELTS (new_init);\n+\t      CONSTRUCTOR_ELTS (new_init) = element_init;\n+\t      if (TREE_PURPOSE (element_init))\n+\t\tindex = TREE_PURPOSE (element_init);\n+\t    }\n+\t}\n+      else\n+\tabort ();\n+\n+      /* The initializers were placed in reverse order in the\n+\t CONSTRUCTOR.  */\n+      CONSTRUCTOR_ELTS (new_init) = nreverse (CONSTRUCTOR_ELTS (new_init));\n+\n+      if (TREE_CODE (old_init) == TREE_LIST)\n+\tnew_init = build_tree_list (TREE_PURPOSE (old_init), new_init);\n+    }\n+\n+  /* If this was a brace-enclosed initializer and all of the\n+     initializers were not used up, there is a problem.  */\n+  if (brace_enclosed_p && *initp)\n+    error (\"too many initializers for `%T'\", type);\n+\n+  return new_init;\n+}\n+\n /* Verify INIT (the initializer for DECL), and record the\n-   initialization in DECL_INITIAL, if appropriate.  Returns a new\n-   value for INIT.  */\n+   initialization in DECL_INITIAL, if appropriate.  \n+\n+   If the return value is non-NULL, it is an expression that must be\n+   evaluated dynamically to initialize DECL.  */\n \n static tree\n-check_initializer (decl, init)\n-     tree decl;\n-     tree init;\n+check_initializer (tree decl, tree init, int flags)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -7790,22 +7999,49 @@ check_initializer (decl, init)\n     init = grok_reference_init (decl, type, init);\n   else if (init)\n     {\n+      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))\n+\tinit = reshape_init (type, &init);\n+\n+      /* If DECL has an array type without a specific bound, deduce the\n+\t array size from the initializer.  */\n+      maybe_deduce_size_from_array_init (decl, init);\n+      type = TREE_TYPE (decl);\n+      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))\n+\tTREE_TYPE (init) = type;\n+\n       if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n \t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    init = digest_init (type, init, (tree *) 0);\n+\t    goto initialize_aggr;\n \t  else if (TREE_CODE (init) == CONSTRUCTOR\n \t\t   && TREE_HAS_CONSTRUCTOR (init))\n \t    {\n \t      if (TYPE_NON_AGGREGATE_CLASS (type))\n \t\t{\n \t\t  error (\"`%D' must be initialized by constructor, not by `{...}'\",\n-\t\t\t    decl);\n+\t\t\t decl);\n \t\t  init = error_mark_node;\n \t\t}\n \t      else\n \t\tgoto dont_use_constructor;\n \t    }\n+\t  else\n+\t    {\n+\t      int saved_stmts_are_full_exprs_p;\n+\n+\t    initialize_aggr:\n+\t      saved_stmts_are_full_exprs_p = 0;\n+\t      if (building_stmt_tree ())\n+\t\t{\n+\t\t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n+\t\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n+\t\t}\n+\t      init = build_aggr_init (decl, init, flags);\n+\t      if (building_stmt_tree ())\n+\t\tcurrent_stmt_tree ()->stmts_are_full_exprs_p =\n+\t\t  saved_stmts_are_full_exprs_p;\n+\t      return init;\n+\t    }\n \t}\n       else\n \t{\n@@ -7816,25 +8052,26 @@ check_initializer (decl, init)\n     }\n   else if (DECL_EXTERNAL (decl))\n     ;\n-  else if (TYPE_P (type)\n-\t   && (IS_AGGR_TYPE (type) || TYPE_NEEDS_CONSTRUCTING (type)))\n+  else if (TYPE_P (type) && TYPE_NEEDS_CONSTRUCTING (type))\n+    goto initialize_aggr;\n+  else if (IS_AGGR_TYPE (type))\n     {\n       tree core_type = strip_array_types (type);\n \n-      if (! TYPE_NEEDS_CONSTRUCTING (core_type))\n-\t{\n-\t  if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type))\n-\t    error (\"structure `%D' with uninitialized const members\", decl);\n-\t  if (CLASSTYPE_REF_FIELDS_NEED_INIT (core_type))\n-\t    error (\"structure `%D' with uninitialized reference members\",\n-\t\t      decl);\n-\t}\n+      if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type))\n+\terror (\"structure `%D' with uninitialized const members\", decl);\n+      if (CLASSTYPE_REF_FIELDS_NEED_INIT (core_type))\n+\terror (\"structure `%D' with uninitialized reference members\",\n+\t       decl);\n \n       check_for_uninitialized_const_var (decl);\n     }\n   else\n     check_for_uninitialized_const_var (decl);\n \n+  if (init && init != error_mark_node)\n+    init = build (INIT_EXPR, type, decl, init);\n+\n   return init;\n }\n \n@@ -7968,50 +8205,41 @@ maybe_inject_for_scope_var (decl)\n \n /* Generate code to initialize DECL (a local variable).  */\n \n-void\n-initialize_local_var (decl, init, flags)\n+static void\n+initialize_local_var (decl, init)\n      tree decl;\n      tree init;\n-     int flags;\n {\n   tree type = TREE_TYPE (decl);\n \n-  /* If the type is bogus, don't bother initializing the variable.  */\n-  if (type == error_mark_node)\n-    return;\n+  my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n+\t\t      || TREE_CODE (decl) == RESULT_DECL, \n+\t\t      20021010);\n+  my_friendly_assert (!TREE_STATIC (decl), 20021010);\n \n-  if (DECL_SIZE (decl) == NULL_TREE && !TREE_STATIC (decl))\n+  if (DECL_SIZE (decl) == NULL_TREE)\n     {\n       /* If we used it already as memory, it must stay in memory.  */\n       DECL_INITIAL (decl) = NULL_TREE;\n       TREE_ADDRESSABLE (decl) = TREE_USED (decl);\n     }\n \n-  /* Local statics are handled differently from ordinary automatic\n-     variables.  */\n-  if (TREE_STATIC (decl))\n-    {\n-      if (TYPE_NEEDS_CONSTRUCTING (type) || init != NULL_TREE\n-\t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\texpand_static_init (decl, init);\n-      return;\n-    }\n-\n   if (DECL_SIZE (decl) && type != error_mark_node)\n     {\n       int already_used;\n \n       /* Compute and store the initial value.  */\n       already_used = TREE_USED (decl) || TREE_USED (type);\n \n-      if (init || TYPE_NEEDS_CONSTRUCTING (type))\n+      /* Perform the initialization.  */\n+      if (init)\n \t{\n \t  int saved_stmts_are_full_exprs_p;\n \n \t  my_friendly_assert (building_stmt_tree (), 20000906);\n \t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n-\t  finish_expr_stmt (build_aggr_init (decl, init, flags));\n+\t  finish_expr_stmt (init);\n \t  current_stmt_tree ()->stmts_are_full_exprs_p =\n \t    saved_stmts_are_full_exprs_p;\n \t}\n@@ -8030,39 +8258,19 @@ initialize_local_var (decl, init, flags)\n       else if (already_used)\n \tTREE_USED (decl) = 1;\n     }\n-}\n-\n-/* Generate code to destroy DECL (a local variable).  */\n-\n-static void\n-destroy_local_var (decl)\n-     tree decl;\n-{\n-  tree type = TREE_TYPE (decl);\n-  tree cleanup;\n-\n-  /* Only variables get cleaned up.  */\n-  if (TREE_CODE (decl) != VAR_DECL)\n-    return;\n-\n-  /* And only things with destructors need cleaning up.  */\n-  if (type == error_mark_node\n-      || TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n-    return;\n \n-  if (TREE_CODE (decl) == VAR_DECL &&\n-      (DECL_EXTERNAL (decl) || TREE_STATIC (decl)))\n-    /* We don't clean up things that aren't defined in this\n-       translation unit, or that need a static cleanup.  The latter\n-       are handled by finish_file.  */\n-    return;\n-\n-  /* Compute the cleanup.  */\n-  cleanup = cxx_maybe_build_cleanup (decl);\n+  /* Generate a cleanup, if necessary.  */\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+    {\n+      tree cleanup;\n \n-  /* Record the cleanup required for this declaration.  */\n-  if (DECL_SIZE (decl) && cleanup)\n-    finish_decl_cleanup (decl, cleanup);\n+      /* Compute the cleanup.  */\n+      cleanup = cxx_maybe_build_cleanup (decl);\n+      \n+      /* Record the cleanup required for this declaration.  */\n+      if (DECL_SIZE (decl) && cleanup)\n+\tfinish_decl_cleanup (decl, cleanup);\n+    }\n }\n \n /* Finish processing of a declaration;\n@@ -8193,7 +8401,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       make_decl_rtl (decl, asmspec);\n     }\n   else if (TREE_CODE (decl) == RESULT_DECL)\n-    init = check_initializer (decl, init);\n+    init = check_initializer (decl, init, flags);\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Only PODs can have thread-local storage.  Other types may require\n@@ -8205,28 +8413,19 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t already initialized DECL.  */\n       if (!DECL_INITIALIZED_P (decl)\n \t  /* If !DECL_EXTERNAL then DECL is being defined.  In the\n-\t     case of a static data memberm initialized inside the\n+\t     case of a static data member initialized inside the\n \t     class-specifier, there can be an initializer even if DECL\n \t     is *not* defined.  */\n \t  && (!DECL_EXTERNAL (decl) || init))\n \t{\n-\t  init = check_initializer (decl, init);\n+\t  init = check_initializer (decl, init, flags);\n \t  /* Thread-local storage cannot be dynamically initialized.  */\n \t  if (DECL_THREAD_LOCAL (decl) && init)\n \t    {\n \t      error (\"`%D' is thread-local and so cannot be dynamically \"\n \t\t     \"initialized\", decl);\n \t      init = NULL_TREE;\n \t    }\n-\t  /* If DECL has an array type without a specific bound, deduce the\n-\t     array size from the initializer.  Note that this must be done\n-\t     after check_initializer is called because of cases like this:\n-\t     \n- \t       struct S { int a; int b; };\n-\t       struct S a[] = { 1, 2 };\n-\t \n-\t     which creates a one-element array, not a two-element array.  */\n-\t  maybe_deduce_size_from_array_init (decl, init);\n \t  /* Handle:\n \t     \n \t     [dcl.init]\n@@ -8283,7 +8482,9 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       else\n \tabstract_virtuals_error (decl, strip_array_types (type));\n \n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n+      if (TREE_CODE (decl) == FUNCTION_DECL \n+\t  || TREE_TYPE (decl) == error_mark_node)\n+\t/* No initialization required.  */\n \t;\n       else if (DECL_EXTERNAL (decl)\n \t       && ! (DECL_LANG_SPECIFIC (decl)\n@@ -8292,35 +8493,25 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t  if (init)\n \t    DECL_INITIAL (decl) = init;\n \t}\n-      else if (TREE_CODE (CP_DECL_CONTEXT (decl)) == FUNCTION_DECL)\n+      else\n \t{\n-\t  /* This is a local declaration.  */\n-\t  if (doing_semantic_analysis_p ())\n-\t    maybe_inject_for_scope_var (decl);\n-\t  /* Initialize the local variable.  But, if we're building a\n-\t     statement-tree, we'll do the initialization when we\n-\t     expand the tree.  */\n-\t  if (processing_template_decl)\n+\t  /* A variable definition.  */\n+\t  if (DECL_FUNCTION_SCOPE_P (decl))\n \t    {\n-\t      if (init || DECL_INITIAL (decl) == error_mark_node)\n-\t\tDECL_INITIAL (decl) = init;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If we're not building RTL, then we need to do so\n-\t\t now.  */\n-\t      my_friendly_assert (building_stmt_tree (), 20000906);\n-\t      /* Initialize the variable.  */\n-\t      initialize_local_var (decl, init, flags);\n-\t      /* Clean up the variable.  */\n-\t      destroy_local_var (decl);\n+\t      /* This is a local declaration.  */\n+\t      if (doing_semantic_analysis_p ())\n+\t\tmaybe_inject_for_scope_var (decl);\n+\t      /* Initialize the local variable.  */\n+\t      if (processing_template_decl)\n+\t\t{\n+\t\t  if (init || DECL_INITIAL (decl) == error_mark_node)\n+\t\t    DECL_INITIAL (decl) = init;\n+\t\t}\n+\t      else if (!TREE_STATIC (decl))\n+\t\tinitialize_local_var (decl, init);\n \t    }\n-\t}\n-      else if (TREE_STATIC (decl) && type != error_mark_node)\n-\t{\n-\t  /* Cleanups for static variables are handled by `finish_file'.  */\n-\t  if (TYPE_NEEDS_CONSTRUCTING (type) || init != NULL_TREE\n-\t      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+\n+\t  if (TREE_STATIC (decl))\n \t    expand_static_init (decl, init);\n \t}\n     finish_end0:\n@@ -8600,12 +8791,27 @@ register_dtor_fn (decl)\n   finish_expr_stmt (build_function_call (get_atexit_node (), args));\n }\n \n-void\n+/* DECL is a VAR_DECL with static storage duration.  INIT, if present,\n+   is its initializer.  Generate code to handle the construction\n+   and destruction of DECL.  */\n+\n+static void\n expand_static_init (decl, init)\n      tree decl;\n      tree init;\n {\n-  tree oldstatic = value_member (decl, static_aggregates);\n+  tree oldstatic;\n+\n+  my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 20021010);\n+  my_friendly_assert (TREE_STATIC (decl), 20021010);\n+\n+  /* Some variables require no initialization.  */\n+  if (!init \n+      && !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n+      && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+    return;\n+\n+  oldstatic = value_member (decl, static_aggregates);\n \n   if (oldstatic)\n     {\n@@ -8655,15 +8861,7 @@ expand_static_init (decl, init)\n       then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n \n       /* Do the initialization itself.  */\n-      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n-\t  || (init && TREE_CODE (init) == TREE_LIST))\n-\tassignment = build_aggr_init (decl, init, 0);\n-      else if (init)\n-\t/* The initialization we're doing here is just a bitwise\n-\t   copy.  */\n-\tassignment = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n-      else\n-\tassignment = NULL_TREE;\n+      assignment = init ? init : NULL_TREE;\n \n       /* Once the assignment is complete, set TEMP to 1.  Since the\n \t construction of the static object is complete at this point,"}, {"sha": "afa65a092790de06a88f1ef1a1f96faa09a16943", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -2508,34 +2508,24 @@ finish_static_initialization_or_destruction (guard_if_stmt)\n   DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n }\n \n-/* Generate code to do the static initialization of DECL.  The\n-   initialization is INIT.  If DECL may be initialized more than once\n-   in different object files, GUARD is the guard variable to \n-   check.  PRIORITY is the priority for the initialization.  */\n+/* Generate code to do the initialization of DECL, a VAR_DECL with\n+   static storage duration.  The initialization is INIT.  */\n \n static void\n do_static_initialization (decl, init)\n      tree decl;\n      tree init;\n {\n-  tree expr;\n   tree guard_if_stmt;\n \n   /* Set up for the initialization.  */\n   guard_if_stmt\n     = start_static_initialization_or_destruction (decl,\n \t\t\t\t\t\t  /*initp=*/1);\n-  \n-  /* Do the initialization itself.  */\n-  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n-      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-    expr = build_aggr_init (decl, init, 0);\n-  else\n-    {\n-      expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n-      TREE_SIDE_EFFECTS (expr) = 1;\n-    }\n-  finish_expr_stmt (expr);\n+\n+  /* Perform the initialization.  */\n+  if (init)\n+    finish_expr_stmt (init);\n \n   /* If we're using __cxa_atexit, register a a function that calls the\n      destructor for the object.  */\n@@ -2567,7 +2557,7 @@ do_static_destruction (decl)\n \n   /* Actually do the destruction.  */\n   guard_if_stmt = start_static_initialization_or_destruction (decl,\n-\t\t\t\t\t\t\t       /*initp=*/0);\n+\t\t\t\t\t\t\t      /*initp=*/0);\n   finish_expr_stmt (build_cleanup (decl));\n   finish_static_initialization_or_destruction (guard_if_stmt);\n }"}, {"sha": "051548ecb028b7cac90f0be04558441b568d07d7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -1041,8 +1041,6 @@ expand_member_init (tree name, tree init)\n    The virtual function table pointer cannot be set up here, because\n    we do not really know its type.\n \n-   Virtual baseclass pointers are also set up here.\n-\n    This never calls operator=().\n \n    When initializing, nothing is CONST.\n@@ -1144,10 +1142,8 @@ build_init (decl, init, flags)\n       || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n     expr = build_aggr_init (decl, init, flags);\n   else\n-    {\n-      expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n-      TREE_SIDE_EFFECTS (expr) = 1;\n-    }\n+    expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n+\n   return expr;\n }\n \n@@ -1184,9 +1180,17 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n \t   have already built up the constructor call so we could wrap it\n \t   in an exception region.  */;\n       else if (TREE_CODE (init) == CONSTRUCTOR)\n-\t/* A brace-enclosed initializer has whatever type is\n-\t   required.  There's no need to convert it.  */\n-\t;\n+\t{\n+\t  if (!TYPE_HAS_CONSTRUCTOR (type))\n+\t    /* A brace-enclosed initializer has whatever type is\n+\t       required.  There's no need to convert it.  */\n+\t    ;\n+\t  else\n+\t    init = ocp_convert (type, \n+\t\t\t\tTREE_VALUE (CONSTRUCTOR_ELTS (init)),\n+\t\t\t\tCONV_IMPLICIT | CONV_FORCE_TEMP, \n+\t\t\t\tflags);\n+\t}\n       else\n \tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n@@ -1259,6 +1263,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, flags)\n   tree type = TREE_TYPE (exp);\n \n   my_friendly_assert (init != error_mark_node && type != error_mark_node, 211);\n+  my_friendly_assert (building_stmt_tree (), 20021010);\n \n   /* Use a function returning the desired type to initialize EXP for us.\n      If the function is a constructor, and its first argument is\n@@ -1273,12 +1278,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, flags)\n       /* If store_init_value returns NULL_TREE, the INIT has been\n \t record in the DECL_INITIAL for EXP.  That means there's\n \t nothing more we have to do.  */\n-      if (!store_init_value (exp, init))\n-\t{\n-\t  if (!building_stmt_tree ())\n-\t    expand_decl_init (exp);\n-\t}\n-      else\n+      if (store_init_value (exp, init))\n \tfinish_expr_stmt (build (INIT_EXPR, type, exp, init));\n       return;\n     }\n@@ -2725,10 +2725,6 @@ build_vec_init (base, init, from_array)\n   if (maxindex == error_mark_node)\n     return error_mark_node;\n \n-  /* For g++.ext/arrnew.C.  */\n-  if (init && TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == NULL_TREE)\n-    init = digest_init (atype, init, 0);\n-      \n   if (init\n       && (from_array == 2\n \t  ? (!CLASS_TYPE_P (type) || !TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n@@ -2745,7 +2741,6 @@ build_vec_init (base, init, from_array)\n \t store_constructor will handle the semantics for us.  */\n \n       stmt_expr = build (INIT_EXPR, atype, base, init);\n-      TREE_SIDE_EFFECTS (stmt_expr) = 1;\n       return stmt_expr;\n     }\n "}, {"sha": "104c4a70ed032a37f4f3bd6d11b7f9fd55955691", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -1351,21 +1351,12 @@ new_initializer:\n \t\t  error (\"`%T' is not a valid expression\", $2.t);\n \t\t  $$ = error_mark_node;\n \t\t}\n-\t/* GNU extension so people can use initializer lists.  Note that\n-\t   this alters the meaning of `new int = 1', which was previously\n-\t   syntactically valid but semantically invalid.\n-           This feature is now deprecated and will be removed in a future\n-           release.  */\n \t| '=' init\n \t\t{\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ISO C++ forbids initialization of new expression with `='\");\n-\t\t  cp_deprecated (\"new initializer lists extension\");\n-\t\t  if (TREE_CODE ($2) != TREE_LIST\n-\t\t      && TREE_CODE ($2) != CONSTRUCTOR)\n-\t\t    $$ = build_tree_list (NULL_TREE, $2);\n-\t\t  else\n-\t\t    $$ = $2;\n+\t\t  /* This was previously allowed as an extension, but\n+\t\t     was removed in G++ 3.3.  */\n+\t\t  error (\"initialization of new expression with `='\");\n+\t\t  $$ = error_mark_node;\n \t\t}\n \t;\n "}, {"sha": "d6ddf131bc1c13afb5f7770b1697fee8ef1cc7b8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -1096,10 +1096,12 @@ get_pseudo_ti_init (type, var_desc, non_public_p)\n               base_init = tree_cons (NULL_TREE, offset, base_init);\n               base_init = tree_cons (NULL_TREE, tinfo, base_init);\n               base_init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_init);\n+\t      TREE_HAS_CONSTRUCTOR (base_init) = 1;\n               base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n             }\n \t  base_inits = build (CONSTRUCTOR,\n \t\t\t      NULL_TREE, NULL_TREE, base_inits);\n+\t  TREE_HAS_CONSTRUCTOR (base_inits) = 1;\n \t  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n \t  /* Prepend the number of bases.  */\n \t  base_inits = tree_cons (NULL_TREE,\n@@ -1163,7 +1165,7 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n   /* Create the pseudo type.  */\n   pseudo_type = make_aggr_type (RECORD_TYPE);\n   finish_builtin_type (pseudo_type, pseudo_name, fields, ix, ptr_type_node);\n-  TYPE_HAS_CONSTRUCTOR (pseudo_type) = 1;\n+  CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n \n   result = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n   TINFO_REAL_NAME (result) = get_identifier (real_name);"}, {"sha": "cc712b91bef5ead1f52d7ee98f65fd9a0db7436f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -367,15 +367,8 @@ store_init_value (decl, init)\n \n   /* End of special C++ code.  */\n \n-  /* We might have already run this bracketed initializer through\n-     digest_init.  Don't do so again.  */\n-  if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init)\n-      && TREE_TYPE (init)\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (init)) == TYPE_MAIN_VARIANT (type))\n-    value = init;\n-  else\n-    /* Digest the specified initializer into an expression.  */\n-    value = digest_init (type, init, (tree *) 0);\n+  /* Digest the specified initializer into an expression.  */\n+  value = digest_init (type, init, (tree *) 0);\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -439,8 +432,7 @@ digest_init (type, init, tail)\n   enum tree_code code = TREE_CODE (type);\n   tree element = NULL_TREE;\n   tree old_tail_contents = NULL_TREE;\n-  /* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR\n-     tree node which has no TREE_TYPE.  */\n+  /* Nonzero if INIT is a braced grouping.  */\n   int raw_constructor;\n \n   /* By default, assume we use one element from a list.\n@@ -471,10 +463,8 @@ digest_init (type, init, tail)\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);\n \n-  if (TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == type)\n-    return init;\n-\n-  raw_constructor = TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == 0;\n+  raw_constructor = (TREE_CODE (init) == CONSTRUCTOR \n+\t\t     && TREE_HAS_CONSTRUCTOR (init));\n \n   if (raw_constructor\n       && CONSTRUCTOR_ELTS (init) != 0"}, {"sha": "4fbef9b2fad5a8b086ca33b8079ecf203f4631a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -1,3 +1,13 @@\n+2002-10-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/init/array1.C: Remove invalid braces.\n+\t* g++.dg/init/brace1.C: New test.\n+\t* g++.dg/init/copy2.C: Likewise.\n+\t* g++.dg/init/copy3.C: Likewise.\n+\t* g++.old-deja/g++.ext/arrnew.C: Change WARNING to ERROR.\n+\t* g++.old-deja/g++.mike/p9129.C: Add ERROR on invalid use of\n+\tbraces.\n+\t\n 2002-10-11  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* gcc.dg/cpp/assembler.S: Don't use -ansi."}, {"sha": "5847247c158d172ea654756ebca2a17ec6ab3376", "filename": "gcc/testsuite/g++.dg/init/array1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray1.C?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -6,15 +6,15 @@\n typedef int iArr[];\n \n const iArr array4={\n-  {1},{2},{3},{4}\n+  1, 2, 3, 4\n };\n \n const iArr array3={\n-  {1},{2},{3}\n+  1, 2, 3\n };\n \n const iArr array5={\n-  {1},{2},{3},{4},{5}\n+  1, 2, 3, 4, 5\n };\n \n int main()"}, {"sha": "a819fa2587cd7d92003e65067c4423eb821ec972", "filename": "gcc/testsuite/g++.dg/init/brace1.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace1.C?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do compile }\n+\n+int i[4] = { { 3 } }; // { dg-error \"brace\" }\n+"}, {"sha": "9a662d4cf165b53b51732aa83e96c4b138a806fe", "filename": "gcc/testsuite/g++.dg/init/copy2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy2.C?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile }\n+\n+struct S { S (); };\n+\n+volatile S s[1] = { S () };"}, {"sha": "fa6a6ea18841975d068e9f8e6f91a7dddf1bf570", "filename": "gcc/testsuite/g++.dg/init/copy3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy3.C?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do run }\n+// { dg-options \"-fno-elide-constructors\" }\n+\n+int copies;\n+\n+struct S { \n+  S () {}\n+  S (const S&) { ++copies; }\n+};\n+\n+S s[1] = { S () };\n+\n+int main () {\n+  if (copies != 1)\n+    return 1;\n+}"}, {"sha": "53030e0d3d7cbfff0e1bec5a8ae765307cb444de", "filename": "gcc/testsuite/g++.old-deja/g++.ext/arrnew.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Farrnew.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Farrnew.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Farrnew.C?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -3,5 +3,5 @@\n // Special g++ Options:\n \n int *f(){\n-  return new int[1] = { 1 };   // WARNING - deprecated\n+  return new int[1] = { 1 };   // ERROR - removed\n }"}, {"sha": "a986104688e7c77e45ffa476ad7cb28ba8881860", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p9129.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp9129.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3df2def72d65c27249128842fe14ef00695b6b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp9129.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp9129.C?ref=8e3df2def72d65c27249128842fe14ef00695b6b", "patch": "@@ -7,6 +7,6 @@ public:\n   int DoSomething();\n };\n \n-int (Foo::*pA)() = { &Foo::DoSomething };\t\n+int (Foo::*pA)() = { &Foo::DoSomething };\t// ERROR - \n int (Foo::*X[1])(int) = { { &Foo::DoSomething } };\t\t    // ERROR - \n int (Foo::*Y[])(int) = { { &Foo::DoSomething, &Foo::DoSomething, 0 } }; // ERROR - "}]}