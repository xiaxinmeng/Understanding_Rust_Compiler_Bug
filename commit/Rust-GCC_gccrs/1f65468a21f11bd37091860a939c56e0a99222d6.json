{"sha": "1f65468a21f11bd37091860a939c56e0a99222d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2NTQ2OGEyMWYxMWJkMzcwOTE4NjBhOTM5YzU2ZTBhOTkyMjJkNg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-08-23T17:49:39Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-08-23T17:49:39Z"}, "message": "re PR fortran/57798 (Incorrect handling of sum over first dimension of a product of automatic arrays)\n\nfortran/\n\tPR fortran/57798\n\t* trans-array.c (gfc_conv_ss_startstride, set_loop_bounds,\n\tgfc_set_delta): Generate preliminary code before the outermost loop.\n\ntestsuite/\n\tPR fortran/57798\n\t* gfortran.dg/inline_sum_5.f90: New.\n\nFrom-SVN: r201947", "tree": {"sha": "04d4e4db6912a0a62a0e817c0291108fd5ad5963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04d4e4db6912a0a62a0e817c0291108fd5ad5963"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f65468a21f11bd37091860a939c56e0a99222d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f65468a21f11bd37091860a939c56e0a99222d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f65468a21f11bd37091860a939c56e0a99222d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f65468a21f11bd37091860a939c56e0a99222d6/comments", "author": null, "committer": null, "parents": [{"sha": "4f7395ffa13bb498c010aad0f08d137a7f766a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7395ffa13bb498c010aad0f08d137a7f766a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f7395ffa13bb498c010aad0f08d137a7f766a1d"}], "stats": {"total": 65, "additions": 58, "deletions": 7}, "files": [{"sha": "e804749727d2afadd2732a49da6ae68af164bb78", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1f65468a21f11bd37091860a939c56e0a99222d6", "patch": "@@ -1,3 +1,9 @@\n+2013-08-23  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/57798\n+\t* trans-array.c (gfc_conv_ss_startstride, set_loop_bounds,\n+\tgfc_set_delta): Generate preliminary code before the outermost loop.\n+\n 2013-08-23  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/57843"}, {"sha": "5a3cf80f9f644da484d3b2783407f148e17c5fe4", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1f65468a21f11bd37091860a939c56e0a99222d6", "patch": "@@ -3776,6 +3776,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n   gfc_ss *ss;\n   tree desc;\n \n+  gfc_loopinfo * const outer_loop = outermost_loop (loop);\n+\n   loop->dimen = 0;\n   /* Determine the rank of the loop.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n@@ -3835,10 +3837,11 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  /* Get the descriptor for the array.  If it is a cross loops array,\n \t     we got the descriptor already in the outermost loop.  */\n \t  if (ss->parent == NULL)\n-\t    gfc_conv_ss_descriptor (&loop->pre, ss, !loop->array_parameter);\n+\t    gfc_conv_ss_descriptor (&outer_loop->pre, ss,\n+\t\t\t\t    !loop->array_parameter);\n \n \t  for (n = 0; n < ss->dimen; n++)\n-\t    gfc_conv_section_startstride (&loop->pre, ss, ss->dim[n]);\n+\t    gfc_conv_section_startstride (&outer_loop->pre, ss, ss->dim[n]);\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n@@ -3874,7 +3877,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t\t   fold_convert (gfc_array_index_type,\n \t\t\t\t\t\t\t rank),\n \t\t\t\t\t   gfc_index_one_node);\n-\t\t    info->end[0] = gfc_evaluate_now (tmp, &loop->pre);\n+\t\t    info->end[0] = gfc_evaluate_now (tmp, &outer_loop->pre);\n \t\t    info->start[0] = gfc_index_zero_node;\n \t\t    info->stride[0] = gfc_index_one_node;\n \t\t    continue;\n@@ -4156,7 +4159,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t}\n \n       tmp = gfc_finish_block (&block);\n-      gfc_add_expr_to_block (&loop->pre, tmp);\n+      gfc_add_expr_to_block (&outer_loop->pre, tmp);\n     }\n \n   for (loop = loop->nested; loop; loop = loop->next)\n@@ -4439,6 +4442,8 @@ set_loop_bounds (gfc_loopinfo *loop)\n   mpz_t i;\n   bool nonoptional_arr;\n \n+  gfc_loopinfo * const outer_loop = outermost_loop (loop);\n+\n   loopspec = loop->specloop;\n \n   mpz_init (i);\n@@ -4627,7 +4632,7 @@ set_loop_bounds (gfc_loopinfo *loop)\n       else\n \t{\n \t  /* Set the delta for this section.  */\n-\t  info->delta[dim] = gfc_evaluate_now (loop->from[n], &loop->pre);\n+\t  info->delta[dim] = gfc_evaluate_now (loop->from[n], &outer_loop->pre);\n \t  /* Number of iterations is (end - start + step) / step.\n \t     with start = 0, this simplifies to\n \t     last = end / step;\n@@ -4639,7 +4644,7 @@ set_loop_bounds (gfc_loopinfo *loop)\n \t\t\t\t gfc_array_index_type, tmp, info->stride[dim]);\n \t  tmp = fold_build2_loc (input_location, MAX_EXPR, gfc_array_index_type,\n \t\t\t\t tmp, build_int_cst (gfc_array_index_type, -1));\n-\t  loop->to[n] = gfc_evaluate_now (tmp, &loop->pre);\n+\t  loop->to[n] = gfc_evaluate_now (tmp, &outer_loop->pre);\n \t  /* Make the loop variable start at 0.  */\n \t  loop->from[n] = gfc_index_zero_node;\n \t}\n@@ -4715,6 +4720,8 @@ gfc_set_delta (gfc_loopinfo *loop)\n   tree tmp;\n   int n, dim;\n \n+  gfc_loopinfo * const outer_loop = outermost_loop (loop);\n+\n   loopspec = loop->specloop;\n \n   /* Calculate the translation from loop variables to array indices.  */\n@@ -4750,7 +4757,7 @@ gfc_set_delta (gfc_loopinfo *loop)\n \t\t\t\t     gfc_array_index_type,\n \t\t\t\t     info->start[dim], tmp);\n \n-\t      info->delta[dim] = gfc_evaluate_now (tmp, &loop->pre);\n+\t      info->delta[dim] = gfc_evaluate_now (tmp, &outer_loop->pre);\n \t    }\n \t}\n     }"}, {"sha": "f8efd687233d9fb3b89741a2ec960edf6d5a6972", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f65468a21f11bd37091860a939c56e0a99222d6", "patch": "@@ -1,3 +1,8 @@\n+2013-08-23  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/57798\n+\t* gfortran.dg/inline_sum_5.f90: New.\n+\n 2013-08-23  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/57843"}, {"sha": "bda73fd99a3f8a56eb97f63a0645fe67ef2a6952", "filename": "gcc/testsuite/gfortran.dg/inline_sum_5.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f65468a21f11bd37091860a939c56e0a99222d6/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_5.f90?ref=1f65468a21f11bd37091860a939c56e0a99222d6", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+!\n+! PR fortran/57798\n+! The call to sum used to be inlined into a loop with an uninitialized bound\n+!\n+! Original testcase by Stephan Kramer <stephan.kramer@imperial.ac.uk>\n+\n+program test\n+  implicit none\n+\n+  call sub(2, 11)\n+\n+  contains\n+\n+    function func(m, n)\n+      integer, intent(in):: m,n\n+      real, dimension(m, n):: func\n+\n+      func = 1.0\n+\n+    end function func\n+\n+    subroutine sub(m, n)\n+      integer, intent(in):: m, n\n+      real, dimension(m,n):: y\n+\n+      y = 1.0\n+      if (any(sum(y*func(m,n), dim=1) /= m)) call abort\n+\n+    end subroutine sub\n+\n+end program test\n+"}]}