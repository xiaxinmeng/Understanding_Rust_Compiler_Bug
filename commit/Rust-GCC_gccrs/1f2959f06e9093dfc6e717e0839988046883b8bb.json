{"sha": "1f2959f06e9093dfc6e717e0839988046883b8bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYyOTU5ZjA2ZTkwOTNkZmM2ZTcxN2UwODM5OTg4MDQ2ODgzYjhiYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-16T16:00:45Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-16T16:00:45Z"}, "message": "array.c, [...]: Fix comment typos.\n\n\t* array.c, data.c, decl.c, dependency.c, error.c, f95-lang.c,\n\tinterface.c, intrinsic.c, io.c, misc.c, module.c, parse.h,\n\tresolve.c, scanner.c, trans-array.c, trans-array.h,\n\ttrans-common.c, trans-const.h, trans-decl.c, trans-expr.c,\n\ttrans-intrinsic.c, trans-stmt.c, trans-types.c, trans.c,\n\ttrans.h: Fix comment typos.  Follow spelling conventions.\n\nFrom-SVN: r87605", "tree": {"sha": "d4390e21373fcfa884178f5708c587e4da66100a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4390e21373fcfa884178f5708c587e4da66100a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f2959f06e9093dfc6e717e0839988046883b8bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2959f06e9093dfc6e717e0839988046883b8bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f2959f06e9093dfc6e717e0839988046883b8bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2959f06e9093dfc6e717e0839988046883b8bb/comments", "author": null, "committer": null, "parents": [{"sha": "d1f05f931e1689f7a0811acc39379831d40dcea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1f05f931e1689f7a0811acc39379831d40dcea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1f05f931e1689f7a0811acc39379831d40dcea9"}], "stats": {"total": 145, "additions": 77, "deletions": 68}, "files": [{"sha": "fb2306967e3611e1bd6d6421deec34450bab20c9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -1,3 +1,12 @@\n+2004-09-16  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* array.c, data.c, decl.c, dependency.c, error.c, f95-lang.c,\n+\tinterface.c, intrinsic.c, io.c, misc.c, module.c, parse.h,\n+\tresolve.c, scanner.c, trans-array.c, trans-array.h,\n+\ttrans-common.c, trans-const.h, trans-decl.c, trans-expr.c,\n+\ttrans-intrinsic.c, trans-stmt.c, trans-types.c, trans.c,\n+\ttrans.h: Fix comment typos.  Follow spelling conventions.\n+\n 2004-09-16  Victor Leikehman  <lei@il.ibm.com>\n \n \tPR/15364"}, {"sha": "ac1ea6f9f9255174fd9648df0bda284843edbffc", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -941,7 +941,7 @@ check_element_type (gfc_expr * expr)\n {\n \n   if (cons_state == CONS_BAD)\n-    return 0;\t\t\t/* Supress further errors */\n+    return 0;\t\t\t/* Suppress further errors */\n \n   if (cons_state == CONS_START)\n     {\n@@ -1607,7 +1607,7 @@ gfc_get_array_element (gfc_expr * array, int element)\n \n /********* Subroutines for determining the size of an array *********/\n \n-/* These are needed just to accomodate RESHAPE().  There are no\n+/* These are needed just to accommodate RESHAPE().  There are no\n    diagnostics here, we just return a negative number if something\n    goes wrong. */\n "}, {"sha": "0c4429a6c15376472cc41bd7bb3721dada80b7fb", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -542,7 +542,7 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n \n \n /* Rearrange a structure constructor so the elements are in the specified\n-   order.  Also insert NULL entries if neccessary.  */\n+   order.  Also insert NULL entries if necessary.  */\n \n static void\n formalize_structure_cons (gfc_expr * expr)"}, {"sha": "44cd2fdbe79cdd984d8e015f51d3caa618309bd8", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -2444,7 +2444,7 @@ gfc_match_subroutine (void)\n }\n \n \n-/* Return nonzero if we're currenly compiling a contained procedure.  */\n+/* Return nonzero if we're currently compiling a contained procedure.  */\n \n static int\n contained_procedure (void)"}, {"sha": "a89e96504da47440336d565d1c0583ab050cdc84", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -306,7 +306,7 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, gfc_expr ** vars,\n       return 1;\n \n     case EXPR_FUNCTION:\n-      /* Remember possible differences betweeen elemental and\n+      /* Remember possible differences between elemental and\n          transformational functions.  All functions inside a FORALL\n          will be pure.  */\n       for (actual = expr2->value.function.actual;"}, {"sha": "084f0ef474e9180664c79e3136b61dcef220d9d1", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -741,7 +741,7 @@ gfc_status_char (char c)\n }\n \n \n-/* Report the number of warnings and errors that occured to the caller.  */\n+/* Report the number of warnings and errors that occurred to the caller.  */\n \n void\n gfc_get_errors (int *w, int *e)"}, {"sha": "d5e436d1159b43b4c9f71a8c1778c5786c068545", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -403,7 +403,7 @@ pushlevel (int ignore ATTRIBUTE_UNUSED)\n tree\n poplevel (int keep, int reverse, int functionbody)\n {\n-  /* Points to a BLOCK tree node. This is the BLOCK node construted for the\n+  /* Points to a BLOCK tree node. This is the BLOCK node constructed for the\n      binding level that we are about to exit and which is returned by this\n      routine.  */\n   tree block_node = NULL_TREE;\n@@ -413,7 +413,7 @@ poplevel (int keep, int reverse, int functionbody)\n \n   /* Reverse the list of XXXX_DECL nodes if desired.  Note that the ..._DECL\n      nodes chained through the `names' field of current_binding_level are in\n-     reverse order except for PARM_DECL node, which are explicitely stored in\n+     reverse order except for PARM_DECL node, which are explicitly stored in\n      the right order.  */\n   decl_chain = (reverse) ? nreverse (current_binding_level->names)\n     : current_binding_level->names;\n@@ -665,7 +665,7 @@ gfc_mark_addressable (tree exp)\n \n int ggc_p = 1;\n \n-/* Builtin function initialisation.  */\n+/* Builtin function initialization.  */\n \n /* Return a definition for a builtin function named NAME and whose data type\n    is TYPE.  TYPE should be a function type with argument types.\n@@ -752,7 +752,7 @@ build_builtin_fntypes (tree * fntype, tree type)\n }\n \n \n-/* Initialisation of builtin function nodes.  */\n+/* Initialization of builtin function nodes.  */\n \n static void\n gfc_init_builtin_functions (void)"}, {"sha": "72d2e5ce44111cda1558b72d466f44c7988c198a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -1623,7 +1623,7 @@ find_sym_in_symtree (gfc_symbol * sym)\n \n /* This subroutine is called when an expression is being resolved.\n    The expression node in question is either a user defined operator\n-   or an instrinsic operator with arguments that aren't compatible\n+   or an intrinsic operator with arguments that aren't compatible\n    with the operator.  This subroutine builds an actual argument list\n    corresponding to the operands, then searches for a compatible\n    interface.  If one is found, the expression node is replaced with"}, {"sha": "949f399dda61f24f297e98fd247857e1cb7197e1", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -35,7 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intrinsic.h\"\n \n \n-/* Nanespace to hold the resolved symbols for intrinsic subroutines.  */\n+/* Namespace to hold the resolved symbols for intrinsic subroutines.  */\n static gfc_namespace *gfc_intrinsic_namespace;\n \n int gfc_init_expr = 0;"}, {"sha": "73bb06b86f0df806686a6e850d71842ac718310b", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -1773,7 +1773,7 @@ gfc_resolve_dt (gfc_dt * dt)\n   if (gfc_reference_st_label (dt->eor, ST_LABEL_TARGET) == FAILURE)\n     return FAILURE;\n \n-  /* Check the format label ectually exists.  */\n+  /* Check the format label actually exists.  */\n   if (dt->format_label && dt->format_label != &format_asterisk\n       && dt->format_label->defined == ST_LABEL_UNKNOWN)\n     {"}, {"sha": "431284ca7d4d26bc47eb4beb4f6a893164d0db0c", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -178,7 +178,7 @@ gfc_basic_typename (bt type)\n }\n \n \n-/* Return a string descibing the type and kind of a typespec.  Because\n+/* Return a string describing the type and kind of a typespec.  Because\n    we return alternating buffers, this subroutine can appear twice in\n    the argument list of a single statement.  */\n "}, {"sha": "5eaf8fb2a643cea774747f5f04307e99537df817", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -78,7 +78,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define MODULE_EXTENSION \".mod\"\n \n \n-/* Structure that descibes a position within a module file */\n+/* Structure that describes a position within a module file */\n \n typedef struct\n {\n@@ -1706,7 +1706,7 @@ mio_array_spec (gfc_array_spec ** asp)\n    gfc_ref structure), find the corresponding array specification\n    structure.  Storing the pointer in the ref structure doesn't quite\n    work when loading from a module. Generating code for an array\n-   reference also needs more infomation than just the array spec.  */\n+   reference also needs more information than just the array spec.  */\n \n static const mstring array_ref_types[] = {\n     minit (\"FULL\", AR_FULL),"}, {"sha": "0d6130eb0fb6a2a684082655d75e772f6931176c", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -1,5 +1,5 @@\n /* Parser header\n-   Copyright (C) 2003 Free Software Foundaton, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n This file is part of GCC."}, {"sha": "5169f5e8b0f61c61f4b4c1344ea99ad1a50d00e0", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -2735,7 +2735,7 @@ validate_case_label_expr (gfc_expr * e, gfc_expr * case_expr)\n    because they are illegal and we never even try to generate code.\n \n    We have the additional caveat that a SELECT construct could have\n-   been a computed GOTO in the source code. Furtunately we can fairly\n+   been a computed GOTO in the source code. Fortunately we can fairly\n    easily work around that here: The case_expr for a \"real\" SELECT CASE\n    is in code->expr1, but for a computed GOTO it is in code->expr2. All\n    we have to do is make sure that the case_expr is a scalar integer\n@@ -4160,7 +4160,7 @@ check_data_variable (gfc_data_variable * var, locus * where)\n \t}\n       gcc_assert (ref);\n \n-      /* Set marks asscording to the reference pattern.  */\n+      /* Set marks according to the reference pattern.  */\n       switch (ref->u.ar.type)\n \t{\n \tcase AR_FULL:"}, {"sha": "9f03c77d9963456d0bb611d2d3f1b57d55dd1a7a", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -689,7 +689,7 @@ load_line (FILE * input, char **pbuf, char *filename, int linenum)\n   static int buflen = 0;\n   char *buffer;\n \n-  /* Detemine the maximum allowed line length.  */\n+  /* Determine the maximum allowed line length.  */\n   if (gfc_current_form == FORM_FREE)\n     maxlen = GFC_MAX_LINE;\n   else\n@@ -739,7 +739,7 @@ load_line (FILE * input, char **pbuf, char *filename, int linenum)\n \t}\n \n       if (gfc_current_form == FORM_FIXED && c == '\\t' && i <= 6)\n-\t{\t\t\t/* Tab expandsion.  */\n+\t{\t\t\t/* Tab expansion.  */\n \t  while (i <= 6)\n \t    {\n \t      *buffer++ = ' ';"}, {"sha": "9fe35139faea6862d59ef277462e7116a9ee5264", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -60,7 +60,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    The scalar gfc_conv_* functions are then used to build the main body of the\n    scalarization loop.  Scalarization loop variables and precalculated scalar\n-   values are automaticaly substituted.  Note that gfc_advance_se_ss_chain\n+   values are automatically substituted.  Note that gfc_advance_se_ss_chain\n    must be used, rather than changing the se->ss directly.\n \n    For assignment expressions requiring a temporary two sub loops are\n@@ -1289,7 +1289,7 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n }\n \n \n-/* Initialise a gfc_loopinfo structure.  */\n+/* Initialize a gfc_loopinfo structure.  */\n \n void\n gfc_init_loopinfo (gfc_loopinfo * loop)\n@@ -1670,7 +1670,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar)\n   /* Calculate the offsets from all the dimensions.  */\n   for (n = 0; n < ar->dimen; n++)\n     {\n-      /* Calculate the index for this demension.  */\n+      /* Calculate the index for this dimension.  */\n       gfc_init_se (&indexse, NULL);\n       gfc_conv_expr_type (&indexse, ar->start[n], gfc_array_index_type);\n       gfc_add_block_to_block (&se->pre, &indexse.pre);\n@@ -2392,7 +2392,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n }\n \n \n-/* Initialise the scalarization loop.  Creates the loop variables.  Determines\n+/* Initialize the scalarization loop.  Creates the loop variables.  Determines\n    the range of the loop variables.  Creates a temporary if required.\n    Calculates how to transform from loop variables to array indices for each\n    expression.  Also generates code for scalar expressions which have been\n@@ -2619,7 +2619,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \n /* Fills in an array descriptor, and returns the size of the array.  The size\n    will be a simple_val, ie a variable or a constant.  Also calculates the\n-   offset of the base.  Returns the size of the arrary.\n+   offset of the base.  Returns the size of the array.\n    {\n     stride = 1;\n     offset = 0;\n@@ -2735,7 +2735,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n }\n \n \n-/* Initialises the descriptor and generates a call to _gfor_allocate.  Does\n+/* Initializes the descriptor and generates a call to _gfor_allocate.  Does\n    the work for an ALLOCATE statement.  */\n /*GCC ARRAYS*/\n \n@@ -3154,7 +3154,7 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n     gfc_add_modify_expr (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n-  /* Set the pointer itself if we aren't using the parameter dirtectly.  */\n+  /* Set the pointer itself if we aren't using the parameter directly.  */\n   if (TREE_CODE (parm) != PARM_DECL)\n     {\n       tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));\n@@ -3272,7 +3272,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   else\n     {\n       gcc_assert (integer_onep (GFC_TYPE_ARRAY_STRIDE (type, 0)));\n-      /* A library call to repack the array if neccessary.  */\n+      /* A library call to repack the array if necessary.  */\n       tmp = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n       tmp = gfc_chainon_list (NULL_TREE, tmp);\n       stmt_unpacked = gfc_build_function_call (gfor_fndecl_in_pack, tmp);\n@@ -4268,7 +4268,7 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_expr * expr,\n       newss = gfc_walk_subexpr (head, arg->expr);\n       if (newss == head)\n \t{\n-\t  /* Scalar argumet.  */\n+\t  /* Scalar argument.  */\n \t  newss = gfc_get_ss ();\n \t  newss->type = type;\n \t  newss->expr = arg->expr;\n@@ -4365,7 +4365,7 @@ gfc_walk_array_constructor (gfc_ss * ss, gfc_expr * expr)\n }\n \n \n-/* Walk an expresson.  Add walked expressions to the head of the SS chain.\n+/* Walk an expression.  Add walked expressions to the head of the SS chain.\n    A wholy scalar expression will not be added.  */\n \n static gfc_ss *\n@@ -4412,7 +4412,7 @@ gfc_walk_subexpr (gfc_ss * ss, gfc_expr * expr)\n /* Entry point for expression walking.\n    A return value equal to the passed chain means this is\n    a scalar expression.  It is up to the caller to take whatever action is\n-   neccessary to translate these.  */\n+   necessary to translate these.  */\n \n gfc_ss *\n gfc_walk_expr (gfc_expr * expr)"}, {"sha": "7a0240350d6e7fdefa5a57eaca637a355698c0b2", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -22,7 +22,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Generate code to free an array.  */\n tree gfc_array_deallocate (tree);\n \n-/* Generate code to initialise an allocate an array.  Statements are added to\n+/* Generate code to initialize an allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n void gfc_array_allocate (gfc_se *, gfc_ref *, tree);\n \n@@ -36,7 +36,7 @@ tree gfc_trans_auto_array_allocation (tree, gfc_symbol *, tree);\n tree gfc_trans_dummy_array_bias (gfc_symbol *, tree, tree);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n tree gfc_trans_g77_array (gfc_symbol *, tree);\n-/* Add initialisation for deferred arrays.  */\n+/* Add initialization for deferred arrays.  */\n tree gfc_trans_deferred_array (gfc_symbol *, tree);\n /* Generate an initializer for a static pointer or allocatable array.  */\n void gfc_trans_static_array_pointer (gfc_symbol *);\n@@ -49,7 +49,7 @@ gfc_ss *gfc_walk_elemental_function_args (gfc_ss *, gfc_expr *, gfc_ss_type);\n gfc_ss *gfc_walk_intrinsic_function (gfc_ss *, gfc_expr *,\n \t\t\t\t     gfc_intrinsic_sym *);\n \n-/* Free the SS assocuated with a loop.  */\n+/* Free the SS associated with a loop.  */\n void gfc_cleanup_loop (gfc_loopinfo *);\n /* Associate a SS chain with a loop.  */\n void gfc_add_ss_to_loop (gfc_loopinfo *, gfc_ss *);\n@@ -68,7 +68,7 @@ void gfc_start_scalarized_body (gfc_loopinfo *, stmtblock_t *);\n void gfc_trans_scalarizing_loops (gfc_loopinfo *, stmtblock_t *);\n /* Mark the end of the main loop body and the start of the copying loop.  */\n void gfc_trans_scalarized_loop_boundary (gfc_loopinfo *, stmtblock_t *);\n-/* Initialise the scalarization loop parameters.  */\n+/* Initialize the scalarization loop parameters.  */\n void gfc_conv_loop_setup (gfc_loopinfo *);\n /* Resolve array assignment dependencies.  */\n void gfc_conv_resolve_dependencies (gfc_loopinfo *, gfc_ss *, gfc_ss *);"}, {"sha": "38e813ec56781dccfeb4373abf4d52f096f16840", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -23,7 +23,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    way to build UNION_TYPE is borrowed from Richard Henderson.\n  \n    Transform common blocks.  An integral part of this is processing\n-   equvalence variables.  Equivalenced variables that are not in a\n+   equivalence variables.  Equivalenced variables that are not in a\n    common block end up in a private block of their own.\n \n    Each common block or local equivalence list is declared as a union.\n@@ -400,7 +400,7 @@ create_common (gfc_common_head *com)\n               if (s->offset < offset)\n                 {\n \t\t    /* We have overlapping initializers.  It could either be\n-\t\t       partially initilalized arrays (legal), or the user\n+\t\t       partially initialized arrays (legal), or the user\n \t\t       specified multiple initial values (illegal).\n \t\t       We don't implement this yet, so bail out.  */\n                   gfc_todo_error (\"Initialization of overlapping variables\");\n@@ -743,7 +743,7 @@ finish_equivalences (gfc_namespace *ns)\n         sym = z->expr->symtree->n.sym;\n         current_segment = get_segment_info (sym, 0);\n \n-        /* All objects directly or indrectly equivalenced with this symbol.  */\n+        /* All objects directly or indirectly equivalenced with this symbol.  */\n         add_equivalences ();\n \n         /* Calculate the minimal offset.  */"}, {"sha": "0fe2d3ac2fd434d0a46ac68261a76d5c2f5642cb", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -42,7 +42,7 @@ tree gfc_conv_string_init (tree, gfc_expr *);\n /* Create a tree node for the string length if it is constant.  */\n void gfc_conv_const_charlen (gfc_charlen *);\n \n-/* Initialise the nodes for constants.  */\n+/* Initialize the nodes for constants.  */\n void gfc_init_constants (void);\n \n /* Build a constant with given type from an int_cst.  */"}, {"sha": "8cb308d37b272fd86faa0630109b5906da8d38ff", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -1079,7 +1079,7 @@ build_function_decl (gfc_symbol * sym)\n     {\n       /* TODO: check if a pure SUBROUTINE has no INTENT(OUT) arguments\n \t including a alternate return. In that case it can also be\n-\t marked as PURE. See also in gfc_get_extern_fucntion_decl().  */\n+\t marked as PURE. See also in gfc_get_extern_function_decl().  */\n       if (attr.function)\n \tDECL_IS_PURE (fndecl) = 1;\n       TREE_SIDE_EFFECTS (fndecl) = 0;\n@@ -1844,7 +1844,7 @@ gfc_build_builtin_function_decls (void)\n }\n \n \n-/* Exaluate the length of dummy character variables.  */\n+/* Evaluate the length of dummy character variables.  */\n \n static tree\n gfc_trans_dummy_character (gfc_charlen * cl, tree fnbody)"}, {"sha": "9e4df47f3dab637c15c9092894bdd016ae06e48c", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -1133,7 +1133,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t actual argument is passed according to the\n \t\t corresponding formal argument.  If the corresponding\n \t\t formal argument is a POINTER or assumed shape, we do\n-\t\t not use g77's calling aonvention, and pass the\n+\t\t not use g77's calling convention, and pass the\n \t\t address of the array descriptor instead. Otherwise we\n \t\t use g77's calling convention.  */\n \t      int f;"}, {"sha": "d76619a994426aacf3e70db45bb46748237cdfcb", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -619,7 +619,7 @@ gfc_conv_intrinsic_exponent (gfc_se * se, gfc_expr * expr)\n }\n \n /* Evaluate a single upper or lower bound.  */\n-/* TODO: bound intrinsic generates way too much unneccessary code.  */\n+/* TODO: bound intrinsic generates way too much unnecessary code.  */\n \n static void\n gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n@@ -2286,7 +2286,7 @@ gfc_conv_intrinsic_scan (gfc_se * se, gfc_expr * expr)\n \n \n /* Verify that a set of characters contains all the characters in a string\n-   by indentifying the position of the first character in a string of\n+   by identifying the position of the first character in a string of\n    characters that does not appear in a given set of characters.  */\n \n static void"}, {"sha": "53e9a85a216423381feb8873fb2a3556c088f7fd", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -572,7 +572,7 @@ gfc_trans_do (gfc_code * code)\n   gfc_add_block_to_block (&block, &se.pre);\n   step = se.expr;\n \n-  /* Initialise loop count. This code is executed before we enter the\n+  /* Initialize loop count. This code is executed before we enter the\n      loop body. We generate: count = (to + step - from) / step.  */\n \n   tmp = fold (build2 (MINUS_EXPR, type, step, from));\n@@ -582,7 +582,7 @@ gfc_trans_do (gfc_code * code)\n   count = gfc_create_var (type, \"count\");\n   gfc_add_modify_expr (&block, count, tmp);\n \n-  /* Initialise the DO variable: dovar = from.  */\n+  /* Initialize the DO variable: dovar = from.  */\n   gfc_add_modify_expr (&block, dovar, from);\n \n   /* Loop body.  */\n@@ -1317,7 +1317,7 @@ gfc_trans_nested_forall_loop (forall_info * nested_forall_info, tree body,\n \n               if (mask)\n                 {\n-                  /* If a mask was specified make the assignment contitional.  */\n+                  /* If a mask was specified make the assignment conditional.  */\n                   if (pmask)\n \t\t    tmp = gfc_build_indirect_ref (mask);\n                   else\n@@ -1545,10 +1545,10 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n     }\n   else\n     {\n-      /* Initilize count2.  */\n+      /* Initialize count2.  */\n       gfc_add_modify_expr (&block, count2, gfc_index_zero_node);\n \n-      /* Initiliaze the loop.  */\n+      /* Initialize the loop.  */\n       gfc_init_loopinfo (&loop);\n \n       /* We may need LSS to determine the shape of the expression.  */\n@@ -1823,7 +1823,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   tmp = generate_loop_for_rhs_to_temp (expr2, tmp1, inner_size, count,\n                                        count1, count2, lss, rss, wheremask);\n \n-  /* Generate body and loops according to the inforamtion in\n+  /* Generate body and loops according to the information in\n      nested_forall_info.  */\n   tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n   gfc_add_expr_to_block (block, tmp);\n@@ -1850,7 +1850,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, inner_size, count,\n                                        count1, count2, wheremask);\n \n-  /* Generate body and loops according to the inforamtion in\n+  /* Generate body and loops according to the information in\n      nested_forall_info.  */\n   tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n   gfc_add_expr_to_block (block, tmp);\n@@ -1931,7 +1931,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n           forall_tmp = forall_tmp->next_nest;\n         }\n \n-      /* Generate body and loops according to the inforamtion in\n+      /* Generate body and loops according to the information in\n          nested_forall_info.  */\n       tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n       gfc_add_expr_to_block (block, tmp);\n@@ -1964,7 +1964,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_modify_expr (&body, count, tmp);\n       tmp = gfc_finish_block (&body);\n \n-      /* Generate body and loops according to the inforamtion in\n+      /* Generate body and loops according to the information in\n          nested_forall_info.  */\n       tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n       gfc_add_expr_to_block (block, tmp);\n@@ -2020,7 +2020,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n           forall_tmp = forall_tmp->next_nest;\n         }\n \n-      /* Generate body and loops according to the inforamtion in\n+      /* Generate body and loops according to the information in\n          nested_forall_info.  */\n       tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n       gfc_add_expr_to_block (block, tmp);\n@@ -2101,7 +2101,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n     Note that this code only works when there are no dependencies.\n     Forall loop with array assignments and data dependencies are a real pain,\n     because the size of the temporary cannot always be determined before the\n-    loop is executed.  This problem is compouded by the presence of nested\n+    loop is executed.  This problem is compounded by the presence of nested\n     FORALL constructs.\n  */\n \n@@ -2314,7 +2314,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       switch (c->op)\n \t{\n \tcase EXEC_ASSIGN:\n-          /* A scalar or array assingment.  */\n+          /* A scalar or array assignment.  */\n \t  need_temp = gfc_check_dependency (c->expr, c->expr2, varexpr, nvar);\n           /* Teporaries due to array assignment data dependencies introduce\n              no end of problems.  */\n@@ -2487,7 +2487,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n \n   /* Variable to index the temporary.  */\n   count = gfc_create_var (gfc_array_index_type, \"count\");\n-  /* Initilize count.  */\n+  /* Initialize count.  */\n   gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n   gfc_start_block (&body);\n@@ -2501,7 +2501,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n     }\n   else\n     {\n-      /* Initiliaze the loop.  */\n+      /* Initialize the loop.  */\n       gfc_init_loopinfo (&loop);\n \n       /* We may need LSS to determine the shape of the expression.  */\n@@ -2791,7 +2791,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n \n \n /* Translate the WHERE construct or statement.\n-   This fuction can be called iteratelly to translate the nested WHERE\n+   This fuction can be called iteratively to translate the nested WHERE\n    construct or statement.\n    MASK is the control mask, and PMASK is the pending control mask.\n    TEMP records the temporary address which must be freed later.  */"}, {"sha": "a87e6f365ddb5284e78e884633732fd3f89ba123", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -739,7 +739,7 @@ gfc_get_element_type (tree type)\n    the calculation for stride02 would overflow.  This may still work, but\n    I haven't checked, and it relies on the overflow doing the right thing.\n \n-   The way to fix this problem is to access alements as follows:\n+   The way to fix this problem is to access elements as follows:\n    data[(index0-lbound0)*stride0 + (index1-lbound1)*stride1]\n    Obviously this is much slower.  I will make this a compile time option,\n    something like -fsmall-array-offsets.  Mixing code compiled with and without\n@@ -1392,13 +1392,13 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t  field_type = gfc_typenode_for_spec (&c->ts);\n \t}\n \n-      /* This returns an array descriptor type.  Initialisation may be\n+      /* This returns an array descriptor type.  Initialization may be\n          required.  */\n       if (c->dimension)\n \t{\n \t  if (c->pointer)\n \t    {\n-\t      /* Pointers to arrays aren't actualy pointer types.  The\n+\t      /* Pointers to arrays aren't actually pointer types.  The\n \t         descriptors are seperate, but the data is common.  */\n \t      field_type = gfc_build_array_type (field_type, c->as);\n \t    }"}, {"sha": "306c475910938aabebb0dfad9294789213a46f08", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -160,7 +160,7 @@ gfc_add_modify_expr (stmtblock_t * pblock, tree lhs, tree rhs)\n \n \n /* Create a new scope/binding level and initialize a block.  Care must be\n-   taken when translating expessions as any temporaries will be placed in\n+   taken when translating expressions as any temporaries will be placed in\n    the innermost scope.  */\n \n void"}, {"sha": "67bc2345e25224e99a894305bd1269e940a9e469", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2959f06e9093dfc6e717e0839988046883b8bb/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=1f2959f06e9093dfc6e717e0839988046883b8bb", "patch": "@@ -35,7 +35,7 @@ typedef struct\n }\n stmtblock_t;\n \n-/* a simplified expresson */\n+/* a simplified expression */\n typedef struct gfc_se\n {\n   /* Code blocks to be executed before and after using the value.  */\n@@ -199,7 +199,7 @@ typedef struct gfc_ss\n gfc_ss;\n #define gfc_get_ss() gfc_getmem(sizeof(gfc_ss))\n \n-/* The contents of this aren't actualy used.  A NULL SS chain indicates a\n+/* The contents of this aren't actually used.  A NULL SS chain indicates a\n    scalar expression, so this pointer is used to terminate SS chains.  */\n extern gfc_ss * const gfc_ss_terminator;\n \n@@ -415,7 +415,7 @@ void gfc_generate_constructors (void);\n /* Generate a runtime error check.  */\n void gfc_trans_runtime_check (tree, tree, stmtblock_t *);\n \n-/* Generate code for an assigment, includes scalarization.  */\n+/* Generate code for an assignment, includes scalarization.  */\n tree gfc_trans_assignment (gfc_expr *, gfc_expr *);\n \n /* Generate code for an pointer assignment.  */\n@@ -521,7 +521,7 @@ struct lang_decl\t\tGTY(())\n   tree saved_descriptor;\n   /* Assigned integer nodes.  Stringlength is the IO format string's length.\n      Addr is the address of the string or the target label. Stringlength is\n-     initialized to -2 and assiged to -1 when addr is assigned to the\n+     initialized to -2 and assigned to -1 when addr is assigned to the\n      address of target label.  */\n   tree stringlen;\n   tree addr;"}]}