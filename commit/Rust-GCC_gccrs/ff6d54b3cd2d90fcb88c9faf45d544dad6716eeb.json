{"sha": "ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2ZDU0YjNjZDJkOTBmY2I4OGM5ZmFmNDVkNTQ0ZGFkNjcxNmVlYg==", "commit": {"author": {"name": "Thomas Fitzsimmons", "email": "fitzsim@redhat.com", "date": "2005-05-05T01:22:12Z"}, "committer": {"name": "Thomas Fitzsimmons", "email": "fitzsim@gcc.gnu.org", "date": "2005-05-05T01:22:12Z"}, "message": "BufferStrategy.java: Document.\n\n2005-05-04  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/awt/image/BufferStrategy.java: Document.\n\nFrom-SVN: r99250", "tree": {"sha": "e9191d306e19647b195bc68ff0ae76fe51b250bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9191d306e19647b195bc68ff0ae76fe51b250bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb/comments", "author": null, "committer": null, "parents": [{"sha": "bebcd931d719100321ae18b9890ad9ea39cd00eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebcd931d719100321ae18b9890ad9ea39cd00eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bebcd931d719100321ae18b9890ad9ea39cd00eb"}], "stats": {"total": 80, "additions": 76, "deletions": 4}, "files": [{"sha": "8b196b5e3ecfded1f355adf111954bf5a4899b6d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb", "patch": "@@ -1,5 +1,7 @@\n 2005-05-04  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n+\t* java/awt/image/BufferStrategy.java: Document.\n+\n \t* java/awt/BufferCapabilities.java: Document.\n \n 2005-05-04  Tom Tromey  <tromey@redhat.com>"}, {"sha": "d0e74c0795e5630c3119e27ba293a333acbaaf23", "filename": "libjava/java/awt/image/BufferStrategy.java", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb/libjava%2Fjava%2Fawt%2Fimage%2FBufferStrategy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb/libjava%2Fjava%2Fawt%2Fimage%2FBufferStrategy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FBufferStrategy.java?ref=ff6d54b3cd2d90fcb88c9faf45d544dad6716eeb", "patch": "@@ -1,5 +1,5 @@\n-/* BufferStrategy.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* BufferStrategy.java -- describes image buffering resources\n+   Copyright (C) 2002, 2005 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,15 +41,85 @@\n import java.awt.BufferCapabilities;\n import java.awt.Graphics;\n \n-/** STUBS ONLY */\n+/**\n+ * This class describes a strategy for managing image buffering\n+ * resources on a Canvas or Window.  A given buffer strategy may make\n+ * use of hardware acceleration or take advantage of features of the\n+ * native graphics system.  Examples of buffering strategies are\n+ * double or triple buffering using either flipping or blitting.  For\n+ * the details of these algorithms see BufferCapabilities.\n+ *\n+ * To use a buffer strategy, you retrieve it from either the current\n+ * GraphicsConfiguration or from the Component on which you'd like to\n+ * draw.  Then you can query the strategy's capabilities to make sure\n+ * they're suitable.\n+ *\n+ * If the strategy's capabilities are suitable, you can obtain a\n+ * graphics object and use it to draw with this strategy.  Drawing\n+ * with a buffer strategy requires extra care, however.  You'll need\n+ * to manually cause the next buffer to be shown on the output device.\n+ * And since buffer strategies are usually implemented with a\n+ * VolatileImage, you must frequently check that the contents of the\n+ * buffer are valid and that the buffer still exists.\n+ *\n+ * A buffer strategy is usually implemented using a VolatileImage.\n+ *\n+ * @see VolatileImage\n+ * @since 1.4\n+ */\n public abstract class BufferStrategy\n {\n+  /**\n+   * Creates a new buffer strategy.\n+   */\n   public BufferStrategy()\n   {\n   }\n+\n+  /**\n+   * Retrieves the capabilities of this buffer strategy.\n+   *\n+   * @return this buffer strategy's capabilities\n+   */\n   public abstract BufferCapabilities getCapabilities();\n+\n+  /**\n+   * Retrieves a graphics object that can be used to draw using this\n+   * buffer strategy.  This method may not be synchronized so be\n+   * careful when calling it from multiple threads.  You also must\n+   * manually dispose of this graphics object.\n+   *\n+   * @return a graphics object that can be used to draw using this\n+   * buffer strategy\n+   */\n   public abstract Graphics getDrawGraphics();\n+\n+  /**\n+   * Returns whether or not the buffer's resources have been reclaimed\n+   * by the native graphics system since the last call to\n+   * getDrawGraphics.  If the buffer resources have been lost then\n+   * you'll need to obtain new resources before drawing again.  For\n+   * details, see the documentation for VolatileImage.\n+   *\n+   * @return true if the contents were lost since the last call to\n+   * getDrawGraphics, false otherwise\n+   */\n   public abstract boolean contentsLost();\n+\n+  /**\n+   * Returns whether or not the buffer's resources were re-created and\n+   * cleared to the default background color since the last call to\n+   * getDrawGraphics.  If the buffer's resources have recently been\n+   * re-created and initialized then the buffer's image may need to be\n+   * re-rendered.  For details, see the documentation for\n+   * VolatileImage.\n+   */\n   public abstract boolean contentsRestored();\n+\n+  /**\n+   * Applies this buffer strategy.  In other words, this method brings\n+   * the contents of the back or intermediate buffers to the front\n+   * buffer.\n+   */\n   public abstract void show();\n-} // class BufferStrategy\n+}"}]}