{"sha": "3095f651230f042648ac9c5d6008e8ea9d37567d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA5NWY2NTEyMzBmMDQyNjQ4YWM5YzVkNjAwOGU4ZWE5ZDM3NTY3ZA==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.vnet.ibm.com", "date": "2017-01-30T23:24:24Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2017-01-30T23:24:24Z"}, "message": "re PR target/79170 (memcmp builtin expansion sequence can overflow)\n\n2017-01-27  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\n\tPR target/79170\n\t* gcc.dg/memcmp-1.c: Improved to catch failures seen in PR 79170.\n\n2017-01-27  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\n\tPR target/79170\n\t* config/rs6000/altivec.md (*setb_internal): Rename to setb_signed.\n\t(setb_unsigned) New pattern for setb with CCUNS.\n\t* config/rs6000/rs6000.c (expand_block_compare): Use a different\n\tsubfc./subfe sequence to avoid overflow problems.  Generate a\n\tshorter sequence with cmpld/setb for power9.\n\t* config/rs6000/rs6000.md (subf<mode>3_carry_dot2): Add a new pattern\n\tfor generating subfc. instruction.\n\t(cmpstrsi): Add TARGET_POPCNTD predicate as the generate sequence\n\tnow uses this instruction.\n\nFrom-SVN: r245041", "tree": {"sha": "768dde0a441d3baf7051f92989e9d3b323e4cd0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/768dde0a441d3baf7051f92989e9d3b323e4cd0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3095f651230f042648ac9c5d6008e8ea9d37567d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3095f651230f042648ac9c5d6008e8ea9d37567d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3095f651230f042648ac9c5d6008e8ea9d37567d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3095f651230f042648ac9c5d6008e8ea9d37567d/comments", "author": null, "committer": null, "parents": [{"sha": "8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94"}], "stats": {"total": 984, "additions": 592, "deletions": 392}, "files": [{"sha": "64ef77decda28e2ff5d0469ccbb2d1d77e20731a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3095f651230f042648ac9c5d6008e8ea9d37567d", "patch": "@@ -1,3 +1,16 @@\n+2017-01-30  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\n+\tPR target/79170\n+\t* config/rs6000/altivec.md (*setb_internal): Rename to setb_signed.\n+\t(setb_unsigned) New pattern for setb with CCUNS.\n+\t* config/rs6000/rs6000.c (expand_block_compare): Use a different\n+\tsubfc./subfe sequence to avoid overflow problems.  Generate a\n+\tshorter sequence with cmpld/setb for power9.\n+\t* config/rs6000/rs6000.md (subf<mode>3_carry_dot2): Add a new pattern\n+\tfor generating subfc. instruction.\n+\t(cmpstrsi): Add TARGET_POPCNTD predicate as the generate sequence\n+\tnow uses this instruction.\n+\n 2017-01-30  Ian Lance Taylor  <iant@google.com>\n \n \tPR debug/79289"}, {"sha": "3a659b0b86c7e2bd9bf19f8d8faa1d872a5e6191", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=3095f651230f042648ac9c5d6008e8ea9d37567d", "patch": "@@ -3838,7 +3838,7 @@\n ;; Otherwise, set operand 0 to 0.  Note that the result stored into\n ;; register operand 0 is non-zero iff either the LT or GT bits are on\n ;; within condition register operand 1.\n-(define_insn \"*setb_internal\"\n+(define_insn \"setb_signed\"\n    [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t (if_then_else:SI (lt (match_operand:CC 1 \"cc_reg_operand\" \"y\")\n \t\t\t      (const_int 0))\n@@ -3851,6 +3851,19 @@\n   \"setb %0,%1\"\n   [(set_attr \"type\" \"logical\")])\n \n+(define_insn \"setb_unsigned\"\n+   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t (if_then_else:SI (ltu (match_operand:CCUNS 1 \"cc_reg_operand\" \"y\")\n+\t\t\t      (const_int 0))\n+\t\t\t  (const_int -1)\n+\t\t\t  (if_then_else (gtu (match_dup 1)\n+\t\t\t\t\t    (const_int 0))\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+  \"setb %0,%1\"\n+  [(set_attr \"type\" \"logical\")])\n+\n ;; Test byte within two ranges.\n ;;\n ;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx"}, {"sha": "5ea59a439f5c8a6c246f0d5e995c7bba7ca015ff", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 136, "deletions": 59, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3095f651230f042648ac9c5d6008e8ea9d37567d", "patch": "@@ -17292,7 +17292,7 @@ rs6000_init_builtins (void)\n   TYPE_NAME (V16QI_type_node) = tdecl;\n \n   tdecl = add_builtin_type (\"__vector __bool char\", bool_V16QI_type_node);\n-  TYPE_NAME ( bool_V16QI_type_node) = tdecl;\n+  TYPE_NAME (bool_V16QI_type_node) = tdecl;\n \n   tdecl = add_builtin_type (\"__vector unsigned short\", unsigned_V8HI_type_node);\n   TYPE_NAME (unsigned_V8HI_type_node) = tdecl;\n@@ -19458,24 +19458,31 @@ expand_block_compare (rtx operands[])\n   rtx src1 = orig_src1;\n   rtx src2 = orig_src2;\n \n-  /* If this is not a fixed size compare, just call memcmp */\n+  /* This case is complicated to handle because the subtract\n+     with carry instructions do not generate the 64-bit\n+     carry and so we must emit code to calculate it ourselves.\n+     We choose not to implement this yet.  */\n+  if (TARGET_32BIT && TARGET_POWERPC64)\n+    return false;\n+\n+  /* If this is not a fixed size compare, just call memcmp.  */\n   if (!CONST_INT_P (bytes_rtx))\n     return false;\n \n-  /* This must be a fixed size alignment */\n+  /* This must be a fixed size alignment.  */\n   if (!CONST_INT_P (align_rtx))\n     return false;\n \n   unsigned int base_align = UINTVAL (align_rtx) / BITS_PER_UNIT;\n \n-  /* SLOW_UNALIGNED_ACCESS -- don't do unaligned stuff */\n+  /* SLOW_UNALIGNED_ACCESS -- don't do unaligned stuff.  */\n   if (SLOW_UNALIGNED_ACCESS (word_mode, MEM_ALIGN (orig_src1))\n       || SLOW_UNALIGNED_ACCESS (word_mode, MEM_ALIGN (orig_src2)))\n     return false;\n \n   gcc_assert (GET_MODE (target) == SImode);\n \n-  /* Anything to move? */\n+  /* Anything to move?  */\n   unsigned HOST_WIDE_INT bytes = UINTVAL (bytes_rtx);\n   if (bytes == 0)\n     return true;\n@@ -19490,6 +19497,13 @@ expand_block_compare (rtx operands[])\n \n   rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n   rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n+  /* P7/P8 code uses cond for subfc. but P9 uses\n+     it for cmpld which needs CCUNSmode. */\n+  rtx cond;\n+  if (TARGET_P9_MISC)\n+    cond = gen_reg_rtx (CCUNSmode);\n+  else\n+    cond = gen_reg_rtx (CCmode);\n \n   /* If we have an LE target without ldbrx and word_mode is DImode,\n      then we must avoid using word_mode.  */\n@@ -19512,27 +19526,35 @@ expand_block_compare (rtx operands[])\n   rtx convert_label = NULL;\n   rtx final_label = NULL;\n \n-  /* Example of generated code for 11 bytes aligned 1 byte:\n-     .L10:\n-             ldbrx 10,6,9\n-             ldbrx 9,7,9\n-             subf. 9,9,10\n-             bne 0,.L8\n-             addi 9,4,7\n-             lwbrx 10,0,9\n-             addi 9,5,7\n-             lwbrx 9,0,9\n+  /* Example of generated code for 18 bytes aligned 1 byte.\n+     Compiled with -fno-reorder-blocks for clarity.\n+             ldbrx 10,31,8\n+             ldbrx 9,7,8\n+             subfc. 9,9,10\n+             bne 0,.L6487\n+             addi 9,12,8\n+             addi 5,11,8\n+             ldbrx 10,0,9\n+             ldbrx 9,0,5\n+             subfc. 9,9,10\n+             bne 0,.L6487\n+             addi 9,12,16\n+             lhbrx 10,0,9\n+             addi 9,11,16\n+             lhbrx 9,0,9\n              subf 9,9,10\n-             b .L9\n-     .L8: # convert_label\n-             cntlzd 9,9\n-             addi 9,9,-1\n-             xori 9,9,0x3f\n-     .L9: # final_label\n-\n-     We start off with DImode and have a compare/branch to something\n-     with a smaller mode then we will need a block with the DI->SI conversion\n-     that may or may not be executed.  */\n+             b .L6488\n+             .p2align 4,,15\n+     .L6487: #convert_label\n+             popcntd 9,9\n+             subfe 10,10,10\n+             or 9,9,10\n+     .L6488: #final_label\n+             extsw 10,9\n+\n+     We start off with DImode for two blocks that jump to the DI->SI conversion\n+     if the difference is found there, then a final block of HImode that skips\n+     the DI->SI conversion.  */\n \n   while (bytes > 0)\n     {\n@@ -19600,38 +19622,31 @@ expand_block_compare (rtx operands[])\n \t    }\n \t}\n \n-      /* We previously did a block that need 64->32 conversion but\n-\t the current block does not, so a label is needed to jump\n-\t to the end.  */\n-      if (generate_6432_conversion && !final_label\n-\t  && GET_MODE_SIZE (GET_MODE (target)) >= load_mode_size)\n-\tfinal_label = gen_label_rtx ();\n-\n-      /* Do we need a 64->32 conversion block?  */\n       int remain = bytes - cmp_bytes;\n-      if (GET_MODE_SIZE (GET_MODE (target)) < GET_MODE_SIZE (load_mode))\n-\t{\n-\t  generate_6432_conversion = true;\n-\t  if (remain > 0 && !convert_label)\n-\t    convert_label = gen_label_rtx ();\n-\t}\n-\n-      if (GET_MODE_SIZE (GET_MODE (target)) >= GET_MODE_SIZE (load_mode))\n+      if (GET_MODE_SIZE (GET_MODE (target)) > GET_MODE_SIZE (load_mode))\n \t{\n \t  /* Target is larger than load size so we don't need to\n \t     reduce result size.  */\n+\n+\t  /* We previously did a block that need 64->32 conversion but\n+\t     the current block does not, so a label is needed to jump\n+\t     to the end.  */\n+\t  if (generate_6432_conversion && !final_label)\n+\t    final_label = gen_label_rtx ();\n+\n \t  if (remain > 0)\n \t    {\n \t      /* This is not the last block, branch to the end if the result\n \t\t of this subtract is not zero.  */\n \t      if (!final_label)\n \t\tfinal_label = gen_label_rtx ();\n \t      rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n-\t      rtx cond = gen_reg_rtx (CCmode);\n \t      rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n-\t      rs6000_emit_dot_insn (tmp_reg_src2, tmp, 2, cond);\n-\t      emit_insn (gen_movsi (target, gen_lowpart (SImode, tmp_reg_src2)));\n-\t      rtx ne_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+\t      rtx cr = gen_reg_rtx (CCmode);\n+\t      rs6000_emit_dot_insn (tmp_reg_src2, tmp, 2, cr);\n+\t      emit_insn (gen_movsi (target,\n+\t\t\t\t    gen_lowpart (SImode, tmp_reg_src2)));\n+\t      rtx ne_rtx = gen_rtx_NE (VOIDmode, cr, const0_rtx);\n \t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, ne_rtx,\n \t\t\t\t\t\t fin_ref, pc_rtx);\n \t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n@@ -19662,17 +19677,34 @@ expand_block_compare (rtx operands[])\n \t}\n       else\n \t{\n+\t  /* Do we need a 64->32 conversion block? We need the 64->32\n+\t     conversion even if target size == load_mode size because\n+\t     the subtract generates one extra bit.  */\n \t  generate_6432_conversion = true;\n+\n \t  if (remain > 0)\n \t    {\n \t      if (!convert_label)\n \t\tconvert_label = gen_label_rtx ();\n \n \t      /* Compare to zero and branch to convert_label if not zero.  */\n \t      rtx cvt_ref = gen_rtx_LABEL_REF (VOIDmode, convert_label);\n-\t      rtx cond = gen_reg_rtx (CCmode);\n-\t      rtx tmp = gen_rtx_MINUS (DImode, tmp_reg_src1, tmp_reg_src2);\n-\t      rs6000_emit_dot_insn (tmp_reg_src2, tmp, 2, cond);\n+\t      if (TARGET_P9_MISC)\n+\t\t{\n+\t\t/* Generate a compare, and convert with a setb later.  */\n+\t\t  rtx cmp = gen_rtx_COMPARE (CCUNSmode, tmp_reg_src1,\n+\t\t\t\t\t     tmp_reg_src2);\n+\t\t  emit_insn (gen_rtx_SET (cond, cmp));\n+\t\t}\n+\t      else\n+\t\t/* Generate a subfc. and use the longer\n+\t\t   sequence for conversion.  */\n+\t\tif (TARGET_64BIT)\n+\t\t  emit_insn (gen_subfdi3_carry_dot2 (tmp_reg_src2, tmp_reg_src2,\n+\t\t\t\t\t\t     tmp_reg_src1, cond));\n+\t\telse\n+\t\t  emit_insn (gen_subfsi3_carry_dot2 (tmp_reg_src2, tmp_reg_src2,\n+\t\t\t\t\t\t     tmp_reg_src1, cond));\n \t      rtx ne_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n \t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, ne_rtx,\n \t\t\t\t\t\t cvt_ref, pc_rtx);\n@@ -19682,10 +19714,21 @@ expand_block_compare (rtx operands[])\n \t    }\n \t  else\n \t    {\n-\t      /* Just do the subtract.  Since this is the last block the\n-\t\t convert code will be generated immediately following.  */\n-\t      emit_insn (gen_subdi3 (tmp_reg_src2, tmp_reg_src1,\n-\t\t\t\t     tmp_reg_src2));\n+\t      /* Just do the subtract/compare.  Since this is the last block\n+\t\t the convert code will be generated immediately following.  */\n+\t      if (TARGET_P9_MISC)\n+\t\t{\n+\t\t  rtx cmp = gen_rtx_COMPARE (CCUNSmode, tmp_reg_src1,\n+\t\t\t\t\t     tmp_reg_src2);\n+\t\t  emit_insn (gen_rtx_SET (cond, cmp));\n+\t\t}\n+\t      else\n+\t\tif (TARGET_64BIT)\n+\t\t  emit_insn (gen_subfdi3_carry (tmp_reg_src2, tmp_reg_src2,\n+\t\t\t\t\t\ttmp_reg_src1));\n+\t\telse\n+\t\t  emit_insn (gen_subfsi3_carry (tmp_reg_src2, tmp_reg_src2,\n+\t\t\t\t\t\ttmp_reg_src1));\n \t    }\n \t}\n \n@@ -19699,12 +19742,46 @@ expand_block_compare (rtx operands[])\n \temit_label (convert_label);\n \n       /* We need to produce DI result from sub, then convert to target SI\n-\t while maintaining <0 / ==0 / >0 properties.\n-\t Segher's sequence: cntlzd 3,3 ; addi 3,3,-1 ; xori 3,3,63 */\n-      emit_insn (gen_clzdi2 (tmp_reg_src2, tmp_reg_src2));\n-      emit_insn (gen_adddi3 (tmp_reg_src2, tmp_reg_src2, GEN_INT (-1)));\n-      emit_insn (gen_xordi3 (tmp_reg_src2, tmp_reg_src2, GEN_INT (63)));\n-      emit_insn (gen_movsi (target, gen_lowpart (SImode, tmp_reg_src2)));\n+\t while maintaining <0 / ==0 / >0 properties. This sequence works:\n+\t subfc L,A,B\n+\t subfe H,H,H\n+\t popcntd L,L\n+\t rldimi L,H,6,0\n+\n+\t This is an alternate one Segher cooked up if somebody\n+\t wants to expand this for something that doesn't have popcntd:\n+\t subfc L,a,b\n+\t subfe H,x,x\n+\t addic t,L,-1\n+\t subfe v,t,L\n+\t or z,v,H\n+\n+\t And finally, p9 can just do this:\n+\t cmpld A,B\n+\t setb r */\n+\n+      if (TARGET_P9_MISC)\n+\t{\n+\t  emit_insn (gen_setb_unsigned (target, cond));\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      rtx tmp_reg_ca = gen_reg_rtx (DImode);\n+\t      emit_insn (gen_subfdi3_carry_in_xx (tmp_reg_ca));\n+\t      emit_insn (gen_popcntddi2 (tmp_reg_src2, tmp_reg_src2));\n+\t      emit_insn (gen_iordi3 (tmp_reg_src2, tmp_reg_src2, tmp_reg_ca));\n+\t      emit_insn (gen_movsi (target, gen_lowpart (SImode, tmp_reg_src2)));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp_reg_ca = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_subfsi3_carry_in_xx (tmp_reg_ca));\n+\t      emit_insn (gen_popcntdsi2 (tmp_reg_src2, tmp_reg_src2));\n+\t      emit_insn (gen_iorsi3 (target, tmp_reg_src2, tmp_reg_ca));\n+\t    }\n+\t}\n     }\n \n   if (final_label)\n@@ -21246,7 +21323,7 @@ register_to_reg_type (rtx reg, bool *is_altivec)\n       regno = true_regnum (reg);\n       if (regno < 0 || regno >= FIRST_PSEUDO_REGISTER)\n \treturn PSEUDO_REG_TYPE;\n-    }\t\n+    }\n \n   gcc_assert (regno >= 0);\n "}, {"sha": "61759949725ff5d21e91cab4f03cb6f6e8e702e8", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=3095f651230f042648ac9c5d6008e8ea9d37567d", "patch": "@@ -2068,6 +2068,35 @@\n   \"subfic %0,%1,%2\"\n   [(set_attr \"type\" \"add\")])\n \n+(define_insn_and_split \"subf<mode>3_carry_dot2\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (minus:P (match_operand:P 2 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t       (match_operand:P 1 \"gpc_reg_operand\" \"r,r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(minus:P (match_dup 2)\n+\t\t   (match_dup 1)))\n+   (set (reg:P CA_REGNO)\n+\t(leu:P (match_dup 1)\n+\t       (match_dup 2)))]\n+  \"<MODE>mode == Pmode\"\n+  \"@\n+   subfc. %0,%1,%2\n+   #\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(parallel [(set (match_dup 0)\n+                   (minus:P (match_dup 2)\n+                            (match_dup 1)))\n+              (set (reg:P CA_REGNO)\n+                   (leu:P (match_dup 1)\n+                          (match_dup 2)))])\n+   (set (match_dup 3)\n+        (compare:CC (match_dup 0)\n+                    (const_int 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"add\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8\")])\n \n (define_insn \"subf<mode>3_carry\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n@@ -9146,11 +9175,11 @@\n                            (match_operand:BLK 2)))\n \t      (use (match_operand:SI 3))\n \t      (use (match_operand:SI 4))])]\n-  \"\"\n+  \"TARGET_POPCNTD\"\n {\n   if (expand_block_compare (operands))\n     DONE;\n-  else\t\n+  else\n     FAIL;\n })\n "}, {"sha": "67800b1104f2ba7e181faa97e3b77ecf2b1a1a5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3095f651230f042648ac9c5d6008e8ea9d37567d", "patch": "@@ -1,3 +1,8 @@\n+2017-01-30  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\n+\tPR target/79170\n+\t* gcc.dg/memcmp-1.c: Improved to catch failures seen in PR 79170.\n+\n 2017-01-30  Martin Sebor  <msebor@redhat.com>\n \n \tPR testsuite/79293"}, {"sha": "b4fd780fdd0d6cde5d0aad3b7ed7a97ee4349388", "filename": "gcc/testsuite/gcc.dg/memcmp-1.c", "status": "modified", "additions": 393, "deletions": 330, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3095f651230f042648ac9c5d6008e8ea9d37567d/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c?ref=3095f651230f042648ac9c5d6008e8ea9d37567d", "patch": "@@ -1,58 +1,124 @@\n-/* Test memcmp builtin expansion for compilation and proper execution.  */\n+/* Test memcmp/strncmp builtin expansion for compilation and proper execution.  */\n /* { dg-do run } */\n /* { dg-options \"-O2\" } */\n /* { dg-require-effective-target ptr32plus } */\n \n #include <stdio.h>\n-#include <string.h>\n #include <stdlib.h>\n+#include <string.h>\n+#include <stdint.h>\n+\n+int lib_memcmp(const void *a, const void *b, size_t n) asm(\"memcmp\");\n+int lib_strncmp(const char *a, const char *b, size_t n) asm(\"strncmp\");\n+\n+#ifndef NRAND\n+#define NRAND 10000\n+#endif\n+#define MAX_SZ 200\n \n-#define RUN_TEST(SZ, ALIGN) test_memcmp_ ## SZ ## _ ## ALIGN ()\n+static void test_driver_memcmp (void (test_memcmp)(const char *, const char *, int),\n+\t\t\t\tvoid (test_strncmp)(const char *, const char *, int),\n+\t\t\t\tsize_t sz, int align)\n+{\n+  char buf1[MAX_SZ*2+10],buf2[MAX_SZ*2+10];\n+  size_t test_sz = (sz<MAX_SZ)?sz:MAX_SZ;\n+  size_t diff_pos, zero_pos;\n+  uint32_t e;\n+  int i,j,l;\n+  for(l=0;l<sz;l++) {\n+    for(i=0;i<NRAND/sz;i++) {\n+      for(j=0;j<l;j++) {\n+\tbuf1[j] = random() & 0xff;\n+\tbuf2[j] = buf1[j];\n+      }\n+      for(j=l;j<sz;j++) {\n+\tbuf1[j] = random() & 0xff;\n+\tbuf2[j] = random() & 0xff;\n+      }\n+    }\n+    e = lib_memcmp(buf1,buf2,sz);\n+    (*test_memcmp)(buf1,buf2,e);\n+    e = lib_strncmp(buf1,buf2,sz);\n+    (*test_strncmp)(buf1,buf2,e);\n+  }\n+  for(diff_pos = ((test_sz>10)?(test_sz-10):0); diff_pos < test_sz+10; diff_pos++)\n+    for(zero_pos = ((test_sz>10)?(test_sz-10):0); zero_pos < test_sz+10; zero_pos++)\n+      {\n+\tmemset(buf1, 'A', 2*test_sz);\n+\tmemset(buf2, 'A', 2*test_sz);\n+\tbuf2[diff_pos] = 'B';\n+\tbuf1[zero_pos] = 0;\n+\tbuf2[zero_pos] = 0;\n+\te = lib_memcmp(buf1,buf2,sz);\n+\t(*test_memcmp)(buf1,buf2,e);\n+\t(*test_memcmp)(buf2,buf1,-e);\n+\t(*test_memcmp)(buf2,buf2,0);\n+\te = lib_strncmp(buf1,buf2,sz);\n+\t(*test_strncmp)(buf1,buf2,e);\n+\t(*test_strncmp)(buf2,buf1,-e);\n+\t(*test_strncmp)(buf2,buf2,0);\n+\t/* differing length: */\n+\tbuf2[diff_pos] = 0;\n+\te = lib_memcmp(buf1,buf2,sz);\n+\t(*test_memcmp)(buf1,buf2,e);\n+\te = lib_strncmp(buf1,buf2,sz);\n+\t(*test_strncmp)(buf1,buf2,e);\n+\tmemset(buf2+diff_pos,'B',sizeof(buf2)-diff_pos);\n+\tbuf2[zero_pos] = 0;\n+\te = lib_memcmp(buf1,buf2,sz);\n+\t(*test_memcmp)(buf1,buf2,e);\n+\t(*test_memcmp)(buf2,buf1,-e);\n+\te = lib_strncmp(buf1,buf2,sz);\n+\t(*test_strncmp)(buf1,buf2,e);\n+\t(*test_strncmp)(buf2,buf1,-e);\n+      }\n+}\n \n-#define DEF_TEST(SZ, ALIGN)                                                \\\n-static void test_memcmp_ ## SZ ## _ ## ALIGN (void) {                      \\\n-  char one[3 * (SZ > 10 ? SZ : 10)];  \t\t\t\t   \t   \\\n-  char two[3 * (SZ > 10 ? SZ : 10)];\t\t\t\t   \t   \\\n-  int i,j;\t\t\t\t\t\t\t\t   \\\n-  for (i = 0 ; i < SZ ; i++)\t\t\t   \t\t           \\\n-    {\t\t\t\t\t\t\t   \t\t   \\\n-      int r1;\t\t\t\t\t\t\t\t   \\\n-      char *a = one + (i & 1) * ALIGN;\t\t\t   \t\t   \\\n-      char *b = two + (i & 1) * ALIGN;\t\t\t   \t\t   \\\n-      memset (a, '-', SZ);\t\t\t\t\t   \t   \\\n-      memset (b, '-', SZ);\t\t\t\t\t   \t   \\\n-      a[i] = '1';\t\t\t\t\t   \t\t   \\\n-      b[i] = '2';\t\t\t\t\t   \t\t   \\\n-      a[SZ] = 0;\t\t\t\t\t\t\t   \\\n-      b[SZ] = 0;\t\t\t\t\t   \t\t   \\\n-      if (!((r1 = memcmp (b, a, SZ)) > 0))   \t\t   \t\t   \\\n-        {\t\t\t\t\t\t\t\t   \\\n-\t  abort ();\t\t\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-      if (!((r1 = memcmp (a, b, SZ)) < 0))\t\t\t   \t   \\\n-        {\t\t\t\t\t\t\t\t   \\\n-\t  abort ();\t\t\t\t\t\t\t   \\\n-\t}                            \t\t\t\t\t   \\\n-      b[i] = '1';\t\t\t\t\t   \t\t   \\\n-      if (!((r1 = memcmp (a, b, SZ)) == 0))\t\t   \t\t   \\\n-        {\t\t\t\t\t\t\t\t   \\\n-\t  abort ();\t\t\t\t\t\t\t   \\\n-\t}                            \t\t\t\t\t   \\\n-      for(j = i; j < SZ ; j++)\t\t\t   \t\t           \\\n-\t{\t\t\t\t\t\t   \t\t   \\\n-\t  a[j] = '1';            \t\t\t   \t\t   \\\n-\t  b[j] = '2';\t\t\t                   \t\t   \\\n-\t}\t\t\t\t\t\t   \t\t   \\\n-      if (!((r1 = memcmp (b, a, SZ)) > 0))\t\t\t   \t   \\\n-        {\t\t\t\t\t\t\t\t   \\\n-\t  abort ();\t\t\t\t\t\t\t   \\\n-\t}             \t\t\t\t\t\t\t   \\\n-      if (!((r1 = memcmp (a, b, SZ)) < 0))\t\t\t   \t   \\\n-        {\t\t\t\t\t\t\t\t   \\\n-\t  abort ();\t\t\t\t\t\t\t   \\\n-\t}\t           \t\t\t\t\t\t   \\\n-    }\t\t\t\t\t\t\t                   \\\n-}                                                                \n+#define RUN_TEST(SZ, ALIGN) test_driver_memcmp (test_memcmp_ ## SZ ## _ ## ALIGN, test_strncmp_ ## SZ ## _ ## ALIGN, SZ, ALIGN);\n+\n+#define DEF_TEST(SZ, ALIGN)\t\t\t\t\t\t\\\n+  static void test_memcmp_ ## SZ ## _ ## ALIGN (const char *str1, const char *str2, int expect)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  char three[8192] __attribute__ ((aligned (4096)));\t\t\t\\\n+  char four[8192] __attribute__ ((aligned (4096)));\t\t\t\\\n+  char *a, *b;\t\t\t\t\t\t\t\t\\\n+  int i,j,r;\t\t\t\t\t\t\t\t\\\n+  for (j = 0; j < 2; j++)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      for (i = 0; i < 2; i++)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  a = three+i*ALIGN+j*(4096-2*i*ALIGN);\t\t\t\t\\\n+\t  b = four+i*ALIGN+j*(4096-2*i*ALIGN);\t\t\t\t\\\n+\t  memcpy(a,str1,SZ);\t\t\t\t\t\t\\\n+\t  memcpy(b,str2,SZ);\t\t\t\t\t\t\\\n+\t  r = memcmp(a,b,SZ);\t\t\t\t\t\t\\\n+\t  if ( r < 0 && !(expect < 0) ) abort();\t\t\t\\\n+\t  if ( r > 0 && !(expect > 0) )\tabort();\t\t\t\\\n+\t  if ( r == 0 && !(expect == 0) ) abort();\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+static void test_strncmp_ ## SZ ## _ ## ALIGN (const char *str1, const char *str2, int expect)\t \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  char three[8192] __attribute__ ((aligned (4096)));\t\t\t\\\n+  char four[8192] __attribute__ ((aligned (4096)));\t\t\t\\\n+  char *a, *b;\t\t\t\t\t\t\t\t\\\n+  int i,j,r;\t\t\t\t\t\t\t\t\\\n+  for (j = 0; j < 2; j++)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      for (i = 0; i < 2; i++)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  a = three+i*ALIGN+j*(4096-2*i*ALIGN);\t\t\t\t\\\n+\t  b = four+i*ALIGN+j*(4096-2*i*ALIGN);\t\t\t\t\\\n+\t  strcpy(a,str1);\t\t\t\t\t\t\\\n+\t  strcpy(b,str2);\t\t\t\t\t\t\\\n+\t  r = strncmp(a,b,SZ);\t\t\t\t\t\t\\\n+\t  if ( r < 0 && !(expect < 0) ) abort();\t\t\t\\\n+\t  if ( r > 0 && !(expect > 0) )\tabort();\t\t\t\\\n+\t  if ( r == 0 && !(expect == 0) ) abort();\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n \n #ifdef TEST_ALL\n DEF_TEST(1,1)\n@@ -300,305 +366,302 @@ DEF_TEST(49,2)\n DEF_TEST(49,4)\n DEF_TEST(49,8)\n DEF_TEST(49,16)\n+DEF_TEST(100,1)\n+DEF_TEST(100,2)\n+DEF_TEST(100,4)\n+DEF_TEST(100,8)\n+DEF_TEST(100,16)\n #else\n DEF_TEST(3,1)\n DEF_TEST(4,1)\n-DEF_TEST(4,2)\n-DEF_TEST(4,4)\n DEF_TEST(5,1)\n+DEF_TEST(5,8)\n DEF_TEST(6,1)\n+DEF_TEST(6,4)\n+DEF_TEST(6,8)\n DEF_TEST(7,1)\n+DEF_TEST(7,2)\n+DEF_TEST(7,4)\n+DEF_TEST(7,8)\n DEF_TEST(8,1)\n-DEF_TEST(8,2)\n-DEF_TEST(8,4)\n-DEF_TEST(8,8)\n DEF_TEST(9,1)\n DEF_TEST(16,1)\n-DEF_TEST(16,2)\n-DEF_TEST(16,4)\n-DEF_TEST(16,8)\n-DEF_TEST(16,16)\n DEF_TEST(32,1)\n-DEF_TEST(32,2)\n-DEF_TEST(32,4)\n-DEF_TEST(32,8)\n-DEF_TEST(32,16)\n+DEF_TEST(100,1)\n+DEF_TEST(100,8)\n #endif\n \n int\n main(int argc, char **argv)\n {\n-\n #ifdef TEST_ALL\n-  RUN_TEST(1,1);\n-  RUN_TEST(1,2);\n-  RUN_TEST(1,4);\n-  RUN_TEST(1,8);\n-  RUN_TEST(1,16);\n-  RUN_TEST(2,1);\n-  RUN_TEST(2,2);\n-  RUN_TEST(2,4);\n-  RUN_TEST(2,8);\n-  RUN_TEST(2,16);\n-  RUN_TEST(3,1);\n-  RUN_TEST(3,2);\n-  RUN_TEST(3,4);\n-  RUN_TEST(3,8);\n-  RUN_TEST(3,16);\n-  RUN_TEST(4,1);\n-  RUN_TEST(4,2);\n-  RUN_TEST(4,4);\n-  RUN_TEST(4,8);\n-  RUN_TEST(4,16);\n-  RUN_TEST(5,1);\n-  RUN_TEST(5,2);\n-  RUN_TEST(5,4);\n-  RUN_TEST(5,8);\n-  RUN_TEST(5,16);\n-  RUN_TEST(6,1);\n-  RUN_TEST(6,2);\n-  RUN_TEST(6,4);\n-  RUN_TEST(6,8);\n-  RUN_TEST(6,16);\n-  RUN_TEST(7,1);\n-  RUN_TEST(7,2);\n-  RUN_TEST(7,4);\n-  RUN_TEST(7,8);\n-  RUN_TEST(7,16);\n-  RUN_TEST(8,1);\n-  RUN_TEST(8,2);\n-  RUN_TEST(8,4);\n-  RUN_TEST(8,8);\n-  RUN_TEST(8,16);\n-  RUN_TEST(9,1);\n-  RUN_TEST(9,2);\n-  RUN_TEST(9,4);\n-  RUN_TEST(9,8);\n-  RUN_TEST(9,16);\n-  RUN_TEST(10,1);\n-  RUN_TEST(10,2);\n-  RUN_TEST(10,4);\n-  RUN_TEST(10,8);\n-  RUN_TEST(10,16);\n-  RUN_TEST(11,1);\n-  RUN_TEST(11,2);\n-  RUN_TEST(11,4);\n-  RUN_TEST(11,8);\n-  RUN_TEST(11,16);\n-  RUN_TEST(12,1);\n-  RUN_TEST(12,2);\n-  RUN_TEST(12,4);\n-  RUN_TEST(12,8);\n-  RUN_TEST(12,16);\n-  RUN_TEST(13,1);\n-  RUN_TEST(13,2);\n-  RUN_TEST(13,4);\n-  RUN_TEST(13,8);\n-  RUN_TEST(13,16);\n-  RUN_TEST(14,1);\n-  RUN_TEST(14,2);\n-  RUN_TEST(14,4);\n-  RUN_TEST(14,8);\n-  RUN_TEST(14,16);\n-  RUN_TEST(15,1);\n-  RUN_TEST(15,2);\n-  RUN_TEST(15,4);\n-  RUN_TEST(15,8);\n-  RUN_TEST(15,16);\n-  RUN_TEST(16,1);\n-  RUN_TEST(16,2);\n-  RUN_TEST(16,4);\n-  RUN_TEST(16,8);\n-  RUN_TEST(16,16);\n-  RUN_TEST(17,1);\n-  RUN_TEST(17,2);\n-  RUN_TEST(17,4);\n-  RUN_TEST(17,8);\n-  RUN_TEST(17,16);\n-  RUN_TEST(18,1);\n-  RUN_TEST(18,2);\n-  RUN_TEST(18,4);\n-  RUN_TEST(18,8);\n-  RUN_TEST(18,16);\n-  RUN_TEST(19,1);\n-  RUN_TEST(19,2);\n-  RUN_TEST(19,4);\n-  RUN_TEST(19,8);\n-  RUN_TEST(19,16);\n-  RUN_TEST(20,1);\n-  RUN_TEST(20,2);\n-  RUN_TEST(20,4);\n-  RUN_TEST(20,8);\n-  RUN_TEST(20,16);\n-  RUN_TEST(21,1);\n-  RUN_TEST(21,2);\n-  RUN_TEST(21,4);\n-  RUN_TEST(21,8);\n-  RUN_TEST(21,16);\n-  RUN_TEST(22,1);\n-  RUN_TEST(22,2);\n-  RUN_TEST(22,4);\n-  RUN_TEST(22,8);\n-  RUN_TEST(22,16);\n-  RUN_TEST(23,1);\n-  RUN_TEST(23,2);\n-  RUN_TEST(23,4);\n-  RUN_TEST(23,8);\n-  RUN_TEST(23,16);\n-  RUN_TEST(24,1);\n-  RUN_TEST(24,2);\n-  RUN_TEST(24,4);\n-  RUN_TEST(24,8);\n-  RUN_TEST(24,16);\n-  RUN_TEST(25,1);\n-  RUN_TEST(25,2);\n-  RUN_TEST(25,4);\n-  RUN_TEST(25,8);\n-  RUN_TEST(25,16);\n-  RUN_TEST(26,1);\n-  RUN_TEST(26,2);\n-  RUN_TEST(26,4);\n-  RUN_TEST(26,8);\n-  RUN_TEST(26,16);\n-  RUN_TEST(27,1);\n-  RUN_TEST(27,2);\n-  RUN_TEST(27,4);\n-  RUN_TEST(27,8);\n-  RUN_TEST(27,16);\n-  RUN_TEST(28,1);\n-  RUN_TEST(28,2);\n-  RUN_TEST(28,4);\n-  RUN_TEST(28,8);\n-  RUN_TEST(28,16);\n-  RUN_TEST(29,1);\n-  RUN_TEST(29,2);\n-  RUN_TEST(29,4);\n-  RUN_TEST(29,8);\n-  RUN_TEST(29,16);\n-  RUN_TEST(30,1);\n-  RUN_TEST(30,2);\n-  RUN_TEST(30,4);\n-  RUN_TEST(30,8);\n-  RUN_TEST(30,16);\n-  RUN_TEST(31,1);\n-  RUN_TEST(31,2);\n-  RUN_TEST(31,4);\n-  RUN_TEST(31,8);\n-  RUN_TEST(31,16);\n-  RUN_TEST(32,1);\n-  RUN_TEST(32,2);\n-  RUN_TEST(32,4);\n-  RUN_TEST(32,8);\n-  RUN_TEST(32,16);\n-  RUN_TEST(33,1);\n-  RUN_TEST(33,2);\n-  RUN_TEST(33,4);\n-  RUN_TEST(33,8);\n-  RUN_TEST(33,16);\n-  RUN_TEST(34,1);\n-  RUN_TEST(34,2);\n-  RUN_TEST(34,4);\n-  RUN_TEST(34,8);\n-  RUN_TEST(34,16);\n-  RUN_TEST(35,1);\n-  RUN_TEST(35,2);\n-  RUN_TEST(35,4);\n-  RUN_TEST(35,8);\n-  RUN_TEST(35,16);\n-  RUN_TEST(36,1);\n-  RUN_TEST(36,2);\n-  RUN_TEST(36,4);\n-  RUN_TEST(36,8);\n-  RUN_TEST(36,16);\n-  RUN_TEST(37,1);\n-  RUN_TEST(37,2);\n-  RUN_TEST(37,4);\n-  RUN_TEST(37,8);\n-  RUN_TEST(37,16);\n-  RUN_TEST(38,1);\n-  RUN_TEST(38,2);\n-  RUN_TEST(38,4);\n-  RUN_TEST(38,8);\n-  RUN_TEST(38,16);\n-  RUN_TEST(39,1);\n-  RUN_TEST(39,2);\n-  RUN_TEST(39,4);\n-  RUN_TEST(39,8);\n-  RUN_TEST(39,16);\n-  RUN_TEST(40,1);\n-  RUN_TEST(40,2);\n-  RUN_TEST(40,4);\n-  RUN_TEST(40,8);\n-  RUN_TEST(40,16);\n-  RUN_TEST(41,1);\n-  RUN_TEST(41,2);\n-  RUN_TEST(41,4);\n-  RUN_TEST(41,8);\n-  RUN_TEST(41,16);\n-  RUN_TEST(42,1);\n-  RUN_TEST(42,2);\n-  RUN_TEST(42,4);\n-  RUN_TEST(42,8);\n-  RUN_TEST(42,16);\n-  RUN_TEST(43,1);\n-  RUN_TEST(43,2);\n-  RUN_TEST(43,4);\n-  RUN_TEST(43,8);\n-  RUN_TEST(43,16);\n-  RUN_TEST(44,1);\n-  RUN_TEST(44,2);\n-  RUN_TEST(44,4);\n-  RUN_TEST(44,8);\n-  RUN_TEST(44,16);\n-  RUN_TEST(45,1);\n-  RUN_TEST(45,2);\n-  RUN_TEST(45,4);\n-  RUN_TEST(45,8);\n-  RUN_TEST(45,16);\n-  RUN_TEST(46,1);\n-  RUN_TEST(46,2);\n-  RUN_TEST(46,4);\n-  RUN_TEST(46,8);\n-  RUN_TEST(46,16);\n-  RUN_TEST(47,1);\n-  RUN_TEST(47,2);\n-  RUN_TEST(47,4);\n-  RUN_TEST(47,8);\n-  RUN_TEST(47,16);\n-  RUN_TEST(48,1);\n-  RUN_TEST(48,2);\n-  RUN_TEST(48,4);\n-  RUN_TEST(48,8);\n-  RUN_TEST(48,16);\n-  RUN_TEST(49,1);\n-  RUN_TEST(49,2);\n-  RUN_TEST(49,4);\n-  RUN_TEST(49,8);\n-  RUN_TEST(49,16);\n+  RUN_TEST(1,1)\n+    RUN_TEST(1,2)\n+    RUN_TEST(1,4)\n+    RUN_TEST(1,8)\n+    RUN_TEST(1,16)\n+    RUN_TEST(2,1)\n+    RUN_TEST(2,2)\n+    RUN_TEST(2,4)\n+    RUN_TEST(2,8)\n+    RUN_TEST(2,16)\n+    RUN_TEST(3,1)\n+    RUN_TEST(3,2)\n+    RUN_TEST(3,4)\n+    RUN_TEST(3,8)\n+    RUN_TEST(3,16)\n+    RUN_TEST(4,1)\n+    RUN_TEST(4,2)\n+    RUN_TEST(4,4)\n+    RUN_TEST(4,8)\n+    RUN_TEST(4,16)\n+    RUN_TEST(5,1)\n+    RUN_TEST(5,2)\n+    RUN_TEST(5,4)\n+    RUN_TEST(5,8)\n+    RUN_TEST(5,16)\n+    RUN_TEST(6,1)\n+    RUN_TEST(6,2)\n+    RUN_TEST(6,4)\n+    RUN_TEST(6,8)\n+    RUN_TEST(6,16)\n+    RUN_TEST(7,1)\n+    RUN_TEST(7,2)\n+    RUN_TEST(7,4)\n+    RUN_TEST(7,8)\n+    RUN_TEST(7,16)\n+    RUN_TEST(8,1)\n+    RUN_TEST(8,2)\n+    RUN_TEST(8,4)\n+    RUN_TEST(8,8)\n+    RUN_TEST(8,16)\n+    RUN_TEST(9,1)\n+    RUN_TEST(9,2)\n+    RUN_TEST(9,4)\n+    RUN_TEST(9,8)\n+    RUN_TEST(9,16)\n+    RUN_TEST(10,1)\n+    RUN_TEST(10,2)\n+    RUN_TEST(10,4)\n+    RUN_TEST(10,8)\n+    RUN_TEST(10,16)\n+    RUN_TEST(11,1)\n+    RUN_TEST(11,2)\n+    RUN_TEST(11,4)\n+    RUN_TEST(11,8)\n+    RUN_TEST(11,16)\n+    RUN_TEST(12,1)\n+    RUN_TEST(12,2)\n+    RUN_TEST(12,4)\n+    RUN_TEST(12,8)\n+    RUN_TEST(12,16)\n+    RUN_TEST(13,1)\n+    RUN_TEST(13,2)\n+    RUN_TEST(13,4)\n+    RUN_TEST(13,8)\n+    RUN_TEST(13,16)\n+    RUN_TEST(14,1)\n+    RUN_TEST(14,2)\n+    RUN_TEST(14,4)\n+    RUN_TEST(14,8)\n+    RUN_TEST(14,16)\n+    RUN_TEST(15,1)\n+    RUN_TEST(15,2)\n+    RUN_TEST(15,4)\n+    RUN_TEST(15,8)\n+    RUN_TEST(15,16)\n+    RUN_TEST(16,1)\n+    RUN_TEST(16,2)\n+    RUN_TEST(16,4)\n+    RUN_TEST(16,8)\n+    RUN_TEST(16,16)\n+    RUN_TEST(17,1)\n+    RUN_TEST(17,2)\n+    RUN_TEST(17,4)\n+    RUN_TEST(17,8)\n+    RUN_TEST(17,16)\n+    RUN_TEST(18,1)\n+    RUN_TEST(18,2)\n+    RUN_TEST(18,4)\n+    RUN_TEST(18,8)\n+    RUN_TEST(18,16)\n+    RUN_TEST(19,1)\n+    RUN_TEST(19,2)\n+    RUN_TEST(19,4)\n+    RUN_TEST(19,8)\n+    RUN_TEST(19,16)\n+    RUN_TEST(20,1)\n+    RUN_TEST(20,2)\n+    RUN_TEST(20,4)\n+    RUN_TEST(20,8)\n+    RUN_TEST(20,16)\n+    RUN_TEST(21,1)\n+    RUN_TEST(21,2)\n+    RUN_TEST(21,4)\n+    RUN_TEST(21,8)\n+    RUN_TEST(21,16)\n+    RUN_TEST(22,1)\n+    RUN_TEST(22,2)\n+    RUN_TEST(22,4)\n+    RUN_TEST(22,8)\n+    RUN_TEST(22,16)\n+    RUN_TEST(23,1)\n+    RUN_TEST(23,2)\n+    RUN_TEST(23,4)\n+    RUN_TEST(23,8)\n+    RUN_TEST(23,16)\n+    RUN_TEST(24,1)\n+    RUN_TEST(24,2)\n+    RUN_TEST(24,4)\n+    RUN_TEST(24,8)\n+    RUN_TEST(24,16)\n+    RUN_TEST(25,1)\n+    RUN_TEST(25,2)\n+    RUN_TEST(25,4)\n+    RUN_TEST(25,8)\n+    RUN_TEST(25,16)\n+    RUN_TEST(26,1)\n+    RUN_TEST(26,2)\n+    RUN_TEST(26,4)\n+    RUN_TEST(26,8)\n+    RUN_TEST(26,16)\n+    RUN_TEST(27,1)\n+    RUN_TEST(27,2)\n+    RUN_TEST(27,4)\n+    RUN_TEST(27,8)\n+    RUN_TEST(27,16)\n+    RUN_TEST(28,1)\n+    RUN_TEST(28,2)\n+    RUN_TEST(28,4)\n+    RUN_TEST(28,8)\n+    RUN_TEST(28,16)\n+    RUN_TEST(29,1)\n+    RUN_TEST(29,2)\n+    RUN_TEST(29,4)\n+    RUN_TEST(29,8)\n+    RUN_TEST(29,16)\n+    RUN_TEST(30,1)\n+    RUN_TEST(30,2)\n+    RUN_TEST(30,4)\n+    RUN_TEST(30,8)\n+    RUN_TEST(30,16)\n+    RUN_TEST(31,1)\n+    RUN_TEST(31,2)\n+    RUN_TEST(31,4)\n+    RUN_TEST(31,8)\n+    RUN_TEST(31,16)\n+    RUN_TEST(32,1)\n+    RUN_TEST(32,2)\n+    RUN_TEST(32,4)\n+    RUN_TEST(32,8)\n+    RUN_TEST(32,16)\n+    RUN_TEST(33,1)\n+    RUN_TEST(33,2)\n+    RUN_TEST(33,4)\n+    RUN_TEST(33,8)\n+    RUN_TEST(33,16)\n+    RUN_TEST(34,1)\n+    RUN_TEST(34,2)\n+    RUN_TEST(34,4)\n+    RUN_TEST(34,8)\n+    RUN_TEST(34,16)\n+    RUN_TEST(35,1)\n+    RUN_TEST(35,2)\n+    RUN_TEST(35,4)\n+    RUN_TEST(35,8)\n+    RUN_TEST(35,16)\n+    RUN_TEST(36,1)\n+    RUN_TEST(36,2)\n+    RUN_TEST(36,4)\n+    RUN_TEST(36,8)\n+    RUN_TEST(36,16)\n+    RUN_TEST(37,1)\n+    RUN_TEST(37,2)\n+    RUN_TEST(37,4)\n+    RUN_TEST(37,8)\n+    RUN_TEST(37,16)\n+    RUN_TEST(38,1)\n+    RUN_TEST(38,2)\n+    RUN_TEST(38,4)\n+    RUN_TEST(38,8)\n+    RUN_TEST(38,16)\n+    RUN_TEST(39,1)\n+    RUN_TEST(39,2)\n+    RUN_TEST(39,4)\n+    RUN_TEST(39,8)\n+    RUN_TEST(39,16)\n+    RUN_TEST(40,1)\n+    RUN_TEST(40,2)\n+    RUN_TEST(40,4)\n+    RUN_TEST(40,8)\n+    RUN_TEST(40,16)\n+    RUN_TEST(41,1)\n+    RUN_TEST(41,2)\n+    RUN_TEST(41,4)\n+    RUN_TEST(41,8)\n+    RUN_TEST(41,16)\n+    RUN_TEST(42,1)\n+    RUN_TEST(42,2)\n+    RUN_TEST(42,4)\n+    RUN_TEST(42,8)\n+    RUN_TEST(42,16)\n+    RUN_TEST(43,1)\n+    RUN_TEST(43,2)\n+    RUN_TEST(43,4)\n+    RUN_TEST(43,8)\n+    RUN_TEST(43,16)\n+    RUN_TEST(44,1)\n+    RUN_TEST(44,2)\n+    RUN_TEST(44,4)\n+    RUN_TEST(44,8)\n+    RUN_TEST(44,16)\n+    RUN_TEST(45,1)\n+    RUN_TEST(45,2)\n+    RUN_TEST(45,4)\n+    RUN_TEST(45,8)\n+    RUN_TEST(45,16)\n+    RUN_TEST(46,1)\n+    RUN_TEST(46,2)\n+    RUN_TEST(46,4)\n+    RUN_TEST(46,8)\n+    RUN_TEST(46,16)\n+    RUN_TEST(47,1)\n+    RUN_TEST(47,2)\n+    RUN_TEST(47,4)\n+    RUN_TEST(47,8)\n+    RUN_TEST(47,16)\n+    RUN_TEST(48,1)\n+    RUN_TEST(48,2)\n+    RUN_TEST(48,4)\n+    RUN_TEST(48,8)\n+    RUN_TEST(48,16)\n+    RUN_TEST(49,1)\n+    RUN_TEST(49,2)\n+    RUN_TEST(49,4)\n+    RUN_TEST(49,8)\n+    RUN_TEST(49,16)\n+    RUN_TEST(100,1)\n+    RUN_TEST(100,2)\n+    RUN_TEST(100,4)\n+    RUN_TEST(100,8)\n+    RUN_TEST(100,16)\n #else\n-  RUN_TEST(3,1);\n-  RUN_TEST(4,1);\n-  RUN_TEST(4,2);\n-  RUN_TEST(4,4);\n-  RUN_TEST(5,1);\n-  RUN_TEST(6,1);\n-  RUN_TEST(7,1);\n-  RUN_TEST(8,1);\n-  RUN_TEST(8,2);\n-  RUN_TEST(8,4);\n-  RUN_TEST(8,8);\n-  RUN_TEST(9,1);\n-  RUN_TEST(16,1);\n-  RUN_TEST(16,2);\n-  RUN_TEST(16,4);\n-  RUN_TEST(16,8);\n-  RUN_TEST(16,16);\n-  RUN_TEST(32,1);\n-  RUN_TEST(32,2);\n-  RUN_TEST(32,4);\n-  RUN_TEST(32,8);\n-  RUN_TEST(32,16);\n+    RUN_TEST(3,1)\n+    RUN_TEST(4,1)\n+    RUN_TEST(5,1)\n+    RUN_TEST(5,8)\n+    RUN_TEST(6,1)\n+    RUN_TEST(6,4)\n+    RUN_TEST(6,8)\n+    RUN_TEST(7,1)\n+    RUN_TEST(7,2)\n+    RUN_TEST(7,4)\n+    RUN_TEST(7,8)\n+    RUN_TEST(8,1)\n+    RUN_TEST(9,1)\n+    RUN_TEST(16,1)\n+    RUN_TEST(32,1)\n+    RUN_TEST(100,1)\n+    RUN_TEST(100,8)\n #endif\n-\n-  return 0;\n }"}]}