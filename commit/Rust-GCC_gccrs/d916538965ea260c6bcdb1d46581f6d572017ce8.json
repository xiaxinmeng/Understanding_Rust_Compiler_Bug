{"sha": "d916538965ea260c6bcdb1d46581f6d572017ce8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxNjUzODk2NWVhMjYwYzZiY2RiMWQ0NjU4MWY2ZDU3MjAxN2NlOA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-16T08:34:21Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-01-16T14:39:05Z"}, "message": "libstdc++: Improve unordered containers == operator (PR 91263)\n\nAvoid comparing elements with operator== multiple times by replacing\nuses of find and equal_range with equivalent inlined code that uses\noperator== instead of the container's equality comparison predicate.\nThis is valid because the standard requires that operator== is a\nrefinement of the equality predicate.\n\nAlso replace the _S_is_permutation function with std::is_permutation,\nwhich wasn't yet implemented when this code was first written.\n\n\tPR libstdc++/91263\n\t* include/bits/hashtable.h (_Hashtable<>): Make _Equality<> friend.\n\t* include/bits/hashtable_policy.h: Include <bits/stl_algo.h>.\n\t(_Equality_base): Remove.\n\t(_Equality<>::_M_equal): Review implementation. Use\n\tstd::is_permutation.\n\t* testsuite/23_containers/unordered_multiset/operators/1.cc\n\t(Hash, Equal, test02, test03): New.\n\t* testsuite/23_containers/unordered_set/operators/1.cc\n\t(Hash, Equal, test02, test03): New.", "tree": {"sha": "59517c6575a40c8df9eb7d343fb009c7cc7de1fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59517c6575a40c8df9eb7d343fb009c7cc7de1fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d916538965ea260c6bcdb1d46581f6d572017ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d916538965ea260c6bcdb1d46581f6d572017ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d916538965ea260c6bcdb1d46581f6d572017ce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d916538965ea260c6bcdb1d46581f6d572017ce8/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c197c851e7528baba7cb837f34c05ba2242f705", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c197c851e7528baba7cb837f34c05ba2242f705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c197c851e7528baba7cb837f34c05ba2242f705"}], "stats": {"total": 251, "additions": 178, "deletions": 73}, "files": [{"sha": "d99c1bbdabcd8ce84cf53b2cb05ad94fde82e646", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d916538965ea260c6bcdb1d46581f6d572017ce8", "patch": "@@ -1,3 +1,16 @@\n+2020-01-16  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/91263\n+\t* include/bits/hashtable.h (_Hashtable<>): Make _Equality<> friend.\n+\t* include/bits/hashtable_policy.h: Include <bits/stl_algo.h>.\n+\t(_Equality_base): Remove.\n+\t(_Equality<>::_M_equal): Review implementation. Use\n+\tstd::is_permutation.\n+\t* testsuite/23_containers/unordered_multiset/operators/1.cc\n+\t(Hash, Equal, test02, test03): New.\n+\t* testsuite/23_containers/unordered_set/operators/1.cc\n+\t(Hash, Equal, test02, test03): New.\n+\n 2020-01-15  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/93267"}, {"sha": "9e721aad8ccc2327076c7c384e465d79f4a2a977", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=d916538965ea260c6bcdb1d46581f6d572017ce8", "patch": "@@ -337,6 +337,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       bool _Constant_iteratorsa>\n \tfriend struct __detail::_Insert;\n \n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa,\n+\t       bool _Unique_keysa>\n+\tfriend struct __detail::_Equality;\n+\n     public:\n       using size_type = typename __hashtable_base::size_type;\n       using difference_type = typename __hashtable_base::difference_type;"}, {"sha": "4024e6c37fa1e959fd8acc737bce9fe4084a5b6f", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 54, "deletions": 73, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=d916538965ea260c6bcdb1d46581f6d572017ce8", "patch": "@@ -34,6 +34,7 @@\n #include <tuple>\t\t// for std::tuple, std::forward_as_tuple\n #include <limits>\t\t// for std::numeric_limits\n #include <bits/stl_algobase.h>\t// for std::min.\n+#include <bits/stl_algo.h>\t// for std::is_permutation.\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -1815,65 +1816,6 @@ namespace __detail\n     _M_eq() const { return _EqualEBO::_M_cget(); }\n   };\n \n-  /**\n-   *  struct _Equality_base.\n-   *\n-   *  Common types and functions for class _Equality.\n-   */\n-  struct _Equality_base\n-  {\n-  protected:\n-    template<typename _Uiterator>\n-      static bool\n-      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);\n-  };\n-\n-  // See std::is_permutation in N3068.\n-  template<typename _Uiterator>\n-    bool\n-    _Equality_base::\n-    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,\n-\t\t      _Uiterator __first2)\n-    {\n-      for (; __first1 != __last1; ++__first1, ++__first2)\n-\tif (!(*__first1 == *__first2))\n-\t  break;\n-\n-      if (__first1 == __last1)\n-\treturn true;\n-\n-      _Uiterator __last2 = __first2;\n-      std::advance(__last2, std::distance(__first1, __last1));\n-\n-      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)\n-\t{\n-\t  _Uiterator __tmp =  __first1;\n-\t  while (__tmp != __it1 && !bool(*__tmp == *__it1))\n-\t    ++__tmp;\n-\n-\t  // We've seen this one before.\n-\t  if (__tmp != __it1)\n-\t    continue;\n-\n-\t  std::ptrdiff_t __n2 = 0;\n-\t  for (__tmp = __first2; __tmp != __last2; ++__tmp)\n-\t    if (*__tmp == *__it1)\n-\t      ++__n2;\n-\n-\t  if (!__n2)\n-\t    return false;\n-\n-\t  std::ptrdiff_t __n1 = 0;\n-\t  for (__tmp = __it1; __tmp != __last1; ++__tmp)\n-\t    if (*__tmp == *__it1)\n-\t      ++__n1;\n-\n-\t  if (__n1 != __n2)\n-\t    return false;\n-\t}\n-      return true;\n-    }\n-\n   /**\n    *  Primary class template  _Equality.\n    *\n@@ -1889,7 +1831,7 @@ namespace __detail\n \t   bool _Unique_keys = _Traits::__unique_keys::value>\n     struct _Equality;\n \n-  /// Specialization.\n+  /// unordered_map and unordered_set specializations.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash,\n@@ -1913,28 +1855,41 @@ namespace __detail\n \t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n     _M_equal(const __hashtable& __other) const\n     {\n+      using __node_base = typename __hashtable::__node_base;\n+      using __node_type = typename __hashtable::__node_type;\n       const __hashtable* __this = static_cast<const __hashtable*>(this);\n-\n       if (__this->size() != __other.size())\n \treturn false;\n \n       for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)\n \t{\n-\t  const auto __ity = __other.find(_ExtractKey()(*__itx));\n-\t  if (__ity == __other.end() || !bool(*__ity == *__itx))\n+\t  std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);\n+\t  __node_base* __prev_n = __other._M_buckets[__ybkt];\n+\t  if (!__prev_n)\n \t    return false;\n+\n+\t  for (__node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);;\n+\t       __n = __n->_M_next())\n+\t    {\n+\t      if (__n->_M_v() == *__itx)\n+\t\tbreak;\n+\n+\t      if (!__n->_M_nxt\n+\t\t  || __other._M_bucket_index(__n->_M_next()) != __ybkt)\n+\t\treturn false;\n+\t    }\n \t}\n+\n       return true;\n     }\n \n-  /// Specialization.\n+  /// unordered_multiset and unordered_multimap specializations.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>\n-    : public _Equality_base\n     {\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits>;\n@@ -1952,25 +1907,51 @@ namespace __detail\n \t      _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::\n     _M_equal(const __hashtable& __other) const\n     {\n+      using __node_base = typename __hashtable::__node_base;\n+      using __node_type = typename __hashtable::__node_type;\n       const __hashtable* __this = static_cast<const __hashtable*>(this);\n-\n       if (__this->size() != __other.size())\n \treturn false;\n \n       for (auto __itx = __this->begin(); __itx != __this->end();)\n \t{\n-\t  const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));\n-\t  const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));\n+\t  std::size_t __x_count = 1;\n+\t  auto __itx_end = __itx;\n+\t  for (++__itx_end; __itx_end != __this->end()\n+\t\t && __this->key_eq()(_ExtractKey()(*__itx),\n+\t\t\t\t     _ExtractKey()(*__itx_end));\n+\t       ++__itx_end)\n+\t    ++__x_count;\n+\n+\t  std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);\n+\t  __node_base* __y_prev_n = __other._M_buckets[__ybkt];\n+\t  if (!__y_prev_n)\n+\t    return false;\n+\n+\t  __node_type* __y_n = static_cast<__node_type*>(__y_prev_n->_M_nxt);\n+\t  for (;; __y_n = __y_n->_M_next())\n+\t    {\n+\t      if (__this->key_eq()(_ExtractKey()(__y_n->_M_v()),\n+\t\t\t\t   _ExtractKey()(*__itx)))\n+\t\tbreak;\n+\n+\t      if (!__y_n->_M_nxt\n+\t\t  || __other._M_bucket_index(__y_n->_M_next()) != __ybkt)\n+\t\treturn false;\n+\t    }\n+\n+\t  typename __hashtable::const_iterator __ity(__y_n);\n+\t  for (auto __ity_end = __ity; __ity_end != __other.end(); ++__ity_end)\n+\t    if (--__x_count == 0)\n+\t      break;\n \n-\t  if (std::distance(__xrange.first, __xrange.second)\n-\t      != std::distance(__yrange.first, __yrange.second))\n+\t  if (__x_count != 0)\n \t    return false;\n \n-\t  if (!_S_is_permutation(__xrange.first, __xrange.second,\n-\t\t\t\t __yrange.first))\n+\t  if (!std::is_permutation(__itx, __itx_end, __ity))\n \t    return false;\n \n-\t  __itx = __xrange.second;\n+\t  __itx = __itx_end;\n \t}\n       return true;\n     }"}, {"sha": "7252cad29c23b301789f377aad7e267ad6cea820", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/operators/1.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperators%2F1.cc?ref=d916538965ea260c6bcdb1d46581f6d572017ce8", "patch": "@@ -99,8 +99,64 @@ void test01()\n   VERIFY( !(ums1 != cums2) );\n }\n \n+void test02()\n+{\n+  std::unordered_multiset<int> us1\n+  { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9 };\n+  std::unordered_multiset<int> us2\n+  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+\n+  VERIFY( us1 == us2 );\n+}\n+\n+struct Hash\n+{\n+  std::size_t\n+  operator()(const std::pair<int, int>& p) const\n+  { return p.first; }\n+};\n+\n+struct Equal\n+{\n+  bool\n+  operator()(const std::pair<int, int>& lhs, const std::pair<int, int>& rhs) const\n+  { return lhs.first == rhs.first; }\n+};\n+\n+void test03()\n+{\n+  std::unordered_multiset<std::pair<int, int>, Hash, Equal> us1\n+  {\n+    { 0, 0 }, { 1, 0 }, { 2, 0 }, { 3, 0 }, { 4, 0 },\n+    { 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1 }, { 4, 1 },\n+    { 5, 0 }, { 6, 0 }, { 7, 0 }, { 8, 0 }, { 9, 0 },\n+    { 5, 1 }, { 6, 1 }, { 7, 1 }, { 8, 1 }, { 9, 1 }\n+  };\n+  std::unordered_multiset<std::pair<int, int>, Hash, Equal> us2\n+  {\n+    { 5, 1 }, { 6, 1 }, { 7, 1 }, { 8, 1 }, { 9, 1 },\n+    { 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1 }, { 4, 1 },\n+    { 5, 0 }, { 6, 0 }, { 7, 0 }, { 8, 0 }, { 9, 0 },\n+    { 0, 0 }, { 1, 0 }, { 2, 0 }, { 3, 0 }, { 4, 0 }\n+  };\n+\n+  VERIFY( us1 == us2 );\n+\n+  std::unordered_multiset<std::pair<int, int>, Hash, Equal> us3\n+  {\n+    { 5, 1 }, { 6, 1 }, { 7, 1 }, { 8, 1 }, { 9, 1 },\n+    { 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1 }, { 4, 1 },\n+    { 5, 0 }, { 6, 0 }, { 7, 1 }, { 8, 0 }, { 9, 0 },\n+    { 0, 0 }, { 1, 0 }, { 2, 0 }, { 3, 0 }, { 4, 0 }\n+  };\n+\n+  VERIFY( us1 != us3 );\n+}\n+\n int main()\n {\n   test01();\n+  test02();\n+  test03();\n   return 0;\n }"}, {"sha": "36a45dfa0991bff6e57a67da38b555d6868e9d0e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/operators/1.cc", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d916538965ea260c6bcdb1d46581f6d572017ce8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperators%2F1.cc?ref=d916538965ea260c6bcdb1d46581f6d572017ce8", "patch": "@@ -99,8 +99,56 @@ void test01()\n   VERIFY( !(us1 != cus2) );\n }\n \n+void test02()\n+{\n+  std::unordered_set<int> us1 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  std::unordered_set<int> us2 { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };\n+\n+  VERIFY( us1 == us2 );\n+}\n+\n+struct Hash\n+{\n+  std::size_t\n+  operator()(const std::pair<int, int>& p) const\n+  { return p.first; }\n+};\n+\n+struct Equal\n+{\n+  bool\n+  operator()(const std::pair<int, int>& lhs, const std::pair<int, int>& rhs) const\n+  { return lhs.first == rhs.first; }\n+};\n+\n+void test03()\n+{\n+  std::unordered_set<std::pair<int, int>, Hash, Equal> us1\n+  {\n+    { 0, 0 }, { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 },\n+    { 5, 5 }, { 6, 6 }, { 7, 7 }, { 8, 8 }, { 9, 9 }\n+  };\n+  std::unordered_set<std::pair<int, int>, Hash, Equal> us2\n+  {\n+    { 5, 5 }, { 6, 6 }, { 7, 7 }, { 8, 8 }, { 9, 9 },\n+    { 0, 0 }, { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 }\n+  };\n+\n+  VERIFY( us1 == us2 );\n+\n+  std::unordered_set<std::pair<int, int>, Hash, Equal> us3\n+  {\n+    { 5, -5 }, { 6, 6 }, { 7, 7 }, { 8, 8 }, { 9, 9 },\n+    { 0, 0  }, { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 }\n+  };\n+\n+  VERIFY( us1 != us3 );\n+}\n+\n int main()\n {\n   test01();\n+  test02();\n+  test03();\n   return 0;\n }"}]}