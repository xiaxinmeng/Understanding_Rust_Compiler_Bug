{"sha": "197c757cb11681a6ff6df1491ebfde4f5a392627", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk3Yzc1N2NiMTE2ODFhNmZmNmRmMTQ5MWViZmRlNGY1YTM5MjYyNw==", "commit": {"author": {"name": "Tim Shen", "email": "timshen@google.com", "date": "2016-08-18T20:31:26Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2016-08-18T20:31:26Z"}, "message": "Implement <variant>\n\n\t* include/Makefile.am: Add new file std/variant.\n\t* include/Makefile.in: Generated from Makefile.am.\n\t* include/bits/enable_special_members.h: Add a tag type to allow\n\tthe construction in non-default constructor.\n\t* include/bits/uses_allocator.h: Add convenience traits to\n\tdetect constructibility.\n\t* include/std/variant: Implement <variant>.\n\t* testsuite/20_util/variant/compile.cc: Compile-time tests.\n\t* testsuite/20_util/variant/run.cc: Runtime tests.\n\nFrom-SVN: r239590", "tree": {"sha": "bc774dd64d1e9187c477c6aa386748350ca8e8d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc774dd64d1e9187c477c6aa386748350ca8e8d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/197c757cb11681a6ff6df1491ebfde4f5a392627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197c757cb11681a6ff6df1491ebfde4f5a392627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/197c757cb11681a6ff6df1491ebfde4f5a392627", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197c757cb11681a6ff6df1491ebfde4f5a392627/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc015f3abebcfe84c64a38d1198ad4601e36893c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc015f3abebcfe84c64a38d1198ad4601e36893c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc015f3abebcfe84c64a38d1198ad4601e36893c"}], "stats": {"total": 2370, "additions": 2368, "deletions": 2}, "files": [{"sha": "a2fa63e67620d50bdfc916f66d0664d908f144c5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -1,3 +1,17 @@\n+2016-08-18  Tim Shen  <timshen@google.com>\n+\n+\tImplement <variant>\n+\n+\t* include/Makefile.am: Add new file std/variant.\n+\t* include/Makefile.in: Generated from Makefile.am.\n+\t* include/bits/enable_special_members.h: Add a tag type to allow\n+\tthe construction in non-default constructor.\n+\t* include/bits/uses_allocator.h: Add convenience traits to\n+\tdetect constructibility.\n+\t* include/std/variant: Implement <variant>.\n+\t* testsuite/20_util/variant/compile.cc: Compile-time tests.\n+\t* testsuite/20_util/variant/run.cc: Runtime tests.\n+\n 2016-08-18  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/xml/manual/test.xml (test.run.permutations): Expand section."}, {"sha": "0a10994de4e5c762e1b69ced04ef82a4ae2d7cb0", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -77,6 +77,7 @@ std_headers = \\\n \t${std_srcdir}/unordered_set \\\n \t${std_srcdir}/utility \\\n \t${std_srcdir}/valarray \\\n+\t${std_srcdir}/variant \\\n \t${std_srcdir}/vector\n \n bits_srcdir = ${glibcxx_srcdir}/include/bits"}, {"sha": "8b774a98f7bbf39023a99f1d2f931cf1519e2642", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -367,6 +367,7 @@ std_headers = \\\n \t${std_srcdir}/unordered_set \\\n \t${std_srcdir}/utility \\\n \t${std_srcdir}/valarray \\\n+\t${std_srcdir}/variant \\\n \t${std_srcdir}/vector\n \n bits_srcdir = ${glibcxx_srcdir}/include/bits"}, {"sha": "07c6c99ef854da92014116254779706896551179", "filename": "libstdc++-v3/include/bits/enable_special_members.h", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fenable_special_members.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fenable_special_members.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fenable_special_members.h?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -36,13 +36,33 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  struct _Enable_default_constructor_tag\n+  {\n+    explicit _Enable_default_constructor_tag() = default;\n+  };\n+\n /**\n   * @brief A mixin helper to conditionally enable or disable the default\n   * constructor.\n   * @sa _Enable_special_members\n   */\n template<bool _Switch, typename _Tag = void>\n-  struct _Enable_default_constructor { };\n+  struct _Enable_default_constructor\n+  {\n+    constexpr _Enable_default_constructor() noexcept = default;\n+    constexpr _Enable_default_constructor(_Enable_default_constructor const&)\n+      noexcept  = default;\n+    constexpr _Enable_default_constructor(_Enable_default_constructor&&)\n+      noexcept = default;\n+    _Enable_default_constructor&\n+    operator=(_Enable_default_constructor const&) noexcept = default;\n+    _Enable_default_constructor&\n+    operator=(_Enable_default_constructor&&) noexcept = default;\n+\n+    // Can be used in other ctors.\n+    constexpr explicit\n+    _Enable_default_constructor(_Enable_default_constructor_tag) { }\n+  };\n \n \n /**\n@@ -86,7 +106,20 @@ template<bool _Default, bool _Destructor,\n \n template<typename _Tag>\n   struct _Enable_default_constructor<false, _Tag>\n-  { constexpr _Enable_default_constructor() noexcept = delete; };\n+  {\n+    constexpr _Enable_default_constructor() noexcept = delete;\n+    constexpr _Enable_default_constructor(_Enable_default_constructor const&)\n+      noexcept  = default;\n+    constexpr _Enable_default_constructor(_Enable_default_constructor&&)\n+      noexcept = default;\n+    _Enable_default_constructor&\n+    operator=(_Enable_default_constructor const&) noexcept = default;\n+    _Enable_default_constructor&\n+    operator=(_Enable_default_constructor&&) noexcept = default;\n+\n+    // Can be used in other ctors.\n+    explicit _Enable_default_constructor(_Enable_default_constructor_tag) { }\n+  };\n \n template<typename _Tag>\n   struct _Enable_destructor<false, _Tag>"}, {"sha": "500bd901554ffd31026568933b214a426455102a", "filename": "libstdc++-v3/include/bits/uses_allocator.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -113,6 +113,57 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     constexpr bool uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;\n #endif // C++17\n \n+  template<template<typename...> class _Predicate,\n+\t   typename _Tp, typename _Alloc, typename... _Args>\n+    struct __is_uses_allocator_predicate\n+    : conditional<uses_allocator<_Tp, _Alloc>::value,\n+      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,\n+\t    _Predicate<_Tp, _Args..., _Alloc>>,\n+      _Predicate<_Tp, _Args...>>::type { };\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    struct __is_uses_allocator_constructible\n+    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>\n+    { };\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    constexpr bool __is_uses_allocator_constructible_v =\n+      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    struct __is_nothrow_uses_allocator_constructible\n+    : __is_uses_allocator_predicate<is_nothrow_constructible,\n+\t\t\t\t    _Tp, _Alloc, _Args...>\n+    { };\n+\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    constexpr bool __is_nothrow_uses_allocator_constructible_v =\n+      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;\n+\n+  template<typename _Tp, typename... _Args>\n+    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,\n+\t\t\t\t\t _Args&&... __args)\n+    { new (__ptr) _Tp(forward<_Args>(__args)...); }\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,\n+\t\t\t\t\t _Args&&... __args)\n+    { new (__ptr) _Tp(allocator_arg, *__a._M_a, forward<_Args>(__args)...); }\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,\n+\t\t\t\t\t _Args&&... __args)\n+    { new (__ptr) _Tp(forward<_Args>(__args)..., *__a._M_a); }\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,\n+\t\t\t\t    _Args&&... __args)\n+    {\n+      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),\n+\t\t\t\t      __ptr, forward<_Args>(__args)...);\n+    }\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "a9b4394477091d225455e9004567d7126d852091", "filename": "libstdc++-v3/include/std/variant", "status": "added", "additions": 1360, "deletions": 0, "changes": 1360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -0,0 +1,1360 @@\n+// <variant> -*- C++ -*-\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file variant\n+ *  This is the <variant> C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_VARIANT\n+#define _GLIBCXX_VARIANT 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus <= 201402L\n+# include <bits/c++17_warning.h>\n+#else\n+\n+#include <type_traits>\n+#include <utility>\n+#include <bits/enable_special_members.h>\n+#include <bits/uses_allocator.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename... _Types> class tuple;\n+  template<typename... _Types> class variant;\n+  template <typename> struct hash;\n+\n+  template<typename _Variant>\n+    struct variant_size;\n+\n+  template<typename _Variant>\n+    struct variant_size<const _Variant> : variant_size<_Variant> {};\n+\n+  template<typename _Variant>\n+    struct variant_size<volatile _Variant> : variant_size<_Variant> {};\n+\n+  template<typename _Variant>\n+    struct variant_size<const volatile _Variant> : variant_size<_Variant> {};\n+\n+  template<typename... _Types>\n+    struct variant_size<variant<_Types...>>\n+    : std::integral_constant<size_t, sizeof...(_Types)> {};\n+\n+  template<typename _Variant>\n+    constexpr size_t variant_size_v = variant_size<_Variant>::value;\n+\n+  template<size_t _Np, typename _Variant>\n+    struct variant_alternative;\n+\n+  template<size_t _Np, typename _First, typename... _Rest>\n+    struct variant_alternative<_Np, variant<_First, _Rest...>>\n+    : variant_alternative<_Np-1, variant<_Rest...>> {};\n+\n+  template<typename _First, typename... _Rest>\n+    struct variant_alternative<0, variant<_First, _Rest...>>\n+    { using type = _First; };\n+\n+  template<size_t _Np, typename _Variant>\n+    using variant_alternative_t =\n+      typename variant_alternative<_Np, _Variant>::type;\n+\n+  constexpr size_t variant_npos = -1;\n+\n+namespace __detail\n+{\n+namespace __variant\n+{\n+  // Returns the first apparence of _Tp in _Types.\n+  // Returns sizeof...(_Types) if _Tp is not in _Types.\n+  template<typename _Tp, typename... _Types>\n+    struct __index_of : std::integral_constant<size_t, 0> {};\n+\n+  template<typename _Tp, typename... _Types>\n+    constexpr size_t __index_of_v = __index_of<_Tp, _Types...>::value;\n+\n+  template<typename _Tp, typename _First, typename... _Rest>\n+    struct __index_of<_Tp, _First, _Rest...> :\n+      std::integral_constant<size_t, is_same_v<_Tp, _First>\n+\t? 0 : __index_of_v<_Tp, _Rest...> + 1> {};\n+\n+  // Extract _From's qualifiers and references and apply it to _To.\n+  // __reserved_type_map<const int&, char> is const char&.\n+  template<typename _From, typename _To>\n+    struct __reserved_type_map_impl\n+    { using type = _To; };\n+\n+  template<typename _From, typename _To>\n+    using __reserved_type_map =\n+      typename __reserved_type_map_impl<_From, _To>::type;\n+\n+  template<typename _From, typename _To>\n+    struct __reserved_type_map_impl<_From&, _To>\n+    { using type = add_lvalue_reference_t<__reserved_type_map<_From, _To>>; };\n+\n+  template<typename _From, typename _To>\n+    struct __reserved_type_map_impl<_From&&, _To>\n+    { using type = add_rvalue_reference_t<__reserved_type_map<_From, _To>>; };\n+\n+  template<typename _From, typename _To>\n+    struct __reserved_type_map_impl<const _From, _To>\n+    { using type = add_const_t<__reserved_type_map<_From, _To>>; };\n+\n+  template<typename _From, typename _To>\n+    struct __reserved_type_map_impl<volatile _From, _To>\n+    { using type = add_volatile_t<__reserved_type_map<_From, _To>>; };\n+\n+  template<typename _From, typename _To>\n+    struct __reserved_type_map_impl<const volatile _From, _To>\n+    { using type = add_cv_t<__reserved_type_map<_From, _To>>; };\n+\n+  // Stores a reference alternative as a... well, reference.\n+  template<typename _Reference>\n+    struct _Reference_storage\n+    {\n+      static_assert(is_reference_v<_Reference>,\n+\t\t    \"BUG: _Reference should be a reference\");\n+\n+      _Reference_storage(_Reference __ref) noexcept : _M_storage(__ref) { }\n+\n+      operator _Reference() noexcept\n+      { return static_cast<_Reference>(_M_storage); }\n+\n+      _Reference _M_storage;\n+    };\n+\n+  // Stores a void alternative, because it is not a regular type.\n+  template<typename _Void>\n+    struct _Void_storage { };\n+\n+  // Map from the alternative type to a non-qualified storage type.\n+  template<typename _Alternative, typename = void>\n+    struct __storage_type\n+    { using type = _Alternative; };\n+\n+  template<typename _Alternative>\n+    struct __storage_type<_Alternative,\n+\t\t\t  enable_if_t<is_reference_v<_Alternative>>>\n+    { using type = _Reference_storage<_Alternative>; };\n+\n+  template<typename _Alternative>\n+    struct __storage_type<_Alternative, enable_if_t<is_void_v<_Alternative>>>\n+    { using type = _Void_storage<_Alternative>; };\n+\n+  template<typename _Type>\n+    using __storage = typename __storage_type<_Type>::type;\n+\n+  template<typename _Type, bool __is_literal = std::is_literal_type_v<_Type>>\n+    struct _Uninitialized;\n+\n+  template<typename _Type>\n+    struct _Uninitialized<_Type, true>\n+    {\n+      constexpr _Uninitialized() = default;\n+\n+      template<typename... _Args>\n+      constexpr _Uninitialized(in_place_index_t<0>, _Args&&... __args)\n+      : _M_storage(std::forward<_Args>(__args)...)\n+      { }\n+\n+      _Type _M_storage;\n+    };\n+\n+  template<typename _Type>\n+    struct _Uninitialized<_Type, false>\n+    {\n+      constexpr _Uninitialized() = default;\n+\n+      template<typename... _Args>\n+      constexpr _Uninitialized(in_place_index_t<0>, _Args&&... __args)\n+      { ::new (&_M_storage) _Type(std::forward<_Args>(__args)...); }\n+\n+      typename std::aligned_storage<sizeof(_Type), alignof(_Type)>::type\n+\t  _M_storage;\n+    };\n+\n+  // Reverse mapping of __storage_type.\n+  template<typename _Storage_type>\n+    struct __alternative_type\n+    {\n+      static_assert(!is_reference_v<_Storage_type>,\n+\t\t    \"BUG: _Storage_type should not be reference\");\n+      using type = _Storage_type;\n+    };\n+\n+  template<typename _Reference>\n+    struct __alternative_type<_Reference_storage<_Reference>>\n+    { using type = _Reference; };\n+\n+  template<typename _Void>\n+    struct __alternative_type<_Void_storage<_Void>>\n+    { using type = _Void; };\n+\n+  // Given a qualified storage type, return the desired reference.\n+  // The qualified storage type is supposed to carry the variant object's\n+  // qualifications and reference information, and the designated alternative's\n+  // storage type.\n+  // Returns the qualification-collapsed alternative references.\n+  //\n+  // For example, __get_alternative<_Reference_storage<int&&>&> returns int&.\n+  template<typename _Qualified_storage>\n+    decltype(auto)\n+    __get_alternative(void* __ptr)\n+    {\n+      using _Storage = decay_t<_Qualified_storage>;\n+      using _Alternative = typename __alternative_type<_Storage>::type;\n+      return __reserved_type_map<_Qualified_storage, _Alternative>(\n+\t*static_cast<_Storage*>(__ptr));\n+    }\n+\n+  // Various functions as \"vtable\" entries, where those vtables are used by\n+  // polymorphic operations.\n+  template<typename _Lhs, typename _Rhs>\n+    constexpr void\n+    __erased_ctor(void* __lhs, void* __rhs)\n+    { ::new (__lhs) decay_t<_Lhs>(__get_alternative<_Rhs>(__rhs)); }\n+\n+  template<typename _Alloc, typename _Lhs, typename _Rhs>\n+    constexpr void\n+    __erased_use_alloc_ctor(const _Alloc& __a, void* __lhs, void* __rhs)\n+    {\n+      __uses_allocator_construct(__a, static_cast<decay_t<_Lhs>*>(__lhs),\n+\t\t\t\t __get_alternative<_Rhs>(__rhs));\n+    }\n+\n+  // TODO: Find a potential chance to reuse this accross the project.\n+  template<typename _Tp>\n+    constexpr void\n+    __erased_dtor(void* __ptr)\n+    {\n+      using _Storage = decay_t<_Tp>;\n+      static_cast<_Storage*>(__ptr)->~_Storage();\n+    }\n+\n+  template<typename _Lhs, typename _Rhs>\n+    constexpr void\n+    __erased_assign(void* __lhs, void* __rhs)\n+    { __get_alternative<_Lhs>(__lhs) = __get_alternative<_Rhs>(__rhs); }\n+\n+  template<typename _Lhs, typename _Rhs>\n+    constexpr void\n+    __erased_swap(void* __lhs, void* __rhs)\n+    {\n+      using std::swap;\n+      swap(__get_alternative<_Lhs>(__lhs), __get_alternative<_Rhs>(__rhs));\n+    }\n+\n+  template<typename _Lhs, typename _Rhs>\n+    constexpr bool\n+    __erased_equal_to(void* __lhs, void* __rhs)\n+    { return __get_alternative<_Lhs>(__lhs) == __get_alternative<_Rhs>(__rhs); }\n+\n+  template<typename _Lhs, typename _Rhs>\n+    constexpr bool\n+    __erased_less_than(void* __lhs, void* __rhs)\n+    { return __get_alternative<_Lhs>(__lhs) < __get_alternative<_Rhs>(__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr size_t\n+    __erased_hash(void* __t)\n+    { return std::hash<decay_t<_Tp>>{}(__get_alternative<_Tp>(__t)); }\n+\n+  template<typename... _Types>\n+    struct _Variant_base;\n+\n+  template<typename... _Types>\n+    struct _Variant_storage\n+    { constexpr _Variant_storage() = default; };\n+\n+  // Use recursive unions to implement a trivially destructible variant.\n+  template<typename _First, typename... _Rest>\n+    struct _Variant_storage<_First, _Rest...>\n+    {\n+      constexpr _Variant_storage() = default;\n+\n+      template<typename... _Args>\n+\tconstexpr _Variant_storage(in_place_index_t<0>, _Args&&... __args)\n+\t: _M_first(in_place<0>, forward<_Args>(__args)...)\n+\t{ }\n+\n+      template<size_t _Np, typename... _Args,\n+\t       typename = enable_if_t<0 < _Np && _Np < sizeof...(_Rest) + 1>>\n+\tconstexpr _Variant_storage(in_place_index_t<_Np>, _Args&&... __args)\n+\t: _M_rest(in_place<_Np - 1>, forward<_Args>(__args)...)\n+\t{ }\n+\n+      ~_Variant_storage() = default;\n+\n+      constexpr void*\n+      _M_storage() const\n+      {\n+\treturn const_cast<void*>(\n+\t  static_cast<const void*>(&_M_first._M_storage));\n+      }\n+\n+      union\n+      {\n+\t_Uninitialized<__storage<_First>> _M_first;\n+\t_Variant_storage<_Rest...> _M_rest;\n+      };\n+    };\n+\n+  template<typename _Derived, bool __is_trivially_destructible>\n+    struct _Dtor_mixin\n+    {\n+      ~_Dtor_mixin()\n+      { static_cast<_Derived*>(this)->_M_destroy(); }\n+    };\n+\n+  template<typename _Derived>\n+    struct _Dtor_mixin<_Derived, true>\n+    {\n+      ~_Dtor_mixin() = default;\n+    };\n+\n+  // Helps SFINAE on special member functions. Otherwise it can live in variant\n+  // class.\n+  template<typename... _Types>\n+    struct _Variant_base :\n+      _Variant_storage<_Types...>,\n+      _Dtor_mixin<_Variant_base<_Types...>,\n+\t\t  __and_<std::is_trivially_destructible<_Types>...>::value>\n+    {\n+      using _Storage = _Variant_storage<_Types...>;\n+\n+      constexpr\n+      _Variant_base()\n+      noexcept(is_nothrow_default_constructible_v<\n+\t\t variant_alternative_t<0, variant<_Types...>>>)\n+      : _Variant_base(in_place<0>) { }\n+\n+      _Variant_base(const _Variant_base& __rhs)\n+      : _Storage(), _M_index(__rhs._M_index)\n+      {\n+\tif (__rhs._M_valid())\n+\t  {\n+\t    static constexpr void (*_S_vtable[])(void*, void*) =\n+\t      { &__erased_ctor<__storage<_Types>&,\n+\t\t\t       const __storage<_Types>&>... };\n+\t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t  }\n+      }\n+\n+      _Variant_base(_Variant_base&& __rhs)\n+      noexcept(__and_<is_nothrow_move_constructible<_Types>...>::value)\n+      : _Storage(), _M_index(__rhs._M_index)\n+      {\n+\tif (__rhs._M_valid())\n+\t  {\n+\t    static constexpr void (*_S_vtable[])(void*, void*) =\n+\t      { &__erased_ctor<__storage<_Types>&, __storage<_Types>&&>... };\n+\t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t  }\n+      }\n+\n+      template<size_t _Np, typename... _Args>\n+\tconstexpr explicit\n+\t_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)\n+\t: _Storage(__i, forward<_Args>(__args)...), _M_index(_Np)\n+\t{ }\n+\n+      template<typename _Alloc>\n+\t_Variant_base(const _Alloc& __a, const _Variant_base& __rhs)\n+\t: _Storage(), _M_index(__rhs._M_index)\n+\t{\n+\t  if (__rhs._M_valid())\n+\t    {\n+\t      static constexpr void\n+\t      (*_S_vtable[])(const _Alloc&, void*, void*) =\n+\t\t{ &__erased_use_alloc_ctor<_Alloc, __storage<_Types>&,\n+\t\t\t\t\t   const __storage<_Types>&>... };\n+\t      _S_vtable[__rhs._M_index](__a, _M_storage(), __rhs._M_storage());\n+\t    }\n+\t}\n+\n+      template<typename _Alloc>\n+\t_Variant_base(const _Alloc& __a, _Variant_base&& __rhs)\n+\t: _Storage(), _M_index(__rhs._M_index)\n+\t{\n+\t  if (__rhs._M_valid())\n+\t    {\n+\t      static constexpr void\n+\t      (*_S_vtable[])(const _Alloc&, void*, void*) =\n+\t\t{ &__erased_use_alloc_ctor<_Alloc, __storage<_Types>&,\n+\t\t\t\t\t   __storage<_Types>&&>... };\n+\t      _S_vtable[__rhs._M_index](__a, _M_storage(), __rhs._M_storage());\n+\t    }\n+\t}\n+\n+      template<typename _Alloc, size_t _Np, typename... _Args>\n+\tconstexpr explicit\n+\t_Variant_base(const _Alloc& __a, in_place_index_t<_Np>,\n+\t\t      _Args&&... __args)\n+\t: _Storage(), _M_index(_Np)\n+\t{\n+\t  using _Storage =\n+\t    __storage<variant_alternative_t<_Np, variant<_Types...>>>;\n+\t  __uses_allocator_construct(__a, static_cast<_Storage*>(_M_storage()),\n+\t\t\t\t     forward<_Args>(__args)...);\n+\t  __glibcxx_assert(_M_index == _Np);\n+\t}\n+\n+      _Variant_base&\n+      operator=(const _Variant_base& __rhs)\n+      {\n+\tif (_M_index == __rhs._M_index)\n+\t  {\n+\t    if (__rhs._M_valid())\n+\t      {\n+\t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n+\t\t  { &__erased_assign<__storage<_Types>&,\n+\t\t\t\t     const __storage<_Types>&>... };\n+\t\t_S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    _Variant_base __tmp(__rhs);\n+\t    this->~_Variant_base();\n+\t    __try\n+\t      {\n+\t\t::new (this) _Variant_base(std::move(__tmp));\n+\t      }\n+\t    __catch (...)\n+\t      {\n+\t\t_M_index = variant_npos;\n+\t\t__throw_exception_again;\n+\t      }\n+\t  }\n+\t__glibcxx_assert(_M_index == __rhs._M_index);\n+\treturn *this;\n+      }\n+\n+      _Variant_base&\n+      operator=(_Variant_base&& __rhs)\n+      noexcept(__and_<is_nothrow_move_constructible<_Types>...,\n+\t\t      is_nothrow_move_assignable<_Types>...>::value)\n+      {\n+\tif (_M_index == __rhs._M_index)\n+\t  {\n+\t    if (__rhs._M_valid())\n+\t      {\n+\t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n+\t\t  { &__erased_assign<__storage<_Types>&,\n+\t\t\t\t     __storage<_Types>&&>... };\n+\t\t_S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    this->~_Variant_base();\n+\t    __try\n+\t      {\n+\t\t::new (this) _Variant_base(std::move(__rhs));\n+\t      }\n+\t    __catch (...)\n+\t      {\n+\t\t_M_index = variant_npos;\n+\t\t__throw_exception_again;\n+\t      }\n+\t  }\n+\treturn *this;\n+      }\n+\n+      void _M_destroy()\n+      {\n+\tif (_M_valid())\n+\t  {\n+\t    static constexpr void (*_S_vtable[])(void*) =\n+\t      { &__erased_dtor<__storage<_Types>&>... };\n+\t    _S_vtable[this->_M_index](_M_storage());\n+\t  }\n+      }\n+\n+      constexpr void*\n+      _M_storage() const\n+      { return _Storage::_M_storage(); }\n+\n+      constexpr bool\n+      _M_valid() const noexcept\n+      { return _M_index != variant_npos; }\n+\n+      size_t _M_index;\n+    };\n+\n+  // For how many times does _Tp appear in _Tuple?\n+  template<typename _Tp, typename _Tuple>\n+    struct __tuple_count;\n+\n+  template<typename _Tp, typename _Tuple>\n+    constexpr size_t __tuple_count_v = __tuple_count<_Tp, _Tuple>::value;\n+\n+  template<typename _Tp, typename... _Types>\n+    struct __tuple_count<_Tp, tuple<_Types...>>\n+    : integral_constant<size_t, 0> { };\n+\n+  template<typename _Tp, typename _First, typename... _Rest>\n+    struct __tuple_count<_Tp, tuple<_First, _Rest...>>\n+    : integral_constant<\n+\tsize_t,\n+\t__tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };\n+\n+  // TODO: Reuse this in <tuple> ?\n+  template<typename _Tp, typename... _Types>\n+    constexpr bool __exactly_once = __tuple_count_v<_Tp, tuple<_Types...>> == 1;\n+\n+  // Takes _Types and create an overloaded _S_fun for each type.\n+  // If a type appears more than once in _Types, create only one overload.\n+  template<typename... _Types>\n+    struct __overload_set\n+    { static void _S_fun(); };\n+\n+  template<typename _First, typename... _Rest>\n+    struct __overload_set<_First, _Rest...> : __overload_set<_Rest...>\n+    {\n+      using __overload_set<_Rest...>::_S_fun;\n+      static integral_constant<size_t, sizeof...(_Rest)> _S_fun(_First);\n+    };\n+\n+  template<typename... _Rest>\n+    struct __overload_set<void, _Rest...> : __overload_set<_Rest...>\n+    {\n+      using __overload_set<_Rest...>::_S_fun;\n+    };\n+\n+  // Helper for variant(_Tp&&) and variant::operator=(_Tp&&).\n+  // __accepted_index maps the arbitrary _Tp to an alternative type in _Variant.\n+  template<typename _Tp, typename _Variant, typename = void>\n+    struct __accepted_index\n+    { static constexpr size_t value = variant_npos; };\n+\n+  template<typename _Tp, typename... _Types>\n+    struct __accepted_index<\n+      _Tp, variant<_Types...>,\n+      decltype(__overload_set<_Types...>::_S_fun(std::declval<_Tp>()),\n+\t       std::declval<void>())>\n+    {\n+      static constexpr size_t value = sizeof...(_Types) - 1\n+\t- decltype(__overload_set<_Types...>::\n+\t\t   _S_fun(std::declval<_Tp>()))::value;\n+    };\n+\n+  // Returns the raw storage for __v.\n+  template<typename _Variant>\n+    void* __get_storage(_Variant&& __v)\n+    { return __v._M_storage(); }\n+\n+  // Returns the reference to the desired alternative.\n+  // It is as unsafe as a reinterpret_cast.\n+  template<typename _Tp, typename _Variant>\n+    decltype(auto) __access(_Variant&& __v)\n+    {\n+      return __get_alternative<__reserved_type_map<_Variant&&, __storage<_Tp>>>(\n+\t__get_storage(forward<_Variant>(__v)));\n+    }\n+\n+  // A helper used to create variadic number of _To types.\n+  template<typename _From, typename _To>\n+    using _To_type = _To;\n+\n+  // Call the actual visitor.\n+  // _Args are qualified storage types.\n+  template<typename _Visitor, typename... _Args>\n+    decltype(auto) __visit_invoke(_Visitor&& __visitor,\n+\t\t\t\t  _To_type<_Args, void*>... __ptrs)\n+    {\n+      return forward<_Visitor>(__visitor)(__get_alternative<_Args>(__ptrs)...);\n+    }\n+\n+  // Used for storing multi-dimensional vtable.\n+  template<typename _Tp, size_t... _Dimensions>\n+    struct _Multi_array\n+    {\n+      constexpr const _Tp&\n+      _M_access() const\n+      { return _M_data; }\n+\n+      _Tp _M_data;\n+    };\n+\n+  template<typename _Tp, size_t __first, size_t... __rest>\n+    struct _Multi_array<_Tp, __first, __rest...>\n+    {\n+      template<typename... _Args>\n+\tconstexpr const _Tp&\n+\t_M_access(size_t __first_index, _Args... __rest_indices) const\n+\t{ return _M_arr[__first_index]._M_access(__rest_indices...); }\n+\n+      _Multi_array<_Tp, __rest...> _M_arr[__first];\n+    };\n+\n+  // Creates a multi-dimensional vtable recursively.\n+  // _Variant_tuple is initially the input from visit(), and gets gradually\n+  // consumed.\n+  // _Arg_tuple is enumerated alternative sequence, represented by a\n+  // qualified storage.\n+  //\n+  // For example,\n+  // visit([](auto, auto){},\n+  //       variant<int, char>(),\n+  //       variant<float, double, long double>())\n+  // will trigger instantiations of:\n+  // __gen_vtable_impl<_Multi_array<void(*)(void*, void*), 2, 3>,\n+  //                   tuple<variant<int, char>,\n+  //                         variant<float, double, long double>>,\n+  //                   tuple<>>\n+  //   __gen_vtable_impl<_Multi_array<void(*)(void*, void*), 3>,\n+  //                     tuple<variant<float, double, long double>>,\n+  //                     tuple<int>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n+  //                       tuple<>,\n+  //                       tuple<int, float>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n+  //                       tuple<>,\n+  //                       tuple<int, double>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n+  //                       tuple<>,\n+  //                       tuple<int, long double>>\n+  //   __gen_vtable_impl<_Multi_array<void(*)(void*, void*), 3>,\n+  //                     tuple<variant<float, double, long double>>,\n+  //                     tuple<char>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n+  //                       tuple<>,\n+  //                       tuple<char, float>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n+  //                       tuple<>,\n+  //                       tuple<char, double>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n+  //                       tuple<>,\n+  //                       tuple<char, long double>>\n+  // The returned multi-dimensional vtable can be fast accessed by the visitor\n+  // using index calculation.\n+  template<typename _Array_type, typename _Variant_tuple, typename _Arg_tuple>\n+    struct __gen_vtable_impl;\n+\n+  template<typename _Array_type, typename _First, typename... _Rest,\n+\t   typename... _Args>\n+    struct __gen_vtable_impl<_Array_type, tuple<_First, _Rest...>,\n+\t\t\t     tuple<_Args...>>\n+    {\n+      static constexpr _Array_type\n+      _S_apply()\n+      {\n+\t_Array_type __vtable{};\n+\t_S_apply_all_alts(\n+\t  __vtable, make_index_sequence<variant_size_v<decay_t<_First>>>());\n+\treturn __vtable;\n+      }\n+\n+      template<size_t... __indices>\n+\tstatic constexpr void\n+\t_S_apply_all_alts(_Array_type& __vtable, index_sequence<__indices...>)\n+\t{ (_S_apply_single_alt<__indices>(__vtable._M_arr[__indices]), ...); }\n+\n+      template<size_t __index>\n+\tstatic constexpr void\n+\t_S_apply_single_alt(auto& __element)\n+\t{\n+\t  using _Alternative = variant_alternative_t<__index, decay_t<_First>>;\n+\t  using _Qualified_storage = __reserved_type_map<\n+\t    _First, __storage<_Alternative>>;\n+\t  __element = __gen_vtable_impl<\n+\t    decay_t<decltype(__element)>, tuple<_Rest...>,\n+\t    tuple<_Args..., _Qualified_storage>>::_S_apply();\n+\t}\n+    };\n+\n+  template<typename _Result_type, typename _Visitor, typename... _Args>\n+    struct __gen_vtable_impl<\n+      _Multi_array<_Result_type (*)(_Visitor, _To_type<_Args, void*>...)>,\n+\t\t   tuple<>, tuple<_Args...>>\n+    {\n+      using _Array_type =\n+\t_Multi_array<_Result_type (*)(_Visitor&&, _To_type<_Args, void*>...)>;\n+\n+      static constexpr auto\n+      _S_apply()\n+      { return _Array_type{&__visit_invoke<_Visitor, _Args...>}; }\n+    };\n+\n+  template<typename _Result_type, typename _Visitor, typename... _Variants>\n+    struct __gen_vtable\n+    {\n+      using _Func_ptr =\n+\t_Result_type (*)(_Visitor&&, _To_type<_Variants, void*>...);\n+      using _Array_type =\n+\t_Multi_array<_Func_ptr, variant_size_v<decay_t<_Variants>>...>;\n+\n+      static constexpr _Array_type\n+      _S_apply()\n+      {\n+\treturn __gen_vtable_impl<\n+\t  _Array_type, tuple<_Variants...>, tuple<>>::_S_apply();\n+      }\n+    };\n+\n+} // namespace __variant\n+} // namespace __detail\n+\n+  template<typename _Tp, typename... _Types>\n+    inline constexpr bool holds_alternative(const variant<_Types...>& __v)\n+    noexcept\n+    {\n+      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n+\t\t    \"T should occur for exactly once in alternatives\");\n+      return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;\n+    }\n+\n+  template<size_t _Np, typename... _Types>\n+    variant_alternative_t<_Np, variant<_Types...>>&\n+    get(variant<_Types...>&);\n+\n+  template<size_t _Np, typename... _Types>\n+    variant_alternative_t<_Np, variant<_Types...>>&&\n+    get(variant<_Types...>&&);\n+\n+  template<size_t _Np, typename... _Types>\n+    variant_alternative_t<_Np, variant<_Types...>> const&\n+    get(const variant<_Types...>&);\n+\n+  template<size_t _Np, typename... _Types>\n+    variant_alternative_t<_Np, variant<_Types...>> const&&\n+    get(const variant<_Types...>&&);\n+\n+  template<typename _Tp, typename... _Types>\n+    inline _Tp& get(variant<_Types...>& __v)\n+    {\n+      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n+\t\t    \"T should occur for exactly once in alternatives\");\n+      static_assert(!is_void_v<_Tp>, \"_Tp should not be void\");\n+      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);\n+    }\n+\n+  template<typename _Tp, typename... _Types>\n+    inline _Tp&& get(variant<_Types...>&& __v)\n+    {\n+      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n+\t\t    \"T should occur for exactly once in alternatives\");\n+      static_assert(!is_void_v<_Tp>, \"_Tp should not be void\");\n+      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(\n+\tstd::move(__v));\n+    }\n+\n+  template<typename _Tp, typename... _Types>\n+    inline const _Tp& get(const variant<_Types...>& __v)\n+    {\n+      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n+\t\t    \"T should occur for exactly once in alternatives\");\n+      static_assert(!is_void_v<_Tp>, \"_Tp should not be void\");\n+      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);\n+    }\n+\n+  template<typename _Tp, typename... _Types>\n+    inline const _Tp&& get(const variant<_Types...>&& __v)\n+    {\n+      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n+\t\t    \"T should occur for exactly once in alternatives\");\n+      static_assert(!is_void_v<_Tp>, \"_Tp should not be void\");\n+      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(\n+\tstd::move(__v));\n+    }\n+\n+  template<size_t _Np, typename... _Types>\n+    inline add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>\n+    get_if(variant<_Types...>* __ptr) noexcept\n+    {\n+      using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;\n+      static_assert(_Np < sizeof...(_Types),\n+\t\t    \"The index should be in [0, number of alternatives)\");\n+      static_assert(!is_void_v<_Alternative_type>, \"_Tp should not be void\");\n+      if (__ptr && __ptr->index() == _Np)\n+\treturn &__detail::__variant::__access<_Alternative_type>(*__ptr);\n+      return nullptr;\n+    }\n+\n+  template<size_t _Np, typename... _Types>\n+    inline add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>\n+    get_if(const variant<_Types...>* __ptr) noexcept\n+    {\n+      using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;\n+      static_assert(_Np < sizeof...(_Types),\n+\t\t    \"The index should be in [0, number of alternatives)\");\n+      static_assert(!is_void_v<_Alternative_type>, \"_Tp should not be void\");\n+      if (__ptr && __ptr->index() == _Np)\n+\treturn &__detail::__variant::__access<_Alternative_type>(*__ptr);\n+      return nullptr;\n+    }\n+\n+  template<typename _Tp, typename... _Types>\n+    inline add_pointer_t<_Tp> get_if(variant<_Types...>* __ptr) noexcept\n+    {\n+      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n+\t\t    \"T should occur for exactly once in alternatives\");\n+      static_assert(!is_void_v<_Tp>, \"_Tp should not be void\");\n+      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);\n+    }\n+\n+  template<typename _Tp, typename... _Types>\n+    inline add_pointer_t<const _Tp> get_if(const variant<_Types...>* __ptr)\n+    noexcept\n+    {\n+      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n+\t\t    \"T should occur for exactly once in alternatives\");\n+      static_assert(!is_void_v<_Tp>, \"_Tp should not be void\");\n+      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);\n+    }\n+\n+  template<typename... _Types>\n+    bool operator==(const variant<_Types...>& __lhs,\n+\t\t    const variant<_Types...>& __rhs)\n+    {\n+      if (__lhs.index() != __rhs.index())\n+\treturn false;\n+\n+      if (__lhs.valueless_by_exception())\n+\treturn true;\n+\n+      using __detail::__variant::__storage;\n+      static constexpr bool (*_S_vtable[])(void*, void*) =\n+\t{ &__detail::__variant::__erased_equal_to<\n+\t  const __storage<_Types>&, const __storage<_Types>&>... };\n+      return _S_vtable[__lhs.index()](\n+\t  __detail::__variant::__get_storage(__lhs),\n+\t  __detail::__variant::__get_storage(__rhs));\n+    }\n+\n+  template<typename... _Types>\n+    inline bool\n+    operator!=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n+    { return !(__lhs == __rhs); }\n+\n+  template<typename... _Types>\n+    inline bool\n+    operator<(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n+    {\n+      if (__lhs.index() < __rhs.index())\n+\treturn true;\n+\n+      if (__lhs.index() > __rhs.index())\n+\treturn false;\n+\n+      if (__lhs.valueless_by_exception())\n+\treturn false;\n+\n+      using __detail::__variant::__storage;\n+      static constexpr bool (*_S_vtable[])(void*, void*) =\n+\t{ &__detail::__variant::__erased_less_than<\n+\t    const __storage<_Types>&,\n+\t    const __storage<_Types>&>... };\n+      return _S_vtable[__lhs.index()](\n+\t  __detail::__variant::__get_storage(__lhs),\n+\t  __detail::__variant::__get_storage(__rhs));\n+    }\n+\n+  template<typename... _Types>\n+    inline bool\n+    operator>(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n+    { return __rhs < __lhs; }\n+\n+  template<typename... _Types>\n+    inline bool\n+    operator<=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n+    { return !(__lhs > __rhs); }\n+\n+  template<typename... _Types>\n+    inline bool\n+    operator>=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n+    { return !(__lhs < __rhs); }\n+\n+  template<typename _Visitor, typename... _Variants>\n+    decltype(auto) visit(_Visitor&&, _Variants&&...);\n+\n+  struct monostate { };\n+\n+  constexpr bool operator<(monostate, monostate) noexcept\n+  { return false; }\n+\n+  constexpr bool operator>(monostate, monostate) noexcept\n+  { return false; }\n+\n+  constexpr bool operator<=(monostate, monostate) noexcept\n+  { return true; }\n+\n+  constexpr bool operator>=(monostate, monostate) noexcept\n+  { return true; }\n+\n+  constexpr bool operator==(monostate, monostate) noexcept\n+  { return true; }\n+\n+  constexpr bool operator!=(monostate, monostate) noexcept\n+  { return false; }\n+\n+  template<typename... _Types>\n+    inline auto swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)\n+    noexcept(noexcept(__lhs.swap(__rhs))) -> decltype(__lhs.swap(__rhs))\n+    { __lhs.swap(__rhs); }\n+\n+  class bad_variant_access : public exception\n+  {\n+  public:\n+    bad_variant_access() noexcept : _M_reason(\"Unknown reason\") { }\n+    const char* what() const noexcept override\n+    { return _M_reason; }\n+\n+  private:\n+    bad_variant_access(const char* __reason) : _M_reason(__reason) { }\n+\n+    const char* _M_reason;\n+\n+    friend void __throw_bad_variant_access(const char* __what);\n+  };\n+\n+  inline void\n+  __throw_bad_variant_access(const char* __what)\n+  { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }\n+\n+  template<typename... _Types>\n+    class variant\n+    : private __detail::__variant::_Variant_base<_Types...>,\n+      private _Enable_default_constructor<\n+\tis_default_constructible_v<\n+\t  variant_alternative_t<0, variant<_Types...>>>, variant<_Types...>>,\n+      private _Enable_copy_move<\n+\t__and_<is_copy_constructible<_Types>...>::value,\n+\t__and_<is_copy_constructible<_Types>...,\n+\t       is_move_constructible<_Types>...,\n+\t       is_copy_assignable<_Types>...>::value,\n+\t__and_<is_move_constructible<_Types>...>::value,\n+\t__and_<is_move_constructible<_Types>...,\n+\t       is_move_assignable<_Types>...>::value,\n+\tvariant<_Types...>>\n+    {\n+    private:\n+      using _Base = __detail::__variant::_Variant_base<_Types...>;\n+      using _Default_ctor_enabler =\n+\t_Enable_default_constructor<\n+\t  is_default_constructible_v<\n+\t    variant_alternative_t<0, variant<_Types...>>>, variant<_Types...>>;\n+\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t__exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;\n+\n+      template<typename _Tp>\n+\tstatic constexpr size_t __accepted_index =\n+\t  __detail::__variant::__accepted_index<_Tp&&, variant>::value;\n+\n+      template<size_t _Np, bool = _Np < sizeof...(_Types)>\n+\tstruct __to_type_impl;\n+\n+      template<size_t _Np>\n+\tstruct __to_type_impl<_Np, true>\n+\t{ using type = variant_alternative_t<_Np, variant>; };\n+\n+      template<size_t _Np>\n+\tusing __to_type = typename __to_type_impl<_Np>::type;\n+\n+      template<typename _Tp>\n+\tusing __accepted_type = __to_type<__accepted_index<_Tp>>;\n+\n+      template<typename _Tp>\n+\tusing __storage = __detail::__variant::__storage<_Tp>;\n+\n+      template<typename _Tp>\n+\tstatic constexpr size_t __index_of =\n+\t  __detail::__variant::__index_of_v<_Tp, _Types...>;\n+\n+    public:\n+      constexpr variant()\n+      noexcept(is_nothrow_default_constructible_v<__to_type<0>>) = default;\n+      variant(const variant&) = default;\n+      variant(variant&&)\n+      noexcept(__and_<\n+\tis_nothrow_move_constructible<_Types>...>::value) = default;\n+\n+      template<typename _Tp,\n+\t       typename = enable_if_t<__exactly_once<__accepted_type<_Tp&&>>\n+\t\t\t  && is_constructible_v<__accepted_type<_Tp&&>, _Tp&&>\n+\t\t\t  && !is_same_v<decay_t<_Tp>, variant>>>\n+\tconstexpr\n+\tvariant(_Tp&& __t)\n+\tnoexcept(is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp&&>)\n+\t: variant(in_place<__accepted_index<_Tp&&>>, forward<_Tp>(__t))\n+\t{ __glibcxx_assert(holds_alternative<__accepted_type<_Tp&&>>(*this)); }\n+\n+      template<typename _Tp, typename... _Args,\n+\t       typename = enable_if_t<__exactly_once<_Tp>\n+\t\t\t  && is_constructible_v<_Tp, _Args&&...>>>\n+\tconstexpr explicit\n+\tvariant(in_place_type_t<_Tp>, _Args&&... __args)\n+\t: variant(in_place<__index_of<_Tp>>, forward<_Args>(__args)...)\n+\t{ __glibcxx_assert(holds_alternative<_Tp>(*this)); }\n+\n+      template<typename _Tp, typename _Up, typename... _Args,\n+\t       typename = enable_if_t<__exactly_once<_Tp>\n+\t\t\t  && is_constructible_v<\n+\t\t\t    _Tp, initializer_list<_Up>&, _Args&&...>>>\n+\tconstexpr explicit\n+\tvariant(in_place_type_t<_Tp>, initializer_list<_Up> __il,\n+\t\t_Args&&... __args)\n+\t: variant(in_place<__index_of<_Tp>>, __il,\n+\t\t  forward<_Args>(__args)...)\n+\t{ __glibcxx_assert(holds_alternative<_Tp>(*this)); }\n+\n+      template<size_t _Np, typename... _Args,\n+\t       typename = enable_if_t<\n+\t\t is_constructible_v<__to_type<_Np>, _Args&&...>>>\n+\tconstexpr explicit\n+\tvariant(in_place_index_t<_Np>, _Args&&... __args)\n+\t: _Base(in_place<_Np>, forward<_Args>(__args)...),\n+\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n+\t{ __glibcxx_assert(index() == _Np); }\n+\n+      template<size_t _Np, typename _Up, typename... _Args,\n+\t       typename = enable_if_t<is_constructible_v<__to_type<_Np>,\n+\t\t\t\t      initializer_list<_Up>&, _Args&&...>>>\n+\tconstexpr explicit\n+\tvariant(in_place_index_t<_Np>, initializer_list<_Up> __il,\n+\t\t_Args&&... __args)\n+\t: _Base(in_place<_Np>, __il, forward<_Args>(__args)...),\n+\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n+\t{ __glibcxx_assert(index() == _Np); }\n+\n+      template<typename _Alloc,\n+\t       typename = enable_if_t<\n+\t\t __is_uses_allocator_constructible_v<__to_type<0>, _Alloc>>>\n+\tvariant(allocator_arg_t, const _Alloc& __a)\n+\t: variant(allocator_arg, __a, in_place<0>)\n+\t{ }\n+\n+      template<typename _Alloc,\n+\t       typename = enable_if_t<__and_<__is_uses_allocator_constructible<\n+\t\t _Types, _Alloc,\n+\t\t add_lvalue_reference_t<add_const_t<_Types>>>...>::value>>\n+\tvariant(allocator_arg_t, const _Alloc& __a, const variant& __rhs)\n+\t: _Base(__a, __rhs),\n+\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n+\t{ }\n+\n+      template<typename _Alloc,\n+\t       typename = enable_if_t<__and_<\n+\t\t __is_uses_allocator_constructible<\n+\t\t   _Types, _Alloc, add_rvalue_reference_t<_Types>>...>::value>>\n+\tvariant(allocator_arg_t, const _Alloc& __a, variant&& __rhs)\n+\t: _Base(__a, std::move(__rhs)),\n+\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n+\t{ }\n+\n+      template<typename _Alloc, typename _Tp,\n+\t       typename = enable_if_t<\n+\t\t __exactly_once<__accepted_type<_Tp&&>>\n+\t\t && __is_uses_allocator_constructible_v<\n+\t\t   __accepted_type<_Tp&&>, _Alloc, _Tp&&>\n+\t\t && !is_same_v<decay_t<_Tp>, variant>, variant&>>\n+\tvariant(allocator_arg_t, const _Alloc& __a, _Tp&& __t)\n+\t: variant(allocator_arg, __a, in_place<__accepted_index<_Tp&&>>,\n+\t\t  forward<_Tp>(__t))\n+\t{ __glibcxx_assert(holds_alternative<__accepted_type<_Tp&&>>(*this)); }\n+\n+      template<typename _Alloc, typename _Tp, typename... _Args,\n+\t       typename = enable_if_t<\n+\t\t __exactly_once<_Tp>\n+\t\t && __is_uses_allocator_constructible_v<\n+\t\t   _Tp, _Alloc, _Args&&...>>>\n+\tvariant(allocator_arg_t, const _Alloc& __a, in_place_type_t<_Tp>,\n+\t\t_Args&&... __args)\n+\t: variant(allocator_arg, __a, in_place<__index_of<_Tp>>,\n+\t\t  forward<_Args>(__args)...)\n+\t{ __glibcxx_assert(holds_alternative<_Tp>(*this)); }\n+\n+      template<typename _Alloc, typename _Tp, typename _Up, typename... _Args,\n+\t       typename = enable_if_t<\n+\t\t __exactly_once<_Tp>\n+\t\t && __is_uses_allocator_constructible_v<\n+\t\t   _Tp, _Alloc, initializer_list<_Up>&, _Args&&...>>>\n+\tvariant(allocator_arg_t, const _Alloc& __a, in_place_type_t<_Tp>,\n+\t\tinitializer_list<_Up> __il, _Args&&... __args)\n+\t: variant(allocator_arg, __a, in_place<__index_of<_Tp>>, __il,\n+\t\t  forward<_Args>(__args)...)\n+\t{ __glibcxx_assert(holds_alternative<_Tp>(*this)); }\n+\n+      template<typename _Alloc, size_t _Np, typename... _Args,\n+\t       typename = enable_if_t<\n+\t\t __is_uses_allocator_constructible_v<\n+\t\t   __to_type<_Np>, _Alloc, _Args&&...>>>\n+\tvariant(allocator_arg_t, const _Alloc& __a, in_place_index_t<_Np>,\n+\t\t_Args&&... __args)\n+\t: _Base(__a, in_place<_Np>, forward<_Args>(__args)...),\n+\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n+\t{ __glibcxx_assert(index() == _Np); }\n+\n+      template<typename _Alloc, size_t _Np, typename _Up, typename... _Args,\n+\t       typename = enable_if_t<\n+\t\t __is_uses_allocator_constructible_v<\n+\t\t   __to_type<_Np>, _Alloc, initializer_list<_Up>&, _Args&&...>>>\n+\tvariant(allocator_arg_t, const _Alloc& __a, in_place_index_t<_Np>,\n+\t\tinitializer_list<_Up> __il, _Args&&... __args)\n+\t: _Base(__a, in_place<_Np>, __il, forward<_Args>(__args)...),\n+\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n+\t{ __glibcxx_assert(index() == _Np); }\n+\n+      ~variant() = default;\n+\n+      variant& operator=(const variant&) = default;\n+      variant& operator=(variant&&)\n+      noexcept(__and_<is_nothrow_move_constructible<_Types>...,\n+\t\t      is_nothrow_move_assignable<_Types>...>::value) = default;\n+\n+      template<typename _Tp>\n+\tenable_if_t<__exactly_once<__accepted_type<_Tp&&>>\n+\t\t    && is_constructible_v<__accepted_type<_Tp&&>, _Tp&&>\n+\t\t    && is_assignable_v<__accepted_type<_Tp&&>&, _Tp&&>\n+\t\t    && !is_same_v<decay_t<_Tp>, variant>, variant&>\n+\toperator=(_Tp&& __rhs)\n+\tnoexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp&&>\n+\t\t && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp&&>)\n+\t{\n+\t  constexpr auto __index = __accepted_index<_Tp&&>;\n+\t  if (index() == __index)\n+\t    *static_cast<__storage<__to_type<__index>>*>(this->_M_storage())\n+\t      = forward<_Tp>(__rhs);\n+\t  else\n+\t    this->emplace<__index>(forward<_Tp>(__rhs));\n+\t  __glibcxx_assert(holds_alternative<__accepted_type<_Tp&&>>(*this));\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp, typename... _Args>\n+\tvoid emplace(_Args&&... __args)\n+\t{\n+\t  static_assert(__exactly_once<_Tp>,\n+\t\t\t\"T should occur for exactly once in alternatives\");\n+\t  this->emplace<__index_of<_Tp>>(forward<_Args>(__args)...);\n+\t  __glibcxx_assert(holds_alternative<_Tp>(*this));\n+\t}\n+\n+      template<typename _Tp, typename _Up, typename... _Args>\n+\tvoid emplace(initializer_list<_Up> __il, _Args&&... __args)\n+\t{\n+\t  static_assert(__exactly_once<_Tp>,\n+\t\t\t\"T should occur for exactly once in alternatives\");\n+\t  this->emplace<__index_of<_Tp>>(__il, forward<_Args>(__args)...);\n+\t  __glibcxx_assert(holds_alternative<_Tp>(*this));\n+\t}\n+\n+      template<size_t _Np, typename... _Args>\n+\tvoid emplace(_Args&&... __args)\n+\t{\n+\t  static_assert(_Np < sizeof...(_Types),\n+\t\t\t\"The index should be in [0, number of alternatives)\");\n+\t  this->~variant();\n+\t  __try\n+\t    {\n+\t      ::new (this) variant(in_place<_Np>,\n+\t\t\t\t   forward<_Args>(__args)...);\n+\t    }\n+\t  __catch (...)\n+\t    {\n+\t      this->_M_index = variant_npos;\n+\t      __throw_exception_again;\n+\t    }\n+\t  __glibcxx_assert(index() == _Np);\n+\t}\n+\n+      template<size_t _Np, typename _Up, typename... _Args>\n+\tvoid emplace(initializer_list<_Up> __il, _Args&&... __args)\n+\t{\n+\t  static_assert(_Np < sizeof...(_Types),\n+\t\t\t\"The index should be in [0, number of alternatives)\");\n+\t  this->~variant();\n+\t  __try\n+\t    {\n+\t      ::new (this) variant(in_place<_Np>, __il,\n+\t\t\t\t   forward<_Args>(__args)...);\n+\t    }\n+\t  __catch (...)\n+\t    {\n+\t      this->_M_index = variant_npos;\n+\t      __throw_exception_again;\n+\t    }\n+\t  __glibcxx_assert(index() == _Np);\n+\t}\n+\n+      constexpr bool valueless_by_exception() const noexcept\n+      { return !this->_M_valid(); }\n+\n+      constexpr size_t index() const noexcept\n+      { return this->_M_index; }\n+\n+      void\n+      swap(variant& __rhs)\n+      noexcept(__and_<__is_nothrow_swappable<_Types>...>::value\n+\t       && is_nothrow_move_assignable_v<variant>)\n+      {\n+\tif (this->index() == __rhs.index())\n+\t  {\n+\t    if (this->_M_valid())\n+\t      {\n+\t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n+\t\t  { &__detail::__variant::__erased_swap<\n+\t\t      __storage<_Types>&, __storage<_Types>&>... };\n+\t\t_S_vtable[__rhs._M_index](this->_M_storage(),\n+\t\t\t\t\t  __rhs._M_storage());\n+\t      }\n+\t  }\n+\telse if (!this->_M_valid())\n+\t  {\n+\t    *this = std::move(__rhs);\n+\t  }\n+\telse if (!__rhs._M_valid())\n+\t  {\n+\t    __rhs = std::move(*this);\n+\t  }\n+\telse\n+\t  {\n+\t    auto __tmp = std::move(__rhs);\n+\t    __rhs = std::move(*this);\n+\t    *this = std::move(__tmp);\n+\t  }\n+      }\n+\n+      template<typename _Vp>\n+\tfriend void* __detail::__variant::__get_storage(_Vp&& __v);\n+    };\n+\n+  // To honor algebraic data type, variant<> should be a bottom type, which\n+  // is 0 (as opposed to a void type, which is 1). Use incomplete type to model\n+  // bottom type.\n+  template<> class variant<>;\n+\n+  template<size_t _Np, typename... _Types>\n+    variant_alternative_t<_Np, variant<_Types...>>&\n+    get(variant<_Types...>& __v)\n+    {\n+      static_assert(_Np < sizeof...(_Types),\n+\t\t    \"The index should be in [0, number of alternatives)\");\n+      if (__v.index() != _Np)\n+\t__throw_bad_variant_access(\"Unexpected index\");\n+      return __detail::__variant::__access<\n+\tvariant_alternative_t<_Np, variant<_Types...>>>(__v);\n+    }\n+\n+  template<size_t _Np, typename... _Types>\n+    variant_alternative_t<_Np, variant<_Types...>>&&\n+    get(variant<_Types...>&& __v)\n+    {\n+      static_assert(_Np < sizeof...(_Types),\n+\t\t    \"The index should be in [0, number of alternatives)\");\n+      if (__v.index() != _Np)\n+\t__throw_bad_variant_access(\"Unexpected index\");\n+      return __detail::__variant::__access<\n+\tvariant_alternative_t<_Np, variant<_Types...>>>(std::move(__v));\n+    }\n+\n+  template<size_t _Np, typename... _Types>\n+    const variant_alternative_t<_Np, variant<_Types...>>&\n+    get(const variant<_Types...>& __v)\n+    {\n+      static_assert(_Np < sizeof...(_Types),\n+\t\t    \"The index should be in [0, number of alternatives)\");\n+      if (__v.index() != _Np)\n+\t__throw_bad_variant_access(\"Unexpected index\");\n+      return __detail::__variant::__access<\n+\tvariant_alternative_t<_Np, variant<_Types...>>>(__v);\n+    }\n+\n+  template<size_t _Np, typename... _Types>\n+    const variant_alternative_t<_Np, variant<_Types...>>&&\n+    get(const variant<_Types...>&& __v)\n+    {\n+      static_assert(_Np < sizeof...(_Types),\n+\t\t    \"The index should be in [0, number of alternatives)\");\n+      if (__v.index() != _Np)\n+\t__throw_bad_variant_access(\"Unexpected index\");\n+      return __detail::__variant::__access<\n+\tvariant_alternative_t<_Np, variant<_Types...>>>(std::move(__v));\n+    }\n+\n+  template<typename _Visitor, typename... _Variants>\n+    decltype(auto)\n+    visit(_Visitor&& __visitor, _Variants&&... __variants)\n+    {\n+      using _Result_type =\n+\tdecltype(forward<_Visitor>(__visitor)(get<0>(__variants)...));\n+      static constexpr auto _S_vtable =\n+\t__detail::__variant::__gen_vtable<\n+\t  _Result_type, _Visitor&&, _Variants&&...>::_S_apply();\n+      auto __func_ptr = _S_vtable._M_access(__variants.index()...);\n+      return (*__func_ptr)(forward<_Visitor>(__visitor),\n+\t\t\t   __detail::__variant::__get_storage(__variants)...);\n+    }\n+\n+  template<typename... _Types, typename _Alloc>\n+    struct uses_allocator<variant<_Types...>, _Alloc>\n+    : true_type { };\n+\n+  template<typename... _Types>\n+    struct hash<variant<_Types...>>\n+    {\n+      using result_type = size_t;\n+      using argument_type = variant<_Types...>;\n+\n+      size_t\n+      operator()(const variant<_Types...>& __t) const\n+      noexcept((... && noexcept(hash<decay_t<_Types>>{}(std::declval<_Types>()))))\n+      {\n+\tif (!__t.valueless_by_exception())\n+\t  {\n+\t    namespace __edv = __detail::__variant;\n+\t    static constexpr size_t (*_S_vtable[])(void*) =\n+\t      { &__edv::__erased_hash<const __edv::__storage<_Types>&>... };\n+\t    return hash<size_t>{}(__t.index())\n+\t      + _S_vtable[__t.index()](__edv::__get_storage(__t));\n+\t  }\n+\treturn hash<size_t>{}(__t.index());\n+      }\n+    };\n+\n+  template<>\n+    struct hash<monostate>\n+    {\n+      using result_type = size_t;\n+      using argument_type = monostate;\n+\n+      size_t\n+      operator()(const monostate& __t) const noexcept\n+      {\n+\tconstexpr size_t __magic_monostate_hash = -7777;\n+\treturn __magic_monostate_hash;\n+      }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+\n+#endif // _GLIBCXX_VARIANT"}, {"sha": "b57d356d3016fa7c4b3f43adc33ff557398bc9fa", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -0,0 +1,405 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <variant>\n+#include <string>\n+#include <vector>\n+\n+using namespace std;\n+\n+struct AllDeleted\n+{\n+  AllDeleted() = delete;\n+  AllDeleted(const AllDeleted&) = delete;\n+  AllDeleted(AllDeleted&&) = delete;\n+  AllDeleted& operator=(const AllDeleted&) = delete;\n+  AllDeleted& operator=(AllDeleted&&) = delete;\n+};\n+\n+struct Empty\n+{\n+  Empty() { };\n+  Empty(const Empty&) { };\n+  Empty(Empty&&) { };\n+  Empty& operator=(const Empty&) { return *this; };\n+  Empty& operator=(Empty&&) { return *this; };\n+};\n+\n+struct DefaultNoexcept\n+{\n+  DefaultNoexcept() noexcept = default;\n+  DefaultNoexcept(const DefaultNoexcept&) noexcept = default;\n+  DefaultNoexcept(DefaultNoexcept&&) noexcept = default;\n+  DefaultNoexcept& operator=(const DefaultNoexcept&) noexcept = default;\n+  DefaultNoexcept& operator=(DefaultNoexcept&&) noexcept = default;\n+};\n+\n+void default_ctor()\n+{\n+  static_assert(is_default_constructible_v<variant<int, string>>, \"\");\n+  static_assert(is_default_constructible_v<variant<string, string>>, \"\");\n+  static_assert(!is_default_constructible_v<variant<>>, \"\");\n+  static_assert(!is_default_constructible_v<variant<AllDeleted, string>>, \"\");\n+  static_assert(is_default_constructible_v<variant<string, AllDeleted>>, \"\");\n+\n+  static_assert(noexcept(variant<int>()), \"\");\n+  static_assert(!noexcept(variant<Empty>()), \"\");\n+  static_assert(noexcept(variant<DefaultNoexcept>()), \"\");\n+}\n+\n+void copy_ctor()\n+{\n+  static_assert(is_copy_constructible_v<variant<int, string>>, \"\");\n+  static_assert(!is_copy_constructible_v<variant<AllDeleted, string>>, \"\");\n+\n+  {\n+    variant<int> a;\n+    static_assert(!noexcept(variant<int>(a)), \"\");\n+  }\n+  {\n+    variant<string> a;\n+    static_assert(!noexcept(variant<string>(a)), \"\");\n+  }\n+  {\n+    variant<int, string> a;\n+    static_assert(!noexcept(variant<int, string>(a)), \"\");\n+  }\n+  {\n+    variant<int, char> a;\n+    static_assert(!noexcept(variant<int, char>(a)), \"\");\n+  }\n+}\n+\n+void move_ctor()\n+{\n+  static_assert(is_move_constructible_v<variant<int, string>>, \"\");\n+  static_assert(!is_move_constructible_v<variant<AllDeleted, string>>, \"\");\n+  static_assert(!noexcept(variant<int, Empty>(variant<int, Empty>())), \"\");\n+  static_assert(noexcept(variant<int, DefaultNoexcept>(variant<int, DefaultNoexcept>())), \"\");\n+}\n+\n+void arbitrary_ctor()\n+{\n+  static_assert(!is_constructible_v<variant<string, string>, const char*>, \"\");\n+  static_assert(is_constructible_v<variant<int, string>, const char*>, \"\");\n+  static_assert(noexcept(variant<int, Empty>(int{})), \"\");\n+  static_assert(noexcept(variant<int, DefaultNoexcept>(int{})), \"\");\n+  static_assert(!noexcept(variant<int, Empty>(Empty{})), \"\");\n+  static_assert(noexcept(variant<int, DefaultNoexcept>(DefaultNoexcept{})), \"\");\n+}\n+\n+void in_place_index_ctor()\n+{\n+  variant<string, string> a(in_place<0>, \"a\");\n+  variant<string, string> b(in_place<1>, {'a'});\n+}\n+\n+void in_place_type_ctor()\n+{\n+  variant<int, string, int> a(in_place<string>, \"a\");\n+  variant<int, string, int> b(in_place<string>, {'a'});\n+  static_assert(!is_constructible_v<variant<string, string>, in_place_type_t<string>, const char*>, \"\");\n+}\n+\n+void uses_alloc_ctors()\n+{\n+  std::allocator<char> alloc;\n+  variant<int> a(allocator_arg, alloc);\n+  static_assert(!is_constructible_v<variant<AllDeleted>, allocator_arg_t, std::allocator<char>>, \"\");\n+  {\n+    variant<int> b(allocator_arg, alloc, a);\n+    static_assert(!is_constructible_v<variant<void>, allocator_arg_t, std::allocator<char>, const variant<void>&>, \"\");\n+  }\n+  {\n+    variant<int> b(allocator_arg, alloc, std::move(a));\n+    static_assert(!is_constructible_v<variant<void>, allocator_arg_t, std::allocator<char>, variant<void>&&>, \"\");\n+  }\n+  {\n+    variant<string, int> b(allocator_arg, alloc, \"a\");\n+    static_assert(!is_constructible_v<variant<string, string>, allocator_arg_t, std::allocator<char>, const char*>, \"\");\n+  }\n+  {\n+    variant<string, int> b(allocator_arg, alloc, in_place<0>, \"a\");\n+    variant<string, string> c(allocator_arg, alloc, in_place<1>, \"a\");\n+  }\n+  {\n+    variant<string, int> b(allocator_arg, alloc, in_place<0>, {'a'});\n+    variant<string, string> c(allocator_arg, alloc, in_place<1>, {'a'});\n+  }\n+  {\n+    variant<int, string, int> b(allocator_arg, alloc, in_place<string>, \"a\");\n+  }\n+  {\n+    variant<int, string, int> b(allocator_arg, alloc, in_place<string>, {'a'});\n+  }\n+}\n+\n+void dtor()\n+{\n+  static_assert(is_destructible_v<variant<int, string>>, \"\");\n+  static_assert(is_destructible_v<variant<AllDeleted, string>>, \"\");\n+}\n+\n+void copy_assign()\n+{\n+  static_assert(is_copy_assignable_v<variant<int, string>>, \"\");\n+  static_assert(!is_copy_assignable_v<variant<AllDeleted, string>>, \"\");\n+  {\n+    variant<Empty> a;\n+    static_assert(!noexcept(a = a), \"\");\n+  }\n+  {\n+    variant<DefaultNoexcept> a;\n+    static_assert(!noexcept(a = a), \"\");\n+  }\n+}\n+\n+void move_assign()\n+{\n+  static_assert(is_move_assignable_v<variant<int, string>>, \"\");\n+  static_assert(!is_move_assignable_v<variant<AllDeleted, string>>, \"\");\n+  {\n+    variant<Empty> a;\n+    static_assert(!noexcept(a = std::move(a)), \"\");\n+  }\n+  {\n+    variant<DefaultNoexcept> a;\n+    static_assert(noexcept(a = std::move(a)), \"\");\n+  }\n+}\n+\n+void arbitrary_assign()\n+{\n+  static_assert(!is_assignable_v<variant<string, string>, const char*>, \"\");\n+  static_assert(is_assignable_v<variant<int, string>, const char*>, \"\");\n+  static_assert(noexcept(variant<int, Empty>() = int{}), \"\");\n+  static_assert(noexcept(variant<int, DefaultNoexcept>() = int{}), \"\");\n+  static_assert(!noexcept(variant<int, Empty>() = Empty{}), \"\");\n+  static_assert(noexcept(variant<int, DefaultNoexcept>() = DefaultNoexcept{}), \"\");\n+}\n+\n+void test_get()\n+{\n+  {\n+    static_assert(is_same<decltype(get<0>(variant<int, string>())), int&&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(variant<int, string>())), string&&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(variant<int, string&>())), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(variant<int, string&&>())), string&&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(variant<int, const string>())), const string&&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(variant<int, const string&>())), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(variant<int, const string&&>())), const string&&>::value, \"\");\n+\n+    static_assert(is_same<decltype(get<int>(variant<int, string>())), int&&>::value, \"\");\n+    static_assert(is_same<decltype(get<string>(variant<int, string>())), string&&>::value, \"\");\n+    static_assert(is_same<decltype(get<string&>(variant<int, string&>())), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<string&&>(variant<int, string&&>())), string&&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string>(variant<int, const string>())), const string&&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string&>(variant<int, const string&>())), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string&&>(variant<int, const string&&>())), const string&&>::value, \"\");\n+  }\n+  {\n+    variant<int, string> a;\n+    variant<int, string&> b;\n+    variant<int, string&&> c;\n+    variant<int, const string> d;\n+    variant<int, const string&> e;\n+    variant<int, const string&&> f;\n+\n+    static_assert(is_same<decltype(get<0>(a)), int&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(a)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(b)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(c)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(e)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(e)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(f)), const string&>::value, \"\");\n+\n+    static_assert(is_same<decltype(get<int>(a)), int&>::value, \"\");\n+    static_assert(is_same<decltype(get<string>(a)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<string&>(b)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<string&&>(c)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string>(e)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string&>(e)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string&&>(f)), const string&>::value, \"\");\n+\n+    static_assert(is_same<decltype(get_if<0>(&a)), int*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&a)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&b)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&c)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&e)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&e)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&f)), const string*>::value, \"\");\n+\n+    static_assert(is_same<decltype(get_if<int>(&a)), int*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<string>(&a)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<string&>(&b)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<string&&>(&c)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<const string>(&e)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<const string&>(&e)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<const string&&>(&f)), const string*>::value, \"\");\n+  }\n+  {\n+    const variant<int, string> a;\n+    const variant<int, string&> b;\n+    const variant<int, string&&> c;\n+    const variant<int, const string> d;\n+    const variant<int, const string&> e;\n+    const variant<int, const string&&> f;\n+\n+    static_assert(is_same<decltype(get<0>(a)), const int&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(a)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(b)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(c)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(d)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(e)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<1>(f)), const string&>::value, \"\");\n+\n+    static_assert(is_same<decltype(get<int>(a)), const int&>::value, \"\");\n+    static_assert(is_same<decltype(get<string>(a)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<string&>(b)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<string&&>(c)), string&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string>(d)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string&>(e)), const string&>::value, \"\");\n+    static_assert(is_same<decltype(get<const string&&>(f)), const string&>::value, \"\");\n+\n+    static_assert(is_same<decltype(get_if<0>(&a)), const int*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&a)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&b)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&c)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&d)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&e)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<1>(&f)), const string*>::value, \"\");\n+\n+    static_assert(is_same<decltype(get_if<int>(&a)), const int*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<string>(&a)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<string&>(&b)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<string&&>(&c)), string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<const string>(&d)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<const string&>(&e)), const string*>::value, \"\");\n+    static_assert(is_same<decltype(get_if<const string&&>(&f)), const string*>::value, \"\");\n+  }\n+}\n+\n+void test_relational()\n+{\n+  {\n+    const variant<int, string> a, b;\n+    (void)(a < b);\n+    (void)(a > b);\n+    (void)(a <= b);\n+    (void)(a == b);\n+    (void)(a != b);\n+    (void)(a >= b);\n+  }\n+  {\n+    const monostate a, b;\n+    (void)(a < b);\n+    (void)(a > b);\n+    (void)(a <= b);\n+    (void)(a == b);\n+    (void)(a != b);\n+    (void)(a >= b);\n+  }\n+}\n+\n+void test_swap()\n+{\n+  variant<int, string> a, b;\n+  a.swap(b);\n+  swap(a, b);\n+}\n+\n+void test_visit()\n+{\n+  {\n+    struct Visitor\n+    {\n+      void operator()(monostate) {}\n+      void operator()(const int&) {}\n+    };\n+    struct CVisitor\n+    {\n+      void operator()(monostate) const {}\n+      void operator()(const int&) const {}\n+    };\n+    variant<monostate, int&, const int&, int&&, const int&&> a;\n+    const variant<monostate, int&, const int&, int&&, const int&&> b;\n+    Visitor v;\n+    const CVisitor u;\n+    static_assert(is_same<void, decltype(visit(Visitor(), a))>::value, \"\");\n+    static_assert(is_same<void, decltype(visit(Visitor(), b))>::value, \"\");\n+    static_assert(is_same<void, decltype(visit(v, a))>::value, \"\");\n+    static_assert(is_same<void, decltype(visit(v, b))>::value, \"\");\n+    static_assert(is_same<void, decltype(visit(u, a))>::value, \"\");\n+    static_assert(is_same<void, decltype(visit(u, b))>::value, \"\");\n+  }\n+  {\n+    struct Visitor\n+    {\n+      bool operator()(int, float) { return false; }\n+      bool operator()(int, double) { return false; }\n+      bool operator()(char, float) { return false; }\n+      bool operator()(char, double) { return false; }\n+    };\n+    visit(Visitor(), variant<int, char>(), variant<float, double>());\n+  }\n+}\n+\n+void test_constexpr()\n+{\n+  constexpr variant<int> a;\n+  static_assert(holds_alternative<int>(a), \"\");\n+  constexpr variant<int, char> b(in_place<0>, int{});\n+  static_assert(holds_alternative<int>(b), \"\");\n+  constexpr variant<int, char> c(in_place<int>, int{});\n+  static_assert(holds_alternative<int>(c), \"\");\n+  constexpr variant<int, char> d(in_place<1>, char{});\n+  static_assert(holds_alternative<char>(d), \"\");\n+  constexpr variant<int, char> e(in_place<char>, char{});\n+  static_assert(holds_alternative<char>(e), \"\");\n+  constexpr variant<int, char> f(char{});\n+  static_assert(holds_alternative<char>(f), \"\");\n+\n+  {\n+    struct literal {\n+\tconstexpr literal() = default;\n+    };\n+\n+    struct nonliteral {\n+\tnonliteral() { }\n+    };\n+\n+    constexpr variant<literal, nonliteral> v{};\n+    constexpr variant<literal, nonliteral> v1{in_place<literal>};\n+    constexpr variant<literal, nonliteral> v2{in_place<0>};\n+  }\n+}\n+\n+void test_void()\n+{\n+  static_assert(is_same<int&&, decltype(get<int>(variant<int, void>()))>::value, \"\");\n+  static_assert(!is_default_constructible_v<variant<void, int>>, \"\");\n+  static_assert(!is_copy_constructible_v<variant<int, void>>, \"\");\n+  static_assert(!is_move_constructible_v<variant<int, void>>, \"\");\n+  static_assert(!is_copy_assignable_v<variant<int, void>>, \"\");\n+  static_assert(!is_move_assignable_v<variant<int, void>>, \"\");\n+  variant<int, void, string> v;\n+  v = 3;\n+  v = \"asdf\";\n+}"}, {"sha": "cbe3b17fd7a342b328f577418899d61519904d49", "filename": "libstdc++-v3/testsuite/20_util/variant/run.cc", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197c757cb11681a6ff6df1491ebfde4f5a392627/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc?ref=197c757cb11681a6ff6df1491ebfde4f5a392627", "patch": "@@ -0,0 +1,501 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <variant>\n+#include <string>\n+#include <vector>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+struct AlwaysThrow\n+{\n+  AlwaysThrow() = default;\n+\n+  AlwaysThrow(const AlwaysThrow&)\n+  { throw nullptr; }\n+\n+  AlwaysThrow(AlwaysThrow&&)\n+  { throw nullptr; }\n+\n+  AlwaysThrow& operator=(const AlwaysThrow&)\n+  {\n+    throw nullptr;\n+    return *this;\n+  }\n+\n+  AlwaysThrow& operator=(AlwaysThrow&&)\n+  {\n+    throw nullptr;\n+    return *this;\n+  }\n+};\n+\n+void default_ctor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<monostate, string> v;\n+  VERIFY(holds_alternative<monostate>(v));\n+}\n+\n+void copy_ctor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<monostate, string> v(\"a\");\n+  VERIFY(holds_alternative<string>(v));\n+  variant<monostate, string> u(v);\n+  VERIFY(holds_alternative<string>(u));\n+  VERIFY(get<string>(u) == \"a\");\n+}\n+\n+void move_ctor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<monostate, string> v(\"a\");\n+  VERIFY(holds_alternative<string>(v));\n+  variant<monostate, string> u(std::move(v));\n+  VERIFY(holds_alternative<string>(u));\n+  VERIFY(get<string>(u) == \"a\");\n+  VERIFY(holds_alternative<string>(v));\n+}\n+\n+void arbitrary_ctor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<int, string> v(\"a\");\n+  VERIFY(holds_alternative<string>(v));\n+  VERIFY(get<1>(v) == \"a\");\n+}\n+\n+void copy_assign()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<monostate, string> v(\"a\");\n+  VERIFY(holds_alternative<string>(v));\n+  variant<monostate, string> u;\n+  u = v;\n+  VERIFY(holds_alternative<string>(u));\n+  VERIFY(get<string>(u) == \"a\");\n+}\n+\n+void move_assign()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<monostate, string> v(\"a\");\n+  VERIFY(holds_alternative<string>(v));\n+  variant<monostate, string> u;\n+  u = std::move(v);\n+  VERIFY(holds_alternative<string>(u));\n+  VERIFY(get<string>(u) == \"a\");\n+  VERIFY(holds_alternative<string>(v));\n+}\n+\n+void arbitrary_assign()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<int, string> v;\n+  v = \"a\";\n+\n+  VERIFY(holds_alternative<string>(variant<int, string>(\"a\")));\n+  VERIFY(get<1>(v) == \"a\");\n+}\n+\n+void dtor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  struct A {\n+      A(int& called) : called(called) {}\n+      ~A() {\n+\t  called++;\n+      }\n+      int& called;\n+  };\n+  {\n+    int called = 0;\n+    { variant<string, A> a(in_place<1>, called); }\n+    VERIFY(called == 1);\n+  }\n+  {\n+    int called = 0;\n+    { variant<string, A> a(in_place<0>); }\n+    VERIFY(called == 0);\n+  }\n+}\n+\n+void in_place_index_ctor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  {\n+    variant<int, string> v(in_place<1>, \"a\");\n+    VERIFY(holds_alternative<string>(v));\n+    VERIFY(get<1>(v) == \"a\");\n+  }\n+  {\n+    variant<int, string> v(in_place<1>, {'a', 'b'});\n+    VERIFY(holds_alternative<string>(v));\n+    VERIFY(get<1>(v) == \"ab\");\n+  }\n+}\n+\n+void in_place_type_ctor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  {\n+    variant<int, string> v(in_place<string>, \"a\");\n+    VERIFY(holds_alternative<string>(v));\n+    VERIFY(get<1>(v) == \"a\");\n+  }\n+  {\n+    variant<int, string> v(in_place<string>, {'a', 'b'});\n+    VERIFY(holds_alternative<string>(v));\n+    VERIFY(get<1>(v) == \"ab\");\n+  }\n+}\n+\n+struct UsesAllocatable\n+{\n+  template<typename Alloc>\n+    UsesAllocatable(std::allocator_arg_t, const Alloc& a)\n+    : d(0), a(static_cast<const void*>(&a)) { }\n+\n+  template<typename Alloc>\n+    UsesAllocatable(std::allocator_arg_t, const Alloc& a, const UsesAllocatable&)\n+    : d(1), a(static_cast<const void*>(&a)) { }\n+\n+  template<typename Alloc>\n+    UsesAllocatable(std::allocator_arg_t, const Alloc& a, UsesAllocatable&&)\n+    : d(2), a(static_cast<const void*>(&a)) { }\n+\n+  int d;\n+  const void* a;\n+};\n+\n+namespace std\n+{\n+  template<>\n+    struct uses_allocator<UsesAllocatable, std::allocator<char>> : true_type { };\n+}\n+\n+void uses_allocator_ctor()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  std::allocator<char> a;\n+  variant<UsesAllocatable> v(std::allocator_arg, a);\n+  VERIFY(get<0>(v).d == 0);\n+  VERIFY(get<0>(v).a == &a);\n+  {\n+    variant<UsesAllocatable> u(std::allocator_arg, a, v);\n+    VERIFY(get<0>(u).d == 1);\n+    VERIFY(get<0>(u).a == &a);\n+  }\n+  {\n+    variant<UsesAllocatable> u(std::allocator_arg, a, std::move(v));\n+    VERIFY(get<0>(u).d == 2);\n+    VERIFY(get<0>(u).a == &a);\n+  }\n+}\n+\n+void emplace()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<int, string> v;\n+  v.emplace<0>(1);\n+  VERIFY(get<0>(v) == 1);\n+  v.emplace<string>(\"a\");\n+  VERIFY(get<string>(v) == \"a\");\n+  v.emplace<1>({'a', 'b'});\n+  VERIFY(get<1>(v) == \"ab\");\n+  v.emplace<string>({'a', 'c'});\n+  VERIFY(get<string>(v) == \"ac\");\n+  {\n+    variant<int, AlwaysThrow> v;\n+    AlwaysThrow a;\n+    try { v.emplace<1>(a); } catch (nullptr_t) { }\n+    VERIFY(v.valueless_by_exception());\n+  }\n+  {\n+    variant<int, AlwaysThrow> v;\n+    try { v.emplace<1>(AlwaysThrow{}); } catch (nullptr_t) { }\n+    VERIFY(v.valueless_by_exception());\n+  }\n+}\n+\n+void test_get()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  VERIFY(get<1>(variant<int, string>(\"a\")) == \"a\");\n+  VERIFY(get<string>(variant<int, string>(\"a\")) == \"a\");\n+  {\n+    bool caught = false;\n+\n+    try\n+      {\n+\tget<0>(variant<int, string>(\"a\"));\n+      }\n+    catch (const bad_variant_access&)\n+      {\n+\tcaught = true;\n+      }\n+    VERIFY(caught);\n+  }\n+  {\n+    bool caught = false;\n+\n+    try\n+      {\n+\tget<int>(variant<int, string>(\"a\"));\n+      }\n+    catch (const bad_variant_access&)\n+      {\n+\tcaught = true;\n+      }\n+    VERIFY(caught);\n+  }\n+}\n+\n+void test_relational()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  VERIFY((variant<int, string>(2) < variant<int, string>(3)));\n+  VERIFY((variant<int, string>(3) == variant<int, string>(3)));\n+  VERIFY((variant<int, string>(3) > variant<int, string>(2)));\n+  VERIFY((variant<int, string>(3) <= variant<int, string>(3)));\n+  VERIFY((variant<int, string>(2) <= variant<int, string>(3)));\n+  VERIFY((variant<int, string>(3) >= variant<int, string>(3)));\n+  VERIFY((variant<int, string>(3) >= variant<int, string>(2)));\n+  VERIFY((variant<int, string>(2) != variant<int, string>(3)));\n+\n+  VERIFY((variant<int, string>(2) < variant<int, string>(\"a\")));\n+  VERIFY((variant<string, int>(2) > variant<string, int>(\"a\")));\n+}\n+\n+void test_swap()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  variant<int, string> a(\"a\"), b(\"b\");\n+  a.swap(b);\n+  VERIFY(get<1>(a) == \"b\");\n+  VERIFY(get<1>(b) == \"a\");\n+  swap(a, b);\n+  VERIFY(get<1>(a) == \"a\");\n+  VERIFY(get<1>(b) == \"b\");\n+}\n+\n+void test_visit()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  {\n+    struct Visitor\n+    {\n+      int operator()(int, float) {\n+\t  return 0;\n+      }\n+      int operator()(int, double) {\n+\t  return 1;\n+      }\n+      int operator()(char, float) {\n+\t  return 2;\n+      }\n+      int operator()(char, double) {\n+\t  return 3;\n+      }\n+      int operator()(int, float) const {\n+\t  return 5;\n+      }\n+      int operator()(int, double) const {\n+\t  return 6;\n+      }\n+      int operator()(char, float) const {\n+\t  return 7;\n+      }\n+      int operator()(char, double) const {\n+\t  return 8;\n+      }\n+    } visitor1;\n+    VERIFY(visit(visitor1, variant<int, char>(1), variant<float, double>(1.0f)) == 0);\n+    VERIFY(visit(visitor1, variant<int, char>(1), variant<float, double>(1.0)) == 1);\n+    VERIFY(visit(visitor1, variant<int, char>('a'), variant<float, double>(1.0f)) == 2);\n+    VERIFY(visit(visitor1, variant<int, char>('a'), variant<float, double>(1.0)) == 3);\n+\n+    const auto& visitor2 = visitor1;\n+    VERIFY(visit(visitor2, variant<int, char>(1), variant<float, double>(1.0f)) == 5);\n+    VERIFY(visit(visitor2, variant<int, char>(1), variant<float, double>(1.0)) == 6);\n+    VERIFY(visit(visitor2, variant<int, char>('a'), variant<float, double>(1.0f)) == 7);\n+    VERIFY(visit(visitor2, variant<int, char>('a'), variant<float, double>(1.0)) == 8);\n+  }\n+\n+  {\n+    struct Visitor\n+    {\n+      int operator()(int, float) && {\n+\t  return 0;\n+      }\n+      int operator()(int, double) && {\n+\t  return 1;\n+      }\n+      int operator()(char, float) && {\n+\t  return 2;\n+      }\n+      int operator()(char, double) && {\n+\t  return 3;\n+      }\n+    };\n+    VERIFY(visit(Visitor{}, variant<int, char>(1), variant<float, double>(1.0f)) == 0);\n+    VERIFY(visit(Visitor{}, variant<int, char>(1), variant<float, double>(1.0)) == 1);\n+    VERIFY(visit(Visitor{}, variant<int, char>('a'), variant<float, double>(1.0f)) == 2);\n+    VERIFY(visit(Visitor{}, variant<int, char>('a'), variant<float, double>(1.0)) == 3);\n+  }\n+}\n+\n+void test_hash()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  unordered_set<variant<int, string>> s;\n+  VERIFY(s.emplace(3).second);\n+  VERIFY(s.emplace(\"asdf\").second);\n+  VERIFY(s.emplace().second);\n+  VERIFY(s.size() == 3);\n+  VERIFY(!s.emplace(3).second);\n+  VERIFY(!s.emplace(\"asdf\").second);\n+  VERIFY(!s.emplace().second);\n+  VERIFY(s.size() == 3);\n+  {\n+    struct A\n+    {\n+      operator int()\n+      {\n+        throw nullptr;\n+      }\n+    };\n+    variant<int, string> v;\n+    try\n+      {\n+        v.emplace<0>(A{});\n+      }\n+    catch (nullptr_t)\n+      {\n+      }\n+    VERIFY(v.valueless_by_exception());\n+    VERIFY(s.insert(v).second);\n+    VERIFY(s.size() == 4);\n+    VERIFY(!s.insert(v).second);\n+  }\n+}\n+\n+void test_valueless_by_exception()\n+{\n+  bool test [[gnu::unused]] = true;\n+\n+  {\n+    AlwaysThrow a;\n+    bool caught = false;\n+    try\n+      {\n+\tvariant<int, AlwaysThrow> v(a);\n+      }\n+    catch (nullptr_t)\n+      {\n+\tcaught = true;\n+      }\n+    VERIFY(caught);\n+  }\n+  {\n+    AlwaysThrow a;\n+    bool caught = false;\n+    try\n+      {\n+\tvariant<int, AlwaysThrow> v(a);\n+      }\n+    catch (nullptr_t)\n+      {\n+\tcaught = true;\n+      }\n+    VERIFY(caught);\n+  }\n+  {\n+    variant<int, AlwaysThrow> v;\n+    bool caught = false;\n+    try\n+      {\n+\tAlwaysThrow a;\n+\tv = a;\n+      }\n+    catch (nullptr_t)\n+      {\n+\tcaught = true;\n+      }\n+    VERIFY(caught);\n+    VERIFY(v.valueless_by_exception());\n+  }\n+  {\n+    variant<int, AlwaysThrow> v;\n+    bool caught = false;\n+    try\n+      {\n+\tv = AlwaysThrow{};\n+      }\n+    catch (nullptr_t)\n+      {\n+\tcaught = true;\n+      }\n+    VERIFY(caught);\n+    VERIFY(v.valueless_by_exception());\n+  }\n+}\n+\n+int main()\n+{\n+  default_ctor();\n+  copy_ctor();\n+  move_ctor();\n+  arbitrary_ctor();\n+  in_place_index_ctor();\n+  in_place_type_ctor();\n+  uses_allocator_ctor();\n+  copy_assign();\n+  move_assign();\n+  arbitrary_assign();\n+  dtor();\n+  emplace();\n+  test_get();\n+  test_relational();\n+  test_swap();\n+  test_visit();\n+  test_hash();\n+  test_valueless_by_exception();\n+}"}]}