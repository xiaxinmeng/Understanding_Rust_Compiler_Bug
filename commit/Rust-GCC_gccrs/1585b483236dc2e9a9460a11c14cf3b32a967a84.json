{"sha": "1585b483236dc2e9a9460a11c14cf3b32a967a84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4NWI0ODMyMzZkYzJlOWE5NDYwYTExYzE0Y2YzYjMyYTk2N2E4NA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-05-29T20:30:45Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-05-29T20:30:45Z"}, "message": "re PR fortran/90539 (481.wrf slowdown by 25% on Intel Kaby with -Ofast -march=native starting with r271377)\n\n2019-05-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/90539\n\t* gfortran.h (gfc_has_dimen_vector_ref): Add prototype.\n\t* trans.h (gfc_conv_subref_array_arg): Add argument check_contiguous.\n\t(gfc_conv_is_contiguous_expr): Add prototype.\n\t* frontend-passes.c (has_dimen_vector_ref): Remove prototype,\n\trename to\n\t(gfc_has_dimen_vector_ref): New function name.\n\t(matmul_temp_args): Use gfc_has_dimen_vector_ref.\n\t(inline_matmul_assign): Likewise.\n\t* trans-array.c (gfc_conv_array_parameter): Also check for absence\n\tof a vector subscript before calling gfc_conv_subref_array_arg.\n\tPass additional argument to gfc_conv_subref_array_arg.\n\t* trans-expr.c (gfc_conv_subref_array_arg): Add argument\n\tcheck_contiguous. If that is true, check if the argument\n\tis contiguous and do not repack in that case.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_is_contiguous): Split\n\taway most of the work into, and call\n\t(gfc_conv_intrinsic_is_coniguous_expr): New function.\n\n2019-05-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/90539\n\t* gfortran.dg/internal_pack_21.f90: Adjust scan patterns.\n\t* gfortran.dg/internal_pack_22.f90: New test.\n\t* gfortran.dg/internal_pack_23.f90: New test.\n\nFrom-SVN: r271751", "tree": {"sha": "6beebca4391189d74ba97af399031e32ebef0dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6beebca4391189d74ba97af399031e32ebef0dd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1585b483236dc2e9a9460a11c14cf3b32a967a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1585b483236dc2e9a9460a11c14cf3b32a967a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1585b483236dc2e9a9460a11c14cf3b32a967a84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1585b483236dc2e9a9460a11c14cf3b32a967a84/comments", "author": null, "committer": null, "parents": [{"sha": "987c9fc581ffb04d5ab7a782bb7aee6205c45663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/987c9fc581ffb04d5ab7a782bb7aee6205c45663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/987c9fc581ffb04d5ab7a782bb7aee6205c45663"}], "stats": {"total": 285, "additions": 237, "deletions": 48}, "files": [{"sha": "4c126b7fa7acf0afe8261e802efed5e0515a7a69", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -1,3 +1,24 @@\n+2019-05-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/90539\n+\t* gfortran.h (gfc_has_dimen_vector_ref): Add prototype.\n+\t* trans.h (gfc_conv_subref_array_arg): Add argument check_contiguous.\n+\t(gfc_conv_is_contiguous_expr): Add prototype.\n+\t* frontend-passes.c (has_dimen_vector_ref): Remove prototype,\n+\trename to\n+\t(gfc_has_dimen_vector_ref): New function name.\n+\t(matmul_temp_args): Use gfc_has_dimen_vector_ref.\n+\t(inline_matmul_assign): Likewise.\n+\t* trans-array.c (gfc_conv_array_parameter): Also check for absence\n+\tof a vector subscript before calling gfc_conv_subref_array_arg.\n+\tPass additional argument to gfc_conv_subref_array_arg.\n+\t* trans-expr.c (gfc_conv_subref_array_arg): Add argument\n+\tcheck_contiguous. If that is true, check if the argument\n+\tis contiguous and do not repack in that case.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_is_contiguous): Split\n+\taway most of the work into, and call\n+\t(gfc_conv_intrinsic_is_coniguous_expr): New function.\n+\n 2019-05-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/90329"}, {"sha": "87df5048b714d015f6ec8d33a50172536a19412a", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -54,7 +54,6 @@ static gfc_code * create_do_loop (gfc_expr *, gfc_expr *, gfc_expr *,\n static gfc_expr* check_conjg_transpose_variable (gfc_expr *, bool *,\n \t\t\t\t\t\t bool *);\n static int call_external_blas (gfc_code **, int *, void *);\n-static bool has_dimen_vector_ref (gfc_expr *);\n static int matmul_temp_args (gfc_code **, int *,void *data);\n static int index_interchange (gfc_code **, int*, void *);\n \n@@ -2868,7 +2867,7 @@ matmul_temp_args (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n     {\n       if (matrix_a->expr_type == EXPR_VARIABLE\n \t  && (gfc_check_dependency (matrix_a, expr1, true)\n-\t      || has_dimen_vector_ref (matrix_a)))\n+\t      || gfc_has_dimen_vector_ref (matrix_a)))\n \ta_tmp = true;\n     }\n   else\n@@ -2881,7 +2880,7 @@ matmul_temp_args (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n     {\n       if (matrix_b->expr_type == EXPR_VARIABLE\n \t  && (gfc_check_dependency (matrix_b, expr1, true)\n-\t      || has_dimen_vector_ref (matrix_b)))\n+\t      || gfc_has_dimen_vector_ref (matrix_b)))\n \tb_tmp = true;\n     }\n   else\n@@ -3681,8 +3680,8 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n \n /* Helper function to check for a dimen vector as subscript.  */\n \n-static bool\n-has_dimen_vector_ref (gfc_expr *e)\n+bool\n+gfc_has_dimen_vector_ref (gfc_expr *e)\n {\n   gfc_array_ref *ar;\n   int i;\n@@ -3838,8 +3837,8 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   if (matrix_b == NULL)\n     return 0;\n \n-  if (has_dimen_vector_ref (expr1) || has_dimen_vector_ref (matrix_a)\n-      || has_dimen_vector_ref (matrix_b))\n+  if (gfc_has_dimen_vector_ref (expr1) || gfc_has_dimen_vector_ref (matrix_a)\n+      || gfc_has_dimen_vector_ref (matrix_b))\n     return 0;\n \n   /* We do not handle data dependencies yet.  */"}, {"sha": "798297bd724aa37a949a88cc3a828c2c62f9ac4f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -3535,6 +3535,7 @@ typedef int (*walk_expr_fn_t) (gfc_expr **, int *, void *);\n int gfc_dummy_code_callback (gfc_code **, int *, void *);\n int gfc_expr_walker (gfc_expr **, walk_expr_fn_t, void *);\n int gfc_code_walker (gfc_code **, walk_code_fn_t, walk_expr_fn_t, void *);\n+bool gfc_has_dimen_vector_ref (gfc_expr *e);\n \n /* simplify.c */\n "}, {"sha": "56d534d04442f0f8b9217bd10e8dd0e23f0d270c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -8139,12 +8139,12 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \t optimizers.  */\n \n       if (g77 && optimize && !optimize_size && expr->expr_type == EXPR_VARIABLE\n-\t  && !is_pointer (expr) && (fsym == NULL\n-\t\t\t\t    || fsym->ts.type != BT_ASSUMED))\n+\t  && !is_pointer (expr) && ! gfc_has_dimen_vector_ref (expr)\n+\t  && (fsym == NULL || fsym->ts.type != BT_ASSUMED))\n \t{\n \t  gfc_conv_subref_array_arg (se, expr, g77,\n \t\t\t\t     fsym ? fsym->attr.intent : INTENT_INOUT,\n-\t\t\t\t     false, fsym, proc_name, sym);\n+\t\t\t\t     false, fsym, proc_name, sym, true);\n \t  return;\n \t}\n "}, {"sha": "5183029a66685bebd70cbed55cdd41ce9fe1a311", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 118, "deletions": 32, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -4579,7 +4579,7 @@ void\n gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n \t\t\t   sym_intent intent, bool formal_ptr,\n \t\t\t   const gfc_symbol *fsym, const char *proc_name,\n-\t\t\t   gfc_symbol *sym)\n+\t\t\t   gfc_symbol *sym, bool check_contiguous)\n {\n   gfc_se lse;\n   gfc_se rse;\n@@ -4602,7 +4602,7 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n \n   pass_optional = fsym && fsym->attr.optional && sym && sym->attr.optional;\n \n-  if (pass_optional)\n+  if (pass_optional || check_contiguous)\n     {\n       gfc_init_se (&work_se, NULL);\n       parmse = &work_se;\n@@ -4880,50 +4880,136 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n   else\n     parmse->expr = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n \n-  if (pass_optional)\n+  /* Basically make this into\n+     \n+     if (present)\n+       {\n+\t if (contiguous)\n+\t   {\n+\t     pointer = a;\n+\t   }\n+\t else\n+\t   {\n+\t     parmse->pre();\n+\t     pointer = parmse->expr;\n+\t   }\n+       }\n+     else\n+       pointer = NULL;\n+\n+     foo (pointer);\n+     if (present && !contiguous)\n+\t   se->post();\n+\n+     */\n+\n+  if (pass_optional || check_contiguous)\n     {\n-      tree present;\n       tree type;\n       stmtblock_t else_block;\n       tree pre_stmts, post_stmts;\n       tree pointer;\n       tree else_stmt;\n+      tree present_var = NULL_TREE;\n+      tree cont_var = NULL_TREE;\n+      tree post_cond;\n \n-      /* Make this into\n+      type = TREE_TYPE (parmse->expr);\n+      pointer = gfc_create_var (type, \"arg_ptr\");\n+\n+      if (check_contiguous)\n+\t{\n+\t  gfc_se cont_se, array_se;\n+\t  stmtblock_t if_block, else_block;\n+\t  tree if_stmt, else_stmt;\n+\n+\t  cont_var = gfc_create_var (boolean_type_node, \"contiguous\");\n+\n+\t  /* cont_var = is_contiguous (expr); .  */\n+\t  gfc_init_se (&cont_se, parmse);\n+\t  gfc_conv_is_contiguous_expr (&cont_se, expr);\n+\t  gfc_add_block_to_block (&se->pre, &(&cont_se)->pre);\n+\t  gfc_add_modify (&se->pre, cont_var, cont_se.expr);\n+\t  gfc_add_block_to_block (&se->pre, &(&cont_se)->post);\n+\n+\t  /* arrayse->expr = descriptor of a.  */\n+\t  gfc_init_se (&array_se, se);\n+\t  gfc_conv_expr_descriptor (&array_se, expr);\n+\t  gfc_add_block_to_block (&se->pre, &(&array_se)->pre);\n+\t  gfc_add_block_to_block (&se->pre, &(&array_se)->post);\n+\n+\t  /* if_stmt = { pointer = &a[0]; } .  */\n+\t  gfc_init_block (&if_block);\n+\t  tmp = gfc_conv_array_data (array_se.expr);\n+\t  tmp = fold_convert (type, tmp);\n+\t  gfc_add_modify (&if_block, pointer, tmp);\n+\t  if_stmt = gfc_finish_block (&if_block);\n+\n+\t  /* else_stmt = { parmse->pre(); pointer = parmse->expr; } .  */\n+\t  gfc_init_block (&else_block);\n+\t  gfc_add_block_to_block (&else_block, &parmse->pre);\n+\t  gfc_add_modify (&else_block, pointer, parmse->expr);\n+\t  else_stmt = gfc_finish_block (&else_block);\n+\n+\t  /* And put the above into an if statement.  */\n+\t  pre_stmts = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t      cont_var, if_stmt, else_stmt);\n+\t}\n+      else\n+\t{\n+\t  /* pointer = pramse->expr;  .  */\n+\t  gfc_add_modify (&parmse->pre, pointer, parmse->expr);\n+\t  pre_stmts = gfc_finish_block (&parmse->pre);\n+\t}\n \n-\t if (present (a))\n-\t   {\n-\t      parmse->pre;\n-\t      optional = parse->expr;\n-\t   }\n-         else\n-\t   optional = NULL;\n-         call foo (optional);\n-         if (present (a))\n-            parmse->post;\n+      if (pass_optional)\n+\t{\n+\t  present_var = gfc_create_var (boolean_type_node, \"present\");\n \n-      */\n+\t  /* present_var = present(sym); .  */\n+\t  tmp = gfc_conv_expr_present (sym);\n+\t  tmp = fold_convert (boolean_type_node, tmp);\n+\t  gfc_add_modify (&se->pre, present_var, tmp);\n \n-      type = TREE_TYPE (parmse->expr);\n-      pointer = gfc_create_var (type, \"optional\");\n-      tmp = gfc_conv_expr_present (sym);\n-      present = gfc_evaluate_now (tmp, &se->pre);\n-      gfc_add_modify (&parmse->pre, pointer, parmse->expr);\n-      pre_stmts = gfc_finish_block (&parmse->pre);\n-\n-      gfc_init_block (&else_block);\n-      gfc_add_modify (&else_block, pointer, build_int_cst (type, 0));\n-      else_stmt = gfc_finish_block (&else_block);\n-\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, present,\n-\t\t\t     pre_stmts, else_stmt);\n-      gfc_add_expr_to_block (&se->pre, tmp);\n+\t  /* else_stmt = { pointer = NULL; } .  */\n+\t  gfc_init_block (&else_block);\n+\t  gfc_add_modify (&else_block, pointer, build_int_cst (type, 0));\n+\t  else_stmt = gfc_finish_block (&else_block);\n+\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, present_var,\n+\t\t\t\t pre_stmts, else_stmt);\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+\n+\t}\n+      else\n+\tgfc_add_expr_to_block (&se->pre, pre_stmts);\n \n       post_stmts = gfc_finish_block (&parmse->post);\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, present,\n+\n+      /* Put together the post stuff, plus the optional\n+\t deallocation.  */\n+      if (check_contiguous)\n+\t{\n+\t  /* !cont_var.  */\n+\t  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t cont_var,\n+\t\t\t\t build_zero_cst (boolean_type_node));\n+\t  if (pass_optional)\n+\t    post_cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t\t\t boolean_type_node, present_var, tmp);\n+\t  else\n+\t    post_cond = tmp;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (pass_optional);\n+\t  post_cond = present_var;\n+\t}\n+\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, post_cond,\n \t\t\t     post_stmts, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&se->post, tmp);\n-\n       se->expr = pointer;\n     }\n "}, {"sha": "f6edd685212c7b9fbbbfe88dfece60a8c0cbb252", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -2832,15 +2832,24 @@ static void\n gfc_conv_intrinsic_is_contiguous (gfc_se * se, gfc_expr * expr)\n {\n   gfc_expr *arg;\n+  arg = expr->value.function.actual->expr;\n+  gfc_conv_is_contiguous_expr (se, arg);\n+  se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n+}\n+\n+/* This function does the work for gfc_conv_intrinsic_is_contiguous,\n+   plus it can be called directly.  */\n+\n+void\n+gfc_conv_is_contiguous_expr (gfc_se *se, gfc_expr *arg)\n+{\n   gfc_ss *ss;\n   gfc_se argse;\n   tree desc, tmp, stride, extent, cond;\n   int i;\n   tree fncall0;\n   gfc_array_spec *as;\n \n-  arg = expr->value.function.actual->expr;\n-\n   if (arg->ts.type == BT_CLASS)\n     gfc_add_class_array_ref (arg);\n \n@@ -2878,7 +2887,7 @@ gfc_conv_intrinsic_is_contiguous (gfc_se * se, gfc_expr * expr)\n       cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n \t\t\t      stride, build_int_cst (TREE_TYPE (stride), 1));\n \n-      for (i = 0; i < expr->value.function.actual->expr->rank - 1; i++)\n+      for (i = 0; i < arg->rank - 1; i++)\n \t{\n \t  tmp = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n \t  extent = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n@@ -2896,7 +2905,7 @@ gfc_conv_intrinsic_is_contiguous (gfc_se * se, gfc_expr * expr)\n \t  cond = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n \t\t\t\t  boolean_type_node, cond, tmp);\n \t}\n-      se->expr = convert (gfc_typenode_for_spec (&expr->ts), cond);\n+      se->expr = cond;\n     }\n }\n "}, {"sha": "0305d331ff745f4ec7109c5a3aa30f3a6bf60461", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -535,7 +535,10 @@ int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool,\n \t\t\t\tconst gfc_symbol *fsym = NULL,\n \t\t\t\tconst char *proc_name = NULL,\n-\t\t\t\tgfc_symbol *sym = NULL);\n+\t\t\t\tgfc_symbol *sym = NULL,\n+\t\t\t\tbool check_contiguous = false);\n+\n+void gfc_conv_is_contiguous_expr (gfc_se *, gfc_expr *);\n \n /* Generate code for a scalar assignment.  */\n tree gfc_trans_scalar_assign (gfc_se *, gfc_se *, gfc_typespec, bool, bool,"}, {"sha": "a0e8b7bc492b6590ad556476f6d10ba8672ed65a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -1,3 +1,10 @@\n+2019-05-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/90539\n+\t* gfortran.dg/internal_pack_21.f90: Adjust scan patterns.\n+\t* gfortran.dg/internal_pack_22.f90: New test.\n+\t* gfortran.dg/internal_pack_23.f90: New test.\n+\n 2019-05-29  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-ssa/alias-access-spath-1.c: new testcase."}, {"sha": "54e43ffa1cba76e09ecb521d328366ba82a5baf0", "filename": "gcc/testsuite/gfortran.dg/internal_pack_21.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_21.f90?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -20,5 +20,5 @@ END MODULE M1\n USE M1\n CALL S2()\n END\n-! { dg-final { scan-tree-dump-times \"optional\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"arg_ptr\" 5 \"original\" } }\n ! { dg-final { scan-tree-dump-not \"_gfortran_internal_unpack\" \"original\" } }"}, {"sha": "4e9fe59ceab7a7d095d341dc54ae18eb7fc6433b", "filename": "gcc/testsuite/gfortran.dg/internal_pack_22.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_22.f90?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original -O\" }\n+! Check that absent and present dummy arguments work with\n+! packing when handing them down to an old-fashioned argument.\n+\n+module x\n+  implicit none\n+contains\n+  subroutine foo (a,b)\n+    real, dimension(:), intent(inout), optional :: a, b\n+    if (present(a)) stop 1\n+    if (.not. present(b)) stop 2\n+    call bar (a, b)\n+  end subroutine foo\n+\n+  subroutine bar (a,b)\n+    real, dimension(2), intent(inout), optional :: a, b\n+    real :: tmp\n+    if (present(a)) stop 3\n+    if (.not. present(b)) stop 4\n+    tmp = b(2)\n+    b(2) = b(1)\n+    b(1) = tmp\n+  end subroutine bar\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  real, dimension(2) :: b\n+  b(1) = 1.\n+  b(2) = 42.\n+  call foo(b=b)\n+  if (b(1) /= 42. .or. b(2)  /= 1.) stop 5\n+end program main\n+! { dg-final { scan-tree-dump-not \"_gfortran_internal_unpack\" \"original\" } }"}, {"sha": "8df82c8b36b0a4c3570b2aac4c4053ebfc7b2ae8", "filename": "gcc/testsuite/gfortran.dg/internal_pack_23.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1585b483236dc2e9a9460a11c14cf3b32a967a84/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_23.f90?ref=1585b483236dc2e9a9460a11c14cf3b32a967a84", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! PR fortran/90539 - this used to cause an ICE.\n+\n+module t2\n+  implicit none\n+contains\n+  subroutine foo(a)\n+    real, dimension(*) :: a\n+    if (a(1) /= 1.0 .or. a(2) /= 2.0) stop 1\n+  end subroutine foo\n+end module t2\n+\n+module t1\n+  use t2\n+  implicit none\n+contains\n+  subroutine bar(a)\n+    real, dimension(:) :: a\n+    if (a(1) /= 1.0 .or. a(2) /= 2.0) stop 1\n+    call foo(a)\n+  end subroutine bar\n+end module t1\n+\n+program main\n+  use t1\n+  call bar([1.0, 2.0])\n+end program main"}]}