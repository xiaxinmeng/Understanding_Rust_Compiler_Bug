{"sha": "638d694d84aedb360309dd956b261e428d85f092", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM4ZDY5NGQ4NGFlZGIzNjAzMDlkZDk1NmIyNjFlNDI4ZDg1ZjA5Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-30T17:11:25Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-30T17:11:25Z"}, "message": "cppfiles.c (redundant_include_p): Provide length of token to cpp_defined.\n\n\t* cppfiles.c (redundant_include_p): Provide length of token to\n\tcpp_defined.\n\t* cpphash.c (_cpp_make_hashnode, _cpp_lookup_slot): Hash\n\tvalues are unsigned int.\n\t(_cpp_lookup, _cpp_lookup_slot): Do not calculate the length.\n\t(_cpp_lookup_slot): Do not calculate the hash, either.\n\t* cpphash.h: Update prototypes.\n\t* cpplib.c (do_define, do_undef, do_pragma_poison, do_assert):\n\tHashes are unsigned int.  Calculate hash here, pass by value\n\tto _cpp_lookup_slot.\n\nFrom-SVN: r33551", "tree": {"sha": "b2cbd4667ef9d395099460fd9be30ff0ec56ed29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2cbd4667ef9d395099460fd9be30ff0ec56ed29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/638d694d84aedb360309dd956b261e428d85f092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638d694d84aedb360309dd956b261e428d85f092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638d694d84aedb360309dd956b261e428d85f092", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638d694d84aedb360309dd956b261e428d85f092/comments", "author": null, "committer": null, "parents": [{"sha": "3f49b8429cb6e4f440d796b8ed8bd75185ada516", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f49b8429cb6e4f440d796b8ed8bd75185ada516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f49b8429cb6e4f440d796b8ed8bd75185ada516"}], "stats": {"total": 76, "additions": 37, "deletions": 39}, "files": [{"sha": "ff99fd8dbc253efb66c443771fab2227573f6dca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638d694d84aedb360309dd956b261e428d85f092/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638d694d84aedb360309dd956b261e428d85f092/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=638d694d84aedb360309dd956b261e428d85f092", "patch": "@@ -1,3 +1,16 @@\n+2000-04-30  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c (redundant_include_p): Provide length of token to\n+\tcpp_defined.\n+\t* cpphash.c (_cpp_make_hashnode, _cpp_lookup_slot): Hash\n+\tvalues are unsigned int.\n+\t(_cpp_lookup, _cpp_lookup_slot): Do not calculate the length.\n+\t(_cpp_lookup_slot): Do not calculate the hash, either.\n+\t* cpphash.h: Update prototypes.\n+\t* cpplib.c (do_define, do_undef, do_pragma_poison, do_assert):\n+\tHashes are unsigned int.  Calculate hash here, pass by value\n+\tto _cpp_lookup_slot.\n+\n 2000-04-30  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* simplify-rtx.c (check_value_useless): Delete function."}, {"sha": "d92b84d97e0bd695ac930454e2323efaf5820473", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=638d694d84aedb360309dd956b261e428d85f092", "patch": "@@ -132,7 +132,8 @@ redundant_include_p (pfile, ihash, ilist)\n \t    included again if the string is the name of a defined macro. */\n \t return (i->control_macro\n \t\t && (i->control_macro[0] == '\\0'\n-\t\t     || cpp_defined (pfile, i->control_macro, -1)))\n+\t\t     || cpp_defined (pfile, i->control_macro, \n+\t\t\t\t     strlen (i->control_macro))))\n \t     ? (IHASH *)-1 : i;\n \n   return 0;"}, {"sha": "4eb2d9d33e6a2db7112725fc6c973e41823ed16e", "filename": "gcc/cpphash.c", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=638d694d84aedb360309dd956b261e428d85f092", "patch": "@@ -246,7 +246,7 @@ _cpp_make_hashnode (name, len, type, hash)\n      const U_CHAR *name;\n      size_t len;\n      enum node_type type;\n-     unsigned long hash;\n+     unsigned int hash;\n {\n   HASHNODE *hp = (HASHNODE *) xmalloc (sizeof (HASHNODE));\n   U_CHAR *p = xmalloc (len + 1);\n@@ -263,11 +263,7 @@ _cpp_make_hashnode (name, len, type, hash)\n   return hp;\n }\n \n-/* Find the hash node for name \"name\", which ends at the first\n-   non-identifier char.\n-\n-   If LEN is >= 0, it is the length of the name.\n-   Otherwise, compute the length now.  */\n+/* Find the hash node for name \"name\", of length LEN.  */\n \n HASHNODE *\n _cpp_lookup (pfile, name, len)\n@@ -278,12 +274,6 @@ _cpp_lookup (pfile, name, len)\n   const U_CHAR *bp;\n   HASHNODE dummy;\n \n-  if (len < 0)\n-    {\n-      for (bp = name; is_idchar (*bp); bp++);\n-      len = bp - name;\n-    }\n-\n   dummy.name = name;\n   dummy.length = len;\n   dummy.hash = _cpp_calc_hash (name, len);\n@@ -300,30 +290,18 @@ _cpp_lookup_slot (pfile, name, len, insert, hash)\n      const U_CHAR *name;\n      int len;\n      enum insert_option insert;\n-     unsigned long *hash;\n+     unsigned int hash;\n {\n   const U_CHAR *bp;\n   HASHNODE dummy;\n-  HASHNODE **slot;\n-\n-  if (len < 0)\n-    {\n-      for (bp = name; is_idchar (*bp); bp++)\n-\t;\n-\n-      len = bp - name;\n-    }\n \n   dummy.name = name;\n   dummy.length = len;\n-  dummy.hash = _cpp_calc_hash (name, len);\n+  dummy.hash = hash;\n \n-  slot = (HASHNODE **) htab_find_slot_with_hash (pfile->hashtab,\n+  return (HASHNODE **) htab_find_slot_with_hash (pfile->hashtab,\n \t\t\t\t\t\t (void *) &dummy,\n \t\t\t\t\t\t dummy.hash, insert);\n-  if (insert)\n-    *hash = dummy.hash;\n-  return slot;\n }\n \n /* Init the hash table.  In here so it can see the hash and eq functions.  */"}, {"sha": "5ccebad392b64a53842ccc34f3ef5445ec15a1bf", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=638d694d84aedb360309dd956b261e428d85f092", "patch": "@@ -103,7 +103,7 @@ struct ihash\n      Used for include_next */\n   struct file_name_list *foundhere;\n \n-  unsigned long hash;\t\t/* save hash value for future reference */\n+  unsigned int hash;\t\t/* save hash value for future reference */\n   const char *nshort;\t\t/* name of file as referenced in #include;\n \t\t\t\t   points into name[]  */\n   const U_CHAR *control_macro;\t/* macro, if any, preventing reinclusion -\n@@ -212,14 +212,14 @@ extern unsigned char _cpp_IStable[256];\n /* In cpphash.c */\n extern HASHNODE *_cpp_make_hashnode\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t enum node_type,\n-\t\t\t\t\t\t unsigned long));\n+\t\t\t\t\t\t unsigned int));\n extern unsigned int _cpp_calc_hash\tPARAMS ((const U_CHAR *, size_t));\n extern HASHNODE *_cpp_lookup\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const U_CHAR *, int));\n extern HASHNODE **_cpp_lookup_slot\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const U_CHAR *, int,\n \t\t\t\t\t\t enum insert_option,\n-\t\t\t\t\t\t unsigned long *));\n+\t\t\t\t\t\t unsigned int));\n extern void _cpp_free_definition\tPARAMS ((HASHNODE *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t cpp_toklist *, HASHNODE *));"}, {"sha": "dd242e241de1db3dfe8943fb2d805cf508004944", "filename": "gcc/cpplib.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638d694d84aedb360309dd956b261e428d85f092/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=638d694d84aedb360309dd956b261e428d85f092", "patch": "@@ -339,7 +339,7 @@ do_define (pfile)\n      cpp_reader *pfile;\n {\n   HASHNODE **slot;\n-  unsigned long hash;\n+  unsigned int hash;\n   int len;\n   U_CHAR *sym;\n   cpp_toklist *list = &pfile->directbuf;\n@@ -371,7 +371,8 @@ do_define (pfile)\n       goto out;\n     }\n \n-  slot = _cpp_lookup_slot (pfile, sym, len, INSERT, &hash);\n+  hash = _cpp_calc_hash (sym, len);\n+  slot = _cpp_lookup_slot (pfile, sym, len, INSERT, hash);\n   if (*slot)\n     {\n       /* Check for poisoned identifiers now.  All other checks\n@@ -686,6 +687,7 @@ do_undef (pfile)\n      cpp_reader *pfile;\n {\n   int len;\n+  unsigned int hash;\n   HASHNODE **slot;\n   U_CHAR *name;\n   long here = CPP_WRITTEN (pfile);\n@@ -713,7 +715,8 @@ do_undef (pfile)\n   name = pfile->token_buffer + here;\n   CPP_SET_WRITTEN (pfile, here);\n \n-  slot = _cpp_lookup_slot (pfile, name, len, NO_INSERT, 0);\n+  hash = _cpp_calc_hash (name, len);\n+  slot = _cpp_lookup_slot (pfile, name, len, NO_INSERT, hash);\n   if (slot)\n     {\n       HASHNODE *hp = *slot;\n@@ -949,7 +952,7 @@ do_pragma_poison (pfile)\n   size_t len;\n   enum cpp_ttype token;\n   int writeit;\n-  unsigned long hash;\n+  unsigned int hash;\n \n   /* As a rule, don't include #pragma poison commands in output,  \n      unless the user asks for them.  */\n@@ -972,7 +975,8 @@ do_pragma_poison (pfile)\n \n       p = pfile->token_buffer + written;\n       len = CPP_PWRITTEN (pfile) - p;\n-      slot = _cpp_lookup_slot (pfile, p, len, INSERT, &hash);\n+      hash = _cpp_calc_hash (p, len);\n+      slot = _cpp_lookup_slot (pfile, p, len, INSERT, hash);\n       if (*slot)\n \t{\n \t  HASHNODE *hp = *slot;\n@@ -1507,7 +1511,7 @@ do_assert (pfile)\n   HASHNODE *base, *this;\n   HASHNODE **bslot, **tslot;\n   size_t blen, tlen;\n-  unsigned long bhash, thash;\n+  unsigned int bhash, thash;\n \n   old_written = CPP_WRITTEN (pfile);\t/* remember where it starts */\n   ret = _cpp_parse_assertion (pfile);\n@@ -1528,14 +1532,16 @@ do_assert (pfile)\n \n   sym = pfile->token_buffer + old_written;\n   blen = (U_CHAR *) strchr (sym, '(') - sym;\n-  tslot = _cpp_lookup_slot (pfile, sym, tlen, INSERT, &thash);\n+  thash = _cpp_calc_hash (sym, tlen);\n+  tslot = _cpp_lookup_slot (pfile, sym, tlen, INSERT, thash);\n   if (*tslot)\n     {\n       cpp_warning (pfile, \"%s re-asserted\", sym);\n       goto error;\n     }\n \n-  bslot = _cpp_lookup_slot (pfile, sym, blen, INSERT, &bhash);\n+  bhash = _cpp_calc_hash (sym, blen);\n+  bslot = _cpp_lookup_slot (pfile, sym, blen, INSERT, bhash);\n   if (! *bslot)\n     {\n       *bslot = base = _cpp_make_hashnode (sym, blen, T_ASSERT, bhash);"}]}