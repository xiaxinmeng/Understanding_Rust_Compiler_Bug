{"sha": "ea6ac8593835b4fbff1a4f163a0e652bfa612852", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE2YWM4NTkzODM1YjRmYmZmMWE0ZjE2M2EwZTY1MmJmYTYxMjg1Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-06-16T08:56:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:56:46Z"}, "message": "re PR ada/20515 (\"stdcall\" imports are not handled correctly)\n\n2005-06-10  Eric Botcazou  <ebotcazou@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\t    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\t    Pascal Obry  <obry@adacore.com>\n\n\t* gigi.h: (build_allocator): Add arg IGNORE_INIT_TYPE.\n\n\t* trans.c (call_to_gnu): Issue a warning for users of Starlet when\n\tmaking a temporary around a procedure call because of non-addressable\n\tactual parameter.\n\t(process_freeze_entity): If entity is a private type, capture size\n\tinformation that may have been computed for the full view.\n\t(tree_transform, case N_Allocator): If have initializing expression,\n\tcheck type for Has_Constrained_Partial_View and pass that to\n\tbuild_allocator.\n\t(tree_transform, case N_Return_Statement): Pass extra arg to\n\tbuild_allocator.\n\n\t* decl.c (annotate_value): Remove early return if -gnatR is not\n\tspecified.\n\t(gnat_to_gnu_field): Don't make a packable type for a component clause\n\tif the position is byte aligned, the field is aliased, and the clause\n\tsize isn't a multiple of the packable alignment. It serves no useful\n\tpurpose packing-wise and would be rejected later on.\n\t(gnat_to_gnu_entity, case object): Pass extra arg to build_allocator.\n\n\tPR ada/20515\n\t(gnat_to_gnu_entity): Remove use of macro _WIN32 which is wrong in the\n\tcontext of cross compilers. We use TARGET_DLLIMPORT_DECL_ATTRIBUTES\n\tinstead.\n\t(create_concat_name): Idem.\n\nFrom-SVN: r101070", "tree": {"sha": "eac412113966b8189ec46c74c4184fe9071335ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eac412113966b8189ec46c74c4184fe9071335ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea6ac8593835b4fbff1a4f163a0e652bfa612852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6ac8593835b4fbff1a4f163a0e652bfa612852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea6ac8593835b4fbff1a4f163a0e652bfa612852", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6ac8593835b4fbff1a4f163a0e652bfa612852/comments", "author": null, "committer": null, "parents": [{"sha": "8704d4b30e3eace58fc9506cf3533b15835c784a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8704d4b30e3eace58fc9506cf3533b15835c784a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8704d4b30e3eace58fc9506cf3533b15835c784a"}], "stats": {"total": 120, "additions": 90, "deletions": 30}, "files": [{"sha": "b2d9d1cf90f4ed0c6e417fc60280b323e48175f4", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea6ac8593835b4fbff1a4f163a0e652bfa612852/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea6ac8593835b4fbff1a4f163a0e652bfa612852/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=ea6ac8593835b4fbff1a4f163a0e652bfa612852", "patch": "@@ -958,8 +958,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  post_error (\"Storage_Error will be raised at run-time?\",\n \t\t\t      gnat_entity);\n \n-\t\tgnu_expr = build_allocator (gnu_alloc_type, gnu_expr,\n-\t\t\t\t\t    gnu_type, 0, 0, gnat_entity);\n+\t\tgnu_expr = build_allocator (gnu_alloc_type, gnu_expr, gnu_type,\n+\t\t\t\t\t    0, 0, gnat_entity, false);\n \t      }\n \t    else\n \t      {\n@@ -3630,7 +3630,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (list_length (gnu_return_list) == 1)\n \t  gnu_return_type = TREE_TYPE (TREE_PURPOSE (gnu_return_list));\n \n-#ifdef _WIN32\n+#ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n \tif (Convention (gnat_entity) == Convention_Stdcall)\n \t  {\n \t    struct attrib *attr\n@@ -5111,7 +5111,6 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n {\n   tree gnu_field_id = get_entity_name (gnat_field);\n   tree gnu_field_type = gnat_to_gnu_type (Etype (gnat_field));\n-  tree gnu_orig_field_type = gnu_field_type;\n   tree gnu_pos = 0;\n   tree gnu_size = 0;\n   tree gnu_field;\n@@ -5138,24 +5137,47 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t\t\t      gnat_field, FIELD_DECL, false, true);\n \n   /* If we are packing this record, have a specified size that's smaller than\n-     that of the field type, or a position is specified, and the field type\n-     is also a record that's BLKmode and with a small constant size, see if\n-     we can get a better form of the type that allows more packing.  If we\n-     can, show a size was specified for it if there wasn't one so we know to\n-     make this a bitfield and avoid making things wider.  */\n+     that of the field type, or a position is specified, and the field type is\n+     also a record that's BLKmode and with a small constant size, see if we\n+     can get a better form of the type that allows more packing.  If we can,\n+     show a size was specified for it if there wasn't one so we know to make\n+     this a bitfield and avoid making things wider.  */\n   if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n       && TYPE_MODE (gnu_field_type) == BLKmode\n       && host_integerp (TYPE_SIZE (gnu_field_type), 1)\n       && compare_tree_int (TYPE_SIZE (gnu_field_type), BIGGEST_ALIGNMENT) <= 0\n       && (packed == 1\n-\t  || (gnu_size && tree_int_cst_lt (gnu_size,\n-\t\t\t\t\t   TYPE_SIZE (gnu_field_type)))\n+\t  || (gnu_size\n+\t      && tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type)))\n \t  || Present (Component_Clause (gnat_field))))\n     {\n-      gnu_field_type = make_packable_type (gnu_field_type);\n-\n-      if (gnu_field_type != gnu_orig_field_type && !gnu_size)\n-\tgnu_size = rm_size (gnu_field_type);\n+      /* See what the alternate type and size would be.  */\n+      tree gnu_packable_type = make_packable_type (gnu_field_type);\n+\n+      /* Compute whether we should avoid the substitution.  */\n+      int reject =\n+        /* There is no point subtituting if there is no change.  */\n+        (gnu_packable_type == gnu_field_type\n+         ||\n+         /* The size of an aliased field must be an exact multiple of the\n+            type's alignment, which the substitution might increase.  Reject\n+            substitutions that would so invalidate a component clause when the\n+            specified position is byte aligned, as the change would have no\n+            real benefit from the packing standpoint anyway.  */\n+         (Is_Aliased (gnat_field)\n+          && Present (Component_Clause (gnat_field))\n+          && UI_To_Int (Component_Bit_Offset (gnat_field)) % BITS_PER_UNIT == 0\n+          && tree_low_cst (gnu_size, 1) % TYPE_ALIGN (gnu_packable_type) != 0)\n+         );\n+\n+      /* Substitute unless told otherwise.  */\n+      if (!reject)\n+        {\n+          gnu_field_type = gnu_packable_type;\n+\n+          if (gnu_size == 0)\n+            gnu_size = rm_size (gnu_field_type);\n+        }\n     }\n \n   /* If we are packing the record and the field is BLKmode, round the\n@@ -5678,10 +5700,6 @@ annotate_value (tree gnu_size)\n   int i;\n   int size;\n \n-  /* If back annotation is suppressed by the front end, return No_Uint */\n-  if (!Back_Annotate_Rep_Info)\n-    return No_Uint;\n-\n   /* See if we've already saved the value for this node.  */\n   if (EXPR_P (gnu_size) && TREE_COMPLEXITY (gnu_size))\n     return (Node_Ref_Or_Val) TREE_COMPLEXITY (gnu_size);\n@@ -6606,7 +6624,7 @@ create_concat_name (Entity_Id gnat_entity, const char *suffix)\n \n   Get_External_Name_With_Suffix (gnat_entity, fp);\n \n-#ifdef _WIN32\n+#ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n   /* A variable using the Stdcall convention (meaning we are running\n      on a Windows box) live in a DLL. Here we adjust its name to use\n      the jump-table, the _imp__NAME contains the address for the NAME"}, {"sha": "fe2f1103aa0c3858fdd77da0b8f9f668ce935033", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea6ac8593835b4fbff1a4f163a0e652bfa612852/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea6ac8593835b4fbff1a4f163a0e652bfa612852/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=ea6ac8593835b4fbff1a4f163a0e652bfa612852", "patch": "@@ -709,10 +709,13 @@ extern tree build_call_alloc_dealloc (tree gnu_obj, tree gnu_size,\n    RESULT_TYPE, which must be some type of pointer.  Return the tree.\n    GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n    the storage pool to use.  GNAT_NODE is used to provide an error\n-   location for restriction violations messages.  */\n+   location for restriction violations messages.  If IGNORE_INIT_TYPE is\n+   true, ignore the type of INIT for the purpose of determining the size;\n+   this will cause the maximum size to be allocated if TYPE is of\n+   self-referential size.  */\n extern tree build_allocator (tree type, tree init, tree result_type,\n                              Entity_Id gnat_proc, Entity_Id gnat_pool,\n-                             Node_Id gnat_node);\n+                             Node_Id gnat_node, bool);\n \n /* Fill in a VMS descriptor for EXPR and return a constructor for it.\n    GNAT_FORMAL is how we find the descriptor record.  */"}, {"sha": "8bd28301b0ddd5c357d20883f71e942b6a7bc625", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea6ac8593835b4fbff1a4f163a0e652bfa612852/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea6ac8593835b4fbff1a4f163a0e652bfa612852/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=ea6ac8593835b4fbff1a4f163a0e652bfa612852", "patch": "@@ -592,7 +592,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n       /* If we are taking 'Address of an unconstrained object, this is the\n \t pointer to the underlying array.  */\n-      gnu_prefix = maybe_unconstrained_array (gnu_prefix);\n+      if (attribute == Attr_Address)\n+\tgnu_prefix = maybe_unconstrained_array (gnu_prefix);\n \n       /* ... fall through ... */\n \n@@ -1633,6 +1634,27 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      tree gnu_copy = gnu_name;\n \t      tree gnu_temp;\n \n+\t      /* For users of Starlet we issue a warning because the\n+\t\t interface apparently assumes that by-ref parameters\n+\t\t outlive the procedure invocation.  The code still\n+\t\t will not work as intended, but we cannot do much\n+\t\t better since other low-level parts of the back-end\n+\t\t would allocate temporaries at will because of the\n+\t\t misalignment if we did not do so here.  */\n+\n+\t      if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n+\t\t{\n+\t\t  post_error\n+\t\t    (\"?possible violation of implicit assumption\",\n+\t\t     gnat_actual);\n+\t\t  post_error_ne\n+\t\t    (\"?made by pragma Import_Valued_Procedure on &\",\n+\t\t     gnat_actual, Entity (Name (gnat_node)));\n+\t\t  post_error_ne\n+\t\t    (\"?because of misalignment of &\",\n+\t\t     gnat_actual, gnat_formal);\n+\t\t}\n+\n \t      /* Remove any unpadding on the actual and make a copy.  But if\n \t\t the actual is a justified modular type, first convert\n \t\t to it.  */\n@@ -3319,6 +3341,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       {\n \ttree gnu_init = 0;\n \ttree gnu_type;\n+\tbool ignore_init_type = false;\n \n \tgnat_temp = Expression (gnat_node);\n \n@@ -3334,6 +3357,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    Entity_Id gnat_desig_type\n \t      = Designated_Type (Underlying_Type (Etype (gnat_node)));\n \n+\t    ignore_init_type = Has_Constrained_Partial_View (gnat_desig_type);\n \t    gnu_init = gnat_to_gnu (Expression (gnat_temp));\n \n \t    gnu_init = maybe_unconstrained_array (gnu_init);\n@@ -3361,7 +3385,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \treturn build_allocator (gnu_type, gnu_init, gnu_result_type,\n \t\t\t\tProcedure_To_Call (gnat_node),\n-\t\t\t\tStorage_Pool (gnat_node), gnat_node);\n+\t\t\t\tStorage_Pool (gnat_node), gnat_node,\n+\t\t\t\tignore_init_type);\n       }\n       break;\n \n@@ -3576,15 +3601,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t= build_allocator (TREE_TYPE (gnu_ret_val),\n \t\t\t\t\t   gnu_ret_val,\n \t\t\t\t\t   TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t\t   0, -1, gnat_node);\n+\t\t\t\t\t   0, -1, gnat_node, false);\n \t\t    else\n \t\t      gnu_ret_val\n \t\t\t= build_allocator (TREE_TYPE (gnu_ret_val),\n \t\t\t\t\t   gnu_ret_val,\n \t\t\t\t\t   TREE_TYPE (gnu_subprog_type),\n \t\t\t\t\t   Procedure_To_Call (gnat_node),\n \t\t\t\t\t   Storage_Pool (gnat_node),\n-\t\t\t\t\t   gnat_node);\n+\t\t\t\t\t   gnat_node, false);\n \t\t  }\n \t      }\n \t  }\n@@ -4754,11 +4779,15 @@ process_freeze_entity (Node_Id gnat_node)\n \n   /* Don't do anything for subprograms that may have been elaborated before\n      their freeze nodes.  This can happen, for example because of an inner call\n-     in an instance body.  */\n-  if (gnu_old\n-       && TREE_CODE (gnu_old) == FUNCTION_DECL\n-       && (Ekind (gnat_entity) == E_Function\n+     in an instance body, or a previous compilation of a spec for inlining\n+     purposes.  */\n+  if  ((gnu_old\n+        && TREE_CODE (gnu_old) == FUNCTION_DECL\n+        && (Ekind (gnat_entity) == E_Function\n           || Ekind (gnat_entity) == E_Procedure))\n+    || (gnu_old\n+        && (TREE_CODE (TREE_TYPE (gnu_old)) == FUNCTION_TYPE\n+        && Ekind (gnat_entity) == E_Subprogram_Type)))\n     return;\n \n   /* If we have a non-dummy type old tree, we have nothing to do.   Unless\n@@ -4798,6 +4827,16 @@ process_freeze_entity (Node_Id gnat_node)\n     {\n       gnu_new = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE, 1);\n \n+      /* Propagate back-annotations from full view to partial view.  */\n+      if (Unknown_Alignment (gnat_entity))\n+\tSet_Alignment (gnat_entity, Alignment (Full_View (gnat_entity)));\n+\n+      if (Unknown_Esize (gnat_entity))\n+\tSet_Esize (gnat_entity, Esize (Full_View (gnat_entity)));\n+\n+      if (Unknown_RM_Size (gnat_entity))\n+\tSet_RM_Size (gnat_entity, RM_Size (Full_View (gnat_entity)));\n+\n       /* The above call may have defined this entity (the simplest example\n   \t of this is when we have a private enumeral type since the bounds\n   \t will have the public view.  */"}]}