{"sha": "f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkxMzJlYjc5N2Q4OTdiOGU2NmI4ZThkZGIzZThlMjc0NGI2YWM1MQ==", "commit": {"author": {"name": "Rodrigo Rivas Costa", "email": "rodrigorivascosta@gmail.com", "date": "2010-09-11T05:20:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-09-11T05:20:08Z"}, "message": "Implement range-based for-statements.\n\n\t* cp-tree.def (RANGE_FOR_STMT): New.\n\t* cp-tree.h (RANGE_FOR_DECL, RANGE_FOR_EXPR, RANGE_FOR_BODY): New.\n\t(cp_convert_range_for): Declare.\n\t* pt.c (tsubst_expr): Add RANGE_FOR_STMT.\n\t(tsubst_copy_and_build): perform_koenig_lookup takes extra argument.\n\t* semantics.c (begin_range_for_stmt): New.\n\t(finish_range_for_decl): New.\n\t(finish_for_stmt): Accept also RANGE_FOR_STMT.\n\t(perform_koenig_lookup): Add extra argument include_std.\n\t* parser.c (cp_parser_c_for): New with code from\n\tcp_parser_iteration_statement().\n\t(cp_parser_range_for): New.\n\t(cp_convert_range_for): New.\n\t(cp_parser_iteration_statement): Add range-for support.\n\t(cp_parser_condition): Adjust comment.\n\t(cp_parser_postfix_expression): perform_koenig_lookup takes extra\n\targument.\n\t* dump.c (cp_dump_tree): Add RANGE_FOR_STMT.\n\t* cxx-pretty-print.c: Likewise.\n\t* lex.c (cxx_init): Likewise.\n\t* name-lookup.c (lookup_function_nonclass): Add extra argument\n\tinclude_std.\n\t(lookup_arg_dependent): Likewise.\n\t* name-lookup.h: Likewise.\n\nFrom-SVN: r164211", "tree": {"sha": "9f2ed3c3628913b10a211d8bef542c2772bafa97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f2ed3c3628913b10a211d8bef542c2772bafa97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/comments", "author": {"login": "rodrigorc", "id": 1128630, "node_id": "MDQ6VXNlcjExMjg2MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1128630?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodrigorc", "html_url": "https://github.com/rodrigorc", "followers_url": "https://api.github.com/users/rodrigorc/followers", "following_url": "https://api.github.com/users/rodrigorc/following{/other_user}", "gists_url": "https://api.github.com/users/rodrigorc/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodrigorc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodrigorc/subscriptions", "organizations_url": "https://api.github.com/users/rodrigorc/orgs", "repos_url": "https://api.github.com/users/rodrigorc/repos", "events_url": "https://api.github.com/users/rodrigorc/events{/privacy}", "received_events_url": "https://api.github.com/users/rodrigorc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e5f2af21a1a93bf5743f00b8adf9c2bdeded8da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e5f2af21a1a93bf5743f00b8adf9c2bdeded8da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e5f2af21a1a93bf5743f00b8adf9c2bdeded8da"}], "stats": {"total": 757, "additions": 720, "deletions": 37}, "files": [{"sha": "60936e0aa5d4ad24a3f0694a2301ee0e03e8fac7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -1,3 +1,31 @@\n+2010-09-11  Rodrigo Rivas <rodrigorivascosta@gmail.com>\n+\n+\tImplement range-based for-statements.\n+\t* cp-tree.def (RANGE_FOR_STMT): New.\n+\t* cp-tree.h (RANGE_FOR_DECL, RANGE_FOR_EXPR, RANGE_FOR_BODY): New.\n+\t(cp_convert_range_for): Declare.\n+\t* pt.c (tsubst_expr): Add RANGE_FOR_STMT.\n+\t(tsubst_copy_and_build): perform_koenig_lookup takes extra argument.\n+\t* semantics.c (begin_range_for_stmt): New.\n+\t(finish_range_for_decl): New.\n+\t(finish_for_stmt): Accept also RANGE_FOR_STMT.\n+\t(perform_koenig_lookup): Add extra argument include_std.\n+\t* parser.c (cp_parser_c_for): New with code from\n+\tcp_parser_iteration_statement().\n+\t(cp_parser_range_for): New.\n+\t(cp_convert_range_for): New.\n+\t(cp_parser_iteration_statement): Add range-for support.\n+\t(cp_parser_condition): Adjust comment.\n+\t(cp_parser_postfix_expression): perform_koenig_lookup takes extra\n+\targument.\n+\t* dump.c (cp_dump_tree): Add RANGE_FOR_STMT.\n+\t* cxx-pretty-print.c: Likewise.\n+\t* lex.c (cxx_init): Likewise.\n+\t* name-lookup.c (lookup_function_nonclass): Add extra argument\n+\tinclude_std.\n+\t(lookup_arg_dependent): Likewise.\n+\t* name-lookup.h: Likewise.\n+\n 2010-09-10  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n \n \tPR c++/43824"}, {"sha": "1eb25c31a7dbef2059de9af7524458893f502e27", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -293,6 +293,11 @@ DEFTREECODE (IF_STMT, \"if_stmt\", tcc_statement, 3)\n    FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\n DEFTREECODE (FOR_STMT, \"for_stmt\", tcc_statement, 4)\n \n+/* Used to represent a range-based `for' statement. The operands are\n+   RANGE_FOR_DECL, RANGE_FOR_EXPR, RANGE_FOR_BODY, respectively.  Only used\n+   in templates.  */\n+DEFTREECODE (RANGE_FOR_STMT, \"range_for_stmt\", tcc_statement, 3)\n+\n /* Used to represent a 'while' statement. The operands are WHILE_COND\n    and WHILE_BODY, respectively.  */\n DEFTREECODE (WHILE_STMT, \"while_stmt\", tcc_statement, 2)"}, {"sha": "c78beb7c2f1ce92e138e17cc33cf3acf08a9834c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -3801,6 +3801,12 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define FOR_EXPR(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n #define FOR_BODY(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n \n+/* RANGE_FOR_STMT accessors. These give access to the declarator,\n+   expression and body of the statement, respectively.  */\n+#define RANGE_FOR_DECL(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 0)\n+#define RANGE_FOR_EXPR(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 1)\n+#define RANGE_FOR_BODY(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 2)\n+\n #define SWITCH_STMT_COND(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n #define SWITCH_STMT_BODY(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n #define SWITCH_STMT_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n@@ -4011,6 +4017,7 @@ extern int function_depth;\n    sizeof can be nested.  */\n \n extern int cp_unevaluated_operand;\n+extern tree cp_convert_range_for (tree, tree, tree);\n \n /* in pt.c  */\n \n@@ -5192,6 +5199,9 @@ extern void finish_for_init_stmt\t\t(tree);\n extern void finish_for_cond\t\t\t(tree, tree);\n extern void finish_for_expr\t\t\t(tree, tree);\n extern void finish_for_stmt\t\t\t(tree);\n+extern tree begin_range_for_stmt\t\t(void);\n+extern void finish_range_for_decl\t\t(tree, tree, tree);\n+extern void finish_range_for_stmt\t\t(tree);\n extern tree finish_break_stmt\t\t\t(void);\n extern tree finish_continue_stmt\t\t(void);\n extern tree begin_switch_stmt\t\t\t(void);\n@@ -5232,7 +5242,7 @@ extern tree finish_stmt_expr_expr\t\t(tree, tree);\n extern tree finish_stmt_expr\t\t\t(tree, bool);\n extern tree stmt_expr_value_expr\t\t(tree);\n bool empty_expr_stmt_p\t\t\t\t(tree);\n-extern tree perform_koenig_lookup\t\t(tree, VEC(tree,gc) *);\n+extern tree perform_koenig_lookup\t\t(tree, VEC(tree,gc) *, bool);\n extern tree finish_call_expr\t\t\t(tree, VEC(tree,gc) **, bool,\n \t\t\t\t\t\t bool, tsubst_flags_t);\n extern tree finish_increment_expr\t\t(tree, enum tree_code);"}, {"sha": "24e282475cb56cfe96d5deb9e72d339b8fa15f12", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -1921,6 +1921,23 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_needs_newline (pp) = true;\n       break;\n \n+    case RANGE_FOR_STMT:\n+      pp_cxx_ws_string (pp, \"for\");\n+      pp_space (pp);\n+      pp_cxx_left_paren (pp);\n+      pp_cxx_statement (pp, RANGE_FOR_DECL (t));\n+      pp_space (pp);\n+      pp_needs_newline (pp) = false;\n+      pp_colon (pp);\n+      pp_space (pp);\n+      pp_cxx_statement (pp, RANGE_FOR_EXPR (t));\n+      pp_cxx_right_paren (pp);\n+      pp_newline_and_indent (pp, 3);\n+      pp_cxx_statement (pp, FOR_BODY (t));\n+      pp_indentation (pp) -= 3;\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n       /* jump-statement:\n \t    goto identifier;\n \t    continue ;"}, {"sha": "1e698bceb9769ac57a9706223da50f8eecb5a8a1", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -453,6 +453,13 @@ cp_dump_tree (void* dump_info, tree t)\n       dump_child (\"body\", FOR_BODY (t));\n       break;\n \n+    case RANGE_FOR_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"decl\", RANGE_FOR_DECL (t));\n+      dump_child (\"expr\", RANGE_FOR_EXPR (t));\n+      dump_child (\"body\", RANGE_FOR_BODY (t));\n+      break;\n+\n     case SWITCH_STMT:\n       dump_stmt (di, t);\n       dump_child (\"cond\", SWITCH_STMT_COND (t));"}, {"sha": "8a894c743baf67a02449e3f356d9ad1fecffb5ac", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -226,8 +226,9 @@ cxx_init (void)\n    CTOR_INITIALIZER,\tTRY_BLOCK,\tHANDLER,\n    EH_SPEC_BLOCK,\tUSING_STMT,\tTAG_DEFN,\n    IF_STMT,\t\tCLEANUP_STMT,\tFOR_STMT,\n-   WHILE_STMT,\t\tDO_STMT,\tBREAK_STMT,\n-   CONTINUE_STMT,\tSWITCH_STMT,\tEXPR_STMT\n+   RANGE_FOR_STMT,\tWHILE_STMT,\tDO_STMT,\n+   BREAK_STMT,\t\tCONTINUE_STMT,\tSWITCH_STMT,\n+   EXPR_STMT\n   };\n \n   memset (&statement_code_p, 0, sizeof (statement_code_p));"}, {"sha": "41feb57898e8d40b55df08caa7c8efb18a0c59f0", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -4389,7 +4389,7 @@ lookup_function_nonclass (tree name, VEC(tree,gc) *args, bool block_p)\n     lookup_arg_dependent (name,\n \t\t\t  lookup_name_real (name, 0, 1, block_p, 0,\n \t\t\t\t\t    LOOKUP_COMPLAIN),\n-\t\t\t  args);\n+\t\t\t  args, false);\n }\n \n tree\n@@ -5063,7 +5063,8 @@ arg_assoc (struct arg_lookup *k, tree n)\n    are the functions found in normal lookup.  */\n \n tree\n-lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args)\n+lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args,\n+\t\t      bool include_std)\n {\n   struct arg_lookup k;\n \n@@ -5086,6 +5087,8 @@ lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args)\n      picking up later definitions) in the second stage. */\n   k.namespaces = make_tree_vector ();\n \n+  if (include_std)\n+    arg_assoc_namespace (&k, std_node);\n   arg_assoc_args_vec (&k, args);\n \n   fns = k.functions;"}, {"sha": "7d2f19e19f93ca2bd5aeeae4c1f02d98600d1cdc", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -342,7 +342,7 @@ extern void do_toplevel_using_decl (tree, tree, tree);\n extern void do_local_using_decl (tree, tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern void do_using_directive (tree);\n-extern tree lookup_arg_dependent (tree, tree, VEC(tree,gc) *);\n+extern tree lookup_arg_dependent (tree, tree, VEC(tree,gc) *, bool);\n extern bool is_associated_namespace (tree, tree);\n extern void parse_using_directive (tree, tree);\n extern tree innermost_non_namespace_value (tree);"}, {"sha": "938534450fec539bd76153c16661b45cd5589f23", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 268, "deletions": 22, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -1829,6 +1829,10 @@ static tree cp_parser_iteration_statement\n   (cp_parser *);\n static void cp_parser_for_init_statement\n   (cp_parser *);\n+static tree  cp_parser_c_for\n+  (cp_parser *);\n+static tree  cp_parser_range_for\n+  (cp_parser *);\n static tree cp_parser_jump_statement\n   (cp_parser *);\n static void cp_parser_declaration_statement\n@@ -5171,7 +5175,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\tkoenig_p = true;\n \t\t\tif (!any_type_dependent_arguments_p (args))\n \t\t\t  postfix_expression\n-\t\t\t    = perform_koenig_lookup (postfix_expression, args);\n+\t\t\t    = perform_koenig_lookup (postfix_expression, args,\n+\t\t\t\t\t\t     /*include_std=*/false);\n \t\t      }\n \t\t    else\n \t\t      postfix_expression\n@@ -5195,7 +5200,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\tkoenig_p = true;\n \t\t\tif (!any_type_dependent_arguments_p (args))\n \t\t\t  postfix_expression\n-\t\t\t    = perform_koenig_lookup (postfix_expression, args);\n+\t\t\t    = perform_koenig_lookup (postfix_expression, args,\n+\t\t\t\t\t\t     /*include_std=*/false);\n \t\t      }\n \t\t  }\n \t      }\n@@ -8580,6 +8586,258 @@ cp_parser_condition (cp_parser* parser)\n   return cp_parser_expression (parser, /*cast_p=*/false, NULL);\n }\n \n+/* Parses a traditional for-statement until the closing ')', not included. */\n+\n+static tree\n+cp_parser_c_for (cp_parser *parser)\n+{\n+  /* Normal for loop */\n+  tree stmt;\n+  tree condition = NULL_TREE;\n+  tree expression = NULL_TREE;\n+\n+  /* Begin the for-statement.  */\n+  stmt = begin_for_stmt ();\n+\n+  /* Parse the initialization.  */\n+  cp_parser_for_init_statement (parser);\n+  finish_for_init_stmt (stmt);\n+\n+  /* If there's a condition, process it.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    condition = cp_parser_condition (parser);\n+  finish_for_cond (condition, stmt);\n+  /* Look for the `;'.  */\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+\n+  /* If there's an expression, process it.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+    expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+  finish_for_expr (expression, stmt);\n+\n+  return stmt;\n+}\n+\n+/* Tries to parse a range-based for-statement:\n+\n+  range-based-for:\n+    type-specifier-seq declarator : expression\n+\n+  If succesful, assigns to *DECL the DECLARATOR and to *EXPR the\n+  expression. Note that the *DECL is returned unfinished, so\n+  later you should call cp_finish_decl().\n+\n+  Returns TRUE iff a range-based for is parsed. */\n+\n+static tree\n+cp_parser_range_for (cp_parser *parser)\n+{\n+  tree stmt, range_decl, range_expr;\n+  cp_decl_specifier_seq type_specifiers;\n+  cp_declarator *declarator;\n+  const char *saved_message;\n+  tree attributes, pushed_scope;\n+\n+  cp_parser_parse_tentatively (parser);\n+  /* New types are not allowed in the type-specifier-seq for a\n+     range-based for loop.  */\n+  saved_message = parser->type_definition_forbidden_message;\n+  parser->type_definition_forbidden_message\n+    = G_(\"types may not be defined in range-based for loops\");\n+  /* Parse the type-specifier-seq.  */\n+  cp_parser_type_specifier_seq (parser, /*is_declaration==*/true,\n+\t\t\t\t/*is_trailing_return=*/false,\n+\t\t\t\t&type_specifiers);\n+  /* Restore the saved message.  */\n+  parser->type_definition_forbidden_message = saved_message;\n+  /* If all is well, we might be looking at a declaration.  */\n+  if (cp_parser_error_occurred (parser))\n+    {\n+      cp_parser_abort_tentative_parse (parser);\n+      return NULL_TREE;\n+    }\n+  /* Parse the declarator.  */\n+  declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t     /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t     /*parenthesized_p=*/NULL,\n+\t\t\t\t     /*member_p=*/false);\n+  /* Parse the attributes.  */\n+  attributes = cp_parser_attributes_opt (parser);\n+  /* The next token should be `:'. */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+    cp_parser_simulate_error (parser);\n+\n+  /* Check if it is a range-based for */\n+  if (!cp_parser_parse_definitely (parser))\n+    return NULL_TREE;\n+\n+  cp_parser_require (parser, CPP_COLON, RT_COLON);\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    {\n+      bool expr_non_constant_p;\n+      range_expr = cp_parser_braced_list (parser, &expr_non_constant_p);\n+    }\n+  else\n+    range_expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\n+  /* If in template, STMT is converted to a normal for-statements\n+     at instantiation. If not, it is done just ahead. */\n+  if (processing_template_decl)\n+    stmt = begin_range_for_stmt ();\n+  else\n+    stmt = begin_for_stmt ();\n+\n+  /* Create the declaration. It must be after begin{,_range}_for_stmt(). */\n+  range_decl = start_decl (declarator, &type_specifiers,\n+\t\t\t   /*initialized_p=*/SD_INITIALIZED,\n+\t\t\t   attributes, /*prefix_attributes=*/NULL_TREE,\n+\t\t\t   &pushed_scope);\n+  /* No scope allowed here */\n+  pop_scope (pushed_scope);\n+\n+  if (TREE_CODE (stmt) == RANGE_FOR_STMT)\n+    finish_range_for_decl (stmt, range_decl, range_expr);\n+  else\n+    /* Convert the range-based for loop into a normal for-statement. */\n+    stmt = cp_convert_range_for (stmt, range_decl, range_expr);\n+\n+  return stmt;\n+}\n+\n+/* Converts a range-based for-statement into a normal\n+   for-statement, as per the definition.\n+\n+      for (RANGE_DECL : RANGE_EXPR)\n+\tBLOCK\n+\n+   should be equivalent to:\n+\n+      {\n+\tauto &&__range = RANGE_EXPR;\n+\tfor (auto __begin = BEGIN_EXPR, end = END_EXPR;\n+\t      __begin != __end;\n+\t      ++__begin)\n+\t  {\n+\t      RANGE_DECL = *__begin;\n+\t      BLOCK\n+\t  }\n+      }\n+\n+   If RANGE_EXPR is an array:\n+       BEGIN_EXPR = __range\n+       END_EXPR = __range + ARRAY_SIZE(__range)\n+   Else:\n+\tBEGIN_EXPR = begin(__range)\n+\tEND_EXPR = end(__range);\n+\n+   When calling begin()/end() we must use argument dependent\n+   lookup, but always considering 'std' as an associated namespace.  */\n+\n+tree\n+cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n+{\n+  tree range_type, range_temp;\n+  tree begin, end;\n+  tree iter_type, begin_expr, end_expr;\n+  tree condition, expression;\n+\n+  /* Find out the type deduced by the declaration\n+   * `auto &&__range = range_expr' */\n+  range_type = cp_build_reference_type (make_auto (), true);\n+  range_type = do_auto_deduction (range_type, range_expr,\n+\t\t\t\t  type_uses_auto (range_type));\n+\n+  /* Create the __range variable */\n+  range_temp = build_decl (input_location, VAR_DECL,\n+\t\t\t   get_identifier (\"__for_range\"), range_type);\n+  TREE_USED (range_temp) = 1;\n+  DECL_ARTIFICIAL (range_temp) = 1;\n+  pushdecl (range_temp);\n+  finish_expr_stmt (cp_build_modify_expr (range_temp, INIT_EXPR, range_expr,\n+\t\t\t\t\t  tf_warning_or_error));\n+  range_temp = convert_from_reference (range_temp);\n+\n+  if (TREE_CODE (TREE_TYPE (range_temp)) == ARRAY_TYPE)\n+    {\n+      /* If RANGE_TEMP is an array we will use pointer arithmetic */\n+      iter_type = build_pointer_type (TREE_TYPE (TREE_TYPE (range_temp)));\n+      begin_expr = range_temp;\n+      end_expr\n+\t= build_binary_op (input_location, PLUS_EXPR,\n+\t\t\t   range_temp,\n+\t\t\t   array_type_nelts_top (TREE_TYPE (range_temp)), 0);\n+    }\n+  else\n+    {\n+      /* If it is not an array, we must call begin(__range)/end__range() */\n+      VEC(tree,gc) *vec;\n+\n+      begin_expr = get_identifier (\"begin\");\n+      vec = make_tree_vector ();\n+      VEC_safe_push (tree, gc, vec, range_temp);\n+      begin_expr = perform_koenig_lookup (begin_expr, vec,\n+\t\t\t\t\t  /*include_std=*/true);\n+      begin_expr = finish_call_expr (begin_expr, &vec, false, true,\n+\t\t\t\t     tf_warning_or_error);\n+      release_tree_vector (vec);\n+\n+      end_expr = get_identifier (\"end\");\n+      vec = make_tree_vector ();\n+      VEC_safe_push (tree, gc, vec, range_temp);\n+      end_expr = perform_koenig_lookup (end_expr, vec,\n+\t\t\t\t\t/*include_std=*/true);\n+      end_expr = finish_call_expr (end_expr, &vec, false, true,\n+\t\t\t\t   tf_warning_or_error);\n+      release_tree_vector (vec);\n+\n+      /* The unqualified type of the __begin and __end temporaries should\n+      * be the same as required by the multiple auto declaration */\n+      iter_type = cv_unqualified (TREE_TYPE (begin_expr));\n+      if (!same_type_p (iter_type, cv_unqualified (TREE_TYPE (end_expr))))\n+\terror (\"inconsistent begin/end types in range-based for: %qT and %qT\",\n+\t       TREE_TYPE (begin_expr), TREE_TYPE (end_expr));\n+    }\n+\n+  /* The new for initialization statement */\n+  begin = build_decl (input_location, VAR_DECL,\n+\t\t      get_identifier (\"__for_begin\"), iter_type);\n+  TREE_USED (begin) = 1;\n+  DECL_ARTIFICIAL (begin) = 1;\n+  pushdecl (begin);\n+  finish_expr_stmt (cp_build_modify_expr (begin, INIT_EXPR, begin_expr,\n+\t\t\t\t\t  tf_warning_or_error));\n+  end = build_decl (input_location, VAR_DECL,\n+\t\t    get_identifier (\"__for_end\"), iter_type);\n+  TREE_USED (end) = 1;\n+  DECL_ARTIFICIAL (end) = 1;\n+  pushdecl (end);\n+\n+  finish_expr_stmt (cp_build_modify_expr (end, INIT_EXPR, end_expr,\n+\t\t\t\t\t  tf_warning_or_error));\n+\n+  finish_for_init_stmt (statement);\n+\n+/* The new for condition */\n+  condition = build_x_binary_op (NE_EXPR,\n+\t\t\t\t begin, ERROR_MARK,\n+\t\t\t\t end, ERROR_MARK,\n+\t\t\t\t NULL, tf_warning_or_error);\n+  finish_for_cond (condition, statement);\n+\n+  /* The new increment expression */\n+  expression = finish_unary_op_expr (PREINCREMENT_EXPR, begin);\n+  finish_for_expr (expression, statement);\n+\n+  /* The declaration is initialized with *__begin inside the loop body */\n+  cp_finish_decl (range_decl,\n+\t\t  build_x_indirect_ref (begin, RO_NULL, tf_warning_or_error),\n+\t\t  /*is_constant_init*/false, NULL_TREE,\n+\t\t  LOOKUP_ONLYCONVERTING);\n+\n+  return statement;\n+}\n+\n+\n /* Parse an iteration-statement.\n \n    iteration-statement:\n@@ -8588,7 +8846,7 @@ cp_parser_condition (cp_parser* parser)\n      for ( for-init-statement condition [opt] ; expression [opt] )\n        statement\n \n-   Returns the new WHILE_STMT, DO_STMT, or FOR_STMT.  */\n+   Returns the new WHILE_STMT, DO_STMT, FOR_STMT or RANGE_FOR_STMT.  */\n \n static tree\n cp_parser_iteration_statement (cp_parser* parser)\n@@ -8661,28 +8919,16 @@ cp_parser_iteration_statement (cp_parser* parser)\n \n     case RID_FOR:\n       {\n-\ttree condition = NULL_TREE;\n-\ttree expression = NULL_TREE;\n-\n-\t/* Begin the for-statement.  */\n-\tstatement = begin_for_stmt ();\n \t/* Look for the `('.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-\t/* Parse the initialization.  */\n-\tcp_parser_for_init_statement (parser);\n-\tfinish_for_init_stmt (statement);\n-\n-\t/* If there's a condition, process it.  */\n-\tif (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\t  condition = cp_parser_condition (parser);\n-\tfinish_for_cond (condition, statement);\n-\t/* Look for the `;'.  */\n-\tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n-\t/* If there's an expression, process it.  */\n-\tif (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-\t  expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-\tfinish_for_expr (expression, statement);\n+\tif (cxx_dialect == cxx0x)\n+\t  statement = cp_parser_range_for (parser);\n+\telse\n+\t  statement = NULL_TREE;\n+\tif (statement == NULL_TREE)\n+\t  statement = cp_parser_c_for (parser);\n+\n \t/* Look for the `)'.  */\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n "}, {"sha": "5a90bdc6eadf7cd119debf046b13a722c180932b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -11743,7 +11743,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case FOR_STMT:\n       stmt = begin_for_stmt ();\n-\t\t\t  RECUR (FOR_INIT_STMT (t));\n+      RECUR (FOR_INIT_STMT (t));\n       finish_for_init_stmt (stmt);\n       tmp = RECUR (FOR_COND (t));\n       finish_for_cond (tmp, stmt);\n@@ -11753,6 +11753,20 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       finish_for_stmt (stmt);\n       break;\n \n+    case RANGE_FOR_STMT:\n+      {\n+        tree decl, expr;\n+        stmt = begin_for_stmt ();\n+        decl = RANGE_FOR_DECL (t);\n+        decl = tsubst (decl, args, complain, in_decl);\n+        maybe_push_decl (decl);\n+        expr = RECUR (RANGE_FOR_EXPR (t));\n+        stmt = cp_convert_range_for (stmt, decl, expr);\n+        RECUR (RANGE_FOR_BODY (t));\n+        finish_for_stmt (stmt);\n+      }\n+      break;\n+\n     case WHILE_STMT:\n       stmt = begin_while_stmt ();\n       tmp = RECUR (WHILE_COND (t));\n@@ -12537,7 +12551,7 @@ tsubst_copy_and_build (tree t,\n \t       into a non-dependent call.  */\n \t    && type_dependent_expression_p_push (t)\n \t    && !any_type_dependent_arguments_p (call_args))\n-\t  function = perform_koenig_lookup (function, call_args);\n+\t  function = perform_koenig_lookup (function, call_args, false);\n \n \tif (TREE_CODE (function) == IDENTIFIER_NODE)\n \t  {"}, {"sha": "0ae00e47221ba7a04a74eee7d493245f89460c58", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -876,15 +876,27 @@ finish_for_expr (tree expr, tree for_stmt)\n \n /* Finish the body of a for-statement, which may be given by\n    FOR_STMT.  The increment-EXPR for the loop must be\n-   provided.  */\n+   provided.\n+   It can also finish RANGE_FOR_STMT. */\n \n void\n finish_for_stmt (tree for_stmt)\n {\n-  FOR_BODY (for_stmt) = do_poplevel (FOR_BODY (for_stmt));\n+  bool scoped;\n+\n+  if (TREE_CODE (for_stmt) == RANGE_FOR_STMT)\n+    {\n+      RANGE_FOR_BODY (for_stmt) = do_poplevel (RANGE_FOR_BODY (for_stmt));\n+      scoped = true;\n+    }\n+  else\n+    {\n+      FOR_BODY (for_stmt) = do_poplevel (FOR_BODY (for_stmt));\n+      scoped = flag_new_for_scope > 0;\n+    }\n \n   /* Pop the scope for the body of the loop.  */\n-  if (flag_new_for_scope > 0)\n+  if (scoped)\n     {\n       tree scope = TREE_CHAIN (for_stmt);\n       TREE_CHAIN (for_stmt) = NULL;\n@@ -894,6 +906,34 @@ finish_for_stmt (tree for_stmt)\n   finish_stmt ();\n }\n \n+/* Begin a range-for-statement.  Returns a new RANGE_FOR_STMT.\n+   To finish it call finish_for_stmt(). */\n+\n+tree\n+begin_range_for_stmt (void)\n+{\n+  tree r;\n+  r = build_stmt (input_location, RANGE_FOR_STMT,\n+\t\t  NULL_TREE, NULL_TREE, NULL_TREE);\n+  /* We can ignore flag_new_for_scope here. */\n+  TREE_CHAIN (r) = do_pushlevel (sk_for);\n+\n+  return r;\n+}\n+\n+/* Finish the head of a range-based for statement, which may\n+   be given by RANGE_FOR_STMT. DECL must be the declaration\n+   and EXPR must be the loop expression. */\n+\n+void\n+finish_range_for_decl (tree range_for_stmt, tree decl, tree expr)\n+{\n+  RANGE_FOR_DECL (range_for_stmt) = decl;\n+  RANGE_FOR_EXPR (range_for_stmt) = expr;\n+  add_stmt (range_for_stmt);\n+  RANGE_FOR_BODY (range_for_stmt) = do_pushlevel (sk_block);\n+}\n+\n /* Finish a break-statement.  */\n \n tree\n@@ -1839,11 +1879,12 @@ empty_expr_stmt_p (tree expr_stmt)\n \n /* Perform Koenig lookup.  FN is the postfix-expression representing\n    the function (or functions) to call; ARGS are the arguments to the\n-   call.  Returns the functions to be considered by overload\n-   resolution.  */\n+   call; if INCLUDE_STD then the `std' namespace is automatically\n+   considered an associated namespace (used in range-based for loops).\n+   Returns the functions to be considered by overload resolution.  */\n \n tree\n-perform_koenig_lookup (tree fn, VEC(tree,gc) *args)\n+perform_koenig_lookup (tree fn, VEC(tree,gc) *args, bool include_std)\n {\n   tree identifier = NULL_TREE;\n   tree functions = NULL_TREE;\n@@ -1879,7 +1920,7 @@ perform_koenig_lookup (tree fn, VEC(tree,gc) *args)\n   if (!any_type_dependent_arguments_p (args)\n       && !any_dependent_template_arguments_p (tmpl_args))\n     {\n-      fn = lookup_arg_dependent (identifier, functions, args);\n+      fn = lookup_arg_dependent (identifier, functions, args, include_std);\n       if (!fn)\n \t/* The unqualified name could not be resolved.  */\n \tfn = unqualified_fn_lookup_error (identifier);"}, {"sha": "d215b7e2d13201edba49e3769229f2f7adf5d03b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -1,3 +1,12 @@\n+2010-09-11  Rodrigo Rivas <rodrigorivascosta@gmail.com>\n+\n+\t* g++.dg/cpp0x/range-for1.C: New.\n+\t* g++.dg/cpp0x/range-for2.C: New.\n+\t* g++.dg/cpp0x/range-for3.C: New.\n+\t* g++.dg/cpp0x/range-for4.C: New.\n+\t* g++.dg/cpp0x/range-for5.C: New.\n+\t* g++.dg/cpp0x/range-for6.C: New.\n+\n 2010-09-11  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* gfortran.dg/inline_transpose_1.f90: Update temporary's locations"}, {"sha": "49e2ecd0bde65d589c1a84b8ba2bfc40ec48fc61", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for1.C?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -0,0 +1,17 @@\n+// Test for range-based for loop\n+// Test the loop with an array\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+extern \"C\" void abort();\n+\n+int main()\n+{\n+    int a[] = {1,2,3,4};\n+    int sum = 0;\n+    for (int x : a)\n+        sum += x;\n+    if (sum != 10)\n+        abort();\n+}"}, {"sha": "bfab37673a141860d0ef42114e368cc239ab568d", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for2.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for2.C?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -0,0 +1,41 @@\n+// Test for range-based for loop\n+// Test the loop with a custom iterator\n+// with begin/end in an associated namespace\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+struct iterator\n+{\n+    int x;\n+    iterator(int v) :x(v) {}\n+    iterator &operator ++() { ++x; return *this; }\n+    int operator *() { return x; }\n+    bool operator != (const iterator &o) { return x != o.x; }\n+};\n+\n+namespace foo\n+{\n+    struct container\n+    {\n+        int min, max;\n+        container(int a, int b) :min(a), max(b) {}\n+    };\n+\n+    iterator begin(container &c)\n+    {\n+        return iterator(c.min);\n+    }\n+\n+    iterator end(container &c)\n+    {\n+        return iterator(c.max + 1);\n+    }\n+}\n+\n+int main()\n+{\n+    foo::container c(1,4);\n+    for (iterator it : c)\n+        ;\n+}"}, {"sha": "947f01ced74d53690c4271f393a492875d96e695", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for3.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for3.C?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -0,0 +1,42 @@\n+// Test for range-based for loop\n+// Test the loop with a custom iterator\n+// with begin/end in std\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+struct iterator\n+{\n+    int x;\n+    iterator(int v) :x(v) {}\n+    iterator &operator ++() { ++x; return *this; }\n+    int operator *() { return x; }\n+    bool operator != (const iterator &o) { return x != o.x; }\n+};\n+\n+struct container\n+{\n+    int min, max;\n+    container(int a, int b) :min(a), max(b) {}\n+};\n+\n+namespace std\n+{\n+    iterator begin(container &c)\n+    {\n+        return iterator(c.min);\n+    }\n+\n+    iterator end(container &c)\n+    {\n+        return iterator(c.max + 1);\n+    }\n+}\n+\n+int main()\n+{\n+    container c(1,4);\n+    for (iterator it : c)\n+    {\n+    }\n+}"}, {"sha": "96c0d90f0f02b1badd5dc8681ea63f9091c46923", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for4.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for4.C?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -0,0 +1,119 @@\n+// Test for range-based for loop with templates\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cstdio>\n+\n+/* Preliminary declarations */\n+namespace pre\n+{\n+  struct iterator\n+  {\n+    int x;\n+    iterator (int v) :x(v) {}\n+    iterator &operator ++() { ++x; return *this; }\n+    int operator *() { return x; }\n+    bool operator != (const iterator &o) { return x != o.x; }\n+  };\n+\n+  struct container\n+  {\n+    int min, max;\n+    container(int a, int b) :min(a), max(b) {}\n+  };\n+\n+  iterator begin(const container &c)\n+  {\n+    return iterator(c.min);\n+  }\n+\n+  iterator end(const container &c)\n+  {\n+    return iterator(c.max);\n+  }\n+\n+} //namespace pre\n+\n+using pre::container;\n+extern \"C\" void abort(void);\n+\n+container run_me_just_once()\n+{\n+    static bool run = false;\n+    if (run)\n+        abort();\n+    run = true;\n+    return container(1,2);\n+}\n+\n+/* Template with dependent expression. */\n+/* Template with dependent expression. */\n+template<typename T> int test1(const T &r)\n+{\n+  int t = 0;\n+  for (int i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression and dependent declaration. */\n+template<typename T> int test2(const container &r)\n+{\n+  int t = 0;\n+  for (T i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression (array) and dependent declaration. */\n+template<typename T> int test2(const int (&r)[4])\n+{\n+  int t = 0;\n+  for (T i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression and auto declaration. */\n+template<typename T> int test3(const container &r)\n+{\n+  int t = 0;\n+  for (auto i : r)\n+    t += i;\n+  return t;\n+}\n+\n+/* Template with non-dependent expression (array) and auto declaration. */\n+template<typename T> int test3(const int (&r)[4])\n+{\n+  int t = 0;\n+  for (auto i : r)\n+    t += i;\n+  return t;\n+}\n+\n+int main ()\n+{\n+  container c(1,5);\n+  int a[4] = {5,6,7,8};\n+\n+  for (auto x : run_me_just_once())\n+      ;\n+\n+  if (test1 (c) != 10)\n+    abort();\n+  if (test1 (a) != 26)\n+    abort();\n+\n+  if (test2<int> (c) != 10)\n+    abort();\n+  if (test2<int> (a) != 26)\n+    abort();\n+\n+  if (test3<int> (c) != 10)\n+    abort();\n+  if (test3<int> (a) != 26)\n+    abort();\n+  return 0;\n+}"}, {"sha": "9c97ad5faf08d32d6436bc178f2c2c446483edc2", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for5.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for5.C?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -0,0 +1,54 @@\n+// Test for errors in range-based for loops\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+struct container\n+{\n+};\n+\n+int *begin(const container &c)\n+{\n+  return 0;\n+}\n+\n+int end(const container &c) //Ops! wrong type\n+{\n+  return 0;\n+}\n+\n+\n+struct Implicit\n+{\n+  Implicit(int x)\n+  {}\n+};\n+struct Explicit\n+{\n+  explicit Explicit(int x)\n+  {}\n+};\n+\n+void test1()\n+{\n+  container c;\n+  for (int x : c) // { dg-error \"inconsistent|conversion\" }\n+    ;\n+\n+  int a[2] = {1,2};\n+  for (Implicit x : a)\n+    ;\n+  for (Explicit x : a) // { dg-error \"conversion\" }\n+    ;\n+  for (const Implicit &x : a)\n+    ;\n+  for (Implicit &&x : a)\n+    ;\n+\n+  //Check the correct scopes\n+  int i;\n+  for (int i : a)\n+  {\n+    int i;\n+  }\n+}"}, {"sha": "775507f8de86474aee02b7766ea01741f2775fce", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for6.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for6.C?ref=f9132eb797d897b8e66b8e8ddb3e8e2744b6ac51", "patch": "@@ -0,0 +1,29 @@\n+// Test for range-based for loop\n+// Test the loop with an initializer_list\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+extern \"C\" void abort();\n+\n+template<typename T> T foo()\n+{\n+    T sum = 0;\n+    for (T x : {T(1),T(2),T(3),T(4)})\n+        sum += x;\n+    if (sum != T(10))\n+        abort();\n+}\n+\n+int main()\n+{\n+    int sum = 0;\n+    for (int x : {1,2,3,4})\n+        sum += x;\n+    if (sum != 10)\n+        abort();\n+\n+    foo<int>();\n+}"}]}