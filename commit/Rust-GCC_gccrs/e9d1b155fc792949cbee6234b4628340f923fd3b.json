{"sha": "e9d1b155fc792949cbee6234b4628340f923fd3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlkMWIxNTVmYzc5Mjk0OWNiZWU2MjM0YjQ2MjgzNDBmOTIzZmQzYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-21T13:08:33Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-21T13:08:33Z"}, "message": "unwind-dw2.c: Fix formatting.\n\n\t* unwind-dw2.c: Fix formatting.\n\t* unwind-dw2-fde.c: Likewise.\n\t* unwind-dw2-fde.h: Likewise.\n\t* unwind-pe.h: Likewise.\n\t* varasm.c: Likewise.\n\t* varray.h: Likewise.\n\nFrom-SVN: r49045", "tree": {"sha": "b37184c9d20bd8707d7e11cb003fcd7410dbb228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b37184c9d20bd8707d7e11cb003fcd7410dbb228"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9d1b155fc792949cbee6234b4628340f923fd3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d1b155fc792949cbee6234b4628340f923fd3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d1b155fc792949cbee6234b4628340f923fd3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d1b155fc792949cbee6234b4628340f923fd3b/comments", "author": null, "committer": null, "parents": [{"sha": "e23baf78dfdb9a21bb2badbd05add51054cd04ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e23baf78dfdb9a21bb2badbd05add51054cd04ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e23baf78dfdb9a21bb2badbd05add51054cd04ac"}], "stats": {"total": 95, "additions": 52, "deletions": 43}, "files": [{"sha": "b83e503df73167f259868784b4abda0074e67239", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9d1b155fc792949cbee6234b4628340f923fd3b", "patch": "@@ -1,3 +1,12 @@\n+2002-01-21  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* unwind-dw2.c: Fix formatting.\n+\t* unwind-dw2-fde.c: Likewise.\n+\t* unwind-dw2-fde.h: Likewise.\n+\t* unwind-pe.h: Likewise.\n+\t* varasm.c: Likewise.\n+\t* varray.h: Likewise.\n+\n 2002-01-21  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \tRemove workaround for register stack overwrite bug in mmix."}, {"sha": "460d7f0d80f13583fc39ab5ff76fe64206dca483", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=e9d1b155fc792949cbee6234b4628340f923fd3b", "patch": "@@ -76,7 +76,7 @@ __register_frame_info_bases (void *begin, struct object *ob,\n \t\t\t     void *tbase, void *dbase)\n {\n   /* If .eh_frame is empty, don't register at all.  */\n-  if (*(uword *)begin == 0)\n+  if (*(uword *) begin == 0)\n     return;\n \n   ob->pc_begin = (void *)-1;\n@@ -107,7 +107,7 @@ __register_frame (void *begin)\n   struct object *ob;\n \n   /* If .eh_frame is empty, don't register at all.  */\n-  if (*(uword *)begin == 0)\n+  if (*(uword *) begin == 0)\n     return;\n \n   ob = (struct object *) malloc (sizeof (struct object));\n@@ -171,7 +171,7 @@ __deregister_frame_info_bases (void *begin)\n   struct object *ob = 0;\n \n   /* If .eh_frame is empty, we haven't registered.  */\n-  if (*(uword *)begin == 0)\n+  if (*(uword *) begin == 0)\n     return ob;\n \n   init_object_mutex_once ();\n@@ -224,7 +224,7 @@ void\n __deregister_frame (void *begin)\n {\n   /* If .eh_frame is empty, we haven't registered.  */\n-  if (*(uword *)begin != 0)\n+  if (*(uword *) begin != 0)\n     free (__deregister_frame_info (begin));\n }\n \n@@ -443,10 +443,10 @@ fde_split (struct object *ob, fde_compare_t fde_compare,\n            probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;\n            probe = chain_end)\n         {\n-          chain_end = (fde **)erratic->array[probe - linear->array];\n+          chain_end = (fde **) erratic->array[probe - linear->array];\n           erratic->array[probe - linear->array] = NULL;\n         }\n-      erratic->array[i] = (fde *)chain_end;\n+      erratic->array[i] = (fde *) chain_end;\n       chain_end = &linear->array[i];\n     }\n \n@@ -642,8 +642,8 @@ classify_object_over_fdes (struct object *ob, fde *this_fde)\n \tcontinue;\n \n       count += 1;\n-      if ((void *)pc_begin < ob->pc_begin)\n-\tob->pc_begin = (void *)pc_begin;\n+      if ((void *) pc_begin < ob->pc_begin)\n+\tob->pc_begin = (void *) pc_begin;\n     }\n \n   return count;\n@@ -679,7 +679,7 @@ add_fdes (struct object *ob, struct fde_accumulator *accu, fde *this_fde)\n \n       if (encoding == DW_EH_PE_absptr)\n \t{\n-\t  if (*(_Unwind_Ptr *)this_fde->pc_begin == 0)\n+\t  if (*(_Unwind_Ptr *) this_fde->pc_begin == 0)\n \t    continue;\n \t}\n       else\n@@ -797,8 +797,8 @@ linear_search_fdes (struct object *ob, fde *this_fde, void *pc)\n \n       if (encoding == DW_EH_PE_absptr)\n \t{\n-\t  pc_begin = ((_Unwind_Ptr *)this_fde->pc_begin)[0];\n-\t  pc_range = ((_Unwind_Ptr *)this_fde->pc_begin)[1];\n+\t  pc_begin = ((_Unwind_Ptr *) this_fde->pc_begin)[0];\n+\t  pc_range = ((_Unwind_Ptr *) this_fde->pc_begin)[1];\n \t  if (pc_begin == 0)\n \t    continue;\n \t}\n@@ -825,7 +825,7 @@ linear_search_fdes (struct object *ob, fde *this_fde, void *pc)\n \t    continue;\n \t}\n \n-      if ((_Unwind_Ptr)pc - pc_begin < pc_range)\n+      if ((_Unwind_Ptr) pc - pc_begin < pc_range)\n         return this_fde;\n     }\n \n@@ -848,8 +848,8 @@ binary_search_unencoded_fdes (struct object *ob, void *pc)\n       void *pc_begin;\n       uaddr pc_range;\n \n-      pc_begin = ((void **)f->pc_begin)[0];\n-      pc_range = ((uaddr *)f->pc_begin)[1];\n+      pc_begin = ((void **) f->pc_begin)[0];\n+      pc_range = ((uaddr *) f->pc_begin)[1];\n \n       if (pc < pc_begin)\n \thi = i;\n@@ -881,9 +881,9 @@ binary_search_single_encoding_fdes (struct object *ob, void *pc)\n \t\t\t\t\t&pc_begin);\n       read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);\n \n-      if ((_Unwind_Ptr)pc < pc_begin)\n+      if ((_Unwind_Ptr) pc < pc_begin)\n \thi = i;\n-      else if ((_Unwind_Ptr)pc >= pc_begin + pc_range)\n+      else if ((_Unwind_Ptr) pc >= pc_begin + pc_range)\n \tlo = i + 1;\n       else\n \treturn f;\n@@ -912,9 +912,9 @@ binary_search_mixed_encoding_fdes (struct object *ob, void *pc)\n \t\t\t\t\tf->pc_begin, &pc_begin);\n       read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);\n \n-      if ((_Unwind_Ptr)pc < pc_begin)\n+      if ((_Unwind_Ptr) pc < pc_begin)\n \thi = i;\n-      else if ((_Unwind_Ptr)pc >= pc_begin + pc_range)\n+      else if ((_Unwind_Ptr) pc >= pc_begin + pc_range)\n \tlo = i + 1;\n       else\n \treturn f;"}, {"sha": "b06ff41133f8047c6f52e446d98429bf658f2a2f", "filename": "gcc/unwind-dw2-fde.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-dw2-fde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-dw2-fde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.h?ref=e9d1b155fc792949cbee6234b4628340f923fd3b", "patch": "@@ -156,7 +156,7 @@ get_cie (struct dwarf_fde *f)\n static inline fde *\n next_fde (fde *f)\n {\n-  return (fde *)((char *)f + f->length + sizeof (f->length));\n+  return (fde *) ((char *) f + f->length + sizeof (f->length));\n }\n \n extern fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);"}, {"sha": "d3828e97ad4e3da4130fec68ec7a7144d7abff1a", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=e9d1b155fc792949cbee6234b4628340f923fd3b", "patch": "@@ -132,10 +132,10 @@ static inline void *\n read_pointer (const void *p) { const union unaligned *up = p; return up->p; }\n \n static inline int\n-read_1u (const void *p) { return *(const unsigned char *)p; }\n+read_1u (const void *p) { return *(const unsigned char *) p; }\n \n static inline int\n-read_1s (const void *p) { return *(const signed char *)p; }\n+read_1s (const void *p) { return *(const signed char *) p; }\n \n static inline int\n read_2u (const void *p) { const union unaligned *up = p; return up->u2; }\n@@ -600,13 +600,13 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t      result = second & first;\n \t      break;\n \t    case DW_OP_div:\n-\t      result = (_Unwind_Sword)second / (_Unwind_Sword)first;\n+\t      result = (_Unwind_Sword) second / (_Unwind_Sword) first;\n \t      break;\n \t    case DW_OP_minus:\n \t      result = second - first;\n \t      break;\n \t    case DW_OP_mod:\n-\t      result = (_Unwind_Sword)second % (_Unwind_Sword)first;\n+\t      result = (_Unwind_Sword) second % (_Unwind_Sword) first;\n \t      break;\n \t    case DW_OP_mul:\n \t      result = second * first;\n@@ -624,28 +624,28 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t      result = second >> first;\n \t      break;\n \t    case DW_OP_shra:\n-\t      result = (_Unwind_Sword)second >> first;\n+\t      result = (_Unwind_Sword) second >> first;\n \t      break;\n \t    case DW_OP_xor:\n \t      result = second ^ first;\n \t      break;\n \t    case DW_OP_le:\n-\t      result = (_Unwind_Sword)first <= (_Unwind_Sword)second;\n+\t      result = (_Unwind_Sword) first <= (_Unwind_Sword) second;\n \t      break;\n \t    case DW_OP_ge:\n-\t      result = (_Unwind_Sword)first >= (_Unwind_Sword)second;\n+\t      result = (_Unwind_Sword) first >= (_Unwind_Sword) second;\n \t      break;\n \t    case DW_OP_eq:\n-\t      result = (_Unwind_Sword)first == (_Unwind_Sword)second;\n+\t      result = (_Unwind_Sword) first == (_Unwind_Sword) second;\n \t      break;\n \t    case DW_OP_lt:\n-\t      result = (_Unwind_Sword)first < (_Unwind_Sword)second;\n+\t      result = (_Unwind_Sword) first < (_Unwind_Sword) second;\n \t      break;\n \t    case DW_OP_gt:\n-\t      result = (_Unwind_Sword)first > (_Unwind_Sword)second;\n+\t      result = (_Unwind_Sword) first > (_Unwind_Sword) second;\n \t      break;\n \t    case DW_OP_ne:\n-\t      result = (_Unwind_Sword)first != (_Unwind_Sword)second;\n+\t      result = (_Unwind_Sword) first != (_Unwind_Sword) second;\n \t      break;\n \n \t    default:\n@@ -725,7 +725,7 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t{\n \t  reg = insn & 0x3f;\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n-\t  offset = (_Unwind_Sword)utmp * fs->data_align;\n+\t  offset = (_Unwind_Sword) utmp * fs->data_align;\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = offset;\n \t}\n@@ -757,7 +757,7 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \tcase DW_CFA_offset_extended:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n-\t  offset = (_Unwind_Sword)utmp * fs->data_align;\n+\t  offset = (_Unwind_Sword) utmp * fs->data_align;\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = offset;\n \t  break;\n@@ -878,7 +878,7 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t     older PowerPC code.  */\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n-\t  offset = (_Unwind_Word)utmp * fs->data_align;\n+\t  offset = (_Unwind_Word) utmp * fs->data_align;\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = -offset;\n \t  break;\n@@ -929,7 +929,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n   execute_cfa_program (insn, end, context, fs);\n \n   /* Locate augmentation for the fde.  */\n-  aug = (unsigned char *)fde + sizeof (*fde);\n+  aug = (unsigned char *) fde + sizeof (*fde);\n   aug += 2 * size_of_encoded_value (fs->fde_encoding);\n   insn = NULL;\n   if (fs->saw_z)"}, {"sha": "01e05ebf34c07efc43d66a8edf4142fe107222a9", "filename": "gcc/unwind-pe.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Funwind-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-pe.h?ref=e9d1b155fc792949cbee6234b4628340f923fd3b", "patch": "@@ -183,10 +183,10 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n \n   if (encoding == DW_EH_PE_aligned)\n     {\n-      _Unwind_Ptr a = (_Unwind_Ptr)p;\n+      _Unwind_Ptr a = (_Unwind_Ptr) p;\n       a = (a + sizeof (void *) - 1) & - sizeof(void *);\n       result = *(_Unwind_Ptr *) a;\n-      p = (const unsigned char *)(a + sizeof (void *));\n+      p = (const unsigned char *) (a + sizeof (void *));\n     }\n   else\n     {\n@@ -201,15 +201,15 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n \t  {\n \t    _Unwind_Word tmp;\n \t    p = read_uleb128 (p, &tmp);\n-\t    result = (_Unwind_Ptr)tmp;\n+\t    result = (_Unwind_Ptr) tmp;\n \t  }\n \t  break;\n \n \tcase DW_EH_PE_sleb128:\n \t  {\n \t    _Unwind_Sword tmp;\n \t    p = read_sleb128 (p, &tmp);\n-\t    result = (_Unwind_Ptr)tmp;\n+\t    result = (_Unwind_Ptr) tmp;\n \t  }\n \t  break;\n \n@@ -246,9 +246,9 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n       if (result != 0)\n \t{\n \t  result += ((encoding & 0x70) == DW_EH_PE_pcrel\n-\t\t     ? (_Unwind_Ptr)u : base);\n+\t\t     ? (_Unwind_Ptr) u : base);\n \t  if (encoding & DW_EH_PE_indirect)\n-\t    result = *(_Unwind_Ptr *)result;\n+\t    result = *(_Unwind_Ptr *) result;\n \t}\n     }\n "}, {"sha": "955a98e9c6ce6b6c35b1193bb2a8beb5729070d5", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e9d1b155fc792949cbee6234b4628340f923fd3b", "patch": "@@ -2684,7 +2684,7 @@ compare_constant_1 (exp, p)\n       if ((enum machine_mode) *p++ != TYPE_MODE (TREE_TYPE (exp)))\n \treturn 0;\n \n-      strp = (const unsigned char *)TREE_STRING_POINTER (exp);\n+      strp = (const unsigned char *) TREE_STRING_POINTER (exp);\n       len = TREE_STRING_LENGTH (exp);\n       if (memcmp ((char *) &TREE_STRING_LENGTH (exp), p,\n \t\t  sizeof TREE_STRING_LENGTH (exp)))"}, {"sha": "66c4d39a3a6c4e58178d18263aaf0d9355c05ee4", "filename": "gcc/varray.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d1b155fc792949cbee6234b4628340f923fd3b/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=e9d1b155fc792949cbee6234b4628340f923fd3b", "patch": "@@ -1,5 +1,5 @@\n /* Virtual array support.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n    Contributed by Cygnus Solutions.\n \n    This file is part of GCC.\n@@ -159,7 +159,7 @@ extern varray_type varray_init\tPARAMS ((size_t, size_t, const char *));\n /* Free up memory allocated by the virtual array, but do not free any of the\n    elements involved.  */\n #define VARRAY_FREE(vp) \\\n-  do { if (vp) { free (vp); vp = (varray_type)0; } } while (0)\n+  do { if (vp) { free (vp); vp = (varray_type) 0; } } while (0)\n \n /* Grow/shrink the virtual array VA to N elements.  */\n extern varray_type varray_grow\tPARAMS ((varray_type, size_t));"}]}