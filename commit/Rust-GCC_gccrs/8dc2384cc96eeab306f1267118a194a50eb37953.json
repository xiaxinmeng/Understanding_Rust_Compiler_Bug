{"sha": "8dc2384cc96eeab306f1267118a194a50eb37953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjMjM4NGNjOTZlZWFiMzA2ZjEyNjcxMThhMTk0YTUwZWIzNzk1Mw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-05-08T17:36:21Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-05-08T17:36:21Z"}, "message": "fold-const.c (fold_div_compare): New function to optimize X/C1 op C2 where op is a comparison operator and C1...\n\n\n\t* fold-const.c (fold_div_compare): New function to optimize X/C1 op C2\n\twhere op is a comparison operator and C1 and C2 are integer constants\n\tinto a range check.\n\t(fold): Call fold_div_compare.\n\n\t* gcc.c-torture/execute/divcmp-1.c: New test case.\n\t* gcc.c-torture/execute/divcmp-2.c: New test case.\n\t* gcc.c-torture/execute/divcmp-3.c: New test case.\n\nFrom-SVN: r81645", "tree": {"sha": "ed0f064da7a01d71c6b87b252c9b06aeea96bed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed0f064da7a01d71c6b87b252c9b06aeea96bed9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc2384cc96eeab306f1267118a194a50eb37953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc2384cc96eeab306f1267118a194a50eb37953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc2384cc96eeab306f1267118a194a50eb37953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc2384cc96eeab306f1267118a194a50eb37953/comments", "author": null, "committer": null, "parents": [{"sha": "ae81c844737f88dbe4420faca7fdebcbfb80861f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae81c844737f88dbe4420faca7fdebcbfb80861f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae81c844737f88dbe4420faca7fdebcbfb80861f"}], "stats": {"total": 723, "additions": 723, "deletions": 0}, "files": [{"sha": "9b395e8d68daf011283130da3055e7d42dc325d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dc2384cc96eeab306f1267118a194a50eb37953", "patch": "@@ -1,3 +1,10 @@\n+2004-05-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_div_compare): New function to optimize X/C1 op C2\n+\twhere op is a comparison operator and C1 and C2 are integer constants\n+\tinto a range check.\n+\t(fold): Call fold_div_compare.\n+\n 2004-05-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* doc/install.texi (sparc-sun-solaris2*): Document bootstrap"}, {"sha": "7d04db613079f7c089c9dd8e9c0ecde957df73cc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8dc2384cc96eeab306f1267118a194a50eb37953", "patch": "@@ -109,6 +109,7 @@ static bool fold_real_zero_addition_p (tree, tree, int);\n static tree fold_mathfn_compare (enum built_in_function, enum tree_code,\n \t\t\t\t tree, tree, tree);\n static tree fold_inf_compare (enum tree_code, tree, tree, tree);\n+static tree fold_div_compare (enum tree_code, tree, tree, tree);\n static bool reorder_operands_p (tree, tree);\n static bool tree_swap_operands_p (tree, tree, bool);\n \n@@ -5215,6 +5216,156 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n   return NULL_TREE;\n }\n \n+/* Subroutine of fold() that optimizes comparisons of a division by\n+   a non-zero integer constant against an integer constant, i.e.\n+   X/C1 op C2.\n+\n+   CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,\n+   GE_EXPR or LE_EXPR.  TYPE is the type of the result and ARG0 and ARG1\n+   are the operands of the comparison.  ARG1 must be a TREE_REAL_CST.\n+\n+   The function returns the constant folded tree if a simplification\n+   can be made, and NULL_TREE otherwise.  */\n+\n+static tree\n+fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n+{\n+  tree prod, tmp, hi, lo;\n+  tree arg00 = TREE_OPERAND (arg0, 0);\n+  tree arg01 = TREE_OPERAND (arg0, 1);\n+  unsigned HOST_WIDE_INT lpart;\n+  HOST_WIDE_INT hpart;\n+  int overflow;\n+\n+  /* We have to do this the hard way to detect unsigned overflow.\n+     prod = int_const_binop (MULT_EXPR, arg01, arg1, 0);  */\n+  overflow = mul_double (TREE_INT_CST_LOW (arg01),\n+\t\t\t TREE_INT_CST_HIGH (arg01),\n+\t\t\t TREE_INT_CST_LOW (arg1),\n+\t\t\t TREE_INT_CST_HIGH (arg1), &lpart, &hpart);\n+  prod = build_int_2 (lpart, hpart);\n+  TREE_TYPE (prod) = TREE_TYPE (arg00);\n+  TREE_OVERFLOW (prod) = force_fit_type (prod, overflow)\n+\t\t\t || TREE_INT_CST_HIGH (prod) != hpart\n+\t\t\t || TREE_INT_CST_LOW (prod) != lpart;\n+  TREE_CONSTANT_OVERFLOW (prod) = TREE_OVERFLOW (prod);\n+\n+  if (TYPE_UNSIGNED (TREE_TYPE (arg0)))\n+    {\n+      tmp = int_const_binop (MINUS_EXPR, arg01, integer_one_node, 0);\n+      lo = prod;\n+\n+      /* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp, 0).  */\n+      overflow = add_double (TREE_INT_CST_LOW (prod),\n+\t\t\t     TREE_INT_CST_HIGH (prod),\n+\t\t\t     TREE_INT_CST_LOW (tmp),\n+\t\t\t     TREE_INT_CST_HIGH (tmp),\n+\t\t\t     &lpart, &hpart);\n+      hi = build_int_2 (lpart, hpart);\n+      TREE_TYPE (hi) = TREE_TYPE (arg00);\n+      TREE_OVERFLOW (hi) = force_fit_type (hi, overflow)\n+\t\t\t   || TREE_INT_CST_HIGH (hi) != hpart\n+\t\t\t   || TREE_INT_CST_LOW (hi) != lpart\n+\t\t\t   || TREE_OVERFLOW (prod);\n+      TREE_CONSTANT_OVERFLOW (hi) = TREE_OVERFLOW (hi);\n+    }\n+  else if (tree_int_cst_sgn (arg01) >= 0)\n+    {\n+      tmp = int_const_binop (MINUS_EXPR, arg01, integer_one_node, 0);\n+      switch (tree_int_cst_sgn (arg1))\n+\t{\n+\tcase -1:\n+\t  lo = int_const_binop (MINUS_EXPR, prod, tmp, 0);\n+\t  hi = prod;\n+\t  break;\n+\n+\tcase  0:\n+\t  lo = fold_negate_const (tmp, TREE_TYPE (arg0));\n+\t  hi = tmp;\n+\t  break;\n+\n+\tcase  1:\n+          hi = int_const_binop (PLUS_EXPR, prod, tmp, 0);\n+\t  lo = prod;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  else\n+    {\n+      tmp = int_const_binop (PLUS_EXPR, arg01, integer_one_node, 0);\n+      switch (tree_int_cst_sgn (arg1))\n+\t{\n+\tcase -1:\n+\t  hi = int_const_binop (MINUS_EXPR, prod, tmp, 0);\n+\t  lo = prod;\n+\t  break;\n+\n+\tcase  0:\n+\t  hi = fold_negate_const (tmp, TREE_TYPE (arg0));\n+\t  lo = tmp;\n+\t  break;\n+\n+\tcase  1:\n+          lo = int_const_binop (PLUS_EXPR, prod, tmp, 0);\n+\t  hi = prod;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+      if (TREE_OVERFLOW (lo) && TREE_OVERFLOW (hi))\n+\treturn omit_one_operand (type, integer_zero_node, arg00);\n+      if (TREE_OVERFLOW (hi))\n+\treturn fold (build2 (GE_EXPR, type, arg00, lo));\n+      if (TREE_OVERFLOW (lo))\n+\treturn fold (build2 (LE_EXPR, type, arg00, hi));\n+      return build_range_check (type, arg00, 1, lo, hi);\n+\n+    case NE_EXPR:\n+      if (TREE_OVERFLOW (lo) && TREE_OVERFLOW (hi))\n+\treturn omit_one_operand (type, integer_one_node, arg00);\n+      if (TREE_OVERFLOW (hi))\n+\treturn fold (build2 (LT_EXPR, type, arg00, lo));\n+      if (TREE_OVERFLOW (lo))\n+\treturn fold (build2 (GT_EXPR, type, arg00, hi));\n+      return build_range_check (type, arg00, 0, lo, hi);\n+\n+    case LT_EXPR:\n+      if (TREE_OVERFLOW (lo))\n+\treturn omit_one_operand (type, integer_zero_node, arg00);\n+      return fold (build2 (LT_EXPR, type, arg00, lo));\n+\n+    case LE_EXPR:\n+      if (TREE_OVERFLOW (hi))\n+\treturn omit_one_operand (type, integer_one_node, arg00);\n+      return fold (build2 (LE_EXPR, type, arg00, hi));\n+\n+    case GT_EXPR:\n+      if (TREE_OVERFLOW (hi))\n+\treturn omit_one_operand (type, integer_zero_node, arg00);\n+      return fold (build2 (GT_EXPR, type, arg00, hi));\n+\n+    case GE_EXPR:\n+      if (TREE_OVERFLOW (lo))\n+\treturn omit_one_operand (type, integer_one_node, arg00);\n+      return fold (build2 (GE_EXPR, type, arg00, lo));\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n /* If CODE with arguments ARG0 and ARG1 represents a single bit\n    equality/inequality test, then return a simplified form of\n    the test using shifts and logical operations.  Otherwise return\n@@ -7902,6 +8053,20 @@ fold (tree expr)\n \t\t\t\tinteger_zero_node));\n \t}\n \n+      /* We can fold X/C1 op C2 where C1 and C2 are integer constants\n+\t into a single range test.  */\n+      if (TREE_CODE (arg0) == TRUNC_DIV_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t  && !integer_zerop (TREE_OPERAND (arg0, 1))\n+\t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n+\t  && !TREE_OVERFLOW (arg1))\n+\t{\n+\t  t1 = fold_div_compare (code, type, arg0, arg1);\n+\t  if (t1 != NULL_TREE)\n+\t    return t1;\n+\t}\n+\n       /* Both ARG0 and ARG1 are known to be constants at this point.  */\n       t1 = fold_relational_const (code, type, arg0, arg1);\n       return (t1 == NULL_TREE ? t : t1);"}, {"sha": "09ca29ab2a726f5aae9f09134bba3fa6af2a5ea6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8dc2384cc96eeab306f1267118a194a50eb37953", "patch": "@@ -1,3 +1,9 @@\n+2004-05-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/divcmp-1.c: New test case.\n+\t* gcc.c-torture/execute/divcmp-2.c: New test case.\n+\t* gcc.c-torture/execute/divcmp-3.c: New test case.\n+\n 2004-05-07  Eric Botcazou <ebotcazou@libertysurf.fr>\n \n \t* g++.dg/other/pragma-re-2.C: New test."}, {"sha": "0a7f305aa7c0c7d08acaff56f9b27e068fafff7d", "filename": "gcc/testsuite/gcc.c-torture/execute/divcmp-1.c", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-1.c?ref=8dc2384cc96eeab306f1267118a194a50eb37953", "patch": "@@ -0,0 +1,356 @@\n+extern void abort(void);\n+\n+int test1(int x)\n+{\n+  return x/10 == 2;\n+}\n+\n+int test1u(unsigned int x)\n+{\n+  return x/10U == 2;\n+}\n+\n+int test2(int x)\n+{\n+  return x/10 == 0;\n+}\n+\n+int test2u(unsigned int x)\n+{\n+  return x/10U == 0;\n+}\n+\n+int test3(int x)\n+{\n+  return x/10 != 2;\n+}\n+\n+int test3u(unsigned int x)\n+{\n+  return x/10U != 2;\n+}\n+\n+int test4(int x)\n+{\n+  return x/10 != 0;\n+}\n+\n+int test4u(unsigned int x)\n+{\n+  return x/10U != 0;\n+}\n+\n+int test5(int x)\n+{\n+  return x/10 < 2;\n+}\n+\n+int test5u(unsigned int x)\n+{\n+  return x/10U < 2;\n+}\n+\n+int test6(int x)\n+{\n+  return x/10 < 0;\n+}\n+\n+int test7(int x)\n+{\n+  return x/10  <= 2;\n+}\n+\n+int test7u(unsigned int x)\n+{\n+  return x/10U <= 2;\n+}\n+\n+int test8(int x)\n+{\n+  return x/10 <= 0;\n+}\n+\n+int test8u(unsigned int x)\n+{\n+  return x/10U <= 0;\n+}\n+\n+int test9(int x)\n+{\n+  return x/10 > 2;\n+}\n+\n+int test9u(unsigned int x)\n+{\n+  return x/10U > 2;\n+}\n+\n+int test10(int x)\n+{\n+  return x/10 > 0;\n+}\n+\n+int test10u(unsigned int x)\n+{\n+  return x/10U > 0;\n+}\n+\n+int test11(int x)\n+{\n+  return x/10 >= 2;\n+}\n+\n+int test11u(unsigned int x)\n+{\n+  return x/10U >= 2;\n+}\n+\n+int test12(int x)\n+{\n+  return x/10 >= 0;\n+}\n+\n+\n+int main()\n+{\n+  if (test1(19) != 0)\n+    abort ();\n+  if (test1(20) != 1)\n+    abort ();\n+  if (test1(29) != 1)\n+    abort ();\n+  if (test1(30) != 0)\n+    abort ();\n+\n+  if (test1u(19) != 0)\n+    abort ();\n+  if (test1u(20) != 1)\n+    abort ();\n+  if (test1u(29) != 1)\n+    abort ();\n+  if (test1u(30) != 0)\n+    abort ();\n+\n+  if (test2(0) != 1)\n+    abort ();\n+  if (test2(9) != 1)\n+    abort ();\n+  if (test2(10) != 0)\n+    abort ();\n+  if (test2(-1) != 1)\n+    abort ();\n+  if (test2(-9) != 1)\n+    abort ();\n+  if (test2(-10) != 0)\n+    abort ();\n+\n+  if (test2u(0) != 1)\n+    abort ();\n+  if (test2u(9) != 1)\n+    abort ();\n+  if (test2u(10) != 0)\n+    abort ();\n+  if (test2u(-1) != 0)\n+    abort ();\n+  if (test2u(-9) != 0)\n+    abort ();\n+  if (test2u(-10) != 0)\n+    abort ();\n+\n+  if (test3(19) != 1)\n+    abort ();\n+  if (test3(20) != 0)\n+    abort ();\n+  if (test3(29) != 0)\n+    abort ();\n+  if (test3(30) != 1)\n+    abort ();\n+\n+  if (test3u(19) != 1)\n+    abort ();\n+  if (test3u(20) != 0)\n+    abort ();\n+  if (test3u(29) != 0)\n+    abort ();\n+  if (test3u(30) != 1)\n+    abort ();\n+\n+  if (test4(0) != 0)\n+    abort ();\n+  if (test4(9) != 0)\n+    abort ();\n+  if (test4(10) != 1)\n+    abort ();\n+  if (test4(-1) != 0)\n+    abort ();\n+  if (test4(-9) != 0)\n+    abort ();\n+  if (test4(-10) != 1)\n+    abort ();\n+\n+  if (test4u(0) != 0)\n+    abort ();\n+  if (test4u(9) != 0)\n+    abort ();\n+  if (test4u(10) != 1)\n+    abort ();\n+  if (test4u(-1) != 1)\n+    abort ();\n+  if (test4u(-9) != 1)\n+    abort ();\n+  if (test4u(-10) != 1)\n+    abort ();\n+\n+  if (test5(19) != 1)\n+    abort ();\n+  if (test5(20) != 0)\n+    abort ();\n+  if (test5(29) != 0)\n+    abort ();\n+  if (test5(30) != 0)\n+    abort ();\n+\n+  if (test5u(19) != 1)\n+    abort ();\n+  if (test5u(20) != 0)\n+    abort ();\n+  if (test5u(29) != 0)\n+    abort ();\n+  if (test5u(30) != 0)\n+    abort ();\n+\n+  if (test6(0) != 0)\n+    abort ();\n+  if (test6(9) != 0)\n+    abort ();\n+  if (test6(10) != 0)\n+    abort ();\n+  if (test6(-1) != 0)\n+    abort ();\n+  if (test6(-9) != 0)\n+    abort ();\n+  if (test6(-10) != 1)\n+    abort ();\n+\n+  if (test7(19) != 1)\n+    abort ();\n+  if (test7(20) != 1)\n+    abort ();\n+  if (test7(29) != 1)\n+    abort ();\n+  if (test7(30) != 0)\n+    abort ();\n+\n+  if (test7u(19) != 1)\n+    abort ();\n+  if (test7u(20) != 1)\n+    abort ();\n+  if (test7u(29) != 1)\n+    abort ();\n+  if (test7u(30) != 0)\n+    abort ();\n+\n+  if (test8(0) != 1)\n+    abort ();\n+  if (test8(9) != 1)\n+    abort ();\n+  if (test8(10) != 0)\n+    abort ();\n+  if (test8(-1) != 1)\n+    abort ();\n+  if (test8(-9) != 1)\n+    abort ();\n+  if (test8(-10) != 1)\n+    abort ();\n+\n+  if (test8u(0) != 1)\n+    abort ();\n+  if (test8u(9) != 1)\n+    abort ();\n+  if (test8u(10) != 0)\n+    abort ();\n+  if (test8u(-1) != 0)\n+    abort ();\n+  if (test8u(-9) != 0)\n+    abort ();\n+  if (test8u(-10) != 0)\n+    abort ();\n+\n+  if (test9(19) != 0)\n+    abort ();\n+  if (test9(20) != 0)\n+    abort ();\n+  if (test9(29) != 0)\n+    abort ();\n+  if (test9(30) != 1)\n+    abort ();\n+\n+  if (test9u(19) != 0)\n+    abort ();\n+  if (test9u(20) != 0)\n+    abort ();\n+  if (test9u(29) != 0)\n+    abort ();\n+  if (test9u(30) != 1)\n+    abort ();\n+\n+  if (test10(0) != 0)\n+    abort ();\n+  if (test10(9) != 0)\n+    abort ();\n+  if (test10(10) != 1)\n+    abort ();\n+  if (test10(-1) != 0)\n+    abort ();\n+  if (test10(-9) != 0)\n+    abort ();\n+  if (test10(-10) != 0)\n+    abort ();\n+\n+  if (test10u(0) != 0)\n+    abort ();\n+  if (test10u(9) != 0)\n+    abort ();\n+  if (test10u(10) != 1)\n+    abort ();\n+  if (test10u(-1) != 1)\n+    abort ();\n+  if (test10u(-9) != 1)\n+    abort ();\n+  if (test10u(-10) != 1)\n+    abort ();\n+\n+  if (test11(19) != 0)\n+    abort ();\n+  if (test11(20) != 1)\n+    abort ();\n+  if (test11(29) != 1)\n+    abort ();\n+  if (test11(30) != 1)\n+    abort ();\n+\n+  if (test11u(19) != 0)\n+    abort ();\n+  if (test11u(20) != 1)\n+    abort ();\n+  if (test11u(29) != 1)\n+    abort ();\n+  if (test11u(30) != 1)\n+    abort ();\n+\n+  if (test12(0) != 1)\n+    abort ();\n+  if (test12(9) != 1)\n+    abort ();\n+  if (test12(10) != 1)\n+    abort ();\n+  if (test12(-1) != 1)\n+    abort ();\n+  if (test12(-9) != 1)\n+    abort ();\n+  if (test12(-10) != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "b059b8fbaecfae4644cdfcb010a6620c2915bef1", "filename": "gcc/testsuite/gcc.c-torture/execute/divcmp-2.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-2.c?ref=8dc2384cc96eeab306f1267118a194a50eb37953", "patch": "@@ -0,0 +1,92 @@\n+extern void abort (void);\n+\n+int test1(int x)\n+{\n+  return x/10 == 2;\n+}\n+\n+int test2(int x)\n+{\n+  return x/10 == 0;\n+}\n+\n+int test3(int x)\n+{\n+  return x/10 == -2;\n+}\n+\n+int test4(int x)\n+{\n+  return x/-10 == 2;\n+}\n+\n+int test5(int x)\n+{\n+  return x/-10 == 0;\n+}\n+\n+int test6(int x)\n+{\n+  return x/-10 == -2;\n+}\n+\n+\n+int main()\n+{\n+  if (test1(19) != 0)\n+    abort ();\n+  if (test1(20) != 1)\n+    abort ();\n+  if (test1(29) != 1)\n+    abort ();\n+  if (test1(30) != 0)\n+    abort ();\n+\n+  if (test2(-10) != 0)\n+    abort ();\n+  if (test2(-9) != 1)\n+    abort ();\n+  if (test2(9) != 1)\n+    abort ();\n+  if (test2(10) != 0)\n+    abort ();\n+\n+  if (test3(-30) != 0)\n+    abort ();\n+  if (test3(-29) != 1)\n+    abort ();\n+  if (test3(-20) != 1)\n+    abort ();\n+  if (test3(-19) != 0)\n+    abort ();\n+\n+  if (test4(-30) != 0)\n+    abort ();\n+  if (test4(-29) != 1)\n+    abort ();\n+  if (test4(-20) != 1)\n+    abort ();\n+  if (test4(-19) != 0)\n+    abort ();\n+\n+  if (test5(-10) != 0)\n+    abort ();\n+  if (test5(-9) != 1)\n+    abort ();\n+  if (test5(9) != 1)\n+    abort ();\n+  if (test5(10) != 0)\n+    abort ();\n+\n+  if (test6(19) != 0)\n+    abort ();\n+  if (test6(20) != 1)\n+    abort ();\n+  if (test6(29) != 1)\n+    abort ();\n+  if (test6(30) != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "ba52c9e24141647400a26bf7939245697b15de69", "filename": "gcc/testsuite/gcc.c-torture/execute/divcmp-3.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2384cc96eeab306f1267118a194a50eb37953/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fdivcmp-3.c?ref=8dc2384cc96eeab306f1267118a194a50eb37953", "patch": "@@ -0,0 +1,97 @@\n+extern void abort(void);\n+\n+int test1(char x)\n+{\n+  return x/100 == 3;\n+}\n+\n+int test1u(unsigned char x)\n+{\n+  return x/100 == 3;\n+}\n+\n+int test2(char x)\n+{\n+  return x/100 != 3;\n+}\n+\n+int test2u(unsigned char x)\n+{\n+  return x/100 != 3;\n+}\n+\n+int test3(char x)\n+{\n+  return x/100 < 3;\n+}\n+\n+int test3u(unsigned char x)\n+{\n+  return x/100 < 3;\n+}\n+\n+int test4(char x)\n+{\n+  return x/100 <= 3;\n+}\n+\n+int test4u(unsigned char x)\n+{\n+  return x/100 <= 3;\n+}\n+\n+int test5(char x)\n+{\n+  return x/100 > 3;\n+}\n+\n+int test5u(unsigned char x)\n+{\n+  return x/100 > 3;\n+}\n+\n+int test6(char x)\n+{\n+  return x/100 >= 3;\n+}\n+\n+int test6u(unsigned char x)\n+{\n+  return x/100 >= 3;\n+}\n+\n+\n+int main()\n+{\n+  int c;\n+\n+  for (c=-128; c<256; c++)\n+  {\n+    if (test1(c) != 0)\n+      abort ();\n+    if (test1u(c) != 0)\n+      abort ();\n+    if (test2(c) != 1)\n+      abort ();\n+    if (test2u(c) != 1)\n+      abort ();\n+    if (test3(c) != 1)\n+      abort ();\n+    if (test3u(c) != 1)\n+      abort ();\n+    if (test4(c) != 1)\n+      abort ();\n+    if (test4u(c) != 1)\n+      abort ();\n+    if (test5(c) != 0)\n+      abort ();\n+    if (test5u(c) != 0)\n+      abort ();\n+    if (test6(c) != 0)\n+      abort ();\n+    if (test6u(c) != 0)\n+      abort ();\n+  }\n+  return 0;\n+}\n+"}]}