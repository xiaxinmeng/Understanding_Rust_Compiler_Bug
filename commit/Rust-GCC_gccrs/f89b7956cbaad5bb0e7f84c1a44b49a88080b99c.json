{"sha": "f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5Yjc5NTZjYmFhZDViYjBlN2Y4NGMxYTQ0YjQ5YTg4MDgwYjk5Yw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2008-04-08T06:54:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:54:53Z"}, "message": "sem.adb (Analyze): Consider case in which we analyze an empty node that was generated by a call to...\n\n2008-04-08  Javier Miranda  <miranda@adacore.com>\n\n\t* sem.adb (Analyze): Consider case in which we analyze an empty node\n\tthat was generated by a call to a runtime function that is not\n\tavailable under the configurable runtime.\n\n\t* sem.ads (Inside_Freezing_Actions): New flag.\n\t(Save_Check_Policy_List): New field in scope stack entry\n\nFrom-SVN: r134048", "tree": {"sha": "330030c908ac6d7719a45b16782ce1e522400d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/330030c908ac6d7719a45b16782ce1e522400d98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f2401a678b0e608bf04faf7d29fdbf10ddf5dbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2401a678b0e608bf04faf7d29fdbf10ddf5dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f2401a678b0e608bf04faf7d29fdbf10ddf5dbf"}], "stats": {"total": 184, "additions": 103, "deletions": 81}, "files": [{"sha": "6b93ab449f19d9bc6e17f3c33a8a4f418d8ceefe", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -547,8 +547,12 @@ package body Sem is\n          --  been any other errors, we just ignore it, otherwise it is\n          --  a real internal error which we complain about.\n \n+         --  We must also consider the case of call to a runtime function\n+         --  that is not available in the configurable runtime.\n+\n          when N_Empty =>\n-            pragma Assert (Serious_Errors_Detected /= 0);\n+            pragma Assert (Serious_Errors_Detected /= 0\n+              or else Configurable_Run_Time_Violations /= 0);\n             null;\n \n          --  A call to analyze the error node is simply ignored, to avoid\n@@ -1275,14 +1279,14 @@ package body Sem is\n       --  values for these variables, and also that such calls do not\n       --  disturb the settings for units being analyzed at a higher level.\n \n+      S_Current_Sem_Unit : constant Unit_Number_Type := Current_Sem_Unit;\n       S_Full_Analysis    : constant Boolean          := Full_Analysis;\n-      S_In_Default_Expr  : constant Boolean          := In_Default_Expression;\n+      S_GNAT_Mode        : constant Boolean          := GNAT_Mode;\n+      S_Global_Dis_Names : constant Boolean          := Global_Discard_Names;\n+      S_In_Spec_Expr     : constant Boolean          := In_Spec_Expression;\n       S_Inside_A_Generic : constant Boolean          := Inside_A_Generic;\n       S_New_Nodes_OK     : constant Int              := New_Nodes_OK;\n       S_Outer_Gen_Scope  : constant Entity_Id        := Outer_Generic_Scope;\n-      S_Sem_Unit         : constant Unit_Number_Type := Current_Sem_Unit;\n-      S_GNAT_Mode        : constant Boolean          := GNAT_Mode;\n-      S_Discard_Names    : constant Boolean          := Global_Discard_Names;\n \n       Generic_Main : constant Boolean :=\n                        Nkind (Unit (Cunit (Main_Unit)))\n@@ -1356,9 +1360,9 @@ package body Sem is\n            (Operating_Mode = Generate_Code or Debug_Flag_X);\n       end if;\n \n-      Full_Analysis         := True;\n-      Inside_A_Generic      := False;\n-      In_Default_Expression := False;\n+      Full_Analysis      := True;\n+      Inside_A_Generic   := False;\n+      In_Spec_Expression := False;\n \n       Set_Comes_From_Source_Default (False);\n       Save_Opt_Config_Switches (Save_Config_Switches);\n@@ -1389,17 +1393,16 @@ package body Sem is\n \n       --  Restore settings of saved switches to entry values\n \n-      Current_Sem_Unit       := S_Sem_Unit;\n-      Full_Analysis          := S_Full_Analysis;\n-      In_Default_Expression  := S_In_Default_Expr;\n-      Inside_A_Generic       := S_Inside_A_Generic;\n-      New_Nodes_OK           := S_New_Nodes_OK;\n-      Outer_Generic_Scope    := S_Outer_Gen_Scope;\n-      GNAT_Mode              := S_GNAT_Mode;\n-      Global_Discard_Names   := S_Discard_Names;\n+      Current_Sem_Unit     := S_Current_Sem_Unit;\n+      Full_Analysis        := S_Full_Analysis;\n+      Global_Discard_Names := S_Global_Dis_Names;\n+      GNAT_Mode            := S_GNAT_Mode;\n+      In_Spec_Expression   := S_In_Spec_Expr;\n+      Inside_A_Generic     := S_Inside_A_Generic;\n+      New_Nodes_OK         := S_New_Nodes_OK;\n+      Outer_Generic_Scope  := S_Outer_Gen_Scope;\n \n       Restore_Opt_Config_Switches (Save_Config_Switches);\n       Expander_Mode_Restore;\n-\n    end Semantics;\n end Sem;"}, {"sha": "d3319b6db809ff50155753791ee30e93d3c18f41", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 82, "deletions": 63, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -84,31 +84,37 @@\n --  Analysis-Resolution-Expansion model for expressions. The most prominent\n --  examples are the handling of default expressions and aggregates.\n \n-----------------------------------------------------\n--- Handling of Default and Per-Object Expressions --\n-----------------------------------------------------\n+-----------------------------------------------------------------------\n+-- Handling of Default and Per-Object Expressions (Spec-Expressions) --\n+-----------------------------------------------------------------------\n \n --  The default expressions in component declarations and in procedure\n---  specifications (but not the ones in object declarations) are quite\n---  tricky to handle. The problem is that some processing is required\n---  at the point where the expression appears:\n+--  specifications (but not the ones in object declarations) are quite tricky\n+--  to handle. The problem is that some processing is required at the point\n+--  where the expression appears:\n \n --    visibility analysis (including user defined operators)\n --    freezing of static expressions\n \n---  but other processing must be deferred until the enclosing entity\n---  (record or procedure specification) is frozen:\n+--  but other processing must be deferred until the enclosing entity (record or\n+--  procedure specification) is frozen:\n \n---    freezing of any other types in the expression\n---    expansion\n+--    freezing of any other types in the expression expansion\n+--    generation of code\n \n --  A similar situation occurs with the argument of priority and interrupt\n --  priority pragmas that appear in task and protected definition specs and\n --  other cases of per-object expressions (see RM 3.8(18)).\n \n---  Expansion has to be deferred since you can't generate code for\n---  expressions that refernce types that have not been frozen yet. As an\n---  example, consider the following:\n+--  Another similar case is the conditions in precondition and postcondition\n+--  pragmas that appear with subprogram specifications rather than in the body.\n+\n+--  Collectively we call these Spec_Expressions. The routine that performs the\n+--  special analysis is called Analyze_Spec_Expression.\n+\n+--  Expansion has to be deferred since you can't generate code for expressions\n+--  that reference types that have not been frozen yet. As an example, consider\n+--  the following:\n \n --      type x is delta 0.5 range -10.0 .. +10.0;\n --      ...\n@@ -118,9 +124,9 @@\n \n --      for x'small use 0.25\n \n---  The expander is in charge of dealing with fixed-point, and of course\n---  the small declaration, which is not too late, since the declaration of\n---  type q does *not* freeze type x, definitely affects the expanded code.\n+--  The expander is in charge of dealing with fixed-point, and of course the\n+--  small declaration, which is not too late, since the declaration of type q\n+--  does *not* freeze type x, definitely affects the expanded code.\n \n --  Another reason that we cannot expand early is that expansion can generate\n --  range checks. These range checks need to be inserted not at the point of\n@@ -132,26 +138,27 @@\n --  this is the one case where this model falls down. Here is how we patch\n --  it up without causing too much distortion to our basic model.\n \n---  A switch (sede below) is set to indicate that we are in the initial\n+--  A switch (In_Spec_Expression) is set to show that we are in the initial\n --  occurence of a default expression. The analyzer is then called on this\n---  expression with the switch set true. Analysis and resolution proceed\n---  almost as usual, except that Freeze_Expression will not freeze\n---  non-static expressions if this switch is set, and the call to Expand at\n---  the end of resolution is skipped. This also skips the code that normally\n---  sets the Analyzed flag to True). The result is that when we are done the\n---  tree is still marked as unanalyzed, but all types for static expressions\n---  are frozen as required, and all entities of variables have been\n---  recorded.  We then turn off the switch, and later on reanalyze the\n---  expression with the switch off. The effect is that this second analysis\n---  freezes the rest of the types as required, and generates code but\n---  visibility analysis is not repeated since all the entities are marked.\n+--  expression with the switch set true. Analysis and resolution proceed almost\n+--  as usual, except that Freeze_Expression will not freeze non-static\n+--  expressions if this switch is set, and the call to Expand at the end of\n+--  resolution is skipped. This also skips the code that normally sets the\n+--  Analyzed flag to True. The result is that when we are done the tree is\n+--  still marked as unanalyzed, but all types for static expressions are frozen\n+--  as required, and all entities of variables have been recorded. We then turn\n+--  off the switch, and later on reanalyze the expression with the switch off.\n+--  The effect is that this second analysis freezes the rest of the types as\n+--  required, and generates code but visibility analysis is not repeated since\n+--  all the entities are marked.\n \n --  The second analysis (the one that generates code) is in the context\n---  where the code is required. For a record field default, this is in\n---  the initialization procedure for the record and for a subprogram\n---  default parameter, it is at the point the subprogram is frozen.\n---  For a priority or storage size pragma it is in the context of the\n---  Init_Proc for the task or protected object.\n+--  where the code is required. For a record field default, this is in the\n+--  initialization procedure for the record and for a subprogram default\n+--  parameter, it is at the point the subprogram is frozen. For a priority or\n+--  storage size pragma it is in the context of the Init_Proc for the task or\n+--  protected object. For a pre/postcondition pragma it is in the body when\n+--  code for the pragma is generated.\n \n ------------------\n -- Pre-Analysis --\n@@ -164,34 +171,35 @@\n --\n --     (1 .. 100 => new Thing (Function_Call))\n --\n---  The normal Analysis-Resolution-Expansion mechanism where expansion\n---  of the children is performed before expansion of the parent does not\n---  work if the code generated for the children by the expander needs\n---  to be evaluated repeatdly (for instance in the above aggregate\n---  \"new Thing (Function_Call)\" needs to be called 100 times.)\n---  The reason why this mecanism does not work is that, the expanded code\n---  for the children is typically inserted above the parent and thus\n---  when the father gets expanded no re-evaluation takes place. For instance\n---  in the case of aggregates if \"new Thing (Function_Call)\" is expanded\n---  before of the aggregate the expanded code will be placed outside\n---  of the aggregate and when expanding the aggregate the loop from 1 to 100\n---  will not surround the expanded code for \"new Thing (Function_Call)\".\n---\n---  To remedy this situation we introduce a new flag which signals whether\n---  we want a full analysis (ie expansion is enabled) or a pre-analysis\n---  which performs Analysis and Resolution but no expansion.\n---\n---  After the complete pre-analysis of an expression has been carried out\n---  we can transform the expression and then carry out the full\n---  Analyze-Resolve-Expand cycle on the transformed expression top-down\n---  so that the expansion of inner expressions happens inside the newly\n---  generated node for the parent expression.\n---\n+--  The normal Analysis-Resolution-Expansion mechanism where expansion of the\n+--  children is performed before expansion of the parent does not work if the\n+--  code generated for the children by the expander needs to be evaluated\n+--  repeatdly (for instance in the above aggregate \"new Thing (Function_Call)\"\n+--  needs to be called 100 times.)\n+\n+--  The reason why this mecanism does not work is that, the expanded code for\n+--  the children is typically inserted above the parent and thus when the\n+--  father gets expanded no re-evaluation takes place. For instance in the case\n+--  of aggregates if \"new Thing (Function_Call)\" is expanded before of the\n+--  aggregate the expanded code will be placed outside of the aggregate and\n+--  when expanding the aggregate the loop from 1 to 100 will not surround the\n+--  expanded code for \"new Thing (Function_Call)\".\n+\n+--  To remedy this situation we introduce a new flag which signals whether we\n+--  want a full analysis (ie expansion is enabled) or a pre-analysis which\n+--  performs Analysis and Resolution but no expansion.\n+\n+--  After the complete pre-analysis of an expression has been carried out we\n+--  can transform the expression and then carry out the full three stage\n+--  (Analyze-Resolve-Expand) cycle on the transformed expression top-down so\n+--  that the expansion of inner expressions happens inside the newly generated\n+--  node for the parent expression.\n+\n --  Note that the difference between processing of default expressions and\n --  pre-analysis of other expressions is that we do carry out freezing in\n --  the latter but not in the former (except for static scalar expressions).\n---  The routine that performs pre-analysis is called Pre_Analyze_And_Resolve\n---  and is in Sem_Res.\n+--  The routine that performs preanalysis and corresponding resolution is\n+--  called Preanalyze_And_Resolve and is in Sem_Res.\n \n with Alloc;\n with Einfo;  use Einfo;\n@@ -223,8 +231,8 @@ package Sem is\n    --  whether expansion is currently enabled). You should really regard this\n    --  as a read only flag.\n \n-   In_Default_Expression : Boolean := False;\n-   --  Switch to indicate that we are in a default expression, as described\n+   In_Spec_Expression : Boolean := False;\n+   --  Switch to indicate that we are in a spec-expression, as described\n    --  above. Note that this must be recursively saved on a Semantics call\n    --  since it is possible for the analysis of an expression to result in a\n    --  recursive call (e.g. to get the entity for System.Address as part of the\n@@ -252,14 +260,22 @@ package Sem is\n    --  package Expander). Only the generic processing can modify the\n    --  status of this flag, any other client should regard it as read-only.\n \n+   Inside_Freezing_Actions : Nat := 0;\n+   --  Flag indicating whether we are within a call to Expand_N_Freeze_Actions.\n+   --  Non-zero means we are inside (it is actually a level counter to deal\n+   --  with nested calls). Used to avoid traversing the tree each time a\n+   --  subprogram call is processed to know if we must not clear all constant\n+   --  indications from entities in the current scope. Only the expansion of\n+   --  freezing nodes can modify the status of this flag, any other client\n+   --  should regard it as read-only.\n+\n    Unloaded_Subunits : Boolean := False;\n    --  This flag is set True if we have subunits that are not loaded. This\n    --  occurs when the main unit is a subunit, and contains lower level\n    --  subunits that are not loaded. We use this flag to suppress warnings\n    --  about unused variables, since these warnings are unreliable in this\n    --  case. We could perhaps do a more accurate job and retain some of the\n-   --  warnings, but it is quite a tricky job. See test 4323-002.\n-   --  Should not reference TN's in the source comments ???\n+   --  warnings, but it is quite a tricky job.\n \n    -----------------------------------\n    -- Handling of Check Suppression --\n@@ -442,6 +458,9 @@ package Sem is\n       Save_Local_Suppress_Stack_Top : Suppress_Stack_Entry_Ptr;\n       --  Save contents of Local_Suppress_Stack on entry to restore on exit\n \n+      Save_Check_Policy_List : Node_Id;\n+      --  Save contents of Check_Policy_List on entry to restore on exit\n+\n       Is_Transient : Boolean;\n       --  Marks Transient Scopes (See Exp_Ch7 body for details)\n "}]}