{"sha": "81a8d137c22953df2ea046466c62cd26c0dba103", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFhOGQxMzdjMjI5NTNkZjJlYTA0NjQ2NmM2MmNkMjZjMGRiYTEwMw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-03-27T23:21:58Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-03-27T23:26:03Z"}, "message": "libstdc++: Add remaining C++20 changes to iterator adaptors\n\nThis adds the missing parts of P0896R4 to reverse_iterator and\nmove_iterator, so that they meet the C++20 requirements. This should be\nthe last piece of P0896R4, meaning ranges support is now complete.\n\nThe PR 94354 bug with reverse_iterator's comparisons is fixed for C++20\nonly, but that change should be extended to C++11, C++14 and C++17 modes\nin stage 1.\n\n\t* include/bits/stl_iterator.h (reverse_iterator::iterator_concept)\n\t(reverse_iterator::iterator_category): Define for C++20.\n\t(reverse_iterator): Define comparison operators correctly for C++20.\n\t(__normal_iterator): Add constraints to comparison operators for C++20.\n\t(move_iterator::operator++(int)) [__cpp_lib_concepts]: Define new\n\toverload for input iterators.\n\t(move_iterator): Add constraints to comparison operators for C++20.\n\tDefine operator<=> for C++20.\n\t* testsuite/24_iterators/move_iterator/input_iterator.cc: New test.\n\t* testsuite/24_iterators/move_iterator/move_only.cc: New test.\n\t* testsuite/24_iterators/move_iterator/rel_ops_c++20.cc: New test.\n\t* testsuite/24_iterators/reverse_iterator/rel_ops_c++20.cc: New test.", "tree": {"sha": "91352bc2ddb369ad0874532af65cc54611d7639f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91352bc2ddb369ad0874532af65cc54611d7639f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81a8d137c22953df2ea046466c62cd26c0dba103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a8d137c22953df2ea046466c62cd26c0dba103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81a8d137c22953df2ea046466c62cd26c0dba103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a8d137c22953df2ea046466c62cd26c0dba103/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae6076b5bc1e0b689eaa8521571b0516de336553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae6076b5bc1e0b689eaa8521571b0516de336553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae6076b5bc1e0b689eaa8521571b0516de336553"}], "stats": {"total": 536, "additions": 521, "deletions": 15}, "files": [{"sha": "fc5f900ed5f1cbd2cebf293736fa9c05f9fb79cb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=81a8d137c22953df2ea046466c62cd26c0dba103", "patch": "@@ -1,5 +1,18 @@\n 2020-03-27  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/stl_iterator.h (reverse_iterator::iterator_concept)\n+\t(reverse_iterator::iterator_category): Define for C++20.\n+\t(reverse_iterator): Define comparison operators correctly for C++20.\n+\t(__normal_iterator): Add constraints to comparison operators for C++20.\n+\t(move_iterator::operator++(int)) [__cpp_lib_concepts]: Define new\n+\toverload for input iterators.\n+\t(move_iterator): Add constraints to comparison operators for C++20.\n+\tDefine operator<=> for C++20.\n+\t* testsuite/24_iterators/move_iterator/input_iterator.cc: New test.\n+\t* testsuite/24_iterators/move_iterator/move_only.cc: New test.\n+\t* testsuite/24_iterators/move_iterator/rel_ops_c++20.cc: New test.\n+\t* testsuite/24_iterators/reverse_iterator/rel_ops_c++20.cc: New test.\n+\n \t* include/bits/iterator_concepts.h (__detail::__decay_copy)\n \t(__detail::__member_begin, __detail::__adl_begin): Move here from\n \t<bits/range_access.h>."}, {"sha": "26eb599993df4cd742c1bedf00571a3f6524ac56", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 116, "deletions": 15, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=81a8d137c22953df2ea046466c62cd26c0dba103", "patch": "@@ -88,6 +88,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+  namespace __detail\n+  {\n+    // Weaken iterator_category _Cat to _Limit if it is derived from that,\n+    // otherwise use _Otherwise.\n+    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>\n+      using __clamp_iter_cat\n+\t= conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;\n+  }\n+#endif\n+\n   // 24.4.1 Reverse iterators\n   /**\n    *  Bidirectional and random access iterators have corresponding reverse\n@@ -126,6 +137,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef typename __traits_type::pointer\t\tpointer;\n       typedef typename __traits_type::reference\t\treference;\n \n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+      using iterator_concept\n+\t= conditional_t<random_access_iterator<_Iterator>,\n+\t\t\trandom_access_iterator_tag,\n+\t\t\tbidirectional_iterator_tag>;\n+      using iterator_category\n+\t= __detail::__clamp_iter_cat<typename __traits_type::iterator_category,\n+\t\t\t\t     random_access_iterator_tag>;\n+#endif\n+\n       /**\n        *  The default constructor value-initializes member @p current.\n        *  If it is a pointer, that means it is zero-initialized.\n@@ -320,16 +341,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         { return __t.operator->(); }\n     };\n \n+  // Used in unevaluated expressions to test for implicit conversion to bool.\n+  namespace __detail { bool __convbool(bool); }\n+\n   //@{\n   /**\n    *  @param  __x  A %reverse_iterator.\n    *  @param  __y  A %reverse_iterator.\n    *  @return  A simple bool.\n    *\n-   *  Reverse iterators forward many operations to their underlying base()\n-   *  iterators.  Others are implemented in terms of one another.\n+   *  Reverse iterators forward comparisons to their underlying base()\n+   *  iterators.\n    *\n   */\n+#if __cplusplus <= 201703L\n   template<typename _Iterator>\n     inline _GLIBCXX17_CONSTEXPR bool\n     operator==(const reverse_iterator<_Iterator>& __x,\n@@ -403,6 +428,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator>=(const reverse_iterator<_IteratorL>& __x,\n \t       const reverse_iterator<_IteratorR>& __y)\n     { return !(__x < __y); }\n+#else // C++20\n+  template<typename _IteratorL, typename _IteratorR>\n+    constexpr auto\n+    operator==(const reverse_iterator<_IteratorL>& __x,\n+\t       const reverse_iterator<_IteratorR>& __y)\n+    -> decltype(__detail::__convbool(__x.base() == __y.base()))\n+    { return __x.base() == __y.base(); }\n+\n+  template<typename _IteratorL, typename _IteratorR>\n+    constexpr auto\n+    operator!=(const reverse_iterator<_IteratorL>& __x,\n+\t       const reverse_iterator<_IteratorR>& __y)\n+    -> decltype(__detail::__convbool(__x.base() != __y.base()))\n+    { return __x.base() != __y.base(); }\n+\n+  template<typename _IteratorL, typename _IteratorR>\n+    constexpr auto\n+    operator<(const reverse_iterator<_IteratorL>& __x,\n+\t      const reverse_iterator<_IteratorR>& __y)\n+    -> decltype(__detail::__convbool(__x.base() < __y.base()))\n+    { return __x.base() < __y.base(); }\n+\n+  template<typename _IteratorL, typename _IteratorR>\n+    constexpr auto\n+    operator>(const reverse_iterator<_IteratorL>& __x,\n+\t      const reverse_iterator<_IteratorR>& __y)\n+    -> decltype(__detail::__convbool(__x.base() > __y.base()))\n+    { return __x.base() > __y.base(); }\n+\n+  template<typename _IteratorL, typename _IteratorR>\n+    constexpr auto\n+    operator<=(const reverse_iterator<_IteratorL>& __x,\n+\t       const reverse_iterator<_IteratorR>& __y)\n+    -> decltype(__detail::__convbool(__x.base() <= __y.base()))\n+    { return __x.base() <= __y.base(); }\n+\n+  template<typename _IteratorL, typename _IteratorR>\n+    constexpr auto\n+    operator>=(const reverse_iterator<_IteratorL>& __x,\n+\t       const reverse_iterator<_IteratorR>& __y)\n+    -> decltype(__detail::__convbool(__x.base() >= __y.base()))\n+    { return __x.base() >= __y.base(); }\n+#endif // C++20\n   //@}\n \n #if __cplusplus < 201103L\n@@ -1000,8 +1068,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Random access iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-    _GLIBCXX20_CONSTEXPR\n+#if __cplusplus > 201703L\n+    constexpr auto\n+#else\n     inline bool\n+#endif\n     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1016,8 +1087,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __lhs.base() < __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-    _GLIBCXX20_CONSTEXPR\n+#if __cplusplus > 201703L\n+    constexpr auto\n+#else\n     inline bool\n+#endif\n     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1032,8 +1106,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __lhs.base() > __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-    _GLIBCXX20_CONSTEXPR\n+#if __cplusplus > 201703L\n+    constexpr auto\n+#else\n     inline bool\n+#endif\n     operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1048,8 +1125,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __lhs.base() <= __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-    _GLIBCXX20_CONSTEXPR\n+#if __cplusplus > 201703L\n+    constexpr auto\n+#else\n     inline bool\n+#endif\n     operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1157,15 +1237,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       _Sent _M_last;\n     };\n-\n-  namespace __detail\n-  {\n-    // Weaken iterator_category _Cat to _Limit if it is derived from that,\n-    // otherwise use _Otherwise.\n-    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>\n-      using __clamp_iter_cat\n-\t= conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;\n-  }\n #endif // C++20\n \n   // 24.4.3  Move iterators\n@@ -1266,6 +1337,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn __tmp;\n       }\n \n+#if __cpp_lib_concepts\n+      constexpr void\n+      operator++(int) requires (!forward_iterator<_Iterator>)\n+      { ++_M_current; }\n+#endif\n+\n       _GLIBCXX17_CONSTEXPR move_iterator&\n       operator--()\n       {\n@@ -1343,6 +1420,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline _GLIBCXX17_CONSTEXPR bool\n     operator==(const move_iterator<_IteratorL>& __x,\n \t       const move_iterator<_IteratorR>& __y)\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+    requires requires { __detail::__convbool(__x.base() == __y.base()); }\n+#endif\n     { return __x.base() == __y.base(); }\n \n   template<typename _Iterator>\n@@ -1351,6 +1431,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       const move_iterator<_Iterator>& __y)\n     { return __x.base() == __y.base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _IteratorL,\n+\t   three_way_comparable_with<_IteratorL> _IteratorR>\n+    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>\n+    operator<=>(const move_iterator<_IteratorL>& __x,\n+\t\tconst move_iterator<_IteratorR>& __y)\n+    { return __x.base() <=> __y.base(); }\n+#else\n   template<typename _IteratorL, typename _IteratorR>\n     inline _GLIBCXX17_CONSTEXPR bool\n     operator!=(const move_iterator<_IteratorL>& __x,\n@@ -1362,11 +1450,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator!=(const move_iterator<_Iterator>& __x,\n \t       const move_iterator<_Iterator>& __y)\n     { return !(__x == __y); }\n+#endif\n \n   template<typename _IteratorL, typename _IteratorR>\n     inline _GLIBCXX17_CONSTEXPR bool\n     operator<(const move_iterator<_IteratorL>& __x,\n \t      const move_iterator<_IteratorR>& __y)\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+    requires requires { __detail::__convbool(__x.base() < __y.base()); }\n+#endif\n     { return __x.base() < __y.base(); }\n \n   template<typename _Iterator>\n@@ -1379,6 +1471,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline _GLIBCXX17_CONSTEXPR bool\n     operator<=(const move_iterator<_IteratorL>& __x,\n \t       const move_iterator<_IteratorR>& __y)\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+    requires requires { __detail::__convbool(__y.base() < __x.base()); }\n+#endif\n     { return !(__y < __x); }\n \n   template<typename _Iterator>\n@@ -1391,6 +1486,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline _GLIBCXX17_CONSTEXPR bool\n     operator>(const move_iterator<_IteratorL>& __x,\n \t      const move_iterator<_IteratorR>& __y)\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+    requires requires { __detail::__convbool(__y.base() < __x.base()); }\n+#endif\n     { return __y < __x; }\n \n   template<typename _Iterator>\n@@ -1403,6 +1501,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline _GLIBCXX17_CONSTEXPR bool\n     operator>=(const move_iterator<_IteratorL>& __x,\n \t       const move_iterator<_IteratorR>& __y)\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+    requires requires { __detail::__convbool(__x.base() < __y.base()); }\n+#endif\n     { return !(__x < __y); }\n \n   template<typename _Iterator>"}, {"sha": "32cf55ca932e6c87ca103db7e4f391e82045090c", "filename": "libstdc++-v3/testsuite/24_iterators/move_iterator/input_iterator.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Finput_iterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Finput_iterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Finput_iterator.cc?ref=81a8d137c22953df2ea046466c62cd26c0dba103", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+void\n+test01()\n+{\n+  int a[2] = { 1, 2 };\n+  __gnu_test::test_container<int, __gnu_test::input_iterator_wrapper> c(a);\n+  auto miter = std::make_move_iterator(c.begin());\n+  VERIFY( *miter == 1 );\n+  miter++;\n+  VERIFY( *miter == 2 );\n+\n+  static_assert( std::is_void_v<decltype(miter++)> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "d64e61e4448a8bdfa8f1d700fcf8c20494162198", "filename": "libstdc++-v3/testsuite/24_iterators/move_iterator/move_only.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fmove_only.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fmove_only.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fmove_only.cc?ref=81a8d137c22953df2ea046466c62cd26c0dba103", "patch": "@@ -0,0 +1,60 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <iterator>\n+\n+struct move_only_iterator\n+{\n+  move_only_iterator() = default;\n+  move_only_iterator(move_only_iterator&&) = default;\n+  move_only_iterator& operator=(move_only_iterator&&) = default;\n+\n+  move_only_iterator& operator++();\n+  move_only_iterator operator++(int);\n+  int& operator*() const;\n+\n+  bool operator==(const move_only_iterator&) const;\n+};\n+\n+template<> struct std::iterator_traits<move_only_iterator>\n+{\n+  using value_type = int;\n+  using difference_type = std::ptrdiff_t;\n+  using iterator_category = std::input_iterator_tag;\n+};\n+\n+static_assert(std::input_iterator<move_only_iterator>);\n+\n+template<typename T>\n+  concept has_member_base = requires (T t) { std::forward<T>(t).base(); };\n+\n+static_assert( ! has_member_base<std::move_iterator<move_iterator>&> );\n+static_assert( ! has_member_base<const std::move_iterator<move_iterator>&> );\n+static_assert( has_member_base<std::move_iterator<move_iterator>> );\n+static_assert( ! has_member_base<const std::move_iterator<move_iterator>> );\n+\n+void\n+test01()\n+{\n+  std::move_iterator<move_only_iterator> m1, m2;\n+  m1 = std::make_move_iterator(move_only_iterator{});\n+  m2 = std::move(m1);\n+  m1.swap(m2);\n+}"}, {"sha": "8f2d73c520f98724e6d2d3083d2452724624f091", "filename": "libstdc++-v3/testsuite/24_iterators/move_iterator/rel_ops_c++20.cc", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Frel_ops_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Frel_ops_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Frel_ops_c%2B%2B20.cc?ref=81a8d137c22953df2ea046466c62cd26c0dba103", "patch": "@@ -0,0 +1,134 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <iterator>\n+\n+template<int>\n+struct Iter\n+{\n+  using iterator_category = std::random_access_iterator_tag;\n+  using value_type = int;\n+  using pointer = int*;\n+  using reference = int&;\n+  using difference_type = std::ptrdiff_t;\n+\n+  Iter();\n+\n+  Iter& operator++();\n+  Iter operator++(int);\n+  Iter& operator--();\n+  Iter operator--(int);\n+  int& operator*() const;\n+  int* operator->() const;\n+\n+  int& operator[](difference_type) const;\n+\n+  Iter& operator+=(difference_type);\n+  Iter& operator-=(difference_type);\n+\n+  template<int N> friend Iter operator+(Iter<N>, difference_type);\n+  template<int N> friend Iter operator+(difference_type, Iter<N>);\n+  template<int N> friend Iter operator-(Iter<N>, difference_type);\n+  template<int N> friend difference_type operator-(Iter<N>, Iter<N>);\n+\n+  // Define the full set of operators for same-type comparisons\n+  template<int N> friend bool operator==(Iter<N>, Iter<N>); // synthesizes !=\n+  template<int N> friend bool operator<(Iter<N>, Iter<N>);\n+  template<int N> friend bool operator>(Iter<N>, Iter<N>);\n+  template<int N> friend bool operator<=(Iter<N>, Iter<N>);\n+  template<int N> friend bool operator>=(Iter<N>, Iter<N>);\n+};\n+\n+\n+static_assert( std::random_access_iterator<Iter<0>> );\n+\n+int   operator==(Iter<0>, long*);\n+void* operator< (Iter<1>, long*);\n+bool& operator< (long*, Iter<2>);\n+\n+using std::move_iterator;\n+\n+static_assert( std::three_way_comparable<move_iterator<Iter<0>>> );\n+\n+move_iterator<Iter<0>> l0{Iter<0>()};\n+move_iterator<Iter<1>> l1{Iter<1>()};\n+move_iterator<Iter<2>> l2{Iter<2>()};\n+move_iterator<long*> r{nullptr};\n+\n+bool b0 = l0 == r;\n+bool b1 = l0 != r;\n+bool b2 = l1 < r;\n+bool b3 = l2 > r;\n+bool b4 = l2 <= r;\n+bool b5 = l1 >= r;\n+\n+template<int N>\n+  concept has_eq\n+    = requires (move_iterator<Iter<N>> l, move_iterator<long*> r)\n+      { l == r; };\n+\n+template<int N>\n+  concept has_ne\n+    = requires (move_iterator<Iter<N>> l, move_iterator<long*> r)\n+      { l != r; };\n+\n+template<int N>\n+  concept has_lt\n+    = requires (move_iterator<Iter<N>> l, move_iterator<long*> r)\n+      { l < r; };\n+\n+template<int N>\n+  concept has_gt\n+    = requires (move_iterator<Iter<N>> l, move_iterator<long*> r)\n+      { l > r; };\n+\n+template<int N>\n+  concept has_le\n+    = requires (move_iterator<Iter<N>> l, move_iterator<long*> r)\n+      { l <= r; };\n+\n+template<int N>\n+  concept has_ge\n+    = requires (move_iterator<Iter<N>> l, move_iterator<long*> r)\n+      { l >= r; };\n+\n+static_assert( has_eq<0> );\n+static_assert( ! has_eq<1> );\n+static_assert( ! has_eq<2> );\n+\n+static_assert( has_ne<0> ); // uses synthesized operator!=\n+static_assert( ! has_ne<1> );\n+static_assert( ! has_ne<2> );\n+\n+static_assert( ! has_lt<0> );\n+static_assert( has_lt<1> );\n+static_assert( ! has_lt<2> );\n+\n+static_assert( ! has_gt<0> );\n+static_assert( ! has_gt<1> );\n+static_assert( has_gt<2> );\n+\n+static_assert( ! has_le<0> );\n+static_assert( ! has_le<1> );\n+static_assert( has_le<2> );\n+\n+static_assert( ! has_ge<0> );\n+static_assert( has_ge<1> );\n+static_assert( ! has_ge<2> );"}, {"sha": "3e91a0396fe09346be332b1a7cc4b0860d43b82d", "filename": "libstdc++-v3/testsuite/24_iterators/reverse_iterator/rel_ops_c++20.cc", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Freverse_iterator%2Frel_ops_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a8d137c22953df2ea046466c62cd26c0dba103/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Freverse_iterator%2Frel_ops_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Freverse_iterator%2Frel_ops_c%2B%2B20.cc?ref=81a8d137c22953df2ea046466c62cd26c0dba103", "patch": "@@ -0,0 +1,156 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <iterator>\n+\n+template<int>\n+struct Iter\n+{\n+  using iterator_category = std::random_access_iterator_tag;\n+  using value_type = int;\n+  using pointer = int*;\n+  using reference = int&;\n+  using difference_type = std::ptrdiff_t;\n+\n+  Iter();\n+\n+  Iter& operator++();\n+  Iter operator++(int);\n+  Iter& operator--();\n+  Iter operator--(int);\n+  int& operator*() const;\n+  int* operator->() const;\n+\n+  int& operator[](difference_type) const;\n+\n+  Iter& operator+=(difference_type);\n+  Iter& operator-=(difference_type);\n+\n+  template<int N> friend Iter operator+(Iter<N>, difference_type);\n+  template<int N> friend Iter operator+(difference_type, Iter<N>);\n+  template<int N> friend Iter operator-(Iter<N>, difference_type);\n+  template<int N> friend difference_type operator-(Iter<N>, Iter<N>);\n+\n+  // Define the full set of operators for same-type comparisons\n+  template<int N> friend bool operator==(Iter<N>, Iter<N>); // synthesizes !=\n+  template<int N> friend bool operator<(Iter<N>, Iter<N>);\n+  template<int N> friend bool operator>(Iter<N>, Iter<N>);\n+  template<int N> friend bool operator<=(Iter<N>, Iter<N>);\n+  template<int N> friend bool operator>=(Iter<N>, Iter<N>);\n+};\n+\n+static_assert( std::random_access_iterator<Iter<0>> );\n+\n+// Define a single kind of mixed-type comparison for each specialization.\n+int   operator==(Iter<0>, long*);\n+void* operator!=(Iter<1>, long*);\n+bool& operator< (Iter<2>, long*);\n+int   operator> (Iter<3>, long*);\n+void* operator<=(Iter<4>, long*);\n+bool& operator>=(Iter<5>, long*);\n+\n+using std::reverse_iterator;\n+\n+reverse_iterator<Iter<0>> l0{Iter<0>()};\n+reverse_iterator<Iter<1>> l1{Iter<1>()};\n+reverse_iterator<Iter<2>> l2{Iter<2>()};\n+reverse_iterator<Iter<3>> l3{Iter<3>()};\n+reverse_iterator<Iter<4>> l4{Iter<4>()};\n+reverse_iterator<Iter<5>> l5{Iter<5>()};\n+reverse_iterator<long*> r{nullptr};\n+\n+bool b0 = l0 == r;\n+bool b1 = l1 != r;\n+bool b2 = l2 < r;\n+bool b3 = l3 > r;\n+bool b4 = l4 <= r;\n+bool b5 = l5 >= r;\n+\n+template<int N>\n+  concept has_eq\n+    = requires (reverse_iterator<Iter<N>> l, reverse_iterator<long*> r)\n+      { l == r; };\n+\n+template<int N>\n+  concept has_ne\n+    = requires (reverse_iterator<Iter<N>> l, reverse_iterator<long*> r)\n+      { l != r; };\n+\n+template<int N>\n+  concept has_lt\n+    = requires (reverse_iterator<Iter<N>> l, reverse_iterator<long*> r)\n+      { l < r; };\n+\n+template<int N>\n+  concept has_gt\n+    = requires (reverse_iterator<Iter<N>> l, reverse_iterator<long*> r)\n+      { l > r; };\n+\n+template<int N>\n+  concept has_le\n+    = requires (reverse_iterator<Iter<N>> l, reverse_iterator<long*> r)\n+      { l <= r; };\n+\n+template<int N>\n+  concept has_ge\n+    = requires (reverse_iterator<Iter<N>> l, reverse_iterator<long*> r)\n+      { l >= r; };\n+\n+static_assert( has_eq<0> );\n+static_assert( ! has_eq<1> );\n+static_assert( ! has_eq<2> );\n+static_assert( ! has_eq<3> );\n+static_assert( ! has_eq<4> );\n+static_assert( ! has_eq<5> );\n+\n+static_assert( has_ne<0> ); // uses synthesized operator!=\n+static_assert( has_ne<1> );\n+static_assert( ! has_ne<2> );\n+static_assert( ! has_ne<3> );\n+static_assert( ! has_ne<4> );\n+static_assert( ! has_ne<5> );\n+\n+static_assert( ! has_lt<0> );\n+static_assert( ! has_lt<1> );\n+static_assert( has_lt<2> );\n+static_assert( ! has_lt<3> );\n+static_assert( ! has_lt<4> );\n+static_assert( ! has_lt<5> );\n+\n+static_assert( ! has_gt<0> );\n+static_assert( ! has_gt<1> );\n+static_assert( ! has_gt<2> );\n+static_assert( has_gt<3> );\n+static_assert( ! has_gt<4> );\n+static_assert( ! has_gt<5> );\n+\n+static_assert( ! has_le<0> );\n+static_assert( ! has_le<1> );\n+static_assert( ! has_le<2> );\n+static_assert( ! has_le<3> );\n+static_assert( has_le<4> );\n+static_assert( ! has_le<5> );\n+\n+static_assert( ! has_ge<0> );\n+static_assert( ! has_ge<1> );\n+static_assert( ! has_ge<2> );\n+static_assert( ! has_ge<3> );\n+static_assert( ! has_ge<4> );\n+static_assert( has_ge<5> );"}]}