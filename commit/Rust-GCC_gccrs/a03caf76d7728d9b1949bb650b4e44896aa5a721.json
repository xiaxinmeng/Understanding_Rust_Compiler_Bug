{"sha": "a03caf76d7728d9b1949bb650b4e44896aa5a721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAzY2FmNzZkNzcyOGQ5YjE5NDliYjY1MGI0ZTQ0ODk2YWE1YTcyMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T18:04:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T18:04:37Z"}, "message": "(assign_parms): Spread out the REG_EQUIV notes on\nCONCATs.\n\nFrom-SVN: r7232", "tree": {"sha": "8d647cd41148fbbb2c766f3ade04787f4637d6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d647cd41148fbbb2c766f3ade04787f4637d6e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a03caf76d7728d9b1949bb650b4e44896aa5a721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03caf76d7728d9b1949bb650b4e44896aa5a721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a03caf76d7728d9b1949bb650b4e44896aa5a721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03caf76d7728d9b1949bb650b4e44896aa5a721/comments", "author": null, "committer": null, "parents": [{"sha": "cac1105ce5f0e7c78071dc0509fab28f17b9cd35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac1105ce5f0e7c78071dc0509fab28f17b9cd35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cac1105ce5f0e7c78071dc0509fab28f17b9cd35"}], "stats": {"total": 45, "additions": 35, "deletions": 10}, "files": [{"sha": "ff80a7f2ead41e3a2de2fa9d0c92b3473df7be17", "filename": "gcc/function.c", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a03caf76d7728d9b1949bb650b4e44896aa5a721/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a03caf76d7728d9b1949bb650b4e44896aa5a721/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a03caf76d7728d9b1949bb650b4e44896aa5a721", "patch": "@@ -3452,7 +3452,7 @@ assign_parms (fndecl, second_time)\n \t     may need to do it in a wider mode.  */\n \n \t  register rtx parmreg;\n-\t  int regno;\n+\t  int regno, regnoi, regnor;\n \n \t  unsignedp = TREE_UNSIGNED (TREE_TYPE (parm));\n \t  nominal_mode = promote_mode (TREE_TYPE (parm), nominal_mode,\n@@ -3590,19 +3590,20 @@ assign_parms (fndecl, second_time)\n \t    {\n \t      enum machine_mode submode = GET_MODE (XEXP (parmreg, 0));\n \n+\t      regnor = REGNO (gen_realpart (submode, parmreg));\n+\t      regnoi = REGNO (gen_imagpart (submode, parmreg));\n+\n \t      if (stack_parm != 0)\n \t\t{\n-\t\t  parm_reg_stack_loc[REGNO (gen_realpart (submode, parmreg))]\n+\t\t  parm_reg_stack_loc[regnor]\n \t\t    = gen_realpart (submode, stack_parm);\n-\t\t  parm_reg_stack_loc[REGNO (gen_imagpart (submode, parmreg))]\n+\t\t  parm_reg_stack_loc[regnoi]\n \t\t    = gen_imagpart (submode, stack_parm);\n \t\t}\n \t      else\n \t\t{\n-\t\t  parm_reg_stack_loc[REGNO (gen_realpart (submode, parmreg))]\n-\t\t    = 0;\n-\t\t  parm_reg_stack_loc[REGNO (gen_imagpart (submode, parmreg))]\n-\t\t    = 0;\n+\t\t  parm_reg_stack_loc[regnor] = 0;\n+\t\t  parm_reg_stack_loc[regnoi] = 0;\n \t\t}\n \t    }\n \t  else\n@@ -3615,14 +3616,38 @@ assign_parms (fndecl, second_time)\n \t     an invalid address, such memory-equivalences\n \t     as we make here would screw up life analysis for it.  */\n \t  if (nominal_mode == passed_mode\n+\t      && ! conversion_insns\n \t      && GET_CODE (entry_parm) == MEM\n \t      && entry_parm == stack_parm\n \t      && stack_offset.var == 0\n \t      && reg_mentioned_p (virtual_incoming_args_rtx,\n \t\t\t\t  XEXP (entry_parm, 0)))\n-\t    REG_NOTES (get_last_insn ())\n-\t      = gen_rtx (EXPR_LIST, REG_EQUIV,\n-\t\t\t entry_parm, REG_NOTES (get_last_insn ()));\n+\t    {\n+\t      rtx linsn = get_last_insn ();\n+\n+\t      /* Mark complex types separately.  */\n+\t      if (GET_CODE (parmreg) == CONCAT)\n+\t        {\n+\t          REG_NOTES (linsn)\n+\t              = gen_rtx (EXPR_LIST, REG_EQUIV,\n+\t\t\t\t parm_reg_stack_loc[regnoi], REG_NOTES (linsn));\n+\n+\t\t  /* Now search backward for where we set the real part.  */\n+\t\t  for (; linsn != 0\n+\t\t       && ! reg_referenced_p (parm_reg_stack_loc[regnor],\n+\t\t\t\t\t      PATTERN (linsn));\n+\t\t       linsn = prev_nonnote_insn (linsn))\n+\t\t    ;\n+\n+\t          REG_NOTES (linsn)\n+\t              = gen_rtx (EXPR_LIST, REG_EQUIV,\n+\t\t\t\t parm_reg_stack_loc[regnor], REG_NOTES (linsn));\n+\t\t}\n+\t      else\n+\t        REG_NOTES (linsn)\n+\t         = gen_rtx (EXPR_LIST, REG_EQUIV,\n+\t\t\t    entry_parm, REG_NOTES (linsn));\n+\t    }\n \n \t  /* For pointer data type, suggest pointer register.  */\n \t  if (TREE_CODE (TREE_TYPE (parm)) == POINTER_TYPE)"}]}