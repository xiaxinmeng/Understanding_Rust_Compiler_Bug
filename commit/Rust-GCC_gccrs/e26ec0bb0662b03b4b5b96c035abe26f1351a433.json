{"sha": "e26ec0bb0662b03b4b5b96c035abe26f1351a433", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI2ZWMwYmIwNjYyYjAzYjRiNWI5NmMwMzVhYmUyNmYxMzUxYTQzMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-24T18:56:31Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-24T18:56:31Z"}, "message": "fold-const.c (fold_comparison): New subroutine of fold_binary containing transformations common to both the...\n\n\n\t* fold-const.c (fold_comparison): New subroutine of fold_binary\n\tcontaining transformations common to both the equality and\n\tordering relational operators, factored out of fold_binary.\n\t(fold_binary): Separate out the equality operators (EQ_EXPR\n\tand NE_EXPR) from the ordering operators (LT_EXPR, GT_EXPR,\n\tLE_EXPR and GE_EXPR), calling fold_comparison to perform the\n\ttransformations common to both.\n\t(fold_div_compare): Fix latent bugs in the previously unreachable \n\tLT_EXPR and GE_EXPR cases.\n\nFrom-SVN: r111423", "tree": {"sha": "ccf3fc8283c40f79587b2af4234aee4b98221395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccf3fc8283c40f79587b2af4234aee4b98221395"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e26ec0bb0662b03b4b5b96c035abe26f1351a433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26ec0bb0662b03b4b5b96c035abe26f1351a433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e26ec0bb0662b03b4b5b96c035abe26f1351a433", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26ec0bb0662b03b4b5b96c035abe26f1351a433/comments", "author": null, "committer": null, "parents": [{"sha": "6bb9adda5c3a5544f2038a8c452c8151bbcb44b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb9adda5c3a5544f2038a8c452c8151bbcb44b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bb9adda5c3a5544f2038a8c452c8151bbcb44b4"}], "stats": {"total": 1457, "additions": 738, "deletions": 719}, "files": [{"sha": "e1ab5426b49c3ee370ca2fed06904cc44bd9c314", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e26ec0bb0662b03b4b5b96c035abe26f1351a433/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e26ec0bb0662b03b4b5b96c035abe26f1351a433/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e26ec0bb0662b03b4b5b96c035abe26f1351a433", "patch": "@@ -1,3 +1,15 @@\n+2006-02-24  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_comparison): New subroutine of fold_binary\n+\tcontaining transformations common to both the equality and\n+\tordering relational operators, factored out of fold_binary.\n+\t(fold_binary): Separate out the equality operators (EQ_EXPR\n+\tand NE_EXPR) from the ordering operators (LT_EXPR, GT_EXPR,\n+\tLE_EXPR and GE_EXPR), calling fold_comparison to perform the\n+\ttransformations common to both.\n+\t(fold_div_compare): Fix latent bugs in the previously unreachable \n+\tLT_EXPR and GE_EXPR cases.\n+\n 2006-02-24  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_init_builtins): Change"}, {"sha": "04a8fab86d8c024a79fb20648cb604245a1390f2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 726, "deletions": 719, "changes": 1445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e26ec0bb0662b03b4b5b96c035abe26f1351a433/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e26ec0bb0662b03b4b5b96c035abe26f1351a433/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e26ec0bb0662b03b4b5b96c035abe26f1351a433", "patch": "@@ -6114,7 +6114,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \n     case LT_EXPR:\n       if (TREE_OVERFLOW (lo))\n-\treturn omit_one_operand (type, integer_zero_node, arg00);\n+\treturn omit_one_operand (type, integer_one_node, arg00);\n       return fold_build2 (LT_EXPR, type, arg00, lo);\n \n     case LE_EXPR:\n@@ -6129,7 +6129,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \n     case GE_EXPR:\n       if (TREE_OVERFLOW (lo))\n-\treturn omit_one_operand (type, integer_one_node, arg00);\n+\treturn omit_one_operand (type, integer_zero_node, arg00);\n       return fold_build2 (GE_EXPR, type, arg00, lo);\n \n     default:\n@@ -7223,17 +7223,456 @@ fold_minmax (enum tree_code code, tree type, tree op0, tree op1)\n   return NULL_TREE;\n }\n \n+/* Subroutine of fold_binary.  This routine performs all of the\n+   transformations that are common to the equality/inequality\n+   operators (EQ_EXPR and NE_EXPR) and the ordering operators\n+   (LT_EXPR, LE_EXPR, GE_EXPR and GT_EXPR).  Callers other than\n+   fold_binary should call fold_binary.  Fold a comparison with\n+   tree code CODE and type TYPE with operands OP0 and OP1.  Return\n+   the folded comparison or NULL_TREE.  */\n+\n+static tree\n+fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n+{\n+  tree arg0, arg1, tem;\n+\n+  arg0 = op0;\n+  arg1 = op1;\n+\n+  STRIP_SIGN_NOPS (arg0);\n+  STRIP_SIGN_NOPS (arg1);\n+\n+  tem = fold_relational_const (code, type, arg0, arg1);\n+  if (tem != NULL_TREE)\n+    return tem;\n+\n+  /* If one arg is a real or integer constant, put it last.  */\n+  if (tree_swap_operands_p (arg0, arg1, true))\n+    return fold_build2 (swap_tree_comparison (code), type, op1, op0);\n+\n+  /* If this is a comparison of two exprs that look like an\n+     ARRAY_REF of the same object, then we can fold this to a\n+     comparison of the two offsets.  */\n+  {\n+    tree base0, offset0, base1, offset1;\n+\n+    if (extract_array_ref (arg0, &base0, &offset0)\n+\t&& extract_array_ref (arg1, &base1, &offset1)\n+\t&& operand_equal_p (base0, base1, 0))\n+      {\n+\t/* Handle no offsets on both sides specially.  */\n+\tif (offset0 == NULL_TREE && offset1 == NULL_TREE)\n+\t  return fold_build2 (code, type, integer_zero_node,\n+\t\t\t      integer_zero_node);\n+\n+\tif (!offset0 || !offset1\n+\t    || TREE_TYPE (offset0) == TREE_TYPE (offset1))\n+\t  {\n+\t    if (offset0 == NULL_TREE)\n+\t      offset0 = build_int_cst (TREE_TYPE (offset1), 0);\n+\t    if (offset1 == NULL_TREE)\n+\t      offset1 = build_int_cst (TREE_TYPE (offset0), 0);\n+\t    return fold_build2 (code, type, offset0, offset1);\n+\t  }\n+      }\n+  }\n+\n+  /* Transform comparisons of the form X +- C1 CMP C2 to X CMP C2 +- C1.  */\n+  if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n+      && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n+\t  && !TYPE_UNSIGNED (TREE_TYPE (arg1))\n+\t  && !(flag_wrapv || flag_trapv))\n+      && (TREE_CODE (arg1) == INTEGER_CST\n+\t  && !TREE_OVERFLOW (arg1)))\n+    {\n+      tree const1 = TREE_OPERAND (arg0, 1);\n+      tree const2 = arg1;\n+      tree variable = TREE_OPERAND (arg0, 0);\n+      tree lhs;\n+      int lhs_add;\n+      lhs_add = TREE_CODE (arg0) != PLUS_EXPR;\n+\n+      lhs = fold_build2 (lhs_add ? PLUS_EXPR : MINUS_EXPR,\n+\t\t\t TREE_TYPE (arg1), const2, const1);\n+      if (TREE_CODE (lhs) == TREE_CODE (arg1)\n+\t  && (TREE_CODE (lhs) != INTEGER_CST\n+\t      || !TREE_OVERFLOW (lhs)))\n+\treturn fold_build2 (code, type, variable, lhs);\n+    }\n+\n+  if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n+    {\n+      tree targ0 = strip_float_extensions (arg0);\n+      tree targ1 = strip_float_extensions (arg1);\n+      tree newtype = TREE_TYPE (targ0);\n+\n+      if (TYPE_PRECISION (TREE_TYPE (targ1)) > TYPE_PRECISION (newtype))\n+\tnewtype = TREE_TYPE (targ1);\n+\n+      /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n+      if (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n+\treturn fold_build2 (code, type, fold_convert (newtype, targ0),\n+\t\t\t    fold_convert (newtype, targ1));\n+\n+      /* (-a) CMP (-b) -> b CMP a  */\n+      if (TREE_CODE (arg0) == NEGATE_EXPR\n+\t  && TREE_CODE (arg1) == NEGATE_EXPR)\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg1, 0),\n+\t\t\t    TREE_OPERAND (arg0, 0));\n+\n+      if (TREE_CODE (arg1) == REAL_CST)\n+\t{\n+\t  REAL_VALUE_TYPE cst;\n+\t  cst = TREE_REAL_CST (arg1);\n+\n+\t  /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n+\t  if (TREE_CODE (arg0) == NEGATE_EXPR)\n+\t    return fold_build2 (swap_tree_comparison (code), type,\n+\t\t\t\tTREE_OPERAND (arg0, 0),\n+\t\t\t\tbuild_real (TREE_TYPE (arg1),\n+\t\t\t\t\t    REAL_VALUE_NEGATE (cst)));\n+\n+\t  /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n+\t  /* a CMP (-0) -> a CMP 0  */\n+\t  if (REAL_VALUE_MINUS_ZERO (cst))\n+\t    return fold_build2 (code, type, arg0,\n+\t\t\t\tbuild_real (TREE_TYPE (arg1), dconst0));\n+\n+\t  /* x != NaN is always true, other ops are always false.  */\n+\t  if (REAL_VALUE_ISNAN (cst)\n+\t      && ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t    {\n+\t      tem = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n+\t      return omit_one_operand (type, tem, arg0);\n+\t    }\n+\n+\t  /* Fold comparisons against infinity.  */\n+\t  if (REAL_VALUE_ISINF (cst))\n+\t    {\n+\t      tem = fold_inf_compare (code, type, arg0, arg1);\n+\t      if (tem != NULL_TREE)\n+\t\treturn tem;\n+\t    }\n+\t}\n+\n+      /* If this is a comparison of a real constant with a PLUS_EXPR\n+\t or a MINUS_EXPR of a real constant, we can convert it into a\n+\t comparison with a revised real constant as long as no overflow\n+\t occurs when unsafe_math_optimizations are enabled.  */\n+      if (flag_unsafe_math_optimizations\n+\t  && TREE_CODE (arg1) == REAL_CST\n+\t  && (TREE_CODE (arg0) == PLUS_EXPR\n+\t      || TREE_CODE (arg0) == MINUS_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n+\t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n+\t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n+\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n+\n+      /* Likewise, we can simplify a comparison of a real constant with\n+         a MINUS_EXPR whose first operand is also a real constant, i.e.\n+         (c1 - x) < c2 becomes x > c1-c2.  */\n+      if (flag_unsafe_math_optimizations\n+\t  && TREE_CODE (arg1) == REAL_CST\n+\t  && TREE_CODE (arg0) == MINUS_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST\n+\t  && 0 != (tem = const_binop (MINUS_EXPR, TREE_OPERAND (arg0, 0),\n+\t\t\t\t      arg1, 0))\n+\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\treturn fold_build2 (swap_tree_comparison (code), type,\n+\t\t\t    TREE_OPERAND (arg0, 1), tem);\n+\n+      /* Fold comparisons against built-in math functions.  */\n+      if (TREE_CODE (arg1) == REAL_CST\n+\t  && flag_unsafe_math_optimizations\n+\t  && ! flag_errno_math)\n+\t{\n+\t  enum built_in_function fcode = builtin_mathfn_code (arg0);\n+\n+\t  if (fcode != END_BUILTINS)\n+\t    {\n+\t      tem = fold_mathfn_compare (fcode, code, type, arg0, arg1);\n+\t      if (tem != NULL_TREE)\n+\t\treturn tem;\n+\t    }\n+\t}\n+    }\n+\n+  /* Convert foo++ == CONST into ++foo == CONST + INCR.  */\n+  if (TREE_CONSTANT (arg1)\n+      && (TREE_CODE (arg0) == POSTINCREMENT_EXPR\n+\t  || TREE_CODE (arg0) == POSTDECREMENT_EXPR)\n+      /* This optimization is invalid for ordered comparisons\n+         if CONST+INCR overflows or if foo+incr might overflow.\n+\t This optimization is invalid for floating point due to rounding.\n+\t For pointer types we assume overflow doesn't happen.  */\n+      && (POINTER_TYPE_P (TREE_TYPE (arg0))\n+\t  || (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+\t      && (code == EQ_EXPR || code == NE_EXPR))))\n+    {\n+      tree varop, newconst;\n+\n+      if (TREE_CODE (arg0) == POSTINCREMENT_EXPR)\n+\t{\n+\t  newconst = fold_build2 (PLUS_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t  arg1, TREE_OPERAND (arg0, 1));\n+\t  varop = build2 (PREINCREMENT_EXPR, TREE_TYPE (arg0),\n+\t\t\t  TREE_OPERAND (arg0, 0),\n+\t\t\t  TREE_OPERAND (arg0, 1));\n+\t}\n+      else\n+\t{\n+\t  newconst = fold_build2 (MINUS_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t  arg1, TREE_OPERAND (arg0, 1));\n+\t  varop = build2 (PREDECREMENT_EXPR, TREE_TYPE (arg0),\n+\t\t\t  TREE_OPERAND (arg0, 0),\n+\t\t\t  TREE_OPERAND (arg0, 1));\n+\t}\n+\n+\n+      /* If VAROP is a reference to a bitfield, we must mask\n+\t the constant by the width of the field.  */\n+      if (TREE_CODE (TREE_OPERAND (varop, 0)) == COMPONENT_REF\n+\t  && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (varop, 0), 1))\n+\t  && host_integerp (DECL_SIZE (TREE_OPERAND\n+\t\t\t\t\t (TREE_OPERAND (varop, 0), 1)), 1))\n+\t{\n+\t  tree fielddecl = TREE_OPERAND (TREE_OPERAND (varop, 0), 1);\n+\t  HOST_WIDE_INT size = tree_low_cst (DECL_SIZE (fielddecl), 1);\n+\t  tree folded_compare, shift;\n+\n+\t  /* First check whether the comparison would come out\n+\t     always the same.  If we don't do that we would\n+\t     change the meaning with the masking.  */\n+\t  folded_compare = fold_build2 (code, type,\n+\t\t\t\t\tTREE_OPERAND (varop, 0), arg1);\n+\t  if (TREE_CODE (folded_compare) == INTEGER_CST)\n+\t    return omit_one_operand (type, folded_compare, varop);\n+\n+\t  shift = build_int_cst (NULL_TREE,\n+\t\t\t\t TYPE_PRECISION (TREE_TYPE (varop)) - size);\n+\t  shift = fold_convert (TREE_TYPE (varop), shift);\n+\t  newconst = fold_build2 (LSHIFT_EXPR, TREE_TYPE (varop),\n+\t\t\t\t  newconst, shift);\n+\t  newconst = fold_build2 (RSHIFT_EXPR, TREE_TYPE (varop),\n+\t\t\t\t  newconst, shift);\n+\t}\n+\n+      return fold_build2 (code, type, varop, newconst);\n+    }\n+\n+  if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n+      && (TREE_CODE (arg0) == NOP_EXPR\n+\t  || TREE_CODE (arg0) == CONVERT_EXPR))\n+    {\n+      /* If we are widening one operand of an integer comparison,\n+\t see if the other operand is similarly being widened.  Perhaps we\n+\t can do the comparison in the narrower type.  */\n+      tem = fold_widened_comparison (code, type, arg0, arg1);\n+      if (tem)\n+\treturn tem;\n+\n+      /* Or if we are changing signedness.  */\n+      tem = fold_sign_changed_comparison (code, type, arg0, arg1);\n+      if (tem)\n+\treturn tem;\n+    }\n+\n+  /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n+     constant, we can simplify it.  */\n+  if (TREE_CODE (arg1) == INTEGER_CST\n+      && (TREE_CODE (arg0) == MIN_EXPR\n+\t  || TREE_CODE (arg0) == MAX_EXPR)\n+      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+    {\n+      tem = optimize_minmax_comparison (code, type, op0, op1);\n+      if (tem)\n+\treturn tem;\n+    }\n+\n+  /* Simplify comparison of something with itself.  (For IEEE\n+     floating-point, we can only do some of these simplifications.)  */\n+  if (operand_equal_p (arg0, arg1, 0))\n+    {\n+      switch (code)\n+\t{\n+\tcase EQ_EXPR:\n+\t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n+\t      || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t    return constant_boolean_node (1, type);\n+\t  break;\n+\n+\tcase GE_EXPR:\n+\tcase LE_EXPR:\n+\t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n+\t      || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t    return constant_boolean_node (1, type);\n+\t  return fold_build2 (EQ_EXPR, type, arg0, arg1);\n+\n+\tcase NE_EXPR:\n+\t  /* For NE, we can only do this simplification if integer\n+\t     or we don't honor IEEE floating point NaNs.  */\n+\t  if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n+\t      && HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t    break;\n+\t  /* ... fall through ...  */\n+\tcase GT_EXPR:\n+\tcase LT_EXPR:\n+\t  return constant_boolean_node (0, type);\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  /* If we are comparing an expression that just has comparisons\n+     of two integer values, arithmetic expressions of those comparisons,\n+     and constants, we can simplify it.  There are only three cases\n+     to check: the two values can either be equal, the first can be\n+     greater, or the second can be greater.  Fold the expression for\n+     those three values.  Since each value must be 0 or 1, we have\n+     eight possibilities, each of which corresponds to the constant 0\n+     or 1 or one of the six possible comparisons.\n+\n+     This handles common cases like (a > b) == 0 but also handles\n+     expressions like  ((x > y) - (y > x)) > 0, which supposedly\n+     occur in macroized code.  */\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) != INTEGER_CST)\n+    {\n+      tree cval1 = 0, cval2 = 0;\n+      int save_p = 0;\n+\n+      if (twoval_comparison_p (arg0, &cval1, &cval2, &save_p)\n+\t  /* Don't handle degenerate cases here; they should already\n+\t     have been handled anyway.  */\n+\t  && cval1 != 0 && cval2 != 0\n+\t  && ! (TREE_CONSTANT (cval1) && TREE_CONSTANT (cval2))\n+\t  && TREE_TYPE (cval1) == TREE_TYPE (cval2)\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (cval1))\n+\t  && TYPE_MAX_VALUE (TREE_TYPE (cval1))\n+\t  && TYPE_MAX_VALUE (TREE_TYPE (cval2))\n+\t  && ! operand_equal_p (TYPE_MIN_VALUE (TREE_TYPE (cval1)),\n+\t\t\t\tTYPE_MAX_VALUE (TREE_TYPE (cval2)), 0))\n+\t{\n+\t  tree maxval = TYPE_MAX_VALUE (TREE_TYPE (cval1));\n+\t  tree minval = TYPE_MIN_VALUE (TREE_TYPE (cval1));\n+\n+\t  /* We can't just pass T to eval_subst in case cval1 or cval2\n+\t     was the same as ARG1.  */\n+\n+\t  tree high_result\n+\t\t= fold_build2 (code, type,\n+\t\t\t       eval_subst (arg0, cval1, maxval,\n+\t\t\t\t\t   cval2, minval),\n+\t\t\t       arg1);\n+\t  tree equal_result\n+\t\t= fold_build2 (code, type,\n+\t\t\t       eval_subst (arg0, cval1, maxval,\n+\t\t\t\t\t   cval2, maxval),\n+\t\t\t       arg1);\n+\t  tree low_result\n+\t\t= fold_build2 (code, type,\n+\t\t\t       eval_subst (arg0, cval1, minval,\n+\t\t\t\t\t   cval2, maxval),\n+\t\t\t       arg1);\n+\n+\t  /* All three of these results should be 0 or 1.  Confirm they are.\n+\t     Then use those values to select the proper code to use.  */\n+\n+\t  if (TREE_CODE (high_result) == INTEGER_CST\n+\t      && TREE_CODE (equal_result) == INTEGER_CST\n+\t      && TREE_CODE (low_result) == INTEGER_CST)\n+\t    {\n+\t      /* Make a 3-bit mask with the high-order bit being the\n+\t\t value for `>', the next for '=', and the low for '<'.  */\n+\t      switch ((integer_onep (high_result) * 4)\n+\t\t      + (integer_onep (equal_result) * 2)\n+\t\t      + integer_onep (low_result))\n+\t\t{\n+\t\tcase 0:\n+\t\t  /* Always false.  */\n+\t\t  return omit_one_operand (type, integer_zero_node, arg0);\n+\t\tcase 1:\n+\t\t  code = LT_EXPR;\n+\t\t  break;\n+\t\tcase 2:\n+\t\t  code = EQ_EXPR;\n+\t\t  break;\n+\t\tcase 3:\n+\t\t  code = LE_EXPR;\n+\t\t  break;\n+\t\tcase 4:\n+\t\t  code = GT_EXPR;\n+\t\t  break;\n+\t\tcase 5:\n+\t\t  code = NE_EXPR;\n+\t\t  break;\n+\t\tcase 6:\n+\t\t  code = GE_EXPR;\n+\t\t  break;\n+\t\tcase 7:\n+\t\t  /* Always true.  */\n+\t\t  return omit_one_operand (type, integer_one_node, arg0);\n+\t\t}\n+\n+\t      if (save_p)\n+\t\treturn save_expr (build2 (code, type, cval1, cval2));\n+\t      return fold_build2 (code, type, cval1, cval2);\n+\t    }\n+\t}\n+    }\n+\n+  /* Fold a comparison of the address of COMPONENT_REFs with the same\n+     type and component to a comparison of the address of the base\n+     object.  In short, &x->a OP &y->a to x OP y and\n+     &x->a OP &y.a to x OP &y  */\n+  if (TREE_CODE (arg0) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (arg0, 0)) == COMPONENT_REF\n+      && TREE_CODE (arg1) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (arg1, 0)) == COMPONENT_REF)\n+    {\n+      tree cref0 = TREE_OPERAND (arg0, 0);\n+      tree cref1 = TREE_OPERAND (arg1, 0);\n+      if (TREE_OPERAND (cref0, 1) == TREE_OPERAND (cref1, 1))\n+\t{\n+\t  tree op0 = TREE_OPERAND (cref0, 0);\n+\t  tree op1 = TREE_OPERAND (cref1, 0);\n+\t  return fold_build2 (code, type,\n+\t\t\t      build_fold_addr_expr (op0),\n+\t\t\t      build_fold_addr_expr (op1));\n+\t}\n+    }\n+\n+  /* We can fold X/C1 op C2 where C1 and C2 are integer constants\n+     into a single range test.  */\n+  if ((TREE_CODE (arg0) == TRUNC_DIV_EXPR\n+       || TREE_CODE (arg0) == EXACT_DIV_EXPR)\n+      && TREE_CODE (arg1) == INTEGER_CST\n+      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+      && !integer_zerop (TREE_OPERAND (arg0, 1))\n+      && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n+      && !TREE_OVERFLOW (arg1))\n+    {\n+      tem = fold_div_compare (code, type, arg0, arg1);\n+      if (tem != NULL_TREE)\n+\treturn tem;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold a binary expression of code CODE and type TYPE with operands\n    OP0 and OP1.  Return the folded expression if folding is\n    successful.  Otherwise, return NULL_TREE.  */\n \n tree\n fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n {\n-  tree t1 = NULL_TREE;\n-  tree tem;\n-  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n+  tree arg0, arg1, tem;\n+  tree t1 = NULL_TREE;\n \n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 2\n@@ -9055,26 +9494,15 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case LE_EXPR:\n-    case GE_EXPR:\t\n-      /* If one arg is a real or integer constant, put it last.  */\n-      if (tree_swap_operands_p (arg0, arg1, true))\n-\treturn fold_build2 (swap_tree_comparison (code), type, op1, op0);\n+      tem = fold_comparison (code, type, op0, op1);\n+      if (tem != NULL_TREE)\n+\treturn tem;\n \n-      /*  ~a != C becomes a != ~C where C is a constant.  Likewise for ==.  */\n-      if (TREE_CODE (arg0) == BIT_NOT_EXPR && TREE_CODE (arg1) == INTEGER_CST\n-\t  && (code == NE_EXPR || code == EQ_EXPR))\n-\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0),\n-\t\t\t    fold_build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), \n-\t\t\t\t\t arg1));\n-\t\n       /* bool_var != 0 becomes bool_var. */\n       if (TREE_CODE (TREE_TYPE (arg0)) == BOOLEAN_TYPE && integer_zerop (arg1)\n           && code == NE_EXPR)\n         return non_lvalue (fold_convert (type, arg0));\n-\t\n+\n       /* bool_var == 1 becomes bool_var. */\n       if (TREE_CODE (TREE_TYPE (arg0)) == BOOLEAN_TYPE && integer_onep (arg1)\n           && code == EQ_EXPR)\n@@ -9090,10 +9518,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n           && code == EQ_EXPR)\n         return fold_build1 (TRUTH_NOT_EXPR, type, arg0);\n \n+      /*  ~a != C becomes a != ~C where C is a constant.  Likewise for ==.  */\n+      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST)\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0),\n+\t\t\t    fold_build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), \n+\t\t\t\t\t arg1));\n+\n       /* If this is an equality comparison of the address of a non-weak\n \t object against zero, then we know the result.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == ADDR_EXPR\n+      if (TREE_CODE (arg0) == ADDR_EXPR\n \t  && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (arg0, 0))\n \t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n \t  && integer_zerop (arg1))\n@@ -9102,8 +9536,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       /* If this is an equality comparison of the address of two non-weak,\n \t unaliased symbols neither of which are extern (since we do not\n \t have access to attributes for externs), then we know the result.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == ADDR_EXPR\n+      if (TREE_CODE (arg0) == ADDR_EXPR\n \t  && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (arg0, 0))\n \t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n \t  && ! lookup_attribute (\"alias\",\n@@ -9133,65 +9566,252 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t        type);\n \t}\n \n-      /* If this is a comparison of two exprs that look like an\n-\t ARRAY_REF of the same object, then we can fold this to a\n-\t comparison of the two offsets.  */\n-      if (TREE_CODE_CLASS (code) == tcc_comparison)\n-\t{\n-\t  tree base0, offset0, base1, offset1;\n-\n-\t  if (extract_array_ref (arg0, &base0, &offset0)\n-\t      && extract_array_ref (arg1, &base1, &offset1)\n-\t      && operand_equal_p (base0, base1, 0))\n-\t    {\n-\t      /* Handle no offsets on both sides specially.  */\n-\t      if (offset0 == NULL_TREE\n-\t\t  && offset1 == NULL_TREE)\n-\t\treturn fold_build2 (code, type, integer_zero_node,\n-\t\t\t\t    integer_zero_node);\n-\n-\t      if (!offset0 || !offset1\n-\t\t  || TREE_TYPE (offset0) == TREE_TYPE (offset1))\n-\t\t{\n-\t\t  if (offset0 == NULL_TREE)\n-\t\t    offset0 = build_int_cst (TREE_TYPE (offset1), 0);\n-\t\t  if (offset1 == NULL_TREE)\n-\t\t    offset1 = build_int_cst (TREE_TYPE (offset0), 0);\n-\t\t  return fold_build2 (code, type, offset0, offset1);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Transform comparisons of the form X +- C CMP X.  */\n-      if ((code != EQ_EXPR && code != NE_EXPR)\n-\t  && (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n-\t  && ((TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t       && !HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0))))\n-\t      || (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t          && !TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t\t  && !(flag_wrapv || flag_trapv))))\n-\t{\n-\t  tree arg01 = TREE_OPERAND (arg0, 1);\n-\t  enum tree_code code0 = TREE_CODE (arg0);\n-\t  int is_positive;\n+      /* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or\n+\t a MINUS_EXPR of a constant, we can convert it into a comparison with\n+\t a revised constant as long as no overflow occurs.  */\n+      if (TREE_CODE (arg1) == INTEGER_CST\n+\t  && (TREE_CODE (arg0) == PLUS_EXPR\n+\t      || TREE_CODE (arg0) == MINUS_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n+\t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n+\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n-\t  if (TREE_CODE (arg01) == REAL_CST)\n-\t    is_positive = REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg01)) ? -1 : 1;\n-\t  else\n-\t    is_positive = tree_int_cst_sgn (arg01);\n+      /* Similarly for a NEGATE_EXPR.  */\n+      if (TREE_CODE (arg0) == NEGATE_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && 0 != (tem = negate_expr (arg1))\n+\t  && TREE_CODE (tem) == INTEGER_CST\n+\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n-\t  /* (X - c) > X becomes false.  */\n-\t  if (code == GT_EXPR\n-\t      && ((code0 == MINUS_EXPR && is_positive >= 0)\n-\t\t  || (code0 == PLUS_EXPR && is_positive <= 0)))\n-\t    return constant_boolean_node (0, type);\n+      /* If we have X - Y == 0, we can convert that to X == Y and similarly\n+\t for !=.  Don't do this for ordered comparisons due to overflow.  */\n+      if (TREE_CODE (arg0) == MINUS_EXPR\n+\t  && integer_zerop (arg1))\n+\treturn fold_build2 (code, type,\n+\t\t\t    TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n \n-\t  /* Likewise (X + c) < X becomes false.  */\n-\t  if (code == LT_EXPR\n-\t      && ((code0 == PLUS_EXPR && is_positive >= 0)\n-\t\t  || (code0 == MINUS_EXPR && is_positive <= 0)))\n-\t    return constant_boolean_node (0, type);\n+      /* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */\n+      if (TREE_CODE (arg0) == ABS_EXPR\n+\t  && (integer_zerop (arg1) || real_zerop (arg1)))\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), arg1);\n+\n+      /* If this is an EQ or NE comparison with zero and ARG0 is\n+\t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n+\t two operations, but the latter can be done in one less insn\n+\t on machines that have only two-operand insns or on which a\n+\t constant cannot be the first operand.  */\n+      if (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && integer_zerop (arg1))\n+\t{\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t  if (TREE_CODE (arg00) == LSHIFT_EXPR\n+\t      && integer_onep (TREE_OPERAND (arg00, 0)))\n+\t    return\n+\t      fold_build2 (code, type,\n+\t\t\t   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t   build2 (RSHIFT_EXPR, TREE_TYPE (arg00),\n+\t\t\t\t\t   arg01, TREE_OPERAND (arg00, 1)),\n+\t\t\t\t   fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\t integer_one_node)),\n+\t\t\t   arg1);\n+\t  else if (TREE_CODE (TREE_OPERAND (arg0, 1)) == LSHIFT_EXPR\n+\t\t   && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 1), 0)))\n+\t    return\n+\t      fold_build2 (code, type,\n+\t\t\t   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t   build2 (RSHIFT_EXPR, TREE_TYPE (arg01),\n+\t\t\t\t\t   arg00, TREE_OPERAND (arg01, 1)),\n+\t\t\t\t   fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\t integer_one_node)),\n+\t\t\t   arg1);\n+\t}\n+\n+      /* If this is an NE or EQ comparison of zero against the result of a\n+\t signed MOD operation whose second operand is a power of 2, make\n+\t the MOD operation unsigned since it is simpler and equivalent.  */\n+      if (integer_zerop (arg1)\n+\t  && !TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t  && (TREE_CODE (arg0) == TRUNC_MOD_EXPR\n+\t      || TREE_CODE (arg0) == CEIL_MOD_EXPR\n+\t      || TREE_CODE (arg0) == FLOOR_MOD_EXPR\n+\t      || TREE_CODE (arg0) == ROUND_MOD_EXPR)\n+\t  && integer_pow2p (TREE_OPERAND (arg0, 1)))\n+\t{\n+\t  tree newtype = lang_hooks.types.unsigned_type (TREE_TYPE (arg0));\n+\t  tree newmod = fold_build2 (TREE_CODE (arg0), newtype,\n+\t\t\t\t     fold_convert (newtype,\n+\t\t\t\t\t\t   TREE_OPERAND (arg0, 0)),\n+\t\t\t\t     fold_convert (newtype,\n+\t\t\t\t\t\t   TREE_OPERAND (arg0, 1)));\n+\n+\t  return fold_build2 (code, type, newmod,\n+\t\t\t      fold_convert (newtype, arg1));\n+\t}\n+\n+      /* If this is an NE comparison of zero with an AND of one, remove the\n+\t comparison since the AND will give the correct value.  */\n+      if (code == NE_EXPR\n+\t  && integer_zerop (arg1)\n+\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && integer_onep (TREE_OPERAND (arg0, 1)))\n+\treturn fold_convert (type, arg0);\n+\n+      /* If we have (A & C) == C where C is a power of 2, convert this into\n+\t (A & C) != 0.  Similarly for NE_EXPR.  */\n+      if (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n+\treturn fold_build2 (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n+\t\t\t    arg0, fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\tinteger_zero_node));\n+\n+      /* If we have (A & C) != 0 or (A & C) == 0 and C is the sign\n+\t bit, then fold the expression into A < 0 or A >= 0.  */\n+      tem = fold_single_bit_test_into_sign_test (code, arg0, arg1, type);\n+      if (tem)\n+\treturn tem;\n+\n+      /* If we have (A & C) == D where D & ~C != 0, convert this into 0.\n+\t Similarly for NE_EXPR.  */\n+      if (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\t{\n+\t  tree notc = fold_build1 (BIT_NOT_EXPR,\n+\t\t\t\t   TREE_TYPE (TREE_OPERAND (arg0, 1)),\n+\t\t\t\t   TREE_OPERAND (arg0, 1));\n+\t  tree dandnotc = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t       arg1, notc);\n+\t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n+\t  if (integer_nonzerop (dandnotc))\n+\t    return omit_one_operand (type, rslt, arg0);\n+\t}\n+\n+      /* If we have (A | C) == D where C & ~D != 0, convert this into 0.\n+\t Similarly for NE_EXPR.  */\n+      if (TREE_CODE (arg0) == BIT_IOR_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\t{\n+\t  tree notd = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), arg1);\n+\t  tree candnotd = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t       TREE_OPERAND (arg0, 1), notd);\n+\t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n+\t  if (integer_nonzerop (candnotd))\n+\t    return omit_one_operand (type, rslt, arg0);\n+\t}\n+\n+      /* If this is a comparison of a field, we may be able to simplify it.  */\n+      if (((TREE_CODE (arg0) == COMPONENT_REF\n+\t    && lang_hooks.can_use_bit_fields_p ())\n+\t   || TREE_CODE (arg0) == BIT_FIELD_REF)\n+\t  /* Handle the constant case even without -O\n+\t     to make sure the warnings are given.  */\n+\t  && (optimize || TREE_CODE (arg1) == INTEGER_CST))\n+\t{\n+\t  t1 = optimize_bit_field_compare (code, type, arg0, arg1);\n+\t  if (t1)\n+\t    return t1;\n+\t}\n+\n+      /* Optimize comparisons of strlen vs zero to a compare of the\n+\t first character of the string vs zero.  To wit,\n+\t\tstrlen(ptr) == 0   =>  *ptr == 0\n+\t\tstrlen(ptr) != 0   =>  *ptr != 0\n+\t Other cases should reduce to one of these two (or a constant)\n+\t due to the return value of strlen being unsigned.  */\n+      if (TREE_CODE (arg0) == CALL_EXPR\n+\t  && integer_zerop (arg1))\n+\t{\n+\t  tree fndecl = get_callee_fndecl (arg0);\n+\t  tree arglist;\n+\n+\t  if (fndecl\n+\t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STRLEN\n+\t      && (arglist = TREE_OPERAND (arg0, 1))\n+\t      && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE\n+\t      && ! TREE_CHAIN (arglist))\n+\t    {\n+\t      tree iref = build_fold_indirect_ref (TREE_VALUE (arglist));\n+\t      return fold_build2 (code, type, iref,\n+\t\t\t\t  build_int_cst (TREE_TYPE (iref), 0));\n+\t    }\n+\t}\n+\n+      /* Fold (X >> C) != 0 into X < 0 if C is one less than the width\n+\t of X.  Similarly fold (X >> C) == 0 into X >= 0.  */\n+      if (TREE_CODE (arg0) == RSHIFT_EXPR\n+\t  && integer_zerop (arg1)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\t{\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t  tree itype = TREE_TYPE (arg00);\n+\t  if (TREE_INT_CST_HIGH (arg01) == 0\n+\t      && TREE_INT_CST_LOW (arg01)\n+\t\t == (unsigned HOST_WIDE_INT) (TYPE_PRECISION (itype) - 1))\n+\t    {\n+\t      if (TYPE_UNSIGNED (itype))\n+\t\t{\n+\t\t  itype = lang_hooks.types.signed_type (itype);\n+\t\t  arg00 = fold_convert (itype, arg00);\n+\t\t}\n+\t      return fold_build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n+\t\t\t\t  type, arg00, build_int_cst (itype, 0));\n+\t    }\n+\t}\n+\n+      if (integer_zerop (arg1)\n+\t  && tree_expr_nonzero_p (arg0))\n+        {\n+\t  tree res = constant_boolean_node (code==NE_EXPR, type);\n+\t  return omit_one_operand (type, res, arg0);\n+\t}\n+      return NULL_TREE;\n+\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+      tem = fold_comparison (code, type, op0, op1);\n+      if (tem != NULL_TREE)\n+\treturn tem;\n+\n+      /* Transform comparisons of the form X +- C CMP X.  */\n+      if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n+\t  && ((TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n+\t       && !HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t      || (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t          && !TYPE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t  && !(flag_wrapv || flag_trapv))))\n+\t{\n+\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t  enum tree_code code0 = TREE_CODE (arg0);\n+\t  int is_positive;\n+\n+\t  if (TREE_CODE (arg01) == REAL_CST)\n+\t    is_positive = REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg01)) ? -1 : 1;\n+\t  else\n+\t    is_positive = tree_int_cst_sgn (arg01);\n+\n+\t  /* (X - c) > X becomes false.  */\n+\t  if (code == GT_EXPR\n+\t      && ((code0 == MINUS_EXPR && is_positive >= 0)\n+\t\t  || (code0 == PLUS_EXPR && is_positive <= 0)))\n+\t    return constant_boolean_node (0, type);\n+\n+\t  /* Likewise (X + c) < X becomes false.  */\n+\t  if (code == LT_EXPR\n+\t      && ((code0 == PLUS_EXPR && is_positive >= 0)\n+\t\t  || (code0 == MINUS_EXPR && is_positive <= 0)))\n+\t    return constant_boolean_node (0, type);\n \n \t  /* Convert (X - c) <= X to true.  */\n \t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1)))\n@@ -9233,217 +9853,26 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    }\n \t}\n \n-      /* Transform comparisons of the form X +- C1 CMP C2 to X CMP C2 +- C1.  */\n-      if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\t  && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t      && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t      && !TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t      && !(flag_wrapv || flag_trapv))\n-\t  && (TREE_CODE (arg1) == INTEGER_CST\n-\t      && !TREE_OVERFLOW (arg1)))\n-\t{\n-\t  tree const1 = TREE_OPERAND (arg0, 1);\n-\t  tree const2 = arg1;\n-\t  tree variable = TREE_OPERAND (arg0, 0);\n-\t  tree lhs;\n-\t  int lhs_add;\n-\t  lhs_add = TREE_CODE (arg0) != PLUS_EXPR;\n-\t  \n-\t  lhs = fold_build2 (lhs_add ? PLUS_EXPR : MINUS_EXPR,\n-\t\t\t     TREE_TYPE (arg1), const2, const1);\n-\t  if (TREE_CODE (lhs) == TREE_CODE (arg1)\n-\t      && (TREE_CODE (lhs) != INTEGER_CST\n-\t          || !TREE_OVERFLOW (lhs)))\n-\t    return fold_build2 (code, type, variable, lhs);\n-\t}\n-\n-      if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n-\t{\n-\t  tree targ0 = strip_float_extensions (arg0);\n-\t  tree targ1 = strip_float_extensions (arg1);\n-\t  tree newtype = TREE_TYPE (targ0);\n-\n-\t  if (TYPE_PRECISION (TREE_TYPE (targ1)) > TYPE_PRECISION (newtype))\n-\t    newtype = TREE_TYPE (targ1);\n-\n-\t  /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n-\t  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t    return fold_build2 (code, type, fold_convert (newtype, targ0),\n-\t\t\t\tfold_convert (newtype, targ1));\n-\n-\t  /* (-a) CMP (-b) -> b CMP a  */\n-\t  if (TREE_CODE (arg0) == NEGATE_EXPR\n-\t      && TREE_CODE (arg1) == NEGATE_EXPR)\n-\t    return fold_build2 (code, type, TREE_OPERAND (arg1, 0),\n-\t\t\t\tTREE_OPERAND (arg0, 0));\n-\n-\t  if (TREE_CODE (arg1) == REAL_CST)\n-\t  {\n-\t    REAL_VALUE_TYPE cst;\n-\t    cst = TREE_REAL_CST (arg1);\n-\n-\t    /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n-\t    if (TREE_CODE (arg0) == NEGATE_EXPR)\n-\t      return\n-\t\tfold_build2 (swap_tree_comparison (code), type,\n-\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t     build_real (TREE_TYPE (arg1),\n-\t\t\t\t\t REAL_VALUE_NEGATE (cst)));\n-\n-\t    /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n-\t    /* a CMP (-0) -> a CMP 0  */\n-\t    if (REAL_VALUE_MINUS_ZERO (cst))\n-\t      return fold_build2 (code, type, arg0,\n-\t\t\t\t  build_real (TREE_TYPE (arg1), dconst0));\n-\n-\t    /* x != NaN is always true, other ops are always false.  */\n-\t    if (REAL_VALUE_ISNAN (cst)\n-\t\t&& ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t      {\n-\t\ttem = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n-\t\treturn omit_one_operand (type, tem, arg0);\n-\t      }\n-\n-\t    /* Fold comparisons against infinity.  */\n-\t    if (REAL_VALUE_ISINF (cst))\n-\t      {\n-\t\ttem = fold_inf_compare (code, type, arg0, arg1);\n-\t\tif (tem != NULL_TREE)\n-\t\t  return tem;\n-\t      }\n-\t  }\n-\n-\t  /* If this is a comparison of a real constant with a PLUS_EXPR\n-\t     or a MINUS_EXPR of a real constant, we can convert it into a\n-\t     comparison with a revised real constant as long as no overflow\n-\t     occurs when unsafe_math_optimizations are enabled.  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg1) == REAL_CST\n-\t      && (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t  || TREE_CODE (arg0) == MINUS_EXPR)\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t      && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t\t\t\t  ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t\t\t  arg1, TREE_OPERAND (arg0, 1), 0))\n-\t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n-\n-\t  /* Likewise, we can simplify a comparison of a real constant with\n-\t     a MINUS_EXPR whose first operand is also a real constant, i.e.\n-\t     (c1 - x) < c2 becomes x > c1-c2.  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg1) == REAL_CST\n-\t      && TREE_CODE (arg0) == MINUS_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST\n-\t      && 0 != (tem = const_binop (MINUS_EXPR, TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t  arg1, 0))\n-\t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold_build2 (swap_tree_comparison (code), type,\n-\t\t\t\tTREE_OPERAND (arg0, 1), tem);\n-\n-\t  /* Fold comparisons against built-in math functions.  */\n-\t  if (TREE_CODE (arg1) == REAL_CST\n-\t      && flag_unsafe_math_optimizations\n-\t      && ! flag_errno_math)\n-\t    {\n-\t      enum built_in_function fcode = builtin_mathfn_code (arg0);\n-\n-\t      if (fcode != END_BUILTINS)\n-\t\t{\n-\t\t  tem = fold_mathfn_compare (fcode, code, type, arg0, arg1);\n-\t\t  if (tem != NULL_TREE)\n-\t\t    return tem;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Convert foo++ == CONST into ++foo == CONST + INCR.  */\n-      if (TREE_CONSTANT (arg1)\n-\t  && (TREE_CODE (arg0) == POSTINCREMENT_EXPR\n-\t      || TREE_CODE (arg0) == POSTDECREMENT_EXPR)\n-\t  /* This optimization is invalid for ordered comparisons\n-\t     if CONST+INCR overflows or if foo+incr might overflow.\n-\t     This optimization is invalid for floating point due to rounding.\n-\t     For pointer types we assume overflow doesn't happen.  */\n-\t  && (POINTER_TYPE_P (TREE_TYPE (arg0))\n-\t      || (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n-\t\t  && (code == EQ_EXPR || code == NE_EXPR))))\n-\t{\n-\t  tree varop, newconst;\n-\n-\t  if (TREE_CODE (arg0) == POSTINCREMENT_EXPR)\n-\t    {\n-\t      newconst = fold_build2 (PLUS_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t      arg1, TREE_OPERAND (arg0, 1));\n-\t      varop = build2 (PREINCREMENT_EXPR, TREE_TYPE (arg0),\n-\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t      TREE_OPERAND (arg0, 1));\n-\t    }\n-\t  else\n-\t    {\n-\t      newconst = fold_build2 (MINUS_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t      arg1, TREE_OPERAND (arg0, 1));\n-\t      varop = build2 (PREDECREMENT_EXPR, TREE_TYPE (arg0),\n-\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t      TREE_OPERAND (arg0, 1));\n-\t    }\n-\n-\n-\t  /* If VAROP is a reference to a bitfield, we must mask\n-\t     the constant by the width of the field.  */\n-\t  if (TREE_CODE (TREE_OPERAND (varop, 0)) == COMPONENT_REF\n-\t      && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (varop, 0), 1))\n-\t      && host_integerp (DECL_SIZE (TREE_OPERAND\n-\t\t\t\t\t   (TREE_OPERAND (varop, 0), 1)), 1))\n-\t    {\n-\t      tree fielddecl = TREE_OPERAND (TREE_OPERAND (varop, 0), 1);\n-\t      HOST_WIDE_INT size = tree_low_cst (DECL_SIZE (fielddecl), 1);\n-\t      tree folded_compare, shift;\n-\n-\t      /* First check whether the comparison would come out\n-\t\t always the same.  If we don't do that we would\n-\t\t change the meaning with the masking.  */\n-\t      folded_compare = fold_build2 (code, type,\n-\t\t\t\t\t    TREE_OPERAND (varop, 0), arg1);\n-\t      if (integer_zerop (folded_compare)\n-\t\t  || integer_onep (folded_compare))\n-\t\treturn omit_one_operand (type, folded_compare, varop);\n-\n-\t      shift = build_int_cst (NULL_TREE,\n-\t\t\t\t     TYPE_PRECISION (TREE_TYPE (varop)) - size);\n-\t      shift = fold_convert (TREE_TYPE (varop), shift);\n-\t      newconst = fold_build2 (LSHIFT_EXPR, TREE_TYPE (varop),\n-\t\t\t\t      newconst, shift);\n-\t      newconst = fold_build2 (RSHIFT_EXPR, TREE_TYPE (varop),\n-\t\t\t\t      newconst, shift);\n-\t    }\n-\n-\t  return fold_build2 (code, type, varop, newconst);\n-\t}\n-\n       /* Change X >= C to X > (C - 1) and X < C to X <= (C - 1) if C > 0.\n \t This transformation affects the cases which are handled in later\n \t optimizations involving comparisons with non-negative constants.  */\n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_CODE (arg0) != INTEGER_CST\n \t  && tree_int_cst_sgn (arg1) > 0)\n \t{\n-\t  switch (code)\n+\t  if (code == GE_EXPR)\n \t    {\n-\t    case GE_EXPR:\n \t      arg1 = const_binop (MINUS_EXPR, arg1,\n \t\t\t          build_int_cst (TREE_TYPE (arg1), 1), 0);\n \t      return fold_build2 (GT_EXPR, type, arg0,\n \t\t\t\t  fold_convert (TREE_TYPE (arg0), arg1));\n-\n-\t    case LT_EXPR:\n+\t    }\n+\t  if (code == LT_EXPR)\n+\t    {\n \t      arg1 = const_binop (MINUS_EXPR, arg1,\n \t\t\t          build_int_cst (TREE_TYPE (arg1), 1), 0);\n \t      return fold_build2 (LE_EXPR, type, arg0,\n \t\t\t\t  fold_convert (TREE_TYPE (arg0), arg1));\n-\n-\t    default:\n-\t      break;\n \t    }\n \t}\n \n@@ -9596,214 +10025,38 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  }\n       }\n \n-      /* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or\n-\t a MINUS_EXPR of a constant, we can convert it into a comparison with\n-\t a revised constant as long as no overflow occurs.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && (TREE_CODE (arg0) == PLUS_EXPR\n-\t      || TREE_CODE (arg0) == MINUS_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n-\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n-\n-      /* Similarly for a NEGATE_EXPR.  */\n-      else if ((code == EQ_EXPR || code == NE_EXPR)\n-\t       && TREE_CODE (arg0) == NEGATE_EXPR\n-\t       && TREE_CODE (arg1) == INTEGER_CST\n-\t       && 0 != (tem = negate_expr (arg1))\n-\t       && TREE_CODE (tem) == INTEGER_CST\n-\t       && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n-\n-      /* If we have X - Y == 0, we can convert that to X == Y and similarly\n-\t for !=.  Don't do this for ordered comparisons due to overflow.  */\n-      else if ((code == NE_EXPR || code == EQ_EXPR)\n-\t       && integer_zerop (arg1) && TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold_build2 (code, type,\n-\t\t\t    TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n-\n-      else if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n-\t       && (TREE_CODE (arg0) == NOP_EXPR\n-\t\t   || TREE_CODE (arg0) == CONVERT_EXPR))\n-\t{\n-\t  /* If we are widening one operand of an integer comparison,\n-\t     see if the other operand is similarly being widened.  Perhaps we\n-\t     can do the comparison in the narrower type.  */\n-\t  tem = fold_widened_comparison (code, type, arg0, arg1);\n-\t  if (tem)\n-\t    return tem;\n-\n-\t  /* Or if we are changing signedness.  */\n-\t  tem = fold_sign_changed_comparison (code, type, arg0, arg1);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n-      /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n-\t constant, we can simplify it.  */\n-      else if (TREE_CODE (arg1) == INTEGER_CST\n-\t       && (TREE_CODE (arg0) == MIN_EXPR\n-\t\t   || TREE_CODE (arg0) == MAX_EXPR)\n-\t       && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tem = optimize_minmax_comparison (code, type, op0, op1);\n-\t  if (tem)\n-\t    return tem;\n-\n-\t  return NULL_TREE;\n-\t}\n-\n       /* If we are comparing an ABS_EXPR with a constant, we can\n \t convert all the cases into explicit comparisons, but they may\n \t well not be faster than doing the ABS and one comparison.\n \t But ABS (X) <= C is a range comparison, which becomes a subtraction\n \t and a comparison, and is probably faster.  */\n-      else if (code == LE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n-\t       && TREE_CODE (arg0) == ABS_EXPR\n-\t       && ! TREE_SIDE_EFFECTS (arg0)\n-\t       && (0 != (tem = negate_expr (arg1)))\n-\t       && TREE_CODE (tem) == INTEGER_CST\n-\t       && ! TREE_CONSTANT_OVERFLOW (tem))\n+      if (code == LE_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (arg0) == ABS_EXPR\n+\t  && ! TREE_SIDE_EFFECTS (arg0)\n+\t  && (0 != (tem = negate_expr (arg1)))\n+\t  && TREE_CODE (tem) == INTEGER_CST\n+\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n \treturn fold_build2 (TRUTH_ANDIF_EXPR, type,\n \t\t\t    build2 (GE_EXPR, type,\n \t\t\t\t    TREE_OPERAND (arg0, 0), tem),\n \t\t\t    build2 (LE_EXPR, type,\n \t\t\t\t    TREE_OPERAND (arg0, 0), arg1));\n \n       /* Convert ABS_EXPR<x> >= 0 to true.  */\n-      else if (code == GE_EXPR\n-\t       && tree_expr_nonnegative_p (arg0)\n-\t       && (integer_zerop (arg1)\n-\t\t   || (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n-                       && real_zerop (arg1))))\n+      if (code == GE_EXPR\n+\t  && tree_expr_nonnegative_p (arg0)\n+\t  && (integer_zerop (arg1)\n+\t      || (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t\t  && real_zerop (arg1))))\n \treturn omit_one_operand (type, integer_one_node, arg0);\n \n       /* Convert ABS_EXPR<x> < 0 to false.  */\n-      else if (code == LT_EXPR\n-\t       && tree_expr_nonnegative_p (arg0)\n-\t       && (integer_zerop (arg1) || real_zerop (arg1)))\n+      if (code == LT_EXPR\n+\t  && tree_expr_nonnegative_p (arg0)\n+\t  && (integer_zerop (arg1) || real_zerop (arg1)))\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n \n-      /* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */\n-      else if ((code == EQ_EXPR || code == NE_EXPR)\n-\t       && TREE_CODE (arg0) == ABS_EXPR\n-\t       && (integer_zerop (arg1) || real_zerop (arg1)))\n-\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), arg1);\n-\n-      /* If this is an EQ or NE comparison with zero and ARG0 is\n-\t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n-\t two operations, but the latter can be done in one less insn\n-\t on machines that have only two-operand insns or on which a\n-\t constant cannot be the first operand.  */\n-      if (integer_zerop (arg1) && (code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR)\n-\t{\n-\t  tree arg00 = TREE_OPERAND (arg0, 0);\n-\t  tree arg01 = TREE_OPERAND (arg0, 1);\n-\t  if (TREE_CODE (arg00) == LSHIFT_EXPR\n-\t      && integer_onep (TREE_OPERAND (arg00, 0)))\n-\t    return\n-\t      fold_build2 (code, type,\n-\t\t\t   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t   build2 (RSHIFT_EXPR, TREE_TYPE (arg00),\n-\t\t\t\t\t   arg01, TREE_OPERAND (arg00, 1)),\n-\t\t\t\t   fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t integer_one_node)),\n-\t\t\t   arg1);\n-\t  else if (TREE_CODE (TREE_OPERAND (arg0, 1)) == LSHIFT_EXPR\n-\t\t   && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 1), 0)))\n-\t    return\n-\t      fold_build2 (code, type,\n-\t\t\t   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t   build2 (RSHIFT_EXPR, TREE_TYPE (arg01),\n-\t\t\t\t\t   arg00, TREE_OPERAND (arg01, 1)),\n-\t\t\t\t   fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t integer_one_node)),\n-\t\t\t   arg1);\n-\t}\n-\n-      /* If this is an NE or EQ comparison of zero against the result of a\n-\t signed MOD operation whose second operand is a power of 2, make\n-\t the MOD operation unsigned since it is simpler and equivalent.  */\n-      if ((code == NE_EXPR || code == EQ_EXPR)\n-\t  && integer_zerop (arg1)\n-\t  && !TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t  && (TREE_CODE (arg0) == TRUNC_MOD_EXPR\n-\t      || TREE_CODE (arg0) == CEIL_MOD_EXPR\n-\t      || TREE_CODE (arg0) == FLOOR_MOD_EXPR\n-\t      || TREE_CODE (arg0) == ROUND_MOD_EXPR)\n-\t  && integer_pow2p (TREE_OPERAND (arg0, 1)))\n-\t{\n-\t  tree newtype = lang_hooks.types.unsigned_type (TREE_TYPE (arg0));\n-\t  tree newmod = fold_build2 (TREE_CODE (arg0), newtype,\n-\t\t\t\t     fold_convert (newtype,\n-\t\t\t\t\t\t   TREE_OPERAND (arg0, 0)),\n-\t\t\t\t     fold_convert (newtype,\n-\t\t\t\t\t\t   TREE_OPERAND (arg0, 1)));\n-\n-\t  return fold_build2 (code, type, newmod,\n-\t\t\t      fold_convert (newtype, arg1));\n-\t}\n-\n-      /* If this is an NE comparison of zero with an AND of one, remove the\n-\t comparison since the AND will give the correct value.  */\n-      if (code == NE_EXPR && integer_zerop (arg1)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && integer_onep (TREE_OPERAND (arg0, 1)))\n-\treturn fold_convert (type, arg0);\n-\n-      /* If we have (A & C) == C where C is a power of 2, convert this into\n-\t (A & C) != 0.  Similarly for NE_EXPR.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn fold_build2 (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n-\t\t\t    arg0, fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\tinteger_zero_node));\n-\n-      /* If we have (A & C) != 0 or (A & C) == 0 and C is the sign\n-\t bit, then fold the expression into A < 0 or A >= 0.  */\n-      tem = fold_single_bit_test_into_sign_test (code, arg0, arg1, type);\n-      if (tem)\n-\treturn tem;\n-\n-      /* If we have (A & C) == D where D & ~C != 0, convert this into 0.\n-\t Similarly for NE_EXPR.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tree notc = fold_build1 (BIT_NOT_EXPR,\n-\t\t\t\t   TREE_TYPE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t   TREE_OPERAND (arg0, 1));\n-\t  tree dandnotc = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t       arg1, notc);\n-\t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n-\t  if (integer_nonzerop (dandnotc))\n-\t    return omit_one_operand (type, rslt, arg0);\n-\t}\n-\n-      /* If we have (A | C) == D where C & ~D != 0, convert this into 0.\n-\t Similarly for NE_EXPR.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_IOR_EXPR\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tree notd = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), arg1);\n-\t  tree candnotd = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t       TREE_OPERAND (arg0, 1), notd);\n-\t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n-\t  if (integer_nonzerop (candnotd))\n-\t    return omit_one_operand (type, rslt, arg0);\n-\t}\n-\n       /* If X is unsigned, convert X < (1 << Y) into X >> Y == 0\n \t and similarly for >= into !=.  */\n       if ((code == LT_EXPR || code == GE_EXPR)\n@@ -9815,12 +10068,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t       TREE_OPERAND (arg1, 1)),\n \t\t       build_int_cst (TREE_TYPE (arg0), 0));\n \n-      else if ((code == LT_EXPR || code == GE_EXPR)\n-\t       && TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t       && (TREE_CODE (arg1) == NOP_EXPR\n-\t\t   || TREE_CODE (arg1) == CONVERT_EXPR)\n-\t       && TREE_CODE (TREE_OPERAND (arg1, 0)) == LSHIFT_EXPR\n-\t       && integer_onep (TREE_OPERAND (TREE_OPERAND (arg1, 0), 0)))\n+      if ((code == LT_EXPR || code == GE_EXPR)\n+\t  && TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t  && (TREE_CODE (arg1) == NOP_EXPR\n+\t      || TREE_CODE (arg1) == CONVERT_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (arg1, 0)) == LSHIFT_EXPR\n+\t  && integer_onep (TREE_OPERAND (TREE_OPERAND (arg1, 0), 0)))\n \treturn\n \t  build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n \t\t  fold_convert (TREE_TYPE (arg0),\n@@ -9829,253 +10082,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t\t      1))),\n \t\t  build_int_cst (TREE_TYPE (arg0), 0));\n \n-      /* Simplify comparison of something with itself.  (For IEEE\n-\t floating-point, we can only do some of these simplifications.)  */\n-      if (operand_equal_p (arg0, arg1, 0))\n-\t{\n-\t  switch (code)\n-\t    {\n-\t    case EQ_EXPR:\n-\t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n-\t\treturn constant_boolean_node (1, type);\n-\t      break;\n-\n-\t    case GE_EXPR:\n-\t    case LE_EXPR:\n-\t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n-\t\treturn constant_boolean_node (1, type);\n-\t      return fold_build2 (EQ_EXPR, type, arg0, arg1);\n-\n-\t    case NE_EXPR:\n-\t      /* For NE, we can only do this simplification if integer\n-\t\t or we don't honor IEEE floating point NaNs.  */\n-\t      if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t\t  && HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n-\t\tbreak;\n-\t      /* ... fall through ...  */\n-\t    case GT_EXPR:\n-\t    case LT_EXPR:\n-\t      return constant_boolean_node (0, type);\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-\n-      /* If we are comparing an expression that just has comparisons\n-\t of two integer values, arithmetic expressions of those comparisons,\n-\t and constants, we can simplify it.  There are only three cases\n-\t to check: the two values can either be equal, the first can be\n-\t greater, or the second can be greater.  Fold the expression for\n-\t those three values.  Since each value must be 0 or 1, we have\n-\t eight possibilities, each of which corresponds to the constant 0\n-\t or 1 or one of the six possible comparisons.\n-\n-\t This handles common cases like (a > b) == 0 but also handles\n-\t expressions like  ((x > y) - (y > x)) > 0, which supposedly\n-\t occur in macroized code.  */\n-\n-      if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) != INTEGER_CST)\n-\t{\n-\t  tree cval1 = 0, cval2 = 0;\n-\t  int save_p = 0;\n-\n-\t  if (twoval_comparison_p (arg0, &cval1, &cval2, &save_p)\n-\t      /* Don't handle degenerate cases here; they should already\n-\t\t have been handled anyway.  */\n-\t      && cval1 != 0 && cval2 != 0\n-\t      && ! (TREE_CONSTANT (cval1) && TREE_CONSTANT (cval2))\n-\t      && TREE_TYPE (cval1) == TREE_TYPE (cval2)\n-\t      && INTEGRAL_TYPE_P (TREE_TYPE (cval1))\n-\t      && TYPE_MAX_VALUE (TREE_TYPE (cval1))\n-\t      && TYPE_MAX_VALUE (TREE_TYPE (cval2))\n-\t      && ! operand_equal_p (TYPE_MIN_VALUE (TREE_TYPE (cval1)),\n-\t\t\t\t    TYPE_MAX_VALUE (TREE_TYPE (cval2)), 0))\n-\t    {\n-\t      tree maxval = TYPE_MAX_VALUE (TREE_TYPE (cval1));\n-\t      tree minval = TYPE_MIN_VALUE (TREE_TYPE (cval1));\n-\n-\t      /* We can't just pass T to eval_subst in case cval1 or cval2\n-\t\t was the same as ARG1.  */\n-\n-\t      tree high_result\n-\t\t= fold_build2 (code, type,\n-\t\t\t       eval_subst (arg0, cval1, maxval,\n-\t\t\t\t\t   cval2, minval),\n-\t\t\t       arg1);\n-\t      tree equal_result\n-\t\t= fold_build2 (code, type,\n-\t\t\t       eval_subst (arg0, cval1, maxval,\n-\t\t\t\t\t   cval2, maxval),\n-\t\t\t       arg1);\n-\t      tree low_result\n-\t\t= fold_build2 (code, type,\n-\t\t\t       eval_subst (arg0, cval1, minval,\n-\t\t\t\t\t   cval2, maxval),\n-\t\t\t       arg1);\n-\n-\t      /* All three of these results should be 0 or 1.  Confirm they\n-\t\t are.  Then use those values to select the proper code\n-\t\t to use.  */\n-\n-\t      if ((integer_zerop (high_result)\n-\t\t   || integer_onep (high_result))\n-\t\t  && (integer_zerop (equal_result)\n-\t\t      || integer_onep (equal_result))\n-\t\t  && (integer_zerop (low_result)\n-\t\t      || integer_onep (low_result)))\n-\t\t{\n-\t\t  /* Make a 3-bit mask with the high-order bit being the\n-\t\t     value for `>', the next for '=', and the low for '<'.  */\n-\t\t  switch ((integer_onep (high_result) * 4)\n-\t\t\t  + (integer_onep (equal_result) * 2)\n-\t\t\t  + integer_onep (low_result))\n-\t\t    {\n-\t\t    case 0:\n-\t\t      /* Always false.  */\n-\t\t      return omit_one_operand (type, integer_zero_node, arg0);\n-\t\t    case 1:\n-\t\t      code = LT_EXPR;\n-\t\t      break;\n-\t\t    case 2:\n-\t\t      code = EQ_EXPR;\n-\t\t      break;\n-\t\t    case 3:\n-\t\t      code = LE_EXPR;\n-\t\t      break;\n-\t\t    case 4:\n-\t\t      code = GT_EXPR;\n-\t\t      break;\n-\t\t    case 5:\n-\t\t      code = NE_EXPR;\n-\t\t      break;\n-\t\t    case 6:\n-\t\t      code = GE_EXPR;\n-\t\t      break;\n-\t\t    case 7:\n-\t\t      /* Always true.  */\n-\t\t      return omit_one_operand (type, integer_one_node, arg0);\n-\t\t    }\n-\n-\t\t  if (save_p)\n-\t\t    return save_expr (build2 (code, type, cval1, cval2));\n-\t\t  else\n-\t\t    return fold_build2 (code, type, cval1, cval2);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If this is a comparison of a field, we may be able to simplify it.  */\n-      if (((TREE_CODE (arg0) == COMPONENT_REF\n-\t    && lang_hooks.can_use_bit_fields_p ())\n-\t   || TREE_CODE (arg0) == BIT_FIELD_REF)\n-\t  && (code == EQ_EXPR || code == NE_EXPR)\n-\t  /* Handle the constant case even without -O\n-\t     to make sure the warnings are given.  */\n-\t  && (optimize || TREE_CODE (arg1) == INTEGER_CST))\n-\t{\n-\t  t1 = optimize_bit_field_compare (code, type, arg0, arg1);\n-\t  if (t1)\n-\t    return t1;\n-\t}\n-\n-      /* Fold a comparison of the address of COMPONENT_REFs with the same\n-         type and component to a comparison of the address of the base\n-\t object.  In short, &x->a OP &y->a to x OP y and\n-         &x->a OP &y.a to x OP &y  */\n-      if (TREE_CODE (arg0) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == COMPONENT_REF\n-\t  && TREE_CODE (arg1) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg1, 0)) == COMPONENT_REF)\n-        {\n-\t  tree cref0 = TREE_OPERAND (arg0, 0);\n-\t  tree cref1 = TREE_OPERAND (arg1, 0);\n-\t  if (TREE_OPERAND (cref0, 1) == TREE_OPERAND (cref1, 1))\n-\t    {\n-\t      tree op0 = TREE_OPERAND (cref0, 0);\n-\t      tree op1 = TREE_OPERAND (cref1, 0);\n-\t      return fold_build2 (code, type,\n-\t\t\t          build_fold_addr_expr (op0),\n-\t\t\t\t  build_fold_addr_expr (op1));\n-\t    }\n-\t}\n-\n-      /* Optimize comparisons of strlen vs zero to a compare of the\n-\t first character of the string vs zero.  To wit,\n-\t\tstrlen(ptr) == 0   =>  *ptr == 0\n-\t\tstrlen(ptr) != 0   =>  *ptr != 0\n-\t Other cases should reduce to one of these two (or a constant)\n-\t due to the return value of strlen being unsigned.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && integer_zerop (arg1)\n-\t  && TREE_CODE (arg0) == CALL_EXPR)\n-\t{\n-\t  tree fndecl = get_callee_fndecl (arg0);\n-\t  tree arglist;\n-\n-\t  if (fndecl\n-\t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STRLEN\n-\t      && (arglist = TREE_OPERAND (arg0, 1))\n-\t      && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE\n-\t      && ! TREE_CHAIN (arglist))\n-\t    {\n-\t      tree iref = build_fold_indirect_ref (TREE_VALUE (arglist));\n-\t      return fold_build2 (code, type, iref,\n-\t\t\t\t  build_int_cst (TREE_TYPE (iref), 0));\n-\t    }\n-\t}\n-\n-      /* We can fold X/C1 op C2 where C1 and C2 are integer constants\n-\t into a single range test.  */\n-      if ((TREE_CODE (arg0) == TRUNC_DIV_EXPR\n-\t   || TREE_CODE (arg0) == EXACT_DIV_EXPR)\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && !integer_zerop (TREE_OPERAND (arg0, 1))\n-\t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t  && !TREE_OVERFLOW (arg1))\n-\t{\n-\t  t1 = fold_div_compare (code, type, arg0, arg1);\n-\t  if (t1 != NULL_TREE)\n-\t    return t1;\n-\t}\n-\n-      /* Fold (X >> C) != 0 into X < 0 if C is one less than the width\n-\t of X.  Similarly fold (X >> C) == 0 into X >= 0.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && integer_zerop (arg1)\n-\t  && TREE_CODE (arg0) == RSHIFT_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tree arg00 = TREE_OPERAND (arg0, 0);\n-\t  tree arg01 = TREE_OPERAND (arg0, 1);\n-\t  tree itype = TREE_TYPE (arg00);\n-\t  if (TREE_INT_CST_HIGH (arg01) == 0\n-\t      && TREE_INT_CST_LOW (arg01)\n-\t\t == (unsigned HOST_WIDE_INT) (TYPE_PRECISION (itype) - 1))\n-\t    {\n-\t      if (TYPE_UNSIGNED (itype))\n-\t\t{\n-\t\t  itype = lang_hooks.types.signed_type (itype);\n-\t\t  arg00 = fold_convert (itype, arg00);\n-\t\t}\n-\t      return fold_build2 (code == EQ_EXPR ? GE_EXPR : LT_EXPR,\n-\t\t\t\t  type, arg00, build_int_cst (itype, 0));\n-\t    }\n-\t}\n-\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && integer_zerop (arg1)\n-\t  && tree_expr_nonzero_p (arg0))\n-        {\n-\t  tree res = constant_boolean_node (code==NE_EXPR, type);\n-\t  return omit_one_operand (type, res, arg0);\n-\t}\n-\n-      t1 = fold_relational_const (code, type, arg0, arg1);\n-      return t1 == NULL_TREE ? NULL_TREE : t1;\n+      return NULL_TREE;\n \n     case UNORDERED_EXPR:\n     case ORDERED_EXPR:"}]}