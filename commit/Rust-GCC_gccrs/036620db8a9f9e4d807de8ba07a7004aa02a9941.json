{"sha": "036620db8a9f9e4d807de8ba07a7004aa02a9941", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM2NjIwZGI4YTlmOWU0ZDgwN2RlOGJhMDdhNzAwNGFhMDJhOTk0MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-12T13:28:18Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-12T13:28:18Z"}, "message": "Make more use of END_REGNO\n\nAn upcoming patch will convert hard_regno_nregs into an inline\nfunction, which in turn allows hard_regno_nregs to be used as the\nname of a targetm field.  This patch rewrites uses that are more\neasily (and efficiently) written as END_REGNO.\n\n2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/frv/frv.c (FOR_EACH_REGNO): Use END_REGNO instead of\n\thard_regno_nregs.\n\t* config/v850/v850.c (v850_reorg): Likewise.\n\t* reload.c (refers_to_regno_for_reload_p): Likewise.\n\t(find_equiv_reg): Likewise.\n\t* reload1.c (reload_reg_reaches_end_p): Likewise.\n\nFrom-SVN: r252011", "tree": {"sha": "302e64c7ba17ddd26f1d65d47517500f88a16d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/302e64c7ba17ddd26f1d65d47517500f88a16d27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/036620db8a9f9e4d807de8ba07a7004aa02a9941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036620db8a9f9e4d807de8ba07a7004aa02a9941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036620db8a9f9e4d807de8ba07a7004aa02a9941", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036620db8a9f9e4d807de8ba07a7004aa02a9941/comments", "author": null, "committer": null, "parents": [{"sha": "462a99aa98416135d2675d07d32f7ce234287983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/462a99aa98416135d2675d07d32f7ce234287983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/462a99aa98416135d2675d07d32f7ce234287983"}], "stats": {"total": 66, "additions": 27, "deletions": 39}, "files": [{"sha": "1b398c8983f335b7df84bbc355e090cd69f2f8fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=036620db8a9f9e4d807de8ba07a7004aa02a9941", "patch": "@@ -1,3 +1,12 @@\n+2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/frv/frv.c (FOR_EACH_REGNO): Use END_REGNO instead of\n+\thard_regno_nregs.\n+\t* config/v850/v850.c (v850_reorg): Likewise.\n+\t* reload.c (refers_to_regno_for_reload_p): Likewise.\n+\t(find_equiv_reg): Likewise.\n+\t* reload1.c (reload_reg_reaches_end_p): Likewise.\n+\n 2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* caller-save.c (add_used_regs): Use REG_NREGS instead of"}, {"sha": "add19e5cb14e5fd750e9d864b4bcff73329ed351", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=036620db8a9f9e4d807de8ba07a7004aa02a9941", "patch": "@@ -135,9 +135,7 @@ struct frv_io {\n \n /* Loop with REG set to each hard register in rtx X.  */\n #define FOR_EACH_REGNO(REG, X)\t\t\t\t\t\t\\\n-  for (REG = REGNO (X);\t\t\t\t\t\t\t\\\n-       REG < REGNO (X) + HARD_REGNO_NREGS (REGNO (X), GET_MODE (X));\t\\\n-       REG++)\n+  for (REG = REGNO (X); REG < END_REGNO (X); REG++)\n \n /* This structure contains machine specific function data.  */\n struct GTY(()) machine_function"}, {"sha": "32c6a036eb37f410cafb2ebe68d60daa14b99692", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=036620db8a9f9e4d807de8ba07a7004aa02a9941", "patch": "@@ -1376,12 +1376,11 @@ v850_reorg (void)\n \t\t for the register */\n \t      if (GET_CODE (dest) == REG)\n \t\t{\n-\t\t  machine_mode mode = GET_MODE (dest);\n \t\t  int regno;\n \t\t  int endregno;\n \n \t\t  regno = REGNO (dest);\n-\t\t  endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+\t\t  endregno = END_REGNO (dest);\n \n \t\t  if (!use_ep)\n \t\t    {"}, {"sha": "21efdcbcaaf429471b2060173c0687296a1e7657", "filename": "gcc/reload.c", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=036620db8a9f9e4d807de8ba07a7004aa02a9941", "patch": "@@ -6439,10 +6439,7 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n \t  return 0;\n \t}\n \n-      return (endregno > r\n-\t      && regno < r + (r < FIRST_PSEUDO_REGISTER\n-\t\t\t      ? hard_regno_nregs[r][GET_MODE (x)]\n-\t\t\t      : 1));\n+      return endregno > r && regno < END_REGNO (x);\n \n     case SUBREG:\n       /* If this is a SUBREG of a hard reg, we can see exactly which\n@@ -6889,15 +6886,11 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n     {\n       int i;\n       for (i = 0; i < n_reloads; i++)\n-\tif (rld[i].reg_rtx != 0 && rld[i].in)\n-\t  {\n-\t    int regno1 = REGNO (rld[i].reg_rtx);\n-\t    int nregs1 = hard_regno_nregs[regno1]\n-\t\t\t\t\t [GET_MODE (rld[i].reg_rtx)];\n-\t    if (regno1 < valueno + valuenregs\n-\t\t&& regno1 + nregs1 > valueno)\n-\t      return 0;\n-\t  }\n+\tif (rld[i].reg_rtx != 0\n+\t    && rld[i].in\n+\t    && (int) REGNO (rld[i].reg_rtx) < valueno + valuenregs\n+\t    && (int) END_REGNO (rld[i].reg_rtx) > valueno)\n+\t  return 0;\n     }\n \n   if (goal_mem)\n@@ -6963,15 +6956,11 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t      if (REG_P (dest))\n \t\t{\n \t\t  int xregno = REGNO (dest);\n-\t\t  int xnregs;\n-\t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n-\t\t    xnregs = hard_regno_nregs[xregno][GET_MODE (dest)];\n-\t\t  else\n-\t\t    xnregs = 1;\n-\t\t  if (xregno < regno + nregs && xregno + xnregs > regno)\n+\t\t  int end_xregno = END_REGNO (dest);\n+\t\t  if (xregno < regno + nregs && end_xregno > regno)\n \t\t    return 0;\n \t\t  if (xregno < valueno + valuenregs\n-\t\t      && xregno + xnregs > valueno)\n+\t\t      && end_xregno > valueno)\n \t\t    return 0;\n \t\t  if (goal_mem_addr_varies\n \t\t      && reg_overlap_mentioned_for_reload_p (dest, goal))\n@@ -7006,16 +6995,12 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t\t      if (REG_P (dest))\n \t\t\t{\n \t\t\t  int xregno = REGNO (dest);\n-\t\t\t  int xnregs;\n-\t\t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n-\t\t\t    xnregs = hard_regno_nregs[xregno][GET_MODE (dest)];\n-\t\t\t  else\n-\t\t\t    xnregs = 1;\n+\t\t\t  int end_xregno = END_REGNO (dest);\n \t\t\t  if (xregno < regno + nregs\n-\t\t\t      && xregno + xnregs > regno)\n+\t\t\t      && end_xregno > regno)\n \t\t\t    return 0;\n \t\t\t  if (xregno < valueno + valuenregs\n-\t\t\t      && xregno + xnregs > valueno)\n+\t\t\t      && end_xregno > valueno)\n \t\t\t    return 0;\n \t\t\t  if (goal_mem_addr_varies\n \t\t\t      && reg_overlap_mentioned_for_reload_p (dest,\n@@ -7052,14 +7037,13 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t\t      if (REG_P (dest))\n \t\t\t{\n \t\t\t  int xregno = REGNO (dest);\n-\t\t\t  int xnregs\n-\t\t\t    = hard_regno_nregs[xregno][GET_MODE (dest)];\n+\t\t\t  int end_xregno = END_REGNO (dest);\n \n \t\t\t  if (xregno < regno + nregs\n-\t\t\t      && xregno + xnregs > regno)\n+\t\t\t      && end_xregno > regno)\n \t\t\t    return 0;\n \t\t\t  else if (xregno < valueno + valuenregs\n-\t\t\t\t   && xregno + xnregs > valueno)\n+\t\t\t\t   && end_xregno > valueno)\n \t\t\t    return 0;\n \t\t\t  else if (goal_mem_addr_varies\n \t\t\t\t   && reg_overlap_mentioned_for_reload_p (dest,"}, {"sha": "4f39e0e91b00fcddfd872f770955e9d52e817e54", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036620db8a9f9e4d807de8ba07a7004aa02a9941/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=036620db8a9f9e4d807de8ba07a7004aa02a9941", "patch": "@@ -5349,15 +5349,13 @@ reload_reg_reaches_end_p (unsigned int regno, int reloadnum)\n   for (i = reloadnum + 1; i < n_reloads; i++)\n     {\n       rtx reg;\n-      int nregs;\n \n       if (rld[i].opnum != opnum || rld[i].when_needed != type)\n \tcontinue;\n       reg = rld[i].reg_rtx;\n       if (reg == NULL_RTX)\n \tcontinue;\n-      nregs = hard_regno_nregs[REGNO (reg)][GET_MODE (reg)];\n-      if (regno >= REGNO (reg) && regno < REGNO (reg) + nregs)\n+      if (regno >= REGNO (reg) && regno < END_REGNO (reg))\n \treturn 0;\n     }\n   "}]}