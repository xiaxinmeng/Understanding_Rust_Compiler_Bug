{"sha": "095bb2765d287159e814896bb20b6ffffba6db0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk1YmIyNzY1ZDI4NzE1OWU4MTQ4OTZiYjIwYjZmZmZmYmE2ZGIwZA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cambridge.redhat.com", "date": "2001-08-14T20:49:22Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2001-08-14T20:49:22Z"}, "message": "Handle nested functions which take variable arguments\n\nFrom-SVN: r44898", "tree": {"sha": "51c296ef491d8115ac7aa71852ad9ad7f41b31ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51c296ef491d8115ac7aa71852ad9ad7f41b31ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/095bb2765d287159e814896bb20b6ffffba6db0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095bb2765d287159e814896bb20b6ffffba6db0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095bb2765d287159e814896bb20b6ffffba6db0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095bb2765d287159e814896bb20b6ffffba6db0d/comments", "author": null, "committer": null, "parents": [{"sha": "98999d8b4917bf744d958f0b1315a5d705620b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98999d8b4917bf744d958f0b1315a5d705620b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98999d8b4917bf744d958f0b1315a5d705620b2f"}], "stats": {"total": 285, "additions": 218, "deletions": 67}, "files": [{"sha": "2854206e62335295e775536b83b0805d397955ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=095bb2765d287159e814896bb20b6ffffba6db0d", "patch": "@@ -1,3 +1,15 @@\n+2001-08-14  Nick Clifton  <nickc@cambridge.redhat.com>\n+\n+\t* config/arm/arm.c (arm_compute_initial_elimination_offset): New\n+\tfunction.\n+\t(arm_expand_prologue): Handled nested functions which take a\n+\tvariable argument list.\n+\t* config/arm/arm.h (ARM_INITIAL_ELIMINATION_OFFSET): Replace\n+\tmacro with an invocation of\n+\tarm_compute_initial_elimination_offset.\n+\t* config/arm/arm-protos.h: Prototype\n+\tarm_compute_initial_elimination_offset. \n+\n 2001-08-14  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* doc/install.texi (Specific, avr): Fix markup."}, {"sha": "1a603f263138d58b36ef1089b064f045ebd71955", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=095bb2765d287159e814896bb20b6ffffba6db0d", "patch": "@@ -34,6 +34,7 @@ extern void   arm_expand_prologue\tPARAMS ((void));\n extern void   assemble_align\t\tPARAMS ((int)); \n extern const char * arm_strip_name_encoding\tPARAMS ((const char *));\n extern unsigned long arm_current_func_type\tPARAMS ((void));\n+extern unsigned int  arm_compute_initial_elimination_offset PARAMS ((unsigned int, unsigned int));\n \n #ifdef TREE_CODE\n extern int    arm_return_in_memory\tPARAMS ((tree));"}, {"sha": "7f89a3d61ff3c0a67d78e5f7251c42a3d6678fb8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 201, "deletions": 17, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=095bb2765d287159e814896bb20b6ffffba6db0d", "patch": "@@ -7875,6 +7875,170 @@ emit_sfm (base_reg, count)\n   return par;\n }\n \n+/* Compute the distance from register FROM to register TO.\n+   These can be the arg pointer (26), the soft frame pointer (25),\n+   the stack pointer (13) or the hard frame pointer (11).\n+   Typical stack layout looks like this:\n+\n+       old stack pointer -> |    |\n+                             ----\n+                            |    | \\\n+                            |    |   saved arguments for\n+                            |    |   vararg functions\n+\t\t\t    |    | /\n+                              --\n+   hard FP & arg pointer -> |    | \\\n+                            |    |   stack\n+                            |    |   frame\n+                            |    | /\n+                              --\n+                            |    | \\\n+                            |    |   call saved\n+                            |    |   registers\n+      soft frame pointer -> |    | /\n+                              --\n+                            |    | \\\n+                            |    |   local\n+                            |    |   variables\n+                            |    | /\n+                              --\n+                            |    | \\\n+                            |    |   outgoing\n+                            |    |   arguments\n+   current stack pointer -> |    | /\n+                              --\n+\n+  For a given funciton some or all of these stack compomnents\n+  may not be needed, giving rise to the possibility of\n+  eliminating some of the registers.\n+\n+  The values returned by this function must reflect the behaviour\n+  of arm_expand_prologue() and arm_compute_save_reg_mask().\n+\n+  The sign of the number returned reflects the direction of stack\n+  growth, so the values are positive for all eliminations except\n+  from the soft frame pointer to the hard frame pointer.  */\n+\t\t\t    \n+unsigned int\n+arm_compute_initial_elimination_offset (from, to)\n+     unsigned int from;\n+     unsigned int to;\n+{\n+  unsigned int local_vars    = (get_frame_size () + 3) & ~3;\n+  unsigned int outgoing_args = current_function_outgoing_args_size;\n+  unsigned int stack_frame;\n+  unsigned int call_saved_registers;\n+  unsigned long func_type;\n+  \n+  func_type = arm_current_func_type ();\n+\n+  /* Volatile functions never return, so there is\n+     no need to save call saved registers.  */\n+  call_saved_registers = 0;\n+  if (! IS_VOLATILE (func_type))\n+    {\n+      unsigned int reg;\n+\n+      for (reg = 0; reg <= 10; reg ++)\n+\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t  call_saved_registers += 4;\n+\n+      if (! TARGET_APCS_FRAME\n+\t  && ! frame_pointer_needed\n+\t  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n+\t  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+\tcall_saved_registers += 4;\n+\n+      if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+\tcall_saved_registers += 4;\n+\n+      if (regs_ever_live[LR_REGNUM]\n+\t  /* If a stack frame is going to be created, the LR will\n+\t     be saved as part of that, so we do not need to allow\n+\t     for it here.  */\n+\t  && ! frame_pointer_needed)\n+\tcall_saved_registers += 4;\n+    }\n+\n+  /* The stack frame contains 4 registers - the old frame pointer,\n+     the old stack pointer, the return address and PC of the start\n+     of the function.  */\n+  stack_frame = frame_pointer_needed ? 16 : 0;\n+\n+  /* FIXME: we should allow for saved floating point registers.  */\n+\n+  /* OK, now we have enough information to compute the distances.\n+     There must be an entry in these switch tables for each pair\n+     of registers in ELIMINABLE_REGS, even if some of the entries\n+     seem to be redundant or useless.  */\n+  switch (from)\n+    {\n+    case ARG_POINTER_REGNUM:\n+      switch (to)\n+\t{\n+\tcase THUMB_HARD_FRAME_POINTER_REGNUM:\n+\t  return 0;\n+\n+\tcase FRAME_POINTER_REGNUM:\n+\t  /* This is the reverse of the soft frame pointer\n+\t     to hard frame pointer elimination below.  */\n+\t  if (call_saved_registers == 0 && stack_frame == 0)\n+\t    return 0;\n+\t  return (call_saved_registers + stack_frame - 4);\n+\n+\tcase ARM_HARD_FRAME_POINTER_REGNUM:\n+\t  /* If there is no stack frame then the hard\n+\t     frame pointer and the arg pointer coincide.  */\n+\t  if (stack_frame == 0 && call_saved_registers != 0)\n+\t    return 0;\n+\t  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */\n+\t  return (frame_pointer_needed\n+\t\t  && current_function_needs_context\n+\t\t  && ! current_function_anonymous_args) ? 4 : 0;\n+\n+\tcase STACK_POINTER_REGNUM:\n+\t  /* If nothing has been pushed on the stack at all\n+\t     then this will return -4.  This *is* correct!  */\n+\t  return call_saved_registers + stack_frame + local_vars + outgoing_args - 4;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case FRAME_POINTER_REGNUM:\n+      switch (to)\n+\t{\n+\tcase THUMB_HARD_FRAME_POINTER_REGNUM:\n+\t  return 0;\n+\n+\tcase ARM_HARD_FRAME_POINTER_REGNUM:\n+\t  /* The hard frame pointer points to the top entry in the\n+\t     stack frame.  The soft frame pointer to the bottom entry\n+\t     in the stack frame.  If there is no stack frame at all,\n+\t     then they are identical.  */\n+\t  if (call_saved_registers == 0 && stack_frame == 0)\n+\t    return 0;\n+\t  return - (call_saved_registers + stack_frame - 4);\n+\n+\tcase STACK_POINTER_REGNUM:\n+\t  return local_vars + outgoing_args;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    default:\n+      /* You cannot eliminate from the stack pointer.\n+\t In theory you could eliminate from the hard frame\n+\t pointer to the stack pointer, but this will never\n+\t happen, since if a stack frame is not needed the\n+\t hard frame pointer will never be used.  */\n+      abort ();\n+    }\n+}\n+\n /* Generate the prologue instructions for entry into an ARM function.  */\n \n void\n@@ -7887,13 +8051,18 @@ arm_expand_prologue ()\n   unsigned long live_regs_mask;\n   unsigned long func_type;\n   int fp_offset = 0;\n+  int saved_pretend_args = 0;\n+  unsigned int args_to_push;\n \n   func_type = arm_current_func_type ();\n \n   /* Naked functions don't have prologues.  */\n   if (IS_NAKED (func_type))\n     return;\n \n+  /* Make a copy of c_f_p_a_s as we may need to modify it locally.  */\n+  args_to_push = current_function_pretend_args_size;\n+  \n   /* Compute which register we will have to save onto the stack.  */\n   live_regs_mask = arm_compute_save_reg_mask ();\n \n@@ -7920,8 +8089,8 @@ arm_expand_prologue ()\n \t       1. The last argument register.\n \t       2. A slot on the stack above the frame.  (This only\n \t          works if the function is not a varargs function).\n-\t\t  \n-\t     If neither of these places is available, we abort (for now).\n+\t       3. Register r3, after pushing the argument registers\n+\t          onto the stack.\n \n \t     Note - we only need to tell the dwarf2 backend about the SP\n \t     adjustment in the second variant; the static chain register\n@@ -7934,7 +8103,7 @@ arm_expand_prologue ()\n \t      insn = gen_rtx_SET (SImode, insn, ip_rtx);\n \t      insn = emit_insn (insn);\n \t    }\n-\t  else if (current_function_pretend_args_size == 0)\n+\t  else if (args_to_push == 0)\n \t    {\n \t      rtx dwarf;\n \t      insn = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);\n@@ -7953,13 +8122,27 @@ arm_expand_prologue ()\n \t\t\t\t\t\t    dwarf, REG_NOTES (insn));\n \t    }\n \t  else\n-\t    /* FIXME - the way to handle this situation is to allow\n-\t       the pretend args to be dumped onto the stack, then\n-\t       reuse r3 to save IP.  This would involve moving the\n-\t       copying of SP into IP until after the pretend args\n-\t       have been dumped, but this is not too hard.  */\n-\t    /* [See e.g. gcc.c-torture/execute/nest-stdar-1.c.]  */\n-\t    error (\"Unable to find a temporary location for static chain register\");\n+\t    {\n+\t      /* Store the args on the stack.  */\n+\t      if (current_function_anonymous_args)\n+\t\tinsn = emit_multi_reg_push\n+\t\t  ((0xf0 >> (args_to_push / 4)) & 0xf);\n+\t      else\n+\t\tinsn = emit_insn\n+\t\t  (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, \n+\t\t\t       GEN_INT (- args_to_push)));\n+\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t      saved_pretend_args = 1;\n+\t      fp_offset = args_to_push;\n+\t      args_to_push = 0;\n+\n+\t      /* Now reuse r3 to preserve IP.  */\n+\t      insn = gen_rtx_REG (SImode, 3);\n+\t      insn = gen_rtx_SET (SImode, insn, ip_rtx);\n+\t      (void) emit_insn (insn);\n+\t    }\n \t}\n \n       if (fp_offset)\n@@ -7974,16 +8157,16 @@ arm_expand_prologue ()\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  if (current_function_pretend_args_size)\n+  if (args_to_push)\n     {\n       /* Push the argument registers, or reserve space for them.  */\n       if (current_function_anonymous_args)\n \tinsn = emit_multi_reg_push\n-\t  ((0xf0 >> (current_function_pretend_args_size / 4)) & 0xf);\n+\t  ((0xf0 >> (args_to_push / 4)) & 0xf);\n       else\n \tinsn = emit_insn\n \t  (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, \n-\t\t       GEN_INT (-current_function_pretend_args_size)));\n+\t\t       GEN_INT (- args_to_push)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -8045,25 +8228,26 @@ arm_expand_prologue ()\n   if (frame_pointer_needed)\n     {\n       /* Create the new frame pointer.  */\n-      insn = GEN_INT (-(4 + current_function_pretend_args_size + fp_offset));\n+      insn = GEN_INT (-(4 + args_to_push + fp_offset));\n       insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       \n       if (IS_NESTED (func_type))\n \t{\n \t  /* Recover the static chain register.  */\n-\t  if (regs_ever_live [3] == 0)\n+\t  if (regs_ever_live [3] == 0\n+\t      || saved_pretend_args)\n \t    {\n \t      insn = gen_rtx_REG (SImode, 3);\n \t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n-\t      insn = emit_insn (insn);\n+\t      (void) emit_insn (insn);\n \t    }\n \t  else /* if (current_function_pretend_args_size == 0) */\n \t    {\n \t      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx, GEN_INT (4));\n \t      insn = gen_rtx_MEM (SImode, insn);\n \t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n-\t      insn = emit_insn (insn);\n+\t      (void) emit_insn (insn);\n \t    }\n \t}\n     }"}, {"sha": "28f49eacbc45397cc03fb7d60f6183aaa7c175cf", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 50, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095bb2765d287159e814896bb20b6ffffba6db0d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=095bb2765d287159e814896bb20b6ffffba6db0d", "patch": "@@ -1639,57 +1639,11 @@ typedef struct\n /* Define the offset between two registers, one to be eliminated, and the\n    other its replacement, at the start of a routine.  */\n #define ARM_INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int volatile_func = IS_VOLATILE (arm_current_func_type ());\t\t\\\n-  if ((FROM) == ARG_POINTER_REGNUM && (TO) == HARD_FRAME_POINTER_REGNUM)\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! current_function_needs_context || ! frame_pointer_needed)\t\\\n-        (OFFSET) = 0;\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        (OFFSET) = 4;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((FROM) == FRAME_POINTER_REGNUM\t\t\t\t\\\n-\t   && (TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n-    (OFFSET) = current_function_outgoing_args_size\t\t\t\\\n-\t\t+ ROUND_UP (get_frame_size ());\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\t\\\n-      int offset = 12;\t\t\t\t\t\t\t\\\n-      int saved_hard_reg = 0;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (! volatile_func)\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          for (regno = 0; regno <= 10; regno++)\t\t\t\t\\\n-\t    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-\t      saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n-\t  if (! TARGET_APCS_FRAME\t\t\t\t\t\\\n-\t      && ! frame_pointer_needed\t\t\t\t\t\\\n-\t      && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\t\t\\\n-\t      && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\t\t\\\n-\t    saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n-\t  /* PIC register is a fixed reg, so call_used_regs set.  */\t\\\n-\t  if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\t\\\n-\t    saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n-          for (regno = FIRST_ARM_FP_REGNUM;\t\t\t\t\\\n-\t       regno <= LAST_ARM_FP_REGNUM; regno++)\t\t\t\\\n-\t    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-\t      offset += 12;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\\\n-\t(OFFSET) = - offset;\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t   if (! frame_pointer_needed)\t\t\t\t\t\\\n-\t     offset -= 16;\t\t\t\t\t\t\\\n-\t   if (! volatile_func\t\t\t\t\t\t\\\n-\t       && (regs_ever_live[LR_REGNUM] /*|| saved_hard_reg */))\t\\\n-\t     offset += 4;\t\t\t\t\t\t\\\n-\t   offset += current_function_outgoing_args_size;\t\t\\\n-\t   (OFFSET) = ROUND_UP (get_frame_size ()) + offset;\t\t\\\n-         }\t\t\t\t\t\t\t\t\\\n+      (OFFSET) = arm_compute_initial_elimination_offset (FROM, TO);\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-}\n+  while (0)\n \n /* Note:  This macro must match the code in thumb_function_prologue().  */\n #define THUMB_INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\\\n@@ -1727,7 +1681,7 @@ typedef struct\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n   if (TARGET_ARM)\t\t\t\t\t\t\t\\\n-    ARM_INITIAL_ELIMINATION_OFFSET (FROM, TO, OFFSET)\t\t\t\\\n+    ARM_INITIAL_ELIMINATION_OFFSET (FROM, TO, OFFSET);\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     THUMB_INITIAL_ELIMINATION_OFFSET (FROM, TO, OFFSET)\n      "}]}