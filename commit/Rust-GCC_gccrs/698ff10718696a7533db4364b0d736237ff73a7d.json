{"sha": "698ff10718696a7533db4364b0d736237ff73a7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk4ZmYxMDcxODY5NmE3NTMzZGI0MzY0YjBkNzM2MjM3ZmY3M2E3ZA==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-06-11T10:04:33Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2014-06-11T10:04:33Z"}, "message": "re PR tree-optimization/61306 (wrong code at -Os and above on x86_64-linux-gnu)\n\n2014-06-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR tree-optimization/61306\n    * tree-ssa-math-opts.c (struct symbolic_number): Store type of\n    expression instead of its size.\n    (do_shift_rotate): Adapt to change in struct symbolic_number. Return\n    false to prevent optimization when the result is unpredictable due to\n    arithmetic right shift of signed type with highest byte is set.\n    (verify_symbolic_number_p): Adapt to change in struct symbolic_number.\n    (init_symbolic_number): Likewise.\n    (find_bswap_or_nop_1): Likewise. Return NULL to prevent optimization\n    when the result is unpredictable due to sign extension.\n\n    gcc/testsuite/\n    * gcc.c-torture/execute/pr61306-1.c: New test.\n    * gcc.c-torture/execute/pr61306-2.c: Likewise.\n    * gcc.c-torture/execute/pr61306-3.c: Likewise.\n\nFrom-SVN: r211444", "tree": {"sha": "e4a6086c454b66fc830408f29d3b4b15429e5b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4a6086c454b66fc830408f29d3b4b15429e5b21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/698ff10718696a7533db4364b0d736237ff73a7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/698ff10718696a7533db4364b0d736237ff73a7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/698ff10718696a7533db4364b0d736237ff73a7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/698ff10718696a7533db4364b0d736237ff73a7d/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d02d8b8cb41501b5904705dc764f7c8a8788f45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d02d8b8cb41501b5904705dc764f7c8a8788f45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d02d8b8cb41501b5904705dc764f7c8a8788f45"}], "stats": {"total": 177, "additions": 153, "deletions": 24}, "files": [{"sha": "7b0f74cf40b12d88a2a09bb92c689b31b8a61f85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=698ff10718696a7533db4364b0d736237ff73a7d", "patch": "@@ -1,3 +1,16 @@\n+2014-06-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/61306\n+\t* tree-ssa-math-opts.c (struct symbolic_number): Store type of\n+\texpression instead of its size.\n+\t(do_shift_rotate): Adapt to change in struct symbolic_number. Return\n+\tfalse to prevent optimization when the result is unpredictable due to\n+\tarithmetic right shift of signed type with highest byte is set.\n+\t(verify_symbolic_number_p): Adapt to change in struct symbolic_number.\n+\t(init_symbolic_number): Likewise.\n+\t(find_bswap_or_nop_1): Likewise. Return NULL to prevent optimization\n+\twhen the result is unpredictable due to sign extension.\n+\n 2014-06-11  Terry Guo  <terry.guo@arm.com>\n \n \t* config/arm/arm.md (*thumb1_adddi3): Move into new file thumb1.md."}, {"sha": "318fa1a825129331e10bff445287ca0fac0bc9d6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=698ff10718696a7533db4364b0d736237ff73a7d", "patch": "@@ -1,3 +1,9 @@\n+2014-06-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* gcc.c-torture/execute/pr61306-1.c: New test.\n+\t* gcc.c-torture/execute/pr61306-2.c: Likewise.\n+\t* gcc.c-torture/execute/pr61306-3.c: Likewise.\n+\n 2014-06-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/acle/acle.exp: New."}, {"sha": "ebc90a32f986750e566a5bdb64112f3b9432e5dd", "filename": "gcc/testsuite/gcc.c-torture/execute/pr61306-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-1.c?ref=698ff10718696a7533db4364b0d736237ff73a7d", "patch": "@@ -0,0 +1,39 @@\n+#ifdef __INT32_TYPE__\n+typedef __INT32_TYPE__ int32_t;\n+#else\n+typedef int int32_t;\n+#endif\n+\n+#ifdef __UINT32_TYPE__\n+typedef __UINT32_TYPE__ uint32_t;\n+#else\n+typedef unsigned uint32_t;\n+#endif\n+\n+#define __fake_const_swab32(x) ((uint32_t)(\t\t      \\\n+\t(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |    \\\n+\t(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |    \\\n+\t(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |    \\\n+\t(( (int32_t)(x) &  (int32_t)0xff000000UL) >> 24)))\n+\n+/* Previous version of bswap optimization failed to consider sign extension\n+   and as a result would replace an expression *not* doing a bswap by a\n+   bswap.  */\n+\n+__attribute__ ((noinline, noclone)) uint32_t\n+fake_bswap32 (uint32_t in)\n+{\n+  return __fake_const_swab32 (in);\n+}\n+\n+int\n+main(void)\n+{\n+  if (sizeof (int32_t) * __CHAR_BIT__ != 32)\n+    return 0;\n+  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)\n+    return 0;\n+  if (fake_bswap32 (0x87654321) != 0xffffff87)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "886ecfd29da0ce79adeff51d92d33e4fe27c4c6f", "filename": "gcc/testsuite/gcc.c-torture/execute/pr61306-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-2.c?ref=698ff10718696a7533db4364b0d736237ff73a7d", "patch": "@@ -0,0 +1,40 @@\n+#ifdef __INT16_TYPE__\n+typedef __INT16_TYPE__ int16_t;\n+#else\n+typedef short int16_t;\n+#endif\n+\n+#ifdef __UINT32_TYPE__\n+typedef __UINT32_TYPE__ uint32_t;\n+#else\n+typedef unsigned uint32_t;\n+#endif\n+\n+#define __fake_const_swab32(x) ((uint32_t)(\t\t\t      \\\n+\t(((uint32_t)         (x) & (uint32_t)0x000000ffUL) << 24) |   \\\n+\t(((uint32_t)(int16_t)(x) & (uint32_t)0x00ffff00UL) <<  8) |   \\\n+\t(((uint32_t)         (x) & (uint32_t)0x00ff0000UL) >>  8) |   \\\n+\t(((uint32_t)         (x) & (uint32_t)0xff000000UL) >> 24)))\n+\n+\n+/* Previous version of bswap optimization failed to consider sign extension\n+   and as a result would replace an expression *not* doing a bswap by a\n+   bswap.  */\n+\n+__attribute__ ((noinline, noclone)) uint32_t\n+fake_bswap32 (uint32_t in)\n+{\n+  return __fake_const_swab32 (in);\n+}\n+\n+int\n+main(void)\n+{\n+  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)\n+    return 0;\n+  if (sizeof (int16_t) * __CHAR_BIT__ != 16)\n+    return 0;\n+  if (fake_bswap32 (0x81828384) != 0xff838281)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "6086e278627cc8158ef14131613f4a8c19ecfbfd", "filename": "gcc/testsuite/gcc.c-torture/execute/pr61306-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr61306-3.c?ref=698ff10718696a7533db4364b0d736237ff73a7d", "patch": "@@ -0,0 +1,13 @@\n+short a = -1;\n+int b;\n+char c;\n+\n+int\n+main ()\n+{\n+  c = a;\n+  b = a | c;\n+  if (b != -1)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "c868e92636668affe369eec2105d3b89412a185f", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698ff10718696a7533db4364b0d736237ff73a7d/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=698ff10718696a7533db4364b0d736237ff73a7d", "patch": "@@ -1622,7 +1622,7 @@ make_pass_cse_sincos (gcc::context *ctxt)\n \n struct symbolic_number {\n   uint64_t n;\n-  int size;\n+  tree type;\n   tree base_addr;\n   tree offset;\n   HOST_WIDE_INT bytepos;\n@@ -1652,34 +1652,39 @@ do_shift_rotate (enum tree_code code,\n \t\t struct symbolic_number *n,\n \t\t int count)\n {\n+  int bitsize = TYPE_PRECISION (n->type);\n+\n   if (count % 8 != 0)\n     return false;\n \n   /* Zero out the extra bits of N in order to avoid them being shifted\n      into the significant bits.  */\n-  if (n->size < (int)sizeof (int64_t))\n-    n->n &= ((uint64_t)1 << (n->size * BITS_PER_UNIT)) - 1;\n+  if (bitsize < 8 * (int)sizeof (int64_t))\n+    n->n &= ((uint64_t)1 << bitsize) - 1;\n \n   switch (code)\n     {\n     case LSHIFT_EXPR:\n       n->n <<= count;\n       break;\n     case RSHIFT_EXPR:\n+      /* Arithmetic shift of signed type: result is dependent on the value.  */\n+      if (!TYPE_UNSIGNED (n->type) && (n->n & (0xff << (bitsize - 8))))\n+\treturn false;\n       n->n >>= count;\n       break;\n     case LROTATE_EXPR:\n-      n->n = (n->n << count) | (n->n >> ((n->size * BITS_PER_UNIT) - count));\n+      n->n = (n->n << count) | (n->n >> (bitsize - count));\n       break;\n     case RROTATE_EXPR:\n-      n->n = (n->n >> count) | (n->n << ((n->size * BITS_PER_UNIT) - count));\n+      n->n = (n->n >> count) | (n->n << (bitsize - count));\n       break;\n     default:\n       return false;\n     }\n   /* Zero unused bits for size.  */\n-  if (n->size < (int)sizeof (int64_t))\n-    n->n &= ((uint64_t)1 << (n->size * BITS_PER_UNIT)) - 1;\n+  if (bitsize < 8 * (int)sizeof (int64_t))\n+    n->n &= ((uint64_t)1 << bitsize) - 1;\n   return true;\n }\n \n@@ -1696,7 +1701,7 @@ verify_symbolic_number_p (struct symbolic_number *n, gimple stmt)\n   if (TREE_CODE (lhs_type) != INTEGER_TYPE)\n     return false;\n \n-  if (TYPE_PRECISION (lhs_type) != n->size * BITS_PER_UNIT)\n+  if (TYPE_PRECISION (lhs_type) != TYPE_PRECISION (n->type))\n     return false;\n \n   return true;\n@@ -1708,20 +1713,23 @@ verify_symbolic_number_p (struct symbolic_number *n, gimple stmt)\n static bool\n init_symbolic_number (struct symbolic_number *n, tree src)\n {\n+  int size;\n+\n   n->base_addr = n->offset = n->alias_set = n->vuse = NULL_TREE;\n \n   /* Set up the symbolic number N by setting each byte to a value between 1 and\n      the byte size of rhs1.  The highest order byte is set to n->size and the\n      lowest order byte to 1.  */\n-  n->size = TYPE_PRECISION (TREE_TYPE (src));\n-  if (n->size % BITS_PER_UNIT != 0)\n+  n->type = TREE_TYPE (src);\n+  size = TYPE_PRECISION (n->type);\n+  if (size % BITS_PER_UNIT != 0)\n     return false;\n-  n->size /= BITS_PER_UNIT;\n-  n->range = n->size;\n+  size /= BITS_PER_UNIT;\n+  n->range = size;\n   n->n = CMPNOP;\n \n-  if (n->size < (int)sizeof (int64_t))\n-    n->n &= ((uint64_t)1 << (n->size * BITS_PER_UNIT)) - 1;\n+  if (size < (int)sizeof (int64_t))\n+    n->n &= ((uint64_t)1 << (size * BITS_PER_UNIT)) - 1;\n \n   return true;\n }\n@@ -1858,12 +1866,12 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t{\n \tcase BIT_AND_EXPR:\n \t  {\n-\t    int i;\n+\t    int i, size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n \t    uint64_t val = int_cst_value (rhs2);\n \t    uint64_t tmp = val;\n \n \t    /* Only constants masking full bytes are allowed.  */\n-\t    for (i = 0; i < n->size; i++, tmp >>= BITS_PER_UNIT)\n+\t    for (i = 0; i < size; i++, tmp >>= BITS_PER_UNIT)\n \t      if ((tmp & 0xff) != 0 && (tmp & 0xff) != 0xff)\n \t\treturn NULL_TREE;\n \n@@ -1879,21 +1887,30 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  break;\n \tCASE_CONVERT:\n \t  {\n-\t    int type_size;\n+\t    int type_size, old_type_size;\n+\t    tree type;\n \n-\t    type_size = TYPE_PRECISION (gimple_expr_type (stmt));\n+\t    type = gimple_expr_type (stmt);\n+\t    type_size = TYPE_PRECISION (type);\n \t    if (type_size % BITS_PER_UNIT != 0)\n \t      return NULL_TREE;\n \n+\t    /* Sign extension: result is dependent on the value.  */\n+\t    old_type_size = TYPE_PRECISION (n->type);\n+\t    if (!TYPE_UNSIGNED (n->type)\n+\t\t&& type_size > old_type_size\n+\t\t&& n->n & (0xff << (old_type_size - 8)))\n+\t      return NULL_TREE;\n+\n \t    if (type_size / BITS_PER_UNIT < (int)(sizeof (int64_t)))\n \t      {\n \t\t/* If STMT casts to a smaller type mask out the bits not\n \t\t   belonging to the target type.  */\n \t\tn->n &= ((uint64_t)1 << type_size) - 1;\n \t      }\n-\t    n->size = type_size / BITS_PER_UNIT;\n+\t    n->type = type;\n \t    if (!n->base_addr)\n-\t      n->range = n->size;\n+\t      n->range = type_size / BITS_PER_UNIT;\n \t  }\n \t  break;\n \tdefault:\n@@ -1906,7 +1923,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n   if (rhs_class == GIMPLE_BINARY_RHS)\n     {\n-      int i;\n+      int i, size;\n       struct symbolic_number n1, n2;\n       uint64_t mask;\n       tree source_expr2;\n@@ -1932,7 +1949,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  if (!source_expr2)\n \t    return NULL_TREE;\n \n-\t  if (n1.size != n2.size)\n+\t  if (TYPE_PRECISION (n1.type) != TYPE_PRECISION (n2.type))\n \t    return NULL_TREE;\n \n \t  if (!n1.vuse != !n2.vuse ||\n@@ -1998,8 +2015,9 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  n->base_addr = n1.base_addr;\n \t  n->offset = n1.offset;\n \t  n->bytepos = n1.bytepos;\n-\t  n->size = n1.size;\n-\t  for (i = 0, mask = 0xff; i < n->size; i++, mask <<= BITS_PER_UNIT)\n+\t  n->type = n1.type;\n+\t  size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n+\t  for (i = 0, mask = 0xff; i < size; i++, mask <<= BITS_PER_UNIT)\n \t    {\n \t      uint64_t masked1, masked2;\n "}]}