{"sha": "132da1a5aa17e496019e1603ce3d59fe1e61d44d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMyZGExYTVhYTE3ZTQ5NjAxOWUxNjAzY2UzZDU5ZmUxZTYxZDQ0ZA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-06-13T17:14:09Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-06-13T17:14:09Z"}, "message": "c-typeck.c (comptypes, [...]): Remove flags parameter.\n\n\t* c-typeck.c (comptypes, tagged_types_tu_compatible_p,\n\tfunction_types_compatible_p, type_lists_compatible_p): Remove\n\tflags parameter.\n\t* c-tree.h (comptypes): Likewise.\n\t(COMPARE_STRICT): Remove.\n\t* c-decl.c, c-lang.c, c-parse.in, c-typeck.c, objc/objc-act.c: All\n\tcallers changed.\n\nFrom-SVN: r83061", "tree": {"sha": "c30a57dca5c79311f6a8335e3a454cbbde51ee9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c30a57dca5c79311f6a8335e3a454cbbde51ee9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/132da1a5aa17e496019e1603ce3d59fe1e61d44d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/132da1a5aa17e496019e1603ce3d59fe1e61d44d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/132da1a5aa17e496019e1603ce3d59fe1e61d44d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/132da1a5aa17e496019e1603ce3d59fe1e61d44d/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "118a3a8ba8497b0b68ebe0f875ce940d84a7315e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118a3a8ba8497b0b68ebe0f875ce940d84a7315e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118a3a8ba8497b0b68ebe0f875ce940d84a7315e"}], "stats": {"total": 120, "additions": 57, "deletions": 63}, "files": [{"sha": "7413811cb80fe7c0137b48cb36634969523c09d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=132da1a5aa17e496019e1603ce3d59fe1e61d44d", "patch": "@@ -1,3 +1,13 @@\n+2004-06-13  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-typeck.c (comptypes, tagged_types_tu_compatible_p,\n+\tfunction_types_compatible_p, type_lists_compatible_p): Remove\n+\tflags parameter.\n+\t* c-tree.h (comptypes): Likewise.\n+\t(COMPARE_STRICT): Remove.\n+\t* c-decl.c, c-lang.c, c-parse.in, c-typeck.c, objc/objc-act.c: All\n+\tcallers changed.\n+\n 2004-06-13  Eric Christopher  <echristo@redhat.com>\n \n \t* c-decl.c (diagnose_mismatched_decls): Improve error message."}, {"sha": "713be8fa464ec39cf90dc1e9434289f8c11673c7", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=132da1a5aa17e496019e1603ce3d59fe1e61d44d", "patch": "@@ -936,7 +936,7 @@ diagnose_arglist_conflict (tree newdecl, tree olddecl,\n   tree t;\n \n   if (TREE_CODE (olddecl) != FUNCTION_DECL\n-      || !comptypes (TREE_TYPE (oldtype), TREE_TYPE (newtype), COMPARE_STRICT)\n+      || !comptypes (TREE_TYPE (oldtype), TREE_TYPE (newtype))\n       || !((TYPE_ARG_TYPES (oldtype) == 0 && DECL_INITIAL (olddecl) == 0)\n \t   ||\n \t   (TYPE_ARG_TYPES (newtype) == 0 && DECL_INITIAL (newdecl) == 0)))\n@@ -1008,7 +1008,7 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n \n       /* Type for passing arg must be consistent with that declared\n \t for the arg.  */\n-      else if (! comptypes (oldargtype, newargtype, COMPARE_STRICT))\n+      else if (! comptypes (oldargtype, newargtype))\n \t{\n \t  error (\"%Jprototype for '%D' declares arg %d with incompatible type\",\n \t\t newdecl, newdecl, i);\n@@ -1090,7 +1090,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       return false;\n     }\n \n-  if (!comptypes (oldtype, newtype, COMPARE_STRICT))\n+  if (!comptypes (oldtype, newtype))\n     {\n       if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t  && DECL_BUILT_IN (olddecl) && !C_DECL_DECLARED_BUILTIN (olddecl))\n@@ -1099,7 +1099,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t     This is for the ffs and fprintf builtins.  */\n \t  tree trytype = match_builtin_function_types (newtype, oldtype);\n \n-\t  if (trytype && comptypes (newtype, trytype, COMPARE_STRICT))\n+\t  if (trytype && comptypes (newtype, trytype))\n \t    *oldtypep = oldtype = trytype;\n \t  else\n \t    {\n@@ -6008,8 +6008,7 @@ store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n \t     declared for the arg.  ISO C says we take the unqualified\n \t     type for parameters declared with qualified type.  */\n \t  if (! comptypes (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parm)),\n-\t\t\t   TYPE_MAIN_VARIANT (TREE_VALUE (type)),\n-\t\t\t   COMPARE_STRICT))\n+\t\t\t   TYPE_MAIN_VARIANT (TREE_VALUE (type))))\n \t    {\n \t      if (TYPE_MAIN_VARIANT (TREE_TYPE (parm))\n \t\t  == TYPE_MAIN_VARIANT (TREE_VALUE (type)))"}, {"sha": "3bdd246c783c3a42811ca162381bedd7cb90ce63", "filename": "gcc/c-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=132da1a5aa17e496019e1603ce3d59fe1e61d44d", "patch": "@@ -216,7 +216,7 @@ finish_file (void)\n int\n c_types_compatible_p (tree x, tree y)\n {\n-    return comptypes (TYPE_MAIN_VARIANT (x), TYPE_MAIN_VARIANT (y), 0);\n+    return comptypes (TYPE_MAIN_VARIANT (x), TYPE_MAIN_VARIANT (y));\n }\n static void\n c_initialize_diagnostics (diagnostic_context *context)"}, {"sha": "08badedb0022c97a6e01ede2d9e08856792cf1f3", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=132da1a5aa17e496019e1603ce3d59fe1e61d44d", "patch": "@@ -700,7 +700,7 @@ primary:\n \t\t  e1 = TYPE_MAIN_VARIANT (groktypename ($3));\n \t\t  e2 = TYPE_MAIN_VARIANT (groktypename ($5));\n \n-\t\t  $$ = comptypes (e1, e2, COMPARE_STRICT)\n+\t\t  $$ = comptypes (e1, e2)\n \t\t    ? build_int_2 (1, 0) : build_int_2 (0, 0);\n \t\t}\n \t| TYPES_COMPATIBLE_P '(' error ')'"}, {"sha": "e758c98afd82ca2aff3c0b1dac7c40b83e5edc8e", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=132da1a5aa17e496019e1603ce3d59fe1e61d44d", "patch": "@@ -214,14 +214,9 @@ extern bool c_warn_unused_global_decl (tree);\n \n /* in c-typeck.c */\n \n-/* For use with comptypes.  */\n-enum {\n-  COMPARE_STRICT = 0\n-};\n-\n extern tree require_complete_type (tree);\n extern int same_translation_unit_p (tree, tree);\n-extern int comptypes (tree, tree, int);\n+extern int comptypes (tree, tree);\n extern tree c_size_in_bytes (tree);\n extern bool c_mark_addressable (tree);\n extern void c_incomplete_type_error (tree, tree);"}, {"sha": "c1a262b82d8a7c998ca2f459e6051a64b2f703d6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=132da1a5aa17e496019e1603ce3d59fe1e61d44d", "patch": "@@ -54,10 +54,10 @@ static int require_constant_value;\n static int require_constant_elements;\n \n static tree qualify_type (tree, tree);\n-static int tagged_types_tu_compatible_p (tree, tree, int);\n+static int tagged_types_tu_compatible_p (tree, tree);\n static int comp_target_types (tree, tree, int);\n-static int function_types_compatible_p (tree, tree, int);\n-static int type_lists_compatible_p (tree, tree, int);\n+static int function_types_compatible_p (tree, tree);\n+static int type_lists_compatible_p (tree, tree);\n static tree decl_constant_value_for_broken_optimization (tree);\n static tree default_function_array_conversion (tree);\n static tree lookup_field (tree, tree);\n@@ -338,8 +338,7 @@ composite_type (tree t1, tree t2)\n \t\ttree memb;\n \t\tfor (memb = TYPE_FIELDS (TREE_VALUE (p1));\n \t\t     memb; memb = TREE_CHAIN (memb))\n-\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p2),\n-\t\t\t\t COMPARE_STRICT))\n+\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p2)))\n \t\t    {\n \t\t      TREE_VALUE (n) = TREE_VALUE (p2);\n \t\t      if (pedantic)\n@@ -353,8 +352,7 @@ composite_type (tree t1, tree t2)\n \t\ttree memb;\n \t\tfor (memb = TYPE_FIELDS (TREE_VALUE (p2));\n \t\t     memb; memb = TREE_CHAIN (memb))\n-\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p1),\n-\t\t\t\t COMPARE_STRICT))\n+\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p1)))\n \t\t    {\n \t\t      TREE_VALUE (n) = TREE_VALUE (p1);\n \t\t      if (pedantic)\n@@ -558,7 +556,7 @@ common_type (tree t1, tree t2)\n    but a warning may be needed if you use them together.  */\n \n int\n-comptypes (tree type1, tree type2, int flags)\n+comptypes (tree type1, tree type2)\n {\n   tree t1 = type1;\n   tree t2 = type2;\n@@ -625,11 +623,11 @@ comptypes (tree type1, tree type2, int flags)\n       if (c_dialect_objc () && (val = objc_comptypes (t1, t2, 0)) >= 0)\n \tbreak;\n       val = (TREE_TYPE (t1) == TREE_TYPE (t2)\n-\t     ? 1 : comptypes (TREE_TYPE (t1), TREE_TYPE (t2), flags));\n+\t     ? 1 : comptypes (TREE_TYPE (t1), TREE_TYPE (t2)));\n       break;\n \n     case FUNCTION_TYPE:\n-      val = function_types_compatible_p (t1, t2, flags);\n+      val = function_types_compatible_p (t1, t2);\n       break;\n \n     case ARRAY_TYPE:\n@@ -642,8 +640,7 @@ comptypes (tree type1, tree type2, int flags)\n \n \t/* Target types must match incl. qualifiers.  */\n \tif (TREE_TYPE (t1) != TREE_TYPE (t2)\n-\t    && 0 == (val = comptypes (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t      flags)))\n+\t    && 0 == (val = comptypes (TREE_TYPE (t1), TREE_TYPE (t2))))\n \t  return 0;\n \n \t/* Sizes must match unless one is missing or variable.  */\n@@ -681,12 +678,12 @@ comptypes (tree type1, tree type2, int flags)\n     case ENUMERAL_TYPE:\n     case UNION_TYPE:\n       if (val != 1 && !same_translation_unit_p (t1, t2))\n-\tval = tagged_types_tu_compatible_p (t1, t2, flags);\n+\tval = tagged_types_tu_compatible_p (t1, t2);\n       break;\n \n     case VECTOR_TYPE:\n       val = TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n-\t    && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), 0);\n+\t    && comptypes (TREE_TYPE (t1), TREE_TYPE (t2));\n       break;\n \n     default:\n@@ -712,7 +709,7 @@ comp_target_types (tree ttl, tree ttr, int reflexive)\n     return val;\n \n   val = comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (ttl)),\n-\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (ttr)), COMPARE_STRICT);\n+\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (ttr)));\n \n   if (val == 2 && pedantic)\n     pedwarn (\"types are not quite compatible\");\n@@ -772,7 +769,7 @@ static const struct tagged_tu_seen * tagged_tu_seen_base;\n    rules.  */\n \n static int\n-tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n+tagged_types_tu_compatible_p (tree t1, tree t2)\n {\n   tree s1, s2;\n   bool needs_warning = false;\n@@ -869,7 +866,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n \t\tif (DECL_NAME (s1) == DECL_NAME (s2))\n \t\t  {\n \t\t    int result;\n-\t\t    result = comptypes (TREE_TYPE (s1), TREE_TYPE (s2), flags);\n+\t\t    result = comptypes (TREE_TYPE (s1), TREE_TYPE (s2));\n \t\t    if (result == 0)\n \t\t      break;\n \t\t    if (result == 2)\n@@ -907,7 +904,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n \t    if (TREE_CODE (s1) != TREE_CODE (s2)\n \t\t|| DECL_NAME (s1) != DECL_NAME (s2))\n \t      break;\n-\t    result = comptypes (TREE_TYPE (s1), TREE_TYPE (s2), flags);\n+\t    result = comptypes (TREE_TYPE (s1), TREE_TYPE (s2));\n \t    if (result == 0)\n \t      break;\n \t    if (result == 2)\n@@ -937,7 +934,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n    Otherwise, the argument types must match.  */\n \n static int\n-function_types_compatible_p (tree f1, tree f2, int flags)\n+function_types_compatible_p (tree f1, tree f2)\n {\n   tree args1, args2;\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n@@ -958,7 +955,7 @@ function_types_compatible_p (tree f1, tree f2, int flags)\n   if (TYPE_VOLATILE (ret2))\n     ret2 = build_qualified_type (TYPE_MAIN_VARIANT (ret2),\n \t\t\t\t TYPE_QUALS (ret2) & ~TYPE_QUAL_VOLATILE);\n-  val = comptypes (ret1, ret2, flags);\n+  val = comptypes (ret1, ret2);\n   if (val == 0)\n     return 0;\n \n@@ -976,8 +973,7 @@ function_types_compatible_p (tree f1, tree f2, int flags)\n \t compare that with the other type's arglist.\n \t If they don't match, ask for a warning (but no error).  */\n       if (TYPE_ACTUAL_ARG_TYPES (f1)\n-\t  && 1 != type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1),\n-\t\t\t\t\t   flags))\n+\t  && 1 != type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1)))\n \tval = 2;\n       return val;\n     }\n@@ -986,14 +982,13 @@ function_types_compatible_p (tree f1, tree f2, int flags)\n       if (!self_promoting_args_p (args1))\n \treturn 0;\n       if (TYPE_ACTUAL_ARG_TYPES (f2)\n-\t  && 1 != type_lists_compatible_p (args1, TYPE_ACTUAL_ARG_TYPES (f2),\n-\t\t\t\t\t   flags))\n+\t  && 1 != type_lists_compatible_p (args1, TYPE_ACTUAL_ARG_TYPES (f2)))\n \tval = 2;\n       return val;\n     }\n \n   /* Both types have argument lists: compare them and propagate results.  */\n-  val1 = type_lists_compatible_p (args1, args2, flags);\n+  val1 = type_lists_compatible_p (args1, args2);\n   return val1 != 1 ? val1 : val;\n }\n \n@@ -1002,7 +997,7 @@ function_types_compatible_p (tree f1, tree f2, int flags)\n    or 2 for compatible with warning.  */\n \n static int\n-type_lists_compatible_p (tree args1, tree args2, int flags)\n+type_lists_compatible_p (tree args1, tree args2)\n {\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n   int val = 1;\n@@ -1035,8 +1030,7 @@ type_lists_compatible_p (tree args1, tree args2, int flags)\n \t       || TREE_CODE (TREE_VALUE (args2)) == ERROR_MARK)\n \t;\n       else if (! (newval = comptypes (TYPE_MAIN_VARIANT (TREE_VALUE (args1)),\n-\t\t\t\t      TYPE_MAIN_VARIANT (TREE_VALUE (args2)),\n-\t\t\t\t      flags)))\n+\t\t\t\t      TYPE_MAIN_VARIANT (TREE_VALUE (args2)))))\n \t{\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n \t     and  wait (union wait *)  to be compatible.  */\n@@ -1050,8 +1044,7 @@ type_lists_compatible_p (tree args1, tree args2, int flags)\n \t      tree memb;\n \t      for (memb = TYPE_FIELDS (TREE_VALUE (args1));\n \t\t   memb; memb = TREE_CHAIN (memb))\n-\t\tif (comptypes (TREE_TYPE (memb), TREE_VALUE (args2),\n-\t\t\t       flags))\n+\t\tif (comptypes (TREE_TYPE (memb), TREE_VALUE (args2)))\n \t\t  break;\n \t      if (memb == 0)\n \t\treturn 0;\n@@ -1066,8 +1059,7 @@ type_lists_compatible_p (tree args1, tree args2, int flags)\n \t      tree memb;\n \t      for (memb = TYPE_FIELDS (TREE_VALUE (args2));\n \t\t   memb; memb = TREE_CHAIN (memb))\n-\t\tif (comptypes (TREE_TYPE (memb), TREE_VALUE (args1),\n-\t\t\t       flags))\n+\t\tif (comptypes (TREE_TYPE (memb), TREE_VALUE (args1)))\n \t\t  break;\n \t      if (memb == 0)\n \t\treturn 0;\n@@ -1837,7 +1829,7 @@ build_function_call (tree function, tree params)\n       && TREE_CODE (function) == NOP_EXPR\n       && TREE_CODE (tem = TREE_OPERAND (function, 0)) == ADDR_EXPR\n       && TREE_CODE (tem = TREE_OPERAND (tem, 0)) == FUNCTION_DECL\n-      && ! comptypes (fntype, TREE_TYPE (tem), COMPARE_STRICT))\n+      && ! comptypes (fntype, TREE_TYPE (tem)))\n     {\n       tree return_type = TREE_TYPE (fntype);\n       tree trap = build_function_call (built_in_decls[BUILT_IN_TRAP],\n@@ -3013,7 +3005,7 @@ build_c_cast (tree type, tree expr)\n \n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \tif (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (field)),\n-\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (value)), COMPARE_STRICT))\n+\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (value))))\n \t  break;\n \n       if (field)\n@@ -3361,7 +3353,7 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n      This code doesn't fully support references, it's just for the\n      special case of va_start and va_copy.  */\n   if (codel == REFERENCE_TYPE\n-      && comptypes (TREE_TYPE (type), TREE_TYPE (rhs), COMPARE_STRICT) == 1)\n+      && comptypes (TREE_TYPE (type), TREE_TYPE (rhs)) == 1)\n     {\n       if (!lvalue_p (rhs))\n \t{\n@@ -3409,7 +3401,7 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t  tree memb_type = TREE_TYPE (memb_types);\n \n \t  if (comptypes (TYPE_MAIN_VARIANT (memb_type),\n-\t\t\t TYPE_MAIN_VARIANT (rhstype), COMPARE_STRICT))\n+\t\t\t TYPE_MAIN_VARIANT (rhstype)))\n \t    break;\n \n \t  if (TREE_CODE (memb_type) != POINTER_TYPE)\n@@ -3988,7 +3980,7 @@ digest_init (tree type, tree init, int require_constant)\n \t  && ((inside_init && TREE_CODE (inside_init) == STRING_CST)))\n \t{\n \t  if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n-\t\t\t TYPE_MAIN_VARIANT (type), COMPARE_STRICT))\n+\t\t\t TYPE_MAIN_VARIANT (type)))\n \t    return inside_init;\n \n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)))\n@@ -4035,8 +4027,7 @@ digest_init (tree type, tree init, int require_constant)\n       {\n \tif (TREE_CODE (inside_init) == VECTOR_CST\n             && comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n-\t\t\t  TYPE_MAIN_VARIANT (type),\n-\t\t\t  COMPARE_STRICT))\n+\t\t\t  TYPE_MAIN_VARIANT (type)))\n \t  return inside_init;\n \telse\n \t  return build_vector (type, CONSTRUCTOR_ELTS (inside_init));\n@@ -4047,19 +4038,19 @@ digest_init (tree type, tree init, int require_constant)\n \n   if (inside_init && TREE_TYPE (inside_init) != 0\n       && (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n-\t\t     TYPE_MAIN_VARIANT (type), COMPARE_STRICT)\n+\t\t     TYPE_MAIN_VARIANT (type))\n \t  || (code == ARRAY_TYPE\n-\t      && comptypes (TREE_TYPE (inside_init), type, COMPARE_STRICT))\n+\t      && comptypes (TREE_TYPE (inside_init), type))\n \t  || (code == VECTOR_TYPE\n-\t      && comptypes (TREE_TYPE (inside_init), type, COMPARE_STRICT))\n+\t      && comptypes (TREE_TYPE (inside_init), type))\n \t  || (code == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE\n \t      && comptypes (TREE_TYPE (TREE_TYPE (inside_init)),\n-\t\t\t    TREE_TYPE (type), COMPARE_STRICT))\n+\t\t\t    TREE_TYPE (type)))\n \t  || (code == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (inside_init)) == FUNCTION_TYPE\n \t      && comptypes (TREE_TYPE (inside_init),\n-\t\t\t    TREE_TYPE (type), COMPARE_STRICT))))\n+\t\t\t    TREE_TYPE (type)))))\n     {\n       if (code == POINTER_TYPE)\n \t{\n@@ -5500,7 +5491,7 @@ output_init_element (tree value, tree type, tree field, int pending)\n \t       && TREE_CODE (type) == ARRAY_TYPE\n \t       && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)\n \t  && !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (value)),\n-\t\t\t TYPE_MAIN_VARIANT (type), COMPARE_STRICT)))\n+\t\t\t TYPE_MAIN_VARIANT (type))))\n     value = default_conversion (value);\n \n   if (TREE_CODE (value) == COMPOUND_LITERAL_EXPR"}, {"sha": "96e29b181bae9a2b1a4243fee8f8f148ca1b3891", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/132da1a5aa17e496019e1603ce3d59fe1e61d44d/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=132da1a5aa17e496019e1603ce3d59fe1e61d44d", "patch": "@@ -1,6 +1,6 @@\n /* Implement classes and message passing for Objective C.\n    Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Steve Naroff.\n \n This file is part of GCC.\n@@ -4257,7 +4257,7 @@ check_ivars (tree inter, tree imp)\n \n       t1 = TREE_TYPE (intdecls); t2 = TREE_TYPE (impdecls);\n \n-      if (!comptypes (t1, t2, false)\n+      if (!comptypes (t1, t2)\n \t  || !tree_int_cst_equal (TREE_VALUE (TREE_VALUE (rawintdecls)),\n \t\t\t\t  TREE_VALUE (TREE_VALUE (rawimpdecls))))\n \t{\n@@ -7612,8 +7612,7 @@ comp_method_with_proto (tree method, tree proto)\n   /* install return type */\n   TREE_TYPE (function1_template) = groktypename (TREE_TYPE (proto));\n \n-  return comptypes (TREE_TYPE (METHOD_DEFINITION (method)), function1_template,\n-\t\t    false);\n+  return comptypes (TREE_TYPE (METHOD_DEFINITION (method)), function1_template);\n }\n \n /* Return 1 if TYPE1 is equivalent to TYPE2.  */"}]}