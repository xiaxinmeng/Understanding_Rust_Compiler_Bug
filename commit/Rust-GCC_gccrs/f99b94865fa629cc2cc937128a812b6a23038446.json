{"sha": "f99b94865fa629cc2cc937128a812b6a23038446", "node_id": "C_kwDOANBUbNoAKGY5OWI5NDg2NWZhNjI5Y2MyY2M5MzcxMjhhODEyYjZhMjMwMzg0NDY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-22T01:29:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-22T23:34:27Z"}, "message": "libstdc++: Add std::format support to <chrono>\n\nThis adds the operator<< overloads and std::formatter specializations\nrequired by C++20 so that <chrono> types can be written to ostreams and\nprinted with std::format.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/chrono (operator<<): Move to new header.\n\t(nonexistent_local_time::_M_make_what_str): Define correctly.\n\t(ambiguous_local_time::_M_make_what_str): Likewise.\n\t* include/bits/chrono_io.h: New file.\n\t* src/c++20/tzdb.cc (operator<<(ostream&, const Rule&)): Use\n\tnew ostream output for month and weekday types.\n\t* testsuite/20_util/duration/io.cc: Test std::format support.\n\t* testsuite/std/time/exceptions.cc: Check what() strings.\n\t* testsuite/std/time/syn_c++20.cc: Uncomment local_time_format.\n\t* testsuite/std/time/time_zone/get_info_local.cc: Enable check\n\tfor formatted output of local_info objects.\n\t* testsuite/std/time/clock/file/io.cc: New test.\n\t* testsuite/std/time/clock/gps/io.cc: New test.\n\t* testsuite/std/time/clock/system/io.cc: New test.\n\t* testsuite/std/time/clock/tai/io.cc: New test.\n\t* testsuite/std/time/clock/utc/io.cc: New test.\n\t* testsuite/std/time/day/io.cc: New test.\n\t* testsuite/std/time/format.cc: New test.\n\t* testsuite/std/time/hh_mm_ss/io.cc: New test.\n\t* testsuite/std/time/month/io.cc: New test.\n\t* testsuite/std/time/weekday/io.cc: New test.\n\t* testsuite/std/time/year/io.cc: New test.\n\t* testsuite/std/time/year_month_day/io.cc: New test.", "tree": {"sha": "8552c2e3d872bf3432094f40b36a958e79919d21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8552c2e3d872bf3432094f40b36a958e79919d21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f99b94865fa629cc2cc937128a812b6a23038446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99b94865fa629cc2cc937128a812b6a23038446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f99b94865fa629cc2cc937128a812b6a23038446", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99b94865fa629cc2cc937128a812b6a23038446/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9247402a29d73dc09830a48d39a27768d40e46e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9247402a29d73dc09830a48d39a27768d40e46e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9247402a29d73dc09830a48d39a27768d40e46e0"}], "stats": {"total": 3614, "additions": 3465, "deletions": 149}, "files": [{"sha": "e91f4ddd4de2bd9b3edc1b548beb99fdc9f2752e", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -175,6 +175,7 @@ bits_headers = \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/charconv.h \\\n \t${bits_srcdir}/chrono.h \\\n+\t${bits_srcdir}/chrono_io.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/cow_string.h \\\n \t${bits_srcdir}/deque.tcc \\"}, {"sha": "06589d538567edf4da5ccc56a31ec898ae619422", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -528,6 +528,7 @@ bits_freestanding = \\\n @GLIBCXX_HOSTED_TRUE@\t${bits_srcdir}/char_traits.h \\\n @GLIBCXX_HOSTED_TRUE@\t${bits_srcdir}/charconv.h \\\n @GLIBCXX_HOSTED_TRUE@\t${bits_srcdir}/chrono.h \\\n+@GLIBCXX_HOSTED_TRUE@\t${bits_srcdir}/chrono_io.h \\\n @GLIBCXX_HOSTED_TRUE@\t${bits_srcdir}/codecvt.h \\\n @GLIBCXX_HOSTED_TRUE@\t${bits_srcdir}/cow_string.h \\\n @GLIBCXX_HOSTED_TRUE@\t${bits_srcdir}/deque.tcc \\"}, {"sha": "4e53cd4aa2e3253ec67cab61865adab43af7ed52", "filename": "libstdc++-v3/include/bits/chrono_io.h", "status": "added", "additions": 2469, "deletions": 0, "changes": 2469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchrono_io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchrono_io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchrono_io.h?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,2469 @@\n+// <chrono> Formatting -*- C++ -*-\n+\n+// Copyright The GNU Toolchain Authors.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/chrono_io.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{chrono}\n+ */\n+\n+#ifndef _GLIBCXX_CHRONO_IO_H\n+#define _GLIBCXX_CHRONO_IO_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 202002L\n+\n+#include <sstream> // ostringstream\n+#include <iomanip> // setw, setfill\n+#include <format>\n+\n+#include <bits/charconv.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+namespace chrono\n+{\n+/// @addtogroup chrono\n+/// @{\n+\n+/// @cond undocumented\n+namespace __detail\n+{\n+  // STATICALLY-WIDEN, see C++20 [time.general]\n+  // It doesn't matter for format strings (which can only be char or wchar_t)\n+  // but this returns the narrow string for anything that isn't wchar_t. This\n+  // is done because const char* can be inserted into any ostream type, and\n+  // will be widened at runtime if necessary.\n+  template<typename _CharT>\n+    consteval auto\n+    _Widen(const char* __narrow, const wchar_t* __wide)\n+    {\n+      if constexpr (is_same_v<_CharT, wchar_t>)\n+\treturn __wide;\n+      else\n+\treturn __narrow;\n+    }\n+#define _GLIBCXX_WIDEN_(C, S) ::std::chrono::__detail::_Widen<C>(S, L##S)\n+#define _GLIBCXX_WIDEN(S) _GLIBCXX_WIDEN_(_CharT, S)\n+\n+\n+  // Write an arbitrary duration suffix into the buffer.\n+  template<typename _Period>\n+    constexpr const char*\n+    __units_suffix_misc(char* __buf, size_t /* TODO check length? */) noexcept\n+    {\n+      namespace __tc = std::__detail;\n+      char* __p = __buf;\n+      __p[0] = '[';\n+      unsigned __nlen = __tc::__to_chars_len((uintmax_t)_Period::num);\n+      __tc::__to_chars_10_impl(__p + 1, __nlen, (uintmax_t)_Period::num);\n+      __p += 1 + __nlen;\n+      if constexpr (_Period::den != 1)\n+\t{\n+\t  __p[0] = '/';\n+\t  unsigned __dlen = __tc::__to_chars_len((uintmax_t)_Period::den);\n+\t  __tc::__to_chars_10_impl(__p + 1, __dlen, (uintmax_t)_Period::den);\n+\t  __p += 1 + __dlen;\n+\t}\n+      __p[0] = ']';\n+      __p[1] = 's';\n+      __p[2] = '\\0';\n+      return __buf;\n+    }\n+\n+  template<typename _Period, typename _CharT>\n+    constexpr auto\n+    __units_suffix(char* __buf, size_t __n) noexcept\n+    {\n+      // The standard say these are all narrow strings, which would need to\n+      // be widened at run-time when inserted into a wide stream. We use\n+      // STATICALLY-WIDEN to widen at compile-time.\n+#define _GLIBCXX_UNITS_SUFFIX(period, suffix) \\\n+    if constexpr (is_same_v<_Period, period>) \\\n+      return _GLIBCXX_WIDEN(suffix);\t      \\\n+    else\n+\n+      _GLIBCXX_UNITS_SUFFIX(atto,  \"as\")\n+      _GLIBCXX_UNITS_SUFFIX(femto, \"fs\")\n+      _GLIBCXX_UNITS_SUFFIX(pico,  \"ps\")\n+      _GLIBCXX_UNITS_SUFFIX(nano,  \"ns\")\n+      _GLIBCXX_UNITS_SUFFIX(milli, \"ms\")\n+#if _GLIBCXX_USE_ALT_MICROSECONDS_SUFFIX\n+      // Deciding this at compile-time is wrong, maybe use nl_langinfo(CODESET)\n+      // to check runtime environment and return u8\"\\u00b5s\", \"\\xb5s\", or \"us\".\n+      _GLIBCXX_UNITS_SUFFIX(micro, \"\\u00b5s\")\n+#else\n+      _GLIBCXX_UNITS_SUFFIX(micro, \"us\")\n+#endif\n+      _GLIBCXX_UNITS_SUFFIX(centi, \"cs\")\n+      _GLIBCXX_UNITS_SUFFIX(deci,  \"ds\")\n+      _GLIBCXX_UNITS_SUFFIX(ratio<1>, \"s\")\n+      _GLIBCXX_UNITS_SUFFIX(deca,  \"das\")\n+      _GLIBCXX_UNITS_SUFFIX(hecto, \"hs\")\n+      _GLIBCXX_UNITS_SUFFIX(kilo,  \"ks\")\n+      _GLIBCXX_UNITS_SUFFIX(mega,  \"Ms\")\n+      _GLIBCXX_UNITS_SUFFIX(giga,  \"Gs\")\n+      _GLIBCXX_UNITS_SUFFIX(tera,  \"Ts\")\n+      _GLIBCXX_UNITS_SUFFIX(tera,  \"Ts\")\n+      _GLIBCXX_UNITS_SUFFIX(peta,  \"Ps\")\n+      _GLIBCXX_UNITS_SUFFIX(exa,   \"Es\")\n+      _GLIBCXX_UNITS_SUFFIX(ratio<60>,    \"min\")\n+      _GLIBCXX_UNITS_SUFFIX(ratio<3600>,  \"h\")\n+      _GLIBCXX_UNITS_SUFFIX(ratio<86400>, \"d\")\n+#undef _GLIBCXX_UNITS_SUFFIX\n+      return __detail::__units_suffix_misc<_Period>(__buf, __n);\n+    }\n+} // namespace __detail\n+/// @endcond\n+\n+  /** Write a `chrono::duration` to an ostream.\n+   *\n+   * @since C++20\n+   */\n+  template<typename _CharT, typename _Traits,\n+\t   typename _Rep, typename _Period>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n+\t       const duration<_Rep, _Period>& __d)\n+    {\n+      using period = typename _Period::type;\n+      char __buf[sizeof(\"[/]s\") + 2 * numeric_limits<intmax_t>::digits10];\n+      std::basic_ostringstream<_CharT, _Traits> __s;\n+      __s.flags(__os.flags());\n+      __s.imbue(__os.getloc());\n+      __s.precision(__os.precision());\n+      __s << __d.count();\n+      __s << __detail::__units_suffix<period, _CharT>(__buf, sizeof(__buf));\n+      __os << std::move(__s).str();\n+      return __os;\n+    }\n+\n+/// @cond undocumented\n+namespace __detail\n+{\n+  // An unspecified type returned by `chrono::local_time_format`.\n+  template<typename _Duration>\n+    struct __local_time_fmt\n+    {\n+      local_time<_Duration> _M_time;\n+      const string* _M_abbrev;\n+      const seconds* _M_offset_sec;\n+    };\n+\n+  struct __local_fmt_t;\n+}\n+/// @endcond\n+\n+  /** Return an object that asssociates timezone info with a local time.\n+   *\n+   * A `chrono::local_time` object has no timezone associated with it. This\n+   * function creates an object that allows formatting a `local_time` as\n+   * though it refers to a timezone with the given abbreviated name and\n+   * offset from UTC.\n+   *\n+   * @since C++20\n+   */\n+  template<typename _Duration>\n+    inline __detail::__local_time_fmt<_Duration>\n+    local_time_format(local_time<_Duration> __time,\n+\t\t      const string* __abbrev = nullptr,\n+\t\t      const seconds* __offset_sec = nullptr)\n+    { return {__time, __abbrev, __offset_sec}; }\n+\n+  /// @}\n+} // namespace chrono\n+\n+/// @cond undocumented\n+namespace __format\n+{\n+  [[noreturn,__gnu__::__always_inline__]]\n+  inline void\n+  __no_timezone_available()\n+  { __throw_format_error(\"format error: no timezone available for %Z or %z\"); }\n+\n+  [[noreturn,__gnu__::__always_inline__]]\n+  inline void\n+  __not_valid_for_duration()\n+  { __throw_format_error(\"format error: chrono-format-spec not valid for \"\n+\t\t\t \"chrono::duration\"); }\n+\n+  [[noreturn,__gnu__::__always_inline__]]\n+  inline void\n+  __invalid_chrono_spec()\n+  { __throw_format_error(\"format error: chrono-format-spec not valid for \"\n+\t\t\t \"argument type\"); }\n+\n+  template<typename _CharT>\n+    struct _ChronoSpec : _Spec<_CharT>\n+    {\n+      basic_string_view<_CharT> _M_chrono_specs;\n+    };\n+\n+  // Represents the information provided by a chrono type.\n+  // e.g. month_weekday has month and weekday but no year or time of day,\n+  // hh_mm_ss has time of day but no date, sys_time is time_point+timezone.\n+  enum _ChronoParts {\n+    _Year = 1, _Month = 2, _Day = 4, _Weekday = 8, _TimeOfDay = 16,\n+    _TimeZone = 32,\n+    _Date = _Year | _Month | _Day | _Weekday,\n+    _DateTime = _Date | _TimeOfDay,\n+    _ZonedDateTime = _DateTime | _TimeZone,\n+    _Duration = 128 // special case\n+  };\n+\n+  constexpr _ChronoParts\n+  operator|(_ChronoParts __x, _ChronoParts __y)\n+  { return static_cast<_ChronoParts>((int)__x | (int)__y); }\n+\n+  // TODO rename this to chrono::__formatter? or chrono::__detail::__formatter?\n+  template<typename _CharT>\n+    struct __formatter_chrono\n+    {\n+      using __string_view = basic_string_view<_CharT>;\n+      using __string = basic_string<_CharT>;\n+\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\t_M_parse(_ParseContext& __pc, _ChronoParts __parts)\n+\t{\n+\t  auto __first = __pc.begin();\n+\t  auto __last = __pc.end();\n+\n+\t  _ChronoSpec<_CharT> __spec{};\n+\n+\t  auto __finalize = [this, &__spec] {\n+\t    _M_spec = __spec;\n+\t  };\n+\n+\t  auto __finished = [&] {\n+\t    if (__first == __last || *__first == '}')\n+\t      {\n+\t\t__finalize();\n+\t\treturn true;\n+\t      }\n+\t    return false;\n+\t  };\n+\n+\t  if (__finished())\n+\t    return __first;\n+\n+\t  __first = __spec._M_parse_fill_and_align(__first, __last);\n+\t  if (__finished())\n+\t    return __first;\n+\n+\t  __first = __spec._M_parse_width(__first, __last, __pc);\n+\t  if (__finished())\n+\t    return __first;\n+\n+\t  if (__parts & _ChronoParts::_Duration)\n+\t    {\n+\t      __first = __spec._M_parse_precision(__first, __last, __pc);\n+\t      if (__finished())\n+\t\treturn __first;\n+\t    }\n+\n+\t  __first = __spec._M_parse_locale(__first, __last);\n+\t  if (__finished())\n+\t    return __first;\n+\n+\t  // Everything up to the end of the string or the first '}' is a\n+\t  // chrono-specs string. Check it is valid.\n+\t  {\n+\t    __string_view __str(__first, __last - __first);\n+\t    auto __end = __str.find('}');\n+\t    if (__end != __str.npos)\n+\t      {\n+\t\t__str.remove_suffix(__str.length() - __end);\n+\t\t__last = __first + __end;\n+\t      }\n+\t    if (__str.find('{') != __str.npos)\n+\t      __throw_format_error(\"chrono format error: '{' in chrono-specs\");\n+\t  }\n+\n+\t  // Parse chrono-specs in [first,last), checking each conversion-spec\n+\t  // against __parts (so fail for %Y if no year in parts).\n+\t  // Save range in __spec._M_chrono_specs.\n+\n+\t  const auto __chrono_specs = __first++; // Skip leading '%'\n+\t  if (*__chrono_specs != '%')\n+\t    __throw_format_error(\"chrono format error: no '%' at start of \"\n+\t\t\t\t     \"chrono-specs\");\n+\n+\t  _CharT __mod{};\n+\t  bool __conv = true;\n+\t  int __needed = 0;\n+\n+\t  while (__first != __last)\n+\t    {\n+\t      enum _Mods { _Mod_none, _Mod_E, _Mod_O, _Mod_E_O };\n+\t      _Mods __allowed_mods = _Mod_none;\n+\n+\t      _CharT __c = *__first++;\n+\t      switch (__c)\n+\t\t{\n+\t\tcase 'a':\n+\t\tcase 'A':\n+\t\t  __needed = _Weekday;\n+\t\t  break;\n+\t\tcase 'b':\n+\t\tcase 'h':\n+\t\tcase 'B':\n+\t\t  __needed = _Month;\n+\t\t  break;\n+\t\tcase 'c':\n+\t\t  __needed = _DateTime;\n+\t\t  __allowed_mods = _Mod_E;\n+\t\t  break;\n+\t\tcase 'C':\n+\t\t  __needed = _Year;\n+\t\t  __allowed_mods = _Mod_E;\n+\t\t  break;\n+\t\tcase 'd':\n+\t\tcase 'e':\n+\t\t  __needed = _Day;\n+\t\t  __allowed_mods = _Mod_O;\n+\t\t  break;\n+\t\tcase 'D':\n+\t\tcase 'F':\n+\t\t  __needed = _Date;\n+\t\t  break;\n+\t\tcase 'g':\n+\t\tcase 'G':\n+\t\t  __needed = _Date;\n+\t\t  break;\n+\t\tcase 'H':\n+\t\tcase 'I':\n+\t\t  __needed = _TimeOfDay;\n+\t\t  __allowed_mods = _Mod_O;\n+\t\t  break;\n+\t\tcase 'j':\n+\t\t  if (!(__parts & _Duration))\n+\t\t    __needed = _Date;\n+\t\t  break;\n+\t\tcase 'm':\n+\t\t  __needed = _Month;\n+\t\t  __allowed_mods = _Mod_O;\n+\t\t  break;\n+\t\tcase 'M':\n+\t\t  __needed = _TimeOfDay;\n+\t\t  __allowed_mods = _Mod_O;\n+\t\t  break;\n+\t\tcase 'p':\n+\t\tcase 'r':\n+\t\tcase 'R':\n+\t\tcase 'T':\n+\t\t  __needed = _TimeOfDay;\n+\t\t  break;\n+\t\tcase 'q':\n+\t\tcase 'Q':\n+\t\t  __needed = _Duration;\n+\t\t  break;\n+\t\tcase 'S':\n+\t\t  __needed = _TimeOfDay;\n+\t\t  __allowed_mods = _Mod_O;\n+\t\t  break;\n+\t\tcase 'u':\n+\t\tcase 'w':\n+\t\t  __needed = _Weekday;\n+\t\t  __allowed_mods = _Mod_O;\n+\t\t  break;\n+\t\tcase 'U':\n+\t\tcase 'V':\n+\t\tcase 'W':\n+\t\t  __needed = _Date;\n+\t\t  __allowed_mods = _Mod_O;\n+\t\t  break;\n+\t\tcase 'x':\n+\t\t  __needed = _Date;\n+\t\t  __allowed_mods = _Mod_E;\n+\t\t  break;\n+\t\tcase 'X':\n+\t\t  __needed = _TimeOfDay;\n+\t\t  __allowed_mods = _Mod_E;\n+\t\t  break;\n+\t\tcase 'y':\n+\t\t  __needed = _Year;\n+\t\t  __allowed_mods = _Mod_E_O;\n+\t\t  break;\n+\t\tcase 'Y':\n+\t\t  __needed = _Year;\n+\t\t  __allowed_mods = _Mod_E;\n+\t\t  break;\n+\t\tcase 'z':\n+\t\t  __needed = _TimeZone;\n+\t\t  __allowed_mods = _Mod_E;\n+\t\t  break;\n+\t\tcase 'Z':\n+\t\t  __needed = _TimeZone;\n+\t\t  __allowed_mods = _Mod_E_O;\n+\t\t  break;\n+\t\tcase 'n':\n+\t\tcase 't':\n+\t\tcase '%':\n+\t\t  break;\n+\t\tcase 'O':\n+\t\tcase 'E':\n+\t\t  __mod = __c;\n+\t\t  continue;\n+\t\tdefault:\n+\t\t  __throw_format_error(\"chrono format error: invalid \"\n+\t\t\t\t       \" specifier in chrono-specs\");\n+\t\t}\n+\n+\t      if ((__mod == 'E' && !(__allowed_mods & _Mod_E))\n+\t\t    || __mod == 'O' && !(__allowed_mods & _Mod_O))\n+\t\t__throw_format_error(\"chrono format error: invalid \"\n+\t\t\t\t     \" modifier in chrono-specs\");\n+\t      __mod = _CharT();\n+\n+\t      if ((__parts & __needed) != __needed)\n+\t\t__throw_format_error(\"chrono format error: format argument \"\n+\t\t\t\t     \"does not contain the information \"\n+\t\t\t\t     \"required by the chrono-specs\");\n+\n+\t      // Scan for next '%', ignoring literal-chars before it.\n+\t      size_t __pos = __string_view(__first, __last - __first).find('%');\n+\t      if (__pos == 0)\n+\t\t++__first;\n+\t      else\n+\t\t{\n+\t\t  if (__pos == __string_view::npos)\n+\t\t    {\n+\t\t      __first = __last;\n+\t\t      __conv = false;\n+\t\t    }\n+\t\t  else\n+\t\t    __first += __pos + 1;\n+\t\t}\n+\t    }\n+\n+\t  // Check for a '%' conversion-spec without a type.\n+\t  if (__conv || __mod != _CharT())\n+\t    __throw_format_error(\"chrono format error: unescaped '%' in \"\n+\t\t\t\t \"chrono-specs\");\n+\n+\t  _M_spec = __spec;\n+\t  _M_spec._M_chrono_specs = {__chrono_specs, __first - __chrono_specs};\n+\n+\t  return __first;\n+\t}\n+\n+      // TODO this function template is instantiated for every different _Tp.\n+      // Consider creating a polymorphic interface for calendar types so\n+      // that we instantiate fewer different specializations. Similar to\n+      // _Sink_iter for std::format. Replace each _S_year, _S_day etc. with\n+      // member functions of that type.\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_format(const _Tp& __t, _FormatContext& __fc,\n+\t\t  bool __is_neg = false) const\n+\t{\n+\t  if constexpr (__is_specialization_of<_Tp, chrono::hh_mm_ss>)\n+\t    __is_neg = __t.is_negative();\n+\t  else if constexpr (!chrono::__is_duration_v<_Tp>)\n+\t    __is_neg = false;\n+\n+\t  auto __first = _M_spec._M_chrono_specs.begin();\n+\t  const auto __last = _M_spec._M_chrono_specs.end();\n+\t  if (__first == __last)\n+\t    return _M_format_to_ostream(__t, __fc, __is_neg);\n+\n+\t  _Sink_iter<_CharT> __out;\n+\t  __format::_Str_sink<_CharT> __sink;\n+\t  bool __write_direct = false;\n+\t  if constexpr (is_same_v<typename _FormatContext::iterator,\n+\t\t\t\t  _Sink_iter<_CharT>>)\n+\t    {\n+\t      if (_M_spec._M_width_kind == __format::_WP_none)\n+\t\t{\n+\t\t  __out = __fc.out();\n+\t\t  __write_direct = true;\n+\t\t}\n+\t      else\n+\t\t__out = __sink.out();\n+\t    }\n+\t  else\n+\t    __out = __sink.out();\n+\n+\t  auto __print_sign = [&__is_neg, &__out] {\n+\t    if (__is_neg)\n+\t      {\n+\t\t*__out++ = _S_plus_minus[1];\n+\t\t__is_neg = false;\n+\t      }\n+\t    return std::move(__out);\n+\t  };\n+\n+\t  // Characters to output for \"%n\", \"%t\" and \"%%\" specifiers.\n+\t  constexpr const _CharT* __literals = _GLIBCXX_WIDEN(\"\\n\\t%\");\n+\n+\t  ++__first; // Skip leading '%' at start of chrono-specs.\n+\n+\t  _CharT __mod{};\n+\t  do\n+\t    {\n+\t      _CharT __c = *__first++;\n+\t      switch (__c)\n+\t\t{\n+\t\tcase 'a':\n+\t\tcase 'A':\n+\t\t  __out = _M_a_A(__t, std::move(__out), __fc, __c == 'A');\n+\t\t  break;\n+\t\tcase 'b':\n+\t\tcase 'h':\n+\t\tcase 'B':\n+\t\t  __out = _M_b_B(__t, std::move(__out), __fc, __c == 'B');\n+\t\t  break;\n+\t\tcase 'c':\n+\t\t  __out = _M_c(__t, std::move(__out), __fc, __mod == 'E');\n+\t\t  break;\n+\t\tcase 'C':\n+\t\tcase 'y':\n+\t\tcase 'Y':\n+\t\t  __out = _M_C_y_Y(__t, std::move(__out), __fc, __c, __mod);\n+\t\t  break;\n+\t\tcase 'd':\n+\t\t  // %d  The day of month as a decimal number.\n+\t\t  // %Od Locale's alternative representation.\n+\t\t  __out = _S_dd_zero_fill((unsigned)_S_day(__t),\n+\t\t\t\t\t  std::move(__out),\n+\t\t\t\t\t  __fc, __mod == 'O');\n+\t\t  break;\n+\t\tcase 'D':\n+\t\t  __out = _M_D(__t, std::move(__out), __fc);\n+\t\t  break;\n+\t\tcase 'e':\n+\t\t  __out = _M_e(__t, std::move(__out), __fc, __mod == 'O');\n+\t\t  break;\n+\t\tcase 'F':\n+\t\t  __out = _M_F(__t, std::move(__out), __fc);\n+\t\t  break;\n+\t\tcase 'g':\n+\t\tcase 'G':\n+\t\t  __out = _M_g_G(__t, std::move(__out), __fc, __c == 'G');\n+\t\t  break;\n+\t\tcase 'H':\n+\t\t  // %H  The hour (24-hour clock) as a decimal number.\n+\t\t  // %OH Locale's alternative representation.\n+\t\t  __out = _S_dd_zero_fill(_S_hms(__t).hours().count(),\n+\t\t\t\t\t  __print_sign(), __fc, __mod == 'O');\n+\t\t  break;\n+\t\tcase 'I':\n+\t\t  __out = _M_I(__t, __print_sign(), __fc, __mod == 'O');\n+\t\t  break;\n+\t\tcase 'j':\n+\t\t  __out = _M_j(__t, __print_sign(), __fc);\n+\t\t  break;\n+\t\tcase 'm':\n+\t\t  // %m  month as a decimal number.\n+\t\t  // %Om Locale's alternative representation.\n+\t\t  __out = _S_dd_zero_fill((unsigned)_S_month(__t),\n+\t\t\t\t\t  std::move(__out), __fc,\n+\t\t\t\t\t  __mod == 'O');\n+\t\t  break;\n+\t\tcase 'M':\n+\t\t  // %M  The minute as a decimal number.\n+\t\t  // %OM Locale's alternative representation.\n+\t\t  __out = _S_dd_zero_fill(_S_hms(__t).minutes().count(),\n+\t\t\t\t\t  __print_sign(), __fc, __mod == 'O');\n+\t\t  break;\n+\t\tcase 'p':\n+\t\t  __out = _M_p(__t, std::move(__out), __fc);\n+\t\t  break;\n+\t\tcase 'q':\n+\t\t  __out = _M_q(__t, std::move(__out), __fc);\n+\t\t  break;\n+\t\tcase 'Q':\n+\t\t  // %Q The duration's numeric value.\n+\t\t  if constexpr (chrono::__is_duration_v<_Tp>)\n+\t\t    __out = std::format_to(__print_sign(), _S_empty_spec,\n+\t\t\t\t\t   __t.count());\n+\t\t  else\n+\t\t    __throw_format_error(\"chrono format error: argument is \"\n+\t\t\t\t\t \"not a duration\");\n+\t\t  break;\n+\t\tcase 'r':\n+\t\t  __out = _M_r(__t, __print_sign(), __fc);\n+\t\t  break;\n+\t\tcase 'R':\n+\t\tcase 'T':\n+\t\t  __out = _M_R_T(__t, __print_sign(), __fc, __c == 'T');\n+\t\t  break;\n+\t\tcase 'S':\n+\t\t  __out = _M_S(__t, __print_sign(), __fc, __mod == 'O');\n+\t\t  break;\n+\t\tcase 'u':\n+\t\tcase 'w':\n+\t\t  __out = _M_u_w(__t, std::move(__out), __fc, __c, __mod == 'O');\n+\t\t  break;\n+\t\tcase 'U':\n+\t\tcase 'V':\n+\t\tcase 'W':\n+\t\t  __out = _M_U_V_W(__t, std::move(__out), __fc, __c,\n+\t\t\t\t   __mod == 'O');\n+\t\t  break;\n+\t\tcase 'x':\n+\t\t  __out = _M_x(__t, std::move(__out), __fc, __mod == 'E');\n+\t\t  break;\n+\t\tcase 'X':\n+\t\t  __out = _M_X(__t, __print_sign(), __fc, __mod == 'E');\n+\t\t  break;\n+\t\tcase 'z':\n+\t\t  __out = _M_z(__t, std::move(__out), __fc, (bool)__mod);\n+\t\t  break;\n+\t\tcase 'Z':\n+\t\t  __out = _M_Z(__t, std::move(__out), __fc);\n+\t\t  break;\n+\t\tcase 'n':\n+\t\t  *__out++ = __literals[0];\n+\t\t  break;\n+\t\tcase 't':\n+\t\t  *__out++ = __literals[1];\n+\t\t  break;\n+\t\tcase '%':\n+\t\t  *__out++ = __literals[2];\n+\t\t  break;\n+\t\tcase 'O':\n+\t\tcase 'E':\n+\t\t  __mod = __c;\n+\t\t  continue;\n+\t\tcase '}':\n+\t\t  __first = __last;\n+\t\t  break;\n+\t\t}\n+\t      __mod = _CharT();\n+\t      // Scan for next '%' and write out everything before it.\n+\t      __string_view __str(__first, __last - __first);\n+\t      size_t __pos = __str.find('%');\n+\t      if (__pos == 0)\n+\t\t++__first;\n+\t      else\n+\t\t{\n+\t\t  if (__pos == __str.npos)\n+\t\t    __first = __last;\n+\t\t  else\n+\t\t    {\n+\t\t      __str.remove_suffix(__str.length() - __pos);\n+\t\t      __first += __pos + 1;\n+\t\t    }\n+\t\t  __out = __format::__write(std::move(__out), __str);\n+\t\t}\n+\t    }\n+\t  while (__first != __last);\n+\n+\t  if constexpr (is_same_v<typename _FormatContext::iterator,\n+\t\t\t\t  _Sink_iter<_CharT>>)\n+\t    if (__write_direct)\n+\t      return __out;\n+\n+\t  auto __str = std::move(__sink).get();\n+\t  return __format::__write_padded_as_spec(__str, __str.size(),\n+\t\t\t\t\t\t  __fc, _M_spec);\n+\t}\n+\n+      _ChronoSpec<_CharT> _M_spec;\n+\n+    private:\n+      // Return the formatting locale.\n+      template<typename _FormatContext>\n+\tstd::locale\n+\t_M_locale(_FormatContext& __fc) const\n+\t{\n+\t  if (!_M_spec._M_localized)\n+\t    return std::locale::classic();\n+\t  else\n+\t    return __fc.locale();\n+\t}\n+\n+      // TODO: consider moving body of every operator<< into this function\n+      // and use std::format(\"{}\", t) to implement those operators. That\n+      // would avoid std::format(\"{}\", t) calling operator<< which calls\n+      // std::format again.\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_format_to_ostream(const _Tp& __t, _FormatContext& __fc,\n+\t\t\t     bool __is_neg) const\n+\t{\n+\t  using ::std::chrono::__detail::__utc_leap_second;\n+\t  using ::std::chrono::__detail::__local_time_fmt;\n+\n+\t  if constexpr (__is_specialization_of<_Tp, __local_time_fmt>)\n+\t    return _M_format_to_ostream(__t._M_time, __fc, false);\n+\t  else\n+\t    {\n+\t      basic_ostringstream<_CharT> __os;\n+\t      __os.imbue(_M_locale(__fc));\n+\n+\t      if constexpr (__is_specialization_of<_Tp, __utc_leap_second>)\n+\t\t__os << __t._M_date << ' ' << __t._M_time;\n+\t      else\n+\t\t{\n+\t\t  if (__is_neg) [[unlikely]]\n+\t\t    __os << _S_plus_minus[1];\n+\t\t  __os << __t;\n+\t\t}\n+\n+\t      auto __str = std::move(__os).str();\n+\t      return __format::__write_padded_as_spec(__str, __str.size(),\n+\t\t\t\t\t\t      __fc, _M_spec);\n+\t    }\n+\t}\n+\n+      static constexpr const _CharT* _S_chars\n+\t= _GLIBCXX_WIDEN(\"0123456789+-:/ {}\");\n+      static constexpr const _CharT* _S_plus_minus = _S_chars + 10;\n+      static constexpr _CharT _S_colon = _S_chars[12];\n+      static constexpr _CharT _S_slash = _S_chars[13];\n+      static constexpr _CharT _S_space = _S_chars[14];\n+      static constexpr const _CharT* _S_empty_spec = _S_chars + 15;\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_a_A(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t       _FormatContext& __ctx, bool __full) const\n+\t{\n+\t  // %a Locale's abbreviated weekday name.\n+\t  // %A Locale's full weekday name.\n+\t  chrono::weekday __wd = _S_weekday(__t);\n+\t  if (!__wd.ok())\n+\t    __throw_format_error(\"format error: invalid weekday\");\n+\n+\t  locale __loc = _M_locale(__ctx);\n+\t  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);\n+\t  const _CharT* __days[7];\n+\t  if (__full)\n+\t    __tp._M_days(__days);\n+\t  else\n+\t    __tp._M_days_abbreviated(__days);\n+\t  __string_view __str(__days[__wd.c_encoding()]);\n+\t  return __format::__write(std::move(__out), __str);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_b_B(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t       _FormatContext& __ctx, bool __full) const\n+\t{\n+\t  // %b Locale's abbreviated month name.\n+\t  // %B Locale's full month name.\n+\t  chrono::month __m = _S_month(__t);\n+\t  if (!__m.ok())\n+\t    __throw_format_error(\"format error: invalid month\");\n+\t  locale __loc = _M_locale(__ctx);\n+\t  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);\n+\t  const _CharT* __months[12];\n+\t  if (__full)\n+\t    __tp._M_months(__months);\n+\t  else\n+\t    __tp._M_months_abbreviated(__months);\n+\t  __string_view __str(__months[(unsigned)__m - 1]);\n+\t  return __format::__write(std::move(__out), __str);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_c(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __mod = false) const\n+\t{\n+\t  // %c  Locale's date and time representation.\n+\t  // %Ec Locale's alternate date and time representation.\n+\n+\t  locale __loc = _M_locale(__ctx);\n+\t  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);\n+\t  const _CharT* __formats[2];\n+\t  __tp._M_date_time_formats(__formats);\n+\t  const _CharT* __rep = __formats[__mod];\n+\t  if (!*__rep)\n+\t    __rep = _GLIBCXX_WIDEN(\"%a %b %e %H:%M:%S %Y\");\n+\t  basic_string<_CharT> __fmt(_S_empty_spec);\n+\t  __fmt.insert(1u, 1u, _S_colon);\n+\t  __fmt.insert(2u, __rep);\n+\t  return std::vformat_to(std::move(__out), __loc, __fmt,\n+\t\t\t\t std::make_format_args<_FormatContext>(__t));\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_C_y_Y(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t       _FormatContext& __ctx, char __conv, char __mod = 0) const\n+\t{\n+\t  // %C  Year divided by 100 using floored division.\n+\t  // %EC Locale's alternative preresentation of the century (era name).\n+\t  // %y  Last two decimal digits of the year.\n+\t  // %OY Locale's alternative represenation.\n+\t  // %Ey Locale's alternative representation of offset from %EC.\n+\t  // %Y  Year as a decimal number.\n+\t  // %EY Locale's alternative full year represenation.\n+\n+\t  chrono::year __y = _S_year(__t);\n+\n+\t  if (__mod == 'E')\n+\t    {\n+\t      // TODO: %EC, %Ey or %EY\n+\t      // return __out;\n+\t    }\n+\n+\t  basic_string<_CharT> __s;\n+\t  int __yi = (int)__y;\n+\t  const bool __is_neg = __yi < 0;\n+\t  __yi = __builtin_abs(__yi);\n+\n+\t  if (__conv == 'Y' || __conv == 'C')\n+\t    {\n+\t      if (__is_neg)\n+\t\t__s.assign(1, _S_plus_minus[1]);\n+\t      int __ci = __yi / 100;\n+\t      if (__ci >= 100) [[unlikely]]\n+\t\t{\n+\t\t  __s += std::format(_S_empty_spec, __ci / 100);\n+\t\t  __ci %= 100;\n+\t\t}\n+\t      __s += _S_two_digits(__ci);\n+\t    }\n+\n+\t  if (__conv == 'Y' || __conv == 'y')\n+\t    __s += _S_two_digits(__yi % 100);\n+\n+\t  if (__mod == 'O') // %OY\n+\t    _S_altnum(_M_locale(__ctx), __s, __is_neg);\n+\n+\t  return __format::__write(std::move(__out), __string_view(__s));\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_D(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext&) const\n+\t{\n+\t  auto __ymd = _S_date(__t);\n+\t  basic_string<_CharT> __s;\n+#if ! _GLIBCXX_USE_CXX11_ABI\n+\t  __s.reserve(8);\n+#endif\n+\t  __s = _S_two_digits((unsigned)__ymd.month());\n+\t  __s += _S_slash;\n+\t  __s += _S_two_digits((unsigned)__ymd.day());\n+\t  __s += _S_slash;\n+\t  __s += _S_two_digits(__builtin_abs((int)__ymd.year()) % 100);\n+\t  return __format::__write(std::move(__out), __string_view(__s));\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_e(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __mod = false) const\n+\t{\n+\t  // %e  Day of month as decimal number, padded with space.\n+\t  // %Oe Locale's alternative digits.\n+\t  chrono::day __d = _S_day(__t);\n+\t  unsigned __i = (unsigned)__d;\n+\t  auto __sv = _S_two_digits(__i);\n+\t  basic_string<_CharT> __s;\n+\t  if (__mod)\n+\t    __sv = _S_altnum(_M_locale(__ctx), __s.assign(__sv));\n+\t  if (__i < 10)\n+\t    __sv = __s = {_S_space, __sv[1]};\n+\t  return __format::__write(std::move(__out), __sv);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_F(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext&) const\n+\t{\n+\t  auto __ymd = _S_date(__t);\n+\t  basic_string<_CharT> __s;\n+#if ! _GLIBCXX_USE_CXX11_ABI\n+\t  __s.reserve(11);\n+#endif\n+\t  __s += std::format(_GLIBCXX_WIDEN(\"{:04d}-  -  \"), (int)__ymd.year());\n+\t  auto __sv = _S_two_digits((unsigned)__ymd.month());\n+\t  __s[__s.size() - 5] = __sv[0];\n+\t  __s[__s.size() - 4] = __sv[1];\n+\t  __sv = _S_two_digits((unsigned)__ymd.day());\n+\t  __s[__s.size() - 2] = __sv[0];\n+\t  __s[__s.size() - 1] = __sv[1];\n+\t  __sv = __s;\n+\t  return __format::__write(std::move(__out), __sv);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_g_G(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __full) const\n+\t{\n+\t  // %g last two decimal digits of the ISO week-based year.\n+\t  // %G ISO week-based year.\n+\t  using namespace chrono;\n+\t  auto __d = _S_days(__t);\n+\t  // Move to nearest Thursday:\n+\t  __d -= (weekday(__d) - Monday) - days(3);\n+\t  // ISO week-based year is the year that contains that Thursday:\n+\t  year __y = year_month_day(__d).year();\n+\t  return _M_C_y_Y(__y, std::move(__out), __ctx, \"yY\"[__full]);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_I(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __mod = false) const\n+\t{\n+\t  auto __hms = _S_hms(__t);\n+\t  int __i = __hms.hours().count();\n+\t  if (__i == 0)\n+\t    __i = 12;\n+\t  else if (__i > 12)\n+\t    __i -= 12;\n+\t  auto __sv = _S_two_digits(__i);\n+\t  basic_string<_CharT> __s;\n+\t  if (__mod)\n+\t    __sv = _S_altnum(_M_locale(__ctx), __s.assign(__sv));\n+\t  return __format::__write(std::move(__out), __sv);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_j(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx) const\n+\t{\n+\t  if constexpr (chrono::__is_duration_v<_Tp>)\n+\t    {\n+\t      // Decimal number of days, without padding.\n+\t      unsigned __d = chrono::duration_cast<chrono::days>(__t).count();\n+\t      return std::format_to(std::move(__out), _S_empty_spec, __d);\n+\t    }\n+\t  else\n+\t    {\n+\t      // Day of the year as a decimal number, padding with zero.\n+\t      using namespace chrono;\n+\t      auto __day = _S_days(__t);\n+\t      auto __ymd = _S_date(__t);\n+\t      days __d;\n+\t      // See \"Calculating Ordinal Dates\" at\n+\t      // https://github.com/HowardHinnant/date/wiki/Examples-and-Recipes\n+\t      if constexpr (is_same_v<typename decltype(__day)::clock, local_t>)\n+\t\t__d = __day - local_days(__ymd.year()/January/0);\n+\t      else\n+\t\t__d = __day - sys_days(__ymd.year()/January/0);\n+\t      return std::format_to(std::move(__out), _GLIBCXX_WIDEN(\"{:03d}\"),\n+\t\t\t\t    __d.count());\n+\t    }\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_p(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx) const\n+\t{\n+\t  // %p The locale's equivalent of the AM/PM designations.\n+\t  auto __hms = _S_hms(__t);\n+\t  locale __loc = _M_locale(__ctx);\n+\t  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);\n+\t  const _CharT* __ampm[2];\n+\t  __tp._M_am_pm(__ampm);\n+\t  return std::format_to(std::move(__out), _S_empty_spec,\n+\t\t\t\t__ampm[__hms.hours().count() >= 12]);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_q(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx) const\n+\t{\n+\t  // %q The duration's unit suffix\n+\t  if constexpr (!chrono::__is_duration_v<_Tp>)\n+\t    __throw_format_error(\"format error: argument is not a duration\");\n+\t  else\n+\t    {\n+\t      using period = typename _Tp::period;\n+\t      char __buf[sizeof(\"[/]s\") + 2 * numeric_limits<intmax_t>::digits10];\n+\t      constexpr size_t __n = sizeof(__buf);\n+\t      auto __s = chrono::__detail::__units_suffix<period, _CharT>(__buf,\n+\t\t\t\t\t\t\t\t\t  __n);\n+\t      if constexpr (is_same_v<decltype(__s), const _CharT*>)\n+\t\treturn std::format_to(std::move(__out), _S_empty_spec, __s);\n+\t      else\n+\t\t{\n+\t\t  // Suffix was written to __buf as narrow string.\n+\t\t  _CharT __wbuf[__n];\n+\t\t  size_t __len = __builtin_strlen(__buf);\n+\t\t  locale __loc = _M_locale(__ctx);\n+\t\t  auto& __ct = use_facet<ctype<_CharT>>(__loc);\n+\t\t  __ct.widen(__buf, __len, __wbuf);\n+\t\t  __wbuf[__len] = 0;\n+\t\t  return std::format_to(std::move(__out), _S_empty_spec,\n+\t\t\t\t\t__wbuf);\n+\t\t}\n+\t    }\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_r(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx) const\n+\t{\n+\t  // %r locale's 12-hour clock time.\n+\t  locale __loc = _M_locale(__ctx);\n+\t  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);\n+\t  const _CharT* __ampm_fmt;\n+\t  __tp._M_am_pm_format(&__ampm_fmt);\n+\t  basic_string<_CharT> __fmt(_S_empty_spec);\n+\t  __fmt.insert(1u, 1u, _S_colon);\n+\t  __fmt.insert(2u, __ampm_fmt);\n+\t  return std::vformat_to(std::move(__out), __fmt,\n+\t\t\t\t std::make_format_args<_FormatContext>(__t));\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_R_T(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t       _FormatContext& __ctx, bool __secs) const\n+\t{\n+\t  // %R Equivalent to %H:%M\n+\t  // %T Equivalent to %H:%M:%S\n+\t  auto __hms = _S_hms(__t);\n+\n+\t  basic_string<_CharT> __s;\n+#if ! _GLIBCXX_USE_CXX11_ABI\n+\t  __s.reserve(11);\n+#endif\n+\t  __s = std::format(_GLIBCXX_WIDEN(\"{:02d}:00\"), __hms.hours().count());\n+\t  auto __sv = _S_two_digits(__hms.minutes().count());\n+\t  __s[__s.size() - 2] = __sv[0];\n+\t  __s[__s.size() - 1] = __sv[1];\n+\t  __sv = __s;\n+\t  __out = __format::__write(std::move(__out), __sv);\n+\t  if (__secs)\n+\t    {\n+\t      *__out++ = _S_colon;\n+\t      __out = _M_S(__hms, std::move(__out), __ctx);\n+\t    }\n+\t  return __out;\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_S(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __mod = false) const\n+\t{\n+\t  // %S  Seconds as a decimal number.\n+\t  // %OS (TODO) The locale's alternative representation.\n+\t  auto __hms = _S_hms(__t);\n+\t  __out = _S_dd_zero_fill(__hms.seconds().count(),\n+\t\t\t\t  std::move(__out), __ctx, __mod);\n+\t  using rep = typename decltype(__hms)::precision::rep;\n+\t  if constexpr (__hms.fractional_width != 0)\n+\t    {\n+\t      locale __loc = _M_locale(__ctx);\n+\t      auto __ss = __hms.subseconds();\n+\t      if constexpr (is_floating_point_v<rep>)\n+\t\t{\n+\t\t  __out = std::format_to(__loc, std::move(__out),\n+\t\t\t\t\t _GLIBCXX_WIDEN(\"{:.{}Lg}\"),\n+\t\t\t\t\t __ss.count(),\n+\t\t\t\t\t __hms.fractional_width);\n+\t\t}\n+\t      else if constexpr (is_integral_v<rep>)\n+\t\t{\n+\t\t  const auto& __np\n+\t\t    = use_facet<numpunct<_CharT>>(__loc);\n+\t\t  __out = std::format_to(std::move(__out),\n+\t\t\t\t\t _GLIBCXX_WIDEN(\"{}{:0{}}\"),\n+\t\t\t\t\t __np.decimal_point(),\n+\t\t\t\t\t __ss.count(),\n+\t\t\t\t\t __hms.fractional_width);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  const auto& __np\n+\t\t    = use_facet<numpunct<_CharT>>(__loc);\n+\t\t  *__out++ = __np.decimal_point();\n+\t\t  auto __str = std::format(_S_empty_spec, __ss.count());\n+\t\t  __out = std::format_to(_GLIBCXX_WIDEN(\"{:0>{}s}\"),\n+\t\t\t\t\t\t\t__str,\n+\t\t\t\t\t\t\t__hms.fractional_width);\n+\t\t}\n+\t    }\n+\t  return __out;\n+\t}\n+\n+      // %t handled in _M_format\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_u_w(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t       _FormatContext& __ctx, _CharT __conv, bool __mod = false) const\n+\t{\n+\t  // %u  ISO weekday as a decimal number (1-7), where Monday is 1.\n+\t  // %Ou Locale's alternative numeric rep.\n+\t  // %w  Weekday as a decimal number (0-6), where Sunday is 0.\n+\t  // %Ow Locale's alternative numeric rep.\n+\t  chrono::weekday __wd = _S_weekday(__t);\n+\t  unsigned __wdi = __conv == 'u' ? __wd.iso_encoding()\n+\t\t\t\t\t : __wd.c_encoding();\n+\t  basic_string<_CharT> __s(1, _S_digit(__wdi));\n+\t  if (__mod)\n+\t    _S_altnum(_M_locale(__ctx), __s);\n+\t  return __format::__write(std::move(__out), __string_view(__s));\n+\t  return __out;\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_U_V_W(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t\t _FormatContext& __ctx, _CharT __conv, bool __mod = false) const\n+\t{\n+\t  // %U  Week number of the year as a decimal number, from first Sunday.\n+\t  // %OU Locale's alternative numeric rep.\n+\t  // %V  ISO week-based week number as a decimal number.\n+\t  // %OV Locale's alternative numeric rep.\n+\t  // %W  Week number of the year as a decimal number, from first Monday.\n+\t  // %OW Locale's alternative numeric rep.\n+\t  using namespace chrono;\n+\t  auto __d = _S_days(__t);\n+\t  using _TDays = decltype(__d); // Either sys_days or local_days.\n+\n+\t  _TDays __first; // First day of week 1.\n+\t  if (__conv == 'V') // W01 begins on Monday before first Thursday.\n+\t    {\n+\t      // Move to nearest Thursday:\n+\t      __d -= (weekday(__d) - Monday) - days(3);\n+\t      // ISO week of __t is number of weeks since January 1 of the\n+\t      // same year as that nearest Thursday.\n+\t      __first = _TDays(year_month_day(__d).year()/January/1);\n+\t    }\n+\t  else\n+\t    {\n+\t      year __y;\n+\t      if constexpr (requires { __t.year(); })\n+\t\t__y = __t.year();\n+\t      else\n+\t\t__y = year_month_day(__d).year();\n+\t      const weekday __weekstart = __conv == 'U' ? Sunday : Monday;\n+\t      __first = _TDays(__y/January/__weekstart[1]);\n+\t    }\n+\t  auto __weeks = chrono::floor<weeks>(__d - __first);\n+\t  __string_view __sv = _S_two_digits(__weeks.count() + 1);\n+\t  basic_string<_CharT> __s;\n+\t  if (__mod)\n+\t    __sv = _S_altnum(_M_locale(__ctx), __s.assign(__sv));\n+\t  return __format::__write(std::move(__out), __sv);\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_x(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __mod = false) const\n+\t{\n+\t  // %x  Locale's date rep\n+\t  // %Ex Locale's alternative date representation.\n+\t  locale __loc = _M_locale(__ctx);\n+\t  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);\n+\t  const _CharT* __date_reps[2];\n+\t  __tp._M_date_formats(__date_reps);\n+\t  const _CharT* __rep = __date_reps[__mod];\n+\t  if (!*__rep)\n+\t    return _M_D(__t, std::move(__out), __ctx);\n+\n+\t  basic_string<_CharT> __fmt(_S_empty_spec);\n+\t  __fmt.insert(1u, 1u, _S_colon);\n+\t  __fmt.insert(2u, __rep);\n+\t  return std::vformat_to(std::move(__out), __fmt,\n+\t\t\t\t std::make_format_args<_FormatContext>(__t));\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_X(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __mod = false) const\n+\t{\n+\t  // %X  Locale's time rep\n+\t  // %EX Locale's alternative time representation.\n+\t  locale __loc = _M_locale(__ctx);\n+\t  const auto& __tp = use_facet<__timepunct<_CharT>>(__loc);\n+\t  const _CharT* __time_reps[2];\n+\t  __tp._M_time_formats(__time_reps);\n+\t  const _CharT* __rep = __time_reps[__mod];\n+\t  if (!*__rep)\n+\t    return _M_R_T(__t, std::move(__out), __ctx, true);\n+\n+\t  basic_string<_CharT> __fmt(_S_empty_spec);\n+\t  __fmt.insert(1u, 1u, _S_colon);\n+\t  __fmt.insert(2u, __rep);\n+\t  return std::vformat_to(std::move(__out), __fmt,\n+\t\t\t\t std::make_format_args<_FormatContext>(__t));\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_z(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx, bool __mod = false) const\n+\t{\n+\t  using ::std::chrono::__detail::__utc_leap_second;\n+\t  using ::std::chrono::__detail::__local_time_fmt;\n+\n+\t  auto __utc = __mod ? __string_view(_GLIBCXX_WIDEN(\"+00:00\"), 6)\n+\t\t\t     : __string_view(_GLIBCXX_WIDEN(\"+0000\"), 5);\n+\n+\t  if constexpr (chrono::__is_time_point_v<_Tp>)\n+\t    {\n+\t      if constexpr (is_same_v<typename _Tp::clock,\n+\t\t\t\t      chrono::system_clock>)\n+\t\treturn __format::__write(std::move(__out), __utc);\n+\t    }\n+\t  else if constexpr (__is_specialization_of<_Tp, __local_time_fmt>)\n+\t    {\n+\t      if (__t._M_offset_sec)\n+\t\t{\n+\t\t  auto __sv = __utc;\n+\t\t  basic_string<_CharT> __s;\n+\t\t  if (*__t._M_offset_sec != 0s)\n+\t\t    {\n+\t\t      chrono:: hh_mm_ss __hms(*__t._M_offset_sec);\n+\t\t      __s = _S_plus_minus[__hms.is_negative()];\n+\t\t      __s += _S_two_digits(__hms.hours().count());\n+\t\t      if (__mod)\n+\t\t\t__s += _S_colon;\n+\t\t      __s += _S_two_digits(__hms.minutes().count());\n+\t\t      __sv = __s;\n+\t\t    }\n+\t\t  return __format::__write(std::move(__out), __sv);\n+\t\t}\n+\t    }\n+\t  else if constexpr (__is_specialization_of<_Tp, __utc_leap_second>)\n+\t    return __format::__write(std::move(__out), __utc);\n+\n+\t  __no_timezone_available();\n+\t}\n+\n+      template<typename _Tp, typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_M_Z(const _Tp& __t, typename _FormatContext::iterator __out,\n+\t     _FormatContext& __ctx) const\n+\t{\n+\t  using ::std::chrono::__detail::__utc_leap_second;\n+\t  using ::std::chrono::__detail::__local_time_fmt;\n+\n+\t  __string_view __utc(_GLIBCXX_WIDEN(\"UTC\"), 3);\n+\t  if constexpr (chrono::__is_time_point_v<_Tp>)\n+\t    {\n+\t      if constexpr (is_same_v<typename _Tp::clock,\n+\t\t\t\t      chrono::system_clock>)\n+\t\treturn __format::__write(std::move(__out), __utc);\n+\t    }\n+\t  else if constexpr (__is_specialization_of<_Tp, __local_time_fmt>)\n+\t    {\n+\t      if (__t._M_abbrev)\n+\t\t{\n+\t\t  __string_view __wsv;\n+\t\t  if constexpr (is_same_v<_CharT, char>)\n+\t\t    __wsv = *__t._M_abbrev;\n+\t\t  else\n+\t\t    {\n+\t\t      string_view __sv = *__t._M_abbrev;\n+\t\t      basic_string<_CharT> __ws(__sv.size());\n+\t\t      auto& __ct = use_facet<ctype<_CharT>>(_M_locale(__ctx));\n+\t\t      __ct.widen(__sv.data(), __sv.size(), __ws.data());\n+\t\t      __wsv = __ws;\n+\t\t    }\n+\t\t  return __format::__write(std::move(__out), __wsv);\n+\t\t}\n+\t    }\n+\t  else if constexpr (__is_specialization_of<_Tp, __utc_leap_second>)\n+\t    return __format::__write(std::move(__out), __utc);\n+\n+\t  __no_timezone_available();\n+\t}\n+\n+      // %% handled in _M_format\n+\n+      // A single digit character in the range '0'..'9'.\n+      static _CharT\n+      _S_digit(int __n) noexcept\n+      {\n+\t// Extra 9s avoid past-the-end read on bad input.\n+\treturn _GLIBCXX_WIDEN(\"0123456789999999\")[__n & 0xf];\n+      }\n+\n+      // A string view of two digit characters, \"00\"..\"99\".\n+      static basic_string_view<_CharT>\n+      _S_two_digits(int __n) noexcept\n+      {\n+\treturn {\n+\t  _GLIBCXX_WIDEN(\"0001020304050607080910111213141516171819\"\n+\t\t\t \"2021222324252627282930313233343536373839\"\n+\t\t\t \"4041424344454647484950515253545556575859\"\n+\t\t\t \"6061626364656667686970717273747576777879\"\n+\t\t\t \"8081828384858687888990919293949596979899\"\n+\t\t\t \"9999999999999999999999999999999999999999\"\n+\t\t\t \"9999999999999999\") + 2 * (__n & 0x7f),\n+\t  2\n+\t};\n+      }\n+\n+      // Convert a numeric string to the locale's alternative numeric symbols.\n+      static basic_string_view<_CharT>\n+      _S_altnum(const locale& __loc, basic_string<_CharT>& __s,\n+\t\tbool __is_neg = false)\n+      {\n+\tif (__loc == locale::classic())\n+\t  return __s;\n+\n+#if 0 // TODO how can we access numpunct_cache?! Need to go via std::time_put?\n+\tauto& __np = use_facet<__numpunct_cache<_CharT>>(__loc);\n+\tauto __nums = __np._M_atoms_out; // alts for \"-+xX01234...\"\n+\tif (__is_neg)\n+\t  __s[0] = __nums[0];\n+\t__nums += 4; // now points to alternate digits\n+\tfor (int __i = __is_neg; __i < __s.size(); ++__i)\n+\t  __s[__i] = __nums[__s[__i] - '0'];\n+#endif\n+\treturn __s;\n+      }\n+\n+      // Write two digits, zero-filled.\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\t_S_dd_zero_fill(int __val, typename _FormatContext::iterator __out,\n+\t\t\t_FormatContext& __ctx, bool __alt_num) const\n+\t{\n+\t  auto __sv = _S_two_digits(__val);\n+\t  basic_string<_CharT> __s;\n+\t  if (__alt_num)\n+\t    __sv = _S_altnum(_M_locale(__ctx), __s.assign(__sv));\n+\t  return __format::__write(std::move(__out), __sv);\n+\t}\n+\n+      // Accessors for the components of chrono types:\n+\n+      // Returns a hh_mm_ss.\n+      template<typename _Tp>\n+\tstatic decltype(auto)\n+\t_S_hms(const _Tp& __t)\n+\t{\n+\t  using ::std::chrono::__detail::__utc_leap_second;\n+\t  using ::std::chrono::__detail::__local_time_fmt;\n+\n+\t  if constexpr (__is_specialization_of<_Tp, chrono::hh_mm_ss>)\n+\t    return __t;\n+\t  else if constexpr (__is_specialization_of<_Tp, __utc_leap_second>)\n+\t    return __t._M_time;\n+\t  else if constexpr (chrono::__is_duration_v<_Tp>)\n+\t    return chrono::hh_mm_ss<_Tp>(__t);\n+\t  else if constexpr (chrono::__is_time_point_v<_Tp>)\n+\t    return chrono::hh_mm_ss(__t - chrono::floor<chrono::days>(__t));\n+\t  else if constexpr (__is_specialization_of<_Tp, __local_time_fmt>)\n+\t    return _S_hms(__t._M_time);\n+\t  else\n+\t    {\n+\t      __invalid_chrono_spec();\n+\t      return chrono::hh_mm_ss<chrono::seconds>();\n+\t    }\n+\t}\n+\n+      // Returns a sys_days or local_days.\n+      template<typename _Tp>\n+\tstatic auto\n+\t_S_days(const _Tp& __t)\n+\t{\n+\t  using namespace chrono;\n+\t  using ::std::chrono::__detail::__utc_leap_second;\n+\t  using ::std::chrono::__detail::__local_time_fmt;\n+\n+\t  if constexpr (__is_time_point_v<_Tp>)\n+\t    return chrono::floor<days>(__t);\n+\t  else if constexpr (__is_specialization_of<_Tp, __utc_leap_second>)\n+\t    return __t._M_date;\n+\t  else if constexpr (__is_specialization_of<_Tp, __local_time_fmt>)\n+\t    return chrono::floor<days>(__t._M_time);\n+\t  else if constexpr (is_same_v<_Tp, year_month_day>\n+\t\t\t       || is_same_v<_Tp, year_month_day_last>\n+\t\t\t       || is_same_v<_Tp, year_month_weekday>\n+\t\t\t       || is_same_v<_Tp, year_month_weekday_last>)\n+\t    return sys_days(__t);\n+\t  else\n+\t    {\n+\t      if constexpr (__is_duration_v<_Tp>)\n+\t\t__not_valid_for_duration();\n+\t      else\n+\t\t__invalid_chrono_spec();\n+\t      return chrono::sys_days();\n+\t    }\n+\t}\n+\n+      // Returns a year_month_day.\n+      template<typename _Tp>\n+\tstatic chrono::year_month_day\n+\t_S_date(const _Tp& __t)\n+\t{\n+\t  if constexpr (is_same_v<_Tp, chrono::year_month_day>)\n+\t    return __t;\n+\t  else\n+\t    return chrono::year_month_day(_S_days(__t));\n+\t}\n+\n+      template<typename _Tp>\n+\tstatic chrono::day\n+\t_S_day(const _Tp& __t)\n+\t{\n+\t  using namespace chrono;\n+\n+\t  if constexpr (is_same_v<_Tp, day>)\n+\t    return __t;\n+\t  else if constexpr (requires { __t.day(); })\n+\t    return __t.day();\n+\t  else\n+\t    return _S_date(__t).day();\n+\t}\n+\n+      template<typename _Tp>\n+\tstatic chrono::month\n+\t_S_month(const _Tp& __t)\n+\t{\n+\t  using namespace chrono;\n+\n+\t  if constexpr (is_same_v<_Tp, month>)\n+\t    return __t;\n+\t  else if constexpr (requires { __t.month(); })\n+\t    return __t.month();\n+\t  else\n+\t    return _S_date(__t).month();\n+\t}\n+\n+      template<typename _Tp>\n+\tstatic chrono::year\n+\t_S_year(const _Tp& __t)\n+\t{\n+\t  using namespace chrono;\n+\n+\t  if constexpr (is_same_v<_Tp, year>)\n+\t    return __t;\n+\t  else if constexpr (requires { __t.year(); })\n+\t    return __t.year();\n+\t  else\n+\t    return _S_date(__t).year();\n+\t}\n+\n+      template<typename _Tp>\n+\tstatic chrono::weekday\n+\t_S_weekday(const _Tp& __t)\n+\t{\n+\t  using namespace ::std::chrono;\n+\t  using ::std::chrono::__detail::__local_time_fmt;\n+\n+\t  if constexpr (is_same_v<_Tp, weekday>)\n+\t    return __t;\n+\t  else if constexpr (requires { __t.weekday(); })\n+\t    return __t.weekday();\n+\t  else if constexpr (is_same_v<_Tp, month_weekday>)\n+\t    return __t.weekday_indexed().weekday();\n+\t  else if constexpr (is_same_v<_Tp, month_weekday_last>)\n+\t    return __t.weekday_last().weekday();\n+\t  else\n+\t    return weekday(_S_days(__t));\n+\t}\n+    };\n+\n+} // namespace __format\n+/// @endcond\n+\n+  template<typename _Rep, typename _Period, typename _CharT>\n+    struct formatter<chrono::duration<_Rep, _Period>, _CharT>\n+    {\n+      constexpr typename basic_format_parse_context<_CharT>::iterator\n+      parse(basic_format_parse_context<_CharT>& __pc)\n+      {\n+\tusing namespace __format;\n+\tauto __it = _M_f._M_parse(__pc, _Duration|_TimeOfDay);\n+\tif constexpr (!is_floating_point_v<_Rep>)\n+\t  if (_M_f._M_spec._M_prec_kind != __format::_WP_none)\n+\t    __throw_format_error(\"format error: invalid precision for duration\");\n+\treturn __it;\n+      }\n+\n+      template<typename _Out>\n+\ttypename basic_format_context<_Out, _CharT>::iterator\n+\tformat(const chrono::duration<_Rep, _Period>& __d,\n+\t       basic_format_context<_Out, _CharT>& __fc) const\n+\t{\n+\t  return _M_f._M_format(chrono::abs(__d), __fc, __d < __d.zero());\n+\t}\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::day, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Day); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::day& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::month, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Month); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::month& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::year, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Year); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::year& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::weekday, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Weekday); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::weekday& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::weekday_indexed, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Weekday); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::weekday_indexed& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::weekday_last, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Weekday); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::weekday_last& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::month_day, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Month|__format::_Day); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::month_day& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::month_day_last, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Month|__format::_Day); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::month_day_last& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::month_weekday, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Month|__format::_Weekday); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::month_weekday& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::month_weekday_last, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Month|__format::_Weekday); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::month_weekday_last& __t,\n+\t       _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::year_month, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Year|__format::_Month); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::year_month& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::year_month_day, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Date); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::year_month_day& __t, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::year_month_day_last, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Date); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::year_month_day_last& __t,\n+\t       _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::year_month_weekday, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Date); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::year_month_weekday& __t,\n+\t       _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::year_month_weekday_last, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_Date); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::year_month_weekday_last& __t,\n+\t       _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _Rep, typename _Period, typename _CharT>\n+    struct formatter<chrono::hh_mm_ss<chrono::duration<_Rep, _Period>>, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_TimeOfDay); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::hh_mm_ss<chrono::duration<_Rep, _Period>>& __t,\n+\t       _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+#if _GLIBCXX_USE_CXX11_ABI || ! _GLIBCXX_USE_DUAL_ABI\n+  template<typename _CharT>\n+    struct formatter<chrono::sys_info, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ChronoParts{}); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::sys_info& __i, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__i, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _CharT>\n+    struct formatter<chrono::local_info, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ChronoParts{}); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::local_info& __i, _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__i, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+#endif\n+\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::sys_time<_Duration>, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ZonedDateTime); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::sys_time<_Duration>& __t,\n+\t       _FormatContext& __fc) const\n+\t{ return _M_f._M_format(__t, __fc); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::utc_time<_Duration>, _CharT>\n+    : __format::__formatter_chrono<_CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ZonedDateTime); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::utc_time<_Duration>& __t,\n+\t       _FormatContext& __fc) const\n+\t{\n+\t  // Adjust by removing leap seconds to get equivalent sys_time.\n+\t  // We can't just use clock_cast because we want to know if the time\n+\t  // falls within a leap second insertion, and format seconds as \"60\".\n+\t  using chrono::__detail::__utc_leap_second;\n+\t  using chrono::seconds;\n+\t  using chrono::sys_time;\n+\t  using _CDur = common_type_t<_Duration, seconds>;\n+\t  const auto __li = chrono::get_leap_second_info(__t);\n+\t  sys_time<_CDur> __s{__t.time_since_epoch() - __li.elapsed};\n+\t  if (!__li.is_leap_second) [[likely]]\n+\t    return _M_f._M_format(__s, __fc);\n+\t  else\n+\t    return _M_f._M_format(__utc_leap_second(__s), __fc);\n+\t}\n+\n+    private:\n+      friend formatter<chrono::__detail::__utc_leap_second<_Duration>, _CharT>;\n+\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::tai_time<_Duration>, _CharT>\n+    : __format::__formatter_chrono<_CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ZonedDateTime); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::tai_time<_Duration>& __t,\n+\t       _FormatContext& __fc) const\n+\t{\n+\t  // Convert to __local_time_fmt with abbrev \"TAI\" and offset 0s.\n+\n+\t  // Offset is 1970y/January/1 - 1958y/January/1\n+\t  constexpr chrono::days __tai_offset = chrono::days(4383);\n+\t  using _CDur = common_type_t<_Duration, chrono::days>;\n+\t  chrono::local_time<_CDur> __lt(__t.time_since_epoch() - __tai_offset);\n+\t  const string __abbrev(\"TAI\", 3);\n+\t  const chrono::seconds __off = 0s;\n+\t  const auto __lf = chrono::local_time_format(__lt, &__abbrev, &__off);\n+\t  return _M_f._M_format(__lf, __fc);\n+\t}\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::gps_time<_Duration>, _CharT>\n+    : __format::__formatter_chrono<_CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ZonedDateTime); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::gps_time<_Duration>& __t,\n+\t       _FormatContext& __fc) const\n+\t{\n+\t  // Convert to __local_time_fmt with abbrev \"GPS\" and offset 0s.\n+\n+\t  // Offset is 1980y/January/Sunday[1] - 1970y/January/1\n+\t  constexpr chrono::days __gps_offset = chrono::days(3657);\n+\t  using _CDur = common_type_t<_Duration, chrono::days>;\n+\t  chrono::local_time<_CDur> __lt(__t.time_since_epoch() + __gps_offset);\n+\t  const string __abbrev(\"GPS\", 3);\n+\t  const chrono::seconds __off = 0s;\n+\t  const auto __lf = chrono::local_time_format(__lt, &__abbrev, &__off);\n+\t  return _M_f._M_format(__lf, __fc);\n+\t}\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::file_time<_Duration>, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ZonedDateTime); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::file_time<_Duration>& __t,\n+\t       _FormatContext& __ctx) const\n+\t{\n+\t  using namespace chrono;\n+\t  return _M_f._M_format(chrono::clock_cast<system_clock>(__t), __ctx);\n+\t}\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::local_time<_Duration>, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_DateTime); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::local_time<_Duration>& __t,\n+\t       _FormatContext& __ctx) const\n+\t{ return _M_f._M_format(__t, __ctx); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::__detail::__local_time_fmt<_Duration>, _CharT>\n+    {\n+      template<typename _ParseContext>\n+\tconstexpr typename _ParseContext::iterator\n+\tparse(_ParseContext& __pc)\n+\t{ return _M_f._M_parse(__pc, __format::_ZonedDateTime); }\n+\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::__detail::__local_time_fmt<_Duration>& __t,\n+\t       _FormatContext& __ctx) const\n+\t{ return _M_f._M_format(__t, __ctx); }\n+\n+    private:\n+      __format::__formatter_chrono<_CharT> _M_f;\n+    };\n+\n+#if _GLIBCXX_USE_CXX11_ABI || ! _GLIBCXX_USE_DUAL_ABI\n+  template<typename _Duration, typename _TimeZonePtr, typename _CharT>\n+    struct formatter<chrono::zoned_time<_Duration, _TimeZonePtr>, _CharT>\n+    : formatter<chrono::__detail::__local_time_fmt<_Duration>, _CharT>\n+    {\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::zoned_time<_Duration, _TimeZonePtr>& __tp,\n+\t       _FormatContext& __ctx) const\n+\t{\n+\t  using chrono::__detail::__local_time_fmt;\n+\t  using _Base = formatter<__local_time_fmt<_Duration>, _CharT>;\n+\t  const chrono::sys_info __info = __tp.get_info();\n+\t  const auto __lf = chrono::local_time_format(__tp.get_local_time(),\n+\t\t\t\t\t\t      &__info.abbrev,\n+\t\t\t\t\t\t      &__info.offset);\n+\t  return _Base::format(__lf, __ctx);\n+\t}\n+    };\n+#endif\n+\n+  // Partial specialization needed for %c formatting of __utc_leap_second.\n+  template<typename _Duration, typename _CharT>\n+    struct formatter<chrono::__detail::__utc_leap_second<_Duration>, _CharT>\n+    : formatter<chrono::utc_time<_Duration>, _CharT>\n+    {\n+      template<typename _FormatContext>\n+\ttypename _FormatContext::iterator\n+\tformat(const chrono::__detail::__utc_leap_second<_Duration>& __t,\n+\t       _FormatContext& __fc) const\n+\t{ return this->_M_f._M_format(__t, __fc); }\n+    };\n+\n+namespace chrono\n+{\n+/// @addtogroup chrono\n+/// @{\n+\n+  // TODO: from_stream for duration\n+#if 0\n+  template<typename _CharT, typename _Traits, typename _Rep, typename _Period,\n+\t   typename _Alloc = allocator<_CharT>>\n+    basic_istream<_CharT, _Traits>&\n+    from_stream(basic_istream<_CharT, _Traits>& __is, const _CharT* __fmt,\n+\t\tduration<_Rep, _Period>& __d,\n+\t\tbasic_string<_CharT, _Traits, _Alloc>* __abbrev = nullptr,\n+\t\tminutes* __offset = nullptr)\n+    {\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const day& __d)\n+    {\n+      using _Ctx = __conditional_t<is_same_v<_CharT, char>,\n+\t\t\t\t   format_context, wformat_context>;\n+      using _Str = basic_string_view<_CharT>;\n+      _Str __s = _GLIBCXX_WIDEN(\"{:02d} is not a valid day\");\n+      if (__d.ok())\n+\t__s = __s.substr(0, 6);\n+      __os << std::vformat(__s, make_format_args<_Ctx>((unsigned)__d));\n+      return __os;\n+    }\n+\n+  // TODO from_stream for day\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const month& __m)\n+    {\n+      using _Ctx = __conditional_t<is_same_v<_CharT, char>,\n+\t\t\t\t   format_context, wformat_context>;\n+      using _Str = basic_string_view<_CharT>;\n+      _Str __s = _GLIBCXX_WIDEN(\"{:L%b}{} is not a valid month\");\n+      if (__m.ok())\n+\t__os << std::vformat(__os.getloc(), __s.substr(0, 6),\n+\t\t\t     make_format_args<_Ctx>(__m));\n+      else\n+\t__os << std::vformat(__s.substr(6),\n+\t\t\t     make_format_args<_Ctx>((unsigned)__m));\n+      return __os;\n+    }\n+\n+  // TODO from_stream for month\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const year& __y)\n+    {\n+      using _Ctx = __conditional_t<is_same_v<_CharT, char>,\n+\t\t\t\t   format_context, wformat_context>;\n+      using _Str = basic_string_view<_CharT>;\n+      _Str __s = _GLIBCXX_WIDEN(\"-{:04d} is not a valid year\");\n+      if (__y.ok())\n+\t__s = __s.substr(0, 7);\n+      int __i = (int)__y;\n+      if (__i >= 0) [[likely]]\n+\t__s.remove_prefix(1);\n+      else\n+\t__i = -__i;\n+      __os << std::vformat(__s, make_format_args<_Ctx>(__i));\n+      return __os;\n+    }\n+\n+  // TODO from_stream for year\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const weekday& __wd)\n+    {\n+      using _Ctx = __conditional_t<is_same_v<_CharT, char>,\n+\t\t\t\t   format_context, wformat_context>;\n+      using _Str = basic_string_view<_CharT>;\n+      _Str __s = _GLIBCXX_WIDEN(\"{:L%a}{} is not a valid weekday\");\n+      if (__wd.ok())\n+\t__os << std::vformat(__os.getloc(), __s.substr(0, 6),\n+\t\t\t     make_format_args<_Ctx>(__wd));\n+      else\n+\t__os << std::vformat(__s.substr(6),\n+\t\t\t     make_format_args<_Ctx>(__wd.c_encoding()));\n+      return __os;\n+    }\n+\n+  // TODO from_stream for weekday\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const weekday_indexed& __wdi)\n+    {\n+      // The standard says to format wdi.weekday() and wdi.index() using\n+      // either \"{:L}[{}]\" or \"{:L}[{} is not a valid index]\". The {:L} spec\n+      // means to format the weekday using ostringstream, so just do that.\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __wdi.weekday();\n+      const auto __i = __wdi.index();\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__os2 << std::format(\"[{}\", __i);\n+      else\n+\t__os2 << std::format(L\"[{}\", __i);\n+      basic_string_view<_CharT> __s = _GLIBCXX_WIDEN(\" is not a valid index]\");\n+      if (__i >= 1 && __i <= 5)\n+\t__os2 << __s.back();\n+      else\n+\t__os2 << __s;\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const weekday_last& __wdl)\n+    {\n+      // As above, just write straight to a stringstream, as if by \"{:L}[last]\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __wdl.weekday() << _GLIBCXX_WIDEN(\"[last]\");\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const month_day& __md)\n+    {\n+      // As above, just write straight to a stringstream, as if by \"{:L}/{}\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __md.month();\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__os2 << '/';\n+      else\n+\t__os2 << L'/';\n+      __os2 << __md.day();\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  // TODO from_stream for month_day\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const month_day_last& __mdl)\n+    {\n+      // As above, just write straight to a stringstream, as if by \"{:L}/last\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __mdl.month();\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__os2 << \"/last\";\n+      else\n+\t__os2 << L\"/last\";\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const month_weekday& __mwd)\n+    {\n+      // As above, just write straight to a stringstream, as if by \"{:L}/{:L}\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __mwd.month();\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__os2 << '/';\n+      else\n+\t__os2 << L'/';\n+      __os2 << __mwd.weekday_indexed();\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const month_weekday_last& __mwdl)\n+    {\n+      // As above, just write straight to a stringstream, as if by \"{:L}/{:L}\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __mwdl.month();\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__os2 << '/';\n+      else\n+\t__os2 << L'/';\n+      __os2 << __mwdl.weekday_last();\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const year_month& __ym)\n+    {\n+      // As above, just write straight to a stringstream, as if by \"{}/{:L}\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __ym.year();\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__os2 << '/';\n+      else\n+\t__os2 << L'/';\n+      __os2 << __ym.month();\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  // TODO from_stream for year_month\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const year_month_day& __ymd)\n+    {\n+      using _Ctx = __conditional_t<is_same_v<_CharT, char>,\n+\t\t\t\t   format_context, wformat_context>;\n+      using _Str = basic_string_view<_CharT>;\n+      _Str __s = _GLIBCXX_WIDEN(\"{:%F} is not a valid date\");\n+      __os << std::vformat(__ymd.ok() ? __s.substr(0, 5) : __s,\n+\t\t\t   make_format_args<_Ctx>(__ymd));\n+      return __os;\n+    }\n+\n+  // TODO from_stream for year_month_day\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const year_month_day_last& __ymdl)\n+    {\n+      // As above, just write straight to a stringstream, as if by \"{}/{:L}\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      __os2 << __ymdl.year();\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__os2 << '/';\n+      else\n+\t__os2 << L'/';\n+      __os2 << __ymdl.month_day_last();\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const year_month_weekday& __ymwd)\n+    {\n+      // As above, just write straight to a stringstream, as if by\n+      // \"{}/{:L}/{:L}\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      _CharT __slash;\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__slash = '/';\n+      else\n+\t__slash = L'/';\n+      __os2 << __ymwd.year() << __slash << __ymwd.month() << __slash\n+\t    << __ymwd.weekday_indexed();\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const year_month_weekday_last& __ymwdl)\n+    {\n+      // As above, just write straight to a stringstream, as if by\n+      // \"{}/{:L}/{:L}\"\n+      basic_stringstream<_CharT> __os2;\n+      __os2.imbue(__os.getloc);\n+      _CharT __slash;\n+      if constexpr (is_same_v<_CharT, char>)\n+\t__slash = '/';\n+      else\n+\t__slash = L'/';\n+      __os2 << __ymwdl.year() << __slash << __ymwdl.month() << __slash\n+\t    << __ymwdl.weekday_last();\n+      __os << __os2.view();\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Duration>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const hh_mm_ss<_Duration>& __hms)\n+    {\n+      return __os << format(__os.getloc(), _GLIBCXX_WIDEN(\"{:L%T}\"), __hms);\n+    }\n+\n+#if _GLIBCXX_USE_CXX11_ABI || ! _GLIBCXX_USE_DUAL_ABI\n+  /// Writes a sys_info object to an ostream in an unspecified format.\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const sys_info& __i)\n+    {\n+      __os << '[' << __i.begin << ',' << __i.end\n+\t   << ',' << hh_mm_ss(__i.offset) << ',' << __i.save\n+\t   << ',' << __i.abbrev << ']';\n+      return __os;\n+    }\n+\n+  /// Writes a local_info object to an ostream in an unspecified format.\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const local_info& __li)\n+    {\n+      __os << '[';\n+      if (__li.result == local_info::unique)\n+\t__os << __li.first;\n+      else\n+\t{\n+\t  if (__li.result == local_info::nonexistent)\n+\t    __os << \"nonexistent\";\n+\t  else\n+\t    __os << \"ambiguous\";\n+\t  __os << \" local time between \" << __li.first;\n+\t  __os << \" and \" << __li.second;\n+\t}\n+      __os << ']';\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Duration,\n+\t   typename _TimeZonePtr>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const zoned_time<_Duration, _TimeZonePtr>& __t)\n+    {\n+      __os << format(__os.getloc(), _GLIBCXX_WIDEN(\"{:L%F %T %Z}\"), __t);\n+      return __os;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _Traits, typename _Duration>\n+    requires (!treat_as_floating_point_v<typename _Duration::rep>)\n+      && ratio_less_v<typename _Duration::period, days::period>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const sys_time<_Duration>& __tp)\n+    {\n+      __os << std::format(__os.getloc(), _GLIBCXX_WIDEN(\"{:L%F %T}\"), __tp);\n+      return __os;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const sys_days& __dp)\n+    {\n+      __os << year_month_day{__dp};\n+      return __os;\n+    }\n+\n+  // TODO: from_stream for sys_time\n+\n+  template<typename _CharT, typename _Traits, typename _Duration>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const utc_time<_Duration>& __t)\n+    {\n+      __os << std::format(__os.getloc(), _GLIBCXX_WIDEN(\"{:L%F %T}\"), __t);\n+      return __os;\n+    }\n+\n+  // TODO: from_stream for utc_time\n+\n+  template<typename _CharT, typename _Traits, typename _Duration>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const tai_time<_Duration>& __t)\n+    {\n+      __os << std::format(__os.getloc(), _GLIBCXX_WIDEN(\"{:L%F %T}\"), __t);\n+      return __os;\n+    }\n+\n+  // TODO: from_stream for tai_time\n+\n+  template<typename _CharT, typename _Traits, typename _Duration>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const gps_time<_Duration>& __t)\n+    {\n+      __os << std::format(__os.getloc(), _GLIBCXX_WIDEN(\"{:L%F %T}\"), __t);\n+      return __os;\n+    }\n+\n+  // TODO: from_stream for gps_time\n+\n+\n+  template<typename _CharT, typename _Traits, typename _Duration>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const file_time<_Duration>& __t)\n+    {\n+      __os << std::format(__os.getloc(), _GLIBCXX_WIDEN(\"{:L%F %T}\"), __t);\n+      return __os;\n+    }\n+\n+  // TODO: from_stream for file_time\n+\n+  template<typename _CharT, typename _Traits, typename _Duration>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const local_time<_Duration>& __lt)\n+    {\n+      __os << sys_time<_Duration>{__lt.time_since_epoch()};\n+      return __os;\n+    }\n+\n+  // TODO: from_stream for local_time\n+#undef _GLIBCXX_WIDEN\n+\n+  /// @} group chrono\n+} // namespace chrono\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++20\n+\n+#endif //_GLIBCXX_CHRONO_IO_H"}, {"sha": "27f391a14556ecf7f099e76b8cf6dc9169f7546b", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 28, "deletions": 136, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -45,7 +45,6 @@\n # include <sstream>\n # include <string>\n # include <vector>\n-# include <bits/charconv.h> // __to_chars_len, __to_chars_10_impl\n # include <bits/stl_algo.h> // upper_bound\n # include <bits/shared_ptr.h>\n # include <bits/unique_ptr.h>\n@@ -627,8 +626,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_day\n       operator/(const year_month& __ym, const day& __d) noexcept;\n-\n-      // TODO: Implement operator<<, to_stream, from_stream.\n     };\n \n     // MONTH\n@@ -751,8 +748,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr month_weekday_last\n       operator/(const weekday_last& __wdl, const month& __m) noexcept;\n-\n-      // TODO: Implement operator<<, to_stream, from_stream.\n     };\n \n     inline constexpr month January{1};\n@@ -929,8 +924,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_weekday_last\n       operator/(const month_weekday_last& __mwdl, const year& __y) noexcept;\n-\n-      // TODO: Implement operator<<, to_stream, from_stream.\n     };\n \n     // WEEKDAY\n@@ -1052,8 +1045,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tauto __n = static_cast<long long>(__x._M_wd) - __y._M_wd;\n \treturn days{__detail::__modulo(__n, 7)};\n       }\n-\n-      // TODO: operator<<, from_stream.\n     };\n \n     inline constexpr weekday Sunday{0};\n@@ -1110,8 +1101,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_weekday\n       operator/(const year_month& __ym, const weekday_indexed& __wdi) noexcept;\n-\n-      // TODO: Implement operator<<.\n     };\n \n     constexpr weekday_indexed\n@@ -1151,8 +1140,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_weekday_last\n       operator/(const year_month& __ym, const weekday_last& __wdl) noexcept;\n-\n-      // TODO: Implement operator<<.\n     };\n \n     constexpr weekday_last\n@@ -1224,8 +1211,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_day\n       operator/(const month_day& __md, int __y) noexcept;\n-\n-      // TODO: Implement operator<<, from_stream.\n     };\n \n     // MONTH_DAY_LAST\n@@ -1278,8 +1263,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_day_last\n       operator/(const month_day_last& __mdl, int __y) noexcept;\n-\n-      // TODO: Implement operator<<.\n     };\n \n     // MONTH_WEEKDAY\n@@ -1339,8 +1322,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_weekday\n       operator/(const month_weekday& __mwd, int __y) noexcept;\n-\n-      // TODO: Implement operator<<.\n     };\n \n     // MONTH_WEEKDAY_LAST\n@@ -1401,8 +1382,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_weekday_last\n       operator/(const month_weekday_last& __mwdl, int __y) noexcept;\n-\n-      // TODO: Implement operator<<.\n     };\n \n     // YEAR_MONTH\n@@ -1544,8 +1523,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       friend constexpr year_month_day_last\n       operator/(const year_month& __ym, last_spec) noexcept;\n-\n-      // TODO: Implement operator<<, from_stream.\n     };\n \n     // YEAR_MONTH_DAY\n@@ -1697,8 +1674,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       friend constexpr year_month_day\n       operator/(const month_day& __md, int __y) noexcept\n       { return chrono::year(__y) / __md; }\n-\n-      // TODO: Implement operator<<, from_stream.\n     };\n \n     // Construct from days since 1970/01/01.\n@@ -1928,8 +1903,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       friend constexpr year_month_day_last\n       operator/(const chrono::month_day_last& __mdl, int __y) noexcept\n       { return chrono::year(__y) / __mdl; }\n-\n-      // TODO: Implement operator<<.\n     };\n \n     // year_month_day ctor from year_month_day_last\n@@ -2118,8 +2091,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       friend constexpr year_month_weekday\n       operator/(const month_weekday& __mwd, int __y) noexcept\n       { return chrono::year(__y) / __mwd; }\n-\n-      // TODO: Implement operator<<.\n     };\n \n     // YEAR_MONTH_WEEKDAY_LAST\n@@ -2267,8 +2238,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       friend constexpr year_month_weekday_last\n       operator/(const chrono::month_weekday_last& __mwdl, int __y) noexcept\n       { return chrono::year(__y) / __mwdl; }\n-\n-      // TODO: Implement operator<<.\n     };\n \n     // HH_MM_SS\n@@ -2284,6 +2253,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __r *= 10;\n \treturn __r;\n       }\n+\n+      template<typename _Duration> struct __utc_leap_second;\n     }\n     /// @endcond\n \n@@ -2389,8 +2360,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return _M_h + _M_m + _M_s + subseconds();\n \t}\n \n-\t// TODO: Implement operator<<.\n-\n       private:\n \tstatic constexpr bool _S_is_unsigned\n \t  = __and_v<is_integral<typename _Duration::rep>,\n@@ -2459,8 +2428,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__byte_duration<ratio<1>>   _M_s{};\n \tbool\t\t\t    _M_is_neg{};\n \t__subseconds<precision>\t    _M_ss{};\n+\n+\ttemplate<typename> friend struct __detail::__utc_leap_second;\n       };\n \n+    /// @cond undocumented\n+    namespace __detail\n+    {\n+      // Represents a time that is within a leap second insertion.\n+      template<typename _Duration>\n+\tstruct __utc_leap_second\n+\t{\n+\t  explicit\n+\t  __utc_leap_second(const sys_time<_Duration>& __s)\n+\t  : _M_date(chrono::floor<days>(__s)), _M_time(__s - _M_date)\n+\t  {\n+\t    ++_M_time._M_s;\n+\t  }\n+\n+\t  sys_days _M_date;\n+\t  hh_mm_ss<common_type_t<_Duration, days>> _M_time;\n+\t};\n+    }\n+    /// @endcond\n+\n     // 12/24 HOURS FUNCTIONS\n \n     constexpr bool\n@@ -2540,9 +2531,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_make_what_str(const local_time<_Duration>& __tp,\n \t\t\t const local_info& __i)\n \t{\n-#if 1\n-\t  return \"local time is non-existent\";\n-#else\n \t  std::ostringstream __os;\n \t  __os << __tp << \" is in a gap between\\n\"\n \t       << local_seconds(__i.first.end.time_since_epoch())\n@@ -2552,7 +2540,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       << \" which are both equivalent to\\n\"\n \t       << __i.first.end << \" UTC\";\n \t  return std::move(__os).str();\n-#endif\n \t}\n     };\n \n@@ -2571,17 +2558,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_make_what_str(const local_time<_Duration>& __tp,\n \t\t\t const local_info& __i)\n \t{\n-#if 1\n-\t  return \"local time is ambiguous\";\n-#else\n \t  std::ostringstream __os;\n \t  __os << __tp << \" is ambiguous.  It could be\\n\"\n \t       << __tp << ' ' << __i.first.abbrev << \" == \"\n \t       << __tp - __i.first.offset << \" UTC or\\n\"\n \t       << __tp << ' ' << __i.second.abbrev << \" == \"\n \t       << __tp - __i.second.offset << \" UTC\";\n \t  return std::move(__os).str();\n-#endif\n \t}\n     };\n \n@@ -3329,106 +3312,15 @@ namespace __detail\n     /// @}\n   } // inline namespace chrono_literals\n   } // inline namespace literals\n-\n-  namespace chrono\n-  {\n-    /// @addtogroup chrono\n-    /// @{\n-\n-    /// @cond undocumented\n-    namespace __detail\n-    {\n-      template<typename _Period>\n-\tconst char*\n-\t__units_suffix_misc(char* __buf, size_t __n) noexcept\n-\t{\n-\t  namespace __tc = std::__detail;\n-\t  char* __p = __buf;\n-\t  __p[0] = '[';\n-\t  unsigned __nlen = __tc::__to_chars_len((uintmax_t)_Period::num);\n-\t  __tc::__to_chars_10_impl(__p + 1, __nlen, (uintmax_t)_Period::num);\n-\t  __p += 1 + __nlen;\n-\t  if constexpr (_Period::den != 1)\n-\t    {\n-\t      __p[0] = '/';\n-\t      unsigned __dlen = __tc::__to_chars_len((uintmax_t)_Period::den);\n-\t      __tc::__to_chars_10_impl(__p + 1, __dlen, (uintmax_t)_Period::den);\n-\t      __p += 1 + __dlen;\n-\t    }\n-\t  __p[0] = ']';\n-\t  __p[1] = 's';\n-\t  __p[2] = '\\0';\n-\t  return __buf;\n-\t}\n-\n-      template<typename _Period, typename _CharT>\n-\tauto\n-\t__units_suffix(char* __buf, size_t __n) noexcept\n-\t{\n-#define _GLIBCXX_UNITS_SUFFIX(period, suffix) \\\n-\tif constexpr (is_same_v<_Period, period>)\t\\\n-\t  {\t\t\t\t\t\t\\\n-\t    if constexpr (is_same_v<_CharT, wchar_t>)\t\\\n-\t      return L##suffix;\t\t\t\t\\\n-\t    else\t\t\t\t\t\\\n-\t      return suffix;\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\\\n-\telse\n-\n-\t  _GLIBCXX_UNITS_SUFFIX(atto, \"as\")\n-\t  _GLIBCXX_UNITS_SUFFIX(femto, \"fs\")\n-\t  _GLIBCXX_UNITS_SUFFIX(pico, \"ps\")\n-\t  _GLIBCXX_UNITS_SUFFIX(nano, \"ns\")\n-\t  _GLIBCXX_UNITS_SUFFIX(micro, \"\\u00b5s\")\n-\t  _GLIBCXX_UNITS_SUFFIX(milli, \"ms\")\n-\t  _GLIBCXX_UNITS_SUFFIX(centi, \"cs\")\n-\t  _GLIBCXX_UNITS_SUFFIX(deci, \"ds\")\n-\t  _GLIBCXX_UNITS_SUFFIX(ratio<1>, \"s\")\n-\t  _GLIBCXX_UNITS_SUFFIX(deca, \"das\")\n-\t  _GLIBCXX_UNITS_SUFFIX(hecto, \"hs\")\n-\t  _GLIBCXX_UNITS_SUFFIX(kilo, \"ks\")\n-\t  _GLIBCXX_UNITS_SUFFIX(mega, \"Ms\")\n-\t  _GLIBCXX_UNITS_SUFFIX(giga, \"Gs\")\n-\t  _GLIBCXX_UNITS_SUFFIX(tera, \"Ts\")\n-\t  _GLIBCXX_UNITS_SUFFIX(tera, \"Ts\")\n-\t  _GLIBCXX_UNITS_SUFFIX(peta, \"Ps\")\n-\t  _GLIBCXX_UNITS_SUFFIX(exa, \"Es\")\n-\t  _GLIBCXX_UNITS_SUFFIX(ratio<60>, \"min\")\n-\t  _GLIBCXX_UNITS_SUFFIX(ratio<3600>, \"h\")\n-\t  _GLIBCXX_UNITS_SUFFIX(ratio<86400>, \"d\")\n-#undef _GLIBCXX_UNITS_SUFFIX\n-\t  return __detail::__units_suffix_misc<_Period>(__buf, __n);\n-\t}\n-    } // namespace __detail\n-    /// @endcond\n-\n-    template<typename _CharT, typename _Traits,\n-\t     typename _Rep, typename _Period>\n-      inline basic_ostream<_CharT, _Traits>&\n-      operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\tconst duration<_Rep, _Period>& __d)\n-      {\n-\tusing period = typename _Period::type;\n-\tchar __buf[sizeof(\"[/]s\") + 2 * numeric_limits<intmax_t>::digits10];\n-\tstd::basic_ostringstream<_CharT, _Traits> __s;\n-\t__s.flags(__os.flags());\n-\t__s.imbue(__os.getloc());\n-\t__s.precision(__os.precision());\n-\t__s << __d.count();\n-\t__s << __detail::__units_suffix<period, _CharT>(__buf, sizeof(__buf));\n-\t__os << std::move(__s).str();\n-\treturn __os;\n-      }\n-\n-    // TODO: from_stream for duration\n-\n-    /// @} group chrono\n-  } // namespace chrono\n #endif // C++20\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n+#if __cplusplus >= 202002L\n+# include <bits/chrono_io.h>\n+#endif\n+\n #endif // C++11\n \n #endif //_GLIBCXX_CHRONO"}, {"sha": "a0bb03173a9481658eaabf0c5399748ee6b2fe9f", "filename": "libstdc++-v3/src/c++20/tzdb.cc", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -511,27 +511,25 @@ namespace std::chrono\n       friend ostream& operator<<(ostream& out, const Rule& r)\n       {\n \tout << \"Rule \" << r.name << ' ' << (int)r.from << ' ' << (int)r.to\n-\t    << ' ' << (unsigned)r.when.day.get_month() << ' ';\n+\t    << ' ' << r.when.day.get_month() << ' ';\n \tswitch (r.when.day.kind)\n \t{\n \tcase on_day::DayOfMonth:\n \t  out << (unsigned)r.when.day.get_day();\n \t  break;\n \tcase on_day::LastWeekday:\n-\t  out << \"last\" << weekday(r.when.day.day_of_week).c_encoding();\n+\t  out << \"last\" << weekday(r.when.day.day_of_week);\n \t  break;\n \tcase on_day::LessEq:\n-\t  out << weekday(r.when.day.day_of_week).c_encoding() << \" <= \"\n+\t  out << weekday(r.when.day.day_of_week) << \" <= \"\n \t    << r.when.day.day_of_month;\n \t  break;\n \tcase on_day::GreaterEq:\n-\t  out << weekday(r.when.day.day_of_week).c_encoding() << \" >= \"\n+\t  out << weekday(r.when.day.day_of_week) << \" >= \"\n \t    << r.when.day.day_of_month;\n \t  break;\n \t}\n-\thh_mm_ss hms(r.when.time);\n-\tout << ' ' << hms.hours().count() << ':' << hms.minutes().count()\n-\t    << ':' << hms.seconds().count() << \"wusd\"[r.when.indicator];\n+\tout << ' ' << hh_mm_ss(r.when.time) << \"wusd\"[r.when.indicator];\n \tout << ' ' << r.save.count();\n \tif (!r.letters.empty())\n \t  out << ' ' << r.letters;"}, {"sha": "27586b543922dd1679aa609e47d8bbdc2f99b49c", "filename": "libstdc++-v3/testsuite/20_util/duration/io.cc", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fduration%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -47,8 +47,56 @@ test02()\n #endif\n }\n \n+void\n+test_format()\n+{\n+  using namespace std::chrono_literals;\n+  auto s = std::format(\"{} {}\", 1h + 23min + 45s, -42min);\n+  VERIFY( s == \"5025s -42min\" );\n+  s = std::format(\"{:%j} {:%j} {:%j}\", 1h + 23min + 45s, 75h, -99h);\n+  VERIFY( s == \"0 3 -4\" );\n+  s = std::format(\"{:%T = %H:%M:%S}\", 1h + 23min + 45s);\n+  VERIFY( s == \"01:23:45 = 01:23:45\" );\n+  s = std::format(\"{:%Q} {:%q} {:%Q%q}\", 6min + 1s, 44min, -22h);\n+  VERIFY( s == \"361 min -22h\" );\n+\n+  std::wstring ws = std::format(L\"{:%Q%q}\", 81s);\n+  VERIFY( ws == L\"81s\" );\n+\n+  // Only print '-' on numeric fields for negative durations:\n+  s = std::format(\"{:%Q} {:%q} {:%q%Q}\", -21h, -20h, -19h);\n+  VERIFY( s == \"-21 h h-19\" );\n+  s = std::format(\"{:%p} {:%p%H}\", -2h, -13h);\n+  VERIFY( s == \"AM PM-13\" );\n+  s = std::format(\"{:%t} {:%t%M}\", -2h, -123s);\n+  VERIFY( s == \"\\t \\t-02\" );\n+\n+  std::string_view specs = \"aAbBcCdDeFgGhHIjmMpqQrRSTuUVwWxXyYzZ\";\n+  std::string_view my_specs = \"HIjMpqQrRSTX\";\n+  for (char c : specs)\n+  {\n+    char fmt[] = { '{', ':', '%', c, '}' };\n+    try\n+    {\n+      (void) std::vformat(std::string_view(fmt, 5), std::make_format_args(1s));\n+      // The call above should throw for any conversion-spec not in my_specs:\n+      VERIFY(my_specs.find(c) != my_specs.npos);\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(my_specs.find(c) == my_specs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+  }\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test_format();\n+  // TODO: test_parse();\n }"}, {"sha": "c8e82bb111c23ce150abf4960faaa1e4a0b5ab1d", "filename": "libstdc++-v3/testsuite/std/time/clock/file/io.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ffile%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ffile%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ffile%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using namespace std::chrono;\n+\n+  file_time<file_clock::duration> t = file_clock::now();\n+  std::ostringstream ss1, ss2;\n+  ss1 << floor<seconds>(t);\n+  ss2 << floor<seconds>(clock_cast<system_clock>(t));\n+  VERIFY( ss1.str() == ss2.str() );\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+}"}, {"sha": "29f3148cf14bcf7f3e0cb5512e7b654e267d7bbd", "filename": "libstdc++-v3/testsuite/std/time/clock/gps/io.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <format>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using std::format;\n+  using namespace std::chrono;\n+\n+  auto st = sys_days{2000y/January/1};\n+  auto gt = clock_cast<gps_clock>(st);\n+\n+  auto s = format(\"{0:%F %T %Z} == {1:%F %T %Z}\", st, gt);\n+  VERIFY( s == \"2000-01-01 00:00:00 UTC == 2000-01-01 00:00:13 GPS\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "e7feebc9a3c8dc980e04308bd5c111f3eff9e6c0", "filename": "libstdc++-v3/testsuite/std/time/clock/system/io.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fsystem%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fsystem%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fsystem%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,72 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using namespace std::chrono;\n+  std::stringstream ss;\n+  ss << sys_seconds{0s} << '\\n';                // 1970-01-01 00:00:00\n+  ss << sys_seconds{946'684'800s} << '\\n';      // 2000-01-01 00:00:00\n+  ss << sys_seconds{946'688'523s} << '\\n';      // 2000-01-01 01:02:03\n+  std::string s1, s2, s3;\n+  std::getline(ss, s1);\n+  std::getline(ss, s2);\n+  std::getline(ss, s3);\n+  VERIFY( s1 == \"1970-01-01 00:00:00\" );\n+  VERIFY( s2 == \"2000-01-01 00:00:00\" );\n+  VERIFY( s3 == \"2000-01-01 01:02:03\" );\n+}\n+\n+template<typename T>\n+concept stream_insertable\n+  = requires (std::ostream& out, const T& t) { out << t; };\n+\n+// operator<<(ostream&, const sys_time<D>&) is constrained to not\n+// allow floating-point types or periods of days or greater.\n+using fp_sys_time = std::chrono::sys_time<std::chrono::duration<float>>;\n+static_assert( !stream_insertable<fp_sys_time> );\n+\n+// But there is an overload for sys_days.\n+static_assert( stream_insertable<std::chrono::sys_days> );\n+\n+void\n+test_format()\n+{\n+  using namespace std::chrono_literals;\n+  std::chrono::sys_time<std::chrono::milliseconds> t(1671470785708ms);\n+\n+  // Every conversion specifier is valid for a sys_time except %q and %Q.\n+\n+  std::string s = std::format(\"{:%a | %A | %b | %B | %c\"\n+\t\t\t      \" | %C | %d | %D | %e | %F | %g | %G | %h\"\n+\t\t\t      \" | %H | %I | %j | %m | %M | %p | %r | %R\"\n+\t\t\t      \" | %S | %T | %u | %U | %V | %w | %W | %x\"\n+\t\t\t      \" | %X | %y | %Y | %z | %Z}\", t);\n+  VERIFY( s == \"Mon | Monday | Dec | December | Mon Dec 19 17:26:25.708 2022\"\n+\t       \" | 20 | 19 | 12/19/22 | 19 | 2022-12-19 | 22 | 2022 | Dec\"\n+\t       \" | 17 | 05 | 353 | 12 | 26 | PM | 05:26:25.708 PM | 17:26\"\n+\t       \" | 25.708 | 17:26:25.708 | 1 | 51 | 51 | 1 | 51 | 12/19/22\"\n+\t       \" | 17:26:25.708 | 22 | 2022 | +0000 | UTC\" );\n+\n+  std::wstring ws = std::format(L\"{:%a | %A | %b | %B | %c\"\n+\t\t\t\t \" | %C | %d | %D | %e | %F | %g | %G | %h\"\n+\t\t\t\t \" | %H | %I | %j | %m | %M | %p | %r | %R\"\n+\t\t\t\t \" | %S | %T | %u | %U | %V | %w | %W | %x\"\n+\t\t\t\t \" | %X | %y | %Y | %z | %Z}\", t);\n+  VERIFY( ws == L\"Mon | Monday | Dec | December | Mon Dec 19 17:26:25.708 2022\"\n+\t\t \" | 20 | 19 | 12/19/22 | 19 | 2022-12-19 | 22 | 2022 | Dec\"\n+\t\t \" | 17 | 05 | 353 | 12 | 26 | PM | 05:26:25.708 PM | 17:26\"\n+\t\t \" | 25.708 | 17:26:25.708 | 1 | 51 | 51 | 1 | 51 | 12/19/22\"\n+\t\t \" | 17:26:25.708 | 22 | 2022 | +0000 | UTC\" );\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+  test_format();\n+}"}, {"sha": "d0255f5431af8322eb6c36381501e687baf2fe82", "filename": "libstdc++-v3/testsuite/std/time/clock/tai/io.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <format>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using std::format;\n+  using namespace std::chrono;\n+\n+  auto st = sys_days{2000y/January/1};\n+  auto tt = clock_cast<tai_clock>(st);\n+\n+  auto s = format(\"{0:%F %T %Z} == {1:%F %T %Z}\", st, tt);\n+  VERIFY( s == \"2000-01-01 00:00:00 UTC == 2000-01-01 00:00:32 TAI\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "b327c7f50c71fd7c957e621028ab8a872333ba81", "filename": "libstdc++-v3/testsuite/std/time/clock/utc/io.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,120 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using std::ostringstream;\n+  using namespace std::chrono;\n+\n+  auto t = sys_days{July/1/2015} - 500ms;\n+  auto u = clock_cast<utc_clock>(t);\n+\n+  std::string_view results[] = {\n+    \"2015-06-30 23:59:59.500 UTC\",\n+    \"2015-06-30 23:59:59.750 UTC\",\n+    \"2015-06-30 23:59:60.000 UTC\",\n+    \"2015-06-30 23:59:60.250 UTC\",\n+    \"2015-06-30 23:59:60.500 UTC\",\n+    \"2015-06-30 23:59:60.750 UTC\",\n+    \"2015-07-01 00:00:00.000 UTC\",\n+    \"2015-07-01 00:00:00.250 UTC\",\n+  };\n+\n+  for (auto result : results)\n+  {\n+    ostringstream out;\n+    out << u << \" UTC\";\n+    VERIFY( out.str() == result );\n+    u += 250ms;\n+  }\n+}\n+\n+void\n+test_format()\n+{\n+  using namespace std::chrono_literals;\n+  std::chrono::utc_time<std::chrono::milliseconds> t(1671470812708ms);\n+\n+  // Every conversion specifier is valid for a utc_time except %q and %Q.\n+  std::string_view specs = \"aAbBcCdDeFgGhHIjmMpqQrRSTuUVwWxXyYzZ\";\n+  std::string_view badspecs = \"qQ\";\n+\n+  std::ostringstream ss;\n+  std::wostringstream wss;\n+\n+  for (char c : specs)\n+  {\n+    char fmt[] = { '{', ':', '%', c, '}' };\n+    try\n+    {\n+      ss << std::vformat(std::string_view(fmt, 5),\n+\t\t\t std::make_format_args(t));\n+      ss << \" | \";\n+      // The call above should throw for any conversion-spec in badspecs:\n+      VERIFY(badspecs.find(c) == badspecs.npos);\n+\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(badspecs.find(c) != badspecs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+\n+    wchar_t wfmt[] = { L'{', L':', L'%', c, L'}' };\n+    try\n+    {\n+      wss << std::vformat(std::wstring_view(wfmt, 5),\n+\t\t\t  std::make_wformat_args(t));\n+      wss << L\" | \";\n+      // The call above should throw for any conversion-spec in badspecs:\n+      VERIFY(badspecs.find(c) == badspecs.npos);\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(badspecs.find(c) != badspecs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+  }\n+\n+  std::string s = ss.str();\n+  VERIFY( s == \"Mon | Monday | Dec | December | Mon Dec 19 17:26:25.708 2022\"\n+\t       \" | 20 | 19 | 12/19/22 | 19 | 2022-12-19 | 22 | 2022 | Dec\"\n+\t       \" | 17 | 05 | 353 | 12 | 26 | PM | 05:26:25.708 PM | 17:26\"\n+\t       \" | 25.708 | 17:26:25.708 | 1 | 51 | 51 | 1 | 51 | 12/19/22\"\n+\t       \" | 17:26:25.708 | 22 | 2022 | +0000 | UTC | \" );\n+\n+  std::wstring ws = wss.str();\n+  VERIFY( ws == L\"Mon | Monday | Dec | December | Mon Dec 19 17:26:25.708 2022\"\n+\t\t \" | 20 | 19 | 12/19/22 | 19 | 2022-12-19 | 22 | 2022 | Dec\"\n+\t\t \" | 17 | 05 | 353 | 12 | 26 | PM | 05:26:25.708 PM | 17:26\"\n+\t\t \" | 25.708 | 17:26:25.708 | 1 | 51 | 51 | 1 | 51 | 12/19/22\"\n+\t\t \" | 17:26:25.708 | 22 | 2022 | +0000 | UTC | \" );\n+\n+  std::chrono::utc_seconds leap(1483228800s + 26s); // 1 Jan 2017\n+  s = std::format(\"{:%T}\", leap - 1s);\n+  VERIFY( s == \"23:59:59\" );\n+  s = std::format(\"{:%T}\", leap);\n+  VERIFY( s == \"23:59:60\" );\n+  s = std::format(\"{:%T}\", leap + 10ms);\n+  VERIFY( s == \"23:59:60.010\" );\n+\n+  s = std::format(\"{:%T}\", leap + 1s);\n+  VERIFY( s == \"00:00:00\" );\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+  test_format();\n+}"}, {"sha": "6158230f28841955a75737ad47588be8fc233927", "filename": "libstdc++-v3/testsuite/std/time/day/io.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fday%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fday%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fday%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-namedlocale \"fr_FR.ISO8859-15\" }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using std::ostringstream;\n+  using namespace std::chrono;\n+\n+  ostringstream ss;\n+  ss << day(1) << ' ' << day(11) << ' ' << day(21) << ' ' << day(31)\n+    << ' ' << day(41);\n+  auto s = ss.str();\n+  VERIFY( s == \"01 11 21 31 41 is not a valid day\" );\n+\n+  ss.str(\"\");\n+  ss.imbue(std::locale(ISO_8859(15,fr_FR)));\n+  ss << day(1);\n+  VERIFY( ss.str() == \"01\" );\n+}\n+\n+void\n+test_format()\n+{\n+  using std::chrono::day;\n+\n+  auto s = std::format(\"{:%d%%%e%t}{:%d%%%e%n}\", day(1), day(11));\n+  VERIFY( s == \"01% 1\\t11%11\\n\" );\n+  auto ws = std::format(L\"{:%d%%%e%t}{:%d%%%e%n}\", day(1), day(11));\n+  VERIFY( ws == L\"01% 1\\t11%11\\n\" );\n+\n+  VERIFY( std::format(\"{} {}\", day(8), day(0)) == \"08 00 is not a valid day\" );\n+\n+  s = std::format(\"{:%Od}\", day(1));\n+  VERIFY( s == \"01\" );\n+  s = std::format(std::locale::classic(), \"{:%Od}\", day(1));\n+  VERIFY( s == \"01\" );\n+  s = std::format(std::locale::classic(), \"{:L%Od}\", day(1));\n+  VERIFY( s == \"01\" );\n+  // TODO test \"{:L%Od}\" with locale that has alternative numeric rep.\n+\n+  std::string_view specs = \"aAbBcCdDeFgGhHIjmMpqQrRSTuUVwWxXyYzZ\";\n+  std::string_view my_specs = \"de\";\n+  for (char c : specs)\n+  {\n+    char fmt[] = { '{', ':', '%', c, '}' };\n+    try\n+    {\n+      (void) std::vformat(std::string_view(fmt, 5),\n+\t\t\t  std::make_format_args(day(1)));\n+      // The call above should throw for any conversion-spec not in my_specs:\n+      VERIFY(my_specs.find(c) != my_specs.npos);\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(my_specs.find(c) == my_specs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+  }\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+  test_format();\n+  // TODO: test_parse();\n+}"}, {"sha": "650b1fe7a374974ee554a7aab6298e9e17eb2a07", "filename": "libstdc++-v3/testsuite/std/time/exceptions.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fexceptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fexceptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fexceptions.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -20,7 +20,7 @@ test_nonexistent()\n \t\t\t local_days{Sunday[2]/March/2016} + 2h + 30min};\n     VERIFY(false);\n   } catch (const nonexistent_local_time& e) {\n-    // VERIFY( e.what() == expected );\n+    VERIFY( e.what() == expected );\n   }\n }\n \n@@ -38,7 +38,7 @@ test_ambiguous()\n \t\t\t local_days{Sunday[1]/November/2016} + 1h + 30min};\n     VERIFY(false);\n   } catch (const ambiguous_local_time& e) {\n-    // VERIFY( e.what() == expected );\n+    VERIFY( e.what() == expected );\n   }\n }\n "}, {"sha": "b05e5da1af85876036bd1bf3e54cbd48b1e89477", "filename": "libstdc++-v3/testsuite/std/time/format.cc", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fformat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fformat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fformat.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,117 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_format_strings()\n+{\n+  using namespace std::chrono_literals;\n+\n+  // valid format strings\n+  VERIFY( std::format(\"{}\", 1s) == \"1s\" );\n+  VERIFY( std::format(\"{:}\", 1s) == \"1s\" );\n+  VERIFY( std::format(\"{:L}\", 1s) == \"1s\" );\n+  VERIFY( std::format(\"{:%%%n%t}\", 1s) == \"%\\n\\t\" );\n+  VERIFY( std::format(\"{:L%%%n%t}\", 1s) == \"%\\n\\t\" );\n+  VERIFY( std::format(\"{:4%%}\", 1s) == \"%   \" );\n+  VERIFY( std::format(\"{:4L%%}\", 1s) == \"%   \" );\n+  VERIFY( std::format(\"{: >4}\", 1s) == \"  1s\" );\n+  VERIFY( std::format(\"{: <4}\", 1s) == \"1s  \" );\n+  VERIFY( std::format(\"{: <4L}\", 1s) == \"1s  \" );\n+  VERIFY( std::format(\"{: >4%%}\", 1s) == \"   %\" );\n+  VERIFY( std::format(\"{: >4L%%}\", 1s) == \"   %\" );\n+  VERIFY( std::format(\"{: ^4%%}\", 1s) == \" %  \" );\n+}\n+\n+template<typename... Args>\n+bool\n+is_format_string_for(const char* str, Args&&... args)\n+{\n+  try {\n+    (void) std::vformat(str, std::make_format_args(args...));\n+    return true;\n+  } catch (const std::format_error&) {\n+    return false;\n+  }\n+}\n+\n+void\n+test_bad_format_strings()\n+{\n+  std::chrono::sys_seconds t{};\n+\n+  // literal '%' must be formatted as \"%%\"\n+  VERIFY( not is_format_string_for(\"{:%}\", t) );\n+\n+  // chrono-specs must start with '%'\n+  VERIFY( not is_format_string_for(\"{:a%}\", t) );\n+  VERIFY( not is_format_string_for(\"{:La%}\", t) );\n+\n+  // '{' not valid in chrono-specs\n+  VERIFY( not is_format_string_for(\"{:%%{{%%}\", t) );\n+\n+  // padding with leading zero not valid for chrono types\n+  VERIFY( not is_format_string_for(\"{:04%T}\", t) );\n+\n+  // precision only valid for chrono::duration types with floating-point rep.\n+  VERIFY( not is_format_string_for(\"{:.4}\", t) );\n+\n+  // unfinished format string\n+  VERIFY( not is_format_string_for(\"{:\", t) );\n+\n+  // dangling modifiers\n+  VERIFY( not is_format_string_for(\"{:%E}\", t) );\n+  VERIFY( not is_format_string_for(\"{:%O}\", t) );\n+\n+  // modifier not valid for conversion specifier\n+  VERIFY( not is_format_string_for(\"{:%Ea}\", t) );\n+  VERIFY( not is_format_string_for(\"{:%Oa}\", t) );\n+}\n+\n+template<typename I>\n+struct move_only_iterator\n+{\n+  using iterator = I;\n+  using value_type = iterator::value_type;\n+  using difference_type = iterator::difference_type;\n+  using iterator_category = std::output_iterator_tag;\n+\n+  move_only_iterator(iterator b) : base_(b) { }\n+  move_only_iterator(move_only_iterator&&) = default;\n+  move_only_iterator& operator=(move_only_iterator&&) = default;\n+\n+  move_only_iterator& operator++() { ++base_; return *this; }\n+  move_only_iterator operator++(int) { auto tmp = *this; ++base_; return tmp; }\n+\n+  decltype(auto) operator*() { return *base_; }\n+\n+private:\n+  iterator base_;\n+};\n+\n+void\n+test_move_only_iterator()\n+{\n+  using namespace std::chrono;\n+  utc_seconds ut(1671543754s);\n+  sys_seconds st(1671543727s);\n+\n+  std::string str;\n+  move_only_iterator mo(std::back_inserter(str));\n+  std::format_to(std::move(mo), \"{:%F} {:%T} {:%Q}\", ut, st, 1s);\n+  VERIFY( str == \"2022-12-20 13:42:07 1\" );\n+\n+  std::vector<wchar_t> vec;\n+  move_only_iterator wmo(std::back_inserter(vec));\n+  std::format_to(std::move(wmo), L\"{:%F} {:%T} {:%Q}\", ut, st, 2s);\n+  VERIFY( std::wstring_view(vec.data(), vec.size()) == L\"2022-12-20 13:42:07 2\" );\n+}\n+\n+int main()\n+{\n+  test_format_strings();\n+  test_bad_format_strings();\n+  test_move_only_iterator();\n+}"}, {"sha": "3b50f40c1f670ff6222693bea4aa5f567b427ab6", "filename": "libstdc++-v3/testsuite/std/time/hh_mm_ss/io.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using std::ostringstream;\n+  using std::chrono::hh_mm_ss;\n+  using namespace std::chrono_literals;\n+\n+  std::locale::global(std::locale::classic());\n+\n+  {\n+    hh_mm_ss hms{-4083007ms};\n+    ostringstream out;\n+    out << hms;\n+    VERIFY( out.str() == \"-01:08:03.007\" );\n+  }\n+\n+  {\n+    hh_mm_ss hms{4083007ms};\n+    ostringstream out;\n+    out << hms;\n+    VERIFY( out.str() == \"01:08:03.007\" );\n+  }\n+\n+  {\n+    hh_mm_ss hms{65745123ms};\n+    ostringstream out;\n+    out << hms;\n+    VERIFY( out.str() == \"18:15:45.123\" );\n+  }\n+\n+  ostringstream out;\n+  out << hh_mm_ss{65745s};\n+  VERIFY( out.str() == \"18:15:45\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "7ceeafd725a88496fe6d1c0121a9d90876787b3d", "filename": "libstdc++-v3/testsuite/std/time/month/io.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,98 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-namedlocale \"fr_FR.ISO8859-15\" }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using std::ostringstream;\n+  using namespace std::chrono;\n+\n+  ostringstream ss;\n+  for (int i = 1; i <= 12; ++i)\n+    ss << month(i);\n+  VERIFY( ss.str() == \"JanFebMarAprMayJunJulAugSepOctNovDec\" );\n+  ss.str(\"\");\n+  ss << month(0) << '|' << month(13);\n+  VERIFY( ss.str() == \"0 is not a valid month|13 is not a valid month\" );\n+\n+  ss.str(\"\");\n+  ss.imbue(std::locale(ISO_8859(15,fr_FR)));\n+  ss << month(1);\n+  VERIFY( ss.str() == \"janv.\" );\n+}\n+\n+void\n+test_format()\n+{\n+  using std::chrono::month;\n+\n+  auto s = std::format(\"{:%b%%%B%t%m%n}\", month(1));\n+  VERIFY( s == \"Jan%January\\t01\\n\" );\n+  auto ws = std::format(L\"{:%b%%%B%t%m%n}\", month(12));\n+  VERIFY( ws == L\"Dec%December\\t12\\n\" );\n+\n+  try\n+  {\n+    (void) std::format(\"{:%b}\", month(13));\n+    VERIFY(false);\n+  }\n+  catch (const std::format_error&)\n+  {\n+  }\n+\n+  s = std::format(\"{} is OK, but {:L}\", month(2), month(13));\n+  VERIFY( s == \"Feb is OK, but 13 is not a valid month\" );\n+\n+  std::locale loc_fr(ISO_8859(15,fr_FR));\n+\n+  s = std::format(\"{:%Om}\", month(1));\n+  VERIFY( s == \"01\" );\n+  s = std::format(std::locale::classic(), \"{:%Om}\", month(1));\n+  VERIFY( s == \"01\" );\n+  s = std::format(std::locale::classic(), \"{:L%Om}\", month(1));\n+  VERIFY( s == \"01\" );\n+  s = std::format(loc_fr, \"{:%Om}\", month(1));\n+  VERIFY( s == \"01\" );\n+  s = std::format(loc_fr, \"{:L%Om}\", month(1));\n+  VERIFY( s == \"01\" );\n+  // TODO test \"{:L%Om}\" with locale that has alternative numeric rep.\n+\n+  s = std::format(loc_fr, \"{:%b}\", month(1));\n+  VERIFY( s == \"Jan\" );\n+  s = std::format(loc_fr, \"{:L%b}\", month(1));\n+  VERIFY( s == \"janv.\" );\n+\n+  std::string_view specs = \"aAbBcCdDeFgGhHIjmMpqQrRSTuUVwWxXyYzZ\";\n+  std::string_view my_specs = \"bBhm\";\n+  for (char c : specs)\n+  {\n+    char fmt[] = { '{', ':', '%', c, '}' };\n+    try\n+    {\n+      (void) std::vformat(std::string_view(fmt, 5),\n+\t\t\t  std::make_format_args(month(1)));\n+      // The call above should throw for any conversion-spec not in my_specs:\n+      VERIFY(my_specs.find(c) != my_specs.npos);\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(my_specs.find(c) == my_specs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+  }\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+  test_format();\n+  // TODO: test_parse();\n+}"}, {"sha": "ad6f58bc9a19ffd2cd1464a71a90f2708c0d26b5", "filename": "libstdc++-v3/testsuite/std/time/syn_c++20.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fsyn_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fsyn_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fsyn_c%2B%2B20.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -124,8 +124,7 @@ namespace __gnu_test\n   using std::chrono::time_zone_link;\n #endif\n \n-  // FIXME\n-  // using std::chrono::local_time_format;\n+  using std::chrono::local_time_format;\n \n   // FIXME\n   // using std::chrono::parse;"}, {"sha": "46ca34b71fd40a68764a003484f9ed21fa05e6da", "filename": "libstdc++-v3/testsuite/std/time/time_zone/get_info_local.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_local.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_local.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_local.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -148,7 +148,6 @@ test_egypt()\n   VERIFY( info.second.save == 1h );\n   VERIFY( info.second.abbrev == \"EEST\" );\n \n-#if 0\n   std::ostringstream out;\n   local_seconds lt(local_days(2001y/January/1));\n   const local_days end(2021y/January/1);\n@@ -209,7 +208,6 @@ test_egypt()\n [[2014-09-25 21:00:00,32767-12-31 00:00:00,02:00:00,0min,EET]]\n )\";\n   VERIFY( out.str() == expected );\n-#endif\n }\n \n int main()"}, {"sha": "6cdb98467b13761755ad863448c1ec6b44fd6589", "filename": "libstdc++-v3/testsuite/std/time/weekday/io.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-namedlocale \"fr_FR.ISO8859-15\" }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using std::ostringstream;\n+  using namespace std::chrono;\n+\n+  ostringstream ss;\n+  for (int i = 0; i <= 7; ++i)\n+    ss << weekday(i);\n+  VERIFY( ss.str() == \"SunMonTueWedThuFriSatSun\" );\n+  ss.str(\"\");\n+  ss << weekday(8) << '|' << weekday(99);\n+  VERIFY( ss.str() == \"8 is not a valid weekday|99 is not a valid weekday\" );\n+\n+  ss.str(\"\");\n+  ss.imbue(std::locale(ISO_8859(15,fr_FR)));\n+  ss << weekday(6);\n+  VERIFY( ss.str() == \"sam.\" );\n+}\n+\n+void\n+test_format()\n+{\n+  using std::chrono::weekday;\n+\n+  auto s = std::format(\"{:%a%%%A%t%u%n%w}\", std::chrono::Monday);\n+  VERIFY( s == \"Mon%Monday\\t1\\n1\" );\n+  auto ws = std::format(L\"{:%a%%%A%t%u%n%w}\", weekday(7));\n+  VERIFY( ws == L\"Sun%Sunday\\t7\\n0\" );\n+\n+  s = std::format(\"{:%w}\", weekday(8));\n+  VERIFY( s == \"8\" );\n+\n+  try\n+  {\n+    (void) std::format(\"{:%a}\", weekday(8));\n+    VERIFY(false);\n+  }\n+  catch (const std::format_error&)\n+  {\n+  }\n+\n+  s = std::format(\"{} is OK, but {:L}\", weekday(2), weekday(13));\n+  VERIFY( s == \"Tue is OK, but 13 is not a valid weekday\" );\n+\n+  std::locale loc_fr(ISO_8859(15,fr_FR));\n+\n+  s = std::format(\"{:%Ow}\", weekday(1));\n+  VERIFY( s == \"1\" );\n+  s = std::format(std::locale::classic(), \"{:%Ow}\", weekday(1));\n+  VERIFY( s == \"1\" );\n+  s = std::format(std::locale::classic(), \"{:L%Ow}\", weekday(1));\n+  VERIFY( s == \"1\" );\n+  s = std::format(loc_fr, \"{:%Ow}\", weekday(1));\n+  VERIFY( s == \"1\" );\n+  s = std::format(loc_fr, \"{:L%Ow}\", weekday(1));\n+  VERIFY( s == \"1\" );\n+  // TODO test \"{:L%Ow}\" with locale that has alternative numeric rep.\n+\n+  s = std::format(loc_fr, \"{:%a}\", weekday(1));\n+  VERIFY( s == \"Mon\" );\n+  s = std::format(loc_fr, \"{:L%a}\", weekday(1));\n+  VERIFY( s == \"lun.\" );\n+\n+  std::string_view specs = \"aAbBcCdDeFgGhHIjmMpqQrRSTuUVwWxXyYzZ\";\n+  std::string_view my_specs = \"aAuw\";\n+  for (char c : specs)\n+  {\n+    char fmt[] = { '{', ':', '%', c, '}' };\n+    try\n+    {\n+      (void) std::vformat(std::string_view(fmt, 5),\n+\t\t\t  std::make_format_args(weekday(1)));\n+      // The call above should throw for any conversion-spec not in my_specs:\n+      VERIFY(my_specs.find(c) != my_specs.npos);\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(my_specs.find(c) == my_specs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+  }\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+  test_format();\n+  // TODO: test_parse();\n+}"}, {"sha": "07316e98aa527a58d2917e9db4e17cf32228e101", "filename": "libstdc++-v3/testsuite/std/time/year/io.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-namedlocale \"fr_FR.ISO8859-15\" }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using std::ostringstream;\n+  using namespace std::chrono;\n+\n+  ostringstream ss;\n+  for (int y : {-1234, -44, -1, 0, 5, 32, 325, 1066, 2022})\n+    ss << year(y) << ' ';\n+  VERIFY( ss.str() == \"-1234 -0044 -0001 0000 0005 0032 0325 1066 2022 \" );\n+  ss.str(\"\");\n+  ss << year::min() << ' ' << year::max() << ' ' << --year::min();\n+  VERIFY( ss.str() == \"-32767 32767 -32768 is not a valid year\" );\n+\n+  ss.str(\"\");\n+  ss.imbue(std::locale(ISO_8859(15,fr_FR)));\n+  ss << 1789y;\n+  VERIFY( ss.str() == \"1789\" );\n+}\n+\n+void\n+test_format()\n+{\n+  using std::chrono::year;\n+  using namespace std::chrono_literals;\n+\n+  auto s = std::format(\"{:%y%%%Y%t%C%n}\", 2022y);\n+  VERIFY( s == \"22%2022\\t20\\n\" );\n+  auto ws = std::format(L\"{:%y%%%Y%t%C%n}\", 2023y);\n+  VERIFY( ws == L\"23%2023\\t20\\n\" );\n+\n+  s = std::format(\"{:%Y}\", --year::min());\n+  VERIFY( s == \"-32768\" );\n+\n+  s = std::format(\"{}\", --year::min()); // formatted via ostream\n+  VERIFY( s == \"-32768 is not a valid year\" );\n+\n+  s = std::format(\"{:%y} {:%y}\", 1976y, -1976y);\n+  VERIFY( s == \"76 76\" ); // LWG 3831\n+\n+  s = std::format(\"{0:%EC}{0:%Ey} = {0:%EY}\", 1642y);\n+  VERIFY( s == \"1642 = 1642\" );\n+  s = std::format(\"{0:L%EC}{0:L%Ey} = {0:L%EY}\", 1642y);\n+  VERIFY( s == \"1642 = 1642\" );\n+  s = std::format(std::locale::classic(), \"{0:L%EC}{0:L%Ey} = {0:L%EY}\", 1642y);\n+  VERIFY( s == \"1642 = 1642\" );\n+\n+  // TODO test \"{:L%EC}\" with locale that has alternative era rep.\n+  // TODO test \"{:L%Ey}\" with locale that has alternative year rep.\n+  // TODO test \"{:L%EY}\" with locale that has alternative year rep.\n+  // TODO test \"{:L%Oy}\" with locale that has alternative numeric rep.\n+\n+  std::string_view specs = \"aAbBcCdDeFgGhHIjmMpqQrRSTuUVwWxXyYzZ\";\n+  std::string_view my_specs = \"CyY\";\n+  for (char c : specs)\n+  {\n+    char fmt[] = { '{', ':', '%', c, '}' };\n+    try\n+    {\n+      (void) std::vformat(std::string_view(fmt, 5),\n+\t\t\t  std::make_format_args(year(2022)));\n+      // The call above should throw for any conversion-spec not in my_specs:\n+      VERIFY(my_specs.find(c) != my_specs.npos);\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(my_specs.find(c) == my_specs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+  }\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+  test_format();\n+  // TODO: test_parse();\n+}"}, {"sha": "688885b37a1ddcda9cc75531fa9a46701116c626", "filename": "libstdc++-v3/testsuite/std/time/year_month_day/io.cc", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day%2Fio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b94865fa629cc2cc937128a812b6a23038446/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day%2Fio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day%2Fio.cc?ref=f99b94865fa629cc2cc937128a812b6a23038446", "patch": "@@ -0,0 +1,121 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-namedlocale \"fr_FR.ISO8859-15\" }\n+\n+#include <chrono>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_ostream()\n+{\n+  using std::ostringstream;\n+  using namespace std::chrono;\n+\n+  ostringstream ss;\n+  ss << 2022y/December/19 << ' ' << 2022y/November/31;\n+  VERIFY( ss.str() == \"2022-12-19 2022-11-31 is not a valid date\" );\n+\n+  ss.str(\"\");\n+  ss.imbue(std::locale(ISO_8859(15,fr_FR)));\n+  ss << 1789y/July/14;\n+  VERIFY( ss.str() == \"1789-07-14\" );\n+}\n+\n+void\n+test_format()\n+{\n+  using std::chrono::year_month_day;\n+  using std::chrono::December;\n+  using std::chrono::January;\n+  using namespace std::chrono_literals;\n+\n+  auto s = std::format(\"{:%y%%%Y%t%C%n%j %a %b}\", 2022y/December/19);\n+  VERIFY( s == \"22%2022\\t20\\n353 Mon Dec\" );\n+  auto ws = std::format(L\"{:%y%%%Y%t%C%n%d}\", 2023y/January/32);\n+  VERIFY( ws == L\"23%2023\\t20\\n32\" );\n+\n+  s = std::format(\"{:%F} {}\", 2023y/January/32, 2023y/January/32);\n+  VERIFY( s == \"2023-01-32 2023-01-32 is not a valid date\" );\n+\n+  s = std::format(\"{:%C%g-W%V-%u}\", 2022y/January/1);\n+  VERIFY( s == \"2021-W52-6\" );\n+  s = std::format(\"{:%G-W%V-%u}\", 2022y/January/3);\n+  VERIFY( s == \"2022-W01-1\" );\n+\n+  // %U: Week number for weeks starting on Sunday\n+  s = std::format(\"Day {:%w (%a) of Week %U of %Y}\", 2022y/January/1);\n+  VERIFY( s == \"Day 6 (Sat) of Week 00 of 2022\" );\n+  s = std::format(\"Day {:%w (%a) of Week %U of %Y}\", 2022y/January/2);\n+  VERIFY( s == \"Day 0 (Sun) of Week 01 of 2022\" );\n+  // %W: Week number for weeks starting on Monday\n+  s = std::format(\"Day {:%u (%a) of Week %W of %Y}\", 2022y/January/2);\n+  VERIFY( s == \"Day 7 (Sun) of Week 00 of 2022\" );\n+  s = std::format(\"Day {:%u (%a) of Week %W of %Y}\", 2022y/January/3);\n+  VERIFY( s == \"Day 1 (Mon) of Week 01 of 2022\" );\n+\n+  // %V: ISO week number (ISO 8601).\n+  s = std::format(\"W{:%V}\", 1977y/1/1);\n+  VERIFY( s == \"W53\" );\n+  s = std::format(\"W{:%V}\", 1977y/1/2);\n+  VERIFY( s == \"W53\" );\n+  s = std::format(\"W{:%V}\", 1977y/12/31);\n+  VERIFY( s == \"W52\" );\n+  s = std::format(\"W{:%V}\", 1978y/1/1);\n+  VERIFY( s == \"W52\" );\n+  s = std::format(\"W{:%V}\", 1978y/1/2);\n+  VERIFY( s == \"W01\" );\n+  s = std::format(\"W{:%V}\", 1978y/12/31);\n+  VERIFY( s == \"W52\" );\n+  s = std::format(\"W{:%V}\", 1979y/1/1);\n+  VERIFY( s == \"W01\" );\n+  s = std::format(\"W{:%V}\", 1979y/12/30);\n+  VERIFY( s == \"W52\" );\n+  s = std::format(\"W{:%V}\", 1979y/12/31);\n+  VERIFY( s == \"W01\" );\n+  s = std::format(\"W{:%V}\", 1980y/1/1);\n+  VERIFY( s == \"W01\" );\n+\n+  s = std::format(\"{:%x}\", 2022y/December/19);\n+  VERIFY( s == \"12/19/22\" );\n+  s = std::format(\"{:L%x}\", 2022y/December/19);\n+  VERIFY( s == \"12/19/22\" );\n+  std::locale loc_fr(ISO_8859(15,fr_FR));\n+  s = std::format(loc_fr, \"{:%x}\", 2022y/December/19);\n+  VERIFY( s == \"12/19/22\" );\n+  s = std::format(loc_fr, \"{:L%x}\", 2022y/December/19);\n+  VERIFY( s == \"19/12/2022\" );\n+  s = std::format(loc_fr, \"{}\", 2022y/December/19);\n+  VERIFY( s == \"2022-12-19\" );\n+  s = std::format(loc_fr, \"{:L%F}\", 2022y/December/19);\n+  VERIFY( s == \"2022-12-19\" );\n+\n+  std::string_view specs = \"aAbBcCdDeFgGhHIjmMpqQrRSTuUVwWxXyYzZ\";\n+  std::string_view my_specs = \"aAbBCdDeFgGhjmuUVwWxyY\";\n+  for (char c : specs)\n+  {\n+    char fmt[] = { '{', ':', '%', c, '}' };\n+    try\n+    {\n+      (void) std::vformat(std::string_view(fmt, 5),\n+\t\t\t  std::make_format_args(2022y/December/19));\n+      // The call above should throw for any conversion-spec not in my_specs:\n+      VERIFY(my_specs.find(c) != my_specs.npos);\n+    }\n+    catch (const std::format_error& e)\n+    {\n+      VERIFY(my_specs.find(c) == my_specs.npos);\n+      std::string_view s = e.what();\n+      // Libstdc++-specific message:\n+      VERIFY(s.find(\"format argument does not contain the information \"\n+\t\t    \"required by the chrono-specs\") != s.npos);\n+    }\n+  }\n+}\n+\n+int main()\n+{\n+  test_ostream();\n+  test_format();\n+  // TODO: test_parse();\n+}"}]}