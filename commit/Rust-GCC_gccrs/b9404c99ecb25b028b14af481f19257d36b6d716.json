{"sha": "b9404c99ecb25b028b14af481f19257d36b6d716", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk0MDRjOTllY2IyNWIwMjhiMTRhZjQ4MWYxOTI1N2QzNmI2ZDcxNg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-10-22T16:19:54Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-10-22T16:19:54Z"}, "message": "s390.md (\"movstr_short_64\", [...]): Merge ...\n\n\t* config/s390/s390.md (\"movstr_short_64\", \"movstr_short_31\"): Merge ...\n\t(\"*movstr_short\"): ... into this insn pattern.\n\t(\"movstr_short\"): New expander.\n\t(\"*movstr_long_64\"): Rename from \"movstr_long_64\", simplify.\n\t(\"*movstr_long_31\"): Rename from \"movstr_long_31\", simplify.\n\t(\"movstr_long\"): New expander.\n\t(\"clrstr_short_64\", \"clrstr_short_31\"): Merge ...\n\t(\"*clrstr_short\"): ... into this insn pattern.\n\t(\"clrstr_short\"): New expander.\n\t(\"*clrstr_long_64\"): Rename from \"clrstr_long_64\", simplify.\n\t(\"*clrstr_long_31\"): Rename from \"clrstr_long_31\", simplify.\n\t(\"clrstr_long\"): New expander.\n\t(\"cmpmem_short_64\", \"cmpmem_short_31\"): Merge ...\n\t(\"*cmpmem_short\"): ... into this insn pattern.\n\t(\"cmpmem_short\"): New expander.\n\t(\"*cmpmem_long_64\"): Rename from \"cmpmem_long_64\".\n\t(\"*cmpmem_long_31\"): Rename from \"cmpmem_long_31\".\n\t(\"cmpmem_long\"): New expander.\n\t* config/s390/s390.c (s390_expand_movstr): Use new expanders.\n\t(s390_expand_clrstr): Likewise.\n\t(s390_expand_cmpmem): Likewise.\n\nFrom-SVN: r72807", "tree": {"sha": "556f310abdba8732448e744018c36d4852a1b54a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/556f310abdba8732448e744018c36d4852a1b54a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9404c99ecb25b028b14af481f19257d36b6d716", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9404c99ecb25b028b14af481f19257d36b6d716", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9404c99ecb25b028b14af481f19257d36b6d716", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9404c99ecb25b028b14af481f19257d36b6d716/comments", "author": null, "committer": null, "parents": [{"sha": "3d05b34592f594b7c91c62d44575add57593aa81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d05b34592f594b7c91c62d44575add57593aa81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d05b34592f594b7c91c62d44575add57593aa81"}], "stats": {"total": 391, "additions": 198, "deletions": 193}, "files": [{"sha": "adc1bc099baa41b59fca2961f75ae6d152214527", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9404c99ecb25b028b14af481f19257d36b6d716/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9404c99ecb25b028b14af481f19257d36b6d716/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9404c99ecb25b028b14af481f19257d36b6d716", "patch": "@@ -1,3 +1,27 @@\n+2003-10-22  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.md (\"movstr_short_64\", \"movstr_short_31\"): Merge ...\n+\t(\"*movstr_short\"): ... into this insn pattern.\n+\t(\"movstr_short\"): New expander.\n+\t(\"*movstr_long_64\"): Rename from \"movstr_long_64\", simplify.\n+\t(\"*movstr_long_31\"): Rename from \"movstr_long_31\", simplify.\n+\t(\"movstr_long\"): New expander.\n+\t(\"clrstr_short_64\", \"clrstr_short_31\"): Merge ...\n+\t(\"*clrstr_short\"): ... into this insn pattern.\n+\t(\"clrstr_short\"): New expander.\n+\t(\"*clrstr_long_64\"): Rename from \"clrstr_long_64\", simplify.\n+\t(\"*clrstr_long_31\"): Rename from \"clrstr_long_31\", simplify.\n+\t(\"clrstr_long\"): New expander.\n+\t(\"cmpmem_short_64\", \"cmpmem_short_31\"): Merge ...\n+\t(\"*cmpmem_short\"): ... into this insn pattern.\n+\t(\"cmpmem_short\"): New expander.\n+\t(\"*cmpmem_long_64\"): Rename from \"cmpmem_long_64\".\n+\t(\"*cmpmem_long_31\"): Rename from \"cmpmem_long_31\".\n+\t(\"cmpmem_long\"): New expander.\n+\t* config/s390/s390.c (s390_expand_movstr): Use new expanders.\n+\t(s390_expand_clrstr): Likewise.\n+\t(s390_expand_cmpmem): Likewise.\n+\n 2003-10-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-pch.c (struct c_pch_validity): Add pch_init field."}, {"sha": "be564d639a293495b265a2121fd4cc8d2007d6d6", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 17, "deletions": 69, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9404c99ecb25b028b14af481f19257d36b6d716/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9404c99ecb25b028b14af481f19257d36b6d716/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b9404c99ecb25b028b14af481f19257d36b6d716", "patch": "@@ -2970,34 +2970,15 @@ legitimize_address (register rtx x, register rtx oldx ATTRIBUTE_UNUSED,\n void\n s390_expand_movstr (rtx dst, rtx src, rtx len)\n {\n-  rtx (*gen_short) (rtx, rtx, rtx) =\n-    TARGET_64BIT ? gen_movstr_short_64 : gen_movstr_short_31;\n-  rtx (*gen_long) (rtx, rtx, rtx, rtx) =\n-    TARGET_64BIT ? gen_movstr_long_64 : gen_movstr_long_31;\n-\n-\n   if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n     {\n       if (INTVAL (len) > 0)\n-        emit_insn (gen_short (dst, src, GEN_INT (INTVAL (len) - 1)));\n+        emit_insn (gen_movstr_short (dst, src, GEN_INT (INTVAL (len) - 1)));\n     }\n \n   else if (TARGET_MVCLE)\n     {\n-      enum machine_mode double_mode = TARGET_64BIT ? TImode : DImode;\n-      enum machine_mode single_mode = TARGET_64BIT ? DImode : SImode;\n-      rtx reg0 = gen_reg_rtx (double_mode);\n-      rtx reg1 = gen_reg_rtx (double_mode);\n-\n-      emit_move_insn (gen_highpart (single_mode, reg0),\n-\t\t      force_operand (XEXP (dst, 0), NULL_RTX));\n-      emit_move_insn (gen_highpart (single_mode, reg1),\n-\t\t      force_operand (XEXP (src, 0), NULL_RTX));\n-\n-      convert_move (gen_lowpart (single_mode, reg0), len, 1);\n-      convert_move (gen_lowpart (single_mode, reg1), len, 1);\n-\n-      emit_insn (gen_long (reg0, reg1, reg0, reg1));\n+      emit_insn (gen_movstr_long (dst, src, convert_to_mode (Pmode, len, 1)));\n     }\n \n   else\n@@ -3009,7 +2990,7 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n-        mode = word_mode;\n+        mode = Pmode;\n \n       type = lang_hooks.types.type_for_mode (mode, 1);\n       if (!type)\n@@ -3042,7 +3023,7 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n \t\t\t\t\t   make_tree (type, blocks),\n \t\t\t\t\t   make_tree (type, const0_rtx)));\n \n-      emit_insn (gen_short (dst, src, GEN_INT (255)));\n+      emit_insn (gen_movstr_short (dst, src, GEN_INT (255)));\n       s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n       s390_load_address (src_addr,\n@@ -3054,7 +3035,8 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n \n       expand_end_loop ();\n \n-      emit_insn (gen_short (dst, src, convert_to_mode (word_mode, count, 1)));\n+      emit_insn (gen_movstr_short (dst, src, \n+\t\t\t\t   convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n     }\n }\n@@ -3064,33 +3046,15 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n void\n s390_expand_clrstr (rtx dst, rtx len)\n {\n-  rtx (*gen_short) (rtx, rtx) =\n-    TARGET_64BIT ? gen_clrstr_short_64 : gen_clrstr_short_31;\n-  rtx (*gen_long) (rtx, rtx, rtx) =\n-    TARGET_64BIT ? gen_clrstr_long_64 : gen_clrstr_long_31;\n-\n-\n   if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n     {\n       if (INTVAL (len) > 0)\n-        emit_insn (gen_short (dst, GEN_INT (INTVAL (len) - 1)));\n+        emit_insn (gen_clrstr_short (dst, GEN_INT (INTVAL (len) - 1)));\n     }\n \n   else if (TARGET_MVCLE)\n     {\n-      enum machine_mode double_mode = TARGET_64BIT ? TImode : DImode;\n-      enum machine_mode single_mode = TARGET_64BIT ? DImode : SImode;\n-      rtx reg0 = gen_reg_rtx (double_mode);\n-      rtx reg1 = gen_reg_rtx (double_mode);\n-\n-      emit_move_insn (gen_highpart (single_mode, reg0),\n-\t\t      force_operand (XEXP (dst, 0), NULL_RTX));\n-      convert_move (gen_lowpart (single_mode, reg0), len, 1);\n-\n-      emit_move_insn (gen_highpart (single_mode, reg1), const0_rtx);\n-      emit_move_insn (gen_lowpart (single_mode, reg1), const0_rtx);\n-\n-      emit_insn (gen_long (reg0, reg1, reg0));\n+      emit_insn (gen_clrstr_long (dst, convert_to_mode (Pmode, len, 1)));\n     }\n \n   else\n@@ -3102,7 +3066,7 @@ s390_expand_clrstr (rtx dst, rtx len)\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n-        mode = word_mode;\n+        mode = Pmode;\n \n       type = lang_hooks.types.type_for_mode (mode, 1);\n       if (!type)\n@@ -3133,7 +3097,7 @@ s390_expand_clrstr (rtx dst, rtx len)\n \t\t\t\t\t   make_tree (type, blocks),\n \t\t\t\t\t   make_tree (type, const0_rtx)));\n \n-      emit_insn (gen_short (dst, GEN_INT (255)));\n+      emit_insn (gen_clrstr_short (dst, GEN_INT (255)));\n       s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n \n@@ -3143,7 +3107,7 @@ s390_expand_clrstr (rtx dst, rtx len)\n \n       expand_end_loop ();\n \n-      emit_insn (gen_short (dst, convert_to_mode (word_mode, count, 1)));\n+      emit_insn (gen_clrstr_short (dst, convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n     }\n }\n@@ -3154,10 +3118,6 @@ s390_expand_clrstr (rtx dst, rtx len)\n void\n s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n {\n-  rtx (*gen_short) (rtx, rtx, rtx) =\n-    TARGET_64BIT ? gen_cmpmem_short_64 : gen_cmpmem_short_31;\n-  rtx (*gen_long) (rtx, rtx, rtx, rtx) =\n-    TARGET_64BIT ? gen_cmpmem_long_64 : gen_cmpmem_long_31;\n   rtx (*gen_result) (rtx) =\n     GET_MODE (target) == DImode ? gen_cmpint_di : gen_cmpint_si;\n \n@@ -3169,7 +3129,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n     {\n       if (INTVAL (len) > 0)\n         {\n-          emit_insn (gen_short (op0, op1, GEN_INT (INTVAL (len) - 1)));\n+          emit_insn (gen_cmpmem_short (op0, op1, GEN_INT (INTVAL (len) - 1)));\n           emit_insn (gen_result (target));\n         }\n       else\n@@ -3178,20 +3138,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n \n   else /* if (TARGET_MVCLE) */\n     {\n-      enum machine_mode double_mode = TARGET_64BIT ? TImode : DImode;\n-      enum machine_mode single_mode = TARGET_64BIT ? DImode : SImode;\n-      rtx reg0 = gen_reg_rtx (double_mode);\n-      rtx reg1 = gen_reg_rtx (double_mode);\n-\n-      emit_move_insn (gen_highpart (single_mode, reg0),\n-\t\t      force_operand (XEXP (op0, 0), NULL_RTX));\n-      emit_move_insn (gen_highpart (single_mode, reg1),\n-\t\t      force_operand (XEXP (op1, 0), NULL_RTX));\n-\n-      convert_move (gen_lowpart (single_mode, reg0), len, 1);\n-      convert_move (gen_lowpart (single_mode, reg1), len, 1);\n-\n-      emit_insn (gen_long (reg0, reg1, reg0, reg1));\n+      emit_insn (gen_cmpmem_long (op0, op1, convert_to_mode (Pmode, len, 1)));\n       emit_insn (gen_result (target));\n     }\n \n@@ -3207,7 +3154,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n-        mode = word_mode;\n+        mode = Pmode;\n \n       type = lang_hooks.types.type_for_mode (mode, 1);\n       if (!type)\n@@ -3240,7 +3187,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n \t\t\t\t\t   make_tree (type, blocks),\n \t\t\t\t\t   make_tree (type, const0_rtx)));\n \n-      emit_insn (gen_short (op0, op1, GEN_INT (255)));\n+      emit_insn (gen_cmpmem_short (op0, op1, GEN_INT (255)));\n       temp = gen_rtx_NE (VOIDmode, gen_rtx_REG (CCSmode, 33), const0_rtx);\n       temp = gen_rtx_IF_THEN_ELSE (VOIDmode, temp,\n \t\t\tgen_rtx_LABEL_REF (VOIDmode, end_label), pc_rtx);\n@@ -3258,7 +3205,8 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n \n       expand_end_loop ();\n \n-      emit_insn (gen_short (op0, op1, convert_to_mode (word_mode, count, 1)));\n+      emit_insn (gen_cmpmem_short (op0, op1, \n+\t\t\t\t   convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n \n       emit_insn (gen_result (target));"}, {"sha": "1e1b08dea534f088a10294ba0e5f30dce663ca4e", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 157, "deletions": 124, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9404c99ecb25b028b14af481f19257d36b6d716/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9404c99ecb25b028b14af481f19257d36b6d716/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=b9404c99ecb25b028b14af481f19257d36b6d716", "patch": "@@ -1785,38 +1785,22 @@\n ; Move a block that is up to 256 bytes in length.\n ; The block length is taken as (operands[2] % 256) + 1.\n \n-(define_insn \"movstr_short_64\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n-        (match_operand:BLK 1 \"memory_operand\" \"Q,Q\"))\n-   (use (match_operand:DI 2 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch:DI 3 \"=X,&a\"))]\n-  \"TARGET_64BIT\"\n-{\n-  switch (which_alternative)\n-    {\n-      case 0:\n-\treturn \"mvc\\t%O0(%b2+1,%R0),%1\";\n-\n-      case 1:\n-\toutput_asm_insn (\"bras\\t%3,.+10\", operands);\n-\toutput_asm_insn (\"mvc\\t%O0(1,%R0),%1\", operands);\n-\treturn \"ex\\t%2,0(%3)\";\n-\n-      default:\n-        abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"SS,NN\")\n-   (set_attr \"type\"    \"cs,cs\")\n-   (set_attr \"atype\"   \"*,agen\")\n-   (set_attr \"length\"  \"*,14\")])\n+(define_expand \"movstr_short\"\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (match_operand:BLK 1 \"memory_operand\" \"\"))\n+     (use (match_operand 2 \"nonmemory_operand\" \"\"))\n+     (clobber (match_dup 3))])]\n+  \"\"\n+  \"operands[3] = gen_rtx_SCRATCH (Pmode);\")\n \n-(define_insn \"movstr_short_31\"\n+(define_insn \"*movstr_short\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n         (match_operand:BLK 1 \"memory_operand\" \"Q,Q\"))\n-   (use (match_operand:SI 2 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch:SI 3 \"=X,&a\"))]\n-  \"!TARGET_64BIT\"\n+   (use (match_operand 2 \"nonmemory_operand\" \"n,a\"))\n+   (clobber (match_scratch 3 \"=X,&a\"))]\n+  \"(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)\n+   && GET_MODE (operands[3]) == Pmode\"\n {\n   switch (which_alternative)\n     {\n@@ -1839,35 +1823,60 @@\n \n ; Move a block of arbitrary length.\n \n-(define_insn \"movstr_long_64\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=d\")\n-        (ashift:TI (plus:TI (match_operand:TI 2 \"register_operand\" \"0\")\n-                            (lshiftrt:TI (match_dup 2) (const_int 64)))\n-                   (const_int 64)))\n-   (set (match_operand:TI 1 \"register_operand\" \"=d\")\n-        (ashift:TI (plus:TI (match_operand:TI 3 \"register_operand\" \"1\")\n-                            (lshiftrt:TI (match_dup 3) (const_int 64)))\n-                   (const_int 64)))\n-   (set (mem:BLK (subreg:DI (match_dup 2) 0))\n-        (mem:BLK (subreg:DI (match_dup 3) 0)))\n+(define_expand \"movstr_long\"\n+  [(parallel\n+    [(clobber (match_dup 2))\n+     (clobber (match_dup 3))\n+     (set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (match_operand:BLK 1 \"memory_operand\" \"\"))\n+     (use (match_operand 2 \"general_operand\" \"\"))\n+     (use (match_dup 3))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+{\n+  enum machine_mode dword_mode = word_mode == DImode ? TImode : DImode;\n+  rtx reg0 = gen_reg_rtx (dword_mode);\n+  rtx reg1 = gen_reg_rtx (dword_mode);\n+  rtx addr0 = gen_lowpart (Pmode, gen_highpart (word_mode, reg0));\n+  rtx addr1 = gen_lowpart (Pmode, gen_highpart (word_mode, reg1));\n+  rtx len0 = gen_lowpart (Pmode, reg0);\n+  rtx len1 = gen_lowpart (Pmode, reg1);\n+\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, reg0));\n+  emit_move_insn (addr0, force_operand (XEXP (operands[0], 0), NULL_RTX));\n+  emit_move_insn (len0, operands[2]);\n+\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n+  emit_move_insn (addr1, force_operand (XEXP (operands[1], 0), NULL_RTX));\n+  emit_move_insn (len1, operands[2]);\n+\n+  operands[0] = replace_equiv_address_nv (operands[0], addr0);\n+  operands[1] = replace_equiv_address_nv (operands[1], addr1);\n+  operands[2] = reg0;\n+  operands[3] = reg1;\n+})\n+\n+(define_insn \"*movstr_long_64\"\n+  [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n+   (clobber (match_operand:TI 1 \"register_operand\" \"=d\"))\n+   (set (mem:BLK (subreg:DI (match_operand:TI 2 \"register_operand\" \"0\") 0))\n+        (mem:BLK (subreg:DI (match_operand:TI 3 \"register_operand\" \"1\") 0)))\n+   (use (match_dup 2))\n+   (use (match_dup 3))\n    (clobber (reg:CC 33))]\n   \"TARGET_64BIT\"\n   \"mvcle\\t%0,%1,0\\;jo\\t.-4\"\n   [(set_attr \"op_type\" \"NN\")\n    (set_attr \"type\"    \"vs\")\n    (set_attr \"length\"  \"8\")])\n \n-(define_insn \"movstr_long_31\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (ashift:DI (plus:DI (match_operand:DI 2 \"register_operand\" \"0\")\n-                            (lshiftrt:DI (match_dup 2) (const_int 32)))\n-                   (const_int 32)))\n-   (set (match_operand:DI 1 \"register_operand\" \"=d\")\n-        (ashift:DI (plus:DI (match_operand:DI 3 \"register_operand\" \"1\")\n-                            (lshiftrt:DI (match_dup 3) (const_int 32)))\n-                   (const_int 32)))\n-   (set (mem:BLK (subreg:SI (match_dup 2) 0))\n-        (mem:BLK (subreg:SI (match_dup 3) 0)))\n+(define_insn \"*movstr_long_31\"\n+  [(clobber (match_operand:DI 0 \"register_operand\" \"=d\"))\n+   (clobber (match_operand:DI 1 \"register_operand\" \"=d\"))\n+   (set (mem:BLK (subreg:SI (match_operand:DI 2 \"register_operand\" \"0\") 0))\n+        (mem:BLK (subreg:SI (match_operand:DI 3 \"register_operand\" \"1\") 0)))\n+   (use (match_dup 2))\n+   (use (match_dup 3))\n    (clobber (reg:CC 33))]\n   \"!TARGET_64BIT\"\n   \"mvcle\\t%0,%1,0\\;jo\\t.-4\"\n@@ -1896,15 +1905,26 @@\n   \"s390_expand_clrstr (operands[0], operands[1]); DONE;\")\n \n ; Clear a block that is up to 256 bytes in length.\n-; The block length is taken as (operands[2] % 256) + 1.\n+; The block length is taken as (operands[1] % 256) + 1.\n \n-(define_insn \"clrstr_short_64\"\n+(define_expand \"clrstr_short\"\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (const_int 0))\n+     (use (match_operand 1 \"nonmemory_operand\" \"\"))\n+     (clobber (match_dup 2))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n+  \"operands[2] = gen_rtx_SCRATCH (Pmode);\")\n+\n+(define_insn \"*clrstr_short\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n         (const_int 0))\n-   (use (match_operand:DI 1 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch:DI 2 \"=X,&a\"))\n+   (use (match_operand 1 \"nonmemory_operand\" \"n,a\"))\n+   (clobber (match_scratch 2 \"=X,&a\"))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n+  \"(GET_MODE (operands[1]) == Pmode || GET_MODE (operands[1]) == VOIDmode)\n+   && GET_MODE (operands[2]) == Pmode\"\n {\n   switch (which_alternative)\n     {\n@@ -1925,42 +1945,40 @@\n    (set_attr \"atype\"   \"*,agen\")\n    (set_attr \"length\"  \"*,14\")])\n \n-(define_insn \"clrstr_short_31\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n-        (const_int 0))\n-   (use (match_operand:SI 1 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch:SI 2 \"=X,&a\"))\n-   (clobber (reg:CC 33))]\n-  \"!TARGET_64BIT\"\n+; Clear a block of arbitrary length.\n+\n+(define_expand \"clrstr_long\"\n+  [(parallel\n+    [(clobber (match_dup 1))\n+     (set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (const_int 0))\n+     (use (match_operand 1 \"general_operand\" \"\"))\n+     (use (match_dup 2))\n+     (clobber (reg:CC 33))])]\n+  \"\"\n {\n-  switch (which_alternative)\n-    {\n-      case 0:\n-\treturn \"xc\\t%O0(%b1+1,%R0),%0\";\n+  enum machine_mode dword_mode = word_mode == DImode ? TImode : DImode;\n+  rtx reg0 = gen_reg_rtx (dword_mode);\n+  rtx reg1 = gen_reg_rtx (dword_mode);\n+  rtx addr0 = gen_lowpart (Pmode, gen_highpart (word_mode, reg0));\n+  rtx len0 = gen_lowpart (Pmode, reg0);\n \n-      case 1:\n-\toutput_asm_insn (\"bras\\t%2,.+10\", operands);\n-\toutput_asm_insn (\"xc\\t%O0(1,%R0),%0\", operands);\n-\treturn \"ex\\t%1,0(%2)\";\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, reg0));\n+  emit_move_insn (addr0, force_operand (XEXP (operands[0], 0), NULL_RTX));\n+  emit_move_insn (len0, operands[1]);\n \n-      default:\n-        abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"SS,NN\")\n-   (set_attr \"type\"    \"cs,cs\")\n-   (set_attr \"atype\"   \"*,agen\")\n-   (set_attr \"length\"  \"*,14\")])\n+  emit_move_insn (reg1, const0_rtx);\n \n-; Clear a block of arbitrary length.\n+  operands[0] = replace_equiv_address_nv (operands[0], addr0);\n+  operands[1] = reg0;\n+  operands[2] = reg1;\n+})\n \n-(define_insn \"clrstr_long_64\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=d\")\n-        (ashift:TI (plus:TI (match_operand:TI 2 \"register_operand\" \"0\")\n-                            (lshiftrt:TI (match_dup 2) (const_int 64)))\n-                   (const_int 64)))\n-   (set (mem:BLK (subreg:DI (match_dup 2) 0))\n+(define_insn \"*clrstr_long_64\"\n+  [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n+   (set (mem:BLK (subreg:DI (match_operand:TI 2 \"register_operand\" \"0\") 0))\n         (const_int 0))\n+   (use (match_dup 2))\n    (use (match_operand:TI 1 \"register_operand\" \"d\"))\n    (clobber (reg:CC 33))]\n   \"TARGET_64BIT\"\n@@ -1969,13 +1987,11 @@\n    (set_attr \"type\"    \"vs\")\n    (set_attr \"length\"  \"8\")])\n \n-(define_insn \"clrstr_long_31\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (ashift:DI (plus:DI (match_operand:DI 2 \"register_operand\" \"0\")\n-                            (lshiftrt:DI (match_dup 2) (const_int 32)))\n-                   (const_int 32)))\n-   (set (mem:BLK (subreg:SI (match_dup 2) 0))\n+(define_insn \"*clrstr_long_31\"\n+  [(clobber (match_operand:DI 0 \"register_operand\" \"=d\"))\n+   (set (mem:BLK (subreg:SI (match_operand:DI 2 \"register_operand\" \"0\") 0))\n         (const_int 0))\n+   (use (match_dup 2))\n    (use (match_operand:DI 1 \"register_operand\" \"d\"))\n    (clobber (reg:CC 33))]\n   \"!TARGET_64BIT\"\n@@ -2011,40 +2027,24 @@\n ; Compare a block that is up to 256 bytes in length.\n ; The block length is taken as (operands[2] % 256) + 1.\n \n-(define_insn \"cmpmem_short_64\"\n-  [(set (reg:CCS 33)\n-        (compare:CCS (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n-                     (match_operand:BLK 1 \"memory_operand\" \"Q,Q\")))\n-   (use (match_operand:DI 2 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch:DI 3 \"=X,&a\"))]\n-  \"TARGET_64BIT\"\n-{\n-  switch (which_alternative)\n-    {\n-      case 0:\n-\treturn \"clc\\t%O0(%b2+1,%R0),%1\";\n-\n-      case 1:\n-\toutput_asm_insn (\"bras\\t%3,.+10\", operands);\n-\toutput_asm_insn (\"clc\\t%O0(1,%R0),%1\", operands);\n-\treturn \"ex\\t%2,0(%3)\";\n-\n-      default:\n-        abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"SS,NN\")\n-   (set_attr \"type\"    \"cs,cs\")\n-   (set_attr \"atype\"   \"*,agen\")\n-   (set_attr \"length\"  \"*,14\")])\n+(define_expand \"cmpmem_short\"\n+  [(parallel\n+    [(set (reg:CCS 33)\n+          (compare:CCS (match_operand:BLK 0 \"memory_operand\" \"\")\n+                       (match_operand:BLK 1 \"memory_operand\" \"\")))\n+     (use (match_operand 2 \"nonmemory_operand\" \"\"))\n+     (clobber (match_dup 3))])]\n+  \"\"\n+  \"operands[3] = gen_rtx_SCRATCH (Pmode);\")\n \n-(define_insn \"cmpmem_short_31\"\n+(define_insn \"*cmpmem_short\"\n   [(set (reg:CCS 33)\n         (compare:CCS (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n                      (match_operand:BLK 1 \"memory_operand\" \"Q,Q\")))\n-   (use (match_operand:SI 2 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch:SI 3 \"=X,&a\"))]\n-  \"!TARGET_64BIT\"\n+   (use (match_operand 2 \"nonmemory_operand\" \"n,a\"))\n+   (clobber (match_scratch 3 \"=X,&a\"))]\n+  \"(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)\n+   && GET_MODE (operands[3]) == Pmode\"\n {\n   switch (which_alternative)\n     {\n@@ -2067,7 +2067,40 @@\n \n ; Compare a block of arbitrary length.\n \n-(define_insn \"cmpmem_long_64\"\n+(define_expand \"cmpmem_long\"\n+  [(parallel\n+    [(clobber (match_dup 2))\n+     (clobber (match_dup 3))\n+     (set (reg:CCS 33)\n+          (compare:CCS (match_operand:BLK 0 \"memory_operand\" \"\")\n+                       (match_operand:BLK 1 \"memory_operand\" \"\")))\n+     (use (match_operand 2 \"general_operand\" \"\"))\n+     (use (match_dup 3))])]\n+  \"\"\n+{\n+  enum machine_mode dword_mode = word_mode == DImode ? TImode : DImode;\n+  rtx reg0 = gen_reg_rtx (dword_mode);\n+  rtx reg1 = gen_reg_rtx (dword_mode);\n+  rtx addr0 = gen_lowpart (Pmode, gen_highpart (word_mode, reg0));\n+  rtx addr1 = gen_lowpart (Pmode, gen_highpart (word_mode, reg1));\n+  rtx len0 = gen_lowpart (Pmode, reg0);\n+  rtx len1 = gen_lowpart (Pmode, reg1);\n+\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, reg0));\n+  emit_move_insn (addr0, force_operand (XEXP (operands[0], 0), NULL_RTX));\n+  emit_move_insn (len0, operands[2]);\n+\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n+  emit_move_insn (addr1, force_operand (XEXP (operands[1], 0), NULL_RTX));\n+  emit_move_insn (len1, operands[2]);\n+\n+  operands[0] = replace_equiv_address_nv (operands[0], addr0);\n+  operands[1] = replace_equiv_address_nv (operands[1], addr1);\n+  operands[2] = reg0;\n+  operands[3] = reg1;\n+})\n+\n+(define_insn \"*cmpmem_long_64\"\n   [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n    (clobber (match_operand:TI 1 \"register_operand\" \"=d\"))\n    (set (reg:CCS 33)\n@@ -2080,7 +2113,7 @@\n   [(set_attr \"op_type\" \"RR\")\n    (set_attr \"type\"    \"vs\")])\n \n-(define_insn \"cmpmem_long_31\"\n+(define_insn \"*cmpmem_long_31\"\n   [(clobber (match_operand:DI 0 \"register_operand\" \"=d\"))\n    (clobber (match_operand:DI 1 \"register_operand\" \"=d\"))\n    (set (reg:CCS 33)"}]}