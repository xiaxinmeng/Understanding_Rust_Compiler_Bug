{"sha": "26b21ca8608443b0b7fdd5c2aa192cdce919f9a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZiMjFjYTg2MDg0NDNiMGI3ZmRkNWMyYWExOTJjZGNlOTE5ZjlhNQ==", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2021-01-25T14:30:22Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-07T09:28:52Z"}, "message": "[Ada] Move Has_Inferable_Discriminants to Sem_Util\n\ngcc/ada/\n\n\t* exp_ch4.adb (Has_Inferable_Discriminants): Moved to Sem_Util.\n\t* sem_util.ads, sem_util.adb (Has_Inferable_Discriminants):\n\tMoved from Exp_Ch4.", "tree": {"sha": "c9a02b42b517393c477f841daa8dc5f5ffe2ab03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a02b42b517393c477f841daa8dc5f5ffe2ab03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f0d76eca6b9f9b9d451e889dad28f22885fd1a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f0d76eca6b9f9b9d451e889dad28f22885fd1a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f0d76eca6b9f9b9d451e889dad28f22885fd1a3"}], "stats": {"total": 178, "additions": 89, "deletions": 89}, "files": [{"sha": "6dc6aee8e37b03ff13fdd63063c00c1175e7da13", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=26b21ca8608443b0b7fdd5c2aa192cdce919f9a5", "patch": "@@ -176,17 +176,6 @@ package body Exp_Ch4 is\n    --  Return the size of a small signed integer type covering Lo .. Hi, the\n    --  main goal being to return a size lower than that of standard types.\n \n-   function Has_Inferable_Discriminants (N : Node_Id) return Boolean;\n-   --  Ada 2005 (AI-216): A view of an Unchecked_Union object has inferable\n-   --  discriminants if it has a constrained nominal type, unless the object\n-   --  is a component of an enclosing Unchecked_Union object that is subject\n-   --  to a per-object constraint and the enclosing object lacks inferable\n-   --  discriminants.\n-   --\n-   --  An expression of an Unchecked_Union type has inferable discriminants\n-   --  if it is either a name of an object with inferable discriminants or a\n-   --  qualified expression whose subtype mark denotes a constrained subtype.\n-\n    procedure Insert_Dereference_Action (N : Node_Id);\n    --  N is an expression whose type is an access. When the type of the\n    --  associated storage pool is derived from Checked_Pool, generate a\n@@ -13358,84 +13347,6 @@ package body Exp_Ch4 is\n       end if;\n    end Get_Size_For_Range;\n \n-   ---------------------------------\n-   -- Has_Inferable_Discriminants --\n-   ---------------------------------\n-\n-   function Has_Inferable_Discriminants (N : Node_Id) return Boolean is\n-\n-      function Prefix_Is_Formal_Parameter (N : Node_Id) return Boolean;\n-      --  Determines whether the left-most prefix of a selected component is a\n-      --  formal parameter in a subprogram. Assumes N is a selected component.\n-\n-      --------------------------------\n-      -- Prefix_Is_Formal_Parameter --\n-      --------------------------------\n-\n-      function Prefix_Is_Formal_Parameter (N : Node_Id) return Boolean is\n-         Sel_Comp : Node_Id;\n-\n-      begin\n-         --  Move to the left-most prefix by climbing up the tree\n-\n-         Sel_Comp := N;\n-         while Present (Parent (Sel_Comp))\n-           and then Nkind (Parent (Sel_Comp)) = N_Selected_Component\n-         loop\n-            Sel_Comp := Parent (Sel_Comp);\n-         end loop;\n-\n-         return Is_Formal (Entity (Prefix (Sel_Comp)));\n-      end Prefix_Is_Formal_Parameter;\n-\n-   --  Start of processing for Has_Inferable_Discriminants\n-\n-   begin\n-      --  For selected components, the subtype of the selector must be a\n-      --  constrained Unchecked_Union. If the component is subject to a\n-      --  per-object constraint, then the enclosing object must have inferable\n-      --  discriminants.\n-\n-      if Nkind (N) = N_Selected_Component then\n-         if Has_Per_Object_Constraint (Entity (Selector_Name (N))) then\n-\n-            --  A small hack. If we have a per-object constrained selected\n-            --  component of a formal parameter, return True since we do not\n-            --  know the actual parameter association yet.\n-\n-            if Prefix_Is_Formal_Parameter (N) then\n-               return True;\n-\n-            --  Otherwise, check the enclosing object and the selector\n-\n-            else\n-               return Has_Inferable_Discriminants (Prefix (N))\n-                 and then Has_Inferable_Discriminants (Selector_Name (N));\n-            end if;\n-\n-         --  The call to Has_Inferable_Discriminants will determine whether\n-         --  the selector has a constrained Unchecked_Union nominal type.\n-\n-         else\n-            return Has_Inferable_Discriminants (Selector_Name (N));\n-         end if;\n-\n-      --  A qualified expression has inferable discriminants if its subtype\n-      --  mark is a constrained Unchecked_Union subtype.\n-\n-      elsif Nkind (N) = N_Qualified_Expression then\n-         return Is_Unchecked_Union (Etype (Subtype_Mark (N)))\n-           and then Is_Constrained (Etype (Subtype_Mark (N)));\n-\n-      --  For all other names, it is sufficient to have a constrained\n-      --  Unchecked_Union nominal subtype.\n-\n-      else\n-         return Is_Unchecked_Union (Base_Type (Etype (N)))\n-           and then Is_Constrained (Etype (N));\n-      end if;\n-   end Has_Inferable_Discriminants;\n-\n    -------------------------------\n    -- Insert_Dereference_Action --\n    -------------------------------"}, {"sha": "4e8047b0b7f9cebc1ebcbfa350e0294b32a5f9d2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=26b21ca8608443b0b7fdd5c2aa192cdce919f9a5", "patch": "@@ -12435,6 +12435,84 @@ package body Sem_Util is\n       return False;\n    end Has_Fully_Default_Initializing_DIC_Pragma;\n \n+   ---------------------------------\n+   -- Has_Inferable_Discriminants --\n+   ---------------------------------\n+\n+   function Has_Inferable_Discriminants (N : Node_Id) return Boolean is\n+\n+      function Prefix_Is_Formal_Parameter (N : Node_Id) return Boolean;\n+      --  Determines whether the left-most prefix of a selected component is a\n+      --  formal parameter in a subprogram. Assumes N is a selected component.\n+\n+      --------------------------------\n+      -- Prefix_Is_Formal_Parameter --\n+      --------------------------------\n+\n+      function Prefix_Is_Formal_Parameter (N : Node_Id) return Boolean is\n+         Sel_Comp : Node_Id;\n+\n+      begin\n+         --  Move to the left-most prefix by climbing up the tree\n+\n+         Sel_Comp := N;\n+         while Present (Parent (Sel_Comp))\n+           and then Nkind (Parent (Sel_Comp)) = N_Selected_Component\n+         loop\n+            Sel_Comp := Parent (Sel_Comp);\n+         end loop;\n+\n+         return Is_Formal (Entity (Prefix (Sel_Comp)));\n+      end Prefix_Is_Formal_Parameter;\n+\n+   --  Start of processing for Has_Inferable_Discriminants\n+\n+   begin\n+      --  For selected components, the subtype of the selector must be a\n+      --  constrained Unchecked_Union. If the component is subject to a\n+      --  per-object constraint, then the enclosing object must have inferable\n+      --  discriminants.\n+\n+      if Nkind (N) = N_Selected_Component then\n+         if Has_Per_Object_Constraint (Entity (Selector_Name (N))) then\n+\n+            --  A small hack. If we have a per-object constrained selected\n+            --  component of a formal parameter, return True since we do not\n+            --  know the actual parameter association yet.\n+\n+            if Prefix_Is_Formal_Parameter (N) then\n+               return True;\n+\n+            --  Otherwise, check the enclosing object and the selector\n+\n+            else\n+               return Has_Inferable_Discriminants (Prefix (N))\n+                 and then Has_Inferable_Discriminants (Selector_Name (N));\n+            end if;\n+\n+         --  The call to Has_Inferable_Discriminants will determine whether\n+         --  the selector has a constrained Unchecked_Union nominal type.\n+\n+         else\n+            return Has_Inferable_Discriminants (Selector_Name (N));\n+         end if;\n+\n+      --  A qualified expression has inferable discriminants if its subtype\n+      --  mark is a constrained Unchecked_Union subtype.\n+\n+      elsif Nkind (N) = N_Qualified_Expression then\n+         return Is_Unchecked_Union (Etype (Subtype_Mark (N)))\n+           and then Is_Constrained (Etype (Subtype_Mark (N)));\n+\n+      --  For all other names, it is sufficient to have a constrained\n+      --  Unchecked_Union nominal subtype.\n+\n+      else\n+         return Is_Unchecked_Union (Base_Type (Etype (N)))\n+           and then Is_Constrained (Etype (N));\n+      end if;\n+   end Has_Inferable_Discriminants;\n+\n    --------------------\n    -- Has_Infinities --\n    --------------------"}, {"sha": "34d706135a7064fcceb7b23d2f5ce5a13cd3a64c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26b21ca8608443b0b7fdd5c2aa192cdce919f9a5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=26b21ca8608443b0b7fdd5c2aa192cdce919f9a5", "patch": "@@ -1388,6 +1388,17 @@ package Sem_Util is\n    --  Determine whether type Typ has a suitable Default_Initial_Condition\n    --  pragma which provides the full default initialization of the type.\n \n+   function Has_Inferable_Discriminants (N : Node_Id) return Boolean;\n+   --  Ada 2005 (AI-216): A view of an Unchecked_Union object has inferable\n+   --  discriminants if it has a constrained nominal type, unless the object\n+   --  is a component of an enclosing Unchecked_Union object that is subject\n+   --  to a per-object constraint and the enclosing object lacks inferable\n+   --  discriminants.\n+   --\n+   --  An expression of an Unchecked_Union type has inferable discriminants\n+   --  if it is either a name of an object with inferable discriminants or a\n+   --  qualified expression whose subtype mark denotes a constrained subtype.\n+\n    function Has_Infinities (E : Entity_Id) return Boolean;\n    --  Determines if the range of the floating-point type E includes\n    --  infinities. Returns False if E is not a floating-point type."}]}