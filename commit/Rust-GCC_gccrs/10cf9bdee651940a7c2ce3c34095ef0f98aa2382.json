{"sha": "10cf9bdee651940a7c2ce3c34095ef0f98aa2382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjZjliZGVlNjUxOTQwYTdjMmNlM2MzNDA5NWVmMGY5OGFhMjM4Mg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-03-22T07:23:21Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-03-22T07:23:21Z"}, "message": "cpplex.c (parse_identifier_slow): Rename parse_slow, adjust prototype, and handle lexing numbers and identifiers.\n\n\t* cpplex.c (parse_identifier_slow): Rename parse_slow, adjust\n\tprototype, and handle lexing numbers and identifiers.\n\t(parse_identifier): Update to new form of parse_slow.\n\t(parse_number): Fast path only, use parse_slow otherwise.\n\t(_cpp_lex_direct): Update calls to parse_number.\n\nFrom-SVN: r51161", "tree": {"sha": "e69357ced9a9d9cbb0d270ac457d906f2c2a8bee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e69357ced9a9d9cbb0d270ac457d906f2c2a8bee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10cf9bdee651940a7c2ce3c34095ef0f98aa2382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10cf9bdee651940a7c2ce3c34095ef0f98aa2382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10cf9bdee651940a7c2ce3c34095ef0f98aa2382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10cf9bdee651940a7c2ce3c34095ef0f98aa2382/comments", "author": null, "committer": null, "parents": [{"sha": "fbc2782eff5df7b8d6c2c4a2cdf4cb92933aeeea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc2782eff5df7b8d6c2c4a2cdf4cb92933aeeea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc2782eff5df7b8d6c2c4a2cdf4cb92933aeeea"}], "stats": {"total": 163, "additions": 83, "deletions": 80}, "files": [{"sha": "58d40e4793219442d391f2736c44182fa3c23450", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10cf9bdee651940a7c2ce3c34095ef0f98aa2382/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10cf9bdee651940a7c2ce3c34095ef0f98aa2382/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10cf9bdee651940a7c2ce3c34095ef0f98aa2382", "patch": "@@ -1,3 +1,11 @@\n+2002-03-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplex.c (parse_identifier_slow): Rename parse_slow, adjust\n+\tprototype, and handle lexing numbers and identifiers.\n+\t(parse_identifier): Update to new form of parse_slow.\n+\t(parse_number): Fast path only, use parse_slow otherwise.\n+\t(_cpp_lex_direct): Update calls to parse_number.\n+\n 2002-03-21  DJ Delorie  <dj@redhat.com>\n \n \t* bb-reorder.c (make_reorder_chain_1): Protect against"}, {"sha": "a66c36adebf8c0236d53865e358244768d43059f", "filename": "gcc/cpplex.c", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10cf9bdee651940a7c2ce3c34095ef0f98aa2382/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10cf9bdee651940a7c2ce3c34095ef0f98aa2382/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=10cf9bdee651940a7c2ce3c34095ef0f98aa2382", "patch": "@@ -77,9 +77,9 @@ static int skip_line_comment PARAMS ((cpp_reader *));\n static void adjust_column PARAMS ((cpp_reader *));\n static int skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *));\n-static cpp_hashnode *parse_identifier_slow PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t    const U_CHAR *));\n-static void parse_number PARAMS ((cpp_reader *, cpp_string *, cppchar_t, int));\n+static U_CHAR *parse_slow PARAMS ((cpp_reader *, const U_CHAR *, int,\n+\t\t\t\t   unsigned int *));\n+static void parse_number PARAMS ((cpp_reader *, cpp_string *, int));\n static int unescaped_terminator_p PARAMS ((cpp_reader *, const U_CHAR *));\n static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n static void unterminated PARAMS ((cpp_reader *, int));\n@@ -412,13 +412,13 @@ name_p (pfile, string)\n    seen:unseen identifiers in normal code; the distribution is\n    Poisson-like).  Second most common case is a new identifier, not\n    split and no dollar sign.  The other possibilities are rare and\n-   have been relegated to parse_identifier_slow.  */\n+   have been relegated to parse_slow.  */\n static cpp_hashnode *\n parse_identifier (pfile)\n      cpp_reader *pfile;\n {\n   cpp_hashnode *result;\n-  const U_CHAR *cur;\n+  const U_CHAR *cur, *base;\n \n   /* Fast-path loop.  Skim over a normal identifier.\n      N.B. ISIDNUM does not include $.  */\n@@ -428,13 +428,19 @@ parse_identifier (pfile)\n \n   /* Check for slow-path cases.  */\n   if (*cur == '?' || *cur == '\\\\' || *cur == '$')\n-    result = parse_identifier_slow (pfile, cur);\n+    {\n+      unsigned int len;\n+\n+      base = parse_slow (pfile, cur, 0, &len);\n+      result = (cpp_hashnode *)\n+\tht_lookup (pfile->hash_table, base, len, HT_ALLOCED);\n+    }\n   else\n     {\n-      const U_CHAR *base = pfile->buffer->cur - 1;\n+      base = pfile->buffer->cur - 1;\n+      pfile->buffer->cur = cur;\n       result = (cpp_hashnode *)\n \tht_lookup (pfile->hash_table, base, cur - base, HT_ALLOC);\n-      pfile->buffer->cur = cur;\n     }\n \n   /* Rarely, identifiers require diagnostics when lexed.\n@@ -458,45 +464,64 @@ parse_identifier (pfile)\n   return result;\n }\n \n-/* Slow path.  This handles identifiers which have been split, and\n-   identifiers which contain dollar signs.  The part of the identifier\n-   from PFILE->buffer->cur-1 to CUR has already been scanned.  */\n-static cpp_hashnode *\n-parse_identifier_slow (pfile, cur)\n+/* Slow path.  This handles numbers and identifiers which have been\n+   split, or contain dollar signs.  The part of the token from\n+   PFILE->buffer->cur-1 to CUR has already been scanned.  NUMBER_P is\n+   1 if it's a number, and 2 if it has a leading period.  Returns a\n+   pointer to the token's NUL-terminated spelling in permanent\n+   storage, and sets PLEN to its length.  */\n+static U_CHAR *\n+parse_slow (pfile, cur, number_p, plen)\n      cpp_reader *pfile;\n      const U_CHAR *cur;\n+     int number_p;\n+     unsigned int *plen;\n {\n   cpp_buffer *buffer = pfile->buffer;\n   const U_CHAR *base = buffer->cur - 1;\n   struct obstack *stack = &pfile->hash_table->stack;\n-  unsigned int c, saw_dollar = 0, len;\n+  unsigned int c, prevc, saw_dollar = 0;\n+\n+  /* Place any leading period.  */\n+  if (number_p == 2)\n+    obstack_1grow (stack, '.');\n \n   /* Copy the part of the token which is known to be okay.  */\n   obstack_grow (stack, base, cur - base);\n \n   /* Now process the part which isn't.  We are looking at one of\n      '$', '\\\\', or '?' on entry to this loop.  */\n+  prevc = cur[-1];\n   c = *cur++;\n   buffer->cur = cur;\n-  do\n+  for (;;)\n     {\n-      while (is_idchar (c))\n+      /* Potential escaped newline?  */\n+      buffer->backup_to = buffer->cur - 1;\n+      if (c == '?' || c == '\\\\')\n+\tc = skip_escaped_newlines (pfile);\n+\n+      if (!is_idchar (c))\n+\t{\n+\t  if (!number_p)\n+\t    break;\n+\t  if (c != '.' && !VALID_SIGN (c, prevc))\n+\t    break;\n+\t}\n+\n+      /* Handle normal identifier characters in this loop.  */\n+      do\n         {\n+\t  prevc = c;\n           obstack_1grow (stack, c);\n \n           if (c == '$')\n             saw_dollar++;\n \n           c = *buffer->cur++;\n         }\n-\n-      /* Potential escaped newline?  */\n-      buffer->backup_to = buffer->cur - 1;\n-      if (c != '?' && c != '\\\\')\n-        break;\n-      c = skip_escaped_newlines (pfile);\n+      while (is_idchar (c));\n     }\n-  while (is_idchar (c));\n \n   /* Step back over the unwanted char.  */\n   BACKUP ();\n@@ -505,79 +530,49 @@ parse_identifier_slow (pfile, cur)\n      accepted as an extension.  Don't warn about it in skipped\n      conditional blocks.  */\n   if (saw_dollar && CPP_PEDANTIC (pfile) && ! pfile->state.skipping)\n-    cpp_pedwarn (pfile, \"'$' character(s) in identifier\");\n+    cpp_pedwarn (pfile, \"'$' character(s) in identifier or number\");\n \n-  /* Identifiers are null-terminated.  */\n-  len = obstack_object_size (stack);\n+  /* Identifiers and numbers are null-terminated.  */\n+  *plen = obstack_object_size (stack);\n   obstack_1grow (stack, '\\0');\n-\n-  return (cpp_hashnode *)\n-    ht_lookup (pfile->hash_table, obstack_finish (stack), len, HT_ALLOCED);\n+  return obstack_finish (stack);\n }\n \n /* Parse a number, beginning with character C, skipping embedded\n    backslash-newlines.  LEADING_PERIOD is non-zero if there was a \".\"\n    before C.  Place the result in NUMBER.  */\n static void\n-parse_number (pfile, number, c, leading_period)\n+parse_number (pfile, number, leading_period)\n      cpp_reader *pfile;\n      cpp_string *number;\n-     cppchar_t c;\n      int leading_period;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  unsigned char *dest, *limit;\n+  const U_CHAR *cur;\n \n-  dest = BUFF_FRONT (pfile->u_buff);\n-  limit = BUFF_LIMIT (pfile->u_buff);\n+  /* Fast-path loop.  Skim over a normal number.\n+     N.B. ISIDNUM does not include $.  */\n+  cur = pfile->buffer->cur;\n+  while (ISIDNUM (*cur) || *cur == '.' || VALID_SIGN (*cur, cur[-1]))\n+    cur++;\n \n-  /* Place a leading period.  */\n-  if (leading_period)\n-    {\n-      if (dest == limit)\n-\t{\n-\t  _cpp_extend_buff (pfile, &pfile->u_buff, 1);\n-\t  dest = BUFF_FRONT (pfile->u_buff);\n-\t  limit = BUFF_LIMIT (pfile->u_buff);\n-\t}\n-      *dest++ = '.';\n-    }\n-  \n-  do\n+  /* Check for slow-path cases.  */\n+  if (*cur == '?' || *cur == '\\\\' || *cur == '$')\n+    number->text = parse_slow (pfile, cur, 1 + leading_period, &number->len);\n+  else\n     {\n-      do\n-\t{\n-\t  /* Need room for terminating null.  */\n-\t  if ((size_t) (limit - dest) < 2)\n-\t    {\n-\t      size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-\t      _cpp_extend_buff (pfile, &pfile->u_buff, 2);\n-\t      dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n-\t      limit = BUFF_LIMIT (pfile->u_buff);\n-\t    }\n-\t  *dest++ = c;\n+      const U_CHAR *base = pfile->buffer->cur - 1;\n+      U_CHAR *dest;\n \n-\t  c = *buffer->cur++;\n-\t}\n-      while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n+      number->len = cur - base + leading_period;\n+      dest = _cpp_unaligned_alloc (pfile, number->len + 1);\n+      dest[number->len] = '\\0';\n+      number->text = dest;\n \n-      /* Potential escaped newline?  */\n-      buffer->backup_to = buffer->cur - 1;\n-      if (c != '?' && c != '\\\\')\n-\tbreak;\n-      c = skip_escaped_newlines (pfile);\n+      if (leading_period)\n+\t*dest++ = '.';\n+      memcpy (dest, base, cur - base);\n+      pfile->buffer->cur = cur;\n     }\n-  while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n-\n-  /* Step back over the unwanted char.  */\n-  BACKUP ();\n-\n-  /* Null-terminate the number.  */\n-  *dest = '\\0';\n-\n-  number->text = BUFF_FRONT (pfile->u_buff);\n-  number->len = dest - number->text;\n-  BUFF_FRONT (pfile->u_buff) = dest + 1;\n }\n \n /* Subroutine of parse_string.  Emits error for unterminated strings.  */\n@@ -978,7 +973,7 @@ _cpp_lex_direct (pfile)\n     case '0': case '1': case '2': case '3': case '4':\n     case '5': case '6': case '7': case '8': case '9':\n       result->type = CPP_NUMBER;\n-      parse_number (pfile, &result->val.str, c, 0);\n+      parse_number (pfile, &result->val.str, 0);\n       break;\n \n     case 'L':\n@@ -1171,7 +1166,7 @@ _cpp_lex_direct (pfile)\n       else if (ISDIGIT (c))\n \t{\n \t  result->type = CPP_NUMBER;\n-\t  parse_number (pfile, &result->val.str, c, 1);\n+\t  parse_number (pfile, &result->val.str, 1);\n \t}\n       else if (c == '*' && CPP_OPTION (pfile, cplusplus))\n \tresult->type = CPP_DOT_STAR;"}]}