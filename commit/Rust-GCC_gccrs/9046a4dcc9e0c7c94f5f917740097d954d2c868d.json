{"sha": "9046a4dcc9e0c7c94f5f917740097d954d2c868d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0NmE0ZGNjOWUwYzdjOTRmNWY5MTc3NDAwOTdkOTU0ZDJjODY4ZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-04-04T20:55:02Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-04-04T20:55:02Z"}, "message": "frontend-passes: (optimize_lexical_comparison): New function.\n\n2010-04-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* frontend-passes: (optimize_lexical_comparison): New function.\n\t(optimize_expr): Call it.\n\t(optimize_comparison): Also handle lexical comparison functions.\n\tReturn false instad of -2 for unequal comparison.\n\n2010-04-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.dg/character_comparison_8.f90:  New test.\n\nFrom-SVN: r171953", "tree": {"sha": "82f9b1e3bdf10c2b9aeeb4ffe439dd074f6a47c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f9b1e3bdf10c2b9aeeb4ffe439dd074f6a47c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9046a4dcc9e0c7c94f5f917740097d954d2c868d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9046a4dcc9e0c7c94f5f917740097d954d2c868d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9046a4dcc9e0c7c94f5f917740097d954d2c868d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9046a4dcc9e0c7c94f5f917740097d954d2c868d/comments", "author": null, "committer": null, "parents": [{"sha": "128e09f93d6fa5fc367ad2be059c6dd674ef1049", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/128e09f93d6fa5fc367ad2be059c6dd674ef1049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/128e09f93d6fa5fc367ad2be059c6dd674ef1049"}], "stats": {"total": 104, "additions": 97, "deletions": 7}, "files": [{"sha": "b6f6b4cd02015fb3c76a3d321690617c0376b4df", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9046a4dcc9e0c7c94f5f917740097d954d2c868d/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9046a4dcc9e0c7c94f5f917740097d954d2c868d/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=9046a4dcc9e0c7c94f5f917740097d954d2c868d", "patch": "@@ -35,6 +35,7 @@ static void optimize_assignment (gfc_code *);\n static bool optimize_op (gfc_expr *);\n static bool optimize_comparison (gfc_expr *, gfc_intrinsic_op);\n static bool optimize_trim (gfc_expr *);\n+static bool optimize_lexical_comparison (gfc_expr *);\n \n /* How deep we are inside an argument list.  */\n \n@@ -119,6 +120,9 @@ optimize_expr (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n   if (optimize_trim (*e))\n     gfc_simplify_expr (*e, 0);\n \n+  if (optimize_lexical_comparison (*e))\n+    gfc_simplify_expr (*e, 0);\n+\n   if ((*e)->expr_type == EXPR_OP && optimize_op (*e))\n     gfc_simplify_expr (*e, 0);\n \n@@ -483,6 +487,34 @@ strip_function_call (gfc_expr *e)\n \n }\n \n+/* Optimization of lexical comparison functions.  */\n+\n+static bool\n+optimize_lexical_comparison (gfc_expr *e)\n+{\n+  if (e->expr_type != EXPR_FUNCTION || e->value.function.isym == NULL)\n+    return false;\n+\n+  switch (e->value.function.isym->id)\n+    {\n+    case GFC_ISYM_LLE:\n+      return optimize_comparison (e, INTRINSIC_LE);\n+\n+    case GFC_ISYM_LGE:\n+      return optimize_comparison (e, INTRINSIC_GE);\n+\n+    case GFC_ISYM_LGT:\n+      return optimize_comparison (e, INTRINSIC_GT);\n+\n+    case GFC_ISYM_LLT:\n+      return optimize_comparison (e, INTRINSIC_LT);\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n /* Recursive optimization of operators.  */\n \n static bool\n@@ -522,9 +554,25 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n   bool change;\n   int eq;\n   bool result;\n+  gfc_actual_arglist *firstarg, *secondarg;\n \n-  op1 = e->value.op.op1;\n-  op2 = e->value.op.op2;\n+  if (e->expr_type == EXPR_OP)\n+    {\n+      firstarg = NULL;\n+      secondarg = NULL;\n+      op1 = e->value.op.op1;\n+      op2 = e->value.op.op2;\n+    }\n+  else if (e->expr_type == EXPR_FUNCTION)\n+    {\n+      /* One of the lexical comparision functions.  */\n+      firstarg = e->value.function.actual;\n+      secondarg = firstarg->next;\n+      op1 = firstarg->expr;\n+      op2 = secondarg->expr;\n+    }\n+  else\n+    gcc_unreachable ();\n \n   /* Strip off unneeded TRIM calls from string comparisons.  */\n \n@@ -587,13 +635,21 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \t\t\t&& op2_left->expr_type == EXPR_CONSTANT\n \t\t\t&& op1_left->value.character.length\n \t\t\t   != op2_left->value.character.length)\n-\t\t    return -2;\n+\t\t    return false;\n \t\t  else\n \t\t    {\n \t\t      gfc_free (op1_left);\n \t\t      gfc_free (op2_left);\n-\t\t      e->value.op.op1 = op1_right;\n-\t\t      e->value.op.op2 = op2_right;\n+\t\t      if (firstarg)\n+\t\t\t{\n+\t\t\t  firstarg->expr = op1_right;\n+\t\t\t  secondarg->expr = op2_right;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  e->value.op.op1 = op1_right;\n+\t\t\t  e->value.op.op2 = op2_right;\n+\t\t\t}\n \t\t      optimize_comparison (e, op);\n \t\t      return true;\n \t\t    }\n@@ -602,8 +658,17 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \t\t{\n \t\t  gfc_free (op1_right);\n \t\t  gfc_free (op2_right);\n-\t\t  e->value.op.op1 = op1_left;\n-\t\t  e->value.op.op2 = op2_left;\n+\t\t  if (firstarg)\n+\t\t    {\n+\t\t      firstarg->expr = op1_left;\n+\t\t      secondarg->expr = op2_left;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      e->value.op.op1 = op1_left;\n+\t\t      e->value.op.op2 = op2_left;\n+\t\t    }\n+\n \t\t  optimize_comparison (e, op);\n \t\t  return true;\n \t\t}"}, {"sha": "6d723f237cf8da0a068ae398d2ace357a6ecdb63", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9046a4dcc9e0c7c94f5f917740097d954d2c868d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9046a4dcc9e0c7c94f5f917740097d954d2c868d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9046a4dcc9e0c7c94f5f917740097d954d2c868d", "patch": "@@ -1,3 +1,14 @@\n+2010-04-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.dg/character_comparison_8.f90:  New test.\n+\n+2010-04-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* frontend-passes: (optimize_lexical_comparison): New function.\n+\t(optimize_expr): Call it.\n+\t(optimize_comparison): Also handle lexical comparison functions.\n+\tReturn false instad of -2 for unequal comparison.\n+\n 2011-04-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/48412"}, {"sha": "54e31a6454b50629a0504a1769d3435ae78c0339", "filename": "gcc/testsuite/gfortran.dg/character_comparison_8.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9046a4dcc9e0c7c94f5f917740097d954d2c868d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9046a4dcc9e0c7c94f5f917740097d954d2c868d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_8.f90?ref=9046a4dcc9e0c7c94f5f917740097d954d2c868d", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+! Check for compile-time optimization of LLE and friends.\n+program main\n+  character(3) :: a\n+  a = 'ab'\n+  if (.not. LLE(a,a)) call abort\n+  if (LLT(a,a)) call abort\n+  if (.not. LGE(a,a)) call abort\n+  if (LGT(a,a)) call abort\n+end program main\n+! { dg-final { scan-tree-dump-times \"gfortran_compare_string\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}]}