{"sha": "54d58eaf29ac5a8410666ff38187a0a76f3936f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRkNThlYWYyOWFjNWE4NDEwNjY2ZmYzODE4N2EwYTc2ZjM5MzZmNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-04T15:17:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-04T15:17:10Z"}, "message": "mcore-protos.h: Remove the prototypes for mcore_arith_reg_operand...\n\n\t* config/mcore/mcore-protos.h: Remove the prototypes for\n\tmcore_arith_reg_operand, mcore_general_movsrc_operand,\n\tmcore_general_movdst_operand, mcore_reload_operand,\n\tmcore_arith_J_operand, mcore_arith_K_operand,\n\tmcore_arith_K_operand_not_0, mcore_arith_M_operand,\n\tmcore_arith_K_S_operand, mcore_arith_imm_operand,\n\tmcore_arith_any_imm_operand, mcore_arith_O_operand,\n\tmcore_literal_K_operand, mcore_addsub_operand,\n\tmcore_compare_operand, mcore_load_multiple_operation,\n\tmcore_store_multiple_operation, mcore_call_address_operand.\n\tAdd a prototype for const_ok_for_mcore.\n\t* config/mcore/mcore.c (mcore_call_address_operand,\n\tmcore_general_movsrc_operand, mcore_general_movdst_operand,\n\tmcore_arith_reg_operand, mcore_reload_operand,\n\tmcore_arith_J_operand, mcore_arith_K_operand,\n\tmcore_arith_K_operand_not_0, mcore_arith_K_S_operand,\n\tmcore_arith_M_operand, mcore_arith_imm_operand,\n\tmcore_arith_any_imm_operand, mcore_arith_O_operand,\n\tmcore_literal_K_operand, mcore_addsub_operand,\n\tmcore_compare_operand, mcore_load_multiple_operation,\n\tmcore_store_multiple_operation): Move to predicates.md.\n\t(const_ok_for_mcore): Export.\n\t* config/mcore/mcore.h (PREDICATE_CODES): Remove.\n\t* config/mcore/mcore.md: Include predicates.md.\n\t* config/mcore/predicates.md: New.\n\nFrom-SVN: r97548", "tree": {"sha": "bd2f665d1032697c82edb7329eb15a5d6b8d22b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd2f665d1032697c82edb7329eb15a5d6b8d22b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54d58eaf29ac5a8410666ff38187a0a76f3936f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54d58eaf29ac5a8410666ff38187a0a76f3936f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54d58eaf29ac5a8410666ff38187a0a76f3936f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54d58eaf29ac5a8410666ff38187a0a76f3936f6/comments", "author": null, "committer": null, "parents": [{"sha": "1f4ea8e5884a6b97b3545b7ab87a16d02b2ebdfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f4ea8e5884a6b97b3545b7ab87a16d02b2ebdfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f4ea8e5884a6b97b3545b7ab87a16d02b2ebdfd"}], "stats": {"total": 716, "additions": 368, "deletions": 348}, "files": [{"sha": "70b1eda8db1b457ad4e32488a435ff4f6f43f787", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54d58eaf29ac5a8410666ff38187a0a76f3936f6", "patch": "@@ -1,3 +1,31 @@\n+2005-04-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/mcore/mcore-protos.h: Remove the prototypes for\n+\tmcore_arith_reg_operand, mcore_general_movsrc_operand,\n+\tmcore_general_movdst_operand, mcore_reload_operand,\n+\tmcore_arith_J_operand, mcore_arith_K_operand,\n+\tmcore_arith_K_operand_not_0, mcore_arith_M_operand,\n+\tmcore_arith_K_S_operand, mcore_arith_imm_operand,\n+\tmcore_arith_any_imm_operand, mcore_arith_O_operand,\n+\tmcore_literal_K_operand, mcore_addsub_operand,\n+\tmcore_compare_operand, mcore_load_multiple_operation,\n+\tmcore_store_multiple_operation, mcore_call_address_operand.\n+\tAdd a prototype for const_ok_for_mcore.\n+\t* config/mcore/mcore.c (mcore_call_address_operand,\n+\tmcore_general_movsrc_operand, mcore_general_movdst_operand,\n+\tmcore_arith_reg_operand, mcore_reload_operand,\n+\tmcore_arith_J_operand, mcore_arith_K_operand,\n+\tmcore_arith_K_operand_not_0, mcore_arith_K_S_operand,\n+\tmcore_arith_M_operand, mcore_arith_imm_operand,\n+\tmcore_arith_any_imm_operand, mcore_arith_O_operand,\n+\tmcore_literal_K_operand, mcore_addsub_operand,\n+\tmcore_compare_operand, mcore_load_multiple_operation,\n+\tmcore_store_multiple_operation): Move to predicates.md.\n+\t(const_ok_for_mcore): Export.\n+\t* config/mcore/mcore.h (PREDICATE_CODES): Remove.\n+\t* config/mcore/mcore.md: Include predicates.md.\n+\t* config/mcore/predicates.md: New.\n+\n 2005-04-04  Andreas Krebbel  <krebbel1@de.ibm.com>\n \t    Adrian Straetling  <straetling@de.ibm.com>\n "}, {"sha": "625b80e9dcfa7b3888a4bf5a31cf85ff62fb2d50", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=54d58eaf29ac5a8410666ff38187a0a76f3936f6", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for exported functions defined in mcore.c\n-   Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Nick Clifton (nickc@redhat.com)\n \n    This file is part of GCC.\n@@ -71,25 +71,7 @@ extern int          mcore_arith_S_operand         \t(rtx);\n #ifdef HAVE_MACHINE_MODES\n extern const char * mcore_output_move          \t\t(rtx, rtx *, enum machine_mode);\n extern const char * mcore_output_movedouble    \t\t(rtx *, enum machine_mode);\n-extern int          mcore_arith_reg_operand       \t(rtx, enum machine_mode);\n-extern int          mcore_general_movsrc_operand  \t(rtx, enum machine_mode);\n-extern int          mcore_general_movdst_operand  \t(rtx, enum machine_mode);\n-extern int          mcore_reload_operand          \t(rtx, enum machine_mode);\n-extern int          mcore_arith_J_operand         \t(rtx, enum machine_mode);\n-extern int          mcore_arith_K_operand         \t(rtx, enum machine_mode);\n-extern int          mcore_arith_K_operand_not_0   \t(rtx, enum machine_mode);\n-extern int          mcore_arith_M_operand         \t(rtx, enum machine_mode);\n-extern int          mcore_arith_K_S_operand       \t(rtx, enum machine_mode);\n-extern int          mcore_arith_imm_operand       \t(rtx, enum machine_mode);\n-extern int          mcore_arith_any_imm_operand   \t(rtx, enum machine_mode);\n-extern int          mcore_arith_O_operand         \t(rtx, enum machine_mode);\n-extern int          mcore_literal_K_operand       \t(rtx, enum machine_mode);\n-extern int          mcore_addsub_operand          \t(rtx, enum machine_mode);\n-extern int          mcore_compare_operand         \t(rtx, enum machine_mode);\n-extern int          mcore_load_multiple_operation \t(rtx, enum machine_mode);\n-extern int          mcore_store_multiple_operation\t(rtx, enum machine_mode);\n-extern int          mcore_call_address_operand    \t(rtx, enum machine_mode);\n-\n+extern int          const_ok_for_mcore                  (int);\n #ifdef TREE_CODE\n extern rtx          mcore_function_arg           \t(CUMULATIVE_ARGS, enum machine_mode, tree, int);\n #endif /* TREE_CODE */"}, {"sha": "6816a805459035ec14885189da11d290d299ff85", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 307, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=54d58eaf29ac5a8410666ff38187a0a76f3936f6", "patch": "@@ -118,7 +118,6 @@ cond_type;\n \n static void       output_stack_adjust           (int, int);\n static int        calc_live_regs                (int *);\n-static int        const_ok_for_mcore            (int);\n static int        try_constant_tricks           (long, int *, int *);\n static const char *     output_inline_const     (enum machine_mode, rtx *);\n static void       layout_mcore_frame            (struct mcore_frame *);\n@@ -655,12 +654,6 @@ mcore_symbolic_address_p (rtx x)\n     }\n }\n \n-int\n-mcore_call_address_operand (rtx x, enum machine_mode mode)\n-{\n-  return register_operand (x, mode) || CONSTANT_P (x);\n-}\n-\n /* Functions to output assembly code for a function call.  */\n \n char *\n@@ -703,7 +696,7 @@ mcore_output_call (rtx operands[], int index)\n \n /* Can we load a constant with a single instruction ?  */\n \n-static int\n+int\n const_ok_for_mcore (int value)\n {\n   if (value >= 0 && value <= 127)\n@@ -1403,120 +1396,6 @@ mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED\n \n /* Predicates used by the templates.  */\n \n-/* Nonzero if OP can be source of a simple move operation.  */\n-\n-int\n-mcore_general_movsrc_operand (rtx op, enum machine_mode mode)\n-{\n-  /* Any (MEM LABEL_REF) is OK.  That is a pc-relative load.  */\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-    return 1;\n-\n-  return general_operand (op, mode);\n-}\n-\n-/* Nonzero if OP can be destination of a simple move operation.  */\n-\n-int\n-mcore_general_movdst_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG && REGNO (op) == CC_REG)\n-    return 0;\n-  \n-  return general_operand (op, mode);\n-}\n-\n-/* Nonzero if OP is a normal arithmetic register.  */\n-\n-int\n-mcore_arith_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! register_operand (op, mode))\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) == REG)\n-    return REGNO (op) != CC_REG;\n-\n-  return 1;\n-}\n-\n-/* Nonzero if OP should be recognized during reload for an ixh/ixw\n-   operand.  See the ixh/ixw patterns.  */\n-\n-int\n-mcore_reload_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mcore_arith_reg_operand (op, mode))\n-    return 1;\n-\n-  if (! reload_in_progress)\n-    return 0;\n-\n-  return GET_CODE (op) == MEM;\n-}\n-\n-/* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n-\n-int\n-mcore_arith_J_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_J (INTVAL (op)))\n-    return 1;\n-  \n-  return 0;\n-}\n-\n-/* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n-\n-int\n-mcore_arith_K_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Nonzero if OP is a valid source operand for a shift or rotate insn.  */\n-\n-int\n-mcore_arith_K_operand_not_0 (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (   GET_CODE (op) == CONST_INT\n-      && CONST_OK_FOR_K (INTVAL (op))\n-      && INTVAL (op) != 0)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-int\n-mcore_arith_K_S_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      if (CONST_OK_FOR_K (INTVAL (op)) || CONST_OK_FOR_M (~INTVAL (op)))\n-\treturn 1;\n-    }\n-  \n-  return 0;\n-}\n-\n int\n mcore_arith_S_operand (rtx op)\n {\n@@ -1526,110 +1405,6 @@ mcore_arith_S_operand (rtx op)\n   return 0;\n }\n \n-int\n-mcore_arith_M_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Nonzero if OP is a valid source operand for loading.  */\n-\n-int\n-mcore_arith_imm_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT && const_ok_for_mcore (INTVAL (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-int\n-mcore_arith_any_imm_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Nonzero if OP is a valid source operand for a cmov with two consts +/- 1.  */\n-\n-int\n-mcore_arith_O_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_O (INTVAL (op)))\n-    return 1;\n-  \n-  return 0;\n-}\n-\n-/* Nonzero if OP is a valid source operand for a btsti.  */\n-\n-int\n-mcore_literal_K_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Nonzero if OP is a valid source operand for an add/sub insn.  */\n-\n-int\n-mcore_addsub_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      return 1;\n-      \n-      /* The following is removed because it precludes large constants from being\n-\t returned as valid source operands for and add/sub insn.  While large \n-\t constants may not directly be used in an add/sub, they may if first loaded\n-\t into a register.  Thus, this predicate should indicate that they are valid,\n-\t and the constraint in mcore.md should control whether an additional load to\n-\t register is needed. (see mcore.md, addsi). -- DAC 4/2/1998  */\n-      /*\n-\tif (CONST_OK_FOR_J(INTVAL(op)) || CONST_OK_FOR_L(INTVAL(op)))\n-          return 1;\n-      */\n-    }\n-  \n-  return 0;\n-}\n-\n-/* Nonzero if OP is a valid source operand for a compare operation.  */\n-\n-int\n-mcore_compare_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n-    return 1;\n-  \n-  return 0;\n-}\n-\n /* Expand insert bit field.  BRC  */\n \n int\n@@ -1729,87 +1504,6 @@ mcore_expand_insv (rtx operands[])\n \n   return 1;\n }\n-\n-/* Return 1 if OP is a load multiple operation.  It is known to be a\n-   PARALLEL and the first section will be tested.  */\n-\n-int\n-mcore_load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int dest_regno;\n-  rtx src_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || REGNO (SET_DEST (elt))    != (unsigned) (dest_regno + i)\n-\t  || GET_CODE (SET_SRC (elt))  != MEM\n-\t  || GET_MODE (SET_SRC (elt))  != SImode\n-\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Similar, but tests for store multiple.  */\n-\n-int\n-mcore_store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int src_regno;\n-  rtx dest_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || REGNO (SET_SRC (elt)) != (unsigned) (src_regno + i)\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n \f\n /* ??? Block move stuff stolen from m88k.  This code has not been\n    verified for correctness.  */"}, {"sha": "837b5922aded3cc1d1d28ad8ec43073e09f59f60", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=54d58eaf29ac5a8410666ff38187a0a76f3936f6", "patch": "@@ -1047,24 +1047,4 @@ extern long mcore_current_compilation_timestamp;\n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n   ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '!')\n \n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  { \"mcore_arith_reg_operand\",\t\t{ REG, SUBREG }},\t\t\\\n-  { \"mcore_general_movsrc_operand\",\t{ MEM, CONST_INT, REG, SUBREG, SYMBOL_REF, LABEL_REF }},\\\n-  { \"mcore_general_movdst_operand\",\t{ MEM, CONST_INT, REG, SUBREG }},\\\n-  { \"mcore_reload_operand\",\t        { MEM, REG, SUBREG }},\t\t\\\n-  { \"mcore_arith_J_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_arith_K_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_arith_K_operand_not_0\",\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_arith_M_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_arith_K_S_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_arith_O_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_arith_imm_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_arith_any_imm_operand\",\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_literal_K_operand\",\t\t{ CONST_INT }},\t\t\t\\\n-  { \"mcore_addsub_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_compare_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n-  { \"mcore_load_multiple_operation\",\t{ PARALLEL }},\t\t\t\\\n-  { \"mcore_store_multiple_operation\",\t{ PARALLEL }},\t\t\t\\\n-  { \"mcore_call_address_operand\",\t{ REG, SUBREG, CONST_INT, SYMBOL_REF }},\t\\\n-\n #endif /* ! GCC_MCORE_H */"}, {"sha": "551587494d7cd4c7416ac50ad772adb451a11400", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=54d58eaf29ac5a8410666ff38187a0a76f3936f6", "patch": "@@ -1,5 +1,6 @@\n ;;  Machine description the Motorola MCore\n-;;  Copyright (C) 1993, 1999, 2000, 2004 Free Software Foundation, Inc.\n+;;  Copyright (C) 1993, 1999, 2000, 2004, 2005\n+;;  Free Software Foundation, Inc.\n ;;  Contributed by Motorola.\n \n ;; This file is part of GCC.\n@@ -53,6 +54,8 @@\n \t\t\t (eq_attr \"type\" \"load\")\n \t\t\t \"nothing\")\n \n+(include \"predicates.md\")\n+\n ;; -------------------------------------------------------------------------\n ;; Test and bit test\n ;; -------------------------------------------------------------------------"}, {"sha": "56089036ba347d3efdd22b667fbd1d8980124606", "filename": "gcc/config/mcore/predicates.md", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54d58eaf29ac5a8410666ff38187a0a76f3936f6/gcc%2Fconfig%2Fmcore%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fpredicates.md?ref=54d58eaf29ac5a8410666ff38187a0a76f3936f6", "patch": "@@ -0,0 +1,333 @@\n+;; Predicate definitions for FIXME FIXME.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Nonzero if OP is a normal arithmetic register.\n+\n+(define_predicate \"mcore_arith_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! register_operand (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) == REG)\n+    return REGNO (op) != CC_REG;\n+\n+  return 1;\n+})\n+\n+;; Nonzero if OP can be source of a simple move operation.\n+\n+(define_predicate \"mcore_general_movsrc_operand\"\n+  (match_code \"mem,const_int,reg,subreg,symbol_ref,label_ref\")\n+{\n+  /* Any (MEM LABEL_REF) is OK.  That is a pc-relative load.  */\n+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+    return 1;\n+\n+  return general_operand (op, mode);\n+})\n+\n+;; Nonzero if OP can be destination of a simple move operation.\n+\n+(define_predicate \"mcore_general_movdst_operand\"\n+  (match_code \"mem,const_int,reg,subreg\")\n+{\n+  if (GET_CODE (op) == REG && REGNO (op) == CC_REG)\n+    return 0;\n+\n+  return general_operand (op, mode);\n+})\n+\n+;; Nonzero if OP should be recognized during reload for an ixh/ixw\n+;; operand.  See the ixh/ixw patterns.\n+\n+(define_predicate \"mcore_reload_operand\"\n+  (match_code \"mem,reg,subreg\")\n+{\n+  if (mcore_arith_reg_operand (op, mode))\n+    return 1;\n+\n+  if (! reload_in_progress)\n+    return 0;\n+\n+  return GET_CODE (op) == MEM;\n+})\n+\n+;; Nonzero if OP is a valid source operand for an arithmetic insn.\n+\n+(define_predicate \"mcore_arith_J_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_J (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Nonzero if OP is a valid source operand for an arithmetic insn.\n+\n+(define_predicate \"mcore_arith_K_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Nonzero if OP is a valid source operand for a shift or rotate insn.\n+\n+(define_predicate \"mcore_arith_K_operand_not_0\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (   GET_CODE (op) == CONST_INT\n+      && CONST_OK_FOR_K (INTVAL (op))\n+      && INTVAL (op) != 0)\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"mcore_arith_M_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"mcore_arith_K_S_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (CONST_OK_FOR_K (INTVAL (op)) || CONST_OK_FOR_M (~INTVAL (op)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+})\n+\n+;; Nonzero if OP is a valid source operand for a cmov with two consts\n+;; +/- 1.\n+\n+(define_predicate \"mcore_arith_O_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_O (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Nonzero if OP is a valid source operand for loading.\n+\n+(define_predicate \"mcore_arith_imm_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT && const_ok_for_mcore (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"mcore_arith_any_imm_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Nonzero if OP is a valid source operand for a btsti.\n+\n+(define_predicate \"mcore_literal_K_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Nonzero if OP is a valid source operand for an add/sub insn.\n+\n+(define_predicate \"mcore_addsub_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      return 1;\n+\n+      /* The following is removed because it precludes large constants from being\n+\t returned as valid source operands for and add/sub insn.  While large\n+\t constants may not directly be used in an add/sub, they may if first loaded\n+\t into a register.  Thus, this predicate should indicate that they are valid,\n+\t and the constraint in mcore.md should control whether an additional load to\n+\t register is needed. (see mcore.md, addsi). -- DAC 4/2/1998  */\n+      /*\n+\tif (CONST_OK_FOR_J(INTVAL(op)) || CONST_OK_FOR_L(INTVAL(op)))\n+          return 1;\n+      */\n+    }\n+\n+  return 0;\n+})\n+\n+;; Nonzero if OP is a valid source operand for a compare operation.\n+\n+(define_predicate \"mcore_compare_operand\"\n+  (match_code \"const_int,reg,subreg\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Return 1 if OP is a load multiple operation.  It is known to be a\n+;; PARALLEL and the first section will be tested.\n+\n+(define_predicate \"mcore_load_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int dest_regno;\n+  rtx src_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || REGNO (SET_DEST (elt))    != (unsigned) (dest_regno + i)\n+\t  || GET_CODE (SET_SRC (elt))  != MEM\n+\t  || GET_MODE (SET_SRC (elt))  != SImode\n+\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Similar, but tests for store multiple.\n+\n+(define_predicate \"mcore_store_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int src_regno;\n+  rtx dest_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || REGNO (SET_SRC (elt)) != (unsigned) (src_regno + i)\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"mcore_call_address_operand\"\n+  (match_code \"reg,subreg,const_int,symbol_ref\")\n+{\n+  return register_operand (op, mode) || CONSTANT_P (op);\n+})"}]}