{"sha": "6d360fd8f2abfb37c7f2bc926678073948160ffd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQzNjBmZDhmMmFiZmIzN2M3ZjJiYzkyNjY3ODA3Mzk0ODE2MGZmZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-04-22T07:08:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-04-22T07:08:58Z"}, "message": "re PR fortran/26769 (Implement transpose() and reshape() for real instead of using integer)\n\n\tPR fortran/26769\n\t* iresolve.c (gfc_resolve_reshape): Use reshape_r16 for real(16).\n\t(gfc_resolve_transpose): Use transpose_r16 for real(16).\n\n\t* Makefile.am (i_transpose_c): Add generated/transpose_r16.c.\n\t(i_reshape_c): Add generated/reshape_r16.c.\n\t* Makefile.in: Regenerated.\n\t* generated/transpose_r16.c: Generated new file.\n\t* generated/redhape_r16.c: Generated new file.\n\nFrom-SVN: r113169", "tree": {"sha": "0d49ef3f971a039272960726776b051d4dc0d1ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d49ef3f971a039272960726776b051d4dc0d1ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d360fd8f2abfb37c7f2bc926678073948160ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d360fd8f2abfb37c7f2bc926678073948160ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d360fd8f2abfb37c7f2bc926678073948160ffd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d360fd8f2abfb37c7f2bc926678073948160ffd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a0b46c94487106de5d4ee7f865fea92302f8d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0b46c94487106de5d4ee7f865fea92302f8d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a0b46c94487106de5d4ee7f865fea92302f8d1c"}], "stats": {"total": 416, "additions": 407, "deletions": 9}, "files": [{"sha": "d10a53ee74c12946dcf9bf8962ee28936890c61a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d360fd8f2abfb37c7f2bc926678073948160ffd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d360fd8f2abfb37c7f2bc926678073948160ffd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6d360fd8f2abfb37c7f2bc926678073948160ffd", "patch": "@@ -1,3 +1,9 @@\n+2006-04-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/26769\n+\t* iresolve.c (gfc_resolve_reshape): Use reshape_r16 for real(16).\n+\t(gfc_resolve_transpose): Use transpose_r16 for real(16).\n+\n 2006-04-21 Paul Thomas <pault@gcc.gnu.org>\n \n \tPR fortran/27122"}, {"sha": "ecb1448df12efd4653cc7a27e2b14752625fc520", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d360fd8f2abfb37c7f2bc926678073948160ffd/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d360fd8f2abfb37c7f2bc926678073948160ffd/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=6d360fd8f2abfb37c7f2bc926678073948160ffd", "patch": "@@ -1,6 +1,6 @@\n /* Intrinsic function resolution.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n This file is part of GCC.\n@@ -1520,7 +1520,7 @@ gfc_resolve_reshape (gfc_expr * f, gfc_expr * source, gfc_expr * shape,\n \tf->value.function.name =\n \t  gfc_get_string (PREFIX(\"reshape_%c%d\"),\n \t\t\t  gfc_type_letter (BT_COMPLEX), source->ts.kind);\n-      else if (source->ts.type == BT_REAL && kind == 10)\n+      else if (source->ts.type == BT_REAL && (kind == 10 || kind == 16))\n \tf->value.function.name =\n \t  gfc_get_string (PREFIX(\"reshape_%c%d\"),\n \t\t\t  gfc_type_letter (BT_REAL), source->ts.kind);\n@@ -1994,9 +1994,10 @@ gfc_resolve_transpose (gfc_expr * f, gfc_expr * matrix)\n           break;\n \n         case BT_REAL:\n-\t  /* There is no kind=10 integer type.  We need to\n+\t  /* There is no kind=10 integer type and on 32-bit targets\n+\t     there is usually no kind=16 integer type.  We need to\n \t     call the real version.  */\n-\t  if (kind == 10)\n+\t  if (kind == 10 || kind == 16)\n \t    {\n \t      f->value.function.name =\n \t\tgfc_get_string (PREFIX(\"transpose_r%d\"), kind);"}, {"sha": "bd02bbd2ed54d18ea0037045cf2fa36f588be2e3", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=6d360fd8f2abfb37c7f2bc926678073948160ffd", "patch": "@@ -1,3 +1,12 @@\n+2006-04-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/26769\n+\t* Makefile.am (i_transpose_c): Add generated/transpose_r16.c.\n+\t(i_reshape_c): Add generated/reshape_r16.c.\n+\t* Makefile.in: Regenerated.\n+\t* generated/transpose_r16.c: Generated new file.\n+\t* generated/redhape_r16.c: Generated new file.\n+\n 2006-04-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/27138"}, {"sha": "1c2fce6b97c1e674f07545d90bdf93ea4d10fbd7", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=6d360fd8f2abfb37c7f2bc926678073948160ffd", "patch": "@@ -313,6 +313,7 @@ generated/transpose_i4.c \\\n generated/transpose_i8.c \\\n generated/transpose_i16.c \\\n generated/transpose_r10.c \\\n+generated/transpose_r16.c \\\n generated/transpose_c4.c \\\n generated/transpose_c8.c \\\n generated/transpose_c10.c \\\n@@ -328,6 +329,7 @@ generated/reshape_i4.c \\\n generated/reshape_i8.c \\\n generated/reshape_i16.c \\\n generated/reshape_r10.c \\\n+generated/reshape_r16.c \\\n generated/reshape_c4.c \\\n generated/reshape_c8.c \\\n generated/reshape_c10.c \\"}, {"sha": "b5289fc1b20b79fdf622783b5238210296edb353", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=6d360fd8f2abfb37c7f2bc926678073948160ffd", "patch": "@@ -123,15 +123,15 @@ am__objects_16 = matmul_i4.lo matmul_i8.lo matmul_i16.lo matmul_r4.lo \\\n \tmatmul_c8.lo matmul_c10.lo matmul_c16.lo\n am__objects_17 = matmul_l4.lo matmul_l8.lo matmul_l16.lo\n am__objects_18 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \\\n-\ttranspose_r10.lo transpose_c4.lo transpose_c8.lo \\\n-\ttranspose_c10.lo transpose_c16.lo\n+\ttranspose_r10.lo transpose_r16.lo transpose_c4.lo \\\n+\ttranspose_c8.lo transpose_c10.lo transpose_c16.lo\n am__objects_19 = shape_i4.lo shape_i8.lo shape_i16.lo\n am__objects_20 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo\n am__objects_21 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo\n am__objects_22 = cshift1_4.lo cshift1_8.lo cshift1_16.lo\n am__objects_23 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \\\n-\treshape_r10.lo reshape_c4.lo reshape_c8.lo reshape_c10.lo \\\n-\treshape_c16.lo\n+\treshape_r10.lo reshape_r16.lo reshape_c4.lo reshape_c8.lo \\\n+\treshape_c10.lo reshape_c16.lo\n am__objects_24 = in_pack_i4.lo in_pack_i8.lo in_pack_i16.lo \\\n \tin_pack_c4.lo in_pack_c8.lo in_pack_c10.lo in_pack_c16.lo\n am__objects_25 = in_unpack_i4.lo in_unpack_i8.lo in_unpack_i16.lo \\\n@@ -661,6 +661,7 @@ generated/transpose_i4.c \\\n generated/transpose_i8.c \\\n generated/transpose_i16.c \\\n generated/transpose_r10.c \\\n+generated/transpose_r16.c \\\n generated/transpose_c4.c \\\n generated/transpose_c8.c \\\n generated/transpose_c10.c \\\n@@ -676,6 +677,7 @@ generated/reshape_i4.c \\\n generated/reshape_i8.c \\\n generated/reshape_i16.c \\\n generated/reshape_r10.c \\\n+generated/reshape_r16.c \\\n generated/reshape_c4.c \\\n generated/reshape_c8.c \\\n generated/reshape_c10.c \\\n@@ -1935,6 +1937,9 @@ transpose_i16.lo: generated/transpose_i16.c\n transpose_r10.lo: generated/transpose_r10.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transpose_r10.lo `test -f 'generated/transpose_r10.c' || echo '$(srcdir)/'`generated/transpose_r10.c\n \n+transpose_r16.lo: generated/transpose_r16.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transpose_r16.lo `test -f 'generated/transpose_r16.c' || echo '$(srcdir)/'`generated/transpose_r16.c\n+\n transpose_c4.lo: generated/transpose_c4.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transpose_c4.lo `test -f 'generated/transpose_c4.c' || echo '$(srcdir)/'`generated/transpose_c4.c\n \n@@ -1995,6 +2000,9 @@ reshape_i16.lo: generated/reshape_i16.c\n reshape_r10.lo: generated/reshape_r10.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_r10.lo `test -f 'generated/reshape_r10.c' || echo '$(srcdir)/'`generated/reshape_r10.c\n \n+reshape_r16.lo: generated/reshape_r16.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_r16.lo `test -f 'generated/reshape_r16.c' || echo '$(srcdir)/'`generated/reshape_r16.c\n+\n reshape_c4.lo: generated/reshape_c4.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_c4.lo `test -f 'generated/reshape_c4.c' || echo '$(srcdir)/'`generated/reshape_c4.c\n "}, {"sha": "a83f62468248036e8d2287c2ee320da5e7423e73", "filename": "libgfortran/generated/reshape_r16.c", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2Fgenerated%2Freshape_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2Fgenerated%2Freshape_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r16.c?ref=6d360fd8f2abfb37c7f2bc926678073948160ffd", "patch": "@@ -0,0 +1,268 @@\n+/* Implementation of the RESHAPE\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+typedef GFC_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n+\n+/* The shape parameter is ignored. We can currently deduce the shape from the\n+   return array.  */\n+\n+extern void reshape_r16 (gfc_array_r16 * const restrict, \n+\tgfc_array_r16 * const restrict, \n+\tshape_type * const restrict,\n+\tgfc_array_r16 * const restrict, \n+\tshape_type * const restrict);\n+export_proto(reshape_r16);\n+\n+void\n+reshape_r16 (gfc_array_r16 * const restrict ret, \n+\tgfc_array_r16 * const restrict source, \n+\tshape_type * const restrict shape,\n+\tgfc_array_r16 * const restrict pad, \n+\tshape_type * const restrict order)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rcount[GFC_MAX_DIMENSIONS];\n+  index_type rextent[GFC_MAX_DIMENSIONS];\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdim;\n+  index_type rsize;\n+  index_type rs;\n+  index_type rex;\n+  GFC_REAL_16 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type scount[GFC_MAX_DIMENSIONS];\n+  index_type sextent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type sdim;\n+  index_type ssize;\n+  const GFC_REAL_16 *sptr;\n+  /* p.* indicates the pad array.  */\n+  index_type pcount[GFC_MAX_DIMENSIONS];\n+  index_type pextent[GFC_MAX_DIMENSIONS];\n+  index_type pstride[GFC_MAX_DIMENSIONS];\n+  index_type pdim;\n+  index_type psize;\n+  const GFC_REAL_16 *pptr;\n+\n+  const GFC_REAL_16 *src;\n+  int n;\n+  int dim;\n+\n+  if (source->dim[0].stride == 0)\n+    source->dim[0].stride = 1;\n+  if (shape->dim[0].stride == 0)\n+    shape->dim[0].stride = 1;\n+  if (pad && pad->dim[0].stride == 0)\n+    pad->dim[0].stride = 1;\n+  if (order && order->dim[0].stride == 0)\n+    order->dim[0].stride = 1;\n+\n+  if (ret->data == NULL)\n+    {\n+      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+      rs = 1;\n+      for (n=0; n < rdim; n++)\n+\t{\n+\t  ret->dim[n].lbound = 0;\n+\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  ret->dim[n].ubound =  rex - 1;\n+\t  ret->dim[n].stride = rs;\n+\t  rs *= rex;\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size ( rs * sizeof (GFC_REAL_16));\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n+    }\n+  else\n+    {\n+      rdim = GFC_DESCRIPTOR_RANK (ret);\n+      if (ret->dim[0].stride == 0)\n+\tret->dim[0].stride = 1;\n+    }\n+\n+  rsize = 1;\n+  for (n = 0; n < rdim; n++)\n+    {\n+      if (order)\n+        dim = order->data[n * order->dim[0].stride] - 1;\n+      else\n+        dim = n;\n+\n+      rcount[n] = 0;\n+      rstride[n] = ret->dim[dim].stride;\n+      rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+\n+      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+        runtime_error (\"shape and target do not conform\");\n+\n+      if (rsize == rstride[n])\n+        rsize *= rextent[n];\n+      else\n+        rsize = 0;\n+      if (rextent[n] <= 0)\n+        return;\n+    }\n+\n+  sdim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  for (n = 0; n < sdim; n++)\n+    {\n+      scount[n] = 0;\n+      sstride[n] = source->dim[n].stride;\n+      sextent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (sextent[n] <= 0)\n+        abort ();\n+\n+      if (ssize == sstride[n])\n+        ssize *= sextent[n];\n+      else\n+        ssize = 0;\n+    }\n+\n+  if (pad)\n+    {\n+      pdim = GFC_DESCRIPTOR_RANK (pad);\n+      psize = 1;\n+      for (n = 0; n < pdim; n++)\n+        {\n+          pcount[n] = 0;\n+          pstride[n] = pad->dim[n].stride;\n+          pextent[n] = pad->dim[n].ubound + 1 - pad->dim[n].lbound;\n+          if (pextent[n] <= 0)\n+            abort ();\n+          if (psize == pstride[n])\n+            psize *= pextent[n];\n+          else\n+            psize = 0;\n+        }\n+      pptr = pad->data;\n+    }\n+  else\n+    {\n+      pdim = 0;\n+      psize = 1;\n+      pptr = NULL;\n+    }\n+\n+  if (rsize != 0 && ssize != 0 && psize != 0)\n+    {\n+      rsize *= sizeof (GFC_REAL_16);\n+      ssize *= sizeof (GFC_REAL_16);\n+      psize *= sizeof (GFC_REAL_16);\n+      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n+\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      return;\n+    }\n+  rptr = ret->data;\n+  src = sptr = source->data;\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+\n+  while (rptr)\n+    {\n+      /* Select between the source and pad arrays.  */\n+      *rptr = *src;\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      src += sstride0;\n+      rcount[0]++;\n+      scount[0]++;\n+      /* Advance to the next destination element.  */\n+      n = 0;\n+      while (rcount[n] == rextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          rcount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * rextent[n];\n+          n++;\n+          if (n == rdim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              rcount[n]++;\n+              rptr += rstride[n];\n+            }\n+        }\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (scount[n] == sextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          scount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= sstride[n] * sextent[n];\n+          n++;\n+          if (n == sdim)\n+            {\n+              if (sptr && pad)\n+                {\n+                  /* Switch to the pad array.  */\n+                  sptr = NULL;\n+                  sdim = pdim;\n+                  for (dim = 0; dim < pdim; dim++)\n+                    {\n+                      scount[dim] = pcount[dim];\n+                      sextent[dim] = pextent[dim];\n+                      sstride[dim] = pstride[dim];\n+                      sstride0 = sstride[0];\n+                    }\n+                }\n+              /* We now start again from the beginning of the pad array.  */\n+              src = pptr;\n+              break;\n+            }\n+          else\n+            {\n+              scount[n]++;\n+              src += sstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "797f3c2e557ad36e92c918ef375c1188f82ac81c", "filename": "libgfortran/generated/transpose_r16.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2Fgenerated%2Ftranspose_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d360fd8f2abfb37c7f2bc926678073948160ffd/libgfortran%2Fgenerated%2Ftranspose_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ftranspose_r16.c?ref=6d360fd8f2abfb37c7f2bc926678073948160ffd", "patch": "@@ -0,0 +1,104 @@\n+/* Implementation of the TRANSPOSE intrinsic\n+   Copyright 2003, 2005 Free Software Foundation, Inc.\n+   Contributed by Tobias Schl\ufffdter\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+extern void transpose_r16 (gfc_array_r16 * const restrict ret, \n+\tgfc_array_r16 * const restrict source);\n+export_proto(transpose_r16);\n+\n+void\n+transpose_r16 (gfc_array_r16 * const restrict ret, \n+\tgfc_array_r16 * const restrict source)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rxstride, rystride;\n+  GFC_REAL_16 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sxstride, systride;\n+  const GFC_REAL_16 *sptr;\n+\n+  index_type xcount, ycount;\n+  index_type x, y;\n+\n+  assert (GFC_DESCRIPTOR_RANK (source) == 2);\n+\n+  if (ret->data == NULL)\n+    {\n+      assert (GFC_DESCRIPTOR_RANK (ret) == 2);\n+      assert (ret->dtype == source->dtype);\n+\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = source->dim[1].ubound - source->dim[1].lbound;\n+      ret->dim[0].stride = 1;\n+\n+      ret->dim[1].lbound = 0;\n+      ret->dim[1].ubound = source->dim[0].ubound - source->dim[0].lbound;\n+      ret->dim[1].stride = ret->dim[0].ubound+1;\n+\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_16) * size0 ((array_t *) ret));\n+      ret->offset = 0;\n+    }\n+\n+  if (ret->dim[0].stride == 0)\n+    ret->dim[0].stride = 1;\n+  if (source->dim[0].stride == 0)\n+    source->dim[0].stride = 1;\n+\n+  sxstride = source->dim[0].stride;\n+  systride = source->dim[1].stride;\n+  xcount = source->dim[0].ubound + 1 - source->dim[0].lbound;\n+  ycount = source->dim[1].ubound + 1 - source->dim[1].lbound;\n+\n+  rxstride = ret->dim[0].stride;\n+  rystride = ret->dim[1].stride;\n+\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  for (y=0; y < ycount; y++)\n+    {\n+      for (x=0; x < xcount; x++)\n+        {\n+          *rptr = *sptr;\n+\n+          sptr += sxstride;\n+          rptr += rystride;\n+        }\n+        sptr += systride - (sxstride * xcount);\n+        rptr += rxstride - (rystride * xcount);\n+    }\n+}\n+\n+#endif"}]}