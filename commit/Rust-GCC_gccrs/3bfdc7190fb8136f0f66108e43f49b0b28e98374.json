{"sha": "3bfdc7190fb8136f0f66108e43f49b0b28e98374", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JmZGM3MTkwZmI4MTM2ZjBmNjYxMDhlNDNmNDliMGIyOGU5ODM3NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-11-01T15:45:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-11-01T15:45:11Z"}, "message": "cp-tree.h (COMPARE_STRICT): New macro.\n\n\t* cp-tree.h (COMPARE_STRICT): New macro.\n\t(COMPARE_BASE): Likewise.\n\t(COMPARE_RELAXED): Likewise.\n\t(COMPARE_REDECLARATION): Likewise.\n\t(same_type_p): Likewise.\n\t(same_or_base_type_p): Likewise.\n\t* call.c (standard_conversion): Use them, in place of comptypes\n\twith numeric arguments.\n\t(reference_binding): Likewise.\n\t(convert_like): Likewise.\n\t(build_over_call): Likewise.\n\t(is_subseq): Likewise.\n\t(is_properly_derived_from): Likewise.\n\t(compare_ics): Likewise.\n\t(joust): Likewise.\n\t* class.c (delete_duplicate_fields_1): Likewise.\n\t(resolves_to_fixed_type_p): Likewise.\n\t(instantiate_type): Likewise.  Remove #if 0'd code.\n\t* decl.c (decls_match): Likewise.  Use COMPARE_REDECLARATION here.\n\t(pushdecl): Likewise.\n\t(lookup_name_real): Likewise.\n\t(grokdeclarator): Likewise.  Check for illegal array declarations.\n\t(grokparms): Likewise.\n\t(grok_op_properties): Likewise.\n\t* decl2.c (check_classfn): Likewise.\n\t* friend.c (is_friend): Likewise.\n\t(make_friend_class): Likewise.\n\t* init.c (expand_aggr_init): Likewise.\n\t(expand_vec_init): Likewise.\n\t* pt.c (is_member_template_class): Remove declaration.\n\t(is_specialization_of): Use COMPARE_* and new macros.\n\t(comp_template_parms): Likewise.\n\t(convert_nontype_argument): Likewise.\n\t(coerce_template_template_parms): Likewise.\n\t(template_args_equal): Likewise.\n\t(lookup_template_class): Likewise.\n\t(type_unification_real): Likewise.\n\t(unify): Likewise.\n\t(get_bindings_real): Likewise.\n\t* search.c (covariant_return_p): Likewise.\n\t(get_matching_virtual): Likewise.\n\t* sig.c (match_method_types): Likewise.\n\t* tree.c (vec_binfo_member): Likewise.\n\t(cp_tree_equal): Likewise.\n\t* typeck.c (common_type): Likewise.\n\t(comp_array_types): Likewise.  Get issues involving unknown array\n\tbounds right.\n\t(comptypes): Update comments.  Use new flags.\n\t(comp_target_types): Use new macros.\n\t(compparms): Likewise.\n\t(comp_target_parms): Likewise.\n\t(string_conv_p): Likewise.\n\t(build_component_ref): Likewise.\n\t(build_indirect_ref): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(build_static_cast): Likewise.\n\t(build_reinterpret_cast): Likewise.\n\t(build_const_cast): Likewise.\n\t(build_modify_expr): Likewise.\n\t(convert_for_assignment): Likewise.\n\t(comp_ptr_ttypes_real): Likewise.\n\t(ptr_reasonably_similar): Likewise.\n\t(comp_ptr_ttypes_const): Likewise.\n\nFrom-SVN: r23490", "tree": {"sha": "98a820a83d25e681e25774f57c392cb655a13b62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98a820a83d25e681e25774f57c392cb655a13b62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bfdc7190fb8136f0f66108e43f49b0b28e98374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bfdc7190fb8136f0f66108e43f49b0b28e98374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bfdc7190fb8136f0f66108e43f49b0b28e98374", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bfdc7190fb8136f0f66108e43f49b0b28e98374/comments", "author": null, "committer": null, "parents": [{"sha": "6d8cf409b45c2b7994fd0e8ce9f235b984298e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8cf409b45c2b7994fd0e8ce9f235b984298e07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d8cf409b45c2b7994fd0e8ce9f235b984298e07"}], "stats": {"total": 658, "additions": 364, "deletions": 294}, "files": [{"sha": "b977db5bd29919bc72c9b031be0fcdc504dfdc47", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -1,3 +1,69 @@\n+1998-11-01  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (COMPARE_STRICT): New macro.\n+\t(COMPARE_BASE): Likewise.\n+\t(COMPARE_RELAXED): Likewise.\n+\t(COMPARE_REDECLARATION): Likewise.\n+\t(same_type_p): Likewise.\n+\t(same_or_base_type_p): Likewise.\n+\t* call.c (standard_conversion): Use them, in place of comptypes\n+\twith numeric arguments.\n+\t(reference_binding): Likewise.\n+\t(convert_like): Likewise.\n+\t(build_over_call): Likewise.\n+\t(is_subseq): Likewise.\n+\t(is_properly_derived_from): Likewise.\n+\t(compare_ics): Likewise.\n+\t(joust): Likewise.\n+\t* class.c (delete_duplicate_fields_1): Likewise.\n+\t(resolves_to_fixed_type_p): Likewise.\n+\t(instantiate_type): Likewise.  Remove #if 0'd code.\n+\t* decl.c (decls_match): Likewise.  Use COMPARE_REDECLARATION here.\n+\t(pushdecl): Likewise.\n+\t(lookup_name_real): Likewise.\n+\t(grokdeclarator): Likewise.  Check for illegal array declarations.\n+\t(grokparms): Likewise.\n+\t(grok_op_properties): Likewise.\n+\t* decl2.c (check_classfn): Likewise.\n+\t* friend.c (is_friend): Likewise.\n+\t(make_friend_class): Likewise.\n+\t* init.c (expand_aggr_init): Likewise.\n+\t(expand_vec_init): Likewise.\n+\t* pt.c (is_member_template_class): Remove declaration.\n+\t(is_specialization_of): Use COMPARE_* and new macros.\n+\t(comp_template_parms): Likewise.\n+\t(convert_nontype_argument): Likewise.\n+\t(coerce_template_template_parms): Likewise.\n+\t(template_args_equal): Likewise.\n+\t(lookup_template_class): Likewise.\n+\t(type_unification_real): Likewise.\n+\t(unify): Likewise.\n+\t(get_bindings_real): Likewise.\n+\t* search.c (covariant_return_p): Likewise.\n+\t(get_matching_virtual): Likewise.\n+\t* sig.c (match_method_types): Likewise.\n+\t* tree.c (vec_binfo_member): Likewise.\n+\t(cp_tree_equal): Likewise.\n+\t* typeck.c (common_type): Likewise.\n+\t(comp_array_types): Likewise.  Get issues involving unknown array\n+\tbounds right.\n+\t(comptypes): Update comments.  Use new flags.\n+\t(comp_target_types): Use new macros.\n+\t(compparms): Likewise.\n+\t(comp_target_parms): Likewise.\n+\t(string_conv_p): Likewise.\n+\t(build_component_ref): Likewise.\n+\t(build_indirect_ref): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(build_static_cast): Likewise.\n+\t(build_reinterpret_cast): Likewise.\n+\t(build_const_cast): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t(comp_ptr_ttypes_real): Likewise.\n+\t(ptr_reasonably_similar): Likewise.\n+\t(comp_ptr_ttypes_const): Likewise.\n+\t\n 1998-10-31  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* rtti.c (build_dynamic_cast_1): Fix cut-and-paste error."}, {"sha": "58914e32b6674c5daf5cb3c5c49007e4758b7504", "filename": "gcc/cp/call.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -845,8 +845,8 @@ standard_conversion (to, from, expr)\n       enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n       enum tree_code utcode = TREE_CODE (TREE_TYPE (to));\n \n-      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (from)),\n-\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (to)), 1))\n+      if (same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (from)),\n+\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (to))))\n \t;\n       else if (utcode == VOID_TYPE && ufcode != OFFSET_TYPE\n \t       && ufcode != FUNCTION_TYPE)\n@@ -862,9 +862,9 @@ standard_conversion (to, from, expr)\n \t  tree tbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (to));\n \n \t  if (DERIVED_FROM_P (fbase, tbase)\n-\t      && (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n-\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))),\n-\t\t\t     1)))\n+\t      && (same_type_p \n+\t\t  (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n+\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))))))\n \t    {\n \t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n \t      from = build_pointer_type (from);\n@@ -884,7 +884,7 @@ standard_conversion (to, from, expr)\n \t    }\n \t}\n \n-      if (comptypes (from, to, 1))\n+      if (same_type_p (from, to))\n \t/* OK */;\n       else if (comp_ptr_ttypes (TREE_TYPE (to), TREE_TYPE (from)))\n \tconv = build_conv (QUAL_CONV, to, conv);\n@@ -909,7 +909,7 @@ standard_conversion (to, from, expr)\n       tree tbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (tofn)));\n \n       if (! DERIVED_FROM_P (fbase, tbase)\n-\t  || ! comptypes (TREE_TYPE (fromfn), TREE_TYPE (tofn), 1)\n+\t  || ! same_type_p (TREE_TYPE (fromfn), TREE_TYPE (tofn))\n \t  || ! compparms (TREE_CHAIN (TYPE_ARG_TYPES (fromfn)),\n \t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (tofn)))\n \t  || CP_TYPE_QUALS (fbase) != CP_TYPE_QUALS (tbase))\n@@ -990,17 +990,17 @@ reference_binding (rto, rfrom, expr, flags)\n   else if (! expr || ! real_lvalue_p (expr))\n     lvalue = 0;\n \n-  related = (comptypes (TYPE_MAIN_VARIANT (to),\n-\t\t\tTYPE_MAIN_VARIANT (from), 1)\n+  related = (same_type_p (TYPE_MAIN_VARIANT (to),\n+\t\t\t  TYPE_MAIN_VARIANT (from))\n \t     || (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n \t\t && DERIVED_FROM_P (to, from)));\n \n   if (lvalue && related && at_least_as_qualified_p (to, from))\n     {\n       conv = build1 (IDENTITY_CONV, from, expr);\n \n-      if (comptypes (TYPE_MAIN_VARIANT (to),\n-\t\t     TYPE_MAIN_VARIANT (from), 1))\n+      if (same_type_p (TYPE_MAIN_VARIANT (to),\n+\t\t       TYPE_MAIN_VARIANT (from)))\n \tconv = build_conv (REF_BIND, rto, conv);\n       else\n \t{\n@@ -3099,7 +3099,7 @@ convert_like (convs, expr)\n \t       destination type takes a pointer argument.  */\n \t    if (TYPE_SIZE (TREE_TYPE (expr)) == 0)\n \t      {\n-\t\tif (comptypes (TREE_TYPE (expr), TREE_TYPE (convs), 1))\n+\t\tif (same_type_p (TREE_TYPE (expr), TREE_TYPE (convs)))\n \t\t  incomplete_type_error (expr, TREE_TYPE (expr));\n \t\telse\n \t\t  cp_error (\"could not convert `%E' (with incomplete type `%T') to `%T'\",\n@@ -3369,8 +3369,8 @@ build_over_call (cand, args, flags)\n       if (TREE_CODE (targ) == ADDR_EXPR)\n \t{\n \t  targ = TREE_OPERAND (targ, 0);\n-\t  if (! comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (arg))),\n-\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (targ)), 1))\n+\t  if (!same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (arg))),\n+\t\t\t    TYPE_MAIN_VARIANT (TREE_TYPE (targ))))\n \t    targ = NULL_TREE;\n \t}\n       else\n@@ -3713,9 +3713,9 @@ is_subseq (ics1, ics2)\n       ics2 = TREE_OPERAND (ics2, 0);\n \n       if (TREE_CODE (ics2) == TREE_CODE (ics1)\n-\t  && comptypes (TREE_TYPE (ics2), TREE_TYPE (ics1), 1)\n-\t  && comptypes (TREE_TYPE (TREE_OPERAND (ics2, 0)),\n-\t\t\tTREE_TYPE (TREE_OPERAND (ics1, 0)), 1))\n+\t  && same_type_p (TREE_TYPE (ics2), TREE_TYPE (ics1))\n+\t  && same_type_p (TREE_TYPE (TREE_OPERAND (ics2, 0)),\n+\t\t\t     TREE_TYPE (TREE_OPERAND (ics1, 0))))\n \treturn 1;\n     }\n }\n@@ -3734,8 +3734,8 @@ is_properly_derived_from (derived, base)\n \n   /* We only allow proper derivation here.  The DERIVED_FROM_P macro\n      considers every class derived from itself.  */\n-  return (!comptypes (TYPE_MAIN_VARIANT (derived),\n-\t\t      TYPE_MAIN_VARIANT (base), 1)\n+  return (!same_type_p (TYPE_MAIN_VARIANT (derived),\n+\t\t\tTYPE_MAIN_VARIANT (base))\n \t  && DERIVED_FROM_P (base, derived));\n }\n \n@@ -3948,7 +3948,7 @@ compare_ics (ics1, ics2)\n       from_type2 = TREE_TYPE (from_type2);\n     }\n \n-  if (comptypes (from_type1, from_type2, 1))\n+  if (same_type_p (from_type1, from_type2))\n     {\n       if (is_subseq (ics1, ics2))\n \treturn 1;\n@@ -4048,7 +4048,7 @@ compare_ics (ics1, ics2)\n       else if (TREE_CODE (deref_to_type1) == VOID_TYPE\n \t       || TREE_CODE (deref_to_type2) == VOID_TYPE)\n \t{\n-\t  if (comptypes (deref_from_type1, deref_from_type2, 1))\n+\t  if (same_type_p (deref_from_type1, deref_from_type2))\n \t    {\n \t      if (TREE_CODE (deref_to_type2) == VOID_TYPE)\n \t\t{\n@@ -4075,7 +4075,7 @@ compare_ics (ics1, ics2)\n \t     \n \t     --conversion of B* to A* is better than conversion of C* to\n \t       A*  */\n-\t  if (comptypes (deref_from_type1, deref_from_type2, 1))\n+\t  if (same_type_p (deref_from_type1, deref_from_type2))\n \t    {\n \t      if (is_properly_derived_from (deref_to_type1,\n \t\t\t\t\t    deref_to_type2))\n@@ -4084,7 +4084,7 @@ compare_ics (ics1, ics2)\n \t\t\t\t\t\t deref_to_type1))\n \t\treturn -1;\n \t    }\n-\t  else if (comptypes (deref_to_type1, deref_to_type2, 1))\n+\t  else if (same_type_p (deref_to_type1, deref_to_type2))\n \t    {\n \t      if (is_properly_derived_from (deref_from_type2,\n \t\t\t\t\t    deref_from_type1))\n@@ -4096,7 +4096,7 @@ compare_ics (ics1, ics2)\n \t}\n     }\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (from_type1))\n-\t   && comptypes (from_type1, from_type2, 1))\n+\t   && same_type_p (from_type1, from_type2))\n     {\n       /* [over.ics.rank]\n \t \n@@ -4115,7 +4115,7 @@ compare_ics (ics1, ics2)\n \t}\n     }\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (to_type1))\n-\t   && comptypes (to_type1, to_type2, 1))\n+\t   && same_type_p (to_type1, to_type2))\n     {\n       /* [over.ics.rank]\n \n@@ -4142,7 +4142,7 @@ compare_ics (ics1, ics2)\n        qualification signature of type T2  */\n   if (TREE_CODE (ics1) == QUAL_CONV \n       && TREE_CODE (ics2) == QUAL_CONV\n-      && comptypes (from_type1, from_type2, 1))\n+      && same_type_p (from_type1, from_type2))\n     return comp_cv_qual_signature (to_type1, to_type2);\n \n   /* [over.ics.rank]\n@@ -4154,8 +4154,8 @@ compare_ics (ics1, ics2)\n      which the reference initialized by S1 refers */\n       \n   if (ref_binding1 && ref_binding2\n-      && comptypes (TYPE_MAIN_VARIANT (to_type1),\n-\t\t    TYPE_MAIN_VARIANT (to_type2), 1))\n+      && same_type_p (TYPE_MAIN_VARIANT (to_type1),\n+\t\t      TYPE_MAIN_VARIANT (to_type2)))\n     return comp_cv_qualification (target_type2, target_type1);\n \n   /* Neither conversion sequence is better than the other.  */\n@@ -4298,8 +4298,8 @@ joust (cand1, cand2, warn)\n \t   != DECL_CONSTRUCTOR_P (cand2->fn))\n \t  /* Don't warn if the two conv ops convert to the same type...  */\n \t  || (! DECL_CONSTRUCTOR_P (cand1->fn)\n-\t      && ! comptypes (TREE_TYPE (cand1->second_conv),\n-\t\t\t      TREE_TYPE (cand2->second_conv), 1))))\n+\t      && ! same_type_p (TREE_TYPE (cand1->second_conv),\n+\t\t\t\tTREE_TYPE (cand2->second_conv)))))\n     {\n       int comp = compare_ics (cand1->second_conv, cand2->second_conv);\n       if (comp != winner)\n@@ -4355,8 +4355,8 @@ joust (cand1, cand2, warn)\n       && TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n     {\n       for (i = 0; i < len; ++i)\n-\tif (! comptypes (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n-\t\t\t TREE_TYPE (TREE_VEC_ELT (cand2->convs, i)), 1))\n+\tif (!same_type_p (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n+\t\t\t  TREE_TYPE (TREE_VEC_ELT (cand2->convs, i))))\n \t  break;\n       if (i == TREE_VEC_LENGTH (cand1->convs))\n \treturn 1;\n@@ -4371,7 +4371,7 @@ joust (cand1, cand2, warn)\n \t  tree t1 = strip_top_quals (non_reference (TREE_TYPE (c1)));\n \t  tree t2 = strip_top_quals (non_reference (TREE_TYPE (c2)));\n \n-\t  if (comptypes (t1, t2, 1))\n+\t  if (same_type_p (t1, t2))\n \t    {\n \t      if (TREE_CODE (c1) == REF_BIND && TREE_CODE (c2) != REF_BIND)\n \t\treturn 1;"}, {"sha": "1fd492f5fbe13c09dab8d5f8d83f35cb2604183d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 49, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -1351,7 +1351,7 @@ delete_duplicate_fields_1 (field, fields)\n \t\t  else if (DECL_DECLARES_TYPE_P (field)\n \t\t\t   && DECL_DECLARES_TYPE_P (x))\n \t\t    {\n-\t\t      if (comptypes (TREE_TYPE (field), TREE_TYPE (x), 1))\n+\t\t      if (same_type_p (TREE_TYPE (field), TREE_TYPE (x)))\n \t\t\tcontinue;\n \t\t      cp_error_at (\"duplicate nested type `%D'\", x);\n \t\t    }\n@@ -4592,7 +4592,7 @@ resolves_to_fixed_type_p (instance, nonnull)\n     return 0;\n   if (POINTER_TYPE_P (t))\n     t = TREE_TYPE (t);\n-  return comptypes (TYPE_MAIN_VARIANT (t), TYPE_MAIN_VARIANT (fixed), 1);\n+  return same_type_p (TYPE_MAIN_VARIANT (t), TYPE_MAIN_VARIANT (fixed));\n }\n \n \f\n@@ -4981,7 +4981,7 @@ instantiate_type (lhstype, rhs, complain)\n \n   if (TREE_TYPE (rhs) != NULL_TREE && ! (type_unknown_p (rhs)))\n     {\n-      if (comptypes (lhstype, TREE_TYPE (rhs), 1))\n+      if (same_type_p (lhstype, TREE_TYPE (rhs)))\n \treturn rhs;\n       if (complain)\n \tcp_error (\"argument of type `%T' does not match `%T'\",\n@@ -5049,48 +5049,6 @@ instantiate_type (lhstype, rhs, complain)\n \n \t/* I could not trigger this code. MvL */\n \tmy_friendly_abort (980326);\n-#if 0\n-\tmy_friendly_assert (TREE_CODE (field) == FIELD_DECL, 178);\n-\tmy_friendly_assert (!(TREE_CODE (TREE_TYPE (field)) == FUNCTION_TYPE\n-\t\t\t      || TREE_CODE (TREE_TYPE (field)) == METHOD_TYPE),\n-\t\t\t    179);\n-\n-\tTREE_TYPE (rhs) = lhstype;\n-\t/* First look for an exact match  */\n-\n-\twhile (field && TREE_TYPE (field) != lhstype)\n-\t  field = DECL_CHAIN (field);\n-\tif (field)\n-\t  {\n-\t    TREE_OPERAND (rhs, 1) = field;\n-\t    mark_used (field);\n-\t    return rhs;\n-\t  }\n-\n-\t/* No exact match found, look for a compatible function.  */\n-\tfield = TREE_OPERAND (rhs, 1);\n-\twhile (field && ! comptypes (lhstype, TREE_TYPE (field), 0))\n-\t  field = DECL_CHAIN (field);\n-\tif (field)\n-\t  {\n-\t    TREE_OPERAND (rhs, 1) = field;\n-\t    field = DECL_CHAIN (field);\n-\t    while (field && ! comptypes (lhstype, TREE_TYPE (field), 0))\n-\t      field = DECL_CHAIN (field);\n-\t    if (field)\n-\t      {\n-\t\tif (complain)\n-\t\t  error (\"ambiguous overload for COMPONENT_REF requested\");\n-\t\treturn error_mark_node;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    if (complain)\n-\t      error (\"no appropriate overload exists for COMPONENT_REF\");\n-\t    return error_mark_node;\n-\t  }\n-#endif\n \treturn rhs;\n       }\n \n@@ -5141,7 +5099,7 @@ instantiate_type (lhstype, rhs, complain)\n \t  {\n \t    elem = OVL_FUNCTION (elems);\n \t    if (TREE_CODE (elem) == FUNCTION_DECL\n-\t\t&& comptypes (lhstype, TREE_TYPE (elem), 1))\n+\t\t&& same_type_p (lhstype, TREE_TYPE (elem)))\n \t      {\n \t\tmark_used (elem);\n \t\treturn elem;\n@@ -5174,8 +5132,8 @@ instantiate_type (lhstype, rhs, complain)\n \t\t      }\n \t\t    save_elem = instantiate_template (elem, t);\n \t\t    /* Check the return type.  */\n-\t\t    if (! comptypes (TREE_TYPE (lhstype),\n-\t\t\t\t     TREE_TYPE (TREE_TYPE (save_elem)), 1))\n+\t\t    if (!same_type_p (TREE_TYPE (lhstype),\n+\t\t\t\t      TREE_TYPE (TREE_TYPE (save_elem))))\n \t\t      save_elem = 0;\n \t\t  }\n \t      }\n@@ -5274,7 +5232,7 @@ instantiate_type (lhstype, rhs, complain)\n \t  {\n \t    elem = TREE_VALUE (baselink);\n \t    while (elem)\n-\t      if (comptypes (lhstype, TREE_TYPE (OVL_CURRENT (elem)), 1))\n+\t      if (same_type_p (lhstype, TREE_TYPE (OVL_CURRENT (elem))))\n \t\t{\n \t\t  mark_used (OVL_CURRENT (elem));\n \t\t  return OVL_CURRENT (elem);"}, {"sha": "aee859a70085a01e13b0514a86b5dd1f4ca320d7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -2431,9 +2431,38 @@ extern tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n #define WANT_ENUM\t4 /* enumerated types */\n #define WANT_POINTER\t8 /* pointer types */\n #define WANT_NULL      16 /* null pointer constant */\n-\n #define WANT_ARITH\t(WANT_INT | WANT_FLOAT)\n \n+/* Used with comptypes, and related functions, to guide type\n+   comparison.  */\n+\n+#define COMPARE_STRICT        0 /* Just check if the types are the\n+\t\t\t\t   same.  */\n+#define COMPARE_BASE          1 /* Check to see if the second type is\n+\t\t\t\t   derived from the first, or if both\n+\t\t\t\t   are pointers (or references) and\n+\t\t\t\t   the types pointed to by the second\n+\t\t\t\t   type is derived from the pointed to\n+\t\t\t\t   by the first.  */\n+#define COMPARE_RELAXED       2 /* Like COMPARE_DERIVED, but in\n+\t\t\t\t   reverse.  Also treat enmeration\n+\t\t\t\t   types as the same as integer types\n+\t\t\t\t   of the same width.  */\n+#define COMPARE_REDECLARATION 4 /* The comparsion is being done when\n+\t\t\t\t   another declaration of an existing\n+\t\t\t\t   entity is seen.  */\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n+   sense of `same'.  */\n+#define same_type_p(type1, type2) \\\n+  comptypes ((type1), (type2), COMPARE_STRICT)\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, or if TYPE2\n+   is derived from TYPE1, or if TYPE2 is a pointer (reference) to a\n+   class derived from the type pointed to (referred to) by TYPE1.  */\n+#define same_or_base_type_p(type1, type2) \\\n+  comptypes ((type1), (type2), COMPARE_BASE)\n+\n #define FRIEND_NAME(LIST) (TREE_PURPOSE (LIST))\n #define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))\n "}, {"sha": "84d3c6796ab008e51bcb85e9811b922c15b47847", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -487,7 +487,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       /* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they\n          meant.  */\n       if (TREE_CODE (intype) == POINTER_TYPE\n-\t  && (comptypes (TREE_TYPE (intype), type, -1)))\n+\t  && (comptypes (TREE_TYPE (intype), type, \n+\t\t\t COMPARE_BASE | COMPARE_RELAXED )))\n \tcp_warning (\"casting `%T' to `%T' does not dereference pointer\",\n \t\t    intype, reftype);\n \t  \n@@ -669,7 +670,7 @@ ocp_convert (type, expr, convtype, flags)\n     /* We need a new temporary; don't take this shortcut.  */;\n   else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e)))\n     {\n-      if (comptypes (type, TREE_TYPE (e), 1))\n+      if (same_type_p (type, TREE_TYPE (e)))\n \t/* The call to fold will not always remove the NOP_EXPR as\n \t   might be expected, since if one of the types is a typedef;\n \t   the comparsion in fold is just equality of pointers, not a"}, {"sha": "394984fa3a3bbb1242de21b77a77a1fe991256a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -2552,7 +2552,7 @@ decls_match (newdecl, olddecl)\n \t  return 0;\n \t}\n \n-      if (comptypes (TREE_TYPE (f1), TREE_TYPE (f2), 1))\n+      if (same_type_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n \t{\n \t  if (! strict_prototypes_lang_c && DECL_LANGUAGE (olddecl) == lang_c\n \t      && p2 == NULL_TREE)\n@@ -2595,7 +2595,8 @@ decls_match (newdecl, olddecl)\n \ttypes_match = 0;\n       else\n \ttypes_match = comptypes (TREE_TYPE (newdecl),\n-\t\t\t\t TREE_TYPE (olddecl), 1);\n+\t\t\t\t TREE_TYPE (olddecl),\n+\t\t\t\t COMPARE_REDECLARATION);\n     }\n \n   return types_match;\n@@ -3527,7 +3528,7 @@ pushdecl (x)\n \t  if (decl\n \t      /* If different sort of thing, we already gave an error.  */\n \t      && TREE_CODE (decl) == TREE_CODE (x)\n-\t      && ! comptypes (TREE_TYPE (x), TREE_TYPE (decl), 1))\n+\t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n \t    {\n \t      cp_pedwarn (\"type mismatch with previous external decl\", x);\n \t      cp_pedwarn_at (\"previous external decl of `%#D'\", decl);\n@@ -4115,7 +4116,7 @@ redeclaration_error_message (newdecl, olddecl)\n       /* Because C++ can put things into name space for free,\n \t constructs like \"typedef struct foo { ... } foo\"\n \t would look like an erroneous redeclaration.  */\n-      if (comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 0))\n+      if (same_type_p (TREE_TYPE (newdecl), TREE_TYPE (olddecl)))\n \treturn 0;\n       else\n \treturn \"redefinition of `%#D'\";\n@@ -5241,7 +5242,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t\t    && CLASSTYPE_TEMPLATE_INFO (subtype)\n \t\t    && CLASSTYPE_TI_TEMPLATE (subtype) == locval)\n \t      && ! (TREE_CODE (locval) == TYPE_DECL\n-\t\t    && comptypes (TREE_TYPE (locval), subtype, 1)))\n+\t\t    && same_type_p (TREE_TYPE (locval), subtype)))\n \t    {\n \t      cp_warning (\"lookup of `%D' finds `%#D'\", name, locval);\n \t      cp_warning (\"  instead of `%D' from dependent base class\",\n@@ -9054,7 +9055,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n     }\n   else if (return_type == return_conversion)\n     {\n-      if (comptypes (type, ctor_return_type, 1) == 0)\n+      if (!same_type_p (type, ctor_return_type))\n \tcp_error (\"operator `%T' declared to return `%T'\",\n \t\t  ctor_return_type, type);\n       else\n@@ -9536,6 +9537,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    if (size == error_mark_node)\n \t      type = error_mark_node;\n+\t    else if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n+\t      {\n+\t\t/* [dcl.array]\n+\n+\t\t   the constant expressions that specify the bounds of\n+\t\t   the arrays can be omitted only for the first member\n+\t\t   of the sequence.  */\n+\t\tcp_error (\"declaration of `%D' as multidimensional array\",\n+\t\t\t  dname);\n+\t\tcp_error (\"must have bounds for all dimensions except the first\");\n+\t\ttype = error_mark_node;\n+\t      }\n \n \t    if (type == error_mark_node)\n \t      continue;\n@@ -11023,7 +11036,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t\t\t TREE_PURPOSE (decl),\n \t\t\t\t\t PARM, init != NULL_TREE,\n \t\t\t\t\t NULL_TREE);\n-\t\t  if (! decl)\n+\t\t  if (! decl || TREE_TYPE (decl) == error_mark_node)\n \t\t    continue;\n \n \t\t  /* Top-level qualifiers on the parameters are\n@@ -11525,14 +11538,14 @@ grok_op_properties (decl, virtualp, friendp)\n \t      if (list_length (argtypes) == 2)\n \t\t{\n \t\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n-\t\t      || !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n-\t\t\t\t     arg, 1))\n+\t\t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n+\t\t\t\t       arg))\n \t\t    cp_warning (\"prefix `%D' should return `%T'\", decl,\n \t\t\t\tbuild_reference_type (arg));\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (!comptypes (TYPE_MAIN_VARIANT (ret), arg, 1))\n+\t\t  if (!same_type_p (TYPE_MAIN_VARIANT (ret), arg))\n \t\t    cp_warning (\"postfix `%D' should return `%T'\", decl, arg);\n \t\t}\n \t    }"}, {"sha": "7b0ba6d71170e1ef8e9a38347e5dd16c465ab473", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -1406,8 +1406,8 @@ check_classfn (ctype, function)\n \t\t\t  && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n \t\t\tp1 = TREE_CHAIN (p1);\n \n-\t\t      if (comptypes (TREE_TYPE (TREE_TYPE (function)),\n-\t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)), 1)\n+\t\t      if (same_type_p (TREE_TYPE (TREE_TYPE (function)),\n+\t\t\t\t       TREE_TYPE (TREE_TYPE (fndecl)))\n \t\t\t  && compparms (p1, p2)\n \t\t\t  && (DECL_TEMPLATE_SPECIALIZATION (function)\n \t\t\t      == DECL_TEMPLATE_SPECIALIZATION (fndecl))"}, {"sha": "81b67a56d5a474aa180c4c19203b288a457f24b9", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -64,7 +64,7 @@ is_friend (type, supplicant)\n \t      tree friends = TREE_VALUE (list);\n \t      for (; friends ; friends = TREE_CHAIN (friends))\n \t\t{\n-\t\t  if (comptypes (ctype, TREE_PURPOSE (friends), 1))\n+\t\t  if (same_type_p (ctype, TREE_PURPOSE (friends)))\n \t\t    return 1;\n \n \t\t  if (TREE_VALUE (friends) == NULL_TREE)\n@@ -86,8 +86,8 @@ is_friend (type, supplicant)\n \t\t     FUNCTION_MEMBER_P bit can go.  */\n \t\t  if ((flag_guiding_decls \n \t\t       || DECL_FUNCTION_MEMBER_P (supplicant))\n-\t\t      && comptypes (TREE_TYPE (supplicant),\n-\t\t\t\t    TREE_TYPE (TREE_VALUE (friends)), 1))\n+\t\t      && same_type_p (TREE_TYPE (supplicant),\n+\t\t\t\t      TREE_TYPE (TREE_VALUE (friends))))\n \t\t    return 1;\n \n \t\t  if (TREE_CODE (TREE_VALUE (friends)) == TEMPLATE_DECL\n@@ -112,7 +112,7 @@ is_friend (type, supplicant)\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL ? \n \t      is_specialization_of (TYPE_MAIN_DECL (supplicant), t) :\n-\t      comptypes (supplicant, t, 1))\n+\t      same_type_p (supplicant, t))\n \t    return 1;\n \t}\n     }      \n@@ -278,7 +278,7 @@ make_friend_class (type, friend_type)\n        friends with itself; this means that each instantiation is\n        friends with all other instantiations.  */\n     is_template_friend = 1;\n-  else if (comptypes (type, friend_type, 1))\n+  else if (same_type_p (type, friend_type))\n     {\n       pedwarn (\"class `%s' is implicitly friends with itself\",\n \t       TYPE_NAME_STRING (type));\n@@ -297,7 +297,7 @@ make_friend_class (type, friend_type)\n \t /* Stop if we find the same type on the list.  */\n \t && !(TREE_CODE (TREE_VALUE (classes)) == TEMPLATE_DECL ?\n \t      friend_type == TREE_VALUE (classes) :\n-\t      comptypes (TREE_VALUE (classes), friend_type, 1)))\n+\t      same_type_p (TREE_VALUE (classes), friend_type)))\n     classes = TREE_CHAIN (classes);\n   if (classes) \n     cp_warning (\"`%T' is already a friend of `%T'\","}, {"sha": "dbf53a31155641419bccc289ab541855d69c5b9d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -1082,7 +1082,8 @@ expand_aggr_init (exp, init, flags)\n \t  return;\n \t}\n       expand_vec_init (exp, exp, array_type_nelts (type), init,\n-\t\t       init && comptypes (TREE_TYPE (init), TREE_TYPE (exp), 1));\n+\t\t       init && same_type_p (TREE_TYPE (init),\n+\t\t\t\t\t    TREE_TYPE (exp)));\n       TREE_READONLY (exp) = was_const;\n       TREE_THIS_VOLATILE (exp) = was_volatile;\n       TREE_TYPE (exp) = type;\n@@ -2784,8 +2785,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n   expand_vec_init_try_block (type);\n \n   if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR\n-      && (!decl || comptypes (TREE_TYPE (init), \n-\t\t\t      TREE_TYPE (decl), 1)))\n+      && (!decl || same_type_p (TREE_TYPE (init), TREE_TYPE (decl))))\n     {\n       /* Do non-default initialization resulting from brace-enclosed\n \t initializers.  */"}, {"sha": "d4bdf82b40fd512991cc1d2622afcaa2a885c7c5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -124,7 +124,6 @@ static int check_cv_quals_for_unify PROTO((int, tree, tree));\n static tree tsubst_template_arg_vector PROTO((tree, tree));\n static tree tsubst_template_parms PROTO((tree, tree));\n static void regenerate_decl_from_template PROTO((tree, tree));\n-static int is_member_template_class PROTO((tree));\n static tree most_specialized PROTO((tree, tree, tree));\n static tree most_specialized_class PROTO((tree, tree));\n static tree most_general_template PROTO((tree));\n@@ -750,8 +749,8 @@ is_specialization_of (decl, tmpl)\n \t   t != NULL_TREE;\n \t   t = CLASSTYPE_USE_TEMPLATE (t)\n \t     ? TREE_TYPE (CLASSTYPE_TI_TEMPLATE (t)) : NULL_TREE)\n-\tif (comptypes (TYPE_MAIN_VARIANT (t), \n-\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (tmpl)), 1))\n+\tif (same_type_p (TYPE_MAIN_VARIANT (t), \n+\t\t\t TYPE_MAIN_VARIANT (TREE_TYPE (tmpl))))\n \t  return 1;\n     }  \n \n@@ -1464,8 +1463,7 @@ int comp_template_parms (parms1, parms2)\n \n \t  if (TREE_CODE (parm1) == TEMPLATE_TYPE_PARM)\n \t    continue;\n-\t  else if (!comptypes (TREE_TYPE (parm1), \n-\t\t\t       TREE_TYPE (parm2), 1))\n+\t  else if (!same_type_p (TREE_TYPE (parm1), TREE_TYPE (parm2)))\n \t    return 0;\n \t}\n     }\n@@ -2555,7 +2553,7 @@ convert_nontype_argument (type, expr)\n \n \t    expr = build_unary_op (ADDR_EXPR, fn, 0);\n \n-\t    my_friendly_assert (comptypes (type, TREE_TYPE (expr), 1), \n+\t    my_friendly_assert (same_type_p (type, TREE_TYPE (expr)), \n \t\t\t\t0);\n \t    return expr;\n \t  }\n@@ -2613,7 +2611,8 @@ convert_nontype_argument (type, expr)\n \t\t  goto bad_argument;\n \t      }\n \n-\t    my_friendly_assert (comptypes (type_referred_to, TREE_TYPE (fn), 1),\n+\t    my_friendly_assert (same_type_p (type_referred_to, \n+\t\t\t\t\t     TREE_TYPE (fn)),\n \t\t\t\t0);\n \n \t    return fn;\n@@ -2626,8 +2625,8 @@ convert_nontype_argument (type, expr)\n \t       identical) type of the template-argument.  The\n \t       template-parameter is bound directly to the\n \t       template-argument, which must be an lvalue.  */\n-\t    if (!comptypes (TYPE_MAIN_VARIANT (expr_type),\n-\t\t\t    TYPE_MAIN_VARIANT (type), 1)\n+\t    if (!same_type_p (TYPE_MAIN_VARIANT (expr_type),\n+\t\t\t      TYPE_MAIN_VARIANT (type))\n \t\t|| !at_least_as_qualified_p (type_referred_to,\n \t\t\t\t\t     expr_type)\n \t\t|| !real_lvalue_p (expr))\n@@ -2664,7 +2663,7 @@ convert_nontype_argument (type, expr)\n \tif (TREE_CODE (expr) == CONSTRUCTOR)\n \t  {\n \t    /* A ptr-to-member constant.  */\n-\t    if (!comptypes (type, expr_type, 1))\n+\t    if (!same_type_p (type, expr_type))\n \t      return error_mark_node;\n \t    else \n \t      return expr;\n@@ -2683,7 +2682,7 @@ convert_nontype_argument (type, expr)\n \n \texpr = build_unary_op (ADDR_EXPR, fn, 0);\n \t\n-\tmy_friendly_assert (comptypes (type, TREE_TYPE (expr), 1), \n+\tmy_friendly_assert (same_type_p (type, TREE_TYPE (expr)),\n \t\t\t    0);\n \treturn expr;\n       }\n@@ -2762,8 +2761,8 @@ coerce_template_template_parms (parm_parms, arg_parms, in_decl, outer_args)\n \t  /* The tsubst call is used to handle cases such as\n \t       template <class T, template <T> class TT> class D;  \n \t     i.e. the parameter list of TT depends on earlier parameters.  */\n-\t  if (!comptypes (tsubst (TREE_TYPE (parm), outer_args, in_decl), \n-\t\t\t  TREE_TYPE (arg), 1))\n+\t  if (!same_type_p (tsubst (TREE_TYPE (parm), outer_args, in_decl), \n+\t\t\t    TREE_TYPE (arg)))\n \t    return 0;\n \t  break;\n \t  \n@@ -3089,7 +3088,7 @@ template_args_equal (ot, nt)\n     /* For member templates */\n     return comp_template_args (ot, nt);\n   else if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't')\n-    return comptypes (ot, nt, 1);\n+    return same_type_p (ot, nt);\n   else\n     return (cp_tree_equal (ot, nt) > 0);\n }\n@@ -3540,7 +3539,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t\t   ctx; \n \t\t   ctx = (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't') \n \t\t     ? TYPE_CONTEXT (ctx) : DECL_CONTEXT (ctx))\n-\t\tif (comptypes (ctx, template_type, 1))\n+\t\tif (same_type_p (ctx, template_type))\n \t\t  break;\n \t      \n \t      if (!ctx)\n@@ -6859,7 +6858,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n \n \t  if (strict == DEDUCE_EXACT)\n \t    {\n-\t      if (comptypes (parm, type, 1))\n+\t      if (same_type_p (parm, type))\n \t\tcontinue;\n \t    }\n \t  else\n@@ -7187,7 +7186,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t/* The PARM is not one we're trying to unify.  Just check\n \t   to see if it matches ARG.  */\n \treturn (TREE_CODE (arg) == TREE_CODE (parm)\n-\t\t&& comptypes (parm, arg, 1)) ? 0 : 1;\n+\t\t&& same_type_p (parm, arg)) ? 0 : 1;\n       idx = TEMPLATE_TYPE_IDX (parm);\n       targ = TREE_VEC_ELT (targs, idx);\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, idx));\n@@ -7276,7 +7275,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \n       /* Simple cases: Value already set, does match or doesn't.  */\n       if (targ != NULL_TREE \n-\t  && (comptypes (targ, arg, 1)\n+\t  && (same_type_p (targ, arg)\n \t      || (explicit_mask && explicit_mask[idx])))\n \treturn 0;\n       else if (targ)\n@@ -7391,8 +7390,8 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n       /* We use the TYPE_MAIN_VARIANT since we have already\n \t checked cv-qualification at the top of the\n \t function.  */\n-      else if (!comptypes (TYPE_MAIN_VARIANT (arg),\n-\t\t\t   TYPE_MAIN_VARIANT (parm), 1))\n+      else if (!same_type_p (TYPE_MAIN_VARIANT (arg),\n+\t\t\t     TYPE_MAIN_VARIANT (parm)))\n \treturn 1;\n \n       /* As far as unification is concerned, this wins.\t Later checks\n@@ -7462,8 +7461,8 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t\t\tCLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE,\n \t\t\texplicit_mask);\n \t}\n-      else if (!comptypes (TYPE_MAIN_VARIANT (parm),\n-\t\t\t   TYPE_MAIN_VARIANT (arg), 1))\n+      else if (!same_type_p (TYPE_MAIN_VARIANT (parm),\n+\t\t\t     TYPE_MAIN_VARIANT (arg)))\n \treturn 1;\n       return 0;\n \n@@ -7692,7 +7691,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n       tree t = tsubst (TREE_TYPE (TREE_TYPE (fn)), targs,\n \t\t       NULL_TREE);\n \n-      if (!comptypes (t, TREE_TYPE (TREE_TYPE (decl)), 1))\n+      if (!same_type_p (t, TREE_TYPE (TREE_TYPE (decl))))\n \treturn NULL_TREE;\n     }\n "}, {"sha": "d9d945fe3815053785fbd794d0d2c9ef7ac2d017", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -1740,7 +1740,7 @@ covariant_return_p (brettype, drettype)\n       drettype = TREE_TYPE (drettype);\n     }\n \n-  if (comptypes (brettype, drettype, 1))\n+  if (same_type_p (brettype, drettype))\n     return 0;\n \n   if (! (TREE_CODE (brettype) == TREE_CODE (drettype)\n@@ -1850,7 +1850,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t  && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes)))\n \t\t{\n \t\t  tree brettype = TREE_TYPE (TREE_TYPE (tmp));\n-\t\t  if (comptypes (brettype, drettype, 1))\n+\t\t  if (same_type_p (brettype, drettype))\n \t\t    /* OK */;\n \t\t  else if ((i = covariant_return_p (brettype, drettype)))\n \t\t    {\n@@ -1864,7 +1864,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t\t}\n \t\t    }\n \t\t  else if (IS_AGGR_TYPE_2 (brettype, drettype)\n-\t\t\t   && comptypes (brettype, drettype, 0))\n+\t\t\t   && same_or_base_type_p (brettype, drettype))\n \t\t    {\n \t\t      error (\"invalid covariant return type (must use pointer or reference)\");\n \t\t      cp_error_at (\"  overriding `%#D'\", tmp);"}, {"sha": "00ba77076bc79301d6d34bd84d07ff6cb749f963", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -408,7 +408,7 @@ match_method_types (sig_mtype, class_mtype)\n   tree class_arg_types = TYPE_ARG_TYPES (class_mtype);\n \n   /* The return types have to be the same.  */\n-  if (! comptypes (sig_return_type, class_return_type, 1))\n+  if (!same_type_p (sig_return_type, class_return_type))\n     return 0;\n \n   /* Compare the first argument `this.'  */"}, {"sha": "2a9b522842544868c993f146a0285107aadc7511", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -2314,7 +2314,7 @@ vec_binfo_member (elem, vec)\n \n   if (vec)\n     for (i = 0; i < TREE_VEC_LENGTH (vec); ++i)\n-      if (comptypes (elem, BINFO_TYPE (TREE_VEC_ELT (vec, i)), 1))\n+      if (same_type_p (elem, BINFO_TYPE (TREE_VEC_ELT (vec, i))))\n \treturn TREE_VEC_ELT (vec, i);\n \n   return NULL_TREE;\n@@ -2387,7 +2387,7 @@ cp_tree_equal (t1, t2)\n       /* We need to do this when determining whether or not two\n \t non-type pointer to member function template arguments\n \t are the same.  */\n-      if (!(comptypes (TREE_TYPE (t1), TREE_TYPE (t2), 1)\n+      if (!(same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n \t    /* The first operand is RTL.  */\n \t    && TREE_OPERAND (t1, 0) == TREE_OPERAND (t2, 0)))\n \treturn 0;\n@@ -2455,15 +2455,14 @@ cp_tree_equal (t1, t2)\n       if (TREE_CODE (TREE_OPERAND (t1, 0)) != TREE_CODE (TREE_OPERAND (t2, 0)))\n \treturn 0;\n       if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t1, 0))) == 't')\n-\treturn comptypes (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0), 1);\n+\treturn same_type_p (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n       break;\n \n     case PTRMEM_CST:\n       /* Two pointer-to-members are the same if they point to the same\n \t field or function in the same class.  */\n       return (PTRMEM_CST_MEMBER (t1) == PTRMEM_CST_MEMBER (t2)\n-\t      && comptypes (PTRMEM_CST_CLASS (t1), PTRMEM_CST_CLASS (t2),\n-\t\t\t    1));\n+\t      && same_type_p (PTRMEM_CST_CLASS (t1), PTRMEM_CST_CLASS (t2)));\n \n     default:\n       break;"}, {"sha": "1322078b3bc1f4eba1ad0cdee78a56ff3d37b80a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 120, "deletions": 132, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -576,7 +576,7 @@ common_type (t1, t2)\n \t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n \t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n \n-\t  if (comptypes (b1, b2, 1)\n+\t  if (same_type_p (b1, b2)\n \t      || (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n \t    basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t2)));\n \t  else\n@@ -611,7 +611,7 @@ common_type (t1, t2)\n \t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n \t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n \n-\t  if (comptypes (b1, b2, 1)\n+\t  if (same_type_p (b1, b2)\n \t      || (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n \t    return build_type_attribute_variant (t2, attributes);\n \t  else if (binfo_or_else (b2, b1))\n@@ -633,61 +633,58 @@ compexcepttypes (t1, t2)\n   return TYPE_RAISES_EXCEPTIONS (t1) == TYPE_RAISES_EXCEPTIONS (t2);\n }\n \n+/* Compare the array types T1 and T2, using CMP as the type comparison\n+   function for the element types.  STRICT is as for comptypes.  */\n+\n static int\n comp_array_types (cmp, t1, t2, strict)\n      register int (*cmp) PROTO((tree, tree, int));\n      tree t1, t2;\n      int strict;\n {\n-  tree d1 = TYPE_DOMAIN (t1);\n-  tree d2 = TYPE_DOMAIN (t2);\n+  tree d1;\n+  tree d2;\n+\n+  if (t1 == t2)\n+    return 1;\n \n-  /* Target types must match incl. qualifiers.  */\n+  /* The type of the array elements must be the same.  */\n   if (!(TREE_TYPE (t1) == TREE_TYPE (t2)\n-\t|| (*cmp) (TREE_TYPE (t1), TREE_TYPE (t2), strict)))\n+\t|| (*cmp) (TREE_TYPE (t1), TREE_TYPE (t2), \n+\t\t   strict & ~COMPARE_REDECLARATION)))\n     return 0;\n \n-  /* Sizes must match unless one is missing or variable.  */\n-  if (d1 == 0 || d2 == 0 || d1 == d2\n-      || TREE_CODE (TYPE_MIN_VALUE (d1)) != INTEGER_CST\n-      || TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n-      || TREE_CODE (TYPE_MAX_VALUE (d1)) != INTEGER_CST\n-      || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST)\n+  d1 = TYPE_DOMAIN (t1);\n+  d2 = TYPE_DOMAIN (t2);\n+\n+  if (d1 == d2)\n     return 1;\n \n-  return ((TREE_INT_CST_LOW (TYPE_MIN_VALUE (d1))\n-\t   == TREE_INT_CST_LOW (TYPE_MIN_VALUE (d2)))\n-\t  && (TREE_INT_CST_HIGH (TYPE_MIN_VALUE (d1))\n-\t      == TREE_INT_CST_HIGH (TYPE_MIN_VALUE (d2)))\n-\t  && (TREE_INT_CST_LOW (TYPE_MAX_VALUE (d1))\n-\t      == TREE_INT_CST_LOW (TYPE_MAX_VALUE (d2)))\n-\t  && (TREE_INT_CST_HIGH (TYPE_MAX_VALUE (d1))\n-\t      == TREE_INT_CST_HIGH (TYPE_MAX_VALUE (d2))));\n+  /* If one of the arrays is dimensionless, and the other has a\n+     dimension, they are of different types.  However, it is legal to\n+     write:\n+\n+       extern int a[];\n+       int a[3];\n+\n+     by [basic.link]: \n+\n+       declarations for an array object can specify\n+       array types that differ by the presence or absence of a major\n+       array bound (_dcl.array_).  */\n+  if (!d1 || !d2)\n+    return strict & COMPARE_REDECLARATION;\n+\n+  /* Check that the dimensions are the same.  */\n+  return (cp_tree_equal (TYPE_MIN_VALUE (d1),\n+\t\t\t TYPE_MIN_VALUE (d2))\n+\t  && cp_tree_equal (TYPE_MAX_VALUE (d1),\n+\t\t\t    TYPE_MAX_VALUE (d2)));\n }\n \n /* Return 1 if TYPE1 and TYPE2 are compatible types for assignment\n-   or various other operations.  This is what ANSI C++ speaks of as\n-   \"being the same\".\n-\n-   For C++: argument STRICT says we should be strict about this\n-   comparison:\n-\n-\t2 : strict, except that if one type is a reference and\n-\t    the other is not, compare the target type of the\n-\t    reference to the type that's not a reference (ARM, p308).\n-\t    This is used for checking for invalid overloading.\n-\t1 : strict (compared according to ANSI C)\n-\t    This is used for checking whether two function decls match.\n-\t0 : <= (compared according to C++)\n-\t-1: <= or >= (relaxed)\n-\n-   Otherwise, pointers involving base classes and derived classes can\n-   be mixed as valid: i.e. a pointer to a derived class may be converted\n-   to a pointer to one of its base classes, as per C++. A pointer to\n-   a derived class may be passed as a parameter to a function expecting a\n-   pointer to a base classes. These allowances do not commute. In this\n-   case, TYPE1 is assumed to be the base class, and TYPE2 is assumed to\n-   be the derived class.  */\n+   or various other operations.  STRICT is a bitwise-or of the\n+   COMPARE_* flags.  */\n \n int\n comptypes (type1, type2, strict)\n@@ -697,9 +694,18 @@ comptypes (type1, type2, strict)\n   register tree t1 = type1;\n   register tree t2 = type2;\n   int attrval, val;\n+  int orig_strict = strict;\n \n-  /* Suppress errors caused by previously reported errors */\n+  /* The special exemption for redeclaring array types without an\n+     array bound only applies at the top level:\n+\n+       extern int (*i)[];\n+       int (*i)[8];\n+\n+     is not legal, for example.  */\n+  strict &= ~COMPARE_REDECLARATION;\n \n+  /* Suppress errors caused by previously reported errors */\n   if (t1 == t2)\n     return 1;\n \n@@ -709,7 +715,7 @@ comptypes (type1, type2, strict)\n   if (t2 == error_mark_node)\n     return 0;\n \n-  if (strict < 0)\n+  if (strict & COMPARE_RELAXED)\n     {\n       /* Treat an enum type as the unsigned integer type of the same width.  */\n \n@@ -728,28 +734,14 @@ comptypes (type1, type2, strict)\n     t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n \n   /* Different classes of types can't be compatible.  */\n-\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n-    {\n-      if (strict == 2\n-\t  && ((TREE_CODE (t1) == REFERENCE_TYPE)\n-\t      ^ (TREE_CODE (t2) == REFERENCE_TYPE)))\n-\t{\n-\t  if (TREE_CODE (t1) == REFERENCE_TYPE)\n-\t    return comptypes (TREE_TYPE (t1), t2, 1);\n-\t  return comptypes (t1, TREE_TYPE (t2), 1);\n-\t}\n-\n-      return 0;\n-    }\n-  if (strict > 1)\n-    strict = 1;\n+    return 0;\n \n   /* Qualifiers must match.  */\n-\n   if (CP_TYPE_QUALS (t1) != CP_TYPE_QUALS (t2))\n     return 0;\n-  if (strict > 0 && TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n+  if (strict == COMPARE_STRICT \n+      && TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n     return 0;\n \n   /* Allow for two different type nodes which have essentially the same\n@@ -784,19 +776,28 @@ comptypes (type1, type2, strict)\n       if (! CLASSTYPE_TEMPLATE_INFO (t1) && ! CLASSTYPE_TEMPLATE_INFO (t2))\n \treturn 1;\n       /* Don't check inheritance.  */\n-      strict = 1;\n+      strict = COMPARE_STRICT;\n       /* fall through */\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n       if (CLASSTYPE_TEMPLATE_INFO (t1) && CLASSTYPE_TEMPLATE_INFO (t2)\n \t  && (CLASSTYPE_TI_TEMPLATE (t1) == CLASSTYPE_TI_TEMPLATE (t2)\n \t      || TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM))\n-\treturn comp_template_args (CLASSTYPE_TI_ARGS (t1),\n-\t\t\t\t   CLASSTYPE_TI_ARGS (t2));\n-      if (strict <= 0)\n-\tgoto look_hard;\n-      return 0;\n+\tval = comp_template_args (CLASSTYPE_TI_ARGS (t1),\n+\t\t\t\t  CLASSTYPE_TI_ARGS (t2));\n+    look_hard:\n+      if ((strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n+\t{\n+\t  val = 1;\n+\t  break;\n+\t}\n+      if ((strict & COMPARE_RELAXED) && DERIVED_FROM_P (t2, t1))\n+\t{\n+\t  val = 1;\n+\t  break;\n+\t}\n+      break;\n \n     case OFFSET_TYPE:\n       val = (comptypes (build_pointer_type (TYPE_OFFSET_BASETYPE (t1)),\n@@ -826,28 +827,9 @@ comptypes (type1, type2, strict)\n       val = comptypes (t1, t2, strict);\n       if (val)\n \tbreak;\n-      /* if they do not, try more relaxed alternatives */\n-      if (strict <= 0)\n-\t{\n-\t  if (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE)\n-\t    {\n-\t      int rval;\n-\t    look_hard:\n-\t      rval = t1 == t2 || DERIVED_FROM_P (t1, t2);\n-\n-\t      if (rval)\n-\t\t{\n-\t\t  val = 1;\n-\t\t  break;\n-\t\t}\n-\t      if (strict < 0)\n-\t\t{\n-\t\t  val = DERIVED_FROM_P (t2, t1);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  return 0;\n-\t}\n+      if (TREE_CODE (t1) == RECORD_TYPE \n+\t  && TREE_CODE (t2) == RECORD_TYPE)\n+\tgoto look_hard;\n       break;\n \n     case FUNCTION_TYPE:\n@@ -860,8 +842,10 @@ comptypes (type1, type2, strict)\n       break;\n \n     case ARRAY_TYPE:\n-      /* Target types must match incl. qualifiers.  */\n-      val = comp_array_types (comptypes, t1, t2, strict);\n+      /* Target types must match incl. qualifiers.  We use ORIG_STRICT\n+\t here since this is the one place where\n+\t COMPARE_REDECLARATION should be used.  */\n+      val = comp_array_types (comptypes, t1, t2, orig_strict);\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n@@ -871,7 +855,7 @@ comptypes (type1, type2, strict)\n     case TYPENAME_TYPE:\n       if (TYPE_IDENTIFIER (t1) != TYPE_IDENTIFIER (t2))\n \treturn 0;\n-      return comptypes (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2), 1);\n+      return same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n \n     default:\n       break;\n@@ -978,15 +962,15 @@ comp_target_types (ttl, ttr, nptrs)\n     }\n \n   if (TREE_CODE (ttr) == ARRAY_TYPE)\n-    return comp_array_types (comp_target_types, ttl, ttr, 0);\n+    return comp_array_types (comp_target_types, ttl, ttr, COMPARE_STRICT);\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n     {\n       tree argsl, argsr;\n       int saw_contra = 0;\n \n       if (pedantic)\n \t{\n-\t  if (comptypes (TREE_TYPE (ttl), TREE_TYPE (ttr), 1) == 0)\n+\t  if (!same_type_p (TREE_TYPE (ttl), TREE_TYPE (ttr)))\n \t    return 0;\n \t}\n       else\n@@ -1009,9 +993,9 @@ comp_target_types (ttl, ttr, nptrs)\n \t  tree tl = TYPE_METHOD_BASETYPE (ttl);\n \t  tree tr = TYPE_METHOD_BASETYPE (ttr);\n \n-\t  if (comptypes (tr, tl, 0) == 0)\n+\t  if (!same_or_base_type_p (tr, tl))\n \t    {\n-\t      if (comptypes (tl, tr, 0))\n+\t      if (same_or_base_type_p (tl, tr))\n \t\tsaw_contra = 1;\n \t      else\n \t\treturn 0;\n@@ -1039,11 +1023,11 @@ comp_target_types (ttl, ttr, nptrs)\n       /* Contravariance: we can assign a pointer to base member to a pointer\n \t to derived member.  Note difference from simple pointer case, where\n \t we can pass a pointer to derived to a pointer to base.  */\n-      if (comptypes (TYPE_OFFSET_BASETYPE (ttr),\n-\t\t     TYPE_OFFSET_BASETYPE (ttl), 0))\n+      if (same_or_base_type_p (TYPE_OFFSET_BASETYPE (ttr),\n+\t\t\t       TYPE_OFFSET_BASETYPE (ttl)))\n \tbase = 1;\n-      else if (comptypes (TYPE_OFFSET_BASETYPE (ttl),\n-\t\t\t  TYPE_OFFSET_BASETYPE (ttr), 0))\n+      else if (same_or_base_type_p (TYPE_OFFSET_BASETYPE (ttl),\n+\t\t\t\t    TYPE_OFFSET_BASETYPE (ttr)))\n \t{\n \t  tree tmp = ttl;\n \t  ttl = ttr;\n@@ -1074,9 +1058,11 @@ comp_target_types (ttl, ttr, nptrs)\n     {\n       if (nptrs < 0)\n \treturn 0;\n-      if (comptypes (build_pointer_type (ttl), build_pointer_type (ttr), 0))\n+      if (same_or_base_type_p (build_pointer_type (ttl), \n+\t\t\t       build_pointer_type (ttr)))\n \treturn 1;\n-      if (comptypes (build_pointer_type (ttr), build_pointer_type (ttl), 0))\n+      if (same_or_base_type_p (build_pointer_type (ttr), \n+\t\t\t       build_pointer_type (ttl)))\n \treturn -1;\n       return 0;\n     }\n@@ -1225,7 +1211,7 @@ compparms (parms1, parms2)\n \t they fail to match.  */\n       if (t1 == 0 || t2 == 0)\n \treturn 0;\n-      if (! comptypes (TREE_VALUE (t2), TREE_VALUE (t1), 1))\n+      if (!same_type_p (TREE_VALUE (t2), TREE_VALUE (t1)))\n \treturn 0;\n \n       t1 = TREE_CHAIN (t1);\n@@ -1279,7 +1265,7 @@ comp_target_parms (parms1, parms2, strict)\n \t}\n       p1 = TREE_VALUE (t1);\n       p2 = TREE_VALUE (t2);\n-      if (comptypes (p1, p2, 1))\n+      if (same_type_p (p1, p2))\n \tcontinue;\n \n       if (pedantic)\n@@ -1303,12 +1289,10 @@ comp_target_parms (parms1, parms2, strict)\n \t      warn_contravariance = 1;\n \t      continue;\n \t    }\n-\t  if (IS_AGGR_TYPE (TREE_TYPE (p1)))\n-\t    {\n-\t      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (p1)),\n-\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (p2)), 1) == 0)\n-\t\treturn 0;\n-\t    }\n+\t  if (IS_AGGR_TYPE (TREE_TYPE (p1))\n+\t      && !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (p1)),\n+\t\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (p2))))\n+\t    return 0;\n \t}\n       /* Note backwards order due to contravariance.  */\n       if (comp_target_types (p2, p1, 1) <= 0)\n@@ -1781,14 +1765,14 @@ string_conv_p (totype, exp, warn)\n     return 0;\n \n   t = TREE_TYPE (totype);\n-  if (! comptypes (t, char_type_node, 1)\n-      && ! comptypes (t, wchar_type_node, 1))\n+  if (!same_type_p (t, char_type_node)\n+      && !same_type_p (t, wchar_type_node))\n     return 0;\n \n   if (TREE_CODE (exp) != STRING_CST)\n     {\n       t = build_pointer_type (build_qualified_type (t, TYPE_QUAL_CONST));\n-      if (! comptypes (TREE_TYPE (exp), t, 1))\n+      if (!same_type_p (TREE_TYPE (exp), t))\n \treturn 0;\n       STRIP_NOPS (exp);\n       if (TREE_CODE (exp) != ADDR_EXPR\n@@ -2110,7 +2094,7 @@ build_component_ref (datum, component, basetype_path, protect)\n     {\n       tree context = DECL_FIELD_CONTEXT (field);\n       tree base = context;\n-      while (!comptypes (base, basetype,1) && TYPE_NAME (base)\n+      while (!same_type_p (base, basetype) && TYPE_NAME (base)\n \t     && ANON_UNION_TYPE_P (base))\n \t{\n \t  base = TYPE_CONTEXT (base);\n@@ -2257,7 +2241,7 @@ build_indirect_ref (ptr, errorstring)\n \n       if (TREE_CODE (pointer) == ADDR_EXPR\n \t  && !flag_volatile\n-\t  && comptypes (t, TREE_TYPE (TREE_OPERAND (pointer, 0)), 1))\n+\t  && same_type_p (t, TREE_TYPE (TREE_OPERAND (pointer, 0))))\n \t/* The POINTER was something like `&x'.  We simplify `*&x' to\n \t   `x'.  */\n \treturn TREE_OPERAND (pointer, 0);\n@@ -5052,7 +5036,7 @@ build_conditional_expr (ifexp, op1, op2)\n \n   if (code1 == RECORD_TYPE && code2 == RECORD_TYPE\n       && real_lvalue_p (op1) && real_lvalue_p (op2)\n-      && comptypes (type1, type2, -1))\n+      && comptypes (type1, type2, COMPARE_BASE | COMPARE_RELAXED))\n     {\n       type1 = build_reference_type (type1);\n       type2 = build_reference_type (type2);\n@@ -5106,7 +5090,7 @@ build_conditional_expr (ifexp, op1, op2)\n \t  result_type = qualify_type (type2, type1);\n \t}\n       /* C++ */\n-      else if (comptypes (type2, type1, 0))\n+      else if (same_or_base_type_p (type2, type1))\n \tresult_type = type2;\n       else if (IS_AGGR_TYPE (TREE_TYPE (type1))\n \t       && IS_AGGR_TYPE (TREE_TYPE (type2))\n@@ -5383,8 +5367,8 @@ build_static_cast (type, expr)\n     }\n   else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n     {\n-      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type))),\n-\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (intype))), 1)\n+      if (same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type))),\n+\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (intype))))\n \t  && at_least_as_qualified_p (TREE_TYPE (TREE_TYPE (type)),\n \t\t\t\t      TREE_TYPE (TREE_TYPE (intype)))\n \t  && (binfo = get_binfo (TYPE_OFFSET_BASETYPE (TREE_TYPE (type)),\n@@ -5452,7 +5436,8 @@ build_reinterpret_cast (type, expr)\n \texpr = build_indirect_ref (expr, 0);\n       return expr;\n     }\n-  else if (comptypes (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type), 1))\n+  else if (same_type_p (TYPE_MAIN_VARIANT (intype), \n+\t\t\tTYPE_MAIN_VARIANT (type)))\n     return build_static_cast (type, expr);\n \n   if (TYPE_PTR_P (type) && (TREE_CODE (intype) == INTEGER_TYPE\n@@ -5531,7 +5516,7 @@ build_const_cast (type, expr)\n \n   intype = TREE_TYPE (expr);\n \n-  if (comptypes (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type), 1))\n+  if (same_type_p (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type)))\n     return build_static_cast (type, expr);\n   else if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n@@ -6033,7 +6018,7 @@ build_modify_expr (lhs, modifycode, rhs)\n     {\n       int from_array;\n       \n-      if (! comptypes (lhstype, TREE_TYPE (rhs), 0))\n+      if (!same_or_base_type_p (lhstype, TREE_TYPE (rhs)))\n \t{\n \t  cp_error (\"incompatible types in assignment of `%T' to `%T'\",\n \t\t    TREE_TYPE (rhs), lhstype);\n@@ -6533,7 +6518,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   else if (TREE_READONLY_DECL_P (rhs))\n     rhs = decl_constant_value (rhs);\n \n-  if (comptypes (type, rhstype, 1))\n+  if (same_type_p (type, rhstype))\n     {\n       overflow_warning (rhs);\n       return rhs;\n@@ -6778,7 +6763,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t member function pointers as C.  Emit warnings here.  */\n \t      if (TREE_CODE (ttl) == FUNCTION_TYPE\n \t\t  || TREE_CODE (ttl) == METHOD_TYPE)\n-\t\tif (! comptypes (ttl, ttr, 0))\n+\t\tif (!same_or_base_type_p (ttl, ttr))\n \t\t  {\n \t\t    warning (\"conflicting function types in %s:\", errtype);\n \t\t    cp_warning (\"\\t`%T' != `%T'\", type, rhstype);\n@@ -7363,8 +7348,8 @@ comp_ptr_ttypes_real (to, from, constp)\n \treturn 0;\n \n       if (TREE_CODE (from) == OFFSET_TYPE\n-\t  && comptypes (TYPE_OFFSET_BASETYPE (from),\n-\t\t\tTYPE_OFFSET_BASETYPE (to), 1))\n+\t  && same_type_p (TYPE_OFFSET_BASETYPE (from),\n+\t\t\t  TYPE_OFFSET_BASETYPE (to)))\n \t  continue;\n \n       /* Const and volatile mean something different for function types,\n@@ -7388,7 +7373,7 @@ comp_ptr_ttypes_real (to, from, constp)\n \n       if (TREE_CODE (to) != POINTER_TYPE)\n \treturn \n-\t  comptypes (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), 1)\n+\t  same_type_p (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from))\n \t  && (constp >= 0 || to_more_cv_qualified);\n     }\n }\n@@ -7418,12 +7403,14 @@ ptr_reasonably_similar (to, from)\n \n       if (TREE_CODE (from) == OFFSET_TYPE\n \t  && comptypes (TYPE_OFFSET_BASETYPE (to),\n-\t\t\tTYPE_OFFSET_BASETYPE (from), -1))\n+\t\t\tTYPE_OFFSET_BASETYPE (from), \n+\t\t\tCOMPARE_BASE | COMPARE_RELAXED))\n \tcontinue;\n \n       if (TREE_CODE (to) != POINTER_TYPE)\n \treturn comptypes\n-\t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), -1);\n+\t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), \n+\t   COMPARE_BASE | COMPARE_RELAXED);\n     }\n }\n \n@@ -7439,12 +7426,13 @@ comp_ptr_ttypes_const (to, from)\n \treturn 0;\n \n       if (TREE_CODE (from) == OFFSET_TYPE\n-\t  && comptypes (TYPE_OFFSET_BASETYPE (from),\n-\t\t\tTYPE_OFFSET_BASETYPE (to), 1))\n+\t  && same_type_p (TYPE_OFFSET_BASETYPE (from),\n+\t\t\t  TYPE_OFFSET_BASETYPE (to)))\n \t  continue;\n \n       if (TREE_CODE (to) != POINTER_TYPE)\n-\treturn comptypes (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), 1);\n+\treturn same_type_p (TYPE_MAIN_VARIANT (to), \n+\t\t\t    TYPE_MAIN_VARIANT (from));\n     }\n }\n "}, {"sha": "489671f24ae10eb3cc7099931a9e2ccb9ea21d9d", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900321_01.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900321_01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900321_01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900321_01.C?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -19,8 +19,8 @@ void function_0 ()\n {\n   // we miss the first two because typeck.c (comp_array_types) deems\n   // it okay if one of the sizes is null\n-  ptr_to_array_of_ints = ptr_to_array_of_3_ints;\t// ERROR - , XFAIL *-*-*\n-  ptr_to_array_of_3_ints = ptr_to_array_of_ints;\t// ERROR - , XFAIL *-*-*\n+  ptr_to_array_of_ints = ptr_to_array_of_3_ints;\t// ERROR - \n+  ptr_to_array_of_3_ints = ptr_to_array_of_ints;\t// ERROR - \n \n   ptr_to_array_of_3_ints = ptr_to_array_of_5_ints;\t// ERROR - \n   ptr_to_array_of_5_ints = ptr_to_array_of_3_ints;\t// ERROR - "}, {"sha": "5f3aa0506090f4ebb06fc7ee60be2c919c0eafdb", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900322_01.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900322_01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900322_01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900322_01.C?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -22,23 +22,23 @@\n \n // keywords: incomplete types, arrays, element types\n \n-extern int extern_two_d [] [];\t\t// ERROR - , XFAIL *-*-*\n+extern int extern_two_d [] [];\t\t// ERROR - invalid declaration\n int tenative_two_d [] [];\t\t// ERROR - caught by g++\n static int static_two_d [] [];\t\t// ERROR - caught by g++\n \n-int (*pointer_to_two_d)[][];\t\t// ERROR - , XFAIL *-*-*\n+int (*pointer_to_two_d)[][];\t\t// ERROR - invalid declaration\n \n-void function_0 (int arg [] []) {\t/* ERROR - */\n+void function_0 (int arg [] []) {\t// ERROR - invalid declaration\n }\n \n typedef int int_one_d_type [];\n-typedef int_one_d_type int_two_d_type[];// ERROR - , XFAIL *-*-*\n+typedef int_one_d_type int_two_d_type[];// ERROR - invalid declaration\n \n struct s;\n \n extern struct s extern_s_array [10];\t// ERROR - , XFAIL *-*-*\n-struct s tenative_s_array [10];\t\t/* ERROR - caught by g++ */\n-static struct s static_s_array [10];\t/* ERROR - caught by g++ */\n+struct s tenative_s_array [10];\t\t// ERROR - caught by g++ \n+static struct s static_s_array [10];\t// ERROR - caught by g++\n \n struct s (*pointer_to_s_array) [];\t// ERROR - , XFAIL *-*-*\n "}, {"sha": "80543b6791324aa3f018abff1d4b56affdacf2f9", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900520_02.C", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900520_02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900520_02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900520_02.C?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -1,13 +1,5 @@\n // g++ 1.37.1 bug 900520_02\n \n-// g++ fails to allow a reference to an unbounded array type to be passed\n-// into a formal parameter whose type is pointer-to-bounded-array type.\n-\n-// Cases other than parameter passing in which similar initializations\n-// take place are allowed however.\n-\n-// cfront 2.0 passes this test.\n-\n // keywords: reference types, initialization, parameter passing\n \n typedef int b_array[3];\n@@ -16,17 +8,17 @@ typedef int u_array[];\n typedef b_array &b_array_ref;\n typedef u_array &u_array_ref;\n \n-void take_b_array_ref (b_array_ref arg) { }\n+void take_b_array_ref (b_array_ref arg) { } // ERROR - passed to here\n \n extern u_array u_array_gbl_obj;\n \n u_array_ref u_array_ref_gbl_obj0 = u_array_gbl_obj;\n \n-b_array_ref b_array_ref_gbl_obj0 = u_array_ref_gbl_obj0;\t// OK\n+b_array_ref b_array_ref_gbl_obj0 = u_array_ref_gbl_obj0; // ERROR - invalid declaration\n \n void test_passing ()\n {\n-  take_b_array_ref (u_array_ref_gbl_obj0);\t// gets bogus error\n+  take_b_array_ref (u_array_ref_gbl_obj0); // ERROR - invalid call\n }\n \n b_array u_array_gbl_obj;"}, {"sha": "6dd5fed5c25d810f98bbd7f50c722ed589e4d690", "filename": "gcc/testsuite/g++.old-deja/g++.other/typeck1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ftypeck1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ftypeck1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ftypeck1.C?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -0,0 +1,17 @@\n+// Build don't link:\n+\n+extern int a[][];   // ERROR - invalid multidimensional array\n+extern int b[7][];  // ERROR - invalid multidimensional array\n+extern int c[][7];  // OK\n+\n+extern int (*i)[];  // ERROR - previous declaration\n+extern int (*i)[7]; // ERROR - conflicting types for `i'\n+\n+extern int m[];\n+extern int m[7];    // OK\n+\n+void f(int (*j)[3])\n+{\n+  extern int (*k)[];\n+  f(k);             // ERROR - passing wrong type\n+}"}, {"sha": "8b7c373c1b73a869584cf52c517d6b02ca446a72", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem3.C?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S : public S<T*> {};\n+template <>\n+struct S<int**> {};\n+\n+void g()\n+{\n+  int S<int*>::*p;\n+  int S<int>::*q = p;\n+}"}, {"sha": "566665af23c64d6f059213cd0156af861a1c17f6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/sizeof2.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fsizeof2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fsizeof2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fsizeof2.C?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -3,8 +3,6 @@\n \n // Adapted from testcase by Oskar Enoksson <osken393@student.liu.se>\n \n-// execution test - XFAIL *-*-*\n-\n extern \"C\" void abort();\n \n template<int N, class T> // Base class"}, {"sha": "cd5f701f20fcbfbb3ab759a298ab5bd1004f960e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/sizeof3.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fsizeof3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bfdc7190fb8136f0f66108e43f49b0b28e98374/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fsizeof3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fsizeof3.C?ref=3bfdc7190fb8136f0f66108e43f49b0b28e98374", "patch": "@@ -1,7 +1,5 @@\n // Adapted from testcase by Oskar Enoksson <osken393@student.liu.se>\n \n-// execution test - XFAIL *-*-*\n-\n extern \"C\" void abort();\n \n template<class T0>\n@@ -22,6 +20,6 @@ public:\n };\n \n int main() {\n-  if (sizeof(C<3,7>::AC::T) != 7) // gets bogus error - XFAIL *-*-*\n+  if (sizeof(C<3,7>::AC::T) != 7) \n     abort();\n }"}]}