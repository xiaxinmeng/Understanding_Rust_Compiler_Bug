{"sha": "e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI3ZDYyMDJjMDdkYmM3MDE3MjczM2ZjZjZlNzljYjJmZmU5YTU2Yw==", "commit": {"author": {"name": "Scott Gilbertson", "email": "scottg@mantatest.com", "date": "2005-07-15T16:07:18Z"}, "committer": {"name": "Scott Gilbertson", "email": "sgilbertson@gcc.gnu.org", "date": "2005-07-15T16:07:18Z"}, "message": "XCanvasPeer.java (attributes): New field.\n\n2005-07-15  Scott Gilbertson  <scottg@mantatest.com>\n\n\t* gnu/awt/xlib/XCanvasPeer.java (attributes): New field.\n\t(eventMask): New field.\n\t(XCanvasPeer(Component)): Use attributes field.\n\t(setBackground): Implemented.\n\t(setEventMask): Process mask only if changed.\n\t* gnu/awt/xlib/XEventLoop.java (class): Iplement Runnable.\n\t(eventLoopThread): New field.\n\t(XEventLoop(Display,EventQueue)): Start eventLoopThread.\n\t(interrupt): Removed.\n\t(run): New method.\n\t* gnu/awt/xlib/XEventQueue.java (getNextEvent): Process Container\n\tand Component events.\n\t* gnu/awt/xlib/XFramePeer.java (processingConfigureNotify): New\n\tfield.\n\t(configureNotify): Set and clear processingConfigureNotify.\n\t(setBounds): Process only if processingConfigureNotify is false.\n\t(toBack): Implemented.\n\t(toFront): Implemented.\n\t* gnu/awt/xlib/XGraphics.java (setColor): Ignore null color.\n\t* gnu/awt/xlib/XGraphicsConfiguration.java (getPixel): Ignore null\n\tcolor.\n\t* gnu/awt/xlib/XToolkit.java (nativeQueueEmpty): Always return true.\n\t(wakeNativeQueue): Do nothing.\n\t(iterateNativeQueue): Do queue.wait if blocking.\n\t* gnu/gcj/xlib/Font.java (loadFont): New method.\n\t(loadFontImpl): Renamed native method, was loadFont.\n\t* gnu/gcj/xlib/Window.java (toFront): New method.\n\t(toBack): New method.\n\t* gnu/gcj/xlib/natFont.cc (loadFontImpl): Renamed method, was\n\tloadFont.\n\t* gnu/gcj/xlib/natWindow.cc (toBack): New method.\n\t(toFront): New method.\n\t* gnu/gcj/xlib/natXAnyEvent.cc (loadNext): Removed timeout.\n\nFrom-SVN: r102057", "tree": {"sha": "36d9688009aa0d1293f407c7660e7901e7986ce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d9688009aa0d1293f407c7660e7901e7986ce0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/comments", "author": null, "committer": null, "parents": [{"sha": "27811bfe0a0bd1ff8ad3b361318df9f80fdae79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27811bfe0a0bd1ff8ad3b361318df9f80fdae79c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27811bfe0a0bd1ff8ad3b361318df9f80fdae79c"}], "stats": {"total": 293, "additions": 229, "deletions": 64}, "files": [{"sha": "4fae8576c865ad8b20f10e561fa439111ed912c3", "filename": "libjava/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -1,3 +1,39 @@\n+2005-07-15  Scott Gilbertson  <scottg@mantatest.com>\n+\n+\t* gnu/awt/xlib/XCanvasPeer.java (attributes): New field.\n+\t(eventMask): New field.\n+\t(XCanvasPeer(Component)): Use attributes field.\n+\t(setBackground): Implemented.\n+\t(setEventMask): Process mask only if changed.\n+\t* gnu/awt/xlib/XEventLoop.java (class): Iplement Runnable.\n+\t(eventLoopThread): New field.\n+\t(XEventLoop(Display,EventQueue)): Start eventLoopThread.\n+\t(interrupt): Removed.\n+\t(run): New method.\n+\t* gnu/awt/xlib/XEventQueue.java (getNextEvent): Process Container\n+\tand Component events.\n+\t* gnu/awt/xlib/XFramePeer.java (processingConfigureNotify): New\n+\tfield.\n+\t(configureNotify): Set and clear processingConfigureNotify.\n+\t(setBounds): Process only if processingConfigureNotify is false.\n+\t(toBack): Implemented.\n+\t(toFront): Implemented.\n+\t* gnu/awt/xlib/XGraphics.java (setColor): Ignore null color.\n+\t* gnu/awt/xlib/XGraphicsConfiguration.java (getPixel): Ignore null\n+\tcolor.\n+\t* gnu/awt/xlib/XToolkit.java (nativeQueueEmpty): Always return true.\n+\t(wakeNativeQueue): Do nothing.\n+\t(iterateNativeQueue): Do queue.wait if blocking.\n+\t* gnu/gcj/xlib/Font.java (loadFont): New method.\n+\t(loadFontImpl): Renamed native method, was loadFont. \n+\t* gnu/gcj/xlib/Window.java (toFront): New method.\n+\t(toBack): New method.\n+\t* gnu/gcj/xlib/natFont.cc (loadFontImpl): Renamed method, was \n+\tloadFont.\n+\t* gnu/gcj/xlib/natWindow.cc (toBack): New method.\n+\t(toFront): New method. \n+\t* gnu/gcj/xlib/natXAnyEvent.cc (loadNext): Removed timeout.\n+\n 2005-07-14  Andrew Haley  <aph@redhat.com>\n \n         * gnu/java/net/protocol/file/Connection.java (unquote): New"}, {"sha": "39a3f9331f4e6d7e5df556ef17bae8be98aa8caa", "filename": "libjava/gnu/awt/xlib/XCanvasPeer.java", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -55,6 +55,8 @@ public class XCanvasPeer implements CanvasPeer\n \n   Component component;\n   XGraphicsConfiguration config;\n+  private WindowAttributes attributes = new WindowAttributes();\n+  private long eventMask;\n   \n   public XCanvasPeer(Component component)\n   {\n@@ -92,7 +94,6 @@ public XCanvasPeer(Component component)\n        object. */\n     component.setBounds(bounds);\n \t    \n-    WindowAttributes attributes = new WindowAttributes();\n \n     /* Set background color */\n     Color bg = component.getBackground();\n@@ -349,8 +350,21 @@ public void requestFocus()\n \n   public void setBackground(Color color)\n   {\n-    /* default canvas peer does not keep track of background, since it won't\n-     * paint anything. */\n+    if (color != null)\n+    {\n+      int[] components =\n+      {\n+        color.getRed (),\n+        color.getGreen (),\n+        color.getBlue (),\n+        0xff\n+      };\n+      \n+      ColorModel cm = config.getColorModel ();\n+      long pixel = cm.getDataElement (components, 0);\n+      attributes.setBackground (pixel);\n+      window.setAttributes (attributes);\n+    }\n   }\n \n   public void setBounds(int x, int y, int width, int height)\n@@ -388,20 +402,22 @@ public void disable ()\n \n   public void setEventMask(long eventMask)\n   {\n-    WindowAttributes attributes = new WindowAttributes();\n-\n-    long xEventMask = getBasicEventMask();\n-\t\n-    if ((eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0)\n+    if (this.eventMask != eventMask)\n+    {\n+      this.eventMask = eventMask;\n+      long xEventMask = getBasicEventMask ();\n+      \n+      if ((eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0)\n       {\n-\txEventMask |=\n-\t  WindowAttributes.MASK_BUTTON_PRESS |\n-\t  WindowAttributes.MASK_BUTTON_RELEASE;\n+        xEventMask |=\n+          WindowAttributes.MASK_BUTTON_PRESS |\n+          WindowAttributes.MASK_BUTTON_RELEASE;\n       }\n-\t    \n-    attributes.setEventMask(xEventMask);\n-    window.setAttributes(attributes);\n-    ensureFlush();\n+      \n+      attributes.setEventMask (xEventMask);\n+      window.setAttributes (attributes);\n+      ensureFlush ();\n+    }\n   }\n \n   public void setFont(Font font)"}, {"sha": "d0c46a804d56a0e2e441808dca2ddf72f2ba6877", "filename": "libjava/gnu/awt/xlib/XEventLoop.java", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -21,12 +21,13 @@\n import java.awt.event.MouseEvent;\n import java.util.Vector;\n \n-public class XEventLoop\n+public class XEventLoop implements Runnable\n {\n   Display display;\n   EventQueue queue;\n   XAnyEvent anyEvent;\n-\n+  private Thread eventLoopThread;\n+  \n   LightweightRedirector lightweightRedirector = new LightweightRedirector();\n     \n   public XEventLoop(Display display, EventQueue queue)\n@@ -35,13 +36,17 @@ public XEventLoop(Display display, EventQueue queue)\n     this.queue = queue;\n     \n     anyEvent = new XAnyEvent(display);\n+    eventLoopThread = new Thread(this, \"AWT thread for XEventLoop\");\n+    eventLoopThread.start();\n   }\n \n-  void interrupt()\n+  public void run ()\n   {\n-    anyEvent.interrupt();\n+    // FIXME: do we need an interrupt mechanism for window shutdown?\n+    while (true)\n+      postNextEvent (true);\n   }\n-\n+  \n   /** If there's an event available, post it.\n    * @return true if an event was posted\n    */\n@@ -65,7 +70,7 @@ public AWTEvent getNextEvent(boolean block)\n     AWTEvent event = null;\n     if (loadNextEvent(block))\n       {\n-        event = createEvent();        \n+        event = createEvent(); \n         event = lightweightRedirector.redirect(event);\n       }\n     return event;"}, {"sha": "b068daf1b52fe69770f80d6266fbaa8b9e493d73", "filename": "libjava/gnu/awt/xlib/XEventQueue.java", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventQueue.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -8,12 +8,16 @@\n \n package gnu.awt.xlib;\n \n-import java.awt.*;\n-\n import gnu.gcj.xlib.Display;\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.EventQueue;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ContainerEvent;\n \n /**\n- * The only difference here from a standard EventQueue is that the X\n+ * The main difference here from a standard EventQueue is that the X\n  * display connection is flushed before waiting for more events.\n  */\n public class XEventQueue extends EventQueue\n@@ -29,6 +33,67 @@ public AWTEvent getNextEvent() throws InterruptedException\n   {\n     if ((peekEvent() == null) && (display != null))\n       display.flush();\n-    return super.getNextEvent();\n+    AWTEvent event = super.getNextEvent();\n+    if (event != null)\n+    {\n+      switch (event.getID ())\n+      {\n+        case ContainerEvent.COMPONENT_ADDED:\n+        {\n+          /* If a component has been added to a container, it needs to be\n+           * invalidated, to ensure that it ultimately gets an addNotify.\n+           * If it's not invalidated, the component will never display in \n+           * an already-showing container (probably applies only to CardLayout).\n+           * Perhaps this code should be in java.awt, but the problem only seems \n+           * to happen with xlib peers (not with gtk peers) so it's here instead.\n+           */\n+          ContainerEvent ce = (ContainerEvent)event;\n+          ce.getChild ().invalidate ();\n+          ce.getContainer ().validate ();\n+        }\n+        break;\n+\n+        case ComponentEvent.COMPONENT_RESIZED:\n+        {\n+          ComponentEvent ce = (ComponentEvent)event;\n+          // FIXME: there may be opportunities to coalesce resize events\n+          ce.getComponent ().validate ();\n+        }\n+        break;\n+\n+        case ComponentEvent.COMPONENT_SHOWN:\n+        {\n+          ComponentEvent ce = (ComponentEvent)event;\n+          Component comp = ce.getComponent ();\n+          if (!comp.isValid ())\n+          {\n+            /* Try to validate, going up the tree to the highest-level invalid\n+             * Container.  The idea is to ensure that addNotify gets called for\n+             * any non-top-level component being shown, to make it create a peer.\n+             */\n+            Container parent = comp.getParent ();\n+            while (parent != null)\n+            {\n+              Container next = parent.getParent ();\n+              if (next == null || next.isValid ())\n+              {\n+                parent.validate ();\n+                break;\n+              }\n+              else\n+                parent = next;\n+            }\n+            if (comp instanceof Container)\n+              comp.validate ();\n+          }\n+          comp.repaint ();\n+        }\n+        break;\n+        \n+        default:\n+          break;\n+      }\n+    }\n+    return event;\n   }\n }"}, {"sha": "79f1e88cf2825a1cd35cf820faf885b0f1cc4222", "filename": "libjava/gnu/awt/xlib/XFramePeer.java", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXFramePeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXFramePeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXFramePeer.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -22,7 +22,8 @@\n \n public class XFramePeer extends XCanvasPeer implements FramePeer\n {\n-\n+  private boolean processingConfigureNotify = false;\n+  \n   public XFramePeer(Frame frame)\n   {\n     super(frame);\n@@ -62,28 +63,24 @@ long getBasicEventMask()\n \n   void configureNotify(XConfigureEvent configEvent)\n   {\n+    processingConfigureNotify = true; // to avoid setBounds flood\n     component.setBounds(configEvent.getBounds());\n-    \n-    /* FIXME: Validation should probably not be done here.  The best\n-       strategy is probably to validate on the AWT thread in response\n-       to an ComponentEvent.  This will make it possible to coalesce\n-       resize validations. */\n-    component.validate();\n+    processingConfigureNotify = false;\n   }\n \n   /* Overridden to ignore request to set bounds if the request occurs\n-     on the X event loop thread.  It is assumed that all requests that\n-     occur on the X event loop thread are results of XConfigureNotify\n-     events, in which case the X window already has the desired\n-     bounds.  */\n+     while processing an XConfigureNotify event, in which case the X\n+     window already has the desired bounds.\n+     That's what java.awt.Window.setBoundsCallback is for, but it's\n+     package-private, and using our own flag eliminates the need to\n+     circumvent java security.\n+  */\n   public void setBounds(int x, int y, int width, int height)\n   {\n-    if (EventQueue.isDispatchThread())\n-      return;\n-    \n-    super.setBounds(x, y, width, height);\n+    if (!processingConfigureNotify)\n+      super.setBounds(x, y, width, height);\n   }\n- \n+  \n   // Implementing ContainerPeer:\n \n   static final Insets INSETS_0_PROTOTYPE = new Insets(0, 0, 0, 0);\n@@ -114,12 +111,12 @@ public void endValidate()\n \n   public void toBack()\n   {\n-    throw new UnsupportedOperationException(\"not implemented yet\");\t\n+    window.toBack ();\t\n   }\n   \n   public void toFront()\n   {\n-    throw new UnsupportedOperationException(\"not implemented yet\");\t\n+    window.toFront ();\n   }\n \n "}, {"sha": "215c04dc197b5bf11f873a4bdc45deac30c98b14", "filename": "libjava/gnu/awt/xlib/XGraphics.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -83,7 +83,8 @@ public XGraphics(Drawable drawable, XGraphicsConfiguration config)\n   \n   public void setColor(Color color)\n   {\n-    context.setForeground(config.getPixel(color));\n+    if (color != null)\n+      context.setForeground(config.getPixel(color));\n   }\n \n   public void setPaintMode()"}, {"sha": "d1202b837912d8b9995fa3cbada61bfa0d2298cb", "filename": "libjava/gnu/awt/xlib/XGraphicsConfiguration.java", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphicsConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphicsConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphicsConfiguration.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -522,17 +522,20 @@ int getPixel(Color color)\n     };\n      */\n     \n-    float[] normalizedComponents =\n-    {\n-      ((float)color.getRed ()) / 255F,\n-      ((float)color.getGreen ()) / 255F,\n-      ((float)color.getBlue ()) / 255F,\n-      1\n-    };\n     int[] unnormalizedComponents = { 0, 0, 0, 0xff };\n     ColorModel cm = getColorModel ();\n-    cm.getUnnormalizedComponents(normalizedComponents, 0,\n-\t\t\t\t unnormalizedComponents, 0);\n+    if (color != null)\n+    {\n+      float[] normalizedComponents =\n+      {\n+        ((float)color.getRed ()) / 255F,\n+        ((float)color.getGreen ()) / 255F,\n+        ((float)color.getBlue ()) / 255F,\n+        1\n+      };\n+      cm.getUnnormalizedComponents(normalizedComponents, 0,\n+           unnormalizedComponents, 0);\n+    }\n     return cm.getDataElement (unnormalizedComponents, 0);\n   }\n }"}, {"sha": "87acec3e34962ae9f8922d4dde32b510965328c0", "filename": "libjava/gnu/awt/xlib/XToolkit.java", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -445,13 +445,16 @@ public RobotPeer createRobot (GraphicsDevice screen) throws AWTException\n   }\n \n   public boolean nativeQueueEmpty() \n-  { \n-    return eventLoop.isIdle(); \n+  {\n+    // Tell EventQueue the native queue is empty, because XEventLoop\n+    // separately ensures that native events are posted to AWT.\n+    return true;\n   }\n \n   public void wakeNativeQueue() \n   {\n-    eventLoop.interrupt();\n+    // Not implemented, because the native queue is always awake.\n+    // (i.e. it's polled in a thread separate from the AWT dispatch thread)\n   }\n \n   /** Checks the native event queue for events.  If blocking, waits until an\n@@ -464,6 +467,18 @@ public void wakeNativeQueue()\n    */\n   public void iterateNativeQueue(java.awt.EventQueue locked, boolean block) \n   {\n-    eventLoop.postNextEvent(block);\n-  }\n+    // There is nothing to do here except block, because XEventLoop \n+    // iterates the queue in a dedicated thread.\n+    if (block)\n+    {\n+      try\n+      {\n+        queue.wait ();\n+      }\n+      catch (InterruptedException ie)\n+      {\n+        // InterruptedException intentionally ignored\n+      }\n+    }\n+  }; \n }"}, {"sha": "74985b9388e081d8417584d1ec93dce0da903d58", "filename": "libjava/gnu/gcj/xlib/Font.java", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FFont.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FFont.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FFont.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -34,7 +34,21 @@ public Font(Display display, String lfdNamePattern)\n     structure = struct;\n   }\n \n-  static native RawData loadFont(Display display, String lfdNamePattern);\n+  static RawData loadFont(Display display, String lfdNamePattern)\n+  {\n+    RawData returnValue = null;\n+    try\n+    {\n+      returnValue = loadFontImpl (display,lfdNamePattern);\n+    }\n+    catch (XException e)\n+    {\n+      // Throw a descriptive exception, including the font pattern\n+      throw new XException (\"Font not found: \" + lfdNamePattern);\n+    }\n+    return returnValue;\n+  }\n+  static native RawData loadFontImpl(Display display, String lfdNamePattern);\n \n   static native int getXIDFromStruct(RawData structure);\n "}, {"sha": "3ff3657c45c95da4e1ff7615ff3538cc59f30f19", "filename": "libjava/gnu/gcj/xlib/Window.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindow.java?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -73,6 +73,8 @@ protected native int createChildXID(Rectangle bounds,\n \n   public native void map();\n   public native void unmap();\n+  public native void toFront();\n+  public native void toBack();\n   \n   protected boolean owned = false;\n "}, {"sha": "cd5d87c7ab69e1412776ade63f94eeb2c7bd40b8", "filename": "libjava/gnu/gcj/xlib/natFont.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatFont.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatFont.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatFont.cc?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -16,7 +16,7 @@ details.  */\n #include <gnu/gcj/xlib/Font.h>\n #include <gnu/gcj/xlib/XException.h>\n \n-gnu::gcj::RawData* gnu::gcj::xlib::Font::loadFont(Display* display,\n+gnu::gcj::RawData* gnu::gcj::xlib::Font::loadFontImpl(Display* display,\n \t\t\t\t\t\t  jstring lfdNamePattern)\n {\n   ::Display* dpy = (::Display*) display->display;"}, {"sha": "62cd086ccb49d44937f71a07cba42ede8ff95bc5", "filename": "libjava/gnu/gcj/xlib/natWindow.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindow.cc?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -77,6 +77,20 @@ void gnu::gcj::xlib::Window::setAttributes(WindowAttributes* attributes)\n   // no fast fail\n }\n \n+void gnu::gcj::xlib::Window::toBack()\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Window window = xid;\n+  XLowerWindow(dpy, window);\n+}\n+\n+void gnu::gcj::xlib::Window::toFront()\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Window window = xid;\n+  XRaiseWindow(dpy, window);\n+}\n+\n void gnu::gcj::xlib::Window::map()\n {\n   ::Display* dpy = (::Display*) (display->display);"}, {"sha": "0bef563ed2d999262d1c87e6fee1bca0c6cd3f7f", "filename": "libjava/gnu/gcj/xlib/natXAnyEvent.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXAnyEvent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXAnyEvent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXAnyEvent.cc?ref=e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "patch": "@@ -69,14 +69,11 @@ jboolean gnu::gcj::xlib::XAnyEvent::loadNext(jboolean block)\n   int xfd = XConnectionNumber(dpy);\n   int pipefd = pipe[0];\n   int n = (xfd > pipefd ? xfd : pipefd) + 1;\n-  struct timeval timeout;\n-  timeout.tv_usec = 100000;  // 100ms timeout\n-  timeout.tv_sec = 0;\n   fd_set rfds;\n   FD_ZERO(&rfds);\n   FD_SET(xfd, &rfds);\n   FD_SET(pipefd, &rfds);  \n-  int sel = _Jv_select (n, &rfds, NULL, NULL, &timeout);\n+  int sel = _Jv_select (n, &rfds, NULL, NULL, NULL);\n   if (sel > 0)\n     {\n       if (FD_ISSET(xfd, &rfds))"}]}