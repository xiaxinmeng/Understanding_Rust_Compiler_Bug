{"sha": "8b219a762a962a9776603018672c9a6cdaf95a2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIyMTlhNzYyYTk2MmE5Nzc2NjAzMDE4NjcyYzlhNmNkYWY5NWEyZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-08-06T23:18:01Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-08-06T23:18:01Z"}, "message": "gcov.c: Tidy.\n\n\t* gcov.c: Tidy.\n\t(struct line_info, struct coverage): New structures.\n\t(gcov_file_name, gcov_file): Remove globals.\n\t(output_data): Take source file parameter. Fix memory leak. Break\n\tup into ...\n\t(init_line_info, output_line_info, make_gcov_file_name,\n\taccumulate_branch_counts): ... here.\n\t(calculate_branch_probs, function_summary): Adjust.\n\t(main): Adjust.\n\t(function_*): Remove global variables.\n\nFrom-SVN: r56080", "tree": {"sha": "89c319efbd67ad85a2d028e73c438ca01caeb9b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89c319efbd67ad85a2d028e73c438ca01caeb9b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b219a762a962a9776603018672c9a6cdaf95a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b219a762a962a9776603018672c9a6cdaf95a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b219a762a962a9776603018672c9a6cdaf95a2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b219a762a962a9776603018672c9a6cdaf95a2d/comments", "author": null, "committer": null, "parents": [{"sha": "317e98c03736c282263fb3544d7ed6095b842e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/317e98c03736c282263fb3544d7ed6095b842e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/317e98c03736c282263fb3544d7ed6095b842e24"}], "stats": {"total": 980, "additions": 482, "deletions": 498}, "files": [{"sha": "3cd7f5596a3c464decffb4bc7d7f81236d80a5f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b219a762a962a9776603018672c9a6cdaf95a2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b219a762a962a9776603018672c9a6cdaf95a2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b219a762a962a9776603018672c9a6cdaf95a2d", "patch": "@@ -1,3 +1,16 @@\n+2002-08-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcov.c: Tidy.\n+\t(struct line_info, struct coverage): New structures.\n+\t(gcov_file_name, gcov_file): Remove globals.\n+\t(output_data): Take source file parameter. Fix memory leak. Break\n+\tup into ...\n+\t(init_line_info, output_line_info, make_gcov_file_name,\n+\taccumulate_branch_counts): ... here.\n+\t(calculate_branch_probs, function_summary): Adjust.\n+\t(main): Adjust.\n+\t(function_*): Remove global variables.\n+\n 2002-08-06  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* dwarf2out.c: Remove unused macros."}, {"sha": "2c526088635db1cc24cfe1cd29360a046601c99d", "filename": "gcc/gcov.c", "status": "modified", "additions": 469, "deletions": 498, "changes": 967, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b219a762a962a9776603018672c9a6cdaf95a2d/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b219a762a962a9776603018672c9a6cdaf95a2d/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=8b219a762a962a9776603018672c9a6cdaf95a2d", "patch": "@@ -103,7 +103,8 @@ struct sourcefile *sources;\n /* One of these is dynamically created whenever we identify an arc in the\n    function.  */\n \n-struct adj_list {\n+struct adj_list\n+{\n   int source;\n   int target;\n   gcov_type arc_count;\n@@ -122,7 +123,8 @@ struct adj_list {\n /* Count the number of basic blocks, and create an array of these structures,\n    one for each bb in the function.  */\n \n-struct bb_info {\n+struct bb_info\n+{\n   struct adj_list *succ;\n   struct adj_list *pred;\n   gcov_type succ_count;\n@@ -149,13 +151,37 @@ struct arcdata\n \n /* Used to save the list of bb_graphs, one per function.  */\n \n-struct bb_info_list {\n+struct bb_info_list\n+{\n   /* Indexed by block number, holds the basic block graph for one function.  */\n   struct bb_info *bb_graph;\n   int num_blocks;\n   struct bb_info_list *next;\n };\n \n+/* Used to hold information about each line. */\n+struct line_info\n+{\n+  gcov_type count;\t      /* execution count */\n+  struct arcdata *branches;   /* list of branch probabilities for line. */\n+  unsigned exists : 1;\t      /* has code associated with it. */\n+};\n+  \n+struct coverage\n+{\n+  int lines;\n+  int lines_executed;\n+  \n+  int branches;\n+  int branches_executed;\n+  int branches_taken;\n+  \n+  int calls;\n+  int calls_executed;\n+  \n+  char *name;\n+};\n+\n /* Holds a list of function basic block graphs.  */\n \n static struct bb_info_list *bb_graph_list = 0;\n@@ -187,11 +213,6 @@ static char *bb_data;\n \n static long bb_data_size;\n \n-/* Name and file pointer of the output file.  */\n-\n-static char *gcov_file_name;\n-static FILE *gcov_file;\n-\n /* Name of the file mentioned on the command line.  */\n \n static char *input_file_name = 0;\n@@ -235,18 +256,27 @@ static void process_args PARAMS ((int, char **));\n static void open_files PARAMS ((void));\n static void read_files PARAMS ((void));\n static void scan_for_source_files PARAMS ((void));\n-static void output_data PARAMS ((void));\n+static void output_data PARAMS ((struct sourcefile *));\n static void print_usage PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void print_version PARAMS ((void)) ATTRIBUTE_NORETURN;\n static void init_arc PARAMS ((struct adj_list *, int, int, struct bb_info *));\n static struct adj_list *reverse_arcs PARAMS ((struct adj_list *));\n static gcov_type *read_profile PARAMS ((char *, long, int));\n static void create_program_flow_graph PARAMS ((struct bb_info_list *));\n static void solve_program_flow_graph PARAMS ((struct bb_info_list *));\n-static void calculate_branch_probs PARAMS ((struct bb_info_list *, int,\n-\t\t\t\t\t    struct arcdata **, int));\n-static void function_summary PARAMS ((void));\n-static const char *format_hwint PARAMS ((HOST_WIDEST_INT, HOST_WIDEST_INT, int));\n+static void accumulate_branch_counts PARAMS ((struct coverage *,\n+\t\t\t\t\t      struct arcdata *));\n+static void calculate_branch_probs PARAMS ((struct bb_info *,\n+\t\t\t\t\t    struct line_info *,\n+\t\t\t\t\t    struct coverage *));\n+static void function_summary PARAMS ((struct coverage *, const char *));\n+static void init_line_info PARAMS ((struct line_info *,\n+\t\t\t\t    struct coverage *, long));\n+static void output_line_info PARAMS ((FILE *, const struct line_info *,\n+\t\t\t\t      const struct coverage *, long));\n+static char *make_gcov_file_name PARAMS ((char *));\n+static const char *format_hwint PARAMS ((HOST_WIDEST_INT, HOST_WIDEST_INT,\n+\t\t\t\t\t int));\n \n extern int main PARAMS ((int, char **));\n \n@@ -255,6 +285,8 @@ main (argc, argv)\n      int argc;\n      char **argv;\n {\n+  struct sourcefile *s_ptr;\n+  \n   gcc_init_libintl ();\n \n   process_args (argc, argv);\n@@ -265,7 +297,8 @@ main (argc, argv)\n \n   scan_for_source_files ();\n \n-  output_data ();\n+  for (s_ptr = sources; s_ptr; s_ptr = s_ptr->next)\n+    output_data (s_ptr);\n \n   return 0;\n }\n@@ -530,7 +563,6 @@ init_arc (arcptr, source, target, bb_graph)\n   bb_graph[target].pred_count++;\n }\n \n-\n /* Reverse the arcs on an arc list.  */\n \n static struct adj_list *\n@@ -1037,77 +1069,61 @@ scan_for_source_files ()\n     }\n }\n \f\n-/* For calculating coverage at the function level.  */\n \n-static int function_source_lines;\n-static int function_source_lines_executed;\n-static int function_branches;\n-static int function_branches_executed;\n-static int function_branches_taken;\n-static int function_calls;\n-static int function_calls_executed;\n-static char *function_name;\n+/* Increment totals in FUNCTION according to arc A_PTR.  */\n+\n+static void\n+accumulate_branch_counts (function, a_ptr)\n+     struct coverage *function;\n+     struct arcdata *a_ptr;\n+{\n+  if (a_ptr->call_insn)\n+    {\n+      function->calls++;\n+      if (a_ptr->total)\n+\tfunction->calls_executed++;\n+    }\n+  else\n+    {\n+      function->branches++;\n+      if (a_ptr->total)\n+\tfunction->branches_executed++;\n+      if (a_ptr->hits)\n+\tfunction->branches_taken++;\n+    }\n+}\n \n /* Calculate the branch taken probabilities for all arcs branches at the\n    end of this block.  */\n \n static void\n-calculate_branch_probs (current_graph, block_num, branch_probs, last_line_num)\n-     struct bb_info_list *current_graph;\n-     int block_num;\n-     struct arcdata **branch_probs;\n-     int last_line_num;\n+calculate_branch_probs (block_ptr, line_info, function)\n+     struct bb_info *block_ptr;\n+     struct line_info *line_info;\n+     struct coverage *function;\n {\n   gcov_type total;\n   struct adj_list *arcptr;\n-  struct arcdata *end_ptr, *a_ptr;\n \n-  total = current_graph->bb_graph[block_num].exec_count;\n-  for (arcptr = current_graph->bb_graph[block_num].succ; arcptr;\n-       arcptr = arcptr->succ_next)\n+  total = block_ptr->exec_count;\n+  for (arcptr = block_ptr->succ; arcptr; arcptr = arcptr->succ_next)\n     {\n+      struct arcdata *a_ptr;\n+      \n       /* Ignore fall through arcs as they aren't really branches.  */\n-\n       if (arcptr->fall_through)\n \tcontinue;\n \n       a_ptr = (struct arcdata *) xmalloc (sizeof (struct arcdata));\n       a_ptr->total = total;\n-      if (total == 0)\n-\ta_ptr->hits = 0;\n-      else\n-\ta_ptr->hits = arcptr->arc_count;\n+      a_ptr->hits = total ? arcptr->arc_count : 0;\n       a_ptr->call_insn = arcptr->fake;\n \n-      if (output_function_summary)\n-\t{\n-\t  if (a_ptr->call_insn)\n-\t    {\n-\t      function_calls++;\n-\t      if (a_ptr->total != 0)\n-\t\tfunction_calls_executed++;\n-\t    }\n-\t  else\n-\t    {\n-\t      function_branches++;\n-\t      if (a_ptr->total != 0)\n-\t\tfunction_branches_executed++;\n-\t      if (a_ptr->hits > 0)\n-\t\tfunction_branches_taken++;\n-\t    }\n-\t}\n-\n-      /* Append the new branch to the end of the list.  */\n-      a_ptr->next = 0;\n-      if (! branch_probs[last_line_num])\n-\tbranch_probs[last_line_num] = a_ptr;\n-      else\n-\t{\n-\t  end_ptr = branch_probs[last_line_num];\n-\t  while (end_ptr->next != 0)\n-\t    end_ptr = end_ptr->next;\n-\t  end_ptr->next = a_ptr;\n-\t}\n+      if (function)\n+\taccumulate_branch_counts (function, a_ptr);\n+      /* Prepend the new branch to the list.  */\n+      a_ptr->next = line_info->branches;\n+      line_info->branches = a_ptr;\n     }\n }\n \n@@ -1162,502 +1178,457 @@ format_hwint (top, bottom, dp)\n /* Output summary info for a function.  */\n \n static void\n-function_summary ()\n+function_summary (function, title)\n+     struct coverage *function;\n+     const char *title;\n {\n-  if (function_source_lines)\n-    fnotice (stdout, \"%s of %d source lines executed in function %s\\n\",\n-\t     format_hwint (function_source_lines_executed,\n-\t\t\t   function_source_lines, 2),\n-\t     function_source_lines, function_name);\n+  if (function->lines)\n+    fnotice (stdout, \"%s of %d lines executed in %s %s\\n\",\n+\t     format_hwint (function->lines_executed,\n+\t\t\t   function->lines, 2),\n+\t     function->lines, title, function->name);\n   else\n-    fnotice (stdout, \"No executable source lines in function %s\\n\",\n-\t     function_name);\n+    fnotice (stdout, \"No executable lines in %s %s\\n\",\n+\t     title, function->name);\n \n   if (output_branch_probs)\n     {\n-      if (function_branches)\n+      if (function->branches)\n \t{\n-\t  fnotice (stdout, \"%s of %d branches executed in function %s\\n\",\n-\t\t   format_hwint (function_branches_executed,\n-\t\t\t\t function_branches, 2),\n-\t\t   function_branches, function_name);\n+\t  fnotice (stdout, \"%s of %d branches executed in %s %s\\n\",\n+\t\t   format_hwint (function->branches_executed,\n+\t\t\t\t function->branches, 2),\n+\t\t   function->branches, title, function->name);\n \t  fnotice (stdout,\n-\t\t\"%s of %d branches taken at least once in function %s\\n\",\n-\t\t   format_hwint (function_branches_taken,\n-\t\t\t\t function_branches, 2),\n-\t\t   function_branches, function_name);\n+\t\t\"%s of %d branches taken at least once in %s %s\\n\",\n+\t\t   format_hwint (function->branches_taken,\n+\t\t\t\t function->branches, 2),\n+\t\t   function->branches, title, function->name);\n \t}\n       else\n-\tfnotice (stdout, \"No branches in function %s\\n\", function_name);\n-      if (function_calls)\n-\tfnotice (stdout, \"%s of %d calls executed in function %s\\n\",\n-\t\t format_hwint (function_calls_executed,\n-\t\t\t       function_calls, 2),\n-\t\t function_calls, function_name);\n+\tfnotice (stdout, \"No branches in %s %s\\n\", title, function->name);\n+      if (function->calls)\n+\tfnotice (stdout, \"%s of %d calls executed in %s %s\\n\",\n+\t\t format_hwint (function->calls_executed,\n+\t\t\t       function->calls, 2),\n+\t\t function->calls, title, function->name);\n       else\n-\tfnotice (stdout, \"No calls in function %s\\n\", function_name);\n+\tfnotice (stdout, \"No calls in %s %s\\n\", title, function->name);\n+    }\n+}\n+\n+/* Generate an output file name. LONG_OUTPUT_NAMES and PRESERVE_PATHS\n+   affect name generation. With preserve_paths we create a filename\n+   from all path components of the source file, replacing '/' with\n+   '#', without it we simply take the basename component. With\n+   long_output_names we prepend the processed name of the input file\n+   to each output name (except when the current source file is the\n+   input file, so you don't get a double concatenation). The two\n+   components are separated by '##'. Also '.' filename components are\n+   removed and '..'  components are renamed to '^'. */\n+\n+static char *\n+make_gcov_file_name (src_name)\n+     char *src_name;\n+{\n+  char *cptr;\n+  char *name = xmalloc (strlen (src_name) + strlen (input_file_name) + 10);\n+  \n+  name[0] = 0;\n+  if (output_long_names && strcmp (src_name, input_file_name))\n+    {\n+      /* Generate the input filename part.  */\n+      cptr = preserve_paths ? NULL : strrchr (input_file_name, '/');\n+      cptr = cptr ? cptr + 1 : input_file_name;\n+      strcat (name, cptr);\n+      strcat (name, \"##\");\n+    }\n+   \n+  /* Generate the source filename part. */\n+  cptr = preserve_paths ? NULL : strrchr (src_name, '/');\n+  cptr = cptr ? cptr + 1 : src_name;\n+  strcat (name, cptr);\n+  \n+  if (preserve_paths)\n+    {\n+      /* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */\n+      char *prev;\n+      \n+      for (cptr = name; (cptr = strchr ((prev = cptr), '/'));)\n+ \t{\n+ \t  unsigned shift = 0;\n+ \t  \n+ \t  if (prev + 1 == cptr && prev[0] == '.')\n+ \t    {\n+ \t      /* Remove '.' */\n+ \t      shift = 2;\n+ \t    }\n+ \t  else if (prev + 2 == cptr && prev[0] == '.' && prev[1] == '.')\n+ \t    {\n+ \t      /* Convert '..' */\n+ \t      shift = 1;\n+ \t      prev[1] = '^';\n+ \t    }\n+ \t  else\n+ \t    *cptr++ = '#';\n+ \t  if (shift)\n+ \t    {\n+ \t      cptr = prev;\n+ \t      do\n+ \t\tprev[0] = prev[shift];\n+\t      while (*prev++);\n+ \t    }\n+ \t}\n     }\n+  \n+  /* Don't strip off the ending for compatibility with tcov, since\n+     this results in confusion if there is more than one file with the\n+     same basename, e.g. tmp.c and tmp.h.  */\n+  strcat (name, \".gcov\");\n+  return name;\n }\n \n-/* Calculate line execution counts, and output the data to a .tcov file.  */\n+/* Scan through the bb_data, and when the file name matches the\n+   source file name, then for each following line number, increment\n+   the line number execution count indicated by the execution count of\n+   the appropriate basic block.  */\n \n static void\n-output_data ()\n+init_line_info (line_info, total, maxlineno)\n+     struct line_info *line_info;\n+     struct coverage *total;\n+     long maxlineno;\n {\n-  /* When scanning data, this is true only if the data applies to the\n-     current source file.  */\n-  int this_file;\n-  /* An array indexed by line number which indicates how many times that line\n-     was executed.  */\n-  gcov_type *line_counts;\n-  /* An array indexed by line number which indicates whether the line was\n-     present in the bb file (i.e. whether it had code associate with it).\n-     Lines never executed are those which both exist, and have zero execution\n-     counts.  */\n-  char *line_exists;\n-  /* An array indexed by line number, which contains a list of branch\n-     probabilities, one for each branch on that line.  */\n-  struct arcdata **branch_probs = NULL;\n-  struct sourcefile *s_ptr;\n-  char *source_file_name;\n-  FILE *source_file;\n-  struct bb_info_list *current_graph;\n+  long block_num = 0;\t\t/* current block number */\n+  struct bb_info *block_ptr = NULL;\t/* current block ptr */\n+  struct coverage function;\n+  struct coverage *func_ptr = NULL;\n+  struct bb_info_list *current_graph = NULL; /* Graph for current function. */\n+  int is_this_file = 0;\t/* We're scanning a block from the desired file. */\n+  char *ptr = bb_data;\n   long count;\n-  char *cptr;\n-  long block_num;\n   long line_num;\n-  long last_line_num = 0;\n-  int i;\n-  struct arcdata *a_ptr;\n-  /* Buffer used for reading in lines from the source file.  */\n-  char string[STRING_SIZE];\n-  /* For calculating coverage at the file level.  */\n-  int total_source_lines;\n-  int total_source_lines_executed;\n-  int total_branches;\n-  int total_branches_executed;\n-  int total_branches_taken;\n-  int total_calls;\n-  int total_calls_executed;\n-\n-  /* Now, for each source file, allocate an array big enough to hold a count\n-     for each line.  Scan through the bb_data, and when the file name matches\n-     the current file name, then for each following line number, increment\n-     the line number execution count indicated by the execution count of\n-     the appropriate basic block.  */\n-\n-  for (s_ptr = sources; s_ptr; s_ptr = s_ptr->next)\n+  struct line_info *line_ptr; /* line info ptr. */\n+   \n+  memset (&function, 0, sizeof (function));\n+  if (output_function_summary)\n+    func_ptr = &function;\n+  \n+  for (count = 0; count < bb_data_size; count++)\n     {\n-      source_file_name = s_ptr->name;\n-\n-      line_counts = (gcov_type *) xcalloc (sizeof (gcov_type), s_ptr->maxlineno);\n-      line_exists = xcalloc (1, s_ptr->maxlineno);\n-      if (output_branch_probs)\n-\tbranch_probs = (struct arcdata **)\n-\t  xcalloc (sizeof (struct arcdata *), s_ptr->maxlineno);\n-\n-      /* There will be a zero at the beginning of the bb info, before the\n-\t first list of line numbers, so must initialize block_num to 0.  */\n-      block_num = 0;\n-      this_file = 0;\n-      current_graph = 0;\n-      {\n-\t/* Pointer into the bb_data, incremented while scanning the data.  */\n-\tchar *ptr = bb_data;\n-\tfor (count = 0; count < bb_data_size; count++)\n-\t  {\n-\t    long delim;\n-\n-\t    __fetch_long (&line_num, ptr, 4);\n-\t    ptr += 4;\n-\t    if (line_num == -1)\n-\t      {\n-\t\t/* Marks the beginning of a file name.  Check to see whether\n-\t\t   this is the filename we are currently collecting data for.  */\n-\n-\t\tif (strcmp (s_ptr->name, ptr))\n-\t\t  this_file = 0;\n-\t\telse\n-\t\t  this_file = 1;\n-\n-\t\t/* Scan past the file name.  */\n-\t\tdo {\n-\t\t  count++;\n-\t\t  __fetch_long (&delim, ptr, 4);\n-\t\t  ptr += 4;\n-\t\t} while (delim != line_num);\n-\t      }\n-\t    else if (line_num == -2)\n-\t      {\n-\t\t/* Marks the start of a new function.  Advance to the next\n-\t\t   program flow graph.  */\n-\n-\t\tif (! current_graph)\n-\t\t  current_graph = bb_graph_list;\n-\t\telse\n-\t\t  {\n-\t\t    if (block_num == current_graph->num_blocks - 1)\n-\t\t      /* Last block falls through to exit.  */\n-\t\t      ;\n-\t\t    else if (block_num == current_graph->num_blocks - 2)\n-\t\t      {\n-\t\t\tif (output_branch_probs && this_file)\n-\t\t\t  calculate_branch_probs (current_graph, block_num,\n-\t\t\t\t\t\t  branch_probs, last_line_num);\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tfnotice (stderr,\n-\t\t\t\t \"didn't use all bb entries of graph, function %s\\n\",\n-\t\t\t\t function_name);\n-\t\t\tfnotice (stderr, \"block_num = %ld, num_blocks = %d\\n\",\n-\t\t\t\t block_num, current_graph->num_blocks);\n-\t\t      }\n-\n-\t\t    current_graph = current_graph->next;\n-\t\t    block_num = 0;\n-\n-\t\t    if (output_function_summary && this_file)\n-\t\t      function_summary ();\n-\t\t  }\n-\n-\t\tif (output_function_summary)\n-\t\t  {\n-\t\t    function_source_lines = 0;\n-\t\t    function_source_lines_executed = 0;\n-\t\t    function_branches = 0;\n-\t\t    function_branches_executed = 0;\n-\t\t    function_branches_taken = 0;\n-\t\t    function_calls = 0;\n-\t\t    function_calls_executed = 0;\n-\t\t  }\n-\n-\t\t/* Save the function name for later use.  */\n-\t\tfunction_name = ptr;\n-\n-\t\t/* Scan past the file name.  */\n-\t\tdo {\n-\t\t  count++;\n-\t\t  __fetch_long (&delim, ptr, 4);\n-\t\t  ptr += 4;\n-\t\t} while (delim != line_num);\n-\t      }\n-\t    else if (line_num == 0)\n-\t      {\n-\t\t/* Marks the end of a block.  */\n-\n-\t\tif (block_num >= current_graph->num_blocks)\n-\t\t  {\n-\t\t    fnotice (stderr, \"ERROR: too many basic blocks in .bb file %s\\n\",\n-\t\t\t     function_name);\n-\t\t    abort ();\n-\t\t  }\n-\n-\t\tif (output_branch_probs && this_file)\n-\t\t  calculate_branch_probs (current_graph, block_num,\n-\t\t\t\t\t  branch_probs, last_line_num);\n-\n-\t\tblock_num++;\n-\t      }\n-\t    else if (this_file)\n-\t      {\n-\t\tif (output_function_summary)\n-\t\t  {\n-\t\t    if (line_exists[line_num] == 0)\n-\t\t      function_source_lines++;\n-\t\t    if (line_counts[line_num] == 0\n-\t\t\t&& current_graph->bb_graph[block_num].exec_count != 0)\n-\t\t      function_source_lines_executed++;\n-\t\t  }\n-\n-\t\t/* Accumulate execution data for this line number.  */\n-\n-\t\tline_counts[line_num]\n-\t\t  += current_graph->bb_graph[block_num].exec_count;\n-\t\tline_exists[line_num] = 1;\n-\t\tlast_line_num = line_num;\n-\t      }\n-\t  }\n-      }\n-\n-      if (output_function_summary && this_file)\n-\tfunction_summary ();\n-\n-      /* Calculate summary test coverage statistics.  */\n-\n-      total_source_lines = 0;\n-      total_source_lines_executed = 0;\n-      total_branches = 0;\n-      total_branches_executed = 0;\n-      total_branches_taken = 0;\n-      total_calls = 0;\n-      total_calls_executed = 0;\n-\n-      for (count = 1; count < s_ptr->maxlineno; count++)\n+      __fetch_long (&line_num, ptr, 4);\n+      ptr += 4;\n+      if (line_num < 0)\n \t{\n-\t  if (line_exists[count])\n+\t  long delim;\n+\t  \n+\t  if (line_num == -1)\n \t    {\n-\t      total_source_lines++;\n-\t      if (line_counts[count])\n-\t\ttotal_source_lines_executed++;\n+\t      /* Marks the beginning of a file name.  Check to see\n+\t     \t whether this is the filename we are currently\n+\t     \t collecting data for.  */\n+\t      is_this_file = !strcmp (total->name, ptr);\n \t    }\n-\t  if (output_branch_probs)\n+\t  else if (line_num == -2)\n \t    {\n-\t      for (a_ptr = branch_probs[count]; a_ptr; a_ptr = a_ptr->next)\n+\t      /* Marks the start of a new function.  Advance to the\n+\t     \t next program flow graph.  */\n+\t      if (!current_graph)\n+\t\tcurrent_graph = bb_graph_list;\n+\t      else\n \t\t{\n-\t\t  if (a_ptr->call_insn)\n+\t\t  if (block_num == current_graph->num_blocks - 1)\n+\t\t    /* Last block falls through to exit.  */\n+\t\t    ;\n+\t\t  else if (block_num == current_graph->num_blocks - 2)\n \t\t    {\n-\t\t      total_calls++;\n-\t\t      if (a_ptr->total != 0)\n-\t\t\ttotal_calls_executed++;\n+\t\t      if (output_branch_probs && is_this_file)\n+\t\t\tcalculate_branch_probs (block_ptr, line_ptr, func_ptr);\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      total_branches++;\n-\t\t      if (a_ptr->total != 0)\n-\t\t\ttotal_branches_executed++;\n-\t\t      if (a_ptr->hits > 0)\n-\t\t\ttotal_branches_taken++;\n+\t\t      fnotice (stderr,\n+\t\t\t       \"didn't use all bb entries of graph, function %s\\n\",\n+\t\t\t       function.name);\n+\t\t      fnotice (stderr, \"block_num = %ld, num_blocks = %d\\n\",\n+\t\t\t       block_num, current_graph->num_blocks);\n \t\t    }\n+\t\t  if (func_ptr && is_this_file)\n+\t\t    function_summary (func_ptr, \"function\");\n+\t\t  current_graph = current_graph->next;\n \t\t}\n+\t      block_num = 0;\n+\t      block_ptr = current_graph->bb_graph;\n+\t      memset (&function, 0, sizeof (function));\n+\t      function.name = ptr;\n+\t    }\n+\t  else\n+\t    {\n+\t      fnotice (stderr, \"ERROR: unexpected line number %ld\\n\", line_num);\n+\t      abort ();\n \t    }\n-\t}\n-\n-      if (total_source_lines)\n-\tfnotice (stdout,\n-\t\t \"%s of %d source lines executed in file %s\\n\",\n-\t\t format_hwint (total_source_lines_executed,\n-\t\t\t       total_source_lines, 2),\n-\t\t total_source_lines, source_file_name);\n-      else\n-\tfnotice (stdout, \"No executable source lines in file %s\\n\",\n-\t\t source_file_name);\n \n-      if (output_branch_probs)\n+\t  /* Scan past the string.  */\n+\t  for (delim = 0; delim != line_num; count++)\n+\t    {\n+\t      __fetch_long (&delim, ptr, 4);\n+\t      ptr += 4;\n+\t    }\n+\t}\n+      else if (!line_num)\n \t{\n-\t  if (total_branches)\n+\t  /* Marks the end of a block.  */\n+\t  if (block_num >= current_graph->num_blocks)\n \t    {\n-\t      fnotice (stdout, \"%s of %d branches executed in file %s\\n\",\n-\t\t       format_hwint (total_branches_executed,\n-\t\t\t\t     total_branches, 2),\n-\t\t       total_branches, source_file_name);\n-\t      fnotice (stdout,\n-\t\t       \"%s of %d branches taken at least once in file %s\\n\",\n-\t\t       format_hwint (total_branches_taken,\n-\t\t\t\t     total_branches, 2),\n-\t\t       total_branches, source_file_name);\n+\t      fnotice (stderr, \"ERROR: too many basic blocks in function %s\\n\",\n+\t\t       function.name);\n+\t      abort ();\n \t    }\n-\t  else\n-\t    fnotice (stdout, \"No branches in file %s\\n\", source_file_name);\n-\t  if (total_calls)\n-\t    fnotice (stdout, \"%s of %d calls executed in file %s\\n\",\n-\t\t     format_hwint (total_calls_executed, total_calls, 2),\n-\t\t     total_calls, source_file_name);\n-\t  else\n-\t    fnotice (stdout, \"No calls in file %s\\n\", source_file_name);\n+\t  \n+\t  if (output_branch_probs && is_this_file)\n+\t    calculate_branch_probs (block_ptr, line_ptr, func_ptr);\n+\t  \n+\t  block_num++;\n+\t  block_ptr++;\n \t}\n-\n-      if (output_gcov_file)\n+      else if (is_this_file)\n \t{\n-\t  /* Now the statistics are ready.  Read in the source file one line\n-\t     at a time, and output that line to the gcov file preceded by\n-\t     its execution count if non zero.  */\n-\t  char const *retval;\n-\n-\t  /* Generate an output file name. LONG_OUTPUT_NAMES and\n-\t     PRESERVE_PATHS affect name generation. With\n-\t     preserve_paths we create a filename from all path\n-\t     components of the source file, replacing '/' with '#',\n-\t     without it we simply take the basename component. With\n-\t     long_output_names we prepend the processed name of the\n-\t     input file to each output name (except when the current\n-\t     source file is the input file, so you don't get a double\n-\t     concatenation). The two components are separated by\n-\t     '##'. Also '.' filename components are removed and '..'\n-\t     components are renamed to '^'. */\n-\t  gcov_file_name = xmalloc (strlen (source_file_name)\n-\t\t\t\t    + strlen (input_file_name) + 10);\n-\t  gcov_file_name[0] = 0;\n-\t  if (output_long_names && strcmp (source_file_name, input_file_name))\n+\t  if (line_num >= maxlineno)\n \t    {\n-\t      /* Generate the input filename part.  */\n-\t      cptr = preserve_paths ? NULL : strrchr (input_file_name, '/');\n-\t      cptr = cptr ? cptr + 1 : input_file_name;\n-\t      strcat (gcov_file_name, cptr);\n-\t      strcat (gcov_file_name, \"##\");\n+\t      fnotice (stderr, \"ERROR: out of range line number in function %s\\n\",\n+\t\t       function.name);\n+\t      abort ();\n \t    }\n-\t  /* Generate the source filename part. */\n-\t  cptr = preserve_paths ? NULL : strrchr (source_file_name, '/');\n-\t  cptr = cptr ? cptr + 1 : source_file_name;\n-\t  strcat (gcov_file_name, cptr);\n \n-\t  if (preserve_paths)\n+\t  line_ptr = &line_info[line_num];\n+\t  if (func_ptr)\n \t    {\n-\t      /* Convert '/' to '#', remove '/./', convert '/../' to\n-\t\t '/^/' */\n-\t      char *prev;\n-\t      \n-\t      for (cptr = gcov_file_name;\n-\t\t   (cptr = strchr ((prev = cptr), '/'));)\n-\t\t{\n-\t\t  unsigned shift = 0;\n-\t\t  \n-\t\t  if (prev + 1 == cptr && prev[0] == '.')\n-\t\t    {\n-\t\t      /* Remove '.' */\n-\t\t      shift = 2;\n-\t\t    }\n-\t\t  else if (prev + 2 == cptr\n-\t\t\t   && prev[0] == '.' && prev[1] == '.')\n-\t\t    {\n-\t\t      /* Convert '..' */\n-\t\t      shift = 1;\n-\t\t      prev[1] = '^';\n-\t\t    }\n-\t\t  else\n-\t\t    *cptr++ = '#';\n-\t\t  if (shift)\n-\t\t    {\n-\t\t      cptr = prev;\n-\t\t      do\n-\t\t\tprev[0] = prev[shift];\n-\t\t      while (*prev++);\n-\t\t    }\n-\t\t}\n+\t      if (!line_ptr->exists)\n+\t\tfunc_ptr->lines++;\n+\t      if (!line_ptr->count && block_ptr->exec_count)\n+\t\tfunc_ptr->lines_executed++;\n \t    }\n \t  \n-\t  /* Don't strip off the ending for compatibility with tcov, since\n-\t     this results in confusion if there is more than one file with\n-\t     the same basename, e.g. tmp.c and tmp.h.  */\n-\t  strcat (gcov_file_name, \".gcov\");\n+\t  /* Accumulate execution data for this line number.  */\n+\t  line_ptr->count += block_ptr->exec_count;\n+\t  line_ptr->exists = 1;\n+\t}\n+    }\n+  \n+  if (func_ptr && is_this_file)\n+    function_summary (func_ptr, \"function\");\n+  \n+  /* Calculate summary test coverage statistics.  */\n+  for (line_num = 1, line_ptr = &line_info[line_num];\n+       line_num < maxlineno; line_num++, line_ptr++)\n+    {\n+      struct arcdata *a_ptr, *prev, *next;\n+      \n+      if (line_ptr->exists)\n+\t{\n+\t  total->lines++;\n+\t  if (line_ptr->count)\n+\t    total->lines_executed++;\n+\t}\n \n-\t  gcov_file = fopen (gcov_file_name, \"w\");\n+      /* Total and reverse the branch information. */\n+      for (a_ptr = line_ptr->branches, prev = NULL; a_ptr; a_ptr = next)\n+\t{\n+\t  next = a_ptr->next;\n+\t  a_ptr->next = prev;\n+\t  prev = a_ptr;\n \n-\t  if (gcov_file == NULL)\n-\t    {\n-\t      fnotice (stderr, \"Could not open output file %s.\\n\",\n-\t\t       gcov_file_name);\n-\t      free (line_counts);\n-\t      free (line_exists);\n-\t      continue;\n-\t    }\n+\t  accumulate_branch_counts (total, a_ptr);\n+\t}\n+      line_ptr->branches = prev;\n+    }\n+}\n \n-\t  fnotice (stdout, \"Creating %s.\\n\", gcov_file_name);\n+/* Read in the source file one line at a time, and output that line to\n+   the gcov file preceded by its execution count and other\n+   information.  */\n \n-\t  fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, source_file_name);\n-\t  fprintf (gcov_file, \"%9s:%5d:Object:%s\\n\", \"-\", 0, bb_file_name);\n-\t  \n-\t  source_file = fopen (source_file_name, \"r\");\n-\t  if (source_file == NULL)\n-\t    fnotice (stderr, \"Could not open source file %s.\\n\",\n-\t\t     source_file_name);\n-\t  else\n-\t    {\n-\t      struct stat status;\n+static void\n+output_line_info (gcov_file, line_info, total, maxlineno)\n+     FILE *gcov_file;\n+     const struct line_info *line_info;\n+     const struct coverage *total;\n+     long maxlineno;\n+{\n+  FILE *source_file;\n+  long line_num;                    /* current line number */\n+  const struct line_info *line_ptr; /* current line info ptr. */\n+  char string[STRING_SIZE];         /* line buffer. */\n+  char const *retval = \"\";\t    /* status of source file reading. */\n \n-\t      if (!fstat (fileno (source_file), &status)\n-\t\t  && status.st_mtime > bb_file_time)\n+  fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, total->name);\n+  fprintf (gcov_file, \"%9s:%5d:Object:%s\\n\", \"-\", 0, bb_file_name);\n+  \n+  source_file = fopen (total->name, \"r\");\n+  if (!source_file)\n+    {\n+      fnotice (stderr, \"Could not open source file %s.\\n\", total->name);\n+      retval = NULL;\n+    }\n+  else\n+    {\n+      struct stat status;\n+      \n+      if (!fstat (fileno (source_file), &status)\n+\t  && status.st_mtime > bb_file_time)\n+\t{\n+\t  fnotice (stderr, \"Warning: source file %s is newer than %s\\n\",\n+\t\t   total->name, bb_file_name);\n+\t  fprintf (gcov_file, \"%9s:%5d:Source is newer than compiler output\\n\",\n+\t\t   \"-\", 0);\n+\t}\n+    }\n+\n+  for (line_num = 1, line_ptr = &line_info[line_num];\n+       line_num < maxlineno; line_num++, line_ptr++)\n+    {\n+      /* For lines which don't exist in the .bb file, print '-' before\n+ \t the source line.  For lines which exist but were never\n+ \t executed, print '#####' before the source line.  Otherwise,\n+ \t print the execution count before the source line.  There are\n+ \t 16 spaces of indentation added before the source line so that\n+ \t tabs won't be messed up.  */\n+      fprintf (gcov_file, \"%9s:%5ld:\",\n+\t       !line_ptr->exists ? \"-\"\n+\t       : !line_ptr->count ? \"#####\"\n+\t       : format_hwint (line_ptr->count, 0, -1), line_num);\n+      \n+      if (retval)\n+\t{\n+\t  /* Copy source line.  */\n+\t  do\n+\t    {\n+\t      retval = fgets (string, STRING_SIZE, source_file);\n+\t      if (!retval)\n \t\t{\n-\t\t  fnotice (stderr, \"Warning: source file %s is newer than %s\\n\",\n-\t\t\t   source_file_name, bb_file_name);\n-\t\t  fprintf (gcov_file, \"%9s:%5d:Source is newer than compiler output\\n\", \"-\", 0);\n+\t\t  fnotice (stderr,\n+\t\t\t   \"Unexpected EOF while reading source file %s.\\n\",\n+\t\t\t   total->name);\n+\t\t  break;\n \t\t}\n+\t      fputs (retval, gcov_file);\n \t    }\n+\t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n');\n+\t}\n+      if (!retval)\n+\tfputs (\"??\\n\", gcov_file);\n+      \n+      if (output_branch_probs)\n+\t{\n+\t  int i;\n+\t  struct arcdata *a_ptr;\n \t  \n-\t  for (retval = source_file ? \"\" : NULL, count = 1;\n-\t       count < s_ptr->maxlineno; count++)\n+\t  for (i = 0, a_ptr = line_ptr->branches; a_ptr;\n+\t       a_ptr = a_ptr->next, i++)\n \t    {\n-\t      /* For lines which don't exist in the .bb file, print\n-\t\t '-' before the source line.  For lines which exist\n-\t\t but were never executed, print '#####' before the source\n-\t\t line.  Otherwise, print the execution count before\n-\t\t the source line.  */\n-\t      \n-\t      /* There are 16 spaces of indentation added before the source\n-\t\t line so that tabs won't be messed up.  */\n-\t      fprintf (gcov_file, \"%9s:%5ld:\",\n-\t\t       !line_exists[count] ? \"-\"\n-\t\t       : !line_counts[count] ? \"#####\"\n-\t\t       : format_hwint (line_counts[count], 0, -1), count);\n-\t      \n-\t      if (retval)\n+\t      if (a_ptr->call_insn)\n \t\t{\n-\t\t  do\n-\t\t    {\n-\t\t      retval = fgets (string, STRING_SIZE, source_file);\n-\t\t      if (!retval)\n-\t\t\t{\n-\t\t\t  fnotice (stderr,\n-\t\t\t\t   \"Unexpected EOF while reading source file %s.\\n\",\n-\t\t\t\t   source_file_name);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      fputs (retval, gcov_file);\n-\t\t    }\n-\t\t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n');\n+\t\t  if (a_ptr->total == 0)\n+\t\t    fnotice (gcov_file, \"call   %2d never executed\\n\", i);\n+\t\t  else\n+\t\t    fnotice\n+\t\t      (gcov_file, \"call   %2d returns %s\\n\", i,\n+\t\t       format_hwint (a_ptr->total - a_ptr->hits,\n+\t\t\t\t     a_ptr->total,\n+\t\t\t\t     -output_branch_counts));\n \t\t}\n-\t      if (!retval)\n-\t\tfputs (\"??\\n\", gcov_file);\n-\t      \n-\t      if (output_branch_probs)\n+\t      else\n \t\t{\n-\t\t  for (i = 0, a_ptr = branch_probs[count]; a_ptr;\n-\t\t       a_ptr = a_ptr->next, i++)\n-\t\t    {\n-\t\t      if (a_ptr->call_insn)\n-\t\t\t{\n-\t\t\t  if (a_ptr->total == 0)\n-\t\t\t    fnotice (gcov_file, \"call   %2d never executed\\n\", i);\n-\t\t\t  else\n-\t\t\t    fnotice\n-\t\t\t      (gcov_file, \"call   %2d returns %s\\n\", i,\n-\t\t\t       format_hwint (a_ptr->total - a_ptr->hits,\n-\t\t\t\t\t     a_ptr->total,\n-\t\t\t\t\t     -output_branch_counts));\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (a_ptr->total == 0)\n-\t\t\t    fnotice (gcov_file, \"branch %2d never executed\\n\",\n-\t\t\t\t     i);\n-\t\t\t  else\n-\t\t\t    fnotice\n-\t\t\t      (gcov_file, \"branch %2d taken %s\\n\", i,\n-\t\t\t       format_hwint (a_ptr->hits, a_ptr->total,\n-\t\t\t\t\t     -output_branch_counts));\n-\t\t\t}\n-\t\t   }\n-\t      }\n+\t\t  if (a_ptr->total == 0)\n+\t\t    fnotice (gcov_file, \"branch %2d never executed\\n\", i);\n+\t\t  else\n+\t\t    fnotice\n+\t\t      (gcov_file, \"branch %2d taken %s\\n\", i,\n+\t\t       format_hwint (a_ptr->hits, a_ptr->total,\n+\t\t\t\t     -output_branch_counts));\n+\t\t}\n \t    }\n-\n-\t  /* Handle all remaining source lines.  There may be lines\n-\t     after the last line of code.  */\n-\t  if (retval)\n+\t}\n+    }\n+  \n+  /* Handle all remaining source lines.  There may be lines after the\n+     last line of code.  */\n+  if (retval)\n+    {\n+      for (; (retval = fgets (string, STRING_SIZE, source_file)); line_num++)\n+\t{\n+\t  fprintf (gcov_file, \"%9s:%5ld:%s\", \"-\", line_num, retval);\n+\t  \n+\t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n')\n \t    {\n-\t      for (; (retval = fgets (string, STRING_SIZE, source_file));\n-\t\t   count++)\n-\t\t{\n-\t\t  fprintf (gcov_file, \"%9s:%5ld:%s\", \"-\", count, retval);\n-\n-\t\t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n')\n-\t\t    {\n-\t\t      retval = fgets (string, STRING_SIZE, source_file);\n-\t\t      if (!retval)\n-\t\t\tbreak;\n-\t\t      fputs (retval, gcov_file);\n-\t\t    }\n-\t\t}\n+\t      retval = fgets (string, STRING_SIZE, source_file);\n+\t      if (!retval)\n+\t\tbreak;\n+\t      fputs (retval, gcov_file);\n \t    }\n+\t}\n+    }\n+  \n+  if (source_file)\n+    fclose (source_file);\n+}\n+\n+/* Calculate line execution counts, and output a .gcov file for source\n+   file S_PTR. Allocate an array big enough to hold a count for each\n+   line.  Scan through the bb_data, and when the file name matches the\n+   current file name, then for each following line number, increment\n+   the line number execution count indicated by the execution count of\n+   the appropriate basic block.  */\n+\n+static void\n+output_data (s_ptr)\n+\t     struct sourcefile *s_ptr;\n+{\n+  struct line_info *line_info\t/* line info data */\n+    = (struct line_info *) xcalloc (s_ptr->maxlineno,\n+\t\t\t\t    sizeof (struct line_info));\n+  long line_num;\n+  struct coverage total;\n+  \n+  memset (&total, 0, sizeof (total));\n+  total.name = s_ptr->name;\n+  \n+  init_line_info (line_info, &total, s_ptr->maxlineno);\n+  function_summary (&total, \"file\");\n \n-\t  if (source_file)\n-\t    fclose (source_file);\n+  if (output_gcov_file)\n+    {\n+      /* Now the statistics are ready.  Read in the source file one\n+\t line at a time, and output that line to the gcov file\n+\t preceded by its execution information.  */\n+      \n+      char *gcov_file_name = make_gcov_file_name (total.name);\n+      FILE *gcov_file = fopen (gcov_file_name, \"w\");\n+      \n+      if (gcov_file)\n+\t{\n+\t  fnotice (stdout, \"Creating %s.\\n\", gcov_file_name);\n+\t  output_line_info (gcov_file, line_info, &total, s_ptr->maxlineno);\n \t  if (ferror (gcov_file))\n \t    fnotice (stderr, \"Error writing output file %s.\\n\",\n \t\t     gcov_file_name);\n \t  fclose (gcov_file);\n \t}\n+      else\n+\tfnotice (stderr, \"Could not open output file %s.\\n\", gcov_file_name);\n+      free (gcov_file_name);\n+    }\n+\n+  /* Free data. */\n+  for (line_num = 1; line_num != s_ptr->maxlineno; line_num++)\n+    {\n+      struct arcdata *branch, *next;\n \n-      free (line_counts);\n-      free (line_exists);\n+      for (branch = line_info[line_num].branches; branch; branch = next)\n+\t{\n+\t  next = branch->next;\n+\t  free (branch);\n+\t}\n     }\n+  free (line_info);\n }"}]}