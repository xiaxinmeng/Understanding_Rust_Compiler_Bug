{"sha": "01d419aec11b9ffbdfae60e78795faea19086e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkNDE5YWVjMTFiOWZmYmRmYWU2MGU3ODc5NWZhZWExOTA4NmUxMA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2007-03-26T21:18:43Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2007-03-26T21:18:43Z"}, "message": "gengtype-parse.c: New file.\n\n\t* gengtype-parse.c: New file.\n\t* gengtype-yacc.y: Delete.\n\t* gengtype-lex.l: Don't include gengtype-yacc.h.\n\tDefine YY_DECL and yyterminate appropriately for recursive\n\tdescent parser.  yylval is now a string out-parameter to yylex.\n\t(HWS, EOID): New shorthand.\n\t(IWORD): Add a couple more types.\n\t(yylex): Add a setup stanza.  Remove the complex rules for\n\tdetecting GTY'ed types and typedefs; replace with simple\n\tkeyword detectors.  Adjust everything for the changed\n\tdefinition of yylval.  Ignore all pp-directives, not just #define.\n\t(yyerror): Delete.\n\t(parse_file): Rename yybegin; do not call yyparse.\n\t(yyend): New.\n\t* gengtype.c (xasprintf): Export again.\n\t(this_file): New.  Use everywhere __FILE__ was being used.\n\t(get_lang_bitmap): Special case types defined in gengtype.c.\n\t(do_typedef, new_structure): Suppress definition of certain types.\n\t(new_structure): Improve diagnostics of duplicate definitions.\n\tMake sure location_s is associated with input.h.\n\t(nreverse_pairs, define_location_structures): New functions.\n\t(main): Improve tagging of kludge types.  Remove old kludges\n\tfor input.h types; use define_location_structures.\n\t* gengtype.h: Update prototypes.  Define token codes here.\n\t* Makefile.in: Remove all references to gengtype-yacc.\n\tAdd rules for gengtype-parse.o.  Adjust rules for gengtype-lex.o\n\tand gengtype.\n\t* bitmap.h (struct bitmap_head_def): Coalesce definitions,\n\tadd GTY((skip)) to the field that's only conditionally there.\n\t* doc/install.texi: Document that Bison is no longer required\n\tunless building treelang.\n\nFrom-SVN: r123235", "tree": {"sha": "92672610b9effb039afa4b4273d36d385aff54d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92672610b9effb039afa4b4273d36d385aff54d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01d419aec11b9ffbdfae60e78795faea19086e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d419aec11b9ffbdfae60e78795faea19086e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d419aec11b9ffbdfae60e78795faea19086e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d419aec11b9ffbdfae60e78795faea19086e10/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11a675992afb01354e8d8331087177c25e97a7a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11a675992afb01354e8d8331087177c25e97a7a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11a675992afb01354e8d8331087177c25e97a7a6"}], "stats": {"total": 595, "additions": 297, "deletions": 298}, "files": [{"sha": "0dc2ec553018a01a827680111ff033acf5805423", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -1,5 +1,37 @@\n 2007-03-26  Zack Weinberg  <zackw@panix.com>\n \n+\t* gengtype-parse.c: New file.\n+\t* gengtype-yacc.y: Delete.\n+\t* gengtype-lex.l: Don't include gengtype-yacc.h.\n+\tDefine YY_DECL and yyterminate appropriately for recursive\n+\tdescent parser.  yylval is now a string out-parameter to yylex.\n+\t(HWS, EOID): New shorthand.\n+\t(IWORD): Add a couple more types.\n+\t(yylex): Add a setup stanza.  Remove the complex rules for\n+\tdetecting GTY'ed types and typedefs; replace with simple\n+\tkeyword detectors.  Adjust everything for the changed\n+\tdefinition of yylval.  Ignore all pp-directives, not just #define.\n+\t(yyerror): Delete.\n+\t(parse_file): Rename yybegin; do not call yyparse.\n+\t(yyend): New.\n+\t* gengtype.c (xasprintf): Export again.\n+\t(this_file): New.  Use everywhere __FILE__ was being used.\n+\t(get_lang_bitmap): Special case types defined in gengtype.c.\n+\t(do_typedef, new_structure): Suppress definition of certain types.\n+\t(new_structure): Improve diagnostics of duplicate definitions.\n+\tMake sure location_s is associated with input.h.\n+\t(nreverse_pairs, define_location_structures): New functions.\n+\t(main): Improve tagging of kludge types.  Remove old kludges\n+\tfor input.h types; use define_location_structures.\n+\t* gengtype.h: Update prototypes.  Define token codes here.\n+\t* Makefile.in: Remove all references to gengtype-yacc.\n+\tAdd rules for gengtype-parse.o.  Adjust rules for gengtype-lex.o\n+\tand gengtype.\n+\t* bitmap.h (struct bitmap_head_def): Coalesce definitions,\n+\tadd GTY((skip)) to the field that's only conditionally there.\n+\t* doc/install.texi: Document that Bison is no longer required\n+\tunless building treelang.\n+\n \t* gengtype.c: Don't include gtyp-gen.h.\n \t(srcdir): Declare here.\n \t(base_files, lang_dir_names): Allocate dynamically."}, {"sha": "4c351908270c8fce7473fc912902d967441a5556", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -188,8 +188,6 @@ GCC_WARN_CFLAGS = $(LOOSE_WARN) $($(@D)-warn) $(NOCOMMON_FLAG) $($@-warn)\n \n # These files are to have specific diagnostics suppressed, or are not to\n # be subject to -Werror:\n-# Bison-1.75 output often yields (harmless) -Wtraditional warnings\n-build/gengtype-yacc.o-warn = -Wno-error\n # flex output may yield harmless \"no previous prototype\" warnings\n build/gengtype-lex.o-warn = -Wno-error\n # SYSCALLS.c misses prototypes\n@@ -1699,7 +1697,7 @@ c-parser.o : c-parser.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \n srcextra: gcc.srcextra lang.srcextra\n \n-gcc.srcextra: gengtype-lex.c gengtype-yacc.c gengtype-yacc.h\n+gcc.srcextra: gengtype-lex.c\n \t-cp -p $^ $(srcdir)\n \n c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n@@ -3105,9 +3103,8 @@ build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H)\t\t\\\n build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h\n build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n-build/gengtype-lex.o : gengtype-lex.c gengtype.h gengtype-yacc.h\t\\\n-  $(BCONFIG_H) $(SYSTEM_H)\n-build/gengtype-yacc.o : gengtype-yacc.c gengtype.h $(BCONFIG_H)\t\t\\\n+build/gengtype-lex.o : gengtype-lex.c gengtype.h $(BCONFIG_H) $(SYSTEM_H)\n+build/gengtype-parse.o : gengtype-parse.c gengtype.h $(BCONFIG_H)\t\\\n   $(SYSTEM_H)\n build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) gengtype.h \t\\\n   rtl.def insn-notes.def errors.h\n@@ -3147,18 +3144,12 @@ build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n # These programs are not linked with the MD reader.\n build/gengenrtl$(build_exeext) : $(BUILD_ERRORS)\n build/genmodes$(build_exeext) : $(BUILD_ERRORS)\n-build/gengtype$(build_exeext) : build/gengtype-lex.o \\\n-  build/gengtype-yacc.o $(BUILD_ERRORS)\n+build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o \\\n+\t\t\t\t$(BUILD_ERRORS)\n \n # Generated source files for gengtype.\n gengtype-lex.c : gengtype-lex.l\n \t-$(FLEX) $(FLEXFLAGS) -o$@ $<\n-# This is a pattern rule solely so that Make knows it need not run the\n-# command twice.  The modifier to $@ ensures that Bison is asked to\n-# produce a .c file, whether or not Make decides it needs the .h file\n-# first.\n-gengtype-y%.c gengtype-y%.h: gengtype-y%.y\n-\t-$(BISON) $(BISONFLAGS) -d -o $(@:.h=.c) $<\n \n #\f\n # Remake internationalization support."}, {"sha": "9a33646ccb1156f62d38f3e7cac63bdc1b92e7d3", "filename": "gcc/bitmap.h", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -70,29 +70,20 @@ typedef struct bitmap_element_def GTY(())\n } bitmap_element;\n \n struct bitmap_descriptor;\n-/* Head of bitmap linked list.  \n-   The gengtype doesn't cope with ifdefs inside the definition,\n-   but for statistics we need bitmap descriptor pointer in.\n-   Trick it by two copies of the definition.  This is safe\n-   because the bitmap descriptor is not grabagecollected.  */\n-#ifndef GATHER_STATISTICS\n+/* Head of bitmap linked list.  gengtype ignores ifdefs, but for\n+   statistics we need to add a bitmap descriptor pointer.  As it is\n+   not collected, we can just GTY((skip)) it.   */\n+\n typedef struct bitmap_head_def GTY(()) {\n   bitmap_element *first;\t/* First element in linked list.  */\n   bitmap_element *current;\t/* Last element looked at.  */\n   unsigned int indx;\t\t/* Index of last element looked at.  */\n   bitmap_obstack *obstack;\t/* Obstack to allocate elements from.\n \t\t\t\t   If NULL, then use ggc_alloc.  */\n-} bitmap_head;\n-#else\n-typedef struct bitmap_head_def {\n-  bitmap_element *first;\t/* First element in linked list.  */\n-  bitmap_element *current;\t/* Last element looked at.  */\n-  unsigned int indx;\t\t/* Index of last element looked at.  */\n-  bitmap_obstack *obstack;\t/* Obstack to allocate elements from.\n-\t\t\t\t   If NULL, then use ggc_alloc.  */\n-  struct bitmap_descriptor *desc;\n-} bitmap_head;\n+#ifndef GATHER_STATISTICS\n+  struct bitmap_descriptor GTY((skip)) *desc;\n #endif\n+} bitmap_head;\n \n /* Global data */\n extern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */"}, {"sha": "fa17564574c58c2663bbf016c935eb30940e807f", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -375,14 +375,14 @@ Necessary to regenerate the top level @file{Makefile.in} file from\n @file{Makefile.tpl} and @file{Makefile.def}.\n \n @item GNU Bison version 1.28 (or later)\n-Berkeley @command{yacc} (@command{byacc}) is also reported to work other\n-than for GCJ.\n \n-Necessary when modifying @file{*.y} files.\n+Necessary when modifying @file{*.y} files.  Necessary to build the\n+@code{treelang} front end (which is not enabled by default) from a\n+checkout of the SVN repository; the generated files are not in the\n+repository.  They are included in releases.\n \n-Necessary to build GCC during development because the generated output\n-files are not included in the SVN repository.  They are included in\n-releases.\n+Berkeley @command{yacc} (@command{byacc}) has been reported to work\n+as well.\n \n @item Flex version 2.5.4 (or later)\n \n@@ -1650,10 +1650,18 @@ that type mismatches occur, this could be the cause.\n \n The solution is not to use such a directory for building GCC@.\n \n-When building from SVN or snapshots, or if you modify parser sources,\n-you need the Bison parser generator installed.  If you do not modify\n-parser sources, releases contain the Bison-generated files and you do\n-not need Bison installed to build them.\n+When building from SVN or snapshots and enabling the @code{treelang}\n+front end, or if you modify @file{*.y} files, you need the Bison parser\n+generator installed.  If you do not modify @file{*.y} files, releases\n+contain the Bison-generated files and you do not need Bison installed\n+to build them.  Note that most front ends now use hand-written parsers,\n+which can be modified with no need for Bison.\n+\n+Similarly, when building from SVN or snapshots, or if you modify\n+@file{*.l} files, you need the Flex lexical analyzer generator installed.\n+There is still one Flex-based lexical analyzer (part of the build\n+machinery, not of GCC itself) that is used even if you only build the\n+C front end.\n \n When building from SVN or snapshots, or if you modify Texinfo\n documentation, you need version 4.4 or later of Texinfo installed if you"}, {"sha": "2d003e0c5fa7d12793076f6c192ce1de07b334ce", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 68, "deletions": 216, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -27,7 +27,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define realloc xrealloc\n \n #include \"gengtype.h\"\n-#include \"gengtype-yacc.h\"\n+\n+#define YY_DECL int yylex (const char **yylval)\n+#define yyterminate() return EOF_TOKEN\n \n struct fileloc lexer_line;\n int lexer_toplevel_done;\n@@ -44,199 +46,58 @@ update_lineno (const char *l, size_t len)\n \n ID\t[[:alpha:]_][[:alnum:]_]*\n WS\t[[:space:]]+\n-IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD\n+HWS\t[ \\t\\r\\v\\f]*\n+IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t\n ITYPE\t{IWORD}({WS}{IWORD})*\n+EOID\t[^[:alnum:]_]\n \n %x in_struct in_struct_comment in_comment\n %option warn noyywrap nounput nodefault perf-report\n %option 8bit never-interactive\n %%\n+  /* Do this on entry to yylex():  */\n+  *yylval = 0;\n+  if (lexer_toplevel_done)\n+    {\n+      BEGIN(INITIAL);\n+      lexer_toplevel_done = 0;\n+    }\n \n-[^[:alnum:]_]typedef{WS}(struct|union){WS}{ID}{WS}?[*[:space:]]{WS}?{ID}{WS}?\";\" {\n-  char *tagstart;\n-  size_t taglen;\n-  char *namestart;\n-  size_t namelen;\n-  int is_pointer = 0;\n-  struct type *t;\n-  int union_p;\n-\n-  tagstart = yytext + strlen (\" typedef \");\n-  while (ISSPACE (*tagstart))\n-    tagstart++;\n-  union_p = tagstart[0] == 'u';\n-  tagstart += strlen (\"union \");\n-  while (ISSPACE (*tagstart))\n-    tagstart++;\n-  for (taglen = 1; ISIDNUM (tagstart[taglen]); taglen++)\n-    ;\n-  for (namestart = tagstart + taglen; \n-       ! ISIDNUM (*namestart);\n-       namestart++)\n-    if (*namestart == '*')\n-      is_pointer = 1;\n-  for (namelen = 1; ISIDNUM (namestart[namelen]); namelen++)\n-    ;\n-  t = find_structure ((const char *) xmemdup (tagstart, taglen, taglen+1),\n-\t\t      union_p);\n-  if (is_pointer)\n-    t = create_pointer (t);\n-  namestart = (char *) xmemdup (namestart, namelen, namelen+1);\n-#ifdef USE_MAPPED_LOCATION\n-  /* temporary kludge - gentype doesn't handle cpp conditionals */\n-  if (strcmp (namestart, \"location_t\") != 0\n-      && strcmp (namestart, \"expanded_location\") != 0)\n-#endif\n-  do_typedef (namestart, t, &lexer_line);\n-  update_lineno (yytext, yyleng);\n+  /* Things we look for in skipping mode: */\n+<INITIAL>{\n+^typedef/{EOID} {\n+  BEGIN(in_struct);\n+  return TYPEDEF;\n }\n-\n-[^[:alnum:]_]typedef{WS}{ITYPE}{WS}{ID}{WS}?\";\" {\n-\n-  char *namestart;\n-  size_t namelen;\n-  char *typestart;\n-  size_t typelen;\n-\n-  for (namestart = yytext + yyleng - 2; ISSPACE (*namestart); namestart--)\n-    ;\n-  for (namelen = 1; !ISSPACE (namestart[-namelen]); namelen++)\n-    ;\n-  namestart -= namelen - 1;\n-  for (typestart = yytext + strlen (\" typedef \"); \n-       ISSPACE(*typestart);\n-       typestart++)\n-    ;\n-  for (typelen = namestart - typestart;\n-       ISSPACE (typestart[typelen-1]);\n-       typelen--)\n-    ;\n-  typestart[typelen] = '\\0';\n-\n-  do_typedef ((const char *) xmemdup (namestart, namelen, namelen+1),\n-  \t      create_scalar_type (typestart),\n-\t      &lexer_line);\n-  update_lineno (yytext, yyleng);\n+^struct/{EOID} {\n+  BEGIN(in_struct);\n+  return STRUCT;\n }\n-\n-[^[:alnum:]_]typedef{WS}{ID}{WS}{ID}{WS}\"(\" {\n-  char *namestart;\n-  size_t namelen;\n-\n-  for (namestart = yytext + yyleng - 2; ISSPACE (*namestart); namestart--)\n-    ;\n-  for (namelen = 1; !ISSPACE (namestart[-namelen]); namelen++)\n-    ;\n-  namestart -= namelen - 1;\n-\n-  do_scalar_typedef ((const char *) xmemdup (namestart, namelen, namelen+1),\n-  \t\t     &lexer_line);\n-  update_lineno (yytext, yyleng);\n+^union/{EOID} {\n+  BEGIN(in_struct);\n+  return UNION;\n }\n-\n-[^[:alnum:]_]typedef{WS}{ID}{WS}?\"*\"?{WS}?\"(\"{WS}?\"*\"{WS}?{ID}{WS}?\")\"{WS}?\"(\" {\n-  char *namestart;\n-  size_t namelen;\n-\n-  for (namestart = yytext + yyleng - 2; !ISIDNUM (*namestart); namestart--)\n-    ;\n-  for (namelen = 1; ISIDNUM (namestart[-namelen]); namelen++)\n-    ;\n-  namestart -= namelen - 1;\n-\n-  do_scalar_typedef ((const char *) xmemdup (namestart, namelen, namelen+1),\n-  \t\t     &lexer_line);\n-  update_lineno (yytext, yyleng);\n+^extern/{EOID} {\n+  BEGIN(in_struct);\n+  return EXTERN;\n }\n-\n-[^[:alnum:]_](typedef{WS})?(struct|union){WS}{ID}{WS}/\"GTY\" {\n-  char *tagstart;\n-  size_t taglen;\n-  int typedef_p;\n-  int union_p;\n-\n-  typedef_p = yytext[1] == 't';\n-  if (typedef_p)\n-    for (tagstart = yytext + strlen (\" typedef \"); \n-\t ISSPACE(*tagstart);\n-\t tagstart++)\n-      ;\n-  else\n-    tagstart = yytext + 1;\n-\n-  union_p = tagstart[0] == 'u';\n-  tagstart += strlen (\"union \");\n-  while (ISSPACE (*tagstart))\n-    tagstart++;\n-  for (taglen = 1; ISIDNUM (tagstart[taglen]); taglen++)\n-    ;\n-\n-  yylval.s = (const char *) xmemdup (tagstart, taglen, taglen + 1);\n-\n+^static/{EOID} {\n   BEGIN(in_struct);\n-  update_lineno (yytext, yyleng);\n-  return union_p ? (typedef_p ? ENT_TYPEDEF_UNION : ENT_UNION)\n-                 : (typedef_p ? ENT_TYPEDEF_STRUCT : ENT_STRUCT);\n+  return STATIC;\n }\n \n-[^[:alnum:]_](extern|static){WS}/\"GTY\" {\n+^DEF_VEC_[OP]/{EOID} {\n   BEGIN(in_struct);\n-  update_lineno (yytext, yyleng);\n-  return ENT_EXTERNSTATIC;\n+  return DEFVEC_OP;\n }\n-\n-^\"DEF_VEC_\"[IPO]{WS}?\"(\"{WS}?{ID}{WS}?\")\" {\n-  /* Definition of a generic VEC structure.  If the letter after\n-     DEF_VEC_ is \"I\", the structure definition is slightly different\n-     than if it is \"P\" or \"O\".  */\n-\n-  char *p = yytext + sizeof(\"DEF_VEC_\") - 1;\n-  char *q;\n-  const char *type;\n-  bool is_I = (*p == 'I');\n-\n-  /* Extract the argument to the macro.  */\n-  p++;\n-  while (!ISALNUM(*p) && *p != '_')\n-    p++;\n-  q = p;\n-  while (ISALNUM(*q) || *q == '_')\n-    ++;\n-  type = xmemdup (p, q - p, q - p + 1);\n-\n-  note_def_vec (type, is_I, &lexer_line);\n-  note_def_vec_alloc (type, \"none\", &lexer_line);\n+^DEF_VEC_I/{EOID} {\n+  BEGIN(in_struct);\n+  return DEFVEC_I;\n+}\n+^DEF_VEC_ALLOC_[IOP]/{EOID} {\n+  BEGIN(in_struct);\n+  return DEFVEC_ALLOC;\n }\n-\n-^\"DEF_VEC_ALLOC_\"[IPO]{WS}?\"(\"{WS}?{ID}{WS}?\",\"{WS}?{ID}{WS}?\")\" {\n-  /* Definition of an allocation strategy for a VEC structure.  For\n-     purposes of gengtype, this just declares a wrapper structure.  */\n-\n-  char *p = yytext + sizeof(\"DEF_VEC_ALLOC_I\") - 1;\n-  char *q;\n-  char *type, *astrat;\n-\n-  /* Extract the two arguments to the macro.  */\n-  while (!ISALNUM(*p) && *p != '_')\n-    p++;\n-  q = p;\n-  while (ISALNUM(*q) || *q == '_')\n-    q++;\n-  type = alloca (q - p + 1);\n-  memcpy (type, p, q - p);\n-  type[q - p] = '\\0';\n-  p = q;\n-\n-  while (!ISALNUM(*p) && *p != '_')\n-    p++;\n-  q = p;\n-  while (ISALNUM(*q) || *q == '_')\n-    q++;\n-  astrat = alloca (q - p + 1);\n-  memcpy (astrat, p, q - p);\n-  astrat[q - p] = '\\0';\n-\n-  note_def_vec_alloc (type, astrat, &lexer_line);\n }\n \n <in_struct>{\n@@ -245,63 +106,57 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n \n {WS}\t\t\t\t{ update_lineno (yytext, yyleng); }\n \n-\"const\"/[^[:alnum:]_]\t\t/* don't care */\n-\"GTY\"/[^[:alnum:]_]\t\t{ return GTY_TOKEN; }\n-\"VEC\"/[^[:alnum:]_]\t\t{ return VEC_TOKEN; }\n-\"union\"/[^[:alnum:]_]\t\t{ return UNION; }\n-\"struct\"/[^[:alnum:]_]\t\t{ return STRUCT; }\n-\"enum\"/[^[:alnum:]_]\t\t{ return ENUM; }\n-\"ptr_alias\"/[^[:alnum:]_]\t{ return ALIAS; }\n-\"nested_ptr\"/[^[:alnum:]_]\t{ return NESTED_PTR; }\n+\"const\"/{EOID}\t\t\t/* don't care */\n+\"GTY\"/{EOID}\t\t\t{ return GTY_TOKEN; }\n+\"VEC\"/{EOID}\t\t\t{ return VEC_TOKEN; }\n+\"union\"/{EOID}\t\t\t{ return UNION; }\n+\"struct\"/{EOID}\t\t\t{ return STRUCT; }\n+\"enum\"/{EOID}\t\t\t{ return ENUM; }\n+\"ptr_alias\"/{EOID}\t  \t{ return PTR_ALIAS; }\n+\"nested_ptr\"/{EOID}\t\t{ return NESTED_PTR; }\n [0-9]+\t\t\t\t{ return NUM; }\n-\"param\"[0-9]*\"_is\"/[^[:alnum:]_]\t\t{\n-  yylval.s = (const char *) xmemdup (yytext, yyleng, yyleng+1);\n+\"param\"[0-9]*\"_is\"/{EOID}\t\t{\n+  *yylval = xmemdup (yytext, yyleng, yyleng+1);\n   return PARAM_IS;\n }\n \n-{IWORD}({WS}{IWORD})*/[^[:alnum:]_]\t\t|\n+{IWORD}({WS}{IWORD})*/{EOID}\t\t|\n \"ENUM_BITFIELD\"{WS}?\"(\"{WS}?{ID}{WS}?\")\"\t{\n   size_t len;\n \n   for (len = yyleng; ISSPACE (yytext[len-1]); len--)\n     ;\n \n-  yylval.s = (const char *) xmemdup (yytext, len, len+1);\n+  *yylval = xmemdup (yytext, len, len+1);\n   update_lineno (yytext, yyleng);\n   return SCALAR;\n }\n \n \n-{ID}/[^[:alnum:]_]\t\t{\n-  yylval.s = (const char *) xmemdup (yytext, yyleng, yyleng+1);\n+{ID}/{EOID}\t\t\t{\n+  *yylval = xmemdup (yytext, yyleng, yyleng+1);\n   return ID;\n }\n \n \\\"([^\"\\\\]|\\\\.)*\\\"\t\t{\n-  yylval.s = (const char *) xmemdup (yytext+1, yyleng-2, yyleng-1);\n+  *yylval = xmemdup (yytext+1, yyleng-2, yyleng-1);\n   return STRING;\n }\n+  /* This \"terminal\" avoids having to parse integer constant expressions.  */\n \"[\"[^\\[\\]]*\"]\"\t\t\t{\n-  yylval.s = (const char *) xmemdup (yytext+1, yyleng-2, yyleng-1);\n+  *yylval = xmemdup (yytext+1, yyleng-2, yyleng-1);\n   return ARRAY;\n }\n \"'\"(\"\\\\\".|[^\\\\])\"'\"\t\t{\n-  yylval.s = (const char *) xmemdup (yytext+1, yyleng-2, yyleng);\n+  *yylval = xmemdup (yytext+1, yyleng-2, yyleng);\n   return CHAR;\n }\n \n-[(){},*:<>]\t\t\t{ return yytext[0]; }\n-\n-[;=]\t\t\t\t{\n-  if (lexer_toplevel_done)\n-    {\n-      BEGIN(INITIAL);\n-      lexer_toplevel_done = 0;\n-    }\n-  return yytext[0];\n-}\n+\"...\"\t\t\t\t{ return ELLIPSIS; }\n+[(){},*:<>;=%|-]\t\t{ return yytext[0]; }\n \n-\"#define\"[^\\n]*\\n\t\t{lexer_line.line++;}\n+   /* ignore pp-directives */\n+^{HWS}\"#\"{HWS}[a-z_]+[^\\n]*\\n   {lexer_line.line++;}\n \n .\t\t\t\t{\n   error_at_line (&lexer_line, \"unexpected character `%s'\", yytext);\n@@ -339,23 +194,20 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n %%\n \n void\n-yyerror (const char *s)\n-{\n-  error_at_line (&lexer_line, s);\n-}\n-\n-void\n-parse_file (const char *fname)\n+yybegin (const char *fname)\n {\n   yyin = fopen (fname, \"r\");\n-  lexer_line.file = fname;\n-  lexer_line.line = 1;\n   if (yyin == NULL)\n     {\n       perror (fname);\n       exit (1);\n     }\n-  if (yyparse() != 0)\n-    exit (1);\n+  lexer_line.file = fname;\n+  lexer_line.line = 1;\n+}\n+\n+void\n+yyend (void)\n+{\n   fclose (yyin);\n }"}, {"sha": "e0cd6c2599fd6fe246c3a8d9924d9e87e31be134", "filename": "gcc/gengtype.c", "status": "modified", "additions": 121, "deletions": 38, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -155,7 +155,7 @@ static const char * get_file_basename (const char *);\n \n \f\n /* Nonzero iff an error has occurred.  */\n-static int hit_error = 0;\n+bool hit_error = false;\n \n static void gen_rtx_next (void);\n static void write_rtx_next (void);\n@@ -174,13 +174,13 @@ error_at_line (struct fileloc *pos, const char *msg, ...)\n   fprintf (stderr, \"%s:%d: \", pos->file, pos->line);\n   vfprintf (stderr, msg, ap);\n   fputc ('\\n', stderr);\n-  hit_error = 1;\n+  hit_error = true;\n \n   va_end (ap);\n }\n \n /* asprintf, but produces fatal message on out-of-memory.  */\n-static char * ATTRIBUTE_PRINTF_1\n+char *\n xasprintf (const char *format, ...)\n {\n   int n;\n@@ -202,6 +202,11 @@ xasprintf (const char *format, ...)\n static const char **gt_files;\n static size_t num_gt_files;\n \n+/* A number of places use the name of this file for a location for\n+   things that we can't rely on the source to define.  Make sure we\n+   can still use pointer comparison on filenames.  */\n+static const char this_file[] = __FILE__;\n+\n /* Vector of per-language directories.  */\n static const char **lang_dir_names;\n static size_t num_lang_dirs;\n@@ -225,11 +230,18 @@ static outf_p *base_files;\n static lang_bitmap\n get_lang_bitmap (const char *gtfile)\n {\n-  lang_bitmap n = 0;\n-  int i;\n-  for (i = -(int) sizeof (lang_bitmap); i < 0; i++)\n-    n = (n << CHAR_BIT) + (unsigned char)gtfile[i];\n-  return n;\n+\n+  if (gtfile == this_file)\n+    /* Things defined in this file are universal.  */\n+    return (((lang_bitmap)1) << num_lang_dirs) - 1;\n+  else\n+    {\n+      lang_bitmap n = 0;\n+      int i;\n+      for (i = -(int) sizeof (lang_bitmap); i < 0; i++)\n+\tn = (n << CHAR_BIT) + (unsigned char)gtfile[i];\n+      return n;\n+    }\n }\n \n /* Set the bitmap returned by get_lang_bitmap.  The only legitimate\n@@ -509,6 +521,18 @@ do_typedef (const char *s, type_p t, struct fileloc *pos)\n {\n   pair_p p;\n \n+  /* temporary kludge - gengtype doesn't handle conditionals or macros.\n+     Ignore any attempt to typedef CUMULATIVE_ARGS, location_t,\n+     expanded_location, or source_locus, unless it is coming from\n+     this file (main() sets them up with safe dummy definitions).  */\n+  if ((!strcmp (s, \"CUMULATIVE_ARGS\")\n+       || !strcmp (s, \"location_t\")\n+       || !strcmp (s, \"source_locus\")\n+       || !strcmp (s, \"source_location\")\n+       || !strcmp (s, \"expanded_location\"))\n+      && pos->file != this_file)\n+    return;\n+\n   for (p = typedefs; p != NULL; p = p->next)\n     if (strcmp (p->name, s) == 0)\n       {\n@@ -562,6 +586,13 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n   type_p s = NULL;\n   lang_bitmap bitmap = get_lang_bitmap (pos->file);\n \n+  /* temporary kludge - gengtype doesn't handle conditionals or\n+     macros.  Ignore any attempt to define struct location_s, unless\n+     it is coming from this file (main() sets it up safely). */\n+  if (!strcmp (name, \"location_s\") && !isunion\n+      && pos->file != this_file)\n+    return find_structure (name, 0);\n+\n   for (si = structures; si != NULL; si = si->next)\n     if (strcmp (name, si->u.s.tag) == 0\n \t&& UNION_P (si) == isunion)\n@@ -610,7 +641,8 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n   if (s->u.s.line.file != NULL\n       || (s->u.s.lang_struct && (s->u.s.lang_struct->u.s.bitmap & bitmap)))\n     {\n-      error_at_line (pos, \"duplicate structure definition\");\n+      error_at_line (pos, \"duplicate definition of '%s %s'\",\n+\t\t     isunion ? \"union\" : \"struct\", s->u.s.tag);\n       error_at_line (&s->u.s.line, \"previous definition here\");\n     }\n \n@@ -623,7 +655,22 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n   if (s->u.s.lang_struct)\n     s->u.s.lang_struct->u.s.bitmap |= bitmap;\n \n-  return s;\n+  /* Reset location_s's location to input.h so that we know where to\n+     write out its mark routine.  */\n+  if (!strcmp (name, \"location_s\") && !isunion\n+      && pos->file == this_file)\n+    {\n+      size_t n;\n+      for (n = 0; n < num_gt_files; n++)\n+\tif (!strcmp (gt_files[n] + strlen (gt_files[n]) - strlen (\"input.h\"),\n+\t\t     \"input.h\"))\n+\t  {\n+\t    s->u.s.line.file = gt_files[n];\n+\t    break;\n+\t  }\n+    }\n+\n+    return s;\n }\n \n /* Return the previously-defined structure with tag NAME (or a union\n@@ -788,7 +835,7 @@ create_field_at (pair_p next, type_p type, const char *name, options_p opt,\n /* Create a fake field with the given type and name.  NEXT is the next\n    field in the chain.  */\n #define create_field(next,type,name) \\\n-    create_field_all(next,type,name, 0, __FILE__, __LINE__)\n+    create_field_all(next,type,name, 0, this_file, __LINE__)\n \n /* Like create_field, but the field is only valid when condition COND\n    is true.  */\n@@ -814,11 +861,26 @@ create_optional_field_ (pair_p next, type_p type, const char *name,\n      tag that specifies the condition under which the field is valid.  */\n   return create_field_all (next, union_type, name,\n \t\t\t   create_option (0, \"desc\", cond),\n-\t\t\t   __FILE__, line);\n+\t\t\t   this_file, line);\n }\n #define create_optional_field(next,type,name,cond)\t\\\n        create_optional_field_(next,type,name,cond,__LINE__)\n \n+/* Reverse a linked list of 'struct pair's in place.  */\n+pair_p\n+nreverse_pairs (pair_p list)\n+{\n+  pair_p prev = 0, p, next;\n+  for (p = list; p; p = next)\n+    {\n+      next = p->next;\n+      p->next = prev;\n+      prev = p;\n+    }\n+  return prev;\n+}\n+\n+\f\n /* We don't care how long a CONST_DOUBLE is.  */\n #define CONST_DOUBLE_FORMAT \"ww\"\n /* We don't want to see codes that are only for generator files.  */\n@@ -3420,12 +3482,42 @@ note_def_vec_alloc (const char *type, const char *astrat, struct fileloc *pos)\n   do_typedef (astratname, new_structure (astratname, 0, pos, field, 0), pos);\n }\n \n+/* Yet more temporary kludge since gengtype doesn't understand conditionals.\n+   This must be kept in sync with input.h.  */\n+static void\n+define_location_structures (void)\n+{\n+  pair_p fields;\n+  type_p locs;\n+  static struct fileloc pos = { this_file, __LINE__ };\n+  do_scalar_typedef (\"source_location\", &pos);\n+\n+#ifdef USE_MAPPED_LOCATION\n+    fields = create_field (0, &scalar_nonchar, \"column\");\n+    fields = create_field (fields, &scalar_nonchar, \"line\");\n+    fields = create_field (fields, &string_type, \"file\");\n+    locs = new_structure (\"anon:expanded_location\", 0, &pos, fields, 0);\n+\n+    do_typedef (\"expanded_location\", locs, &pos);\n+    do_scalar_typedef (\"location_t\", &pos);\n+    do_scalar_typedef (\"source_locus\", &pos);\n+#else\n+    fields = create_field (0, &scalar_nonchar, \"line\");\n+    fields = create_field (fields, &string_type, \"file\");\n+    locs = new_structure (\"location_s\", 0, &pos, fields, 0);\n+\n+    do_typedef (\"expanded_location\", locs, &pos);\n+    do_typedef (\"location_t\", locs, &pos);\n+    do_typedef (\"source_locus\", create_pointer (locs), &pos);\n+#endif\n+}\n+\n \f\n int\n main (int argc, char **argv)\n {\n   size_t i;\n-  static struct fileloc pos = { __FILE__, __LINE__ };\n+  static struct fileloc pos = { this_file, 0 };\n \n   /* fatal uses this */\n   progname = \"gengtype\";\n@@ -3444,34 +3536,23 @@ main (int argc, char **argv)\n   scalar_nonchar.u.scalar_is_char = false;\n   gen_rtx_next ();\n \n-  do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n-  do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos);\n-  do_scalar_typedef (\"double_int\", &pos);\n-  do_scalar_typedef (\"uint8\", &pos);\n-  do_scalar_typedef (\"jword\", &pos);\n-  do_scalar_typedef (\"JCF_u2\", &pos);\n-#ifdef USE_MAPPED_LOCATION\n-  do_scalar_typedef (\"location_t\", &pos);\n-  do_scalar_typedef (\"source_locus\", &pos);\n-#endif\n-  do_scalar_typedef (\"void\", &pos);\n-\n+  /* These types are set up with #define or else outside of where\n+     we can see them.  */\n+  pos.line = __LINE__ + 1;\n+  do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos); pos.line++;\n+  do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos); pos.line++;\n+  do_scalar_typedef (\"double_int\", &pos); pos.line++;\n+  do_scalar_typedef (\"uint8\", &pos); pos.line++;\n+  do_scalar_typedef (\"jword\", &pos); pos.line++;\n+  do_scalar_typedef (\"JCF_u2\", &pos); pos.line++;\n+  do_scalar_typedef (\"void\", &pos); pos.line++;\n   do_typedef (\"PTR\", create_pointer (resolve_typedef (\"void\", &pos)), &pos);\n-\n-  do_typedef (\"HARD_REG_SET\", create_array (&scalar_nonchar, \"2\"), &pos);\n+  define_location_structures ();\n \n   for (i = 0; i < num_gt_files; i++)\n-    {\n-      parse_file (gt_files[i]);\n-#ifndef USE_MAPPED_LOCATION\n-      /* temporary kludge - gengtype doesn't handle conditionals.\n-\t Manually add source_locus *after* we've processed input.h.  */\n-      if (i == 0)\n-\tdo_typedef (\"source_locus\", create_pointer (resolve_typedef (\"location_t\", &pos)), &pos);\n-#endif\n-    }\n+    parse_file (gt_files[i]);\n \n-  if (hit_error != 0)\n+  if (hit_error)\n     return 1;\n \n   set_gc_used (variables);\n@@ -3485,5 +3566,7 @@ main (int argc, char **argv)\n   write_rtx_next ();\n   close_output_files ();\n \n-  return (hit_error != 0);\n+  if (hit_error)\n+    return 1;\n+  return 0;\n }"}, {"sha": "a23e2778e93563222e15a0eda6f510817e318887", "filename": "gcc/gengtype.h", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -41,6 +41,9 @@ extern struct fileloc lexer_line;\n extern void error_at_line \n   (struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n \n+/* Like asprintf, but calls fatal() on out of memory.  */\n+extern char *xasprintf(const char *, ...) ATTRIBUTE_PRINTF_1;\n+\n /* Constructor routines for types.  */\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n extern void do_scalar_typedef (const char *s, struct fileloc *pos);\n@@ -57,6 +60,7 @@ extern options_p create_nested_ptr_option (options_p, type_p t,\n \t\t\t\t\t   const char *from, const char *to);\n extern pair_p create_field_at (pair_p next, type_p type, const char *name,\n \t\t\t       options_p opt, struct fileloc *pos);\n+extern pair_p nreverse_pairs (pair_p list);\n extern type_p adjust_field_type (type_p, options_p);\n extern void note_variable (const char *s, type_p t, options_p o,\n \t\t\t   struct fileloc *pos);\n@@ -65,10 +69,45 @@ extern void note_def_vec (const char *typename, bool is_scalar,\n extern void note_def_vec_alloc (const char *type, const char *astrat,\n \t\t\t\tstruct fileloc *pos);\n \n-/* Lexer and parser routines, most automatically generated.  */\n-extern int yylex (void);\n-extern void yyerror (const char *);\n-extern int yyparse (void);\n+/* Lexer and parser routines.  */\n+extern int yylex (const char **yylval);\n+extern void yybegin (const char *fname);\n+extern void yyend (void);\n extern void parse_file (const char *name);\n+extern bool hit_error;\n+\n+/* Token codes.  */\n+enum {\n+  EOF_TOKEN = 0,\n+\n+  /* Per standard convention, codes in the range (0, UCHAR_MAX]\n+     represent single characters with those character codes.  */\n \n+  CHAR_TOKEN_OFFSET = UCHAR_MAX + 1,\n+  GTY_TOKEN = CHAR_TOKEN_OFFSET,\n+  TYPEDEF,\n+  EXTERN,\n+  STATIC,\n+  UNION,\n+  STRUCT,\n+  ENUM,\n+  VEC_TOKEN,\n+  DEFVEC_OP,\n+  DEFVEC_I,\n+  DEFVEC_ALLOC,\n+  ELLIPSIS,\n+  PTR_ALIAS,\n+  NESTED_PTR,\n+  PARAM_IS,\n+  NUM,\n+  SCALAR,\n+  ID,\n+  STRING,\n+  CHAR,\n+  ARRAY,\n+\n+  /* print_token assumes that any token >= FIRST_TOKEN_WITH_VALUE may have\n+     a meaningful value to be printed.  */\n+  FIRST_TOKEN_WITH_VALUE = PARAM_IS\n+};\n #endif"}, {"sha": "efdfbd33854bcd50ef10ad9aab086332acd45471", "filename": "gcc/input.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d419aec11b9ffbdfae60e78795faea19086e10/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=01d419aec11b9ffbdfae60e78795faea19086e10", "patch": "@@ -28,6 +28,9 @@ extern struct line_maps line_table;\n /* The location for declarations in \"<built-in>\" */\n #define BUILTINS_LOCATION ((source_location) 2)\n \n+/* Note: if any of the types defined inside this #ifdef are changed,\n+   gengtype.c:define_location_structures must be updated to match.  */\n+\n #ifdef USE_MAPPED_LOCATION\n \n typedef struct"}]}