{"sha": "8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkM2NmNGUxN2M5NzAzNmI0ZjljZWNiZTJmNDM4YTJkYTkyMDM1MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-06-03T08:57:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-06-03T08:57:55Z"}, "message": "builtins.c (expand_builtin_memcpy): Remove endp argument and endp != 0 handling.\n\n\t* builtins.c (expand_builtin_memcpy): Remove endp argument and endp\n\t!= 0 handling.  Pass 0 to store_by_pieces.\n\t(expand_builtin_mempcpy): Add endp argument.  Don't call\n\texpand_builtin_memcpy, call store_by_pieces resp. move_by_pieces\n\tdirectly.  If ignoring result, only do expand_call.\n\t(expand_builtin_stpcpy): Likewise.  Call expand_builtin_mempcpy\n\totherwise.\n\t(expand_builtin_strncpy, expand_builtin_memset): Adjust\n\tstore_by_pices callers.\n\t(expand_builtin): Adjust expand_builtin_memcpy and\n\texpand_builtin_mempcpy callers.\n\t* expr.c (can_move_by_pieces): New function.\n\t(move_by_pieces): Add endp argument, return to resp. memory at end\n\tor one byte earlier depending on endp.\n\t(store_by_pieces): Likewise.\n\t(emit_block_move): Adjust call to move_by_pieces.\n\t(emit_push_insn): Adjust move_by_pieces caller.\n\t* expr.h (can_move_by_pieces): New prototype.\n\t(store_by_pieces): Adjust prototypes.\n\t* rtl.h (move_by_pieces): Adjust prototype.\n\t* config/mips/mips.c (expand_block_move): Adjust move_by_pieces\n\tcaller.\n\n\t* gcc.c-torture/execute/builtins/string-4.c (main_test): Remove\n\tmempcpy test with post-increments.\n\t* gcc.c-torture/execute/string-opt-3.c: New test.\n\t* gcc.dg/string-opt-1.c: New test.\n\nFrom-SVN: r67358", "tree": {"sha": "969f8e454fe8799c43c000ed725898b0593270ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/969f8e454fe8799c43c000ed725898b0593270ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc6a602b278d597095052e6de06f02d65b315a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6a602b278d597095052e6de06f02d65b315a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6a602b278d597095052e6de06f02d65b315a03"}], "stats": {"total": 504, "additions": 412, "deletions": 92}, "files": [{"sha": "b628ed0649fd504f97e735dd076ac9291eed8f03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -1,3 +1,28 @@\n+2003-06-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* builtins.c (expand_builtin_memcpy): Remove endp argument and endp\n+\t!= 0 handling.  Pass 0 to store_by_pieces.\n+\t(expand_builtin_mempcpy): Add endp argument.  Don't call\n+\texpand_builtin_memcpy, call store_by_pieces resp. move_by_pieces\n+\tdirectly.  If ignoring result, only do expand_call.\n+\t(expand_builtin_stpcpy): Likewise.  Call expand_builtin_mempcpy\n+\totherwise.\n+\t(expand_builtin_strncpy, expand_builtin_memset): Adjust\n+\tstore_by_pices callers.\n+\t(expand_builtin): Adjust expand_builtin_memcpy and\n+\texpand_builtin_mempcpy callers.\n+\t* expr.c (can_move_by_pieces): New function.\n+\t(move_by_pieces): Add endp argument, return to resp. memory at end\n+\tor one byte earlier depending on endp.\n+\t(store_by_pieces): Likewise.\n+\t(emit_block_move): Adjust call to move_by_pieces.\n+\t(emit_push_insn): Adjust move_by_pieces caller.\n+\t* expr.h (can_move_by_pieces): New prototype.\n+\t(store_by_pieces): Adjust prototypes.\n+\t* rtl.h (move_by_pieces): Adjust prototype.\n+\t* config/mips/mips.c (expand_block_move): Adjust move_by_pieces\n+\tcaller.\n+\n 2003-06-03  Ben Elliston  <bje@wasabisystems.com>\n \n \t* doc/md.texi (Processor pipeline description): Improve wording."}, {"sha": "557e397945ce9c23b15aee37e3e030cdbb30e8c4", "filename": "gcc/builtins.c", "status": "modified", "additions": 99, "deletions": 72, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -125,9 +125,9 @@ static rtx expand_builtin_strspn\tPARAMS ((tree, rtx,\n static rtx expand_builtin_strcspn\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memcpy\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode, int));\n-static rtx expand_builtin_mempcpy\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n+static rtx expand_builtin_mempcpy\tPARAMS ((tree, rtx,\n+\t\t\t\t\t\t enum machine_mode, int));\n static rtx expand_builtin_memmove\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_bcopy\t\tPARAMS ((tree));\n@@ -2274,16 +2274,12 @@ builtin_memcpy_read_str (data, offset, mode)\n /* Expand a call to the memcpy builtin, with arguments in ARGLIST.\n    Return 0 if we failed, the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n-   mode MODE if that's convenient).  If ENDP is 0 return the\n-   destination pointer, if ENDP is 1 return the end pointer ala\n-   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n-   stpcpy.  */\n+   mode MODE if that's convenient).  */\n static rtx\n-expand_builtin_memcpy (arglist, target, mode, endp)\n+expand_builtin_memcpy (arglist, target, mode)\n      tree arglist;\n      rtx target;\n      enum machine_mode mode;\n-     int endp;\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -2294,7 +2290,6 @@ expand_builtin_memcpy (arglist, target, mode, endp)\n       tree src = TREE_VALUE (TREE_CHAIN (arglist));\n       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n       const char *src_str;\n-\n       unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n       unsigned int dest_align\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n@@ -2331,28 +2326,15 @@ expand_builtin_memcpy (arglist, target, mode, endp)\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n \t\t\t\t  (PTR) src_str, dest_align))\n \t{\n-\t  store_by_pieces (dest_mem, INTVAL (len_rtx),\n-\t\t\t   builtin_memcpy_read_str,\n-\t\t\t   (PTR) src_str, dest_align);\n+\t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n+\t\t\t\t      builtin_memcpy_read_str,\n+\t\t\t\t      (PTR) src_str, dest_align, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (GET_MODE (dest_mem) != ptr_mode)\n \t    dest_mem = convert_memory_address (ptr_mode, dest_mem);\n #endif\n-\t  if (endp)\n-\t    {\n-\t      rtx result;\n-\t      rtx delta = len_rtx;\n-\n-\t      if (endp == 2)\n-\t\tdelta = GEN_INT (INTVAL (delta) - 1);\n-\n-\t      result = simplify_gen_binary (PLUS, GET_MODE (dest_mem),\n-\t\t\t\t\t    dest_mem, delta);\n-\t      return force_operand (result, NULL_RTX);\n-\t    }\n-\t  else\n-\t    return dest_mem;\n+\t  return dest_mem;\n \t}\n \n       src_mem = get_memory_rtx (src);\n@@ -2370,61 +2352,112 @@ expand_builtin_memcpy (arglist, target, mode, endp)\n \t    dest_addr = convert_memory_address (ptr_mode, dest_addr);\n #endif\n \t}\n-\n-      if (endp)\n-        {\n-\t  rtx result = force_operand (len_rtx, NULL_RTX);\n-\n-\t  if (endp == 2)\n-\t    {\n-\t      result = simplify_gen_binary (MINUS, GET_MODE (dest_addr),\n-\t\t\t\t\t    result, const1_rtx);\n-\t      result = force_operand (result, NULL_RTX);\n-\t    }\n-\n-\t  result = simplify_gen_binary (PLUS, GET_MODE (dest_addr),\n-\t\t\t\t\tdest_addr, result);\n-\t  return force_operand (result, NULL_RTX);\n-\t}\n-      else\n-\treturn dest_addr;\n+      return dest_addr;\n     }\n }\n \n /* Expand a call to the mempcpy builtin, with arguments in ARGLIST.\n    Return 0 if we failed the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n-   mode MODE if that's convenient).  */\n+   mode MODE if that's convenient).  If ENDP is 0 return the\n+   destination pointer, if ENDP is 1 return the end pointer ala\n+   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n+   stpcpy.  */\n \n static rtx\n-expand_builtin_mempcpy (arglist, target, mode)\n+expand_builtin_mempcpy (arglist, target, mode, endp)\n      tree arglist;\n      rtx target;\n      enum machine_mode mode;\n+     int endp;\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n+  /* If return value is ignored, transform mempcpy into memcpy.  */\n+  else if (target == const0_rtx)\n+    {\n+      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\n+      if (!fn)\n+\treturn 0;\n+\n+      return expand_expr (build_function_call_expr (fn, arglist),\n+\t\t\t  target, mode, EXPAND_NORMAL);\n+    }\n   else\n     {\n-      /* If return value is ignored, transform mempcpy into memcpy.  */\n-      if (target == const0_rtx)\n+      tree dest = TREE_VALUE (arglist);\n+      tree src = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      const char *src_str;\n+      unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+      unsigned int dest_align\n+\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      rtx dest_mem, src_mem, len_rtx;\n+\n+      /* If DEST is not a pointer type or LEN is not constant,\n+\t call the normal function.  */\n+      if (dest_align == 0 || !host_integerp (len, 1))\n+\treturn 0;\n+\n+      /* If the LEN parameter is zero, return DEST.  */\n+      if (tree_low_cst (len, 1) == 0)\n \t{\n-\t  tree fn;\n-\t  rtx ret = expand_builtin_memcpy (arglist, target, mode, /*endp=*/0);\n+\t  /* Evaluate and ignore SRC in case it has side-effects.  */\n+\t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t}\n \n-\t  if (ret)\n-\t    return ret;\n+      /* If either SRC is not a pointer type, don't do this\n+         operation in-line.  */\n+      if (src_align == 0)\n+\treturn 0;\n \n-\t  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-\t  if (!fn)\n-\t    return 0;\n+      len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+      src_str = c_getstr (src);\n \n-\t  return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n+      /* If SRC is a string constant and block move would be done\n+\t by pieces, we can avoid loading the string from memory\n+\t and only stored the computed constants.  */\n+      if (src_str\n+\t  && GET_CODE (len_rtx) == CONST_INT\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n+\t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n+\t\t\t\t  (PTR) src_str, dest_align))\n+\t{\n+\t  dest_mem = get_memory_rtx (dest);\n+\t  set_mem_align (dest_mem, dest_align);\n+\t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n+\t\t\t\t      builtin_memcpy_read_str,\n+\t\t\t\t      (PTR) src_str, dest_align, endp);\n+\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t  if (GET_MODE (dest_mem) != ptr_mode)\n+\t    dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+#endif\n+\t  return dest_mem;\n \t}\n \n-      return expand_builtin_memcpy (arglist, target, mode, /*endp=*/1);\n+      if (GET_CODE (len_rtx) == CONST_INT\n+\t  && can_move_by_pieces (INTVAL (len_rtx),\n+\t\t\t\t MIN (dest_align, src_align)))\n+\t{\n+\t  dest_mem = get_memory_rtx (dest);\n+\t  set_mem_align (dest_mem, dest_align);\n+\t  src_mem = get_memory_rtx (src);\n+\t  set_mem_align (src_mem, src_align);\n+\t  dest_mem = move_by_pieces (dest_mem, src_mem, INTVAL (len_rtx),\n+\t\t\t\t     MIN (dest_align, src_align), endp);\n+\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t  if (GET_MODE (dest_mem) != ptr_mode)\n+\t    dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+#endif\n+\t  return dest_mem;\n+\t}\n+\n+      return 0;\n     }\n }\n \n@@ -2563,21 +2596,15 @@ expand_builtin_stpcpy (arglist, target, mode)\n       /* If return value is ignored, transform stpcpy into strcpy.  */\n       if (target == const0_rtx)\n \t{\n-\t  tree fn;\n-\t  rtx ret = expand_builtin_strcpy (arglist, target, mode);\n-\n-\t  if (ret)\n-\t    return ret;\n-\n-\t  fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+\t  tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n \t  if (!fn)\n \t    return 0;\n \n \t  return expand_expr (build_function_call_expr (fn, arglist),\n \t\t\t      target, mode, EXPAND_NORMAL);\n \t}\n \n-      /* Ensure we get an actual string who length can be evaluated at\n+      /* Ensure we get an actual string whose length can be evaluated at\n          compile-time, not an expression containing a string.  This is\n          because the latter will potentially produce pessimized code\n          when used to produce the return value.  */\n@@ -2588,7 +2615,7 @@ expand_builtin_stpcpy (arglist, target, mode)\n       len = fold (size_binop (PLUS_EXPR, len, ssize_int (1)));\n       newarglist = copy_list (arglist);\n       chainon (newarglist, build_tree_list (NULL_TREE, len));\n-      return expand_builtin_memcpy (newarglist, target, mode, /*endp=*/2);\n+      return expand_builtin_mempcpy (newarglist, target, mode, /*endp=*/2);\n     }\n }\n \n@@ -2670,7 +2697,7 @@ expand_builtin_strncpy (arglist, target, mode)\n \t  dest_mem = get_memory_rtx (dest);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_strncpy_read_str,\n-\t\t\t   (PTR) p, dest_align);\n+\t\t\t   (PTR) p, dest_align, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (GET_MODE (dest_mem) != ptr_mode)\n@@ -2798,7 +2825,7 @@ expand_builtin_memset (arglist, target, mode)\n \t  dest_mem = get_memory_rtx (dest);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_memset_gen_str,\n-\t\t\t   (PTR) val_rtx, dest_align);\n+\t\t\t   (PTR) val_rtx, dest_align, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (GET_MODE (dest_mem) != ptr_mode)\n@@ -2822,7 +2849,7 @@ expand_builtin_memset (arglist, target, mode)\n \t  dest_mem = get_memory_rtx (dest);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_memset_read_str,\n-\t\t\t   (PTR) &c, dest_align);\n+\t\t\t   (PTR) &c, dest_align, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (GET_MODE (dest_mem) != ptr_mode)\n@@ -4698,13 +4725,13 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       break;\n \n     case BUILT_IN_MEMCPY:\n-      target = expand_builtin_memcpy (arglist, target, mode, /*endp=*/0);\n+      target = expand_builtin_memcpy (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n \n     case BUILT_IN_MEMPCPY:\n-      target = expand_builtin_mempcpy (arglist, target, mode);\n+      target = expand_builtin_mempcpy (arglist, target, mode, /*endp=*/ 1);\n       if (target)\n \treturn target;\n       break;"}, {"sha": "0b216105e0aeeeb75e55bcebc053d804f37614e5", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -3821,7 +3821,7 @@ expand_block_move (operands)\n \n   else if (constp && bytes <= (unsigned)2 * MAX_MOVE_BYTES\n \t   && align == (unsigned) UNITS_PER_WORD)\n-    move_by_pieces (orig_dest, orig_src, bytes, align * BITS_PER_WORD);\n+    move_by_pieces (orig_dest, orig_src, bytes, align * BITS_PER_WORD, 0);\n \n   else if (constp && bytes <= (unsigned)2 * MAX_MOVE_BYTES)\n     emit_insn (gen_movstrsi_internal (replace_equiv_address (orig_dest,"}, {"sha": "f340335515b8443a747ed67653d8a3d96c567c6e", "filename": "gcc/expr.c", "status": "modified", "additions": 89, "deletions": 9, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -1456,20 +1456,37 @@ convert_modes (mode, oldmode, x, unsignedp)\n \n #define STORE_MAX_PIECES  MIN (MOVE_MAX_PIECES, 2 * sizeof (HOST_WIDE_INT))\n \n+/* Determine whether the LEN bytes can be moved by using several move\n+   instructions.  Return nonzero if a call to move_by_pieces should\n+   succeed.  */\n+\n+int\n+can_move_by_pieces (len, align)\n+     unsigned HOST_WIDE_INT len;\n+     unsigned int align;\n+{\n+  return MOVE_BY_PIECES_P (len, align);\n+}\n+\n /* Generate several move instructions to copy LEN bytes from block FROM to\n    block TO.  (These are MEM rtx's with BLKmode).  The caller must pass FROM\n    and TO through protect_from_queue before calling.\n \n    If PUSH_ROUNDING is defined and TO is NULL, emit_single_push_insn is\n    used to push FROM to the stack.\n \n-   ALIGN is maximum stack alignment we can assume.  */\n+   ALIGN is maximum stack alignment we can assume.\n \n-void\n-move_by_pieces (to, from, len, align)\n+   If ENDP is 0 return to, if ENDP is 1 return memory at the end ala\n+   mempcpy, and if ENDP is 2 return memory the end minus one byte ala\n+   stpcpy.  */\n+\n+rtx\n+move_by_pieces (to, from, len, align, endp)\n      rtx to, from;\n      unsigned HOST_WIDE_INT len;\n      unsigned int align;\n+     int endp;\n {\n   struct move_by_pieces data;\n   rtx to_addr, from_addr = XEXP (from, 0);\n@@ -1583,6 +1600,36 @@ move_by_pieces (to, from, len, align)\n   /* The code above should have handled everything.  */\n   if (data.len > 0)\n     abort ();\n+\n+  if (endp)\n+    {\n+      rtx to1;\n+\n+      if (data.reverse)\n+\tabort ();\n+      if (data.autinc_to)\n+\t{\n+\t  if (endp == 2)\n+\t    {\n+\t      if (HAVE_POST_INCREMENT && data.explicit_inc_to > 0)\n+\t\temit_insn (gen_add2_insn (data.to_addr, constm1_rtx));\n+\t      else\n+\t\tdata.to_addr = copy_addr_to_reg (plus_constant (data.to_addr,\n+\t\t\t\t\t\t\t\t-1));\n+\t    }\n+\t  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,\n+\t\t\t\t\t   data.offset);\n+\t}\n+      else\n+\t{\n+\t  if (endp == 2)\n+\t    --data.offset;\n+\t  to1 = adjust_address (data.to, QImode, data.offset);\n+\t}\n+      return to1;\n+    }\n+  else\n+    return data.to;\n }\n \n /* Return number of insns required to move L bytes by pieces.\n@@ -1760,7 +1807,7 @@ emit_block_move (x, y, size, method)\n     }\n \n   if (GET_CODE (size) == CONST_INT && MOVE_BY_PIECES_P (INTVAL (size), align))\n-    move_by_pieces (x, y, INTVAL (size), align);\n+    move_by_pieces (x, y, INTVAL (size), align, 0);\n   else if (emit_block_move_via_movstr (x, y, size, align))\n     ;\n   else if (may_use_call)\n@@ -2014,7 +2061,7 @@ init_block_move_fn (asmspec)\n {\n   if (!block_move_fn)\n     {\n-      tree fn, args;\n+      tree args, fn;\n \n       if (TARGET_MEM_FUNCTIONS)\n \t{\n@@ -2738,15 +2785,19 @@ can_store_by_pieces (len, constfun, constfundata, align)\n /* Generate several move instructions to store LEN bytes generated by\n    CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n    pointer which will be passed as argument in every CONSTFUN call.\n-   ALIGN is maximum alignment we can assume.  */\n+   ALIGN is maximum alignment we can assume.\n+   If ENDP is 0 return to, if ENDP is 1 return memory at the end ala\n+   mempcpy, and if ENDP is 2 return memory the end minus one byte ala\n+   stpcpy.  */\n \n-void\n-store_by_pieces (to, len, constfun, constfundata, align)\n+rtx\n+store_by_pieces (to, len, constfun, constfundata, align, endp)\n      rtx to;\n      unsigned HOST_WIDE_INT len;\n      rtx (*constfun) PARAMS ((PTR, HOST_WIDE_INT, enum machine_mode));\n      PTR constfundata;\n      unsigned int align;\n+     int endp;\n {\n   struct store_by_pieces data;\n \n@@ -2758,6 +2809,35 @@ store_by_pieces (to, len, constfun, constfundata, align)\n   data.len = len;\n   data.to = to;\n   store_by_pieces_1 (&data, align);\n+  if (endp)\n+    {\n+      rtx to1;\n+\n+      if (data.reverse)\n+\tabort ();\n+      if (data.autinc_to)\n+\t{\n+\t  if (endp == 2)\n+\t    {\n+\t      if (HAVE_POST_INCREMENT && data.explicit_inc_to > 0)\n+\t\temit_insn (gen_add2_insn (data.to_addr, constm1_rtx));\n+\t      else\n+\t\tdata.to_addr = copy_addr_to_reg (plus_constant (data.to_addr,\n+\t\t\t\t\t\t\t\t-1));\n+\t    }\n+\t  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,\n+\t\t\t\t\t   data.offset);\n+\t}\n+      else\n+\t{\n+\t  if (endp == 2)\n+\t    --data.offset;\n+\t  to1 = adjust_address (data.to, QImode, data.offset);\n+\t}\n+      return to1;\n+    }\n+  else\n+    return data.to;\n }\n \n /* Generate several move instructions to clear LEN bytes of block TO.  (A MEM\n@@ -3872,7 +3952,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      && where_pad != none && where_pad != stack_direction)\n \t    anti_adjust_stack (GEN_INT (extra));\n \n-\t  move_by_pieces (NULL, xinner, INTVAL (size) - used, align);\n+\t  move_by_pieces (NULL, xinner, INTVAL (size) - used, align, 0);\n \t}\n       else\n #endif /* PUSH_ROUNDING  */"}, {"sha": "8cf5a8e5a6cf4030f39b2f44e92dba5a1b90d203", "filename": "gcc/expr.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -450,6 +450,11 @@ extern void use_group_regs PARAMS ((rtx *, rtx));\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n extern rtx clear_storage PARAMS ((rtx, rtx));\n \n+/* Determine whether the LEN bytes can be moved by using several move\n+   instructions.  Return nonzero if a call to move_by_pieces should\n+   succeed.  */\n+extern int can_move_by_pieces PARAMS ((unsigned HOST_WIDE_INT, unsigned int));\n+\n /* Return nonzero if it is desirable to store LEN bytes generated by\n    CONSTFUN with several move instructions by store_by_pieces\n    function.  CONSTFUNDATA is a pointer which will be passed as argument\n@@ -463,11 +468,12 @@ extern int can_store_by_pieces PARAMS ((unsigned HOST_WIDE_INT,\n /* Generate several move instructions to store LEN bytes generated by\n    CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n    pointer which will be passed as argument in every CONSTFUN call.\n-   ALIGN is maximum alignment we can assume.  */\n-extern void store_by_pieces PARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t     rtx (*) (PTR, HOST_WIDE_INT,\n-\t\t\t\t\t      enum machine_mode),\n-\t\t\t\t     PTR, unsigned int));\n+   ALIGN is maximum alignment we can assume.\n+   Returns TO + LEN.  */\n+extern rtx store_by_pieces PARAMS ((rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t    rtx (*) (PTR, HOST_WIDE_INT,\n+\t\t\t\t\t     enum machine_mode),\n+\t\t\t\t    PTR, unsigned int, int));\n \n /* Emit insns to set X from Y.  */\n extern rtx emit_move_insn PARAMS ((rtx, rtx));"}, {"sha": "8a76fe2a2675676a6ab13eeec087d81fd4688f57", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -2141,9 +2141,9 @@ extern void emit_jump\t\t\tPARAMS ((rtx));\n extern int preserve_subexpressions_p\tPARAMS ((void));\n \n /* In expr.c */\n-extern void move_by_pieces\t\tPARAMS ((rtx, rtx,\n+extern rtx move_by_pieces\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned int));\n+\t\t\t\t\t\t unsigned int, int));\n \n /* In flow.c */\n extern void recompute_reg_usage\t\t\tPARAMS ((rtx, int));"}, {"sha": "5ab4e9a780709640a83598cbfe8da7e799a28d54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -1,3 +1,10 @@\n+2003-06-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/builtins/string-4.c (main_test): Remove\n+\tmempcpy test with post-increments.\n+\t* gcc.c-torture/execute/string-opt-3.c: New test.\n+\t* gcc.dg/string-opt-1.c: New test.\n+\n 2003-06-03  David Billinghurst (David.Billinghurst@riotinto.com)\n \n \tPR fortran/10965"}, {"sha": "0d0544e3de2e6b86c428a2c692be61e8d0fabc30", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/string-4.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstring-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstring-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstring-4.c?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -23,7 +23,6 @@ void\n main_test (void)\n {\n   int i;\n-  const char *s;\n \n   if (stpcpy (p, \"abcde\") != p + 5 || memcmp (p, \"abcde\", 6))\n     abort ();\n@@ -47,9 +46,8 @@ main_test (void)\n   if (stpcpy ((i++, p + 20 + 1), \"23\") != (p + 20 + 1 + 2) || i != 9 || memcmp (p + 20, \"q23\\0u\", 6))\n     abort ();\n \n-  s = s1; i = 3;\n   memcpy (p + 25, \"QRSTU\", 6);\n-  if (mempcpy (p + 25 + 1, s++, i++) != (p + 25 + 1 + 3) || i != 4 || s != s1 + 1 || memcmp (p + 25, \"Q123U\", 6))\n+  if (mempcpy (p + 25 + 1, s1, 3) != (p + 25 + 1 + 3) || memcmp (p + 25, \"Q123U\", 6))\n     abort ();\n \n   if (stpcpy (stpcpy (p, \"ABCD\"), \"EFG\") != p + 7 || memcmp (p, \"ABCDEFG\", 8))"}, {"sha": "71a41cdbf4ec8c7609d50419eb157d53f95c95f4", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-3.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-3.c?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -0,0 +1,166 @@\n+/* Copyright (C) 2003  Free Software Foundation.\n+\n+   Ensure that builtin mempcpy and stpcpy perform correctly.\n+\n+   Written by Jakub Jelinek, 21/05/2003.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern void *mempcpy (void *, const void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+extern char *stpcpy (char *, const char *);\n+\n+long buf1[64];\n+char *buf2 = (char *) (buf1 + 32);\n+long buf5[20];\n+char buf7[20];\n+\n+int\n+__attribute__((noinline))\n+test (long *buf3, char *buf4, char *buf6, int n)\n+{\n+  int i = 0;\n+\n+  /* These should probably be handled by store_by_pieces on most arches.  */\n+  if (mempcpy (buf1, \"ABCDEFGHI\", 9) != (char *) buf1 + 9\n+      || memcmp (buf1, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (mempcpy (buf1, \"abcdefghijklmnopq\", 17) != (char *) buf1 + 17\n+      || memcmp (buf1, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf3, \"ABCDEF\", 6) != (char *) buf1 + 6\n+      || memcmp (buf1, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf3, \"a\", 1) != (char *) buf1 + 1\n+      || memcmp (buf1, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy ((char *) buf3 + 2, \"bcd\" + ++i, 2) != (char *) buf1 + 4\n+      || memcmp (buf1, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 1)\n+    abort ();\n+\n+  /* These should probably be handled by move_by_pieces on most arches.  */\n+  if (mempcpy ((char *) buf3 + 4, buf5, 6) != (char *) buf1 + 10\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy ((char *) buf1 + ++i + 8, (char *) buf5 + 1, 1)\n+      != (char *) buf1 + 11\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  if (mempcpy ((char *) buf3 + 14, buf6, 2) != (char *) buf1 + 16\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy (buf3, buf5, 8) != (char *) buf1 + 8\n+      || memcmp (buf1, \"RSTUVWXYVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy (buf3, buf5, 17) != (char *) buf1 + 17\n+      || memcmp (buf1, \"RSTUVWXYZ01234567\\0\", 19))\n+    abort ();\n+\n+  __builtin_memcpy (buf3, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movstrendM or mempcpy\n+     call.  */\n+  if (mempcpy ((char *) buf3 + 4, buf5, n + 6) != (char *) buf1 + 10\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy ((char *) buf1 + ++i + 8, (char *) buf5 + 1, n + 1)\n+      != (char *) buf1 + 12\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (mempcpy ((char *) buf3 + 14, buf6, n + 2) != (char *) buf1 + 16\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  i = 1;\n+\n+  /* These might be handled by store_by_pieces.  */\n+  if (mempcpy (buf2, \"ABCDEFGHI\", 9) != buf2 + 9\n+      || memcmp (buf2, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (mempcpy (buf2, \"abcdefghijklmnopq\", 17) != buf2 + 17\n+      || memcmp (buf2, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf4, \"ABCDEF\", 6) != buf2 + 6\n+      || memcmp (buf2, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf4, \"a\", 1) != buf2 + 1\n+      || memcmp (buf2, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy (buf4 + 2, \"bcd\" + i++, 2) != buf2 + 4\n+      || memcmp (buf2, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  /* These might be handled by move_by_pieces.  */\n+  if (mempcpy (buf4 + 4, buf7, 6) != buf2 + 10\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf2 + i++ + 8, buf7 + 1, 1)\n+      != buf2 + 11\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (mempcpy (buf4 + 14, buf6, 2) != buf2 + 16\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  __builtin_memcpy (buf4, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movstrendM or mempcpy\n+     call.  */\n+  if (mempcpy (buf4 + 4, buf7, n + 6) != buf2 + 10\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf2 + i++ + 8, buf7 + 1, n + 1)\n+      != buf2 + 12\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 4)\n+    abort ();\n+\n+  if (mempcpy (buf4 + 14, buf6, n + 2) != buf2 + 16\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  /* Now stpcpy tests.  */\n+  if (stpcpy ((char *) buf3, \"abcdefghijklmnop\") != (char *) buf1 + 16\n+      || memcmp (buf1, \"abcdefghijklmnop\", 17))\n+    abort ();\n+\n+  if (__builtin_stpcpy ((char *) buf3, \"ABCDEFG\") != (char *) buf1 + 7\n+      || memcmp (buf1, \"ABCDEFG\\0ijklmnop\", 17))\n+    abort ();\n+\n+  if (stpcpy ((char *) buf3 + i++, \"x\") != (char *) buf1 + 5\n+      || memcmp (buf1, \"ABCDx\\0G\\0ijklmnop\", 17))\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  __builtin_memcpy (buf5, \"RSTUVWXYZ0123456789\", 20);\n+  __builtin_memcpy (buf7, \"RSTUVWXYZ0123456789\", 20);\n+  return test (buf1, buf2, \"rstuvwxyz\", 0);\n+}"}, {"sha": "bc0f30098fa1fc4225d0bb3230f5e59f7a8fa738", "filename": "gcc/testsuite/gcc.dg/string-opt-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd3cf4e17c97036b4f9cecbe2f438a2da920351/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c?ref=8fd3cf4e17c97036b4f9cecbe2f438a2da920351", "patch": "@@ -0,0 +1,11 @@\n+/* Ensure mempcpy is not \"optimized\" into memcpy followed by addition.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void *\n+fn (char *x, char *y, int z)\n+{\n+  return __builtin_mempcpy (x, y, z);\n+}\n+\n+/* { dg-final { scan-assembler-not \"memcpy\" } } */"}]}