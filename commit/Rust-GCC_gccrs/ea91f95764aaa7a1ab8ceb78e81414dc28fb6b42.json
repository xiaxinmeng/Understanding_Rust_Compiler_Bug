{"sha": "ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5MWY5NTc2NGFhYTdhMWFiOGNlYjc4ZTgxNDE0ZGMyOGZiNmI0Mg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-05-18T01:31:20Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-05-18T01:31:20Z"}, "message": "re PR middle-end/31796 (Evaluate remquo/remainder/drem at compile-time)\n\n\tPR middle-end/31796\n\t* builtins.c (do_mpfr_remquo): New.\n\t(fold_builtin_2): Handle BUILT_IN_DREM/BUILT_IN_REMAINDER.\n\t(fold_builtin_3): Handle BUILT_IN_REMQUO.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-math-2.c: Add tests for remquo, remainder\n\tand drem.\n\t* gcc.dg/torture/builtin-math-4.c: Likewise.\n\nFrom-SVN: r124820", "tree": {"sha": "d397abaa47309791779548be5eedc00901d236bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d397abaa47309791779548be5eedc00901d236bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/comments", "author": null, "committer": null, "parents": [{"sha": "fd2ef596b5fe6bfdf10bed1c8a4b4100d8a0772a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2ef596b5fe6bfdf10bed1c8a4b4100d8a0772a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2ef596b5fe6bfdf10bed1c8a4b4100d8a0772a"}], "stats": {"total": 240, "additions": 240, "deletions": 0}, "files": [{"sha": "a7b9b0ce82573b6c33c7f15b9027921d6cce8951", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "patch": "@@ -1,5 +1,10 @@\n 2007-05-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n+\tPR middle-end/31796\n+\t* builtins.c (do_mpfr_remquo): New.\n+\t(fold_builtin_2): Handle BUILT_IN_DREM/BUILT_IN_REMAINDER.\n+\t(fold_builtin_3): Handle BUILT_IN_REMQUO.\n+\n \tPR middle-end/30251\n \t* builtins.c (fold_builtin_1): Handle y0, y1.\n \t(fold_builtin_2): Handle yn."}, {"sha": "96c1c032fa0f672542374187a29f505a91c26ed9", "filename": "gcc/builtins.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "patch": "@@ -235,6 +235,7 @@ static tree do_mpfr_sincos (tree, tree, tree);\n static tree do_mpfr_bessel_n (tree, tree, tree,\n \t\t\t      int (*)(mpfr_ptr, long, mpfr_srcptr, mp_rnd_t),\n \t\t\t      const REAL_VALUE_TYPE *, bool);\n+static tree do_mpfr_remquo (tree, tree, tree);\n #endif\n \n /* Return true if NODE should be considered for inline expansion regardless\n@@ -9920,6 +9921,13 @@ fold_builtin_2 (tree fndecl, tree arg0, tree arg1, bool ignore)\n \treturn do_mpfr_bessel_n (arg0, arg1, type, mpfr_yn,\n \t\t\t\t &dconst0, false);\n     break;\n+\n+    CASE_FLT_FN (BUILT_IN_DREM):\n+    CASE_FLT_FN (BUILT_IN_REMAINDER):\n+      if (validate_arg (arg0, REAL_TYPE)\n+          && validate_arg(arg1, REAL_TYPE))\n+        return do_mpfr_arg2 (arg0, arg1, type, mpfr_remainder);\n+    break;\n #endif\n \n     CASE_FLT_FN (BUILT_IN_ATAN2):\n@@ -10077,6 +10085,15 @@ fold_builtin_3 (tree fndecl, tree arg0, tree arg1, tree arg2, bool ignore)\n \treturn do_mpfr_arg3 (arg0, arg1, arg2, type, mpfr_fma);\n     break;\n \n+#if MPFR_VERSION >= MPFR_VERSION_NUM(2,3,0)\n+    CASE_FLT_FN (BUILT_IN_REMQUO):\n+      if (validate_arg (arg0, REAL_TYPE)\n+\t  && validate_arg(arg1, REAL_TYPE)\n+\t  && validate_arg(arg2, POINTER_TYPE))\n+\treturn do_mpfr_remquo (arg0, arg1, arg2);\n+    break;\n+#endif\n+\n     case BUILT_IN_MEMSET:\n       return fold_builtin_memset (arg0, arg1, arg2, type, ignore);\n \n@@ -12596,4 +12613,76 @@ do_mpfr_bessel_n (tree arg1, tree arg2, tree type,\n   \n   return result;\n }\n+\n+/* If arguments ARG0 and ARG1 are REAL_CSTs, call mpfr_remquo() to set\n+   the pointer *(ARG_QUO) and return the result.  The type is taken\n+   from the type of ARG0 and is used for setting the precision of the\n+   calculation and results.  */\n+\n+static tree\n+do_mpfr_remquo (tree arg0, tree arg1, tree arg_quo)\n+{\n+  tree const type = TREE_TYPE (arg0);\n+  tree result = NULL_TREE;\n+  \n+  STRIP_NOPS (arg0);\n+  STRIP_NOPS (arg1);\n+  \n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n+      && TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0)\n+      && TREE_CODE (arg1) == REAL_CST && !TREE_OVERFLOW (arg1))\n+    {\n+      const REAL_VALUE_TYPE *const ra0 = TREE_REAL_CST_PTR (arg0);\n+      const REAL_VALUE_TYPE *const ra1 = TREE_REAL_CST_PTR (arg1);\n+\n+      if (!real_isnan (ra0) && !real_isinf (ra0)\n+\t  && !real_isnan (ra1) && !real_isinf (ra1))\n+        {\n+\t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n+\t  tree result_rem;\n+\t  long integer_quo;\n+\t  mpfr_t m0, m1;\n+\n+\t  mpfr_inits2 (prec, m0, m1, NULL);\n+\t  mpfr_from_real (m0, ra0, GMP_RNDN);\n+\t  mpfr_from_real (m1, ra1, GMP_RNDN);\n+\t  mpfr_clear_flags ();\n+\t  mpfr_remquo (m0, &integer_quo, m0, m1, GMP_RNDN);\n+\t  /* Remquo is independent of the rounding mode, so pass\n+\t     inexact=0 to do_mpfr_ckconv().  */\n+\t  result_rem = do_mpfr_ckconv (m0, type, /*inexact=*/ 0);\n+\t  mpfr_clears (m0, m1, NULL);\n+\t  if (result_rem)\n+\t    {\n+\t      /* MPFR calculates quo in the host's long so it may\n+\t\t return more bits in quo than the target int can hold\n+\t\t if sizeof(host long) > sizeof(target int).  This can\n+\t\t happen even for native compilers in LP64 mode.  In\n+\t\t these cases, modulo the quo value with the largest\n+\t\t number that the target int can hold while leaving one\n+\t\t bit for the sign.  */\n+\t      if (sizeof (integer_quo) * CHAR_BIT > INT_TYPE_SIZE)\n+\t\tinteger_quo %= (long)(1UL << (INT_TYPE_SIZE - 1));\n+\n+\t      /* Dereference the quo pointer argument.  */\n+\t      arg_quo = build_fold_indirect_ref (arg_quo);\n+\t      /* Proceed iff a valid pointer type was passed in.  */\n+\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (arg_quo)) == integer_type_node)\n+\t        {\n+\t\t  /* Set the value. */\n+\t\t  tree result_quo = fold_build2 (MODIFY_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (arg_quo), arg_quo,\n+\t\t\t\t\t\t build_int_cst (NULL, integer_quo));\n+\t\t  TREE_SIDE_EFFECTS (result_quo) = 1;\n+\t\t  /* Combine the quo assignment with the rem.  */\n+\t\t  result = non_lvalue (fold_build2 (COMPOUND_EXPR, type,\n+\t\t\t\t\t\t    result_quo, result_rem));\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return result;\n+}\n #endif"}, {"sha": "c0f4b6742f6e9e51788cc1c3a585e4ea43fe96dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "patch": "@@ -1,5 +1,9 @@\n 2007-05-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n+\t* gcc.dg/torture/builtin-math-2.c: Add tests for remquo, remainder\n+\tand drem.\n+\t* gcc.dg/torture/builtin-math-4.c: Likewise.\n+\n \t* gcc.dg/torture/builtin-math-2.c: Test y0, y1, yn.\n \t* gcc.dg/torture/builtin-math-4.c: Likewise.\n "}, {"sha": "81608b8789345a18cd4c71581c8ed4db0c1fb08c", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-2.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c?ref=ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "patch": "@@ -42,6 +42,13 @@ extern void fool (long double);\n   fool (__builtin_##FUNC##l (ARG1##L, ARG2)); \\\n } while (0)\n \n+#define TESTIT_REMQUO(ARG1, ARG2) do { \\\n+  int quo; \\\n+  foof (__builtin_remquof (ARG1##F, ARG2##F, &quo)); \\\n+  foo (__builtin_remquo (ARG1, ARG2, &quo)); \\\n+  fool (__builtin_remquol (ARG1##L, ARG2##L, &quo)); \\\n+} while (0)\n+\n void bar()\n {\n   /* An argument of NaN is not evaluated at compile-time.  */\n@@ -252,6 +259,13 @@ void bar()\n   TESTIT2_I1 (yn, -3, 0.0);\n   TESTIT2_I1 (yn, -3, -0.0);\n \n+  /* The second argument of remquo/remainder/drem must not be 0.  */\n+  TESTIT_REMQUO (1.0, 0.0);\n+  TESTIT_REMQUO (1.0, -0.0);\n+  TESTIT2 (remainder, 1.0, 0.0);\n+  TESTIT2 (remainder, 1.0, -0.0);\n+  TESTIT2 (drem, 1.0, 0.0);\n+  TESTIT2 (drem, 1.0, -0.0);\n }\n \n /* { dg-final { scan-tree-dump-times \"exp2 \" 9 \"original\" } } */\n@@ -317,4 +331,13 @@ void bar()\n /* { dg-final { scan-tree-dump-times \"yn \" 6 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"ynf\" 6 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"ynl\" 6 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"remquo \" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"remquof\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"remquol\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"remainder \" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"remainderf\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"remainderl\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"drem \" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"dremf\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"dreml\" 2 \"original\" } } */\n /* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "e91f14c822070ad667d5533578c822ef0a5b765d", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-4.c", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-4.c?ref=ea91f95764aaa7a1ab8ceb78e81414dc28fb6b42", "patch": "@@ -71,8 +71,44 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   } while (0)\n \n+/* Test that remquo(ARG0, ARG1, &ARG_Q) == RES and ARG_Q == RES_Q.\n+   Also test remainder/drem (ARG0,ARG1) == RES.  */\n+#define TESTIT2_REMQUO(ARG0,ARG1,ARG_Q,RES,RES_Q) do { \\\n+  ARG_Q = 12345; \\\n+  if (__builtin_remquof(ARG0##F, ARG1##F, &ARG_Q) != RES##F \\\n+      || CKSGN_F(__builtin_remquof(ARG0##F, ARG1##F, &ARG_Q),RES##F) \\\n+      || ARG_Q != RES_Q \\\n+      || __builtin_remainderf(ARG0##F, ARG1##F) != RES##F \\\n+      || CKSGN_F(__builtin_remainderf(ARG0##F, ARG1##F),RES##F) \\\n+      || __builtin_dremf(ARG0##F, ARG1##F) != RES##F \\\n+      || CKSGN_F(__builtin_dremf(ARG0##F, ARG1##F),RES##F)) \\\n+    link_error(__LINE__); \\\n+  ARG_Q = 12345; \\\n+  if (__builtin_remquo(ARG0, ARG1, &ARG_Q) != RES \\\n+      || CKSGN(__builtin_remquo(ARG0, ARG1, &ARG_Q),RES) \\\n+      || ARG_Q != RES_Q \\\n+      || __builtin_remainder(ARG0, ARG1) != RES \\\n+      || CKSGN(__builtin_remainder(ARG0, ARG1),RES) \\\n+      || __builtin_drem(ARG0, ARG1) != RES \\\n+      || CKSGN(__builtin_drem(ARG0, ARG1),RES)) \\\n+    link_error(__LINE__); \\\n+  ARG_Q = 12345; \\\n+  if (__builtin_remquol(ARG0##L, ARG1##L, &ARG_Q) != RES##L \\\n+      || CKSGN_L(__builtin_remquol(ARG0##L, ARG1##L, &ARG_Q),RES##L) \\\n+      || ARG_Q != RES_Q \\\n+      || __builtin_remainderl(ARG0##L, ARG1##L) != RES##L \\\n+      || CKSGN_L(__builtin_remainderl(ARG0##L, ARG1##L),RES##L) \\\n+      || __builtin_dreml(ARG0##L, ARG1##L) != RES##L \\\n+      || CKSGN_L(__builtin_dreml(ARG0##L, ARG1##L),RES##L)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n int main (void)\n {\n+#ifdef __OPTIMIZE__\n+  int q;\n+#endif\n+\n   TESTIT (j0, 0.0, 1.0); /* j0(0) == 1 */\n   TESTIT (j0, -0.0, 1.0); /* j0(-0) == 1 */\n   TESTIT_R (j0, 1.0, 0.765, 0.766); /* j0(1) == 0.7651... */\n@@ -131,6 +167,89 @@ int main (void)\n   TESTIT2_R (yn, 3, 0.89, -8.03, -8.02); /* yn(3,0.89) == -8.020... */\n   TESTIT2_R (yn, -3, 8.0, -0.03, -0.02); /* yn(-3,8) == -0.026... */\n   TESTIT2_R (yn, -3, 0.99, 5.98, 5.99); /* yn(-3,0.99) == 5.982... */\n+\n+#ifdef __OPTIMIZE__\n+  /* These tests rely on propagating the variable q, which happens\n+     only when optimization is turned on.  This macro also tests\n+     remainder/drem.  */\n+  TESTIT2_REMQUO (0.0, 1.0, q, 0.0, 0); /* remquo(0,1,&q)==0, q==0 */\n+  TESTIT2_REMQUO (1.0, 1.0, q, 0.0, 1); /* remquo(1,1,&q)==0, q==1 */\n+  TESTIT2_REMQUO (2.0, 1.0, q, 0.0, 2); /* remquo(2,1,&q)==0, q==2 */\n+  TESTIT2_REMQUO (-0.0, 1.0, q, -0.0, 0); /* remquo(-0,1,&q)==-0, q==0 */\n+  TESTIT2_REMQUO (-1.0, 1.0, q, -0.0, -1); /* remquo(-1,1,&q)==-0, q==-1 */\n+  TESTIT2_REMQUO (-2.0, 1.0, q, -0.0, -2); /* remquo(-2,1,&q)==-0, q==-2 */\n+\n+  TESTIT2_REMQUO (0.0, -1.0, q, 0.0, 0); /* remquo(0,-1,&q)==0, q==0 */\n+  TESTIT2_REMQUO (1.0, -1.0, q, 0.0, -1); /* remquo(1,-1,&q)==0, q==-1 */\n+  TESTIT2_REMQUO (2.0, -1.0, q, 0.0, -2); /* remquo(2,-1,&q)==0, q==-2 */\n+  TESTIT2_REMQUO (-0.0, -1.0, q, -0.0, 0); /* remquo(-0,-1,&q)==-0, q==0 */\n+  TESTIT2_REMQUO (-1.0, -1.0, q, -0.0, 1); /* remquo(-1,-1,&q)==-0, q==1 */\n+  TESTIT2_REMQUO (-2.0, -1.0, q, -0.0, 2); /* remquo(-2,-1,&q)==-0, q==2 */\n+\n+  TESTIT2_REMQUO (1.0, 2.0, q, 1.0, 0); /* remquo(1,2,&q)==1, q==0 */\n+  TESTIT2_REMQUO (3.0, 2.0, q, -1.0, 2); /* remquo(3,2,&q)==-1, q==2 */\n+  TESTIT2_REMQUO (5.0, 2.0, q, 1.0, 2); /* remquo(5,2,&q)==1, q==2 */\n+  TESTIT2_REMQUO (-1.0, 2.0, q, -1.0, 0); /* remquo(-1,2,&q)==-1, q==0 */\n+  TESTIT2_REMQUO (-3.0, 2.0, q, 1.0, -2); /* remquo(-3,2,&q)==1, q==-2 */\n+  TESTIT2_REMQUO (-5.0, 2.0, q, -1.0, -2); /* remquo(-5,2,&q)==-1, q==-2 */\n+\n+  TESTIT2_REMQUO (1.0, -2.0, q, 1.0, 0); /* remquo(1,-2,&q)==1, q==0 */\n+  TESTIT2_REMQUO (3.0, -2.0, q, -1.0, -2); /* remquo(3,-2,&q)==-1, q==-2 */\n+  TESTIT2_REMQUO (5.0, -2.0, q, 1.0, -2); /* remquo(5,-2,&q)==1, q==-2 */\n+  TESTIT2_REMQUO (-1.0, -2.0, q, -1.0, 0); /* remquo(-1,-2,&q)==-1, q==0 */\n+  TESTIT2_REMQUO (-3.0, -2.0, q, 1.0, 2); /* remquo(-3,-2,&q)==1, q==2 */\n+  TESTIT2_REMQUO (-5.0, -2.0, q, -1.0, 2); /* remquo(-5,-2,&q)==-1, q==2 */\n+\n+  /* Test that the maximum possible value can be generated into the\n+     int quotient, and check for wrap around (modulo) when that value\n+     is exceeded.  We can only check for this when the mantissa has\n+     enough bits to hold an INT_MAX value with complete precision.  */\n+\n+#define MAXIT(FUNC,X,R) do { \\\n+  q = 12345; \\\n+  if (__builtin_##FUNC((X), 1, &q) != 0 || q != (R)) \\\n+    link_error (__LINE__); \\\n+} while (0)\n   \n+  if (sizeof(int)*__CHAR_BIT__ <= __FLT_MANT_DIG__)\n+  {\n+    MAXIT(remquof, __INT_MAX__-1.0F, __INT_MAX__-1);\n+    MAXIT(remquof, __INT_MAX__+0.0F, __INT_MAX__);\n+    MAXIT(remquof, __INT_MAX__+1.0F, 0);\n+    MAXIT(remquof, __INT_MAX__+2.0F, 1);\n+\n+    MAXIT(remquof, -(__INT_MAX__-1.0F), -(__INT_MAX__-1));\n+    MAXIT(remquof, -(__INT_MAX__+0.0F), -__INT_MAX__);\n+    MAXIT(remquof, -(__INT_MAX__+1.0F), 0);\n+    MAXIT(remquof, -(__INT_MAX__+2.0F), -1);\n+  }\n+\n+  if (sizeof(int)*__CHAR_BIT__ <= __DBL_MANT_DIG__)\n+  {\n+    MAXIT(remquo, __INT_MAX__-1.0, __INT_MAX__-1);\n+    MAXIT(remquo, __INT_MAX__+0.0, __INT_MAX__);\n+    MAXIT(remquo, __INT_MAX__+1.0, 0);\n+    MAXIT(remquo, __INT_MAX__+2.0, 1);\n+\n+    MAXIT(remquo, -(__INT_MAX__-1.0), -(__INT_MAX__-1));\n+    MAXIT(remquo, -(__INT_MAX__+0.0), -__INT_MAX__);\n+    MAXIT(remquo, -(__INT_MAX__+1.0), 0);\n+    MAXIT(remquo, -(__INT_MAX__+2.0), -1);\n+  }\n+\n+  if (sizeof(int)*__CHAR_BIT__ <= __LDBL_MANT_DIG__)\n+  {\n+    MAXIT(remquo, __INT_MAX__-1.0L, __INT_MAX__-1);\n+    MAXIT(remquo, __INT_MAX__+0.0L, __INT_MAX__);\n+    MAXIT(remquo, __INT_MAX__+1.0L, 0);\n+    MAXIT(remquo, __INT_MAX__+2.0L, 1);\n+\n+    MAXIT(remquol, -(__INT_MAX__-1.0L), -(__INT_MAX__-1));\n+    MAXIT(remquol, -(__INT_MAX__+0.0L), -__INT_MAX__);\n+    MAXIT(remquol, -(__INT_MAX__+1.0L), 0);\n+    MAXIT(remquol, -(__INT_MAX__+2.0L), -1);\n+  }\n+#endif\n+\n   return 0;\n }"}]}