{"sha": "cbe87f458252d3d25288d261703d79277943848e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JlODdmNDU4MjUyZDNkMjUyODhkMjYxNzAzZDc5Mjc3OTQzODQ4ZQ==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2021-03-23T00:00:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-18T08:36:54Z"}, "message": "[Ada] Fix detection of overlapping actuals with renamings\n\ngcc/ada/\n\n\t* sem_util.adb (Denotes_Same_Object): Explicitly test for node\n\tkinds being the same; deal with renamings one-by-one; adjust\n\tnumbers in references to the Ada RM.", "tree": {"sha": "ea714794a9ff2ade9d74513246edbaaf18f367a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea714794a9ff2ade9d74513246edbaaf18f367a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbe87f458252d3d25288d261703d79277943848e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe87f458252d3d25288d261703d79277943848e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbe87f458252d3d25288d261703d79277943848e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe87f458252d3d25288d261703d79277943848e/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca5cdc9053ffe033e8ece1c4be7882c67b3f5a39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5cdc9053ffe033e8ece1c4be7882c67b3f5a39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca5cdc9053ffe033e8ece1c4be7882c67b3f5a39"}], "stats": {"total": 142, "additions": 62, "deletions": 80}, "files": [{"sha": "44a4dc21f14e2cf7f287275530559b94604421b2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 62, "deletions": 80, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe87f458252d3d25288d261703d79277943848e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe87f458252d3d25288d261703d79277943848e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=cbe87f458252d3d25288d261703d79277943848e", "patch": "@@ -7388,93 +7388,55 @@ package body Sem_Util is\n          return True;\n       end Is_Valid_Renaming;\n \n-      --  Local variables\n-\n-      Obj1 : Node_Id := A1;\n-      Obj2 : Node_Id := A2;\n-\n    --  Start of processing for Denotes_Same_Object\n \n    begin\n-      --  Both names statically denote the same stand-alone object or parameter\n-      --  (RM 6.4.1(6.5/3))\n+      --  Both names statically denote the same stand-alone object or\n+      --  parameter (RM 6.4.1(6.6/3)).\n \n-      if Is_Entity_Name (Obj1)\n-        and then Is_Entity_Name (Obj2)\n-        and then Entity (Obj1) = Entity (Obj2)\n+      if Is_Entity_Name (A1)\n+        and then Is_Entity_Name (A2)\n+        and then Entity (A1) = Entity (A2)\n       then\n          return True;\n-      end if;\n-\n-      --  For renamings, the prefix of any dereference within the renamed\n-      --  object_name is not a variable, and any expression within the\n-      --  renamed object_name contains no references to variables nor\n-      --  calls on nonstatic functions (RM 6.4.1(6.10/3)).\n-\n-      if Is_Renaming (Obj1) then\n-         if Is_Valid_Renaming (Obj1) then\n-            Obj1 := Renamed_Entity (Entity (Obj1));\n-         else\n-            return False;\n-         end if;\n-      end if;\n-\n-      if Is_Renaming (Obj2) then\n-         if Is_Valid_Renaming (Obj2) then\n-            Obj2 := Renamed_Entity (Entity (Obj2));\n-         else\n-            return False;\n-         end if;\n-      end if;\n-\n-      --  No match if not same node kind (such cases are handled by\n-      --  Denotes_Same_Prefix)\n-\n-      if Nkind (Obj1) /= Nkind (Obj2) then\n-         return False;\n-\n-      --  After handling valid renamings, one of the two names statically\n-      --  denoted a renaming declaration whose renamed object_name is known\n-      --  to denote the same object as the other (RM 6.4.1(6.10/3))\n-\n-      elsif Is_Entity_Name (Obj1) then\n-         if Is_Entity_Name (Obj2) then\n-            return Entity (Obj1) = Entity (Obj2);\n-         else\n-            return False;\n-         end if;\n \n       --  Both names are selected_components, their prefixes are known to\n       --  denote the same object, and their selector_names denote the same\n-      --  component (RM 6.4.1(6.6/3)).\n+      --  component (RM 6.4.1(6.7/3)).\n \n-      elsif Nkind (Obj1) = N_Selected_Component then\n-         return Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2))\n+      elsif Nkind (A1) = N_Selected_Component\n+        and then Nkind (A2) = N_Selected_Component\n+      then\n+         return Denotes_Same_Object (Prefix (A1), Prefix (A2))\n            and then\n-             Entity (Selector_Name (Obj1)) = Entity (Selector_Name (Obj2));\n+             Entity (Selector_Name (A1)) = Entity (Selector_Name (A2));\n \n       --  Both names are dereferences and the dereferenced names are known to\n-      --  denote the same object (RM 6.4.1(6.7/3))\n+      --  denote the same object (RM 6.4.1(6.8/3)).\n \n-      elsif Nkind (Obj1) = N_Explicit_Dereference then\n-         return Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2));\n+      elsif Nkind (A1) = N_Explicit_Dereference\n+        and then Nkind (A2) = N_Explicit_Dereference\n+      then\n+         return Denotes_Same_Object (Prefix (A1), Prefix (A2));\n \n       --  Both names are indexed_components, their prefixes are known to denote\n       --  the same object, and each of the pairs of corresponding index values\n       --  are either both static expressions with the same static value or both\n-      --  names that are known to denote the same object (RM 6.4.1(6.8/3))\n+      --  names that are known to denote the same object (RM 6.4.1(6.9/3)).\n \n-      elsif Nkind (Obj1) = N_Indexed_Component then\n-         if not Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2)) then\n+      elsif Nkind (A1) = N_Indexed_Component\n+        and then Nkind (A2) = N_Indexed_Component\n+      then\n+         if not Denotes_Same_Object (Prefix (A1), Prefix (A2)) then\n             return False;\n          else\n             declare\n                Indx1 : Node_Id;\n                Indx2 : Node_Id;\n \n             begin\n-               Indx1 := First (Expressions (Obj1));\n-               Indx2 := First (Expressions (Obj2));\n+               Indx1 := First (Expressions (A1));\n+               Indx2 := First (Expressions (A2));\n                while Present (Indx1) loop\n \n                   --  Indexes must denote the same static value or same object\n@@ -7501,33 +7463,53 @@ package body Sem_Util is\n \n       --  Both names are slices, their prefixes are known to denote the same\n       --  object, and the two slices have statically matching index constraints\n-      --  (RM 6.4.1(6.9/3))\n+      --  (RM 6.4.1(6.10/3)).\n \n-      elsif Nkind (Obj1) = N_Slice\n-        and then Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2))\n+      elsif Nkind (A1) = N_Slice\n+        and then Nkind (A2) = N_Slice\n       then\n-         declare\n-            Lo1, Lo2, Hi1, Hi2 : Node_Id;\n+         if not Denotes_Same_Object (Prefix (A1), Prefix (A2)) then\n+            return False;\n+         else\n+            declare\n+               Lo1, Lo2, Hi1, Hi2 : Node_Id;\n \n-         begin\n-            Get_Index_Bounds (Discrete_Range (Obj1), Lo1, Hi1);\n-            Get_Index_Bounds (Discrete_Range (Obj2), Lo2, Hi2);\n+            begin\n+               Get_Index_Bounds (Discrete_Range (A1), Lo1, Hi1);\n+               Get_Index_Bounds (Discrete_Range (A2), Lo2, Hi2);\n \n-            --  Check whether bounds are statically identical. There is no\n-            --  attempt to detect partial overlap of slices.\n+               --  Check whether bounds are statically identical. There is no\n+               --  attempt to detect partial overlap of slices.\n \n-            return Denotes_Same_Object (Lo1, Lo2)\n-                     and then\n-                   Denotes_Same_Object (Hi1, Hi2);\n-         end;\n+               return Denotes_Same_Object (Lo1, Lo2)\n+                        and then\n+                      Denotes_Same_Object (Hi1, Hi2);\n+            end;\n+         end if;\n \n-      --  In the recursion, literals appear as indexes\n+      --  One of the two names statically denotes a renaming declaration whose\n+      --  renamed object_name is known to denote the same object as the other;\n+      --  the prefix of any dereference within the renamed object_name is not a\n+      --  variable, and any expression within the renamed object_name contains\n+      --  no references to variables nor calls on nonstatic functions (RM\n+      --  6.4.1(6.11/3)).\n \n-      elsif Nkind (Obj1) = N_Integer_Literal\n-              and then\n-            Nkind (Obj2) = N_Integer_Literal\n+      elsif Is_Renaming (A1)\n+        and then Is_Valid_Renaming (A1)\n+      then\n+         return Denotes_Same_Object (Renamed_Entity (Entity (A1)), A2);\n+\n+      elsif Is_Renaming (A2)\n+        and then Is_Valid_Renaming (A2)\n+      then\n+         return Denotes_Same_Object (A1, Renamed_Entity (Entity (A2)));\n+\n+      --  In the recursion, literals appear as slice bounds\n+\n+      elsif Nkind (A1) = N_Integer_Literal\n+        and then Nkind (A2) = N_Integer_Literal\n       then\n-         return Intval (Obj1) = Intval (Obj2);\n+         return Intval (A1) = Intval (A2);\n \n       else\n          return False;"}]}