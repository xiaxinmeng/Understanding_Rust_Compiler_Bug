{"sha": "8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNhN2ZhODRhM2FmMzU1YzNlMmJiZGEyYWNjNjE5MzRjMTYwNzhiMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-23T23:27:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-23T23:27:21Z"}, "message": "analyzer: rewrite of switch handling\n\nWhen investigating false positives on the Linux kernel from\n-Wanalyzer-use-of-uninitialized-value, I noticed that the existing\nimplementation of switch statements in the analyzer is broken.\n\nSpecifically, the existing implementation assumes a 1:1 association\nbetween CFG out-edges from the basic block and case labels in the\ngimple switch statement.  This happened to be the case in the\nexamples I had tested, but there is no such association in general.\nIn particular, in the motivating example:\n  arch/x86/kernel/cpu/mtrr/if.c: mtrr_ioctl\nthe switch statement has 3 blocks, each covering multiple ranges of\nioctl command IDs for which different local variables are initialized,\nwhich the existing implementation gets badly wrong. [1]\n\nThis patch reimplements switch handling in the analyzer to eliminate\nthis false assumption - instead, for each out-edge we gather the set\nof case labels for that out-edge, and use that to determine the\nset of value ranges for the edge.  Avoiding false positives for the\nabove example requires that we accurately track value ranges for\nsymbolic values, so the patch extends constraint_manager with a new\nbounded_ranges_constraint, adding just enough information to capture the\nranges for switch statements whilst retaining combatility with the\nexisting constraint-handling (ultimately I'd prefer to simply throw\nall of this into a SAT solver and let it track things).\n\nDoing so fixes the false positives seen on the Linux kernel and an\nexisting xfail in the test suite.\n\nThe patch also fixes a long-standing bug in\nconstraint_manager::add_unknown_constraint when updating constraints\ndue to combining equivalence classes, spotted when debugging the\nsame logic for the new kind of constraints.\n\n[1] a reduced version of this code is captured in this patch, in\ngcc.dg/analyzer/torture/switch-3.c\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (struct rejected_constraint): Convert to...\n\t(class rejected_constraint): ...this.\n\t(class bounded_ranges): New forward decl.\n\t(class bounded_ranges_manager): New forward decl.\n\t* constraint-manager.cc: Include \"analyzer/analyzer-logging.h\" and\n\t\"tree-pretty-print.h\".\n\t(can_plus_one_p): New.\n\t(plus_one): New.\n\t(can_minus_one_p): New.\n\t(minus_one): New.\n\t(bounded_range::bounded_range): New.\n\t(dump_cst): New.\n\t(bounded_range::dump_to_pp): New.\n\t(bounded_range::dump): New.\n\t(bounded_range::to_json): New.\n\t(bounded_range::set_json_attr): New.\n\t(bounded_range::contains_p): New.\n\t(bounded_range::intersects_p): New.\n\t(bounded_range::operator==): New.\n\t(bounded_range::cmp): New.\n\t(bounded_ranges::bounded_ranges): New.\n\t(bounded_ranges::bounded_ranges): New.\n\t(bounded_ranges::bounded_ranges): New.\n\t(bounded_ranges::canonicalize): New.\n\t(bounded_ranges::validate): New.\n\t(bounded_ranges::operator==): New.\n\t(bounded_ranges::dump_to_pp): New.\n\t(bounded_ranges::dump): New.\n\t(bounded_ranges::to_json): New.\n\t(bounded_ranges::eval_condition): New.\n\t(bounded_ranges::contain_p): New.\n\t(bounded_ranges::cmp): New.\n\t(bounded_ranges_manager::~bounded_ranges_manager): New.\n\t(bounded_ranges_manager::get_or_create_empty): New.\n\t(bounded_ranges_manager::get_or_create_point): New.\n\t(bounded_ranges_manager::get_or_create_range): New.\n\t(bounded_ranges_manager::get_or_create_union): New.\n\t(bounded_ranges_manager::get_or_create_intersection): New.\n\t(bounded_ranges_manager::get_or_create_inverse): New.\n\t(bounded_ranges_manager::consolidate): New.\n\t(bounded_ranges_manager::get_or_create_ranges_for_switch): New.\n\t(bounded_ranges_manager::create_ranges_for_switch): New.\n\t(bounded_ranges_manager::make_case_label_ranges): New.\n\t(bounded_ranges_manager::log_stats): New.\n\t(bounded_ranges_constraint::print): New.\n\t(bounded_ranges_constraint::to_json): New.\n\t(bounded_ranges_constraint::operator==): New.\n\t(bounded_ranges_constraint::add_to_hash): New.\n\t(constraint_manager::constraint_manager): Update for new field\n\tm_bounded_ranges_constraints.\n\t(constraint_manager::operator=): Likewise.\n\t(constraint_manager::hash): Likewise.\n\t(constraint_manager::operator==): Likewise.\n\t(constraint_manager::print): Likewise.\n\t(constraint_manager::dump_to_pp): Likewise.\n\t(constraint_manager::to_json): Likewise.\n\t(constraint_manager::add_unknown_constraint): Update the lhs_ec_id\n\tif necessary in existing constraints when combining equivalence\n\tclasses.  Add similar code for handling\n\tm_bounded_ranges_constraints.\n\t(constraint_manager::add_constraint_internal): Add comment.\n\t(constraint_manager::add_bounded_ranges): New.\n\t(constraint_manager::eval_condition): Use new field\n\tm_bounded_ranges_constraints.\n\t(constraint_manager::purge): Update bounded_ranges_constraint\n\tinstances.\n\t(constraint_manager::canonicalize): Update for new field.\n\t(merger_fact_visitor::on_ranges): New.\n\t(constraint_manager::for_each_fact): Use new field\n\tm_bounded_ranges_constraints.\n\t(constraint_manager::validate):  Fix off-by-one error needed due\n\tto bug fixed above in add_unknown_constraint.  Validate the EC IDs\n\tin m_bounded_ranges_constraints.\n\t(constraint_manager::get_range_manager): New.\n\t(selftest::assert_dump_bounded_range_eq): New.\n\t(ASSERT_DUMP_BOUNDED_RANGE_EQ): New.\n\t(selftest::test_bounded_range): New.\n\t(selftest::assert_dump_bounded_ranges_eq): New.\n\t(ASSERT_DUMP_BOUNDED_RANGES_EQ): New.\n\t(selftest::test_bounded_ranges): New.\n\t(selftest::run_constraint_manager_tests): Call the new selftests.\n\t* constraint-manager.h (struct bounded_range): New.\n\t(struct bounded_ranges): New.\n\t(template <> struct default_hash_traits<bounded_ranges::key_t>): New.\n\t(class bounded_ranges_manager): New.\n\t(fact_visitor::on_ranges): New pure virtual function.\n\t(class bounded_ranges_constraint): New.\n\t(constraint_manager::add_bounded_ranges): New decl.\n\t(constraint_manager::get_range_manager): New decl.\n\t(constraint_manager::m_bounded_ranges_constraints): New field.\n\t* diagnostic-manager.cc (epath_finder::process_worklist_item):\n\tTransfer ownership of rc to add_feasibility_problem.\n\t* engine.cc (feasibility_problem::dump_to_pp): Use get_model.\n\t* feasible-graph.cc (infeasible_node::dump_dot): Update for\n\tconversion of m_rc to a pointer.\n\t(feasible_graph::add_feasibility_problem): Pass RC by pointer and\n\ttake ownership.\n\t* feasible-graph.h (infeasible_node::infeasible_node): Pass RC by\n\tpointer and take ownership.\n\t(infeasible_node::~infeasible_node): New.\n\t(infeasible_node::m_rc): Convert to a pointer.\n\t(feasible_graph::add_feasibility_problem): Pass RC by pointer and\n\ttake ownership.\n\t* region-model-manager.cc: Include\n\t\"analyzer/constraint-manager.h\".\n\t(region_model_manager::region_model_manager): Initializer new\n\tfield m_range_mgr.\n\t(region_model_manager::~region_model_manager): Delete it.\n\t(region_model_manager::log_stats): Call log_stats on it.\n\t* region-model.cc (region_model::add_constraint): Use new subclass\n\trejected_op_constraint.\n\t(region_model::apply_constraints_for_gswitch): Reimplement using\n\tbounded_ranges_manager.\n\t(rejected_constraint::dump_to_pp): Convert to...\n\t(rejected_op_constraint::dump_to_pp): ...this.\n\t(rejected_ranges_constraint::dump_to_pp): New.\n\t* region-model.h (struct purge_stats): Add field\n\tm_num_bounded_ranges_constraints.\n\t(region_model_manager::get_range_manager): New.\n\t(region_model_manager::m_range_mgr): New.\n\t(region_model::get_range_manager): New.\n\t(struct rejected_constraint): Split into...\n\t(class rejected_constraint):...this new abstract base class,\n\tand...\n\t(class rejected_op_constraint): ...this new concrete subclass.\n\t(class rejected_ranges_constraint): New.\n\t* supergraph.cc: Include \"tree-cfg.h\".\n\t(supergraph::supergraph): Drop idx param from add_cfg_edge.\n\t(supergraph::add_cfg_edge): Drop idx param.\n\t(switch_cfg_superedge::switch_cfg_superedge): Move here from\n\theader.  Populate m_case_labels with all cases which go to DST.\n\t(switch_cfg_superedge::dump_label_to_pp): Reimplement to use\n\tm_case_labels.\n\t(switch_cfg_superedge::get_case_label): Delete.\n\t* supergraph.h (supergraphadd_cfg_edge): Drop \"idx\" param.\n\t(switch_cfg_superedge::switch_cfg_superedge): Drop idx param and\n\tmove implementation to supergraph.cc.\n\t(switch_cfg_superedge::get_case_label): Delete.\n\t(switch_cfg_superedge::get_case_labels): New.\n\t(switch_cfg_superedge::m_idx): Delete.\n\t(switch_cfg_superedge::m_case_labels): New field.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/switch.c: Remove xfail.  Add various tests.\n\t* gcc.dg/analyzer/torture/switch-2.c: New test.\n\t* gcc.dg/analyzer/torture/switch-3.c: New test.\n\t* gcc.dg/analyzer/torture/switch-4.c: New test.\n\t* gcc.dg/analyzer/torture/switch-5.c: New test.", "tree": {"sha": "558b25a4a4e51f476cbb9c0cdb36baa0b0faa136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/558b25a4a4e51f476cbb9c0cdb36baa0b0faa136"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "192d4edd15cabf1f0e88e5a62142cd252542ea0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/192d4edd15cabf1f0e88e5a62142cd252542ea0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/192d4edd15cabf1f0e88e5a62142cd252542ea0c"}], "stats": {"total": 2265, "additions": 2135, "deletions": 130}, "files": [{"sha": "05d47512bd7d79f71f32c010943e41c23bcb0742", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -75,10 +75,12 @@ class region_model;\n class region_model_context;\n   class impl_region_model_context;\n class call_details;\n-struct rejected_constraint;\n+class rejected_constraint;\n class constraint_manager;\n class equiv_class;\n class reachable_regions;\n+class bounded_ranges;\n+class bounded_ranges_manager;\n \n class pending_diagnostic;\n class state_change_event;"}, {"sha": "dc65c8dd92b163056259aee3aaf8f029bd37ee6d", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 1342, "deletions": 23, "changes": 1365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -42,12 +42,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n #include \"tristate.h\"\n+#include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\"\n #include \"analyzer/analyzer-selftests.h\"\n+#include \"tree-pretty-print.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -65,6 +67,50 @@ compare_constants (tree lhs_const, enum tree_code op, tree rhs_const)\n   return tristate (tristate::TS_UNKNOWN);\n }\n \n+/* Return true iff CST is below the maximum value for its type.  */\n+\n+static bool\n+can_plus_one_p (tree cst)\n+{\n+  gcc_assert (CONSTANT_CLASS_P (cst));\n+  return tree_int_cst_lt (cst, TYPE_MAX_VALUE (TREE_TYPE (cst)));\n+}\n+\n+/* Return (CST + 1).  */\n+\n+static tree\n+plus_one (tree cst)\n+{\n+  gcc_assert (CONSTANT_CLASS_P (cst));\n+  gcc_assert (can_plus_one_p (cst));\n+  tree result = fold_build2 (PLUS_EXPR, TREE_TYPE (cst),\n+\t\t\t     cst, integer_one_node);\n+  gcc_assert (CONSTANT_CLASS_P (result));\n+  return result;\n+}\n+\n+/* Return true iff CST is above the minimum value for its type.  */\n+\n+static bool\n+can_minus_one_p (tree cst)\n+{\n+  gcc_assert (CONSTANT_CLASS_P (cst));\n+  return tree_int_cst_lt (TYPE_MIN_VALUE (TREE_TYPE (cst)), cst);\n+}\n+\n+/* Return (CST - 1).  */\n+\n+static tree\n+minus_one (tree cst)\n+{\n+  gcc_assert (CONSTANT_CLASS_P (cst));\n+  gcc_assert (can_minus_one_p (cst));\n+  tree result = fold_build2 (MINUS_EXPR, TREE_TYPE (cst),\n+\t\t\t     cst, integer_one_node);\n+  gcc_assert (CONSTANT_CLASS_P (result));\n+  return result;\n+}\n+\n /* struct bound.  */\n \n /* Ensure that this bound is closed by converting an open bound to a\n@@ -222,37 +268,709 @@ range::eval_condition (enum tree_code op, tree rhs_const) const\n \treturn tristate (tristate::TS_TRUE);\n       break;\n \n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n-  return tristate (tristate::TS_UNKNOWN);\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+  return tristate (tristate::TS_UNKNOWN);\n+}\n+\n+/* Return true if RHS_CONST is below the lower bound of this range.  */\n+\n+bool\n+range::below_lower_bound (tree rhs_const) const\n+{\n+  if (!m_lower_bound.m_constant)\n+    return false;\n+\n+  return compare_constants (rhs_const,\n+\t\t\t    m_lower_bound.m_closed ? LT_EXPR : LE_EXPR,\n+\t\t\t    m_lower_bound.m_constant).is_true ();\n+}\n+\n+/* Return true if RHS_CONST is above the upper bound of this range.  */\n+\n+bool\n+range::above_upper_bound (tree rhs_const) const\n+{\n+  if (!m_upper_bound.m_constant)\n+    return false;\n+\n+  return compare_constants (rhs_const,\n+\t\t\t    m_upper_bound.m_closed ? GT_EXPR : GE_EXPR,\n+\t\t\t    m_upper_bound.m_constant).is_true ();\n+}\n+\n+/* struct bounded_range.  */\n+\n+bounded_range::bounded_range (const_tree lower, const_tree upper)\n+: m_lower (const_cast<tree> (lower)),\n+  m_upper (const_cast<tree> (upper))\n+{\n+  if (lower && upper)\n+    {\n+      gcc_assert (TREE_CODE (m_lower) == INTEGER_CST);\n+      gcc_assert (TREE_CODE (m_upper) == INTEGER_CST);\n+      /* We should have lower <= upper.  */\n+      gcc_assert (!tree_int_cst_lt (m_upper, m_lower));\n+    }\n+  else\n+    {\n+      /* Purely for pending on-stack values, for\n+\t writing back to.  */\n+      gcc_assert (m_lower == NULL_TREE);\n+      gcc_assert (m_lower == NULL_TREE);\n+    }\n+}\n+\n+static void\n+dump_cst (pretty_printer *pp, tree cst, bool show_types)\n+{\n+  gcc_assert (cst);\n+  if (show_types)\n+    {\n+      pp_character (pp, '(');\n+      dump_generic_node (pp, TREE_TYPE (cst), 0, (dump_flags_t)0, false);\n+      pp_character (pp, ')');\n+    }\n+  dump_generic_node (pp, cst, 0, (dump_flags_t)0, false);\n+}\n+\n+/* Dump this object to PP.  */\n+\n+void\n+bounded_range::dump_to_pp (pretty_printer *pp, bool show_types) const\n+{\n+  if (tree_int_cst_equal (m_lower, m_upper))\n+    dump_cst (pp, m_lower, show_types);\n+  else\n+    {\n+      pp_character (pp, '[');\n+      dump_cst (pp, m_lower, show_types);\n+      pp_string (pp, \", \");\n+      dump_cst (pp, m_upper, show_types);\n+      pp_character (pp, ']');\n+    }\n+}\n+\n+/* Dump this object to stderr.  */\n+\n+void\n+bounded_range::dump (bool show_types) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, show_types);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+json::object *\n+bounded_range::to_json () const\n+{\n+  json::object *range_obj = new json::object ();\n+  set_json_attr (range_obj, \"lower\", m_lower);\n+  set_json_attr (range_obj, \"upper\", m_upper);\n+  return range_obj;\n+}\n+\n+/* Subroutine of bounded_range::to_json.  */\n+\n+void\n+bounded_range::set_json_attr (json::object *obj, const char *name, tree value)\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_printf (&pp, \"%E\", value);\n+  obj->set (name, new json::string (pp_formatted_text (&pp)));\n+}\n+\n+\n+/* Return true iff CST is within this range.  */\n+\n+bool\n+bounded_range::contains_p (tree cst) const\n+{\n+  /* Reject if below lower bound.  */\n+  if (tree_int_cst_lt (cst, m_lower))\n+    return false;\n+  /* Reject if above lower bound.  */\n+  if (tree_int_cst_lt (m_upper, cst))\n+    return false;\n+  return true;\n+}\n+\n+/* If this range intersects OTHER, return true, writing\n+   the intersection to *OUT if OUT is non-NULL.\n+   Return false if they do not intersect.  */\n+\n+bool\n+bounded_range::intersects_p (const bounded_range &other,\n+\t\t\t     bounded_range *out) const\n+{\n+  const tree max_lower\n+    = (tree_int_cst_le (m_lower, other.m_lower)\n+       ? other.m_lower : m_lower);\n+  gcc_assert (TREE_CODE (max_lower) == INTEGER_CST);\n+  const tree min_upper\n+    = (tree_int_cst_le (m_upper, other.m_upper)\n+       ? m_upper : other.m_upper);\n+  gcc_assert (TREE_CODE (min_upper) == INTEGER_CST);\n+\n+  if (tree_int_cst_le (max_lower, min_upper))\n+    {\n+      if (out)\n+\t*out = bounded_range (max_lower, min_upper);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+bool\n+bounded_range::operator== (const bounded_range &other) const\n+{\n+  return (tree_int_cst_equal (m_lower, other.m_lower)\n+\t  && tree_int_cst_equal (m_upper, other.m_upper));\n+}\n+\n+int\n+bounded_range::cmp (const bounded_range &br1, const bounded_range &br2)\n+{\n+  if (int cmp_lower = tree_int_cst_compare (br1.m_lower,\n+\t\t\t\t\t    br2.m_lower))\n+    return cmp_lower;\n+  return tree_int_cst_compare (br1.m_upper, br2.m_upper);\n+}\n+\n+/* struct bounded_ranges.  */\n+\n+/* Construct a bounded_ranges instance from a single range.  */\n+\n+bounded_ranges::bounded_ranges (const bounded_range &range)\n+: m_ranges (1)\n+{\n+  m_ranges.quick_push (range);\n+  canonicalize ();\n+  validate ();\n+}\n+\n+/* Construct a bounded_ranges instance from multiple ranges.  */\n+\n+bounded_ranges::bounded_ranges (const vec<bounded_range> &ranges)\n+: m_ranges (ranges.length ())\n+{\n+  m_ranges.safe_splice (ranges);\n+  canonicalize ();\n+  validate ();\n+}\n+\n+/* Construct a bounded_ranges instance for values of LHS for which\n+   (LHS OP RHS_CONST) is true (e.g. \"(LHS > 3)\".  */\n+\n+bounded_ranges::bounded_ranges (enum tree_code op, tree rhs_const)\n+: m_ranges ()\n+{\n+  gcc_assert (TREE_CODE (rhs_const) == INTEGER_CST);\n+  tree type = TREE_TYPE (rhs_const);\n+  switch (op)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case EQ_EXPR:\n+      m_ranges.safe_push (bounded_range (rhs_const, rhs_const));\n+      break;\n+\n+    case GE_EXPR:\n+      m_ranges.safe_push (bounded_range (rhs_const, TYPE_MAX_VALUE (type)));\n+      break;\n+\n+    case LE_EXPR:\n+      m_ranges.safe_push (bounded_range (TYPE_MIN_VALUE (type), rhs_const));\n+      break;\n+\n+    case NE_EXPR:\n+      if (tree_int_cst_lt (TYPE_MIN_VALUE (type), rhs_const))\n+\tm_ranges.safe_push (bounded_range (TYPE_MIN_VALUE (type),\n+\t\t\t\t\t   minus_one (rhs_const)));\n+      if (tree_int_cst_lt (rhs_const, TYPE_MAX_VALUE (type)))\n+\tm_ranges.safe_push (bounded_range (plus_one (rhs_const),\n+\t\t\t\t\t   TYPE_MAX_VALUE (type)));\n+      break;\n+    case GT_EXPR:\n+      if (tree_int_cst_lt (rhs_const, TYPE_MAX_VALUE (type)))\n+\tm_ranges.safe_push (bounded_range (plus_one (rhs_const),\n+\t\t\t\t\t   TYPE_MAX_VALUE (type)));\n+      break;\n+    case LT_EXPR:\n+      if (tree_int_cst_lt (TYPE_MIN_VALUE (type), rhs_const))\n+\tm_ranges.safe_push (bounded_range (TYPE_MIN_VALUE (type),\n+\t\t\t\t\t   minus_one (rhs_const)));\n+      break;\n+    }\n+  canonicalize ();\n+  validate ();\n+}\n+\n+/* Subroutine of ctors for fixing up m_ranges.\n+   Also, initialize m_hash.  */\n+\n+void\n+bounded_ranges::canonicalize ()\n+{\n+  /* Sort the ranges.  */\n+  m_ranges.qsort ([](const void *p1, const void *p2) -> int\n+\t\t  {\n+\t\t    const bounded_range &br1 = *(const bounded_range *)p1;\n+\t\t    const bounded_range &br2 = *(const bounded_range *)p2;\n+\t\t    return bounded_range::cmp (br1, br2);\n+\t\t  });\n+\n+  /* Merge ranges that are touching or overlapping.  */\n+  for (unsigned i = 1; i < m_ranges.length (); )\n+    {\n+      bounded_range *prev = &m_ranges[i - 1];\n+      const bounded_range *next = &m_ranges[i];\n+      if (prev->intersects_p (*next, NULL)\n+\t  || (can_plus_one_p (prev->m_upper)\n+\t      && tree_int_cst_equal (plus_one (prev->m_upper),\n+\t\t\t\t     next->m_lower)))\n+\t{\n+\t  prev->m_upper = next->m_upper;\n+\t  m_ranges.ordered_remove (i);\n+\t}\n+      else\n+\ti++;\n+    }\n+\n+  /* Initialize m_hash.  */\n+  inchash::hash hstate (0);\n+  for (const auto &iter : m_ranges)\n+    {\n+      inchash::add_expr (iter.m_lower, hstate);\n+      inchash::add_expr (iter.m_upper, hstate);\n+    }\n+  m_hash = hstate.end ();\n+}\n+\n+/* Assert that this object is valid.  */\n+\n+void\n+bounded_ranges::validate () const\n+{\n+  /* Skip this in a release build.  */\n+#if !CHECKING_P\n+  return;\n+#endif\n+\n+  for (unsigned i = 1; i < m_ranges.length (); i++)\n+    {\n+      const bounded_range &prev = m_ranges[i - 1];\n+      const bounded_range &next = m_ranges[i];\n+\n+      /* Give up if we somehow have incompatible different types.  */\n+      if (!types_compatible_p (TREE_TYPE (prev.m_upper),\n+\t\t\t       TREE_TYPE (next.m_lower)))\n+\tcontinue;\n+\n+      /* Verify sorted.  */\n+      gcc_assert (tree_int_cst_lt (prev.m_upper, next.m_lower));\n+\n+      gcc_assert (can_plus_one_p (prev.m_upper));\n+      /* otherwise there's no room for \"next\".  */\n+\n+      /* Verify no ranges touch each other.  */\n+      gcc_assert (tree_int_cst_lt (plus_one (prev.m_upper), next.m_lower));\n+    }\n+}\n+\n+/* bounded_ranges equality operator.  */\n+\n+bool\n+bounded_ranges::operator== (const bounded_ranges &other) const\n+{\n+  if (m_ranges.length () != other.m_ranges.length ())\n+    return false;\n+  for (unsigned i = 0; i < m_ranges.length (); i++)\n+    {\n+      if (m_ranges[i] != other.m_ranges[i])\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Dump this object to PP.  */\n+\n+void\n+bounded_ranges::dump_to_pp (pretty_printer *pp, bool show_types) const\n+{\n+  pp_character (pp, '{');\n+  for (unsigned i = 0; i < m_ranges.length (); ++i)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      m_ranges[i].dump_to_pp (pp, show_types);\n+    }\n+  pp_character (pp, '}');\n+}\n+\n+/* Dump this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+bounded_ranges::dump (bool show_types) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, show_types);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+json::value *\n+bounded_ranges::to_json () const\n+{\n+  json::array *arr_obj = new json::array ();\n+\n+  for (unsigned i = 0; i < m_ranges.length (); ++i)\n+    arr_obj->append (m_ranges[i].to_json ());\n+\n+  return arr_obj;\n+}\n+\n+/* Determine whether (X OP RHS_CONST) is known to be true or false\n+   for all X in the ranges expressed by this object.  */\n+\n+tristate\n+bounded_ranges::eval_condition (enum tree_code op,\n+\t\t\t\ttree rhs_const,\n+\t\t\t\tbounded_ranges_manager *mgr) const\n+{\n+  /* Convert (X OP RHS_CONST) to a bounded_ranges instance and find\n+     the intersection of that with this object.  */\n+  bounded_ranges other (op, rhs_const);\n+  const bounded_ranges *intersection\n+    = mgr->get_or_create_intersection (this, &other);\n+\n+  if (intersection->m_ranges.length () > 0)\n+    {\n+      /* We can use pointer equality to check for equality,\n+\t due to instance consolidation.  */\n+      if (intersection == this)\n+\treturn tristate (tristate::TS_TRUE);\n+      else\n+\treturn tristate (tristate::TS_UNKNOWN);\n+    }\n+  else\n+    /* No intersection.  */\n+    return tristate (tristate::TS_FALSE);\n+}\n+\n+/* Return true if CST is within any of the ranges.  */\n+\n+bool\n+bounded_ranges::contain_p (tree cst) const\n+{\n+  gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n+  for (const auto &iter : m_ranges)\n+    {\n+      /* TODO: should we optimize this based on sorting?  */\n+      if (iter.contains_p (cst))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+int\n+bounded_ranges::cmp (const bounded_ranges *a, const bounded_ranges *b)\n+{\n+  if (int cmp_length = ((int)a->m_ranges.length ()\n+\t\t\t- (int)b->m_ranges.length ()))\n+    return cmp_length;\n+  for (unsigned i = 0; i < a->m_ranges.length (); i++)\n+    {\n+      if (int cmp_range = bounded_range::cmp (a->m_ranges[i], b->m_ranges[i]))\n+\treturn cmp_range;\n+    }\n+  /* They are equal.  They ought to have been consolidated, so we should\n+     have two pointers to the same object.  */\n+  gcc_assert (a == b);\n+  return 0;\n+}\n+\n+/* class bounded_ranges_manager.  */\n+\n+/* bounded_ranges_manager's dtor.  */\n+\n+bounded_ranges_manager::~bounded_ranges_manager ()\n+{\n+  /* Delete the managed objects.  */\n+  for (const auto &iter : m_map)\n+    delete iter.second;\n+}\n+\n+/* Get the bounded_ranges instance for the empty set,  creating it if\n+   necessary.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::get_or_create_empty ()\n+{\n+  auto_vec<bounded_range> empty_vec;\n+\n+  return consolidate (new bounded_ranges (empty_vec));\n+}\n+\n+/* Get the bounded_ranges instance for {CST}, creating it if necessary.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::get_or_create_point (const_tree cst)\n+{\n+  gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n+\n+  return get_or_create_range (cst, cst);\n+}\n+\n+/* Get the bounded_ranges instance for {[LOWER_BOUND..UPPER_BOUND]},\n+   creating it if necessary.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::get_or_create_range (const_tree lower_bound,\n+\t\t\t\t\t     const_tree upper_bound)\n+{\n+  gcc_assert (TREE_CODE (lower_bound) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (upper_bound) == INTEGER_CST);\n+\n+  return consolidate\n+    (new bounded_ranges (bounded_range (lower_bound, upper_bound)));\n+}\n+\n+/* Get the bounded_ranges instance for the union of OTHERS,\n+   creating it if necessary.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::\n+get_or_create_union (const vec <const bounded_ranges *> &others)\n+{\n+  auto_vec<bounded_range> ranges;\n+  for (const auto &r : others)\n+    ranges.safe_splice (r->m_ranges);\n+  return consolidate (new bounded_ranges (ranges));\n+}\n+\n+/* Get the bounded_ranges instance for the intersection of A and B,\n+   creating it if necessary.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::get_or_create_intersection (const bounded_ranges *a,\n+\t\t\t\t\t\t    const bounded_ranges *b)\n+{\n+  auto_vec<bounded_range> ranges;\n+  unsigned a_idx = 0;\n+  unsigned b_idx = 0;\n+  while (a_idx < a->m_ranges.length ()\n+\t && b_idx < b->m_ranges.length ())\n+    {\n+      const bounded_range &r_a = a->m_ranges[a_idx];\n+      const bounded_range &r_b = b->m_ranges[b_idx];\n+\n+      bounded_range intersection (NULL_TREE, NULL_TREE);\n+      if (r_a.intersects_p (r_b, &intersection))\n+\t{\n+\t  ranges.safe_push (intersection);\n+\t}\n+      if (tree_int_cst_lt (r_a.m_lower, r_b.m_lower))\n+\t{\n+\t  a_idx++;\n+\t}\n+      else\n+\t{\n+\t  if (tree_int_cst_lt (r_a.m_upper, r_b.m_upper))\n+\t    a_idx++;\n+\t  else\n+\t    b_idx++;\n+\t}\n+    }\n+\n+  return consolidate (new bounded_ranges (ranges));\n+}\n+\n+/* Get the bounded_ranges instance for the inverse of OTHER relative\n+   to TYPE, creating it if necessary.\n+   This is for use when handling \"default\" in switch statements, where\n+   OTHER represents all the other cases.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::get_or_create_inverse (const bounded_ranges *other,\n+\t\t\t\t\t       tree type)\n+{\n+  tree min_val = TYPE_MIN_VALUE (type);\n+  tree max_val = TYPE_MAX_VALUE (type);\n+  if (other->m_ranges.length () == 0)\n+    return get_or_create_range (min_val, max_val);\n+  auto_vec<bounded_range> ranges;\n+  tree first_lb = other->m_ranges[0].m_lower;\n+  if (tree_int_cst_lt (min_val, first_lb)\n+      && can_minus_one_p (first_lb))\n+    ranges.safe_push (bounded_range (min_val,\n+\t\t\t\t     minus_one (first_lb)));\n+  for (unsigned i = 1; i < other->m_ranges.length (); i++)\n+    {\n+      tree prev_ub = other->m_ranges[i - 1].m_upper;\n+      tree iter_lb = other->m_ranges[i].m_lower;\n+      gcc_assert (tree_int_cst_lt (prev_ub, iter_lb));\n+      if (can_plus_one_p (prev_ub) && can_minus_one_p (iter_lb))\n+\tranges.safe_push (bounded_range (plus_one (prev_ub),\n+\t\t\t\t\t minus_one (iter_lb)));\n+    }\n+  tree last_ub\n+    = other->m_ranges[other->m_ranges.length () - 1].m_upper;\n+  if (tree_int_cst_lt (last_ub, max_val)\n+      && can_plus_one_p (last_ub))\n+    ranges.safe_push (bounded_range (plus_one (last_ub), max_val));\n+\n+  return consolidate (new bounded_ranges (ranges));\n+}\n+\n+/* If an object equal to INST is already present, delete INST and\n+   return the existing object.\n+   Otherwise add INST and return it.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::consolidate (bounded_ranges *inst)\n+{\n+  if (bounded_ranges **slot = m_map.get (inst))\n+    {\n+      delete inst;\n+      return *slot;\n+    }\n+  m_map.put (inst, inst);\n+  return inst;\n+}\n+\n+/* Get the bounded_ranges instance for EDGE of SWITCH_STMT,\n+   creating it if necessary, and caching it by edge.  */\n+\n+const bounded_ranges *\n+bounded_ranges_manager::\n+get_or_create_ranges_for_switch (const switch_cfg_superedge *edge,\n+\t\t\t\t const gswitch *switch_stmt)\n+{\n+  /* Look in per-edge cache.  */\n+  if (const bounded_ranges ** slot = m_edge_cache.get (edge))\n+    return *slot;\n+\n+  /* Not yet in cache.  */\n+  const bounded_ranges *all_cases_ranges\n+    = create_ranges_for_switch (*edge, switch_stmt);\n+  m_edge_cache.put (edge, all_cases_ranges);\n+  return all_cases_ranges;\n }\n \n-/* Return true if RHS_CONST is below the lower bound of this range.  */\n+/* Get the bounded_ranges instance for EDGE of SWITCH_STMT,\n+   creating it if necessary, for edges for which the per-edge\n+   cache has not yet been populated.  */\n \n-bool\n-range::below_lower_bound (tree rhs_const) const\n+const bounded_ranges *\n+bounded_ranges_manager::\n+create_ranges_for_switch (const switch_cfg_superedge &edge,\n+\t\t\t  const gswitch *switch_stmt)\n {\n-  if (!m_lower_bound.m_constant)\n-    return false;\n+  /* Get the ranges for each case label.  */\n+  auto_vec <const bounded_ranges *> case_ranges_vec\n+    (gimple_switch_num_labels (switch_stmt));\n \n-  return compare_constants (rhs_const,\n-\t\t\t    m_lower_bound.m_closed ? LT_EXPR : LE_EXPR,\n-\t\t\t    m_lower_bound.m_constant).is_true ();\n+  for (tree case_label : edge.get_case_labels ())\n+    {\n+      /* Get the ranges for this case label.  */\n+      const bounded_ranges *case_ranges\n+\t= make_case_label_ranges (switch_stmt, case_label);\n+      case_ranges_vec.quick_push (case_ranges);\n+    }\n+\n+  /* Combine all the ranges for each case label into a single collection\n+     of ranges.  */\n+  const bounded_ranges *all_cases_ranges\n+    = get_or_create_union (case_ranges_vec);\n+  return all_cases_ranges;\n }\n \n-/* Return true if RHS_CONST is above the upper bound of this range.  */\n+/* Get the bounded_ranges instance for CASE_LABEL within\n+   SWITCH_STMT.  */\n \n-bool\n-range::above_upper_bound (tree rhs_const) const\n+const bounded_ranges *\n+bounded_ranges_manager::\n+make_case_label_ranges (const gswitch *switch_stmt,\n+\t\t\ttree case_label)\n {\n-  if (!m_upper_bound.m_constant)\n-    return false;\n+  gcc_assert (TREE_CODE (case_label) == CASE_LABEL_EXPR);\n+  tree lower_bound = CASE_LOW (case_label);\n+  tree upper_bound = CASE_HIGH (case_label);\n+  if (lower_bound)\n+    {\n+      if (upper_bound)\n+\t/* Range.  */\n+\treturn get_or_create_range (lower_bound, upper_bound);\n+      else\n+\t/* Single-value.  */\n+\treturn get_or_create_point (lower_bound);\n+    }\n+  else\n+    {\n+      /* The default case.\n+\t Add exclusions based on the other cases.  */\n+      auto_vec <const bounded_ranges *> other_case_ranges\n+\t(gimple_switch_num_labels (switch_stmt));\n+      for (unsigned other_idx = 1;\n+\t   other_idx < gimple_switch_num_labels (switch_stmt);\n+\t   other_idx++)\n+\t{\n+\t  tree other_label = gimple_switch_label (switch_stmt,\n+\t\t\t\t\t\t  other_idx);\n+\t  const bounded_ranges *other_ranges\n+\t    = make_case_label_ranges (switch_stmt, other_label);\n+\t  other_case_ranges.quick_push (other_ranges);\n+\t}\n+      const bounded_ranges *other_cases_ranges\n+\t= get_or_create_union (other_case_ranges);\n+      tree type = TREE_TYPE (gimple_switch_index (switch_stmt));\n+      return get_or_create_inverse (other_cases_ranges, type);\n+    }\n+}\n \n-  return compare_constants (rhs_const,\n-\t\t\t    m_upper_bound.m_closed ? GT_EXPR : GE_EXPR,\n-\t\t\t    m_upper_bound.m_constant).is_true ();\n+/* Dump the number of objects of each class that were managed by this\n+   manager to LOGGER.\n+   If SHOW_OBJS is true, also dump the objects themselves.  */\n+\n+void\n+bounded_ranges_manager::log_stats (logger *logger, bool show_objs) const\n+{\n+  LOG_SCOPE (logger);\n+  logger->log (\"  # %s: %li\", \"ranges\", m_map.elements ());\n+  if (!show_objs)\n+    return;\n+\n+  auto_vec<const bounded_ranges *> vec_objs (m_map.elements ());\n+  for (const auto &iter : m_map)\n+    vec_objs.quick_push (iter.second);\n+  vec_objs.qsort\n+    ([](const void *p1, const void *p2) -> int\n+     {\n+       const bounded_ranges *br1 = *(const bounded_ranges * const *)p1;\n+       const bounded_ranges *br2 = *(const bounded_ranges * const *)p2;\n+       return bounded_ranges::cmp (br1, br2);\n+     });\n+\n+  for (const auto &iter : vec_objs)\n+    {\n+      logger->start_log_line ();\n+      pretty_printer *pp = logger->get_printer ();\n+      pp_string (pp, \"    \");\n+      iter->dump_to_pp (pp, true);\n+      logger->end_log_line ();\n+    }\n }\n \n /* class equiv_class.  */\n@@ -576,6 +1294,49 @@ constraint::implied_by (const constraint &other,\n   return false;\n }\n \n+/* class bounded_ranges_constraint.  */\n+\n+void\n+bounded_ranges_constraint::print (pretty_printer *pp,\n+\t\t\t\t  const constraint_manager &cm) const\n+{\n+  m_ec_id.print (pp);\n+  pp_string (pp, \": \");\n+  m_ec_id.get_obj (cm).print (pp);\n+  pp_string (pp, \": \");\n+  m_ranges->dump_to_pp (pp, true);\n+}\n+\n+json::object *\n+bounded_ranges_constraint::to_json () const\n+{\n+  json::object *con_obj = new json::object ();\n+\n+  con_obj->set (\"ec\", new json::integer_number (m_ec_id.as_int ()));\n+  con_obj->set (\"ranges\", m_ranges->to_json ());\n+\n+  return con_obj;\n+}\n+\n+bool\n+bounded_ranges_constraint::\n+operator== (const bounded_ranges_constraint &other) const\n+{\n+  if (m_ec_id != other.m_ec_id)\n+    return false;\n+\n+  /* We can compare by pointer, since the bounded_ranges_manager\n+     consolidates instances.  */\n+  return m_ranges == other.m_ranges;\n+}\n+\n+void\n+bounded_ranges_constraint::add_to_hash (inchash::hash *hstate) const\n+{\n+  hstate->add_int (m_ec_id.m_idx);\n+  hstate->merge_hash (m_ranges->get_hash ());\n+}\n+\n /* class equiv_class_id.  */\n \n /* Get the underlying equiv_class for this ID from CM.  */\n@@ -612,6 +1373,7 @@ equiv_class_id::print (pretty_printer *pp) const\n constraint_manager::constraint_manager (const constraint_manager &other)\n : m_equiv_classes (other.m_equiv_classes.length ()),\n   m_constraints (other.m_constraints.length ()),\n+  m_bounded_ranges_constraints (other.m_bounded_ranges_constraints.length ()),\n   m_mgr (other.m_mgr)\n {\n   int i;\n@@ -621,6 +1383,8 @@ constraint_manager::constraint_manager (const constraint_manager &other)\n   constraint *c;\n   FOR_EACH_VEC_ELT (other.m_constraints, i, c)\n     m_constraints.quick_push (*c);\n+  for (const auto &iter : other.m_bounded_ranges_constraints)\n+    m_bounded_ranges_constraints.quick_push (iter);\n }\n \n /* constraint_manager's assignment operator.  */\n@@ -630,6 +1394,7 @@ constraint_manager::operator= (const constraint_manager &other)\n {\n   gcc_assert (m_equiv_classes.length () == 0);\n   gcc_assert (m_constraints.length () == 0);\n+  gcc_assert (m_bounded_ranges_constraints.length () == 0);\n \n   int i;\n   equiv_class *ec;\n@@ -640,6 +1405,8 @@ constraint_manager::operator= (const constraint_manager &other)\n   m_constraints.reserve (other.m_constraints.length ());\n   FOR_EACH_VEC_ELT (other.m_constraints, i, c)\n     m_constraints.quick_push (*c);\n+  for (const auto &iter : other.m_bounded_ranges_constraints)\n+    m_bounded_ranges_constraints.quick_push (iter);\n \n   return *this;\n }\n@@ -658,6 +1425,8 @@ constraint_manager::hash () const\n     hstate.merge_hash (ec->hash ());\n   FOR_EACH_VEC_ELT (m_constraints, i, c)\n     hstate.merge_hash (c->hash ());\n+  for (const auto &iter : m_bounded_ranges_constraints)\n+    iter.add_to_hash (&hstate);\n   return hstate.end ();\n }\n \n@@ -670,6 +1439,9 @@ constraint_manager::operator== (const constraint_manager &other) const\n     return false;\n   if (m_constraints.length () != other.m_constraints.length ())\n     return false;\n+  if (m_bounded_ranges_constraints.length ()\n+      != other.m_bounded_ranges_constraints.length ())\n+    return false;\n \n   int i;\n   equiv_class *ec;\n@@ -684,6 +1456,13 @@ constraint_manager::operator== (const constraint_manager &other) const\n     if (!(*c == other.m_constraints[i]))\n       return false;\n \n+  for (unsigned i = 0; i < m_bounded_ranges_constraints.length (); i++)\n+    {\n+      if (m_bounded_ranges_constraints[i]\n+\t  != other.m_bounded_ranges_constraints[i])\n+\treturn false;\n+    }\n+\n   return true;\n }\n \n@@ -711,6 +1490,18 @@ constraint_manager::print (pretty_printer *pp) const\n \tpp_string (pp, \" && \");\n       c->print (pp, *this);\n     }\n+  if (m_bounded_ranges_constraints.length ())\n+    {\n+      pp_string (pp, \"  |  \");\n+      i = 0;\n+      for (const auto &iter : m_bounded_ranges_constraints)\n+\t{\n+\t  if (i > 0)\n+\t    pp_string (pp, \" && \");\n+\t  iter.print (pp, *this);\n+\t  i++;\n+\t}\n+    }\n   pp_printf (pp, \"}\");\n }\n \n@@ -762,6 +1553,30 @@ constraint_manager::dump_to_pp (pretty_printer *pp, bool multiline) const\n     }\n   if (!multiline)\n     pp_string (pp, \"}\");\n+  if (m_bounded_ranges_constraints.length ())\n+    {\n+      if (multiline)\n+\tpp_string (pp, \"  \");\n+      pp_string (pp, \"ranges:\");\n+      if (multiline)\n+\tpp_newline (pp);\n+      else\n+\tpp_string (pp, \"{\");\n+      i = 0;\n+      for (const auto &iter : m_bounded_ranges_constraints)\n+\t{\n+\t  if (multiline)\n+\t    pp_string (pp, \"    \");\n+\t  else if (i > 0)\n+\t    pp_string (pp, \" && \");\n+\t  iter.print (pp, *this);\n+\t  if (multiline)\n+\t    pp_newline (pp);\n+\t  i++;\n+\t}\n+      if (!multiline)\n+\tpp_string (pp, \"}\");\n+      }\n }\n \n /* Dump a multiline representation of this constraint_manager to FP.  */\n@@ -818,6 +1633,14 @@ constraint_manager::to_json () const\n     cm_obj->set (\"constraints\", con_arr);\n   }\n \n+  /* m_bounded_ranges_constraints.  */\n+  {\n+    json::array *con_arr = new json::array ();\n+    for (const auto &c : m_bounded_ranges_constraints)\n+      con_arr->append (c.to_json ());\n+    cm_obj->set (\"bounded_ranges_constraints\", con_arr);\n+  }\n+\n   return cm_obj;\n }\n \n@@ -936,6 +1759,8 @@ constraint_manager::add_unknown_constraint (equiv_class_id lhs_ec_id,\n \tif (final_ec != old_ec)\n \t  m_equiv_classes[rhs_ec_id.m_idx] = final_ec;\n \tdelete old_ec;\n+\tif (lhs_ec_id == final_ec_id)\n+\t  lhs_ec_id = rhs_ec_id;\n \n \t/* Update the constraints.  */\n \tconstraint *c;\n@@ -955,6 +1780,14 @@ constraint_manager::add_unknown_constraint (equiv_class_id lhs_ec_id,\n \t    if (c->m_rhs == final_ec_id)\n \t      c->m_rhs = rhs_ec_id;\n \t  }\n+\tbounded_ranges_constraint *brc;\n+\tFOR_EACH_VEC_ELT (m_bounded_ranges_constraints, i, brc)\n+\t  {\n+\t    if (brc->m_ec_id == rhs_ec_id)\n+\t      brc->m_ec_id = lhs_ec_id;\n+\t    if (brc->m_ec_id == final_ec_id)\n+\t      brc->m_ec_id = rhs_ec_id;\n+\t  }\n \n \t/* We may now have self-comparisons due to the merger; these\n \t   constraints should be removed.  */\n@@ -1008,6 +1841,8 @@ constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n   /* Add the constraint.  */\n   m_constraints.safe_push (new_c);\n \n+  /* We don't yet update m_bounded_ranges_constraints here yet.  */\n+\n   if (!flag_analyzer_transitivity)\n     return;\n \n@@ -1141,6 +1976,80 @@ constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n     }\n }\n \n+/* Attempt to add the constraint that SVAL is within RANGES to this\n+   constraint_manager.\n+\n+   Return true if the constraint was successfully added (or is already\n+   known to be true).\n+   Return false if the constraint contradicts existing knowledge.  */\n+\n+bool\n+constraint_manager::add_bounded_ranges (const svalue *sval,\n+\t\t\t\t\tconst bounded_ranges *ranges)\n+{\n+  sval = sval->unwrap_any_unmergeable ();\n+\n+  /* Nothing can be known about unknown/poisoned values.  */\n+  if (!sval->can_have_associated_state_p ())\n+    /* Not a contradiction.  */\n+    return true;\n+\n+  /* If SVAL is a constant, then we can look at RANGES directly.  */\n+  if (tree cst = sval->maybe_get_constant ())\n+    {\n+      /* If the ranges contain CST, then it's a successful no-op;\n+\t otherwise it's a contradiction.  */\n+      return ranges->contain_p (cst);\n+    }\n+\n+  equiv_class_id ec_id = get_or_add_equiv_class (sval);\n+\n+  /* If the EC has a constant, it's either true or false.  */\n+  const equiv_class &ec = ec_id.get_obj (*this);\n+  if (tree ec_cst = ec.get_any_constant ())\n+    {\n+      if (ranges->contain_p (ec_cst))\n+\t/* We already have SVAL == EC_CST, within RANGES, so\n+\t   we can discard RANGES and succeed.  */\n+\treturn true;\n+      else\n+\t/* We already have SVAL == EC_CST, not within RANGES, so\n+\t   we can reject RANGES as a contradiction.  */\n+\treturn false;\n+    }\n+\n+  /* We have at most one per ec_id.  */\n+  /* Iterate through each range in RANGES.  */\n+  for (auto iter : m_bounded_ranges_constraints)\n+    {\n+      if (iter.m_ec_id == ec_id)\n+\t{\n+\t  /* Update with intersection, or fail if empty.  */\n+\t  bounded_ranges_manager *mgr = get_range_manager ();\n+\t  const bounded_ranges *intersection\n+\t    = mgr->get_or_create_intersection (iter.m_ranges, ranges);\n+\t  if (intersection->empty_p ())\n+\t    {\n+\t      /* No intersection; fail.  */\n+\t      return false;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Update with intersection; succeed.  */\n+\t      iter.m_ranges = intersection;\n+\t      validate ();\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  m_bounded_ranges_constraints.safe_push\n+    (bounded_ranges_constraint (ec_id, ranges));\n+\n+  validate ();\n+\n+  return true;\n+}\n+\n /* Look for SVAL within the equivalence classes of this constraint_manager;\n    if found, return true, writing the id to *OUT if OUT is non-NULL,\n    otherwise return false.  */\n@@ -1279,6 +2188,8 @@ constraint_manager::eval_condition (equiv_class_id lhs_ec,\n \t}\n     }\n \n+  /* We don't use m_bounded_ranges_constraints here yet.  */\n+\n   return tristate (tristate::TS_UNKNOWN);\n }\n \n@@ -1404,6 +2315,12 @@ constraint_manager::eval_condition (equiv_class_id lhs_ec,\n \t    }\n \t}\n     }\n+\n+  bounded_ranges_manager *mgr = get_range_manager ();\n+  for (const auto &iter : m_bounded_ranges_constraints)\n+    if (iter.m_ec_id == lhs_ec)\n+      return iter.m_ranges->eval_condition (op, rhs_const, mgr);\n+\n   /* Look at existing bounds on LHS_EC.  */\n   range lhs_bounds = get_ec_bounds (lhs_ec);\n   return lhs_bounds.eval_condition (op, rhs_const);\n@@ -1552,6 +2469,29 @@ constraint_manager::purge (const PurgeCriteria &p, purge_stats *stats)\n \t\t  con_idx++;\n \t\t}\n \t    }\n+\n+\t  /* Update bounded_ranges_constraint instances.  */\n+\t  for (unsigned r_idx = 0;\n+\t       r_idx < m_bounded_ranges_constraints.length (); )\n+\t    {\n+\t      bounded_ranges_constraint *brc\n+\t\t= &m_bounded_ranges_constraints[r_idx];\n+\n+\t      /* Remove if it refers to the deleted EC.  */\n+\t      if (brc->m_ec_id == ec_idx)\n+\t\t{\n+\t\t  m_bounded_ranges_constraints.ordered_remove (r_idx);\n+\t\t  if (stats)\n+\t\t    stats->m_num_bounded_ranges_constraints++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Renumber any EC ids that refer to ECs that have\n+\t\t     had their idx changed.  */\n+\t\t  brc->m_ec_id.update_for_removal (ec_idx);\n+\t\t  r_idx++;\n+\t\t}\n+\t    }\n \t}\n       else\n \tec_idx++;\n@@ -1610,6 +2550,17 @@ constraint_manager::purge (const PurgeCriteria &p, purge_stats *stats)\n \t\t  c->m_lhs.update_for_removal (ec_idx);\n \t\t  c->m_rhs.update_for_removal (ec_idx);\n \t\t}\n+\n+\t      /* Likewise for m_bounded_ranges_constraints.  */\n+\t      for (unsigned r_idx = 0;\n+\t\t   r_idx < m_bounded_ranges_constraints.length ();\n+\t\t   r_idx++)\n+\t\t{\n+\t\t  bounded_ranges_constraint *brc\n+\t\t    = &m_bounded_ranges_constraints[r_idx];\n+\t\t  brc->m_ec_id.update_for_removal (ec_idx);\n+\t\t}\n+\n \t      continue;\n \t    }\n \t}\n@@ -1751,6 +2702,9 @@ constraint_manager::canonicalize ()\n       used_ecs.add (m_equiv_classes[c->m_rhs.as_int ()]);\n     }\n \n+  for (const auto &iter : m_bounded_ranges_constraints)\n+    used_ecs.add (m_equiv_classes[iter.m_ec_id.as_int ()]);\n+\n   /* Purge unused ECs: those that aren't used by constraints and\n      that effectively have only one svalue (either in m_constant\n      or in m_vars).  */\n@@ -1791,6 +2745,9 @@ constraint_manager::canonicalize ()\n       ec_id_map.update (&c->m_rhs);\n     }\n \n+  for (auto &iter : m_bounded_ranges_constraints)\n+    ec_id_map.update (&iter.m_ec_id);\n+\n   /* Finally, sort the constraints. */\n   m_constraints.qsort (constraint_cmp);\n }\n@@ -1835,6 +2792,32 @@ class merger_fact_visitor : public fact_visitor\n       }\n   }\n \n+  void on_ranges (const svalue *lhs_sval,\n+\t\t  const bounded_ranges *ranges) FINAL OVERRIDE\n+  {\n+    for (const auto &iter : m_cm_b->m_bounded_ranges_constraints)\n+      {\n+\tconst equiv_class &ec_rhs = iter.m_ec_id.get_obj (*m_cm_b);\n+\tfor (unsigned i = 0; i < ec_rhs.m_vars.length (); i++)\n+\t  {\n+\t    const svalue *rhs_sval = ec_rhs.m_vars[i];\n+\t    if (lhs_sval == rhs_sval)\n+\t      {\n+\t\t/* Union of the two ranges.  */\n+\t\tauto_vec <const bounded_ranges *> pair (2);\n+\t\tpair.quick_push (ranges);\n+\t\tpair.quick_push (iter.m_ranges);\n+\t\tbounded_ranges_manager *ranges_mgr\n+\t\t  = m_cm_b->get_range_manager ();\n+\t\tconst bounded_ranges *union_\n+\t\t  = ranges_mgr->get_or_create_union (pair);\n+\t\tbool sat = m_out->add_bounded_ranges (lhs_sval, union_);\n+\t\tgcc_assert (sat);\n+\t      }\n+\t  }\n+      }\n+  }\n+\n private:\n   const constraint_manager *m_cm_b;\n   constraint_manager *m_out;\n@@ -1908,6 +2891,16 @@ constraint_manager::for_each_fact (fact_visitor *visitor) const\n \t    visitor->on_fact (ec_lhs.m_vars[i], code, ec_rhs.m_vars[j]);\n \t}\n     }\n+\n+  for (const auto &iter : m_bounded_ranges_constraints)\n+    {\n+      const equiv_class &ec_lhs = iter.m_ec_id.get_obj (*this);\n+      for (unsigned i = 0; i < ec_lhs.m_vars.length (); i++)\n+\t{\n+\t  const svalue *lhs_sval = ec_lhs.m_vars[i];\n+\t  visitor->on_ranges (lhs_sval, iter.m_ranges);\n+\t}\n+    }\n }\n \n /* Assert that this object is valid.  */\n@@ -1945,10 +2938,22 @@ constraint_manager::validate () const\n   FOR_EACH_VEC_ELT (m_constraints, i, c)\n     {\n       gcc_assert (!c->m_lhs.null_p ());\n-      gcc_assert (c->m_lhs.as_int () <= (int)m_equiv_classes.length ());\n+      gcc_assert (c->m_lhs.as_int () < (int)m_equiv_classes.length ());\n       gcc_assert (!c->m_rhs.null_p ());\n-      gcc_assert (c->m_rhs.as_int () <= (int)m_equiv_classes.length ());\n+      gcc_assert (c->m_rhs.as_int () < (int)m_equiv_classes.length ());\n     }\n+\n+  for (const auto &iter : m_bounded_ranges_constraints)\n+    {\n+      gcc_assert (!iter.m_ec_id.null_p ());\n+      gcc_assert (iter.m_ec_id.as_int () < (int)m_equiv_classes.length ());\n+    }\n+}\n+\n+bounded_ranges_manager *\n+constraint_manager::get_range_manager () const\n+{\n+  return m_mgr->get_range_manager ();\n }\n \n #if CHECKING_P\n@@ -2696,6 +3701,318 @@ test_many_constants ()\n     }\n }\n \n+/* Implementation detail of ASSERT_DUMP_BOUNDED_RANGES_EQ.  */\n+\n+static void\n+assert_dump_bounded_range_eq (const location &loc,\n+\t\t\t      const bounded_range &range,\n+\t\t\t      const char *expected)\n+{\n+  auto_fix_quotes sentinel;\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  range.dump_to_pp (&pp, false);\n+  ASSERT_STREQ_AT (loc, pp_formatted_text (&pp), expected);\n+}\n+\n+/* Assert that BR.dump (false) is EXPECTED.  */\n+\n+#define ASSERT_DUMP_BOUNDED_RANGE_EQ(BR, EXPECTED) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_dump_bounded_range_eq ((SELFTEST_LOCATION), (BR), (EXPECTED)); \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that bounded_range works as expected.  */\n+\n+static void\n+test_bounded_range ()\n+{\n+  tree u8_0 = build_int_cst (unsigned_char_type_node, 0);\n+  tree u8_1 = build_int_cst (unsigned_char_type_node, 1);\n+  tree u8_64 = build_int_cst (unsigned_char_type_node, 64);\n+  tree u8_128 = build_int_cst (unsigned_char_type_node, 128);\n+  tree u8_255 = build_int_cst (unsigned_char_type_node, 255);\n+\n+  tree s8_0 = build_int_cst (signed_char_type_node, 0);\n+  tree s8_1 = build_int_cst (signed_char_type_node, 1);\n+  tree s8_2 = build_int_cst (signed_char_type_node, 2);\n+\n+  bounded_range br_u8_0 (u8_0, u8_0);\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (br_u8_0, \"0\");\n+  ASSERT_TRUE (br_u8_0.contains_p (u8_0));\n+  ASSERT_FALSE (br_u8_0.contains_p (u8_1));\n+  ASSERT_TRUE (br_u8_0.contains_p (s8_0));\n+  ASSERT_FALSE (br_u8_0.contains_p (s8_1));\n+\n+  bounded_range br_u8_0_1 (u8_0, u8_1);\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (br_u8_0_1, \"[0, 1]\");\n+\n+  bounded_range tmp (NULL_TREE, NULL_TREE);\n+  ASSERT_TRUE (br_u8_0.intersects_p (br_u8_0_1, &tmp));\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (tmp, \"0\");\n+\n+  bounded_range br_u8_64_128 (u8_64, u8_128);\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (br_u8_64_128, \"[64, 128]\");\n+\n+  ASSERT_FALSE (br_u8_0.intersects_p (br_u8_64_128, NULL));\n+  ASSERT_FALSE (br_u8_64_128.intersects_p (br_u8_0, NULL));\n+\n+  bounded_range br_u8_128_255 (u8_128, u8_255);\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (br_u8_128_255, \"[128, 255]\");\n+  ASSERT_TRUE (br_u8_128_255.intersects_p (br_u8_64_128, &tmp));\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (tmp, \"128\");\n+\n+  bounded_range br_s8_2 (s8_2, s8_2);\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (br_s8_2, \"2\");\n+  bounded_range br_s8_2_u8_255 (s8_2, u8_255);\n+  ASSERT_DUMP_BOUNDED_RANGE_EQ (br_s8_2_u8_255, \"[2, 255]\");\n+}\n+\n+/* Implementation detail of ASSERT_DUMP_BOUNDED_RANGES_EQ.  */\n+\n+static void\n+assert_dump_bounded_ranges_eq (const location &loc,\n+\t\t\t       const bounded_ranges *ranges,\n+\t\t\t       const char *expected)\n+{\n+  auto_fix_quotes sentinel;\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  ranges->dump_to_pp (&pp, false);\n+  ASSERT_STREQ_AT (loc, pp_formatted_text (&pp), expected);\n+}\n+\n+/* Implementation detail of ASSERT_DUMP_BOUNDED_RANGES_EQ.  */\n+\n+static void\n+assert_dump_bounded_ranges_eq (const location &loc,\n+\t\t\t       const bounded_ranges &ranges,\n+\t\t\t       const char *expected)\n+{\n+  auto_fix_quotes sentinel;\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  ranges.dump_to_pp (&pp, false);\n+  ASSERT_STREQ_AT (loc, pp_formatted_text (&pp), expected);\n+}\n+\n+/* Assert that BRS.dump (false) is EXPECTED.  */\n+\n+#define ASSERT_DUMP_BOUNDED_RANGES_EQ(BRS, EXPECTED) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_dump_bounded_ranges_eq ((SELFTEST_LOCATION), (BRS), (EXPECTED)); \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that the bounded_ranges class works as expected.  */\n+\n+static void\n+test_bounded_ranges ()\n+{\n+  bounded_ranges_manager mgr;\n+\n+  tree ch0 = build_int_cst (unsigned_char_type_node, 0);\n+  tree ch1 = build_int_cst (unsigned_char_type_node, 1);\n+  tree ch2 = build_int_cst (unsigned_char_type_node, 2);\n+  tree ch3 = build_int_cst (unsigned_char_type_node, 3);\n+  tree ch128 = build_int_cst (unsigned_char_type_node, 128);\n+  tree ch129 = build_int_cst (unsigned_char_type_node, 129);\n+  tree ch254 = build_int_cst (unsigned_char_type_node, 254);\n+  tree ch255 = build_int_cst (unsigned_char_type_node, 255);\n+\n+  const bounded_ranges *empty = mgr.get_or_create_empty ();\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (empty, \"{}\");\n+\n+  const bounded_ranges *point0 = mgr.get_or_create_point (ch0);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (point0, \"{0}\");\n+\n+  const bounded_ranges *point1 = mgr.get_or_create_point (ch1);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (point1, \"{1}\");\n+\n+  const bounded_ranges *point2 = mgr.get_or_create_point (ch2);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (point2, \"{2}\");\n+\n+  const bounded_ranges *range0_128 = mgr.get_or_create_range (ch0, ch128);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (range0_128, \"{[0, 128]}\");\n+\n+  const bounded_ranges *range0_255 = mgr.get_or_create_range (ch0, ch255);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (range0_255, \"{[0, 255]}\");\n+\n+  ASSERT_FALSE (empty->contain_p (ch0));\n+  ASSERT_FALSE (empty->contain_p (ch1));\n+  ASSERT_FALSE (empty->contain_p (ch255));\n+\n+  ASSERT_TRUE (point0->contain_p (ch0));\n+  ASSERT_FALSE (point0->contain_p (ch1));\n+  ASSERT_FALSE (point0->contain_p (ch255));\n+\n+  ASSERT_FALSE (point1->contain_p (ch0));\n+  ASSERT_TRUE (point1->contain_p (ch1));\n+  ASSERT_FALSE (point0->contain_p (ch255));\n+\n+  ASSERT_TRUE (range0_128->contain_p (ch0));\n+  ASSERT_TRUE (range0_128->contain_p (ch1));\n+  ASSERT_TRUE (range0_128->contain_p (ch128));\n+  ASSERT_FALSE (range0_128->contain_p (ch129));\n+  ASSERT_FALSE (range0_128->contain_p (ch254));\n+  ASSERT_FALSE (range0_128->contain_p (ch255));\n+\n+  const bounded_ranges *inv0_128\n+    = mgr.get_or_create_inverse (range0_128, unsigned_char_type_node);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (inv0_128, \"{[129, 255]}\");\n+\n+  const bounded_ranges *range128_129 = mgr.get_or_create_range (ch128, ch129);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (range128_129, \"{[128, 129]}\");\n+\n+  const bounded_ranges *inv128_129\n+    = mgr.get_or_create_inverse (range128_129, unsigned_char_type_node);\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (inv128_129, \"{[0, 127], [130, 255]}\");\n+\n+  /* Intersection.  */\n+  {\n+    /* Intersection of disjoint ranges should be empty set.  */\n+    const bounded_ranges *intersect0_1\n+      = mgr.get_or_create_intersection (point0, point1);\n+    ASSERT_DUMP_BOUNDED_RANGES_EQ (intersect0_1, \"{}\");\n+  }\n+\n+  /* Various tests of \"union of ranges\".  */\n+  {\n+    {\n+      /* Touching points should be merged into a range.  */\n+      auto_vec <const bounded_ranges *> v;\n+      v.safe_push (point0);\n+      v.safe_push (point1);\n+      const bounded_ranges *union_0_and_1 = mgr.get_or_create_union (v);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (union_0_and_1, \"{[0, 1]}\");\n+    }\n+\n+    {\n+      /* Overlapping and out-of-order.  */\n+      auto_vec <const bounded_ranges *> v;\n+      v.safe_push (inv0_128); // {[129, 255]}\n+      v.safe_push (range128_129);\n+      const bounded_ranges *union_129_255_and_128_129\n+\t= mgr.get_or_create_union (v);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (union_129_255_and_128_129, \"{[128, 255]}\");\n+    }\n+\n+    {\n+      /* Union of R and inverse(R) should be full range of type.  */\n+      auto_vec <const bounded_ranges *> v;\n+      v.safe_push (range128_129);\n+      v.safe_push (inv128_129);\n+      const bounded_ranges *union_ = mgr.get_or_create_union (v);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (union_, \"{[0, 255]}\");\n+    }\n+\n+    /* Union with an endpoint.  */\n+    {\n+      const bounded_ranges *range2_to_255\n+\t= mgr.get_or_create_range (ch2, ch255);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (range2_to_255, \"{[2, 255]}\");\n+      auto_vec <const bounded_ranges *> v;\n+      v.safe_push (point0);\n+      v.safe_push (point2);\n+      v.safe_push (range2_to_255);\n+      const bounded_ranges *union_ = mgr.get_or_create_union (v);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (union_, \"{0, [2, 255]}\");\n+    }\n+\n+    /* Construct from vector of bounded_range.  */\n+    {\n+      auto_vec<bounded_range> v;\n+      v.safe_push (bounded_range (ch2, ch2));\n+      v.safe_push (bounded_range (ch0, ch0));\n+      v.safe_push (bounded_range (ch2, ch255));\n+      bounded_ranges br (v);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (&br, \"{0, [2, 255]}\");\n+    }\n+  }\n+\n+  /* Various tests of \"inverse\".  */\n+  {\n+    {\n+      const bounded_ranges *range_1_to_3 = mgr.get_or_create_range (ch1, ch3);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (range_1_to_3, \"{[1, 3]}\");\n+      const bounded_ranges *inv\n+\t= mgr.get_or_create_inverse (range_1_to_3, unsigned_char_type_node);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (inv, \"{0, [4, 255]}\");\n+    }\n+    {\n+      const bounded_ranges *range_1_to_255\n+\t= mgr.get_or_create_range (ch1, ch255);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (range_1_to_255, \"{[1, 255]}\");\n+      const bounded_ranges *inv\n+\t= mgr.get_or_create_inverse (range_1_to_255, unsigned_char_type_node);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (inv, \"{0}\");\n+    }\n+    {\n+      const bounded_ranges *range_0_to_254\n+\t= mgr.get_or_create_range (ch0, ch254);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (range_0_to_254, \"{[0, 254]}\");\n+      const bounded_ranges *inv\n+\t= mgr.get_or_create_inverse (range_0_to_254, unsigned_char_type_node);\n+      ASSERT_DUMP_BOUNDED_RANGES_EQ (inv, \"{255}\");\n+    }\n+  }\n+\n+  /* \"case 'a'-'z': case 'A-Z':\" vs \"default:\", for ASCII.  */\n+  {\n+    tree ch65 = build_int_cst (unsigned_char_type_node, 65);\n+    tree ch90 = build_int_cst (unsigned_char_type_node, 90);\n+\n+    tree ch97 = build_int_cst (unsigned_char_type_node, 97);\n+    tree ch122 = build_int_cst (unsigned_char_type_node, 122);\n+\n+    const bounded_ranges *A_to_Z = mgr.get_or_create_range (ch65, ch90);\n+    ASSERT_DUMP_BOUNDED_RANGES_EQ (A_to_Z, \"{[65, 90]}\");\n+    const bounded_ranges *a_to_z = mgr.get_or_create_range (ch97, ch122);\n+    ASSERT_DUMP_BOUNDED_RANGES_EQ (a_to_z, \"{[97, 122]}\");\n+    auto_vec <const bounded_ranges *> v;\n+    v.safe_push (A_to_Z);\n+    v.safe_push (a_to_z);\n+    const bounded_ranges *label_ranges = mgr.get_or_create_union (v);\n+    ASSERT_DUMP_BOUNDED_RANGES_EQ (label_ranges, \"{[65, 90], [97, 122]}\");\n+    const bounded_ranges *default_ranges\n+      = mgr.get_or_create_inverse (label_ranges, unsigned_char_type_node);\n+    ASSERT_DUMP_BOUNDED_RANGES_EQ (default_ranges,\n+\t\t\t\t   \"{[0, 64], [91, 96], [123, 255]}\");\n+  }\n+\n+  /* Verify ranges from ops.  */\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (EQ_EXPR, ch128),\n+\t\t\t\t \"{128}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (NE_EXPR, ch128),\n+\t\t\t\t \"{[0, 127], [129, 255]}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (LT_EXPR, ch128),\n+\t\t\t\t \"{[0, 127]}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (LE_EXPR, ch128),\n+\t\t\t\t \"{[0, 128]}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (GE_EXPR, ch128),\n+\t\t\t\t \"{[128, 255]}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (GT_EXPR, ch128),\n+\t\t\t\t \"{[129, 255]}\");\n+  /* Ops at endpoints of type ranges.  */\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (LE_EXPR, ch0),\n+\t\t\t\t \"{0}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (LT_EXPR, ch0),\n+\t\t\t\t \"{}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (NE_EXPR, ch0),\n+\t\t\t\t \"{[1, 255]}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (GE_EXPR, ch255),\n+\t\t\t\t \"{255}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (GT_EXPR, ch255),\n+\t\t\t\t \"{}\");\n+  ASSERT_DUMP_BOUNDED_RANGES_EQ (bounded_ranges (NE_EXPR, ch255),\n+\t\t\t\t \"{[0, 254]}\");\n+\n+  /* Verify that instances are consolidated by mgr.  */\n+  ASSERT_EQ (mgr.get_or_create_point (ch0),\n+\t     mgr.get_or_create_point (ch0));\n+  ASSERT_NE (mgr.get_or_create_point (ch0),\n+\t     mgr.get_or_create_point (ch1));\n+}\n+\n /* Run the selftests in this file, temporarily overriding\n    flag_analyzer_transitivity with TRANSITIVITY.  */\n \n@@ -2715,6 +4032,8 @@ run_constraint_manager_tests (bool transitivity)\n   test_constraint_impl ();\n   test_equality ();\n   test_many_constants ();\n+  test_bounded_range ();\n+  test_bounded_ranges ();\n \n   flag_analyzer_transitivity = saved_flag_analyzer_transitivity;\n }"}, {"sha": "0a430eae91fb415ae22a8f68785117ed0b51d71c", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -64,6 +64,164 @@ struct range\n   bound m_upper_bound;\n };\n \n+/* A closed range of values with constant integer bounds\n+   e.g. [3, 5] for the set {3, 4, 5}.  */\n+\n+struct bounded_range\n+{\n+  bounded_range (const_tree lower, const_tree upper);\n+\n+  void dump_to_pp (pretty_printer *pp, bool show_types) const;\n+  void dump (bool show_types) const;\n+\n+  json::object *to_json () const;\n+\n+  bool contains_p (tree cst) const;\n+\n+  bool intersects_p (const bounded_range &other,\n+\t\t     bounded_range *out) const;\n+\n+  bool operator== (const bounded_range &other) const;\n+  bool operator!= (const bounded_range &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  static int cmp (const bounded_range &a, const bounded_range &b);\n+\n+  tree m_lower;\n+  tree m_upper;\n+\n+private:\n+  static void set_json_attr (json::object *obj, const char *name, tree value);\n+};\n+\n+/* A collection of bounded_range instances, suitable\n+   for representing the ranges on a case label within a switch\n+   statement.  */\n+\n+struct bounded_ranges\n+{\n+public:\n+  typedef bounded_ranges key_t;\n+\n+  bounded_ranges (const bounded_range &range);\n+  bounded_ranges (const vec<bounded_range> &ranges);\n+  bounded_ranges (enum tree_code op, tree rhs_const);\n+\n+  bool operator== (const bounded_ranges &other) const;\n+\n+  hashval_t get_hash () const { return m_hash; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool show_types) const;\n+  void dump (bool show_types) const;\n+\n+  json::value *to_json () const;\n+\n+  tristate eval_condition (enum tree_code op,\n+\t\t\t   tree rhs_const,\n+\t\t\t   bounded_ranges_manager *mgr) const;\n+\n+  bool contain_p (tree cst) const;\n+  bool empty_p () const { return m_ranges.length () == 0; }\n+\n+  static int cmp (const bounded_ranges *a, const bounded_ranges *b);\n+\n+private:\n+  void canonicalize ();\n+  void validate () const;\n+\n+  friend class bounded_ranges_manager;\n+\n+  auto_vec<bounded_range> m_ranges;\n+  hashval_t m_hash;\n+};\n+\n+} // namespace ana\n+\n+template <> struct default_hash_traits<bounded_ranges::key_t>\n+: public member_function_hash_traits<bounded_ranges::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* An object to own and consolidate bounded_ranges instances.\n+   This also caches the mapping from switch_cfg_superedge\n+   bounded_ranges instances, so that get_or_create_ranges_for_switch is\n+   memoized.  */\n+\n+class bounded_ranges_manager\n+{\n+public:\n+  ~bounded_ranges_manager ();\n+\n+  const bounded_ranges *\n+  get_or_create_ranges_for_switch (const switch_cfg_superedge *edge,\n+\t\t\t\t   const gswitch *switch_stmt);\n+\n+  const bounded_ranges *get_or_create_empty ();\n+  const bounded_ranges *get_or_create_point (const_tree value);\n+  const bounded_ranges *get_or_create_range (const_tree lower_bound,\n+\t\t\t\t\t     const_tree upper_bound);\n+  const bounded_ranges *\n+  get_or_create_union (const vec <const bounded_ranges *> &others);\n+  const bounded_ranges *\n+  get_or_create_intersection (const bounded_ranges *a,\n+\t\t\t      const bounded_ranges *b);\n+  const bounded_ranges *\n+  get_or_create_inverse (const bounded_ranges *other, tree type);\n+\n+  void log_stats (logger *logger, bool show_objs) const;\n+\n+private:\n+  const bounded_ranges *\n+  create_ranges_for_switch (const switch_cfg_superedge &edge,\n+\t\t\t    const gswitch *switch_stmt);\n+\n+  const bounded_ranges *\n+  make_case_label_ranges (const gswitch *switch_stmt,\n+\t\t\t  tree case_label);\n+\n+  const bounded_ranges *consolidate (bounded_ranges *);\n+\n+  struct hash_traits_t : public typed_noop_remove<bounded_ranges *>\n+  {\n+    typedef bounded_ranges *key_type;\n+    typedef bounded_ranges *value_type;\n+\n+    static inline bool\n+    equal (const key_type &k1, const key_type &k2)\n+    {\n+      return *k1 == *k2;\n+    }\n+    static inline hashval_t\n+    hash (const key_type &k)\n+    {\n+      return k->get_hash ();\n+    }\n+    static inline bool is_empty (key_type k) { return k == NULL; }\n+    static inline void mark_empty (key_type &k) { k = NULL; }\n+    static inline bool is_deleted (key_type k)\n+    {\n+      return k == reinterpret_cast<key_type> (1);\n+    }\n+\n+    static const bool empty_zero_p = true;\n+  };\n+  struct traits_t : public simple_hashmap_traits<hash_traits_t,\n+\t\t\t\t\t\t bounded_ranges *>\n+  {\n+  };\n+  typedef hash_map<bounded_ranges *, bounded_ranges *, traits_t> map_t;\n+  map_t m_map;\n+\n+  typedef hash_map<const switch_cfg_superedge *,\n+\t\t   const bounded_ranges *> edge_cache_t;\n+  edge_cache_t m_edge_cache;\n+};\n+\n /* An equivalence class within a constraint manager: a set of\n    svalues that are known to all be equal to each other,\n    together with an optional tree constant that they are equal to.  */\n@@ -190,6 +348,33 @@ class fact_visitor\n   virtual void on_fact (const svalue *lhs,\n \t\t\tenum tree_code,\n \t\t\tconst svalue *rhs) = 0;\n+  virtual void on_ranges (const svalue *lhs,\n+\t\t\t  const bounded_ranges *ranges) = 0;\n+};\n+\n+class bounded_ranges_constraint\n+{\n+public:\n+  bounded_ranges_constraint (equiv_class_id ec_id,\n+\t\t\t     const bounded_ranges *ranges)\n+  : m_ec_id (ec_id), m_ranges (ranges)\n+  {\n+  }\n+\n+  void print (pretty_printer *pp, const constraint_manager &cm) const;\n+\n+  json::object *to_json () const;\n+\n+  bool operator== (const bounded_ranges_constraint &other) const;\n+  bool operator!= (const bounded_ranges_constraint &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  void add_to_hash (inchash::hash *hstate) const;\n+\n+  equiv_class_id m_ec_id;\n+  const bounded_ranges *m_ranges;\n };\n \n /* A collection of equivalence classes and constraints on them.\n@@ -248,6 +433,9 @@ class constraint_manager\n \t\t\t       enum tree_code op,\n \t\t\t       equiv_class_id rhs_ec_id);\n \n+  bool add_bounded_ranges (const svalue *sval,\n+\t\t\t   const bounded_ranges *ranges);\n+\n   bool get_equiv_class_by_svalue (const svalue *sval,\n \t\t\t\t    equiv_class_id *out) const;\n   equiv_class_id get_or_add_equiv_class (const svalue *sval);\n@@ -281,8 +469,11 @@ class constraint_manager\n \n   void validate () const;\n \n+  bounded_ranges_manager *get_range_manager () const;\n+\n   auto_delete_vec<equiv_class> m_equiv_classes;\n   auto_vec<constraint> m_constraints;\n+  auto_vec<bounded_ranges_constraint> m_bounded_ranges_constraints;\n \n  private:\n   void add_constraint_internal (equiv_class_id lhs_id,"}, {"sha": "7ffe00043568ec7ef704ddd482e88a249e3ceede", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -520,8 +520,7 @@ epath_finder::process_worklist_item (feasible_worklist *worklist,\n \t  gcc_assert (rc);\n \t  fg->add_feasibility_problem (fnode,\n \t\t\t\t       succ_eedge,\n-\t\t\t\t       *rc);\n-\t  delete rc;\n+\t\t\t\t       rc);\n \n \t  /* Give up if there have been too many infeasible edges.  */\n \t  if (fg->get_num_infeasible ()"}, {"sha": "4ee92794941b7e0ef2f8e94581ef863b7fe7ce13", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -3842,7 +3842,7 @@ feasibility_problem::dump_to_pp (pretty_printer *pp) const\n       pp_string (pp, \"; rejected constraint: \");\n       m_rc->dump_to_pp (pp);\n       pp_string (pp, \"; rmodel: \");\n-      m_rc->m_model.dump_to_pp (pp, true, false);\n+      m_rc->get_model ().dump_to_pp (pp, true, false);\n     }\n }\n "}, {"sha": "3b8589630ed15a2842827eb1e9347445e7d9b124", "filename": "gcc/analyzer/feasible-graph.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Ffeasible-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Ffeasible-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.cc?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -129,7 +129,7 @@ infeasible_node::dump_dot (graphviz_out *gv,\n \n   pp_string (pp, \"rejected constraint:\");\n   pp_newline (pp);\n-  m_rc.dump_to_pp (pp);\n+  m_rc->dump_to_pp (pp);\n \n   pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n \n@@ -178,12 +178,13 @@ feasible_graph::add_node (const exploded_node *enode,\n }\n \n /* Add an infeasible_node to this graph and an infeasible_edge connecting\n-   to it from SRC_FNODE, capturing a failure of RC along EEDGE.  */\n+   to it from SRC_FNODE, capturing a failure of RC along EEDGE.\n+   Takes ownership of RC.  */\n \n void\n feasible_graph::add_feasibility_problem (feasible_node *src_fnode,\n \t\t\t\t\t const exploded_edge *eedge,\n-\t\t\t\t\t const rejected_constraint &rc)\n+\t\t\t\t\t rejected_constraint *rc)\n {\n   infeasible_node *dst_fnode\n     = new infeasible_node (eedge->m_dest, m_nodes.length (), rc);"}, {"sha": "07696faeceed0b280599febce1704e03818a445d", "filename": "gcc/analyzer/feasible-graph.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Ffeasible-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Ffeasible-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.h?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -115,17 +115,18 @@ class infeasible_node : public base_feasible_node\n {\n public:\n   infeasible_node (const exploded_node *inner_node, unsigned index,\n-\t\t   const rejected_constraint &rc)\n+\t\t   rejected_constraint *rc)\n   : base_feasible_node (inner_node, index),\n     m_rc (rc)\n   {\n   }\n+  ~infeasible_node () { delete m_rc; }\n \n   void dump_dot (graphviz_out *gv,\n \t\t const dump_args_t &args) const FINAL OVERRIDE;\n \n private:\n-  rejected_constraint m_rc;\n+  rejected_constraint *m_rc;\n };\n \n /* Base class of edge within a feasible_graph.  */\n@@ -192,7 +193,7 @@ class feasible_graph : public digraph <fg_traits>\n \n   void add_feasibility_problem (feasible_node *src_fnode,\n \t\t\t\tconst exploded_edge *eedge,\n-\t\t\t\tconst rejected_constraint &rc);\n+\t\t\t\trejected_constraint *rc);\n \n   exploded_path *make_epath (feasible_node *fnode) const;\n "}, {"sha": "1cdec1bd2303c2646c1f339f02c6a8805a7e0ee0", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/constraint-manager.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -77,7 +78,8 @@ region_model_manager::region_model_manager ()\n   m_fndecls_map (), m_labels_map (),\n   m_globals_region (alloc_region_id (), &m_root_region),\n   m_globals_map (),\n-  m_store_mgr (this)\n+  m_store_mgr (this),\n+  m_range_mgr (new bounded_ranges_manager ())\n {\n }\n \n@@ -142,6 +144,8 @@ region_model_manager::~region_model_manager ()\n   for (string_map_t::iterator iter = m_string_map.begin ();\n        iter != m_string_map.end (); ++iter)\n     delete (*iter).second;\n+\n+  delete m_range_mgr;\n }\n \n /* Return true if C exceeds the complexity limit for svalues.  */\n@@ -1574,6 +1578,7 @@ region_model_manager::log_stats (logger *logger, bool show_objs) const\n   logger->log (\"  # managed dynamic regions: %i\",\n \t       m_managed_dynamic_regions.length ());\n   m_store_mgr.log_stats (logger, show_objs);\n+  m_range_mgr->log_stats (logger, show_objs);\n }\n \n /* Dump the number of objects of each class that were managed by this"}, {"sha": "787f2ed33c0fc7c5850f8b099854c00d53b25763", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 23, "deletions": 52, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -2773,7 +2773,7 @@ region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n {\n   bool sat = add_constraint (lhs, op, rhs, ctxt);\n   if (!sat && out)\n-    *out = new rejected_constraint (*this, lhs, op, rhs);\n+    *out = new rejected_op_constraint (*this, lhs, op, rhs);\n   return sat;\n }\n \n@@ -3329,56 +3329,15 @@ region_model::apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n \t\t\t\t\t     region_model_context *ctxt,\n \t\t\t\t\t     rejected_constraint **out)\n {\n+  bounded_ranges_manager *ranges_mgr = get_range_manager ();\n+  const bounded_ranges *all_cases_ranges\n+    = ranges_mgr->get_or_create_ranges_for_switch (&edge, switch_stmt);\n   tree index  = gimple_switch_index (switch_stmt);\n-  tree case_label = edge.get_case_label ();\n-  gcc_assert (TREE_CODE (case_label) == CASE_LABEL_EXPR);\n-  tree lower_bound = CASE_LOW (case_label);\n-  tree upper_bound = CASE_HIGH (case_label);\n-  if (lower_bound)\n-    {\n-      if (upper_bound)\n-\t{\n-\t  /* Range.  */\n-\t  if (!add_constraint (index, GE_EXPR, lower_bound, ctxt, out))\n-\t    return false;\n-\t  return add_constraint (index, LE_EXPR, upper_bound, ctxt, out);\n-\t}\n-      else\n-\t/* Single-value.  */\n-\treturn add_constraint (index, EQ_EXPR, lower_bound, ctxt, out);\n-    }\n-  else\n-    {\n-      /* The default case.\n-\t Add exclusions based on the other cases.  */\n-      for (unsigned other_idx = 1;\n-\t   other_idx < gimple_switch_num_labels (switch_stmt);\n-\t   other_idx++)\n-\t{\n-\t  tree other_label = gimple_switch_label (switch_stmt,\n-\t\t\t\t\t\t  other_idx);\n-\t  tree other_lower_bound = CASE_LOW (other_label);\n-\t  tree other_upper_bound = CASE_HIGH (other_label);\n-\t  gcc_assert (other_lower_bound);\n-\t  if (other_upper_bound)\n-\t    {\n-\t      /* Exclude this range-valued case.\n-\t\t For now, we just exclude the boundary values.\n-\t\t TODO: exclude the values within the region.  */\n-\t      if (!add_constraint (index, NE_EXPR, other_lower_bound,\n-\t\t\t\t   ctxt, out))\n-\t\treturn false;\n-\t      if (!add_constraint (index, NE_EXPR, other_upper_bound,\n-\t\t\t\t   ctxt, out))\n-\t\treturn false;\n-\t    }\n-\t  else\n-\t    /* Exclude this single-valued case.  */\n-\t    if (!add_constraint (index, NE_EXPR, other_lower_bound, ctxt, out))\n-\t      return false;\n-\t}\n-      return true;\n-    }\n+  const svalue *index_sval = get_rvalue (index, ctxt);\n+  bool sat = m_constraints->add_bounded_ranges (index_sval, all_cases_ranges);\n+  if (!sat && out)\n+    *out = new rejected_ranges_constraint (*this, index, all_cases_ranges);\n+  return sat;\n }\n \n /* Apply any constraints due to an exception being thrown at LAST_STMT.\n@@ -3860,10 +3819,10 @@ debug (const region_model &rmodel)\n   rmodel.dump (false);\n }\n \n-/* struct rejected_constraint.  */\n+/* class rejected_op_constraint : public rejected_constraint.  */\n \n void\n-rejected_constraint::dump_to_pp (pretty_printer *pp) const\n+rejected_op_constraint::dump_to_pp (pretty_printer *pp) const\n {\n   region_model m (m_model);\n   const svalue *lhs_sval = m.get_rvalue (m_lhs, NULL);\n@@ -3873,6 +3832,18 @@ rejected_constraint::dump_to_pp (pretty_printer *pp) const\n   rhs_sval->dump_to_pp (pp, true);\n }\n \n+/* class rejected_ranges_constraint : public rejected_constraint.  */\n+\n+void\n+rejected_ranges_constraint::dump_to_pp (pretty_printer *pp) const\n+{\n+  region_model m (m_model);\n+  const svalue *sval = m.get_rvalue (m_expr, NULL);\n+  sval->dump_to_pp (pp, true);\n+  pp_string (pp, \" in \");\n+  m_ranges->dump_to_pp (pp, true);\n+}\n+\n /* class engine.  */\n \n /* Dump the managed objects by class to LOGGER, and the per-class totals.  */"}, {"sha": "f2c82b0dd807553e1289b9da77c05a2c337089bd", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -189,13 +189,15 @@ struct purge_stats\n     m_num_regions (0),\n     m_num_equiv_classes (0),\n     m_num_constraints (0),\n+    m_num_bounded_ranges_constraints (0),\n     m_num_client_items (0)\n   {}\n \n   int m_num_svalues;\n   int m_num_regions;\n   int m_num_equiv_classes;\n   int m_num_constraints;\n+  int m_num_bounded_ranges_constraints;\n   int m_num_client_items;\n };\n \n@@ -320,6 +322,7 @@ class region_model_manager\n   unsigned alloc_region_id () { return m_next_region_id++; }\n \n   store_manager *get_store_manager () { return &m_store_mgr; }\n+  bounded_ranges_manager *get_range_manager () const { return m_range_mgr; }\n \n   /* Dynamically-allocated region instances.\n      The number of these within the analysis can grow arbitrarily.\n@@ -456,6 +459,8 @@ class region_model_manager\n \n   store_manager m_store_mgr;\n \n+  bounded_ranges_manager *m_range_mgr;\n+\n   /* \"Dynamically-allocated\" region instances.\n      The number of these within the analysis can grow arbitrarily.\n      They are still owned by the manager.  */\n@@ -698,6 +703,10 @@ class region_model\n   void unset_dynamic_extents (const region *reg);\n \n   region_model_manager *get_manager () const { return m_mgr; }\n+  bounded_ranges_manager *get_range_manager () const\n+  {\n+    return m_mgr->get_range_manager ();\n+  }\n \n   void unbind_region_and_descendents (const region *reg,\n \t\t\t\t      enum poison_kind pkind);\n@@ -945,21 +954,54 @@ struct model_merger\n /* A record that can (optionally) be written out when\n    region_model::add_constraint fails.  */\n \n-struct rejected_constraint\n+class rejected_constraint\n {\n-  rejected_constraint (const region_model &model,\n-\t\t     tree lhs, enum tree_code op, tree rhs)\n-  : m_model (model), m_lhs (lhs), m_op (op), m_rhs (rhs)\n-  {}\n+public:\n+  virtual ~rejected_constraint () {}\n+  virtual void dump_to_pp (pretty_printer *pp) const = 0;\n \n-  void dump_to_pp (pretty_printer *pp) const;\n+  const region_model &get_model () const { return m_model; }\n+\n+protected:\n+  rejected_constraint (const region_model &model)\n+  : m_model (model)\n+  {}\n \n   region_model m_model;\n+};\n+\n+class rejected_op_constraint : public rejected_constraint\n+{\n+public:\n+  rejected_op_constraint (const region_model &model,\n+\t\t\t  tree lhs, enum tree_code op, tree rhs)\n+  : rejected_constraint (model),\n+    m_lhs (lhs), m_op (op), m_rhs (rhs)\n+  {}\n+\n+  void dump_to_pp (pretty_printer *pp) const FINAL OVERRIDE;\n+\n   tree m_lhs;\n   enum tree_code m_op;\n   tree m_rhs;\n };\n \n+class rejected_ranges_constraint : public rejected_constraint\n+{\n+public:\n+  rejected_ranges_constraint (const region_model &model,\n+\t\t\t      tree expr, const bounded_ranges *ranges)\n+  : rejected_constraint (model),\n+    m_expr (expr), m_ranges (ranges)\n+  {}\n+\n+  void dump_to_pp (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+private:\n+  tree m_expr;\n+  const bounded_ranges *m_ranges;\n+};\n+\n /* A bundle of state.  */\n \n class engine"}, {"sha": "85acf44d045f6e19d657e30c7414289d00b6eac7", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 74, "deletions": 25, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"cfg.h\"\n #include \"digraph.h\"\n+#include \"tree-cfg.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/analyzer-logging.h\"\n \n@@ -246,7 +247,7 @@ supergraph::supergraph (logger *logger)\n \t      supernode *dest_supernode\n \t\t= *m_bb_to_initial_node.get (dest_cfg_block);\n \t      cfg_superedge *cfg_sedge\n-\t\t= add_cfg_edge (src_supernode, dest_supernode, cfg_edge, idx);\n+\t\t= add_cfg_edge (src_supernode, dest_supernode, cfg_edge);\n \t      m_cfg_edge_to_cfg_superedge.put (cfg_edge, cfg_sedge);\n \t    }\n       }\n@@ -505,17 +506,16 @@ supergraph::add_node (function *fun, basic_block bb, gcall *returning_call,\n    adding it to this supergraph.\n \n    If the edge is for a switch statement, create a switch_cfg_superedge\n-   subclass using IDX (the index of E within the out-edges from SRC's\n-   underlying basic block).  */\n+   subclass.  */\n \n cfg_superedge *\n-supergraph::add_cfg_edge (supernode *src, supernode *dest, ::edge e, int idx)\n+supergraph::add_cfg_edge (supernode *src, supernode *dest, ::edge e)\n {\n   /* Special-case switch edges.  */\n   gimple *stmt = src->get_last_stmt ();\n   cfg_superedge *new_edge;\n   if (stmt && stmt->code == GIMPLE_SWITCH)\n-    new_edge = new switch_cfg_superedge (src, dest, e, idx);\n+    new_edge = new switch_cfg_superedge (src, dest, e);\n   else\n     new_edge = new cfg_superedge (src, dest, e);\n   add_edge (new_edge);\n@@ -1072,6 +1072,23 @@ cfg_superedge::get_phi_arg (const gphi *phi) const\n   return gimple_phi_arg_def (phi, index);\n }\n \n+switch_cfg_superedge::switch_cfg_superedge (supernode *src,\n+\t\t\t\t\t    supernode *dst,\n+\t\t\t\t\t    ::edge e)\n+: cfg_superedge (src, dst, e)\n+{\n+  /* Populate m_case_labels with all cases which go to DST.  */\n+  const gswitch *gswitch = get_switch_stmt ();\n+  for (unsigned i = 0; i < gimple_switch_num_labels (gswitch); i++)\n+    {\n+      tree case_ = gimple_switch_label (gswitch, i);\n+      basic_block bb = label_to_block (src->get_function (),\n+\t\t\t\t       CASE_LABEL (case_));\n+      if (bb == dst->m_bb)\n+\tm_case_labels.safe_push (case_);\n+    }\n+}\n+\n /* Implementation of superedge::dump_label_to_pp for CFG superedges for\n    \"switch\" statements.\n \n@@ -1081,31 +1098,63 @@ void\n switch_cfg_superedge::dump_label_to_pp (pretty_printer *pp,\n \t\t\t\t\tbool user_facing ATTRIBUTE_UNUSED) const\n {\n-  tree case_label = get_case_label ();\n-  gcc_assert (TREE_CODE (case_label) == CASE_LABEL_EXPR);\n-  tree lower_bound = CASE_LOW (case_label);\n-  tree upper_bound = CASE_HIGH (case_label);\n-  if (lower_bound)\n+  if (user_facing)\n     {\n-      pp_printf (pp, \"case \");\n-      dump_generic_node (pp, lower_bound, 0, (dump_flags_t)0, false);\n-      if (upper_bound)\n+      for (unsigned i = 0; i < m_case_labels.length (); ++i)\n \t{\n-\t  pp_printf (pp, \" ... \");\n-\t  dump_generic_node (pp, upper_bound, 0, (dump_flags_t)0, false);\n+\t  if (i > 0)\n+\t    pp_string (pp, \", \");\n+\t  tree case_label = m_case_labels[i];\n+\t  gcc_assert (TREE_CODE (case_label) == CASE_LABEL_EXPR);\n+\t  tree lower_bound = CASE_LOW (case_label);\n+\t  tree upper_bound = CASE_HIGH (case_label);\n+\t  if (lower_bound)\n+\t    {\n+\t      pp_printf (pp, \"case \");\n+\t      dump_generic_node (pp, lower_bound, 0, (dump_flags_t)0, false);\n+\t      if (upper_bound)\n+\t\t{\n+\t\t  pp_printf (pp, \" ... \");\n+\t\t  dump_generic_node (pp, upper_bound, 0, (dump_flags_t)0,\n+\t\t\t\t     false);\n+\t\t}\n+\t      pp_printf (pp, \":\");\n+\t    }\n+\t  else\n+\t    pp_printf (pp, \"default:\");\n \t}\n-      pp_printf (pp, \":\");\n     }\n   else\n-    pp_printf (pp, \"default:\");\n-}\n-\n-/* Get the case label for this \"switch\" superedge.  */\n-\n-tree\n-switch_cfg_superedge::get_case_label () const\n-{\n-  return gimple_switch_label (get_switch_stmt (), m_idx);\n+    {\n+      pp_character (pp, '{');\n+      for (unsigned i = 0; i < m_case_labels.length (); ++i)\n+\t{\n+\t  if (i > 0)\n+\t    pp_string (pp, \", \");\n+\t  tree case_label = m_case_labels[i];\n+\t  gcc_assert (TREE_CODE (case_label) == CASE_LABEL_EXPR);\n+\t  tree lower_bound = CASE_LOW (case_label);\n+\t  tree upper_bound = CASE_HIGH (case_label);\n+\t  if (lower_bound)\n+\t    {\n+\t      if (upper_bound)\n+\t\t{\n+\t\t  pp_character (pp, '[');\n+\t\t  dump_generic_node (pp, lower_bound, 0, (dump_flags_t)0,\n+\t\t\t\t     false);\n+\t\t  pp_string (pp, \", \");\n+\t\t  dump_generic_node (pp, upper_bound, 0, (dump_flags_t)0,\n+\t\t\t\t     false);\n+\t\t  pp_character (pp, ']');\n+\t\t}\n+\t      else\n+\t\tdump_generic_node (pp, lower_bound, 0, (dump_flags_t)0, false);\n+\t    }\n+\t  else\n+\t    pp_printf (pp, \"default\");\n+\t}\n+      pp_character (pp, '}');\n+    }\n }\n \n /* Implementation of superedge::dump_label_to_pp for interprocedural"}, {"sha": "09a12be483d15ce9b76d600e0c6a77c1514588d8", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -181,7 +181,7 @@ class supergraph : public digraph<supergraph_traits>\n private:\n   supernode *add_node (function *fun, basic_block bb, gcall *returning_call,\n \t\t       gimple_seq phi_nodes);\n-  cfg_superedge *add_cfg_edge (supernode *src, supernode *dest, ::edge e, int idx);\n+  cfg_superedge *add_cfg_edge (supernode *src, supernode *dest, ::edge e);\n   call_superedge *add_call_superedge (supernode *src, supernode *dest,\n \t\t\t\t      cgraph_edge *cedge);\n   return_superedge *add_return_superedge (supernode *src, supernode *dest,\n@@ -539,15 +539,12 @@ is_a_helper <const cfg_superedge *>::test (const superedge *sedge)\n namespace ana {\n \n /* A subclass for edges from switch statements, retaining enough\n-   information to identify the pertinent case, and for adding labels\n+   information to identify the pertinent cases, and for adding labels\n    when rendering via graphviz.  */\n \n class switch_cfg_superedge : public cfg_superedge {\n  public:\n-  switch_cfg_superedge (supernode *src, supernode *dst, ::edge e, int idx)\n-  : cfg_superedge (src, dst, e),\n-    m_idx (idx)\n-  {}\n+  switch_cfg_superedge (supernode *src, supernode *dst, ::edge e);\n \n   const switch_cfg_superedge *dyn_cast_switch_cfg_superedge () const\n     FINAL OVERRIDE\n@@ -563,10 +560,10 @@ class switch_cfg_superedge : public cfg_superedge {\n     return as_a <gswitch *> (m_src->get_last_stmt ());\n   }\n \n-  tree get_case_label () const;\n+  const vec<tree> &get_case_labels () const { return m_case_labels; }\n \n- private:\n-  const int m_idx;\n+private:\n+  auto_vec<tree> m_case_labels;\n };\n \n } // namespace ana"}, {"sha": "0b9e7e3b869836a9c425217991006054fb72fe54", "filename": "gcc/testsuite/gcc.dg/analyzer/switch.c", "status": "modified", "additions": 137, "deletions": 4, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -8,23 +8,156 @@ void test (int i)\n     {\n     case 0:\n       __analyzer_eval (i == 0); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != -1); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != 0); /* { dg-warning \"FALSE\" } */\n+      __analyzer_eval (i != 1); /* { dg-warning \"TRUE\" } */\n       break;\n \n     case 3 ... 5:\n+      __analyzer_eval (i != 0); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i > 1); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i > 2); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i >= 2); /* { dg-warning \"TRUE\" } */\n       __analyzer_eval (i >= 3); /* { dg-warning \"TRUE\" } */\n       __analyzer_eval (i <= 5); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i < 6); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i <= 6); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i < 7); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != 6); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != 3); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i != 4); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i != 5); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i >= 4); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i >= 5); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i <= 3); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i <= 4); /* { dg-warning \"UNKNOWN\" } */\n       break;\n \n     default:\n+      __analyzer_eval (i == -1); /* { dg-warning \"UNKNOWN\" } */\n       __analyzer_eval (i == 0); /* { dg-warning \"FALSE\" } */\n       __analyzer_eval (i == 2); /* { dg-warning \"UNKNOWN\" } */\n       __analyzer_eval (i == 3); /* { dg-warning \"FALSE\" } */\n-      __analyzer_eval (i == 4); /* { dg-warning \"FALSE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-      /* TODO(xfail^^^): we're only checking against endpoints of case\n-\t ranges, not the insides.  */\n+      __analyzer_eval (i == 4); /* { dg-warning \"FALSE\" } */\n       __analyzer_eval (i == 5); /* { dg-warning \"FALSE\" } */\n       __analyzer_eval (i == 6); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i != 0); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != 1); /* { dg-warning \"UNKNOWN\" } */\n+      __analyzer_eval (i != 3); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != 4); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != 5); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (i != 6); /* { dg-warning \"UNKNOWN\" } */\n       break;\n     }\n }\n+\n+/* Verify that the analyzer follows the correct paths on a\n+   switch statement guarded by an if, using noinline to defeat\n+   optimizations.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_2 (int y)\n+{\n+  switch (y)\n+    {\n+    case 0:\n+      __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+      break;\n+    case 1:\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      break;\n+    case 2:\n+      __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+      break;\n+    default:\n+      __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+      break;\n+    }\n+}\n+\n+void test_2 (int x)\n+{\n+  if (x == 1)\n+    __analyzer_called_by_test_2 (x);\n+}\n+\n+void test_3 (int x, int y)\n+{\n+  if (y == 3)\n+    switch (x)\n+      {\n+      case 0 ... 9:\n+      case 20 ... 29:\n+\tif (x == y)\n+\t  __analyzer_dump_path (); /* { dg-message \"path\" } */\n+\telse\n+\t  __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      }\n+}\n+\n+struct s4\n+{\n+  unsigned char level:3;\n+  unsigned char key_id_mode:2;\n+  unsigned char reserved:3;\n+};\n+\n+void test_4 (struct s4 *p)\n+{\n+  switch (p->key_id_mode)\n+    {\n+    case 0:\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      break;\n+    case 1:\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      break;\n+    case 2:\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      break;\n+    case 3:\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      break;\n+    }\n+  __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+int test_5 (unsigned v)\n+{\n+  switch (v)\n+    {\n+    case 0:\n+      return 7;\n+      break;\n+    case 1:\n+      return 23;\n+      break;\n+    default:\n+      return v * 2;\n+    }\n+}\n+\n+int test_6 (unsigned v)\n+{\n+  switch (v)\n+    {\n+    case 0:\n+      return 3;\n+    case -1:\n+      return 22;\n+    }\n+  return -3;\n+}\n+\n+int g7 = -1;\n+int test_7 ()\n+{\n+\tswitch (g7++) {\n+\tcase 0:\n+\t  return 32;\n+\n+\tcase 100:\n+\t  return 42;\n+\t}\n+\treturn 0;\n+}"}, {"sha": "3da2e301b146aef158b5377bde2f2f9ec661d174", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/switch-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-2.c?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -0,0 +1,42 @@\n+struct s\n+{\n+  int f0;\n+  int f1;\n+};\n+\n+int test (int cmd)\n+{\n+  int err = 0;\n+  struct s foo;\n+  struct s bar;\n+  \n+  switch (cmd)\n+    {\n+    case 0:\n+      foo.f0 = 0;\n+      break;\n+    case 1:\n+      foo.f0 = 1;\n+      break;\n+    case 30 ... 50:\n+    case 70 ... 80:\n+      __builtin_memset (&bar, 0, sizeof (bar));\n+      break;      \n+    }\n+\n+  switch (cmd)\n+    {\n+    default:\n+      return -1;\n+    case 0 ... 1:\n+      return foo.f0;\n+      break;\n+    case 42:\n+      return bar.f1;\n+      break;\n+    case 65:\n+      return bar.f1;\n+      break;\n+    }\n+  return err;\n+}"}, {"sha": "57b8acdb29290b09083c45602baeefc179e49b84", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/switch-3.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-3.c?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -0,0 +1,158 @@\n+typedef unsigned int __u32;\n+__extension__ typedef unsigned long long __u64;\n+\n+extern unsigned long\n+copy_from_user(void *to, const void *from, unsigned long n);\n+\n+extern unsigned long\n+copy_to_user(void *to, const void *from, unsigned long n);\n+\n+struct mtrr_sentry {\n+  __u64 base;\n+  __u32 size;\n+  __u32 type;\n+};\n+\n+struct mtrr_gentry {\n+  __u64 base;\n+  __u32 size;\n+  __u32 regnum;\n+  __u32 type;\n+  __u32 _pad;\n+};\n+\n+#define _IOC_NRBITS\t8\n+#define _IOC_TYPEBITS\t8\n+#define _IOC_SIZEBITS\t14\n+#define _IOC_DIRBITS\t2\n+\n+#define _IOC_NRSHIFT\t0\n+#define _IOC_TYPESHIFT\t(_IOC_NRSHIFT+_IOC_NRBITS)\n+#define _IOC_SIZESHIFT\t(_IOC_TYPESHIFT+_IOC_TYPEBITS)\n+#define _IOC_DIRSHIFT\t(_IOC_SIZESHIFT+_IOC_SIZEBITS)\n+\n+#define _IOC_WRITE\t1U\n+#define _IOC_READ\t2U\n+\n+#define _IOC(dir,type,nr,size) \\\n+\t(((dir)  << _IOC_DIRSHIFT) | \\\n+\t ((type) << _IOC_TYPESHIFT) | \\\n+\t ((nr)   << _IOC_NRSHIFT) | \\\n+\t ((size) << _IOC_SIZESHIFT))\n+\n+#define _IOC_TYPECHECK(t) (sizeof(t))\n+\n+#define _IOW(type,nr,size)\t_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n+#define _IOWR(type,nr,size)\t_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n+\n+#define MTRR_IOCTL_BASE 'M'\n+\n+#define\tEFAULT\t\t14\n+#define\tEINVAL\t\t22\n+#define\tENOTTY\t\t25\n+\n+#define MTRRIOC_ADD_ENTRY        _IOW(MTRR_IOCTL_BASE,  0, struct mtrr_sentry)\n+#define MTRRIOC_SET_ENTRY        _IOW(MTRR_IOCTL_BASE,  1, struct mtrr_sentry)\n+#define MTRRIOC_DEL_ENTRY        _IOW(MTRR_IOCTL_BASE,  2, struct mtrr_sentry)\n+#define MTRRIOC_GET_ENTRY        _IOWR(MTRR_IOCTL_BASE, 3, struct mtrr_gentry)\n+#define MTRRIOC_KILL_ENTRY       _IOW(MTRR_IOCTL_BASE,  4, struct mtrr_sentry)\n+#define MTRRIOC_ADD_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  5, struct mtrr_sentry)\n+#define MTRRIOC_SET_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  6, struct mtrr_sentry)\n+#define MTRRIOC_DEL_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  7, struct mtrr_sentry)\n+#define MTRRIOC_GET_PAGE_ENTRY   _IOWR(MTRR_IOCTL_BASE, 8, struct mtrr_gentry)\n+#define MTRRIOC_KILL_PAGE_ENTRY  _IOW(MTRR_IOCTL_BASE,  9, struct mtrr_sentry)\n+\n+extern void check_init_u64 (__u64 v);\n+extern void check_init_u32 (__u32 v);\n+\n+/* Adapted/reduced from arch/x86/kernel/cpu/mtrr/if.c: mtrr_ioctl,\n+   which is GPL-2.0  */\n+\n+long mtrr_ioctl(unsigned int cmd, unsigned long __arg) {\n+  int err = 0;\n+  struct mtrr_sentry sentry;\n+  struct mtrr_gentry gentry;\n+  void *arg = (void *)__arg;\n+\n+  __builtin_memset(&gentry, 0, sizeof(gentry));\n+\n+  switch (cmd) {\n+\tcase MTRRIOC_ADD_ENTRY:\n+\tcase MTRRIOC_SET_ENTRY:\n+\tcase MTRRIOC_DEL_ENTRY:\n+\tcase MTRRIOC_KILL_ENTRY:\n+\tcase MTRRIOC_ADD_PAGE_ENTRY:\n+\tcase MTRRIOC_SET_PAGE_ENTRY:\n+\tcase MTRRIOC_DEL_PAGE_ENTRY:\n+\tcase MTRRIOC_KILL_PAGE_ENTRY:\n+\t\tif (copy_from_user(&sentry, arg, sizeof(sentry)))\n+\t\t\treturn -EFAULT;\n+\t\tbreak;\n+\tcase MTRRIOC_GET_ENTRY:\n+\tcase MTRRIOC_GET_PAGE_ENTRY:\n+\t\tif (copy_from_user(&gentry, arg, sizeof(gentry)))\n+\t\t\treturn -EFAULT;\n+\t\tbreak;\n+  }\n+\n+  switch (cmd) {\n+\tdefault:\n+\t\treturn -ENOTTY;\n+\tcase MTRRIOC_ADD_ENTRY:\n+\t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_SET_ENTRY:\n+\t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_DEL_ENTRY:\n+\t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_KILL_ENTRY:\n+ \t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_GET_ENTRY:\n+ \t  check_init_u64 (gentry.base);\n+\t  check_init_u32 (gentry.size);\n+\t  check_init_u32 (gentry.regnum);\n+\t  check_init_u32 (gentry.type);\n+\t  check_init_u32 (gentry._pad);\n+\t  break;\n+\tcase MTRRIOC_ADD_PAGE_ENTRY:\n+ \t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_SET_PAGE_ENTRY:\n+ \t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_DEL_PAGE_ENTRY:\n+ \t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_KILL_PAGE_ENTRY:\n+ \t  check_init_u64 (sentry.base);\n+\t  check_init_u32 (sentry.size);\n+\t  check_init_u32 (sentry.type);\n+\t  break;\n+\tcase MTRRIOC_GET_PAGE_ENTRY:\n+ \t  check_init_u64 (gentry.base);\n+\t  check_init_u32 (gentry.size);\n+\t  check_init_u32 (gentry.regnum);\n+\t  check_init_u32 (gentry.type);\n+\t  check_init_u32 (gentry._pad);\n+\t  break;\n+  }\n+\n+ return err;\n+}"}, {"sha": "f5cdb5cea016a8bad4351da445ce6025eb4e010e", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/switch-4.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-4.c?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -0,0 +1,27 @@\n+struct snd_ac97 {\n+  // snip\n+  unsigned int id;\n+  // snip\n+};\n+\n+int snd_ac97_valid_reg(struct snd_ac97 *ac97, unsigned short reg) {\n+\n+  switch (ac97->id) {\n+  case 0x53544d02:\n+    if (reg == 0x22 || reg == 0x7a)\n+      return 1;\n+    __attribute__((__fallthrough__));\n+  case 0x414b4d00:\n+    return 0;\n+  }\n+  return 1;\n+}\n+\n+int snd_ac97_update_bits(struct snd_ac97 *ac97, unsigned short reg) {\n+  if (ac97->id == 0x414c4781)\n+    {\n+      if (!snd_ac97_valid_reg(ac97, reg))\n+\treturn -22;\n+    }\n+  return 0;\n+}"}, {"sha": "10b2f29c680108da10a5cad24cad80fa5bf10f0b", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/switch-5.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca7fa84a3af355c3e2bbda2acc61934c16078b2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fswitch-5.c?ref=8ca7fa84a3af355c3e2bbda2acc61934c16078b2", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries\" } */\n+\n+typedef unsigned char u8;\n+typedef signed int s32;\n+typedef unsigned int u32;\n+\n+enum v4l2_mpeg_video_hevc_profile {\n+  V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN = 0,\n+  V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE = 1,\n+  V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10 = 2\n+};\n+enum v4l2_buf_type {\n+  V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,\n+  V4L2_BUF_TYPE_VIDEO_OUTPUT = 2\n+};\n+struct v4l2_fmtdesc {\n+  u32 index;\n+  u32 type;\n+};\n+struct v4l2_ctrl;\n+s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl);\n+struct create_channel_param {\n+  u8 profile;\n+};\n+\n+u8\n+hevc_profile_to_mcu_profile(enum v4l2_mpeg_video_hevc_profile profile) {\n+  switch (profile) {\n+  default:\n+  case V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN:\n+    return 1;\n+  case V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10:\n+    return 2;\n+  case V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE:\n+    return 3;\n+  }\n+}\n+\n+int fill_create_channel_param(struct v4l2_ctrl *ctrl,\n+\t\t\t      struct create_channel_param *param) {\n+  enum v4l2_mpeg_video_hevc_profile profile;\n+  profile = v4l2_ctrl_g_ctrl(ctrl);\n+  param->profile = hevc_profile_to_mcu_profile(profile);\n+  return 0;\n+}\n+\n+int allegro_enum_fmt_vid(struct v4l2_fmtdesc *f) {\n+  switch (f->type) {\n+  case V4L2_BUF_TYPE_VIDEO_OUTPUT:\n+    if (f->index >= 1)\n+      return -22;\n+    break;\n+  case V4L2_BUF_TYPE_VIDEO_CAPTURE:\n+    if (f->index >= 2)\n+      return -22;\n+    break;\n+  default:\n+    return -22;\n+  }\n+  return 0;\n+}\n+\n+int allegro_ioctl_streamon(struct v4l2_ctrl *ctrl,\n+\t\t\t   struct create_channel_param *param) {\n+  fill_create_channel_param(ctrl, param);\n+\n+  return 0;\n+}"}]}