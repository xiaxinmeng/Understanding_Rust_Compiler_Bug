{"sha": "c2a12ca06dd0762c03ec8f0f3be3feb096119386", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJhMTJjYTA2ZGQwNzYyYzAzZWM4ZjBmM2JlM2ZlYjA5NjExOTM4Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-11-12T14:59:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-11-12T14:59:26Z"}, "message": "tree-vectorizer.h (vect_slp_analyze_data_ref_dependences): Rename to vect_slp_analyze_instance_dependence.\n\n2015-11-12  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_slp_analyze_data_ref_dependences):\n\tRename to vect_slp_analyze_instance_dependence.\n\t* tree-vect-data-refs.c (vect_slp_analyze_data_ref_dependence):\n\tRemove WAR special-case.\n\t(vect_slp_analyze_node_dependences): Instead add more specific\n\tcode here, not relying on other instances being vectorized.\n\t(vect_slp_analyze_instance_dependence): Adjust accordingly.\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove excessive\n\tvertical space in dump files.\n\t(vect_print_slp_tree): Likewise.\n\t(vect_analyze_slp_instance): Dump a header for the final SLP tree.\n\t(vect_slp_analyze_bb_1): Delay computing relevant stmts and\n\tnot vectorized stmts until after dependence analysis removed\n\tinstances.  Merge alignment and dependence checks.\n\t* tree-vectorizer.c (pass_slp_vectorize::execute): Clear visited\n\tflag on all stmts.\n\nFrom-SVN: r230262", "tree": {"sha": "f3d1556263ab224db98ddf189c9395bd0690deb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3d1556263ab224db98ddf189c9395bd0690deb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2a12ca06dd0762c03ec8f0f3be3feb096119386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a12ca06dd0762c03ec8f0f3be3feb096119386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a12ca06dd0762c03ec8f0f3be3feb096119386", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a12ca06dd0762c03ec8f0f3be3feb096119386/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50487d7978c5cafd044cf58c5e705175f5a671a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50487d7978c5cafd044cf58c5e705175f5a671a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50487d7978c5cafd044cf58c5e705175f5a671a9"}], "stats": {"total": 214, "additions": 115, "deletions": 99}, "files": [{"sha": "f994dabb2c97f0a5a1ab28542144d31fb4cca871", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2a12ca06dd0762c03ec8f0f3be3feb096119386", "patch": "@@ -1,3 +1,22 @@\n+2015-11-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_slp_analyze_data_ref_dependences):\n+\tRename to vect_slp_analyze_instance_dependence.\n+\t* tree-vect-data-refs.c (vect_slp_analyze_data_ref_dependence):\n+\tRemove WAR special-case.\n+\t(vect_slp_analyze_node_dependences): Instead add more specific\n+\tcode here, not relying on other instances being vectorized.\n+\t(vect_slp_analyze_instance_dependence): Adjust accordingly.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove excessive\n+\tvertical space in dump files.\n+\t(vect_print_slp_tree): Likewise.\n+\t(vect_analyze_slp_instance): Dump a header for the final SLP tree.\n+\t(vect_slp_analyze_bb_1): Delay computing relevant stmts and\n+\tnot vectorized stmts until after dependence analysis removed\n+\tinstances.  Merge alignment and dependence checks.\n+\t* tree-vectorizer.c (pass_slp_vectorize::execute): Clear visited\n+\tflag on all stmts.\n+\n 2015-11-12  Evandro Menezes  <e.menezes@samsung.com>\n \n \t* config/aarch64/aarch64-protos.h (tune_params): Add new members"}, {"sha": "590d363b731af65ddf9a7bdcd8b9f443d13ba429", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 70, "deletions": 59, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c2a12ca06dd0762c03ec8f0f3be3feb096119386", "patch": "@@ -537,32 +537,17 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n       dump_printf (MSG_NOTE,  \"\\n\");\n     }\n \n-  /* We do not vectorize basic blocks with write-write dependencies.  */\n-  if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n-    return true;\n-\n-  /* If we have a read-write dependence check that the load is before the store.\n-     When we vectorize basic blocks, vector load can be only before\n-     corresponding scalar load, and vector store can be only after its\n-     corresponding scalar store.  So the order of the acceses is preserved in\n-     case the load is before the store.  */\n-  gimple *earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n-  if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n-    {\n-      /* That only holds for load-store pairs taking part in vectorization.  */\n-      if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dra)))\n-\t  && STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (drb))))\n-\treturn false;\n-    }\n-\n   return true;\n }\n \n \n-/* Analyze dependences involved in the transform of SLP NODE.  */\n+/* Analyze dependences involved in the transform of SLP NODE.  STORES\n+   contain the vector of scalar stores of this instance if we are\n+   disambiguating the loads.  */\n \n static bool\n-vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node)\n+vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n+\t\t\t\t   vec<gimple *> stores, gimple *last_store)\n {\n   /* This walks over all stmts involved in the SLP load/store done\n      in NODE verifying we can sink them up to the last stmt in the\n@@ -584,15 +569,40 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node)\n \n \t  /* If we couldn't record a (single) data reference for this\n \t     stmt we have to give up.  */\n+\t  /* ???  Here and below if dependence analysis fails we can resort\n+\t     to the alias oracle which can handle more kinds of stmts.  */\n \t  data_reference *dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n \t  if (!dr_b)\n \t    return false;\n \n+\t  /* If we run into a store of this same instance (we've just\n+\t     marked those) then delay dependence checking until we run\n+\t     into the last store because this is where it will have\n+\t     been sunk to (and we verify if we can do that as well).  */\n+\t  if (gimple_visited_p (stmt))\n+\t    {\n+\t      if (stmt != last_store)\n+\t\tcontinue;\n+\t      unsigned i;\n+\t      gimple *store;\n+\t      FOR_EACH_VEC_ELT (stores, i, store)\n+\t\t{\n+\t\t  data_reference *store_dr\n+\t\t    = STMT_VINFO_DATA_REF (vinfo_for_stmt (store));\n+\t\t  ddr_p ddr = initialize_data_dependence_relation\n+\t\t\t\t(dr_a, store_dr, vNULL);\n+\t\t  if (vect_slp_analyze_data_ref_dependence (ddr))\n+\t\t    {\n+\t\t      free_dependence_relation (ddr);\n+\t\t      return false;\n+\t\t    }\n+\t\t  free_dependence_relation (ddr);\n+\t\t}\n+\t    }\n+\n \t  ddr_p ddr = initialize_data_dependence_relation (dr_a, dr_b, vNULL);\n \t  if (vect_slp_analyze_data_ref_dependence (ddr))\n \t    {\n-\t      /* ???  If the dependence analysis failed we can resort to the\n-\t\t alias oracle which can handle more kinds of stmts.  */\n \t      free_dependence_relation (ddr);\n \t      return false;\n \t    }\n@@ -610,52 +620,53 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node)\n    the maximum vectorization factor the data dependences allow.  */\n \n bool\n-vect_slp_analyze_data_ref_dependences (bb_vec_info bb_vinfo)\n+vect_slp_analyze_instance_dependence (slp_instance instance)\n {\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_slp_analyze_data_ref_dependences ===\\n\");\n+                     \"=== vect_slp_analyze_instance_dependence ===\\n\");\n \n-  slp_instance instance;\n-  slp_tree load;\n-  unsigned int i, j;\n-  for (i = 0; BB_VINFO_SLP_INSTANCES (bb_vinfo).iterate (i, &instance); )\n+  /* The stores of this instance are at the root of the SLP tree.  */\n+  slp_tree store = SLP_INSTANCE_TREE (instance);\n+  if (! STMT_VINFO_DATA_REF (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (store)[0])))\n+    store = NULL;\n+\n+  /* Verify we can sink stores to the vectorized stmt insert location.  */\n+  gimple *last_store = NULL;\n+  if (store)\n     {\n-      bool remove = false;\n-      /* Verify we can sink loads to the vectorized stmt insert location.  */\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, load)\n-\tif (! vect_slp_analyze_node_dependences (instance, load))\n-\t  {\n-\t    remove = true;\n-\t    break;\n-\t  }\n-      /* Verify we can sink stores to the vectorized stmt insert location.  */\n-      slp_tree store = SLP_INSTANCE_TREE (instance);\n-      if (!remove\n-\t  && STMT_VINFO_DATA_REF\n-\t\t(vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (store)[0]))\n-\t  && ! vect_slp_analyze_node_dependences (instance, store))\n-\tremove = true;\n-      if (remove)\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"removing SLP instance operations starting from: \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\t    SLP_TREE_SCALAR_STMTS\n-\t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n-\t  vect_free_slp_instance (instance);\n-\t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n-\t  continue;\n-\t}\n-      i++;\n+      if (! vect_slp_analyze_node_dependences (instance, store, vNULL, NULL))\n+\treturn false;\n+\n+      /* Mark stores in this instance and remember the last one.  */\n+      last_store = vect_find_last_scalar_stmt_in_slp (store);\n+      for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n+\tgimple_set_visited (SLP_TREE_SCALAR_STMTS (store)[k], true);\n     }\n \n-  if (!BB_VINFO_SLP_INSTANCES (bb_vinfo).length ())\n-    return false;\n+  bool res = true;\n \n-  return true;\n-}\n+  /* Verify we can sink loads to the vectorized stmt insert location,\n+     special-casing stores of this instance.  */\n+  slp_tree load;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), i, load)\n+    if (! vect_slp_analyze_node_dependences (instance, load,\n+\t\t\t\t\t     store\n+\t\t\t\t\t     ? SLP_TREE_SCALAR_STMTS (store)\n+\t\t\t\t\t     : vNULL, last_store))\n+      {\n+\tres = false;\n+\tbreak;\n+      }\n \n+  /* Unset the visited flag.  */\n+  if (store)\n+    for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n+      gimple_set_visited (SLP_TREE_SCALAR_STMTS (store)[k], false);\n+\n+  return res;\n+}\n \n /* Function vect_compute_data_ref_alignment\n "}, {"sha": "7873259625f24d398974d818c74c3b9202b3d29e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 19, "deletions": 37, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c2a12ca06dd0762c03ec8f0f3be3feb096119386", "patch": "@@ -458,7 +458,6 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-          dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n       /* Fail to vectorize statements marked as unvectorizable.  */\n@@ -1114,7 +1113,7 @@ vect_build_slp_tree (vec_info *vinfo,\n /* Dump a slp tree NODE using flags specified in DUMP_KIND.  */\n \n static void\n-vect_print_slp_tree (int dump_kind, slp_tree node)\n+vect_print_slp_tree (int dump_kind, location_t loc, slp_tree node)\n {\n   int i;\n   gimple *stmt;\n@@ -1123,16 +1122,14 @@ vect_print_slp_tree (int dump_kind, slp_tree node)\n   if (!node)\n     return;\n \n-  dump_printf (dump_kind, \"node \");\n+  dump_printf_loc (dump_kind, loc, \"node\\n\");\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n-      dump_printf (dump_kind, \"\\n\\tstmt %d \", i);\n+      dump_printf_loc (dump_kind, loc, \"\\tstmt %d \", i);\n       dump_gimple_stmt (dump_kind, TDF_SLIM, stmt, 0);\n     }\n-  dump_printf (dump_kind, \"\\n\");\n-\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_print_slp_tree (dump_kind, child);\n+    vect_print_slp_tree (dump_kind, loc, child);\n }\n \n \n@@ -1756,7 +1753,11 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       vinfo->slp_instances.safe_push (new_instance);\n \n       if (dump_enabled_p ())\n-\tvect_print_slp_tree (MSG_NOTE, node);\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"Final SLP tree for instance:\\n\");\n+\t  vect_print_slp_tree (MSG_NOTE, vect_location, node);\n+\t}\n \n       return true;\n     }\n@@ -2294,7 +2295,6 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t       bool &fatal)\n {\n   bb_vec_info bb_vinfo;\n-  vec<slp_instance> slp_instances;\n   slp_instance instance;\n   int i;\n   int min_vf = 2;\n@@ -2389,11 +2389,12 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n-  /* Analyze and verify the alignment of data references in the SLP\n-     instances.  */\n+  /* Analyze and verify the alignment of data references and the\n+     dependence in the SLP instances.  */\n   for (i = 0; BB_VINFO_SLP_INSTANCES (bb_vinfo).iterate (i, &instance); )\n     {\n-      if (! vect_slp_analyze_and_verify_instance_alignment (instance))\n+      if (! vect_slp_analyze_and_verify_instance_alignment (instance)\n+\t  || ! vect_slp_analyze_instance_dependence (instance))\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"removing SLP instance operations starting from: \");\n@@ -2404,25 +2405,20 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n \t  continue;\n \t}\n+\n+      /* Mark all the statements that we want to vectorize as pure SLP and\n+\t relevant.  */\n+      vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance), pure_slp, -1);\n+      vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n+\n       i++;\n     }\n-\n   if (! BB_VINFO_SLP_INSTANCES (bb_vinfo).length ())\n     {\n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n     }\n \n-  slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n-\n-  /* Mark all the statements that we want to vectorize as pure SLP and\n-     relevant.  */\n-  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n-    {\n-      vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance), pure_slp, -1);\n-      vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n-    }\n-\n   /* Mark all the statements that we do not want to vectorize.  */\n   for (gimple_stmt_iterator gsi = bb_vinfo->region_begin;\n        gsi_stmt (gsi) != gsi_stmt (bb_vinfo->region_end); gsi_next (&gsi))\n@@ -2432,20 +2428,6 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \tSTMT_VINFO_VECTORIZABLE (vinfo) = false;\n     }\n \n-  /* Analyze dependences.  At this point all stmts not participating in\n-     vectorization have to be marked.  Dependence analysis assumes\n-     that we either vectorize all SLP instances or none at all.  */\n-  if (! vect_slp_analyze_data_ref_dependences (bb_vinfo))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: unhandled data dependence \"\n-\t\t\t \"in basic block.\\n\");\n-\n-      destroy_bb_vec_info (bb_vinfo);\n-      return NULL;\n-    }\n-\n   if (!vect_slp_analyze_operations (BB_VINFO_SLP_INSTANCES (bb_vinfo),\n \t\t\t\t    BB_VINFO_TARGET_COST_DATA (bb_vinfo)))\n     {"}, {"sha": "08c80253caa8876930689eb97207365729e7d0d5", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c2a12ca06dd0762c03ec8f0f3be3feb096119386", "patch": "@@ -719,12 +719,16 @@ pass_slp_vectorize::execute (function *fun)\n       scev_initialize ();\n     }\n \n-  /* Mark all stmts as not belonging to the current region.  */\n+  /* Mark all stmts as not belonging to the current region and unvisited.  */\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n-\tgimple_set_uid (gsi_stmt (gsi), -1);\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple_set_uid (stmt, -1);\n+\t  gimple_set_visited (stmt, false);\n+\t}\n     }\n \n   init_stmt_vec_info_vec ();"}, {"sha": "5a6a24073b3301237ea57293b24346d7d5269985", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a12ca06dd0762c03ec8f0f3be3feb096119386/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c2a12ca06dd0762c03ec8f0f3be3feb096119386", "patch": "@@ -1009,7 +1009,7 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n extern tree vect_get_smallest_scalar_type (gimple *, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n extern bool vect_analyze_data_ref_dependences (loop_vec_info, int *);\n-extern bool vect_slp_analyze_data_ref_dependences (bb_vec_info);\n+extern bool vect_slp_analyze_instance_dependence (slp_instance);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n extern bool vect_analyze_data_refs_alignment (loop_vec_info);\n extern bool vect_verify_datarefs_alignment (loop_vec_info);"}]}