{"sha": "335a120f7fc249992772fbabe5ad9375443a0848", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM1YTEyMGY3ZmMyNDk5OTI3NzJmYmFiZTVhZDkzNzU0NDNhMDg0OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-06-20T14:34:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-06-20T14:34:06Z"}, "message": "[PR c++/85634] Fix tsubst ICE\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-06/msg01237.html\n\tPR c++/85634\n\t* cp-tree.h (lookup_keep): Drop KEEP parm.\n\t(lookup_list_keep): Delete.\n\t(maybe_get_fns): Declare.\n\t* parser.c (cp_parser_primary_expression): Call lookup_keep here.\n\t(cp_parser_template_id): Not here ...\n\t* decl.c (cp_finish_decl): ... nor here ...\n\t* init.c (build_raw_new_expr): ... nor here ...\n\t* pt.c (process_template_parm): ... nor here ...\n\t* semantics.c (perform_koenig_lookup): Call lookup_keep.\n\t(finish_call_expr): Not here.\n\t* tree.c (ovl_cache): Delete.\n\t(ovl_make, ovl_copy): No cache.\n\t(lookup_keep): Always keep.\n\t(lookup_list_keep): Delete.\n\t(maybe_get_fns): New, broken out of ...\n\t(get_fns): ... here.  Call it.\n\t(built_min_nt_loc, build_min, build_min_non_dep): Drop lookup_keep.\n\t(build_min_nt_call_vec): Likewise.\n\n\tPR c++/85634\n\t* g++.dg/lookup/pr85634.C: New.\n\nFrom-SVN: r261802", "tree": {"sha": "7a82856f99119d29b694d297474a71289c1eb1ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a82856f99119d29b694d297474a71289c1eb1ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/335a120f7fc249992772fbabe5ad9375443a0848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335a120f7fc249992772fbabe5ad9375443a0848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/335a120f7fc249992772fbabe5ad9375443a0848", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335a120f7fc249992772fbabe5ad9375443a0848/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b54006ae92d9df52acfa6fdc2046fadb74cca446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54006ae92d9df52acfa6fdc2046fadb74cca446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54006ae92d9df52acfa6fdc2046fadb74cca446"}], "stats": {"total": 215, "additions": 99, "deletions": 116}, "files": [{"sha": "822a18acc2ea088391fc98c2ea4b20b187d0ab0b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -1,3 +1,25 @@\n+2018-06-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/85634\n+\t* cp-tree.h (lookup_keep): Drop KEEP parm.\n+\t(lookup_list_keep): Delete.\n+\t(maybe_get_fns): Declare.\n+\t* parser.c (cp_parser_primary_expression): Call lookup_keep here.\n+\t(cp_parser_template_id): Not here ...\n+\t* decl.c (cp_finish_decl): ... nor here ...\n+\t* init.c (build_raw_new_expr): ... nor here ...\n+\t* pt.c (process_template_parm): ... nor here ...\n+\t* semantics.c (perform_koenig_lookup): Call lookup_keep.\n+\t(finish_call_expr): Not here.\n+\t* tree.c (ovl_cache): Delete.\n+\t(ovl_make, ovl_copy): No cache.\n+\t(lookup_keep): Always keep.\n+\t(lookup_list_keep): Delete.\n+\t(maybe_get_fns): New, broken out of ...\n+\t(get_fns): ... here.  Call it.\n+\t(built_min_nt_loc, build_min, build_min_non_dep): Drop lookup_keep.\n+\t(build_min_nt_call_vec): Likewise.\n+\n 2018-06-19  Jason Merrill  <jason@redhat.com>\n \n \t* cp-tree.h (CONSTRUCTOR_NO_IMPLICIT_ZERO): Remove."}, {"sha": "ee9242f9313eac9b6d504e5f0c6974c4d8cafea1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -7094,11 +7094,11 @@ extern void lookup_mark\t\t\t\t(tree lookup, bool val);\n extern tree lookup_add\t\t\t\t(tree fns, tree lookup);\n extern tree lookup_maybe_add\t\t\t(tree fns, tree lookup,\n \t\t\t\t\t\t bool deduping);\n-extern void lookup_keep\t\t\t\t(tree lookup, bool keep);\n-extern void lookup_list_keep\t\t\t(tree list, bool keep);\n+extern void lookup_keep\t\t\t\t(tree lookup);\n extern int is_overloaded_fn\t\t\t(tree) ATTRIBUTE_PURE;\n extern bool really_overloaded_fn\t\t(tree) ATTRIBUTE_PURE;\n extern tree dependent_name\t\t\t(tree);\n+extern tree maybe_get_fns\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree get_fns\t\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree get_first_fn\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree ovl_scope\t\t\t\t(tree);"}, {"sha": "f12a01b28f555acbf099e3bc5a0906b8d223c376", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -6973,11 +6973,8 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t}\n \n       if (init)\n-\t{\n-\t  if (TREE_CODE (init) == TREE_LIST)\n-\t    lookup_list_keep (init, true);\n-\t  DECL_INITIAL (decl) = init;\n-\t}\n+\tDECL_INITIAL (decl) = init;\n+\n       if (dep_init)\n \t{\n \t  retrofit_lang_decl (decl);"}, {"sha": "810a776a3c8a2a3df712dce7ab36db77b27bcaf6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -2403,12 +2403,7 @@ build_raw_new_expr (vec<tree, va_gc> *placement, tree type, tree nelts,\n   else if (init->is_empty ())\n     init_list = void_node;\n   else\n-    {\n-      init_list = build_tree_list_vec (init);\n-      for (tree v = init_list; v; v = TREE_CHAIN (v))\n-\tif (TREE_CODE (TREE_VALUE (v)) == OVERLOAD)\n-\t  lookup_keep (TREE_VALUE (v), true);\n-    }\n+    init_list = build_tree_list_vec (init);\n \n   new_expr = build4 (NEW_EXPR, build_pointer_type (type),\n \t\t     build_tree_list_vec (placement), type, nelts,"}, {"sha": "b618485ab2b6f281ee529ad7ee928e06cb3bdadd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -5603,6 +5603,14 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      }\n \t  }\n \n+\tif (processing_template_decl)\n+\t  if (tree fns = maybe_get_fns (decl))\n+\t    /* It's too difficult to mark ths in all the places where\n+\t       we know for sure we need to keep the lookup, so do it\n+\t       now.  The cost is extra GC to recycle the lookups\n+\t       resolved at parse time.  */\n+\t    lookup_keep (fns);\n+\n \tdecl = (finish_id_expression\n \t\t(id_expression, decl, parser->scope,\n \t\t idk,\n@@ -15989,11 +15997,6 @@ cp_parser_template_id (cp_parser *parser,\n       token->type = CPP_TEMPLATE_ID;\n       token->location = combined_loc;\n \n-      /* We must mark the lookup as kept, so we don't throw it away on\n-\t the first parse.  */\n-      if (is_overloaded_fn (template_id))\n-\tlookup_keep (get_fns (template_id), true);\n-\n       /* Retrieve any deferred checks.  Do not pop this access checks yet\n \t so the memory will not be reclaimed during token replacing below.  */\n       token->u.tree_check_value = ggc_cleared_alloc<struct tree_check> ();"}, {"sha": "be42b20df76df0c9a76b4a0129d03a5d8904ce2d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -4431,9 +4431,6 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n \n   pushdecl (decl);\n \n-  if (defval && TREE_CODE (defval) == OVERLOAD)\n-    lookup_keep (defval, true);\n-  \n   /* Build the parameter node linking the parameter declaration,\n      its default argument (if any), and its constraints (if any). */\n   parm = build_tree_list (defval, parm);"}, {"sha": "38b7b66e214859bffafc4070d12dfc148b31cf38", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -2325,6 +2325,11 @@ perform_koenig_lookup (cp_expr fn, vec<tree, va_gc> *args,\n \t  else\n \t    fn = identifier;\n \t}\n+      else if (TREE_CODE (fn) == OVERLOAD && processing_template_decl)\n+\t/* FIXME: We shouldn't really need to mark the lookup here, as\n+\t   resolving the (non-dependent) call should save the single\n+\t   function we resolve to.  Related to PR c++/83529.  */\n+\tlookup_keep (fn);\n     }\n \n   if (fn && template_id && fn != error_mark_node)\n@@ -2385,10 +2390,7 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t  SET_EXPR_LOCATION (result, cp_expr_loc_or_loc (fn, input_location));\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n \t  if (is_overloaded_fn (fn))\n-\t    {\n-\t      fn = get_fns (fn);\n-\t      lookup_keep (fn, true);\n-\t    }\n+\t    fn = get_fns (fn);\n \n \t  if (cfun)\n \t    {\n@@ -2575,10 +2577,6 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n       result = convert_from_reference (result);\n     }\n \n-  /* Free or retain OVERLOADs from lookup.  */\n-  if (is_overloaded_fn (orig_fn))\n-    lookup_keep (get_fns (orig_fn), processing_template_decl);\n-\n   return result;\n }\n "}, {"sha": "e7bd79b6276b7d30c5269f15d02332cf3cc68407", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 35, "deletions": 87, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -2131,25 +2131,12 @@ build_ref_qualified_type (tree type, cp_ref_qualifier rqual)\n   return build_cp_fntype_variant (type, rqual, raises, late);\n }\n \n-/* Cache of free ovl nodes.  Uses OVL_FUNCTION for chaining.  */\n-static GTY((deletable)) tree ovl_cache;\n-\n /* Make a raw overload node containing FN.  */\n \n tree\n ovl_make (tree fn, tree next)\n {\n-  tree result = ovl_cache;\n-\n-  if (result)\n-    {\n-      ovl_cache = OVL_FUNCTION (result);\n-      /* Zap the flags.  */\n-      memset (result, 0, sizeof (tree_base));\n-      TREE_SET_CODE (result, OVERLOAD);\n-    }\n-  else\n-    result = make_node (OVERLOAD);\n+  tree result = make_node (OVERLOAD);\n \n   if (TREE_CODE (fn) == OVERLOAD)\n     OVL_NESTED_P (result) = true;\n@@ -2164,17 +2151,7 @@ ovl_make (tree fn, tree next)\n static tree\n ovl_copy (tree ovl)\n {\n-  tree result = ovl_cache;\n-\n-  if (result)\n-    {\n-      ovl_cache = OVL_FUNCTION (result);\n-      /* Zap the flags.  */\n-      memset (result, 0, sizeof (tree_base));\n-      TREE_SET_CODE (result, OVERLOAD);\n-    }\n-  else\n-    result = make_node (OVERLOAD);\n+  tree result = make_node (OVERLOAD);\n \n   gcc_checking_assert (!OVL_NESTED_P (ovl) && OVL_USED_P (ovl));\n   TREE_TYPE (result) = TREE_TYPE (ovl);\n@@ -2413,44 +2390,22 @@ ovl_used (tree ovl)\n     }\n }\n \n-/* If KEEP is true, preserve the contents of a lookup so that it is\n-   available for a later instantiation.  Otherwise release the LOOKUP\n-   nodes for reuse.  */\n+/* Preserve the contents of a lookup so that it is available for a\n+   later instantiation.  */\n \n void\n-lookup_keep (tree lookup, bool keep)\n+lookup_keep (tree lookup)\n {\n   for (;\n        lookup && TREE_CODE (lookup) == OVERLOAD\n \t && OVL_LOOKUP_P (lookup) && !OVL_USED_P (lookup);\n        lookup = OVL_CHAIN (lookup))\n-    if (keep)\n-      {\n-\tOVL_USED_P (lookup) = true;\n-\tovl_used (OVL_FUNCTION (lookup));\n-      }\n-    else\n-      {\n-\tOVL_FUNCTION (lookup) = ovl_cache;\n-\tovl_cache = lookup;\n-      }\n-\n-  if (keep)\n-    ovl_used (lookup);\n-}\n-\n-/* LIST is a TREE_LIST whose TREE_VALUEs may be OVERLOADS that need\n-   keeping, or may be ignored.  */\n-\n-void\n-lookup_list_keep (tree list, bool keep)\n-{\n-  for (; list; list = TREE_CHAIN (list))\n     {\n-      tree v = TREE_VALUE (list);\n-      if (TREE_CODE (v) == OVERLOAD)\n-\tlookup_keep (v, keep);\n+      OVL_USED_P (lookup) = true;\n+      ovl_used (OVL_FUNCTION (lookup));\n     }\n+\n+  ovl_used (lookup);\n }\n \n /* Returns nonzero if X is an expression for a (possibly overloaded)\n@@ -2505,10 +2460,11 @@ really_overloaded_fn (tree x)\n   return is_overloaded_fn (x) == 2;\n }\n \n-/* Get the overload set FROM refers to.  */\n+/* Get the overload set FROM refers to.  Returns NULL if it's not an\n+   overload set.  */\n \n tree\n-get_fns (tree from)\n+maybe_get_fns (tree from)\n {\n   /* A baselink is also considered an overloaded function.  */\n   if (TREE_CODE (from) == OFFSET_REF\n@@ -2518,9 +2474,23 @@ get_fns (tree from)\n     from = BASELINK_FUNCTIONS (from);\n   if (TREE_CODE (from) == TEMPLATE_ID_EXPR)\n     from = TREE_OPERAND (from, 0);\n-  gcc_assert (TREE_CODE (from) == OVERLOAD\n-\t      || TREE_CODE (from) == FUNCTION_DECL);\n-  return from;\n+\n+  if (TREE_CODE (from) == OVERLOAD\n+      || TREE_CODE (from) == FUNCTION_DECL)\n+    return from;\n+\n+  return NULL;\n+}\n+\n+/* FROM refers to an overload set.  Return that set (or die).  */\n+\n+tree\n+get_fns (tree from)\n+{\n+  tree res = maybe_get_fns (from);\n+\n+  gcc_assert (res);\n+  return res;\n }\n \n /* Return the first function of the overload set FROM refers to.  */\n@@ -3306,12 +3276,7 @@ build_min_nt_loc (location_t loc, enum tree_code code, ...)\n   length = TREE_CODE_LENGTH (code);\n \n   for (i = 0; i < length; i++)\n-    {\n-      tree x = va_arg (p, tree);\n-      TREE_OPERAND (t, i) = x;\n-      if (x && TREE_CODE (x) == OVERLOAD)\n-\tlookup_keep (x, true);\n-    }\n+    TREE_OPERAND (t, i) = va_arg (p, tree);\n \n   va_end (p);\n   return t;\n@@ -3339,21 +3304,12 @@ build_min (enum tree_code code, tree tt, ...)\n     {\n       tree x = va_arg (p, tree);\n       TREE_OPERAND (t, i) = x;\n-      if (x)\n-\t{\n-\t  if (!TYPE_P (x) && TREE_SIDE_EFFECTS (x))\n-\t    TREE_SIDE_EFFECTS (t) = 1;\n-\t  if (TREE_CODE (x) == OVERLOAD)\n-\t    lookup_keep (x, true);\n-\t}\n+      if (x && !TYPE_P (x) && TREE_SIDE_EFFECTS (x))\n+\tTREE_SIDE_EFFECTS (t) = 1;\n     }\n \n   va_end (p);\n \n-  if (code == CAST_EXPR)\n-    /* The single operand is a TREE_LIST, which we have to check.  */\n-    lookup_list_keep (TREE_OPERAND (t, 0), true);\n-\n   return t;\n }\n \n@@ -3382,12 +3338,7 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n   TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (non_dep);\n \n   for (i = 0; i < length; i++)\n-    {\n-      tree x = va_arg (p, tree);\n-      TREE_OPERAND (t, i) = x;\n-      if (x && TREE_CODE (x) == OVERLOAD)\n-\tlookup_keep (x, true);\n-    }\n+    TREE_OPERAND (t, i) = va_arg (p, tree);\n \n   if (code == COMPOUND_EXPR && TREE_CODE (non_dep) != COMPOUND_EXPR)\n     /* This should not be considered a COMPOUND_EXPR, because it\n@@ -3410,11 +3361,8 @@ build_min_nt_call_vec (tree fn, vec<tree, va_gc> *args)\n   CALL_EXPR_FN (ret) = fn;\n   CALL_EXPR_STATIC_CHAIN (ret) = NULL_TREE;\n   FOR_EACH_VEC_SAFE_ELT (args, ix, t)\n-    {\n-      CALL_EXPR_ARG (ret, ix) = t;\n-      if (TREE_CODE (t) == OVERLOAD)\n-\tlookup_keep (t, true);\n-    }\n+    CALL_EXPR_ARG (ret, ix) = t;\n+\n   return ret;\n }\n "}, {"sha": "25a7caaebe440ac4012b0c5d679c47329047ef55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -1,3 +1,8 @@\n+2018-06-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/85634\n+\t* g++.dg/lookup/pr85634.C: New.\n+\n 2018-06-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/ldp_stp_q.c: New test."}, {"sha": "e3b3682699356f08a9291b8b6a088180bd0da803", "filename": "gcc/testsuite/g++.dg/lookup/pr85634.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr85634.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335a120f7fc249992772fbabe5ad9375443a0848/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr85634.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr85634.C?ref=335a120f7fc249992772fbabe5ad9375443a0848", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/85634 ICE managing lookup set\n+\n+namespace N {\n+  template <class T> void Foo (T *const &);\n+}\n+\n+using namespace N;\n+\n+template<class T> void Foo (const T &);\n+\n+\n+template <class T>\n+void Frob()\n+{\n+  void (*op)(const T&) = Foo;\n+}\n+\n+template void Frob<int *>();"}]}