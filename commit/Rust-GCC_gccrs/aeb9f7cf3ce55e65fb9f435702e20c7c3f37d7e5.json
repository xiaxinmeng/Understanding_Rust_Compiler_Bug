{"sha": "aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWViOWY3Y2YzY2U1NWU2NWZiOWY0MzU3MDJlMjBjN2MzZjM3ZDdlNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-05T23:16:52Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-05T23:16:52Z"}, "message": "tm.texi.in (TARGET_CLASS_LIKELY_SPILLED_P): Update documentation.\n\n\n\t* doc/tm.texi.in (TARGET_CLASS_LIKELY_SPILLED_P): Update documentation.\n\t* doc/tm.texi: Regenerate.\n\t* regs.h (REG_LIVE_LENGTH): Update comments to not refer to no longer\n\texisting files global.c and local-alloc.c.\n\t* regmove.c (copy_src_to_dest): Likewise.\n\t* function.h (struct rtl_data): Likewise.\n\t* ira-color.c (allocno_priority_compare_func): Likewise.\n\t* regstat.c (regstat_compute_ri): Likewise.\n\t* config/epiphany/epiphany.h, config/vax/vax.h, config/cris/cris.h,\n\tconfig/h8300/h8300.h, config/alpha/alpha.h, config/sparc/sparc.h,\n\tconfig/rs6000/rs6000.h, config/pdp11/pdp11.h, config/pa/pa.h,\n\tconfig/v850/v850.h, config/mn10300/mn10300.h, config/m32r/m32r.h,\n\tconfig/i386/i386.h, config/mcore/mcore.h, config/sh/sh.h,\n\tconfig/arm/arm.h (REGNO_OK_FOR_BASE_P): Likewise.\n\nFrom-SVN: r194229", "tree": {"sha": "7daa076305a95e822e50b52025fa432bc497750f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7daa076305a95e822e50b52025fa432bc497750f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/comments", "author": null, "committer": null, "parents": [{"sha": "833fe7dadc06faaeefb7812a69dcc9a178543184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833fe7dadc06faaeefb7812a69dcc9a178543184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/833fe7dadc06faaeefb7812a69dcc9a178543184"}], "stats": {"total": 139, "additions": 82, "deletions": 57}, "files": [{"sha": "efeafd3c73b1eac54d99b7b84f8fab3f15e864ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -1,3 +1,20 @@\n+2012-12-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* doc/tm.texi.in (TARGET_CLASS_LIKELY_SPILLED_P): Update documentation.\n+\t* doc/tm.texi: Regenerate.\n+\t* regs.h (REG_LIVE_LENGTH): Update comments to not refer to no longer\n+\texisting files global.c and local-alloc.c.\n+\t* regmove.c (copy_src_to_dest): Likewise.\n+\t* function.h (struct rtl_data): Likewise.\n+\t* ira-color.c (allocno_priority_compare_func): Likewise.\n+\t* regstat.c (regstat_compute_ri): Likewise.\n+\t* config/epiphany/epiphany.h, config/vax/vax.h, config/cris/cris.h,\n+\tconfig/h8300/h8300.h, config/alpha/alpha.h, config/sparc/sparc.h,\n+\tconfig/rs6000/rs6000.h, config/pdp11/pdp11.h, config/pa/pa.h,\n+\tconfig/v850/v850.h, config/mn10300/mn10300.h, config/m32r/m32r.h,\n+\tconfig/i386/i386.h, config/mcore/mcore.h, config/sh/sh.h,\n+\tconfig/arm/arm.h (REGNO_OK_FOR_BASE_P): Likewise.\n+\n 2012-12-05  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR target/54160"}, {"sha": "bc14d84055bb5a9eeac728911bed1a564fe47ca6", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -778,7 +778,8 @@ extern int alpha_memory_latency;\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) 0\n #define REGNO_OK_FOR_BASE_P(REGNO) \\"}, {"sha": "d0f351d861ed0f0a853621b0fe07026f69964c31", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -1730,7 +1730,8 @@ enum arm_auto_incmodes\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n #define TEST_REGNO(R, TEST, VALUE) \\\n   ((R TEST VALUE) || ((unsigned) reg_renumber[R] TEST VALUE))\n "}, {"sha": "80fb8f3ad86a4aec4960f1ee50c604a0619c2a58", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -577,7 +577,8 @@ enum reg_class\n #define INDEX_REG_CLASS GENERAL_REGS\n \n /* Since it uses reg_renumber, it is safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n #define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\t\\\n  ((REGNO) <= CRIS_LAST_GENERAL_REGISTER\t\t\t\t\t\\\n   || (REGNO) == ARG_POINTER_REGNUM\t\t\t\t\t\\"}, {"sha": "534f513132b96e5ec74052dc1ab18a6eb324966d", "filename": "gcc/config/epiphany/epiphany.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -407,7 +407,8 @@ extern enum reg_class epiphany_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n ((REGNO) < FIRST_PSEUDO_REGISTER || (unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER)\n #define REGNO_OK_FOR_INDEX_P(REGNO) \\"}, {"sha": "b98f6169112f519a57f7c98d438f6b360f350574", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -498,7 +498,8 @@ struct cum_arg\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(regno) 0\n "}, {"sha": "3ac345172c8291c59be282c855bad752369eb2ce", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -1614,7 +1614,8 @@ typedef struct ix86_args {\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) \t\t\t\t\t\\\n   ((REGNO) < STACK_POINTER_REGNUM \t\t\t\t\t\\"}, {"sha": "e871328af7b557aefc20e043157c8356f3c02b60", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -501,7 +501,8 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n   ((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\\\n    ? GPR_P (REGNO) || (REGNO) == ARG_POINTER_REGNUM\t\\"}, {"sha": "a64e4460fa18e7320e7112a44b68f25553242a11", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -516,7 +516,8 @@ extern const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) < AP_REG || (unsigned) reg_renumber[(REGNO)] < AP_REG)\n "}, {"sha": "4dea839873b78501c999110eee0eddaf319556e5", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -347,7 +347,8 @@ enum reg_class\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #ifndef REG_OK_STRICT\n # define REG_STRICT 0"}, {"sha": "29dbea012565fda5a7e09947834a9111993d0208", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -750,7 +750,8 @@ extern int may_call_alloca;\n    They give nonzero only if X is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(X) \\\n   ((X) && ((X) < 32\t\t\t\t\t\t\t\\"}, {"sha": "76925b1683f8d4477d1982f34cd2504adbe17abc", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -400,7 +400,8 @@ extern int may_call_alloca;\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) <= PC_REGNUM || (unsigned) reg_renumber[REGNO] <= PC_REGNUM || \\"}, {"sha": "2e23f6e523dae8b8ee2ba02a83d8cab213e54c4b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -1729,7 +1729,8 @@ typedef struct rs6000_args\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\\\n ((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\\"}, {"sha": "212b97d9c10c834bc962c18f7ebd34ef29a02470", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -1618,7 +1618,8 @@ struct sh_args {\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n   (GENERAL_OR_AP_REGISTER_P (REGNO) \\"}, {"sha": "99c6a0393285e9b9ca3f50f989ae7074eef18d55", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -1379,7 +1379,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) \\\n (SPARC_INT_REG_P (REGNO) || SPARC_INT_REG_P (reg_renumber[REGNO]) \\"}, {"sha": "2e3e55a18fac13c6f29f20ece7163338f003d6c7", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -354,7 +354,8 @@ enum reg_class\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n  \n #define REGNO_OK_FOR_BASE_P(regno)             \\\n   (((regno) < FIRST_PSEUDO_REGISTER            \\"}, {"sha": "513ac6102db501a25ee49696e2b8e2e32b1327a6", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -385,7 +385,8 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n+   has been allocated, which happens in reginfo.c during register\n+   allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(regno)\t\\\n   ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)"}, {"sha": "3ab99871c3b0746a0aeba0e08577db544ff5f73e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -2834,15 +2834,13 @@ registers of @var{rclass} are needed for spill registers.\n \n The default version of this target hook returns @code{true} if @var{rclass}\n has exactly one register and @code{false} otherwise.  On most machines, this\n-default should be used.  Only use this target hook to some other expression\n-if pseudos allocated by @file{local-alloc.c} end up in memory because their\n-hard registers were needed for spill registers.  If this target hook returns\n-@code{false} for those classes, those pseudos will only be allocated by\n-@file{global.c}, which knows how to reallocate the pseudo to another\n-register.  If there would not be another register available for reallocation,\n-you should not change the implementation of this target hook since\n-the only effect of such implementation would be to slow down register\n-allocation.\n+default should be used.  For generally register-starved machines, such as\n+i386, or machines with right register constraints, such as SH, this hook\n+can be used to avoid excessive spilling.\n+\n+This hook is also used by some of the global intra-procedural code\n+transformations to throtle code motion, to avoid increasing register\n+pressure.\n @end deftypefn\n \n @deftypefn {Target Hook} {unsigned char} TARGET_CLASS_MAX_NREGS (reg_class_t @var{rclass}, enum machine_mode @var{mode})"}, {"sha": "6d48fe48b759fef271a5031f2d6234e102073594", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -2810,15 +2810,13 @@ registers of @var{rclass} are needed for spill registers.\n \n The default version of this target hook returns @code{true} if @var{rclass}\n has exactly one register and @code{false} otherwise.  On most machines, this\n-default should be used.  Only use this target hook to some other expression\n-if pseudos allocated by @file{local-alloc.c} end up in memory because their\n-hard registers were needed for spill registers.  If this target hook returns\n-@code{false} for those classes, those pseudos will only be allocated by\n-@file{global.c}, which knows how to reallocate the pseudo to another\n-register.  If there would not be another register available for reallocation,\n-you should not change the implementation of this target hook since\n-the only effect of such implementation would be to slow down register\n-allocation.\n+default should be used.  For generally register-starved machines, such as\n+i386, or machines with right register constraints, such as SH, this hook\n+can be used to avoid excessive spilling.\n+\n+This hook is also used by some of the global intra-procedural code\n+transformations to throtle code motion, to avoid increasing register\n+pressure.\n @end deftypefn\n \n @hook TARGET_CLASS_MAX_NREGS"}, {"sha": "65a7c48aa08d4933544e6b6c2bd26a069c935167", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -389,7 +389,8 @@ struct GTY(()) rtl_data {\n   bool arg_pointer_save_area_init;\n \n   /* Nonzero if current function must be given a frame pointer.\n-     Set in global.c if anything is allocated on the stack there.  */\n+     Set in reload1.c or lra-eliminations.c if anything is allocated\n+     on the stack there.  */\n   bool frame_pointer_needed;\n \n   /* When set, expand should optimize for speed.  */"}, {"sha": "3b9319ca7c5a5d20c35ab9526bb5ef5901c87a46", "filename": "gcc/ira-color.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -2516,8 +2516,7 @@ improve_allocation (void)\n     }\n }\n \n-/* Sort allocnos according to their priorities which are calculated\n-   analogous to ones in file `global.c'.  */\n+/* Sort allocnos according to their priorities.  */\n static int\n allocno_priority_compare_func (const void *v1p, const void *v2p)\n {"}, {"sha": "8dc2d54a674e4ecece8b8f61db4e49fe942e534c", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -616,10 +616,10 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest)\n   int src_regno;\n   int dest_regno;\n \n-  /* A REG_LIVE_LENGTH of -1 indicates the register is equivalent to a constant\n-     or memory location and is used infrequently; a REG_LIVE_LENGTH of -2 is\n-     parameter when there is no frame pointer that is not allocated a register.\n-     For now, we just reject them, rather than incrementing the live length.  */\n+  /* A REG_LIVE_LENGTH of -1 indicates the register must not go into\n+     a hard register, e.g. because it crosses as setjmp.  See the\n+     comment in regstat.c:regstat_bb_compute_ri.  Don't try to apply\n+     any transformations to such regs.  */\n \n   if (REG_P (src)\n       && REG_LIVE_LENGTH (REGNO (src)) > 0"}, {"sha": "adc9384b62e1f5da56df77cb2fa771aa5476314b", "filename": "gcc/regs.h", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -176,21 +176,17 @@ extern size_t reg_info_p_size;\n \n #define REG_N_THROWING_CALLS_CROSSED(N) (reg_info_p[N].throw_calls_crossed)\n \n-/* Total number of instructions at which (REG n) is live.  The larger\n-   this is, the less priority (REG n) gets for allocation in a hard\n-   register (in global-alloc).  This is set in df-problems.c whenever\n-   register info is requested and remains valid for the rest of the\n-   compilation of the function; it is used to control register\n-   allocation.\n-\n-   local-alloc.c may alter this number to change the priority.\n-\n-   Negative values are special.\n-   -1 is used to mark a pseudo reg which has a constant or memory equivalent\n-   and is used infrequently enough that it should not get a hard register.\n-   -2 is used to mark a pseudo reg for a parameter, when a frame pointer\n-   is not required.  global.c makes an allocno for this but does\n-   not try to assign a hard register to it.  */\n+/* Total number of instructions at which (REG n) is live.\n+   \n+   This is set in regstat.c whenever register info is requested and\n+   remains valid for the rest of the compilation of the function; it is\n+   used to control register allocation.  The larger this is, the less\n+   priority (REG n) gets for allocation in a hard register (in IRA in\n+   priority-coloring mode).\n+\n+   Negative values are special: -1 is used to mark a pseudo reg that\n+   should not be allocated to a hard register, because it crosses a\n+   setjmp call.  */\n \n #define REG_LIVE_LENGTH(N)  (reg_info_p[N].live_length)\n "}, {"sha": "34eb7ad67bf2f5c38e6980f8f177856460666178", "filename": "gcc/regstat.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=aeb9f7cf3ce55e65fb9f435702e20c7c3f37d7e5", "patch": "@@ -389,7 +389,7 @@ regstat_compute_ri (void)\n   BITMAP_FREE (local_processed);\n   free (local_live_last_luid);\n \n-  /* See the setjmp comment in regstat_ri_bb_compute.  */\n+  /* See the setjmp comment in regstat_bb_compute_ri.  */\n   EXECUTE_IF_SET_IN_BITMAP (setjmp_crosses, FIRST_PSEUDO_REGISTER, regno, bi)\n     {\n       REG_BASIC_BLOCK (regno) = REG_BLOCK_UNKNOWN;"}]}