{"sha": "1118a3ff9d3ad6a64bba25dc01e7703325e23d92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTExOGEzZmY5ZDNhZDZhNjRiYmEyNWRjMDFlNzcwMzMyNWUyM2Q5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-08-11T10:02:32Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-08-11T10:02:32Z"}, "message": "Do not combine PRED_LOOP_GUARD and PRED_LOOP_GUARD_WITH_RECURSION\n\nThis patch avoids both PRED_LOOP_GUARD and PRED_LOOP_GUARD_WITH_RECURSION to be\nattached to one edge.  We have logic that prevents same predictor to apply to\none edge twice, but since we split LOOP_GUARD to two more specialized cases,\nthis no longer fires.\n\nDouble prediction happens in exchange benchmark and leads to unrealistically\nlow hitrates on some edges which in turn leads to bad IPA profile and misguides\nipa-cp.\n\nUnforutnately it seems that the bad profile also leads to bit better\nperformance by disabling some of loop stuff, but that really ought to be done\nin some meaningful way, not by an accident.\n\ngcc/ChangeLog:\n\n2020-08-11  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* predict.c (not_loop_guard_equal_edge_p): New function.\n\t(maybe_predict_edge): New function.\n\t(predict_paths_for_bb): Use it.\n\t(predict_paths_leading_to_edge): Use it.\n\ngcc/testsuite/ChangeLog:\n\n2020-08-11  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/ipa/ipa-clone-2.c: Lower threshold from 500 to 400.", "tree": {"sha": "ffaecdfa7a38197b140ad70bf9274fe2f4c0c67a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffaecdfa7a38197b140ad70bf9274fe2f4c0c67a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1118a3ff9d3ad6a64bba25dc01e7703325e23d92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1118a3ff9d3ad6a64bba25dc01e7703325e23d92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1118a3ff9d3ad6a64bba25dc01e7703325e23d92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1118a3ff9d3ad6a64bba25dc01e7703325e23d92/comments", "author": null, "committer": null, "parents": [{"sha": "6c2583c14a8776e88f9834608686f34ec11f717f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c2583c14a8776e88f9834608686f34ec11f717f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c2583c14a8776e88f9834608686f34ec11f717f"}], "stats": {"total": 38, "additions": 32, "deletions": 6}, "files": [{"sha": "4c4bba549398523f86b26684e068c130322db29b", "filename": "gcc/predict.c", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1118a3ff9d3ad6a64bba25dc01e7703325e23d92/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1118a3ff9d3ad6a64bba25dc01e7703325e23d92/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=1118a3ff9d3ad6a64bba25dc01e7703325e23d92", "patch": "@@ -3122,6 +3122,35 @@ tree_guess_outgoing_edge_probabilities (basic_block bb)\n   bb_predictions = NULL;\n }\n \f\n+/* Filter function predicate that returns true for a edge predicate P\n+   if its edge is equal to DATA.  */\n+\n+static bool\n+not_loop_guard_equal_edge_p (edge_prediction *p, void *data)\n+{\n+  return p->ep_edge != (edge)data || p->ep_predictor != PRED_LOOP_GUARD;\n+}\n+\n+/* Predict edge E with PRED unless it is already predicted by some predictor\n+   considered equivalent.  */\n+\n+static void\n+maybe_predict_edge (edge e, enum br_predictor pred, enum prediction taken)\n+{\n+  if (edge_predicted_by_p (e, pred, taken))\n+    return;\n+  if (pred == PRED_LOOP_GUARD\n+      && edge_predicted_by_p (e, PRED_LOOP_GUARD_WITH_RECURSION, taken))\n+    return;\n+  /* Consider PRED_LOOP_GUARD_WITH_RECURSION superrior to LOOP_GUARD.  */\n+  if (pred == PRED_LOOP_GUARD_WITH_RECURSION)\n+    {\n+      edge_prediction **preds = bb_predictions->get (e->src);\n+      if (preds)\n+\tfilter_predictions (preds, not_loop_guard_equal_edge_p, e);\n+    }\n+  predict_edge_def (e, pred, taken);\n+}\n /* Predict edges to successors of CUR whose sources are not postdominated by\n    BB by PRED and recurse to all postdominators.  */\n \n@@ -3177,10 +3206,7 @@ predict_paths_for_bb (basic_block cur, basic_block bb,\n \t regions that are only reachable by abnormal edges.  We simply\n \t prevent visiting given BB twice.  */\n       if (found)\n-\t{\n-\t  if (!edge_predicted_by_p (e, pred, taken))\n-            predict_edge_def (e, pred, taken);\n-\t}\n+\tmaybe_predict_edge (e, pred, taken);\n       else if (bitmap_set_bit (visited, e->src->index))\n \tpredict_paths_for_bb (e->src, e->src, pred, taken, visited, in_loop);\n     }\n@@ -3223,7 +3249,7 @@ predict_paths_leading_to_edge (edge e, enum br_predictor pred,\n   if (!has_nonloop_edge)\n     predict_paths_for_bb (bb, bb, pred, taken, auto_bitmap (), in_loop);\n   else\n-    predict_edge_def (e, pred, taken);\n+    maybe_predict_edge (e, pred, taken);\n }\n \f\n /* This is used to carry information about basic blocks.  It is"}, {"sha": "53ae25a1e24f48f9b0b53ad29612a75a08788ad1", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-clone-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1118a3ff9d3ad6a64bba25dc01e7703325e23d92/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-clone-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1118a3ff9d3ad6a64bba25dc01e7703325e23d92/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-clone-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-clone-2.c?ref=1118a3ff9d3ad6a64bba25dc01e7703325e23d92", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-ipa-cp-details -fno-early-inlining --param ipa-cp-max-recursive-depth=8\" } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details -fno-early-inlining --param ipa-cp-max-recursive-depth=8 --param=ipa-cp-eval-threshold=400\" } */\n \n int fn();\n "}]}