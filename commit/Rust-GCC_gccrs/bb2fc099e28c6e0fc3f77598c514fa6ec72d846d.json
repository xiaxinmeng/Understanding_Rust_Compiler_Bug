{"sha": "bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "node_id": "C_kwDOANBUbNoAKGJiMmZjMDk5ZTI4YzZlMGZjM2Y3NzU5OGM1MTRmYTZlYzcyZDg0NmQ", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-11-05T22:22:05Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-01T10:24:42Z"}, "message": "[Ada] Improve support for casing on types with controlled parts\n\ngcc/ada/\n\n\t* sem_case.adb (Check_Bindings): Provide a second strategy for\n\timplementing bindings and choose which strategy to use for a\n\tgiven binding. The previous approach was to introduce a new\n\tobject and assign the bound value to the object.  The new\n\tapproach is to introduce a renaming of a dereference of an\n\taccess value that references the appropriate subcomponent, so no\n\tcopies are made.  The original strategy is still used if the\n\ttype of the object is elementary.  When the renaming approach is\n\tused, the initialization of the access value is not generated\n\tuntil expansion. Until this missing initialization is added, the\n\ttree looks like a known-at-compile-time dereference of a null\n\taccess value: Temp : Some_Access_Type; Obj : Designated_Type\n\trenames Temp.all; This leads to problems, so a bogus initial\n\tvalue is provided here and then later deleted during expansion.\n\t(Check_Composite_Case_Selector): Disallow a case selector\n\texpression that requires finalization. Note that it is ok if the\n\tselector's type requires finalization, as long as the expression\n\titself doesn't have any \"newly constructed\" parts.\n\t* exp_ch5.adb (Pattern_Match): Detect the case where analysis of\n\ta general (i.e., composite selector type) case statement chose\n\tto implement a binding as a renaming rather than by making a\n\tcopy. In that case, generate the assignments to initialize the\n\taccess-valued object whose designated value is later renamed\n\t(and remove the bogus initial value for that object that was\n\tadded during analysis).\n\t* sem_util.ads, sem_util.adb: Add new function\n\tIs_Newly_Constructed corresponding to RM 4.4 term.", "tree": {"sha": "32125e9ef4a86d75953b9001c2722254d9cb9a99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32125e9ef4a86d75953b9001c2722254d9cb9a99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be6bb3fc57e2af376e5c18eeca51119e87a55ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6bb3fc57e2af376e5c18eeca51119e87a55ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be6bb3fc57e2af376e5c18eeca51119e87a55ee3"}], "stats": {"total": 561, "additions": 444, "deletions": 117}, "files": [{"sha": "42cffd5186a41acb7e4ade1ae72f1d2a57aa4440", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 134, "deletions": 64, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "patch": "@@ -3348,6 +3348,13 @@ package body Exp_Ch5 is\n             Alt          : Node_Id;\n             Suppress_Choice_Index_Update : Boolean := False) return Node_Id\n          is\n+            procedure Finish_Binding_Object_Declaration\n+              (Component_Assoc : Node_Id; Subobject : Node_Id);\n+            --  Finish the work that was started during analysis to\n+            --  declare a binding object. If we are generating a copy,\n+            --  then initialize it. If we are generating a renaming, then\n+            --  initialize the access value designating the renamed object.\n+\n             function Update_Choice_Index return Node_Id is (\n               Make_Assignment_Statement (Loc,\n                 Name       =>\n@@ -3368,6 +3375,130 @@ package body Exp_Ch5 is\n             function Indexed_Element (Idx : Pos) return Node_Id;\n             --  Returns the Nth (well, ok, the Idxth) element of Object\n \n+            ---------------------------------------\n+            -- Finish_Binding_Object_Declaration --\n+            ---------------------------------------\n+\n+            procedure Finish_Binding_Object_Declaration\n+              (Component_Assoc : Node_Id; Subobject : Node_Id)\n+            is\n+               Decl_Chars   : constant Name_Id :=\n+                 Binding_Chars (Component_Assoc);\n+\n+               Block_Stmt   : constant Node_Id := First (Statements (Alt));\n+               pragma Assert (Nkind (Block_Stmt) = N_Block_Statement);\n+               pragma Assert (No (Next (Block_Stmt)));\n+\n+               Decl         : Node_Id := First (Declarations (Block_Stmt));\n+               Def_Id       : Node_Id := Empty;\n+\n+               --  Declare_Copy indicates which of the two approaches\n+               --  was chosen during analysis: declare (and initialize)\n+               --  a new variable, or use access values to declare a renaming\n+               --  of the appropriate subcomponent of the selector value.\n+               Declare_Copy : constant Boolean :=\n+                 Nkind (Decl) = N_Object_Declaration;\n+\n+               function Make_Conditional (Stmt : Node_Id) return Node_Id;\n+               --  If there is only one choice for this alternative, then\n+               --  simply return the argument. If there is more than one\n+               --  choice, then wrap an if-statement around the argument\n+               --  so that it is only executed if the current choice matches.\n+\n+               ----------------------\n+               -- Make_Conditional --\n+               ----------------------\n+\n+               function Make_Conditional (Stmt : Node_Id) return Node_Id\n+               is\n+                  Condition : Node_Id;\n+               begin\n+                  if Present (Choice_Index_Decl) then\n+                     Condition :=\n+                       Make_Op_Eq (Loc,\n+                         New_Occurrence_Of\n+                           (Defining_Identifier (Choice_Index_Decl), Loc),\n+                         Make_Integer_Literal (Loc, Int (Choice_Index)));\n+\n+                     return Make_If_Statement (Loc,\n+                              Condition       => Condition,\n+                              Then_Statements => New_List (Stmt));\n+                  else\n+                     --  execute Stmt unconditionally\n+                     return Stmt;\n+                  end if;\n+               end Make_Conditional;\n+\n+            begin\n+               --  find the variable to be modified (and its declaration)\n+               loop\n+                  if Nkind (Decl) in N_Object_Declaration\n+                    | N_Object_Renaming_Declaration\n+                  then\n+                     Def_Id := Defining_Identifier (Decl);\n+                     exit when Chars (Def_Id) = Decl_Chars;\n+                  end if;\n+                  Next (Decl);\n+                  pragma Assert (Present (Decl));\n+               end loop;\n+\n+               --  For a binding object, we sometimes make a copy and\n+               --  sometimes introduce  a renaming. That decision is made\n+               --  elsewhere. The renaming case involves dereferencing an\n+               --  access value because of the possibility of multiple\n+               --  choices (with multiple binding definitions) for a single\n+               --  alternative. In the copy case, we initialize the copy\n+               --  here (conditionally if there are multiple choices); in the\n+               --  renaming case, we initialize (again, maybe conditionally)\n+               --  the access value.\n+\n+               if Declare_Copy then\n+                  declare\n+                     Assign_Value : constant Node_Id  :=\n+                       Make_Assignment_Statement (Loc,\n+                         Name       => New_Occurrence_Of (Def_Id, Loc),\n+                         Expression => Subobject);\n+\n+                     HSS : constant Node_Id :=\n+                       Handled_Statement_Sequence (Block_Stmt);\n+                  begin\n+                     Prepend (Make_Conditional (Assign_Value),\n+                              Statements (HSS));\n+                     Set_Analyzed (HSS, False);\n+                  end;\n+               else\n+                  pragma Assert (Nkind (Name (Decl)) = N_Explicit_Dereference);\n+\n+                  declare\n+                     Ptr_Obj  : constant Entity_Id :=\n+                       Entity (Prefix (Name (Decl)));\n+                     Ptr_Decl : constant Node_Id := Parent (Ptr_Obj);\n+\n+                     Assign_Reference : constant Node_Id :=\n+                       Make_Assignment_Statement (Loc,\n+                         Name       => New_Occurrence_Of (Ptr_Obj, Loc),\n+                         Expression =>\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => Subobject,\n+                             Attribute_Name => Name_Unrestricted_Access));\n+                  begin\n+                     Insert_After\n+                       (After => Ptr_Decl,\n+                        Node  => Make_Conditional (Assign_Reference));\n+\n+                     if Present (Expression (Ptr_Decl)) then\n+                        --  Delete bogus initial value built during analysis.\n+                        --  Look for \"5432\" in sem_case.adb.\n+                        pragma Assert (Nkind (Expression (Ptr_Decl)) =\n+                                       N_Unchecked_Type_Conversion);\n+                        Set_Expression (Ptr_Decl, Empty);\n+                     end if;\n+                  end;\n+               end if;\n+\n+               Set_Analyzed (Block_Stmt, False);\n+            end Finish_Binding_Object_Declaration;\n+\n             ---------------------\n             -- Indexed_Element --\n             ---------------------\n@@ -3519,70 +3650,9 @@ package body Exp_Ch5 is\n \n                               if Binding_Chars (Component_Assoc) /= No_Name\n                               then\n-                                 declare\n-                                    Decl_Chars : constant Name_Id :=\n-                                      Binding_Chars (Component_Assoc);\n-\n-                                    Block_Stmt : constant Node_Id :=\n-                                      First (Statements (Alt));\n-                                    pragma Assert\n-                                      (Nkind (Block_Stmt) = N_Block_Statement);\n-                                    pragma Assert (No (Next (Block_Stmt)));\n-                                    Decl : Node_Id\n-                                      := First (Declarations (Block_Stmt));\n-                                    Def_Id : Node_Id := Empty;\n-\n-                                    Assignment_Stmt : Node_Id;\n-                                    Condition       : Node_Id;\n-                                    Prepended_Stmt  : Node_Id;\n-                                 begin\n-                                    --  find the variable to be modified\n-                                    while No (Def_Id) or else\n-                                      Chars (Def_Id) /= Decl_Chars\n-                                    loop\n-                                       Def_Id := Defining_Identifier (Decl);\n-                                       Next (Decl);\n-                                    end loop;\n-\n-                                    Assignment_Stmt :=\n-                                      Make_Assignment_Statement (Loc,\n-                                        Name       => New_Occurrence_Of\n-                                                        (Def_Id, Loc),\n-                                        Expression => Subobject);\n-\n-                                    --  conditional if multiple choices\n-\n-                                    if Present (Choice_Index_Decl) then\n-                                       Condition :=\n-                                         Make_Op_Eq (Loc,\n-                                           New_Occurrence_Of\n-                                             (Defining_Identifier\n-                                                (Choice_Index_Decl), Loc),\n-                                          Make_Integer_Literal\n-                                            (Loc, Int (Choice_Index)));\n-\n-                                       Prepended_Stmt :=\n-                                         Make_If_Statement (Loc,\n-                                           Condition       => Condition,\n-                                           Then_Statements =>\n-                                             New_List (Assignment_Stmt));\n-                                    else\n-                                       --  assignment is unconditional\n-                                       Prepended_Stmt := Assignment_Stmt;\n-                                    end if;\n-\n-                                    declare\n-                                       HSS : constant Node_Id :=\n-                                         Handled_Statement_Sequence\n-                                           (Block_Stmt);\n-                                    begin\n-                                       Prepend (Prepended_Stmt,\n-                                                Statements (HSS));\n-\n-                                       Set_Analyzed (Block_Stmt, False);\n-                                       Set_Analyzed (HSS, False);\n-                                    end;\n-                                 end;\n+                                 Finish_Binding_Object_Declaration\n+                                   (Component_Assoc => Component_Assoc,\n+                                    Subobject => Subobject);\n                               end if;\n \n                               Next (Choice);"}, {"sha": "eb592c49f62762354b71baabe0faa225eeab217a", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 180, "deletions": 53, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "patch": "@@ -1991,6 +1991,154 @@ package body Sem_Case is\n             procedure Check_Bindings\n             is\n                use Case_Bindings_Table;\n+\n+               function Binding_Subtype (Idx : Binding_Index;\n+                                         Tab : Table_Type)\n+                 return Entity_Id is\n+                 (Etype (Nlists.First (Choices (Tab (Idx).Comp_Assoc))));\n+\n+               procedure Declare_Binding_Objects\n+                  (Alt_Start             : Binding_Index;\n+                   Alt                   : Node_Id;\n+                   First_Choice_Bindings : Natural;\n+                   Tab                   : Table_Type);\n+               --  Declare the binding objects for a given alternative\n+\n+               ------------------------------\n+               --  Declare_Binding_Objects --\n+               ------------------------------\n+\n+               procedure Declare_Binding_Objects\n+                  (Alt_Start             : Binding_Index;\n+                   Alt                   : Node_Id;\n+                   First_Choice_Bindings : Natural;\n+                   Tab                   : Table_Type)\n+               is\n+                  Loc : constant Source_Ptr := Sloc (Alt);\n+                  Declarations : constant List_Id := New_List;\n+                  Decl         : Node_Id;\n+                  Obj_Type     : Entity_Id;\n+                  Def_Id       : Entity_Id;\n+               begin\n+                  for FC_Idx in Alt_Start ..\n+                    Alt_Start + Binding_Index (First_Choice_Bindings - 1)\n+                  loop\n+                     Obj_Type := Binding_Subtype (FC_Idx, Tab);\n+                     Def_Id := Make_Defining_Identifier\n+                                 (Loc,\n+                                  Binding_Chars (Tab (FC_Idx).Comp_Assoc));\n+\n+                     --  Either make a copy or rename the original. At a\n+                     --  minimum, we do not want a copy if it would need\n+                     --  finalization. Copies may also introduce problems\n+                     --  if default init can have side effects (although we\n+                     --  could suppress such default initialization).\n+                     --  We have to make a copy in any cases where\n+                     --  Unrestricted_Access doesn't work.\n+                     --\n+                     --  This is where the copy-or-rename decision is made.\n+                     --  In many cases either way would work and so we have\n+                     --  some flexibility here.\n+\n+                     if not Is_By_Copy_Type (Obj_Type) then\n+                        --  Generate\n+                        --     type Ref\n+                        --       is access constant Obj_Type;\n+                        --     Ptr : Ref := <some bogus value>;\n+                        --     Obj : Obj_Type renames Ptr.all;\n+                                       --\n+                        --  Initialization of Ptr will be generated later\n+                        --  during expansion.\n+\n+                        declare\n+                           Ptr_Type : constant Entity_Id :=\n+                             Make_Temporary (Loc, 'P');\n+\n+                           Ptr_Type_Def : constant Node_Id :=\n+                             Make_Access_To_Object_Definition (Loc,\n+                               All_Present => True,\n+                               Subtype_Indication =>\n+                                 New_Occurrence_Of (Obj_Type, Loc));\n+\n+                           Ptr_Type_Decl : constant Node_Id :=\n+                             Make_Full_Type_Declaration (Loc,\n+                               Ptr_Type,\n+                               Type_Definition => Ptr_Type_Def);\n+\n+                           Ptr_Obj : constant Entity_Id :=\n+                             Make_Temporary (Loc, 'T');\n+\n+                           --  We will generate initialization code for this\n+                           --  object later (during expansion) but in the\n+                           --  meantime we don't want the dereference that\n+                           --  is generated a few lines below here to be\n+                           --  transformed into a Raise_C_E. To prevent this,\n+                           --  we provide a bogus initial value here; this\n+                           --  initial value will be removed later during\n+                           --  expansion.\n+\n+                           Ptr_Obj_Decl : constant Node_Id :=\n+                             Make_Object_Declaration\n+                               (Loc, Ptr_Obj,\n+                                Object_Definition =>\n+                                  New_Occurrence_Of (Ptr_Type, Loc),\n+                                Expression =>\n+                                  Unchecked_Convert_To\n+                                    (Ptr_Type,\n+                                     Make_Integer_Literal (Loc, 5432)));\n+                        begin\n+                           Mutate_Ekind (Ptr_Type, E_Access_Type);\n+\n+                           --  in effect, Storage_Size => 0\n+                           Set_No_Pool_Assigned (Ptr_Type);\n+\n+                           Set_Is_Access_Constant (Ptr_Type);\n+\n+                           --  We could set Ptr_Type'Alignment here if that\n+                           --  ever turns out to be needed for renaming a\n+                           --  misaligned subcomponent.\n+\n+                           Mutate_Ekind (Ptr_Obj, E_Variable);\n+                           Set_Etype (Ptr_Obj, Ptr_Type);\n+\n+                           Decl :=\n+                             Make_Object_Renaming_Declaration\n+                               (Loc, Def_Id,\n+                                Subtype_Mark =>\n+                                  New_Occurrence_Of (Obj_Type, Loc),\n+                                Name =>\n+                                  Make_Explicit_Dereference\n+                                    (Loc, New_Occurrence_Of (Ptr_Obj, Loc)));\n+\n+                           Append_To (Declarations, Ptr_Type_Decl);\n+                           Append_To (Declarations, Ptr_Obj_Decl);\n+                        end;\n+                     else\n+                        Decl := Make_Object_Declaration\n+                          (Sloc => Loc,\n+                           Defining_Identifier => Def_Id,\n+                           Object_Definition =>\n+                              New_Occurrence_Of (Obj_Type, Loc));\n+                     end if;\n+                     Append_To (Declarations, Decl);\n+                  end loop;\n+\n+                  declare\n+                     Old_Statements : constant List_Id := Statements (Alt);\n+                     New_Statements : constant List_Id := New_List;\n+\n+                     Block_Statement : constant Node_Id :=\n+                       Make_Block_Statement (Sloc => Loc,\n+                         Declarations => Declarations,\n+                         Handled_Statement_Sequence =>\n+                           Make_Handled_Sequence_Of_Statements\n+                             (Loc, Old_Statements),\n+                         Has_Created_Identifier => True);\n+                  begin\n+                     Append_To (New_Statements, Block_Statement);\n+                     Set_Statements (Alt, New_Statements);\n+                  end;\n+               end Declare_Binding_Objects;\n             begin\n                if Last = 0 then\n                   --  no bindings to check\n@@ -2005,10 +2153,6 @@ package body Sem_Case is\n                     return Boolean is (\n                     Binding_Chars (Tab (Idx1).Comp_Assoc) =\n                     Binding_Chars (Tab (Idx2).Comp_Assoc));\n-\n-                  function Binding_Subtype (Idx : Binding_Index)\n-                    return Entity_Id is\n-                    (Etype (Nlists.First (Choices (Tab (Idx).Comp_Assoc))));\n                begin\n                   --  Verify that elements with given choice or alt value\n                   --  are contiguous, and that elements with equal\n@@ -2172,8 +2316,8 @@ package body Sem_Case is\n                                     loop\n                                        if Same_Id (Idx2, FC_Idx) then\n                                           if not Subtypes_Statically_Match\n-                                            (Binding_Subtype (Idx2),\n-                                             Binding_Subtype (FC_Idx))\n+                                            (Binding_Subtype (Idx2, Tab),\n+                                             Binding_Subtype (FC_Idx, Tab))\n                                           then\n                                              Error_Msg_N\n                                                (\"subtype of binding in \"\n@@ -2228,50 +2372,12 @@ package body Sem_Case is\n                            --  the current alternative. Then analyze them.\n \n                            if First_Choice_Bindings > 0 then\n-                              declare\n-                                 Loc : constant Source_Ptr := Sloc (Alt);\n-                                 Declarations : constant List_Id := New_List;\n-                                 Decl         : Node_Id;\n-                              begin\n-                                 for FC_Idx in\n-                                   Alt_Start ..\n-                                   Alt_Start +\n-                                     Binding_Index (First_Choice_Bindings - 1)\n-                                 loop\n-                                    Decl := Make_Object_Declaration\n-                                      (Sloc => Loc,\n-                                       Defining_Identifier =>\n-                                         Make_Defining_Identifier\n-                                           (Loc,\n-                                            Binding_Chars\n-                                              (Tab (FC_Idx).Comp_Assoc)),\n-                                        Object_Definition =>\n-                                          New_Occurrence_Of\n-                                            (Binding_Subtype (FC_Idx), Loc));\n-\n-                                    Append_To (Declarations, Decl);\n-                                 end loop;\n-\n-                                 declare\n-                                    Old_Statements : constant List_Id :=\n-                                      Statements (Alt);\n-                                    New_Statements : constant List_Id :=\n-                                      New_List;\n-\n-                                    Block_Statement : constant Node_Id :=\n-                                      Make_Block_Statement (Sloc => Loc,\n-                                        Declarations => Declarations,\n-                                        Handled_Statement_Sequence =>\n-                                          Make_Handled_Sequence_Of_Statements\n-                                            (Loc, Old_Statements),\n-                                        Has_Created_Identifier => True);\n-                                 begin\n-                                    Append_To\n-                                      (New_Statements, Block_Statement);\n-\n-                                    Set_Statements (Alt, New_Statements);\n-                                 end;\n-                              end;\n+                              Declare_Binding_Objects\n+                                (Alt_Start             => Alt_Start,\n+                                 Alt                   => Alt,\n+                                 First_Choice_Bindings =>\n+                                   First_Choice_Bindings,\n+                                 Tab                   => Tab);\n                            end if;\n                         end;\n                      end if;\n@@ -3361,11 +3467,32 @@ package body Sem_Case is\n          begin\n             if not Is_Composite_Type (Subtyp) then\n                Error_Msg_N\n-                 (\"case selector type neither discrete nor composite\", N);\n+                 (\"case selector type must be discrete or composite\", N);\n             elsif Is_Limited_Type (Subtyp) then\n-               Error_Msg_N (\"case selector type is limited\", N);\n+               Error_Msg_N (\"case selector type must not be limited\", N);\n             elsif Is_Class_Wide_Type (Subtyp) then\n-               Error_Msg_N (\"case selector type is class-wide\", N);\n+               Error_Msg_N (\"case selector type must not be class-wide\", N);\n+            elsif Needs_Finalization (Subtyp)\n+              and then Is_Newly_Constructed\n+                         (Expression (N), Context_Requires_NC => False)\n+            then\n+               --  We could allow this case as long as there are no bindings.\n+               --\n+               --  If there are bindings, then allowing this case will get\n+               --  messy because the selector expression will be finalized\n+               --  before the statements of the selected alternative are\n+               --  executed (unless we add an INOX-specific change to the\n+               --  accessibility rules to prevent this earlier-than-wanted\n+               --  finalization, but adding new INOX-specific accessibility\n+               --  complexity is probably not the direction we want to go).\n+               --  This early selector finalization would be ok if we made\n+               --  copies in this case (so that the bindings would not yield\n+               --  a view of a finalized object), but then we'd have to deal\n+               --  with finalizing those copies (which would necessarily\n+               --  include defining their accessibility level). So it gets\n+               --  messy either way.\n+\n+               Error_Msg_N (\"case selector must not require finalization\", N);\n             end if;\n          end Check_Composite_Case_Selector;\n "}, {"sha": "2f5070a9789e44c7ab085bcaa15368f6e65d0d50", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "patch": "@@ -18426,6 +18426,117 @@ package body Sem_Util is\n       end case;\n    end Is_Name_Reference;\n \n+   --------------------------\n+   -- Is_Newly_Constructed --\n+   --------------------------\n+\n+   function Is_Newly_Constructed\n+     (Exp : Node_Id; Context_Requires_NC : Boolean) return Boolean\n+   is\n+      Original_Exp : constant Node_Id := Original_Node (Exp);\n+\n+      function Is_NC (Exp : Node_Id) return Boolean is\n+        (Is_Newly_Constructed (Exp, Context_Requires_NC));\n+\n+      --  If the context requires that the expression shall be newly\n+      --  constructed, then \"True\" is a good result in the sense that the\n+      --  expression satisfies the requirements of the context (and \"False\"\n+      --  is analogously a bad result). If the context requires that the\n+      --  expression shall *not* be newly constructed, then things are\n+      --  reversed: \"False\" is the good value and \"True\" is the bad value.\n+\n+      Good_Result : constant Boolean := Context_Requires_NC;\n+      Bad_Result  : constant Boolean := not Good_Result;\n+   begin\n+      case Nkind (Original_Exp) is\n+         when N_Aggregate\n+            | N_Extension_Aggregate\n+            | N_Function_Call\n+            | N_Op\n+         =>\n+            return True;\n+\n+         when N_Identifier =>\n+            return Present (Entity (Original_Exp))\n+              and then Ekind (Entity (Original_Exp)) = E_Function;\n+\n+         when N_Qualified_Expression =>\n+            return Is_NC (Expression (Original_Exp));\n+\n+         when N_Type_Conversion\n+            | N_Unchecked_Type_Conversion\n+         =>\n+            if Is_View_Conversion (Original_Exp) then\n+               return Is_NC (Expression (Original_Exp));\n+            elsif not Comes_From_Source (Exp) then\n+               if Exp /= Original_Exp then\n+                  return Is_NC (Original_Exp);\n+               else\n+                  return Is_NC (Expression (Original_Exp));\n+               end if;\n+            else\n+               return False;\n+            end if;\n+\n+         when N_Explicit_Dereference\n+            | N_Indexed_Component\n+            | N_Selected_Component\n+         =>\n+            return Nkind (Exp) = N_Function_Call;\n+\n+         --  A use of 'Input is a function call, hence allowed. Normally the\n+         --  attribute will be changed to a call, but the attribute by itself\n+         --  can occur with -gnatc.\n+\n+         when N_Attribute_Reference =>\n+            return Attribute_Name (Original_Exp) = Name_Input;\n+\n+         --  \"return raise ...\" is OK\n+\n+         when N_Raise_Expression =>\n+            return Good_Result;\n+\n+         --  For a case expression, all dependent expressions must be legal\n+\n+         when N_Case_Expression =>\n+            declare\n+               Alt : Node_Id;\n+\n+            begin\n+               Alt := First (Alternatives (Original_Exp));\n+               while Present (Alt) loop\n+                  if Is_NC (Expression (Alt)) = Bad_Result then\n+                     return Bad_Result;\n+                  end if;\n+\n+                  Next (Alt);\n+               end loop;\n+\n+               return Good_Result;\n+            end;\n+\n+         --  For an if expression, all dependent expressions must be legal\n+\n+         when N_If_Expression =>\n+            declare\n+               Then_Expr : constant Node_Id :=\n+                             Next (First (Expressions (Original_Exp)));\n+               Else_Expr : constant Node_Id := Next (Then_Expr);\n+            begin\n+               if (Is_NC (Then_Expr) = Bad_Result)\n+                 or else (Is_NC (Else_Expr) = Bad_Result)\n+               then\n+                  return Bad_Result;\n+               else\n+                  return Good_Result;\n+               end if;\n+            end;\n+\n+         when others =>\n+            return False;\n+      end case;\n+   end Is_Newly_Constructed;\n+\n    ------------------------------------\n    -- Is_Non_Preelaborable_Construct --\n    ------------------------------------"}, {"sha": "2878fce80ffc74171c345f797cefe14872d5dad2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb2fc099e28c6e0fc3f77598c514fa6ec72d846d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=bb2fc099e28c6e0fc3f77598c514fa6ec72d846d", "patch": "@@ -1521,6 +1521,25 @@ package Sem_Util is\n    --  integer for use in compile-time checking. Note: Level is restricted to\n    --  be non-dynamic.\n \n+   function Is_Newly_Constructed\n+     (Exp : Node_Id; Context_Requires_NC : Boolean) return Boolean;\n+   --  Indicates whether a given expression is \"newly constructed\" (RM 4.4).\n+   --  Context_Requires_NC determines the result returned for cases like a\n+   --  raise expression or a conditional expression where some-but-not-all\n+   --  operative constituents are newly constructed. Thus, this is a\n+   --  somewhat unusual predicate in that the result required in order to\n+   --  satisfy whatever legality rule is being checked can influence the\n+   --  result of the predicate. Context_Requires_NC might be True for\n+   --  something like the \"newly constructed\" rule for a limited expression\n+   --  of a return statement, and False for something like the\n+   --  \"newly constructed\" rule pertaining to a limited object renaming in a\n+   --  declare expression. Eventually, the code to implement every\n+   --  RM legality rule requiring/prohibiting a \"newly constructed\" expression\n+   --  should be implemented by calling this function; that's not done yet.\n+   --  The function name doesn't quite match the RM definition of the term if\n+   --  Context_Requires_NC = False; in that case, \"Might_Be_Newly_Constructed\"\n+   --  might be a more accurate name.\n+\n    function Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post\n      (Subp : Entity_Id) return Boolean;\n    --  Return True if Subp is a primitive of an abstract type, where the"}]}