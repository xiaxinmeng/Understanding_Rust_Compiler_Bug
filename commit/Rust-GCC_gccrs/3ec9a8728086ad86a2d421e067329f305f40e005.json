{"sha": "3ec9a8728086ad86a2d421e067329f305f40e005", "node_id": "C_kwDOANBUbNoAKDNlYzlhODcyODA4NmFkODZhMmQ0MjFlMDY3MzI5ZjMwNWY0MGUwMDU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-04T09:21:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-04T09:21:45Z"}, "message": "c-family: Incremental fix for -Wsign-compare BIT_NOT_EXPR handling [PR107465]\n\nThere can be too many extensions and seems I didn't get everything right in\nthe previously posted patch.\n\nThe following incremental patch ought to fix that.\nThe code can deal with quite a few sign/zero extensions at various spots\nand it is important to deal with all of them right.\nOn the argument that contains BIT_NOT_EXPR we have:\nMSB bits#4 bits#3 BIT_NOT_EXPR bits#2 bits#1 LSB\nwhere bits#1 is one or more bits (TYPE_PRECISION (TREE_TYPE (arg0))\nat the end of the function) we don't know anything about, for the purposes\nof this warning it is VARYING that is inverted with BIT_NOT_EXPR to some other\nVARYING bits;\nbits#2 is one or more bits (TYPE_PRECISION (TREE_TYPE (op0)) -\nTYPE_PRECISION (TREE_TYPE (arg0)) at the end of the function)\nwhich are known to be 0 before the BIT_NOT_EXPR and 1 after it.\nbits#3 is zero or more bits from the TYPE_PRECISION (TREE_TYPE (op0))\nat the end of function to the TYPE_PRECISION (TREE_TYPE (op0)) at the\nend of the function to TYPE_PRECISION (TREE_TYPE (op0)) at the start\nof the function, which are either zero extension or sign extension.\nAnd bits#4 is zero or more bits from the TYPE_PRECISION (TREE_TYPE (op0))\nat the start of the function to TYPE_PRECISION (result_type), which\nagain can be zero or sign extension.\n\nNow, vanilla trunk as well as the previously posted patch mishandles the\ncase where bits#3 are sign extended (as bits#2 are known to be all set,\nthat means bits#3 are all set too) but bits#4 are zero extended and are\nthus all 0.\n\nThe patch fixes it by tracking the lowest bit which is known to be clear\nabove the known to be set bits (if any, otherwise it is precision of\nresult_type).\n\n2023-03-04  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c/107465\n\t* c-warn.cc (warn_for_sign_compare): Don't warn for unset bits\n\tabove innermost zero extension of BIT_NOT_EXPR result.\n\n\t* c-c++-common/Wsign-compare-2.c (f18): New test.", "tree": {"sha": "d80b9a89702b7ff172dd87208b9720f8e55d8644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d80b9a89702b7ff172dd87208b9720f8e55d8644"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ec9a8728086ad86a2d421e067329f305f40e005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec9a8728086ad86a2d421e067329f305f40e005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec9a8728086ad86a2d421e067329f305f40e005", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec9a8728086ad86a2d421e067329f305f40e005/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daaf74a714c41c8dbaf9954bcc58462c63062b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daaf74a714c41c8dbaf9954bcc58462c63062b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daaf74a714c41c8dbaf9954bcc58462c63062b4f"}], "stats": {"total": 58, "additions": 30, "deletions": 28}, "files": [{"sha": "ccbede95ea4269f92bbfaf0d84e99cfb17585588", "filename": "gcc/c-family/c-warn.cc", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec9a8728086ad86a2d421e067329f305f40e005/gcc%2Fc-family%2Fc-warn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec9a8728086ad86a2d421e067329f305f40e005/gcc%2Fc-family%2Fc-warn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.cc?ref=3ec9a8728086ad86a2d421e067329f305f40e005", "patch": "@@ -2345,13 +2345,33 @@ warn_for_sign_compare (location_t location,\n      have all bits set that are set in the ~ operand when it is\n      extended.  */\n \n+  /* bits0 is the bit index of op0 extended to result_type, which will\n+     be always 0 and so all bits above it.  If there is a BIT_NOT_EXPR\n+     in that operand possibly sign or zero extended to op0 and then\n+     possibly further sign or zero extended to result_type, bits0 will\n+     be the precision of result type if all the extensions involved\n+     if any are sign extensions, and will be the place of the innermost\n+     zero extension otherwise.  We warn only if BIT_NOT_EXPR's operand is\n+     zero extended from some even smaller precision, in that case after\n+     BIT_NOT_EXPR some bits below bits0 will be guaranteed to be set.\n+     Similarly for bits1.  */\n+  int bits0 = TYPE_PRECISION (result_type);\n+  if (TYPE_UNSIGNED (TREE_TYPE (op0)))\n+    bits0 = TYPE_PRECISION (TREE_TYPE (op0));\n   tree arg0 = c_common_get_narrower (op0, &unsignedp0);\n   if (TYPE_PRECISION (TREE_TYPE (arg0)) == TYPE_PRECISION (TREE_TYPE (op0)))\n     unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n+  else if (unsignedp0)\n+    bits0 = TYPE_PRECISION (TREE_TYPE (arg0));\n   op0 = arg0;\n+  int bits1 = TYPE_PRECISION (result_type);\n+  if (TYPE_UNSIGNED (TREE_TYPE (op1)))\n+    bits1 = TYPE_PRECISION (TREE_TYPE (op1));\n   tree arg1 = c_common_get_narrower (op1, &unsignedp1);\n   if (TYPE_PRECISION (TREE_TYPE (arg1)) == TYPE_PRECISION (TREE_TYPE (op1)))\n     unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n+  else if (unsignedp1)\n+    bits1 = TYPE_PRECISION (TREE_TYPE (arg1));\n   op1 = arg1;\n \n   if ((TREE_CODE (op0) == BIT_NOT_EXPR)\n@@ -2361,6 +2381,7 @@ warn_for_sign_compare (location_t location,\n \t{\n \t  std::swap (op0, op1);\n \t  std::swap (unsignedp0, unsignedp1);\n+\t  std::swap (bits0, bits1);\n \t}\n \n       int unsignedp;\n@@ -2379,16 +2400,8 @@ warn_for_sign_compare (location_t location,\n \t      && bits < HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      HOST_WIDE_INT mask = HOST_WIDE_INT_M1U << bits;\n-\t      if (unsignedp0)\n-\t\t{\n-\t\t  bits = TYPE_PRECISION (TREE_TYPE (op0));\n-\t\t  if (bits < TYPE_PRECISION (result_type)\n-\t\t      && bits < HOST_BITS_PER_WIDE_INT)\n-\t\t    mask &= ~(HOST_WIDE_INT_M1U << bits);\n-\t\t}\n-\t      bits = TYPE_PRECISION (result_type);\n-\t      if (bits < HOST_BITS_PER_WIDE_INT)\n-\t\tmask &= ~(HOST_WIDE_INT_M1U << bits);\n+\t      if (bits0 < HOST_BITS_PER_WIDE_INT)\n+\t\tmask &= ~(HOST_WIDE_INT_M1U << bits0);\n \t      if ((mask & constant) != mask)\n \t\t{\n \t\t  if (constant == 0)\n@@ -2406,24 +2419,7 @@ warn_for_sign_compare (location_t location,\n \t\t< TYPE_PRECISION (TREE_TYPE (op0)))\n \t       && unsignedp\n \t       && unsignedp1\n-\t       /* If unsignedp0, the BIT_NOT_EXPR result is\n-\t\t  zero extended, so say if op0 is unsigned char\n-\t\t  variable, BIT_NOT_EXPR is unsigned short and\n-\t\t  result type int and op0 has value 0x55, the\n-\t\t  int value will be 0xffaa, or for op0 0xaa it\n-\t\t  will be 0xff55.  In these cases, warn if\n-\t\t  op1 is unsigned and narrower than unsigned short.\n-\t\t  While if unsignedp0 is false, the BIT_NOT_EXPR\n-\t\t  result is sign extended and because of the\n-\t\t  above TYPE_PRECISION comparison we know the\n-\t\t  MSB of BIT_NOT_EXPR is set (perhaps with some\n-\t\t  further bits below it).  The sign extension will\n-\t\t  then ensure all bits above BIT_NOT_EXPR up to\n-\t\t  result_type's precision are set.  */\n-\t       && (TYPE_PRECISION (TREE_TYPE (op1))\n-\t\t   < TYPE_PRECISION (unsignedp0\n-\t\t\t\t     ? TREE_TYPE (op0)\n-\t\t\t\t     : result_type)))\n+\t       && TYPE_PRECISION (TREE_TYPE (op1)) < bits0)\n \twarning_at (location, OPT_Wsign_compare,\n \t\t    \"comparison of promoted bitwise complement \"\n \t\t    \"of an unsigned value with unsigned\");"}, {"sha": "71a7c9899fbb7c4784822a94c97c2b02025b14e4", "filename": "gcc/testsuite/c-c++-common/Wsign-compare-2.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec9a8728086ad86a2d421e067329f305f40e005/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsign-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec9a8728086ad86a2d421e067329f305f40e005/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsign-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsign-compare-2.c?ref=3ec9a8728086ad86a2d421e067329f305f40e005", "patch": "@@ -104,3 +104,9 @@ f17 (unsigned char x, unsigned short y)\n {\n   return (unsigned short) (~(unsigned short) x) == y;\t\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with unsigned\" } */\n }\n+\n+int\n+f18 (unsigned char x)\n+{\n+  return (unsigned int) (short) (~(unsigned short) x) == 0xffffff05ULL;\t/* { dg-bogus \"comparison of promoted bitwise complement of an unsigned value with constant\" } */\n+}"}]}