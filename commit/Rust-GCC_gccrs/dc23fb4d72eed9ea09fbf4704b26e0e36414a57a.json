{"sha": "dc23fb4d72eed9ea09fbf4704b26e0e36414a57a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyM2ZiNGQ3MmVlZDllYTA5ZmJmNDcwNGIyNmUwZTM2NDE0YTU3YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-07T16:56:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-07T16:56:09Z"}, "message": "compiler: speed up variable initializer sorting\n    \n    The compiler used to do variable initializer sorting by looping\n    through all the initialized variables and, for each one, looping\n    through all the initialized variables and checking for a dependency.\n    For very large packages with thousands of initialized global\n    variables, this quadratic loop could take quite a long time.\n    \n    Change the approach to first loop through all the initialized\n    variables and fetch all the references to other variables from the\n    initialization code.  Then, loop through them again and this time add\n    a dependency for each referenced, initialized, variable, while\n    checking for initialization loops.  We still have a nested loop, but\n    this time the inner loop should normally be short--just the list of\n    referenced variables, not the list of all variables.\n    \n    Reviewed-on: https://go-review.googlesource.com/116816\n\nFrom-SVN: r261284", "tree": {"sha": "81494302b4f5708ad6c96bad6ecfd9c109574c38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81494302b4f5708ad6c96bad6ecfd9c109574c38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a/comments", "author": null, "committer": null, "parents": [{"sha": "fa725532c41ae543fd0078263ea348aa5af3997d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa725532c41ae543fd0078263ea348aa5af3997d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa725532c41ae543fd0078263ea348aa5af3997d"}], "stats": {"total": 290, "additions": 193, "deletions": 97}, "files": [{"sha": "4c27161d412a91543add559fbe3f48da29d46abd", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=dc23fb4d72eed9ea09fbf4704b26e0e36414a57a", "patch": "@@ -1,4 +1,4 @@\n-baf289294a026ddd30c9e4341aff528084337763\n+3ec698690d2a8ecbf115489f17d85e848a2f7293\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4d77ace62e9c5674caaabfc58a379c51a1a72693", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 192, "deletions": 96, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc23fb4d72eed9ea09fbf4704b26e0e36414a57a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=dc23fb4d72eed9ea09fbf4704b26e0e36414a57a", "patch": "@@ -910,70 +910,82 @@ Gogo::create_initialization_function(Named_object* initfn,\n   return initfn;\n }\n \n-// Search for references to VAR in any statements or called functions.\n+// Given an expression, collect all the global variables defined in\n+// this package that it references.\n \n-class Find_var : public Traverse\n+class Find_vars : public Traverse\n {\n- public:\n-  // A hash table we use to avoid looping.  The index is the name of a\n-  // named object.  We only look through objects defined in this\n-  // package.\n+ private:\n+  // The list of variables we accumulate.\n+  typedef Unordered_set(Named_object*) Vars;\n+\n+  // A hash table we use to avoid looping.  The index is a\n+  // Named_object* or a Temporary_statement*.  We only look through\n+  // objects defined in this package.\n   typedef Unordered_set(const void*) Seen_objects;\n \n-  Find_var(Named_object* var, Seen_objects* seen_objects)\n+ public:\n+  Find_vars()\n     : Traverse(traverse_expressions),\n-      var_(var), seen_objects_(seen_objects), found_(false)\n+      vars_(), seen_objects_()\n   { }\n \n-  // Whether the variable was found.\n-  bool\n-  found() const\n-  { return this->found_; }\n+  // An iterator through the variables found, after the traversal.\n+  typedef Vars::const_iterator const_iterator;\n+\n+  const_iterator\n+  begin() const\n+  { return this->vars_.begin(); }\n+\n+  const_iterator\n+  end() const\n+  { return this->vars_.end(); }\n \n   int\n   expression(Expression**);\n \n  private:\n-  // The variable we are looking for.\n-  Named_object* var_;\n-  // Names of objects we have already seen.\n-  Seen_objects* seen_objects_;\n-  // True if the variable was found.\n-  bool found_;\n+  // Accumulated variables.\n+  Vars vars_;\n+  // Objects we have already seen.\n+  Seen_objects seen_objects_;\n };\n \n-// See if EXPR refers to VAR, looking through function calls and\n-// variable initializations.\n+// Collect global variables referenced by EXPR.  Look through function\n+// calls and variable initializations.\n \n int\n-Find_var::expression(Expression** pexpr)\n+Find_vars::expression(Expression** pexpr)\n {\n   Expression* e = *pexpr;\n \n   Var_expression* ve = e->var_expression();\n   if (ve != NULL)\n     {\n       Named_object* v = ve->named_object();\n-      if (v == this->var_)\n+      if (!v->is_variable() || v->package() != NULL)\n \t{\n-\t  this->found_ = true;\n-\t  return TRAVERSE_EXIT;\n+\t  // This is a result parameter or a variable defined in a\n+\t  // different package.  Either way we don't care about it.\n+\t  return TRAVERSE_CONTINUE;\n \t}\n \n-      if (v->is_variable() && v->package() == NULL)\n+      std::pair<Seen_objects::iterator, bool> ins =\n+\tthis->seen_objects_.insert(v);\n+      if (!ins.second)\n \t{\n-\t  Expression* init = v->var_value()->init();\n-\t  if (init != NULL)\n-\t    {\n-\t      std::pair<Seen_objects::iterator, bool> ins =\n-\t\tthis->seen_objects_->insert(v);\n-\t      if (ins.second)\n-\t\t{\n-\t\t  // This is the first time we have seen this name.\n-\t\t  if (Expression::traverse(&init, this) == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n-\t\t}\n-\t    }\n+\t  // We've seen this variable before.\n+\t  return TRAVERSE_CONTINUE;\n+\t}\n+\n+      if (v->var_value()->is_global())\n+\tthis->vars_.insert(v);\n+\n+      Expression* init = v->var_value()->init();\n+      if (init != NULL)\n+\t{\n+\t  if (Expression::traverse(&init, this) == TRAVERSE_EXIT)\n+\t    return TRAVERSE_EXIT;\n \t}\n     }\n \n@@ -988,7 +1000,7 @@ Find_var::expression(Expression** pexpr)\n       if (f->is_function() && f->package() == NULL)\n \t{\n \t  std::pair<Seen_objects::iterator, bool> ins =\n-\t    this->seen_objects_->insert(f);\n+\t    this->seen_objects_.insert(f);\n \t  if (ins.second)\n \t    {\n \t      // This is the first time we have seen this name.\n@@ -1006,7 +1018,7 @@ Find_var::expression(Expression** pexpr)\n       if (init != NULL)\n \t{\n \t  std::pair<Seen_objects::iterator, bool> ins =\n-\t    this->seen_objects_->insert(ts);\n+\t    this->seen_objects_.insert(ts);\n \t  if (ins.second)\n \t    {\n \t      // This is the first time we have seen this temporary\n@@ -1026,22 +1038,28 @@ static bool\n expression_requires(Expression* expr, Block* preinit, Named_object* dep,\n \t\t    Named_object* var)\n {\n-  Find_var::Seen_objects seen_objects;\n-  Find_var find_var(var, &seen_objects);\n+  Find_vars find_vars;\n   if (expr != NULL)\n-    Expression::traverse(&expr, &find_var);\n+    Expression::traverse(&expr, &find_vars);\n   if (preinit != NULL)\n-    preinit->traverse(&find_var);\n+    preinit->traverse(&find_vars);\n   if (dep != NULL)\n     {\n       Expression* init = dep->var_value()->init();\n       if (init != NULL)\n-\tExpression::traverse(&init, &find_var);\n+\tExpression::traverse(&init, &find_vars);\n       if (dep->var_value()->has_pre_init())\n-\tdep->var_value()->preinit()->traverse(&find_var);\n+\tdep->var_value()->preinit()->traverse(&find_vars);\n     }\n \n-  return find_var.found();\n+  for (Find_vars::const_iterator p = find_vars.begin();\n+       p != find_vars.end();\n+       ++p)\n+    {\n+      if (*p == var)\n+\treturn true;\n+    }\n+  return false;\n }\n \n // Sort variable initializations.  If the initialization expression\n@@ -1052,11 +1070,11 @@ class Var_init\n {\n  public:\n   Var_init()\n-    : var_(NULL), init_(NULL), dep_count_(0)\n+    : var_(NULL), init_(NULL), refs_(NULL), dep_count_(0)\n   { }\n \n   Var_init(Named_object* var, Bstatement* init)\n-    : var_(var), init_(init), dep_count_(0)\n+    : var_(var), init_(init), refs_(NULL), dep_count_(0)\n   { }\n \n   // Return the variable.\n@@ -1069,6 +1087,19 @@ class Var_init\n   init() const\n   { return this->init_; }\n \n+  // Add a reference.\n+  void\n+  add_ref(Named_object* var);\n+\n+  // The variables which this variable's initializers refer to.\n+  const std::vector<Named_object*>*\n+  refs()\n+  { return this->refs_; }\n+\n+  // Clear the references, if any.\n+  void\n+  clear_refs();\n+\n   // Return the number of remaining dependencies.\n   size_t\n   dep_count() const\n@@ -1087,14 +1118,38 @@ class Var_init\n  private:\n   // The variable being initialized.\n   Named_object* var_;\n-  // The initialization statement.\n+  // The backend initialization statement.\n   Bstatement* init_;\n+  // Variables this refers to.\n+  std::vector<Named_object*>* refs_;\n   // The number of initializations this is dependent on.  A variable\n   // initialization should not be emitted if any of its dependencies\n   // have not yet been resolved.\n   size_t dep_count_;\n };\n \n+// Add a reference.\n+\n+void\n+Var_init::add_ref(Named_object* var)\n+{\n+  if (this->refs_ == NULL)\n+    this->refs_ = new std::vector<Named_object*>;\n+  this->refs_->push_back(var);\n+}\n+\n+// Clear the references, if any.\n+\n+void\n+Var_init::clear_refs()\n+{\n+  if (this->refs_ != NULL)\n+    {\n+      delete this->refs_;\n+      this->refs_ = NULL;\n+    }\n+}\n+\n // For comparing Var_init keys in a map.\n \n inline bool\n@@ -1114,70 +1169,119 @@ sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n   if (var_inits->empty())\n     return;\n \n-  typedef std::pair<Named_object*, Named_object*> No_no;\n-  typedef std::map<No_no, bool> Cache;\n-  Cache cache;\n+  std::map<Named_object*, Var_init*> var_to_init;\n \n   // A mapping from a variable initialization to a set of\n   // variable initializations that depend on it.\n   typedef std::map<Var_init, std::set<Var_init*> > Init_deps;\n   Init_deps init_deps;\n   bool init_loop = false;\n-  for (Var_inits::iterator p1 = var_inits->begin();\n-       p1 != var_inits->end();\n-       ++p1)\n+\n+  // Compute all variable references.\n+  for (Var_inits::iterator pvar = var_inits->begin();\n+       pvar != var_inits->end();\n+       ++pvar)\n     {\n-      Named_object* var = p1->var();\n+      Named_object* var = pvar->var();\n+      var_to_init[var] = &*pvar;\n+\n+      Find_vars find_vars;\n       Expression* init = var->var_value()->init();\n-      Block* preinit = var->var_value()->preinit();\n+      if (init != NULL)\n+\tExpression::traverse(&init, &find_vars);\n+      if (var->var_value()->has_pre_init())\n+\tvar->var_value()->preinit()->traverse(&find_vars);\n       Named_object* dep = gogo->var_depends_on(var->var_value());\n+      if (dep != NULL)\n+\t{\n+\t  Expression* dinit = dep->var_value()->init();\n+\t  if (dinit != NULL)\n+\t    Expression::traverse(&dinit, &find_vars);\n+\t  if (dep->var_value()->has_pre_init())\n+\t    dep->var_value()->preinit()->traverse(&find_vars);\n+\t}\n+      for (Find_vars::const_iterator p = find_vars.begin();\n+\t   p != find_vars.end();\n+\t   ++p)\n+\tpvar->add_ref(*p);\n+    }\n \n-      // Start walking through the list to see which variables VAR\n-      // needs to wait for.\n-      for (Var_inits::iterator p2 = var_inits->begin();\n-\t   p2 != var_inits->end();\n-\t   ++p2)\n+  // Add dependencies to init_deps, and check for cycles.\n+  for (Var_inits::iterator pvar = var_inits->begin();\n+       pvar != var_inits->end();\n+       ++pvar)\n+    {\n+      Named_object* var = pvar->var();\n+\n+      const std::vector<Named_object*>* refs = pvar->refs();\n+      if (refs == NULL)\n+\tcontinue;\n+      for (std::vector<Named_object*>::const_iterator pdep = refs->begin();\n+\t   pdep != refs->end();\n+\t   ++pdep)\n \t{\n-\t  if (var == p2->var())\n-\t    continue;\n+\t  Named_object* dep = *pdep;\n+\t  if (var == dep)\n+\t    {\n+\t      // This is a reference from a variable to itself, which\n+\t      // may indicate a loop.  We only report an error if\n+\t      // there is an initializer and there is no dependency.\n+\t      // When there is no initializer, it means that the\n+\t      // preinitializer sets the variable, which will appear\n+\t      // to be a loop here.\n+\t      if (var->var_value()->init() != NULL\n+\t\t  && gogo->var_depends_on(var->var_value()) == NULL)\n+\t\tgo_error_at(var->location(),\n+\t\t\t    (\"initialization expression for %qs \"\n+\t\t\t     \"depends upon itself\"),\n+\t\t\t    var->message_name().c_str());\n+\n+\t      continue;\n+\t    }\n \n-\t  Named_object* p2var = p2->var();\n-\t  No_no key(var, p2var);\n-\t  std::pair<Cache::iterator, bool> ins =\n-\t    cache.insert(std::make_pair(key, false));\n-\t  if (ins.second)\n-\t    ins.first->second = expression_requires(init, preinit, dep, p2var);\n-\t  if (ins.first->second)\n+\t  Var_init* dep_init = var_to_init[dep];\n+\t  if (dep_init == NULL)\n \t    {\n-\t      // VAR depends on P2VAR.\n-\t      init_deps[*p2].insert(&(*p1));\n-\t      p1->add_dependency();\n-\n-\t      // Check for cycles.\n-\t      key = std::make_pair(p2var, var);\n-\t      ins = cache.insert(std::make_pair(key, false));\n-\t      if (ins.second)\n-\t\tins.first->second =\n-\t\t  expression_requires(p2var->var_value()->init(),\n-\t\t\t\t      p2var->var_value()->preinit(),\n-\t\t\t\t      gogo->var_depends_on(p2var->var_value()),\n-\t\t\t\t      var);\n-\t      if (ins.first->second)\n+\t      // This is a dependency on some variable that doesn't\n+\t      // have an initializer, so for purposes of\n+\t      // initialization ordering this is irrelevant.\n+\t      continue;\n+\t    }\n+\n+\t  init_deps[*dep_init].insert(&(*pvar));\n+\t  pvar->add_dependency();\n+\n+\t  // Check for cycles.\n+\t  const std::vector<Named_object*>* deprefs = dep_init->refs();\n+\t  if (deprefs == NULL)\n+\t    continue;\n+\t  for (std::vector<Named_object*>::const_iterator pdepdep =\n+\t\t deprefs->begin();\n+\t       pdepdep != deprefs->end();\n+\t       ++pdepdep)\n+\t    {\n+\t      if (*pdepdep == var)\n \t\t{\n \t\t  go_error_at(var->location(),\n \t\t\t      (\"initialization expressions for %qs and \"\n \t\t\t       \"%qs depend upon each other\"),\n \t\t\t      var->message_name().c_str(),\n-\t\t\t      p2var->message_name().c_str());\n-\t\t  go_inform(p2->var()->location(), \"%qs defined here\",\n-\t\t\t    p2var->message_name().c_str());\n+\t\t\t      dep->message_name().c_str());\n+\t\t  go_inform(dep->location(), \"%qs defined here\",\n+\t\t\t    dep->message_name().c_str());\n \t\t  init_loop = true;\n \t\t  break;\n \t\t}\n \t    }\n \t}\n     }\n \n+  var_to_init.clear();\n+  for (Var_inits::iterator pvar = var_inits->begin();\n+       pvar != var_inits->end();\n+       ++pvar)\n+    pvar->clear_refs();\n+\n   // If there are no dependencies then the declaration order is sorted.\n   if (!init_deps.empty() && !init_loop)\n     {\n@@ -1214,14 +1318,6 @@ sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n       var_inits->swap(ready);\n       go_assert(init_deps.empty());\n     }\n-\n-  // VAR_INITS is in the correct order.  For each VAR in VAR_INITS,\n-  // check for a loop of VAR on itself.\n-  // interpret as a loop.\n-  for (Var_inits::const_iterator p = var_inits->begin();\n-       p != var_inits->end();\n-       ++p)\n-    gogo->check_self_dep(p->var());\n }\n \n // Give an error if the initialization expression for VAR depends on"}]}