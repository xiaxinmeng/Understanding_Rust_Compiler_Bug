{"sha": "b8ff4e88e790df436088012ce6db7f7d3b6c1514", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhmZjRlODhlNzkwZGY0MzYwODgwMTJjZTZkYjdmN2QzYjZjMTUxNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-05-26T17:41:34Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-05-26T17:41:34Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-05-26  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * trans-array.c (gfc_conv_array_ref): Handle pointer coarrays.\n        * trans-decl.c (has_coarray_vars, caf_init_block,\n        gfor_fndecl_caf_register): New file-global variables.\n        (gfc_finish_var_decl): Make sure that coarrays in main are static.\n        (gfc_build_qualified_array): Generate coarray token variable.\n        (gfc_get_symbol_decl): Don't use a static initializer for coarrays.\n        (gfc_build_builtin_function_decls): Set gfor_fndecl_caf_register.\n        (gfc_trans_deferred_vars, gfc_emit_parameter_debug_info): Skip for\n        static coarrays.\n        (generate_local_decl): Check for local coarrays.\n        (create_main_function): SYNC ALL before calling MAIN.\n        (generate_coarray_sym_init): Register static coarray.\n        (generate_coarray_init): Generate CAF registering constructor\n        function.\n        (gfc_generate_function_code): Call it, if needed, do not create\n        cgraph twice.\n        (gfc_generate_module_vars, gfc_process_block_locals): Call\n        generate_coarray_init.\n        * trans-types.c (gfc_get_nodesc_array_type): Generate pointers\n        * for\n        -fcoarray=lib.\n        * trans.h (gfor_fndecl_caf_register): New variable.\n        (lang_type): New element caf_token.\n        (GFC_TYPE_ARRAY_CAF_TOKEN): New macro.\n\n2011-05-26  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray/registering_1.f90: New.\n\nFrom-SVN: r174301", "tree": {"sha": "6849d2aa0446ce8a27b11e1707397da8df445fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6849d2aa0446ce8a27b11e1707397da8df445fe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ff4e88e790df436088012ce6db7f7d3b6c1514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ff4e88e790df436088012ce6db7f7d3b6c1514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ff4e88e790df436088012ce6db7f7d3b6c1514", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ff4e88e790df436088012ce6db7f7d3b6c1514/comments", "author": null, "committer": null, "parents": [{"sha": "92e948a836d98e98a1721008795dfddbb47828a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e948a836d98e98a1721008795dfddbb47828a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92e948a836d98e98a1721008795dfddbb47828a6"}], "stats": {"total": 277, "additions": 264, "deletions": 13}, "files": [{"sha": "79d4a2515d2fa7d2df47e3a5f4f18ae4615b4d9c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b8ff4e88e790df436088012ce6db7f7d3b6c1514", "patch": "@@ -1,3 +1,30 @@\n+2011-05-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* trans-array.c (gfc_conv_array_ref): Handle pointer coarrays.\n+\t* trans-decl.c (has_coarray_vars, caf_init_block,\n+\tgfor_fndecl_caf_register): New file-global variables.\n+\t(gfc_finish_var_decl): Make sure that coarrays in main are static.\n+\t(gfc_build_qualified_array): Generate coarray token variable.\n+\t(gfc_get_symbol_decl): Don't use a static initializer for coarrays.\n+\t(gfc_build_builtin_function_decls): Set gfor_fndecl_caf_register.\n+\t(gfc_trans_deferred_vars, gfc_emit_parameter_debug_info): Skip for\n+\tstatic coarrays.\n+\t(generate_local_decl): Check for local coarrays.\n+\t(create_main_function): SYNC ALL before calling MAIN.\n+\t(generate_coarray_sym_init): Register static coarray.\n+\t(generate_coarray_init): Generate CAF registering constructor\n+\tfunction.\n+\t(gfc_generate_function_code): Call it, if needed, do not create\n+\tcgraph twice.\n+\t(gfc_generate_module_vars, gfc_process_block_locals): Call\n+\tgenerate_coarray_init.\n+\t* trans-types.c (gfc_get_nodesc_array_type): Generate pointers for\n+\t-fcoarray=lib.\n+\t* trans.h (gfor_fndecl_caf_register): New variable.\n+\t(lang_type): New element caf_token.\n+\t(GFC_TYPE_ARRAY_CAF_TOKEN): New macro.\n+\n 2011-05-24  Joseph Myers  <joseph@codesourcery.com>\n \n \t* Make-lang.in (GFORTRAN_D_OBJS): Remove prefix.o.\n@@ -27,11 +54,11 @@\n \n 2011-05-20  Janne Blomqvist  <jb@gcc.gnu.org>\n \n-        * gfortran.texi (set_fpe): Update documentation.\n-        * invoke.texi (-ffpe-trap): Likewise.\n-        * libgfortran.h (GFC_FPE_PRECISION): Rename to GFC_FPE_INEXACT.\n-        * options.c (gfc_handle_fpe_trap_option): Handle inexact and make\n-        precision an alias for it.\n+\t* gfortran.texi (set_fpe): Update documentation.\n+\t* invoke.texi (-ffpe-trap): Likewise.\n+\t* libgfortran.h (GFC_FPE_PRECISION): Rename to GFC_FPE_INEXACT.\n+\t* options.c (gfc_handle_fpe_trap_option): Handle inexact and make\n+\tprecision an alias for it.\n \n 2011-05-19  Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "29c7f835475ebde0f081697f1a42806254e5b9fd", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=b8ff4e88e790df436088012ce6db7f7d3b6c1514", "patch": "@@ -2623,6 +2623,10 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n   if (ar->dimen == 0)\n     {\n       gcc_assert (ar->codimen);\n+      if (GFC_ARRAY_TYPE_P (TREE_TYPE (se->expr))\n+\t  && TREE_CODE (TREE_TYPE (se->expr)) == POINTER_TYPE)\n+\tse->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n+\n       /* Use the actual tree type and not the wrapped coarray. */\n       se->expr = fold_convert (TREE_TYPE (TREE_TYPE (se->expr)), se->expr);\n       return;"}, {"sha": "299f2246d9cb5cf1b388b9727d9e2313a43abad4", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 175, "deletions": 5, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=b8ff4e88e790df436088012ce6db7f7d3b6c1514", "patch": "@@ -78,6 +78,12 @@ static gfc_namespace *module_namespace;\n static gfc_symbol* current_procedure_symbol = NULL;\n \n \n+/* With -fcoarray=lib: For generating the registering call\n+   of static coarrays.  */\n+static bool has_coarray_vars;\n+static stmtblock_t caf_init_block;\n+\n+\n /* List of static constructor functions.  */\n \n tree gfc_static_ctors;\n@@ -114,6 +120,7 @@ tree gfor_fndecl_associated;\n /* Coarray run-time library function decls.  */\n tree gfor_fndecl_caf_init;\n tree gfor_fndecl_caf_finalize;\n+tree gfor_fndecl_caf_register;\n tree gfor_fndecl_caf_critical;\n tree gfor_fndecl_caf_end_critical;\n tree gfor_fndecl_caf_sync_all;\n@@ -566,7 +573,9 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n      SAVE_EXPLICIT.  */\n   if (!sym->attr.use_assoc\n \t&& (sym->attr.save != SAVE_NONE || sym->attr.data\n-\t      || (sym->value && sym->ns->proc_name->attr.is_main_program)))\n+\t    || (sym->value && sym->ns->proc_name->attr.is_main_program)\n+\t    || (gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t\t&& sym->attr.codimension && !sym->attr.allocatable)))\n     TREE_STATIC (decl) = 1;\n \n   if (sym->attr.volatile_)\n@@ -745,6 +754,18 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n   nest = (procns->proc_name->backend_decl != current_function_decl)\n \t && !sym->attr.contained;\n \n+  if (sym->attr.codimension && gfc_option.coarray == GFC_FCOARRAY_LIB\n+      && GFC_TYPE_ARRAY_CAF_TOKEN (type) == NULL_TREE)\n+    {\n+      tree token;\n+\n+      token = gfc_create_var_np (pvoid_type_node, \"caf_token\");\n+      GFC_TYPE_ARRAY_CAF_TOKEN (type) = token;\n+      DECL_ARTIFICIAL (token) = 1;\n+      TREE_STATIC (token) = 1;\n+      gfc_add_decl_to_function (token);\n+    }\n+\n   for (dim = 0; dim < GFC_TYPE_ARRAY_RANK (type); dim++)\n     {\n       if (GFC_TYPE_ARRAY_LBOUND (type, dim) == NULL_TREE)\n@@ -1403,7 +1424,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       && !(sym->attr.use_assoc && !intrinsic_array_parameter)\n       && (sym->attr.save || sym->ns->proc_name->attr.is_main_program\n \t  || gfc_option.flag_max_stack_var_size == 0\n-\t  || sym->attr.data || sym->ns->proc_name->attr.flavor == FL_MODULE))\n+\t  || sym->attr.data || sym->ns->proc_name->attr.flavor == FL_MODULE)\n+      && (gfc_option.coarray != GFC_FCOARRAY_LIB || !sym->attr.codimension))\n     {\n       /* Add static initializer. For procedures, it is only needed if\n \t SAVE is specified otherwise they need to be reinitialized\n@@ -3025,6 +3047,11 @@ gfc_build_builtin_function_decls (void)\n       gfor_fndecl_caf_finalize = gfc_build_library_function_decl (\n \tget_identifier (PREFIX(\"caf_finalize\")), void_type_node, 0);\n \n+      gfor_fndecl_caf_register = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_register\")), \"...WWW\", pvoid_type_node, 6,\n+        size_type_node, integer_type_node, ppvoid_type_node, pint_type,\n+        build_pointer_type (pchar_type_node), integer_type_node);\n+\n       gfor_fndecl_caf_critical = gfc_build_library_function_decl (\n \tget_identifier (PREFIX(\"caf_critical\")), void_type_node, 0);\n \n@@ -3458,7 +3485,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t      gfc_trans_deferred_array (sym, block);\n \t\t    }\n \t\t}\n-\t      else\n+\t      else if (gfc_option.coarray != GFC_FCOARRAY_LIB)\n \t\t{\n \t\t  gfc_save_backend_locus (&loc);\n \t\t  gfc_set_backend_locus (&sym->declared_at);\n@@ -3864,6 +3891,10 @@ gfc_create_module_variable (gfc_symbol * sym)\n           rest_of_decl_compilation (length, 1, 0);\n         }\n     }\n+\n+  if (sym->attr.codimension && !sym->attr.dummy && !sym->attr.allocatable\n+      && sym->attr.referenced && !sym->attr.use_assoc)\n+    has_coarray_vars = true;\n }\n \n /* Emit debug information for USE statements.  */\n@@ -4066,6 +4097,9 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n \t\t\t\t   sym->attr.dimension, false))\n     return;\n \n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && sym->attr.codimension)\n+    return;\n+\n   /* Create the decl for the variable or constant.  */\n   decl = build_decl (input_location,\n \t\t     sym->attr.flavor == FL_PARAMETER ? CONST_DECL : VAR_DECL,\n@@ -4087,6 +4121,120 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n   debug_hooks->global_decl (decl);\n }\n \n+\n+static void\n+generate_coarray_sym_init (gfc_symbol *sym)\n+{\n+  tree tmp, size, decl, token;\n+\n+  if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension\n+      || sym->attr.use_assoc || !sym->attr.referenced) \n+    return;\n+\n+  decl = sym->backend_decl;\n+  TREE_USED(decl) = 1;\n+  gcc_assert (GFC_ARRAY_TYPE_P (TREE_TYPE (decl)));\n+\n+  /* FIXME: Workaround for PR middle-end/49106, cf. also PR middle-end/49108\n+     to make sure the variable is not optimized away.  */\n+  DECL_PRESERVE_P (DECL_CONTEXT (decl)) = 1;\n+\n+  size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (decl)));\n+\n+  if (GFC_TYPE_ARRAY_RANK (TREE_TYPE (decl)))\n+    {\n+      tmp = GFC_TYPE_ARRAY_SIZE (TREE_TYPE (decl));\n+      size = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t      fold_convert (size_type_node, tmp),\n+\t\t\t      fold_convert (size_type_node, size));\n+    }\n+\n+  gcc_assert (GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (decl)) != NULL_TREE);\n+  token = gfc_build_addr_expr (ppvoid_type_node,\n+\t\t\t       GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE(decl)));\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_register, 6, size,\n+\t\t\t     build_int_cst (integer_type_node, 0), /* type.  */\n+\t\t\t     token, null_pointer_node, /* token, stat.  */\n+\t\t\t     null_pointer_node, /* errgmsg, errmsg_len.  */\n+\t\t\t     build_int_cst (integer_type_node, 0));\n+  \n+  gfc_add_modify (&caf_init_block, decl, fold_convert (TREE_TYPE (decl), tmp));\n+\n+\n+  /* Handle \"static\" initializer.  */\n+  if (sym->value)\n+    {\n+      sym->attr.pointer = 1;\n+      tmp = gfc_trans_assignment (gfc_lval_expr_from_sym (sym), sym->value,\n+\t\t\t\t  true, false);\n+      sym->attr.pointer = 0;\n+      gfc_add_expr_to_block (&caf_init_block, tmp);\n+    }\n+}\n+\n+\n+/* Generate constructor function to initialize static, nonallocatable\n+   coarrays.  */\n+\n+static void\n+generate_coarray_init (gfc_namespace * ns __attribute((unused)))\n+{\n+  tree fndecl, tmp, decl, save_fn_decl;\n+\n+  save_fn_decl = current_function_decl;\n+  push_function_context ();\n+\n+  tmp = build_function_type_list (void_type_node, NULL_TREE);\n+  fndecl = build_decl (input_location, FUNCTION_DECL,\n+\t\t       create_tmp_var_name (\"_caf_init\"), tmp);\n+\n+  DECL_STATIC_CONSTRUCTOR (fndecl) = 1;\n+  SET_DECL_INIT_PRIORITY (fndecl, DEFAULT_INIT_PRIORITY);\n+\n+  decl = build_decl (input_location, RESULT_DECL, NULL_TREE, void_type_node);\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  DECL_CONTEXT (decl) = fndecl;\n+  DECL_RESULT (fndecl) = decl;\n+\n+  pushdecl (fndecl);\n+  current_function_decl = fndecl;\n+  announce_function (fndecl);\n+\n+  rest_of_decl_compilation (fndecl, 0, 0);\n+  make_decl_rtl (fndecl);\n+  init_function_start (fndecl);\n+\n+  pushlevel (0);\n+  gfc_init_block (&caf_init_block);\n+\n+  gfc_traverse_ns (ns, generate_coarray_sym_init);\n+\n+  DECL_SAVED_TREE (fndecl) = gfc_finish_block (&caf_init_block);\n+  decl = getdecls ();\n+\n+  poplevel (1, 0, 1);\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n+\n+  DECL_SAVED_TREE (fndecl)\n+    = build3_v (BIND_EXPR, decl, DECL_SAVED_TREE (fndecl),\n+                DECL_INITIAL (fndecl));\n+  dump_function (TDI_original, fndecl);\n+\n+  cfun->function_end_locus = input_location;\n+  set_cfun (NULL);\n+\n+  if (decl_function_context (fndecl))\n+    (void) cgraph_create_node (fndecl);\n+  else\n+    cgraph_finalize_function (fndecl, true);\n+\n+  pop_function_context ();\n+  current_function_decl = save_fn_decl;\n+}\n+\n+\n /* Generate all the required code for module variables.  */\n \n void\n@@ -4101,9 +4249,14 @@ gfc_generate_module_vars (gfc_namespace * ns)\n   /* Generate COMMON blocks.  */\n   gfc_trans_common (ns);\n \n+  has_coarray_vars = false;\n+\n   /* Create decls for all the module variables.  */\n   gfc_traverse_ns (ns, gfc_create_module_variable);\n \n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n+    generate_coarray_init (ns);\n+\n   cur_module = NULL;\n \n   gfc_trans_use_stmts (ns);\n@@ -4200,6 +4353,10 @@ generate_local_decl (gfc_symbol * sym)\n {\n   if (sym->attr.flavor == FL_VARIABLE)\n     {\n+      if (sym->attr.codimension && !sym->attr.dummy && !sym->attr.allocatable\n+\t  && sym->attr.referenced && !sym->attr.use_assoc)\n+\thas_coarray_vars = true;\n+\n       if (!sym->attr.dummy && !sym->ns->proc_name->attr.entry_master)\n \tgenerate_dependency_declarations (sym);\n \n@@ -4897,8 +5054,12 @@ gfc_generate_function_code (gfc_namespace * ns)\n   nonlocal_dummy_decls = NULL;\n   nonlocal_dummy_decl_pset = NULL;\n \n+  has_coarray_vars = false;\n   generate_local_vars (ns);\n \n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n+    generate_coarray_init (ns);\n+\n   /* Keep the parent fake result declaration in module functions\n      or external procedures.  */\n   if ((ns->parent && ns->parent->proc_name->attr.flavor == FL_MODULE)\n@@ -5062,9 +5223,13 @@ gfc_generate_function_code (gfc_namespace * ns)\n     }\n   current_function_decl = old_context;\n \n-  if (decl_function_context (fndecl))\n+  if (decl_function_context (fndecl) && !gfc_option.coarray == GFC_FCOARRAY_LIB\n+      && has_coarray_vars)\n     /* Register this function with cgraph just far enough to get it\n-       added to our parent's nested function list.  */\n+       added to our parent's nested function list.\n+       If there are static coarrays in this function, the nested _caf_init\n+       function has already called cgraph_create_node, which also created\n+       the cgraph node for this function.  */\n     (void) cgraph_create_node (fndecl);\n   else\n     cgraph_finalize_function (fndecl, true);\n@@ -5190,8 +5355,13 @@ gfc_process_block_locals (gfc_namespace* ns)\n   tree decl;\n \n   gcc_assert (saved_local_decls == NULL_TREE);\n+  has_coarray_vars = false;\n+\n   generate_local_vars (ns);\n \n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n+    generate_coarray_init (ns);\n+\n   decl = saved_local_decls;\n   while (decl)\n     {"}, {"sha": "9c4f5f6d01e64a2ce130290bd348a2b90db14b83", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=b8ff4e88e790df436088012ce6db7f7d3b6c1514", "patch": "@@ -1542,13 +1542,13 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n \n   if (as->rank == 0)\n     {\n-      if (packed != PACKED_STATIC)\n+      if (packed != PACKED_STATIC  || gfc_option.coarray == GFC_FCOARRAY_LIB)\n \ttype = build_pointer_type (type);\n \n       if (restricted)\n         type = build_qualified_type (type, TYPE_QUAL_RESTRICT);\t\n \n-      if (packed != PACKED_STATIC)\n+      if (packed != PACKED_STATIC  || gfc_option.coarray == GFC_FCOARRAY_LIB)\n \t{\n \t  GFC_ARRAY_TYPE_P (type) = 1;\n \t  TYPE_LANG_SPECIFIC (type) = TYPE_LANG_SPECIFIC (TREE_TYPE (type)); \n@@ -1596,7 +1596,8 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n       DECL_ORIGINAL_TYPE (type_decl) = gtype;\n     }\n \n-  if (packed != PACKED_STATIC || !known_stride)\n+  if (packed != PACKED_STATIC || !known_stride\n+      || (as->corank && gfc_option.coarray == GFC_FCOARRAY_LIB))\n     {\n       /* For dummy arrays and automatic (heap allocated) arrays we\n \t want a pointer to the array.  */"}, {"sha": "95cd9fbf151cfb28fabffe19cc9446474fc65b61", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=b8ff4e88e790df436088012ce6db7f7d3b6c1514", "patch": "@@ -617,6 +617,7 @@ extern GTY(()) tree gfor_fndecl_associated;\n /* Coarray run-time library function decls.  */\n extern GTY(()) tree gfor_fndecl_caf_init;\n extern GTY(()) tree gfor_fndecl_caf_finalize;\n+extern GTY(()) tree gfor_fndecl_caf_register;\n extern GTY(()) tree gfor_fndecl_caf_critical;\n extern GTY(()) tree gfor_fndecl_caf_end_critical;\n extern GTY(()) tree gfor_fndecl_caf_sync_all;\n@@ -722,6 +723,7 @@ struct GTY((variable_size))\tlang_type\t {\n   tree span;\n   tree base_decl[2];\n   tree nonrestricted_type;\n+  tree caf_token;\n };\n \n struct GTY((variable_size)) lang_decl {\n@@ -766,6 +768,7 @@ struct GTY((variable_size)) lang_decl {\n   (TYPE_LANG_SPECIFIC(node)->stride[dim])\n #define GFC_TYPE_ARRAY_RANK(node) (TYPE_LANG_SPECIFIC(node)->rank)\n #define GFC_TYPE_ARRAY_CORANK(node) (TYPE_LANG_SPECIFIC(node)->corank)\n+#define GFC_TYPE_ARRAY_CAF_TOKEN(node) (TYPE_LANG_SPECIFIC(node)->caf_token)\n #define GFC_TYPE_ARRAY_SIZE(node) (TYPE_LANG_SPECIFIC(node)->size)\n #define GFC_TYPE_ARRAY_OFFSET(node) (TYPE_LANG_SPECIFIC(node)->offset)\n #define GFC_TYPE_ARRAY_AKIND(node) (TYPE_LANG_SPECIFIC(node)->akind)"}, {"sha": "eec8fa7061962c8ce6041138565998f5d0f85816", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8ff4e88e790df436088012ce6db7f7d3b6c1514", "patch": "@@ -1,3 +1,8 @@\n+2011-05-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray/registering_1.f90: New.\n+\n 2011-05-26  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/variadic111.C: New."}, {"sha": "a18ba615af73c0d749257d05ef2d6c994d483e72", "filename": "gcc/testsuite/gfortran.dg/coarray/registering_1.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fregistering_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff4e88e790df436088012ce6db7f7d3b6c1514/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fregistering_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fregistering_1.f90?ref=b8ff4e88e790df436088012ce6db7f7d3b6c1514", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+!\n+! PR fortran/18918\n+!\n+! Check whether registering coarrays works\n+!\n+module m\n+  integer :: a(1)[*] = 7\n+end module m\n+\n+use m\n+if (any (a /= 7)) call abort()\n+a = 88\n+if (any (a /= 88)) call abort()\n+\n+ block\n+   integer :: b[*] = 8494\n+   if (b /= 8494) call abort()\n+ end block\n+\n+if (any (a /= 88)) call abort()\n+call test ()\n+end\n+\n+subroutine test()\n+  real :: z[*] = sqrt(2.0)\n+  if (z /= sqrt(2.0)) call abort()\n+  call sub1()\n+contains\n+  subroutine sub1\n+    real :: r[4,*] = -1\n+    if (r /= -1) call abort\n+    r = 10\n+    if (r /= 10) call abort\n+  end subroutine sub1\n+\n+  subroutine uncalled()\n+     integer :: not_refed[2:*] = 784\n+     if (not_refed /= 784) call abort()\n+  end subroutine uncalled\n+end subroutine test"}]}