{"sha": "ffabcde5e102cd7cc8a283ddc89861a727226913", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhYmNkZTVlMTAyY2Q3Y2M4YTI4M2RkYzg5ODYxYTcyNzIyNjkxMw==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2006-02-15T09:32:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:32:52Z"}, "message": "a-rbtgso.adb, [...]: All explicit raise statements now include an exception message.\n\n2006-02-13  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-rbtgso.adb, a-crbtgo.adb, a-crbtgk.adb, a-coorse.adb, \n\ta-cohama.adb, a-ciorse.adb, a-cihama.adb, a-cihase.adb, \n\ta-cohase.adb: All explicit raise statements now include an exception\n\tmessage.\n\n\t* a-ciormu.ads, a-ciormu.adb, a-coormu.ads, a-coormu.adb\n\t(Update_Element_Preserving_Key): renamed op to just Update_Element.\n\tExplicit raise statements now include an exception message\n\n\t* a-cihase.ads, a-cohase.ads: Removed comment.\n\n\t* a-stboha.ads, a-stboha.adb, a-stfiha.ads, a-envvar.adb,\n\ta-envvar.ads, a-swbwha.ads, a-swbwha.adb, a-swfwha.ads, a-szbzha.ads,\n\ta-szbzha.adb, a-szfzha.ads: New files.\n\nFrom-SVN: r111035", "tree": {"sha": "39a55d293e0dcbbc8992be624d0eb85bc7be0307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39a55d293e0dcbbc8992be624d0eb85bc7be0307"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffabcde5e102cd7cc8a283ddc89861a727226913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffabcde5e102cd7cc8a283ddc89861a727226913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffabcde5e102cd7cc8a283ddc89861a727226913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffabcde5e102cd7cc8a283ddc89861a727226913/comments", "author": null, "committer": null, "parents": [{"sha": "738819cdce8e966e04a3e83d305db2cfa9bdaa75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/738819cdce8e966e04a3e83d305db2cfa9bdaa75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/738819cdce8e966e04a3e83d305db2cfa9bdaa75"}], "stats": {"total": 1829, "additions": 1342, "deletions": 487}, "files": [{"sha": "04c9c6b0e764ed4db4d3c978960858181cf2d048", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 90, "deletions": 57, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -186,28 +186,31 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to delete key not in map\";\n       end if;\n \n       Free (X);\n    end Delete;\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Delete equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Delete designates wrong map\";\n       end if;\n \n       if Container.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Delete attempted to tamper with elements (map is busy)\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n       Free (Position.Node);\n@@ -223,24 +226,27 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n       end if;\n \n       return Node.Element.all;\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Element equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of function Element is bad\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -262,21 +268,29 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Equivalent_Keys (Left, Right : Cursor) return Boolean is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+      if Left.Node = null then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys equals No_Element\";\n+      end if;\n \n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null\n-        or else Right.Node.Key = null\n-      then\n-         raise Program_Error;\n+      if Left.Node.Key = null then\n+         raise Program_Error with\n+           \"Left cursor of Equivalent_Keys is bad\";\n+      end if;\n+\n+      if Right.Node.Key = null then\n+         raise Program_Error with\n+           \"Right cursor of Equivalent_Keys is bad\";\n       end if;\n \n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n       return Equivalent_Keys (Left.Node.Key.all, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -285,16 +299,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Key_Type) return Boolean\n    is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n       if Left.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Left cursor of Equivalent_Keys is bad\";\n       end if;\n \n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+\n       return Equivalent_Keys (Left.Node.Key.all, Right);\n    end Equivalent_Keys;\n \n@@ -303,16 +319,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Cursor) return Boolean\n    is\n    begin\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n-\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n       if Right.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Right cursor of Equivalent_Keys is bad\";\n       end if;\n \n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n       return Equivalent_Keys (Left, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -472,7 +490,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n       if not Inserted then\n          if Container.HT.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Include attempted to tamper with cursors (map is locked)\";\n          end if;\n \n          K := Position.Node.Key;\n@@ -559,7 +578,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to insert key already in map\";\n       end if;\n    end Insert;\n \n@@ -607,16 +627,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Key\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Key equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of function Key is bad\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n       return Position.Node.Key.all;\n    end Key;\n \n@@ -657,18 +679,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor of Next is bad\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"Position cursor of Next is bad\");\n+\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n@@ -692,18 +714,20 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n                                             Element : Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Query_Element is bad\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n       declare\n          M  : Map renames Position.Container.all;\n          HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n@@ -752,7 +776,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Read;\n \n    ---------------\n@@ -801,11 +825,13 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to replace key not in map\";\n       end if;\n \n       if Container.HT.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Replace attempted to tamper with cursors (map is locked)\";\n       end if;\n \n       K := Node.Key;\n@@ -835,26 +861,30 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n       if Position.Container.HT.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Replace_Element attempted to tamper with cursors (map is locked)\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n       declare\n          X : Element_Access := Position.Node.Element;\n \n@@ -896,22 +926,25 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Update_Element is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Update_Element designates wrong map\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n       declare\n          HT : Hash_Table_Type renames Container.HT;\n \n@@ -1021,7 +1054,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Write;\n \n    ----------------"}, {"sha": "0bb8cb73f7549237a04d52dcf7809f1ca04ae82e", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 111, "deletions": 76, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -42,10 +42,10 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n-with System;  use type System.Address;\n-\n with Ada.Containers.Prime_Numbers;\n \n+with System;  use type System.Address;\n+\n package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    -----------------------\n@@ -214,7 +214,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n \n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n       Free (X);\n@@ -225,24 +225,25 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       if Container.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"Position cursor is bad\");\n+\n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n       Free (Position.Node);\n@@ -270,7 +271,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       --  TODO: This can be written in terms of a loop instead as\n@@ -367,16 +369,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor of equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then  --  handle dangling reference\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -396,21 +398,29 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    function Equivalent_Elements (Left, Right : Cursor)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+      if Left.Node = null then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements equals No_Element\";\n+      end if;\n \n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null  --  handle dangling cursor reference\n-        or else Right.Node.Element = null\n-      then\n-         raise Program_Error;\n+      if Left.Node.Element = null then\n+         raise Program_Error with\n+           \"Left cursor of Equivalent_Elements is bad\";\n       end if;\n \n+      if Right.Node.Element = null then\n+         raise Program_Error with\n+           \"Right cursor of Equivalent_Elements is bad\";\n+      end if;\n+\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Elements\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Elements\");\n+\n       return Equivalent_Elements\n                (Left.Node.Element.all,\n                 Right.Node.Element.all);\n@@ -419,32 +429,36 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null then  --  handling dangling reference\n-         raise Program_Error;\n+      if Left.Node.Element = null then\n+         raise Program_Error with\n+           \"Left cursor of Equivalent_Elements is bad\";\n       end if;\n \n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Elements\");\n+\n       return Equivalent_Elements (Left.Node.Element.all, Right);\n    end Equivalent_Elements;\n \n    function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n-\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n-      if Right.Node.Element = null then  --  handle dangling cursor reference\n-         raise Program_Error;\n+      if Right.Node.Element = null then\n+         raise Program_Error with\n+           \"Right cursor of Equivalent_Elements is bad\";\n       end if;\n \n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Elements\");\n+\n       return Equivalent_Elements (Left, Right.Node.Element.all);\n    end Equivalent_Elements;\n \n@@ -632,7 +646,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       if not Inserted then\n          if Container.HT.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          X := Position.Node.Element;\n@@ -669,7 +684,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n       end if;\n    end Insert;\n \n@@ -737,7 +753,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       --  TODO: optimize this to use an explicit\n@@ -951,16 +968,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"bad cursor in Next\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Next\");\n+\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n@@ -1016,16 +1033,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"bad cursor in Query_Element\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n       declare\n          HT : Hash_Table_Type renames\n                 Position.Container'Unrestricted_Access.all.HT;\n@@ -1068,7 +1086,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n    ---------------\n@@ -1103,11 +1121,13 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to replace element not in set\";\n       end if;\n \n       if Container.HT.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is locked)\";\n       end if;\n \n       X := Node.Element;\n@@ -1131,7 +1151,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          pragma Assert (Hash (Node.Element.all) = Hash (New_Item));\n \n          if HT.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          declare\n@@ -1145,7 +1166,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       end if;\n \n       if HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       HT_Ops.Delete_Node_Sans_Free (HT, Node);\n@@ -1227,7 +1249,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             null;\n       end Reinsert_Old_Element;\n \n-      raise Program_Error;\n+      raise Program_Error with \"attempt to replace existing element\";\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -1236,20 +1258,21 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"bad cursor in Replace_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong set\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n       Replace_Element (Container.HT, Position.Node, New_Item);\n    end Replace_Element;\n \n@@ -1289,7 +1312,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       declare\n@@ -1605,7 +1629,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       declare\n@@ -1808,7 +1833,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n    ----------------\n@@ -1873,7 +1898,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n          if X = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"key not in map\";\n          end if;\n \n          Free (X);\n@@ -1888,7 +1913,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Key       : Key_Type) return Element_Type\n       is\n          Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n+\n       begin\n+         if Node = null then\n+            raise Constraint_Error with \"key not in map\";\n+         end if;\n+\n          return Node.Element.all;\n       end Element;\n \n@@ -1941,16 +1971,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n-         pragma Assert (Vet (Position), \"bad cursor in function Key\");\n-\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Node.Element = null then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor is bad\";\n          end if;\n \n+         pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n          return Key (Position.Node.Element.all);\n       end Key;\n \n@@ -1968,47 +1999,50 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n          end if;\n \n          Replace_Element (Container.HT, Node, New_Item);\n       end Replace;\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n-         Position  : in     Cursor;\n+         Position  : Cursor;\n          Process   : not null access\n            procedure (Element : in out Element_Type))\n       is\n          HT   : Hash_Table_Type renames Container.HT;\n          Indx : Hash_Type;\n \n       begin\n-         pragma Assert\n-           (Vet (Position),\n-            \"bad cursor in Update_Element_Preserving_Key\");\n-\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Node.Element = null\n            or else Position.Node.Next = Position.Node\n          then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor is bad\";\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong set\";\n          end if;\n \n          if HT.Buckets = null\n            or else HT.Buckets'Length = 0\n            or else HT.Length = 0\n          then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor is bad (set is empty)\";\n          end if;\n \n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in Update_Element_Preserving_Key\");\n+\n          Indx := HT_Ops.Index (HT, Position.Node);\n \n          declare\n@@ -2052,7 +2086,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                   Prev := Prev.Next;\n \n                   if Prev = null then\n-                     raise Program_Error;\n+                     raise Program_Error with\n+                       \"Position cursor is bad (node not found)\";\n                   end if;\n                end loop;\n \n@@ -2069,7 +2104,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             Free (X);\n          end;\n \n-         raise Program_Error;\n+         raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n    end Generic_Keys;"}, {"sha": "71636340414dfb4e79cd16e5af204a33654265a0", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -180,7 +180,7 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      procedure Replace           -- TODO: ask Randy why this is still here\n+      procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type);"}, {"sha": "980e868f0ef565303cbe2c8f06a9ed442a48210c", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 119, "deletions": 81, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -162,16 +162,20 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null\n-        or else Right.Node.Element = null\n-      then\n-         raise Program_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error with \"Left cursor is bad\";\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -186,11 +190,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       if Left.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -202,11 +206,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       if Right.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -230,16 +234,20 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null\n-        or else Right.Node.Element = null\n-      then\n-         raise Program_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error with \"Left cursor is bad\";\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -256,11 +264,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       if Left.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -272,11 +280,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       if Right.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -375,7 +383,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    begin\n       if Node = Done then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n       loop\n@@ -391,11 +399,15 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -464,11 +476,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -580,13 +592,10 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function First_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.First = null then\n-         raise Constraint_Error;\n-      end if;\n-\n-      if Container.Tree.First.Element = null then\n-         raise Program_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n+      pragma Assert (Container.Tree.First.Element /= null);\n       return Container.Tree.First.Element.all;\n    end First_Element;\n \n@@ -703,7 +712,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       begin\n          if Node = Done then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n          loop\n@@ -726,7 +735,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          return Node.Element.all;\n@@ -870,11 +879,13 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       function Key (Position : Cursor) return Key_Type is\n       begin\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Node.Element = null then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor is bad\";\n          end if;\n \n          pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -930,35 +941,36 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          B := B - 1;\n       end Reverse_Iterate;\n \n-      -----------------------------------\n-      -- Update_Element_Preserving_Key --\n-      -----------------------------------\n+      --------------------\n+      -- Update_Element --\n+      --------------------\n \n-      procedure Update_Element_Preserving_Key\n+      procedure Update_Element\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access procedure (Element : in out Element_Type))\n       is\n          Tree : Tree_Type renames Container.Tree;\n+         Node : constant Node_Access := Position.Node;\n \n       begin\n-         if Position.Node = null then\n-            raise Constraint_Error;\n+         if Node = null then\n+            raise Constraint_Error with \"Position cursor equals No_Element\";\n          end if;\n \n-         if Position.Node.Element = null then\n-            raise Program_Error;\n+         if Node.Element = null then\n+            raise Program_Error with \"Position cursor is bad\";\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor designates wrong set\";\n          end if;\n \n-         pragma Assert (Vet (Container.Tree, Position.Node),\n-                        \"bad cursor in Update_Element_Preserving_Key\");\n+         pragma Assert (Vet (Tree, Node),\n+                        \"bad cursor in Update_Element\");\n \n          declare\n-            E : Element_Type renames Position.Node.Element.all;\n+            E : Element_Type renames Node.Element.all;\n             K : constant Key_Type := Key (E);\n \n             B : Natural renames Tree.Busy;\n@@ -985,15 +997,47 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n             end if;\n          end;\n \n-         declare\n-            X : Node_Access := Position.Node;\n+         --  Delete_Node checks busy-bit\n+\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n+\n+         Insert_New_Item : declare\n+            function New_Node return Node_Access;\n+            pragma Inline (New_Node);\n+\n+            procedure Insert_Post is\n+               new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+            procedure Unconditional_Insert is\n+               new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+            --------------\n+            -- New_Node --\n+            --------------\n+\n+            function New_Node return Node_Access is\n+            begin\n+               Node.Color := Red_Black_Trees.Red;\n+               Node.Parent := null;\n+               Node.Left := null;\n+               Node.Right := null;\n+\n+               return Node;\n+            end New_Node;\n+\n+            Result : Node_Access;\n+\n+         --  Start of processing for Insert_New_Item\n+\n          begin\n-            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n-            Free (X);\n-         end;\n+            Unconditional_Insert\n+              (Tree => Tree,\n+               Key  => Node.Element.all,\n+               Node => Result);\n \n-         raise Program_Error;\n-      end Update_Element_Preserving_Key;\n+            pragma Assert (Result = Node);\n+         end Insert_New_Item;\n+      end Update_Element;\n \n    end Generic_Keys;\n \n@@ -1022,11 +1066,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Position  : out Cursor)\n    is\n    begin\n-      Insert_Sans_Hint\n-        (Container.Tree,\n-         New_Item,\n-         Position.Node);\n-\n+      Insert_Sans_Hint (Container.Tree, New_Item, Position.Node);\n       Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n@@ -1045,36 +1085,32 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       procedure Insert_Post is\n         new Element_Keys.Generic_Insert_Post (New_Node);\n \n-      procedure Unconditional_Insert_Sans_Hint is\n+      procedure Unconditional_Insert is\n         new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n \n       --------------\n       -- New_Node --\n       --------------\n \n       function New_Node return Node_Access is\n-         X : Element_Access := new Element_Type'(New_Item);\n+         Element : Element_Access := new Element_Type'(New_Item);\n \n       begin\n          return new Node_Type'(Parent  => null,\n                                Left    => null,\n                                Right   => null,\n                                Color   => Red_Black_Trees.Red,\n-                               Element => X);\n-\n+                               Element => Element);\n       exception\n          when others =>\n-            Free_Element (X);\n+            Free_Element (Element);\n             raise;\n       end New_Node;\n \n    --  Start of processing for Insert_Sans_Hint\n \n    begin\n-      Unconditional_Insert_Sans_Hint\n-        (Tree,\n-         New_Item,\n-         Node);\n+      Unconditional_Insert (Tree, New_Item, Node);\n    end Insert_Sans_Hint;\n \n    ----------------------\n@@ -1310,9 +1346,10 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function Last_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n+      pragma Assert (Container.Tree.Last.Element /= null);\n       return Container.Tree.Last.Element.all;\n    end Last_Element;\n \n@@ -1436,11 +1473,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -1513,7 +1550,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n    ---------------------\n@@ -1532,7 +1569,8 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          null;\n       else\n          if Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          declare\n@@ -1596,15 +1634,15 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -1823,7 +1861,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n end Ada.Containers.Indefinite_Ordered_Multisets;"}, {"sha": "358c891649d63b209cfd81a22683633330a4729d", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -216,7 +216,7 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n-      procedure Update_Element_Preserving_Key\n+      procedure Update_Element\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access"}, {"sha": "0e11e6506edc766c21986a2400e427c54292f70a", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 81, "deletions": 54, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -150,16 +150,20 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null\n-        or else Right.Node.Element = null\n-      then\n-         raise Program_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error with \"Left cursor is bad\";\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -174,11 +178,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       if Left.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -190,11 +194,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       if Right.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -236,16 +240,20 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n-      if Left.Node.Element = null\n-        or else Right.Node.Element = null\n-      then\n-         raise Program_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error with \"Left cursor is bad\";\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -262,11 +270,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       if Left.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Left cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -278,11 +286,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       if Right.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Right cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -372,14 +380,18 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    -- Delete --\n    ------------\n \n-   procedure Delete (Container : in out Set; Position  : in out Cursor) is\n+   procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -396,7 +408,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    begin\n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n       Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -456,11 +468,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -568,7 +580,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function First_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n       return Container.Tree.First.Element.all;\n@@ -684,7 +696,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       begin\n          if X = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -701,7 +713,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          return Node.Element.all;\n@@ -797,11 +809,13 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       function Key (Position : Cursor) return Key_Type is\n       begin\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Node.Element = null then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor is bad\";\n          end if;\n \n          pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -823,7 +837,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n          end if;\n \n          Replace_Element (Container.Tree, Node, New_Item);\n@@ -843,15 +858,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       begin\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Node.Element = null then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor is bad\";\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor designates wrong set\";\n          end if;\n \n          pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -892,7 +907,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             Free (X);\n          end;\n \n-         raise Program_Error;\n+         raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n    end Generic_Keys;\n@@ -921,7 +936,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       if not Inserted then\n          if Container.Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          X := Position.Node.Element;\n@@ -957,7 +973,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n       end if;\n    end Insert;\n \n@@ -1196,7 +1213,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function Last_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n       return Container.Tree.Last.Element.all;\n@@ -1247,6 +1264,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Position cursor is bad\";\n+      end if;\n+\n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n                      \"bad cursor in Next\");\n \n@@ -1296,6 +1317,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Position cursor is bad\";\n+      end if;\n+\n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n                      \"bad cursor in Previous\");\n \n@@ -1322,11 +1347,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -1401,7 +1426,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n    -------------\n@@ -1416,11 +1441,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to replace element not in set\";\n       end if;\n \n       if Container.Tree.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is locked)\";\n       end if;\n \n       X := Node.Element;\n@@ -1444,7 +1470,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          null;\n       else\n          if Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          declare\n@@ -1550,7 +1577,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             null;\n       end Reinsert_Old_Element;\n \n-      raise Program_Error;\n+      raise Program_Error with \"attempt to replace existing element\";\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -1560,15 +1587,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -1749,7 +1776,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n end Ada.Containers.Indefinite_Ordered_Sets;"}, {"sha": "59ae2a5cd5842f145f5813a4f4ae7464e4afa9a6", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 67, "deletions": 45, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -180,28 +180,31 @@ package body Ada.Containers.Hashed_Maps is\n       Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to delete key not in map\";\n       end if;\n \n       Free (X);\n    end Delete;\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Delete equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Delete designates wrong map\";\n       end if;\n \n       if Container.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Delete attempted to tamper with elements (map is busy)\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n       Free (Position.Node);\n@@ -217,20 +220,22 @@ package body Ada.Containers.Hashed_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n       end if;\n \n       return Node.Element;\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Element equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n       return Position.Node.Element;\n    end Element;\n \n@@ -252,37 +257,43 @@ package body Ada.Containers.Hashed_Maps is\n    function Equivalent_Keys (Left, Right : Cursor)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+      if Left.Node = null then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys equals No_Element\";\n+      end if;\n \n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Left), \"Left cursor of Equivalent_Keys is bad\");\n+      pragma Assert (Vet (Right), \"Right cursor of Equivalent_Keys is bad\");\n+\n       return Equivalent_Keys (Left.Node.Key, Right.Node.Key);\n    end Equivalent_Keys;\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Left), \"Left cursor in Equivalent_Keys is bad\");\n+\n       return Equivalent_Keys (Left.Node.Key, Right);\n    end Equivalent_Keys;\n \n    function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n-\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Right), \"Right cursor of Equivalent_Keys is bad\");\n+\n       return Equivalent_Keys (Left, Right.Node.Key);\n    end Equivalent_Keys;\n \n@@ -409,7 +420,8 @@ package body Ada.Containers.Hashed_Maps is\n \n       if not Inserted then\n          if Container.HT.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Include attempted to tamper with cursors (map is locked)\";\n          end if;\n \n          Position.Node.Key := Key;\n@@ -518,7 +530,8 @@ package body Ada.Containers.Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to insert key already in map\";\n       end if;\n    end Insert;\n \n@@ -565,12 +578,13 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Key\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Key equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n       return Position.Node.Key;\n    end Key;\n \n@@ -606,12 +620,12 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n@@ -640,12 +654,13 @@ package body Ada.Containers.Hashed_Maps is\n                    procedure (Key : Key_Type; Element : Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n       declare\n          M  : Map renames Position.Container.all;\n          HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n@@ -692,7 +707,7 @@ package body Ada.Containers.Hashed_Maps is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Read;\n \n    ---------------\n@@ -728,11 +743,13 @@ package body Ada.Containers.Hashed_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to replace key not in map\";\n       end if;\n \n       if Container.HT.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Replace attempted to tamper with cursors (map is locked)\";\n       end if;\n \n       Node.Key := Key;\n@@ -749,20 +766,23 @@ package body Ada.Containers.Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n       if Position.Container.HT.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Replace_Element attempted to tamper with cursors (map is locked)\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n       Position.Node.Element := New_Item;\n    end Replace_Element;\n \n@@ -798,16 +818,18 @@ package body Ada.Containers.Hashed_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Update_Element designates wrong map\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n       declare\n          HT : Hash_Table_Type renames Container.HT;\n          B  : Natural renames HT.Busy;\n@@ -906,7 +928,7 @@ package body Ada.Containers.Hashed_Maps is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Write;\n \n    ----------------"}, {"sha": "a54683e36ff392d28e3ee30729e320fa4c2d9b26", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 91, "deletions": 60, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -207,7 +207,7 @@ package body Ada.Containers.Hashed_Sets is\n       Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n \n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n       Free (X);\n@@ -218,20 +218,21 @@ package body Ada.Containers.Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       if Container.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n       Free (Position.Node);\n@@ -254,12 +255,13 @@ package body Ada.Containers.Hashed_Sets is\n          return;\n       end if;\n \n-      if Source.Length = 0 then\n+      if Source.HT.Length = 0 then\n          return;\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       --  TODO: This can be written in terms of a loop instead as\n@@ -291,11 +293,11 @@ package body Ada.Containers.Hashed_Sets is\n          return Empty_Set;\n       end if;\n \n-      if Left.Length = 0 then\n+      if Left.HT.Length = 0 then\n          return Empty_Set;\n       end if;\n \n-      if Right.Length = 0 then\n+      if Right.HT.Length = 0 then\n          return Left;\n       end if;\n \n@@ -353,12 +355,12 @@ package body Ada.Containers.Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n       return Position.Node.Element;\n    end Element;\n \n@@ -378,39 +380,47 @@ package body Ada.Containers.Hashed_Sets is\n    function Equivalent_Elements (Left, Right : Cursor)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+      if Left.Node = null then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements equals No_Element\";\n+      end if;\n \n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Elements\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Elements\");\n+\n       return Equivalent_Elements (Left.Node.Element, Right.Node.Element);\n    end Equivalent_Elements;\n \n    function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n-\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Left), \"Left cursor in Equivalent_Elements is bad\");\n+\n       return Equivalent_Elements (Left.Node.Element, Right);\n    end Equivalent_Elements;\n \n    function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n-\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements equals No_Element\";\n       end if;\n \n+      pragma Assert\n+        (Vet (Right),\n+         \"Right cursor of Equivalent_Elements is bad\");\n+\n       return Equivalent_Elements (Left, Right.Node.Element);\n    end Equivalent_Elements;\n \n@@ -584,7 +594,8 @@ package body Ada.Containers.Hashed_Sets is\n \n       if not Inserted then\n          if Container.HT.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          Position.Node.Element := New_Item;\n@@ -617,7 +628,8 @@ package body Ada.Containers.Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n       end if;\n    end Insert;\n \n@@ -679,7 +691,8 @@ package body Ada.Containers.Hashed_Sets is\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       --  TODO: optimize this to use an explicit\n@@ -880,12 +893,12 @@ package body Ada.Containers.Hashed_Sets is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Next\");\n+\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n@@ -940,12 +953,13 @@ package body Ada.Containers.Hashed_Sets is\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n       declare\n          HT : Hash_Table_Type renames Position.Container.HT;\n \n@@ -987,7 +1001,7 @@ package body Ada.Containers.Hashed_Sets is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n    ---------------\n@@ -1021,11 +1035,13 @@ package body Ada.Containers.Hashed_Sets is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to replace element not in set\";\n       end if;\n \n       if Container.HT.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is locked)\";\n       end if;\n \n       Node.Element := New_Item;\n@@ -1045,15 +1061,17 @@ package body Ada.Containers.Hashed_Sets is\n          pragma Assert (Hash (Node.Element) = Hash (New_Item));\n \n          if HT.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          Node.Element := New_Item;  --  Note that this assignment can fail\n          return;\n       end if;\n \n       if HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       HT_Ops.Delete_Node_Sans_Free (HT, Node);\n@@ -1129,7 +1147,7 @@ package body Ada.Containers.Hashed_Sets is\n             null;\n       end Reinsert_Old_Element;\n \n-      raise Program_Error;\n+      raise Program_Error with \"attempt to replace existing element\";\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -1138,16 +1156,18 @@ package body Ada.Containers.Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n-\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong set\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n       Replace_Element (Container.HT, Position.Node, New_Item);\n    end Replace_Element;\n \n@@ -1187,7 +1207,8 @@ package body Ada.Containers.Hashed_Sets is\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       declare\n@@ -1452,7 +1473,8 @@ package body Ada.Containers.Hashed_Sets is\n       end if;\n \n       if Target.HT.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       declare\n@@ -1634,7 +1656,7 @@ package body Ada.Containers.Hashed_Sets is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n    ----------------\n@@ -1699,7 +1721,7 @@ package body Ada.Containers.Hashed_Sets is\n          Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n          if X = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n          Free (X);\n@@ -1716,6 +1738,10 @@ package body Ada.Containers.Hashed_Sets is\n          Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n \n       begin\n+         if Node = null then\n+            raise Constraint_Error with \"key not in map\";\n+         end if;\n+\n          return Node.Element;\n       end Element;\n \n@@ -1770,12 +1796,13 @@ package body Ada.Containers.Hashed_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n-         pragma Assert (Vet (Position), \"bad cursor in function Key\");\n-\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n+         pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n          return Key (Position.Node.Element);\n       end Key;\n \n@@ -1793,7 +1820,8 @@ package body Ada.Containers.Hashed_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n          end if;\n \n          Replace_Element (Container.HT, Node, New_Item);\n@@ -1813,26 +1841,28 @@ package body Ada.Containers.Hashed_Sets is\n          Indx : Hash_Type;\n \n       begin\n-         pragma Assert\n-           (Vet (Position),\n-            \"bad cursor in Update_Element_Preserving_Key\");\n-\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong set\";\n          end if;\n \n          if HT.Buckets = null\n            or else HT.Buckets'Length = 0\n            or else HT.Length = 0\n            or else Position.Node.Next = Position.Node\n          then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor is bad (set is empty)\";\n          end if;\n \n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in Update_Element_Preserving_Key\");\n+\n          Indx := HT_Ops.Index (HT, Position.Node);\n \n          declare\n@@ -1876,7 +1906,8 @@ package body Ada.Containers.Hashed_Sets is\n                   Prev := Prev.Next;\n \n                   if Prev = null then\n-                     raise Program_Error;\n+                     raise Program_Error with\n+                       \"Position cursor is bad (node not found)\";\n                   end if;\n                end loop;\n \n@@ -1893,7 +1924,7 @@ package body Ada.Containers.Hashed_Sets is\n             Free (X);\n          end;\n \n-         raise Program_Error;\n+         raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n    end Generic_Keys;"}, {"sha": "dccb56cb0ccecd108251f316fc2f3432787337a2", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -179,7 +179,7 @@ package Ada.Containers.Hashed_Sets is\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      procedure Replace          --  TODO: ask Randy why this wasn't removed\n+      procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type);"}, {"sha": "2ad3613016f999693eac74184c8c708c90f5f5f8", "filename": "gcc/ada/a-coormu.adb", "status": "modified", "additions": 93, "deletions": 56, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -158,10 +158,12 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -177,7 +179,7 @@ package body Ada.Containers.Ordered_Multisets is\n       return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -190,7 +192,7 @@ package body Ada.Containers.Ordered_Multisets is\n       return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -214,10 +216,12 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -235,7 +239,7 @@ package body Ada.Containers.Ordered_Multisets is\n       return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -248,7 +252,7 @@ package body Ada.Containers.Ordered_Multisets is\n       return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -342,7 +346,8 @@ package body Ada.Containers.Ordered_Multisets is\n \n    begin\n       if Node = Done then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to delete element not in set\";\n       end if;\n \n       loop\n@@ -358,11 +363,11 @@ package body Ada.Containers.Ordered_Multisets is\n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -431,7 +436,7 @@ package body Ada.Containers.Ordered_Multisets is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -542,7 +547,7 @@ package body Ada.Containers.Ordered_Multisets is\n    function First_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n       return Container.Tree.First.Element;\n@@ -650,7 +655,7 @@ package body Ada.Containers.Ordered_Multisets is\n \n       begin\n          if Node = Done then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n          loop\n@@ -672,7 +677,7 @@ package body Ada.Containers.Ordered_Multisets is\n                   Key_Keys.Find (Container.Tree, Key);\n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          return Node.Element;\n@@ -816,7 +821,8 @@ package body Ada.Containers.Ordered_Multisets is\n       function Key (Position : Cursor) return Key_Type is\n       begin\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -868,31 +874,34 @@ package body Ada.Containers.Ordered_Multisets is\n          B := B - 1;\n       end Reverse_Iterate;\n \n-      -----------------------------------\n-      -- Update_Element_Preserving_Key --\n-      -----------------------------------\n+      --------------------\n+      -- Update_Element --\n+      --------------------\n \n-      procedure Update_Element_Preserving_Key\n+      procedure Update_Element\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access procedure (Element : in out Element_Type))\n       is\n          Tree : Tree_Type renames Container.Tree;\n+         Node : constant Node_Access := Position.Node;\n \n       begin\n-         if Position.Node = null then\n-            raise Constraint_Error;\n+         if Node = null then\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong set\";\n          end if;\n \n-         pragma Assert (Vet (Container.Tree, Position.Node),\n-                        \"bad cursor in Update_Element_Preserving_Key\");\n+         pragma Assert (Vet (Tree, Node),\n+                        \"bad cursor in Update_Element\");\n \n          declare\n-            E : Element_Type renames Position.Node.Element;\n+            E : Element_Type renames Node.Element;\n             K : constant Key_Type := Key (E);\n \n             B : Natural renames Tree.Busy;\n@@ -919,15 +928,47 @@ package body Ada.Containers.Ordered_Multisets is\n             end if;\n          end;\n \n-         declare\n-            X : Node_Access := Position.Node;\n+         --  Delete_Node checks busy-bit\n+\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n+\n+         Insert_New_Item : declare\n+            function New_Node return Node_Access;\n+            pragma Inline (New_Node);\n+\n+            procedure Insert_Post is\n+               new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+            procedure Unconditional_Insert is\n+               new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+            --------------\n+            -- New_Node --\n+            --------------\n+\n+            function New_Node return Node_Access is\n+            begin\n+               Node.Color := Red_Black_Trees.Red;\n+               Node.Parent := null;\n+               Node.Left := null;\n+               Node.Right := null;\n+\n+               return Node;\n+            end New_Node;\n+\n+            Result : Node_Access;\n+\n+         --  Start of processing for Insert_New_Item\n+\n          begin\n-            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n-            Free (X);\n-         end;\n+            Unconditional_Insert\n+              (Tree => Tree,\n+               Key  => Node.Element,\n+               Node => Result);\n \n-         raise Program_Error;\n-      end Update_Element_Preserving_Key;\n+            pragma Assert (Result = Node);\n+         end Insert_New_Item;\n+      end Update_Element;\n \n    end Generic_Keys;\n \n@@ -944,7 +985,7 @@ package body Ada.Containers.Ordered_Multisets is\n    -- Insert --\n    ------------\n \n-   procedure Insert (Container : in out Set; New_Item  : Element_Type) is\n+   procedure Insert (Container : in out Set; New_Item : Element_Type) is\n       Position : Cursor;\n    begin\n       Insert (Container, New_Item, Position);\n@@ -956,11 +997,7 @@ package body Ada.Containers.Ordered_Multisets is\n       Position  : out Cursor)\n    is\n    begin\n-      Insert_Sans_Hint\n-        (Container.Tree,\n-         New_Item,\n-         Position.Node);\n-\n+      Insert_Sans_Hint (Container.Tree, New_Item, Position.Node);\n       Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n@@ -979,7 +1016,7 @@ package body Ada.Containers.Ordered_Multisets is\n       procedure Insert_Post is\n         new Element_Keys.Generic_Insert_Post (New_Node);\n \n-      procedure Unconditional_Insert_Sans_Hint is\n+      procedure Unconditional_Insert is\n         new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n \n       --------------\n@@ -1000,10 +1037,7 @@ package body Ada.Containers.Ordered_Multisets is\n    --  Start of processing for Insert_Sans_Hint\n \n    begin\n-      Unconditional_Insert_Sans_Hint\n-        (Tree,\n-         New_Item,\n-         Node);\n+      Unconditional_Insert (Tree, New_Item, Node);\n    end Insert_Sans_Hint;\n \n    ----------------------\n@@ -1234,7 +1268,7 @@ package body Ada.Containers.Ordered_Multisets is\n    function Last_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n       return Container.Tree.Last.Element;\n@@ -1360,7 +1394,7 @@ package body Ada.Containers.Ordered_Multisets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -1433,7 +1467,7 @@ package body Ada.Containers.Ordered_Multisets is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n    ---------------------\n@@ -1452,7 +1486,8 @@ package body Ada.Containers.Ordered_Multisets is\n          null;\n       else\n          if Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          Node.Element := Item;\n@@ -1507,11 +1542,13 @@ package body Ada.Containers.Ordered_Multisets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -1730,7 +1767,7 @@ package body Ada.Containers.Ordered_Multisets is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n end Ada.Containers.Ordered_Multisets;"}, {"sha": "7e53d1ca7a7a052ba7b8f30dfdb209e6e4ad63b1", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -223,7 +223,7 @@ package Ada.Containers.Ordered_Multisets is\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n-      procedure Update_Element_Preserving_Key\n+      procedure Update_Element\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access"}, {"sha": "552987329d71ee8c6d747dfe8188a31a984ae546", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -159,10 +159,12 @@ package body Ada.Containers.Ordered_Sets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -177,7 +179,7 @@ package body Ada.Containers.Ordered_Sets is\n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -189,7 +191,7 @@ package body Ada.Containers.Ordered_Sets is\n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -213,10 +215,12 @@ package body Ada.Containers.Ordered_Sets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -233,7 +237,7 @@ package body Ada.Containers.Ordered_Sets is\n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n@@ -245,7 +249,7 @@ package body Ada.Containers.Ordered_Sets is\n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n@@ -337,11 +341,11 @@ package body Ada.Containers.Ordered_Sets is\n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -357,7 +361,7 @@ package body Ada.Containers.Ordered_Sets is\n \n    begin\n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n       Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -417,7 +421,7 @@ package body Ada.Containers.Ordered_Sets is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -523,7 +527,7 @@ package body Ada.Containers.Ordered_Sets is\n    function First_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n       return Container.Tree.First.Element;\n@@ -628,7 +632,7 @@ package body Ada.Containers.Ordered_Sets is\n \n       begin\n          if X = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n          Delete_Node_Sans_Free (Container.Tree, X);\n@@ -645,7 +649,7 @@ package body Ada.Containers.Ordered_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          return Node.Element;\n@@ -741,7 +745,8 @@ package body Ada.Containers.Ordered_Sets is\n       function Key (Position : Cursor) return Key_Type is\n       begin\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -763,7 +768,8 @@ package body Ada.Containers.Ordered_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n          end if;\n \n          Replace_Element (Container.Tree, Node, New_Item);\n@@ -782,11 +788,13 @@ package body Ada.Containers.Ordered_Sets is\n \n       begin\n          if Position.Node = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong set\";\n          end if;\n \n          pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -827,7 +835,7 @@ package body Ada.Containers.Ordered_Sets is\n             Free (X);\n          end;\n \n-         raise Program_Error;\n+         raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n    end Generic_Keys;\n@@ -854,7 +862,8 @@ package body Ada.Containers.Ordered_Sets is\n \n       if not Inserted then\n          if Container.Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          Position.Node.Element := New_Item;\n@@ -892,7 +901,8 @@ package body Ada.Containers.Ordered_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n       end if;\n    end Insert;\n \n@@ -1130,7 +1140,7 @@ package body Ada.Containers.Ordered_Sets is\n    function Last_Element (Container : Set) return Element_Type is\n    begin\n       if Container.Tree.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"set is empty\";\n       end if;\n \n       return Container.Tree.Last.Element;\n@@ -1256,7 +1266,7 @@ package body Ada.Containers.Ordered_Sets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n@@ -1331,7 +1341,7 @@ package body Ada.Containers.Ordered_Sets is\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n    -------------\n@@ -1344,11 +1354,13 @@ package body Ada.Containers.Ordered_Sets is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"attempt to replace element not in set\";\n       end if;\n \n       if Container.Tree.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is locked)\";\n       end if;\n \n       Node.Element := New_Item;\n@@ -1370,7 +1382,8 @@ package body Ada.Containers.Ordered_Sets is\n          null;\n       else\n          if Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          Node.Element := Item;\n@@ -1465,7 +1478,7 @@ package body Ada.Containers.Ordered_Sets is\n             null;  -- Assignment must have failed\n       end Reinsert_Old_Element;\n \n-      raise Program_Error;\n+      raise Program_Error with \"attempt to replace existing element\";\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -1475,11 +1488,13 @@ package body Ada.Containers.Ordered_Sets is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong set\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n@@ -1660,7 +1675,7 @@ package body Ada.Containers.Ordered_Sets is\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n end Ada.Containers.Ordered_Sets;"}, {"sha": "7fe8e3b5f672abb9150053d152b89f862994c571", "filename": "gcc/ada/a-crbtgk.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -254,13 +254,14 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Key  : Key_Type;\n       Z    : out Node_Access)\n    is\n-      subtype Length_Subtype is Count_Type range 0 .. Count_Type'Last - 1;\n-\n-      New_Length : constant Count_Type := Length_Subtype'(Tree.Length) + 1;\n-\n    begin\n+      if Tree.Length = Count_Type'Last then\n+         raise Constraint_Error with \"too many elements\";\n+      end if;\n+\n       if Tree.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n       if Y = null\n@@ -316,7 +317,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n \n       Ops.Set_Parent (Z, Y);\n       Ops.Rebalance_For_Insert (Tree, Z);\n-      Tree.Length := New_Length;\n+      Tree.Length := Tree.Length + 1;\n    end Generic_Insert_Post;\n \n    -----------------------"}, {"sha": "b0b7ca09bc6568a350539587677a9952a0f16637", "filename": "gcc/ada/a-crbtgo.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -246,7 +246,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    begin\n       if Tree.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n --    pragma Assert (Tree.Length > 0);\n@@ -523,7 +524,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n       Root : Node_Access := Tree.Root;\n    begin\n       if Tree.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n       Tree := (First  => null,\n@@ -672,7 +674,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n       end if;\n \n       if Source.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n       Clear (Target);\n@@ -771,7 +774,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    procedure Generic_Write\n      (Stream : access Root_Stream_Type'Class;\n-      Tree   : in     Tree_Type)\n+      Tree   : Tree_Type)\n    is\n       procedure Process (Node : Node_Access);\n       pragma Inline (Process);"}, {"sha": "586451b974ec9aed0a46a08ae658961ef0624c1d", "filename": "gcc/ada/a-envvar.adb", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-envvar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-envvar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-envvar.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,228 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . E N V I R O N M E N T _ V A R I A B L E S           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with Interfaces.C.Strings;\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Environment_Variables is\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Name : String) is\n+      procedure Clear_Env_Var (Name : System.Address);\n+      pragma Import (C, Clear_Env_Var, \"__gnat_unsetenv\");\n+\n+      F_Name  : String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      Clear_Env_Var (F_Name'Address);\n+   end Clear;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear is\n+      procedure Clear_Env;\n+      pragma Import (C, Clear_Env, \"__gnat_clearenv\");\n+   begin\n+      Clear_Env;\n+   end Clear;\n+\n+   ------------\n+   -- Exists --\n+   ------------\n+\n+   function Exists (Name : String) return Boolean is\n+      use System;\n+\n+      procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n+      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_getenv\");\n+\n+      Env_Value_Ptr    : aliased Address;\n+      Env_Value_Length : aliased Integer;\n+      F_Name           : aliased String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      Get_Env_Value_Ptr\n+        (F_Name'Address, Env_Value_Length'Address, Env_Value_Ptr'Address);\n+\n+      if Env_Value_Ptr = System.Null_Address then\n+         return False;\n+      end if;\n+\n+      return True;\n+   end Exists;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Process : not null access procedure (Name, Value : String))\n+   is\n+      use Interfaces.C.Strings;\n+      type C_String_Array is array (Natural) of aliased chars_ptr;\n+      type C_String_Array_Access is access C_String_Array;\n+\n+      function Get_Env return C_String_Array_Access;\n+      pragma Import (C, Get_Env, \"__gnat_environ\");\n+\n+      type String_Access is access all String;\n+      procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);\n+\n+      Env_Length : Natural := 0;\n+      Env        : constant C_String_Array_Access := Get_Env;\n+\n+   begin\n+      --  If the environment is null return directly\n+\n+      if Env = null then\n+         return;\n+      end if;\n+\n+      --  First get the number of environment variables\n+\n+      loop\n+         exit when Env (Env_Length) = Null_Ptr;\n+         Env_Length := Env_Length + 1;\n+      end loop;\n+\n+      declare\n+         Env_Copy : array (1 .. Env_Length) of String_Access;\n+\n+      begin\n+         --  Copy the environment\n+\n+         for Iterator in 1 ..  Env_Length loop\n+            Env_Copy (Iterator) := new String'(Value (Env (Iterator - 1)));\n+         end loop;\n+\n+         --  Iterate on the environment copy\n+\n+         for Iterator in 1 .. Env_Length loop\n+            declare\n+               Current_Var : constant String := Env_Copy (Iterator).all;\n+               Value_Index : Natural := Env_Copy (Iterator)'First;\n+\n+            begin\n+               loop\n+                  exit when Current_Var (Value_Index) = '=';\n+                  Value_Index := Value_Index + 1;\n+               end loop;\n+\n+               Process\n+                 (Current_Var (Current_Var'First .. Value_Index - 1),\n+                  Current_Var (Value_Index + 1 .. Current_Var'Last));\n+            end;\n+         end loop;\n+\n+         --  Free the copy of the environment\n+\n+         for Iterator in 1 .. Env_Length loop\n+            Free (Env_Copy (Iterator));\n+         end loop;\n+      end;\n+   end Iterate;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set (Name : String; Value : String) is\n+      F_Name  : String (1 .. Name'Length + 1);\n+      F_Value : String (1 .. Value'Length + 1);\n+\n+      procedure Set_Env_Value (Name, Value : System.Address);\n+      pragma Import (C, Set_Env_Value, \"__gnat_setenv\");\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      F_Value (1 .. Value'Length) := Value;\n+      F_Value (F_Value'Last)      := ASCII.NUL;\n+\n+      Set_Env_Value (F_Name'Address, F_Value'Address);\n+   end Set;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Name : String) return String is\n+      use System;\n+\n+      procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n+      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_getenv\");\n+\n+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n+      pragma Import (C, Strncpy, \"strncpy\");\n+\n+      Env_Value_Ptr    : aliased Address;\n+      Env_Value_Length : aliased Integer;\n+      F_Name           : aliased String (1 .. Name'Length + 1);\n+\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+\n+      Get_Env_Value_Ptr\n+        (F_Name'Address, Env_Value_Length'Address, Env_Value_Ptr'Address);\n+\n+      if Env_Value_Ptr = System.Null_Address then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Env_Value_Length > 0 then\n+         declare\n+            Result : aliased String (1 .. Env_Value_Length);\n+         begin\n+            Strncpy (Result'Address, Env_Value_Ptr, Env_Value_Length);\n+            return Result;\n+         end;\n+      else\n+         return \"\";\n+      end if;\n+   end Value;\n+\n+end Ada.Environment_Variables;"}, {"sha": "2b0229c50697c1aae8ed93100c1197d292078d7c", "filename": "gcc/ada/a-envvar.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-envvar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-envvar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-envvar.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . E N V I R O N M E N T _ V A R I A B L E S           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2005-2006, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+---                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Environment_Variables is\n+   pragma Preelaborate (Environment_Variables);\n+\n+   function Value (Name : String) return String;\n+   --  If the external execution environment supports environment variables,\n+   --  then Value returns the value of the environment variable with the given\n+   --  name. If no environment variable with the given name exists, then\n+   --  Constraint_Error is propagated. If the execution environment does not\n+   --  support environment variables, then Program_Error is propagated.\n+\n+   function Exists (Name : String) return Boolean;\n+   --  If the external execution environment supports environment variables and\n+   --  an environment variable with the given name currently exists, then\n+   --  Exists returns True; otherwise it returns False.\n+\n+   procedure Set (Name : String; Value : String);\n+   --  If the external execution environment supports environment variables,\n+   --  then Set first clears any existing environment variable with the given\n+   --  name, and then defines a single new environment variable with the given\n+   --  name and value. Otherwise Program_Error is propagated.\n+   --  If implementation-defined circumstances prohibit the definition of an\n+   --  environment variable with the given name and value, then\n+   --  Constraint_Error is propagated.\n+   --  It is implementation defined whether there exist values for which the\n+   --  call Set(Name, Value) has the same effect as Clear (Name).\n+\n+   procedure Clear (Name : String);\n+   --  If the external execution environment supports environment variables,\n+   --  then Clear deletes all existing environment variables with the given\n+   --  name. Otherwise Program_Error is propagated.\n+\n+   procedure Clear;\n+   --  If the external execution environment supports environment variables,\n+   --  then Clear deletes all existing environment variables. Otherwise\n+   --  Program_Error is propagated.\n+\n+   procedure Iterate\n+     (Process : not null access procedure (Name, Value : String));\n+   --  If the external execution environment supports environment variables,\n+   --  then Iterate calls the subprogram designated by Process for each\n+   --  existing environment variable, passing the name and value of that\n+   --  environment variable. Otherwise Program_Error is propagated.\n+\n+end Ada.Environment_Variables;"}, {"sha": "fcb9adf2fc662a27d3bcd0db468acf30b3de9949", "filename": "gcc/ada/a-rbtgso.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-rbtgso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-rbtgso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgso.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -96,7 +96,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n    begin\n       if Target'Address = Source'Address then\n          if Target.Busy > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (container is busy)\";\n          end if;\n \n          Clear (Target);\n@@ -108,7 +109,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n       end if;\n \n       if Target.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n       loop\n@@ -222,7 +224,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n       end if;\n \n       if Target.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n       if Source.Length = 0 then\n@@ -400,7 +403,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n \n    begin\n       if Target.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n       if Target'Address = Source'Address then\n@@ -566,7 +570,8 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n       end if;\n \n       if Target.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n       Iterate (Source);"}, {"sha": "ba5ce06b0d2dba592e42529eff5b1975cd5dd0af", "filename": "gcc/ada/a-stboha.adb", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-stboha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-stboha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stboha.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--             A D A . S T R I N G S . B O U N D E D . H A S H              --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--           Copyright (C) 2004-2006 Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Note: source of this algorithm: GNAT.HTable.Hash (g-htable.adb)\n+\n+function Ada.Strings.Bounded.Hash (Key : Bounded.Bounded_String)\n+  return Containers.Hash_Type\n+is\n+   use Ada.Containers;\n+\n+   function Rotate_Left\n+     (Value  : Hash_Type;\n+      Amount : Natural) return Hash_Type;\n+   pragma Import (Intrinsic, Rotate_Left);\n+\n+   Tmp : Hash_Type;\n+\n+begin\n+   Tmp := 0;\n+   for J in 1 .. Bounded.Length (Key) loop\n+      Tmp := Rotate_Left (Tmp, 3) + Character'Pos (Bounded.Element (Key, J));\n+   end loop;\n+\n+   return Tmp;\n+end Ada.Strings.Bounded.Hash;"}, {"sha": "999850e9ef1a7c8e27ba9eff8ec1b4a4d6f9ed78", "filename": "gcc/ada/a-stboha.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-stboha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-stboha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stboha.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,25 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--             A D A . S T R I N G S . B O U N D E D . H A S H              --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers;\n+\n+generic\n+   with package Bounded is\n+     new Ada.Strings.Bounded.Generic_Bounded_Length (<>);\n+\n+function Ada.Strings.Bounded.Hash (Key : Bounded.Bounded_String)\n+    return Containers.Hash_Type;\n+\n+pragma Preelaborate (Ada.Strings.Bounded.Hash);"}, {"sha": "23380034625d2f27bee56f9fbd4909bc2011ec0b", "filename": "gcc/ada/a-stfiha.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-stfiha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-stfiha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stfiha.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--             A D A . S T R I N G S . F I X E D . H A S H                  --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers, Ada.Strings.Hash;\n+\n+function Ada.Strings.Fixed.Hash (Key : String) return Containers.Hash_Type\n+   renames Ada.Strings.Hash;\n+\n+pragma Pure (Ada.Strings.Fixed.Hash);"}, {"sha": "42b844ba8f2efeff550d6c5d6b55c2f77cb01905", "filename": "gcc/ada/a-swbwha.adb", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-swbwha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-swbwha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swbwha.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,59 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . S T R I N G S . W I D E _ B O U N D E D . W I D E _ H A S H    --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--           Copyright (C) 2004-2006 Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Note: source of this algorithm: GNAT.HTable.Hash (g-htable.adb)\n+\n+function Ada.Strings.Wide_Bounded.Wide_Hash\n+  (Key : Bounded.Bounded_Wide_String)\n+  return Containers.Hash_Type\n+is\n+   use Ada.Containers;\n+\n+   function Rotate_Left\n+     (Value  : Hash_Type;\n+      Amount : Natural) return Hash_Type;\n+   pragma Import (Intrinsic, Rotate_Left);\n+\n+   Tmp : Hash_Type;\n+\n+begin\n+   Tmp := 0;\n+   for J in 1 .. Bounded.Length (Key) loop\n+      Tmp := Rotate_Left (Tmp, 3) +\n+               Wide_Character'Pos (Bounded.Element (Key, J));\n+   end loop;\n+\n+   return Tmp;\n+end Ada.Strings.Wide_Bounded.Wide_Hash;"}, {"sha": "59479527c30596540f484142d0e1afcb14739e72", "filename": "gcc/ada/a-swbwha.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-swbwha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-swbwha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swbwha.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,25 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . S T R I N G S . W I D E _ B O U N D E D . W I D E _ H A S H    --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers;\n+\n+generic\n+   with package Bounded is\n+     new Ada.Strings.Wide_Bounded.Generic_Bounded_Length (<>);\n+\n+function Ada.Strings.Wide_Bounded.Wide_Hash (Key : Bounded.Bounded_Wide_String)\n+    return Containers.Hash_Type;\n+\n+pragma Preelaborate (Ada.Strings.Wide_Bounded.Wide_Hash);"}, {"sha": "ebabe865b70960f3f32cbfaf015933877a67b940", "filename": "gcc/ada/a-swfwha.ads", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-swfwha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-swfwha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swfwha.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,22 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--    A D A . S T R I N G S . W I D E _ F I X E D . W I D E _ H A S H       --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers, Ada.Strings.Wide_Hash;\n+\n+function Ada.Strings.Wide_Fixed.Wide_Hash\n+  (Key : Wide_String) return Containers.Hash_Type\n+  renames Ada.Strings.Wide_Hash;\n+\n+pragma Pure (Ada.Strings.Wide_Fixed.Wide_Hash);"}, {"sha": "458f47757d482d41036c036c847b8d6a3c902f52", "filename": "gcc/ada/a-szbzha.adb", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-szbzha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-szbzha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szbzha.adb?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--        A D A . S T R I N G S . W I D E _ W I D E _ B O U N D E D .       --\n+--                      W I D E _ W I D E _ H A S H                         --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--           Copyright (C) 2004-2006 Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Note: source of this algorithm: GNAT.HTable.Hash (g-htable.adb)\n+\n+function Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash\n+  (Key : Bounded.Bounded_Wide_Wide_String)\n+  return Containers.Hash_Type\n+is\n+   use Ada.Containers;\n+\n+   function Rotate_Left\n+     (Value  : Hash_Type;\n+      Amount : Natural) return Hash_Type;\n+   pragma Import (Intrinsic, Rotate_Left);\n+\n+   Tmp : Hash_Type;\n+\n+begin\n+   Tmp := 0;\n+   for J in 1 .. Bounded.Length (Key) loop\n+      Tmp := Rotate_Left (Tmp, 3) +\n+               Wide_Wide_Character'Pos (Bounded.Element (Key, J));\n+   end loop;\n+\n+   return Tmp;\n+end Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash;"}, {"sha": "b368d7934148c28669ac1b97d299726bd1aa1597", "filename": "gcc/ada/a-szbzha.ads", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-szbzha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-szbzha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szbzha.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,27 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--        A D A . S T R I N G S . W I D E _ W I D E _ B O U N D E D .       --\n+--                      W I D E _ W I D E _ H A S H                         --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers;\n+\n+generic\n+   with package Bounded is\n+     new Ada.Strings.Wide_Wide_Bounded.Generic_Bounded_Length (<>);\n+\n+function Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash\n+  (Key : Bounded.Bounded_Wide_Wide_String)\n+  return Containers.Hash_Type;\n+\n+pragma Preelaborate (Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash);"}, {"sha": "1753fc7462c1a2df5b49d007cbd52e01259fbe78", "filename": "gcc/ada/a-szfzha.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-szfzha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffabcde5e102cd7cc8a283ddc89861a727226913/gcc%2Fada%2Fa-szfzha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szfzha.ads?ref=ffabcde5e102cd7cc8a283ddc89861a727226913", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--        A D A . S T R I N G S . W I D E _ W I D E _ F I X E D .           --\n+--                      W I D E _ W I D E _ H A S H                         --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers, Ada.Strings.Wide_Wide_Hash;\n+\n+function Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Hash\n+  (Key : Wide_Wide_String) return Containers.Hash_Type\n+  renames Ada.Strings.Wide_Wide_Hash;\n+\n+pragma Pure (Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Hash);"}]}