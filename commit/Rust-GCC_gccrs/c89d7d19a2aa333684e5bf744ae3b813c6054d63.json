{"sha": "c89d7d19a2aa333684e5bf744ae3b813c6054d63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg5ZDdkMTlhMmFhMzMzNjg0ZTViZjc0NGFlM2I4MTNjNjA1NGQ2Mw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2019-10-12T19:41:50Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2019-10-12T19:41:50Z"}, "message": "[Darwin, machopic 6/n] Fix for 67183\n\nWhen we're using the LLVM-based assembler (the default on modern Darwin)\nthe ordering of stubs and non-lazy symbol pointers is important.\n\nInterleaving the output (current GCC behaviour) leads to crashes which\nprevents us from building code with symbol stubs.\n\nTo resolve this, we order the output of stubs and symbol indirections:\n\n 1. Any indirections in the data section\n 2. Symbol stubs.\n 3. Non-lazy symbol pointers.\n\nAt present, we still emit LTO sections after these.\n\ngcc/ChangeLog:\n\n2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR target/67183\n\t* config/darwin.c (machopic_indirection): New field to flag\n\tnon-lazy-symbol-pointers in the data section.\n\t(machopic_indirection_name): Compute if an indirection should\n\tappear in the data section.\n\t(machopic_output_data_section_indirection): New callback split\n\tfrom machopic_output_indirection.\n\t(machopic_output_stub_indirection): Likewise.\n\t(machopic_output_indirection): Retain the code for non-lazy\n\tsymbol pointers in their regular section.\n\t(machopic_finish): Use the new callbacks to order the indirection\n\toutput.\n\nFrom-SVN: r276926", "tree": {"sha": "f7e3a9fbf75e71b2768e3dc87a3e9d3934a3e236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7e3a9fbf75e71b2768e3dc87a3e9d3934a3e236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c89d7d19a2aa333684e5bf744ae3b813c6054d63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89d7d19a2aa333684e5bf744ae3b813c6054d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c89d7d19a2aa333684e5bf744ae3b813c6054d63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89d7d19a2aa333684e5bf744ae3b813c6054d63/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aea083d4bfb7538499eae0271dae740e7efa240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aea083d4bfb7538499eae0271dae740e7efa240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aea083d4bfb7538499eae0271dae740e7efa240"}], "stats": {"total": 259, "additions": 166, "deletions": 93}, "files": [{"sha": "161b58084a042c0ee5ce99f5a1827ecc9444fb91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89d7d19a2aa333684e5bf744ae3b813c6054d63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89d7d19a2aa333684e5bf744ae3b813c6054d63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c89d7d19a2aa333684e5bf744ae3b813c6054d63", "patch": "@@ -1,3 +1,28 @@\n+2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR target/67183\n+\t* config/darwin.c (machopic_indirection): New field to flag\n+\tnon-lazy-symbol-pointers in the data section.\n+\t(machopic_indirection_name): Compute if an indirection should\n+\tappear in the data section.\n+\t(machopic_output_data_section_indirection): New callback split\n+\tfrom machopic_output_indirection.\n+\t(machopic_output_stub_indirection): Likewise.\n+\t(machopic_output_indirection): Retain the code for non-lazy\n+\tsymbol pointers in their regular section.\n+\t(machopic_finish): Use the new callbacks to order the indirection\n+\toutput.\n+\n+2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* config/darwin-protos.h (machopic_finish): Delete.\n+\t* config/darwin.c (machopic_finish): Make static.\n+\n+2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* config/darwin.c (darwin_file_end): Only emit empty CTOR/DTOR\n+\tsections when building kernel extension code.\n+\n 2019-10-12  Palmer Dabbelt  <palmer@sifive.com>\n \n \t* doc/extend.texi (Alternate Keywords): Change \"-std=c11\" to \"a"}, {"sha": "f6543fc99764a1061010c32a0f711a2b6f2307a0", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 141, "deletions": 93, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89d7d19a2aa333684e5bf744ae3b813c6054d63/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89d7d19a2aa333684e5bf744ae3b813c6054d63/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=c89d7d19a2aa333684e5bf744ae3b813c6054d63", "patch": "@@ -454,6 +454,13 @@ typedef struct GTY ((for_user)) machopic_indirection\n   bool stub_p;\n   /* True iff this stub or pointer has been referenced.  */\n   bool used;\n+  /* True iff a non-lazy symbol pointer should be emitted into the .data\n+     section, rather than the non-lazy symbol pointers section.  The cases\n+     for which this occurred seem to have been unintentional, and later\n+     toolchains emit all of the indirections to the 'usual' section.  We\n+     are keeping this in case it is necessary to preserve compatibility with\n+     older toolchains.  */\n+  bool nlsp_in_data_section;\n } machopic_indirection;\n \n struct indirection_hasher : ggc_ptr_hash<machopic_indirection>\n@@ -590,6 +597,18 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)\n       p->ptr_name = xstrdup (buffer);\n       p->stub_p = stub_p;\n       p->used = false;\n+      /* Here we are undoing a number of causes that placed some indirections\n+\t (apparently erroneously) into the .data section.  Specifically, some\n+\t symbols that are ABI mandated indirections and some hidden symbols\n+\t were being placed there - which cause difficulties with later\n+\t versions of ld64.\n+      */\n+      p->nlsp_in_data_section =\n+\t   ! MACHO_SYMBOL_MUST_INDIRECT_P (sym_ref)\n+\t&& ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref)\n+\t&& (machopic_symbol_defined_p (sym_ref)\n+\t    || SYMBOL_REF_LOCAL_P (sym_ref))\n+\t&& ! indirect_data (sym_ref);\n       *slot = p;\n     }\n \n@@ -1069,131 +1088,160 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n   return pic_ref;\n }\n \n-/* Output the stub or non-lazy pointer in *SLOT, if it has been used.\n-   DATA is the FILE* for assembly output.  Called from\n-   htab_traverse.  */\n+/* Callbacks to output the stub or non-lazy pointers.\n+   Each works on the item in *SLOT,if it has been used.\n+   DATA is the FILE* for assembly output.\n+   Called from htab_traverses, invoked from machopic_finish().  */\n \n int\n-machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)\n+machopic_output_data_section_indirection (machopic_indirection **slot,\n+\t\t\t\t\t  FILE *asm_out_file)\n {\n   machopic_indirection *p = *slot;\n-  rtx symbol;\n-  const char *sym_name;\n-  const char *ptr_name;\n \n-  if (!p->used)\n+  if (!p->used || !p->nlsp_in_data_section)\n     return 1;\n \n-  symbol = p->symbol;\n-  sym_name = XSTR (symbol, 0);\n-  ptr_name = p->ptr_name;\n+  rtx symbol = p->symbol;\n+  /* The original symbol name.  */\n+  const char *sym_name = XSTR (symbol, 0);\n+  /* The name of the indirection symbol.  */\n+  const char *ptr_name = p->ptr_name;\n \n-  if (p->stub_p)\n-    {\n-      char *sym;\n-      char *stub;\n-      tree id;\n+  switch_to_section (data_section);\n+  assemble_align (GET_MODE_ALIGNMENT (Pmode));\n+  assemble_label (asm_out_file, ptr_name);\n+  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),\n+\t\t    GET_MODE_SIZE (Pmode),\n+\t\t    GET_MODE_ALIGNMENT (Pmode), 1);\n \n-      id = maybe_get_identifier (sym_name);\n-      if (id)\n-\t{\n-\t  tree id_orig = id;\n+  return 1;\n+}\n \n-\t  while (IDENTIFIER_TRANSPARENT_ALIAS (id))\n-\t    id = TREE_CHAIN (id);\n-\t  if (id != id_orig)\n-\t    sym_name = IDENTIFIER_POINTER (id);\n-\t}\n+int\n+machopic_output_stub_indirection (machopic_indirection **slot,\n+\t\t\t\t  FILE *asm_out_file)\n+{\n+  machopic_indirection *p = *slot;\n \n-      sym = XALLOCAVEC (char, strlen (sym_name) + 2);\n-      if (sym_name[0] == '*' || sym_name[0] == '&')\n-\tstrcpy (sym, sym_name + 1);\n-      else if (sym_name[0] == '-' || sym_name[0] == '+')\n-\tstrcpy (sym, sym_name);\n-      else\n-\tsprintf (sym, \"%s%s\", user_label_prefix, sym_name);\n+  if (!p->used || !p->stub_p)\n+    return 1;\n \n-      stub = XALLOCAVEC (char, strlen (ptr_name) + 2);\n-      if (ptr_name[0] == '*' || ptr_name[0] == '&')\n-\tstrcpy (stub, ptr_name + 1);\n-      else\n-\tsprintf (stub, \"%s%s\", user_label_prefix, ptr_name);\n+  rtx symbol = p->symbol;\n+  /* The original symbol name.  */\n+  const char *sym_name = XSTR (symbol, 0);\n+  /* The name of the stub symbol.  */\n+  const char *ptr_name = p->ptr_name;\n \n-      machopic_output_stub (asm_out_file, sym, stub);\n-    }\n-  else if (! indirect_data (symbol)\n-\t   && ! MACHO_SYMBOL_MUST_INDIRECT_P (symbol)\n-\t   && ! MACHO_SYMBOL_HIDDEN_VIS_P (symbol)\n-\t   && (machopic_symbol_defined_p (symbol)\n-\t       || SYMBOL_REF_LOCAL_P (symbol)))\n+  tree id = maybe_get_identifier (sym_name);\n+  if (id)\n     {\n-      switch_to_section (data_section);\n-      assemble_align (GET_MODE_ALIGNMENT (Pmode));\n-      assemble_label (asm_out_file, ptr_name);\n-      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),\n-\t\t\tGET_MODE_SIZE (Pmode),\n-\t\t\tGET_MODE_ALIGNMENT (Pmode), 1);\n+      tree id_orig = id;\n+\n+      while (IDENTIFIER_TRANSPARENT_ALIAS (id))\n+\tid = TREE_CHAIN (id);\n+      if (id != id_orig)\n+\tsym_name = IDENTIFIER_POINTER (id);\n     }\n+\n+  char *sym = XALLOCAVEC (char, strlen (sym_name) + 2);\n+  if (sym_name[0] == '*' || sym_name[0] == '&')\n+    strcpy (sym, sym_name + 1);\n+  else if (sym_name[0] == '-' || sym_name[0] == '+')\n+    strcpy (sym, sym_name);\n   else\n-    {\n-      rtx init = const0_rtx;\n+    sprintf (sym, \"%s%s\", user_label_prefix, sym_name);\n+\n+  char *stub = XALLOCAVEC (char, strlen (ptr_name) + 2);\n+  if (ptr_name[0] == '*' || ptr_name[0] == '&')\n+    strcpy (stub, ptr_name + 1);\n+  else\n+    sprintf (stub, \"%s%s\", user_label_prefix, ptr_name);\n+\n+  machopic_output_stub (asm_out_file, sym, stub);\n+\n+  return 1;\n+}\n+\n+int\n+machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)\n+{\n+  machopic_indirection *p = *slot;\n+\n+  if (!p->used || p->stub_p || p->nlsp_in_data_section)\n+    return 1;\n+\n+  rtx symbol = p->symbol;\n+  /* The original symbol name.  */\n+  const char *sym_name = XSTR (symbol, 0);\n+  /* The nonlazy-stub symbol name.  */\n+  const char *ptr_name = p->ptr_name;\n \n-      switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);\n+  switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);\n \n-      /* Mach-O symbols are passed around in code through indirect\n-\t references and the original symbol_ref hasn't passed through\n-\t the generic handling and reference-catching in\n-\t output_operand, so we need to manually mark weak references\n-\t as such.  */\n-      if (SYMBOL_REF_WEAK (symbol))\n+  /* Mach-O symbols are passed around in code through indirect references and\n+     the original symbol_ref hasn't passed through the generic handling and\n+     reference-catching in output_operand, so we need to manually mark weak\n+     references as such.  */\n+\n+  if (SYMBOL_REF_WEAK (symbol))\n+    {\n+      tree decl = SYMBOL_REF_DECL (symbol);\n+      gcc_checking_assert (DECL_P (decl));\n+\n+      if (decl != NULL_TREE\n+\t  && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)\n+\t  /* Handle only actual external-only definitions, not\n+\t     e.g. extern inline code or variables for which\n+\t     storage has been allocated.  */\n+\t  && !TREE_STATIC (decl))\n \t{\n-\t  tree decl = SYMBOL_REF_DECL (symbol);\n-\t  gcc_assert (DECL_P (decl));\n-\n-\t  if (decl != NULL_TREE\n-\t      && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)\n-\t      /* Handle only actual external-only definitions, not\n-\t\t e.g. extern inline code or variables for which\n-\t\t storage has been allocated.  */\n-\t      && !TREE_STATIC (decl))\n-\t    {\n-\t      fputs (\"\\t.weak_reference \", asm_out_file);\n-\t      assemble_name (asm_out_file, sym_name);\n-\t      fputc ('\\n', asm_out_file);\n-\t    }\n+\t  fputs (\"\\t.weak_reference \", asm_out_file);\n+\t  assemble_name (asm_out_file, sym_name);\n+\t  fputc ('\\n', asm_out_file);\n \t}\n+    }\n \n-      assemble_name (asm_out_file, ptr_name);\n-      fprintf (asm_out_file, \":\\n\");\n+  assemble_name (asm_out_file, ptr_name);\n+  fprintf (asm_out_file, \":\\n\");\n \n-      fprintf (asm_out_file, \"\\t.indirect_symbol \");\n-      assemble_name (asm_out_file, sym_name);\n-      fprintf (asm_out_file, \"\\n\");\n+  fprintf (asm_out_file, \"\\t.indirect_symbol \");\n+  assemble_name (asm_out_file, sym_name);\n+  fprintf (asm_out_file, \"\\n\");\n \n-      /* Variables that are marked with MACHO_SYMBOL_FLAG_STATIC need to\n-\t have their symbol name instead of 0 in the second entry of\n-\t the non-lazy symbol pointer data structure when they are\n-\t defined.  This allows the runtime to rebind newer instances\n-\t of the translation unit with the original instance of the\n-\t symbol.  */\n+  /* Variables that are marked with MACHO_SYMBOL_FLAG_STATIC need to\n+     have their symbol name instead of 0 in the second entry of\n+     the non-lazy symbol pointer data structure when they are\n+     defined.  This allows the runtime to rebind newer instances\n+     of the translation unit with the original instance of the\n+     symbol.  */\n \n-      if (MACHO_SYMBOL_STATIC_P (symbol)\n-\t  && machopic_symbol_defined_p (symbol))\n-\tinit = gen_rtx_SYMBOL_REF (Pmode, sym_name);\n+  rtx init = const0_rtx;\n+  if (MACHO_SYMBOL_STATIC_P (symbol) && machopic_symbol_defined_p (symbol))\n+    init = gen_rtx_SYMBOL_REF (Pmode, sym_name);\n \n-      assemble_integer (init, GET_MODE_SIZE (Pmode),\n-\t\t\tGET_MODE_ALIGNMENT (Pmode), 1);\n-    }\n+  assemble_integer (init, GET_MODE_SIZE (Pmode),\n+\t\t    GET_MODE_ALIGNMENT (Pmode), 1);\n \n   return 1;\n }\n \n static void\n machopic_finish (FILE *asm_out_file)\n {\n-  if (machopic_indirections)\n-    machopic_indirections\n-      ->traverse_noresize<FILE *, machopic_output_indirection> (asm_out_file);\n+  if (!machopic_indirections)\n+    return;\n+\n+  /* First output an symbol indirections that have been placed into .data\n+     (we don't expect these now).  */\n+  machopic_indirections->traverse_noresize\n+    <FILE *, machopic_output_data_section_indirection> (asm_out_file);\n+\n+  machopic_indirections->traverse_noresize\n+    <FILE *, machopic_output_stub_indirection> (asm_out_file);\n+\n+  machopic_indirections->traverse_noresize\n+    <FILE *, machopic_output_indirection> (asm_out_file);\n }\n \n int"}]}