{"sha": "cc3c7c132926180feb7bec2abeaa63867040661a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MzYzdjMTMyOTI2MTgwZmViN2JlYzJhYmVhYTYzODY3MDQwNjYxYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T12:00:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T12:00:52Z"}, "message": "(contains_this_placeholder_p): Delete.\n\n(contains_placeholder_p): Now contains code from above function.\n(contains_placeholder_p, case 'r'): Don't look at offset info.\n\nFrom-SVN: r14604", "tree": {"sha": "f4414ee0ee7cc95194cc10867fb9fda185292b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4414ee0ee7cc95194cc10867fb9fda185292b73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc3c7c132926180feb7bec2abeaa63867040661a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc3c7c132926180feb7bec2abeaa63867040661a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc3c7c132926180feb7bec2abeaa63867040661a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc3c7c132926180feb7bec2abeaa63867040661a/comments", "author": null, "committer": null, "parents": [{"sha": "40365c9252501b4dddd256401ede3a20d95ec79a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40365c9252501b4dddd256401ede3a20d95ec79a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40365c9252501b4dddd256401ede3a20d95ec79a"}], "stats": {"total": 54, "additions": 14, "deletions": 40}, "files": [{"sha": "f756d05faa7d1badf44836a43c8f7072d5ea149a", "filename": "gcc/tree.c", "status": "modified", "additions": 14, "deletions": 40, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc3c7c132926180feb7bec2abeaa63867040661a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc3c7c132926180feb7bec2abeaa63867040661a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=cc3c7c132926180feb7bec2abeaa63867040661a", "patch": "@@ -2404,17 +2404,6 @@ unsave_expr_now (expr)\n int\n contains_placeholder_p (exp)\n      tree exp;\n-{\n-  return contains_this_placeholder_p (exp, NULL_TREE);\n-}\n-\n-/* Similar, but if PL is non-zero it is assumed to be a PLACEHOLDER_EXPR\n-   and we return 1 if that PLACEHOLDER_EXPR is in EXP.  */\n-\n-int\n-contains_this_placeholder_p (exp, pl)\n-     tree exp;\n-     tree pl;\n {\n   register enum tree_code code = TREE_CODE (exp);\n \n@@ -2423,31 +2412,16 @@ contains_this_placeholder_p (exp, pl)\n   if (code == WITH_RECORD_EXPR)\n     return 0;\n   else if (code == PLACEHOLDER_EXPR)\n-    return (pl == 0 || pl == exp);\n+    return 1;\n \n   switch (TREE_CODE_CLASS (code))\n     {\n     case 'r':\n-      if (TREE_CODE (exp) == ARRAY_REF)\n-\t{\n-\t  tree domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-\n-\t  if (domain != 0\n-\t      && ((TREE_CODE (TYPE_MIN_VALUE (domain)) != INTEGER_CST\n-\t\t   && contains_this_placeholder_p (TYPE_MIN_VALUE (domain),\n-\t\t\t\t\t\t   pl))\n-\t\t  || (TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST\n-\t\t      && contains_this_placeholder_p (TYPE_MAX_VALUE (domain),\n-\t\t\t\t\t\t      pl))\n-\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl)))\n-\t    return 1;\n-\t}\n-      else if (TREE_CODE (exp) == BIT_FIELD_REF\n-\t       && (contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl)\n-\t\t   || contains_this_placeholder_p (TREE_OPERAND (exp, 2), pl)))\n-\treturn 1;\n-\n-      return contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl);\n+      /* Don't look at any PLACEHOLDER_EXPRs that might be in index or bit\n+\t position computations since they will be converted into a\n+\t WITH_RECORD_EXPR involving the reference, which will assume\n+\t here will be valid.  */\n+      return contains_placeholder_p (TREE_OPERAND (exp, 0));\n \n     case '1':\n     case '2':  case '<':\n@@ -2456,29 +2430,29 @@ contains_this_placeholder_p (exp, pl)\n \t{\n \tcase COMPOUND_EXPR:\n \t  /* Ignoring the first operand isn't quite right, but works best. */\n-\t  return contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl);\n+\t  return contains_placeholder_p (TREE_OPERAND (exp, 1));\n \n \tcase RTL_EXPR:\n \tcase CONSTRUCTOR:\n \t  return 0;\n \n \tcase COND_EXPR:\n-\t  return (contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl)\n-\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl)\n-\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 2), pl));\n+\t  return (contains_placeholder_p (TREE_OPERAND (exp, 0))\n+\t\t  || contains_placeholder_p (TREE_OPERAND (exp, 1))\n+\t\t  || contains_placeholder_p (TREE_OPERAND (exp, 2)));\n \n \tcase SAVE_EXPR:\n \t   return (SAVE_EXPR_RTL (exp) == 0\n-\t\t   && contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl));\n+\t\t   && contains_placeholder_p (TREE_OPERAND (exp, 0)));\n \t}\n \n       switch (tree_code_length[(int) code])\n \t{\n \tcase 1:\n-\t  return contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl);\n+\t  return contains_placeholder_p (TREE_OPERAND (exp, 0));\n \tcase 2:\n-\t  return (contains_this_placeholder_p (TREE_OPERAND (exp, 0), pl)\n-\t\t  || contains_this_placeholder_p (TREE_OPERAND (exp, 1), pl));\n+\t  return (contains_placeholder_p (TREE_OPERAND (exp, 0))\n+\t\t  || contains_placeholder_p (TREE_OPERAND (exp, 1)));\n \t}\n     }\n "}]}