{"sha": "f939c3e63c5076205c56fb36e9c7cdc064a189a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkzOWMzZTYzYzUwNzYyMDVjNTZmYjM2ZTljN2NkYzA2NGExODlhOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-04T10:49:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-04T10:49:59Z"}, "message": "Turn HARD_REGNO_MODE_OK into a target hook\n\n2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (hard_regno_mode_ok): New hook.\n\t* doc/tm.texi (HARD_REGNO_MODE_OK): Replace with...\n\t(TARGET_HARD_REGNO_MODE_OK): ...this.\n\t* doc/tm.texi.in: Regenerate.\n\t* hooks.h (hook_bool_uint_mode_true): Declare.\n\t* hooks.c (hook_bool_uint_mode_true): New function.\n\t* doc/md.texi: Refer to targetm.hard_regno_mode_ok instead of\n\tHARD_REGNO_MODE_OK.\n\t* genpreds.c (write_insn_preds_c): Add an include of target.h.\n\t* alias.c (init_alias_target): Use targetm.hard_regno_mode_ok\n\tinstead of HARD_REGNO_MODE_OK.\n\t* caller-save.c: Include target.h.\n\t(reg_save_code): Use targetm.hard_regno_mode_ok instead of\n\tHARD_REGNO_MODE_OK.\n\t* combine.c (can_combine_p): Likewise.\n\t(combinable_i3pat): Likewise.\n\t(can_change_dest_mode): Likewise.\n\t* expr.c (init_expr_target): Likewise.\n\t(convert_move): Likewise.\n\t(convert_modes): Likewise.\n\t* ira.c (setup_prohibited_class_mode_regs): Likewise.\n\t(setup_prohibited_mode_move_regs): Likewise.\n\t* ira.h (target_ira): Likewise.\n\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n\t* lra-constraints.c (process_alt_operands): Likewise.\n\t(split_reg): Likewise.\n\t* recog.c (peep2_find_free_register): Likewise.\n\t* ree.c (combine_reaching_defs): Likewise.\n\t* regcprop.c (maybe_mode_change): Likewise.\n\t* reginfo.c (init_reg_sets_1): Likewise.\n\t(choose_hard_reg_mode): Likewise.\n\t(simplifiable_subregs): Likewise.\n\t* regrename.c (check_new_reg_p): Likewise.\n\t* reload.c (find_valid_class): Likewise.\n\t(find_valid_class_1): Likewise.\n\t(reload_inner_reg_of_subreg): Likewise.\n\t(push_reload): Likewise.\n\t(combine_reloads): Likewise.\n\t(find_dummy_reload): Likewise.\n\t(find_reloads): Likewise.\n\t* reload1.c (find_reg): Likewise.\n\t(set_reload_reg): Likewise.\n\t(allocate_reload_reg): Likewise.\n\t(choose_reload_regs): Likewise.\n\t(reload_adjust_reg_for_temp): Likewise.\n\t* rtlanal.c (subreg_size_offset_from_lsb): Likewise.\n\t(simplify_subreg_regno): Likewise.\n\t* sel-sched.c (init_regs_for_mode): Likewise.\n\t* varasm.c (make_decl_rtl): Likewise.\n\t* config/aarch64/aarch64.h (HARD_REGNO_MODE_OK): Delete.\n\t(MODES_TIEABLE_P): Use targetm.hard_regno_mode_ok instead of\n\tHARD_REGNO_MODE_OK.\n\t* config/aarch64/aarch64-protos.h (aarch64_hard_regno_mode_ok): Delete.\n\t* config/aarch64/aarch64.c (aarch64_hard_regno_mode_ok): Make static.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/alpha/alpha.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/alpha/alpha.c (alpha_hard_regno_mode_ok): New function.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/arc/arc.h (arc_hard_regno_mode_ok): Delete.\n\t(arc_mode_class): Delete.\n\t(HARD_REGNO_MODE_OK): Delete.\n\t* config/arc/arc.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(arc_hard_regno_mode_ok): Rename old array to...\n\t(arc_hard_regno_mode_ok_modes): ...this.\n\t(arc_conditional_register_usage): Update accordingly.\n\t(arc_mode_class): Make static.\n\t(arc_hard_regno_mode_ok): New function.\n\t* config/arm/arm.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/arm/arm-protos.h (arm_hard_regno_mode_ok): Delete.\n\t* config/arm/arm.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(arm_hard_regno_mode_ok): Make static.\n\t* config/arm/arm.md (movdi): Use targetm.hard_regno_mode_ok instead of\n\tHARD_REGNO_MODE_OK.\n\t* config/avr/avr-protos.h (avr_hard_regno_mode_ok): Delete.\n\t* config/avr/avr.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/avr/avr.c (avr_hard_regno_mode_ok): Make static and\n\treturn a bool.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/bfin/bfin-protos.h (hard_regno_mode_ok): Delete.\n\t* config/bfin/bfin.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/bfin/bfin.c (hard_regno_mode_ok): Rename to...\n\t(bfin_hard_regno_mode_ok): ...this.  Make static and return a bool.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/bfin/predicates.md (valid_reg_operand): Use\n\ttargetm.hard_regno_mode_ok instead of HARD_REGNO_MODE_OK.\n\t* config/c6x/c6x.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/c6x/c6x.c (c6x_hard_regno_mode_ok): New function.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/cr16/cr16.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/cr16/cr16-protos.h (cr16_hard_regno_mode_ok): Delete.\n\t* config/cr16/cr16.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(cr16_hard_regno_mode_ok): Make static and return a bool.\n\t* config/cris/cris.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/cris/cris.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(cris_hard_regno_mode_ok): New function.\n\t* config/epiphany/epiphany.h (epiphany_hard_regno_mode_ok): Delete.\n\t(epiphany_mode_class): Delete.\n\t(HARD_REGNO_MODE_OK): Delete.\n\t* config/epiphany/epiphany-protos.h (hard_regno_mode_ok): Delete.\n\t* config/epiphany/epiphany.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(hard_regno_mode_ok): Rename to...\n\t(epiphany_hard_regno_mode_ok): ...this.  Make static and return a bool.\n\t* config/fr30/fr30.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/fr30/fr30.md: Refer to targetm.hard_regno_mode_ok instead of\n\tHARD_REGNO_MODE_OK.\n\t* config/frv/frv.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/frv/frv-protos.h (frv_hard_regno_mode_ok): Delete.\n\t* config/frv/frv.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(frv_hard_regno_mode_ok): Make static and return a bool.\n\t* config/frv/frv.md: Refer to targetm.hard_regno_mode_ok instead of\n\tHARD_REGNO_MODE_OK.\n\t* config/ft32/ft32.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/h8300/h8300.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/h8300/h8300-protos.h (h8300_hard_regno_mode_ok): Delete.\n\t* config/h8300/h8300.c (h8300_hard_regno_mode_ok): Make static\n\tand return a bool.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/i386/i386.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/i386/i386-protos.h (ix86_hard_regno_mode_ok): Delete.\n\t* config/i386/i386.c (ix86_hard_regno_mode_ok): Make static and\n\treturn a bool.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/ia64/ia64.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/ia64/ia64.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(ia64_hard_regno_mode_ok): New function.\n\t* config/iq2000/iq2000.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/iq2000/iq2000.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(iq2000_hard_regno_mode_ok): New function.\n\t* config/lm32/lm32.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/lm32/lm32.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(lm32_hard_regno_mode_ok): New function.\n\t* config/m32c/m32c.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/m32c/m32c-protos.h (m32c_hard_regno_ok): Delete.\n\t* config/m32c/m32c.c (class_can_hold_mode): Use m32c_hard_regno_mode_ok\n\tinstead of HARD_REGNO_MODE_OK.\n\t(m32c_hard_regno_ok): Rename to...\n\t(m32c_hard_regno_mode_ok): ...this.  Make static and return a bool.\n\t(m32c_cannot_change_mode_class): Update accordingly.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/m32r/m32r.h (m32r_hard_regno_mode_ok): Delete.\n\t(m32r_mode_class): Delete.\n\t(HARD_REGNO_MODE_OK): Delete.\n\t* config/m32r/m32r.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(m32r_hard_regno_mode_ok): Rename to...\n\t(m32r_hard_regno_modes): ...this.\n\t(m32r_mode_class): Make static.\n\t(m32r_hard_regno_mode_ok): New function.\n\t* config/m68k/m68k.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/m68k/m68k-protos.h (m68k_regno_mode_ok): Delete.\n\t* config/m68k/m68k.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(m68k_hard_regno_mode_ok): Make static.\n\t* config/mcore/mcore.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/mcore/mcore.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(mcore_hard_regno_mode_ok): New function.\n\t* config/microblaze/microblaze.h (microblaze_hard_regno_mode_ok)\n\t(HARD_REGNO_MODE_OK): Delete.\n\t* config/microblaze/microblaze.c (microblaze_hard_regno_mode_ok):\n\tRename to...\n\t(microblaze_hard_regno_mode_ok_p): ...this and make static.\n\t(microblaze_hard_regno_mode_ok): New function.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/mips/mips.h (HARD_REGNO_MODE_OK): Delete.\n\t(mips_hard_regno_mode_ok): Delete.\n\t* config/mips/mips.c (mips_hard_regno_mode_ok): Rename to...\n\t(mips_hard_regno_mode_ok_p): ...this and make static.\n\t(mips_hard_regno_mode_ok_p): Rename to...\n\t(mips_hard_regno_mode_ok_uncached): ...this.\n\t(mips_hard_regno_mode_ok): New function.\n\t(mips_class_max_nregs): Use mips_hard_regno_mode_ok instead\n\tof HARD_REGNO_MODE_OK.\n\t(mips_option_override): Update after above name changes.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/mmix/mmix.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/mn10300/mn10300.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/mn10300/mn10300-protos.h (mn10300_hard_regno_mode_ok): Delete.\n\t* config/mn10300/mn10300.c (mn10300_hard_regno_mode_ok): Make static.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/moxie/moxie.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/msp430/msp430.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/msp430/msp430-protos.h (msp430_hard_regno_mode_ok): Delete.\n\t* config/msp430/msp430.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(msp430_hard_regno_mode_ok): Make static and return a bool.\n\t* config/nds32/nds32.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/nds32/nds32-protos.h (nds32_hard_regno_mode_ok): Delete.\n\t* config/nds32/nds32.c (nds32_hard_regno_mode_ok): Make static\n\tand return a bool.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/nios2/nios2.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/nvptx/nvptx.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/pa/pa.h (MODES_TIEABLE_P): Update commentary.\n\t* config/pa/pa32-regs.h (HARD_REGNO_MODE_OK): Rename to...\n\t(PA_HARD_REGNO_MODE_OK): ...this\n\t* config/pa/pa64-regs.h (HARD_REGNO_MODE_OK): Rename to...\n\t(PA_HARD_REGNO_MODE_OK): ...this.\n\t* config/pa/pa.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(pa_hard_regno_mode_ok): New function.\n\t* config/pdp11/pdp11.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/pdp11/pdp11.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(pdp11_hard_regno_mode_ok): New function.\n\t* config/powerpcspe/powerpcspe.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/powerpcspe/powerpcspe-protos.h (rs6000_hard_regno_mode_ok_p):\n\tDelete.\n\t* config/powerpcspe/powerpcspe.c (rs6000_hard_regno_mode_ok_p):\n\tMake static.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(rs6000_hard_regno_mode_ok): Rename to...\n\t(rs6000_hard_regno_mode_ok_uncached): ...this.\n\t(rs6000_init_hard_regno_mode_ok): Update accordingly.\n\t(rs6000_hard_regno_mode_ok): New function.\n\t* config/riscv/riscv.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/riscv/riscv-protos.h (riscv_hard_regno_mode_ok_p): Delete.\n\t* config/riscv/riscv.c (riscv_hard_regno_mode_ok_p): Rename to...\n\t(riscv_hard_regno_mode_ok): ...this and make static.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/rl78/rl78.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/rl78/rl78-protos.h (rl78_hard_regno_mode_ok): Delete.\n\t* config/rl78/rl78.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(rl78_hard_regno_mode_ok): Make static and return bool.\n\t* config/rs6000/rs6000.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/rs6000/rs6000-protos.h (rs6000_hard_regno_mode_ok_p):\n\tDelete.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok_p): Make static.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(rs6000_hard_regno_mode_ok): Rename to...\n\t(rs6000_hard_regno_mode_ok_uncached): ...this.\n\t(rs6000_init_hard_regno_mode_ok): Update accordingly.\n\t(rs6000_hard_regno_mode_ok): New function.\n\t* config/rx/rx.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/rx/rx.c (rx_hard_regno_mode_ok): New function.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/s390/s390.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/s390/s390-protos.h (s390_hard_regno_mode_ok): Delete.\n\t* config/s390/s390.c (s390_hard_regno_mode_ok): Make static.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/sh/sh.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/sh/sh-protos.h (sh_hard_regno_mode_ok): Delete.\n\t* config/sh/sh.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(sh_hard_regno_mode_ok): Make static.\n\t* config/sparc/constraints.md: Refer to targetm.hard_regno_mode_ok\n\tinstead of HARD_REGNO_MODE_OK.\n\t* config/sparc/sparc.h (hard_regno_mode_classes): Delete.\n\t(sparc_mode_class): Delete.\n\t(HARD_REGNO_MODE_OK): Delete.\n\t* config/sparc/sparc.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(hard_regno_mode_classes): Make static.\n\t(sparc_mode_class): Likewise.\n\t(sparc_hard_regno_mode_ok): New function.\n\t* config/spu/spu.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/stormy16/stormy16.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/stormy16/stormy16.c (xstormy16_hard_regno_mode_ok): New\n\tfunction.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/tilegx/tilegx.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/tilepro/tilepro.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/v850/v850.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/v850/v850.c (v850_hard_regno_mode_ok): New function.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t* config/vax/vax.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/visium/visium.h (HARD_REGNO_MODE_OK): Delete.\n\t* config/visium/visium.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(visium_hard_regno_mode_ok): New function.\n\t* config/visium/visium.md: Refer to targetm.hard_regno_mode_ok\n\tinstead of HARD_REGNO_MODE_OK.\n\t* config/xtensa/xtensa.h (xtensa_hard_regno_mode_ok): Delete.\n\t(HARD_REGNO_MODE_OK): Delete.\n\t* config/xtensa/xtensa.c (xtensa_hard_regno_mode_ok): Rename to...\n\t(xtensa_hard_regno_mode_ok_p): ...this and make static.\n\t(xtensa_option_override): Update accordingly.\n\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n\t(xtensa_hard_regno_mode_ok): New function.\n\t* system.h (HARD_REGNO_MODE_OK): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251646", "tree": {"sha": "c896cfa2fbe6c91ac6769a2e03f5e00bc5b514ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c896cfa2fbe6c91ac6769a2e03f5e00bc5b514ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f939c3e63c5076205c56fb36e9c7cdc064a189a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f939c3e63c5076205c56fb36e9c7cdc064a189a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f939c3e63c5076205c56fb36e9c7cdc064a189a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f939c3e63c5076205c56fb36e9c7cdc064a189a8/comments", "author": null, "committer": null, "parents": [{"sha": "80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ec73f4ee2bcf4b2338eefe3521940ab0fd6dc4"}], "stats": {"total": 1806, "additions": 1046, "deletions": 760}, "files": [{"sha": "b0f5212665d39abaf5c6408b629d74dcf5fcb9ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1,3 +1,279 @@\n+2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (hard_regno_mode_ok): New hook.\n+\t* doc/tm.texi (HARD_REGNO_MODE_OK): Replace with...\n+\t(TARGET_HARD_REGNO_MODE_OK): ...this.\n+\t* doc/tm.texi.in: Regenerate.\n+\t* hooks.h (hook_bool_uint_mode_true): Declare.\n+\t* hooks.c (hook_bool_uint_mode_true): New function.\n+\t* doc/md.texi: Refer to targetm.hard_regno_mode_ok instead of\n+\tHARD_REGNO_MODE_OK.\n+\t* genpreds.c (write_insn_preds_c): Add an include of target.h.\n+\t* alias.c (init_alias_target): Use targetm.hard_regno_mode_ok\n+\tinstead of HARD_REGNO_MODE_OK.\n+\t* caller-save.c: Include target.h.\n+\t(reg_save_code): Use targetm.hard_regno_mode_ok instead of\n+\tHARD_REGNO_MODE_OK.\n+\t* combine.c (can_combine_p): Likewise.\n+\t(combinable_i3pat): Likewise.\n+\t(can_change_dest_mode): Likewise.\n+\t* expr.c (init_expr_target): Likewise.\n+\t(convert_move): Likewise.\n+\t(convert_modes): Likewise.\n+\t* ira.c (setup_prohibited_class_mode_regs): Likewise.\n+\t(setup_prohibited_mode_move_regs): Likewise.\n+\t* ira.h (target_ira): Likewise.\n+\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n+\t* lra-constraints.c (process_alt_operands): Likewise.\n+\t(split_reg): Likewise.\n+\t* recog.c (peep2_find_free_register): Likewise.\n+\t* ree.c (combine_reaching_defs): Likewise.\n+\t* regcprop.c (maybe_mode_change): Likewise.\n+\t* reginfo.c (init_reg_sets_1): Likewise.\n+\t(choose_hard_reg_mode): Likewise.\n+\t(simplifiable_subregs): Likewise.\n+\t* regrename.c (check_new_reg_p): Likewise.\n+\t* reload.c (find_valid_class): Likewise.\n+\t(find_valid_class_1): Likewise.\n+\t(reload_inner_reg_of_subreg): Likewise.\n+\t(push_reload): Likewise.\n+\t(combine_reloads): Likewise.\n+\t(find_dummy_reload): Likewise.\n+\t(find_reloads): Likewise.\n+\t* reload1.c (find_reg): Likewise.\n+\t(set_reload_reg): Likewise.\n+\t(allocate_reload_reg): Likewise.\n+\t(choose_reload_regs): Likewise.\n+\t(reload_adjust_reg_for_temp): Likewise.\n+\t* rtlanal.c (subreg_size_offset_from_lsb): Likewise.\n+\t(simplify_subreg_regno): Likewise.\n+\t* sel-sched.c (init_regs_for_mode): Likewise.\n+\t* varasm.c (make_decl_rtl): Likewise.\n+\t* config/aarch64/aarch64.h (HARD_REGNO_MODE_OK): Delete.\n+\t(MODES_TIEABLE_P): Use targetm.hard_regno_mode_ok instead of\n+\tHARD_REGNO_MODE_OK.\n+\t* config/aarch64/aarch64-protos.h (aarch64_hard_regno_mode_ok): Delete.\n+\t* config/aarch64/aarch64.c (aarch64_hard_regno_mode_ok): Make static.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/alpha/alpha.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/alpha/alpha.c (alpha_hard_regno_mode_ok): New function.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/arc/arc.h (arc_hard_regno_mode_ok): Delete.\n+\t(arc_mode_class): Delete.\n+\t(HARD_REGNO_MODE_OK): Delete.\n+\t* config/arc/arc.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(arc_hard_regno_mode_ok): Rename old array to...\n+\t(arc_hard_regno_mode_ok_modes): ...this.\n+\t(arc_conditional_register_usage): Update accordingly.\n+\t(arc_mode_class): Make static.\n+\t(arc_hard_regno_mode_ok): New function.\n+\t* config/arm/arm.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/arm/arm-protos.h (arm_hard_regno_mode_ok): Delete.\n+\t* config/arm/arm.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(arm_hard_regno_mode_ok): Make static.\n+\t* config/arm/arm.md (movdi): Use targetm.hard_regno_mode_ok instead of\n+\tHARD_REGNO_MODE_OK.\n+\t* config/avr/avr-protos.h (avr_hard_regno_mode_ok): Delete.\n+\t* config/avr/avr.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/avr/avr.c (avr_hard_regno_mode_ok): Make static and\n+\treturn a bool.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/bfin/bfin-protos.h (hard_regno_mode_ok): Delete.\n+\t* config/bfin/bfin.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/bfin/bfin.c (hard_regno_mode_ok): Rename to...\n+\t(bfin_hard_regno_mode_ok): ...this.  Make static and return a bool.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/bfin/predicates.md (valid_reg_operand): Use\n+\ttargetm.hard_regno_mode_ok instead of HARD_REGNO_MODE_OK.\n+\t* config/c6x/c6x.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/c6x/c6x.c (c6x_hard_regno_mode_ok): New function.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/cr16/cr16.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/cr16/cr16-protos.h (cr16_hard_regno_mode_ok): Delete.\n+\t* config/cr16/cr16.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(cr16_hard_regno_mode_ok): Make static and return a bool.\n+\t* config/cris/cris.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/cris/cris.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(cris_hard_regno_mode_ok): New function.\n+\t* config/epiphany/epiphany.h (epiphany_hard_regno_mode_ok): Delete.\n+\t(epiphany_mode_class): Delete.\n+\t(HARD_REGNO_MODE_OK): Delete.\n+\t* config/epiphany/epiphany-protos.h (hard_regno_mode_ok): Delete.\n+\t* config/epiphany/epiphany.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(hard_regno_mode_ok): Rename to...\n+\t(epiphany_hard_regno_mode_ok): ...this.  Make static and return a bool.\n+\t* config/fr30/fr30.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/fr30/fr30.md: Refer to targetm.hard_regno_mode_ok instead of\n+\tHARD_REGNO_MODE_OK.\n+\t* config/frv/frv.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/frv/frv-protos.h (frv_hard_regno_mode_ok): Delete.\n+\t* config/frv/frv.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(frv_hard_regno_mode_ok): Make static and return a bool.\n+\t* config/frv/frv.md: Refer to targetm.hard_regno_mode_ok instead of\n+\tHARD_REGNO_MODE_OK.\n+\t* config/ft32/ft32.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/h8300/h8300.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/h8300/h8300-protos.h (h8300_hard_regno_mode_ok): Delete.\n+\t* config/h8300/h8300.c (h8300_hard_regno_mode_ok): Make static\n+\tand return a bool.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/i386/i386.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/i386/i386-protos.h (ix86_hard_regno_mode_ok): Delete.\n+\t* config/i386/i386.c (ix86_hard_regno_mode_ok): Make static and\n+\treturn a bool.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/ia64/ia64.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/ia64/ia64.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(ia64_hard_regno_mode_ok): New function.\n+\t* config/iq2000/iq2000.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/iq2000/iq2000.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(iq2000_hard_regno_mode_ok): New function.\n+\t* config/lm32/lm32.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/lm32/lm32.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(lm32_hard_regno_mode_ok): New function.\n+\t* config/m32c/m32c.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/m32c/m32c-protos.h (m32c_hard_regno_ok): Delete.\n+\t* config/m32c/m32c.c (class_can_hold_mode): Use m32c_hard_regno_mode_ok\n+\tinstead of HARD_REGNO_MODE_OK.\n+\t(m32c_hard_regno_ok): Rename to...\n+\t(m32c_hard_regno_mode_ok): ...this.  Make static and return a bool.\n+\t(m32c_cannot_change_mode_class): Update accordingly.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/m32r/m32r.h (m32r_hard_regno_mode_ok): Delete.\n+\t(m32r_mode_class): Delete.\n+\t(HARD_REGNO_MODE_OK): Delete.\n+\t* config/m32r/m32r.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(m32r_hard_regno_mode_ok): Rename to...\n+\t(m32r_hard_regno_modes): ...this.\n+\t(m32r_mode_class): Make static.\n+\t(m32r_hard_regno_mode_ok): New function.\n+\t* config/m68k/m68k.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/m68k/m68k-protos.h (m68k_regno_mode_ok): Delete.\n+\t* config/m68k/m68k.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(m68k_hard_regno_mode_ok): Make static.\n+\t* config/mcore/mcore.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/mcore/mcore.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(mcore_hard_regno_mode_ok): New function.\n+\t* config/microblaze/microblaze.h (microblaze_hard_regno_mode_ok)\n+\t(HARD_REGNO_MODE_OK): Delete.\n+\t* config/microblaze/microblaze.c (microblaze_hard_regno_mode_ok):\n+\tRename to...\n+\t(microblaze_hard_regno_mode_ok_p): ...this and make static.\n+\t(microblaze_hard_regno_mode_ok): New function.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/mips/mips.h (HARD_REGNO_MODE_OK): Delete.\n+\t(mips_hard_regno_mode_ok): Delete.\n+\t* config/mips/mips.c (mips_hard_regno_mode_ok): Rename to...\n+\t(mips_hard_regno_mode_ok_p): ...this and make static.\n+\t(mips_hard_regno_mode_ok_p): Rename to...\n+\t(mips_hard_regno_mode_ok_uncached): ...this.\n+\t(mips_hard_regno_mode_ok): New function.\n+\t(mips_class_max_nregs): Use mips_hard_regno_mode_ok instead\n+\tof HARD_REGNO_MODE_OK.\n+\t(mips_option_override): Update after above name changes.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/mmix/mmix.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/mn10300/mn10300.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/mn10300/mn10300-protos.h (mn10300_hard_regno_mode_ok): Delete.\n+\t* config/mn10300/mn10300.c (mn10300_hard_regno_mode_ok): Make static.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/moxie/moxie.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/msp430/msp430.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/msp430/msp430-protos.h (msp430_hard_regno_mode_ok): Delete.\n+\t* config/msp430/msp430.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(msp430_hard_regno_mode_ok): Make static and return a bool.\n+\t* config/nds32/nds32.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/nds32/nds32-protos.h (nds32_hard_regno_mode_ok): Delete.\n+\t* config/nds32/nds32.c (nds32_hard_regno_mode_ok): Make static\n+\tand return a bool.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/nios2/nios2.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/nvptx/nvptx.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/pa/pa.h (MODES_TIEABLE_P): Update commentary.\n+\t* config/pa/pa32-regs.h (HARD_REGNO_MODE_OK): Rename to...\n+\t(PA_HARD_REGNO_MODE_OK): ...this\n+\t* config/pa/pa64-regs.h (HARD_REGNO_MODE_OK): Rename to...\n+\t(PA_HARD_REGNO_MODE_OK): ...this.\n+\t* config/pa/pa.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(pa_hard_regno_mode_ok): New function.\n+\t* config/pdp11/pdp11.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/pdp11/pdp11.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(pdp11_hard_regno_mode_ok): New function.\n+\t* config/powerpcspe/powerpcspe.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/powerpcspe/powerpcspe-protos.h (rs6000_hard_regno_mode_ok_p):\n+\tDelete.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_hard_regno_mode_ok_p):\n+\tMake static.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(rs6000_hard_regno_mode_ok): Rename to...\n+\t(rs6000_hard_regno_mode_ok_uncached): ...this.\n+\t(rs6000_init_hard_regno_mode_ok): Update accordingly.\n+\t(rs6000_hard_regno_mode_ok): New function.\n+\t* config/riscv/riscv.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/riscv/riscv-protos.h (riscv_hard_regno_mode_ok_p): Delete.\n+\t* config/riscv/riscv.c (riscv_hard_regno_mode_ok_p): Rename to...\n+\t(riscv_hard_regno_mode_ok): ...this and make static.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/rl78/rl78.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/rl78/rl78-protos.h (rl78_hard_regno_mode_ok): Delete.\n+\t* config/rl78/rl78.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(rl78_hard_regno_mode_ok): Make static and return bool.\n+\t* config/rs6000/rs6000.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/rs6000/rs6000-protos.h (rs6000_hard_regno_mode_ok_p):\n+\tDelete.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok_p): Make static.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(rs6000_hard_regno_mode_ok): Rename to...\n+\t(rs6000_hard_regno_mode_ok_uncached): ...this.\n+\t(rs6000_init_hard_regno_mode_ok): Update accordingly.\n+\t(rs6000_hard_regno_mode_ok): New function.\n+\t* config/rx/rx.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/rx/rx.c (rx_hard_regno_mode_ok): New function.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/s390/s390.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/s390/s390-protos.h (s390_hard_regno_mode_ok): Delete.\n+\t* config/s390/s390.c (s390_hard_regno_mode_ok): Make static.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/sh/sh.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/sh/sh-protos.h (sh_hard_regno_mode_ok): Delete.\n+\t* config/sh/sh.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(sh_hard_regno_mode_ok): Make static.\n+\t* config/sparc/constraints.md: Refer to targetm.hard_regno_mode_ok\n+\tinstead of HARD_REGNO_MODE_OK.\n+\t* config/sparc/sparc.h (hard_regno_mode_classes): Delete.\n+\t(sparc_mode_class): Delete.\n+\t(HARD_REGNO_MODE_OK): Delete.\n+\t* config/sparc/sparc.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(hard_regno_mode_classes): Make static.\n+\t(sparc_mode_class): Likewise.\n+\t(sparc_hard_regno_mode_ok): New function.\n+\t* config/spu/spu.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/stormy16/stormy16.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/stormy16/stormy16.c (xstormy16_hard_regno_mode_ok): New\n+\tfunction.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/tilegx/tilegx.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/tilepro/tilepro.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/v850/v850.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/v850/v850.c (v850_hard_regno_mode_ok): New function.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t* config/vax/vax.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/visium/visium.h (HARD_REGNO_MODE_OK): Delete.\n+\t* config/visium/visium.c (TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(visium_hard_regno_mode_ok): New function.\n+\t* config/visium/visium.md: Refer to targetm.hard_regno_mode_ok\n+\tinstead of HARD_REGNO_MODE_OK.\n+\t* config/xtensa/xtensa.h (xtensa_hard_regno_mode_ok): Delete.\n+\t(HARD_REGNO_MODE_OK): Delete.\n+\t* config/xtensa/xtensa.c (xtensa_hard_regno_mode_ok): Rename to...\n+\t(xtensa_hard_regno_mode_ok_p): ...this and make static.\n+\t(xtensa_option_override): Update accordingly.\n+\t(TARGET_HARD_REGNO_MODE_OK): Redefine.\n+\t(xtensa_hard_regno_mode_ok): New function.\n+\t* system.h (HARD_REGNO_MODE_OK): Poison.\n+\n 2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e4865729a9b5685488cca5f516789b44b04d0a71", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -3186,7 +3186,7 @@ init_alias_target (void)\n        argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n        numbers, so translate if necessary due to register windows.  */\n     if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))\n-\t&& HARD_REGNO_MODE_OK (i, Pmode))\n+\t&& targetm.hard_regno_mode_ok (i, Pmode))\n       static_reg_base_value[i] = arg_base_value;\n \n   static_reg_base_value[STACK_POINTER_REGNUM]"}, {"sha": "5e6b92b0b8d4fe0fcfd242c7492a81bfe155c545", "filename": "gcc/caller-save.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"addresses.h\"\n #include \"dumpfile.h\"\n #include \"rtl-iter.h\"\n+#include \"target.h\"\n \n #define MOVE_MAX_WORDS (MOVE_MAX / UNITS_PER_WORD)\n \n@@ -111,11 +112,11 @@ reg_save_code (int reg, machine_mode mode)\n   bool ok;\n   if (cached_reg_save_code[reg][mode])\n      return cached_reg_save_code[reg][mode];\n-  if (!HARD_REGNO_MODE_OK (reg, mode))\n+  if (!targetm.hard_regno_mode_ok (reg, mode))\n     {\n-      /* Depending on how HARD_REGNO_MODE_OK is defined, range propagation\n-\t might deduce here that reg >= FIRST_PSEUDO_REGISTER.  So the assert\n-\t below silences a warning.  */\n+      /* Depending on how targetm.hard_regno_mode_ok is defined, range\n+\t propagation might deduce here that reg >= FIRST_PSEUDO_REGISTER.\n+\t So the assert below silences a warning.  */\n       gcc_assert (reg < FIRST_PSEUDO_REGISTER);\n       cached_reg_save_code[reg][mode] = -1;\n       cached_reg_restore_code[reg][mode] = -1;"}, {"sha": "4a3b4d62fc026bea298d0dd8373fce5e9363ef78", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2011,7 +2011,7 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n \n       if (REG_P (src)\n \t  && ((REGNO (dest) < FIRST_PSEUDO_REGISTER\n-\t       && ! HARD_REGNO_MODE_OK (REGNO (dest), GET_MODE (dest)))\n+\t       && !targetm.hard_regno_mode_ok (REGNO (dest), GET_MODE (dest)))\n \t      /* Don't extend the life of a hard register unless it is\n \t\t user variable (if we have few registers) or it can't\n \t\t fit into the desired register (meaning something special\n@@ -2020,7 +2020,8 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n \t\t reload can't handle a conflict with constraints of other\n \t\t inputs.  */\n \t      || (REGNO (src) < FIRST_PSEUDO_REGISTER\n-\t\t  && ! HARD_REGNO_MODE_OK (REGNO (src), GET_MODE (src)))))\n+\t\t  && !targetm.hard_regno_mode_ok (REGNO (src),\n+\t\t\t\t\t\t  GET_MODE (src)))))\n \treturn 0;\n     }\n   else if (GET_CODE (dest) != CC0)\n@@ -2210,8 +2211,8 @@ combinable_i3pat (rtx_insn *i3, rtx *loc, rtx i2dest, rtx i1dest, rtx i0dest,\n \n \t  || (REG_P (inner_dest)\n \t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER\n-\t      && (! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n-\t\t\t\t\tGET_MODE (inner_dest))))\n+\t      && !targetm.hard_regno_mode_ok (REGNO (inner_dest),\n+\t\t\t\t\t      GET_MODE (inner_dest)))\n \t  || (i1_not_in_src && reg_overlap_mentioned_p (i1dest, src))\n \t  || (i0_not_in_src && reg_overlap_mentioned_p (i0dest, src)))\n \treturn 0;\n@@ -2454,7 +2455,7 @@ can_change_dest_mode (rtx x, int added_sets, machine_mode mode)\n   /* Allow hard registers if the new mode is legal, and occupies no more\n      registers than the old mode.  */\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    return (HARD_REGNO_MODE_OK (regno, mode)\n+    return (targetm.hard_regno_mode_ok (regno, mode)\n \t    && REG_NREGS (x) >= hard_regno_nregs[regno][mode]);\n \n   /* Or a pseudo that is only used once.  */"}, {"sha": "88c0e687037187d0171700de29524d26a263f3a2", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -375,7 +375,6 @@ int aarch64_asm_preferred_eh_data_format (int, int);\n int aarch64_fpconst_pow_of_2 (rtx);\n machine_mode aarch64_hard_regno_caller_save_mode (unsigned, unsigned,\n \t\t\t\t\t\t       machine_mode);\n-int aarch64_hard_regno_mode_ok (unsigned, machine_mode);\n int aarch64_hard_regno_nregs (unsigned, machine_mode);\n int aarch64_uxt_size (int, HOST_WIDE_INT);\n int aarch64_vec_fpconst_pow_of_2 (rtx);"}, {"sha": "f10a42cc4e824fafb7cd3e64c454eb6e5082f58d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1083,9 +1083,9 @@ aarch64_hard_regno_nregs (unsigned regno, machine_mode mode)\n   gcc_unreachable ();\n }\n \n-/* Implement HARD_REGNO_MODE_OK.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n-int\n+static bool\n aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n@@ -1101,18 +1101,18 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n     return mode == Pmode;\n \n   if (GP_REGNUM_P (regno) && ! aarch64_vect_struct_mode_p (mode))\n-    return 1;\n+    return true;\n \n   if (FP_REGNUM_P (regno))\n     {\n       if (aarch64_vect_struct_mode_p (mode))\n \treturn\n \t  (regno + aarch64_hard_regno_nregs (regno, mode) - 1) <= V31_REGNUM;\n       else\n-\treturn 1;\n+\treturn true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  The callee only saves\n@@ -15669,6 +15669,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 4\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK aarch64_hard_regno_mode_ok\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   aarch64_hard_regno_call_part_clobbered"}, {"sha": "87f01e643445427a52660b3dfe96d336dacbf9d7", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -403,8 +403,6 @@ extern unsigned aarch64_architecture_version;\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\taarch64_hard_regno_nregs (REGNO, MODE)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\taarch64_hard_regno_mode_ok (REGNO, MODE)\n-\n #define MODES_TIEABLE_P(MODE1, MODE2) aarch64_modes_tieable_p (MODE1, MODE2)\n \n #define DWARF2_UNWIND_INFO 1"}, {"sha": "bcb949955203dc8d3e54a5a17493640019a15e25", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -9891,6 +9891,22 @@ alpha_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n \t\t    build2 (COMPOUND_EXPR, void_type_node,\n \t\t\t    reload_fenv, restore_fnenv), update_call);\n }\n+\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  On Alpha, the integer registers\n+   can hold any mode.  The floating-point registers can hold 64-bit\n+   integers as well, but not smaller values.  */\n+\n+static bool\n+alpha_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  if (IN_RANGE (regno, 32, 62))\n+    return (mode == SFmode\n+\t    || mode == DFmode\n+\t    || mode == DImode\n+\t    || mode == SCmode\n+\t    || mode == DCmode);\n+  return true;\n+}\n \f\n /* Initialize the GCC target structure.  */\n #if TARGET_ABI_OPEN_VMS\n@@ -10085,6 +10101,9 @@ alpha_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV alpha_atomic_assign_expand_fenv\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK alpha_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "438c348d97a616c403ea0a8cfe87c73c35a3d53a", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -385,25 +385,15 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   CEIL (GET_MODE_SIZE (MODE), UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On Alpha, the integer registers can hold any mode.  The floating-point\n-   registers can hold 64-bit integers as well, but not smaller values.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\t\\\n-  (IN_RANGE ((REGNO), 32, 62)\t\t\t\t\t\t\\\n-   ? (MODE) == SFmode || (MODE) == DFmode || (MODE) == DImode\t\t\\\n-     || (MODE) == SCmode || (MODE) == DCmode\t\t\t\t\\\n-   : 1)\n-\n /* A C expression that is nonzero if a value of mode\n    MODE1 is accessible in mode MODE2 without copying.\n \n    This asymmetric test is true when MODE1 could be put\n    in an FP register but MODE2 could not.  */\n \n #define MODES_TIEABLE_P(MODE1, MODE2) \t\t\t\t\\\n-  (HARD_REGNO_MODE_OK (32, (MODE1))\t\t\t\t\\\n-   ? HARD_REGNO_MODE_OK (32, (MODE2))\t\t\t\t\\\n+  (targetm.hard_regno_mode_ok (32, (MODE1))\t\t\t\\\n+   ? targetm.hard_regno_mode_ok (32, (MODE2))\t\t\t\\\n    : 1)\n \n /* Specify the registers used for certain standard purposes."}, {"sha": "3438980d1c3758fe56ca728ed58cf192015b459a", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -590,6 +590,9 @@ static void arc_finalize_pic (void);\n #undef TARGET_DWARF_REGISTER_SPAN\n #define TARGET_DWARF_REGISTER_SPAN arc_dwarf_register_span\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK arc_hard_regno_mode_ok\n+\n /* Try to keep the (mov:DF _, reg) as early as possible so\n    that the d<add/sub/mul>h-lr insns appear together and can\n    use the peephole2 pattern.  */\n@@ -1483,7 +1486,7 @@ enum arc_mode_class {\n \n /* Value is 1 if register/mode pair is acceptable on arc.  */\n \n-unsigned int arc_hard_regno_mode_ok[] = {\n+static unsigned int arc_hard_regno_modes[] = {\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, D_MODES,\n@@ -1509,7 +1512,7 @@ unsigned int arc_hard_regno_mode_ok[] = {\n   S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES\n };\n \n-unsigned int arc_mode_class [NUM_MACHINE_MODES];\n+static unsigned int arc_mode_class [NUM_MACHINE_MODES];\n \n enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n@@ -1730,10 +1733,10 @@ arc_conditional_register_usage (void)\n \t  CLEAR_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], LP_COUNT);\n \n \t  /* Instead of taking out SF_MODE like below, forbid it outright.  */\n-\t  arc_hard_regno_mode_ok[60] = 0;\n+\t  arc_hard_regno_modes[60] = 0;\n \t}\n       else\n-\tarc_hard_regno_mode_ok[60] = 1 << (int) S_MODE;\n+\tarc_hard_regno_modes[60] = 1 << (int) S_MODE;\n     }\n \n   /* ARCHS has 64-bit data-path which makes use of the even-odd paired\n@@ -1742,7 +1745,7 @@ arc_conditional_register_usage (void)\n     {\n       for (regno = 1; regno < 32; regno +=2)\n \t{\n-\t  arc_hard_regno_mode_ok[regno] = S_MODES;\n+\t  arc_hard_regno_modes[regno] = S_MODES;\n \t}\n     }\n \n@@ -1820,8 +1823,8 @@ arc_conditional_register_usage (void)\n       fixed_regs[42] = 1;\n       fixed_regs[43] = 1;\n \n-      arc_hard_regno_mode_ok[40] = 0;\n-      arc_hard_regno_mode_ok[42] = 0;\n+      arc_hard_regno_modes[40] = 0;\n+      arc_hard_regno_modes[42] = 0;\n \n       CLEAR_HARD_REG_SET(reg_class_contents [DOUBLE_REGS]);\n     }\n@@ -1867,10 +1870,18 @@ arc_conditional_register_usage (void)\n     fixed_regs[ACCL_REGNO] = 0;\n     fixed_regs[ACCH_REGNO] = 0;\n \n-    arc_hard_regno_mode_ok[ACC_REG_FIRST] = D_MODES;\n+    arc_hard_regno_modes[ACC_REG_FIRST] = D_MODES;\n   }\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+arc_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return (arc_hard_regno_modes[regno] & arc_mode_class[mode]) != 0;\n+}\n+\n /* Handle an \"interrupt\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "10532c4fc7e2c4dd254ed0556baa26fbd75e1db1", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -450,19 +450,13 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   && REGNO >= ARC_FIRST_SIMD_VR_REG && REGNO <= ARC_LAST_SIMD_VR_REG) ? 1 \\\n  : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-extern unsigned int arc_hard_regno_mode_ok[];\n-extern unsigned int arc_mode_class[];\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-((arc_hard_regno_mode_ok[REGNO] & arc_mode_class[MODE]) != 0)\n-\n /* A C expression that is nonzero if it is desirable to choose\n    register allocation so as to avoid move instructions between a\n    value of mode MODE1 and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n-   MODE2)' must be zero.  */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `TARGET_MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n \n /* Tie QI/HI/SI modes together.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\"}, {"sha": "189af348c1aef5bf08ffab27ad8cd5fc2f223481", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -61,7 +61,6 @@ extern void arm_gen_unlikely_cbranch (enum rtx_code, machine_mode cc_mode,\n \t\t\t\t      rtx label_ref);\n extern bool arm_vector_mode_supported_p (machine_mode);\n extern bool arm_small_register_classes_for_mode_p (machine_mode);\n-extern int arm_hard_regno_mode_ok (unsigned int, machine_mode);\n extern bool arm_modes_tieable_p (machine_mode, machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n extern int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);"}, {"sha": "3c6c56ccdb5ae5f50ec90b0a1d02bfe40385ead2", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -313,6 +313,7 @@ static unsigned int arm_elf_section_type_flags (tree decl, const char *name,\n \t\t\t\t\t\tint reloc);\n static void arm_expand_divmod_libfunc (rtx, machine_mode, rtx, rtx, rtx *, rtx *);\n static opt_scalar_float_mode arm_floatn_mode (int, bool);\n+static bool arm_hard_regno_mode_ok (unsigned int, machine_mode);\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -780,6 +781,8 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_FIXED_CONDITION_CODE_REGS\n #define TARGET_FIXED_CONDITION_CODE_REGS arm_fixed_condition_code_regs\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK arm_hard_regno_mode_ok\n \f\n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n@@ -23344,9 +23347,8 @@ thumb2_asm_output_opcode (FILE * stream)\n     }\n }\n \n-/* Returns true if REGNO is a valid register\n-   for holding a quantity of type MODE.  */\n-int\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+static bool\n arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n@@ -23390,7 +23392,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \t       || (mode == CImode && NEON_REGNO_OK_FOR_NREGS (regno, 6))\n \t       || (mode == XImode && NEON_REGNO_OK_FOR_NREGS (regno, 8));\n \n-      return FALSE;\n+      return false;\n     }\n \n   if (TARGET_REALLY_IWMMXT)\n@@ -23409,10 +23411,10 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   if (regno <= LAST_ARM_REGNUM)\n     {\n       if (ARM_NUM_REGS (mode) > 4)\n-\t  return FALSE;\n+\treturn false;\n \n       if (TARGET_THUMB2)\n-\treturn TRUE;\n+\treturn true;\n \n       return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0);\n     }\n@@ -23422,7 +23424,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n     /* We only allow integers in the fake hard registers.  */\n     return GET_MODE_CLASS (mode) == MODE_INT;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Implement MODES_TIEABLE_P.  */"}, {"sha": "4385b7dcf00e102f1b078c5dfd6ee3224f5a2bd1", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -990,10 +990,6 @@ extern int arm_arch_cmse;\n     && !IS_VFP_REGNUM (REGNO)\t\t\\\n    ? 1 : ARM_NUM_REGS (MODE))\n \n-/* Return true if REGNO is suitable for holding a quantity of type MODE.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  arm_hard_regno_mode_ok ((REGNO), (MODE))\n-\n #define MODES_TIEABLE_P(MODE1, MODE2) arm_modes_tieable_p (MODE1, MODE2)\n \n #define VALID_IWMMXT_REG_MODE(MODE) \\"}, {"sha": "6380c69df624060dc745ebd238dc119233d5643b", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -5804,7 +5804,7 @@\n \toperands[1] = force_reg (DImode, operands[1]);\n     }\n   if (REG_P (operands[0]) && REGNO (operands[0]) <= LAST_ARM_REGNUM\n-      && !HARD_REGNO_MODE_OK (REGNO (operands[0]), DImode))\n+      && !targetm.hard_regno_mode_ok (REGNO (operands[0]), DImode))\n     {\n       /* Avoid LDRD's into an odd-numbered register pair in ARM state\n \t when expanding function calls.  */\n@@ -5823,7 +5823,7 @@\n       DONE;\n     }\n   else if (REG_P (operands[1]) && REGNO (operands[1]) <= LAST_ARM_REGNUM\n-\t   && !HARD_REGNO_MODE_OK (REGNO (operands[1]), DImode))\n+\t   && !targetm.hard_regno_mode_ok (REGNO (operands[1]), DImode))\n     {\n       /* Avoid STRD's from an odd-numbered register pair in ARM state\n \t when expanding function prologue.  */"}, {"sha": "e4306ea5d63f5b2649276edd67d8ca4568ca259e", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -111,7 +111,6 @@ extern int avr_jump_mode (rtx x, rtx_insn *insn);\n extern int test_hard_reg_class (enum reg_class rclass, rtx x);\n extern int jump_over_one_insn_p (rtx_insn *insn, rtx dest);\n \n-extern int avr_hard_regno_mode_ok (int regno, machine_mode mode);\n extern void avr_final_prescan_insn (rtx_insn *insn, rtx *operand,\n \t\t\t\t    int num_operands);\n extern int avr_simplify_comparison_p (machine_mode mode,"}, {"sha": "62ddc579d861a33ebae83336b448db3fb205338f", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -12149,14 +12149,12 @@ jump_over_one_insn_p (rtx_insn *insn, rtx dest)\n }\n \n \n-/* Worker function for `HARD_REGNO_MODE_OK'.  */\n-/* Returns 1 if a value of mode MODE can be stored starting with hard\n-   register number REGNO.  On the enhanced core, anything larger than\n-   1 byte must start in even numbered register for \"movw\" to work\n-   (this way we don't have to check for odd registers everywhere).  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  On the enhanced core, anything\n+   larger than 1 byte must start in even numbered register for \"movw\" to\n+   work (this way we don't have to check for odd registers everywhere).  */\n \n-int\n-avr_hard_regno_mode_ok (int regno, machine_mode mode)\n+static bool\n+avr_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   /* NOTE: 8-bit values must not be disallowed for R28 or R29.\n         Disallowing QI et al. in these regs might lead to code like\n@@ -12169,7 +12167,7 @@ avr_hard_regno_mode_ok (int regno, machine_mode mode)\n   /* Any GENERAL_REGS register can hold 8-bit values.  */\n \n   if (GET_MODE_SIZE (mode) == 1)\n-    return 1;\n+    return true;\n \n   /* FIXME: Ideally, the following test is not needed.\n         However, it turned out that it can reduce the number\n@@ -12178,7 +12176,7 @@ avr_hard_regno_mode_ok (int regno, machine_mode mode)\n \n   if (GET_MODE_SIZE (mode) >= 4\n       && regno >= REG_X)\n-    return 0;\n+    return false;\n \n   /* All modes larger than 8 bits should start in an even register.  */\n \n@@ -14691,6 +14689,8 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE avr_conditional_register_usage\n \n+#undef  TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK avr_hard_regno_mode_ok\n #undef  TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK avr_hard_regno_scratch_ok\n #undef  TARGET_HARD_REGNO_CALL_PART_CLOBBERED"}, {"sha": "449382c771c8bd7c41e4c8af58405f7116c9bc63", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -212,8 +212,6 @@ FIXME: DRIVER_SELF_SPECS has changed.\n #define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) avr_hard_regno_mode_ok(REGNO, MODE)\n-\n #define MODES_TIEABLE_P(MODE1, MODE2) 1\n \n enum reg_class {"}, {"sha": "223646d59a0a1ea0ffb5c56235c4061c930005e9", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -71,7 +71,6 @@ extern char *bfin_asm_long (void);\n extern char *bfin_asm_short (void);\n extern int log2constp (unsigned HOST_WIDE_INT);\n \n-extern int hard_regno_mode_ok (int, machine_mode);\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\t  \n extern HOST_WIDE_INT bfin_initial_elimination_offset (int, int);\n "}, {"sha": "7572527a1e5debd605185cf12d7a3c53e7ca5228", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2114,16 +2114,18 @@ bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx cookie, int sibcall)\n     CALL_INSN_FUNCTION_USAGE (call) = use;\n }\n \f\n-/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.\n \n-int\n-hard_regno_mode_ok (int regno, machine_mode mode)\n+   Do not allow to store a value in REG_CC for any mode.\n+   Do not allow to store value in pregs if mode is not SI.  */\n+static bool\n+bfin_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   /* Allow only dregs to store value of mode HI or QI */\n   enum reg_class rclass = REGNO_REG_CLASS (regno);\n \n   if (mode == CCmode)\n-    return 0;\n+    return false;\n \n   if (mode == V2HImode)\n     return D_REGNO_P (regno);\n@@ -2139,7 +2141,7 @@ hard_regno_mode_ok (int regno, machine_mode mode)\n \n   if (mode == SImode\n       && TEST_HARD_REG_BIT (reg_class_contents[PROLOGUE_REGS], regno))\n-    return 1;\n+    return true;\n \n   return TEST_HARD_REG_BIT (reg_class_contents[MOST_REGS], regno);\n }\n@@ -5845,4 +5847,7 @@ bfin_conditional_register_usage (void)\n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P bfin_can_use_doloop_p\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK bfin_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "232ce23fe0df6ca2e7a0f264ff0d0da9887a991a", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -677,10 +677,6 @@ enum reg_class\n    registers.  */\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n-/* Do not allow to store a value in REG_CC for any mode */\n-/* Do not allow to store value in pregs if mode is not SI*/\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok((REGNO), (MODE))\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n@@ -700,9 +696,9 @@ enum reg_class\n    register allocation so as to avoid move instructions between a\n    value of mode MODE1 and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n-   MODE2)' must be zero. */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero. */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n  ((MODE1) == (MODE2)\t\t\t\t\t\\\n   || ((GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\"}, {"sha": "7541c75ed9d2737038716f5e1b7bc6d12a15c06c", "filename": "gcc/config/bfin/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -79,7 +79,7 @@\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n   if (REGNO (op) < FIRST_PSEUDO_REGISTER)\n-    return HARD_REGNO_MODE_OK (REGNO (op), mode);\n+    return targetm.hard_regno_mode_ok (REGNO (op), mode);\n   return 1;\n })\n "}, {"sha": "af0dae2d0fa6ab6b9d813a035c75df04635bd287", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -6696,6 +6696,14 @@ c6x_debug_unwind_info (void)\n \n   return default_debug_unwind_info ();\n }\n+\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+c6x_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return GET_MODE_SIZE (mode) <= UNITS_PER_WORD || (regno & 1) == 0;\n+}\n \f\n /* Target Structure.  */\n \n@@ -6862,6 +6870,9 @@ c6x_debug_unwind_info (void)\n #undef  TARGET_BUILTIN_DECL\n #define TARGET_BUILTIN_DECL c6x_builtin_decl\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK c6x_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-c6x.h\""}, {"sha": "da58fda17cfb32249e941ed938a6420756fadccf", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -185,9 +185,6 @@ extern c6x_cpu_t c6x_arch;\n   ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)  \\\n    / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(reg, mode) (GET_MODE_SIZE (mode) <= UNITS_PER_WORD \\\n-\t\t\t\t       ? 1 : ((reg) & 1) == 0)\n-\n #define MODES_TIEABLE_P(mode1, mode2)\t       \\\n   ((mode1) == (mode2) ||\t\t       \\\n    (GET_MODE_SIZE (mode1) <= UNITS_PER_WORD && \\"}, {"sha": "4872c0b8b2e3c97f050ab99b3e3661da54da2b68", "filename": "gcc/config/cr16/cr16-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -23,7 +23,6 @@\n \n /* Register usage.  */\n extern enum reg_class cr16_regno_reg_class (int);\n-extern int cr16_hard_regno_mode_ok (int regno, machine_mode);\n \n /* Passing function arguments.  */\n extern int cr16_function_arg_regno_p (int);"}, {"sha": "39c3ba97640383ab292315ca136694ba9324ffd6", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -220,6 +220,9 @@ static const struct attribute_spec cr16_attribute_table[] = {\n #undef TARGET_ASM_UNALIGNED_DI_OP\n #define TARGET_ASM_UNALIGNED_DI_OP \tTARGET_ASM_ALIGNED_DI_OP\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK\tcr16_hard_regno_mode_ok\n+\n /* Target hook implementations.  */\n \n /* Implements hook TARGET_RETURN_IN_MEMORY.  */\n@@ -463,28 +466,31 @@ cr16_regno_reg_class (int regno)\n   return NO_REGS;\n }\n \n-/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-int\n-cr16_hard_regno_mode_ok (int regno, machine_mode mode)\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  On the CR16 architecture, all\n+   registers can hold all modes, except that double precision floats\n+   (and double ints) must fall on even-register boundaries.  */\n+\n+static bool\n+cr16_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if ((GET_MODE_SIZE (mode) >= 4) && (regno == 11))\n-    return 0;\n+    return false;\n  \n   if (mode == DImode || mode == DFmode)\n     {\n       if ((regno > 8) || (regno & 1))\n-\treturn 0;\n-      return 1;\n+\treturn false;\n+      return true;\n     }\n \n   if ((TARGET_INT32)\n        && ((regno >= 12) && (GET_MODE_SIZE (mode) < 4 )))\n-     return 0;\n+     return false;\n \n   /* CC can only hold CCmode values.  */\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n-    return 0;\n-  return 1;\n+    return false;\n+  return true;\n }\n \n /* Returns register number for function return value.*/"}, {"sha": "fc234e7e8e617bae0c109d673e3d5bce6821d038", "filename": "gcc/config/cr16/cr16.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -204,13 +204,6 @@ while (0)\n   ? ((GET_MODE_SIZE (MODE) + CR16_UNITS_PER_DWORD - 1) / CR16_UNITS_PER_DWORD)\\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD       - 1) / UNITS_PER_WORD))\n \n-/* Nonzero if it is permissible to store a value of mode @var{mode} in hard\n-   register number @var{regno} (or in several registers starting with that\n-   one).  On the CR16 architecture, all registers can hold all modes,\n-   except that double precision floats (and double ints) must fall on\n-   even-register boundaries.  */ \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) cr16_hard_regno_mode_ok (REGNO, MODE)\n-\n #define NOTICE_UPDATE_CC(EXP, INSN) \\\n    notice_update_cc ((EXP))\n "}, {"sha": "01806389075a17d770ef24cefbf798527dab6028", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -163,6 +163,7 @@ static rtx cris_function_value(const_tree, const_tree, bool);\n static rtx cris_libcall_value (machine_mode, const_rtx);\n static bool cris_function_value_regno_p (const unsigned int);\n static void cris_file_end (void);\n+static bool cris_hard_regno_mode_ok (unsigned int, machine_mode);\n \n /* This is the parsed result of the \"-max-stack-stackframe=\" option.  If\n    it (still) is zero, then there was no such option given.  */\n@@ -280,6 +281,9 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_FUNCTION_VALUE_REGNO_P\n #define TARGET_FUNCTION_VALUE_REGNO_P cris_function_value_regno_p\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK cris_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Helper for cris_load_multiple_op and cris_ret_movem_op.  */\n@@ -4292,6 +4296,18 @@ cris_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n      sake of a trampoline.  */\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.\n+\n+   CRIS permits all registers to hold all modes.  Well, except for the\n+   condition-code register.  And we can't hold larger-than-register size\n+   modes in the last special register that can hold a full 32 bits.  */\n+static bool\n+cris_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return ((mode == CCmode || regno != CRIS_CC0_REGNUM)\n+\t  && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t      || (regno != CRIS_MOF_REGNUM && regno != CRIS_ACR_REGNUM)));\n+}\n \n #if 0\n /* Various small functions to replace macros.  Only called from a"}, {"sha": "8203b886f8b7d590e46bb09be39815156d7af88d", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -477,18 +477,9 @@ extern int cris_cpu_version;\n  (MODE == VOIDmode \\\n   ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* CRIS permits all registers to hold all modes.  Well, except for the\n-   condition-code register.  And we can't hold larger-than-register size\n-   modes in the last special register that can hold a full 32 bits.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n- (((MODE) == CCmode\t\t\t\t\\\n-   || (REGNO) != CRIS_CC0_REGNUM)\t\t\\\n-  && (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\\\n-      || ((REGNO) != CRIS_MOF_REGNUM && (REGNO) != CRIS_ACR_REGNUM)))\n-\n /* Because CCmode isn't covered by the \"narrower mode\" statement in\n    tm.texi, we can still say all modes are tieable despite not having an\n-   always 1 HARD_REGNO_MODE_OK.  */\n+   always 1 TARGET_HARD_REGNO_MODE_OK.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) 1\n \n "}, {"sha": "841c25c6d40f86030c27ce1cf9e283b4bcbf4934", "filename": "gcc/config/epiphany/epiphany-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -38,7 +38,6 @@ extern void epiphany_expand_prologue (void);\n extern void epiphany_expand_epilogue (int);\n extern int epiphany_initial_elimination_offset (int, int);\n extern void epiphany_init_expanders (void);\n-extern int hard_regno_mode_ok (int regno, machine_mode mode);\n #ifdef HARD_CONST\n extern void emit_set_fp_mode (int entity, int mode, int prev_mode,\n \t\t\t      HARD_REG_SET regs_live);"}, {"sha": "67d52b8e891832e3e5177d9757d568fe37be05c2", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -170,6 +170,9 @@ static rtx_insn *frame_insn (rtx);\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n #undef TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK epiphany_hard_regno_mode_ok\n \f\n bool\n epiphany_is_interrupt_p (tree decl)\n@@ -355,14 +358,15 @@ get_epiphany_condition_code (rtx comparison)\n }\n \n \n-/* Return 1 if hard register REGNO can hold a value of machine_mode MODE.  */\n-int\n-hard_regno_mode_ok (int regno, machine_mode mode)\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+epiphany_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     return (regno & 1) == 0 && GPR_P (regno);\n   else\n-    return 1;\n+    return true;\n }\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,"}, {"sha": "416899196a54c43f43c8dff1be14e9392beaa8fd", "filename": "gcc/config/epiphany/epiphany.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -309,18 +309,13 @@ along with GCC; see the file COPYING3.  If not see\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-extern const unsigned int epiphany_hard_regno_mode_ok[];\n-extern unsigned int epiphany_mode_class[];\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok((REGNO), (MODE))\n-\n /* A C expression that is nonzero if it is desirable to choose\n    register allocation so as to avoid move instructions between a\n    value of mode MODE1 and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n-   MODE2)' must be zero.  */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n \n #define MODES_TIEABLE_P(MODE1, MODE2) 1\n "}, {"sha": "0366fdd05f8713fdb5c516489ce603dec2ed307e", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -246,19 +246,13 @@ along with GCC; see the file COPYING3.  If not see\n #define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is permissible to store a value of mode\n-   MODE in hard register number REGNO (or in several registers starting with\n-   that one).  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n /* A C expression that is nonzero if it is desirable to choose register\n    allocation so as to avoid move instructions between a value of mode MODE1\n    and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R, MODE2)' are\n-   ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)' must be\n-   zero.  */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) 1\n \n /*}}}*/ \f"}, {"sha": "383a7ee74e52e2a543093b073fb7919bbd77c2d2", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -118,22 +118,23 @@\n ;; patterns `reload_inM' or `reload_outM' to handle them.\n \n ;; The constraints on a `moveM' must permit moving any hard register to any\n-;; other hard register provided that `HARD_REGNO_MODE_OK' permits mode M in\n-;; both registers and `REGISTER_MOVE_COST' applied to their classes returns a\n-;; value of 2.\n+;; other hard register provided that `TARGET_HARD_REGNO_MODE_OK' permits mode\n+;; M in both registers and `REGISTER_MOVE_COST' applied to their classes\n+;; returns a value of 2.\n \n ;; It is obligatory to support floating point `moveM' instructions\n ;; into and out of any registers that can hold fixed point values,\n ;; because unions and structures (which have modes `SImode' or\n ;; `DImode') can be in those registers and they may have floating\n ;; point members.\n \n-;; There may also be a need to support fixed point `moveM' instructions in and\n-;; out of floating point registers.  Unfortunately, I have forgotten why this\n-;; was so, and I don't know whether it is still true.  If `HARD_REGNO_MODE_OK'\n-;; rejects fixed point values in floating point registers, then the constraints\n-;; of the fixed point `moveM' instructions must be designed to avoid ever\n-;; trying to reload into a floating point register.\n+;; There may also be a need to support fixed point `moveM' instructions\n+;; in and out of floating point registers.  Unfortunately, I have\n+;; forgotten why this was so, and I don't know whether it is still true.\n+;; If `TARGET_HARD_REGNO_MODE_OK' rejects fixed point values in floating\n+;; point registers, then the constraints of the fixed point `moveM'\n+;; instructions must be designed to avoid ever trying to reload into a\n+;; floating point register.\n \n ;;}}}\n ;;{{{ Push and Pop  "}, {"sha": "be87f74c46a16a8de479b296757637c67c972a22", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -74,7 +74,6 @@ extern void frv_ifcvt_modify_cancel\t(struct ce_if_block *);\n extern enum reg_class frv_secondary_reload_class\n \t\t\t\t\t(enum reg_class,\n \t\t\t\t\t machine_mode, rtx);\n-extern int frv_hard_regno_mode_ok\t(int, machine_mode);\n extern int frv_hard_regno_nregs\t\t(int, machine_mode);\n extern int frv_class_max_nregs\t\t(enum reg_class rclass,\n \t\t\t\t\t machine_mode mode);"}, {"sha": "3c40d9b2ef90152154ba5c12412209b9ebb63578", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 10, "deletions": 58, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -399,6 +399,7 @@ static bool frv_can_eliminate\t\t\t(const int, const int);\n static void frv_conditional_register_usage\t(void);\n static void frv_trampoline_init\t\t\t(rtx, tree, rtx);\n static bool frv_class_likely_spilled_p \t\t(reg_class_t);\n+static bool frv_hard_regno_mode_ok\t\t(unsigned int, machine_mode);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_PRINT_OPERAND\n@@ -516,6 +517,9 @@ static bool frv_class_likely_spilled_p \t\t(reg_class_t);\n #undef TARGET_LIBCALL_VALUE\n #define TARGET_LIBCALL_VALUE frv_libcall_value\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK frv_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #define FRV_SYMBOL_REF_TLS_P(RTX) \\\n@@ -6517,62 +6521,10 @@ frv_adjust_field_align (tree field, int computed)\n }\n \n \f\n-/* A C expression that is nonzero if it is permissible to store a value of mode\n-   MODE in hard register number REGNO (or in several registers starting with\n-   that one).  For a machine where all registers are equivalent, a suitable\n-   definition is\n-\n-        #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-   It is not necessary for this macro to check for the numbers of fixed\n-   registers, because the allocation mechanism considers them to be always\n-   occupied.\n-\n-   On some machines, double-precision values must be kept in even/odd register\n-   pairs.  The way to implement that is to define this macro to reject odd\n-   register numbers for such modes.\n-\n-   The minimum requirement for a mode to be OK in a register is that the\n-   `movMODE' instruction pattern support moves between the register and any\n-   other hard register for which the mode is OK; and that moving a value into\n-   the register and back out not alter it.\n-\n-   Since the same instruction used to move `SImode' will work for all narrower\n-   integer modes, it is not necessary on any machine for `HARD_REGNO_MODE_OK'\n-   to distinguish between these modes, provided you define patterns `movhi',\n-   etc., to take advantage of this.  This is useful because of the interaction\n-   between `HARD_REGNO_MODE_OK' and `MODES_TIEABLE_P'; it is very desirable for\n-   all integer modes to be tieable.\n-\n-   Many machines have special registers for floating point arithmetic.  Often\n-   people assume that floating point machine modes are allowed only in floating\n-   point registers.  This is not true.  Any registers that can hold integers\n-   can safely *hold* a floating point machine mode, whether or not floating\n-   arithmetic can be done on it in those registers.  Integer move instructions\n-   can be used to move the values.\n-\n-   On some machines, though, the converse is true: fixed-point machine modes\n-   may not go in floating registers.  This is true if the floating registers\n-   normalize any value stored in them, because storing a non-floating value\n-   there would garble it.  In this case, `HARD_REGNO_MODE_OK' should reject\n-   fixed-point machine modes in floating registers.  But if the floating\n-   registers do not automatically normalize, if you can store any bit pattern\n-   in one and retrieve it unchanged without a trap, then any machine mode may\n-   go in a floating register, so you can define this macro to say so.\n-\n-   The primary significance of special floating registers is rather that they\n-   are the registers acceptable in floating point arithmetic instructions.\n-   However, this is of no concern to `HARD_REGNO_MODE_OK'.  You handle it by\n-   writing the proper constraints for those instructions.\n-\n-   On some machines, the floating registers are especially slow to access, so\n-   that it is better to store a value in a stack frame than in such a register\n-   if floating point arithmetic is not being done.  As long as the floating\n-   registers are not in class `GENERAL_REGS', they will not be used unless some\n-   pattern's constraint asks for one.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n-int\n-frv_hard_regno_mode_ok (int regno, machine_mode mode)\n+static bool\n+frv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   int base;\n   int mask;\n@@ -6624,18 +6576,18 @@ frv_hard_regno_mode_ok (int regno, machine_mode mode)\n \n \t  /* Fill in the table.  */\n \t  else\n-\t    return 0;\n+\t    return false;\n \n \t  /* Anything smaller than an SI is OK in any word-sized register.  */\n \t  if (GET_MODE_SIZE (mode) < 4)\n-\t    return 1;\n+\t    return true;\n \n \t  mask = (GET_MODE_SIZE (mode) / 4) - 1;\n \t}\n       return (((regno - base) & mask) == 0);\n     }\n \n-  return 0;\n+  return false;\n }\n \n \f"}, {"sha": "2e2957c0f36aeec2f2d0de21ca01df64fd1db992", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 3, "deletions": 58, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -763,68 +763,13 @@\n    we can build the appropriate instructions to properly reload the values.  */\n #define HARD_REGNO_NREGS(REGNO, MODE) frv_hard_regno_nregs (REGNO, MODE)\n \n-/* A C expression that is nonzero if it is permissible to store a value of mode\n-   MODE in hard register number REGNO (or in several registers starting with\n-   that one).  For a machine where all registers are equivalent, a suitable\n-   definition is\n-\n-        #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-   It is not necessary for this macro to check for the numbers of fixed\n-   registers, because the allocation mechanism considers them to be always\n-   occupied.\n-\n-   On some machines, double-precision values must be kept in even/odd register\n-   pairs.  The way to implement that is to define this macro to reject odd\n-   register numbers for such modes.\n-\n-   The minimum requirement for a mode to be OK in a register is that the\n-   `movMODE' instruction pattern support moves between the register and any\n-   other hard register for which the mode is OK; and that moving a value into\n-   the register and back out not alter it.\n-\n-   Since the same instruction used to move `SImode' will work for all narrower\n-   integer modes, it is not necessary on any machine for `HARD_REGNO_MODE_OK'\n-   to distinguish between these modes, provided you define patterns `movhi',\n-   etc., to take advantage of this.  This is useful because of the interaction\n-   between `HARD_REGNO_MODE_OK' and `MODES_TIEABLE_P'; it is very desirable for\n-   all integer modes to be tieable.\n-\n-   Many machines have special registers for floating point arithmetic.  Often\n-   people assume that floating point machine modes are allowed only in floating\n-   point registers.  This is not true.  Any registers that can hold integers\n-   can safely *hold* a floating point machine mode, whether or not floating\n-   arithmetic can be done on it in those registers.  Integer move instructions\n-   can be used to move the values.\n-\n-   On some machines, though, the converse is true: fixed-point machine modes\n-   may not go in floating registers.  This is true if the floating registers\n-   normalize any value stored in them, because storing a non-floating value\n-   there would garble it.  In this case, `HARD_REGNO_MODE_OK' should reject\n-   fixed-point machine modes in floating registers.  But if the floating\n-   registers do not automatically normalize, if you can store any bit pattern\n-   in one and retrieve it unchanged without a trap, then any machine mode may\n-   go in a floating register, so you can define this macro to say so.\n-\n-   The primary significance of special floating registers is rather that they\n-   are the registers acceptable in floating point arithmetic instructions.\n-   However, this is of no concern to `HARD_REGNO_MODE_OK'.  You handle it by\n-   writing the proper constraints for those instructions.\n-\n-   On some machines, the floating registers are especially slow to access, so\n-   that it is better to store a value in a stack frame than in such a register\n-   if floating point arithmetic is not being done.  As long as the floating\n-   registers are not in class `GENERAL_REGS', they will not be used unless some\n-   pattern's constraint asks for one.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) frv_hard_regno_mode_ok (REGNO, MODE)\n-\n /* A C expression that is nonzero if it is desirable to choose register\n    allocation so as to avoid move instructions between a value of mode MODE1\n    and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R, MODE2)' are\n-   ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)' must be\n-   zero.  */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) (MODE1 == MODE2)\n \n /* Define this macro if the compiler should avoid copies to/from CCmode"}, {"sha": "6411c68b2eb1a9aef39f289f57e0fc2f1ab10ad3", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1335,22 +1335,23 @@\n ;; patterns `reload_inM' or `reload_outM' to handle them.\n \n ;; The constraints on a `moveM' must permit moving any hard register to any\n-;; other hard register provided that `HARD_REGNO_MODE_OK' permits mode M in\n-;; both registers and `REGISTER_MOVE_COST' applied to their classes returns a\n-;; value of 2.\n+;; other hard register provided that `TARGET_HARD_REGNO_MODE_OK' permits\n+;; mode M in both registers and `REGISTER_MOVE_COST' applied to their\n+;; classes returns a value of 2.\n \n ;; It is obligatory to support floating point `moveM' instructions\n ;; into and out of any registers that can hold fixed point values,\n ;; because unions and structures (which have modes `SImode' or\n ;; `DImode') can be in those registers and they may have floating\n ;; point members.\n \n-;; There may also be a need to support fixed point `moveM' instructions in and\n-;; out of floating point registers.  Unfortunately, I have forgotten why this\n-;; was so, and I don't know whether it is still true.  If `HARD_REGNO_MODE_OK'\n-;; rejects fixed point values in floating point registers, then the constraints\n-;; of the fixed point `moveM' instructions must be designed to avoid ever\n-;; trying to reload into a floating point register.\n+;; There may also be a need to support fixed point `moveM' instructions\n+;; in and out of floating point registers.  Unfortunately, I have\n+;; forgotten why this was so, and I don't know whether it is still true.\n+;; If `TARGET_HARD_REGNO_MODE_OK' rejects fixed point values in floating\n+;; point registers, then the constraints of the fixed point `moveM'\n+;; instructions must be designed to avoid ever trying to reload into a\n+;; floating point register.\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")"}, {"sha": "84de381d152395cb3e312e41654c6b786e08162b", "filename": "gcc/config/ft32/ft32.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fft32%2Fft32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fft32%2Fft32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -166,12 +166,6 @@ enum reg_class\n /* We can't copy to or from our CC register. */\n #define AVOID_CCMODE_COPIES 1\n \n-/* A C expression that is nonzero if it is permissible to store a\n-   value of mode MODE in hard register number REGNO (or in several\n-   registers starting with that one).  All gstore registers are\n-   equivalent, so we can set this to 1.  */\n-#define HARD_REGNO_MODE_OK(R,M) 1\n-\n /* A C expression whose value is a register class containing hard\n    register REGNO.  */\n #define REGNO_REG_CLASS(R) ((R < FT32_PC) ? GENERAL_REGS :                \\"}, {"sha": "16829a04d06adf1cd7b2003e781fd91db3744fcd", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -100,7 +100,6 @@ extern int h8300_initial_elimination_offset (int, int);\n extern int h8300_regs_ok_for_stm (int, rtx[]);\n extern int h8300_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int h8300_hard_regno_nregs (int, machine_mode);\n-extern int h8300_hard_regno_mode_ok (int, machine_mode);\n extern bool h8300_move_ok (rtx, rtx);\n \n struct cpp_reader;"}, {"sha": "a8b1cf2025a017a84675e29cabe8da5d0c1890fd", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -5889,10 +5889,10 @@ h8300_hard_regno_nregs (int regno ATTRIBUTE_UNUSED, machine_mode mode)\n   return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n-/* Worker function for HARD_REGNO_MODE_OK.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n-int\n-h8300_hard_regno_mode_ok (int regno, machine_mode mode)\n+static bool\n+h8300_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (TARGET_H8300)\n     /* If an even reg, then anything goes.  Otherwise the mode must be\n@@ -6101,6 +6101,9 @@ h8300_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK h8300_hard_regno_scratch_ok\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK h8300_hard_regno_mode_ok\n+\n #undef TARGET_LRA_P\n #define TARGET_LRA_P hook_bool_void_false\n "}, {"sha": "6a72e8704c8d6d63d6eb4419708f61ebeb33d112", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -239,13 +239,10 @@ extern const char * const *h8_reg_names;\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\\\n   h8300_hard_regno_nregs ((REGNO), (MODE))\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n-  h8300_hard_regno_mode_ok ((REGNO), (MODE))\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t  \\\n   ((MODE1) == (MODE2)\t\t\t\t\t\t\t  \\\n    || (((MODE1) == QImode || (MODE1) == HImode\t\t\t\t  \\"}, {"sha": "7ab149f0299084cfb5f81e2b86d1ae0a23e05469", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -167,7 +167,6 @@ extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx);\n-extern bool ix86_hard_regno_mode_ok (int, machine_mode);\n extern bool ix86_modes_tieable_p (machine_mode, machine_mode);\n extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n \t\t\t\t\t  machine_mode, int);"}, {"sha": "fd5f813a27c8f6d922ae50e3100c529c1d028d6b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -41296,11 +41296,10 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n   return 2;\n }\n \n-/* Return TRUE if hard register REGNO can hold a value of machine-mode\n-   MODE.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n-bool\n-ix86_hard_regno_mode_ok (int regno, machine_mode mode)\n+static bool\n+ix86_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   /* Flags and only flags can only hold CCmode values.  */\n   if (CC_REGNO_P (regno))\n@@ -53261,6 +53260,9 @@ ix86_run_selftests (void)\n #undef TARGET_NOCE_CONVERSION_PROFITABLE_P\n #define TARGET_NOCE_CONVERSION_PROFITABLE_P ix86_noce_conversion_profitable_p\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK ix86_hard_regno_mode_ok\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   ix86_hard_regno_call_part_clobbered"}, {"sha": "d3dbeded72bfb6310f4fd2a5600dc0b6ea206d29", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1181,15 +1181,10 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n   (TARGET_FMA4 && ((MODE) == V4SFmode || (MODE) == V2DFmode \\\n \t\t  || (MODE) == V8SFmode || (MODE) == V4DFmode))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n-   ix86_hard_regno_mode_ok ((REGNO), (MODE))\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n \n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   ix86_modes_tieable_p ((MODE1), (MODE2))"}, {"sha": "583614f1709825da0ca3c93677de89744281b4d1", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -335,6 +335,8 @@ static section * ia64_hpux_function_section (tree, enum node_frequency,\n static bool ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t\t      const unsigned char *sel);\n \n+static bool ia64_hard_regno_mode_ok (unsigned int, machine_mode);\n+\n #define MAX_VECT_LEN\t8\n \n struct expand_vec_perm_d\n@@ -653,6 +655,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 0\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK ia64_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Returns TRUE iff the target attribute indicated by ATTR_ID takes a plain\n@@ -4251,6 +4256,31 @@ ia64_hard_regno_rename_ok (int from, int to)\n   return 1;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+ia64_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  if (FR_REGNO_P (regno))\n+    return (GET_MODE_CLASS (mode) != MODE_CC\n+\t    && mode != BImode\n+\t    && mode != TFmode);\n+\n+  if (PR_REGNO_P (regno))\n+    return mode == BImode || GET_MODE_CLASS (mode) == MODE_CC;\n+\n+  if (GR_REGNO_P (regno))\n+    return mode != XFmode && mode != XCmode && mode != RFmode;\n+\n+  if (AR_REGNO_P (regno))\n+    return mode == DImode;\n+\n+  if (BR_REGNO_P (regno))\n+    return mode == DImode;\n+\n+  return false;\n+}\n+\n /* Target hook for assembling integer objects.  Handle word-sized\n    aligned objects and detect the cases when @fptr is needed.  */\n "}, {"sha": "4567cf661e5c2df0fb8be3ab6004271d3e6a150b", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -614,30 +614,13 @@ while (0)\n    : FR_REGNO_P (REGNO) && (MODE) == XCmode ? 2\t\t\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is permissible to store a value of mode\n-   MODE in hard register number REGNO (or in several registers starting with\n-   that one).  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n-  (FR_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n-     GET_MODE_CLASS (MODE) != MODE_CC &&\t\t\t\\\n-     (MODE) != BImode &&\t\t\t\t\t\\\n-     (MODE) != TFmode \t\t\t\t\t\t\\\n-   : PR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n-     (MODE) == BImode || GET_MODE_CLASS (MODE) == MODE_CC\t\\\n-   : GR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n-     (MODE) != XFmode && (MODE) != XCmode && (MODE) != RFmode\t\\\n-   : AR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n-   : BR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n-   : 0)\n-\n /* A C expression that is nonzero if it is desirable to choose register\n    allocation so as to avoid move instructions between a value of mode MODE1\n    and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R, MODE2)' are\n-   ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)' must be\n-   zero.  */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n /* Don't tie integer and FP modes, as that causes us to get integer registers\n    allocated for FP instructions.  XFmode only supported in FP registers so\n    we can't tie it with any other modes.  */"}, {"sha": "b57f4184db6cf6f1ee745efe0e6588bb75d71dd9", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -177,6 +177,7 @@ static rtx iq2000_libcall_value       (machine_mode, const_rtx);\n static void iq2000_print_operand      (FILE *, rtx, int);\n static void iq2000_print_operand_address (FILE *, machine_mode, rtx);\n static bool iq2000_print_operand_punct_valid_p (unsigned char code);\n+static bool iq2000_hard_regno_mode_ok (unsigned int, machine_mode);\n \n #undef  TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS \t\tiq2000_init_builtins\n@@ -254,6 +255,9 @@ static bool iq2000_print_operand_punct_valid_p (unsigned char code);\n #undef  TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT\t\tiq2000_trampoline_init\n \n+#undef  TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK\tiq2000_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return nonzero if we split the address into high and low parts.  */\n@@ -3485,4 +3489,14 @@ iq2000_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   emit_move_insn (mem, chain_value);\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+iq2000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return (REGNO_REG_CLASS (regno) == GR_REGS\n+\t  ? (regno & 1) == 0 || GET_MODE_SIZE (mode) <= 4\n+\t  : (regno & 1) == 0 || GET_MODE_SIZE (mode) == 4);\n+}\n+\n #include \"gt-iq2000.h\""}, {"sha": "2c22cfbb366ae56b6fbc7f9d59f56ac61daacd5a", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -165,11 +165,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n- ((REGNO_REG_CLASS (REGNO) == GR_REGS)\t\t\t\t\\\n-  ? ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 4     \t\\\n-  : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) == 4)\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n   ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\\\n     GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\"}, {"sha": "536944fe2f7db4c95d98f8e3db05cf4896551025", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -77,6 +77,7 @@ static rtx lm32_function_arg (cumulative_args_t cum,\n static void lm32_function_arg_advance (cumulative_args_t cum,\n \t\t\t\t       machine_mode mode,\n \t\t\t\t       const_tree type, bool named);\n+static bool lm32_hard_regno_mode_ok (unsigned int, machine_mode);\n \n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE lm32_option_override\n@@ -106,6 +107,8 @@ static void lm32_function_arg_advance (cumulative_args_t cum,\n #define TARGET_LRA_P hook_bool_void_false\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P lm32_legitimate_address_p\n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK lm32_hard_regno_mode_ok\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -1221,3 +1224,11 @@ lm32_move_ok (machine_mode mode, rtx operands[2]) {\n     return register_or_zero_operand (operands[1], mode);\n   return true;\n }\n+\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+lm32_hard_regno_mode_ok (unsigned int regno, machine_mode)\n+{\n+  return G_REG_P (regno);\n+}"}, {"sha": "c890db932c2f00905abf5dfdf42a713b836372ab", "filename": "gcc/config/lm32/lm32.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Flm32%2Flm32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Flm32%2Flm32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -166,8 +166,6 @@ do {                                                    \\\n #define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n     ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) G_REG_P(REGNO)\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)           \\\n (      GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n     && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\"}, {"sha": "de03b51fa744957bbe23f34354df56b9d4fe7dd6", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -50,7 +50,6 @@ void m32c_expand_neg_mulpsi3 (rtx *);\n int  m32c_expand_setmemhi (rtx *);\n bool m32c_matches_constraint_p (rtx, int);\n int  m32c_hard_regno_nregs (int, machine_mode);\n-int  m32c_hard_regno_ok (int, machine_mode);\n bool m32c_illegal_subreg_p (rtx);\n bool m32c_immd_dbl_mov (rtx *, machine_mode);\n rtx  m32c_incoming_return_addr_rtx (void);"}, {"sha": "39d1fd8018ccc1e5e029b4ec5fb7872af01ca01c", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -92,6 +92,8 @@ static rtx m32c_libcall_value (machine_mode, const_rtx);\n /* Returns true if an address is specified, else false.  */\n static bool m32c_get_pragma_address (const char *varname, unsigned *addr);\n \n+static bool m32c_hard_regno_mode_ok (unsigned int, machine_mode);\n+\n #define SYMBOL_FLAG_FUNCVEC_FUNCTION    (SYMBOL_FLAG_MACH_DEP << 0)\n \n #define streq(a,b) (strcmp ((a), (b)) == 0)\n@@ -370,7 +372,7 @@ class_can_hold_mode (reg_class_t rclass, machine_mode mode)\n       results[rclass][mode] = 1;\n       for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n \tif (in_hard_reg_set_p (reg_class_contents[(int) rclass], mode, r)\n-\t    && HARD_REGNO_MODE_OK (r, mode))\n+\t    && m32c_hard_regno_mode_ok (r, mode))\n \t  {\n \t    results[rclass][mode] = 2;\n \t    break;\n@@ -573,10 +575,10 @@ m32c_hard_regno_nregs (int regno, machine_mode mode)\n   return rv ? rv : 1;\n }\n \n-/* Implements HARD_REGNO_MODE_OK.  The above function does the work\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  The above function does the work\n    already; just test its return value.  */\n-int\n-m32c_hard_regno_ok (int regno, machine_mode mode)\n+static bool\n+m32c_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   return m32c_hard_regno_nregs_1 (regno, mode) != 0;\n }\n@@ -815,7 +817,7 @@ m32c_cannot_change_mode_class (machine_mode from,\n      can't allow the change.  */\n   for (rn = 0; rn < FIRST_PSEUDO_REGISTER; rn++)\n     if (class_contents[rclass][0] & (1 << rn))\n-      if (! m32c_hard_regno_ok (rn, to))\n+      if (! m32c_hard_regno_mode_ok (rn, to))\n \treturn 1;\n \n   if (to == QImode)\n@@ -4487,6 +4489,9 @@ m32c_output_compare (rtx_insn *insn, rtx *operands)\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED hook_bool_void_true\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK m32c_hard_regno_mode_ok\n+\n /* The Global `targetm' Variable. */\n \n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "0561df320ee22fe65f8795b533e6593bc22ab464", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -256,7 +256,6 @@ machine_function;\n /* How Values Fit in Registers */\n \n #define HARD_REGNO_NREGS(R,M) m32c_hard_regno_nregs (R, M)\n-#define HARD_REGNO_MODE_OK(R,M) m32c_hard_regno_ok (R, M)\n #define MODES_TIEABLE_P(M1,M2) m32c_modes_tieable_p (M1, M2)\n #define AVOID_CCMODE_COPIES\n "}, {"sha": "44736ed4b29fb24634db1d95615df2b37fb165c1", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -102,6 +102,7 @@ static void m32r_conditional_register_usage (void);\n static void m32r_trampoline_init (rtx, tree, rtx);\n static bool m32r_legitimate_constant_p (machine_mode, rtx);\n static bool m32r_attribute_identifier (const_tree);\n+static bool m32r_hard_regno_mode_ok (unsigned int, machine_mode);\n \f\n /* M32R specific attributes.  */\n \n@@ -209,6 +210,9 @@ static const struct attribute_spec m32r_attribute_table[] =\n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P m32r_legitimate_constant_p\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK m32r_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Called by m32r_option_override to initialize various things.  */\n@@ -270,14 +274,14 @@ enum m32r_mode_class\n \n /* Value is 1 if register/mode pair is acceptable on arc.  */\n \n-const unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] =\n+static const unsigned int m32r_hard_regno_modes[FIRST_PSEUDO_REGISTER] =\n {\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, S_MODES, S_MODES, S_MODES,\n   S_MODES, C_MODES, A_MODES, A_MODES\n };\n \n-unsigned int m32r_mode_class [NUM_MACHINE_MODES];\n+static unsigned int m32r_mode_class [NUM_MACHINE_MODES];\n \n enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n@@ -2747,6 +2751,14 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n     }\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+m32r_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return (m32r_hard_regno_modes[regno] & m32r_mode_class[mode]) != 0;\n+}\n+\n /* Return true if using NEW_REG in place of OLD_REG is ok.  */\n \n int"}, {"sha": "5f74f7f4a37c0fad1a2b08430fb6ef4c485f83be", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -396,19 +396,13 @@\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-extern const unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n-extern unsigned int m32r_mode_class[];\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((m32r_hard_regno_mode_ok[REGNO] & m32r_mode_class[MODE]) != 0)\n-\n /* A C expression that is nonzero if it is desirable to choose\n    register allocation so as to avoid move instructions between a\n    value of mode MODE1 and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n-   MODE2)' must be zero.  */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n \n /* Tie QI/HI/SI modes together.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \t\t\\"}, {"sha": "cdd6798c6608d42b7e6bf15ad20dd0ea9ab52eab", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -86,7 +86,6 @@ extern enum attr_op_mem m68k_sched_attr_op_mem (rtx_insn *);\n \n #endif /* RTX_CODE */\n \n-extern bool m68k_regno_mode_ok (int, machine_mode);\n extern enum reg_class m68k_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   machine_mode, rtx);\n extern enum reg_class m68k_preferred_reload_class (rtx, enum reg_class);"}, {"sha": "f28955ba87c2f93ac27db6d2ac6274ff035ad897", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -187,6 +187,7 @@ static bool m68k_output_addr_const_extra (FILE *, rtx);\n static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n static enum flt_eval_method\n m68k_excess_precision (enum excess_precision_type);\n+static bool m68k_hard_regno_mode_ok (unsigned int, machine_mode);\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -334,6 +335,9 @@ m68k_excess_precision (enum excess_precision_type);\n #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 128\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK m68k_hard_regno_mode_ok\n+\n static const struct attribute_spec m68k_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n@@ -5170,12 +5174,12 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n-/* Value is true if hard register REGNO can hold a value of machine-mode\n-   MODE.  On the 68000, we let the cpu registers can hold any mode, but\n-   restrict the 68881 registers to floating-point modes.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  On the 68000, we let the cpu\n+   registers can hold any mode, but restrict the 68881 registers to\n+   floating-point modes.  */\n \n-bool\n-m68k_regno_mode_ok (int regno, machine_mode mode)\n+static bool\n+m68k_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (DATA_REGNO_P (regno))\n     {"}, {"sha": "2c49dde0c23fbb4b5558e86efbc1fa7ecaab4da2", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -394,9 +394,6 @@ along with GCC; see the file COPYING3.  If not see\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   m68k_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  m68k_regno_mode_ok ((REGNO), (MODE))\n-\n #define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \\\n   m68k_secondary_reload_class (CLASS, MODE, X)\n "}, {"sha": "69fa798b666a846da80fd02a792733d3d3feb26e", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -144,6 +144,7 @@ static void       mcore_option_override\t\t(void);\n static bool       mcore_legitimate_constant_p   (machine_mode, rtx);\n static bool\t  mcore_legitimate_address_p\t(machine_mode, rtx, bool,\n \t\t\t\t\t\t addr_space_t);\n+static bool\t  mcore_hard_regno_mode_ok\t(unsigned int, machine_mode);\n \f\n /* MCore specific attributes.  */\n \n@@ -240,6 +241,9 @@ static const struct attribute_spec mcore_attribute_table[] =\n #undef TARGET_WARN_FUNC_RETURN\n #define TARGET_WARN_FUNC_RETURN mcore_warn_func_return\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK mcore_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Adjust the stack and return the number of bytes taken to do it.  */\n@@ -3260,3 +3264,14 @@ mcore_legitimate_address_p (machine_mode mode, rtx x, bool strict_p,\n   return false;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  We may keep double values in\n+   even registers.  */\n+\n+static bool\n+mcore_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  if (TARGET_8ALIGN && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return (regno & 1) == 0;\n+\n+  return regno < 18;\n+}"}, {"sha": "ef8f7f651cea39cacc7242163ffe0ec5f9d4dd89", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -248,15 +248,10 @@ extern char * mcore_current_function_name;\n #define HARD_REGNO_NREGS(REGNO, MODE)  \\\n    (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   We may keep double values in even registers.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)  \\\n-  ((TARGET_8ALIGN && GET_MODE_SIZE (MODE) > UNITS_PER_WORD) ? (((REGNO) & 1) == 0) : (REGNO < 18))\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n "}, {"sha": "75cb236cee9532015286b2675df72292b1f22b15", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -176,8 +176,8 @@ REAL_VALUE_TYPE dfhigh, dflow, sfhigh, sflow;\n \n /* Array giving truth value on whether or not a given hard register\n    can support a given mode.  */\n-char microblaze_hard_regno_mode_ok[(int)MAX_MACHINE_MODE]\n-\t\t\t\t  [FIRST_PSEUDO_REGISTER];\n+static char microblaze_hard_regno_mode_ok_p[(int)MAX_MACHINE_MODE]\n+\t\t\t\t\t   [FIRST_PSEUDO_REGISTER];\n \n /* Current frame information calculated by compute_frame_size.  */\n struct microblaze_frame_info current_frame_info;\n@@ -1841,11 +1841,25 @@ microblaze_option_override (void)\n \t  else\n \t    ok = 0;\n \n-\t  microblaze_hard_regno_mode_ok[(int) mode][regno] = ok;\n+\t  microblaze_hard_regno_mode_ok_p[(int) mode][regno] = ok;\n \t}\n     }\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  In 32 bit mode, require that\n+   DImode and DFmode be in even registers.  For DImode, this makes some\n+   of the insns easier to write, since you don't have to worry about a\n+   DImode value in registers 3 & 4, producing a result in 4 & 5.\n+\n+   To make the code simpler, the hook now just references an\n+   array built in override_options.  */\n+\n+static bool\n+microblaze_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return microblaze_hard_regno_mode_ok_p[mode][regno];\n+}\n+\n /* Return true if FUNC is an interrupt function as specified\n    by the \"interrupt_handler\" attribute.  */\n \n@@ -3873,6 +3887,9 @@ microblaze_machine_dependent_reorg (void)\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG microblaze_machine_dependent_reorg\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK microblaze_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-microblaze.h\""}, {"sha": "5a0ea0a55ff8aa9ab5f5c0043a865df7827b940c", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -295,20 +295,6 @@ extern enum pipeline_type microblaze_pipe;\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n \t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.  In 32 bit mode, require that DImode and DFmode be in even\n-   registers.  For DImode, this makes some of the insns easier to\n-   write, since you don't have to worry about a DImode value in\n-   registers 3 & 4, producing a result in 4 & 5.\n-\n-   To make the code simpler HARD_REGNO_MODE_OK now just references an\n-   array built in override_options.  Because machmodes.h is not yet\n-   included before this file is processed, the MODE bound can't be\n-   expressed here.  */\n-extern char microblaze_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-            microblaze_hard_regno_mode_ok[ (int)(MODE) ][ (REGNO)]\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n   ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n     GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\"}, {"sha": "0d1265effdab1404420f3c12c765991b6f161cd0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -494,7 +494,7 @@ static int mips_base_align_jumps; /* align_jumps */\n static int mips_base_align_functions; /* align_functions */\n \n /* Index [M][R] is true if register R is allowed to hold a value of mode M.  */\n-bool mips_hard_regno_mode_ok[(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n+static bool mips_hard_regno_mode_ok_p[MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n \n /* Index C is true if character C is a valid PRINT_OPERAND punctation\n    character.  */\n@@ -12725,7 +12725,7 @@ mips_can_use_return_insn (void)\n    The result of this function is cached in mips_hard_regno_mode_ok.  */\n \n static bool\n-mips_hard_regno_mode_ok_p (unsigned int regno, machine_mode mode)\n+mips_hard_regno_mode_ok_uncached (unsigned int regno, machine_mode mode)\n {\n   unsigned int size;\n   enum mode_class mclass;\n@@ -12830,6 +12830,14 @@ mips_hard_regno_mode_ok_p (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+mips_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return mips_hard_regno_mode_ok_p[mode][regno];\n+}\n+\n /* Return nonzero if register OLD_REG can be renamed to register NEW_REG.  */\n \n bool\n@@ -12912,14 +12920,14 @@ mips_class_max_nregs (enum reg_class rclass, machine_mode mode)\n   COPY_HARD_REG_SET (left, reg_class_contents[(int) rclass]);\n   if (hard_reg_set_intersect_p (left, reg_class_contents[(int) ST_REGS]))\n     {\n-      if (HARD_REGNO_MODE_OK (ST_REG_FIRST, mode))\n+      if (mips_hard_regno_mode_ok (ST_REG_FIRST, mode))\n \tsize = MIN (size, 4);\n \n       AND_COMPL_HARD_REG_SET (left, reg_class_contents[(int) ST_REGS]);\n     }\n   if (hard_reg_set_intersect_p (left, reg_class_contents[(int) FP_REGS]))\n     {\n-      if (HARD_REGNO_MODE_OK (FP_REG_FIRST, mode))\n+      if (mips_hard_regno_mode_ok (FP_REG_FIRST, mode))\n \t{\n \t  if (MSA_SUPPORTED_MODE_P (mode))\n \t    size = MIN (size, UNITS_PER_MSA_REG);\n@@ -20110,8 +20118,8 @@ mips_option_override (void)\n   /* Set up mips_hard_regno_mode_ok.  */\n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n     for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-      mips_hard_regno_mode_ok[mode][regno]\n-\t= mips_hard_regno_mode_ok_p (regno, (machine_mode) mode);\n+      mips_hard_regno_mode_ok_p[mode][regno]\n+\t= mips_hard_regno_mode_ok_uncached (regno, (machine_mode) mode);\n \n   /* Function to allocate machine-dependent function status.  */\n   init_machine_status = &mips_init_machine_status;\n@@ -22578,6 +22586,9 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK mips_hard_regno_scratch_ok\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK mips_hard_regno_mode_ok\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   mips_hard_regno_call_part_clobbered"}, {"sha": "b6a6740d2f5070634207d669a437c0a7c6f51474", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1961,9 +1961,6 @@ FP_ASM_SPEC \"\\\n \n #define HARD_REGNO_NREGS(REGNO, MODE) mips_hard_regno_nregs (REGNO, MODE)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  mips_hard_regno_mode_ok[ (int)(MODE) ][ (REGNO) ]\n-\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG)\t\t\t\t\\\n   mips_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \n@@ -3214,7 +3211,6 @@ struct mips_asm_switch {\n };\n \n extern const enum reg_class mips_regno_to_class[];\n-extern bool mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n extern const char *current_function_file; /* filename current function is in */\n extern int num_source_filenames;\t/* current .file # */\n extern struct mips_asm_switch mips_noreorder;"}, {"sha": "fc0589238b759075e99ae2d0d8927eaae1189dea", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -386,8 +386,6 @@ struct GTY(()) machine_function\n    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \t\\\n     / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n /* Note that no register can really be accessed in single-float mode, so\n    we *can* say 1 here.  FIXME:  Will TRT happen for single-float, or do\n    we have to punt to libgcc1.asm?  */"}, {"sha": "439092b031ce8d3674307e0157e08752838ad155", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -25,7 +25,6 @@ extern rtx   mn10300_legitimize_reload_address (rtx, machine_mode,\n \t\t\t\t\t\tint, int, int);\n extern bool  mn10300_function_value_regno_p (const unsigned int);\n extern unsigned int   mn10300_get_live_callee_saved_regs (unsigned int *);\n-extern bool  mn10300_hard_regno_mode_ok (unsigned int, machine_mode);\n extern bool  mn10300_modes_tieable (machine_mode, machine_mode);\n extern const char *mn10300_output_add (rtx[3], bool);\n extern void  mn10300_print_operand (FILE *, rtx, int);"}, {"sha": "738f04c82b40629d9bf9d6badb9ed3dc5522201b", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2626,7 +2626,9 @@ mn10300_can_output_mi_thunk (const_tree    thunk_fndecl ATTRIBUTE_UNUSED,\n   return true;\n }\n \n-bool\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n mn10300_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (REGNO_REG_CLASS (regno) == FP_REGS\n@@ -3425,4 +3427,7 @@ mn10300_reorg (void)\n #undef  TARGET_FLAGS_REGNUM\n #define TARGET_FLAGS_REGNUM  CC_REG\n \n+#undef  TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK mn10300_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "b669fe700554869f03596a23f609905d23d2250c", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -233,15 +233,10 @@ extern enum processor_type mn10300_tune_cpu;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  mn10300_hard_regno_mode_ok ((REGNO), (MODE))\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   mn10300_modes_tieable ((MODE1), (MODE2))\n "}, {"sha": "09a720f513880eb0dee6b64fdf156f3cbdec63bb", "filename": "gcc/config/moxie/moxie.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -171,12 +171,6 @@ enum reg_class\n /* We can't copy to or from our CC register. */\n #define AVOID_CCMODE_COPIES 1\n \n-/* A C expression that is nonzero if it is permissible to store a\n-   value of mode MODE in hard register number REGNO (or in several\n-   registers starting with that one).  All gstore registers are \n-   equivalent, so we can set this to 1.  */\n-#define HARD_REGNO_MODE_OK(R,M) 1\n-\n /* A C expression whose value is a register class containing hard\n    register REGNO.  */\n #define REGNO_REG_CLASS(R) ((R < MOXIE_PC) ? GENERAL_REGS :\t\t\\"}, {"sha": "7935088c78afb81e5705275ccc217ef8f186091f", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -29,7 +29,6 @@ void\tmsp430_expand_helper (rtx *operands, const char *, bool);\n void\tmsp430_expand_prologue (void);\n const char * msp430x_extendhisi (rtx *);\n void\tmsp430_fixup_compare_operands (machine_mode, rtx *);\n-int\tmsp430_hard_regno_mode_ok (int, machine_mode);\n int\tmsp430_hard_regno_nregs (int, machine_mode);\n int\tmsp430_hard_regno_nregs_has_padding (int, machine_mode);\n int\tmsp430_hard_regno_nregs_with_padding (int, machine_mode);"}, {"sha": "eb92c488d6a079787adf1199a7ebc0e1b3ce17d5", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -933,12 +933,14 @@ msp430_hard_regno_nregs_with_padding (int regno ATTRIBUTE_UNUSED,\n   return msp430_hard_regno_nregs (regno, mode);\n }\n \n-/* Implements HARD_REGNO_MODE_OK.  */\n-int\n-msp430_hard_regno_mode_ok (int regno ATTRIBUTE_UNUSED,\n-\t\t\t   machine_mode mode)\n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK msp430_hard_regno_mode_ok\n+\n+static bool\n+msp430_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n-  return regno <= (ARG_POINTER_REGNUM - msp430_hard_regno_nregs (regno, mode));\n+  return regno <= (ARG_POINTER_REGNUM\n+\t\t   - (unsigned int) msp430_hard_regno_nregs (regno, mode));\n }\n \n /* Implements MODES_TIEABLE_P.  */"}, {"sha": "86cef2cbb0488caeab731853f3fc5cb5be80b963", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -335,9 +335,6 @@ typedef struct\n #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n   msp430_hard_regno_nregs (REGNO, MODE)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n-  msp430_hard_regno_mode_ok (REGNO, MODE)\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n   msp430_modes_tieable_p (MODE1, MODE2)\n \f"}, {"sha": "741e874105d87a674cdfc150cb8246a6d36ccb2e", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -31,7 +31,6 @@ extern void nds32_init_expanders (void);\n /* -- How Values Fit in Registers.  */\n \n extern int nds32_hard_regno_nregs (int, machine_mode);\n-extern int nds32_hard_regno_mode_ok (int, machine_mode);\n \n \f\n /* Register Classes.  */"}, {"sha": "defd723f775711c52631e364663912134628b1e5", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2753,17 +2753,21 @@ nds32_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,\n   return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n }\n \n-int\n-nds32_hard_regno_mode_ok (int regno, machine_mode mode)\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+nds32_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   /* Restrict double-word quantities to even register pairs.  */\n   if (HARD_REGNO_NREGS (regno, mode) == 1\n       || !((regno) & 1))\n-    return 1;\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK nds32_hard_regno_mode_ok\n \f\n /* Register Classes.  */\n "}, {"sha": "274d2a74b893c6bb23b523a94c1a0ee8f6ad6149", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -600,10 +600,6 @@ enum nds32_builtins\n    reg \"regno\" for holding a value of mode \"mode\".  */\n #define HARD_REGNO_NREGS(regno, mode) nds32_hard_regno_nregs (regno, mode)\n \n-/* Value is 1 if hard register \"regno\" can hold a value\n-   of machine-mode \"mode\".  */\n-#define HARD_REGNO_MODE_OK(regno, mode) nds32_hard_regno_mode_ok (regno, mode)\n-\n /* A C expression that is nonzero if a value of mode1\n    is accessible in mode2 without copying.\n    Define this macro to return nonzero in as many cases as possible"}, {"sha": "adbf56258e77189ddc71b119c05746063f0f2b88", "filename": "gcc/config/nios2/nios2.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnios2%2Fnios2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnios2%2Fnios2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -173,7 +173,6 @@\n   }\n \n #define MODES_TIEABLE_P(MODE1, MODE2) 1\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n "}, {"sha": "fea56d8e6eef18ada1b29bb24d511e94c699f51a", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -99,8 +99,6 @@\n   ((void)(REG), (void)(MODE), 1)\n #define CANNOT_CHANGE_MODE_CLASS(M1, M2, CLS)\t\\\n   ((void)(M1), (void)(M2), (void)(CLS), true)\n-#define HARD_REGNO_MODE_OK(REG, MODE)\t\t\\\n-     ((void)(REG), (void)(MODE), true)\n \n /* Register Classes.  */\n enum reg_class             {  NO_REGS,    ALL_REGS,\tLIM_REG_CLASSES };"}, {"sha": "c3bc01e4a54dafcbfdf122f1a9ec2afcdb9e48e2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -198,6 +198,7 @@ static unsigned int pa_section_type_flags (tree, const char *, int);\n static bool pa_legitimate_address_p (machine_mode, rtx, bool);\n static bool pa_callee_copies (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n+static bool pa_hard_regno_mode_ok (unsigned int, machine_mode);\n \n /* The following extra sections are only used for SOM.  */\n static GTY(()) section *som_readonly_data_section;\n@@ -404,6 +405,9 @@ static size_t n_deferred_plabels = 0;\n #undef TARGET_LRA_P\n #define TARGET_LRA_P hook_bool_void_false\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK pa_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse the -mfixed-range= option string.  */\n@@ -9998,7 +10002,7 @@ pa_cannot_change_mode_class (machine_mode from, machine_mode to,\n   if (MAYBE_FP_REG_CLASS_P (rclass))\n     return true;\n \n-  /* HARD_REGNO_MODE_OK places modes with sizes larger than a word\n+  /* TARGET_HARD_REGNO_MODE_OK places modes with sizes larger than a word\n      in specific sets of registers.  Thus, we cannot allow changing\n      to a larger mode when it's larger than a word.  */\n   if (GET_MODE_SIZE (to) > UNITS_PER_WORD\n@@ -10010,13 +10014,13 @@ pa_cannot_change_mode_class (machine_mode from, machine_mode to,\n \n /* Returns TRUE if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be FALSE for correct output.\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be FALSE for correct output.\n    \n    We should return FALSE for QImode and HImode because these modes\n    are not ok in the floating-point registers.  However, this prevents\n    tieing these modes to SImode and DImode in the general registers.\n-   So, this isn't a good idea.  We rely on HARD_REGNO_MODE_OK and\n+   So, this isn't a good idea.  We rely on TARGET_HARD_REGNO_MODE_OK and\n    CANNOT_CHANGE_MODE_CLASS to prevent these modes from being used\n    in the floating-point registers.  */\n \n@@ -10756,4 +10760,12 @@ pa_callee_copies (cumulative_args_t cum ATTRIBUTE_UNUSED,\n   return !TARGET_CALLER_COPIES;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+pa_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return PA_HARD_REGNO_MODE_OK (regno, mode);\n+}\n+\n #include \"gt-pa.h\""}, {"sha": "4ae0597ff8ba6b8dbc35756fb0284a17626f9cb9", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -324,10 +324,10 @@ typedef struct GTY(()) machine_function\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+/* Value is 1 if it is a good idea to tie two pseudo registers when one\n+   has mode MODE1 and one has mode MODE2.\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   pa_modes_tieable_p (MODE1, MODE2)\n "}, {"sha": "bb7b9abfb1f26e9453a688a37f4d413d42c57ad5", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -206,7 +206,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    supported under HP-UX using libcalls.  Since TFmode values are passed\n    by reference, they never need to be loaded into the floating-point\n    registers.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+#define PA_HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n    : (REGNO) == 88 ? SCALAR_INT_MODE_P (MODE)\t\t\t\t\\\n    : !TARGET_PA_11 && FP_REGNO_P (REGNO)\t\t\t\t\\"}, {"sha": "ffbcb446a4164f9e3abfadbcbcfb9d02d4505b18", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -149,7 +149,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n    force this to be an even register if it cannot hold the full mode.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+#define PA_HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0\t\t\t\t\t\t\t\t\\\n    ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\t\t\\\n    : (REGNO) == 60 ? SCALAR_INT_MODE_P (MODE)\t\t\t\t\\"}, {"sha": "d8fe00cd71bb7701774789db2a63129e081e75fc", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -235,6 +235,9 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n \n #undef  TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P pdp11_scalar_mode_supported_p\n+\n+#undef  TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK pdp11_hard_regno_mode_ok\n \f\n /* A helper function to determine if REGNO should be saved in the\n    current function's stack frame.  */\n@@ -1925,4 +1928,23 @@ pdp11_branch_cost ()\n   return (TARGET_BRANCH_CHEAP ? 0 : 1);\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  On the pdp, the cpu registers\n+   can hold any mode other than float (because otherwise we may end up\n+   being asked to move from CPU to FPU register, which isn't a valid\n+   operation on the PDP11).  For CPU registers, check alignment.\n+\n+   FPU accepts SF and DF but actually holds a DF - simplifies life!  */\n+\n+static bool\n+pdp11_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  if (regno <= PC_REGNUM)\n+    return (GET_MODE_BITSIZE (mode) <= 16\n+\t    || (GET_MODE_BITSIZE (mode) >= 32\n+\t\t&& !(regno & 1)\n+\t\t&& !FLOAT_MODE_P (mode)));\n+\n+  return FLOAT_MODE_P (mode);\n+}\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "6314702e208af55c3b6d3b10043d774d34b8d36e", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -176,26 +176,10 @@ extern const struct real_format pdp11_d_format;\n     :1)\n     \n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the pdp, the cpu registers can hold any mode other than float\n-   (because otherwise we may end up being asked to move from CPU to FPU\n-   register, which isn't a valid operation on the PDP11).\n-   For CPU registers, check alignment.\n-\n-   FPU accepts SF and DF but actually holds a DF - simplifies life!\n-*/\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-(((REGNO) <= PC_REGNUM)?\t\t\t\t\\\n-  ((GET_MODE_BITSIZE(MODE) <= 16) \t\t\t\\\n-   || (GET_MODE_BITSIZE(MODE) >= 32 &&      \t\t\\\n-       !((REGNO) & 1) && !FLOAT_MODE_P (MODE)))\t\t\\\n-  :FLOAT_MODE_P (MODE))\n-    \n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) 0\n \n /* Specify the registers used for certain standard purposes."}, {"sha": "0f3e492a8a1073d2152f4aad3455ab6388624243", "filename": "gcc/config/powerpcspe/powerpcspe-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -254,7 +254,6 @@ const char * rs6000_xcoff_strip_dollar (const char *);\n \n void rs6000_final_prescan_insn (rtx_insn *, rtx *operand, int num_operands);\n \n-extern bool rs6000_hard_regno_mode_ok_p[][FIRST_PSEUDO_REGISTER];\n extern unsigned char rs6000_class_max_nregs[][LIM_REG_CLASSES];\n extern unsigned char rs6000_hard_regno_nregs[][FIRST_PSEUDO_REGISTER];\n "}, {"sha": "67021f62899269580d4d7989c4e1ce4091bb4c31", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -210,7 +210,8 @@ static bool rs6000_returns_struct;\n #endif\n \n /* Value is TRUE if register/mode pair is acceptable.  */\n-bool rs6000_hard_regno_mode_ok_p[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n+static bool rs6000_hard_regno_mode_ok_p\n+  [NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n \n /* Maximum number of registers needed for a given register class and mode.  */\n unsigned char rs6000_class_max_nregs[NUM_MACHINE_MODES][LIM_REG_CLASSES];\n@@ -1972,6 +1973,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK rs6000_hard_regno_mode_ok\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   rs6000_hard_regno_call_part_clobbered\n@@ -2060,7 +2064,7 @@ rs6000_hard_regno_nregs_internal (int regno, machine_mode mode)\n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n    MODE.  */\n static int\n-rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n+rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n {\n   int last_regno = regno + rs6000_hard_regno_nregs[mode][regno] - 1;\n \n@@ -2160,6 +2164,14 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+rs6000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return rs6000_hard_regno_mode_ok_p[mode][regno];\n+}\n+\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n@@ -3684,10 +3696,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_hard_regno_nregs[m][r]\n \t= rs6000_hard_regno_nregs_internal (r, (machine_mode)m);\n \n-  /* Precalculate HARD_REGNO_MODE_OK.  */\n+  /* Precalculate TARGET_HARD_REGNO_MODE_OK.  */\n   for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-      if (rs6000_hard_regno_mode_ok (r, (machine_mode)m))\n+      if (rs6000_hard_regno_mode_ok_uncached (r, (machine_mode)m))\n \trs6000_hard_regno_mode_ok_p[m][r] = true;\n \n   /* Precalculate CLASS_MAX_NREGS sizes.  */"}, {"sha": "75d59f419fe0e435acc320617fb8e3843a8cf6bc", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1330,15 +1330,10 @@ enum data_align { align_abi, align_opt, align_both };\n #define PAIRED_VECTOR_MODE(MODE)        \\\n          ((MODE) == V2SFmode)            \n \n-/* Value is TRUE if hard register REGNO can hold a value of\n-   machine-mode MODE.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  rs6000_hard_regno_mode_ok_p[(int)(MODE)][REGNO]\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.\n \n    PTImode cannot tie with other modes because PTImode is restricted to even\n    GPR registers, and TImode can go in any GPR as well as VSX registers (PR"}, {"sha": "0d3c21ea9e05adbb3586f28a2fb27b65c92579ac", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -39,7 +39,6 @@ enum riscv_symbol_type {\n extern enum riscv_symbol_type riscv_classify_symbolic_expression (rtx);\n extern bool riscv_symbolic_constant_p (rtx, enum riscv_symbol_type *);\n extern int riscv_regno_mode_ok_for_base_p (int, machine_mode, bool);\n-extern bool riscv_hard_regno_mode_ok_p (unsigned int, machine_mode);\n extern int riscv_address_insns (rtx, machine_mode, bool);\n extern int riscv_const_insns (rtx);\n extern int riscv_split_const_insns (rtx);"}, {"sha": "defe8f2ba09e8c6e73a8aa2c4bff13c8a032e103", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -3519,10 +3519,10 @@ riscv_register_move_cost (machine_mode mode,\n   return SECONDARY_MEMORY_NEEDED (from, to, mode) ? 8 : 2;\n }\n \n-/* Return true if register REGNO can store a value of mode MODE.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n-bool\n-riscv_hard_regno_mode_ok_p (unsigned int regno, machine_mode mode)\n+static bool\n+riscv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   unsigned int nregs = riscv_hard_regno_nregs (regno, mode);\n \n@@ -4083,6 +4083,9 @@ riscv_cannot_copy_insn_p (rtx_insn *insn)\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN riscv_expand_builtin\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK riscv_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-riscv.h\""}, {"sha": "6f07b541893866ec897dad0a74b115312287a1c7", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -296,9 +296,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #define HARD_REGNO_NREGS(REGNO, MODE) riscv_hard_regno_nregs (REGNO, MODE)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  riscv_hard_regno_mode_ok_p (REGNO, MODE)\n-\n /* Don't allow floating-point modes to be tied, since type punning of\n    single-precision and double-precision is implementation defined.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n@@ -864,7 +861,6 @@ while (0)\n \n #ifndef USED_FOR_TARGET\n extern const enum reg_class riscv_regno_to_class[];\n-extern bool riscv_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n extern bool riscv_slow_unaligned_access;\n #endif\n "}, {"sha": "569146a6219f3c8bca7178a27d40b31f62c1ed18", "filename": "gcc/config/rl78/rl78-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -29,7 +29,6 @@ void\t\trl78_expand_eh_epilogue (rtx);\n void\t\trl78_expand_epilogue (void);\n void\t\trl78_expand_prologue (void);\n int\t\trl78_far_p (rtx x);\n-int\t\trl78_hard_regno_mode_ok (int, machine_mode);\n int\t\trl78_hard_regno_nregs (int, machine_mode);\n bool\t\trl78_hl_b_c_addr_p (rtx);\n int\t\trl78_initial_elimination_offset (int, int);"}, {"sha": "8dd593e5b1a4d9e2684b2e9d14a9d78c76d8946b", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -459,34 +459,36 @@ rl78_hard_regno_nregs (int regno, machine_mode mode)\n   return ((GET_MODE_SIZE (mode) + rs - 1) / rs);\n }\n \n-/* Implements HARD_REGNO_MODE_OK.  */\n-int\n-rl78_hard_regno_mode_ok (int regno, machine_mode mode)\n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK rl78_hard_regno_mode_ok\n+\n+static bool\n+rl78_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   int s = GET_MODE_SIZE (mode);\n \n   if (s < 1)\n-    return 0;\n+    return false;\n   /* These are not to be used by gcc.  */\n   if (regno == 23 || regno == ES_REG || regno == CS_REG)\n-    return 0;\n+    return false;\n   /* $fp can always be accessed as a 16-bit value.  */\n   if (regno == FP_REG && s == 2)\n-    return 1;\n+    return true;\n   if (regno < SP_REG)\n     {\n       /* Since a reg-reg move is really a reg-mem move, we must\n \t enforce alignment.  */\n       if (s > 1 && (regno % 2))\n-\treturn 0;\n-      return 1;\n+\treturn false;\n+      return true;\n     }\n   if (s == CC_REGNUM)\n     return (mode == BImode);\n   /* All other registers must be accessed in their natural sizes.  */\n   if (s == register_sizes [regno])\n-    return 1;\n-  return 0;\n+    return true;\n+  return false;\n }\n \n /* Simplify_gen_subreg() doesn't handle memory references the way we"}, {"sha": "18df6658e59728c330f4600bd6b04388da36ced8", "filename": "gcc/config/rl78/rl78.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -410,9 +410,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n   rl78_hard_regno_nregs (REGNO, MODE)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n-  rl78_hard_regno_mode_ok (REGNO, MODE)\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n   (   (   GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\t\\\n        || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\"}, {"sha": "95fb3ad3149dfcb937b6406c95974ae148830fec", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -255,7 +255,6 @@ const char * rs6000_xcoff_strip_dollar (const char *);\n \n void rs6000_final_prescan_insn (rtx_insn *, rtx *operand, int num_operands);\n \n-extern bool rs6000_hard_regno_mode_ok_p[][FIRST_PSEUDO_REGISTER];\n extern unsigned char rs6000_class_max_nregs[][LIM_REG_CLASSES];\n extern unsigned char rs6000_hard_regno_nregs[][FIRST_PSEUDO_REGISTER];\n "}, {"sha": "b9d7b55f7f54403606f5ed168ce1a652dfe9ad4c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -201,7 +201,8 @@ static bool rs6000_returns_struct;\n #endif\n \n /* Value is TRUE if register/mode pair is acceptable.  */\n-bool rs6000_hard_regno_mode_ok_p[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n+static bool rs6000_hard_regno_mode_ok_p\n+  [NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n \n /* Maximum number of registers needed for a given register class and mode.  */\n unsigned char rs6000_class_max_nregs[NUM_MACHINE_MODES][LIM_REG_CLASSES];\n@@ -1962,6 +1963,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_OPTION_FUNCTION_VERSIONS\n #define TARGET_OPTION_FUNCTION_VERSIONS common_function_versions\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK rs6000_hard_regno_mode_ok\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   rs6000_hard_regno_call_part_clobbered\n@@ -2034,7 +2038,7 @@ rs6000_hard_regno_nregs_internal (int regno, machine_mode mode)\n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n    MODE.  */\n static int\n-rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n+rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n {\n   int last_regno = regno + rs6000_hard_regno_nregs[mode][regno] - 1;\n \n@@ -2127,6 +2131,14 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+rs6000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return rs6000_hard_regno_mode_ok_p[mode][regno];\n+}\n+\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n@@ -3598,10 +3610,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_hard_regno_nregs[m][r]\n \t= rs6000_hard_regno_nregs_internal (r, (machine_mode)m);\n \n-  /* Precalculate HARD_REGNO_MODE_OK.  */\n+  /* Precalculate TARGET_HARD_REGNO_MODE_OK.  */\n   for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-      if (rs6000_hard_regno_mode_ok (r, (machine_mode)m))\n+      if (rs6000_hard_regno_mode_ok_uncached (r, (machine_mode)m))\n \trs6000_hard_regno_mode_ok_p[m][r] = true;\n \n   /* Precalculate CLASS_MAX_NREGS sizes.  */"}, {"sha": "90eaff5493ffc192900c485a4a9afdbd04e8fc7f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1258,15 +1258,10 @@ enum data_align { align_abi, align_opt, align_both };\n #define PAIRED_VECTOR_MODE(MODE)        \\\n          ((MODE) == V2SFmode)            \n \n-/* Value is TRUE if hard register REGNO can hold a value of\n-   machine-mode MODE.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  rs6000_hard_regno_mode_ok_p[(int)(MODE)][REGNO]\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.\n \n    PTImode cannot tie with other modes because PTImode is restricted to even\n    GPR registers, and TImode can go in any GPR as well as VSX registers (PR"}, {"sha": "de35419d8e8f9aa5310397943e473775633e7116", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -3434,6 +3434,13 @@ rx_atomic_sequence::~rx_atomic_sequence (void)\n     emit_insn (gen_mvtc (GEN_INT (CTRLREG_PSW), m_prev_psw_reg));\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+rx_hard_regno_mode_ok (unsigned int regno, machine_mode)\n+{\n+  return REGNO_REG_CLASS (regno) == GR_REGS;\n+}\n \f\n #undef  TARGET_NARROW_VOLATILE_BITFIELD\n #define TARGET_NARROW_VOLATILE_BITFIELD\t\trx_narrow_volatile_bitfield\n@@ -3588,6 +3595,9 @@ rx_atomic_sequence::~rx_atomic_sequence (void)\n #undef  TARGET_LRA_P\n #define TARGET_LRA_P \t\t\t\trx_enable_lra\n \n+#undef  TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK\t\trx_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rx.h\""}, {"sha": "67bfeb7272fa7d78dfddd052cf8e46f7d92efeb9", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -333,9 +333,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n \n #define HARD_REGNO_NREGS(REGNO, MODE)   CLASS_MAX_NREGS (0, MODE)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n-  (REGNO_REG_CLASS (REGNO) == GR_REGS)\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n   (   (   GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\t\\\n        || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\"}, {"sha": "dd6c0c1bf19b9940b6efc942c606c88de68ad0db", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -47,7 +47,6 @@ extern bool s390_can_use_simple_return_insn (void);\n extern bool s390_can_use_return_insn (void);\n extern void s390_function_profiler (FILE *, int);\n extern void s390_set_has_landing_pad_p (bool);\n-extern bool s390_hard_regno_mode_ok (unsigned int, machine_mode);\n extern bool s390_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int s390_class_max_nregs (enum reg_class, machine_mode);\n extern int s390_cannot_change_mode_class (machine_mode, machine_mode,"}, {"sha": "c7d255d70d8359b7eac420bb69763346999d14d9", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -87,6 +87,8 @@ along with GCC; see the file COPYING3.  If not see\n /* This file should be included last.  */\n #include \"target-def.h\"\n \n+static bool s390_hard_regno_mode_ok (unsigned int, machine_mode);\n+\n /* Remember the last target of s390_set_current_function.  */\n static GTY(()) tree s390_previous_fndecl;\n \n@@ -10386,9 +10388,9 @@ s390_optimize_nonescaping_tx (void)\n   return;\n }\n \n-/* Return true if it is legal to put a value with MODE into REGNO.  */\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n-bool\n+static bool\n s390_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (!TARGET_VX && VECTOR_NOFP_REGNO_P (regno))\n@@ -15961,6 +15963,9 @@ s390_asan_shadow_offset (void)\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK s390_hard_regno_scratch_ok\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK s390_hard_regno_mode_ok\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   s390_hard_regno_call_part_clobbered"}, {"sha": "43f6975ee192f5d06f2f4f900db3b980031d6c3b", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -499,9 +499,6 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n #define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n   s390_class_max_nregs (REGNO_REG_CLASS (REGNO), (MODE))\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)         \\\n-  s390_hard_regno_mode_ok ((REGNO), (MODE))\n-\n #define HARD_REGNO_RENAME_OK(FROM, TO)          \\\n   s390_hard_regno_rename_ok ((FROM), (TO))\n "}, {"sha": "b52860d18bc1fc4b986b7cd97593867d8c654db4", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -361,7 +361,6 @@ extern bool sh_loads_bankedreg_p (rtx);\n extern int sh2a_get_function_vector_number (rtx);\n extern bool sh2a_is_function_vector_call (rtx);\n extern void sh_fix_range (const char *);\n-extern bool sh_hard_regno_mode_ok (unsigned int, machine_mode);\n extern machine_mode sh_hard_regno_caller_save_mode (unsigned int, unsigned int,\n \t\t\t\t\t\t    machine_mode);\n extern bool sh_can_use_simple_return_p (void);"}, {"sha": "e9487f1812b21779045d2ef125545f14a4d3bd98", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -321,6 +321,7 @@ static bool sh_legitimate_combined_insn (rtx_insn* insn);\n static bool sh_fixed_condition_code_regs (unsigned int* p1, unsigned int* p2);\n \n static void sh_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n+static bool sh_hard_regno_mode_ok (unsigned int, machine_mode);\n \f\n static const struct attribute_spec sh_attribute_table[] =\n {\n@@ -641,6 +642,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM sh_cannot_force_const_mem_p\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK sh_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -10494,7 +10498,8 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   return target;\n }\n \n-/* Return true if hard register REGNO can hold a value of machine-mode MODE.\n+/* Implement TARGET_HARD_REGNO_MODE_OK.\n+\n    We can allow any mode in any general register.  The special registers\n    only allow SImode.  Don't allow any mode in the PR.\n \n@@ -10509,7 +10514,7 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n    We want to allow TImode FP regs so that when V4SFmode is loaded as TImode,\n    it won't be ferried through GP registers first.  */\n-bool\n+static bool\n sh_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (SPECIAL_REGISTER_P (regno))\n@@ -10569,7 +10574,7 @@ sh_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n }\n \n /* Specify the modes required to caller save a given hard regno.\n-   choose_hard_reg_mode chooses mode based on HARD_REGNO_MODE_OK\n+   choose_hard_reg_mode chooses mode based on TARGET_HARD_REGNO_MODE_OK\n    and returns ?Imode for float regs when sh_hard_regno_mode_ok\n    permits integer modes on them.  That makes LRA's split process\n    unhappy.  See PR55212."}, {"sha": "ac991af7bf03cb5f1125b25ff28dc7bcc445e78e", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -823,14 +823,10 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n     ? ((GET_MODE_SIZE (MODE) + (2*UNITS_PER_WORD - 1)) / (2*UNITS_PER_WORD)) \\\n     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n-  sh_hard_regno_mode_ok ((REGNO), (MODE))\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.\n    That's the case for xd registers: we don't hold SFmode values in\n    them, so we can't tie an SFmode pseudos with one in another\n    floating-point mode.  */"}, {"sha": "42a6851851b0554b923fc52033a6b0180244ea10", "filename": "gcc/config/sparc/constraints.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -157,10 +157,10 @@\n ;; register into the register class, which would not restrict things\n ;; at all.\n ;;\n-;; Using a combination of GENERAL_REGS and HARD_REGNO_MODE_OK is not a\n-;; full solution either.  In fact, even though IRA uses the macro\n-;; HARD_REGNO_MODE_OK to calculate which registers are prohibited from\n-;; use in certain modes, it still can allocate an odd hard register\n+;; Using a combination of GENERAL_REGS and TARGET_HARD_REGNO_MODE_OK is\n+;; not a full solution either.  In fact, even though IRA uses the macro\n+;; TARGET_HARD_REGNO_MODE_OK to calculate which registers are prohibited\n+;; from use in certain modes, it still can allocate an odd hard register\n ;; for DImode values.  This is due to how IRA populates the table\n ;; ira_useful_class_mode_regs[][].  It suffers from the same problem\n ;; as using a register class to describe this restriction.  Namely, it"}, {"sha": "159685d4226619c046b28073e6da3e029c711350", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -675,6 +675,8 @@ static scalar_int_mode sparc_cstore_mode (enum insn_code icode);\n static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n static bool sparc_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static unsigned int sparc_min_arithmetic_precision (void);\n+static bool sparc_hard_regno_mode_ok (unsigned int, machine_mode);\n+\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -899,6 +901,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK sparc_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Return the memory reference contained in X if any, zero otherwise.  */\n@@ -4974,7 +4979,7 @@ enum sparc_mode_class {\n    registers can hold double-word quantities in 32-bit mode.  */\n \n /* This points to either the 32-bit or the 64-bit version.  */\n-const int *hard_regno_mode_classes;\n+static const int *hard_regno_mode_classes;\n \n static const int hard_32bit_mode_classes[] = {\n   S_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n@@ -5026,7 +5031,7 @@ static const int hard_64bit_mode_classes[] = {\n   CC_MODES, 0, D_MODES\n };\n \n-int sparc_mode_class [NUM_MACHINE_MODES];\n+static int sparc_mode_class [NUM_MACHINE_MODES];\n \n enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n@@ -13122,10 +13127,22 @@ sparc_regmode_natural_size (machine_mode mode)\n   return size;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.\n+\n+   ??? Because of the funny way we pass parameters we should allow certain\n+   ??? types of float/complex values to be in integer registers during\n+   ??? RTL generation.  This only matters on arch32.  */\n+\n+static bool\n+sparc_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return (hard_regno_mode_classes[regno] & sparc_mode_class[mode]) != 0;\n+}\n+\n /* Return TRUE if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be FALSE for correct output.\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be FALSE for correct output.\n \n    For V9 we have to deal with the fact that only the lower 32 floating\n    point registers are 32-bit addressable.  */"}, {"sha": "b4c3dab6646a76b5e727bac6c35f67626cf12e92", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -768,17 +768,6 @@ extern enum cmodel sparc_cmodel;\n    macro too.  */\n #define REGMODE_NATURAL_SIZE(MODE) sparc_regmode_natural_size (MODE)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   See sparc.c for how we initialize this.  */\n-extern const int *hard_regno_mode_classes;\n-extern int sparc_mode_class[];\n-\n-/* ??? Because of the funny way we pass parameters we should allow certain\n-   ??? types of float/complex values to be in integer registers during\n-   ??? RTL generation.  This only matters on arch32.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((hard_regno_mode_classes[REGNO] & sparc_mode_class[MODE]) != 0)\n-\n /* Value is 1 if it is OK to rename a hard register FROM to another hard\n    register TO.  We cannot rename %g1 as it may be used before the save\n    register window instruction in the prologue.  */\n@@ -878,10 +867,10 @@ extern int sparc_mode_class[];\n \n    For v9 we must distinguish between the upper and lower floating point\n    registers because the upper ones can't hold SFmode values.\n-   HARD_REGNO_MODE_OK won't help here because reload assumes that register(s)\n-   satisfying a group need for a class will also satisfy a single need for\n-   that class.  EXTRA_FP_REGS is a bit of a misnomer as it covers all 64 fp\n-   regs.\n+   TARGET_HARD_REGNO_MODE_OK won't help here because reload assumes that\n+   register(s) satisfying a group need for a class will also satisfy a\n+   single need for that class.  EXTRA_FP_REGS is a bit of a misnomer as\n+   it covers all 64 fp regs.\n \n    It is important that one class contains all the general and all the standard\n    fp regs.  Otherwise find_reg() won't properly allocate int regs for moves,"}, {"sha": "b2e0121cd141da837a0ee8be54f790497c703168", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -176,8 +176,6 @@ extern GTY(()) int spu_tune;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n     ((GET_MODE_BITSIZE(MODE)+MAX_FIXED_MODE_SIZE-1)/MAX_FIXED_MODE_SIZE)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   (GET_MODE_BITSIZE (MODE1) <= MAX_FIXED_MODE_SIZE \\\n    && GET_MODE_BITSIZE (MODE2) <= MAX_FIXED_MODE_SIZE)"}, {"sha": "897d0e6f32c6b37076102105c9bd5eb80fd5e772", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2617,6 +2617,14 @@ xstormy16_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   const HOST_WIDE_INT size = int_size_in_bytes (type);\n   return (size == -1 || size > UNITS_PER_WORD * NUM_ARGUMENT_REGISTERS);\n }\n+\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+xstormy16_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return regno != 16 || mode == BImode;\n+}\n \f\n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n@@ -2694,6 +2702,9 @@ xstormy16_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT xstormy16_trampoline_init\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK xstormy16_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-stormy16.h\""}, {"sha": "5ce2f34ba4a7b134c9cc9f368d923494ac952125", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -145,15 +145,13 @@\n #define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) ((REGNO) != 16 || (MODE) == BImode)\n-\n /* A C expression that is nonzero if it is desirable to choose register\n    allocation so as to avoid move instructions between a value of mode MODE1\n    and a value of mode MODE2.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R, MODE2)' are\n-   ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)' must be\n-   zero.  */\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) ((MODE1) != BImode && (MODE2) != BImode)\n \n \f"}, {"sha": "d6793225cb6af52731db7f436ec8eab851c5e2b2", "filename": "gcc/config/tilegx/tilegx.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -162,8 +162,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)  1\n \n /* Register that holds an address into the text segment that can be"}, {"sha": "56186387d62ee98885d610a8c2b63a572e4b5918", "filename": "gcc/config/tilepro/tilepro.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -127,9 +127,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* All registers can hold all modes.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)  1\n \n /* Register that holds an address into the text segment that can be"}, {"sha": "4f932477648a1049068ab4832af852dd21299a7c", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -3247,6 +3247,14 @@ v850_gen_movdi (rtx * operands)\n   \n   return \"st.dw %1, %0\";\n }\n+\n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+v850_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return GET_MODE_SIZE (mode) <= 4 || ((regno & 1) == 0 && regno != 0);\n+}\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -3352,6 +3360,9 @@ v850_gen_movdi (rtx * operands)\n #undef  TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n \n+#undef  TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK v850_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-v850.h\""}, {"sha": "de00cfe2c85bac31ec2dcc7d3dd3bbf99d9a3a77", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -300,16 +300,10 @@ extern GTY(()) rtx v850_compare_op1;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n- ((GET_MODE_SIZE (MODE) <= 4) || (((REGNO) & 1) == 0 && (REGNO) != 0))\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   (MODE1 == MODE2 || (GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4))\n "}, {"sha": "c8831e2f91ab5def7ae22bdb20c7a00512ad4cb9", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -143,14 +143,10 @@ along with GCC; see the file COPYING3.  If not see\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the VAX, all registers can hold all modes.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)  1\n \n /* Specify the registers used for certain standard purposes."}, {"sha": "7d29f27c4947d745ce97e1a466516eb494c3b916", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -228,6 +228,8 @@ static void visium_init_libfuncs (void);\n \n static unsigned int visium_reorg (void);\n \n+static bool visium_hard_regno_mode_ok (unsigned int, machine_mode);\n+\n /* Setup the global target hooks structure.  */\n \n #undef  TARGET_MAX_ANCHOR_OFFSET\n@@ -339,6 +341,9 @@ static unsigned int visium_reorg (void);\n #undef TARGET_FLAGS_REGNUM\n #define TARGET_FLAGS_REGNUM FLAGS_REGNUM\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK visium_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n namespace {\n@@ -836,6 +841,26 @@ visium_hard_regno_rename_ok (unsigned int from ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.\n+\n+   Modes with sizes which cross from the one register class to the\n+   other cannot be allowed. Only single floats are allowed in the\n+   floating point registers, and only fixed point values in the EAM\n+   registers. */\n+\n+static bool\n+visium_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  if (GP_REGISTER_P (regno))\n+    return GP_REGISTER_P (regno + HARD_REGNO_NREGS (regno, mode) - 1);\n+\n+  if (FP_REGISTER_P (regno))\n+    return mode == SFmode || (mode == SImode && TARGET_FPU_IEEE);\n+\n+  return (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && HARD_REGNO_NREGS (regno, mode) == 1);\n+}\n+\n /* Return true if it is ok to do sibling call optimization for the specified\n    call expression EXP.  DECL will be the called function, or NULL if this\n    is an indirect call.  */"}, {"sha": "6538bff4600d89f19b1f21874a50725f6199fb78", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -573,34 +573,17 @@\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   visium_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \n-/*  `HARD_REGNO_MODE_OK (REGNO, MODE)'\n-\n-    A C expression that is nonzero if it is permissible to store a\n-    value of mode MODE in hard register number REGNO (or in several\n-    registers starting with that one). \n-\n-    Modes with sizes which cross from the one register class to the\n-    other cannot be allowed. Only single floats are allowed in the\n-    floating point registers, and only fixed point values in the EAM\n-    registers. */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)                         \\\n- (GP_REGISTER_P (REGNO) ?                                       \\\n-     GP_REGISTER_P (REGNO + HARD_REGNO_NREGS (REGNO, MODE) - 1) \\\n-  : FP_REGISTER_P (REGNO) ?                                     \\\n-     (MODE) == SFmode || ((MODE) == SImode && TARGET_FPU_IEEE)  \\\n-  : GET_MODE_CLASS (MODE) == MODE_INT                           \\\n-    && HARD_REGNO_NREGS (REGNO, MODE) == 1)\n-\n /* `MODES_TIEABLE_P (MODE1, MODE2)'\n \n    A C expression that is nonzero if a value of mode MODE1 is\n    accessible in mode MODE2 without copying.\n \n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are always the same for any R, then `MODES_TIEABLE_P\n-   (MODE1, MODE2)' should be nonzero.  If they differ for any R, you\n-   should define this macro to return zero unless some other mechanism\n-   ensures the accessibility of the value in a narrower mode.\n+   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n+   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are always the same for any R,\n+   then `MODES_TIEABLE_P (MODE1, MODE2)' should be nonzero.  If they\n+   differ for any R, you should define this macro to return zero unless\n+   some other mechanism ensures the accessibility of the value in a\n+   narrower mode.\n \n    You should define this macro to return nonzero in as many cases as\n    possible since doing so will allow GNU CC to perform better"}, {"sha": "31b0d49274ea5b77ad97f306818ee5b4c0c8a9aa", "filename": "gcc/config/visium/visium.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvisium%2Fvisium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fvisium%2Fvisium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.md?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2145,7 +2145,7 @@\n ;; mantissa) to a quiet NaN (-1). This is acceptable when the data to be\n ;; moved is in fact a floating-point number, but to avoid nasty surprises\n ;; integers must in general be kept out of the floating-point registers.\n-;; HARD_REGNO_MODE_OK thus only allows SFmode in these registers.\n+;; TARGET_HARD_REGNO_MODE_OK thus only allows SFmode in these registers.\n ;; However, since FTOI and ITOF use floating-point registers for both their\n ;; inputs and outputs, to use these instructions integers must transiently\n ;; occupy such registers. To disguise this from the compiler, UNSPECs are"}, {"sha": "1d5fbcac459fe394ef0dd476f78637eb26738d09", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -78,7 +78,8 @@ enum internal_test\n \n /* Array giving truth value on whether or not a given hard register\n    can support a given mode.  */\n-char xtensa_hard_regno_mode_ok[(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n+static char xtensa_hard_regno_mode_ok_p\n+  [(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n \n /* Largest block move to handle in-line.  */\n #define LARGEST_MOVE_RATIO 15\n@@ -177,6 +178,7 @@ static bool xtensa_member_type_forces_blk (const_tree,\n \t\t\t\t\t   machine_mode mode);\n \n static void xtensa_conditional_register_usage (void);\n+static bool xtensa_hard_regno_mode_ok (unsigned int, machine_mode);\n \n \f\n \n@@ -305,6 +307,9 @@ static void xtensa_conditional_register_usage (void);\n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE xtensa_conditional_register_usage\n \n+#undef TARGET_HARD_REGNO_MODE_OK\n+#define TARGET_HARD_REGNO_MODE_OK xtensa_hard_regno_mode_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -2217,7 +2222,7 @@ xtensa_option_override (void)\n \t  else\n \t    temp = FALSE;\n \n-\t  xtensa_hard_regno_mode_ok[(int) mode][regno] = temp;\n+\t  xtensa_hard_regno_mode_ok_p[(int) mode][regno] = temp;\n \t}\n     }\n \n@@ -2252,6 +2257,14 @@ xtensa_option_override (void)\n     }\n }\n \n+/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+\n+static bool\n+xtensa_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n+{\n+  return xtensa_hard_regno_mode_ok_p[mode][regno];\n+}\n+\n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand X.  X is an RTL\n    expression."}, {"sha": "2ec31ab596917d0f48233b1778199dc207662a4b", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -328,17 +328,10 @@ extern int leaf_function;\n \t((GET_MODE_SIZE (MODE) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG) : \\\n \t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.  */\n-extern char xtensa_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  xtensa_hard_regno_mode_ok[(int) (MODE)][(REGNO)]\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n   ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n     GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\"}, {"sha": "14aab9474bc214d2e07a4a7ba74abfabb65e7cbe", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -4731,7 +4731,7 @@ it is unsafe to call @code{gen_reg_rtx} to allocate a new pseudo.\n \n The constraints on a @samp{mov@var{m}} must permit moving any hard\n register to any other hard register provided that\n-@code{HARD_REGNO_MODE_OK} permits mode @var{m} in both registers and\n+@code{TARGET_HARD_REGNO_MODE_OK} permits mode @var{m} in both registers and\n @code{TARGET_REGISTER_MOVE_COST} applied to their classes returns a value\n of 2.\n \n@@ -4744,7 +4744,7 @@ point members.\n There may also be a need to support fixed point @samp{mov@var{m}}\n instructions in and out of floating point registers.  Unfortunately, I\n have forgotten why this was so, and I don't know whether it is still\n-true.  If @code{HARD_REGNO_MODE_OK} rejects fixed point values in\n+true.  If @code{TARGET_HARD_REGNO_MODE_OK} rejects fixed point values in\n floating point registers, then the constraints of the fixed point\n @samp{mov@var{m}} instructions must be designed to avoid ever trying to\n reload into a floating point register."}, {"sha": "35141acb6f0ce2081ecda038c79ccfed4bd12788", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2017,8 +2017,9 @@ consecutive registers are needed for a given mode.\n A C expression for the number of consecutive hard registers, starting\n at register number @var{regno}, required to hold a value of mode\n @var{mode}.  This macro must never return zero, even if a register\n-cannot hold the requested mode - indicate that with HARD_REGNO_MODE_OK\n-and/or CANNOT_CHANGE_MODE_CLASS instead.\n+cannot hold the requested mode - indicate that with\n+@code{TARGET_HARD_REGNO_MODE_OK} and/or @code{CANNOT_CHANGE_MODE_CLASS}\n+instead.\n \n On a machine where all registers are exactly one word, a suitable\n definition of this macro is\n@@ -2066,22 +2067,18 @@ happens for example on SPARC 64-bit where the natural size of\n floating-point registers is still 32-bit.\n @end defmac\n \n-@defmac HARD_REGNO_MODE_OK (@var{regno}, @var{mode})\n-A C expression that is nonzero if it is permissible to store a value\n+@deftypefn {Target Hook} bool TARGET_HARD_REGNO_MODE_OK (unsigned int @var{regno}, machine_mode @var{mode})\n+This hook returns true if it is permissible to store a value\n of mode @var{mode} in hard register number @var{regno} (or in several\n-registers starting with that one).  For a machine where all registers\n-are equivalent, a suitable definition is\n-\n-@smallexample\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-@end smallexample\n+registers starting with that one).  The default definition returns true\n+unconditionally.\n \n You need not include code to check for the numbers of fixed registers,\n because the allocation mechanism considers them to be always occupied.\n \n @cindex register pairs\n On some machines, double-precision values must be kept in even/odd\n-register pairs.  You can implement that by defining this macro to reject\n+register pairs.  You can implement that by defining this hook to reject\n odd register numbers for such modes.\n \n The minimum requirement for a mode to be OK in a register is that the\n@@ -2091,9 +2088,9 @@ value into the register and back out not alter it.\n \n Since the same instruction used to move @code{word_mode} will work for\n all narrower integer modes, it is not necessary on any machine for\n-@code{HARD_REGNO_MODE_OK} to distinguish between these modes, provided\n-you define patterns @samp{movhi}, etc., to take advantage of this.  This\n-is useful because of the interaction between @code{HARD_REGNO_MODE_OK}\n+this hook to distinguish between these modes, provided you define\n+patterns @samp{movhi}, etc., to take advantage of this.  This is\n+useful because of the interaction between @code{TARGET_HARD_REGNO_MODE_OK}\n and @code{MODES_TIEABLE_P}; it is very desirable for all integer modes\n to be tieable.\n \n@@ -2108,24 +2105,24 @@ On some machines, though, the converse is true: fixed-point machine\n modes may not go in floating registers.  This is true if the floating\n registers normalize any value stored in them, because storing a\n non-floating value there would garble it.  In this case,\n-@code{HARD_REGNO_MODE_OK} should reject fixed-point machine modes in\n+@code{TARGET_HARD_REGNO_MODE_OK} should reject fixed-point machine modes in\n floating registers.  But if the floating registers do not automatically\n normalize, if you can store any bit pattern in one and retrieve it\n unchanged without a trap, then any machine mode may go in a floating\n-register, so you can define this macro to say so.\n+register, so you can define this hook to say so.\n \n The primary significance of special floating registers is rather that\n they are the registers acceptable in floating point arithmetic\n instructions.  However, this is of no concern to\n-@code{HARD_REGNO_MODE_OK}.  You handle it by writing the proper\n+@code{TARGET_HARD_REGNO_MODE_OK}.  You handle it by writing the proper\n constraints for those instructions.\n \n On some machines, the floating registers are especially slow to access,\n so that it is better to store a value in a stack frame than in such a\n register if floating point arithmetic is not being done.  As long as the\n floating registers are not in class @code{GENERAL_REGS}, they will not\n be used unless some pattern's constraint asks for one.\n-@end defmac\n+@end deftypefn\n \n @defmac HARD_REGNO_RENAME_OK (@var{from}, @var{to})\n A C expression that is nonzero if it is OK to rename a hard register\n@@ -2142,9 +2139,9 @@ The default is always nonzero.\n A C expression that is nonzero if a value of mode\n @var{mode1} is accessible in mode @var{mode2} without copying.\n \n-If @code{HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\n-@code{HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same for\n-any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\n+If @code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\n+@code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same\n+for any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\n should be nonzero.  If they differ for any @var{r}, you should define\n this macro to return zero unless some other mechanism ensures the\n accessibility of the value in a narrower mode.\n@@ -2331,7 +2328,7 @@ When a value occupying several consecutive registers is expected in a\n certain class, all the registers used must belong to that class.\n Therefore, register classes cannot be used to enforce a requirement for\n a register pair to start with an even-numbered register.  The way to\n-specify this requirement is with @code{HARD_REGNO_MODE_OK}.\n+specify this requirement is with @code{TARGET_HARD_REGNO_MODE_OK}.\n \n Register classes used for input-operands of bitwise-and or shift\n instructions have a special requirement: each such class must have, for"}, {"sha": "edcd9a2fa9d8c59c3255348d0d0a7893ab3c6f33", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 8, "deletions": 66, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1808,8 +1808,9 @@ consecutive registers are needed for a given mode.\n A C expression for the number of consecutive hard registers, starting\n at register number @var{regno}, required to hold a value of mode\n @var{mode}.  This macro must never return zero, even if a register\n-cannot hold the requested mode - indicate that with HARD_REGNO_MODE_OK\n-and/or CANNOT_CHANGE_MODE_CLASS instead.\n+cannot hold the requested mode - indicate that with\n+@code{TARGET_HARD_REGNO_MODE_OK} and/or @code{CANNOT_CHANGE_MODE_CLASS}\n+instead.\n \n On a machine where all registers are exactly one word, a suitable\n definition of this macro is\n@@ -1857,66 +1858,7 @@ happens for example on SPARC 64-bit where the natural size of\n floating-point registers is still 32-bit.\n @end defmac\n \n-@defmac HARD_REGNO_MODE_OK (@var{regno}, @var{mode})\n-A C expression that is nonzero if it is permissible to store a value\n-of mode @var{mode} in hard register number @var{regno} (or in several\n-registers starting with that one).  For a machine where all registers\n-are equivalent, a suitable definition is\n-\n-@smallexample\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-@end smallexample\n-\n-You need not include code to check for the numbers of fixed registers,\n-because the allocation mechanism considers them to be always occupied.\n-\n-@cindex register pairs\n-On some machines, double-precision values must be kept in even/odd\n-register pairs.  You can implement that by defining this macro to reject\n-odd register numbers for such modes.\n-\n-The minimum requirement for a mode to be OK in a register is that the\n-@samp{mov@var{mode}} instruction pattern support moves between the\n-register and other hard register in the same class and that moving a\n-value into the register and back out not alter it.\n-\n-Since the same instruction used to move @code{word_mode} will work for\n-all narrower integer modes, it is not necessary on any machine for\n-@code{HARD_REGNO_MODE_OK} to distinguish between these modes, provided\n-you define patterns @samp{movhi}, etc., to take advantage of this.  This\n-is useful because of the interaction between @code{HARD_REGNO_MODE_OK}\n-and @code{MODES_TIEABLE_P}; it is very desirable for all integer modes\n-to be tieable.\n-\n-Many machines have special registers for floating point arithmetic.\n-Often people assume that floating point machine modes are allowed only\n-in floating point registers.  This is not true.  Any registers that\n-can hold integers can safely @emph{hold} a floating point machine\n-mode, whether or not floating arithmetic can be done on it in those\n-registers.  Integer move instructions can be used to move the values.\n-\n-On some machines, though, the converse is true: fixed-point machine\n-modes may not go in floating registers.  This is true if the floating\n-registers normalize any value stored in them, because storing a\n-non-floating value there would garble it.  In this case,\n-@code{HARD_REGNO_MODE_OK} should reject fixed-point machine modes in\n-floating registers.  But if the floating registers do not automatically\n-normalize, if you can store any bit pattern in one and retrieve it\n-unchanged without a trap, then any machine mode may go in a floating\n-register, so you can define this macro to say so.\n-\n-The primary significance of special floating registers is rather that\n-they are the registers acceptable in floating point arithmetic\n-instructions.  However, this is of no concern to\n-@code{HARD_REGNO_MODE_OK}.  You handle it by writing the proper\n-constraints for those instructions.\n-\n-On some machines, the floating registers are especially slow to access,\n-so that it is better to store a value in a stack frame than in such a\n-register if floating point arithmetic is not being done.  As long as the\n-floating registers are not in class @code{GENERAL_REGS}, they will not\n-be used unless some pattern's constraint asks for one.\n-@end defmac\n+@hook TARGET_HARD_REGNO_MODE_OK\n \n @defmac HARD_REGNO_RENAME_OK (@var{from}, @var{to})\n A C expression that is nonzero if it is OK to rename a hard register\n@@ -1933,9 +1875,9 @@ The default is always nonzero.\n A C expression that is nonzero if a value of mode\n @var{mode1} is accessible in mode @var{mode2} without copying.\n \n-If @code{HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\n-@code{HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same for\n-any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\n+If @code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\n+@code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same\n+for any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\n should be nonzero.  If they differ for any @var{r}, you should define\n this macro to return zero unless some other mechanism ensures the\n accessibility of the value in a narrower mode.\n@@ -2114,7 +2056,7 @@ When a value occupying several consecutive registers is expected in a\n certain class, all the registers used must belong to that class.\n Therefore, register classes cannot be used to enforce a requirement for\n a register pair to start with an even-numbered register.  The way to\n-specify this requirement is with @code{HARD_REGNO_MODE_OK}.\n+specify this requirement is with @code{TARGET_HARD_REGNO_MODE_OK}.\n \n Register classes used for input-operands of bitwise-and or shift\n instructions have a special requirement: each such class must have, for"}, {"sha": "7fcf2f7eea45ebcf5eac421115057ca2adc6024c", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -148,7 +148,7 @@ init_expr_target (void)\n \t     && (direct_load[(int) mode] == 0 || direct_store[(int) mode] == 0);\n \t     regno++)\n \t  {\n-\t    if (! HARD_REGNO_MODE_OK (regno, mode))\n+\t    if (!targetm.hard_regno_mode_ok (regno, mode))\n \t      continue;\n \n \t    set_mode_and_regno (reg, mode, regno);\n@@ -541,7 +541,7 @@ convert_mode_scalar (rtx to, rtx from, int unsignedp)\n \t    || GET_CODE (from) == SUBREG))\n \tfrom = force_reg (from_mode, from);\n       if (REG_P (from) && REGNO (from) < FIRST_PSEUDO_REGISTER\n-\t  && ! HARD_REGNO_MODE_OK (REGNO (from), to_mode))\n+\t  && !targetm.hard_regno_mode_ok (REGNO (from), to_mode))\n \tfrom = copy_to_reg (from);\n       emit_move_insn (to, gen_lowpart (to_mode, from));\n       return;\n@@ -694,7 +694,7 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n       && ((MEM_P (x) && !MEM_VOLATILE_P (x) && direct_load[(int) int_mode])\n           || (REG_P (x)\n               && (!HARD_REGISTER_P (x)\n-                  || HARD_REGNO_MODE_OK (REGNO (x), int_mode))\n+\t\t  || targetm.hard_regno_mode_ok (REGNO (x), int_mode))\n               && TRULY_NOOP_TRUNCATION_MODES_P (int_mode, GET_MODE (x)))))\n    return gen_lowpart (int_mode, x);\n "}, {"sha": "48226f5d3ac267ed7801746e03729dbe36bd931d", "filename": "gcc/genpreds.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1581,7 +1581,8 @@ write_insn_preds_c (void)\n #include \\\"reload.h\\\"\\n\\\n #include \\\"regs.h\\\"\\n\\\n #include \\\"emit-rtl.h\\\"\\n\\\n-#include \\\"tm-constrs.h\\\"\\n\");\n+#include \\\"tm-constrs.h\\\"\\n\\\n+#include \\\"target.h\\\"\\n\");\n \n   FOR_ALL_PREDICATES (p)\n     write_one_predicate_function (p);"}, {"sha": "7254e2ea4fc59fe043e989fe1656918aba099be6", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -133,6 +133,13 @@ hook_bool_uint_mode_false (unsigned int, machine_mode)\n   return false;\n }\n \n+/* Generic hook that takes (unsigned int, machine_mode) and returns true.  */\n+bool\n+hook_bool_uint_mode_true (unsigned int, machine_mode)\n+{\n+  return true;\n+}\n+\n /* Generic hook that takes (FILE *, const char *) and does nothing.  */\n void\n hook_void_FILEptr_constcharptr (FILE *, const char *)"}, {"sha": "632d3370a13e8cc3c843038343a9064979473cc7", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -39,6 +39,7 @@ extern bool hook_bool_const_rtx_insn_const_rtx_insn_true (const rtx_insn *,\n extern bool hook_bool_mode_uhwi_false (machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT);\n extern bool hook_bool_uint_mode_false (unsigned int, machine_mode);\n+extern bool hook_bool_uint_mode_true (unsigned int, machine_mode);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_const_tree_false (const_tree);\n extern bool hook_bool_tree_true (tree);"}, {"sha": "df7a3838a6efc64474c349a821f86f1296607b50", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1508,7 +1508,7 @@ setup_prohibited_class_mode_regs (void)\n \t  for (k = ira_class_hard_regs_num[cl] - 1; k >= 0; k--)\n \t    {\n \t      hard_regno = ira_class_hard_regs[cl][k];\n-\t      if (! HARD_REGNO_MODE_OK (hard_regno, (machine_mode) j))\n+\t      if (!targetm.hard_regno_mode_ok (hard_regno, (machine_mode) j))\n \t\tSET_HARD_REG_BIT (ira_prohibited_class_mode_regs[cl][j],\n \t\t\t\t  hard_regno);\n \t      else if (in_hard_reg_set_p (temp_hard_regset,\n@@ -1754,7 +1754,7 @@ setup_prohibited_mode_move_regs (void)\n       SET_HARD_REG_SET (ira_prohibited_mode_move_regs[i]);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n \t{\n-\t  if (! HARD_REGNO_MODE_OK (j, (machine_mode) i))\n+\t  if (!targetm.hard_regno_mode_ok (j, (machine_mode) i))\n \t    continue;\n \t  set_mode_and_regno (test_reg1, (machine_mode) i, j);\n \t  set_mode_and_regno (test_reg2, (machine_mode) i, j);"}, {"sha": "69021c4ac74b3a75b88ca9c863ce1ff479d60b5e", "filename": "gcc/ira.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -114,8 +114,8 @@ struct target_ira\n   HARD_REG_SET x_ira_no_alloc_regs;\n \n   /* Array whose values are hard regset of hard registers available for\n-     the allocation of given register class whose HARD_REGNO_MODE_OK\n-     values for given mode are zero.  */\n+     the allocation of given register class whose targetm.hard_regno_mode_ok\n+     values for given mode are false.  */\n   HARD_REG_SET x_ira_prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n };\n "}, {"sha": "ca458ff2df0b7417903d59df4d8bad0ba645a87a", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -640,7 +640,8 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \thard_regno = ira_class_hard_regs[rclass][i];\n       if (! overlaps_hard_reg_set_p (conflict_set,\n \t\t\t\t     PSEUDO_REGNO_MODE (regno), hard_regno)\n-\t  && HARD_REGNO_MODE_OK (hard_regno, PSEUDO_REGNO_MODE (regno))\n+\t  && targetm.hard_regno_mode_ok (hard_regno,\n+\t\t\t\t\t PSEUDO_REGNO_MODE (regno))\n \t  /* We can not use prohibited_class_mode_regs for all classes\n \t     because it is not defined for all classes.  */\n \t  && (ira_allocno_class_translate[rclass] != rclass"}, {"sha": "ca9fb1169d9cba660d269566299ceaf50b7afee1", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -2416,7 +2416,7 @@ process_alt_operands (int only_alternative)\n \t\t{\n \t\t  int i;\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    if (HARD_REGNO_MODE_OK (i, mode)\n+\t\t    if (targetm.hard_regno_mode_ok (i, mode)\n \t\t\t&& in_hard_reg_set_p (reg_class_contents[this_alternative],\n \t\t\t\t\t      mode, i))\n \t\t      break;\n@@ -2528,10 +2528,9 @@ process_alt_operands (int only_alternative)\n \t\t      && hard_regno[nop] < 0\n \t\t      && GET_CODE (*curr_id->operand_loc[nop]) == SUBREG\n \t\t      && ira_class_hard_regs_num[this_alternative] > 0\n-\t\t      && ! HARD_REGNO_MODE_OK (ira_class_hard_regs\n-\t\t\t\t\t       [this_alternative][0],\n-\t\t\t\t\t       GET_MODE\n-\t\t\t\t\t       (*curr_id->operand_loc[nop])))\n+\t\t      && (!targetm.hard_regno_mode_ok\n+\t\t\t  (ira_class_hard_regs[this_alternative][0],\n+\t\t\t   GET_MODE (*curr_id->operand_loc[nop]))))\n \t\t    {\n \t\t      if (lra_dump_file != NULL)\n \t\t\tfprintf\n@@ -2615,9 +2614,9 @@ process_alt_operands (int only_alternative)\n \t\t     more one general reg).  Therefore we have 2\n \t\t     conditions to check that the reload pseudo can\n \t\t     not hold the mode value.  */\n-\t\t  && ! HARD_REGNO_MODE_OK (ira_class_hard_regs\n-\t\t\t\t\t   [this_alternative][0],\n-\t\t\t\t\t   GET_MODE (*curr_id->operand_loc[nop]))\n+\t\t  && (!targetm.hard_regno_mode_ok\n+\t\t      (ira_class_hard_regs[this_alternative][0],\n+\t\t       GET_MODE (*curr_id->operand_loc[nop])))\n \t\t  /* The above condition is not enough as the first\n \t\t     reg in ira_class_hard_regs can be not aligned for\n \t\t     multi-words mode values.  */\n@@ -5519,7 +5518,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t mode used for each independent register may not be supported\n \t so reject the split.  Splitting the wider mode should theoretically\n \t be possible but is not implemented.  */\n-      if (! HARD_REGNO_MODE_OK (hard_regno, mode))\n+      if (!targetm.hard_regno_mode_ok (hard_regno, mode))\n \t{\n \t  if (lra_dump_file != NULL)\n \t    {"}, {"sha": "87dacd8f48d0931c812472c679796dda3d9f4136", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -3159,7 +3159,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n #endif\n \n       /* Can it support the mode we need?  */\n-      if (! HARD_REGNO_MODE_OK (regno, mode))\n+      if (!targetm.hard_regno_mode_ok (regno, mode))\n \tcontinue;\n \n       success = 1;"}, {"sha": "72564de98af8b07b4d3fa3dfaa2828691f34e644", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -819,7 +819,7 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \n       /* Ensure we can use the src_reg in dst_mode (needed for\n \t the (set (reg1) (reg2)) insn mentioned above).  */\n-      if (!HARD_REGNO_MODE_OK (REGNO (src_reg), dst_mode))\n+      if (!targetm.hard_regno_mode_ok (REGNO (src_reg), dst_mode))\n \treturn false;\n \n       /* Ensure the number of hard registers of the copy match.  */"}, {"sha": "1161f157d8e2ff45331984b0820766823b6cea98", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -420,7 +420,7 @@ maybe_mode_change (machine_mode orig_mode, machine_mode copy_mode,\n       offset = ((WORDS_BIG_ENDIAN ? wordoffset : 0)\n \t\t+ (BYTES_BIG_ENDIAN ? byteoffset : 0));\n       regno += subreg_regno_offset (regno, orig_mode, offset, new_mode);\n-      if (HARD_REGNO_MODE_OK (regno, new_mode))\n+      if (targetm.hard_regno_mode_ok (regno, new_mode))\n \treturn gen_raw_REG (new_mode, regno);\n     }\n   return NULL_RTX;"}, {"sha": "6f699eb0fb7c0cae152d27698da4803ae852d4a5", "filename": "gcc/reginfo.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -473,7 +473,7 @@ init_reg_sets_1 (void)\n       CLEAR_HARD_REG_SET (ok_regs2);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n \tif (!TEST_HARD_REG_BIT (fixed_nonglobal_reg_set, j)\n-\t    && HARD_REGNO_MODE_OK (j, (machine_mode) m))\n+\t    && targetm.hard_regno_mode_ok (j, (machine_mode) m))\n \t  {\n \t    SET_HARD_REG_BIT (ok_regs, j);\n \t    if (!fixed_regs[j])\n@@ -634,31 +634,31 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n-\t&& HARD_REGNO_MODE_OK (regno, mode)\n+\t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n-\t&& HARD_REGNO_MODE_OK (regno, mode)\n+\t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n-\t&& HARD_REGNO_MODE_OK (regno, mode)\n+\t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n-\t&& HARD_REGNO_MODE_OK (regno, mode)\n+\t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n \t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n@@ -672,7 +672,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n     {\n       mode = (machine_mode) m;\n       if ((unsigned) hard_regno_nregs[regno][mode] == nregs\n-\t  && HARD_REGNO_MODE_OK (regno, mode)\n+\t  && targetm.hard_regno_mode_ok (regno, mode)\n \t  && (!call_saved\n \t      || !targetm.hard_regno_call_part_clobbered (regno, mode)))\n \treturn mode;\n@@ -1238,7 +1238,7 @@ simplifiable_subregs (const subreg_shape &shape)\n     {\n       simplifiable_subreg *info = new simplifiable_subreg (shape);\n       for (unsigned int i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-\tif (HARD_REGNO_MODE_OK (i, shape.inner_mode)\n+\tif (targetm.hard_regno_mode_ok (i, shape.inner_mode)\n \t    && simplify_subreg_regno (i, shape.inner_mode, shape.offset,\n \t\t\t\t      shape.outer_mode) >= 0)\n \t  SET_HARD_REG_BIT (info->simplifiable_regs, i);"}, {"sha": "9c196a1082db41747dd7bbf107c65a859f15e339", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -335,7 +335,7 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n   /* See whether it accepts all modes that occur in\n      definition and uses.  */\n   for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n-    if ((! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n+    if ((!targetm.hard_regno_mode_ok (new_reg, GET_MODE (*tmp->loc))\n \t && ! DEBUG_INSN_P (tmp->insn))\n \t|| (this_head->need_caller_save_reg\n \t    && ! (targetm.hard_regno_call_part_clobbered"}, {"sha": "f10a88b3e90c03cd823cb948deb767d4d9397e2b", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -667,11 +667,11 @@ find_valid_class (machine_mode outer ATTRIBUTE_UNUSED,\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER - n && ! bad; regno++)\n \tif (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno))\n \t  {\n-\t    if (HARD_REGNO_MODE_OK (regno, inner))\n+\t    if (targetm.hard_regno_mode_ok (regno, inner))\n \t      {\n \t\tgood = 1;\n \t\tif (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno + n)\n-\t\t    && ! HARD_REGNO_MODE_OK (regno + n, outer))\n+\t\t    && !targetm.hard_regno_mode_ok (regno + n, outer))\n \t\t  bad = 1;\n \t      }\n \t  }\n@@ -720,7 +720,7 @@ find_valid_class_1 (machine_mode outer ATTRIBUTE_UNUSED,\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n         {\n           if (in_hard_reg_set_p (reg_class_contents[rclass], mode, regno)\n-              && (HARD_REGNO_MODE_OK (regno, mode)))\n+\t      && targetm.hard_regno_mode_ok (regno, mode))\n             computed_rclass_size++;\n         }\n \n@@ -850,7 +850,7 @@ reload_inner_reg_of_subreg (rtx x, machine_mode mode, bool output)\n     return false;\n \n   /* If INNER is not ok for MODE, then INNER will need reloading.  */\n-  if (!HARD_REGNO_MODE_OK (subreg_regno (x), mode))\n+  if (!targetm.hard_regno_mode_ok (subreg_regno (x), mode))\n     return true;\n \n   /* If this is for an output, and the outer part is a word or smaller,\n@@ -1087,7 +1087,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t\t/ UNITS_PER_WORD)\n \t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (in))]\n \t\t\t\t\t\t[GET_MODE (SUBREG_REG (in))]))\n-\t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (in), inmode)))\n+\t\t  || !targetm.hard_regno_mode_ok (subreg_regno (in), inmode)))\n \t  || (secondary_reload_class (1, rclass, inmode, in) != NO_REGS\n \t      && (secondary_reload_class (1, rclass, GET_MODE (SUBREG_REG (in)),\n \t\t\t\t\t  SUBREG_REG (in))\n@@ -1181,7 +1181,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t      && ! (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n \t\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n \t\t        > UNITS_PER_WORD))\n-\t      && ! HARD_REGNO_MODE_OK (subreg_regno (out), outmode))\n+\t      && !targetm.hard_regno_mode_ok (subreg_regno (out), outmode))\n \t  || (secondary_reload_class (0, rclass, outmode, out) != NO_REGS\n \t      && (secondary_reload_class (0, rclass, GET_MODE (SUBREG_REG (out)),\n \t\t\t\t\t  SUBREG_REG (out))\n@@ -1310,7 +1310,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    outmode = word_mode;\n \t}\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (HARD_REGNO_MODE_OK (i, mode)\n+\tif (targetm.hard_regno_mode_ok (i, mode)\n \t    && in_hard_reg_set_p (reg_class_contents[(int) rclass], mode, i))\n \t  break;\n       if (i == FIRST_PSEUDO_REGISTER)\n@@ -1621,8 +1621,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    /* Make sure the operand fits in the reg that dies.  */\n \t    && (GET_MODE_SIZE (rel_mode)\n \t\t<= GET_MODE_SIZE (GET_MODE (XEXP (note, 0))))\n-\t    && HARD_REGNO_MODE_OK (regno, inmode)\n-\t    && HARD_REGNO_MODE_OK (regno, outmode))\n+\t    && targetm.hard_regno_mode_ok (regno, inmode)\n+\t    && targetm.hard_regno_mode_ok (regno, outmode))\n \t  {\n \t    unsigned int offs;\n \t    unsigned int nregs = MAX (hard_regno_nregs[regno][inmode],\n@@ -1902,7 +1902,7 @@ combine_reloads (void)\n \t&& !reg_overlap_mentioned_for_reload_p (XEXP (note, 0),\n \t\t\t\t\t\trld[output_reload].out)\n \t&& (regno = REGNO (XEXP (note, 0))) < FIRST_PSEUDO_REGISTER\n-\t&& HARD_REGNO_MODE_OK (regno, rld[output_reload].outmode)\n+\t&& targetm.hard_regno_mode_ok (regno, rld[output_reload].outmode)\n \t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].rclass],\n \t\t\t      regno)\n \t&& (hard_regno_nregs[regno][rld[output_reload].outmode]\n@@ -2026,7 +2026,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n       *inloc = const0_rtx;\n \n       if (regno < FIRST_PSEUDO_REGISTER\n-\t  && HARD_REGNO_MODE_OK (regno, outmode)\n+\t  && targetm.hard_regno_mode_ok (regno, outmode)\n \t  && ! refers_to_regno_for_reload_p (regno, regno + nwords,\n \t\t\t\t\t     PATTERN (this_insn), outloc))\n \t{\n@@ -2063,13 +2063,13 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t  || find_reg_note (this_insn, REG_UNUSED, real_out))\n       && find_reg_note (this_insn, REG_DEAD, real_in)\n       && !fixed_regs[REGNO (in)]\n-      && HARD_REGNO_MODE_OK (REGNO (in),\n-\t\t\t     /* The only case where out and real_out might\n-\t\t\t\thave different modes is where real_out\n-\t\t\t\tis a subreg, and in that case, out\n-\t\t\t\thas a real mode.  */\n-\t\t\t     (GET_MODE (out) != VOIDmode\n-\t\t\t      ? GET_MODE (out) : outmode))\n+      && targetm.hard_regno_mode_ok (REGNO (in),\n+\t\t\t\t     /* The only case where out and real_out\n+\t\t\t\t\tmight have different modes is where\n+\t\t\t\t\treal_out is a subreg, and in that\n+\t\t\t\t\tcase, out has a real mode.  */\n+\t\t\t\t     (GET_MODE (out) != VOIDmode\n+\t\t\t\t      ? GET_MODE (out) : outmode))\n       && (ORIGINAL_REGNO (in) < FIRST_PSEUDO_REGISTER\n \t  /* However only do this if we can be sure that this input\n \t     operand doesn't correspond with an uninitialized pseudo.\n@@ -4574,7 +4574,7 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \n \tif (regno < FIRST_PSEUDO_REGISTER\n \t    && TEST_HARD_REG_BIT (reg_class_contents[rld[i].rclass], regno)\n-\t    && HARD_REGNO_MODE_OK (regno, rld[i].mode))\n+\t    && targetm.hard_regno_mode_ok (regno, rld[i].mode))\n \t  {\n \t    int nr = hard_regno_nregs[regno][rld[i].mode];\n \t    int ok = 1, nri;"}, {"sha": "648434b7b64bdab975b22330a67a17653d5b7ede", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1845,7 +1845,7 @@ find_reg (struct insn_chain *chain, int order)\n \n       if (! TEST_HARD_REG_BIT (not_usable, regno)\n \t  && ! TEST_HARD_REG_BIT (used_by_other_reload, regno)\n-\t  && HARD_REGNO_MODE_OK (regno, rl->mode))\n+\t  && targetm.hard_regno_mode_ok (regno, rl->mode))\n \t{\n \t  int this_cost = spill_cost[regno];\n \t  int ok = 1;\n@@ -6099,9 +6099,7 @@ failed_reload (rtx_insn *insn, int r)\n static int\n set_reload_reg (int i, int r)\n {\n-  /* regno is 'set but not used' if HARD_REGNO_MODE_OK doesn't use its first\n-     parameter.  */\n-  int regno ATTRIBUTE_UNUSED;\n+  int regno;\n   rtx reg = spill_reg_rtx[i];\n \n   if (reg == 0 || GET_MODE (reg) != rld[r].mode)\n@@ -6112,7 +6110,7 @@ set_reload_reg (int i, int r)\n \n   /* Detect when the reload reg can't hold the reload mode.\n      This used to be one `if', but Sequent compiler can't handle that.  */\n-  if (HARD_REGNO_MODE_OK (regno, rld[r].mode))\n+  if (targetm.hard_regno_mode_ok (regno, rld[r].mode))\n     {\n       machine_mode test_mode = VOIDmode;\n       if (rld[r].in)\n@@ -6124,9 +6122,9 @@ set_reload_reg (int i, int r)\n \t to reload from or into have modes which are valid for this\n \t reload register.  Otherwise the reload insns would be invalid.  */\n       if (! (rld[r].in != 0 && test_mode != VOIDmode\n-\t     && ! HARD_REGNO_MODE_OK (regno, test_mode)))\n+\t     && !targetm.hard_regno_mode_ok (regno, test_mode)))\n \tif (! (rld[r].out != 0\n-\t       && ! HARD_REGNO_MODE_OK (regno, GET_MODE (rld[r].out))))\n+\t       && !targetm.hard_regno_mode_ok (regno, GET_MODE (rld[r].out))))\n \t  {\n \t    /* The reg is OK.  */\n \t    last_spill_reg = i;\n@@ -6217,7 +6215,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t\t\t\t\trld[r].when_needed, rld[r].in,\n \t\t\t\t\trld[r].out, r, 1)))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[rclass], regnum)\n-\t      && HARD_REGNO_MODE_OK (regnum, rld[r].mode)\n+\t      && targetm.hard_regno_mode_ok (regnum, rld[r].mode)\n \t      /* Look first for regs to share, then for unshared.  But\n \t\t don't share regs used for inherited reloads; they are\n \t\t the ones we want to preserve.  */\n@@ -6587,7 +6585,7 @@ choose_reload_regs (struct insn_chain *chain)\n \n \t\t  if (reg_reloaded_contents[i] == regno\n \t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid, i)\n-\t\t      && HARD_REGNO_MODE_OK (i, rld[r].mode)\n+\t\t      && targetm.hard_regno_mode_ok (i, rld[r].mode)\n \t\t      && (TEST_HARD_REG_BIT (reg_class_contents[(int) rclass], i)\n \t\t\t  /* Even if we can't use this register as a reload\n \t\t\t     register, we might use it for reload_override_in,\n@@ -6771,7 +6769,8 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t    equiv = 0;\n \t\t}\n \n-\t      if (equiv != 0 && ! HARD_REGNO_MODE_OK (regno, rld[r].mode))\n+\t      if (equiv != 0\n+\t\t  && !targetm.hard_regno_mode_ok (regno, rld[r].mode))\n \t\tequiv = 0;\n \n \t      /* We found a register that contains the value we need.\n@@ -7152,7 +7151,7 @@ reload_adjust_reg_for_temp (rtx *reload_reg, rtx alt_reload_reg,\n \tcontinue;\n       if (GET_MODE (reg) != new_mode)\n \t{\n-\t  if (!HARD_REGNO_MODE_OK (regno, new_mode))\n+\t  if (!targetm.hard_regno_mode_ok (regno, new_mode))\n \t    continue;\n \t  if (hard_regno_nregs[regno][new_mode]\n \t      > hard_regno_nregs[regno][GET_MODE (reg)])"}, {"sha": "2029528a02dad4933626b2c4fcf4b26f3c02c190", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -3635,8 +3635,8 @@ subreg_size_offset_from_lsb (unsigned int outer_bytes,\n    function does not check whether adding INFO->offset to XREGNO gives\n    a valid hard register; even if INFO->offset + XREGNO is out of range,\n    there might be another register of the same type that is in range.\n-   Likewise it doesn't check whether HARD_REGNO_MODE_OK accepts the new\n-   register, since that can depend on things like whether the final\n+   Likewise it doesn't check whether targetm.hard_regno_mode_ok accepts\n+   the new register, since that can depend on things like whether the final\n    register number is even or odd.  Callers that want to check whether\n    this particular subreg can be replaced by a simple (reg ...) should\n    use simplify_subreg_regno.  */\n@@ -3901,8 +3901,8 @@ simplify_subreg_regno (unsigned int xregno, machine_mode xmode,\n      ??? We allow invalid registers if (reg:XMODE XREGNO) is also invalid.\n      This is a kludge to work around how complex FP arguments are passed\n      on IA-64 and should be fixed.  See PR target/49226.  */\n-  if (!HARD_REGNO_MODE_OK (yregno, ymode)\n-      && HARD_REGNO_MODE_OK (xregno, xmode))\n+  if (!targetm.hard_regno_mode_ok (yregno, ymode)\n+      && targetm.hard_regno_mode_ok (xregno, xmode))\n     return -1;\n \n   return (int) yregno;"}, {"sha": "92c0c6572b6a3725621ff82462749cf489b7cbf6", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1076,7 +1076,7 @@ init_regs_for_mode (machine_mode mode)\n \n       /* See whether it accepts all modes that occur in\n          original insns.  */\n-      if (! HARD_REGNO_MODE_OK (cur_reg, mode))\n+      if (!targetm.hard_regno_mode_ok (cur_reg, mode))\n         continue;\n \n       nregs = hard_regno_nregs[cur_reg][mode];"}, {"sha": "8feaffed27d191b666a92662d265becef2deb102", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -911,7 +911,7 @@ extern void fancy_abort (const char *, int, const char *)\n \tLIBGCC2_HAS_DF_MODE LIBGCC2_HAS_XF_MODE LIBGCC2_HAS_TF_MODE\t\\\n \tCLEAR_BY_PIECES_P MOVE_BY_PIECES_P SET_BY_PIECES_P\t\t\\\n \tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\t\t\t\\\n-\tHARD_REGNO_CALL_PART_CLOBBERED\n+\tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "ca9dc87b54288d5af3f1bb2c2eb7d2626da76d33", "filename": "gcc/target.def", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -5381,6 +5381,65 @@ that are not actually in any insns yet, but will be later.\",\n  void, (void),\n  hook_void_void)\n \n+DEFHOOK\n+(hard_regno_mode_ok,\n+ \"This hook returns true if it is permissible to store a value\\n\\\n+of mode @var{mode} in hard register number @var{regno} (or in several\\n\\\n+registers starting with that one).  The default definition returns true\\n\\\n+unconditionally.\\n\\\n+\\n\\\n+You need not include code to check for the numbers of fixed registers,\\n\\\n+because the allocation mechanism considers them to be always occupied.\\n\\\n+\\n\\\n+@cindex register pairs\\n\\\n+On some machines, double-precision values must be kept in even/odd\\n\\\n+register pairs.  You can implement that by defining this hook to reject\\n\\\n+odd register numbers for such modes.\\n\\\n+\\n\\\n+The minimum requirement for a mode to be OK in a register is that the\\n\\\n+@samp{mov@var{mode}} instruction pattern support moves between the\\n\\\n+register and other hard register in the same class and that moving a\\n\\\n+value into the register and back out not alter it.\\n\\\n+\\n\\\n+Since the same instruction used to move @code{word_mode} will work for\\n\\\n+all narrower integer modes, it is not necessary on any machine for\\n\\\n+this hook to distinguish between these modes, provided you define\\n\\\n+patterns @samp{movhi}, etc., to take advantage of this.  This is\\n\\\n+useful because of the interaction between @code{TARGET_HARD_REGNO_MODE_OK}\\n\\\n+and @code{MODES_TIEABLE_P}; it is very desirable for all integer modes\\n\\\n+to be tieable.\\n\\\n+\\n\\\n+Many machines have special registers for floating point arithmetic.\\n\\\n+Often people assume that floating point machine modes are allowed only\\n\\\n+in floating point registers.  This is not true.  Any registers that\\n\\\n+can hold integers can safely @emph{hold} a floating point machine\\n\\\n+mode, whether or not floating arithmetic can be done on it in those\\n\\\n+registers.  Integer move instructions can be used to move the values.\\n\\\n+\\n\\\n+On some machines, though, the converse is true: fixed-point machine\\n\\\n+modes may not go in floating registers.  This is true if the floating\\n\\\n+registers normalize any value stored in them, because storing a\\n\\\n+non-floating value there would garble it.  In this case,\\n\\\n+@code{TARGET_HARD_REGNO_MODE_OK} should reject fixed-point machine modes in\\n\\\n+floating registers.  But if the floating registers do not automatically\\n\\\n+normalize, if you can store any bit pattern in one and retrieve it\\n\\\n+unchanged without a trap, then any machine mode may go in a floating\\n\\\n+register, so you can define this hook to say so.\\n\\\n+\\n\\\n+The primary significance of special floating registers is rather that\\n\\\n+they are the registers acceptable in floating point arithmetic\\n\\\n+instructions.  However, this is of no concern to\\n\\\n+@code{TARGET_HARD_REGNO_MODE_OK}.  You handle it by writing the proper\\n\\\n+constraints for those instructions.\\n\\\n+\\n\\\n+On some machines, the floating registers are especially slow to access,\\n\\\n+so that it is better to store a value in a stack frame than in such a\\n\\\n+register if floating point arithmetic is not being done.  As long as the\\n\\\n+floating registers are not in class @code{GENERAL_REGS}, they will not\\n\\\n+be used unless some pattern's constraint asks for one.\",\n+ bool, (unsigned int regno, machine_mode mode),\n+ hook_bool_uint_mode_true)\n+\n /* Return true if is OK to use a hard register REGNO as scratch register\n    in peephole2.  */\n DEFHOOK"}, {"sha": "476efcfb786fc19166b6b5ffb7f6f6c59b5ecfdd", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939c3e63c5076205c56fb36e9c7cdc064a189a8/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f939c3e63c5076205c56fb36e9c7cdc064a189a8", "patch": "@@ -1387,7 +1387,7 @@ make_decl_rtl (tree decl)\n       else if (!in_hard_reg_set_p (operand_reg_set, mode, reg_number))\n \terror (\"the register specified for %q+D is not general enough\"\n \t       \" to be used as a register variable\", decl);\n-      else if (!HARD_REGNO_MODE_OK (reg_number, mode))\n+      else if (!targetm.hard_regno_mode_ok (reg_number, mode))\n \terror (\"register specified for %q+D isn%'t suitable for data type\",\n                decl);\n       /* Now handle properly declared static register variables.  */"}]}