{"sha": "71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkNmZjNmIwYjMyYmEwYjFjMWFhYmU5Y2NhYzdmZjBlMDY5ZGJiMg==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2007-02-21T13:49:01Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2007-02-21T13:49:01Z"}, "message": "GregorianCalendar.java: Removed.\n\n2007-02-21  Gary Benson  <gbenson@redhat.com>\n\n\t* java/util/GregorianCalendar.java: Removed.\n\t* sources.am, Makefile.in: Rebuilt.\n\nFrom-SVN: r122198", "tree": {"sha": "c40e4a2652f0b448f9489db499649e2459eb1c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c40e4a2652f0b448f9489db499649e2459eb1c44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/comments", "author": null, "committer": null, "parents": [{"sha": "b494dc09c45dd4c615fe434635f28914d6400f4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b494dc09c45dd4c615fe434635f28914d6400f4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b494dc09c45dd4c615fe434635f28914d6400f4b"}], "stats": {"total": 1368, "additions": 7, "deletions": 1361}, "files": [{"sha": "34c18cffcfd25256ebfde8b03f528d72c013a2be", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "patch": "@@ -1,3 +1,8 @@\n+2007-02-21  Gary Benson  <gbenson@redhat.com>\n+\n+\t* java/util/GregorianCalendar.java: Removed.\n+\t* sources.am, Makefile.in: Rebuilt.\n+\n 2007-02-20  Keith Seitz  <keiths@redhat.com>\n \n \t* gnu/classpath/jdwp/natVMVirtualMachine.cc"}, {"sha": "db8813ed19b1470062b41ffadc358ae7032b390a", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "patch": "@@ -4880,7 +4880,7 @@ classpath/java/util/Formattable.java \\\n classpath/java/util/FormattableFlags.java \\\n classpath/java/util/Formatter.java \\\n classpath/java/util/FormatterClosedException.java \\\n-java/util/GregorianCalendar.java \\\n+classpath/java/util/GregorianCalendar.java \\\n classpath/java/util/HashMap.java \\\n classpath/java/util/HashSet.java \\\n classpath/java/util/Hashtable.java \\"}, {"sha": "1bda39e7ebb57a8845da4b9250433a72a2f3c33d", "filename": "libjava/classpath/lib/java/util/GregorianCalendar.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FGregorianCalendar.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FGregorianCalendar.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FGregorianCalendar.class?ref=71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2"}, {"sha": "9fe77cde5a0478bfaa508fbaa1923dd5d74ed5ce", "filename": "libjava/java/util/GregorianCalendar.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2Fjava%2Futil%2FGregorianCalendar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2Fjava%2Futil%2FGregorianCalendar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.h?ref=71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "patch": "@@ -61,7 +61,6 @@ class java::util::GregorianCalendar : public ::java::util::Calendar\n public: // actually package-private\n   static const jlong serialVersionUID = -8125100834729963327LL;\n private:\n-  static ::java::lang::String * bundleName;\n   static const jint EPOCH_DAYS = 719162;\n   static JArray< jint > * minimums;\n   static JArray< jint > * maximums;"}, {"sha": "dc77c2f502452a526052ee8f2ca4ead2149d0314", "filename": "libjava/java/util/GregorianCalendar.java", "status": "removed", "additions": 0, "deletions": 1358, "changes": 1358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b494dc09c45dd4c615fe434635f28914d6400f4b/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b494dc09c45dd4c615fe434635f28914d6400f4b/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=b494dc09c45dd4c615fe434635f28914d6400f4b", "patch": "@@ -1,1358 +0,0 @@\n-/* java.util.GregorianCalendar\n-   Copyright (C) 1998, 1999, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.util;\n-\n-\n-/**\n- * <p>\n- * This class represents the Gregorian calendar, that is used in most\n- * countries all over the world.  It does also handle the Julian calendar\n- * for dates smaller than the date of the change to the Gregorian calendar.\n- * The Gregorian calendar differs from the Julian calendar by a different\n- * leap year rule (no leap year every 100 years, except if year is divisible\n- * by 400).\n- * </p>\n- * <p>\n- * This change date is different from country to country, and can be changed with\n- * <code>setGregorianChange</code>.  The first countries to adopt the Gregorian\n- * calendar did so on the 15th of October, 1582.  This date followed October\n- * the 4th, 1582 in the Julian calendar system.  The non-existant days that were\n- * omitted when the change took place are interpreted as Gregorian dates.\n- * </p>\n- * <p>\n- * Prior to the changeover date, New Year's Day occurred on the 25th of March.\n- * However, this class always takes New Year's Day as being the 1st of January.\n- * Client code should manually adapt the year value, if required, for dates\n- * between January the 1st and March the 24th in years prior to the changeover.\n- * </p>\n- * <p>\n- * Any date infinitely forwards or backwards in time can be represented by\n- * this class.  A <em>proleptic</em> calendar system is used, which allows\n- * future dates to be created via the existing rules.  This allows meaningful\n- * and consistent dates to be produced for all years.  However, dates are only\n- * historically accurate following March the 1st, 4AD when the Julian calendar\n- * system was adopted.  Prior to this, leap year rules were applied erraticly.\n- * </p>\n- * <p>\n- * There are two eras available for the Gregorian calendar, namely BC and AD.\n- * </p>\n- * <p>\n- * Weeks are defined as a period of seven days, beginning on the first day\n- * of the week, as returned by <code>getFirstDayOfWeek()</code>, and ending\n- * on the day prior to this.\n- * </p>\n- * <p>\n- * The weeks of the year are numbered from 1 to a possible 53.  The first week\n- * of the year is defined as the first week that contains at least the minimum\n- * number of days of the first week in the new year (retrieved via\n- * <code>getMinimalDaysInFirstWeek()</code>).  All weeks after this are numbered\n- * from 2 onwards.\n- * </p>\n- * <p>\n- * For example, take the year 2004.  It began on a Thursday.  The first week\n- * of 2004 depends both on where a week begins and how long it must minimally\n- * last.  Let's say that the week begins on a Monday and must have a minimum\n- * of 5 days.  In this case, the first week begins on Monday, the 5th of January.\n- * The first 4 days (Thursday to Sunday) are not eligible, as they are too few\n- * to make up the minimum number of days of the first week which must be in\n- * the new year.  If the minimum was lowered to 4 days, then the first week\n- * would instead begin on Monday, the 29th of December, 2003.  This first week\n- * has 4 of its days in the new year, and is now eligible.\n- * </p>\n- * <p>\n- * The weeks of the month are numbered from 0 to a possible 6.  The first week\n- * of the month (numbered 1) is a set of days, prior to the first day of the week,\n- * which number at least the minimum number of days in a week.  Unlike the first\n- * week of the year, the first week of the month only uses days from that particular\n- * month.  As a consequence, it may have a variable number of days (from the minimum\n- * number required up to a full week of 7) and it need not start on the first day of\n- * the week.  It must, however, be following by the first day of the week, as this\n- * marks the beginning of week 2.  Any days of the month which occur prior to the\n- * first week (because the first day of the week occurs before the minimum number\n- * of days is met) are seen as week 0.\n- * </p>\n- * <p>\n- * Again, we will take the example of the year 2004 to demonstrate this.  September\n- * 2004 begins on a Wednesday.  Taking our first day of the week as Monday, and the\n- * minimum length of the first week as 6, we find that week 1 runs from Monday,\n- * the 6th of September to Sunday the 12th.  Prior to the 6th, there are only\n- * 5 days (Wednesday through to Sunday).  This is too small a number to meet the\n- * minimum, so these are classed as being days in week 0.  Week 2 begins on the\n- * 13th, and so on.  This changes if we reduce the minimum to 5.  In this case,\n- * week 1 is a truncated week from Wednesday the 1st to Sunday the 5th, and week\n- * 0 doesn't exist.  The first seven day week is week 2, starting on the 6th.\n- * </p>\n- * <p>\n- * On using the <code>clear()</code> method, the Gregorian calendar returns\n- * to its default value of the 1st of January, 1970 AD 00:00:00 (the epoch).\n- * The day of the week is set to the correct day for that particular time.\n- * The day is also the first of the month, and the date is in week 0.\n- * </p>\n- *\n- * @see Calendar\n- * @see TimeZone\n- * @see Calendar#getFirstDayOfWeek()\n- * @see Calendar#getMinimalDaysInFirstWeek()\n- */\n-public class GregorianCalendar extends Calendar\n-{\n-  /**\n-   * Constant representing the era BC (Before Christ).\n-   */\n-  public static final int BC = 0;\n-\n-  /**\n-   * Constant representing the era AD (Anno Domini).\n-   */\n-  public static final int AD = 1;\n-\n-  /**\n-   * The point at which the Gregorian calendar rules were used.\n-   * This is locale dependent; the default for most catholic\n-   * countries is midnight (UTC) on October 5, 1582 (Julian),\n-   * or October 15, 1582 (Gregorian).\n-   *\n-   * @serial the changeover point from the Julian calendar\n-   *         system to the Gregorian.\n-   */\n-  private long gregorianCutover;\n-\n-  /**\n-   * For compatability with Sun's JDK.\n-   */\n-  static final long serialVersionUID = -8125100834729963327L;\n-\n-  /**\n-   * The name of the resource bundle. Used only by getBundle()\n-   */\n-  private static final String bundleName = \"gnu.java.locale.Calendar\";\n-\n-  /**\n-   * Days in the epoch. Relative Jan 1, year '0' which is not a leap year.\n-   * (although there is no year zero, this does not matter.)\n-   * This is consistent with the formula:\n-   * = (year-1)*365L + ((year-1) >> 2)\n-   *\n-   * Plus the gregorian correction:\n-   *  Math.floor((year-1) / 400.) - Math.floor((year-1) / 100.);\n-   * For a correct julian date, the correction is -2 instead.\n-   *\n-   * The gregorian cutover in 1582 was 10 days, so by calculating the\n-   * correction from year zero, we have 15 non-leap days (even centuries)\n-   * minus 3 leap days (year 400,800,1200) = 12. Subtracting two corrects\n-   * this to the correct number 10.\n-   */\n-  private static final int EPOCH_DAYS = 719162;\n-\n-  /**\n-   * Constructs a new GregorianCalender representing the current\n-   * time, using the default time zone and the default locale.\n-   */\n-  public GregorianCalendar()\n-  {\n-    this(TimeZone.getDefault(), Locale.getDefault());\n-  }\n-\n-  /**\n-   * Constructs a new GregorianCalender representing the current\n-   * time, using the specified time zone and the default locale.\n-   *\n-   * @param zone a time zone.\n-   */\n-  public GregorianCalendar(TimeZone zone)\n-  {\n-    this(zone, Locale.getDefault());\n-  }\n-\n-  /**\n-   * Constructs a new GregorianCalender representing the current\n-   * time, using the default time zone and the specified locale.\n-   *\n-   * @param locale a locale.\n-   */\n-  public GregorianCalendar(Locale locale)\n-  {\n-    this(TimeZone.getDefault(), locale);\n-  }\n-\n-  /**\n-   * Constructs a new GregorianCalender representing the current\n-   * time with the given time zone and the given locale.\n-   *\n-   * @param zone a time zone.\n-   * @param locale a locale.\n-   */\n-  public GregorianCalendar(TimeZone zone, Locale locale)\n-  {\n-    this(zone, locale, false);\n-    setTimeInMillis(System.currentTimeMillis());\n-    complete();\n-  }\n-\n-  /**\n-   * Common constructor that all constructors should call.\n-   * @param zone a time zone.\n-   * @param locale a locale.\n-   * @param unused unused parameter to make the signature differ from\n-   * the public constructor (TimeZone, Locale).\n-   */\n-  private GregorianCalendar(TimeZone zone, Locale locale, boolean unused)\n-  {\n-    super(zone, locale);\n-    ResourceBundle rb = ResourceBundle.getBundle(bundleName, locale,\n-                                                 ClassLoader\n-                                                 .getSystemClassLoader());\n-    gregorianCutover = ((Date) rb.getObject(\"gregorianCutOver\")).getTime();\n-  }\n-\n-  /**\n-   * Constructs a new GregorianCalendar representing midnight on the\n-   * given date with the default time zone and locale.\n-   * @param year corresponds to the YEAR time field.\n-   * @param month corresponds to the MONTH time field.\n-   * @param day corresponds to the DAY time field.\n-   */\n-  public GregorianCalendar(int year, int month, int day)\n-  {\n-    this(TimeZone.getDefault(), Locale.getDefault(), false);\n-    set(year, month, day);\n-  }\n-\n-  /**\n-   * Constructs a new GregorianCalendar representing midnight on the\n-   * given date with the default time zone and locale.\n-   *\n-   * @param year corresponds to the YEAR time field.\n-   * @param month corresponds to the MONTH time field.\n-   * @param day corresponds to the DAY time field.\n-   * @param hour corresponds to the HOUR_OF_DAY time field.\n-   * @param minute corresponds to the MINUTE time field.\n-   */\n-  public GregorianCalendar(int year, int month, int day, int hour, int minute)\n-  {\n-    this(TimeZone.getDefault(), Locale.getDefault(), false);\n-    set(year, month, day, hour, minute);\n-  }\n-\n-  /**\n-   * Constructs a new GregorianCalendar representing midnight on the\n-   * given date with the default time zone and locale.\n-   *\n-   * @param year corresponds to the YEAR time field.\n-   * @param month corresponds to the MONTH time field.\n-   * @param day corresponds to the DAY time field.\n-   * @param hour corresponds to the HOUR_OF_DAY time field.\n-   * @param minute corresponds to the MINUTE time field.\n-   * @param second corresponds to the SECOND time field.\n-   */\n-  public GregorianCalendar(int year, int month, int day, int hour, int minute,\n-                           int second)\n-  {\n-    this(TimeZone.getDefault(), Locale.getDefault(), false);\n-    set(year, month, day, hour, minute, second);\n-  }\n-\n-  /**\n-   * Sets the date of the switch from Julian dates to Gregorian dates.\n-   * You can use <code>new Date(Long.MAX_VALUE)</code> to use a pure\n-   * Julian calendar, or <code>Long.MIN_VALUE</code> for a pure Gregorian\n-   * calendar.\n-   *\n-   * @param date the date of the change.\n-   */\n-  public void setGregorianChange(Date date)\n-  {\n-    gregorianCutover = date.getTime();\n-  }\n-\n-  /**\n-   * Gets the date of the switch from Julian dates to Gregorian dates.\n-   *\n-   * @return the date of the change.\n-   */\n-  public final Date getGregorianChange()\n-  {\n-    return new Date(gregorianCutover);\n-  }\n-\n-  /**\n-   * <p>\n-   * Determines if the given year is a leap year.  The result is\n-   * undefined if the Gregorian change took place in 1800, so that\n-   * the end of February is skipped, and that year is specified.\n-   * (well...).\n-   * </p>\n-   * <p>\n-   * To specify a year in the BC era, use a negative value calculated\n-   * as 1 - y, where y is the required year in BC.  So, 1 BC is 0,\n-   * 2 BC is -1, 3 BC is -2, etc.\n-   * </p>\n-   *\n-   * @param year a year (use a negative value for BC).\n-   * @return true, if the given year is a leap year, false otherwise.\n-   */\n-  public boolean isLeapYear(int year)\n-  {\n-    // Only years divisible by 4 can be leap years\n-    if ((year & 3) != 0)\n-      return false;\n-\n-    // Is the leap-day a Julian date? Then it's a leap year\n-    if (! isGregorian(year, 31 + 29 - 1))\n-      return true;\n-\n-    // Apply gregorian rules otherwise\n-    return ((year % 100) != 0 || (year % 400) == 0);\n-  }\n-\n-  /**\n-   * Retrieves the day of the week corresponding to the specified\n-   * day of the specified year.\n-   *\n-   * @param year the year in which the dayOfYear occurs.\n-   * @param dayOfYear the day of the year (an integer between 0 and\n-   *        and 366)\n-   */\n-  private int getWeekDay(int year, int dayOfYear)\n-  {\n-    boolean greg = isGregorian(year, dayOfYear);\n-    int day = (int) getLinearDay(year, dayOfYear, greg);\n-\n-    // The epoch was a thursday.\n-    int weekday = (day + THURSDAY) % 7;\n-    if (weekday <= 0)\n-      weekday += 7;\n-    return weekday;\n-  }\n-\n-  /**\n-   * Returns the day of the week for the first day of a given month (0..11)\n-   */\n-  private int getFirstDayOfMonth(int year, int month)\n-  {\n-    int[] dayCount = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n-\n-    if (month > 11)\n-      {\n-\tyear += (month / 12);\n-\tmonth = month % 12;\n-      }\n-\n-    if (month < 0)\n-      {\n-\tyear += (int) month / 12;\n-\tmonth = month % 12;\n-\tif (month < 0)\n-\t  {\n-\t    month += 12;\n-\t    year--;\n-\t  }\n-      }\n-\n-    int dayOfYear = dayCount[month] + 1;\n-    if (month > 1)\n-      if (isLeapYear(year))\n-\tdayOfYear++;\n-\n-    boolean greg = isGregorian(year, dayOfYear);\n-    int day = (int) getLinearDay(year, dayOfYear, greg);\n-\n-    // The epoch was a thursday.\n-    int weekday = (day + THURSDAY) % 7;\n-    if (weekday <= 0)\n-      weekday += 7;\n-    return weekday;\n-  }\n-\n-  /**\n-   * Takes a year, and a (zero based) day of year and determines\n-   * if it is gregorian or not.\n-   */\n-  private boolean isGregorian(int year, int dayOfYear)\n-  {\n-    int relativeDay = (year - 1) * 365 + ((year - 1) >> 2) + dayOfYear\n-                      - EPOCH_DAYS; // gregorian days from 1 to epoch.\n-    int gregFactor = (int) Math.floor((double) (year - 1) / 400.)\n-                     - (int) Math.floor((double) (year - 1) / 100.);\n-\n-    return ((relativeDay + gregFactor) * 60L * 60L * 24L * 1000L >= gregorianCutover);\n-  }\n-\n-  /**\n-   * Check set fields for validity, without leniency.\n-   *\n-   * @throws IllegalArgumentException if a field is invalid\n-   */\n-  private void nonLeniencyCheck() throws IllegalArgumentException\n-  {\n-    int[] month_days = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n-    int year = fields[YEAR];\n-    int month = fields[MONTH];\n-    int leap = isLeapYear(year) ? 1 : 0;\n-\n-    if (isSet[ERA] && fields[ERA] != AD && fields[ERA] != BC)\n-      throw new IllegalArgumentException(\"Illegal ERA.\");\n-    if (isSet[YEAR] && fields[YEAR] < 1)\n-      throw new IllegalArgumentException(\"Illegal YEAR.\");\n-    if (isSet[MONTH] && (month < 0 || month > 11))\n-      throw new IllegalArgumentException(\"Illegal MONTH.\");\n-    if (isSet[WEEK_OF_YEAR])\n-      {\n-\tint daysInYear = 365 + leap;\n-\tdaysInYear += (getFirstDayOfMonth(year, 0) - 1); // pad first week\n-\tint last = getFirstDayOfMonth(year, 11) + 4;\n-\tif (last > 7)\n-\t  last -= 7;\n-\tdaysInYear += 7 - last;\n-\tint weeks = daysInYear / 7;\n-\tif (fields[WEEK_OF_YEAR] < 1 || fields[WEEK_OF_YEAR] > weeks)\n-\t  throw new IllegalArgumentException(\"Illegal WEEK_OF_YEAR.\");\n-      }\n-\n-    if (isSet[WEEK_OF_MONTH])\n-      {\n-\tint weeks = (month == 1 && leap == 0) ? 4 : 5;\n-\tif (fields[WEEK_OF_MONTH] < 1 || fields[WEEK_OF_MONTH] > weeks)\n-\t  throw new IllegalArgumentException(\"Illegal WEEK_OF_MONTH.\");\n-      }\n-\n-    if (isSet[DAY_OF_MONTH])\n-      if (fields[DAY_OF_MONTH] < 1\n-          || fields[DAY_OF_MONTH] > month_days[month]\n-          + ((month == 1) ? leap : 0))\n-\tthrow new IllegalArgumentException(\"Illegal DAY_OF_MONTH.\");\n-\n-    if (isSet[DAY_OF_YEAR]\n-        && (fields[DAY_OF_YEAR] < 1 || fields[DAY_OF_YEAR] > 365 + leap))\n-      throw new IllegalArgumentException(\"Illegal DAY_OF_YEAR.\");\n-\n-    if (isSet[DAY_OF_WEEK]\n-        && (fields[DAY_OF_WEEK] < 1 || fields[DAY_OF_WEEK] > 7))\n-      throw new IllegalArgumentException(\"Illegal DAY_OF_WEEK.\");\n-\n-    if (isSet[DAY_OF_WEEK_IN_MONTH])\n-      {\n-\tint weeks = (month == 1 && leap == 0) ? 4 : 5;\n-\tif (fields[DAY_OF_WEEK_IN_MONTH] < -weeks\n-\t    || fields[DAY_OF_WEEK_IN_MONTH] > weeks)\n-\t  throw new IllegalArgumentException(\"Illegal DAY_OF_WEEK_IN_MONTH.\");\n-      }\n-\n-    if (isSet[AM_PM] && fields[AM_PM] != AM && fields[AM_PM] != PM)\n-      throw new IllegalArgumentException(\"Illegal AM_PM.\");\n-    if (isSet[HOUR] && (fields[HOUR] < 0 || fields[HOUR] > 11))\n-      throw new IllegalArgumentException(\"Illegal HOUR.\");\n-    if (isSet[HOUR_OF_DAY]\n-        && (fields[HOUR_OF_DAY] < 0 || fields[HOUR_OF_DAY] > 23))\n-      throw new IllegalArgumentException(\"Illegal HOUR_OF_DAY.\");\n-    if (isSet[MINUTE] && (fields[MINUTE] < 0 || fields[MINUTE] > 59))\n-      throw new IllegalArgumentException(\"Illegal MINUTE.\");\n-    if (isSet[SECOND] && (fields[SECOND] < 0 || fields[SECOND] > 59))\n-      throw new IllegalArgumentException(\"Illegal SECOND.\");\n-    if (isSet[MILLISECOND]\n-        && (fields[MILLISECOND] < 0 || fields[MILLISECOND] > 999))\n-      throw new IllegalArgumentException(\"Illegal MILLISECOND.\");\n-    if (isSet[ZONE_OFFSET]\n-        && (fields[ZONE_OFFSET] < -12 * 60 * 60 * 1000L\n-        || fields[ZONE_OFFSET] > 12 * 60 * 60 * 1000L))\n-      throw new IllegalArgumentException(\"Illegal ZONE_OFFSET.\");\n-    if (isSet[DST_OFFSET]\n-        && (fields[DST_OFFSET] < -12 * 60 * 60 * 1000L\n-        || fields[DST_OFFSET] > 12 * 60 * 60 * 1000L))\n-      throw new IllegalArgumentException(\"Illegal DST_OFFSET.\");\n-  }\n-\n-  /**\n-   * Converts the time field values (<code>fields</code>) to\n-   * milliseconds since the epoch UTC (<code>time</code>).\n-   *\n-   * @throws IllegalArgumentException if any calendar fields\n-   *         are invalid.\n-   */\n-  protected synchronized void computeTime()\n-  {\n-    int millisInDay = 0;\n-    int era = fields[ERA];\n-    int year = fields[YEAR];\n-    int month = fields[MONTH];\n-    int day = fields[DAY_OF_MONTH];\n-\n-    int minute = fields[MINUTE];\n-    int second = fields[SECOND];\n-    int millis = fields[MILLISECOND];\n-    int[] month_days = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n-    int[] dayCount = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n-    int hour = 0;\n-\n-    if (! isLenient())\n-      nonLeniencyCheck();\n-\n-    if (! isSet[MONTH] && (! isSet[DAY_OF_WEEK] || isSet[WEEK_OF_YEAR]))\n-      {\n-\t// 5: YEAR + DAY_OF_WEEK + WEEK_OF_YEAR\n-\tif (isSet[WEEK_OF_YEAR])\n-\t  {\n-\t    int first = getFirstDayOfMonth(year, 0);\n-\t    int offs = 1;\n-\t    int daysInFirstWeek = getFirstDayOfWeek() - first;\n-\t    if (daysInFirstWeek <= 0)\n-\t      daysInFirstWeek += 7;\n-\n-\t    if (daysInFirstWeek < getMinimalDaysInFirstWeek())\n-\t      offs += daysInFirstWeek;\n-\t    else\n-\t      offs -= 7 - daysInFirstWeek;\n-\t    month = 0;\n-\t    day = offs + 7 * (fields[WEEK_OF_YEAR] - 1);\n-\t    offs = fields[DAY_OF_WEEK] - getFirstDayOfWeek();\n-\n-\t    if (offs < 0)\n-\t      offs += 7;\n-\t    day += offs;\n-\t  }\n-\telse\n-\t  {\n-\t    // 4:  YEAR + DAY_OF_YEAR\n-\t    month = 0;\n-\t    day = fields[DAY_OF_YEAR];\n-\t  }\n-      }\n-    else\n-      {\n-\tif (isSet[DAY_OF_WEEK])\n-\t  {\n-\t    int first = getFirstDayOfMonth(year, month);\n-\n-\t    // 3: YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK\n-\t    if (isSet[DAY_OF_WEEK_IN_MONTH])\n-\t      {\n-\t\tif (fields[DAY_OF_WEEK_IN_MONTH] < 0)\n-\t\t  {\n-\t\t    month++;\n-\t\t    first = getFirstDayOfMonth(year, month);\n-\t\t    day = 1 + 7 * (fields[DAY_OF_WEEK_IN_MONTH]);\n-\t\t  }\n-\t\telse\n-\t\t  day = 1 + 7 * (fields[DAY_OF_WEEK_IN_MONTH] - 1);\n-\n-\t\tint offs = fields[DAY_OF_WEEK] - first;\n-\t\tif (offs < 0)\n-\t\t  offs += 7;\n-\t\tday += offs;\n-\t      }\n-\t    else\n-\t      { // 2: YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK\n-\t\tint offs = 1;\n-\t\tint daysInFirstWeek = getFirstDayOfWeek() - first;\n-\t\tif (daysInFirstWeek <= 0)\n-\t\t  daysInFirstWeek += 7;\n-\n-\t\tif (daysInFirstWeek < getMinimalDaysInFirstWeek())\n-\t\t  offs += daysInFirstWeek;\n-\t\telse\n-\t\t  offs -= 7 - daysInFirstWeek;\n-\n-\t\tday = offs + 7 * (fields[WEEK_OF_MONTH] - 1);\n-\t\toffs = fields[DAY_OF_WEEK] - getFirstDayOfWeek();\n-\t\tif (offs <= 0)\n-\t\t  offs += 7;\n-\t\tday += offs;\n-\t      }\n-\t  }\n-\n-\t// 1:  YEAR + MONTH + DAY_OF_MONTH\n-      }\n-    if (era == BC && year > 0)\n-      year = 1 - year;\n-\n-    // rest of code assumes day/month/year set\n-    // should negative BC years be AD?\n-    // get the hour (but no check for validity)\n-    if (isSet[HOUR])\n-      {\n-\thour = fields[HOUR];\n-\tif (fields[AM_PM] == PM)\n-\t  hour += 12;\n-      }\n-    else\n-      hour = fields[HOUR_OF_DAY];\n-\n-    // Read the era,year,month,day fields and convert as appropriate.\n-    // Calculate number of milliseconds into the day\n-    // This takes care of both h, m, s, ms over/underflows.\n-    long allMillis = (((hour * 60L) + minute) * 60L + second) * 1000L + millis;\n-    day += allMillis / (24 * 60 * 60 * 1000L);\n-    millisInDay = (int) (allMillis % (24 * 60 * 60 * 1000L));\n-\n-    if (month < 0)\n-      {\n-\tyear += (int) month / 12;\n-\tmonth = month % 12;\n-\tif (month < 0)\n-\t  {\n-\t    month += 12;\n-\t    year--;\n-\t  }\n-      }\n-    if (month > 11)\n-      {\n-\tyear += (month / 12);\n-\tmonth = month % 12;\n-      }\n-\n-    month_days[1] = isLeapYear(year) ? 29 : 28;\n-\n-    while (day <= 0)\n-      {\n-\tif (month == 0)\n-\t  {\n-\t    year--;\n-\t    month_days[1] = isLeapYear(year) ? 29 : 28;\n-\t  }\n-\tmonth = (month + 11) % 12;\n-\tday += month_days[month];\n-      }\n-    while (day > month_days[month])\n-      {\n-\tday -= (month_days[month]);\n-\tmonth = (month + 1) % 12;\n-\tif (month == 0)\n-\t  {\n-\t    year++;\n-\t    month_days[1] = isLeapYear(year) ? 29 : 28;\n-\t  }\n-      }\n-\n-    // ok, by here we have valid day,month,year,era and millisinday\n-    int dayOfYear = dayCount[month] + day - 1; // (day starts on 1)\n-    if (isLeapYear(year) && month > 1)\n-      dayOfYear++;\n-\n-    int relativeDay = (year - 1) * 365 + ((year - 1) >> 2) + dayOfYear\n-                      - EPOCH_DAYS; // gregorian days from 1 to epoch.\n-    int gregFactor = (int) Math.floor((double) (year - 1) / 400.)\n-                     - (int) Math.floor((double) (year - 1) / 100.);\n-\n-    if ((relativeDay + gregFactor) * 60L * 60L * 24L * 1000L >= gregorianCutover)\n-      relativeDay += gregFactor;\n-    else\n-      relativeDay -= 2;\n-\n-    time = relativeDay * (24 * 60 * 60 * 1000L) + millisInDay;\n-\n-    // the epoch was a Thursday.\n-    int weekday = (int) (relativeDay + THURSDAY) % 7;\n-    if (weekday <= 0)\n-      weekday += 7;\n-    fields[DAY_OF_WEEK] = weekday;\n-\n-    // Time zone corrections.\n-    TimeZone zone = getTimeZone();\n-    int rawOffset = isSet[ZONE_OFFSET] ? fields[ZONE_OFFSET]\n-                                       : zone.getRawOffset();\n-\n-    int dstOffset = isSet[DST_OFFSET] ? fields[DST_OFFSET]\n-                                      : (zone.getOffset((year < 0) ? BC : AD,\n-                                                        (year < 0) ? 1 - year\n-                                                                   : year,\n-                                                        month, day, weekday,\n-                                                        millisInDay)\n-                                      - zone.getRawOffset());\n-\n-    time -= rawOffset + dstOffset;\n-\n-    isTimeSet = true;\n-  }\n-\n-  /**\n-   * Get the linear day in days since the epoch, using the\n-   * Julian or Gregorian calendar as specified.  If you specify a\n-   * nonpositive year it is interpreted as BC as following: 0 is 1\n-   * BC, -1 is 2 BC and so on.\n-   *\n-   * @param year the year of the date.\n-   * @param dayOfYear the day of year of the date; 1 based.\n-   * @param gregorian <code>true</code>, if we should use the Gregorian rules.\n-   * @return the days since the epoch, may be negative.\n-   */\n-  private long getLinearDay(int year, int dayOfYear, boolean gregorian)\n-  {\n-    // The 13 is the number of days, that were omitted in the Gregorian\n-    // Calender until the epoch.\n-    // We shift right by 2 instead of dividing by 4, to get correct\n-    // results for negative years (and this is even more efficient).\n-    long julianDay = (year - 1) * 365L + ((year - 1) >> 2) + (dayOfYear - 1)\n-                     - EPOCH_DAYS; // gregorian days from 1 to epoch.\n-\n-    if (gregorian)\n-      {\n-\t// subtract the days that are missing in gregorian calendar\n-\t// with respect to julian calendar.\n-\t//\n-\t// Okay, here we rely on the fact that the gregorian\n-\t// calendar was introduced in the AD era.  This doesn't work\n-\t// with negative years.\n-\t//\n-\t// The additional leap year factor accounts for the fact that\n-\t// a leap day is not seen on Jan 1 of the leap year.\n-\tint gregOffset = (int) Math.floor((double) (year - 1) / 400.)\n-\t                 - (int) Math.floor((double) (year - 1) / 100.);\n-\n-\treturn julianDay + gregOffset;\n-      }\n-    else\n-      julianDay -= 2;\n-    return julianDay;\n-  }\n-\n-  /**\n-   * Converts the given linear day into era, year, month,\n-   * day_of_year, day_of_month, day_of_week, and writes the result\n-   * into the fields array.\n-   *\n-   * @param day the linear day.\n-   * @param gregorian true, if we should use Gregorian rules.\n-   */\n-  private void calculateDay(int[] fields, long day, boolean gregorian)\n-  {\n-    // the epoch was a Thursday.\n-    int weekday = (int) (day + THURSDAY) % 7;\n-    if (weekday <= 0)\n-      weekday += 7;\n-    fields[DAY_OF_WEEK] = weekday;\n-\n-    // get a first approximation of the year.  This may be one \n-    // year too big.\n-    int year = 1970\n-               + (int) (gregorian\n-                        ? ((day - 100L) * 400L) / (365L * 400L + 100L - 4L\n-                        + 1L) : ((day - 100L) * 4L) / (365L * 4L + 1L));\n-    if (day >= 0)\n-      year++;\n-\n-    long firstDayOfYear = getLinearDay(year, 1, gregorian);\n-\n-    // Now look in which year day really lies.\n-    if (day < firstDayOfYear)\n-      {\n-\tyear--;\n-\tfirstDayOfYear = getLinearDay(year, 1, gregorian);\n-      }\n-\n-    day -= firstDayOfYear - 1; // day of year,  one based.\n-\n-    fields[DAY_OF_YEAR] = (int) day;\n-    if (year <= 0)\n-      {\n-\tfields[ERA] = BC;\n-\tfields[YEAR] = 1 - year;\n-      }\n-    else\n-      {\n-\tfields[ERA] = AD;\n-\tfields[YEAR] = year;\n-      }\n-\n-    int leapday = isLeapYear(year) ? 1 : 0;\n-    if (day <= 31 + 28 + leapday)\n-      {\n-\tfields[MONTH] = (int) day / 32; // 31->JANUARY, 32->FEBRUARY\n-\tfields[DAY_OF_MONTH] = (int) day - 31 * fields[MONTH];\n-      }\n-    else\n-      {\n-\t// A few more magic formulas\n-\tint scaledDay = ((int) day - leapday) * 5 + 8;\n-\tfields[MONTH] = scaledDay / (31 + 30 + 31 + 30 + 31);\n-\tfields[DAY_OF_MONTH] = (scaledDay % (31 + 30 + 31 + 30 + 31)) / 5 + 1;\n-      }\n-  }\n-\n-  /**\n-   * Converts the milliseconds since the epoch UTC\n-   * (<code>time</code>) to time fields\n-   * (<code>fields</code>).\n-   */\n-  protected synchronized void computeFields()\n-  {\n-    boolean gregorian = (time >= gregorianCutover);\n-\n-    TimeZone zone = getTimeZone();\n-    fields[ZONE_OFFSET] = zone.getRawOffset();\n-    long localTime = time + fields[ZONE_OFFSET];\n-\n-    long day = localTime / (24 * 60 * 60 * 1000L);\n-    int millisInDay = (int) (localTime % (24 * 60 * 60 * 1000L));\n-\n-    if (millisInDay < 0)\n-      {\n-\tmillisInDay += (24 * 60 * 60 * 1000);\n-\tday--;\n-      }\n-\n-    calculateDay(fields, day, gregorian);\n-    fields[DST_OFFSET] = zone.getOffset(fields[ERA], fields[YEAR],\n-                                        fields[MONTH], fields[DAY_OF_MONTH],\n-                                        fields[DAY_OF_WEEK], millisInDay)\n-                         - fields[ZONE_OFFSET];\n-\n-    millisInDay += fields[DST_OFFSET];\n-    if (millisInDay >= 24 * 60 * 60 * 1000)\n-      {\n-\tmillisInDay -= 24 * 60 * 60 * 1000;\n-\tcalculateDay(fields, ++day, gregorian);\n-      }\n-\n-    fields[DAY_OF_WEEK_IN_MONTH] = (fields[DAY_OF_MONTH] + 6) / 7;\n-\n-    // which day of the week are we (0..6), relative to getFirstDayOfWeek\n-    int relativeWeekday = (7 + fields[DAY_OF_WEEK] - getFirstDayOfWeek()) % 7;\n-\n-    fields[WEEK_OF_MONTH] = (fields[DAY_OF_MONTH] - relativeWeekday + 12) / 7;\n-\n-    int weekOfYear = (fields[DAY_OF_YEAR] - relativeWeekday + 6) / 7;\n-\n-    // Do the Correction: getMinimalDaysInFirstWeek() is always in the \n-    // first week.\n-    int minDays = getMinimalDaysInFirstWeek();\n-    int firstWeekday = (7 + getWeekDay(fields[YEAR], minDays)\n-                       - getFirstDayOfWeek()) % 7;\n-    if (minDays - firstWeekday < 1)\n-      weekOfYear++;\n-    fields[WEEK_OF_YEAR] = weekOfYear;\n-\n-    int hourOfDay = millisInDay / (60 * 60 * 1000);\n-    fields[AM_PM] = (hourOfDay < 12) ? AM : PM;\n-    int hour = hourOfDay % 12;\n-    fields[HOUR] = hour;\n-    fields[HOUR_OF_DAY] = hourOfDay;\n-    millisInDay %= (60 * 60 * 1000);\n-    fields[MINUTE] = millisInDay / (60 * 1000);\n-    millisInDay %= (60 * 1000);\n-    fields[SECOND] = millisInDay / (1000);\n-    fields[MILLISECOND] = millisInDay % 1000;\n-\n-    areFieldsSet = isSet[ERA] = isSet[YEAR] = isSet[MONTH] = isSet[WEEK_OF_YEAR] = isSet[WEEK_OF_MONTH] = isSet[DAY_OF_MONTH] = isSet[DAY_OF_YEAR] = isSet[DAY_OF_WEEK] = isSet[DAY_OF_WEEK_IN_MONTH] = isSet[AM_PM] = isSet[HOUR] = isSet[HOUR_OF_DAY] = isSet[MINUTE] = isSet[SECOND] = isSet[MILLISECOND] = isSet[ZONE_OFFSET] = isSet[DST_OFFSET] = true;\n-  }\n-  \n-  /**\n-   * Return a hash code for this object, following the general contract\n-   * specified by {@link Object#hashCode()}.\n-   * @return the hash code\n-   */\n-  public int hashCode()\n-  {\n-    int val = (int) ((gregorianCutover >>> 32) ^ (gregorianCutover & 0xffffffff));\n-    return super.hashCode() ^ val;\n-  }\n-\n-  /**\n-   * Compares the given calendar with this.  An object, o, is\n-   * equivalent to this if it is also a <code>GregorianCalendar</code>\n-   * with the same time since the epoch under the same conditions\n-   * (same change date and same time zone).\n-   *\n-   * @param o the object to that we should compare.\n-   * @return true, if the given object is a calendar, that represents\n-   * the same time (but doesn't necessarily have the same fields).\n-   * @throws IllegalArgumentException if one of the fields\n-   *         <code>ZONE_OFFSET</code> or <code>DST_OFFSET</code> is\n-   *         specified, if an unknown field is specified or if one\n-   *         of the calendar fields receives an illegal value when\n-   *         leniancy is not enabled.\n-   */\n-  public boolean equals(Object o)\n-  {\n-    if (! (o instanceof GregorianCalendar))\n-      return false;\n-\n-    GregorianCalendar cal = (GregorianCalendar) o;\n-    return (cal.gregorianCutover == gregorianCutover\n-            && super.equals(o));\n-  }\n-\n-  /**\n-   * Adds the specified amount of time to the given time field.  The\n-   * amount may be negative to subtract the time.  If the field overflows\n-   * it does what you expect: Jan, 25 + 10 Days is Feb, 4.\n-   * @param field one of the time field constants.\n-   * @param amount the amount of time to add.\n-   * @exception IllegalArgumentException if <code>field</code> is\n-   *   <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code>, or invalid; or\n-   *   if <code>amount</code> contains an out-of-range value and the calendar\n-   *   is not in lenient mode.\n-   */\n-  public void add(int field, int amount)\n-  {\n-    switch (field)\n-      {\n-      case YEAR:\n-\tcomplete();\n-\tfields[YEAR] += amount;\n-\tisTimeSet = false;\n-\tbreak;\n-      case MONTH:\n-\tcomplete();\n-\tint months = fields[MONTH] + amount;\n-\tfields[YEAR] += months / 12;\n-\tfields[MONTH] = months % 12;\n-\tif (fields[MONTH] < 0)\n-\t  {\n-\t    fields[MONTH] += 12;\n-\t    fields[YEAR]--;\n-\t  }\n-\tint maxDay = getActualMaximum(DAY_OF_MONTH);\n-\tif (fields[DAY_OF_MONTH] > maxDay)\n-\t  fields[DAY_OF_MONTH] = maxDay;\n-\tset(YEAR, fields[YEAR]);\n-\tset(MONTH, fields[MONTH]);\n-\tbreak;\n-      case DAY_OF_MONTH:\n-      case DAY_OF_YEAR:\n-      case DAY_OF_WEEK:\n-\tif (! isTimeSet)\n-\t  computeTime();\n-\ttime += amount * (24 * 60 * 60 * 1000L);\n-\tareFieldsSet = false;\n-\tbreak;\n-      case WEEK_OF_YEAR:\n-      case WEEK_OF_MONTH:\n-      case DAY_OF_WEEK_IN_MONTH:\n-\tif (! isTimeSet)\n-\t  computeTime();\n-\ttime += amount * (7 * 24 * 60 * 60 * 1000L);\n-\tareFieldsSet = false;\n-\tbreak;\n-      case AM_PM:\n-\tif (! isTimeSet)\n-\t  computeTime();\n-\ttime += amount * (12 * 60 * 60 * 1000L);\n-\tareFieldsSet = false;\n-\tbreak;\n-      case HOUR:\n-      case HOUR_OF_DAY:\n-\tif (! isTimeSet)\n-\t  computeTime();\n-\ttime += amount * (60 * 60 * 1000L);\n-\tareFieldsSet = false;\n-\tbreak;\n-      case MINUTE:\n-\tif (! isTimeSet)\n-\t  computeTime();\n-\ttime += amount * (60 * 1000L);\n-\tareFieldsSet = false;\n-\tbreak;\n-      case SECOND:\n-\tif (! isTimeSet)\n-\t  computeTime();\n-\ttime += amount * (1000L);\n-\tareFieldsSet = false;\n-\tbreak;\n-      case MILLISECOND:\n-\tif (! isTimeSet)\n-\t  computeTime();\n-\ttime += amount;\n-\tareFieldsSet = false;\n-\tbreak;\n-      case ZONE_OFFSET:\n-      case DST_OFFSET:default:\n-\tthrow new IllegalArgumentException(\"Invalid or unknown field\");\n-      }\n-  }\n-\n-  /**\n-   * Rolls the specified time field up or down.  This means add one\n-   * to the specified field, but don't change the other fields.  If\n-   * the maximum for this field is reached, start over with the\n-   * minimum value.\n-   *\n-   * <strong>Note:</strong> There may be situation, where the other\n-   * fields must be changed, e.g rolling the month on May, 31.\n-   * The date June, 31 is automatically converted to July, 1.\n-   * This requires lenient settings.\n-   *\n-   * @param field the time field. One of the time field constants.\n-   * @param up the direction, true for up, false for down.\n-   * @throws IllegalArgumentException if one of the fields\n-   *         <code>ZONE_OFFSET</code> or <code>DST_OFFSET</code> is\n-   *         specified, if an unknown field is specified or if one\n-   *         of the calendar fields receives an illegal value when\n-   *         leniancy is not enabled.\n-   */\n-  public void roll(int field, boolean up)\n-  {\n-    roll(field, up ? 1 : -1);\n-  }\n-\n-  /**\n-   * Checks that the fields are still within their legal bounds,\n-   * following use of the <code>roll()</code> method.\n-   *\n-   * @param field the field to check.\n-   * @param delta multipler for alterations to the <code>time</code>.\n-   * @see #roll(int, boolean)\n-   * @see #roll(int, int)\n-   */\n-  private void cleanUpAfterRoll(int field, int delta)\n-  {\n-    switch (field)\n-      {\n-      case ERA:\n-      case YEAR:\n-      case MONTH:\n-\t// check that day of month is still in correct range\n-\tif (fields[DAY_OF_MONTH] > getActualMaximum(DAY_OF_MONTH))\n-\t  fields[DAY_OF_MONTH] = getActualMaximum(DAY_OF_MONTH);\n-\tisTimeSet = false;\n-\tisSet[WEEK_OF_MONTH] = false;\n-\tisSet[DAY_OF_WEEK] = false;\n-\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n-\tisSet[DAY_OF_YEAR] = false;\n-\tisSet[WEEK_OF_YEAR] = false;\n-\tbreak;\n-      case DAY_OF_MONTH:\n-\tisSet[WEEK_OF_MONTH] = false;\n-\tisSet[DAY_OF_WEEK] = false;\n-\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n-\tisSet[DAY_OF_YEAR] = false;\n-\tisSet[WEEK_OF_YEAR] = false;\n-\ttime += delta * (24 * 60 * 60 * 1000L);\n-\tbreak;\n-      case WEEK_OF_MONTH:\n-\tisSet[DAY_OF_MONTH] = false;\n-\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n-\tisSet[DAY_OF_YEAR] = false;\n-\tisSet[WEEK_OF_YEAR] = false;\n-\ttime += delta * (7 * 24 * 60 * 60 * 1000L);\n-\tbreak;\n-      case DAY_OF_WEEK_IN_MONTH:\n-\tisSet[DAY_OF_MONTH] = false;\n-\tisSet[WEEK_OF_MONTH] = false;\n-\tisSet[DAY_OF_YEAR] = false;\n-\tisSet[WEEK_OF_YEAR] = false;\n-\ttime += delta * (7 * 24 * 60 * 60 * 1000L);\n-\tbreak;\n-      case DAY_OF_YEAR:\n-\tisSet[MONTH] = false;\n-\tisSet[DAY_OF_MONTH] = false;\n-\tisSet[WEEK_OF_MONTH] = false;\n-\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n-\tisSet[DAY_OF_WEEK] = false;\n-\tisSet[WEEK_OF_YEAR] = false;\n-\ttime += delta * (24 * 60 * 60 * 1000L);\n-\tbreak;\n-      case WEEK_OF_YEAR:\n-\tisSet[MONTH] = false;\n-\tisSet[DAY_OF_MONTH] = false;\n-\tisSet[WEEK_OF_MONTH] = false;\n-\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n-\tisSet[DAY_OF_YEAR] = false;\n-\ttime += delta * (7 * 24 * 60 * 60 * 1000L);\n-\tbreak;\n-      case AM_PM:\n-\tisSet[HOUR_OF_DAY] = false;\n-\ttime += delta * (12 * 60 * 60 * 1000L);\n-\tbreak;\n-      case HOUR:\n-\tisSet[HOUR_OF_DAY] = false;\n-\ttime += delta * (60 * 60 * 1000L);\n-\tbreak;\n-      case HOUR_OF_DAY:\n-\tisSet[HOUR] = false;\n-\tisSet[AM_PM] = false;\n-\ttime += delta * (60 * 60 * 1000L);\n-\tbreak;\n-      case MINUTE:\n-\ttime += delta * (60 * 1000L);\n-\tbreak;\n-      case SECOND:\n-\ttime += delta * (1000L);\n-\tbreak;\n-      case MILLISECOND:\n-\ttime += delta;\n-\tbreak;\n-      }\n-  }\n-\n-  /**\n-   * Rolls the specified time field by the given amount.  This means\n-   * add amount to the specified field, but don't change the other\n-   * fields.  If the maximum for this field is reached, start over\n-   * with the minimum value and vice versa for negative amounts.\n-   *\n-   * <strong>Note:</strong> There may be situation, where the other\n-   * fields must be changed, e.g rolling the month on May, 31.\n-   * The date June, 31 is automatically corrected to June, 30.\n-   *\n-   * @param field the time field. One of the time field constants.\n-   * @param amount the amount by which we should roll.\n-   * @throws IllegalArgumentException if one of the fields\n-   *         <code>ZONE_OFFSET</code> or <code>DST_OFFSET</code> is\n-   *         specified, if an unknown field is specified or if one\n-   *         of the calendar fields receives an illegal value when\n-   *         leniancy is not enabled.\n-   */\n-  public void roll(int field, int amount)\n-  {\n-    switch (field)\n-      {\n-      case DAY_OF_WEEK:\n-\t// day of week is special: it rolls automatically\n-\tadd(field, amount);\n-\treturn;\n-      case ZONE_OFFSET:\n-      case DST_OFFSET:\n-\tthrow new IllegalArgumentException(\"Can't roll time zone\");\n-      }\n-    complete();\n-    int min = getActualMinimum(field);\n-    int range = getActualMaximum(field) - min + 1;\n-    int oldval = fields[field];\n-    int newval = (oldval - min + range + amount) % range + min;\n-    if (newval < min)\n-      newval += range;\n-    fields[field] = newval;\n-    cleanUpAfterRoll(field, newval - oldval);\n-  }\n-\n-  /**\n-   * The minimum values for the calendar fields.\n-   */\n-  private static final int[] minimums = \n-                                        {\n-                                          BC, 1, 0, 0, 1, 1, 1, SUNDAY, 1, AM,\n-                                          1, 0, 0, 0, 0, -(12 * 60 * 60 * 1000),\n-                                          0\n-                                        };\n-\n-  /**\n-   * The maximum values for the calendar fields.\n-   */\n-  private static final int[] maximums = \n-                                        {\n-                                          AD, 5000000, 11, 53, 5, 31, 366,\n-                                          SATURDAY, 5, PM, 12, 23, 59, 59, 999,\n-                                          +(12 * 60 * 60 * 1000),\n-                                          (12 * 60 * 60 * 1000)\n-                                        };\n-\n-  /**\n-   * Gets the smallest value that is allowed for the specified field.\n-   *\n-   * @param field one of the time field constants.\n-   * @return the smallest value for the specified field.\n-   */\n-  public int getMinimum(int field)\n-  {\n-    return minimums[field];\n-  }\n-\n-  /**\n-   * Gets the biggest value that is allowed for the specified field.\n-   *\n-   * @param field one of the time field constants.\n-   * @return the biggest value.\n-   */\n-  public int getMaximum(int field)\n-  {\n-    return maximums[field];\n-  }\n-\n-  /**\n-   * Gets the greatest minimum value that is allowed for the specified field.\n-   * This is the largest value returned by the <code>getActualMinimum(int)</code>\n-   * method.\n-   *\n-   * @param field the time field. One of the time field constants.\n-   * @return the greatest minimum value.\n-   * @see #getActualMinimum(int)\n-   */\n-  public int getGreatestMinimum(int field)\n-  {\n-    if (field == WEEK_OF_YEAR)\n-      return 1;\n-    return minimums[field];\n-  }\n-\n-  /**\n-   * Gets the smallest maximum value that is allowed for the\n-   * specified field.  This is the smallest value returned\n-   * by the <code>getActualMaximum(int)</code>.  For example,\n-   * this is 28 for DAY_OF_MONTH (as all months have at least\n-   * 28 days).\n-   *\n-   * @param field the time field. One of the time field constants.\n-   * @return the least maximum value.\n-   * @see #getActualMaximum(int)\n-   * @since 1.2\n-   */\n-  public int getLeastMaximum(int field)\n-  {\n-    switch (field)\n-      {\n-      case WEEK_OF_YEAR:\n-\treturn 52;\n-      case DAY_OF_MONTH:\n-\treturn 28;\n-      case DAY_OF_YEAR:\n-\treturn 365;\n-      case DAY_OF_WEEK_IN_MONTH:\n-      case WEEK_OF_MONTH:\n-\treturn 4;\n-      default:\n-\treturn maximums[field];\n-      }\n-  }\n-\n-  /**\n-   * Gets the actual minimum value that is allowed for the specified field.\n-   * This value is dependent on the values of the other fields.  Note that\n-   * this calls <code>complete()</code> if not enough fields are set.  This\n-   * can have ugly side effects.  The value given depends on the current\n-   * time used by this instance.\n-   *\n-   * @param field the time field. One of the time field constants.\n-   * @return the actual minimum value.\n-   * @since 1.2\n-   */\n-  public int getActualMinimum(int field)\n-  {\n-    if (field == WEEK_OF_YEAR)\n-      {\n-\tint min = getMinimalDaysInFirstWeek();\n-\tif (min == 0)\n-\t  return 1;\n-\tif (! areFieldsSet || ! isSet[ERA] || ! isSet[YEAR])\n-\t  complete();\n-\n-\tint year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n-\tint weekday = getWeekDay(year, min);\n-\tif ((7 + weekday - getFirstDayOfWeek()) % 7 >= min - 1)\n-\t  return 1;\n-\treturn 0;\n-      }\n-    return minimums[field];\n-  }\n-\n-  /**\n-   * Gets the actual maximum value that is allowed for the specified field.\n-   * This value is dependent on the values of the other fields.  Note that\n-   * this calls <code>complete()</code> if not enough fields are set.  This\n-   * can have ugly side effects.  The value given depends on the current time\n-   * used by this instance; thus, leap years have a maximum day of month value of\n-   * 29, rather than 28.\n-   *\n-   * @param field the time field. One of the time field constants.\n-   * @return the actual maximum value.\n-   */\n-  public int getActualMaximum(int field)\n-  {\n-    switch (field)\n-      {\n-      case WEEK_OF_YEAR:\n-        {\n-\t  if (! areFieldsSet || ! isSet[ERA] || ! isSet[YEAR])\n-\t    complete();\n-\n-\t  // This is wrong for the year that contains the gregorian change.\n-\t  // I.e it gives the weeks in the julian year or in the gregorian\n-\t  // year in that case.\n-\t  int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n-\t  int lastDay = isLeapYear(year) ? 366 : 365;\n-\t  int weekday = getWeekDay(year, lastDay);\n-\t  int week = (lastDay + 6 - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n-\n-\t  int minimalDays = getMinimalDaysInFirstWeek();\n-\t  int firstWeekday = getWeekDay(year, minimalDays);\n-\t  /*\n-\t   * Is there a set of days at the beginning of the year, before the\n-\t   * first day of the week, equal to or greater than the minimum number\n-\t   * of days required in the first week?\n-\t   */\n-\t  if (minimalDays - (7 + firstWeekday - getFirstDayOfWeek()) % 7 < 1)\n-\t    return week + 1; /* Add week 1: firstWeekday through to firstDayOfWeek */\n-        }\n-      case DAY_OF_MONTH:\n-        {\n-\t  if (! areFieldsSet || ! isSet[MONTH])\n-\t    complete();\n-\t  int month = fields[MONTH];\n-\n-\t  // If you change this, you should also change \n-\t  // SimpleTimeZone.getDaysInMonth();\n-\t  if (month == FEBRUARY)\n-\t    {\n-\t      if (! isSet[YEAR] || ! isSet[ERA])\n-\t\tcomplete();\n-\t      int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n-\t      return isLeapYear(year) ? 29 : 28;\n-\t    }\n-\t  else if (month < AUGUST)\n-\t    return 31 - (month & 1);\n-\t  else\n-\t    return 30 + (month & 1);\n-        }\n-      case DAY_OF_YEAR:\n-        {\n-\t  if (! areFieldsSet || ! isSet[ERA] || ! isSet[YEAR])\n-\t    complete();\n-\t  int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n-\t  return isLeapYear(year) ? 366 : 365;\n-        }\n-      case DAY_OF_WEEK_IN_MONTH:\n-        {\n-\t  // This is wrong for the month that contains the gregorian change.\n-\t  int daysInMonth = getActualMaximum(DAY_OF_MONTH);\n-\n-\t  // That's black magic, I know\n-\t  return (daysInMonth - (fields[DAY_OF_MONTH] - 1) % 7 + 6) / 7;\n-        }\n-      case WEEK_OF_MONTH:\n-        {\n-\t  int daysInMonth = getActualMaximum(DAY_OF_MONTH);\n-\t  int weekday = (daysInMonth - fields[DAY_OF_MONTH]\n-\t                + fields[DAY_OF_WEEK] - SUNDAY) % 7 + SUNDAY;\n-\t  return (daysInMonth + 6 - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n-        }\n-      default:\n-\treturn maximums[field];\n-      }\n-  }\n-}"}, {"sha": "01618ce0c2051d89b178e2b5bf1ee4c4853b31e7", "filename": "libjava/sources.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "patch": "@@ -5525,7 +5525,7 @@ classpath/java/util/Formattable.java \\\n classpath/java/util/FormattableFlags.java \\\n classpath/java/util/Formatter.java \\\n classpath/java/util/FormatterClosedException.java \\\n-java/util/GregorianCalendar.java \\\n+classpath/java/util/GregorianCalendar.java \\\n classpath/java/util/HashMap.java \\\n classpath/java/util/HashSet.java \\\n classpath/java/util/Hashtable.java \\"}]}