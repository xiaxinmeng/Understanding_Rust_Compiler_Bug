{"sha": "9763f8c821d7e6b851a114ea2ae810f07096ba64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc2M2Y4YzgyMWQ3ZTZiODUxYTExNGVhMmFlODEwZjA3MDk2YmE2NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-25T08:24:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-25T08:24:34Z"}, "message": "[multiple changes]\n\n2009-06-25  Ed Falis  <falis@adacore.com>\n\n\t* s-vxwext-rtp.ads: Add missing declaration\n\n2009-06-25  Matthew Gingell  <gingell@adacore.com>\n\n\t* a-stwise.adb, a-stzsea.adb (Count, Index): Avoid local copy on stack,\n\tspeed up unmapped case.\n\n2009-06-25  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Check): Change error message for illegal abstract\n\tprojects.\n\n2009-06-25  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Add note on use of -gnatct for ASIS\n\n2009-06-25  Emmanuel Briot  <briot@adacore.com>\n\n\t* fmap.ads: Add documentation on mapping files\n\nFrom-SVN: r148930", "tree": {"sha": "b9f2a7f928ca8d203d1eec57c09c86e1c5970dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9f2a7f928ca8d203d1eec57c09c86e1c5970dd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9763f8c821d7e6b851a114ea2ae810f07096ba64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9763f8c821d7e6b851a114ea2ae810f07096ba64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9763f8c821d7e6b851a114ea2ae810f07096ba64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9763f8c821d7e6b851a114ea2ae810f07096ba64/comments", "author": null, "committer": null, "parents": [{"sha": "3cb711674443e827e2ebc61a131590214d05c1bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb711674443e827e2ebc61a131590214d05c1bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb711674443e827e2ebc61a131590214d05c1bc"}], "stats": {"total": 591, "additions": 465, "deletions": 126}, "files": [{"sha": "c90ab103892162fe5d7feaffe538f6a6d1c82294", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -1,3 +1,25 @@\n+2009-06-25  Ed Falis  <falis@adacore.com>\n+\n+\t* s-vxwext-rtp.ads: Add missing declaration\n+\n+2009-06-25  Matthew Gingell  <gingell@adacore.com>\n+\n+\t* a-stwise.adb, a-stzsea.adb (Count, Index): Avoid local copy on stack,\n+\tspeed up unmapped case.\n+\n+2009-06-25  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Check): Change error message for illegal abstract\n+\tprojects.\n+\n+2009-06-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Add note on use of -gnatct for ASIS\n+\n+2009-06-25  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* fmap.ads: Add documentation on mapping files\n+\n 2009-06-25  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch6.adb, g-socket.ads, g-socket.adb, sem_ch3.adb: Minor"}, {"sha": "3220c8f5530eb54110322349d716900e4603487b", "filename": "gcc/ada/a-stwise.adb", "status": "modified", "additions": 210, "deletions": 62, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fa-stwise.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fa-stwise.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwise.adb?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -30,6 +30,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Strings.Wide_Maps; use Ada.Strings.Wide_Maps;\n+with System;                use System;\n \n package body Ada.Strings.Wide_Search is\n \n@@ -72,59 +73,101 @@ package body Ada.Strings.Wide_Search is\n       Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n       return Natural\n    is\n-      N : Natural;\n-      J : Natural;\n-\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Num : Natural;\n+      Ind : Natural;\n+      Cur : Natural;\n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n       end if;\n \n-      --  Handle the case of non-identity mappings by creating a mapped\n-      --  string and making a recursive call using the identity mapping\n-      --  on this mapped string.\n+      Num := 0;\n+      Ind := Source'First;\n+\n+      --  Unmapped case\n+\n+      if Mapping'Address = Wide_Maps.Identity'Address then\n+         Ind := Source'First;\n+         while Ind <= Source'Length - PL1 loop\n+            if Pattern = Source (Ind .. Ind + PL1) then\n+               Num := Num + 1;\n+               Ind := Ind + Pattern'Length;\n+            else\n+               Ind := Ind + 1;\n+            end if;\n+         end loop;\n \n-      if Mapping /= Wide_Maps.Identity then\n-         declare\n-            Mapped_Source : Wide_String (Source'Range);\n+      --  Mapped case\n \n-         begin\n-            for J in Source'Range loop\n-               Mapped_Source (J) := Value (Mapping, Source (J));\n+      else\n+         Ind := Source'First;\n+         while Ind <= Source'Length - PL1 loop\n+            Cur := Ind;\n+            for K in Pattern'Range loop\n+               if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                  Ind := Ind + 1;\n+                  goto Cont;\n+               else\n+                  Cur := Cur + 1;\n+               end if;\n             end loop;\n \n-            return Count (Mapped_Source, Pattern);\n-         end;\n-      end if;\n+            Num := Num + 1;\n+            Ind := Ind + Pattern'Length;\n \n-      N := 0;\n-      J := Source'First;\n+         <<Cont>>\n+            null;\n+         end loop;\n+      end if;\n \n-      while J <= Source'Last - (Pattern'Length - 1) loop\n-         if Source (J .. J + (Pattern'Length - 1)) = Pattern then\n-            N := N + 1;\n-            J := J + Pattern'Length;\n-         else\n-            J := J + 1;\n-         end if;\n-      end loop;\n+      --  Return result\n \n-      return N;\n+      return Num;\n    end Count;\n \n    function Count\n      (Source  : Wide_String;\n       Pattern : Wide_String;\n       Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n-      Mapped_Source : Wide_String (Source'Range);\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Num : Natural;\n+      Ind : Natural;\n+      Cur : Natural;\n \n    begin\n-      for J in Source'Range loop\n-         Mapped_Source (J) := Mapping (Source (J));\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      --  Check for null pointer in case checks are off\n+\n+      if Mapping = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Num := 0;\n+      Ind := Source'First;\n+      while Ind <= Source'Last - PL1 loop\n+         Cur := Ind;\n+         for K in Pattern'Range loop\n+            if Pattern (K) /= Mapping (Source (Cur)) then\n+               Ind := Ind + 1;\n+               goto Cont;\n+            else\n+               Cur := Cur + 1;\n+            end if;\n+         end loop;\n+\n+         Num := Num + 1;\n+         Ind := Ind + Pattern'Length;\n+\n+      <<Cont>>\n+         null;\n       end loop;\n \n-      return Count (Mapped_Source, Pattern);\n+      return Num;\n    end Count;\n \n    function Count\n@@ -166,8 +209,8 @@ package body Ada.Strings.Wide_Search is\n                end if;\n             end loop;\n \n-            --  Here if J indexes 1st char of token, and all chars\n-            --  after J are in the token\n+            --  Here if J indexes first char of token, and all chars after J\n+            --  are in the token.\n \n             Last := Source'Last;\n             return;\n@@ -191,41 +234,88 @@ package body Ada.Strings.Wide_Search is\n       Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n       return Natural\n    is\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Ind : Natural;\n+      Cur : Natural;\n+\n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n       end if;\n \n-      --  Handle the case of non-identity mappings by creating a mapped\n-      --  string and making a recursive call using the identity mapping\n-      --  on this mapped string.\n+      --  Forwards case\n+\n+      if Going = Forward then\n+         Ind := Source'First;\n \n-      if Mapping /= Identity then\n-         declare\n-            Mapped_Source : Wide_String (Source'Range);\n+         --  Unmapped forward case\n \n-         begin\n-            for J in Source'Range loop\n-               Mapped_Source (J) := Value (Mapping, Source (J));\n+         if Mapping'Address = Wide_Maps.Identity'Address then\n+            for J in 1 .. Source'Length - PL1 loop\n+               if Pattern = Source (Ind .. Ind + PL1) then\n+                  return Ind;\n+               else\n+                  Ind := Ind + 1;\n+               end if;\n             end loop;\n \n-            return Index (Mapped_Source, Pattern, Going);\n-         end;\n-      end if;\n+         --  Mapped forward case\n \n-      if Going = Forward then\n-         for J in Source'First .. Source'Last - Pattern'Length + 1 loop\n-            if Pattern = Source (J .. J + Pattern'Length - 1) then\n-               return J;\n-            end if;\n-         end loop;\n+         else\n+            for J in 1 .. Source'Length - PL1 loop\n+               Cur := Ind;\n \n-      else -- Going = Backward\n-         for J in reverse Source'First .. Source'Last - Pattern'Length + 1 loop\n-            if Pattern = Source (J .. J + Pattern'Length - 1) then\n-               return J;\n-            end if;\n-         end loop;\n+               for K in Pattern'Range loop\n+                  if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                     goto Cont1;\n+                  else\n+                     Cur := Cur + 1;\n+                  end if;\n+               end loop;\n+\n+               return Ind;\n+\n+            <<Cont1>>\n+               Ind := Ind + 1;\n+            end loop;\n+         end if;\n+\n+      --  Backwards case\n+\n+      else\n+         --  Unmapped backward case\n+\n+         Ind := Source'Last - PL1;\n+\n+         if Mapping'Address = Wide_Maps.Identity'Address then\n+            for J in reverse 1 .. Source'Length - PL1 loop\n+               if Pattern = Source (Ind .. Ind + PL1) then\n+                  return Ind;\n+               else\n+                  Ind := Ind - 1;\n+               end if;\n+            end loop;\n+\n+         --  Mapped backward case\n+\n+         else\n+            for J in reverse 1 .. Source'Length - PL1 loop\n+               Cur := Ind;\n+\n+               for K in Pattern'Range loop\n+                  if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                     goto Cont2;\n+                  else\n+                     Cur := Cur + 1;\n+                  end if;\n+               end loop;\n+\n+               return Ind;\n+\n+            <<Cont2>>\n+               Ind := Ind - 1;\n+            end loop;\n+         end if;\n       end if;\n \n       --  Fall through if no match found. Note that the loops are skipped\n@@ -240,14 +330,68 @@ package body Ada.Strings.Wide_Search is\n       Going   : Direction := Forward;\n       Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n-      Mapped_Source : Wide_String (Source'Range);\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Ind : Natural;\n+      Cur : Natural;\n \n    begin\n-      for J in Source'Range loop\n-         Mapped_Source (J) := Mapping (Source (J));\n-      end loop;\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      --  Check for null pointer in case checks are off\n+\n+      if Mapping = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Forwards case\n+\n+      if Going = Forward then\n+         Ind := Source'First;\n+         for J in 1 .. Source'Length - PL1 loop\n+            Cur := Ind;\n+\n+            for K in Pattern'Range loop\n+               if Pattern (K) /= Mapping.all (Source (Cur)) then\n+                  goto Cont1;\n+               else\n+                  Cur := Cur + 1;\n+               end if;\n+            end loop;\n+\n+            return Ind;\n+\n+         <<Cont1>>\n+            Ind := Ind + 1;\n+         end loop;\n+\n+      --  Backwards case\n+\n+      else\n+         Ind := Source'Last - PL1;\n+         for J in reverse 1 .. Source'Length - PL1 loop\n+            Cur := Ind;\n+\n+            for K in Pattern'Range loop\n+               if Pattern (K) /= Mapping.all (Source (Cur)) then\n+                  goto Cont2;\n+               else\n+                  Cur := Cur + 1;\n+               end if;\n+            end loop;\n+\n+            return Ind;\n \n-      return Index (Mapped_Source, Pattern, Going);\n+         <<Cont2>>\n+            Ind := Ind - 1;\n+         end loop;\n+      end if;\n+\n+      --  Fall through if no match found. Note that the loops are skipped\n+      --  completely in the case of the pattern being longer than the source.\n+\n+      return 0;\n    end Index;\n \n    function Index\n@@ -257,14 +401,18 @@ package body Ada.Strings.Wide_Search is\n       Going  : Direction  := Forward) return Natural\n    is\n    begin\n+      --  Forwards case\n+\n       if Going = Forward then\n          for J in Source'Range loop\n             if Belongs (Source (J), Set, Test) then\n                return J;\n             end if;\n          end loop;\n \n-      else -- Going = Backward\n+      --  Backwards case\n+\n+      else\n          for J in reverse Source'Range loop\n             if Belongs (Source (J), Set, Test) then\n                return J;"}, {"sha": "d0a7f9d8f2450bde17ba254a3800d9612f9ef9c3", "filename": "gcc/ada/a-stzsea.adb", "status": "modified", "additions": 210, "deletions": 61, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fa-stzsea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fa-stzsea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzsea.adb?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -30,6 +30,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Strings.Wide_Wide_Maps; use Ada.Strings.Wide_Wide_Maps;\n+with System; use System;\n \n package body Ada.Strings.Wide_Wide_Search is\n \n@@ -73,44 +74,58 @@ package body Ada.Strings.Wide_Wide_Search is\n                   Wide_Wide_Maps.Identity)\n       return Natural\n    is\n-      N : Natural;\n-      J : Natural;\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Num : Natural;\n+      Ind : Natural;\n+      Cur : Natural;\n \n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n       end if;\n \n-      --  Handle the case of non-identity mappings by creating a mapped\n-      --  string and making a recursive call using the identity mapping\n-      --  on this mapped string.\n+      Num := 0;\n+      Ind := Source'First;\n \n-      if Mapping /= Wide_Wide_Maps.Identity then\n-         declare\n-            Mapped_Source : Wide_Wide_String (Source'Range);\n+      --  Unmapped case\n \n-         begin\n-            for J in Source'Range loop\n-               Mapped_Source (J) := Value (Mapping, Source (J));\n+      if Mapping'Address = Wide_Wide_Maps.Identity'Address then\n+         Ind := Source'First;\n+         while Ind <= Source'Length - PL1 loop\n+            if Pattern = Source (Ind .. Ind + PL1) then\n+               Num := Num + 1;\n+               Ind := Ind + Pattern'Length;\n+            else\n+               Ind := Ind + 1;\n+            end if;\n+         end loop;\n+\n+      --  Mapped case\n+\n+      else\n+         Ind := Source'First;\n+         while Ind <= Source'Length - PL1 loop\n+            Cur := Ind;\n+            for K in Pattern'Range loop\n+               if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                  Ind := Ind + 1;\n+                  goto Cont;\n+               else\n+                  Cur := Cur + 1;\n+               end if;\n             end loop;\n \n-            return Count (Mapped_Source, Pattern);\n-         end;\n+            Num := Num + 1;\n+            Ind := Ind + Pattern'Length;\n+\n+         <<Cont>>\n+            null;\n+         end loop;\n       end if;\n \n-      N := 0;\n-      J := Source'First;\n+      --  Return result\n \n-      while J <= Source'Last - (Pattern'Length - 1) loop\n-         if Source (J .. J + (Pattern'Length - 1)) = Pattern then\n-            N := N + 1;\n-            J := J + Pattern'Length;\n-         else\n-            J := J + 1;\n-         end if;\n-      end loop;\n-\n-      return N;\n+      return Num;\n    end Count;\n \n    function Count\n@@ -119,14 +134,43 @@ package body Ada.Strings.Wide_Wide_Search is\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n       return Natural\n    is\n-      Mapped_Source : Wide_Wide_String (Source'Range);\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Num : Natural;\n+      Ind : Natural;\n+      Cur : Natural;\n \n    begin\n-      for J in Source'Range loop\n-         Mapped_Source (J) := Mapping (Source (J));\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      --  Check for null pointer in case checks are off\n+\n+      if Mapping = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Num := 0;\n+      Ind := Source'First;\n+      while Ind <= Source'Last - PL1 loop\n+         Cur := Ind;\n+         for K in Pattern'Range loop\n+            if Pattern (K) /= Mapping (Source (Cur)) then\n+               Ind := Ind + 1;\n+               goto Cont;\n+            else\n+               Cur := Cur + 1;\n+            end if;\n+         end loop;\n+\n+         Num := Num + 1;\n+         Ind := Ind + Pattern'Length;\n+\n+      <<Cont>>\n+         null;\n       end loop;\n \n-      return Count (Mapped_Source, Pattern);\n+      return Num;\n    end Count;\n \n    function Count\n@@ -168,8 +212,8 @@ package body Ada.Strings.Wide_Wide_Search is\n                end if;\n             end loop;\n \n-            --  Here if J indexes 1st char of token, and all chars\n-            --  after J are in the token\n+            --  Here if J indexes first char of token, and all chars after J\n+            --  are in the token.\n \n             Last := Source'Last;\n             return;\n@@ -194,41 +238,88 @@ package body Ada.Strings.Wide_Wide_Search is\n                   Wide_Wide_Maps.Identity)\n       return Natural\n    is\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Ind : Natural;\n+      Cur : Natural;\n+\n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n       end if;\n \n-      --  Handle the case of non-identity mappings by creating a mapped\n-      --  string and making a recursive call using the identity mapping\n-      --  on this mapped string.\n+      --  Forwards case\n+\n+      if Going = Forward then\n+         Ind := Source'First;\n \n-      if Mapping /= Identity then\n-         declare\n-            Mapped_Source : Wide_Wide_String (Source'Range);\n+         --  Unmapped forward case\n \n-         begin\n-            for J in Source'Range loop\n-               Mapped_Source (J) := Value (Mapping, Source (J));\n+         if Mapping'Address = Wide_Wide_Maps.Identity'Address then\n+            for J in 1 .. Source'Length - PL1 loop\n+               if Pattern = Source (Ind .. Ind + PL1) then\n+                  return Ind;\n+               else\n+                  Ind := Ind + 1;\n+               end if;\n             end loop;\n \n-            return Index (Mapped_Source, Pattern, Going);\n-         end;\n-      end if;\n+         --  Mapped forward case\n \n-      if Going = Forward then\n-         for J in Source'First .. Source'Last - Pattern'Length + 1 loop\n-            if Pattern = Source (J .. J + Pattern'Length - 1) then\n-               return J;\n-            end if;\n-         end loop;\n+         else\n+            for J in 1 .. Source'Length - PL1 loop\n+               Cur := Ind;\n \n-      else -- Going = Backward\n-         for J in reverse Source'First .. Source'Last - Pattern'Length + 1 loop\n-            if Pattern = Source (J .. J + Pattern'Length - 1) then\n-               return J;\n-            end if;\n-         end loop;\n+               for K in Pattern'Range loop\n+                  if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                     goto Cont1;\n+                  else\n+                     Cur := Cur + 1;\n+                  end if;\n+               end loop;\n+\n+               return Ind;\n+\n+            <<Cont1>>\n+               Ind := Ind + 1;\n+            end loop;\n+         end if;\n+\n+      --  Backwards case\n+\n+      else\n+         --  Unmapped backward case\n+\n+         Ind := Source'Last - PL1;\n+\n+         if Mapping'Address = Wide_Wide_Maps.Identity'Address then\n+            for J in reverse 1 .. Source'Length - PL1 loop\n+               if Pattern = Source (Ind .. Ind + PL1) then\n+                  return Ind;\n+               else\n+                  Ind := Ind - 1;\n+               end if;\n+            end loop;\n+\n+         --  Mapped backward case\n+\n+         else\n+            for J in reverse 1 .. Source'Length - PL1 loop\n+               Cur := Ind;\n+\n+               for K in Pattern'Range loop\n+                  if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                     goto Cont2;\n+                  else\n+                     Cur := Cur + 1;\n+                  end if;\n+               end loop;\n+\n+               return Ind;\n+\n+            <<Cont2>>\n+               Ind := Ind - 1;\n+            end loop;\n+         end if;\n       end if;\n \n       --  Fall through if no match found. Note that the loops are skipped\n@@ -244,14 +335,68 @@ package body Ada.Strings.Wide_Wide_Search is\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n       return Natural\n    is\n-      Mapped_Source : Wide_Wide_String (Source'Range);\n+      PL1 : constant Integer := Pattern'Length - 1;\n+      Ind : Natural;\n+      Cur : Natural;\n \n    begin\n-      for J in Source'Range loop\n-         Mapped_Source (J) := Mapping (Source (J));\n-      end loop;\n+      if Pattern = \"\" then\n+         raise Pattern_Error;\n+      end if;\n+\n+      --  Check for null pointer in case checks are off\n+\n+      if Mapping = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Forwards case\n+\n+      if Going = Forward then\n+         Ind := Source'First;\n+         for J in 1 .. Source'Length - PL1 loop\n+            Cur := Ind;\n+\n+            for K in Pattern'Range loop\n+               if Pattern (K) /= Mapping.all (Source (Cur)) then\n+                  goto Cont1;\n+               else\n+                  Cur := Cur + 1;\n+               end if;\n+            end loop;\n+\n+            return Ind;\n+\n+         <<Cont1>>\n+            Ind := Ind + 1;\n+         end loop;\n+\n+      --  Backwards case\n+\n+      else\n+         Ind := Source'Last - PL1;\n+         for J in reverse 1 .. Source'Length - PL1 loop\n+            Cur := Ind;\n+\n+            for K in Pattern'Range loop\n+               if Pattern (K) /= Mapping.all (Source (Cur)) then\n+                  goto Cont2;\n+               else\n+                  Cur := Cur + 1;\n+               end if;\n+            end loop;\n+\n+            return Ind;\n \n-      return Index (Mapped_Source, Pattern, Going);\n+         <<Cont2>>\n+            Ind := Ind - 1;\n+         end loop;\n+      end if;\n+\n+      --  Fall through if no match found. Note that the loops are skipped\n+      --  completely in the case of the pattern being longer than the source.\n+\n+      return 0;\n    end Index;\n \n    function Index\n@@ -261,14 +406,18 @@ package body Ada.Strings.Wide_Wide_Search is\n       Going  : Direction  := Forward) return Natural\n    is\n    begin\n+      --  Forwards case\n+\n       if Going = Forward then\n          for J in Source'Range loop\n             if Belongs (Source (J), Set, Test) then\n                return J;\n             end if;\n          end loop;\n \n-      else -- Going = Backward\n+      --  Backwards case\n+\n+      else\n          for J in reverse Source'Range loop\n             if Belongs (Source (J), Set, Test) then\n                return J;"}, {"sha": "77c1a0eac6b3d24a4923033fb075c56d1e848640", "filename": "gcc/ada/fmap.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Ffmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Ffmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffmap.ads?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,6 +25,15 @@\n \n --  This package keeps two mappings: from unit names to file names,\n --  and from file names to path names.\n+--\n+--  This mapping is used to communicate between the builder (gnatmake or\n+--  gprbuild) and the compiler. The format of this mapping file is the\n+--  following:\n+--  For each source file, there are three lines in the mapping file:\n+--    Unit name with %b or %s added depending on whether it is a body or a spec\n+--    File name\n+--    Path name (set to '/' if the file should be ignored in fact, ie for\n+--               a Locally_Removed_File in a project)\n \n with Namet; use Namet;\n "}, {"sha": "a2093c44f7cc940344033f785b9683555c3eb595", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -6996,6 +6996,8 @@ This not normally required, but is used by separate analysis tools.\n Typically\n these tools do the necessary compilations automatically, so you should\n not have to specify this switch in normal operation.\n+Note that the combination of switches @option{-gnatct} generates a tree\n+in the form required by ASIS applications.\n \n @item -gnatu\n @cindex @option{-gnatu} (@command{gcc})"}, {"sha": "b8a2864fd2026cfe42548f974030b08ade511aef", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -881,8 +881,8 @@ package body Prj.Nmsc is\n             else\n                Error_Msg\n                  (Project, In_Tree,\n-                  \"an abstract project needs to have no language, \" &\n-                  \"no sources or no source directories\",\n+                  \"at least one of Source_Files, Source_Dirs or Languages \" &\n+                  \"must be declared empty for an abstract project\",\n                   Project.Location);\n             end if;\n          end;"}, {"sha": "22452a18e777005737be1808ac26f0688ed5d06c", "filename": "gcc/ada/s-vxwext-rtp.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fs-vxwext-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9763f8c821d7e6b851a114ea2ae810f07096ba64/gcc%2Fada%2Fs-vxwext-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-rtp.ads?ref=9763f8c821d7e6b851a114ea2ae810f07096ba64", "patch": "@@ -81,4 +81,13 @@ package System.VxWorks.Ext is\n    function Set_Time_Slice (ticks : int) return int;\n    pragma Inline (Set_Time_Slice);\n \n+   --------------------------------\n+   -- Processor Affinity for SMP --\n+   --------------------------------\n+\n+   function taskCpuAffinitySet (tid : t_id; CPU : int) return int;\n+   pragma Convention (C, taskCpuAffinitySet);\n+   --  For SMP run-times set the CPU affinity.\n+   --  For uniprocessor systems return ERROR status.\n+\n end System.VxWorks.Ext;"}]}