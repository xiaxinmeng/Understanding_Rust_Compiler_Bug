{"sha": "1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFlNThjMzBlMjdhNDY5MjU1MjMwMzNmZTNmNWFhMjBmN2I2YjRkMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-04-30T16:27:30Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-04-30T16:27:30Z"}, "message": "bb-reorder.c, [...]: Fix comment typos.\n\n\t* bb-reorder.c, c-opts.c, cfglayout.c, cgraph.c, cgraphunit.c,\n\tcppfiles.c, fold-const.c, ggc-zone.c, loop-doloop.c, optabs.c,\n\treg-stack.c, varasm.c, config/alpha/ev4.md,\n\tconfig/alpha/ev5.md, config/alpha/ev6.md, config/arm/arm.c,\n\tconfig/c4x/c4x.c, config/c4x/c4x.md, config/cris/cris.c,\n\tconfig/cris/cris.h, config/fr30/fr30.h, config/frv/frv.c,\n\tconfig/frv/frv.h, config/frv/frv.md, config/h8300/h8300.c,\n\tconfig/i386/i386.c, config/i386/i386.md, config/i386/winnt.c,\n\tconfig/ia64/itanium2.md, config/ip2k/ip2k.c,\n\tconfig/mips/mips.c, config/mips/mips.h, config/mips/sr71k.md,\n\tconfig/pa/pa.c, config/s390/s390.c, config/sh/sh.c: Fix\n\tcomment typos.\n\nFrom-SVN: r81345", "tree": {"sha": "5061220e8209778aa37f21016395d5b6b6291a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5061220e8209778aa37f21016395d5b6b6291a31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/comments", "author": null, "committer": null, "parents": [{"sha": "a692ad2ece994e2e1cd8dbe06fb7efda4098cbec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a692ad2ece994e2e1cd8dbe06fb7efda4098cbec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a692ad2ece994e2e1cd8dbe06fb7efda4098cbec"}], "stats": {"total": 123, "additions": 69, "deletions": 54}, "files": [{"sha": "57085d84f4f509f7ebe48348f801b0eb45c829af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -1,3 +1,18 @@\n+2004-04-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* bb-reorder.c, c-opts.c, cfglayout.c, cgraph.c, cgraphunit.c,\n+\tcppfiles.c, fold-const.c, ggc-zone.c, loop-doloop.c, optabs.c,\n+\treg-stack.c, varasm.c, config/alpha/ev4.md,\n+\tconfig/alpha/ev5.md, config/alpha/ev6.md, config/arm/arm.c,\n+\tconfig/c4x/c4x.c, config/c4x/c4x.md, config/cris/cris.c,\n+\tconfig/cris/cris.h, config/fr30/fr30.h, config/frv/frv.c,\n+\tconfig/frv/frv.h, config/frv/frv.md, config/h8300/h8300.c,\n+\tconfig/i386/i386.c, config/i386/i386.md, config/i386/winnt.c,\n+\tconfig/ia64/itanium2.md, config/ip2k/ip2k.c,\n+\tconfig/mips/mips.c, config/mips/mips.h, config/mips/sr71k.md,\n+\tconfig/pa/pa.c, config/s390/s390.c, config/sh/sh.c: Fix\n+\tcomment typos.\n+\n 2004-04-30  Paul Brook  <paul@codesourcery.com>\n \n \t* config.gcc: Default ep9312 to hard-float."}, {"sha": "5437b8b0349a3b8323a7267bd299e1e56d8540fe", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -901,7 +901,7 @@ connect_traces (int n_traces, struct trace *traces)\n   last_trace = -1;\n \n   /* If we are partitioning hot/cold basic blocks, mark the cold\n-     traces as already connnected, to remove them from consideration\n+     traces as already connected, to remove them from consideration\n      for connection to the hot traces.  After the hot traces have all\n      been connected (determined by \"unconnected_hot_trace_count\"), we\n      will go back and connect the cold traces.  */"}, {"sha": "9acdf6f425e18e968362e2640b89a0945ca53c7e", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -101,7 +101,7 @@ static size_t deferred_count;\n /* Number of deferred options scanned for -include.  */\n static size_t include_cursor;\n \n-/* Permit Fotran front-end options.  */\n+/* Permit Fortran front-end options.  */\n static bool permit_fortran_options;\n \n static void set_Wimplicit (int);"}, {"sha": "e62c60ab83fcf98e4875473d15203bc70f2a3d9e", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -1172,7 +1172,7 @@ cfg_layout_initialize_rbi (basic_block bb)\n   memset (bb->rbi, 0, sizeof (struct reorder_block_def));\n }\n \f\n-/* Main entry point to this module - initialize the datastructures for\n+/* Main entry point to this module - initialize the data structures for\n    CFG layout changes.  It keeps LOOPS up-to-date if not null.  */\n \n void"}, {"sha": "c1e66f933a60c5e487b3fc28530b3f229939e2e2", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -50,21 +50,21 @@ The callgraph:\n     Intraprocedural information:\n \n       Callgraph is place to store data needed for intraprocedural optimization.\n-      All datastructures are divided into three components: local_info that\n+      All data structures are divided into three components: local_info that\n       is produced while analyzing the function, global_info that is result\n-      of global walkking of the callgraph on the end of compilation and\n+      of global walking of the callgraph on the end of compilation and\n       rtl_info used by RTL backend to propagate data from already compiled\n       functions to their callers.\n \n     Inlining plans:\n \n       The function inlining information is decided in advance and maintained\n       in the callgraph as so called inline plan.\n-      For each inlined call, the calle's node is clonned to represent the\n+      For each inlined call, the callee's node is cloned to represent the\n       new function copy produced by inlininer.\n-      Each inlined call gets unque corresponding clone node of the callee\n-      and the datastructure is updated while inlining is performed, so\n-      the clones are elliminated and their callee edges redirected to the\n+      Each inlined call gets a unique corresponding clone node of the callee\n+      and the data structure is updated while inlining is performed, so\n+      the clones are eliminated and their callee edges redirected to the\n       caller. \n \n       Each edge has \"inline_failed\" field.  When the field is set to NULL,\n@@ -100,7 +100,7 @@ The varpool data structure:\n static GTY((param_is (struct cgraph_node))) htab_t cgraph_hash;\n \n /* We destructively update callgraph during inlining and thus we need to\n-   keep information on whether inlining happend separately.  */\n+   keep information on whether inlining happened separately.  */\n htab_t cgraph_inline_hash;\n \n /* The linked list of cgraph nodes.  */\n@@ -152,7 +152,7 @@ eq_node (const void *p1, const void *p2)\n \t  (tree) p2);\n }\n \n-/* Allocate new callgraph node and insert it into basic datastructures.  */\n+/* Allocate new callgraph node and insert it into basic data structures.  */\n static struct cgraph_node *\n cgraph_create_node (void)\n {"}, {"sha": "156c924bca1c12f2da94b8b0a5c3de9c3d0882cb", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -36,7 +36,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n     - cgraph_varpool_finalize_variable\n \n-      This function has same behaviour as the above but is used for static\n+      This function has same behavior as the above but is used for static\n       variables.\n \n     - cgraph_finalize_compilation_unit\n@@ -324,7 +324,7 @@ cgraph_finalize_function (tree decl, bool nested)\n       if (node->output)\n \tabort ();\n \n-      /* Reset our datastructures so we can analyze the function again.  */\n+      /* Reset our data structures so we can analyze the function again.  */\n       memset (&node->local, 0, sizeof (node->local));\n       memset (&node->global, 0, sizeof (node->global));\n       memset (&node->rtl, 0, sizeof (node->rtl));\n@@ -1022,7 +1022,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n {\n   struct cgraph_node *n;\n \n-  /* We may elliminate the need for out-of-line copy to be output.  In that\n+  /* We may eliminate the need for out-of-line copy to be output.  In that\n      case just go ahead and re-use it.  */\n   if (!e->callee->callers->next_caller\n       && (!e->callee->needed || DECL_EXTERNAL (e->callee->decl))\n@@ -1348,7 +1348,7 @@ cgraph_decide_inlining_of_small_functions (void)\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n-   expenses on updating datastructures.  */\n+   expenses on updating data structures.  */\n \n static void\n cgraph_decide_inlining (void)\n@@ -1491,7 +1491,7 @@ cgraph_decide_inlining (void)\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n-   expenses on updating datastructures.  */\n+   expenses on updating data structures.  */\n \n static void\n cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n@@ -1561,7 +1561,7 @@ cgraph_expand_all_functions (void)\n   if (order_pos != cgraph_n_nodes)\n     abort ();\n \n-  /* Garbage collector may remove inline clones we elliminate during\n+  /* Garbage collector may remove inline clones we eliminate during\n      optimization.  So we must be sure to not reference them.  */\n   for (i = 0; i < order_pos; i++)\n     if (order[i]->output)"}, {"sha": "5056fa1277ab90fc9419c5416324aecbd2b689d3", "filename": "gcc/config/alpha/ev4.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Falpha%2Fev4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Falpha%2Fev4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev4.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -98,7 +98,7 @@\n   \"ev4_ist\"\n   \"store_data_bypass_p\")\n \n-; Multiplies use a non-piplined imul unit.  Also, \"no [ebox] insn can\n+; Multiplies use a non-pipelined imul unit.  Also, \"no [ebox] insn can\n ; be issued exactly three cycles before an integer multiply completes\".\n \n (define_insn_reservation \"ev4_imulsi\" 21"}, {"sha": "ece25d7e961f9c71978da5a8fc5e29429b9f08d2", "filename": "gcc/config/alpha/ev5.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Falpha%2Fev5.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Falpha%2Fev5.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev5.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -18,7 +18,7 @@\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n \n-;; EV5 has two asymetric integer units, E0 and E1, plus separate\n+;; EV5 has two asymmetric integer units, E0 and E1, plus separate\n ;; FP add and multiply units.\n \n (define_automaton \"ev5_0,ev5_1\")\n@@ -97,7 +97,7 @@\n ; Conditional move and branch can issue the same cycle as the test.\n (define_bypass 0 \"ev5_ilogcmp\" \"ev5_ibr,ev5_cmov\" \"if_test_bypass_p\")\n \n-; Multiplies use a non-piplined imul unit.  Also, \"no insn can be issued\n+; Multiplies use a non-pipelined imul unit.  Also, \"no insn can be issued\n ; to E0 exactly two cycles before an integer multiply completes\".\n \n (define_insn_reservation \"ev5_imull\" 8\n@@ -136,7 +136,7 @@\n (define_bypass 13 \"ev5_imulq\" \"ev5_imull,ev5_imulq,ev5_imulh\")\n (define_bypass 15 \"ev5_imulh\" \"ev5_imull,ev5_imulq,ev5_imulh\")\n \n-; Similarly for the FPU we have two asymetric units.\n+; Similarly for the FPU we have two asymmetric units.\n \n (define_insn_reservation \"ev5_fadd\" 4\n   (and (eq_attr \"cpu\" \"ev5\")"}, {"sha": "561ca709d5de62513af52aea1ef7108516841716", "filename": "gcc/config/alpha/ev6.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Falpha%2Fev6.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Falpha%2Fev6.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev6.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -22,7 +22,7 @@\n ; expected to help over-much, but a precise description can be important\n ; for software pipelining.\n ;\n-; EV6 has two symmetric pairs (\"clusters\") of two asymetric integer\n+; EV6 has two symmetric pairs (\"clusters\") of two asymmetric integer\n ; units (\"upper\" and \"lower\"), yielding pipe names U0, U1, L0, L1.\n ;\n ; ??? The clusters have independent register files that are re-synced"}, {"sha": "02864fb28ea37016b642b258764b13fe38672aba", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -7875,7 +7875,7 @@ print_multi_reg (FILE *stream, const char *instr, int reg, int mask)\n \n   /* Add a ^ character for the 26-bit ABI, but only if we were loading\n      the PC.  Otherwise we would generate an UNPREDICTABLE instruction.\n-     Strictly speaking the instruction would be unpredicatble only if\n+     Strictly speaking the instruction would be unpredictable only if\n      we were writing back the base register as well, but since we never\n      want to generate an LDM type 2 instruction (register bank switching)\n      which is what you get if the PC is not being loaded, we do not need"}, {"sha": "0dad6a4c97c5d8e59c12cb06589a8698396a582d", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -1244,7 +1244,7 @@ c4x_emit_move_sequence (rtx *operands, enum machine_mode mode)\n       && dp_reg_operand (XEXP (op1, 0), mode))\n     {\n       /* expand_increment will sometimes create a LO_SUM immediate\n-\t address.  Undo this sillyness.  */\n+\t address.  Undo this silliness.  */\n       op1 = XEXP (op1, 1);\n     }\n   "}, {"sha": "1ea954abdd81ec2609d797739844966e35c1b8ec", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -154,7 +154,7 @@\n ;  not for 'c'.\n \n ;  The 'f' constraint is only for float register operands---when \n-;  a register satisying the 'f' constraint is used as a dst operand,\n+;  a register satisfying the 'f' constraint is used as a dst operand,\n ;  the CC gets clobbered (except for LDFcond).\n \n ;  The ! in front of the 'b' constraint says to GCC to disparage the\n@@ -190,7 +190,7 @@\n ;  didn't allow it to move the CC around.\n \n ;  Note that fundamental operations, such as moves, must not clobber the\n-;  CC.  Thus movqi choses a move instruction that doesn't clobber the CC.\n+;  CC.  Thus movqi chooses a move instruction that doesn't clobber the CC.\n ;  If GCC wants to combine a move with a compare, it is smart enough to\n ;  chose the move instruction that sets the CC.\n "}, {"sha": "a975f0b850960209d9dd4433e2d6e9cbe6b38722", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -2947,7 +2947,7 @@ cris_split_movdx (rtx *operands)\n \t  int reverse\n \t    = (refers_to_regno_p (dregno, dregno + 1, addr, NULL) != 0);\n \n-\t  /* The original code imples that we can't do\n+\t  /* The original code implies that we can't do\n \t     move.x [rN+],rM  move.x [rN],rM+1\n \t     when rN is dead, because of REG_NOTES damage.  That is\n \t     consistent with what I've seen, so don't try it."}, {"sha": "a4a08fe3151081c4d83736db40386805c42dfaf2", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -337,7 +337,7 @@ extern int target_flags;\n /* Whether or not to work around multiplication instruction hardware bug\n    when generating code for models where it may be present.  From the\n    trouble report for Etrax 100 LX: \"A multiply operation may cause\n-   incorrect cache behaviour under some specific circumstances. The\n+   incorrect cache behavior under some specific circumstances. The\n    problem can occur if the instruction following the multiply instruction\n    causes a cache miss, and multiply operand 1 (source operand) bits\n    [31:27] matches the logical mapping of the mode register address"}, {"sha": "81b5f1f9bc55d60ee7af3461f5a7d8c2809760ee", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -1208,7 +1208,7 @@ extern struct rtx_def * fr30_compare_op0;\n extern struct rtx_def * fr30_compare_op1;\n \n /*}}}*/ \f\n-/*{{{  PERDICATE_CODES.  */ \n+/*{{{  PREDICATE_CODES.  */ \n \n #define PREDICATE_CODES\t\t\t\t\t\\\n   { \"stack_add_operand\",\t{ CONST_INT }},\t\t\\"}, {"sha": "d5808bfa7ac45b0f95f65e86393ceb1e6cb66ae1", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -6627,7 +6627,7 @@ frv_ifcvt_init_extra_fields (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n }\n \n \f\n-/* Internal function to add a potenial insn to the list of insns to be inserted\n+/* Internal function to add a potential insn to the list of insns to be inserted\n    if the conditional execution conversion is successful.  */\n \n static void"}, {"sha": "1e892102994dca04b4f3961688e08418b673077b", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -931,7 +931,7 @@ extern int target_flags;\n #define LAST_ARG_REGNUM\t\t(FIRST_ARG_REGNUM + FRV_NUM_ARG_REGS - 1)\n \n /* Registers used by the exception handling functions.  These should be\n-   registers that are not otherwised used by the calling sequence.  */\n+   registers that are not otherwise used by the calling sequence.  */\n #define FIRST_EH_REGNUM\t\t14\n #define LAST_EH_REGNUM\t\t15\n "}, {"sha": "20170bd412312a1bc882fb98647c568f0ea4b189", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -2788,7 +2788,7 @@\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"multi\")])\n \n-;; Patterns for addsi3/subdi3 after spliting\n+;; Patterns for addsi3/subdi3 after splitting\n (define_insn \"adddi3_lower\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n \t(plus:SI (match_operand:SI 1 \"integer_register_operand\" \"d\")"}, {"sha": "789bb00c53700607e91327c528cd79f23bbeaac4", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -4671,7 +4671,7 @@ same_cmp_following_p (rtx i1)\n }\n \n /* Return nonzero if OPERANDS are valid for stm (or ldm) that pushes\n-   (or pops) N registers.  OPERANDS are asssumed to be an array of\n+   (or pops) N registers.  OPERANDS are assumed to be an array of\n    registers.  */\n \n int"}, {"sha": "5a6832ded25cd4175c10f73b448281e9ec69b9ce", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -15817,7 +15817,7 @@ ix86_expand_vector_init (rtx target, rtx vals)\n     }\n \n   /* ... values where only first field is non-constant are best loaded\n-     from the pool and overwriten via move later.  */\n+     from the pool and overwritten via move later.  */\n   if (!i)\n     {\n       rtx op = simplify_gen_subreg (mode, XVECEXP (vals, 0, 0),"}, {"sha": "e258559d18893007b3c24ebc61bafdcdc8c3872d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -14937,7 +14937,7 @@\n ;; With sincos pattern defined, sin and cos builtin function will be\n ;; expanded to sincos pattern with one of its outputs left unused. \n ;; Cse pass  will detected, if two sincos patterns can be combined,\n-;; otherwise sincos pattern will be splitted back to sin or cos pattern,\n+;; otherwise sincos pattern will be split back to sin or cos pattern,\n ;; depending on the unused output.\n \n (define_insn \"sincosdf3\""}, {"sha": "b97810a67edc90500a03cc631e8170b3901d41eb", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -672,7 +672,7 @@ i386_pe_section_type_flags (tree decl, const char *name, int reloc)\n   unsigned int **slot;\n \n   /* The names we put in the hashtable will always be the unique\n-     versions gived to us by the stringtable, so we can just use\n+     versions given to us by the stringtable, so we can just use\n      their addresses as the keys.  */\n   if (!htab)\n     htab = htab_create (31, htab_hash_pointer, htab_eq_pointer, NULL);"}, {"sha": "6e71f5b0f9ab414993431160bbce571f18e65813", "filename": "gcc/config/ia64/itanium2.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fia64%2Fitanium2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fia64%2Fitanium2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium2.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -484,7 +484,7 @@\n (define_reservation \"2_M_only_um01\" \"2_M0_only_um01|2_M1_only_um01\")\n \n ;; I instruction is dispersed to the lowest numbered I unit\n-;; not already in use.  Remeber about possible splitting.\n+;; not already in use.  Remember about possible splitting.\n (define_reservation \"2_I0\"\n   \"2_0mi.i+2_ui0|2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0\\\n    |2_0mfi.+2_ui0|2_0mi.b+2_ui0|(2_1mi.i|2_1mi.b)+(2_ui0|2_ui1)\\\n@@ -1335,7 +1335,7 @@\n    +(2b_um2|2b_um3)\")\n \n ;; I instruction is dispersed to the lowest numbered I unit\n-;; not already in use.  Remeber about possible splitting.\n+;; not already in use.  Remember about possible splitting.\n (define_reservation \"2b_I\"\n   \"2b_0mi.i+2_2+2b_ui0|2b_0mii.+2_3+(2b_ui0|2b_ui1)|2b_0mmi.+2_3+2b_ui0\\\n    |2b_0mfi.+2_3+2b_ui0|2b_0mi.b+2_2+2b_ui0\\"}, {"sha": "05ccb614c4fbeabd1c08a308e1b3f7310140909d", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -2730,7 +2730,7 @@ ip2k_gen_unsigned_comp_branch (rtx insn, enum rtx_code code, rtx label)\n \tcase GTU:\n \t  if (imm_sub)\n \t    {\n-\t      /* > 0xffffffffffffffff never suceeds!  */\n+\t      /* > 0xffffffffffffffff never succeeds!  */\n \t      if (((const_high & 0xffffffff) != 0xffffffff)\n \t\t  || ((const_low & 0xffffffff) != 0xffffffff))\n \t\t{\n@@ -2948,7 +2948,7 @@ ip2k_gen_unsigned_comp_branch (rtx insn, enum rtx_code code, rtx label)\n \t      if (((const_high & 0xffffffff) == 0xffffffff)\n \t\t  && ((const_low & 0xffffffff) == 0xffffffff))\n \t        {\n-\t\t  /* <= 0xffffffffffffffff always suceeds.  */\n+\t\t  /* <= 0xffffffffffffffff always succeeds.  */\n \t\t  OUT_AS1 (page, %2);\n \t          OUT_AS1 (jmp, %2);\n \t\t}"}, {"sha": "ccb2b3fbab8a7f28ac15f35aaae6c5a9a9b99ae5", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -4762,7 +4762,7 @@ override_options (void)\n \n        (1) The value of an R_MIPS_GOT16 relocation depends on whether\n \t   the symbol is local or global.  We therefore need to know\n-\t   a symbol's binding before refering to it using %got().\n+\t   a symbol's binding before referring to it using %got().\n \n        (2) R_MIPS_CALL16 can only be applied to global symbols.\n "}, {"sha": "3c3936d85333a33818b53ff6e5621df28d8daad7", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -2076,7 +2076,7 @@ extern enum reg_class mips_char_to_class[256];\n    `T' is for constant move_operands that cannot be safely loaded into $25.\n    `U' is for constant move_operands that can be safely loaded into $25.\n    `W' is for memory references that are based on a member of BASE_REG_CLASS.\n-\t This is true for all non-mips16 references (although it can somtimes\n+\t This is true for all non-mips16 references (although it can sometimes\n \t be indirect if !TARGET_EXPLICIT_RELOCS).  For mips16, it excludes\n \t stack and constant-pool references.  */\n "}, {"sha": "f1ce973b3353d03da718533734af93e65ab3a3d2", "filename": "gcc/config/mips/sr71k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fmips%2Fsr71k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fmips%2Fsr71k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsr71k.md?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -17,7 +17,7 @@\n ;;  contrived to support published timings.\n ;;\n ;; Reference:\n-;;   \"SR3 Microporocessor Specification, System development information,\"\n+;;   \"SR3 Microprocessor Specification, System development information,\"\n ;;   Revision 1.0, 13 December 2000.\n ;;\n ;;"}, {"sha": "d4a286d4d8ff04f878e3ffbc7ae6fe26d13b691f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -8419,7 +8419,7 @@ pa_reorg (void)\n \t markers disables output of the branch table to readonly memory,\n \t and any alignment directives that might be needed.  Possibly,\n \t the begin_brtab insn should be output before the label for the\n-\t table.  This doesn matter at the moment since the tables are\n+\t table.  This doesn't matter at the moment since the tables are\n \t always output in the text section.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{"}, {"sha": "ed277ad4e85a08ce321ff2b49f7c3a32efd2f1b0", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -5219,7 +5219,7 @@ s390_return_addr_rtx (int count, rtx frame)\n   return gen_rtx_MEM (Pmode, addr);\n }\n \n-/* Find first call clobbered register unsused in a function.\n+/* Find first call clobbered register unused in a function.\n    This could be used as base register in a leaf function\n    or for holding the return address before epilogue.  */\n "}, {"sha": "ed4b714ad89f59180cee0fa5399eaa512f60bdc8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -338,7 +338,7 @@ static tree sh_build_builtin_va_list (void);\n    TARGET_SCHED_INIT_GLOBAL: Added a new target hook in the generic\n    scheduler; it is called inside the sched_init function just after\n    find_insn_reg_weights function call. It is used to calculate the SImode\n-   and SFmode weights of insns of basic blocks; much similiar to what\n+   and SFmode weights of insns of basic blocks; much similar to what\n    find_insn_reg_weights does. \n    TARGET_SCHED_FINISH_GLOBAL: Corresponding cleanup hook.\n "}, {"sha": "41657ce91ff3c5d3a2b1f4561dd8b2b99f6d5089", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -382,7 +382,7 @@ _cpp_find_failed (_cpp_file *file)\n \n /* Given a filename FNAME search for such a file in the include path\n    starting from START_DIR.  If FNAME is the empty string it is\n-   interpreted as STDIN if START_DIR is PFILE->no_seach_path.\n+   interpreted as STDIN if START_DIR is PFILE->no_search_path.\n \n    If the file is not found in the file cache fall back to the O/S and\n    add the result to our cache.\n@@ -1342,7 +1342,7 @@ cpp_get_prev (cpp_buffer *b)\n   return b->prev;\n }\n \f\n-/* This datastructure holds the list of header files that were seen\n+/* This data structure holds the list of header files that were seen\n    while the PCH was being built.  The 'entries' field is kept sorted\n    in memcmp() order; yes, this means that on little-endian systems,\n    it's sorted initially by the least-significant byte of 'size', but"}, {"sha": "1aed785c31d3b00cfc9f048d67a4f5b6d9ec77fb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -8875,7 +8875,7 @@ tree_expr_nonzero_p (tree t)\n {\n   tree type = TREE_TYPE (t);\n \n-  /* Doing something usefull for floating point would need more work.  */\n+  /* Doing something useful for floating point would need more work.  */\n   if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n     return false;\n "}, {"sha": "afdead25b169b40ae6413ce9f35633a07ad76850", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -1293,7 +1293,7 @@ struct ggc_pch_data\n   size_t written;\n };\n \n-/* Initialize the PCH datastructure.  */\n+/* Initialize the PCH data structure.  */\n \n struct ggc_pch_data *\n init_ggc_pch (void)"}, {"sha": "fa6b55b3cfa59c22d354bf9ff5dc4fad8f1b1dee", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -129,7 +129,7 @@ doloop_condition_get (rtx pattern)\n     return condition;\n \n   /* ??? If a machine uses a funny comparison, we could return a\n-     canonicalised form here.  */\n+     canonicalized form here.  */\n \n   return 0;\n }"}, {"sha": "8d2a232a469a4ab24719c81a95b3fd8aa8fae6b6", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -1089,7 +1089,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       /* If TARGET is the same as one of the operands, the REG_EQUAL note\n \t won't be accurate, so use a new target. Do this also if target is not\n \t a REG, first because having a register instead may open optimization\n-\t oportunities, and second because if target and op0 happen to be MEMs\n+\t opportunities, and second because if target and op0 happen to be MEMs\n \t designating the same location, we would risk clobbering it too early\n \t in the code sequence we generate below.  */\n       if (target == 0 || target == op0 || target == op1 || ! REG_P (target))"}, {"sha": "8464ab43bc607f9bf4fe0d88d97ed8d6d17249c7", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -3045,7 +3045,7 @@ convert_regs (FILE *file)\n \n   /* ??? Future: process inner loops first, and give them arbitrary\n      initial stacks which emit_swap_insn can modify.  This ought to\n-     prevent double fxch that aften appears at the head of a loop.  */\n+     prevent double fxch that often appears at the head of a loop.  */\n \n   /* Process all blocks reachable from all entry points.  */\n   for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)"}, {"sha": "13f1191a30884e9cf8d689411882e42ddd322f94", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "patch": "@@ -236,7 +236,7 @@ unlikely_text_section (void)\n \t\t   current_function_name ());\n \t  unlikely_section_label_printed = true;\n \n-\t  /* Make sure that we have approprate alignment for instructions\n+\t  /* Make sure that we have appropriate alignment for instructions\n \t     in this section.  */\n \t  assemble_align (FUNCTION_BOUNDARY);\n \t}"}]}