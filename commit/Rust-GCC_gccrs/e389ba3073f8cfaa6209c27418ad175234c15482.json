{"sha": "e389ba3073f8cfaa6209c27418ad175234c15482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4OWJhMzA3M2Y4Y2ZhYTYyMDljMjc0MThhZDE3NTIzNGMxNTQ4Mg==", "commit": {"author": {"name": "Andrew Burgess", "email": "andrew.burgess@embecosm.com", "date": "2016-11-17T22:40:05Z"}, "committer": {"name": "Andrew Burgess", "email": "aburgess@gcc.gnu.org", "date": "2016-11-17T22:40:05Z"}, "message": "arc/nps400: New peephole2 pattern allow more cmem loads\n\nIn the case where we access a single bit from a value and use this in a\nEQ/NE comparison, GCC will convert this into a sign-extend and GE/LT\ncomparison.\n\nNormally this would be fine, however, if the value is in CMEM memory,\nthen we don't have a sign-extending load available (using the special\nshort CMEM load instructions), and instead we end up using a long form\nload with LIMM, which is less efficient.\n\nThis peephole optimisation looks for the sign-extend followed by GE/LT\npattern and converts this back into a load and EQ/NE comparison.\n\ngcc/ChangeLog:\n\n\t* config/arc/arc.md (cmem bit/sign-extend peephole2): New peephole\n\tto make better use of cmem loads in the case where a single bit is\n\tbeing accessed.\n\t* config/arc/predicates.md (ge_lt_comparison_operator): New\n\tpredicate.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/arc/cmem-bit-1.c: New file.\n\t* gcc.target/arc/cmem-bit-2.c: New file.\n\t* gcc.target/arc/cmem-bit-3.c: New file.\n\t* gcc.target/arc/cmem-bit-4.c: New file.\n\nFrom-SVN: r242572", "tree": {"sha": "d1d24a4ac6cce3b81d65f6d75b22d2f66801f2fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1d24a4ac6cce3b81d65f6d75b22d2f66801f2fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e389ba3073f8cfaa6209c27418ad175234c15482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e389ba3073f8cfaa6209c27418ad175234c15482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e389ba3073f8cfaa6209c27418ad175234c15482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e389ba3073f8cfaa6209c27418ad175234c15482/comments", "author": {"login": "T-J-Teru", "id": 475372, "node_id": "MDQ6VXNlcjQ3NTM3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4", "gravatar_id": "", "url": "https://api.github.com/users/T-J-Teru", "html_url": "https://github.com/T-J-Teru", "followers_url": "https://api.github.com/users/T-J-Teru/followers", "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}", "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}", "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions", "organizations_url": "https://api.github.com/users/T-J-Teru/orgs", "repos_url": "https://api.github.com/users/T-J-Teru/repos", "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}", "received_events_url": "https://api.github.com/users/T-J-Teru/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9775c1a5ea9df3e82db338719bf0a15d9b8713cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9775c1a5ea9df3e82db338719bf0a15d9b8713cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9775c1a5ea9df3e82db338719bf0a15d9b8713cb"}], "stats": {"total": 141, "additions": 141, "deletions": 0}, "files": [{"sha": "24ed0f89b9e24a660ceba65f4bd0e6d2cb42f184", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -1,3 +1,11 @@\n+2016-11-17  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* config/arc/arc.md (cmem bit/sign-extend peephole2): New peephole\n+\tto make better use of cmem loads in the case where a single bit is\n+\tbeing accessed.\n+\t* config/arc/predicates.md (ge_lt_comparison_operator): New\n+\tpredicate.\n+\n 2016-11-17  Andrew Senkevich <andrew.senkevich@intel.com>\n \n \t* config/i386/i386.c (processor_features): Add F_AVX5124VNNIW,"}, {"sha": "925fcd6d1add8ac21762e3694a14ae295d8bd8c6", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -1465,6 +1465,49 @@\n   [(set_attr \"type\" \"cmove,cmove\")\n    (set_attr \"length\" \"4,8\")])\n \n+;; When there's a mask of a single bit, and then a compare to 0 or 1,\n+;; if the single bit is the sign bit, then GCC likes to convert this\n+;; into a sign extend and a compare less than, or greater to zero.\n+;; This is usually fine, except for the NXP400 where we have access to\n+;; a bit test instruction, along with a special short load instruction\n+;; (from CMEM), that doesn't support sign-extension on load.\n+;;\n+;; This peephole optimisation attempts to restore the use of bit-test\n+;; in those cases where it is useful to do so.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t(sign_extend:SI\n+\t\t(match_operand:QI 1 \"any_mem_operand\" \"\")))\n+   (set (reg:CC_ZN CC_REG)\n+\t(compare:CC_ZN (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"ge_lt_comparison_operator\"\n+\t\t       [(reg:CC_ZN CC_REG) (const_int 0)])\n+\t\t      (match_operand 3 \"\" \"\")\n+\t\t      (match_operand 4 \"\" \"\")))]\n+  \"TARGET_NPS_CMEM\n+   && cmem_address (XEXP (operands[1], 0), SImode)\n+   && peep2_reg_dead_p (2, operands[0])\n+   && peep2_regno_dead_p (3, CC_REG)\"\n+  [(set (match_dup 0)\n+\t(zero_extend:SI\n+\t(match_dup 1)))\n+   (set (reg:CC_ZN CC_REG)\n+\t(compare:CC_ZN (zero_extract:SI\n+\t\t\t (match_dup 0)\n+\t\t\t (const_int 1)\n+\t\t\t (const_int 7))\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 2)\n+\t\t      (match_dup 3)\n+\t\t      (match_dup 4)))]\n+  \"if (GET_CODE (operands[2]) == GE)\n+     operands[2] = gen_rtx_EQ (VOIDmode, gen_rtx_REG (CC_ZNmode, 61), const0_rtx);\n+   else\n+     operands[2] = gen_rtx_NE (VOIDmode, gen_rtx_REG (CC_ZNmode, 61), const0_rtx);\")\n+\n ; Try to generate more short moves, and/or less limms, by substituting a\n ; conditional move with a conditional sub.\n (define_peephole2"}, {"sha": "d8c928141014e8b77e510c507b749feab50f53e3", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -452,6 +452,9 @@\n (define_predicate \"equality_comparison_operator\"\n   (match_code \"eq, ne\"))\n \n+(define_predicate \"ge_lt_comparison_operator\"\n+  (match_code \"ge, lt\"))\n+\n (define_predicate \"brcc_nolimm_operator\"\n   (ior (match_test \"REG_P (XEXP (op, 1))\")\n        (and (match_code \"eq, ne, lt, ge, ltu, geu\")"}, {"sha": "1daa0aabb60e9c656d02c738a67d532bdccc3738", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -1,3 +1,10 @@\n+2016-11-17  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gcc.target/arc/cmem-bit-1.c: New file.\n+\t* gcc.target/arc/cmem-bit-2.c: New file.\n+\t* gcc.target/arc/cmem-bit-3.c: New file.\n+\t* gcc.target/arc/cmem-bit-4.c: New file.\n+\n 2016-11-17  Andrew Senkevich <andrew.senkevich@intel.com>\n \n \t* gcc.target/i386/builtin_target.c: Handle new \"avx5124vnniw\","}, {"sha": "d49ab5cd44f8e47ca2c4ea88f8e176151a381413", "filename": "gcc/testsuite/gcc.target/arc/cmem-bit-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-1.c?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -mcmem -O2\" } */\n+\n+struct strange_bool\n+{\n+  unsigned char bool_bit   :1;\n+  unsigned char other_bits :7;\n+};\n+\n+struct strange_bool a_strange_bool __attribute__((section(\".cmem\")));\n+\n+extern void bar();\n+\n+void foo() {\n+  if (a_strange_bool.bool_bit)\n+    bar();\n+}\n+\n+/* { dg-final { scan-assembler \"xldb r\\[0-9\\]+,\\\\\\[@a_strange_bool\\\\\\]\" } } */\n+/* { dg-final { scan-assembler \"btst_s r\\[0-9\\]+,7\" { target arceb-*-* } } } */"}, {"sha": "45b49c6dfc3ee74379a8ad6f0c45a223369b2cf2", "filename": "gcc/testsuite/gcc.target/arc/cmem-bit-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-2.c?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -mcmem -O2\" } */\n+\n+struct strange_bool\n+{\n+  unsigned short bool_bit   :1;\n+  unsigned short other_bits :15;\n+};\n+\n+struct strange_bool a_strange_bool __attribute__((section(\".cmem\")));\n+\n+extern void bar();\n+\n+void foo() {\n+  if (a_strange_bool.bool_bit)\n+    bar();\n+}\n+\n+/* { dg-final { scan-assembler \"xldb r\\[0-9\\]+,\\\\\\[@a_strange_bool\\\\\\]\" } } */\n+/* { dg-final { scan-assembler \"btst_s r\\[0-9\\]+,7\" { target arceb-*-* } } } */"}, {"sha": "371ff2bca8b7f1a1303276aec68beb64d785e62f", "filename": "gcc/testsuite/gcc.target/arc/cmem-bit-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-3.c?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -mcmem -O2\" } */\n+\n+struct strange_bool\n+{\n+  unsigned int bool_bit   :1;\n+  unsigned int other_bits :31;\n+};\n+\n+struct strange_bool a_strange_bool __attribute__((section(\".cmem\")));\n+\n+extern void bar();\n+\n+void foo() {\n+  if (a_strange_bool.bool_bit)\n+    bar();\n+}\n+\n+/* { dg-final { scan-assembler \"xldb r\\[0-9\\]+,\\\\\\[@a_strange_bool\\\\\\]\" } } */\n+/* { dg-final { scan-assembler \"btst_s r\\[0-9\\]+,7\" { target arceb-*-* } } } */"}, {"sha": "a95c6ae14d31d58e350f8a9d0994cc4de9aa4b14", "filename": "gcc/testsuite/gcc.target/arc/cmem-bit-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e389ba3073f8cfaa6209c27418ad175234c15482/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fcmem-bit-4.c?ref=e389ba3073f8cfaa6209c27418ad175234c15482", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -mcmem -O2\" } */\n+\n+struct strange_bool\n+{\n+  unsigned long long bool_bit   :1;\n+  unsigned long long other_bits :61;\n+};\n+\n+struct strange_bool a_strange_bool __attribute__((section(\".cmem\")));\n+\n+extern void bar();\n+\n+void foo() {\n+  if (a_strange_bool.bool_bit)\n+    bar();\n+}\n+\n+/* { dg-final { scan-assembler \"xldb r\\[0-9\\]+,\\\\\\[@a_strange_bool\\\\\\]\" } } */\n+/* { dg-final { scan-assembler \"btst_s r\\[0-9\\]+,7\" { target arceb-*-* } } } */"}]}