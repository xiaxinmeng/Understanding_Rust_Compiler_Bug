{"sha": "5067f3a0041a89b3200d70053923ffd84346b0f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2N2YzYTAwNDFhODliMzIwMGQ3MDA1MzkyM2ZmZDg0MzQ2YjBmMA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-13T10:33:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-13T10:33:47Z"}, "message": "[multiple changes]\n\n2017-09-13  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch13.adb (Register_Address_Clause_Check): New procedure to save\n\tthe suppression status of Alignment_Check on the current scope.\n\t(Alignment_Checks_Suppressed): New function to use the saved instead of\n\tthe current suppression status of Alignment_Check.\n\t(Address_Clause_Check_Record): Add Alignment_Checks_Suppressed field.\n\t(Analyze_Attribute_Definition_Clause): Instead of manually appending to\n\tthe table, call Register_Address_Clause_Check.\n\t(Validate_Address_Clauses): Call Alignment_Checks_Suppressed on the\n\trecorded address clause instead of its entity.\n\n2017-09-13  Jerome Guitton  <guitton@adacore.com>\n\n\t* libgnarl/s-tpopsp__vxworks-tls.adb,\n\tlibgnarl/s-tpopsp__vxworks-rtp.adb, libgnarl/s-tpopsp__vxworks.adb\n\t(Self): Register thread if task id is null.\n\n2017-09-13  Arnaud Charlet  <charlet@adacore.com>\n\n\t* libgnat/s-htable.adb, libgnat/s-htable.ads: Minor style tuning.\n\n2017-09-13  Arnaud Charlet  <charlet@adacore.com>\n\n\t* lib-xref-spark_specific.adb (Scopes): simplify hash map; now it maps\n\tfrom an entity to only scope index, as a mapping from an entity to the\n\tsame entity was useless.\n\t(Get_Scope_Num): refactor as a simple renaming; rename parameter from N\n\tto E.\n\t(Set_Scope_Num): refactor as a simple renaming; rename parameter from N\n\tto E.\n\t(Is_Constant_Object_Without_Variable_Input): remove local \"Result\"\n\tvariable, just use return statements.\n\nFrom-SVN: r252076", "tree": {"sha": "9e7a255dce1e4de7aef3ad036f3ae0dff43d912b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e7a255dce1e4de7aef3ad036f3ae0dff43d912b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5067f3a0041a89b3200d70053923ffd84346b0f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5067f3a0041a89b3200d70053923ffd84346b0f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5067f3a0041a89b3200d70053923ffd84346b0f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5067f3a0041a89b3200d70053923ffd84346b0f0/comments", "author": null, "committer": null, "parents": [{"sha": "231bba8d5c46680281fd3163acb33a961252d56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/231bba8d5c46680281fd3163acb33a961252d56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/231bba8d5c46680281fd3163acb33a961252d56a"}], "stats": {"total": 218, "additions": 173, "deletions": 45}, "files": [{"sha": "35ebd0c96c6ad3e636e6f36a38f1b17cc363ec84", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -1,3 +1,37 @@\n+2017-09-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch13.adb (Register_Address_Clause_Check): New procedure to save\n+\tthe suppression status of Alignment_Check on the current scope.\n+\t(Alignment_Checks_Suppressed): New function to use the saved instead of\n+\tthe current suppression status of Alignment_Check.\n+\t(Address_Clause_Check_Record): Add Alignment_Checks_Suppressed field.\n+\t(Analyze_Attribute_Definition_Clause): Instead of manually appending to\n+\tthe table, call Register_Address_Clause_Check.\n+\t(Validate_Address_Clauses): Call Alignment_Checks_Suppressed on the\n+\trecorded address clause instead of its entity.\n+\n+2017-09-13  Jerome Guitton  <guitton@adacore.com>\n+\n+\t* libgnarl/s-tpopsp__vxworks-tls.adb,\n+\tlibgnarl/s-tpopsp__vxworks-rtp.adb, libgnarl/s-tpopsp__vxworks.adb\n+\t(Self): Register thread if task id is null.\n+\n+2017-09-13  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* libgnat/s-htable.adb, libgnat/s-htable.ads: Minor style tuning.\n+\n+2017-09-13  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb (Scopes): simplify hash map; now it maps\n+\tfrom an entity to only scope index, as a mapping from an entity to the\n+\tsame entity was useless.\n+\t(Get_Scope_Num): refactor as a simple renaming; rename parameter from N\n+\tto E.\n+\t(Set_Scope_Num): refactor as a simple renaming; rename parameter from N\n+\tto E.\n+\t(Is_Constant_Object_Without_Variable_Input): remove local \"Result\"\n+\tvariable, just use return statements.\n+\n 2017-09-13  Arnaud Charlet  <charlet@adacore.com>\n \n \t* libgnarl/s-vxwext__kernel-smp.adb,"}, {"sha": "b6ddd93783ce24bd3f35def215621504244998c7", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -215,24 +215,20 @@ package body SPARK_Specific is\n            --  Packages\n \n            or else Nkind_In (N, N_Package_Body,\n-                                N_Package_Body_Stub,\n                                 N_Package_Declaration)\n            --  Protected units\n \n            or else Nkind_In (N, N_Protected_Body,\n-                                N_Protected_Body_Stub,\n                                 N_Protected_Type_Declaration)\n \n            --  Subprograms\n \n            or else Nkind_In (N, N_Subprogram_Body,\n-                                N_Subprogram_Body_Stub,\n                                 N_Subprogram_Declaration)\n \n            --  Task units\n \n            or else Nkind_In (N, N_Task_Body,\n-                                N_Task_Body_Stub,\n                                 N_Task_Type_Declaration)\n          then\n             Add_SPARK_Scope (N);\n@@ -310,8 +306,8 @@ package body SPARK_Specific is\n       function Get_Entity_Type (E : Entity_Id) return Character;\n       --  Return a character representing the type of entity\n \n-      function Get_Scope_Num (N : Entity_Id) return Nat;\n-      --  Return the scope number associated to entity N\n+      function Get_Scope_Num (E : Entity_Id) return Nat;\n+      --  Return the scope number associated with the entity E\n \n       function Is_Constant_Object_Without_Variable_Input\n         (E : Entity_Id) return Boolean;\n@@ -339,8 +335,8 @@ package body SPARK_Specific is\n       procedure Move (From : Natural; To : Natural);\n       --  Move procedure for Sort call\n \n-      procedure Set_Scope_Num (N : Entity_Id; Num : Nat);\n-      --  Associate entity N to scope number Num\n+      procedure Set_Scope_Num (E : Entity_Id; Num : Nat);\n+      --  Associate entity E with the scope number Num\n \n       procedure Update_Scope_Range\n         (S    : Scope_Index;\n@@ -353,16 +349,10 @@ package body SPARK_Specific is\n       No_Scope : constant Nat := 0;\n       --  Initial scope counter\n \n-      type Scope_Rec is record\n-         Num    : Nat;\n-         Entity : Entity_Id;\n-      end record;\n-      --  Type used to relate an entity and a scope number\n-\n       package Scopes is new GNAT.HTable.Simple_HTable\n         (Header_Num => Entity_Hashed_Range,\n-         Element    => Scope_Rec,\n-         No_Element => (Num => No_Scope, Entity => Empty),\n+         Element    => Nat,\n+         No_Element => No_Scope,\n          Key        => Entity_Id,\n          Hash       => Entity_Hash,\n          Equal      => \"=\");\n@@ -411,10 +401,7 @@ package body SPARK_Specific is\n       -- Get_Scope_Num --\n       -------------------\n \n-      function Get_Scope_Num (N : Entity_Id) return Nat is\n-      begin\n-         return Scopes.Get (N).Num;\n-      end Get_Scope_Num;\n+      function Get_Scope_Num (E : Entity_Id) return Nat renames Scopes.Get;\n \n       -----------------------------------------------\n       -- Is_Constant_Object_Without_Variable_Input --\n@@ -423,8 +410,6 @@ package body SPARK_Specific is\n       function Is_Constant_Object_Without_Variable_Input\n         (E : Entity_Id) return Boolean\n       is\n-         Result : Boolean;\n-\n       begin\n          case Ekind (E) is\n \n@@ -445,23 +430,21 @@ package body SPARK_Specific is\n                   end if;\n \n                   if Is_Imported (E) then\n-                     Result := False;\n+                     return False;\n                   else\n                      pragma Assert (Present (Expression (Decl)));\n-                     Result := Is_Static_Expression (Expression (Decl));\n+                     return Is_Static_Expression (Expression (Decl));\n                   end if;\n                end;\n \n             when E_In_Parameter\n                | E_Loop_Parameter\n             =>\n-               Result := True;\n+               return True;\n \n             when others =>\n-               Result := False;\n+               return False;\n          end case;\n-\n-         return Result;\n       end Is_Constant_Object_Without_Variable_Input;\n \n       ----------------------------\n@@ -663,10 +646,7 @@ package body SPARK_Specific is\n       -- Set_Scope_Num --\n       -------------------\n \n-      procedure Set_Scope_Num (N : Entity_Id; Num : Nat) is\n-      begin\n-         Scopes.Set (K => N, E => Scope_Rec'(Num => Num, Entity => N));\n-      end Set_Scope_Num;\n+      procedure Set_Scope_Num (E : Entity_Id; Num : Nat) renames Scopes.Set;\n \n       ------------------------\n       -- Update_Scope_Range --\n@@ -1430,7 +1410,11 @@ package body SPARK_Specific is\n               or else Nkind (N) in N_Later_Decl_Item\n               or else Nkind (N) = N_Entry_Body\n             then\n-               Process (N);\n+               if Nkind (N) in N_Body_Stub then\n+                  Process (Get_Body_From_Stub (N));\n+               else\n+                  Process (N);\n+               end if;\n             end if;\n \n             Traverse_Declaration_Or_Statement (N);"}, {"sha": "c7e2f66cd4055aad326135d0edfc2b46750f081f", "filename": "gcc/ada/libgnarl/s-tpopsp__vxworks-rtp.adb", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks-rtp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks-rtp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks-rtp.adb?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -72,9 +72,29 @@ package body Specific is\n    -- Self --\n    ----------\n \n+   --  To make Ada tasks and C threads interoperate better, we have added some\n+   --  functionality to Self. Suppose a C main program (with threads) calls an\n+   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n+   --  Eventually, a call will be made to self. Since the call is not coming\n+   --  from an Ada task, there will be no corresponding ATCB.\n+\n+   --  What we do in Self is to catch references that do not come from\n+   --  recognized Ada tasks, and create an ATCB for the calling thread.\n+\n+   --  The new ATCB will be \"detached\" from the normal Ada task master\n+   --  hierarchy, much like the existing implicitly created signal-server\n+   --  tasks.\n+\n    function Self return Task_Id is\n+      Result : constant Task_Id := To_Task_Id (tlsValueGet (ATCB_Key));\n    begin\n-      return To_Task_Id (tlsValueGet (ATCB_Key));\n+      if Result /= null then\n+         return Result;\n+      else\n+         --  If the value is Null then it is a non-Ada task\n+\n+         return Register_Foreign_Thread;\n+      end if;\n    end Self;\n \n end Specific;"}, {"sha": "7cdad5a5a4c6bdc9480d059793374dc2f979cf6b", "filename": "gcc/ada/libgnarl/s-tpopsp__vxworks-tls.adb", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks-tls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks-tls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks-tls.adb?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -71,9 +71,29 @@ package body Specific is\n    -- Self --\n    ----------\n \n+   --  To make Ada tasks and C threads interoperate better, we have added some\n+   --  functionality to Self. Suppose a C main program (with threads) calls an\n+   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n+   --  Eventually, a call will be made to self. Since the call is not coming\n+   --  from an Ada task, there will be no corresponding ATCB.\n+\n+   --  What we do in Self is to catch references that do not come from\n+   --  recognized Ada tasks, and create an ATCB for the calling thread.\n+\n+   --  The new ATCB will be \"detached\" from the normal Ada task master\n+   --  hierarchy, much like the existing implicitly created signal-server\n+   --  tasks.\n+\n    function Self return Task_Id is\n+      Result : constant Task_Id := ATCB;\n    begin\n-      return ATCB;\n+      if Result /= null then\n+         return Result;\n+      else\n+         --  If the value is Null then it is a non-Ada task\n+\n+         return Register_Foreign_Thread;\n+      end if;\n    end Self;\n \n end Specific;"}, {"sha": "bd8f92d57beace1663ad52800ef8c5c2001b0a7e", "filename": "gcc/ada/libgnarl/s-tpopsp__vxworks.adb", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpopsp__vxworks.adb?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -121,9 +121,29 @@ package body Specific is\n    -- Self --\n    ----------\n \n+   --  To make Ada tasks and C threads interoperate better, we have added some\n+   --  functionality to Self. Suppose a C main program (with threads) calls an\n+   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n+   --  Eventually, a call will be made to self. Since the call is not coming\n+   --  from an Ada task, there will be no corresponding ATCB.\n+\n+   --  What we do in Self is to catch references that do not come from\n+   --  recognized Ada tasks, and create an ATCB for the calling thread.\n+\n+   --  The new ATCB will be \"detached\" from the normal Ada task master\n+   --  hierarchy, much like the existing implicitly created signal-server\n+   --  tasks.\n+\n    function Self return Task_Id is\n+      Result : constant Task_Id := To_Task_Id (ATCB_Key);\n    begin\n-      return To_Task_Id (ATCB_Key);\n+      if Result /= null then\n+         return Result;\n+      else\n+         --  If the value is Null then it is a non-Ada task\n+\n+         return Register_Foreign_Thread;\n+      end if;\n    end Self;\n \n end Specific;"}, {"sha": "b640a34dc79289edf6d6e79be45a0baa421f1766", "filename": "gcc/ada/libgnat/s-htable.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnat%2Fs-htable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnat%2Fs-htable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-htable.adb?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -82,8 +82,8 @@ package body System.HTable is\n       function Get_First return Elmt_Ptr is\n       begin\n          Iterator_Started := True;\n-         Iterator_Index := Table'First;\n-         Iterator_Ptr := Table (Iterator_Index);\n+         Iterator_Index   := Table'First;\n+         Iterator_Ptr     := Table (Iterator_Index);\n          return Get_Non_Null;\n       end Get_First;\n "}, {"sha": "810343a2bc95df19cd616d52158e5bcfb12336b2", "filename": "gcc/ada/libgnat/s-htable.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnat%2Fs-htable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Flibgnat%2Fs-htable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-htable.ads?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -61,7 +61,7 @@ package System.HTable is\n \n       No_Element : Element;\n       --  The object that is returned by Get when no element has been set for\n-      --  a given key\n+      --  a given key.\n \n       type Key is private;\n       with function Hash  (F : Key)      return Header_Num;"}, {"sha": "1fc5c1591382c4beb81ccf5bcc510bc761174bbb", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5067f3a0041a89b3200d70053923ffd84346b0f0/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5067f3a0041a89b3200d70053923ffd84346b0f0", "patch": "@@ -203,6 +203,15 @@ package body Sem_Ch13 is\n    --  renaming_as_body. For tagged types, the specification is one of the\n    --  primitive specs.\n \n+   procedure Register_Address_Clause_Check\n+     (N   : Node_Id;\n+      X   : Entity_Id;\n+      A   : Uint;\n+      Y   : Entity_Id;\n+      Off : Boolean);\n+   --  Register a check for the address clause N. The rest of the parameters\n+   --  are in keeping with the components of Address_Clause_Check_Record below.\n+\n    procedure Resolve_Iterable_Operation\n      (N      : Node_Id;\n       Cursor : Entity_Id;\n@@ -318,6 +327,11 @@ package body Sem_Ch13 is\n \n       Off : Boolean;\n       --  Whether the address is offset within Y in the second case\n+\n+      Alignment_Checks_Suppressed : Boolean;\n+      --  Whether alignment checks are suppressed by an active scope suppress\n+      --  setting. We need to save the value in order to be able to reuse it\n+      --  after the back end has been run.\n    end record;\n \n    package Address_Clause_Checks is new Table.Table (\n@@ -328,6 +342,26 @@ package body Sem_Ch13 is\n      Table_Increment      => 200,\n      Table_Name           => \"Address_Clause_Checks\");\n \n+   function Alignment_Checks_Suppressed\n+     (ACCR : Address_Clause_Check_Record) return Boolean;\n+   --  Return whether the alignment check generated for the address clause\n+   --  is suppressed.\n+\n+   ---------------------------------\n+   -- Alignment_Checks_Suppressed --\n+   ---------------------------------\n+\n+   function Alignment_Checks_Suppressed\n+     (ACCR : Address_Clause_Check_Record) return Boolean\n+   is\n+   begin\n+      if Checks_May_Be_Suppressed (ACCR.X) then\n+         return Is_Check_Suppressed (ACCR.X, Alignment_Check);\n+      else\n+         return ACCR.Alignment_Checks_Suppressed;\n+      end if;\n+   end Alignment_Checks_Suppressed;\n+\n    -----------------------------------------\n    -- Adjust_Record_For_Reverse_Bit_Order --\n    -----------------------------------------\n@@ -5047,8 +5081,8 @@ package body Sem_Ch13 is\n                        and then not Is_Generic_Type (Etype (U_Ent))\n                        and then Address_Clause_Overlay_Warnings\n                      then\n-                        Address_Clause_Checks.Append\n-                          ((N, U_Ent, No_Uint, O_Ent, Off));\n+                        Register_Address_Clause_Check\n+                          (N, U_Ent, No_Uint, O_Ent, Off);\n                      end if;\n                   else\n                      --  If this is not an overlay, mark a variable as being\n@@ -5073,8 +5107,8 @@ package body Sem_Ch13 is\n                         if Compile_Time_Known_Value (Addr)\n                           and then Address_Clause_Overlay_Warnings\n                         then\n-                           Address_Clause_Checks.Append\n-                             ((N, U_Ent, Expr_Value (Addr), Empty, False));\n+                           Register_Address_Clause_Check\n+                             (N, U_Ent, Expr_Value (Addr), Empty, False);\n                         end if;\n                      end;\n                   end if;\n@@ -12254,6 +12288,22 @@ package body Sem_Ch13 is\n       end if;\n    end Push_Scope_And_Install_Discriminants;\n \n+   -----------------------------------\n+   -- Register_Address_Clause_Check --\n+   -----------------------------------\n+\n+   procedure Register_Address_Clause_Check\n+     (N   : Node_Id;\n+      X   : Entity_Id;\n+      A   : Uint;\n+      Y   : Entity_Id;\n+      Off : Boolean)\n+   is\n+      ACS : constant Boolean := Scope_Suppress.Suppress (Alignment_Check);\n+   begin\n+      Address_Clause_Checks.Append ((N, X, A, Y, Off, ACS));\n+   end Register_Address_Clause_Check;\n+\n    ------------------------\n    -- Rep_Item_Too_Early --\n    ------------------------\n@@ -13465,7 +13515,7 @@ package body Sem_Ch13 is\n                --  Check for known value not multiple of alignment\n \n                if No (ACCR.Y) then\n-                  if not Alignment_Checks_Suppressed (ACCR.X)\n+                  if not Alignment_Checks_Suppressed (ACCR)\n                     and then X_Alignment /= 0\n                     and then ACCR.A mod X_Alignment /= 0\n                   then\n@@ -13510,7 +13560,7 @@ package body Sem_Ch13 is\n                --  Note: we do not check the alignment if we gave a size\n                --  warning, since it would likely be redundant.\n \n-               elsif not Alignment_Checks_Suppressed (ACCR.X)\n+               elsif not Alignment_Checks_Suppressed (ACCR)\n                  and then Y_Alignment /= Uint_0\n                  and then\n                    (Y_Alignment < X_Alignment"}]}