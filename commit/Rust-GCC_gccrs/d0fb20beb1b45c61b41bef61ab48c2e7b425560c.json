{"sha": "d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBmYjIwYmViMWI0NWM2MWI0MWJlZjYxYWI0OGMyZTdiNDI1NTYwYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-03-13T09:26:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-03-13T09:26:25Z"}, "message": "re PR middle-end/35185 (ICE using openmp with g++-4.2)\n\n\tPR middle-end/35185\n\t* omp-low.c (lower_regimplify, init_tmp_var, save_tmp_var): Removed.\n\t(lower_omp_2): New function.\n\t(lower_omp_1, lower_omp): Rewritten.\n\n\t* testsuite/libgomp.c++/pr35185.C: New test.\n\nFrom-SVN: r133162", "tree": {"sha": "45d911a5091949c7b0cf5a010ff1cbc43fcb128a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45d911a5091949c7b0cf5a010ff1cbc43fcb128a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/comments", "author": null, "committer": null, "parents": [{"sha": "20cef83acca722837e262ac90c4f5fce51559274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20cef83acca722837e262ac90c4f5fce51559274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20cef83acca722837e262ac90c4f5fce51559274"}], "stats": {"total": 267, "additions": 152, "deletions": 115}, "files": [{"sha": "2fa006f4dcd3f3ae138fd436cefa403046648b65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "patch": "@@ -1,3 +1,10 @@\n+2008-03-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/35185\n+\t* omp-low.c (lower_regimplify, init_tmp_var, save_tmp_var): Removed.\n+\t(lower_omp_2): New function.\n+\t(lower_omp_1, lower_omp): Rewritten.\n+\n 2008-03-13  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR 35054\n@@ -22,7 +29,6 @@\n \n 2008-03-12  Paul Brook  <paul@codesourcery.com>\n \n-\tgcc/\n \t* config/arm/arm.c (arm_size_rtx_costs): Use ARM costs for Thumb-2.\n \n 2008-03-12  Uros Bizjak  <ubizjak@gmail.com>\n@@ -55,7 +61,7 @@\n \tAdjust stack pointer by poping call clobered registers.\n \t(arm_expand_prologue): Use offsets->saved_regs_mask.\n \tAdjust stack pointer by pushing extra registers.\n-\t* gcc/config/arm.h (arm_stack_offsets): Add saved_regs_mask.\n+\t* config/arm.h (arm_stack_offsets): Add saved_regs_mask.\n \n 2008-03-12  Paolo Bonzini  <bonzini@gnu.org>\n \n@@ -3974,7 +3980,7 @@\n 2008-01-02  Arthur Norman <acn1@cam.ac.uk>\n \n \tPR target/34013\n-\t* gcc/config/i386/i386.c (ix86_expand_prologue): Save red-zone\n+\t* config/i386/i386.c (ix86_expand_prologue): Save red-zone\n \twhile stack probing.\n \n 2008-01-01  Douglas Gregor  <doug.gregor@gmail.com>"}, {"sha": "340c621d350b8e0984f9166d06953e1c1e8046a0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 105, "deletions": 112, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "patch": "@@ -4880,184 +4880,177 @@ lower_omp_parallel (tree *stmt_p, omp_context *ctx)\n   pop_gimplify_context (NULL_TREE);\n }\n \n-\n-/* Pass *TP back through the gimplifier within the context determined by WI.\n-   This handles replacement of DECL_VALUE_EXPR, as well as adjusting the \n-   flags on ADDR_EXPR.  */\n-\n-static void\n-lower_regimplify (tree *tp, struct walk_stmt_info *wi)\n-{\n-  enum gimplify_status gs;\n-  tree pre = NULL;\n-\n-  if (wi->is_lhs)\n-    gs = gimplify_expr (tp, &pre, NULL, is_gimple_lvalue, fb_lvalue);\n-  else if (wi->val_only)\n-    gs = gimplify_expr (tp, &pre, NULL, is_gimple_val, fb_rvalue);\n-  else\n-    gs = gimplify_expr (tp, &pre, NULL, is_gimple_formal_tmp_var, fb_rvalue);\n-  gcc_assert (gs == GS_ALL_DONE);\n-\n-  if (pre)\n-    tsi_link_before (&wi->tsi, pre, TSI_SAME_STMT);\n-}\n-\n-/* Copy EXP into a temporary.  Insert the initialization statement before TSI.  */\n+/* Callback for lower_omp_1.  Return non-NULL if *tp needs to be\n+   regimplified.  */\n \n static tree\n-init_tmp_var (tree exp, tree_stmt_iterator *tsi)\n+lower_omp_2 (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n-  tree t, stmt;\n-\n-  t = create_tmp_var (TREE_TYPE (exp), NULL);\n-  DECL_GIMPLE_REG_P (t) = 1;\n-  stmt = build_gimple_modify_stmt (t, exp);\n-  SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n-  tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n-\n-  return t;\n-}\n-\n-/* Similarly, but copy from the temporary and insert the statement\n-   after the iterator.  */\n+  tree t = *tp;\n \n-static tree\n-save_tmp_var (tree exp, tree_stmt_iterator *tsi)\n-{\n-  tree t, stmt;\n+  /* Any variable with DECL_VALUE_EXPR needs to be regimplified.  */\n+  if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t))\n+    return t;\n \n-  t = create_tmp_var (TREE_TYPE (exp), NULL);\n-  DECL_GIMPLE_REG_P (t) = 1;\n-  stmt = build_gimple_modify_stmt (exp, t);\n-  SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n-  tsi_link_after (tsi, stmt, TSI_SAME_STMT);\n+  /* If a global variable has been privatized, TREE_CONSTANT on\n+     ADDR_EXPR might be wrong.  */\n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    recompute_tree_invariant_for_addr_expr (t);\n \n-  return t;\n+  *walk_subtrees = !TYPE_P (t) && !DECL_P (t);\n+  return NULL_TREE;\n }\n \n-/* Callback for walk_stmts.  Lower the OpenMP directive pointed by TP.  */\n-\n-static tree\n-lower_omp_1 (tree *tp, int *walk_subtrees, void *data)\n+static void\n+lower_omp_1 (tree *tp, omp_context *ctx, tree_stmt_iterator *tsi)\n {\n-  struct walk_stmt_info *wi = data;\n-  omp_context *ctx = wi->info;\n   tree t = *tp;\n \n+  if (!t)\n+    return;\n+\n+  if (EXPR_HAS_LOCATION (t))\n+    input_location = EXPR_LOCATION (t);\n+\n   /* If we have issued syntax errors, avoid doing any heavy lifting.\n      Just replace the OpenMP directives with a NOP to avoid\n      confusing RTL expansion.  */\n-  if (errorcount && OMP_DIRECTIVE_P (*tp))\n+  if (errorcount && OMP_DIRECTIVE_P (t))\n     {\n       *tp = build_empty_stmt ();\n-      return NULL_TREE;\n+      return;\n     }\n \n-  *walk_subtrees = 0;\n-  switch (TREE_CODE (*tp))\n+  switch (TREE_CODE (t))\n     {\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t  lower_omp_1 (tsi_stmt_ptr (i), ctx, &i);\n+      }\n+      break;\n+\n+    case COND_EXPR:\n+      lower_omp_1 (&COND_EXPR_THEN (t), ctx, NULL);\n+      lower_omp_1 (&COND_EXPR_ELSE (t), ctx, NULL);\n+      if (ctx\n+\t  && walk_tree (&COND_EXPR_COND (t), lower_omp_2, ctx, NULL))\n+\t{\n+\t  tree pre = NULL;\n+\t  gimplify_expr (&COND_EXPR_COND (t), &pre, NULL,\n+\t\t\t is_gimple_condexpr, fb_rvalue);\n+\t  if (pre)\n+\t    {\n+\t      if (tsi)\n+\t\ttsi_link_before (tsi, pre, TSI_SAME_STMT);\n+\t      else\n+\t\t{\n+\t\t  append_to_statement_list (t, &pre);\n+\t\t  *tp = pre;\n+\t\t}\n+\t    }\n+\t}\n+      break;\n+    case CATCH_EXPR:\n+      lower_omp_1 (&CATCH_BODY (t), ctx, NULL);\n+      break;\n+    case EH_FILTER_EXPR:\n+      lower_omp_1 (&EH_FILTER_FAILURE (t), ctx, NULL);\n+      break;\n+    case TRY_CATCH_EXPR:\n+    case TRY_FINALLY_EXPR:\n+      lower_omp_1 (&TREE_OPERAND (t, 0), ctx, NULL);\n+      lower_omp_1 (&TREE_OPERAND (t, 1), ctx, NULL);\n+      break;\n+    case BIND_EXPR:\n+      lower_omp_1 (&BIND_EXPR_BODY (t), ctx, NULL);\n+      break;\n+    case RETURN_EXPR:\n+      lower_omp_1 (&TREE_OPERAND (t, 0), ctx, NULL);\n+      break;\n+\n     case OMP_PARALLEL:\n       ctx = maybe_lookup_ctx (t);\n       lower_omp_parallel (tp, ctx);\n       break;\n-\n     case OMP_FOR:\n       ctx = maybe_lookup_ctx (t);\n       gcc_assert (ctx);\n       lower_omp_for (tp, ctx);\n       break;\n-\n     case OMP_SECTIONS:\n       ctx = maybe_lookup_ctx (t);\n       gcc_assert (ctx);\n       lower_omp_sections (tp, ctx);\n       break;\n-\n     case OMP_SINGLE:\n       ctx = maybe_lookup_ctx (t);\n       gcc_assert (ctx);\n       lower_omp_single (tp, ctx);\n       break;\n-\n     case OMP_MASTER:\n       ctx = maybe_lookup_ctx (t);\n       gcc_assert (ctx);\n       lower_omp_master (tp, ctx);\n       break;\n-\n     case OMP_ORDERED:\n       ctx = maybe_lookup_ctx (t);\n       gcc_assert (ctx);\n       lower_omp_ordered (tp, ctx);\n       break;\n-\n     case OMP_CRITICAL:\n       ctx = maybe_lookup_ctx (t);\n       gcc_assert (ctx);\n       lower_omp_critical (tp, ctx);\n       break;\n \n-    case VAR_DECL:\n-      if (ctx && DECL_HAS_VALUE_EXPR_P (t))\n+    default:\n+      if (ctx && walk_tree (tp, lower_omp_2, ctx, NULL))\n \t{\n-\t  lower_regimplify (&t, wi);\n-\t  if (wi->val_only)\n+\t  /* The gimplifier doesn't gimplify CALL_EXPR_STATIC_CHAIN.\n+\t     Handle that here.  */\n+\t  tree call = get_call_expr_in (t);\n+\t  if (call\n+\t      && CALL_EXPR_STATIC_CHAIN (call)\n+\t      && walk_tree (&CALL_EXPR_STATIC_CHAIN (call), lower_omp_2,\n+\t\t\t    ctx, NULL))\n \t    {\n-\t      if (wi->is_lhs)\n-\t\tt = save_tmp_var (t, &wi->tsi);\n-\t      else\n-\t\tt = init_tmp_var (t, &wi->tsi);\n+\t      tree pre = NULL;\n+\t      gimplify_expr (&CALL_EXPR_STATIC_CHAIN (call), &pre, NULL,\n+\t\t\t     is_gimple_val, fb_rvalue);\n+\t      if (pre)\n+\t\t{\n+\t\t  if (tsi)\n+\t\t    tsi_link_before (tsi, pre, TSI_SAME_STMT);\n+\t\t  else\n+\t\t    {\n+\t\t      append_to_statement_list (t, &pre);\n+\t\t      lower_omp_1 (&pre, ctx, NULL);\n+\t\t      *tp = pre;\n+\t\t      return;\n+\t\t    }\n+\t\t}\n \t    }\n-\t  *tp = t;\n-\t}\n-      break;\n-\n-    case ADDR_EXPR:\n-      if (ctx)\n-\tlower_regimplify (tp, wi);\n-      break;\n-\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-    case COMPONENT_REF:\n-    case VIEW_CONVERT_EXPR:\n-      if (ctx)\n-\tlower_regimplify (tp, wi);\n-      break;\n \n-    case INDIRECT_REF:\n-      if (ctx)\n-\t{\n-\t  wi->is_lhs = false;\n-\t  wi->val_only = true;\n-\t  lower_regimplify (&TREE_OPERAND (t, 0), wi);\n+\t  if (tsi == NULL)\n+\t    gimplify_stmt (tp);\n+\t  else\n+\t    {\n+\t      tree pre = NULL;\n+\t      gimplify_expr (tp, &pre, NULL, is_gimple_stmt, fb_none);\n+\t      if (pre)\n+\t\ttsi_link_before (tsi, pre, TSI_SAME_STMT);\n+\t    }\n \t}\n       break;\n-\n-    default:\n-      if (!TYPE_P (t) && !DECL_P (t))\n-\t*walk_subtrees = 1;\n-      break;\n     }\n-\n-  return NULL_TREE;\n }\n \n static void\n lower_omp (tree *stmt_p, omp_context *ctx)\n {\n-  struct walk_stmt_info wi;\n-\n-  memset (&wi, 0, sizeof (wi));\n-  wi.callback = lower_omp_1;\n-  wi.info = ctx;\n-  wi.val_only = true;\n-  wi.want_locations = true;\n-\n-  walk_stmts (&wi, stmt_p);\n+  lower_omp_1 (stmt_p, ctx, NULL);\n }\n \f\n /* Main entry point.  */"}, {"sha": "17d714c1d452d2e7084c7bdffc5d31dae12901a2", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "patch": "@@ -1,3 +1,8 @@\n+2008-03-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/35185\n+\t* testsuite/libgomp.c++/pr35185.C: New test.\n+\n 2008-03-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/35549"}, {"sha": "f22c7720787b7971e09f724e5627160cfbe55be5", "filename": "libgomp/testsuite/libgomp.c++/pr35185.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr35185.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fb20beb1b45c61b41bef61ab48c2e7b425560c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr35185.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr35185.C?ref=d0fb20beb1b45c61b41bef61ab48c2e7b425560c", "patch": "@@ -0,0 +1,33 @@\n+// PR middle-end/35185\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  S () : s (6) {}\n+  ~S () {}\n+  int s;\n+};\n+\n+__attribute__((noinline))\n+bool\n+bar (S s)\n+{\n+  return s.s != 6;\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  int err = 0;\n+#pragma omp parallel shared (s)\n+  {\n+    if (bar (s))\n+      #pragma omp atomic\n+\terr++;\n+  }\n+  if (err)\n+    abort ();\n+}"}]}