{"sha": "a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBlZjg4NGY3M2Q3OTFhYmQwOWNhM2Y1YTljY2Y3MjVlYWQ1ZmUzOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-27T13:26:02Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-27T13:26:02Z"}, "message": "vec.h: Implement integral type vector specialization.\n\n\t* vec.h: Implement integral type vector specialization.\n\t(VEC_T): Define a non-GTY structure.\n\t(VEC_T_GTY): Define a GTY structure.\n\t(VEC_TA): Rename to ...\n\t(VEC_TA_GTY): ... here.\n\t(DEF_VEC_I, DEF_VEC_ALLOC_I): New.\n\t(DEF_VEC_P, DEF_VEC_ALLOC_P): Adjust.\n\t(DEF_VEC_FUNC_P, DEF_VEC_ALLOC_FUNC_P): New, broken out of\n\tDEF_VEC_P and DEF_VEC_ALLOC_P.\n\t(DEF_VEC_O, DEF_VEC_ALLOC_O): Adjust.\n\t(DEF_VEC_FUNC_O, DEF_VEC_ALLOC_FUNC_O): New, broken out of\n\tDEF_VEC_O and DEF_VEC_ALLOC_O.\n\t* global.c: Use DEF_VEC_I, DEF_VEC_ALLOC_I.\n\t* lambda-code.c: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\nFrom-SVN: r100251", "tree": {"sha": "e3f210ab216eaf0a7c58b01f4405ce385f33b809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3f210ab216eaf0a7c58b01f4405ce385f33b809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/comments", "author": null, "committer": null, "parents": [{"sha": "6e3b9e2787800d6fde4828a532cc94d436193701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3b9e2787800d6fde4828a532cc94d436193701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e3b9e2787800d6fde4828a532cc94d436193701"}], "stats": {"total": 187, "additions": 125, "deletions": 62}, "files": [{"sha": "77d2700174ab01fe78b03b697d9798f21448fc35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "patch": "@@ -1,3 +1,22 @@\n+2005-05-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.h: Implement integral type vector specialization.\n+\t(VEC_T): Define a non-GTY structure.\n+\t(VEC_T_GTY): Define a GTY structure.\n+\t(VEC_TA): Rename to ...\n+\t(VEC_TA_GTY): ... here.\n+\t(DEF_VEC_I, DEF_VEC_ALLOC_I): New.\n+\t(DEF_VEC_P, DEF_VEC_ALLOC_P): Adjust.\n+\t(DEF_VEC_FUNC_P, DEF_VEC_ALLOC_FUNC_P): New, broken out of\n+\tDEF_VEC_P and DEF_VEC_ALLOC_P.\n+\t(DEF_VEC_O, DEF_VEC_ALLOC_O): Adjust.\n+\t(DEF_VEC_FUNC_O, DEF_VEC_ALLOC_FUNC_O): New, broken out of\n+\tDEF_VEC_O and DEF_VEC_ALLOC_O.\n+\t* global.c: Use DEF_VEC_I, DEF_VEC_ALLOC_I.\n+\t* lambda-code.c: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\n 2005-05-27  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-into-ssa.c (update_ssa): Ensure that the operand cache"}, {"sha": "dea1fc553479bfdfd6dac21bbd206ee042f815c6", "filename": "gcc/global.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "patch": "@@ -2098,8 +2098,8 @@ mark_reg_change (rtx reg, rtx setter, void *data)\n /* Classes of registers which could be early clobbered in the current\n    insn.  */\n \n-DEF_VEC_P(int);\n-DEF_VEC_ALLOC_P(int,heap);\n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int,heap);\n \n static VEC(int,heap) *earlyclobber_regclass;\n "}, {"sha": "738ea7a2651c0b582621a2c9474b2efe296bd432", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "patch": "@@ -115,8 +115,8 @@\n  Fourier-Motzkin elimination is used to compute the bounds of the base space\n  of the lattice.  */\n \n-DEF_VEC_P(int);\n-DEF_VEC_ALLOC_P(int,heap);\n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int,heap);\n \n static bool perfect_nestify (struct loops *, \n \t\t\t     struct loop *, VEC(tree,heap) *, "}, {"sha": "f1da55a7593aa8eb791f0f263279e7c1834c8a5c", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "patch": "@@ -107,8 +107,8 @@ static VEC(tree,heap) *block_defs_stack;\n /* Basic block vectors used in this file ought to be allocated in the\n    heap.  We use pointer vector, because ints can be easily passed by\n    value.  */\n-DEF_VEC_P(int);\n-DEF_VEC_ALLOC_P(int,heap);\n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int,heap);\n \n /* Set of existing SSA names being replaced by update_ssa.  */\n static sbitmap old_ssa_names;"}, {"sha": "e80ef8fd7fbb0b39dc3da23e10c541d05fedcff7", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "patch": "@@ -1281,8 +1281,8 @@ add_conflicts_if_valid (tpa_p tpa, conflict_graph graph,\n     }\n }\n \n-DEF_VEC_P(int);\n-DEF_VEC_ALLOC_P(int,heap);\n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int,heap);\n \n /* Return a conflict graph for the information contained in LIVE_INFO.  Only\n    conflicts between items in the same TPA list are added.  If optional "}, {"sha": "9b16976e268668c6a8f20c48278e752dd4ce9cb0", "filename": "gcc/vec.h", "status": "modified", "additions": 98, "deletions": 54, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ef884f73d791abd09ca3f5a9ccf725ead5fe39/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=a0ef884f73d791abd09ca3f5a9ccf725ead5fe39", "patch": "@@ -29,17 +29,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    out-of-line generic functions.  The vectors are designed to\n    interoperate with the GTY machinery.\n \n-   Because of the different behavior of objects and of pointers to\n-   objects, there are two flavors.  One to deal with a vector of\n-   pointers to objects, and one to deal with a vector of objects\n-   themselves.  Both of these pass pointers to objects around -- in\n-   the former case the pointers are stored into the vector and in the\n-   latter case the pointers are dereferenced and the objects copied\n-   into the vector.  Therefore, when using a vector of pointers, the\n-   objects pointed to must be long lived, but when dealing with a\n-   vector of objects, the source objects need not be.  The vector of\n-   pointers API is also appropriate for small register sized objects\n-   like integers.\n+   Because of the different behavior of structure objects, scalar\n+   objects and of pointers, there are three flavors, one for each of\n+   these variants.  Both the structure object and pointer variants\n+   pass pointers to objects around -- in the former case the pointers\n+   are stored into the vector and in the latter case the pointers are\n+   dereferenced and the objects copied into the vector.  The scalar\n+   object variant is suitable for int-like objects, and the vector\n+   elements are returned by value.\n \n    There are both 'index' and 'iterate' accessors.  The iterator\n    returns a boolean iteration condition and updates the iteration\n@@ -96,20 +93,24 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the 'space' predicate will tell you whether there is spare capacity\n    in the vector.  You will not normally need to use these two functions.\n    \n-   Vector types are defined using a DEF_VEC_{O,P}(TYPEDEF) macro, to\n+   Vector types are defined using a DEF_VEC_{O,P,I}(TYPEDEF) macro, to\n    get the non-memory allocation version, and then a\n-   DEF_VEC_ALLOC_{O,P}(TYPEDEF,ALLOC) macro to get memory managed\n+   DEF_VEC_ALLOC_{O,P,I}(TYPEDEF,ALLOC) macro to get memory managed\n    vectors.  Variables of vector type are declared using a\n    VEC(TYPEDEF,ALLOC) macro.  The ALLOC argument specifies the\n    allocation strategy, and can be either 'gc' or 'heap' for garbage\n    collected and heap allocated respectively.  It can be 'none' to get\n    a vector that must be explicitly allocated (for instance as a\n-   trailing array of another structure).  The characters O and P\n-   indicate whether TYPEDEF is a pointer (P) or object (O) type.  Be\n-   careful to pick the correct one, as you'll get an awkward and\n-   inefficient API if you get the wrong one.  There is a check, which\n-   results in a compile-time warning, for the P versions, but there is\n-   no check for the O versions, as that is not possible in plain C.\n+   trailing array of another structure).  The characters O, P and I\n+   indicate whether TYPEDEF is a pointer (P), object (O) or integral\n+   (I) type.  Be careful to pick the correct one, as you'll get an\n+   awkward and inefficient API if you use the wrong one.  There is a\n+   check, which results in a compile-time warning, for the P and I\n+   versions, but there is no check for the O versions, as that is not\n+   possible in plain C.  Due to the way GTY works, you must annotate\n+   any structures you wish to insert or reference from a vector with a\n+   GTY(()) tag.  You need to do this even if you never declare the GC\n+   allocated variants.\n \n    An example of their use would be,\n \n@@ -147,6 +148,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VEC_length(T,V)\t(VEC_OP(T,base,length)(VEC_BASE(V)))\n \n /* Get the final element of the vector.\n+   T VEC_T_last(VEC(T) *v); // Integer\n    T VEC_T_last(VEC(T) *v); // Pointer\n    T *VEC_T_last(VEC(T) *v); // Object\n \n@@ -155,6 +157,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VEC_last(T,V)\t(VEC_OP(T,base,last)(VEC_BASE(V) VEC_CHECK_INFO))\n \n /* Index into vector\n+   T VEC_T_index(VEC(T) *v, unsigned ix); // Integer\n    T VEC_T_index(VEC(T) *v, unsigned ix); // Pointer\n    T *VEC_T_index(VEC(T) *v, unsigned ix); // Object\n \n@@ -163,6 +166,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VEC_index(T,V,I) (VEC_OP(T,base,index)(VEC_BASE(V),I VEC_CHECK_INFO))\n \n /* Iterate over vector\n+   int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Integer\n    int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Pointer\n    int VEC_T_iterate(VEC(T) *v, unsigned ix, T *&ptr); // Object\n \n@@ -228,6 +232,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,A,reserve)(&(V),R VEC_CHECK_INFO MEM_STAT_INFO))\n \n /* Push object with no reallocation\n+   T *VEC_T_quick_push (VEC(T) *v, T obj); // Integer\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n    T *VEC_T_quick_push (VEC(T) *v, T *obj); // Object\n    \n@@ -240,6 +245,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,base,quick_push)(VEC_BASE(V),O VEC_CHECK_INFO))\n \n /* Push object with reallocation\n+   T *VEC_T_A_safe_push (VEC(T,A) *&v, T obj); // Integer\n    T *VEC_T_A_safe_push (VEC(T,A) *&v, T obj); // Pointer\n    T *VEC_T_A_safe_push (VEC(T,A) *&v, T *obj); // Object\n    \n@@ -251,6 +257,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,A,safe_push)(&(V),O VEC_CHECK_INFO MEM_STAT_INFO))\n \n /* Pop element off end\n+   T VEC_T_pop (VEC(T) *v);\t\t// Integer\n    T VEC_T_pop (VEC(T) *v);\t\t// Pointer\n    void VEC_T_pop (VEC(T) *v);\t\t// Object\n \n@@ -279,6 +286,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,A,safe_grow)(&(V),I VEC_CHECK_INFO))\n \n /* Replace element\n+   T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Integer\n    T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Pointer\n    T *VEC_T_replace (VEC(T) *v, unsigned ix, T *val);  // Object\n    \n@@ -292,6 +300,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,base,replace)(VEC_BASE(V),I,O VEC_CHECK_INFO))\n \n /* Insert object with no reallocation\n+   T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Integer\n    T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Pointer\n    T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T *val); // Object\n    \n@@ -304,6 +313,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,base,quick_insert)(VEC_BASE(V),I,O VEC_CHECK_INFO))\n \n /* Insert object with reallocation\n+   T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Integer\n    T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Pointer\n    T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T *val); // Object\n    \n@@ -316,6 +326,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,A,safe_insert)(&(V),I,O VEC_CHECK_INFO MEM_STAT_INFO))\n      \n /* Remove element retaining order\n+   T VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Integer\n    T VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Pointer\n    void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Object\n    \n@@ -327,6 +338,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t(VEC_OP(T,base,ordered_remove)(VEC_BASE(V),I VEC_CHECK_INFO))\n \n /* Remove element destroying order\n+   T VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Integer\n    T VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Pointer\n    void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Object\n    \n@@ -346,6 +358,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VEC_address(T,V)\t\t(VEC_OP(T,base,address)(VEC_BASE(V)))\n \n /* Find the first index in the vector not less than the object.\n+   unsigned VEC_T_lower_bound (VEC(T) *v, const T val, \n+                               bool (*lessthan) (const T, const T)); // Integer\n    unsigned VEC_T_lower_bound (VEC(T) *v, const T val, \n                                bool (*lessthan) (const T, const T)); // Pointer\n    unsigned VEC_T_lower_bound (VEC(T) *v, const T *val,\n@@ -397,6 +411,14 @@ extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n \n /* Base of vector type, not user visible.  */     \n #define VEC_T(T,B)\t\t\t\t\t\t\t  \\\n+typedef struct VEC(T,B) \t\t\t\t \t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  unsigned num;\t\t\t\t\t\t\t\t  \\\n+  unsigned alloc;\t\t\t\t\t\t\t  \\\n+  T vec[1];\t\t\t\t\t\t\t\t  \\\n+} VEC(T,B)\n+\n+#define VEC_T_GTY(T,B)\t\t\t\t\t\t\t  \\\n typedef struct VEC(T,B) GTY(())\t\t\t\t \t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   unsigned num;\t\t\t\t\t\t\t\t  \\\n@@ -405,7 +427,7 @@ typedef struct VEC(T,B) GTY(())\t\t\t\t \t\t  \\\n } VEC(T,B)\n \n /* Derived vector type, user visible.  */\n-#define VEC_TA(T,B,A,GTY)\t\t\t\t\t\t  \\\n+#define VEC_TA_GTY(T,B,A,GTY)\t\t\t\t\t\t  \\\n typedef struct VEC(T,A) GTY\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC(T,B) base;\t\t\t\t\t\t\t  \\\n@@ -414,20 +436,49 @@ typedef struct VEC(T,A) GTY\t\t\t\t\t\t  \\\n /* Convert to base type.  */\n #define VEC_BASE(P)  ((P) ? &(P)->base : 0)\n \n+/* Vector of integer-like object.  */\n+#if IN_GENGTYPE\n+{\"DEF_VEC_I\", VEC_STRINGIFY (VEC_T(#0,#1)) \";\", \"none\"},\n+{\"DEF_VEC_ALLOC_I\", VEC_STRINGIFY (VEC_TA (#0,#1,#2,#3)) \";\", NULL},\n+#else\n+#define DEF_VEC_I(T)\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,must_be,integral_type) (void) \t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  (void)~(T)0;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+VEC_T(T,base);\t\t\t\t\t\t\t\t  \\\n+VEC_TA_GTY(T,base,none,);\t\t\t\t\t\t  \\\n+DEF_VEC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_I(T,A)\t\t\t\t\t\t  \\\n+VEC_TA_GTY(T,base,A,);\t\t\t\t\t\t\t  \\\n+DEF_VEC_ALLOC_FUNC_P(T,A)\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#endif\n+\n /* Vector of pointer to object.  */\n #if IN_GENGTYPE\n-{\"DEF_VEC_P\", VEC_STRINGIFY (VEC_T(#0,#1)) \";\", \"none\"},\n-{\"DEF_VEC_ALLOC_P\", VEC_STRINGIFY (VEC_TA (#0,#1,#2,#3)) \";\", NULL},\n+{\"DEF_VEC_P\", VEC_STRINGIFY (VEC_T_GTY(#0,#1)) \";\", \"none\"},\n+{\"DEF_VEC_ALLOC_P\", VEC_STRINGIFY (VEC_TA_GTY (#0,#1,#2,#3)) \";\", NULL},\n #else\n-  \n #define DEF_VEC_P(T) \t\t\t\t\t\t\t  \\\n-VEC_T(T,base);\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,must,be_a_pointer_or_integer) (void) \t  \\\n+static inline void VEC_OP (T,must_be,pointer_type) (void) \t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  (void)((T)0 == (void *)0);\t\t\t\t\t\t  \\\n+  (void)((T)1 == (void *)1);\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+VEC_T_GTY(T,base);\t\t\t\t\t\t\t  \\\n+VEC_TA_GTY(T,base,none,);\t\t\t\t\t\t  \\\n+DEF_VEC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_P(T,A)\t\t\t\t\t\t  \\\n+VEC_TA_GTY(T,base,A,);\t\t\t\t\t\t\t  \\\n+DEF_VEC_ALLOC_FUNC_P(T,A)\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#endif\n+\n+#define DEF_VEC_FUNC_P(T)\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)   \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n@@ -598,13 +649,9 @@ static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n           len_ = half_;\t\t\t\t\t\t\t  \\\n      }\t\t\t\t\t\t\t\t\t  \\\n    return first_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-VEC_TA(T,base,none,)\n-  \n-#define DEF_VEC_ALLOC_P(T,A)\t\t\t\t\t\t  \\\n-VEC_TA(T,base,A,);\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n+}\n+\n+#define DEF_VEC_ALLOC_FUNC_P(T,A)\t\t\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,alloc)\t\t\t\t  \\\n      (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -659,20 +706,25 @@ static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n  \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-#endif\n+}\n \n /* Vector of object.  */\n #if IN_GENGTYPE\n-{\"DEF_VEC_O\", VEC_STRINGIFY (VEC_T(#0,#1)) \";\", \"none\"},\n-{\"DEF_VEC_ALLOC_O\", VEC_STRINGIFY (VEC_TA(#0,#1,#2,#3)) \";\", NULL},\n+{\"DEF_VEC_O\", VEC_STRINGIFY (VEC_T_GTY(#0,#1)) \";\", \"none\"},\n+{\"DEF_VEC_ALLOC_O\", VEC_STRINGIFY (VEC_TA_GTY(#0,#1,#2,#3)) \";\", NULL},\n #else\n-  \n #define DEF_VEC_O(T)\t\t\t\t\t\t\t  \\\n-VEC_T(T,base);\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n+VEC_T_GTY(T,base);\t\t\t\t\t\t\t  \\\n+VEC_TA_GTY(T,base,none,);\t\t\t\t\t\t  \\\n+DEF_VEC_FUNC_O(T)\t\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_O(T,A)\t\t\t\t\t\t  \\\n+VEC_TA_GTY(T,base,A,);\t\t\t\t\t\t\t  \\\n+DEF_VEC_ALLOC_FUNC_O(T,A)\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#endif\n+\n+#define DEF_VEC_FUNC_O(T)\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n@@ -830,13 +882,9 @@ static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n           len_ = half_;\t\t\t\t\t\t\t  \\\n      }\t\t\t\t\t\t\t\t\t  \\\n    return first_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-VEC_TA(T,base,none,)\n+}\n \n-#define DEF_VEC_ALLOC_O(T,A)\t\t\t\t\t\t  \\\n-VEC_TA(T,base,A,);\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n+#define DEF_VEC_ALLOC_FUNC_O(T,A)\t\t\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n      (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -899,9 +947,5 @@ static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-#endif\n-\n+}\n #endif /* GCC_VEC_H */"}]}