{"sha": "61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFkM2NkYmIxMmU4N2RkOGJmZWM4Y2UwODJjMGFjMWQ1Nzc2NDc0Yw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2005-06-18T13:18:52Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-06-18T13:18:52Z"}, "message": "tree.def (REDUC_MAX_EXPR, [...]): New tree-codes.\n\n        * tree.def (REDUC_MAX_EXPR, REDUC_MIN_EXPR, REDUC_PLUS_EXPR): New\n        tree-codes.\n        * optabs.h (OTI_reduc_smax, OTI_reduc_umax, OTI_reduc_smin,\n        OTI_reduc_umin, OTI_reduc_plus): New optabs for reduction.\n        (reduc_smax_optab, reduc_umax_optab, reduc_smin_optab, reduc_umin_optab,\n        reduc_plus_optab): New optabs for reduction.\n        * expr.c (expand_expr_real_1): Handle new tree-codes.\n        * tree-inline.c (estimate_num_insns_1): Handle new tree-codes.\n        * tree-pretty-print.c (dump_generic_node, op_prio, op_symbol): Handle\n        new tree-codes.\n        * optabs.c (optab_for_tree_code): Handle new tree-codes.\n        (init_optabs): Initialize new optabs.\n        * genopinit.c (optabs): Define handlers for new optabs.\n\n        * tree-vect-analyze.c (vect_analyze_operations): Fail vectorization in\n        case of a phi that is marked as relevant. Call vectorizable_reduction.\n        (vect_mark_relevant): Phis may be marked as relevant.\n        (vect_mark_stmts_to_be_vectorized): The use corresponding to the\n        reduction variable in a reduction stmt does not mark its defining phi\n        as relevant. Update documentation accordingly.\n        (vect_can_advance_ivs_p): Skip reduction phis.\n        * tree-vect-transform.c (vect_get_vec_def_for_operand): Takes\n        additional argument. Handle reduction.\n        (vect_create_destination_var): Update call to vect_get_new_vect_var.\n        Handle non-vector argument.\n        (get_initial_def_for_reduction): New function.\n        (vect_create_epilog_for_reduction): New function.\n        (vectorizable_reduction): New function.\n        (vect_get_new_vect_var): Handle new vect_var_kind.\n        (vectorizable_assignment, vectorizable_operation, vectorizable_store,\n        vectorizable_condition): Update call to vect_get_new_vect_var.\n        (vect_transform_stmt): Call vectorizable_reduction.\n        (vect_update_ivs_after_vectorizer): Skip reduction phis.\n        (vect_transform_loop): Skip if stmt is both not relevant and not live.\n        * tree-vectorizer.c (reduction_code_for_scalar_code): New function.\n        (vect_is_simple_reduction): Was empty - added implementation.\n        * tree-vectorizer.h (vect_scalar_var): New enum vect_var_kind value.\n        (reduc_vec_info_type): New enum vect_def_type value.\n        * config/rs6000/altivec.md (reduc_smax_v4si, reduc_smax_v4sf,\n        reduc_umax_v4si, reduc_smin_v4si, reduc_umin_v4sf, reduc_smin_v4sf,\n        reduc_plus_v4si, reduc_plus_v4sf): New define_expands.\n\n        * tree-vect-analyze.c (vect_determine_vectorization_factor): Remove\n        ENABLE_CHECKING around gcc_assert.\n        * tree-vect-transform.c (vect_do_peeling_for_loop_bound,\n        (vect_do_peeling_for_alignment, vect_transform_loop,\n        vect_get_vec_def_for_operand): Likewise.\n\nFrom-SVN: r101155", "tree": {"sha": "76522a399271e0448291fb8b63bbbf3f898dc165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76522a399271e0448291fb8b63bbbf3f898dc165"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/comments", "author": null, "committer": null, "parents": [{"sha": "6d409ca872d76ffce2b945153486992787e74250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d409ca872d76ffce2b945153486992787e74250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d409ca872d76ffce2b945153486992787e74250"}], "stats": {"total": 1250, "additions": 1149, "deletions": 101}, "files": [{"sha": "73986314282ff7ce894e486db9ba8a2fb6524748", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -1,3 +1,53 @@\n+2005-06-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree.def (REDUC_MAX_EXPR, REDUC_MIN_EXPR, REDUC_PLUS_EXPR): New\n+\ttree-codes.\n+\t* optabs.h (OTI_reduc_smax, OTI_reduc_umax, OTI_reduc_smin,\n+\tOTI_reduc_umin, OTI_reduc_plus): New optabs for reduction. \n+\t(reduc_smax_optab, reduc_umax_optab, reduc_smin_optab, reduc_umin_optab,\n+\treduc_plus_optab): New optabs for reduction.\n+\t* expr.c (expand_expr_real_1): Handle new tree-codes.\n+\t* tree-inline.c (estimate_num_insns_1): Handle new tree-codes.\n+\t* tree-pretty-print.c (dump_generic_node, op_prio, op_symbol): Handle\n+\tnew tree-codes.\n+\t* optabs.c (optab_for_tree_code): Handle new tree-codes.\n+\t(init_optabs): Initialize new optabs.\n+\t* genopinit.c (optabs): Define handlers for new optabs. \n+\n+\t* tree-vect-analyze.c (vect_analyze_operations): Fail vectorization in\n+\tcase of a phi that is marked as relevant. Call vectorizable_reduction.\n+\t(vect_mark_relevant): Phis may be marked as relevant.\n+\t(vect_mark_stmts_to_be_vectorized): The use corresponding to the \n+\treduction variable in a reduction stmt does not mark its defining phi\n+\tas relevant. Update documentation accordingly.\n+\t(vect_can_advance_ivs_p): Skip reduction phis.\n+\t* tree-vect-transform.c (vect_get_vec_def_for_operand): Takes\n+\tadditional argument. Handle reduction.\n+\t(vect_create_destination_var): Update call to vect_get_new_vect_var.\n+\tHandle non-vector argument.\n+\t(get_initial_def_for_reduction): New function.\n+\t(vect_create_epilog_for_reduction): New function. \n+\t(vectorizable_reduction): New function.\n+\t(vect_get_new_vect_var): Handle new vect_var_kind.       \n+\t(vectorizable_assignment, vectorizable_operation, vectorizable_store,\n+\tvectorizable_condition): Update call to vect_get_new_vect_var.\n+\t(vect_transform_stmt): Call vectorizable_reduction.\n+\t(vect_update_ivs_after_vectorizer): Skip reduction phis.\n+\t(vect_transform_loop): Skip if stmt is both not relevant and not live.\n+\t* tree-vectorizer.c (reduction_code_for_scalar_code): New function.\n+\t(vect_is_simple_reduction): Was empty - added implementation.\n+\t* tree-vectorizer.h (vect_scalar_var): New enum vect_var_kind value.\n+\t(reduc_vec_info_type): New enum vect_def_type value.\n+\t* config/rs6000/altivec.md (reduc_smax_v4si, reduc_smax_v4sf,\n+\treduc_umax_v4si, reduc_smin_v4si, reduc_umin_v4sf, reduc_smin_v4sf,\n+\treduc_plus_v4si, reduc_plus_v4sf): New define_expands.\n+\n+\t* tree-vect-analyze.c (vect_determine_vectorization_factor): Remove\n+\tENABLE_CHECKING around gcc_assert.\n+\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound,\n+\t(vect_do_peeling_for_alignment, vect_transform_loop, \n+\tvect_get_vec_def_for_operand): Likewise.\n+\n 2005-06-18  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* config/ia64/ia64.c (ia64_function_arg): Set up a PARALLEL for a"}, {"sha": "3b2044783c262db769891f356949e559a412d720", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -1825,6 +1825,160 @@\n   operands[3] = gen_reg_rtx (GET_MODE (operands[0]));\n })\n \n+;; Reduction\n+\n+(define_expand \"reduc_smax_v4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{  \n+  rtx vtmp1 = gen_reg_rtx (V4SImode);\n+  rtx vtmp2 = gen_reg_rtx (V4SImode);\n+  rtx vtmp3 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_smaxv4si3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_smaxv4si3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+\n+(define_expand \"reduc_smax_v4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx vtmp1 = gen_reg_rtx (V4SFmode);\n+  rtx vtmp2 = gen_reg_rtx (V4SFmode);\n+  rtx vtmp3 = gen_reg_rtx (V4SFmode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4sf (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_smaxv4sf3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4sf (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_smaxv4sf3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+\n+(define_expand \"reduc_umax_v4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx vtmp1 = gen_reg_rtx (V4SImode);\n+  rtx vtmp2 = gen_reg_rtx (V4SImode);\n+  rtx vtmp3 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_umaxv4si3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_umaxv4si3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+\n+(define_expand \"reduc_smin_v4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx vtmp1 = gen_reg_rtx (V4SImode);\n+  rtx vtmp2 = gen_reg_rtx (V4SImode);\n+  rtx vtmp3 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_sminv4si3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_sminv4si3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+\n+(define_expand \"reduc_smin_v4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vtmp1 = gen_reg_rtx (V4SFmode);\n+  rtx vtmp2 = gen_reg_rtx (V4SFmode);\n+  rtx vtmp3 = gen_reg_rtx (V4SFmode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4sf (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_sminv4sf3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4sf (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_sminv4sf3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+\n+(define_expand \"reduc_umin_v4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx vtmp1 = gen_reg_rtx (V4SImode);\n+  rtx vtmp2 = gen_reg_rtx (V4SImode);\n+  rtx vtmp3 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_uminv4si3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_uminv4si3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+\n+(define_expand \"reduc_plus_v4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx vtmp1 = gen_reg_rtx (V4SImode);\n+  rtx vtmp2 = gen_reg_rtx (V4SImode);\n+  rtx vtmp3 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_addv4si3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_addv4si3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+  \n+(define_expand \"reduc_plus_v4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx vtmp1 = gen_reg_rtx (V4SFmode);\n+  rtx vtmp2 = gen_reg_rtx (V4SFmode);\n+  rtx vtmp3 = gen_reg_rtx (V4SFmode);\n+\n+  emit_insn (gen_altivec_vsldoi_v4sf (vtmp1, operands[1], operands[1], \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n+  emit_insn (gen_addv4sf3 (vtmp2, operands[1], vtmp1));\n+  emit_insn (gen_altivec_vsldoi_v4sf (vtmp3, vtmp2, vtmp2, \n+\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n+  emit_insn (gen_addv4sf3 (operands[0], vtmp2, vtmp3));\n+  DONE;\n+}\")\n+\n (define_insn \"vec_realign_load_v4sf\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n         (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")"}, {"sha": "ac500b5d52c70a726371fa78358b213ba65a7f6f", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -8356,6 +8356,16 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         return temp;\n       }\n \n+    case REDUC_MAX_EXPR:\n+    case REDUC_MIN_EXPR:\n+    case REDUC_PLUS_EXPR:\n+      {\n+        op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+        this_optab = optab_for_tree_code (code, type);\n+        temp = expand_unop (mode, this_optab, op0, target, unsignedp);\n+        gcc_assert (temp);\n+        return temp;\n+      }\n \n     default:\n       return lang_hooks.expand_expr (exp, original_target, tmode,"}, {"sha": "eea084d22d52a90a361068967907d45986ca775b", "filename": "gcc/genopinit.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -198,7 +198,12 @@ static const char * const optabs[] =\n   \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\",\n   \"vec_realign_load_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_load_$a$)\",\n   \"vcond_gen_code[$A] = CODE_FOR_$(vcond$a$)\",\n-  \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\"\n+  \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\",\n+  \"reduc_smax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smax_$a$)\",\n+  \"reduc_umax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umax_$a$)\",\n+  \"reduc_smin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smin_$a$)\",\n+  \"reduc_umin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umin_$a$)\",\n+  \"reduc_plus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_plus_$a$)\" \n };\n \n static void gen_insn (rtx);"}, {"sha": "cd4f2cbe6d097a59c66c581742af8285f385e582", "filename": "gcc/optabs.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -294,6 +294,15 @@ optab_for_tree_code (enum tree_code code, tree type)\n     case REALIGN_LOAD_EXPR:\n       return vec_realign_load_optab;\n \n+    case REDUC_MAX_EXPR:\n+      return TYPE_UNSIGNED (type) ? reduc_umax_optab : reduc_smax_optab;\n+\n+    case REDUC_MIN_EXPR:\n+      return TYPE_UNSIGNED (type) ? reduc_umin_optab : reduc_smin_optab;\n+\n+    case REDUC_PLUS_EXPR:\n+      return reduc_plus_optab;\n+\n     default:\n       break;\n     }\n@@ -5061,6 +5070,12 @@ init_optabs (void)\n   cstore_optab = init_optab (UNKNOWN);\n   push_optab = init_optab (UNKNOWN);\n \n+  reduc_smax_optab = init_optab (UNKNOWN);\n+  reduc_umax_optab = init_optab (UNKNOWN);\n+  reduc_smin_optab = init_optab (UNKNOWN);\n+  reduc_umin_optab = init_optab (UNKNOWN);\n+  reduc_plus_optab = init_optab (UNKNOWN);\n+\n   vec_extract_optab = init_optab (UNKNOWN);\n   vec_set_optab = init_optab (UNKNOWN);\n   vec_init_optab = init_optab (UNKNOWN);"}, {"sha": "2495fedef0bc27d7f9b38117ea80010c99e4ba9d", "filename": "gcc/optabs.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -231,6 +231,13 @@ enum optab_index\n   /* Conditional add instruction.  */\n   OTI_addcc,\n \n+  /* Reduction operations on a vector operand.  */\n+  OTI_reduc_smax,\n+  OTI_reduc_umax,\n+  OTI_reduc_smin,\n+  OTI_reduc_umin,\n+  OTI_reduc_plus,\n+\n   /* Set specified field of vector operand.  */\n   OTI_vec_set,\n   /* Extract specified field of vector operand.  */\n@@ -347,6 +354,12 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define push_optab (optab_table[OTI_push])\n #define addcc_optab (optab_table[OTI_addcc])\n \n+#define reduc_smax_optab (optab_table[OTI_reduc_smax])\n+#define reduc_umax_optab (optab_table[OTI_reduc_umax])\n+#define reduc_smin_optab (optab_table[OTI_reduc_smin])\n+#define reduc_umin_optab (optab_table[OTI_reduc_umin])\n+#define reduc_plus_optab (optab_table[OTI_reduc_plus])\n+\n #define vec_set_optab (optab_table[OTI_vec_set])\n #define vec_extract_optab (optab_table[OTI_vec_extract])\n #define vec_init_optab (optab_table[OTI_vec_init])"}, {"sha": "375bd449df3ecf5d7b869870a999b760be0644ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -1,3 +1,11 @@\n+2005-06-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_reduction): New.\n+\t* gcc.dg/vect/vect-reduc-1.c: Now vectorizable for vect_reduction\n+\ttargets.\n+\t* gcc.dg/vect/vect-reduc-2.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-3.c: Likewise.\n+\n 2005-06-18  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* gcc.target/ia64/float80-varargs-1.c: New test."}, {"sha": "9fce8b3e1a3ee2bb14072ff6d83653d34795317e", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-1.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -7,7 +7,6 @@\n #define DIFF 242\n \n /* Test vectorization of reduction of unsigned-int.  */\n-/* Not supported yet.  */\n \n int main1 (unsigned int x, unsigned int max_result)\n {\n@@ -52,5 +51,4 @@ int main (void)\n   return main1 (0, 15);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported use in stmt.\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail {! vect_reduction} } } } */"}, {"sha": "38693539f33d24553a0e1622db62b652920b0de5", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-2.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -8,7 +8,6 @@\n #define DIFF 242\n \n /* Test vectorization of reduction of signed-int.  */\n-/* Not supported yet.  */\n \n int main1 (int x, int max_result)\n {\n@@ -50,5 +49,4 @@ int main (void)\n   return main1 (0, 15);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported use in stmt.\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail {! vect_reduction} } } } */"}, {"sha": "398d9cdb34b2529212d43c7ca10fb9aa34f2c13e", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-3.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -8,7 +8,6 @@\n \n /* Test vectorization of reduction of unsigned-int in the presence\n    of unknown-loop-bound.  */\n-/* Not supported yet.  */\n \n int main1 (int n)\n {\n@@ -37,5 +36,4 @@ int main (void)\n   return main1 (N-1);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported use in stmt.\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail {! vect_reduction} } } } */"}, {"sha": "4facec651e8b8ffed800ccf6312f27ae7838c533", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -988,6 +988,23 @@ proc check_effective_target_vect_int_mult { } {\n     return $et_vect_int_mult_saved\n }\n \n+# Return 1 if the target supports vector reduction\n+\n+proc check_effective_target_vect_reduction { } {\n+    global et_vect_reduction_saved\n+\n+    if [info exists et_vect_reduction_saved] { \n+        verbose \"check_effective_target_vect_reduction: using cached result\" 2\n+    } else {\n+        set et_vect_reduction_saved 0\n+        if { [istarget powerpc*-*-*] } {\n+            set et_vect_reduction_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_reduction: returning $et_vect_reduction_saved\" 2\n+    return $et_vect_reduction_saved\n+}   \n+\n # Return 1 if the target supports atomic operations on \"int\" and \"long\".\n \n proc check_effective_target_sync_int_long { } {"}, {"sha": "7fa43507630f8be4ba1533f24611c17cbdb69c59", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -1736,6 +1736,10 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \n     case REALIGN_LOAD_EXPR:\n \n+    case REDUC_MAX_EXPR:\n+    case REDUC_MIN_EXPR:\n+    case REDUC_PLUS_EXPR:\n+\n     case RESX_EXPR:\n       *count += 1;\n       break;"}, {"sha": "1922be7f4d33fbd4c1e3847235646af60b63b7cb", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -1535,6 +1535,24 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case REDUC_MAX_EXPR:\n+      pp_string (buffer, \" REDUC_MAX_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case REDUC_MIN_EXPR:\n+      pp_string (buffer, \" REDUC_MIN_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case REDUC_PLUS_EXPR:\n+      pp_string (buffer, \" REDUC_PLUS_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     default:\n       NIY;\n     }\n@@ -1817,6 +1835,9 @@ op_prio (tree op)\n     case ABS_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n+    case REDUC_MAX_EXPR:\n+    case REDUC_MIN_EXPR:\n+    case REDUC_PLUS_EXPR:\n       return 16;\n \n     case SAVE_EXPR:\n@@ -1907,6 +1928,9 @@ op_symbol (tree op)\n     case PLUS_EXPR:\n       return \"+\";\n \n+    case REDUC_PLUS_EXPR:\n+      return \"r+\";\n+\n     case NEGATE_EXPR:\n     case MINUS_EXPR:\n       return \"-\";"}, {"sha": "1cca9e84c07171656ba4b976531fe977e548c951", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 80, "deletions": 46, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -413,10 +413,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           else\n             vectorization_factor = nunits;\n \n-#ifdef ENABLE_CHECKING\n           gcc_assert (GET_MODE_SIZE (TYPE_MODE (scalar_type))\n                         * vectorization_factor == UNITS_PER_SIMD_WORD);\n-#endif\n         }\n     }\n \n@@ -483,8 +481,16 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t    return false;\n \t  }\n \n-          gcc_assert (!STMT_VINFO_RELEVANT_P (stmt_info));\n-        }\n+\t  if (STMT_VINFO_RELEVANT_P (stmt_info))\n+\t    {\n+\t      /* Most likely a reduction-like computation that is used\n+\t         in the loop.  */\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t                                LOOP_LOC (loop_vinfo)))\n+\t        fprintf (vect_dump, \"not vectorized: unsupported pattern.\");\n+ \t     return false;\n+\t    }\n+\t}\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n@@ -541,7 +547,12 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t  if (STMT_VINFO_LIVE_P (stmt_info))\n \t    {\n-\t      ok = vectorizable_live_operation (stmt, NULL, NULL);\n+\t      ok = vectorizable_reduction (stmt, NULL, NULL);\n+\n+\t      if (ok)\n+                need_to_vectorize = true;\n+              else\n+\t        ok = vectorizable_live_operation (stmt, NULL, NULL);\n \n \t      if (!ok)\n \t\t{\n@@ -2148,13 +2159,13 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n     fprintf (vect_dump, \"mark relevant %d, live %d.\",relevant_p, live_p);\n \n   STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n+  STMT_VINFO_RELEVANT_P (stmt_info) |= relevant_p;\n \n   if (TREE_CODE (stmt) == PHI_NODE)\n-    /* Don't mark as relevant because it's not going to vectorized.  */\n+    /* Don't put phi-nodes in the worklist. Phis that are marked relevant\n+       or live will fail vectorization later on.  */\n     return;\n \n-  STMT_VINFO_RELEVANT_P (stmt_info) |= relevant_p;\n-\n   if (STMT_VINFO_RELEVANT_P (stmt_info) == save_relevant_p\n       && STMT_VINFO_LIVE_P (stmt_info) == save_live_p)\n     {\n@@ -2337,19 +2348,33 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n          Exceptions:\n \n-         - if USE is used only for address computations (e.g. array indexing),\n+\t (case 1)\n+           If USE is used only for address computations (e.g. array indexing),\n            which does not need to be directly vectorized, then the\n            liveness/relevance of the respective DEF_STMT is left unchanged.\n \n-         - if STMT has been identified as defining a reduction variable, then:\n-             STMT_VINFO_LIVE_P (DEF_STMT_info) <-- false\n-             STMT_VINFO_RELEVANT_P (DEF_STMT_info) <-- true\n-           because even though STMT is classified as live (since it defines a\n-           value that is used across loop iterations) and irrelevant (since it\n-           is not used inside the loop), it will be vectorized, and therefore\n-           the corresponding DEF_STMTs need to marked as relevant.\n+\t (case 2)\n+           If STMT has been identified as defining a reduction variable, then\n+\t   we have two cases:\n+\t   (case 2.1)\n+\t     The last use of STMT is the reduction-variable, which is defined\n+\t     by a loop-header-phi. We don't want to mark the phi as live or\n+\t     relevant (because it does not need to be vectorized, it is handled\n+             as part of the vectorization of the reduction), so in this case we\n+\t     skip the call to vect_mark_relevant.\n+\t   (case 2.2)\n+\t     The rest of the uses of STMT are defined in the loop body. For\n+             the def_stmt of these uses we want to set liveness/relevance\n+             as follows:\n+               STMT_VINFO_LIVE_P (DEF_STMT_info) <-- false\n+               STMT_VINFO_RELEVANT_P (DEF_STMT_info) <-- true\n+             because even though STMT is classified as live (since it defines a\n+             value that is used across loop iterations) and irrelevant (since it\n+             is not used inside the loop), it will be vectorized, and therefore\n+             the corresponding DEF_STMTs need to marked as relevant.\n        */\n \n+      /* case 2.2:  */\n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n         {\n           gcc_assert (!relevant_p && live_p);\n@@ -2359,42 +2384,42 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n       FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n \t{\n-\t  /* We are only interested in uses that need to be vectorized. Uses \n-\t     that are used for address computation are not considered relevant.\n+\t  /* case 1: we are only interested in uses that need to be vectorized. \n+\t     Uses that are used for address computation are not considered \n+\t     relevant.\n \t   */\n-\t  if (exist_non_indexing_operands_for_use_p (use, stmt))\n-\t    {\n-\t      if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n-                {\n-                  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n-                    fprintf (vect_dump, \n-\t\t\t     \"not vectorized: unsupported use in stmt.\");\n-\t\t  VEC_free (tree, heap, worklist);\n-                  return false;\n-                }\n+\t  if (!exist_non_indexing_operands_for_use_p (use, stmt))\n+\t    continue;\n \n-\t      if (!def_stmt || IS_EMPTY_STMT (def_stmt))\n-\t\tcontinue;\n+\t  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n+            {\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t    \t\tLOOP_LOC (loop_vinfo)))\n+                fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n+\t      VEC_free (tree, heap, worklist);\n+              return false;\n+            }\n \n-              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-                {\n-                  fprintf (vect_dump, \"worklist: examine use %d: \", i);\n-                  print_generic_expr (vect_dump, use, TDF_SLIM);\n-                }\n+\t  if (!def_stmt || IS_EMPTY_STMT (def_stmt))\n+\t    continue;\n \n-\t      bb = bb_for_stmt (def_stmt);\n-              if (!flow_bb_inside_loop_p (loop, bb))\n-                continue;\n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            {\n+              fprintf (vect_dump, \"worklist: examine use %d: \", i);\n+              print_generic_expr (vect_dump, use, TDF_SLIM);\n+            }\n \n-              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-                {\n-                  fprintf (vect_dump, \"def_stmt: \");\n-                  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n-                }\n+\t  bb = bb_for_stmt (def_stmt);\n+          if (!flow_bb_inside_loop_p (loop, bb))\n+            continue;\n \n-              vect_mark_relevant (&worklist, def_stmt, relevant_p, live_p);\n-\t    }\n+\t  /* case 2.1: the reduction-use does not mark the defining-phi\n+\t     as relevant.  */\n+\t  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n+\t      && TREE_CODE (def_stmt) == PHI_NODE)\n+\t    continue;\n+\n+\t  vect_mark_relevant (&worklist, def_stmt, relevant_p, live_p);\n \t}\n     }\t\t\t\t/* while worklist */\n \n@@ -2445,6 +2470,15 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \t  continue;\n \t}\n \n+      /* Skip reduction phis.  */\n+\n+      if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (phi)) == vect_reduction_def)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            fprintf (vect_dump, \"reduc phi. skip.\");\n+          continue;\n+        }\n+\n       /* Analyze the evolution function.  */\n \n       access_fn = instantiate_parameters"}, {"sha": "2b4d1d774af4f381f6b1023bfaeb08db6edfed08", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 534, "deletions": 32, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -42,6 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"tree-pass.h\"\n #include \"toplev.h\"\n+#include \"real.h\"\n \n /* Utility functions for the code transformation.  */\n static bool vect_transform_stmt (tree, block_stmt_iterator *);\n@@ -52,12 +53,13 @@ static tree vect_create_data_ref_ptr\n static tree vect_create_index_for_vector_ref (loop_vec_info);\n static tree vect_create_addr_base_for_vector_ref (tree, tree *, tree);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n-static tree vect_get_vec_def_for_operand (tree, tree);\n+static tree vect_get_vec_def_for_operand (tree, tree, tree *);\n static tree vect_init_vector (tree, tree);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n static bool vect_is_simple_cond (tree, loop_vec_info); \n static void update_vuses_to_preheader (tree, struct loop*);\n+static tree get_initial_def_for_reduction (tree, tree, tree *);\n \n /* Utility function dealing with loop peeling (not peeling itself).  */\n static void vect_generate_tmps_on_preheader \n@@ -85,10 +87,20 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n   const char *prefix;\n   tree new_vect_var;\n \n-  if (var_kind == vect_simple_var)\n-    prefix = \"vect_\"; \n-  else\n+  switch (var_kind)\n+  {\n+  case vect_simple_var:\n+    prefix = \"vect_\";\n+    break;\n+  case vect_scalar_var:\n+    prefix = \"stmp_\";\n+    break;\n+  case vect_pointer_var:\n     prefix = \"vect_p\";\n+    break;\n+  default:\n+    gcc_unreachable ();\n+  }\n \n   if (name)\n     new_vect_var = create_tmp_var (type, concat (prefix, name, NULL));\n@@ -435,13 +447,18 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n {\n   tree vec_dest;\n   const char *new_name;\n+  tree type;\n+  enum vect_var_kind kind;\n+\n+  kind = vectype ? vect_simple_var : vect_scalar_var;\n+  type = vectype ? vectype : TREE_TYPE (scalar_dest);\n \n   gcc_assert (TREE_CODE (scalar_dest) == SSA_NAME);\n \n   new_name = get_name (scalar_dest);\n   if (!new_name)\n     new_name = \"var_\";\n-  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, new_name);\n+  vec_dest = vect_get_new_vect_var (type, vect_simple_var, new_name);\n   add_referenced_tmp_var (vec_dest);\n \n   return vec_dest;\n@@ -502,7 +519,7 @@ vect_init_vector (tree stmt, tree vector_var)\n    needs to be introduced.  */\n \n static tree\n-vect_get_vec_def_for_operand (tree op, tree stmt)\n+vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n {\n   tree vec_oprnd;\n   tree vec_stmt;\n@@ -512,6 +529,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vec_inv;\n   tree vec_cst;\n   tree t = NULL_TREE;\n@@ -542,14 +560,14 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n         }\n     }\n \n-  /* FORNOW */\n-  gcc_assert (dt != vect_reduction_def);\n-\n   switch (dt)\n     {\n     /* Case 1: operand is a constant.  */\n     case vect_constant_def:\n       {\n+\tif (scalar_def) \n+\t  *scalar_def = op;\n+\n         /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n         if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n           fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n@@ -565,6 +583,9 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n     /* Case 2: operand is defined outside the loop - loop invariant.  */\n     case vect_invariant_def:\n       {\n+\tif (scalar_def) \n+\t  *scalar_def = def;\n+\n         /* Create 'vec_inv = {inv,inv,..,inv}'  */\n         if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n           fprintf (vect_dump, \"Create vector_inv.\");\n@@ -581,6 +602,9 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n     /* Case 3: operand is defined inside the loop.  */\n     case vect_loop_def:\n       {\n+\tif (scalar_def) \n+\t  *scalar_def = def_stmt;\n+\n         /* Get the def from the vectorized stmt.  */\n         def_stmt_info = vinfo_for_stmt (def_stmt);\n         vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n@@ -589,7 +613,17 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n         return vec_oprnd;\n       }\n \n-    /* Case 4: operand is defined by loop-header phi - induction.  */\n+    /* Case 4: operand is defined by a loop header phi - reduction  */\n+    case vect_reduction_def:\n+      {\n+        gcc_assert (TREE_CODE (def_stmt) == PHI_NODE);\n+\n+        /* Get the def before the loop  */\n+        op = PHI_ARG_DEF_FROM_EDGE (def_stmt, loop_preheader_edge (loop));\n+        return get_initial_def_for_reduction (stmt, op, scalar_def);\n+     }\n+\n+    /* Case 5: operand is defined by loop-header phi - induction.  */\n     case vect_induction_def:\n       {\n         if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n@@ -618,10 +652,8 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n       print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n     }\n \n-#ifdef ENABLE_CHECKING\n   /* Make sure bsi points to the stmt that is being vectorized.  */\n   gcc_assert (stmt == bsi_stmt (*bsi));\n-#endif\n \n #ifdef USE_MAPPED_LOCATION\n   SET_EXPR_LOCATION (vec_stmt, EXPR_LOCATION (stmt));\n@@ -631,6 +663,458 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n }\n \n \n+#define ADJUST_IN_EPILOG 1\n+\n+/* Function get_initial_def_for_reduction\n+\n+   Input:\n+   STMT - a stmt that performs a reduction operation in the loop.\n+   INIT_VAL - the initial value of the reduction variable\n+\n+   Output:\n+   SCALAR_DEF - a tree that holds a value to be added to the final result\n+\tof the reduction (used for \"ADJUST_IN_EPILOG\" - see below).\n+   Return a vector variable, initialized according to the operation that STMT\n+\tperforms. This vector will be used as the initial value of the\n+\tvector of partial results.\n+\n+   Option1 (\"ADJUST_IN_EPILOG\"): Initialize the vector as follows:\n+     add:         [0,0,...,0,0]\n+     mult:        [1,1,...,1,1]\n+     min/max:     [init_val,init_val,..,init_val,init_val]\n+     bit and/or:  [init_val,init_val,..,init_val,init_val]\n+   and when necessary (e.g. add/mult case) let the caller know \n+   that it needs to adjust the result by init_val.\n+\n+   Option2: Initialize the vector as follows:\n+     add:         [0,0,...,0,init_val]\n+     mult:        [1,1,...,1,init_val]\n+     min/max:     [init_val,init_val,...,init_val]\n+     bit and/or:  [init_val,init_val,...,init_val]\n+   and no adjustments are needed.\n+\n+   For example, for the following code:\n+\n+   s = init_val;\n+   for (i=0;i<n;i++)\n+     s = s + a[i];\n+\n+   STMT is 's = s + a[i]', and the reduction variable is 's'.\n+   For a vector of 4 units, we want to return either [0,0,0,init_val],\n+   or [0,0,0,0] and let the caller know that it needs to adjust\n+   the result at the end by 'init_val'.\n+\n+   FORNOW: We use the \"ADJUST_IN_EPILOG\" scheme.\n+   TODO: Use some cost-model to estimate which scheme is more profitable.\n+*/\n+\n+static tree\n+get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n+{\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n+  int nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n+  int nelements;\n+  enum tree_code code = TREE_CODE (TREE_OPERAND (stmt, 1));\n+  tree type = TREE_TYPE (init_val);\n+  tree def;\n+  tree vec, t = NULL_TREE;\n+  bool need_epilog_adjust;\n+  int i;\n+\n+  gcc_assert (INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type));\n+\n+  switch (code)\n+  {\n+  case PLUS_EXPR:\n+    def = INTEGRAL_TYPE_P (type) ? integer_zero_node :\n+                                   build_real (type, dconst0);\n+#ifdef ADJUST_IN_EPILOG\n+    /* All the 'nunits' elements are set to 0. The final result will be\n+       adjusted by 'init_val' at the loop epilog.  */\n+    nelements = nunits;\n+    need_epilog_adjust = true;\n+#else\n+    /* 'nunits - 1' elements are set to 0; The last element is set to \n+        'init_val'.  No further adjustments at the epilog are needed.  */\n+    nelements = nunits - 1;\n+    need_epilog_adjust = false;\n+#endif\n+    break;\n+\n+  case MIN_EXPR:\n+  case MAX_EXPR:\n+    def = init_val;\n+    nelements = nunits;\n+    need_epilog_adjust = false;\n+    break;\n+\n+  default:\n+    gcc_unreachable ();\n+  }\n+\n+  for (i = nelements - 1; i >= 0; --i)\n+    {\n+      t = tree_cons (NULL_TREE, def, t);\n+    }\n+\n+  if (nelements == nunits - 1)\n+    {\n+      /* Set the last element of the vector.  */\n+      t = tree_cons (NULL_TREE, init_val, t);\n+      nelements += 1;\n+    }\n+  gcc_assert (nelements == nunits);\n+  \n+  if (TREE_CODE (init_val) == INTEGER_CST || TREE_CODE (init_val) == REAL_CST)\n+    vec = build_vector (vectype, t);\n+  else\n+    vec = build_constructor (vectype, t);\n+    \n+  if (need_epilog_adjust)\n+    *scalar_def = init_val;\n+  else\n+    *scalar_def = INTEGRAL_TYPE_P (type) ? integer_zero_node\n+                                           : build_real (type, dconst0);\n+  return vect_init_vector (stmt, vec);\n+}\n+\n+\n+/* Function vect_create_epilog_for_reduction:\n+    \n+   Create code at the loop-epilog to finalize the result of a reduction\n+   computation.\n+  \n+   LOOP_EXIT_VECT_DEF is a vector of partial results. We need to \"reduce\" it\n+   into a single result, by applying the operation REDUC_CODE on the\n+   partial-results-vector. For this, we need to create a new phi node at the\n+   loop exit to preserve loop-closed form, as illustrated below.\n+\n+   STMT is the original scalar reduction stmt that is being vectorized.\n+   REDUCTION_OP is the scalar reduction-variable.\n+   REDUCTION_PHI is the phi-node that carries the reduction computation.\n+   This function also sets the arguments for the REDUCTION_PHI:\n+   The loop-entry argument is the (vectorized) initial-value of REDUCTION_OP.\n+   The loop-latch argument is VECT_DEF - the vector of partial sums.\n+\n+     This function transforms this:\n+    \n+        loop:\n+          vec_def = phi <null, null>    # REDUCTION_PHI\n+          ....\n+          VECT_DEF = ...\n+\n+        loop_exit:\n+          s_out0 = phi <s_loop>         # EXIT_PHI\n+\n+          use <s_out0>\n+          use <s_out0>\n+\n+     Into:\n+\n+        loop:\n+          vec_def = phi <vec_init, VECT_DEF> # REDUCTION_PHI\n+          ....\n+          VECT_DEF = ...\n+\n+        loop_exit:\n+          s_out0 = phi <s_loop>         # EXIT_PHI\n+          v_out1 = phi <VECT_DEF>       # NEW_EXIT_PHI\n+\n+          v_out2 = reduc_expr <v_out1>\n+          s_out3 = extract_field <v_out2, 0>\n+\n+          use <s_out3>\n+          use <s_out3>\n+*/\n+\n+static void\n+vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n+                                  enum tree_code reduc_code, tree reduction_phi)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block exit_bb;\n+  tree scalar_dest = TREE_OPERAND (stmt, 0);\n+  tree scalar_type = TREE_TYPE (scalar_dest);\n+  tree new_phi;\n+  block_stmt_iterator exit_bsi;\n+  tree vec_dest;\n+  tree new_temp;\n+  tree epilog_stmt;\n+  tree new_scalar_dest, exit_phi;\n+  tree bitsize, bitpos; \n+  enum tree_code code = TREE_CODE (TREE_OPERAND (stmt, 1));\n+  tree scalar_initial_def;\n+  tree vec_initial_def;\n+  tree orig_name;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  \n+  /*** 1. Create the reduction def-use cycle  ***/\n+  \n+  /* 1.1 set the loop-entry arg of the reduction-phi:  */\n+  /* For the case of reduction, vect_get_vec_def_for_operand returns\n+     the scalar def before the loop, that defines the initial value\n+     of the reduction variable.  */\n+  vec_initial_def = vect_get_vec_def_for_operand (reduction_op, stmt,\n+\t\t\t\t\t\t  &scalar_initial_def);\n+  add_phi_arg (reduction_phi, vec_initial_def, loop_preheader_edge (loop));\n+\n+\n+  /* 1.2 set the loop-latch arg for the reduction-phi:  */\n+  add_phi_arg (reduction_phi, vect_def, loop_latch_edge (loop));\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    {\n+      fprintf (vect_dump, \"transform reduction: created def-use cycle:\");\n+      print_generic_expr (vect_dump, reduction_phi, TDF_SLIM);\n+      fprintf (vect_dump, \"\\n\");\n+      print_generic_expr (vect_dump, SSA_NAME_DEF_STMT (vect_def), TDF_SLIM);\n+    }\n+\n+\n+  /*** 2. Create epilog code ***/\n+\n+  /* 2.1 Create new loop-exit-phi to preserve loop-closed form:\n+        v_out1 = phi <v_loop>  */\n+\n+  exit_bb = loop->single_exit->dest;\n+  new_phi = create_phi_node (SSA_NAME_VAR (vect_def), exit_bb);\n+  SET_PHI_ARG_DEF (new_phi, loop->single_exit->dest_idx, vect_def);\n+\n+  exit_bsi = bsi_start (exit_bb);\n+\n+\n+  /* 2.2 Create:\n+        v_out2 = reduc_expr <v_out1>\n+        s_out3 = extract_field <v_out2, 0>  */\n+\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+                         build1 (reduc_code, vectype, PHI_RESULT (new_phi)));\n+  new_temp = make_ssa_name (vec_dest, epilog_stmt);\n+  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    {\n+      fprintf (vect_dump, \"transform reduction: created epilog code:\");\n+      print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+    }\n+\n+  new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n+  bitsize = TYPE_SIZE (scalar_type);\n+\n+  /* The result is in the low order bits.  */\n+  if (BITS_BIG_ENDIAN)\n+    bitpos = size_binop (MULT_EXPR,\n+                       bitsize_int (TYPE_VECTOR_SUBPARTS (vectype) - 1),\n+                       TYPE_SIZE (scalar_type));\n+  else\n+    bitpos = bitsize_zero_node;\n+\n+  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+                 build3 (BIT_FIELD_REF, scalar_type,\n+                         new_temp, bitsize, bitpos));\n+  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC)) \n+    print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\n+  \n+  /* 2.3 Adjust the final result by the initial value of the reduction\n+         variable. (when such adjustment is not needed, then\n+         'scalar_initial_def' is zero).\n+\n+         Create:\n+         s_out = scalar_expr <s_out, scalar_initial_def>  */\n+\n+  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+                  build2 (code, scalar_type, new_temp, scalar_initial_def));\n+  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\n+    \n+  /* 2.4 Replace uses of s_out0 with uses of s_out3  */ \n+\n+  /* Find the loop-closed-use at the loop exit of the original\n+     scalar result.  (The reduction result is expected to have\n+     two immediate uses - one at the latch block, and one at the\n+     loop exit).  */\n+  exit_phi = NULL;\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)\n+    {\n+      if (!flow_bb_inside_loop_p (loop, bb_for_stmt (USE_STMT (use_p))))\n+        {\n+          exit_phi = USE_STMT (use_p);\n+          break;\n+        }\n+    }\n+\n+  orig_name = PHI_RESULT (exit_phi);\n+\n+  FOR_EACH_IMM_USE_SAFE (use_p, imm_iter, orig_name)\n+    SET_USE (use_p, new_temp);\n+} \n+\n+\n+/* Function vectorizable_reduction.\n+\n+   Check if STMT performs a reduction operation that can be vectorized.\n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+bool\n+vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n+{\n+  tree vec_dest;\n+  tree scalar_dest;\n+  tree op0, op1;\n+  tree loop_vec_def;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  tree operation;\n+  enum tree_code code, reduc_code = 0;\n+  enum machine_mode vec_mode;\n+  int op_type;\n+  optab optab, reduc_optab;\n+  tree new_temp;\n+  tree def0, def1, def_stmt0, def_stmt1;\n+  enum vect_def_type dt0, dt1;\n+  tree new_phi;\n+  tree scalar_type;\n+  bool is_simple_use0;\n+  bool is_simple_use1;\n+\n+  /* Is vectorizable reduction?  */\n+\n+  /* Not supportable if the reduction variable is used in the loop.  */\n+  if (STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  if (!STMT_VINFO_LIVE_P (stmt_info))\n+    return false;\n+\n+  /* Make sure it was already recognized as a reduction pattern.  */\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def)\n+    return false;\n+\n+  gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+\n+  operation = TREE_OPERAND (stmt, 1);\n+  code = TREE_CODE (operation);\n+  op_type = TREE_CODE_LENGTH (code);\n+\n+  if (op_type != binary_op)\n+    return false;\n+\n+  op0 = TREE_OPERAND (operation, 0);\n+  op1 = TREE_OPERAND (operation, 1);\n+  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_type = TREE_TYPE (scalar_dest);\n+\n+  /* Check the first operand. It is expected to be defined inside the loop.  */\n+  is_simple_use0 =\n+        vect_is_simple_use (op0, loop_vinfo, &def_stmt0, &def0, &dt0);\n+  is_simple_use1 =\n+        vect_is_simple_use (op1, loop_vinfo, &def_stmt1, &def1, &dt1);\n+\n+  gcc_assert (is_simple_use0);\n+  gcc_assert (is_simple_use1);\n+  gcc_assert (dt0 == vect_loop_def);\n+  gcc_assert (dt1 == vect_reduction_def);\n+  gcc_assert (TREE_CODE (def_stmt1) == PHI_NODE);\n+  gcc_assert (stmt == vect_is_simple_reduction (loop, def_stmt1));\n+\n+  if (STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt1)))\n+   return false;\n+\n+  /* Supportable by target?  */\n+\n+  /* check support for the operation in the loop  */\n+  optab = optab_for_tree_code (code, vectype);\n+  if (!optab)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"no optab.\");\n+      return false;\n+    }\n+  vec_mode = TYPE_MODE (vectype);\n+  if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"op not supported by target.\");\n+      return false;\n+    }\n+\n+  /* check support for the epilog operation  */\n+  if (!reduction_code_for_scalar_code (code, &reduc_code))\n+    return false;\n+  reduc_optab = optab_for_tree_code (reduc_code, vectype);\n+  if (!reduc_optab)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"no optab for reduction.\");\n+      return false;\n+    }\n+  if (reduc_optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"op not supported by target.\");\n+      return false;\n+    }\n+ \n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n+      return true;\n+    }\n+\n+  /** Transform.  **/\n+\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"transform reduction.\");\n+\n+  /* Create the destination vector  */\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\n+\n+  /* Create the reduction-phi that defines the reduction-operand.  */\n+  new_phi = create_phi_node (vec_dest, loop->header);\n+\n+\n+  /* Prepare the operand that is defined inside the loop body  */\n+  loop_vec_def = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+  gcc_assert (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (loop_vec_def))));\n+\n+\n+  /* Create the vectorized operation that computes the partial results  */\n+  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+                build2 (code, vectype, loop_vec_def, PHI_RESULT (new_phi)));\n+  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n+  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n+  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+\n+\n+  /* Finalize the reduction-phi (set it's arguments) and create the\n+     epilog reduction code.  */\n+  vect_create_epilog_for_reduction (new_temp, stmt, op1, reduc_code, new_phi);\n+  return true;\n+}\n+\n+\n /* Function vectorizable_assignment.\n \n    Check if STMT performs an assignment (copy) that can be vectorized. \n@@ -688,7 +1172,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /* Handle use.  */\n   op = TREE_OPERAND (stmt, 1);\n-  vec_oprnd = vect_get_vec_def_for_operand (op, stmt);\n+  vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n \n   /* Arguments are ready. create the new vector stmt.  */\n   *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, vec_oprnd);\n@@ -846,12 +1330,12 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /* Handle uses.  */\n   op0 = TREE_OPERAND (operation, 0);\n-  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt);\n+  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n \n   if (op_type == binary_op)\n     {\n       op1 = TREE_OPERAND (operation, 1);\n-      vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt); \n+      vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL); \n     }\n \n   /* Arguments are ready. create the new vector stmt.  */\n@@ -940,7 +1424,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   gcc_assert (alignment_support_cheme == dr_aligned);  /* FORNOW */\n \n   /* Handle use - get the vectorized def from the defining stmt.  */\n-  vec_oprnd1 = vect_get_vec_def_for_operand (op, stmt);\n+  vec_oprnd1 = vect_get_vec_def_for_operand (op, stmt, NULL);\n \n   /* Handle def.  */\n   /* FORNOW: make sure the data reference is aligned.  */\n@@ -1387,11 +1871,11 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /* Handle cond expr.  */\n   vec_cond_lhs = \n-    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0), stmt);\n+    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0), stmt, NULL);\n   vec_cond_rhs = \n-    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1), stmt);\n-  vec_then_clause = vect_get_vec_def_for_operand (then_clause, stmt);\n-  vec_else_clause = vect_get_vec_def_for_operand (else_clause, stmt);\n+    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1), stmt, NULL);\n+  vec_then_clause = vect_get_vec_def_for_operand (then_clause, stmt, NULL);\n+  vec_else_clause = vect_get_vec_def_for_operand (else_clause, stmt, NULL);\n \n   /* Arguments are ready. create the new vector stmt.  */\n   vec_compare = build2 (TREE_CODE (cond_expr), vectype, \n@@ -1460,8 +1944,23 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n \n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      done = vectorizable_live_operation (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n+      switch (STMT_VINFO_TYPE (stmt_info))\n+      {\n+      case reduc_vec_info_type:\n+        done = vectorizable_reduction (stmt, bsi, &vec_stmt);\n+        gcc_assert (done);\n+        break;\n+\n+      default:\n+        done = vectorizable_live_operation (stmt, bsi, &vec_stmt);\n+        gcc_assert (done);\n+      }\n+\n+      if (vec_stmt)\n+        {\n+          gcc_assert (!STMT_VINFO_VEC_STMT (stmt_info));\n+          STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+        }\n     }\n \n   return is_store; \n@@ -1717,6 +2216,14 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \t  continue;\n \t}\n \n+      /* Skip reduction phis.  */\n+      if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (phi)) == vect_reduction_def)\n+        { \n+          if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+            fprintf (vect_dump, \"reduc phi. skip.\");\n+          continue;\n+        } \n+\n       access_fn = analyze_scalar_evolution (loop, PHI_RESULT (phi)); \n       gcc_assert (access_fn);\n       evolution_part =\n@@ -1770,9 +2277,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   struct loop *new_loop;\n   edge update_e;\n   basic_block preheader;\n-#ifdef ENABLE_CHECKING\n   int loop_num;\n-#endif\n \n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_loop_bound ===\");\n@@ -1787,14 +2292,12 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   vect_generate_tmps_on_preheader (loop_vinfo, &ni_name,\n \t\t\t\t   &ratio_mult_vf_name, ratio);\n \n-#ifdef ENABLE_CHECKING\n   loop_num  = loop->num; \n-#endif\n   new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, loop->single_exit,\n \t\t\t\t\t    ratio_mult_vf_name, ni_name, false);\n-#ifdef ENABLE_CHECKING\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n+#ifdef ENABLE_CHECKING\n   slpeel_verify_cfg_after_peeling (loop, new_loop);\n #endif\n \n@@ -2010,8 +2513,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   new_loop = \n \tslpeel_tree_peel_loop_to_edge (loop, loops, loop_preheader_edge (loop), \n \t\t\t\t       niters_of_prolog_loop, ni_name, true); \n-#ifdef ENABLE_CHECKING\n   gcc_assert (new_loop);\n+#ifdef ENABLE_CHECKING\n   slpeel_verify_cfg_after_peeling (new_loop, loop);\n #endif\n \n@@ -2051,7 +2554,6 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n \n-  \n   /* Peel the loop if there are data refs with unknown alignment.\n      Only one data ref with unknown store is allowed.  */\n \n@@ -2104,18 +2606,18 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t    }\t\n \t  stmt_info = vinfo_for_stmt (stmt);\n \t  gcc_assert (stmt_info);\n-\t  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+\t      && !STMT_VINFO_LIVE_P (stmt_info))\n \t    {\n \t      bsi_next (&si);\n \t      continue;\n \t    }\n-#ifdef ENABLE_CHECKING\n \t  /* FORNOW: Verify that all stmts operate on the same number of\n \t             units and no inner unrolling is necessary.  */\n \t  gcc_assert \n \t\t(TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n \t\t == vectorization_factor);\n-#endif\n+\n \t  /* -------- vectorize statement ------------ */\n \t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    fprintf (vect_dump, \"transform statement.\");"}, {"sha": "1967e53712538cbff4390fa861cbc349f5640363", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 214, "deletions": 11, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -575,9 +575,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n \t  if (!current_new_name)\n \t    continue;\n         }\n-#ifdef ENABLE_CHECKING\n       gcc_assert (get_current_def (current_new_name) == NULL_TREE);\n-#endif\n \n       set_current_def (current_new_name, PHI_RESULT (new_phi));\n       bitmap_set_bit (*defs, SSA_NAME_VERSION (current_new_name));\n@@ -761,9 +759,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   LOC loop_loc;\n \n   orig_cond = get_loop_exit_condition (loop);\n-#ifdef ENABLE_CHECKING\n   gcc_assert (orig_cond);\n-#endif\n   loop_cond_bsi = bsi_for_stmt (orig_cond);\n \n   standard_iv_increment_position (loop, &incr_bsi, &insert_after);\n@@ -1354,6 +1350,7 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_VECT_STEP (res) = NULL_TREE;\n   STMT_VINFO_VECT_BASE_ALIGNED_P (res) = false;\n   STMT_VINFO_VECT_MISALIGNMENT (res) = NULL_TREE;\n+  STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n \n   return res;\n }\n@@ -1744,9 +1741,44 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n }\n \n \n+/* Function reduction_code_for_scalar_code\n+\n+   Input:\n+   CODE - tree_code of a reduction operations.\n+\n+   Output:\n+   REDUC_CODE - the correponding tree-code to be used to reduce the\n+      vector of partial results into a single scalar result (which\n+      will also reside in a vector).\n+\n+   Return TRUE if a corresponding REDUC_CODE was found, FALSE otherwise.  */\n+\n+bool\n+reduction_code_for_scalar_code (enum tree_code code,\n+                                enum tree_code *reduc_code)\n+{\n+  switch (code)\n+  {\n+  case MAX_EXPR:\n+    *reduc_code = REDUC_MAX_EXPR;\n+    return true;\n+\n+  case MIN_EXPR:\n+    *reduc_code = REDUC_MIN_EXPR;\n+    return true;\n+\n+  case PLUS_EXPR:\n+    *reduc_code = REDUC_PLUS_EXPR;\n+    return true;\n+\n+  default:\n+    return false;\n+  }\n+}\n+\n+\n /* Function vect_is_simple_reduction\n \n-   TODO:\n    Detect a cross-iteration def-use cucle that represents a simple\n    reduction computation. We look for the following pattern:\n \n@@ -1756,18 +1788,189 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n      a2 = operation (a3, a1)\n   \n    such that:\n-   1. operation is...\n-   2. no uses for a2 in the loop (elsewhere)  */\n+   1. operation is commutative and associative and it is safe to \n+      change the the order of the computation.\n+   2. no uses for a2 in the loop (a2 is used out of the loop)\n+   3. no uses of a1 in the loop besides the reduction operation.\n+\n+   Condition 1 is tested here.\n+   Conditions 2,3 are tested in vect_mark_stmts_to_be_vectorized.  */\n \n tree\n vect_is_simple_reduction (struct loop *loop ATTRIBUTE_UNUSED, \n \t\t\t  tree phi ATTRIBUTE_UNUSED)\n {\n-  /* FORNOW */\n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-    fprintf (vect_dump, \"reduction: unknown pattern.\");\n+  edge latch_e = loop_latch_edge (loop);\n+  tree loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n+  tree def_stmt, def1, def2;\n+  enum tree_code code;\n+  int op_type;\n+  tree operation, op1, op2;\n+  tree type;\n+\n+  if (TREE_CODE (loop_arg) != SSA_NAME)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: not ssa_name: \");\n+          print_generic_expr (vect_dump, loop_arg, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n \n-  return NULL_TREE;\n+  def_stmt = SSA_NAME_DEF_STMT (loop_arg);\n+  if (!def_stmt)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"reduction: no def_stmt.\");\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (def_stmt) != MODIFY_EXPR)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  operation = TREE_OPERAND (def_stmt, 1);\n+  code = TREE_CODE (operation);\n+  if (!commutative_tree_code (code) || !associative_tree_code (code))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: not commutative/associative: \");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  op_type = TREE_CODE_LENGTH (code);\n+  if (op_type != binary_op)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: not binary operation: \");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  op1 = TREE_OPERAND (operation, 0);\n+  op2 = TREE_OPERAND (operation, 1);\n+  if (TREE_CODE (op1) != SSA_NAME || TREE_CODE (op2) != SSA_NAME)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: uses not ssa_names: \");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  /* Check that it's ok to change the order of the computation  */\n+  type = TREE_TYPE (operation);\n+  if (type != TREE_TYPE (op1) || type != TREE_TYPE (op2))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: multiple types: operation type: \");\n+          print_generic_expr (vect_dump, type, TDF_SLIM);\n+          fprintf (vect_dump, \", operands types: \");\n+          print_generic_expr (vect_dump, TREE_TYPE (op1), TDF_SLIM);\n+          fprintf (vect_dump, \",\");\n+          print_generic_expr (vect_dump, TREE_TYPE (op2), TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  /* CHECKME: check for !flag_finite_math_only too?  */\n+  if (SCALAR_FLOAT_TYPE_P (type) && !flag_unsafe_math_optimizations)\n+    {\n+      /* Changing the order of operations changes the sematics.  */\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: unsafe fp math optimization: \");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+  else if (INTEGRAL_TYPE_P (type) && !TYPE_UNSIGNED (type) && flag_trapv)\n+    {\n+      /* Changing the order of operations changes the sematics.  */\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: unsafe int math optimization: \");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  /* reduction is safe. we're dealing with one of the following:\n+     1) integer arithmetic and no trapv\n+     2) floating point arithmetic, and special flags permit this optimization.\n+   */\n+  def1 = SSA_NAME_DEF_STMT (op1);\n+  def2 = SSA_NAME_DEF_STMT (op2);\n+  if (!def1 || !def2)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: no defs for operands: \");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (def1) == MODIFY_EXPR\n+      && flow_bb_inside_loop_p (loop, bb_for_stmt (def1))\n+      && def2 == phi)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"detected reduction:\");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return def_stmt;\n+    }\n+  else if (TREE_CODE (def2) == MODIFY_EXPR\n+      && flow_bb_inside_loop_p (loop, bb_for_stmt (def2))\n+      && def1 == phi)\n+    {\n+      use_operand_p use;\n+      ssa_op_iter iter;\n+\n+      /* Swap operands (just for simplicity - so that the rest of the code\n+\t can assume that the reduction variable is always the last (second)\n+\t argument).  */\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"detected reduction: need to swap operands:\");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+\n+      /* CHECKME */\n+      FOR_EACH_SSA_USE_OPERAND (use, def_stmt, iter, SSA_OP_USE)\n+        {\n+          tree tuse = USE_FROM_PTR (use);\n+          if (tuse == op1)\n+            SET_USE (use, op2);\n+          else if (tuse == op2)\n+            SET_USE (use, op1);\n+        }\n+      return def_stmt;\n+    }\n+  else\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        {\n+          fprintf (vect_dump, \"reduction: unknown pattern.\");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n }\n \n "}, {"sha": "3c2712dbbade4f7210e68910c48306248c274622", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -39,7 +39,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Used for naming of new temporaries.  */\n enum vect_var_kind {\n   vect_simple_var,\n-  vect_pointer_var\n+  vect_pointer_var,\n+  vect_scalar_var\n };\n \n /* Defines type of operation: unary or binary.  */\n@@ -155,7 +156,8 @@ enum stmt_vec_info_type {\n   store_vec_info_type,\n   op_vec_info_type,\n   assignment_vec_info_type,\n-  condition_vec_info_type\n+  condition_vec_info_type,\n+  reduc_vec_info_type\n };\n \n typedef struct data_reference *dr_p;\n@@ -345,6 +347,8 @@ extern tree vect_is_simple_reduction (struct loop *, tree);\n extern bool vect_can_force_dr_alignment_p (tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n   (struct data_reference *);\n+extern bool reduction_code_for_scalar_code (enum tree_code, enum tree_code *);\n+\n /* Creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);\n extern void destroy_loop_vec_info (loop_vec_info);\n@@ -363,6 +367,7 @@ extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_reduction (tree, block_stmt_iterator *, tree *);\n /* Driver for transformation stage.  */\n extern void vect_transform_loop (loop_vec_info, struct loops *);\n "}, {"sha": "2b8c2806f4a71587563705a46ecb31ccfd8e5b51", "filename": "gcc/tree.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=61d3cdbb12e87dd8bfec8ce082c0ac1d5776474c", "patch": "@@ -947,6 +947,16 @@ DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n \n DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 7)\n \n+/* Reduction operations. \n+   Operations that take a vector of elements and \"reduce\" it to a scalar\n+   result (e.g. summing the elements of the vector, finding the minimum over\n+   the vector elements, etc).\n+   Operand 0 is a vector; the first element in the vector has the result.\n+   Operand 1 is a vector.  */ \n+DEFTREECODE (REDUC_MAX_EXPR, \"reduc_max_expr\", tcc_unary, 1)\n+DEFTREECODE (REDUC_MIN_EXPR, \"reduc_min_expr\", tcc_unary, 1)\n+DEFTREECODE (REDUC_PLUS_EXPR, \"reduc_plus_expr\", tcc_unary, 1)\n+\n /*\n Local variables:\n mode:c"}]}