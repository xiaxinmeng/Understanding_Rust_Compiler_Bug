{"sha": "9b0365879b3c4917f5a2485a1fca8bb678484bfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIwMzY1ODc5YjNjNDkxN2Y1YTI0ODVhMWZjYThiYjY3ODQ4NGJmZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-07T08:39:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-07T08:39:12Z"}, "message": "[IRA] Handle fully-tied destinations in a similar way to earlyclobbers\n\nIRA's make_early_clobber_and_input_conflicts checks for cases in\nwhich an output operand is likely to be an earlyclobber and an input\noperand is unlikely to be tieable with it.  If so, the allocno for\nthe output conflicts with the allocno for the input.  This seems\nto work well.\n\nHowever, a similar situation arises if an output operand is likely\nto be tied to one of a set of input operands X and if another input\noperand has a different value from all of the operands in X.\nE.g. if we have:\n\n  0: \"=r, r\"\n  1: \"0, r\"\n  2: \"r, 0\"\n  3: \"r, r\"\n\noperand 0 will always be tied to operand 1 or operand 2, so if operand 3\nis different from them both, operand 0 acts like an earlyclobber as far\nas operand 3 (only) is concerned.  The same is true for operand 2 in:\n\n  0: \"=r\"\n  1: \"0\"\n  2: \"r\"\n\nIn the second example, we'd normally have a copy between operand 1 and\noperand 0 if operand 1 dies in the instruction, and so there's rarely\na problem.  But if operand 1 doesn't die in the instruction, operand 0\nstill acts as an earlyclobber for operand 2 (if different from operand 1),\nsince in that case LRA must copy operand 1 to operand 0 before the\ninstruction.\n\nAs the existing comment says:\n\n    Avoid introducing unnecessary conflicts by checking classes of the\n    constraints and pseudos because otherwise significant code\n    degradation is possible for some targets.\n\nI think that's doubly true here.  E.g. it's perfectly reasonable to have\nconstraints like:\n\n  0: \"=r, r\"\n  1: \"0, r\"\n  2: \"r, r\"\n\non targets like s390 that have shorter instructions for tied operands,\nbut that don't want the size difference to influence RA too much.\nWe shouldn't treat operand 0 as earlyclobber wrt operand 2 in that case.\n\nThis patch therefore treats a normal tied non-earlyclobber output as\nbeing effectively earlyclobber wrt to an input if it is so for *all*\npreferred alternatives.\n\n2019-10-07  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* ira-lives.c (check_and_make_def_conflict): Handle cases in which\n\tDEF is not a true earlyclobber but is tied to a specific input\n\toperand, and so is effectively earlyclobber wrt inputs that have\n\tdifferent values.\n\t(make_early_clobber_and_input_conflicts): Pass this case to the above.\n\nFrom-SVN: r276650", "tree": {"sha": "e195e5f08879e121f8ccf818cb2dfe2e11a2ad3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e195e5f08879e121f8ccf818cb2dfe2e11a2ad3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b0365879b3c4917f5a2485a1fca8bb678484bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0365879b3c4917f5a2485a1fca8bb678484bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b0365879b3c4917f5a2485a1fca8bb678484bfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0365879b3c4917f5a2485a1fca8bb678484bfe/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad00d6c1746fdcbfd86b2d50f2500d7ccb0d1691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad00d6c1746fdcbfd86b2d50f2500d7ccb0d1691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad00d6c1746fdcbfd86b2d50f2500d7ccb0d1691"}], "stats": {"total": 94, "additions": 80, "deletions": 14}, "files": [{"sha": "798d16cf0c6a5fa1ab3783c6039b99d5491441d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0365879b3c4917f5a2485a1fca8bb678484bfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0365879b3c4917f5a2485a1fca8bb678484bfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b0365879b3c4917f5a2485a1fca8bb678484bfe", "patch": "@@ -1,3 +1,11 @@\n+2019-10-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* ira-lives.c (check_and_make_def_conflict): Handle cases in which\n+\tDEF is not a true earlyclobber but is tied to a specific input\n+\toperand, and so is effectively earlyclobber wrt inputs that have\n+\tdifferent values.\n+\t(make_early_clobber_and_input_conflicts): Pass this case to the above.\n+\n 2019-10-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* machmode.h (opt_mode): Mark constructors with CONSTEXPR."}, {"sha": "098b0e7395311d74ed7f8293ff24d40b18a46435", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 72, "deletions": 14, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0365879b3c4917f5a2485a1fca8bb678484bfe/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0365879b3c4917f5a2485a1fca8bb678484bfe/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=9b0365879b3c4917f5a2485a1fca8bb678484bfe", "patch": "@@ -633,9 +633,28 @@ check_and_make_def_use_conflict (rtx dreg, rtx orig_dreg,\n \n /* Check and make if necessary conflicts for definition DEF of class\n    DEF_CL of the current insn with input operands.  Process only\n-   constraints of alternative ALT.  */\n+   constraints of alternative ALT.\n+\n+   One of three things is true when this function is called:\n+\n+   (1) DEF is an earlyclobber for alternative ALT.  Input operands then\n+       conflict with DEF in ALT unless they explicitly match DEF via 0-9\n+       constraints.\n+\n+   (2) DEF matches (via 0-9 constraints) an operand that is an\n+       earlyclobber for alternative ALT.  Other input operands then\n+       conflict with DEF in ALT.\n+\n+   (3) [FOR_TIE_P] Some input operand X matches DEF for alternative ALT.\n+       Input operands with a different value from X then conflict with\n+       DEF in ALT.\n+\n+   However, there's still a judgement call to make when deciding\n+   whether a conflict in ALT is important enough to be reflected\n+   in the pan-alternative allocno conflict set.  */\n static void\n-check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n+check_and_make_def_conflict (int alt, int def, enum reg_class def_cl,\n+\t\t\t     bool for_tie_p)\n {\n   int use, use_match;\n   ira_allocno_t a;\n@@ -669,14 +688,40 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n       if (use == def || recog_data.operand_type[use] == OP_OUT)\n \tcontinue;\n \n+      /* An earlyclobber on DEF doesn't apply to an input operand X if X\n+\t explicitly matches DEF, but it applies to other input operands\n+\t even if they happen to be the same value as X.\n+\n+\t In contrast, if an input operand X is tied to a non-earlyclobber\n+\t DEF, there's no conflict with other input operands that have the\n+\t same value as X.  */\n+      if (op_alt[use].matches == def\n+\t  || (for_tie_p\n+\t      && rtx_equal_p (recog_data.operand[use],\n+\t\t\t      recog_data.operand[op_alt[def].matched])))\n+\tcontinue;\n+\n       if (op_alt[use].anything_ok)\n \tuse_cl = ALL_REGS;\n       else\n \tuse_cl = op_alt[use].cl;\n+      if (use_cl == NO_REGS)\n+\tcontinue;\n+\n+      /* If DEF is simply a tied operand, ignore cases in which this\n+\t alternative requires USE to have a likely-spilled class.\n+\t Adding a conflict would just constrain USE further if DEF\n+\t happens to be allocated first.  */\n+      if (for_tie_p && targetm.class_likely_spilled_p (use_cl))\n+\tcontinue;\n \n       /* If there's any alternative that allows USE to match DEF, do not\n \t record a conflict.  If that causes us to create an invalid\n-\t instruction due to the earlyclobber, reload must fix it up.  */\n+\t instruction due to the earlyclobber, reload must fix it up.\n+\n+\t Likewise, if we're treating a tied DEF like a partial earlyclobber,\n+\t do not record a conflict if there's another alternative in which\n+\t DEF is neither tied nor earlyclobber.  */\n       for (alt1 = 0; alt1 < recog_data.n_alternatives; alt1++)\n \t{\n \t  if (!TEST_BIT (preferred_alternatives, alt1))\n@@ -691,6 +736,12 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n \t\t  && recog_data.constraints[use - 1][0] == '%'\n \t\t  && op_alt1[use - 1].matches == def))\n \t    break;\n+\t  if (for_tie_p\n+\t      && !op_alt1[def].earlyclobber\n+\t      && op_alt1[def].matched < 0\n+\t      && alternative_class (op_alt1, def) != NO_REGS\n+\t      && alternative_class (op_alt1, use) != NO_REGS)\n+\t    break;\n \t}\n \n       if (alt1 < recog_data.n_alternatives)\n@@ -701,8 +752,7 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n \n       if ((use_match = op_alt[use].matches) >= 0)\n \t{\n-\t  if (use_match == def)\n-\t    continue;\n+\t  gcc_checking_assert (use_match != def);\n \n \t  if (op_alt[use_match].anything_ok)\n \t    use_cl = ALL_REGS;\n@@ -717,7 +767,11 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n /* Make conflicts of early clobber pseudo registers of the current\n    insn with its inputs.  Avoid introducing unnecessary conflicts by\n    checking classes of the constraints and pseudos because otherwise\n-   significant code degradation is possible for some targets.  */\n+   significant code degradation is possible for some targets.\n+\n+   For these purposes, tying an input to an output makes that output act\n+   like an earlyclobber for inputs with a different value, since the output\n+   register then has a predetermined purpose on input to the instruction.  */\n static void\n make_early_clobber_and_input_conflicts (void)\n {\n@@ -732,15 +786,19 @@ make_early_clobber_and_input_conflicts (void)\n     if (TEST_BIT (preferred_alternatives, alt))\n       for (def = 0; def < n_operands; def++)\n \t{\n-\t  def_cl = NO_REGS;\n-\t  if (op_alt[def].earlyclobber)\n+\t  if (op_alt[def].anything_ok)\n+\t    def_cl = ALL_REGS;\n+\t  else\n+\t    def_cl = op_alt[def].cl;\n+\t  if (def_cl != NO_REGS)\n \t    {\n-\t      if (op_alt[def].anything_ok)\n-\t\tdef_cl = ALL_REGS;\n-\t      else\n-\t\tdef_cl = op_alt[def].cl;\n-\t      check_and_make_def_conflict (alt, def, def_cl);\n+\t      if (op_alt[def].earlyclobber)\n+\t\tcheck_and_make_def_conflict (alt, def, def_cl, false);\n+\t      else if (op_alt[def].matched >= 0\n+\t\t       && !targetm.class_likely_spilled_p (def_cl))\n+\t\tcheck_and_make_def_conflict (alt, def, def_cl, true);\n \t    }\n+\n \t  if ((def_match = op_alt[def].matches) >= 0\n \t      && (op_alt[def_match].earlyclobber\n \t\t  || op_alt[def].earlyclobber))\n@@ -749,7 +807,7 @@ make_early_clobber_and_input_conflicts (void)\n \t\tdef_cl = ALL_REGS;\n \t      else\n \t\tdef_cl = op_alt[def_match].cl;\n-\t      check_and_make_def_conflict (alt, def, def_cl);\n+\t      check_and_make_def_conflict (alt, def, def_cl, false);\n \t    }\n \t}\n }"}]}