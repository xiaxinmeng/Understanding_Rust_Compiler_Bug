{"sha": "e32883d1a20e755d07956165d0f0362728c749f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMyODgzZDFhMjBlNzU1ZDA3OTU2MTY1ZDBmMDM2MjcyOGM3NDlmNA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-02-21T02:27:07Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-02-21T02:27:07Z"}, "message": "re PR libfortran/35132 (Formatted stream I/O write should truncate)\n\n2008-02-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/35132\n\t* io/transfer.c (next_record_w): Truncate after the last record for\n\tSTREAM I/O.\n\n\tPR libfortran/34954\n\t* io/transfer.c (data_transfer_init): Initialize dtp->rec if writing.\n\n\tPR libfortran/34974\n\t* io/transfer.c (formatted_transfer_scalar): Flush the buffer if skips\n\tis less than zero. (next_record_w): Use sseek to position the file to\n\tthe max position reached.\n\nFrom-SVN: r132512", "tree": {"sha": "63b91da41f92dac4c36797756c45d2f7f9fff586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63b91da41f92dac4c36797756c45d2f7f9fff586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e32883d1a20e755d07956165d0f0362728c749f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32883d1a20e755d07956165d0f0362728c749f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e32883d1a20e755d07956165d0f0362728c749f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32883d1a20e755d07956165d0f0362728c749f4/comments", "author": null, "committer": null, "parents": [{"sha": "d5e0c0ae6254a3b019855e77df5c3af25a7da1db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e0c0ae6254a3b019855e77df5c3af25a7da1db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e0c0ae6254a3b019855e77df5c3af25a7da1db"}], "stats": {"total": 31, "additions": 28, "deletions": 3}, "files": [{"sha": "7a401983c29736cfdb4ddd38eacf855bbd8be24f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32883d1a20e755d07956165d0f0362728c749f4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32883d1a20e755d07956165d0f0362728c749f4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=e32883d1a20e755d07956165d0f0362728c749f4", "patch": "@@ -1,3 +1,17 @@\n+2008-02-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/35132\n+\t* io/transfer.c (next_record_w): Truncate after the last record for\n+\tSTREAM I/O.\n+\n+\tPR libfortran/34954\n+\t* io/transfer.c (data_transfer_init): Initialize dtp->rec if writing.\n+\n+\tPR libfortran/34974\n+\t* io/transfer.c (formatted_transfer_scalar): Flush the buffer if skips\n+\tis less than zero. (next_record_w): Use sseek to position the file to\n+\tthe max position reached.\n+\n 2008-02-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/35036"}, {"sha": "c3e91149a27ad81889384328ac0349fb49b98c8a", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32883d1a20e755d07956165d0f0362728c749f4/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32883d1a20e755d07956165d0f0362728c749f4/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=e32883d1a20e755d07956165d0f0362728c749f4", "patch": "@@ -916,8 +916,8 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n      the entire field has been read.  The next read field will start right after\n      the comma in the stream.  (Set to 0 for character reads).  */\n   dtp->u.p.sf_read_comma = 1;\n-\n   dtp->u.p.line_buffer = scratch;\n+\n   for (;;)\n     {\n       /* If reversion has occurred and there is another real data item,\n@@ -1274,6 +1274,11 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t      else\n \t\tread_x (dtp, dtp->u.p.skips);\n \t    }\n+\t  else\n+\t    {\n+\t      if (dtp->u.p.skips < 0)\n+\t\tflush (dtp->u.p.current_unit->s);\n+\t    }\n \n \t  break;\n \n@@ -2007,6 +2012,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \tdtp->u.p.current_unit->strm_pos = dtp->rec;\n \n     }\n+  else\n+    dtp->rec = 0;\n \n   /* Overwriting an existing sequential file ?\n      it is always safe to truncate the file on the first write */\n@@ -2583,7 +2590,8 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t  if (max_pos > m)\n \t    {\n \t      length = (int) (max_pos - m);\n-\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n+\t      sseek (dtp->u.p.current_unit->s,\n+\t\t     file_position (dtp->u.p.current_unit->s) + length);\n \t    }\n #ifdef HAVE_CRLF\n \t  len = 2;\n@@ -2594,7 +2602,10 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t    goto io_error;\n \t  \n \t  if (is_stream_io (dtp))\n-\t    dtp->u.p.current_unit->strm_pos += len;\n+\t    {\n+\t      dtp->u.p.current_unit->strm_pos += len;\n+\t      struncate(dtp->u.p.current_unit->s);\n+\t    }\n \t}\n \n       break;"}]}