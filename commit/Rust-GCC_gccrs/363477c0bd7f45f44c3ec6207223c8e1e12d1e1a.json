{"sha": "363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYzNDc3YzBiZDdmNDVmNDRjM2VjNjIwNzIyM2M4ZTFlMTJkMWUxYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-12-15T20:47:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-12-15T20:47:29Z"}, "message": "tree-vectorizer.h (struct _stmt_vec_info): Remove pattern_def_stmt field, add pattern_def_seq.\n\n\t* tree-vectorizer.h (struct _stmt_vec_info): Remove pattern_def_stmt\n\tfield, add pattern_def_seq.\n\t(STMT_VINFO_PATTERN_DEF_STMT): Remove.\n\t(STMT_VINFO_PATTERN_DEF_SEQ): Define.\n\t(NUM_PATTERNS): Bump to 10.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor,\n\tvect_transform_loop): Adjust for pattern def changing from a single\n\tgimple stmt to gimple_seq.\n\t* tree-vect-stmts.c (vect_analyze_stmt, new_stmt_vec_info,\n\tfree_stmt_vec_info): Likewise.\n\t* tree-vect-patterns.c (vect_recog_over_widening_pattern,\n\tvect_recog_vector_vector_shift_pattern,\n\tvect_recog_mixed_size_cond_pattern, adjust_bool_pattern_cast,\n\tadjust_bool_pattern, vect_mark_pattern_stmts): Likewise.\n\t(vect_recog_sdivmod_pow2_pattern): New function.\n\t(vect_vect_recog_func_ptrs): Add it.\n\n\t* config/i386/sse.md (vcond<V_256:mode><VI_256:mode>,\n\tvcond<V_128:mode><VI124_128:mode>, vcond<VI8F_128:mode>v2di):\n\tUse general_operand instead of nonimmediate_operand for\n\toperand 5 and no predicate for operands 1 and 2.\n\t* config/i386/i386.c (ix86_expand_int_vcond): Optimize\n\tx < 0 ? -1 : 0 and x < 0 ? 1 : 0 into vector arithmetic\n\tresp. logical shift.\n\n\t* gcc.dg/vect/vect-sdivmod-1.c: New test.\n\nFrom-SVN: r182388", "tree": {"sha": "418d9808a38c0a0e9799d8eaa4017398ef3f10a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/418d9808a38c0a0e9799d8eaa4017398ef3f10a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1b750d87ff09d884637a654624422bd2f249fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b750d87ff09d884637a654624422bd2f249fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b750d87ff09d884637a654624422bd2f249fbc"}], "stats": {"total": 702, "additions": 582, "deletions": 120}, "files": [{"sha": "6f173c77c9e28954f3aaba7ea7a3d187444e761f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -1,3 +1,30 @@\n+2011-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Remove pattern_def_stmt\n+\tfield, add pattern_def_seq.\n+\t(STMT_VINFO_PATTERN_DEF_STMT): Remove.\n+\t(STMT_VINFO_PATTERN_DEF_SEQ): Define.\n+\t(NUM_PATTERNS): Bump to 10.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor,\n+\tvect_transform_loop): Adjust for pattern def changing from a single\n+\tgimple stmt to gimple_seq.\n+\t* tree-vect-stmts.c (vect_analyze_stmt, new_stmt_vec_info,\n+\tfree_stmt_vec_info): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_over_widening_pattern,\n+\tvect_recog_vector_vector_shift_pattern,\n+\tvect_recog_mixed_size_cond_pattern, adjust_bool_pattern_cast,\n+\tadjust_bool_pattern, vect_mark_pattern_stmts): Likewise.\n+\t(vect_recog_sdivmod_pow2_pattern): New function.\n+\t(vect_vect_recog_func_ptrs): Add it.\n+\n+\t* config/i386/sse.md (vcond<V_256:mode><VI_256:mode>,\n+\tvcond<V_128:mode><VI124_128:mode>, vcond<VI8F_128:mode>v2di):\n+\tUse general_operand instead of nonimmediate_operand for\n+\toperand 5 and no predicate for operands 1 and 2.\n+\t* config/i386/i386.c (ix86_expand_int_vcond): Optimize\n+\tx < 0 ? -1 : 0 and x < 0 ? 1 : 0 into vector arithmetic\n+\tresp. logical shift.\n+\n 2011-12-15  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr-protos.h (print_operand): Remove."}, {"sha": "f2ab36377b4b747bf905ea506a21f27256472b04", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -19434,6 +19434,45 @@ ix86_expand_int_vcond (rtx operands[])\n   cop0 = operands[4];\n   cop1 = operands[5];\n \n+  /* Try to optimize x < 0 ? -1 : 0 into (signed) x >> 31\n+     and x < 0 ? 1 : 0 into (unsigned) x >> 31.  */\n+  if ((code == LT || code == GE)\n+      && data_mode == mode\n+      && cop1 == CONST0_RTX (mode)\n+      && operands[1 + (code == LT)] == CONST0_RTX (data_mode)\n+      && GET_MODE_SIZE (GET_MODE_INNER (data_mode)) > 1\n+      && GET_MODE_SIZE (GET_MODE_INNER (data_mode)) <= 8\n+      && (GET_MODE_SIZE (data_mode) == 16\n+\t  || (TARGET_AVX2 && GET_MODE_SIZE (data_mode) == 32)))\n+    {\n+      rtx negop = operands[2 - (code == LT)];\n+      int shift = GET_MODE_BITSIZE (GET_MODE_INNER (data_mode)) - 1;\n+      if (negop == CONST1_RTX (data_mode))\n+\t{\n+\t  rtx res = expand_simple_binop (mode, LSHIFTRT, cop0, GEN_INT (shift),\n+\t\t\t\t\t operands[0], 1, OPTAB_DIRECT);\n+\t  if (res != operands[0])\n+\t    emit_move_insn (operands[0], res);\n+\t  return true;\n+\t}\n+      else if (GET_MODE_INNER (data_mode) != DImode\n+\t       && vector_all_ones_operand (negop, data_mode))\n+\t{\n+\t  rtx res = expand_simple_binop (mode, ASHIFTRT, cop0, GEN_INT (shift),\n+\t\t\t\t\t operands[0], 0, OPTAB_DIRECT);\n+\t  if (res != operands[0])\n+\t    emit_move_insn (operands[0], res);\n+\t  return true;\n+\t}\n+    }\n+\n+  if (!nonimmediate_operand (cop1, mode))\n+    cop1 = force_reg (mode, cop1);\n+  if (!general_operand (operands[1], data_mode))\n+    operands[1] = force_reg (data_mode, operands[1]);\n+  if (!general_operand (operands[2], data_mode))\n+    operands[2] = force_reg (data_mode, operands[2]);\n+\n   /* XOP supports all of the comparisons on all 128-bit vector int types.  */\n   if (TARGET_XOP\n       && (mode == V16QImode || mode == V8HImode"}, {"sha": "2d248aae2c7bfe521c7f55a55277910dfdfec50c", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -6340,9 +6340,9 @@\n \t(if_then_else:V_256\n \t  (match_operator 3 \"\"\n \t    [(match_operand:VI_256 4 \"nonimmediate_operand\" \"\")\n-\t     (match_operand:VI_256 5 \"nonimmediate_operand\" \"\")])\n-\t  (match_operand:V_256 1 \"general_operand\" \"\")\n-\t  (match_operand:V_256 2 \"general_operand\" \"\")))]\n+\t     (match_operand:VI_256 5 \"general_operand\" \"\")])\n+\t  (match_operand:V_256 1 \"\" \"\")\n+\t  (match_operand:V_256 2 \"\" \"\")))]\n   \"TARGET_AVX2\n    && (GET_MODE_NUNITS (<V_256:MODE>mode)\n        == GET_MODE_NUNITS (<VI_256:MODE>mode))\"\n@@ -6357,9 +6357,9 @@\n \t(if_then_else:V_128\n \t  (match_operator 3 \"\"\n \t    [(match_operand:VI124_128 4 \"nonimmediate_operand\" \"\")\n-\t     (match_operand:VI124_128 5 \"nonimmediate_operand\" \"\")])\n-\t  (match_operand:V_128 1 \"general_operand\" \"\")\n-\t  (match_operand:V_128 2 \"general_operand\" \"\")))]\n+\t     (match_operand:VI124_128 5 \"general_operand\" \"\")])\n+\t  (match_operand:V_128 1 \"\" \"\")\n+\t  (match_operand:V_128 2 \"\" \"\")))]\n   \"TARGET_SSE2\n    && (GET_MODE_NUNITS (<V_128:MODE>mode)\n        == GET_MODE_NUNITS (<VI124_128:MODE>mode))\"\n@@ -6374,9 +6374,9 @@\n \t(if_then_else:VI8F_128\n \t  (match_operator 3 \"\"\n \t    [(match_operand:V2DI 4 \"nonimmediate_operand\" \"\")\n-\t     (match_operand:V2DI 5 \"nonimmediate_operand\" \"\")])\n-\t  (match_operand:VI8F_128 1 \"general_operand\" \"\")\n-\t  (match_operand:VI8F_128 2 \"general_operand\" \"\")))]\n+\t     (match_operand:V2DI 5 \"general_operand\" \"\")])\n+\t  (match_operand:VI8F_128 1 \"\" \"\")\n+\t  (match_operand:VI8F_128 2 \"\" \"\")))]\n   \"TARGET_SSE4_2\"\n {\n   bool ok = ix86_expand_int_vcond (operands);"}, {"sha": "c44a0673a266dd3ae49b2a8802a61ed15c8c6d7c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -1,5 +1,7 @@\n 2011-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gcc.dg/vect/vect-sdivmod-1.c: New test.\n+\n \tPR c++/51463\n \t* g++.dg/cpp0x/pr51463.C: New test.\n "}, {"sha": "c18204ea3548b16f60479854206c2cc71798fd58", "filename": "gcc/testsuite/gcc.dg/vect/vect-sdivmod-1.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-sdivmod-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-sdivmod-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-sdivmod-1.c?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -0,0 +1,98 @@\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+int a[4096];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int x)\n+{\n+  int i, j;\n+  for (i = 1; i <= x; i++)\n+    {\n+      j = a[i] >> 8;\n+      j = 1 + (j / 2);\n+      a[i] = j << 8;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int x)\n+{\n+  int i, j;\n+  for (i = 1; i <= x; i++)\n+    {\n+      j = a[i] >> 8;\n+      j = 1 + (j / 16);\n+      a[i] = j << 8;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (int x)\n+{\n+  int i, j;\n+  for (i = 1; i <= x; i++)\n+    {\n+      j = a[i] >> 8;\n+      j = 1 + (j % 2);\n+      a[i] = j << 8;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (int x)\n+{\n+  int i, j;\n+  for (i = 1; i <= x; i++)\n+    {\n+      j = a[i] >> 8;\n+      j = 1 + (j % 16);\n+      a[i] = j << 8;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  for (i = 0; i < 4096; i++)\n+    {\n+      asm (\"\");\n+      a[i] = (i - 2048) << 8;\n+    }\n+  f1 (4095);\n+  if (a[0] != (-2048 << 8))\n+    abort ();\n+  for (i = 1; i < 4096; i++)\n+    if (a[i] != ((1 + ((i - 2048) / 2)) << 8))\n+      abort ();\n+    else\n+      a[i] = (i - 2048) << 8;\n+  f2 (4095);\n+  if (a[0] != (-2048 << 8))\n+    abort ();\n+  for (i = 1; i < 4096; i++)\n+    if (a[i] != ((1 + ((i - 2048) / 16)) << 8))\n+      abort ();\n+    else\n+      a[i] = (i - 2048) << 8;\n+  f3 (4095);\n+  if (a[0] != (-2048 << 8))\n+    abort ();\n+  for (i = 1; i < 4096; i++)\n+    if (a[i] != ((1 + ((i - 2048) % 2)) << 8))\n+      abort ();\n+    else\n+      a[i] = (i - 2048) << 8;\n+  f4 (4095);\n+  if (a[0] != (-2048 << 8))\n+    abort ();\n+  for (i = 1; i < 4096; i++)\n+    if (a[i] != ((1 + ((i - 2048) % 16)) << 8))\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 4 \"vect\" { target vect_condition } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ae28ef6dd842ce14375efcb8986c2317dfb64869", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 121, "deletions": 63, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -1,5 +1,5 @@\n /* Loop Vectorization\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com> and\n    Ira Rosen <irar@il.ibm.com>\n@@ -181,8 +181,10 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   stmt_vec_info stmt_info;\n   int i;\n   HOST_WIDE_INT dummy;\n-  gimple stmt, pattern_stmt = NULL, pattern_def_stmt = NULL;\n-  bool analyze_pattern_stmt = false, pattern_def = false;\n+  gimple stmt, pattern_stmt = NULL;\n+  gimple_seq pattern_def_seq = NULL;\n+  gimple_stmt_iterator pattern_def_si = gsi_start (NULL);\n+  bool analyze_pattern_stmt = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_determine_vectorization_factor ===\");\n@@ -248,10 +250,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           tree vf_vectype;\n \n           if (analyze_pattern_stmt)\n-            {\n-              stmt = pattern_stmt;\n-              analyze_pattern_stmt = false;\n-            }\n+\t    stmt = pattern_stmt;\n           else\n             stmt = gsi_stmt (si);\n \n@@ -296,28 +295,54 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                        || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n             analyze_pattern_stmt = true;\n \n-          /* If a pattern statement has a def stmt, analyze it too.  */\n-          if (is_pattern_stmt_p (stmt_info)\n-              && (pattern_def_stmt = STMT_VINFO_PATTERN_DEF_STMT (stmt_info))\n-              && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n-                  || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt))))\n-            {\n-              if (pattern_def)\n-                pattern_def = false;\n-              else\n-                {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    {\n-                      fprintf (vect_dump, \"==> examining pattern def stmt: \");\n-                      print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n-                                         TDF_SLIM);\n-                    }\n+\t  /* If a pattern statement has def stmts, analyze them too.  */\n+\t  if (is_pattern_stmt_p (stmt_info))\n+\t    {\n+\t      if (pattern_def_seq == NULL)\n+\t\t{\n+\t\t  pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n+\t\t  pattern_def_si = gsi_start (pattern_def_seq);\n+\t\t}\n+\t      else if (!gsi_end_p (pattern_def_si))\n+\t\tgsi_next (&pattern_def_si);\n+\t      if (pattern_def_seq != NULL)\n+\t\t{\n+\t\t  gimple pattern_def_stmt = NULL;\n+\t\t  stmt_vec_info pattern_def_stmt_info = NULL;\n \n-                  pattern_def = true;\n-                  stmt = pattern_def_stmt;\n-                  stmt_info = vinfo_for_stmt (stmt);\n-                }\n-            }\n+\t\t  while (!gsi_end_p (pattern_def_si))\n+\t\t    {\n+\t\t      pattern_def_stmt = gsi_stmt (pattern_def_si);\n+\t\t      pattern_def_stmt_info\n+\t\t\t= vinfo_for_stmt (pattern_def_stmt);\n+\t\t      if (STMT_VINFO_RELEVANT_P (pattern_def_stmt_info)\n+\t\t\t  || STMT_VINFO_LIVE_P (pattern_def_stmt_info))\n+\t\t\tbreak;\n+\t\t      gsi_next (&pattern_def_si);\n+\t\t    }\n+\n+\t\t  if (!gsi_end_p (pattern_def_si))\n+\t\t    {\n+\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (vect_dump,\n+\t\t\t\t   \"==> examining pattern def stmt: \");\n+\t\t\t  print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n+\t\t\t\t\t     TDF_SLIM);\n+\t\t\t}\n+\n+\t\t      stmt = pattern_def_stmt;\n+\t\t      stmt_info = pattern_def_stmt_info;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      pattern_def_si = gsi_start (NULL);\n+\t\t      analyze_pattern_stmt = false;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tanalyze_pattern_stmt = false;\n+\t    }\n \n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n \t    {\n@@ -347,7 +372,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t idiom).  */\n \t      gcc_assert (STMT_VINFO_DATA_REF (stmt_info)\n \t\t\t  || is_pattern_stmt_p (stmt_info)\n-\t\t\t  || pattern_def);\n+\t\t\t  || !gsi_end_p (pattern_def_si));\n \t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n \t    }\n \t  else\n@@ -425,8 +450,11 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      || (nunits > vectorization_factor))\n \t    vectorization_factor = nunits;\n \n-          if (!analyze_pattern_stmt && !pattern_def)\n-            gsi_next (&si);\n+\t  if (!analyze_pattern_stmt && gsi_end_p (pattern_def_si))\n+\t    {\n+\t      pattern_def_seq = NULL;\n+\t      gsi_next (&si);\n+\t    }\n         }\n     }\n \n@@ -5150,8 +5178,10 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n   bool do_peeling_for_loop_bound;\n-  gimple stmt, pattern_stmt, pattern_def_stmt;\n-  bool transform_pattern_stmt = false, pattern_def = false;\n+  gimple stmt, pattern_stmt;\n+  gimple_seq pattern_def_seq = NULL;\n+  gimple_stmt_iterator pattern_def_si = gsi_start (NULL);\n+  bool transform_pattern_stmt = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n@@ -5245,10 +5275,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t  bool is_store;\n \n           if (transform_pattern_stmt)\n-            {\n-              stmt = pattern_stmt;\n-              transform_pattern_stmt = false;\n-            }\n+\t    stmt = pattern_stmt;\n           else\n             stmt = gsi_stmt (si);\n \n@@ -5295,28 +5322,53 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n                        || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n             transform_pattern_stmt = true;\n \n-          /* If pattern statement has a def stmt, vectorize it too.  */\n-          if (is_pattern_stmt_p (stmt_info)\n-              && (pattern_def_stmt = STMT_VINFO_PATTERN_DEF_STMT (stmt_info))\n-              && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n-                  || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt))))\n-            {\n-              if (pattern_def)\n-                pattern_def = false;\n-              else\n-                {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    {\n-                      fprintf (vect_dump, \"==> vectorizing pattern def\"\n-                                          \" stmt: \");\n-                      print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n-                                         TDF_SLIM);\n-                    }\n+\t  /* If pattern statement has def stmts, vectorize them too.  */\n+\t  if (is_pattern_stmt_p (stmt_info))\n+\t    {\n+\t      if (pattern_def_seq == NULL)\n+\t\t{\n+\t\t  pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n+\t\t  pattern_def_si = gsi_start (pattern_def_seq);\n+\t\t}\n+\t      else if (!gsi_end_p (pattern_def_si))\n+\t\tgsi_next (&pattern_def_si);\n+\t      if (pattern_def_seq != NULL)\n+\t\t{\n+\t\t  gimple pattern_def_stmt = NULL;\n+\t\t  stmt_vec_info pattern_def_stmt_info = NULL;\n \n-                  pattern_def = true;\n-                  stmt = pattern_def_stmt;\n-                  stmt_info = vinfo_for_stmt (stmt);\n-                }\n+\t\t  while (!gsi_end_p (pattern_def_si))\n+\t\t    {\n+\t\t      pattern_def_stmt = gsi_stmt (pattern_def_si);\n+\t\t      pattern_def_stmt_info\n+\t\t\t= vinfo_for_stmt (pattern_def_stmt);\n+\t\t      if (STMT_VINFO_RELEVANT_P (pattern_def_stmt_info)\n+\t\t\t  || STMT_VINFO_LIVE_P (pattern_def_stmt_info))\n+\t\t\tbreak;\n+\t\t      gsi_next (&pattern_def_si);\n+\t\t    }\n+\n+\t\t  if (!gsi_end_p (pattern_def_si))\n+\t\t    {\n+\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (vect_dump, \"==> vectorizing pattern def\"\n+\t\t\t\t\t      \" stmt: \");\n+\t\t\t  print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n+\t\t\t\t\t     TDF_SLIM);\n+\t\t\t}\n+\n+\t\t      stmt = pattern_def_stmt;\n+\t\t      stmt_info = pattern_def_stmt_info;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      pattern_def_si = gsi_start (NULL);\n+\t\t      transform_pattern_stmt = false;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\ttransform_pattern_stmt = false;\n             }\n \n \t  gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n@@ -5346,9 +5398,12 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */\n \t      if (!vinfo_for_stmt (stmt) || PURE_SLP_STMT (stmt_info))\n \t\t{\n-                  if (!transform_pattern_stmt && !pattern_def)\n- \t\t    gsi_next (&si);\n-  \t\t  continue;\n+\t\t  if (!transform_pattern_stmt && gsi_end_p (pattern_def_si))\n+\t\t    {\n+\t\t      pattern_def_seq = NULL;\n+\t\t      gsi_next (&si);\n+\t\t    }\n+\t\t  continue;\n \t\t}\n \t    }\n \n@@ -5378,8 +5433,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t}\n \t    }\n \n-          if (!transform_pattern_stmt && !pattern_def)\n- \t    gsi_next (&si);\n+\t  if (!transform_pattern_stmt && gsi_end_p (pattern_def_si))\n+\t    {\n+\t      pattern_def_seq = NULL;\n+\t      gsi_next (&si);\n+\t    }\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */\n "}, {"sha": "cbc7b443d04e56c7d020d73612afcefdf4f92e22", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 252, "deletions": 28, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -53,6 +53,8 @@ static gimple vect_recog_widen_shift_pattern (VEC (gimple, heap) **,\n \t                                tree *, tree *);\n static gimple vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **,\n \t\t\t\t\t\t      tree *, tree *);\n+static gimple vect_recog_sdivmod_pow2_pattern (VEC (gimple, heap) **,\n+\t\t\t\t\t       tree *, tree *);\n static gimple vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **,\n \t\t\t\t\t\t  tree *, tree *);\n static gimple vect_recog_bool_pattern (VEC (gimple, heap) **, tree *, tree *);\n@@ -64,6 +66,7 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_over_widening_pattern,\n \tvect_recog_widen_shift_pattern,\n \tvect_recog_vector_vector_shift_pattern,\n+\tvect_recog_sdivmod_pow2_pattern,\n \tvect_recog_mixed_size_cond_pattern,\n \tvect_recog_bool_pattern};\n \n@@ -867,7 +870,7 @@ vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n    NEW_DEF_STMT - in case DEF has to be promoted, we create two pattern\n          statements for STMT: the first one is a type promotion and the second\n          one is the operation itself.  We return the type promotion statement\n-         in NEW_DEF_STMT and further store it in STMT_VINFO_PATTERN_DEF_STMT of\n+\t in NEW_DEF_STMT and further store it in STMT_VINFO_PATTERN_DEF_SEQ of\n          the second pattern statement.  */\n \n static bool\n@@ -988,7 +991,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n         a. Its type is not sufficient for the operation, we create a new stmt:\n            a type conversion for OPRND from HALF_TYPE to INTERM_TYPE.  We store\n            this statement in NEW_DEF_STMT, and it is later put in\n-           STMT_VINFO_PATTERN_DEF_STMT of the pattern statement for STMT.\n+\t   STMT_VINFO_PATTERN_DEF_SEQ of the pattern statement for STMT.\n         b. OPRND is good to use in the new statement.  */\n   if (first)\n     {\n@@ -1143,7 +1146,8 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n \t= gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt), var,\n \t\t\t\t\top0, op1);\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n-      STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (stmt)) = new_def_stmt;\n+      STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (stmt))\n+\t= gimple_seq_alloc_with_stmt (new_def_stmt);\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n@@ -1198,8 +1202,8 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n       else\n         {\n           if (prev_stmt)\n-            STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (use_stmt))\n-               = STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (prev_stmt));\n+\t    STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (use_stmt))\n+\t       = STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (prev_stmt));\n \n           *type_in = vectype;\n           *type_out = NULL_TREE;\n@@ -1475,7 +1479,7 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n     i.e. the shift/rotate stmt.  The original stmt (S3) is replaced\n     with a shift/rotate which has same type on both operands, in the\n     second case just b_T op c_T, in the first case with added cast\n-    from a_t to c_T in STMT_VINFO_PATTERN_DEF_STMT.\n+    from a_t to c_T in STMT_VINFO_PATTERN_DEF_SEQ.\n \n   Output:\n \n@@ -1555,7 +1559,8 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n       def = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n       def_stmt = gimple_build_assign_with_ops (NOP_EXPR, def, oprnd1,\n \t\t\t\t\t       NULL_TREE);\n-      STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo) = def_stmt;\n+      STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo)\n+\t= gimple_seq_alloc_with_stmt (def_stmt);\n     }\n \n   /* Pattern detected.  */\n@@ -1573,6 +1578,217 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n   return pattern_stmt;\n }\n \n+/* Detect a signed division by power of two constant that wouldn't be\n+   otherwise vectorized:\n+\n+   type a_t, b_t;\n+\n+   S1 a_t = b_t / N;\n+\n+  where type 'type' is a signed integral type and N is a constant positive\n+  power of two.\n+\n+  Similarly handle signed modulo by power of two constant:\n+\n+   S4 a_t = b_t % N;\n+\n+  Input/Output:\n+\n+  * STMTS: Contains a stmt from which the pattern search begins,\n+    i.e. the division stmt.  S1 is replaced by:\n+  S3  y_t = b_t < 0 ? N - 1 : 0;\n+  S2  x_t = b_t + y_t;\n+  S1' a_t = x_t >> log2 (N);\n+\n+    S4 is replaced by (where *_T temporaries have unsigned type):\n+  S9  y_T = b_t < 0 ? -1U : 0U;\n+  S8  z_T = y_T >> (sizeof (type_t) * CHAR_BIT - log2 (N));\n+  S7  z_t = (type) z_T;\n+  S6  w_t = b_t + z_t;\n+  S5  x_t = w_t & (N - 1);\n+  S4' a_t = x_t - z_t;\n+\n+  Output:\n+\n+  * TYPE_IN: The type of the input arguments to the pattern.\n+\n+  * TYPE_OUT: The type of the output of this pattern.\n+\n+  * Return value: A new stmt that will be used to replace the division\n+    S1 or modulo S4 stmt.  */\n+\n+static gimple\n+vect_recog_sdivmod_pow2_pattern (VEC (gimple, heap) **stmts,\n+\t\t\t\t tree *type_in, tree *type_out)\n+{\n+  gimple last_stmt = VEC_pop (gimple, *stmts);\n+  tree oprnd0, oprnd1, vectype, itype, cond;\n+  gimple pattern_stmt, def_stmt;\n+  enum tree_code rhs_code;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  optab optab;\n+\n+  if (!is_gimple_assign (last_stmt))\n+    return NULL;\n+\n+  rhs_code = gimple_assign_rhs_code (last_stmt);\n+  switch (rhs_code)\n+    {\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+      break;\n+    default:\n+      return NULL;\n+    }\n+\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+    return NULL;\n+\n+  oprnd0 = gimple_assign_rhs1 (last_stmt);\n+  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  itype = TREE_TYPE (oprnd0);\n+  if (TREE_CODE (oprnd0) != SSA_NAME\n+      || TREE_CODE (oprnd1) != INTEGER_CST\n+      || TREE_CODE (itype) != INTEGER_TYPE\n+      || TYPE_UNSIGNED (itype)\n+      || TYPE_PRECISION (itype) != GET_MODE_PRECISION (TYPE_MODE (itype))\n+      || !integer_pow2p (oprnd1)\n+      || tree_int_cst_sgn (oprnd1) != 1)\n+    return NULL;\n+\n+  vectype = get_vectype_for_scalar_type (itype);\n+  if (vectype == NULL_TREE)\n+    return NULL;\n+\n+  /* If the target can handle vectorized division or modulo natively,\n+     don't attempt to optimize this.  */\n+  optab = optab_for_tree_code (rhs_code, vectype, optab_default);\n+  if (optab != NULL)\n+    {\n+      enum machine_mode vec_mode = TYPE_MODE (vectype);\n+      int icode = (int) optab_handler (optab, vec_mode);\n+      if (icode != CODE_FOR_nothing\n+\t  || GET_MODE_SIZE (vec_mode) == UNITS_PER_WORD)\n+\treturn NULL;\n+    }\n+\n+  /* Pattern detected.  */\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_recog_sdivmod_pow2_pattern: detected: \");\n+\n+  cond = build2 (LT_EXPR, boolean_type_node, oprnd0, build_int_cst (itype, 0));\n+  if (rhs_code == TRUNC_DIV_EXPR)\n+    {\n+      tree var = vect_recog_temp_ssa_var (itype, NULL);\n+      def_stmt\n+\t= gimple_build_assign_with_ops3 (COND_EXPR, var, cond,\n+\t\t\t\t\t fold_build2 (MINUS_EXPR, itype,\n+\t\t\t\t\t\t      oprnd1,\n+\t\t\t\t\t\t      build_int_cst (itype,\n+\t\t\t\t\t\t\t\t     1)),\n+\t\t\t\t\t build_int_cst (itype, 0));\n+      STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo)\n+\t= gimple_seq_alloc_with_stmt (def_stmt);\n+      var = vect_recog_temp_ssa_var (itype, NULL);\n+      def_stmt\n+\t= gimple_build_assign_with_ops (PLUS_EXPR, var, oprnd0,\n+\t\t\t\t\tgimple_assign_lhs (def_stmt));\n+      gimplify_seq_add_stmt (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo),\n+\t\t\t     def_stmt);\n+\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops (RSHIFT_EXPR,\n+\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\tvar,\n+\t\t\t\t\tbuild_int_cst (itype,\n+\t\t\t\t\t\t       tree_log2 (oprnd1)));\n+    }\n+  else\n+    {\n+      tree signmask;\n+      STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+      if (compare_tree_int (oprnd1, 2) == 0)\n+\t{\n+\t  signmask = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops3 (COND_EXPR, signmask, cond,\n+\t\t\t\t\t     build_int_cst (itype, 1),\n+\t\t\t\t\t     build_int_cst (itype, 0));\n+\t  gimplify_seq_add_stmt (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo),\n+\t\t\t\t def_stmt);\n+\t}\n+      else\n+\t{\n+\t  tree utype\n+\t    = build_nonstandard_integer_type (TYPE_PRECISION (itype), 1);\n+\t  tree vecutype = get_vectype_for_scalar_type (utype);\n+\t  tree shift\n+\t    = build_int_cst (utype, GET_MODE_BITSIZE (TYPE_MODE (itype))\n+\t\t\t\t    - tree_log2 (oprnd1));\n+\t  tree var = vect_recog_temp_ssa_var (utype, NULL);\n+\t  stmt_vec_info def_stmt_vinfo;\n+\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops3 (COND_EXPR, var, cond,\n+\t\t\t\t\t     build_int_cst (utype, -1),\n+\t\t\t\t\t     build_int_cst (utype, 0));\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n+\t  gimplify_seq_add_stmt (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo),\n+\t\t\t\t def_stmt);\n+\t  var = vect_recog_temp_ssa_var (utype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, var,\n+\t\t\t\t\t    gimple_assign_lhs (def_stmt),\n+\t\t\t\t\t    shift);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n+\t  gimplify_seq_add_stmt (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo),\n+\t\t\t\t def_stmt);\n+\t  signmask = vect_recog_temp_ssa_var (itype, NULL);\n+\t  def_stmt\n+\t    = gimple_build_assign_with_ops (NOP_EXPR, signmask, var,\n+\t\t\t\t\t    NULL_TREE);\n+\t  gimplify_seq_add_stmt (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo),\n+\t\t\t\t def_stmt);\n+\t}\n+      def_stmt\n+\t= gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\toprnd0, signmask);\n+      gimplify_seq_add_stmt (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo),\n+\t\t\t     def_stmt);\n+      def_stmt\n+\t= gimple_build_assign_with_ops (BIT_AND_EXPR,\n+\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\tgimple_assign_lhs (def_stmt),\n+\t\t\t\t\tfold_build2 (MINUS_EXPR, itype,\n+\t\t\t\t\t\t     oprnd1,\n+\t\t\t\t\t\t     build_int_cst (itype,\n+\t\t\t\t\t\t\t\t    1)));\n+      gimplify_seq_add_stmt (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo),\n+\t\t\t     def_stmt);\n+\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops (MINUS_EXPR,\n+\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\tgimple_assign_lhs (def_stmt),\n+\t\t\t\t\tsignmask);\n+    }\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+\n+  VEC_safe_push (gimple, heap, *stmts, last_stmt);\n+\n+  *type_in = vectype;\n+  *type_out = vectype;\n+  return pattern_stmt;\n+}\n+\n /* Function vect_recog_mixed_size_cond_pattern\n \n    Try to find the following pattern:\n@@ -1680,7 +1896,8 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n \t\t\t\t    vect_recog_temp_ssa_var (type, NULL),\n \t\t\t\t    gimple_assign_lhs (def_stmt), NULL_TREE);\n \n-  STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo) = def_stmt;\n+  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo)\n+    = gimple_seq_alloc_with_stmt (def_stmt);\n   def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n   set_vinfo_for_stmt (def_stmt, def_stmt_info);\n   STMT_VINFO_VECTYPE (def_stmt_info) = vecitype;\n@@ -1767,17 +1984,18 @@ check_bool_pattern (tree var, loop_vec_info loop_vinfo)\n \n /* Helper function of adjust_bool_pattern.  Add a cast to TYPE to a previous\n    stmt (SSA_NAME_DEF_STMT of VAR) by moving the COND_EXPR from RELATED_STMT\n-   to PATTERN_DEF_STMT and adding a cast as RELATED_STMT.  */\n+   to PATTERN_DEF_SEQ and adding a cast as RELATED_STMT.  */\n \n static tree\n adjust_bool_pattern_cast (tree type, tree var)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (SSA_NAME_DEF_STMT (var));\n   gimple cast_stmt, pattern_stmt;\n \n-  gcc_assert (!STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo));\n+  gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo));\n   pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n-  STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo) = pattern_stmt;\n+  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo)\n+    = gimple_seq_alloc_with_stmt (pattern_stmt);\n   cast_stmt\n     = gimple_build_assign_with_ops (NOP_EXPR,\n \t\t\t\t    vect_recog_temp_ssa_var (type, NULL),\n@@ -1882,7 +2100,7 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n \t      VEC_quick_push (gimple, *stmts, stmt);\n \t      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt))\n \t\t= STMT_VINFO_RELATED_STMT (stmt_def_vinfo);\n-\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_STMT (stmt_def_vinfo));\n+\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_def_vinfo));\n \t      STMT_VINFO_RELATED_STMT (stmt_def_vinfo) = NULL;\n \t      return irhs2;\n \t    }\n@@ -1907,7 +2125,7 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n \t      VEC_quick_push (gimple, *stmts, stmt);\n \t      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt))\n \t\t= STMT_VINFO_RELATED_STMT (stmt_def_vinfo);\n-\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_STMT (stmt_def_vinfo));\n+\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_def_vinfo));\n \t      STMT_VINFO_RELATED_STMT (stmt_def_vinfo) = NULL;\n \t      return irhs1;\n \t    }\n@@ -2086,7 +2304,8 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n \t  tree rhs2 = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n \t  gimple cast_stmt\n \t    = gimple_build_assign_with_ops (NOP_EXPR, rhs2, rhs, NULL_TREE);\n-\t  STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo) = cast_stmt;\n+\t  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo)\n+\t    = gimple_seq_alloc_with_stmt (cast_stmt);\n \t  rhs = rhs2;\n \t}\n       pattern_stmt\n@@ -2139,23 +2358,28 @@ vect_mark_pattern_stmts (gimple orig_stmt, gimple pattern_stmt,\n   STMT_VINFO_VECTYPE (pattern_stmt_info) = pattern_vectype;\n   STMT_VINFO_IN_PATTERN_P (orig_stmt_info) = true;\n   STMT_VINFO_RELATED_STMT (orig_stmt_info) = pattern_stmt;\n-  STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info)\n-    = STMT_VINFO_PATTERN_DEF_STMT (orig_stmt_info);\n-  if (STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info))\n+  STMT_VINFO_PATTERN_DEF_SEQ (pattern_stmt_info)\n+    = STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt_info);\n+  if (STMT_VINFO_PATTERN_DEF_SEQ (pattern_stmt_info))\n     {\n-      def_stmt = STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info);\n-      def_stmt_info = vinfo_for_stmt (def_stmt);\n-      if (def_stmt_info == NULL)\n+      gimple_stmt_iterator si;\n+      for (si = gsi_start (STMT_VINFO_PATTERN_DEF_SEQ (pattern_stmt_info));\n+\t   !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_info);\n+\t  def_stmt = gsi_stmt (si);\n+\t  def_stmt_info = vinfo_for_stmt (def_stmt);\n+\t  if (def_stmt_info == NULL)\n+\t    {\n+\t      def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+\t      set_vinfo_for_stmt (def_stmt, def_stmt_info);\n+\t    }\n+\t  gimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n+\t  STMT_VINFO_RELATED_STMT (def_stmt_info) = orig_stmt;\n+\t  STMT_VINFO_DEF_TYPE (def_stmt_info)\n+\t    = STMT_VINFO_DEF_TYPE (orig_stmt_info);\n+\t  if (STMT_VINFO_VECTYPE (def_stmt_info) == NULL_TREE)\n+\t    STMT_VINFO_VECTYPE (def_stmt_info) = pattern_vectype;\n \t}\n-      gimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n-      STMT_VINFO_RELATED_STMT (def_stmt_info) = orig_stmt;\n-      STMT_VINFO_DEF_TYPE (def_stmt_info)\n-\t= STMT_VINFO_DEF_TYPE (orig_stmt_info);\n-      if (STMT_VINFO_VECTYPE (def_stmt_info) == NULL_TREE)\n-\tSTMT_VINFO_VECTYPE (def_stmt_info) = pattern_vectype;\n     }\n }\n "}, {"sha": "24deba756a3d925b45210db8c93e9e4eb3612af9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -5203,7 +5203,8 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n   bool ok;\n   tree scalar_type, vectype;\n-  gimple pattern_stmt, pattern_def_stmt;\n+  gimple pattern_stmt;\n+  gimple_seq pattern_def_seq;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -5274,21 +5275,29 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n    }\n \n   if (is_pattern_stmt_p (stmt_info)\n-      && (pattern_def_stmt = STMT_VINFO_PATTERN_DEF_STMT (stmt_info))\n-      && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n-          || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt))))\n+      && (pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info)))\n     {\n-      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        {\n-          fprintf (vect_dump, \"==> examining pattern def statement: \");\n-          print_gimple_stmt (vect_dump, pattern_def_stmt, 0, TDF_SLIM);\n-        }\n+      gimple_stmt_iterator si;\n \n-      if (!vect_analyze_stmt (pattern_def_stmt, need_to_vectorize, node))\n-        return false;\n-   }\n+      for (si = gsi_start (pattern_def_seq); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple pattern_def_stmt = gsi_stmt (si);\n+\t  if (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n+\t      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt)))\n+\t    {\n+\t      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t{\n+\t\t  fprintf (vect_dump, \"==> examining pattern def statement: \");\n+\t\t  print_gimple_stmt (vect_dump, pattern_def_stmt, 0, TDF_SLIM);\n+\t\t}\n \n+\t      if (!vect_analyze_stmt (pattern_def_stmt,\n+\t\t\t\t      need_to_vectorize, node))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n \n   switch (STMT_VINFO_DEF_TYPE (stmt_info))\n     {\n@@ -5605,7 +5614,7 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo,\n   STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_IN_PATTERN_P (res) = false;\n   STMT_VINFO_RELATED_STMT (res) = NULL;\n-  STMT_VINFO_PATTERN_DEF_STMT (res) = NULL;\n+  STMT_VINFO_PATTERN_DEF_SEQ (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n \n   STMT_VINFO_DR_BASE_ADDRESS (res) = NULL;\n@@ -5676,8 +5685,13 @@ free_stmt_vec_info (gimple stmt)\n \t= vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n       if (patt_info)\n \t{\n-\t  if (STMT_VINFO_PATTERN_DEF_STMT (patt_info))\n-\t    free_stmt_vec_info (STMT_VINFO_PATTERN_DEF_STMT (patt_info));\n+\t  gimple_seq seq = STMT_VINFO_PATTERN_DEF_SEQ (patt_info);\n+\t  if (seq)\n+\t    {\n+\t      gimple_stmt_iterator si;\n+\t      for (si = gsi_start (seq); !gsi_end_p (si); gsi_next (&si))\n+\t\tfree_stmt_vec_info (gsi_stmt (si));\n+\t    }\n \t  free_stmt_vec_info (STMT_VINFO_RELATED_STMT (stmt_info));\n \t}\n     }"}, {"sha": "4f4fb49e7f7f51e587966d8fab66f29a09647c78", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363477c0bd7f45f44c3ec6207223c8e1e12d1e1a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=363477c0bd7f45f44c3ec6207223c8e1e12d1e1a", "patch": "@@ -487,8 +487,8 @@ typedef struct _stmt_vec_info {\n         pattern).  */\n   gimple related_stmt;\n \n-  /* Used to keep a def stmt of a pattern stmt if such exists.  */\n-  gimple pattern_def_stmt;\n+  /* Used to keep a sequence of def stmts of a pattern stmt if such exists.  */\n+  gimple_seq pattern_def_seq;\n \n   /* List of datarefs that are known to have the same alignment as the dataref\n      of this stmt.  */\n@@ -561,7 +561,7 @@ typedef struct _stmt_vec_info {\n \n #define STMT_VINFO_IN_PATTERN_P(S)         (S)->in_pattern_p\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n-#define STMT_VINFO_PATTERN_DEF_STMT(S)     (S)->pattern_def_stmt\n+#define STMT_VINFO_PATTERN_DEF_SEQ(S)      (S)->pattern_def_seq\n #define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs\n #define STMT_VINFO_DEF_TYPE(S)             (S)->def_type\n #define STMT_VINFO_GROUP_FIRST_ELEMENT(S)  (S)->first_element\n@@ -929,7 +929,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n-#define NUM_PATTERNS 9\n+#define NUM_PATTERNS 10\n void vect_pattern_recog (loop_vec_info);\n \n /* In tree-vectorizer.c.  */"}]}