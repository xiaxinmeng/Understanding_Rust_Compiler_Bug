{"sha": "93febe6804531d2219c4a81520721b625eeb8280", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmZWJlNjgwNDUzMWQyMjE5YzRhODE1MjA3MjFiNjI1ZWViODI4MA==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@amelek.gda.pl", "date": "2002-05-17T20:19:47Z"}, "committer": {"name": "Marek Michalkiewicz", "email": "marekm@gcc.gnu.org", "date": "2002-05-17T20:19:47Z"}, "message": "avr.c (avr_regs_to_save): New function.\n\n\n\t* config/avr/avr.c (avr_regs_to_save): New function.  Also check\n\tfor fixed registers, possibly used for global register variables.\n\t(initial_elimination_offset, avr_output_function_prologue,\n\tavr_output_function_epilogue):  Move common code to avr_regs_to_save.\n\nFrom-SVN: r53569", "tree": {"sha": "c0782a7cb8196038e258c7a30182b654f7c7c8da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0782a7cb8196038e258c7a30182b654f7c7c8da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93febe6804531d2219c4a81520721b625eeb8280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93febe6804531d2219c4a81520721b625eeb8280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93febe6804531d2219c4a81520721b625eeb8280", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93febe6804531d2219c4a81520721b625eeb8280/comments", "author": null, "committer": null, "parents": [{"sha": "004cb2635143f44703686ca8b1e1ce0df91e0d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/004cb2635143f44703686ca8b1e1ce0df91e0d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/004cb2635143f44703686ca8b1e1ce0df91e0d43"}], "stats": {"total": 104, "additions": 58, "deletions": 46}, "files": [{"sha": "7883517aa92a3b3af3957a4610fc36f4f60eab8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93febe6804531d2219c4a81520721b625eeb8280/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93febe6804531d2219c4a81520721b625eeb8280/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93febe6804531d2219c4a81520721b625eeb8280", "patch": "@@ -1,3 +1,10 @@\n+2002-05-17  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n+\n+\t* config/avr/avr.c (avr_regs_to_save): New function.  Also check\n+\tfor fixed registers, possibly used for global register variables.\n+\t(initial_elimination_offset, avr_output_function_prologue,\n+\tavr_output_function_epilogue):  Move common code to avr_regs_to_save.\n+\n 2002-05-17  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* Makefile.in: Update for cpptrad.c."}, {"sha": "95b625f8e2e0dce303cd3e37415ac005df3f2776", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93febe6804531d2219c4a81520721b625eeb8280/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93febe6804531d2219c4a81520721b625eeb8280/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=93febe6804531d2219c4a81520721b625eeb8280", "patch": "@@ -47,6 +47,7 @@\n static int    avr_naked_function_p PARAMS ((tree));\n static int    interrupt_function_p PARAMS ((tree));\n static int    signal_function_p    PARAMS ((tree));\n+static int    avr_regs_to_save     PARAMS ((HARD_REG_SET *));\n static int    sequent_regs_live    PARAMS ((void));\n static const char * ptrreg_to_str  PARAMS ((int));\n static const char * cond_string    PARAMS ((enum rtx_code));\n@@ -363,38 +364,58 @@ signal_function_p (func)\n   return a != NULL_TREE;\n }\n \n+/* Return the number of hard registers to push/pop in the prologue/epilogue\n+   of the current function, and optionally store these registers in SET.  */\n+\n+static int\n+avr_regs_to_save (set)\n+     HARD_REG_SET *set;\n+{\n+  int reg, count;\n+  int int_or_sig_p = (interrupt_function_p (current_function_decl)\n+\t\t      || signal_function_p (current_function_decl));\n+  int leaf_func_p = leaf_function_p ();\n+\n+  if (set)\n+    CLEAR_HARD_REG_SET (*set);\n+  count = 0;\n+  for (reg = 0; reg < 32; reg++)\n+    {\n+      /* Do not push/pop __tmp_reg__, __zero_reg__, as well as\n+\t any global register variables.  */\n+      if (fixed_regs[reg])\n+\tcontinue;\n+\n+      if ((int_or_sig_p && !leaf_func_p && call_used_regs[reg])\n+\t  || (regs_ever_live[reg]\n+\t      && (int_or_sig_p || !call_used_regs[reg])\n+\t      && !(frame_pointer_needed\n+\t\t   && (reg == REG_Y || reg == (REG_Y+1)))))\n+\t{\n+\t  if (set)\n+\t    SET_HARD_REG_BIT (*set, reg);\n+\t  count++;\n+\t}\n+    }\n+  return count;\n+}\n+\n /* Compute offset between arg_pointer and frame_pointer */\n \n int\n initial_elimination_offset (from, to)\n      int from;\n      int to;\n {\n-  int reg;\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return 0;\n   else\n     {\n-      int interrupt_func_p = interrupt_function_p (current_function_decl);\n-      int signal_func_p = signal_function_p (current_function_decl);\n-      int leaf_func_p = leaf_function_p ();\n-      int offset= frame_pointer_needed ? 2 : 0;\n+      int offset = frame_pointer_needed ? 2 : 0;\n \n-      for (reg = 0; reg < 32; ++reg)\n-\t{\n-\t  if ((!leaf_func_p && (call_used_regs[reg]\n-\t\t\t\t&& (interrupt_func_p || signal_func_p)))\n-\t      || (regs_ever_live[reg]\n-\t\t  && (!call_used_regs[reg] || interrupt_func_p || signal_func_p)\n-\t\t  && ! (frame_pointer_needed\n-\t\t\t&& (reg == REG_Y || reg == (REG_Y+1)))))\n-\t    {\n-\t      ++offset;\n-\t    }\n-\t}\n+      offset += avr_regs_to_save (NULL);\n       return get_frame_size () + 2 + 1 + offset;\n     }\n-  return 0;\n }\n \n /* This function checks sequence of live registers */\n@@ -569,7 +590,6 @@ avr_output_function_prologue (file, size)\n   int reg;\n   int interrupt_func_p;\n   int signal_func_p;\n-  int leaf_func_p;\n   int main_p;\n   int live_seq;\n   int minimize;\n@@ -582,7 +602,6 @@ avr_output_function_prologue (file, size)\n \n   interrupt_func_p = interrupt_function_p (current_function_decl);\n   signal_func_p = signal_function_p (current_function_decl);\n-  leaf_func_p = leaf_function_p ();\n   main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));\n   live_seq = sequent_regs_live ();\n   minimize = (TARGET_CALL_PROLOGUES\n@@ -598,7 +617,7 @@ avr_output_function_prologue (file, size)\n       fprintf (file,\"\\tsei\\n\");\n       ++prologue_size;\n     }\n-  if (interrupt_func_p | signal_func_p)\n+  if (interrupt_func_p || signal_func_p)\n     {\n       fprintf (file, \"\\t\"\n                AS1 (push,__zero_reg__)   CR_TAB\n@@ -647,20 +666,14 @@ avr_output_function_prologue (file, size)\n     }\n   else\n     {\n+      HARD_REG_SET set;\n+\n+      prologue_size += avr_regs_to_save (&set);\n       for (reg = 0; reg < 32; ++reg)\n \t{\n-\t  if ((!leaf_func_p\n-\t       && (call_used_regs[reg]\n-\t\t   && (interrupt_func_p || signal_func_p)\n-\t\t   && !(reg == TMP_REGNO || reg == ZERO_REGNO)))\n-\t      || (regs_ever_live[reg]\n-\t\t  && (!call_used_regs[reg]\n-\t\t      || interrupt_func_p || signal_func_p)\n-\t\t  && ! (frame_pointer_needed\n-\t\t\t&& (reg == REG_Y || reg == (REG_Y+1)))))\n+\t  if (TEST_HARD_REG_BIT (set, reg))\n \t    {\n \t      fprintf (file, \"\\t\" AS1 (push,%s) \"\\n\", avr_regnames[reg]);\n-\t      ++prologue_size;\n \t    }\n \t}\n       if (frame_pointer_needed)\n@@ -706,7 +719,6 @@ avr_output_function_epilogue (file, size)\n   int reg;\n   int interrupt_func_p;\n   int signal_func_p;\n-  int leaf_func_p;\n   int main_p;\n   int function_size;\n   int live_seq;\n@@ -720,7 +732,6 @@ avr_output_function_epilogue (file, size)\n \n   interrupt_func_p = interrupt_function_p (current_function_decl);\n   signal_func_p = signal_function_p (current_function_decl);\n-  leaf_func_p = leaf_function_p ();\n   main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));\n   function_size = (INSN_ADDRESSES (INSN_UID (get_last_insn ()))\n \t\t   - INSN_ADDRESSES (INSN_UID (get_insns ())));\n@@ -766,14 +777,16 @@ avr_output_function_epilogue (file, size)\n     }\n   else\n     {\n+      HARD_REG_SET set;\n+\n       if (frame_pointer_needed)\n \t{\n \t  if (size)\n \t    {\n \t      fputs (\"\\t\", file);\n \t      epilogue_size += out_adj_frame_ptr (file, -size);\n \n-\t      if (interrupt_func_p | signal_func_p)\n+\t      if (interrupt_func_p || signal_func_p)\n \t\t{\n \t\t  epilogue_size += out_set_stack_ptr (file, -1, 0);\n \t\t}\n@@ -788,24 +801,16 @@ avr_output_function_epilogue (file, size)\n \t  epilogue_size += 2;\n \t}\n \n+      epilogue_size += avr_regs_to_save (&set);\n       for (reg = 31; reg >= 0; --reg)\n \t{\n-\t  if ((!leaf_func_p\n-\t       && (call_used_regs[reg]\n-\t\t   && (interrupt_func_p || signal_func_p)\n-\t\t   && !(reg == TMP_REGNO || reg == ZERO_REGNO)))\n-\t      || (regs_ever_live[reg]\n-\t\t  && (!call_used_regs[reg]\n-\t\t      || interrupt_func_p || signal_func_p)\n-\t\t  && ! (frame_pointer_needed\n-\t\t\t&& (reg == REG_Y || reg == (REG_Y+1)))))\n+\t  if (TEST_HARD_REG_BIT (set, reg))\n \t    {\n \t      fprintf (file, \"\\t\" AS1 (pop,%s) \"\\n\", avr_regnames[reg]);\n-\t      ++epilogue_size;\n \t    }\n \t}\n-      \n-      if (interrupt_func_p | signal_func_p)\n+\n+      if (interrupt_func_p || signal_func_p)\n \t{\n \t  fprintf (file, \"\\t\"\n \t\t   AS1 (pop,__tmp_reg__)      CR_TAB"}]}