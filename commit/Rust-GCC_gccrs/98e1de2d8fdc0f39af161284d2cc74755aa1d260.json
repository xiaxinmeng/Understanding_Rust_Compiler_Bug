{"sha": "98e1de2d8fdc0f39af161284d2cc74755aa1d260", "node_id": "C_kwDOANBUbNoAKDk4ZTFkZTJkOGZkYzBmMzlhZjE2MTI4NGQyY2M3NDc1NWFhMWQyNjA", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-29T07:29:21Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-29T07:37:26Z"}, "message": "ast: Resolver: Refactor ResolveRelativeTypePath in its own source file", "tree": {"sha": "a56e48d6dbe4daaf399a0fb6b7d926ed85ede31c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a56e48d6dbe4daaf399a0fb6b7d926ed85ede31c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98e1de2d8fdc0f39af161284d2cc74755aa1d260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e1de2d8fdc0f39af161284d2cc74755aa1d260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e1de2d8fdc0f39af161284d2cc74755aa1d260", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e1de2d8fdc0f39af161284d2cc74755aa1d260/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f"}], "stats": {"total": 102, "additions": 52, "deletions": 50}, "files": [{"sha": "141788019ee8706a4159d4e7e1403f4fca2aeb9b", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e1de2d8fdc0f39af161284d2cc74755aa1d260/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e1de2d8fdc0f39af161284d2cc74755aa1d260/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=98e1de2d8fdc0f39af161284d2cc74755aa1d260", "patch": "@@ -248,5 +248,52 @@ ResolveType::visit (AST::SliceType &type)\n   type.get_elem_type ()->accept_vis (*this);\n }\n \n+ResolveRelativeTypePath::ResolveRelativeTypePath (CanonicalPath qualified_path)\n+  : ResolveTypeToCanonicalPath (true, true)\n+{\n+  result = qualified_path;\n+}\n+\n+bool\n+ResolveRelativeTypePath::go (AST::QualifiedPathInType &path)\n+{\n+  // resolve the type and trait path\n+  auto &qualified_path = path.get_qualified_path_type ();\n+  CanonicalPath result = CanonicalPath::create_empty ();\n+  if (!resolve_qual_seg (qualified_path, result))\n+    return false;\n+\n+  // resolve the associated impl if available but it can also be from a trait\n+  // and this is allowed to fail\n+  auto resolver = Resolver::get ();\n+  NodeId projection_resolved_id = UNKNOWN_NODEID;\n+  if (resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n+    {\n+      // mark the resolution for this\n+      resolver->insert_resolved_name (qualified_path.get_node_id (),\n+\t\t\t\t      projection_resolved_id);\n+    }\n+\n+  // qualified types are similar to other paths in that we cannot guarantee\n+  // that we can resolve the path at name resolution. We must look up\n+  // associated types and type information to figure this out properly\n+\n+  ResolveRelativeTypePath o (result);\n+  std::unique_ptr<AST::TypePathSegment> &associated\n+    = path.get_associated_segment ();\n+\n+  associated->accept_vis (o);\n+  if (o.failure_flag)\n+    return false;\n+\n+  for (auto &seg : path.get_segments ())\n+    {\n+      seg->accept_vis (o);\n+      if (o.failure_flag)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "933413537b6dfdbfb9ebf5e1441b5dc76243f638", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 5, "deletions": 50, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e1de2d8fdc0f39af161284d2cc74755aa1d260/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e1de2d8fdc0f39af161284d2cc74755aa1d260/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=98e1de2d8fdc0f39af161284d2cc74755aa1d260", "patch": "@@ -190,54 +190,10 @@ class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n   using ResolveTypeToCanonicalPath::visit;\n \n public:\n-  static bool go (AST::QualifiedPathInType &path, NodeId parent,\n-\t\t  bool canonicalize_type_with_generics)\n-  {\n-    // resolve the type and trait path\n-    auto &qualified_path = path.get_qualified_path_type ();\n-    CanonicalPath result = CanonicalPath::create_empty ();\n-    if (!resolve_qual_seg (qualified_path, result))\n-      return false;\n-\n-    // resolve the associated impl if available but it can also be from a trait\n-    // and this is allowed to fail\n-    auto resolver = Resolver::get ();\n-    NodeId projection_resolved_id = UNKNOWN_NODEID;\n-    if (resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n-      {\n-\t// mark the resolution for this\n-\tresolver->insert_resolved_name (qualified_path.get_node_id (),\n-\t\t\t\t\tprojection_resolved_id);\n-      }\n-\n-    // qualified types are similar to other paths in that we cannot guarantee\n-    // that we can resolve the path at name resolution. We must look up\n-    // associated types and type information to figure this out properly\n-\n-    ResolveRelativeTypePath o (result);\n-    std::unique_ptr<AST::TypePathSegment> &associated\n-      = path.get_associated_segment ();\n-\n-    associated->accept_vis (o);\n-    if (o.failure_flag)\n-      return false;\n-\n-    for (auto &seg : path.get_segments ())\n-      {\n-\tseg->accept_vis (o);\n-\tif (o.failure_flag)\n-\t  return false;\n-      }\n-\n-    return true;\n-  }\n+  static bool go (AST::QualifiedPathInType &path);\n \n private:\n-  ResolveRelativeTypePath (CanonicalPath qualified_path)\n-    : ResolveTypeToCanonicalPath (true, true)\n-  {\n-    result = qualified_path;\n-  }\n+  ResolveRelativeTypePath (CanonicalPath qualified_path);\n \n   static bool resolve_qual_seg (AST::QualifiedPathType &seg,\n \t\t\t\tCanonicalPath &result);\n@@ -375,8 +331,7 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::QualifiedPathInType &path) override\n   {\n-    ok = ResolveRelativeTypePath::go (path, parent,\n-\t\t\t\t      canonicalize_type_with_generics);\n+    ok = ResolveRelativeTypePath::go (path);\n   }\n \n   void visit (AST::ArrayType &type) override;\n@@ -431,7 +386,7 @@ class ResolveTypeBound : public ResolverBase\n     ok = resolved_node != UNKNOWN_NODEID;\n   }\n \n-  void visit (AST::Lifetime &bound) override { ok = true; }\n+  void visit (AST::Lifetime &) override { ok = true; }\n \n private:\n   ResolveTypeBound (NodeId parent, bool canonicalize_type_with_generics)\n@@ -459,7 +414,7 @@ class ResolveGenericParam : public ResolverBase\n     return resolver.resolved_node;\n   };\n \n-  void visit (AST::LifetimeParam &param) override\n+  void visit (AST::LifetimeParam &) override\n   {\n     // For now do not do anything and accept everything.\n     ok = true;"}]}