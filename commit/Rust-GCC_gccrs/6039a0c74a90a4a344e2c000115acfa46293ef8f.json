{"sha": "6039a0c74a90a4a344e2c000115acfa46293ef8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAzOWEwYzc0YTkwYTRhMzQ0ZTJjMDAwMTE1YWNmYTQ2MjkzZWY4Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-11-11T15:50:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-11-11T15:50:16Z"}, "message": "tree-pass.h (pass_purge_lineno_notes): Remove declaration.\n\n\n\t* tree-pass.h (pass_purge_lineno_notes): Remove declaration.\n\t* modulo-sched.c (find_line_note): Remove.\n\t(loop_canon_p): Do not worry about line number notes.\n\t(sms_schedule): Likewise.\n\t* cse.c (cse_main): Likewise.\n\t* regmove.c (fixup_match_1): Likewise\n\t* function.c (emit_return_info_block): Likewise.\n\t(expand_function_end): Likewise.\n\t(thread_prologue_an_epilogue_insns): Likewise.\n\t* cfgrtl.c (try_redirect_by_replacing_jump, rtl_tidy_fallthru_edge):\n\tLikewise.\n\t* emit-rtl.c (find_line_note, emit_insn_after_with_line_notes,\n\temit_note_copy_after): Kill.\n\t(emit_note_copy): Do not worry about line numbers.\n\t* jump.c (purge_line_number_notes): Kill.\n\t(pass_purge_lineno_notes): Kill.\n\t* cfgcleanup.c (rest_of_handle_jump2): Kill purge_line_number_notes\n\tcall.\n\t* rtl.h (emit_note_copy_after, emit_insn_after_with_line_notes): Kill.\n\t* passes.c (init_optimization_passes): Don't purge_lineno_notes.\n\t* sched-ebb.c (schedule_ebbs): Don't do rm_redundant_line_notes.\n\t* tree-pass.h (pass_purge_lineno_notes): Kill.\n\t* sched-ebb.c (schedule_ebb): Don't rm_line_notes,\n\trm_redundant_line_notes.\n\t* sched-rgb.c (schedule_region): Don't rm_line_notes,\n\trm_redundant_line_notes.\n\t* sched-int.h (rm_line_notes, rm_redundant_line_notes): Kill.\n\t* haifa-sched.c: Update comment about handling notes.\n \t(unlink_line_notes): Kill.\n\t(rm_line_notes): Kill.\n\t(save_line_notes): Simplify.\n\t(rm_redundant_line_notes): Kill.\n\nFrom-SVN: r118693", "tree": {"sha": "5f4208819ca7ad9f4213c79c692e4029d0966257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f4208819ca7ad9f4213c79c692e4029d0966257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6039a0c74a90a4a344e2c000115acfa46293ef8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6039a0c74a90a4a344e2c000115acfa46293ef8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6039a0c74a90a4a344e2c000115acfa46293ef8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6039a0c74a90a4a344e2c000115acfa46293ef8f/comments", "author": null, "committer": null, "parents": [{"sha": "f9f770a8d56552aab041b8de6548858241a03f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f770a8d56552aab041b8de6548858241a03f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f770a8d56552aab041b8de6548858241a03f53"}], "stats": {"total": 481, "additions": 47, "deletions": 434}, "files": [{"sha": "7ddbac97c2b99ac79a0fead20024e7d623af9edb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -1,3 +1,38 @@\n+2006-11-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pass.h (pass_purge_lineno_notes): Remove declaration.\n+\t* modulo-sched.c (find_line_note): Remove.\n+\t(loop_canon_p): Do not worry about line number notes.\n+\t(sms_schedule): Likewise.\n+\t* cse.c (cse_main): Likewise.\n+\t* regmove.c (fixup_match_1): Likewise\n+\t* function.c (emit_return_info_block): Likewise.\n+\t(expand_function_end): Likewise.\n+\t(thread_prologue_an_epilogue_insns): Likewise.\n+\t* cfgrtl.c (try_redirect_by_replacing_jump, rtl_tidy_fallthru_edge):\n+\tLikewise.\n+\t* emit-rtl.c (find_line_note, emit_insn_after_with_line_notes,\n+\temit_note_copy_after): Kill.\n+\t(emit_note_copy): Do not worry about line numbers.\n+\t* jump.c (purge_line_number_notes): Kill.\n+\t(pass_purge_lineno_notes): Kill.\n+\t* cfgcleanup.c (rest_of_handle_jump2): Kill purge_line_number_notes\n+\tcall.\n+\t* rtl.h (emit_note_copy_after, emit_insn_after_with_line_notes): Kill.\n+\t* passes.c (init_optimization_passes): Don't purge_lineno_notes.\n+\t* sched-ebb.c (schedule_ebbs): Don't do rm_redundant_line_notes.\n+\t* tree-pass.h (pass_purge_lineno_notes): Kill.\n+\t* sched-ebb.c (schedule_ebb): Don't rm_line_notes,\n+\trm_redundant_line_notes.\n+\t* sched-rgb.c (schedule_region): Don't rm_line_notes,\n+\trm_redundant_line_notes.\n+\t* sched-int.h (rm_line_notes, rm_redundant_line_notes): Kill.\n+\t* haifa-sched.c: Update comment about handling notes.\n+ \t(unlink_line_notes): Kill.\n+\t(rm_line_notes): Kill.\n+\t(save_line_notes): Simplify.\n+\t(rm_redundant_line_notes): Kill.\n+\n 2006-11-11  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.def (FIX_CEIL_EXPR, FIX_FLOOR_EXPR, FIX_ROUND_EXPR):"}, {"sha": "33c26fb4071b7a7fe95dfc050324e887c0e5d270", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -2312,8 +2312,6 @@ rest_of_handle_jump2 (void)\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)\n \t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n-  purge_line_number_notes ();\n-\n   if (optimize)\n     cleanup_cfg (CLEANUP_EXPENSIVE);\n "}, {"sha": "0edad6a1af316888b4122f883c50a8fcbc853233", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -866,12 +866,6 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   e->probability = REG_BR_PROB_BASE;\n   e->count = src->count;\n \n-  /* We don't want a block to end on a line-number note since that has\n-     the potential of changing the code between -g and not -g.  */\n-  while (NOTE_P (BB_END (e->src))\n-\t && NOTE_LINE_NUMBER (BB_END (e->src)) >= 0)\n-    delete_insn (BB_END (e->src));\n-\n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n \n@@ -1233,11 +1227,6 @@ rtl_tidy_fallthru_edge (edge e)\n #endif\n \n       q = PREV_INSN (q);\n-\n-      /* We don't want a block to end on a line-number note since that has\n-\t the potential of changing the code between -g and not -g.  */\n-      while (NOTE_P (q) && NOTE_LINE_NUMBER (q) >= 0)\n-\tq = PREV_INSN (q);\n     }\n \n   /* Selectively unlink the sequence.  */"}, {"sha": "dca20477f5d2332235fab85331ee09e5fbaf3597", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -6138,19 +6138,10 @@ cse_main (rtx f, int nregs)\n \n   /* Compute the mapping from uids to cuids.\n      CUIDs are numbers assigned to insns, like uids,\n-     except that cuids increase monotonically through the code.\n-     Don't assign cuids to line-number NOTEs, so that the distance in cuids\n-     between two insns is not affected by -g.  */\n+     except that cuids increase monotonically through the code.  */\n \n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (!NOTE_P (insn)\n-\t  || NOTE_LINE_NUMBER (insn) < 0)\n-\tINSN_CUID (insn) = ++i;\n-      else\n-\t/* Give a line number note the same cuid as preceding insn.  */\n-\tINSN_CUID (insn) = i;\n-    }\n+    INSN_CUID (insn) = ++i;\n \n   /* Loop over basic blocks.\n      Compute the maximum number of qty's needed for each basic block"}, {"sha": "114015c8a2d6126f94a0f6d1eeb12c334d2bd398", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -166,7 +166,6 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n #define first_label_num (cfun->emit->x_first_label_num)\n \n static rtx make_call_insn_raw (rtx);\n-static rtx find_line_note (rtx);\n static rtx change_address_1 (rtx, enum machine_mode, rtx, int);\n static void unshare_all_decls (tree);\n static void reset_used_decls (tree);\n@@ -3663,22 +3662,6 @@ reorder_insns (rtx from, rtx to, rtx after)\n     }\n }\n \n-/* Return the line note insn preceding INSN.  */\n-\n-static rtx\n-find_line_note (rtx insn)\n-{\n-  if (no_line_numbers)\n-    return 0;\n-\n-  for (; insn; insn = PREV_INSN (insn))\n-    if (NOTE_P (insn)\n-\t&& NOTE_LINE_NUMBER (insn) >= 0)\n-      break;\n-\n-  return insn;\n-}\n-\n \f\n /* Emit insn(s) of given code and pattern\n    at a specified place within the doubly-linked list.\n@@ -3963,22 +3946,6 @@ emit_insn_after_noloc (rtx x, rtx after)\n   return last;\n }\n \n-/* Similar to emit_insn_after, except that line notes are to be inserted so\n-   as to act as if this insn were at FROM.  */\n-\n-void\n-emit_insn_after_with_line_notes (rtx x, rtx after, rtx from)\n-{\n-  rtx from_line = find_line_note (from);\n-  rtx after_line = find_line_note (after);\n-  rtx insn = emit_insn_after (x, after);\n-\n-  if (from_line)\n-    emit_note_copy_after (from_line, after);\n-\n-  if (after_line)\n-    emit_note_copy_after (after_line, insn);\n-}\n \n /* Make an insn of code JUMP_INSN with body X\n    and output it after the insn AFTER.  */\n@@ -4098,28 +4065,6 @@ emit_note_after (int subtype, rtx after)\n   add_insn_after (note, after);\n   return note;\n }\n-\n-/* Emit a copy of note ORIG after the insn AFTER.  */\n-\n-rtx\n-emit_note_copy_after (rtx orig, rtx after)\n-{\n-  rtx note;\n-\n-  if (NOTE_LINE_NUMBER (orig) >= 0 && no_line_numbers)\n-    {\n-      cur_insn_uid++;\n-      return 0;\n-    }\n-\n-  note = rtx_alloc (NOTE);\n-  INSN_UID (note) = cur_insn_uid++;\n-  NOTE_LINE_NUMBER (note) = NOTE_LINE_NUMBER (orig);\n-  NOTE_DATA (note) = NOTE_DATA (orig);\n-  BLOCK_FOR_INSN (note) = NULL;\n-  add_insn_after (note, after);\n-  return note;\n-}\n \f\n /* Like emit_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n@@ -4504,12 +4449,6 @@ emit_note_copy (rtx orig)\n {\n   rtx note;\n   \n-  if (NOTE_LINE_NUMBER (orig) >= 0 && no_line_numbers)\n-    {\n-      cur_insn_uid++;\n-      return NULL_RTX;\n-    }\n-  \n   note = rtx_alloc (NOTE);\n   \n   INSN_UID (note) = cur_insn_uid++;"}, {"sha": "a27d8cbb19f6bc504f74d7d38243d786e2506b2a", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 83, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -203,7 +203,7 @@ extern tree debug_find_var_in_block_tree (tree, tree);\n static void record_insns (rtx, VEC(int,heap) **) ATTRIBUTE_UNUSED;\n static int contains (rtx, VEC(int,heap) **);\n #ifdef HAVE_return\n-static void emit_return_into_block (basic_block, rtx);\n+static void emit_return_into_block (basic_block);\n #endif\n #if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n static rtx keep_stack_depressed (rtx);\n@@ -4340,14 +4340,6 @@ expand_function_end (void)\n      without returning a value.  */\n   emit_note (NOTE_INSN_FUNCTION_END);\n \n-  /* Must mark the last line number note in the function, so that the test\n-     coverage code can avoid counting the last line twice.  This just tells\n-     the code to ignore the immediately following line note, since there\n-     already exists a copy of this note somewhere above.  This line number\n-     note is still needed for debugging though, so we can't delete it.  */\n-  if (flag_test_coverage)\n-    emit_note (NOTE_INSN_REPEATED_LINE_NUMBER);\n-\n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */\n   force_next_line_note ();\n@@ -4653,11 +4645,9 @@ sibcall_epilogue_contains (rtx insn)\n    block_for_insn appropriately.  */\n \n static void\n-emit_return_into_block (basic_block bb, rtx line_note)\n+emit_return_into_block (basic_block bb)\n {\n   emit_jump_insn_after (gen_return (), BB_END (bb));\n-  if (line_note)\n-    emit_note_copy_after (line_note, PREV_INSN (BB_END (bb)));\n }\n #endif /* HAVE_return */\n \n@@ -5123,18 +5113,6 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       if (BB_HEAD (last) == label && LABEL_P (label))\n \t{\n \t  edge_iterator ei2;\n-\t  rtx epilogue_line_note = NULL_RTX;\n-\n-\t  /* Locate the line number associated with the closing brace,\n-\t     if we can find one.  */\n-\t  for (seq = get_last_insn ();\n-\t       seq && ! active_insn_p (seq);\n-\t       seq = PREV_INSN (seq))\n-\t    if (NOTE_P (seq) && NOTE_LINE_NUMBER (seq) > 0)\n-\t      {\n-\t\tepilogue_line_note = seq;\n-\t\tbreak;\n-\t      }\n \n \t  for (ei2 = ei_start (last->preds); (e = ei_safe_edge (ei2)); )\n \t    {\n@@ -5158,7 +5136,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t\t with a simple return instruction.  */\n \t      if (simplejump_p (jump))\n \t\t{\n-\t\t  emit_return_into_block (bb, epilogue_line_note);\n+\t\t  emit_return_into_block (bb);\n \t\t  delete_insn (jump);\n \t\t}\n \n@@ -5195,7 +5173,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t     this is still reachable will be determined later.  */\n \n \t  emit_barrier_after (BB_END (last));\n-\t  emit_return_into_block (last, epilogue_line_note);\n+\t  emit_return_into_block (last);\n \t  epilogue_end = BB_END (last);\n \t  single_succ_edge (last)->flags &= ~EDGE_FALLTHRU;\n \t  goto epilogue_done;\n@@ -5297,61 +5275,6 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n     }\n #endif\n \n-#ifdef HAVE_prologue\n-  /* This is probably all useless now that we use locators.  */\n-  if (prologue_end)\n-    {\n-      rtx insn, prev;\n-\n-      /* GDB handles `break f' by setting a breakpoint on the first\n-\t line note after the prologue.  Which means (1) that if\n-\t there are line number notes before where we inserted the\n-\t prologue we should move them, and (2) we should generate a\n-\t note before the end of the first basic block, if there isn't\n-\t one already there.\n-\n-\t ??? This behavior is completely broken when dealing with\n-\t multiple entry functions.  We simply place the note always\n-\t into first basic block and let alternate entry points\n-\t to be missed.\n-       */\n-\n-      for (insn = prologue_end; insn; insn = prev)\n-\t{\n-\t  prev = PREV_INSN (insn);\n-\t  if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-\t    {\n-\t      /* Note that we cannot reorder the first insn in the\n-\t\t chain, since rest_of_compilation relies on that\n-\t\t remaining constant.  */\n-\t      if (prev == NULL)\n-\t\tbreak;\n-\t      reorder_insns (insn, insn, prologue_end);\n-\t    }\n-\t}\n-\n-      /* Find the last line number note in the first block.  */\n-      for (insn = BB_END (ENTRY_BLOCK_PTR->next_bb);\n-\t   insn != prologue_end && insn;\n-\t   insn = PREV_INSN (insn))\n-\tif (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-\t  break;\n-\n-      /* If we didn't find one, make a copy of the first line number\n-\t we run across.  */\n-      if (! insn)\n-\t{\n-\t  for (insn = next_active_insn (prologue_end);\n-\t       insn;\n-\t       insn = PREV_INSN (insn))\n-\t    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-\t      {\n-\t\temit_note_copy_after (insn, prologue_end);\n-\t\tbreak;\n-\t      }\n-\t}\n-    }\n-#endif\n #ifdef HAVE_epilogue\n   if (epilogue_end)\n     {\n@@ -5366,8 +5289,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t{\n \t  next = NEXT_INSN (insn);\n \t  if (NOTE_P (insn) \n-\t      && (NOTE_LINE_NUMBER (insn) > 0\n-\t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG\n \t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END))\n \t    reorder_insns (insn, insn, PREV_INSN (epilogue_end));\n \t}"}, {"sha": "6cd1fe1e18576f2cbed6374e88b5dac35ae71ba8", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 3, "deletions": 138, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -511,26 +511,18 @@ static void advance_one_cycle (void);\n    Generally, NOTES are saved before scheduling and restored after scheduling.\n    The scheduler distinguishes between three types of notes:\n \n-   (1) LINE_NUMBER notes, generated and used for debugging.  Here,\n-   before scheduling a region, a pointer to the LINE_NUMBER note is\n-   added to the insn following it (in save_line_notes()), and the note\n-   is removed (in rm_line_notes() and unlink_line_notes()).  After\n-   scheduling the region, this pointer is used for regeneration of\n-   the LINE_NUMBER note (in restore_line_notes()).\n-\n-   (2) LOOP_BEGIN, LOOP_END, SETJMP, EHREGION_BEG, EHREGION_END notes:\n+   (1) LOOP_BEGIN, LOOP_END, SETJMP, EHREGION_BEG, EHREGION_END notes:\n    Before scheduling a region, a pointer to the note is added to the insn\n    that follows or precedes it.  (This happens as part of the data dependence\n    computation).  After scheduling an insn, the pointer contained in it is\n    used for regenerating the corresponding note (in reemit_notes).\n \n-   (3) All other notes (e.g. INSN_DELETED):  Before scheduling a block,\n+   (2) All other notes (e.g. INSN_DELETED):  Before scheduling a block,\n    these notes are put in a list (in rm_other_notes() and\n    unlink_other_notes ()).  After scheduling the block, these notes are\n    inserted at the beginning of the block (in schedule_block()).  */\n \n static rtx unlink_other_notes (rtx, rtx);\n-static rtx unlink_line_notes (rtx, rtx);\n static void reemit_notes (rtx);\n \n static rtx *ready_lastpos (struct ready_list *);\n@@ -1276,50 +1268,6 @@ unlink_other_notes (rtx insn, rtx tail)\n   return insn;\n }\n \n-/* Delete line notes beginning with INSN. Record line-number notes so\n-   they can be reused.  Returns the insn following the notes.  */\n-\n-static rtx\n-unlink_line_notes (rtx insn, rtx tail)\n-{\n-  rtx prev = PREV_INSN (insn);\n-\n-  while (insn != tail && NOTE_NOT_BB_P (insn))\n-    {\n-      rtx next = NEXT_INSN (insn);\n-\n-      if (write_symbols != NO_DEBUG && NOTE_LINE_NUMBER (insn) > 0)\n-\t{\n-          basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-\t  /* Delete the note from its current position.  */\n-\t  if (prev)\n-\t    NEXT_INSN (prev) = next;\n-\t  if (next)\n-\t    PREV_INSN (next) = prev;\n-\n-          if (bb)\n-            {\n-              /* Basic block can begin with either LABEL or\n-                 NOTE_INSN_BASIC_BLOCK.  */\n-              gcc_assert (BB_HEAD (bb) != insn);\n-\n-              /* Check if we are removing last insn in the BB.  */\n-              if (BB_END (bb) == insn)\n-                BB_END (bb) = prev;\n-            }\n-\n-\t  /* Record line-number notes so they can be reused.  */\n-\t  LINE_NOTE (insn) = insn;\n-\t}\n-      else\n-\tprev = insn;\n-\n-      insn = next;\n-    }\n-  return insn;\n-}\n-\n /* Return the head and tail pointers of ebb starting at BEG and ending\n    at END.  */\n \n@@ -1373,34 +1321,6 @@ no_real_insns_p (rtx head, rtx tail)\n   return 1;\n }\n \n-/* Delete line notes from one block. Save them so they can be later restored\n-   (in restore_line_notes).  HEAD and TAIL are the boundaries of the\n-   block in which notes should be processed.  */\n-\n-void\n-rm_line_notes (rtx head, rtx tail)\n-{\n-  rtx next_tail;\n-  rtx insn;\n-\n-  next_tail = NEXT_INSN (tail);\n-  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    {\n-      rtx prev;\n-\n-      /* Farm out notes, and maybe save them in NOTE_LIST.\n-         This is needed to keep the debugger from\n-         getting completely deranged.  */\n-      if (NOTE_NOT_BB_P (insn))\n-\t{\n-\t  prev = insn;\n-\t  insn = unlink_line_notes (insn, next_tail);\n-\n-\t  gcc_assert (prev != tail && prev != head && insn != next_tail);\n-\t}\n-    }\n-}\n-\n /* Save line number notes for each insn in block B.  HEAD and TAIL are\n    the boundaries of the block in which notes should be processed.  */\n \n@@ -1420,10 +1340,7 @@ save_line_notes (int b, rtx head, rtx tail)\n   next_tail = NEXT_INSN (tail);\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-      line = insn;\n-    else\n-      LINE_NOTE (insn) = line;\n+    LINE_NOTE (insn) = line;\n }\n \n /* After a block was scheduled, insert line notes into the insns list.\n@@ -1497,58 +1414,6 @@ restore_line_notes (rtx head, rtx tail)\n     fprintf (sched_dump, \";; added %d line-number notes\\n\", added_notes);\n }\n \n-/* After scheduling the function, delete redundant line notes from the\n-   insns list.  */\n-\n-void\n-rm_redundant_line_notes (void)\n-{\n-  rtx line = 0;\n-  rtx insn = get_insns ();\n-  int active_insn = 0;\n-  int notes = 0;\n-\n-  /* Walk the insns deleting redundant line-number notes.  Many of these\n-     are already present.  The remainder tend to occur at basic\n-     block boundaries.  */\n-  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-      {\n-\t/* If there are no active insns following, INSN is redundant.  */\n-\tif (active_insn == 0)\n-\t  {\n-\t    notes++;\n-\t    SET_INSN_DELETED (insn);\n-\t  }\n-\t/* If the line number is unchanged, LINE is redundant.  */\n-\telse if (line\n-#ifdef USE_MAPPED_LOCATION\n-\t\t && NOTE_SOURCE_LOCATION (line) == NOTE_SOURCE_LOCATION (insn)\n-#else\n-\t\t && NOTE_LINE_NUMBER (line) == NOTE_LINE_NUMBER (insn)\n-\t\t && NOTE_SOURCE_FILE (line) == NOTE_SOURCE_FILE (insn)\n-#endif\n-)\n-\t  {\n-\t    notes++;\n-\t    SET_INSN_DELETED (line);\n-\t    line = insn;\n-\t  }\n-\telse\n-\t  line = insn;\n-\tactive_insn = 0;\n-      }\n-    else if (!((NOTE_P (insn)\n-\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n-\t       || (NONJUMP_INSN_P (insn)\n-\t\t   && (GET_CODE (PATTERN (insn)) == USE\n-\t\t       || GET_CODE (PATTERN (insn)) == CLOBBER))))\n-      active_insn++;\n-\n-  if (sched_verbose && notes)\n-    fprintf (sched_dump, \";; deleted %d line-number notes\\n\", notes);\n-}\n-\n /* Delete notes between HEAD and TAIL and put them in the chain\n    of notes ended by NOTE_LIST.  */\n "}, {"sha": "f42ee5a43ab956972b3ff00f4fcd272475234e9c", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -140,62 +140,6 @@ struct tree_opt_pass pass_cleanup_barriers =\n   0                                     /* letter */\n };\n \n-unsigned int\n-purge_line_number_notes (void)\n-{\n-  rtx last_note = 0;\n-  rtx insn;\n-  /* Delete extraneous line number notes.\n-     Note that two consecutive notes for different lines are not really\n-     extraneous.  There should be some indication where that line belonged,\n-     even if it became empty.  */\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (NOTE_P (insn))\n-      {\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n-\t  /* Any previous line note was for the prologue; gdb wants a new\n-\t     note after the prologue even if it is for the same line.  */\n-\t  last_note = NULL_RTX;\n-\telse if (NOTE_LINE_NUMBER (insn) >= 0)\n-\t  {\n-\t    /* Delete this note if it is identical to previous note.  */\n-\t    if (last_note\n-#ifdef USE_MAPPED_LOCATION\n-\t\t&& NOTE_SOURCE_LOCATION (insn) == NOTE_SOURCE_LOCATION (last_note)\n-#else\n-\t\t&& NOTE_SOURCE_FILE (insn) == NOTE_SOURCE_FILE (last_note)\n-\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_LINE_NUMBER (last_note)\n-#endif\n-)\n-\t      {\n-\t\tdelete_related_insns (insn);\n-\t\tcontinue;\n-\t      }\n-\n-\t    last_note = insn;\n-\t  }\n-      }\n-  return 0;\n-}\n-\n-struct tree_opt_pass pass_purge_lineno_notes =\n-{\n-  \"elnotes\",                            /* name */\n-  NULL,                                 /* gate */\n-  purge_line_number_notes,              /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  0,                                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func,                       /* todo_flags_finish */\n-  0                                     /* letter */\n-};\n-\n \f\n /* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL\n    notes whose labels don't occur in the insn any more.  Returns the"}, {"sha": "8426ba6313a963cae175c0b444afc1b3e1d4e4f6", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -761,19 +761,6 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop * loop, rtx count_r\n   end_sequence ();\n }\n \n-/* Return the line note insn preceding INSN, for debugging.  Taken from\n-   emit-rtl.c.  */\n-static rtx\n-find_line_note (rtx insn)\n-{\n-  for (; insn; insn = PREV_INSN (insn))\n-    if (NOTE_P (insn)\n-\t&& NOTE_LINE_NUMBER (insn) >= 0)\n-      break;\n-\n-  return insn;\n-}\n-\n /* Return true if all the BBs of the loop are empty except the\n    loop header.  */\n static bool\n@@ -831,16 +818,7 @@ loop_canon_p (struct loop *loop)\n     {\n       if (dump_file)\n \t{\n-\t  rtx line_note = find_line_note (BB_END (loop->header));\n-\n \t  fprintf (dump_file, \"SMS loop many exits \");\n-\t  if (line_note)\n-\t    {\n-\t      expanded_location xloc;\n-\t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t      fprintf (dump_file, \" %s %d (file, line)\\n\",\n-\t\t       xloc.file, xloc.line);\n-\t    }\n \t}\n       return false;\n     }\n@@ -849,16 +827,7 @@ loop_canon_p (struct loop *loop)\n     {\n       if (dump_file)\n \t{\n-\t  rtx line_note = find_line_note (BB_END (loop->header));\n-\n \t  fprintf (dump_file, \"SMS loop many BBs. \");\n-\t  if (line_note)\n-\t    {\n-\t      expanded_location xloc;\n-  \t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t      fprintf (dump_file, \" %s %d (file, line)\\n\",\n-\t\t       xloc.file, xloc.line);\n-\t    }\n \t}\n       return false;\n     }\n@@ -986,15 +955,6 @@ sms_schedule (void)\n \t{\n \t  if (dump_file)\n \t    {\n-\t      rtx line_note = find_line_note (tail);\n-\n-\t      if (line_note)\n-\t\t{\n-\t\t  expanded_location xloc;\n-\t\t  NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t\t  fprintf (dump_file, \"SMS bb %s %d (file, line)\\n\",\n-\t\t\t   xloc.file, xloc.line);\n-\t\t}\n \t      fprintf (dump_file, \"SMS single-bb-loop\\n\");\n \t      if (profile_info && flag_branch_probabilities)\n \t    \t{\n@@ -1084,15 +1044,6 @@ sms_schedule (void)\n \n       if (dump_file)\n \t{\n-\t  rtx line_note = find_line_note (tail);\n-\n-\t  if (line_note)\n-\t    {\n-\t      expanded_location xloc;\n-\t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t      fprintf (dump_file, \"SMS bb %s %d (file, line)\\n\",\n-\t\t       xloc.file, xloc.line);\n-\t    }\n \t  fprintf (dump_file, \"SMS single-bb-loop\\n\");\n \t  if (profile_info && flag_branch_probabilities)\n \t    {"}, {"sha": "05288b6a149521db13de6a7c6f89a908ec01cd3a", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -683,7 +683,6 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_variable_tracking);\n   NEXT_PASS (pass_free_cfg);\n   NEXT_PASS (pass_machine_reorg);\n-  NEXT_PASS (pass_purge_lineno_notes);\n   NEXT_PASS (pass_cleanup_barriers);\n   NEXT_PASS (pass_delay_slots);\n   NEXT_PASS (pass_split_for_shorten_branches);"}, {"sha": "4bd5d1da9915b97ba7486cd8ad04877818522c22", "filename": "gcc/regmove.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -1894,15 +1894,9 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n \t{\n \t  rtx notes = REG_NOTES (insn);\n \n-\t  emit_insn_after_with_line_notes (pat, PREV_INSN (p), insn);\n+\t  p = emit_insn_after_setloc (pat, PREV_INSN (p), INSN_LOCATOR (insn));\n \t  delete_insn (insn);\n-\t  /* emit_insn_after_with_line_notes has no\n-\t     return value, so search for the new insn.  */\n-\t  insn = p;\n-\t  while (! INSN_P (insn) || PATTERN (insn) != pat)\n-\t    insn = PREV_INSN (insn);\n-\n-\t  REG_NOTES (insn) = notes;\n+\t  REG_NOTES (p) = notes;\n \t}\n     }\n   /* Sometimes we'd generate src = const; src += n;"}, {"sha": "abc3d5a0670f371af45716799e19f20b2c3a62f1", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -1553,7 +1553,6 @@ extern rtx emit_call_insn_after_setloc (rtx, rtx, int);\n extern rtx emit_barrier_after (rtx);\n extern rtx emit_label_after (rtx, rtx);\n extern rtx emit_note_after (int, rtx);\n-extern rtx emit_note_copy_after (rtx, rtx);\n extern rtx emit_insn (rtx);\n extern rtx emit_jump_insn (rtx);\n extern rtx emit_call_insn (rtx);\n@@ -2065,7 +2064,6 @@ extern void add_insn (rtx);\n extern void add_insn_before (rtx, rtx);\n extern void add_insn_after (rtx, rtx);\n extern void remove_insn (rtx);\n-extern void emit_insn_after_with_line_notes (rtx, rtx, rtx);\n extern rtx emit (rtx);\n extern void renumber_insns (void);\n extern rtx delete_insn (rtx);"}, {"sha": "19c60cf9f0dc7bf118949fcb49a58758efb118c6", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -482,7 +482,6 @@ schedule_ebb (rtx head, rtx tail)\n   if (write_symbols != NO_DEBUG)\n     {\n       save_line_notes (first_bb->index, head, tail);\n-      rm_line_notes (head, tail);\n     }\n \n   /* rm_other_notes only removes notes which are _inside_ the\n@@ -681,9 +680,6 @@ schedule_ebbs (void)\n   if (reload_completed)\n     reposition_prologue_and_epilogue_notes (get_insns ());\n \n-  if (write_symbols != NO_DEBUG)\n-    rm_redundant_line_notes ();\n-\n   sched_finish ();\n }\n "}, {"sha": "000af71433697395527b426ff72ee7608831c2fc", "filename": "gcc/sched-int.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -634,10 +634,8 @@ extern int haifa_classify_insn (rtx);\n extern void get_ebb_head_tail (basic_block, basic_block, rtx *, rtx *);\n extern int no_real_insns_p (rtx, rtx);\n \n-extern void rm_line_notes (rtx, rtx);\n extern void save_line_notes (int, rtx, rtx);\n extern void restore_line_notes (rtx, rtx);\n-extern void rm_redundant_line_notes (void);\n extern void rm_other_notes (rtx, rtx);\n \n extern int insn_cost (rtx, rtx, rtx);"}, {"sha": "47d0a9a17a30432d5e412bb5e84608201f5bd6cc", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -2787,7 +2787,6 @@ schedule_region (int rgn)\n       if (write_symbols != NO_DEBUG)\n \t{\n \t  save_line_notes (b, head, tail);\n-\t  rm_line_notes (head, tail);\n \t}\n \n       /* rm_other_notes only removes notes which are _inside_ the\n@@ -3045,10 +3044,6 @@ schedule_insns (void)\n   if (reload_completed)\n     reposition_prologue_and_epilogue_notes (get_insns ());\n \n-  /* Delete redundant line notes.  */\n-  if (write_symbols != NO_DEBUG)\n-    rm_redundant_line_notes ();\n-\n   if (sched_verbose)\n     {\n       if (reload_completed == 0 && flag_schedule_interblock)"}, {"sha": "d6838d2081fe7eaa12e31f2f600d0c538ccc2363", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6039a0c74a90a4a344e2c000115acfa46293ef8f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=6039a0c74a90a4a344e2c000115acfa46293ef8f", "patch": "@@ -386,7 +386,6 @@ extern struct tree_opt_pass pass_duplicate_computed_gotos;\n extern struct tree_opt_pass pass_variable_tracking;\n extern struct tree_opt_pass pass_free_cfg;\n extern struct tree_opt_pass pass_machine_reorg;\n-extern struct tree_opt_pass pass_purge_lineno_notes;\n extern struct tree_opt_pass pass_cleanup_barriers;\n extern struct tree_opt_pass pass_delay_slots;\n extern struct tree_opt_pass pass_split_for_shorten_branches;"}]}