{"sha": "07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdmNGE4M2Q0YWZiYTI4ZjhiNzNhOWI5YThhZWI0OGFkZWM5ZWFjMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-10-04T03:24:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-10-04T03:24:42Z"}, "message": "devirt-42.C: New testcase.\n\n\n\t* testsuite/g++.dg/ipa/devirt-42.C: New testcase.\n\t* testsuite/g++.dg/ipa/devirt-43.C: New testcase.\n\t* testsuite/g++.dg/ipa/devirt-44.C: New testcase.\n\t* testsuite/g++.dg/ipa/devirt-45.C: New testcase.\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Fix\n\tcode determining speculative type.\n\t(ipa_polymorphic_call_context::combine_with): Fix speculation merge.\n\nFrom-SVN: r215886", "tree": {"sha": "4e12538abcb7a57877879348dae3ea4837723aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e12538abcb7a57877879348dae3ea4837723aa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/comments", "author": null, "committer": null, "parents": [{"sha": "dbaba85539c4742ccb02f4750c05ccc296cbbb7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbaba85539c4742ccb02f4750c05ccc296cbbb7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbaba85539c4742ccb02f4750c05ccc296cbbb7b"}], "stats": {"total": 195, "additions": 192, "deletions": 3}, "files": [{"sha": "9437414fb9b67bcedbff31e0d8a472d514a9c040", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -1,3 +1,10 @@\n+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Fix\n+\tcode determining speculative type.\n+\t(ipa_polymorphic_call_context::combine_with): Fix speculation merge.\n+\n 2014-10-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* altivec.md (altivec_lvsl): New define_expand."}, {"sha": "a9b037a5211ccc03ead3347732a615543d340484", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -820,8 +820,7 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t\t\t\t\t       &offset2, &size, &max_size);\n \n \t  if (max_size != -1 && max_size == size)\n-\t    combine_speculation_with (TYPE_MAIN_VARIANT\n-\t\t\t\t\t(TREE_TYPE (TREE_TYPE (base_pointer))),\n+\t    combine_speculation_with (TYPE_MAIN_VARIANT (TREE_TYPE (base)),\n \t\t\t\t      offset + offset2,\n \t\t\t\t      true,\n \t\t\t\t      NULL /* Do not change outer type.  */);\n@@ -1970,7 +1969,7 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \n   updated |= combine_speculation_with (ctx.speculative_outer_type,\n \t\t\t\t       ctx.speculative_offset,\n-\t\t\t\t       ctx.maybe_in_construction,\n+\t\t\t\t       ctx.speculative_maybe_derived_type,\n \t\t\t\t       otr_type);\n \n   if (updated && dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "2293926ea893f59b333933f1d9733372f0e8ff8c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -1,3 +1,10 @@\n+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* testsuite/g++.dg/ipa/devirt-42.C: New testcase.\n+\t* testsuite/g++.dg/ipa/devirt-43.C: New testcase.\n+\t* testsuite/g++.dg/ipa/devirt-44.C: New testcase.\n+\t* testsuite/g++.dg/ipa/devirt-45.C: New testcase.\n+\n 2014-10-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/lvsl-lvsr.c: New test."}, {"sha": "5ba1158f8f7b5ea7e3bb4d9bd49064e71ab672a8", "filename": "gcc/testsuite/g++.dg/ipa/devirt-41.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-41.C?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-inline-details -fno-early-inlining -fno-ipa-cp\" } */\n+struct A {virtual int foo () {return 1;}};\n+struct B:A {virtual int foo () {return 2;}};\n+\n+void dostuff(struct A *);\n+\n+static void\n+test (struct A *a)\n+{\n+  dostuff (a);\n+  if (a->foo ()!= 2)\n+    __builtin_abort ();\n+}\n+\n+main()\n+{\n+  struct B a;\n+  dostuff (&a);\n+  test (&a);\n+}\n+/* Inlining of dostuff into main should combine polymorphic context\n+   specifying Outer type:struct B offset 0\n+   with Outer type (dynamic):struct A (or a derived type) offset 0\n+   and enable devirtualization.\n+\n+   Because the type is in static storage, we know it won't change type in dostuff\n+   and from callstack we can tell that is is not in construction/destruction.  */\n+/* { dg-final { scan-ipa-dump-times \"First type is base of second\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "40076ddf33e6b673ef313530f784c89361616490", "filename": "gcc/testsuite/g++.dg/ipa/devirt-42.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-42.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-42.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-42.C?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-cp -fdump-ipa-inline-details -fno-early-inlining -fdump-tree-optimized\" } */\n+struct A {\n+  virtual int foo () {return 1;}\n+  int bar () {return foo();}\n+  int barbar ();\n+};\n+namespace {\n+  struct B:A {virtual int foo () {return 2;}\n+\t      int barbar () {return bar();}};\n+}\n+\n+int\n+A::barbar()\n+{\n+  return static_cast<B*>(this)->barbar();\n+}\n+\n+main()\n+{\n+  struct B b;\n+  struct A *a = &b;\n+  return a->barbar ();\n+}\n+\n+/* Inlining everything into main makes type clear from type of variable b.\n+   However devirtualization is also possible for offline copy of A::barbar. Invoking\n+   B's barbar makes it clear the type is at least B and B is an anonymous\n+   namespace type and therefore we know it has no derivations.\n+   FIXME: Currently we devirtualize speculatively only because we do not track\n+   dynamic type changes well.  */\n+/* { dg-final { scan-ipa-dump-times \"First type is base of second\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Outer types match, merging flags\" 2 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a speculative target\" 1 \"inline\"  } } */\n+\n+/* Verify that speculation is optimized by late optimizers.  */\n+/* { dg-final { scan-ipa-dump-times \"return 2\" 2 \"optimized\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"OBJ_TYPE_REF\" \"optimized\"  } } */\n+\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { cleanup-ipa-dump \"optimized\" } } */"}, {"sha": "9be49e764eae269d8cf8012852e1705f4700d185", "filename": "gcc/testsuite/g++.dg/ipa/devirt-43.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-43.C?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-inline-details -fno-ipa-cp -fno-early-inlining\" } */\n+struct A {virtual int foo () {return 1;}};\n+struct B {int i; struct A a;};\n+struct C:A {virtual int foo () {return 2;}};\n+\n+void dostuff(struct A *);\n+\n+static void\n+test (struct A *a)\n+{\n+  dostuff (a);\n+  if (a->foo ()!= 2)\n+    __builtin_abort ();\n+}\n+\n+void\n+t(struct B *b)\n+{\n+  test(&b->a);\n+}\n+/* Here b comes externally, but we take speculative hint from type of the pointer that it is\n+   of type B.  This makes A fully specified and we know C::foo is unlikely.\n+   FIXME: We could most probably can devirtualize unconditonally because dereference of b in\n+   &b->a makes the type known.  GIMPLE does not represent this.  */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a speculative target\" 1 \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "4f6ab30cb02c6365d19b6e3f96cfc7b2016ca1a8", "filename": "gcc/testsuite/g++.dg/ipa/devirt-44.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-44.C?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-cp -fdump-ipa-inline-details -fno-early-inlining -fdump-tree-optimized\" } */\n+struct A {\n+  virtual int foo () {return 1;}\n+  int wrapfoo () {foo();}\n+  A() {wrapfoo();}\n+};\n+struct B:A {virtual int foo () {return 2;}};\n+\n+void dostuff(struct A *);\n+\n+static void\n+test (struct A *a)\n+{\n+  dostuff (a);\n+  if (a->foo ()!= 2)\n+    __builtin_abort ();\n+}\n+\n+main()\n+{\n+  struct B a;\n+  dostuff (&a);\n+  test (&a);\n+}\n+/* Here one invocation of foo is while type is in construction, while other is not.\n+   Check that we handle that.  */\n+\n+/* { dg-final { scan-ipa-dump-times \"First type is base of second\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"(maybe in construction)\" \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\\[^\\\\n\\]*A::foo\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\\[^\\\\n\\]*B::foo\" 1 \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "2158c7e59872691731cd4b7e6e7e61704a7e9ea2", "filename": "gcc/testsuite/g++.dg/ipa/devirt-45.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-45.C?ref=07f4a83d4afba28f8b73a9b9a8aeb48adec9eac3", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-cp -fdump-ipa-inline-details -fno-early-inlining -fdump-tree-optimized\" } */\n+struct A {\n+  virtual int foo () {return 1;}\n+  int wrapfoo () {foo();}\n+  A() {wrapfoo();}\n+};\n+inline void* operator new(__SIZE_TYPE__ s, void* buf) throw() {\n+   return buf;\n+}\n+struct B:A {virtual int foo () {return 2;}};\n+\n+void dostuff(struct A *);\n+\n+static void\n+test2 (struct A *a)\n+{\n+  dostuff (a);\n+  if (a->foo ()!= 2)\n+    __builtin_abort ();\n+}\n+\n+static void\n+test (struct A *a)\n+{\n+  dostuff (a);\n+  static_cast<B*>(a)->~B();\n+  new(a) B();\n+  test2(a);\n+}\n+\n+main()\n+{\n+  struct B a;\n+  dostuff (&a);\n+  test (&a);\n+}\n+\n+/* One invocation is A::foo () other is B::foo () even though the type is destroyed and rebuilt in test() */\n+/* { dg-final { scan-ipa-dump \"(maybe in construction)\" \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\\[^\\\\n\\]*A::foo\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\\[^\\\\n\\]*B::foo\" 1 \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}