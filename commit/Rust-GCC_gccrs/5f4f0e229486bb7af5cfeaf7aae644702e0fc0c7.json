{"sha": "5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY0ZjBlMjI5NDg2YmI3YWY1Y2ZlYWY3YWFlNjQ0NzAyZTBmYzBjNw==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:04:00Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:04:00Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1471", "tree": {"sha": "c4e3d923add2b1e3aec57cb0e90c70c3fb93a5f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4e3d923add2b1e3aec57cb0e90c70c3fb93a5f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/comments", "author": null, "committer": null, "parents": [{"sha": "3d678dca190485cba2a650037191fc647289a432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d678dca190485cba2a650037191fc647289a432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d678dca190485cba2a650037191fc647289a432"}], "stats": {"total": 908, "additions": 504, "deletions": 404}, "files": [{"sha": "5915cf079bbd46fd544a7303805121ad38fc330c", "filename": "gcc/collect2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -28,7 +28,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include <sys/types.h>\n #include <stdio.h>\n-#include <string.h>\n #include <ctype.h>\n #include <errno.h>\n #include <signal.h>"}, {"sha": "bfdacb71f541f3e70c7978112669689fd5e60498", "filename": "gcc/combine.c", "status": "modified", "additions": 306, "deletions": 291, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -249,10 +249,10 @@ static short label_tick;\n \n    If an entry is zero, it means that we don't know anything special.  */\n \n-static int *reg_significant;\n+static HOST_WIDE_INT *reg_significant;\n \n /* Mode used to compute significance in reg_significant.  It is the largest\n-   integer mode that can fit in HOST_BITS_PER_INT.  */\n+   integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n static enum machine_mode significant_mode;\n \n@@ -364,7 +364,7 @@ static rtx make_field_assignment ();\n static rtx make_compound_operation ();\n static rtx apply_distributive_law ();\n static rtx simplify_and_const_int ();\n-static unsigned significant_bits ();\n+static unsigned HOST_WIDE_INT significant_bits ();\n static int merge_outer_ops ();\n static rtx simplify_shift_const ();\n static int recog_for_combine ();\n@@ -403,15 +403,15 @@ combine_instructions (f, nregs)\n   reg_last_set_value = (rtx *) alloca (nregs * sizeof (rtx));\n   reg_last_set_table_tick = (short *) alloca (nregs * sizeof (short));\n   reg_last_set_label = (short *) alloca (nregs * sizeof (short));\n-  reg_last_set_invalid = (char *) alloca (nregs * sizeof (short));\n-  reg_significant = (int *) alloca (nregs * sizeof (int));\n+  reg_last_set_invalid = (char *) alloca (nregs * sizeof (char));\n+  reg_significant = (HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n \n   bzero (reg_last_death, nregs * sizeof (rtx));\n   bzero (reg_last_set, nregs * sizeof (rtx));\n   bzero (reg_last_set_value, nregs * sizeof (rtx));\n   bzero (reg_last_set_table_tick, nregs * sizeof (short));\n   bzero (reg_last_set_invalid, nregs * sizeof (char));\n-  bzero (reg_significant, nregs * sizeof (int));\n+  bzero (reg_significant, nregs * sizeof (HOST_WIDE_INT));\n \n   init_recog_no_volatile ();\n \n@@ -423,7 +423,7 @@ combine_instructions (f, nregs)\n \n   uid_cuid = (int *) alloca ((i + 1) * sizeof (int));\n \n-  significant_mode = mode_for_size (HOST_BITS_PER_INT, MODE_INT, 0);\n+  significant_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n   /* Don't use reg_significant when computing it.  This can cause problems\n      when, for example, we have j <<= 1 in a loop.  */\n@@ -466,7 +466,7 @@ combine_instructions (f, nregs)\n \t  /* Try this insn with each insn it links back to.  */\n \n \t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t    if ((next = try_combine (insn, XEXP (links, 0), 0)) != 0)\n+\t    if ((next = try_combine (insn, XEXP (links, 0), NULL_RTX)) != 0)\n \t      goto retry;\n \n \t  /* Try each sequence of three linked insns ending with this one.  */\n@@ -491,7 +491,7 @@ combine_instructions (f, nregs)\n \t      && GET_CODE (prev) == INSN\n \t      && sets_cc0_p (PATTERN (prev)))\n \t    {\n-\t      if ((next = try_combine (insn, prev, 0)) != 0)\n+\t      if ((next = try_combine (insn, prev, NULL_RTX)) != 0)\n \t\tgoto retry;\n \n \t      for (nextlinks = LOG_LINKS (prev); nextlinks;\n@@ -509,7 +509,7 @@ combine_instructions (f, nregs)\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n \t    {\n-\t      if ((next = try_combine (insn, prev, 0)) != 0)\n+\t      if ((next = try_combine (insn, prev, NULL_RTX)) != 0)\n \t\tgoto retry;\n \n \t      for (nextlinks = LOG_LINKS (prev); nextlinks;\n@@ -557,7 +557,7 @@ combine_instructions (f, nregs)\n }\n \f\n /* Called via note_stores.  If X is a pseudo that is used in more than\n-   one basic block, is narrower that HOST_BITS_PER_INT, and is being\n+   one basic block, is narrower that HOST_BITS_PER_WIDE_INT, and is being\n    set, record what bits are significant.  If we are clobbering X,\n    ignore this \"set\" because the clobbered value won't be used. \n \n@@ -574,7 +574,7 @@ set_significant (x, set)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       && reg_n_sets[REGNO (x)] > 1\n       && reg_basic_block[REGNO (x)] < 0\n-      && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_INT)\n+      && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (GET_CODE (set) == CLOBBER)\n \treturn;\n@@ -700,14 +700,14 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n       || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == STRICT_LOW_PART\n       /* Don't combine with an insn that sets a register to itself if it has\n \t a REG_EQUAL note.  This may be part of a REG_NO_CONFLICT sequence.  */\n-      || (rtx_equal_p (src, dest) && find_reg_note (insn, REG_EQUAL, 0))\n+      || (rtx_equal_p (src, dest) && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n       /* Can't merge a function call.  */\n       || GET_CODE (src) == CALL\n       /* Don't substitute into an incremented register.  */\n       || FIND_REG_INC_NOTE (i3, dest)\n       || (succ && FIND_REG_INC_NOTE (succ, dest))\n       /* Don't combine the end of a libcall into anything.  */\n-      || find_reg_note (insn, REG_RETVAL, 0)\n+      || find_reg_note (insn, REG_RETVAL, NULL_RTX)\n       /* Make sure that DEST is not used after SUCC but before I3.  */\n       || (succ && ! all_adjacent\n \t  && reg_used_between_p (dest, succ, i3))\n@@ -1006,7 +1006,7 @@ try_combine (i3, i2, i1)\n   if (GET_RTX_CLASS (GET_CODE (i3)) != 'i'\n       || GET_RTX_CLASS (GET_CODE (i2)) != 'i'\n       || (i1 && GET_RTX_CLASS (GET_CODE (i1)) != 'i')\n-      || find_reg_note (i3, REG_LIBCALL, 0))\n+      || find_reg_note (i3, REG_LIBCALL, NULL_RTX))\n     return 0;\n \n   combine_attempts++;\n@@ -1145,8 +1145,8 @@ try_combine (i3, i2, i1)\n #endif\n \n   /* Verify that I2 and I1 are valid for combining.  */\n-  if (! can_combine_p (i2, i3, i1, 0, &i2dest, &i2src)\n-      || (i1 && ! can_combine_p (i1, i3, 0, i2, &i1dest, &i1src)))\n+  if (! can_combine_p (i2, i3, i1, NULL_RTX, &i2dest, &i2src)\n+      || (i1 && ! can_combine_p (i1, i3, NULL_RTX, i2, &i1dest, &i1src)))\n     {\n       undo_all ();\n       return 0;\n@@ -1350,7 +1350,8 @@ try_combine (i3, i2, i1)\n \t above (see detailed comments there) that ensures  that I1DEST\n \t isn't mentioned in any SETs in NEWPAT that are field assignments. */\n \n-      if (! combinable_i3pat (0, &newpat, i1dest, 0, 0, 0))\n+      if (! combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX,\n+\t\t\t      0, NULL_PTR))\n \t{\n \t  undo_all ();\n \t  return 0;\n@@ -1363,9 +1364,9 @@ try_combine (i3, i2, i1)\n \n   /* Fail if an autoincrement side-effect has been duplicated.  Be careful\n      to count all the ways that I2SRC and I1SRC can be used.  */\n-  if ((FIND_REG_INC_NOTE (i2, 0) != 0\n+  if ((FIND_REG_INC_NOTE (i2, NULL_RTX) != 0\n        && i2_is_used + added_sets_2 > 1)\n-      || (i1 != 0 && FIND_REG_INC_NOTE (i1, 0) != 0\n+      || (i1 != 0 && FIND_REG_INC_NOTE (i1, NULL_RTX) != 0\n \t  && (n_occurrences + added_sets_1 + (added_sets_2 && ! i1_feeds_i3)\n \t      > 1))\n       /* Fail if we tried to make a new register (we used to abort, but there's\n@@ -1575,8 +1576,7 @@ try_combine (i3, i2, i1)\n \t      && GET_CODE (XEXP (*split, 1)) == CONST_INT\n \t      && (i = exact_log2 (INTVAL (XEXP (*split, 1)))) >= 0)\n \t    SUBST (*split, gen_rtx_combine (ASHIFT, GET_MODE (*split),\n-\t\t\t\t\t    XEXP (*split, 0),\n-\t\t\t\t\t    gen_rtx (CONST_INT, VOIDmode, i)));\n+\t\t\t\t\t    XEXP (*split, 0), GEN_INT (i)));\n \n #ifdef INSN_SCHEDULING\n \t  /* If *SPLIT is a paradoxical SUBREG, when we split it, it should\n@@ -1643,7 +1643,7 @@ try_combine (i3, i2, i1)\n \t     that destination.  */\n \n \t  PATTERN (i3) = newpat;\n-\t  distribute_links (gen_rtx (INSN_LIST, VOIDmode, i3, 0));\n+\t  distribute_links (gen_rtx (INSN_LIST, VOIDmode, i3, NULL_RTX));\n \n \t  /* I3 now uses what used to be its destination and which is\n \t     now I2's destination.  That means we need a LOG_LINK from\n@@ -1747,7 +1747,7 @@ try_combine (i3, i2, i1)\n \t}\n \n       distribute_notes (new_other_notes, undobuf.other_insn,\n-\t\t\tundobuf.other_insn, 0, 0, 0);\n+\t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX);\n     }\n \n   /* We now know that we can do this combination.  Merge the insns and \n@@ -1859,33 +1859,40 @@ try_combine (i3, i2, i1)\n \n     /* Distribute all the LOG_LINKS and REG_NOTES from I1, I2, and I3.  */\n     if (i3notes)\n-      distribute_notes (i3notes, i3, i3, newi2pat ? i2 : 0, elim_i2, elim_i1);\n+      distribute_notes (i3notes, i3, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n     if (i2notes)\n-      distribute_notes (i2notes, i2, i3, newi2pat ? i2 : 0, elim_i2, elim_i1);\n+      distribute_notes (i2notes, i2, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n     if (i1notes)\n-      distribute_notes (i1notes, i1, i3, newi2pat ? i2 : 0, elim_i2, elim_i1);\n+      distribute_notes (i1notes, i1, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n     if (midnotes)\n-      distribute_notes (midnotes, 0, i3, newi2pat ? i2 : 0, elim_i2, elim_i1);\n+      distribute_notes (midnotes, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n \n     /* Distribute any notes added to I2 or I3 by recog_for_combine.  We\n        know these are REG_UNUSED and want them to go to the desired insn,\n        so we always pass it as i3.  */\n     if (newi2pat && new_i2_notes)\n-      distribute_notes (new_i2_notes, i2, i2, 0, 0, 0);\n+      distribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n     if (new_i3_notes)\n-      distribute_notes (new_i3_notes, i3, i3, 0, 0, 0);\n+      distribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n \n     /* If I3DEST was used in I3SRC, it really died in I3.  We may need to\n        put a REG_DEAD note for it somewhere.  Similarly for I2 and I1.  */\n     if (i3dest_killed)\n-      distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed, 0),\n-\t\t\t0, i3, newi2pat ? i2 : 0, 0, 0);\n+      distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed, NULL_RTX),\n+\t\t\tNULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\tNULL_RTX, NULL_RTX);\n     if (i2dest_in_i2src)\n-      distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i2dest, 0),\n-\t\t\t0, i3, newi2pat ? i2 : 0, 0, 0);\n+      distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i2dest, NULL_RTX),\n+\t\t\tNULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\tNULL_RTX, NULL_RTX);\n     if (i1dest_in_i1src)\n-      distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i1dest, 0),\n-\t\t\t0, i3, newi2pat ? i2 : 0, 0, 0);\n+      distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i1dest, NULL_RTX),\n+\t\t\tNULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\tNULL_RTX, NULL_RTX);\n \n     distribute_links (i3links);\n     distribute_links (i2links);\n@@ -1899,7 +1906,7 @@ try_combine (i3, i2, i1)\n \t   I2 set the register to a value that depended on its old\n \t   contents, we will get confused.  If this insn is used, thing\n \t   will be set correctly in combine_instructions.  */\n-\trecord_value_for_reg (i2dest, 0, 0);\n+\trecord_value_for_reg (i2dest, NULL_RTX, NULL_RTX);\n \n \t/* If the reg formerly set in I2 died only once and that was in I3,\n \t   zero its use count so it won't make `reload' do any work.  */\n@@ -1908,22 +1915,22 @@ try_combine (i3, i2, i1)\n \t    regno = REGNO (i2dest);\n \t    reg_n_sets[regno]--;\n \t    if (reg_n_sets[regno] == 0\n-\t\t&& ! (basic_block_live_at_start[0][regno / HOST_BITS_PER_INT]\n-\t\t      & (1 << (regno % HOST_BITS_PER_INT))))\n+\t\t&& ! (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n+\t\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n \t      reg_n_refs[regno] = 0;\n \t  }\n       }\n \n     if (i1 && GET_CODE (i1dest) == REG)\n       {\n-\trecord_value_for_reg (i1dest, 0, 0);\n+\trecord_value_for_reg (i1dest, NULL_RTX, NULL_RTX);\n \tregno = REGNO (i1dest);\n \tif (! added_sets_1)\n \t  {\n \t    reg_n_sets[regno]--;\n \t    if (reg_n_sets[regno] == 0\n-\t\t&& ! (basic_block_live_at_start[0][regno / HOST_BITS_PER_INT]\n-\t\t      & (1 << (regno % HOST_BITS_PER_INT))))\n+\t\t&& ! (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n+\t\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n \t      reg_n_refs[regno] = 0;\n \t  }\n       }\n@@ -2080,7 +2087,7 @@ find_split_point (loc)\n \t so, this is an IOR of an AND, so split it into that.  */\n       if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (SET_DEST (x), 0)))\n-\t      <= HOST_BITS_PER_INT)\n+\t      <= HOST_BITS_PER_WIDE_INT)\n \t  && GET_CODE (XEXP (SET_DEST (x), 1)) == CONST_INT\n \t  && GET_CODE (XEXP (SET_DEST (x), 2)) == CONST_INT\n \t  && GET_CODE (SET_SRC (x)) == CONST_INT\n@@ -2094,24 +2101,22 @@ find_split_point (loc)\n \t  int src = INTVAL (SET_SRC (x));\n \t  rtx dest = XEXP (SET_DEST (x), 0);\n \t  enum machine_mode mode = GET_MODE (dest);\n-\t  unsigned int mask = (1 << len) - 1;\n+\t  unsigned HOST_WIDE_INT mask = ((HOST_WIDE_INT) 1 << len) - 1;\n \n #if BITS_BIG_ENDIAN\n \t  pos = GET_MODE_BITSIZE (mode) - len - pos;\n #endif\n \n \t  if (src == mask)\n \t    SUBST (SET_SRC (x),\n-\t\t   gen_binary (IOR, mode, dest,\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode, src << pos)));\n+\t\t   gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n \t  else\n \t    SUBST (SET_SRC (x),\n \t\t   gen_binary (IOR, mode,\n \t\t\t       gen_binary (AND, mode, dest, \n-\t\t\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t    (~ (mask << pos)\n-\t\t\t\t\t\t     & GET_MODE_MASK (mode)))),\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode, src << pos)));\n+\t\t\t\t\t   GEN_INT (~ (mask << pos)\n+\t\t\t\t\t\t    & GET_MODE_MASK (mode))),\n+\t\t\t       GEN_INT (src << pos)));\n \n \t  SUBST (SET_DEST (x), dest);\n \n@@ -2154,15 +2159,15 @@ find_split_point (loc)\n \t{\n \t  enum machine_mode mode = GET_MODE (SET_SRC (x));\n \n-\t  if (unsignedp && len < HOST_BITS_PER_INT)\n+\t  if (unsignedp && len < HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_combine\n \t\t     (AND, mode,\n \t\t      gen_rtx_combine (LSHIFTRT, mode,\n \t\t\t\t       gen_lowpart_for_combine (mode, inner),\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, pos)),\n-\t\t      gen_rtx (CONST_INT, VOIDmode, (1 << len) - 1)));\n+\t\t\t\t       GEN_INT (pos)),\n+\t\t      GEN_INT (((HOST_WIDE_INT) 1 << len) - 1)));\n \n \t      split = find_split_point (&SET_SRC (x));\n \t      if (split && split != &SET_SRC (x))\n@@ -2175,11 +2180,9 @@ find_split_point (loc)\n \t\t     (ASHIFTRT, mode,\n \t\t      gen_rtx_combine (ASHIFT, mode,\n \t\t\t\t       gen_lowpart_for_combine (mode, inner),\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t(GET_MODE_BITSIZE (mode)\n-\t\t\t\t\t\t - len - pos))),\n-\t\t      gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t       GET_MODE_BITSIZE (mode) - len)));\n+\t\t\t\t       GEN_INT (GET_MODE_BITSIZE (mode)\n+\t\t\t\t\t\t- len - pos)),\n+\t\t      GEN_INT (GET_MODE_BITSIZE (mode) - len)));\n \n \t      split = find_split_point (&SET_SRC (x));\n \t      if (split && split != &SET_SRC (x))\n@@ -2645,7 +2648,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && GET_MODE_CLASS (mode) == MODE_INT)\n \t{\n \t  temp = operand_subword (SUBREG_REG (x), SUBREG_WORD (x),\n-\t\t\t\t      0, op0_mode);\n+\t\t\t\t  0, op0_mode);\n \t  if (temp)\n \t    return temp;\n \t}\n@@ -2663,9 +2666,10 @@ subst (x, from, to, in_dest, unique_copy)\n \t of the AND.  Otherwise, it is the resulting expression.  */\n       if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n \t  && subreg_lowpart_p (x)\n-\t  && GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) <= HOST_BITS_PER_INT)\n+\t  && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n+\t      <= HOST_BITS_PER_WIDE_INT))\n \t{\n-\t  temp = simplify_and_const_int (0, GET_MODE (SUBREG_REG (x)),\n+\t  temp = simplify_and_const_int (NULL_RTX, GET_MODE (SUBREG_REG (x)),\n \t\t\t\t\t SUBREG_REG (x), GET_MODE_MASK (mode));\n \t  if (GET_CODE (temp) == AND && GET_CODE (XEXP (temp, 1)) == CONST_INT\n \t      && INTVAL (XEXP (temp, 1)) == GET_MODE_MASK (mode))\n@@ -2746,9 +2750,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t if (GET_CODE (in2) == NOT)\n \t   in2 = XEXP (in2, 0);\n  \t else if (GET_CODE (in2) == CONST_INT\n-\t\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT)\n-\t   in2 = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t  GET_MODE_MASK (mode) & ~ INTVAL (in2));\n+\t\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t   in2 = GEN_INT (GET_MODE_MASK (mode) & ~ INTVAL (in2));\n \t else\n \t   in2 = gen_rtx_combine (NOT, GET_MODE (in2), in2);\n \n@@ -2851,8 +2854,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && (i = exact_log2 (significant_bits (temp, mode))) >= 0)\n \t{\n \t  rtx temp1 = simplify_shift_const\n-\t    (0, ASHIFTRT, mode,\n-\t     simplify_shift_const (0, ASHIFT, mode, temp,\n+\t    (NULL_RTX, ASHIFTRT, mode,\n+\t     simplify_shift_const (NULL_RTX, ASHIFT, mode, temp,\n \t\t\t\t   GET_MODE_BITSIZE (mode) - 1 - i),\n \t     GET_MODE_BITSIZE (mode) - 1 - i);\n \n@@ -2932,18 +2935,18 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) == - INTVAL (XEXP (XEXP (x, 0), 1))\n \t  && (i = exact_log2 (INTVAL (XEXP (XEXP (x, 0), 1)))) >= 0\n-\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n+\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && ((GET_CODE (XEXP (XEXP (x, 0), 0)) == AND\n \t       && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n \t       && (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n-\t\t   == (1 << (i + 1)) - 1))\n+\t\t   == ((HOST_WIDE_INT) 1 << (i + 1)) - 1))\n \t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) == ZERO_EXTEND\n \t\t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)))\n \t\t      == i + 1))))\n \t{\n \t  x = simplify_shift_const\n-\t    (0, ASHIFTRT, mode,\n-\t     simplify_shift_const (0, ASHIFT, mode,\n+\t    (NULL_RTX, ASHIFTRT, mode,\n+\t     simplify_shift_const (NULL_RTX, ASHIFT, mode,\n \t\t\t\t   XEXP (XEXP (XEXP (x, 0), 0), 0),\n \t\t\t\t   GET_MODE_BITSIZE (mode) - (i + 1)),\n \t     GET_MODE_BITSIZE (mode) - (i + 1));\n@@ -2961,8 +2964,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && significant_bits (XEXP (x, 0), mode) == 1)\n \t{\n \t  x = simplify_shift_const\n-\t    (0, ASHIFTRT, mode,\n-\t     simplify_shift_const (0, ASHIFT, mode,\n+\t    (NULL_RTX, ASHIFTRT, mode,\n+\t     simplify_shift_const (NULL_RTX, ASHIFT, mode,\n \t\t\t\t   gen_rtx_combine (XOR, mode,\n \t\t\t\t\t\t    XEXP (x, 0), const1_rtx),\n \t\t\t\t   GET_MODE_BITSIZE (mode) - 1),\n@@ -2991,7 +2994,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && exact_log2 (- INTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n \t{\n-\t  x = simplify_and_const_int (0, mode, XEXP (x, 0),\n+\t  x = simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n \t\t\t\t      - INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n \t  goto restart;\n \t}\n@@ -3026,7 +3029,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t      || GET_CODE (XEXP (x, 0)) == ROTATE\n \t      || GET_CODE (XEXP (x, 0)) == ROTATERT))\n \t{\n-\t  x = simplify_shift_const (0, ASHIFT, mode, XEXP (x, 0), i);\n+\t  x = simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (x, 0), i);\n \t  goto restart;\n \t}\n \n@@ -3048,7 +3051,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t      || GET_CODE (XEXP (x, 0)) == ROTATE\n \t      || GET_CODE (XEXP (x, 0)) == ROTATERT))\n \t{\n-\t  x = simplify_shift_const (0, LSHIFTRT, mode, XEXP (x, 0), i);\n+\t  x = simplify_shift_const (NULL_RTX, LSHIFTRT, mode, XEXP (x, 0), i);\n \t  goto restart;\n \t}\n       break;\n@@ -3113,13 +3116,14 @@ subst (x, from, to, in_dest, unique_copy)\n \t     STORE_FLAG_VALUE when we are done, since we are only going to\n \t     test the sign bit.  */\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n-\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n-\t      && STORE_FLAG_VALUE == 1 << (GET_MODE_BITSIZE (mode) - 1)\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && (STORE_FLAG_VALUE\n+\t\t  == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n \t      && (i = exact_log2 (significant_bits (op0, GET_MODE (op0)))) >= 0)\n \t    {\n-\t      x = simplify_shift_const (0, ASHIFT, mode, op0,\n+\t      x = simplify_shift_const (NULL_RTX, ASHIFT, mode, op0,\n \t\t\t\t\tGET_MODE_BITSIZE (mode) - 1 - i);\n \t      if (GET_CODE (x) == AND && XEXP (x, 1) == const_true_rtx)\n \t\treturn XEXP (x, 0);\n@@ -3297,7 +3301,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t      if (((old_code == NE && new_code == EQ)\n \t\t   || (old_code == EQ && new_code == NE))\n \t\t  && ! other_changed && op1 == const0_rtx\n-\t\t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_INT\n+\t\t  && (GET_MODE_BITSIZE (GET_MODE (op0))\n+\t\t      <= HOST_BITS_PER_WIDE_INT)\n \t\t  && (exact_log2 (mask = significant_bits (op0,\n \t\t\t\t\t\t\t   GET_MODE (op0)))\n \t\t      >= 0))\n@@ -3311,7 +3316,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t      other_insn = 0;\n \n \t\t      op0 = gen_binary (XOR, GET_MODE (op0), op0,\n-\t\t\t\t\tgen_rtx (CONST_INT, VOIDmode, mask));\n+\t\t\t\t\tGEN_INT (mask));\n \t\t    }\n \t\t}\n \n@@ -3383,9 +3388,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t    {\n \t      temp = gen_binary (AND, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t  (INTVAL (XEXP (XEXP (x, 0), 1))\n-\t\t\t\t\t   & ~ INTVAL (XEXP (x, 1)))));\n+\t\t\t\t GEN_INT (INTVAL (XEXP (XEXP (x, 0), 1))\n+\t\t\t\t\t  & ~ INTVAL (XEXP (x, 1))));\n \t      return gen_binary (IOR, mode, temp, XEXP (x, 1));\n \t    }\n \n@@ -3631,8 +3635,9 @@ subst (x, from, to, in_dest, unique_copy)\n \n       /* (xor (comparison foo bar) (const_int sign-bit))\n \t when STORE_FLAG_VALUE is the sign bit.  */\n-      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n-\t  && STORE_FLAG_VALUE == 1 << (GET_MODE_BITSIZE (mode) - 1)\n+      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && (STORE_FLAG_VALUE\n+\t      == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t  && XEXP (x, 1) == const_true_rtx\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n \t  && reversible_comparison_p (XEXP (x, 0)))\n@@ -3648,9 +3653,11 @@ subst (x, from, to, in_dest, unique_copy)\n \n       /* If operand is something known to be positive, ignore the ABS.  */\n       if (GET_CODE (XEXP (x, 0)) == FFS || GET_CODE (XEXP (x, 0)) == ABS\n-\t  || (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) <= HOST_BITS_PER_INT\n+\t  || ((GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n+\t       <= HOST_BITS_PER_WIDE_INT)\n \t      && ((significant_bits (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n-\t\t   & (1 << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1)))\n+\t\t   & ((HOST_WIDE_INT) 1\n+\t\t      << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1)))\n \t\t  == 0)))\n \treturn XEXP (x, 0);\n \n@@ -3707,7 +3714,7 @@ subst (x, from, to, in_dest, unique_copy)\n \tSUBST (XEXP (x, 1),\n \t       force_to_mode (XEXP (x, 1), GET_MODE (x),\n \t\t\t      exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))),\n-\t\t\t      0));\n+\t\t\t      NULL_RTX));\n #endif\n \n       break;\n@@ -3813,19 +3820,20 @@ expand_compound_operation (x)\n \n   modewidth = GET_MODE_BITSIZE (GET_MODE (x));\n   if (modewidth >= pos - len)\n-    tem = simplify_shift_const (0, unsignedp ? LSHIFTRT : ASHIFTRT,\n+    tem = simplify_shift_const (NULL_RTX, unsignedp ? LSHIFTRT : ASHIFTRT,\n \t\t\t\tGET_MODE (x),\n-\t\t\t\tsimplify_shift_const (0, ASHIFT, GET_MODE (x),\n+\t\t\t\tsimplify_shift_const (NULL_RTX, ASHIFT,\n+\t\t\t\t\t\t      GET_MODE (x),\n \t\t\t\t\t\t      XEXP (x, 0),\n \t\t\t\t\t\t      modewidth - pos - len),\n \t\t\t\tmodewidth - len);\n \n-  else if (unsignedp && len < HOST_BITS_PER_INT)\n-    tem = simplify_and_const_int (0, GET_MODE (x),\n-\t\t\t\t  simplify_shift_const (0, LSHIFTRT,\n+  else if (unsignedp && len < HOST_BITS_PER_WIDE_INT)\n+    tem = simplify_and_const_int (NULL_RTX, GET_MODE (x),\n+\t\t\t\t  simplify_shift_const (NULL_RTX, LSHIFTRT,\n \t\t\t\t\t\t\tGET_MODE (x),\n \t\t\t\t\t\t\tXEXP (x, 0), pos),\n-\t\t\t\t  (1 << len) - 1);\n+\t\t\t\t  ((HOST_WIDE_INT) 1 << len) - 1);\n   else\n     /* Any other cases we can't handle.  */\n     return x;\n@@ -3882,9 +3890,8 @@ expand_field_assignment (x)\n \n #if BITS_BIG_ENDIAN\n \t  if (GET_CODE (pos) == CONST_INT)\n-\t    pos = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t   (GET_MODE_BITSIZE (GET_MODE (inner)) - len\n-\t\t\t    - INTVAL (pos)));\n+\t    pos = GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner)) - len\n+\t\t\t   - INTVAL (pos));\n \t  else if (GET_CODE (pos) == MINUS\n \t\t   && GET_CODE (XEXP (pos, 1)) == CONST_INT\n \t\t   && (INTVAL (XEXP (pos, 1))\n@@ -3893,9 +3900,9 @@ expand_field_assignment (x)\n \t    pos = XEXP (pos, 0);\n \t  else\n \t    pos = gen_binary (MINUS, GET_MODE (pos),\n-\t\t\t      gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t       (GET_MODE_BITSIZE (GET_MODE (inner))\n-\t\t\t\t\t- len)), pos);\n+\t\t\t      GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner))\n+\t\t\t\t       - len),\n+\t\t\t      pos);\n #endif\n \t}\n \n@@ -3921,8 +3928,8 @@ expand_field_assignment (x)\n       compute_mode = GET_MODE (inner);\n \n       /* Compute a mask of LEN bits, if we can do this on the host machine.  */\n-      if (len < HOST_BITS_PER_INT)\n-\tmask = gen_rtx (CONST_INT, VOIDmode, (1 << len) - 1);\n+      if (len < HOST_BITS_PER_WIDE_INT)\n+\tmask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n       else\n \tbreak;\n \n@@ -4149,10 +4156,10 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n   else\n     pos_rtx\n       = gen_rtx_combine (MINUS, GET_MODE (pos_rtx),\n-\t\t\t gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t  (MAX (GET_MODE_BITSIZE (is_mode),\n-\t\t\t\t\tGET_MODE_BITSIZE (wanted_mem_mode))\n-\t\t\t\t   - len)), pos_rtx);\n+\t\t\t GEN_INT (MAX (GET_MODE_BITSIZE (is_mode),\n+\t\t\t\t       GET_MODE_BITSIZE (wanted_mem_mode))\n+\t\t\t\t  - len),\n+\t\t\t pos_rtx);\n #endif\n \n   /* If INNER has a wider mode, make it smaller.  If this is a constant\n@@ -4218,12 +4225,11 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   /* Make POS_RTX unless we already have it and it is correct.  */\n   if (pos_rtx == 0 || (pos >= 0 && INTVAL (pos_rtx) != pos))\n-    pos_rtx = gen_rtx (CONST_INT, VOIDmode, pos);\n+    pos_rtx = GEN_INT (pos);\n \n   /* Make the required operation.  See if we can use existing rtx.  */\n   new = gen_rtx_combine (unsignedp ? ZERO_EXTRACT : SIGN_EXTRACT,\n-\t\t\t extraction_mode, inner,\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, len), pos_rtx);\n+\t\t\t extraction_mode, inner, GEN_INT (len), pos_rtx);\n   if (! in_dest)\n     new = gen_lowpart_for_combine (mode, new);\n \n@@ -4280,11 +4286,11 @@ make_compound_operation (x, in_code)\n       /* Convert shifts by constants into multiplications if inside\n \t an address.  */\n       if (in_code == MEM && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_INT\n+\t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0)\n \tnew = gen_rtx_combine (MULT, mode, XEXP (x, 0),\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t1 << INTVAL (XEXP (x, 1))));\n+\t\t\t       GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t<< INTVAL (XEXP (x, 1))));\n       break;\n \n     case AND:\n@@ -4322,7 +4328,7 @@ make_compound_operation (x, in_code)\n \tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0),\n \t\t\t       (GET_MODE_BITSIZE (mode)\n \t\t\t\t- INTVAL (XEXP (XEXP (x, 0), 1))),\n-\t\t\t       0, i, 1, 0, in_code == COMPARE);\n+\t\t\t       NULL_RTX, i, 1, 0, in_code == COMPARE);\n \n       /* On machines without logical shifts, if the operand of the AND is\n \t a logical shift and our mask turns off all the propagated sign\n@@ -4341,10 +4347,10 @@ make_compound_operation (x, in_code)\n \t       && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t       && INTVAL (XEXP (XEXP (x, 0), 1)) >= 0\n-\t       && INTVAL (XEXP (XEXP (x, 0), 1)) < HOST_BITS_PER_INT\n-\t       && mode_width <= HOST_BITS_PER_INT)\n+\t       && INTVAL (XEXP (XEXP (x, 0), 1)) < HOST_BITS_PER_WIDE_INT\n+\t       && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t{\n-\t  unsigned mask = GET_MODE_MASK (mode);\n+\t  unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n \n \t  mask >>= INTVAL (XEXP (XEXP (x, 0), 1));\n \t  if ((INTVAL (XEXP (x, 1)) & ~mask) == 0)\n@@ -4358,14 +4364,14 @@ make_compound_operation (x, in_code)\n \t If it doesn't end up being a ZERO_EXTEND, we will ignore it unless\n \t we are in a COMPARE.  */\n       else if ((i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n-\tnew = make_extraction (mode, XEXP (x, 0), 0, 0, i, 1,\n+\tnew = make_extraction (mode, XEXP (x, 0), 0, NULL_RTX, i, 1,\n \t\t\t       0, in_code == COMPARE);\n \n       /* If we are in a comparison and this is an AND with a power of two,\n \t convert this into the appropriate bit extract.  */\n       else if (in_code == COMPARE\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n-\tnew = make_extraction (mode, XEXP (x, 0), i, 0, 1, 1, 0, 1);\n+\tnew = make_extraction (mode, XEXP (x, 0), i, NULL_RTX, 1, 1, 0, 1);\n \n       break;\n \n@@ -4383,7 +4389,7 @@ make_compound_operation (x, in_code)\n #else\n \t  && 1\n #endif\n-\t  && mode_width <= HOST_BITS_PER_INT\n+\t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && (significant_bits (XEXP (x, 0), mode)\n \t      & (1 << (mode_width - 1))) == 0)\n \t{\n@@ -4403,7 +4409,7 @@ make_compound_operation (x, in_code)\n \tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0),\n \t\t\t       (INTVAL (XEXP (x, 1))\n \t\t\t\t- INTVAL (XEXP (XEXP (x, 0), 1))),\n-\t\t\t       0, mode_width - INTVAL (XEXP (x, 1)),\n+\t\t\t       NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n \t\t\t       code == LSHIFTRT, 0, in_code == COMPARE);\n       break;\n     }\n@@ -4435,7 +4441,7 @@ make_compound_operation (x, in_code)\n \n static int\n get_pos_from_mask (m, plen)\n-     unsigned int m;\n+     unsigned HOST_WIDE_INT m;\n      int *plen;\n {\n   /* Get the bit number of the first 1 bit from the right, -1 if none.  */\n@@ -4495,8 +4501,8 @@ force_to_mode (x, mode, bits, reg)\n       break;\n \n     case CONST_INT:\n-      if (bits < HOST_BITS_PER_INT)\n-\tx = gen_rtx (CONST_INT, VOIDmode, INTVAL (x) & ((1 << bits) - 1));\n+      if (bits < HOST_BITS_PER_WIDE_INT)\n+\tx = GEN_INT (INTVAL (x) & (((HOST_WIDE_INT) 1 << bits) - 1));\n       return x;\n \n     case SUBREG:\n@@ -4511,7 +4517,7 @@ force_to_mode (x, mode, bits, reg)\n \n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n-\t  int mask = INTVAL (XEXP (x, 1));\n+\t  HOST_WIDE_INT mask = INTVAL (XEXP (x, 1));\n \t  int len = exact_log2 (mask + 1);\n \t  rtx op = XEXP (x, 0);\n \n@@ -4522,8 +4528,8 @@ force_to_mode (x, mode, bits, reg)\n \t  op = force_to_mode (op, mode, len > 0 ? MIN (len, bits) : bits,\n \t\t\t      reg);\n \n-\t  if (bits < HOST_BITS_PER_INT)\n-\t    mask &= (1 << bits) - 1;\n+\t  if (bits < HOST_BITS_PER_WIDE_INT)\n+\t    mask &= ((HOST_WIDE_INT) 1 << bits) - 1;\n \n \t  x = simplify_and_const_int (x, mode, op, mask);\n \n@@ -4532,8 +4538,8 @@ force_to_mode (x, mode, bits, reg)\n \t     can't be wider), we don't need it.  */\n \n \t  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t      && bits < HOST_BITS_PER_INT\n-\t      && INTVAL (XEXP (x, 1)) == (1 << bits) - 1)\n+\t      && bits < HOST_BITS_PER_WIDE_INT\n+\t      && INTVAL (XEXP (x, 1)) == ((HOST_WIDE_INT) 1 << bits) - 1)\n \t    x = XEXP (x, 0);\n \t  return x;\n \t}\n@@ -4602,7 +4608,8 @@ make_field_assignment (x)\n   rtx src = SET_SRC (x);\n   rtx ourdest;\n   rtx assign;\n-  int c1, pos, len;\n+  HOST_WIDE_INT c1;\n+  int pos, len;\n   rtx other;\n   enum machine_mode mode;\n \n@@ -4681,7 +4688,7 @@ make_field_assignment (x)\n       || (c1 & significant_bits (other, GET_MODE (other))) != 0)\n     return x;\n \n-  assign = make_extraction (VOIDmode, dest, pos, 0, len, 1, 1, 0);\n+  assign = make_extraction (VOIDmode, dest, pos, NULL_RTX, len, 1, 1, 0);\n \n   /* The mode to use for the source is the mode of the assignment, or of\n      what is inside a possible STRICT_LOW_PART.  */\n@@ -4691,8 +4698,8 @@ make_field_assignment (x)\n   /* Shift OTHER right POS places and make it the source, restricting it\n      to the proper length and mode.  */\n \n-  src = force_to_mode (simplify_shift_const (0, LSHIFTRT, GET_MODE (src),\n-\t\t\t\t\t     other, pos),\n+  src = force_to_mode (simplify_shift_const (NULL_RTX, LSHIFTRT,\n+\t\t\t\t\t     GET_MODE (src), other, pos),\n \t\t       mode, len, dest);\n \n   return gen_rtx_combine (SET, VOIDmode, assign, src);\n@@ -4827,11 +4834,11 @@ simplify_and_const_int (x, mode, varop, constop)\n      rtx x;\n      enum machine_mode mode;\n      rtx varop;\n-     unsigned constop;\n+     unsigned HOST_WIDE_INT constop;\n {\n   register enum machine_mode tmode;\n   register rtx temp;\n-  unsigned significant;\n+  unsigned HOST_WIDE_INT significant;\n \n   /* There is a large class of optimizations based on the principle that\n      some operations produce results where certain bits are known to be zero,\n@@ -4846,9 +4853,9 @@ simplify_and_const_int (x, mode, varop, constop)\n \n   while (1)\n     {\n-      /* If we ever encounter a mode wider than the host machine's word\n-\t size, we can't compute the masks accurately, so give up.  */\n-      if (GET_MODE_BITSIZE (GET_MODE (varop)) > HOST_BITS_PER_INT)\n+      /* If we ever encounter a mode wider than the host machine's widest\n+\t integer size, we can't compute the masks accurately, so give up.  */\n+      if (GET_MODE_BITSIZE (GET_MODE (varop)) > HOST_BITS_PER_WIDE_INT)\n \tbreak;\n \n       /* Unless one of the cases below does a `continue',\n@@ -4927,15 +4934,14 @@ simplify_and_const_int (x, mode, varop, constop)\n \t  if (GET_CODE (XEXP (varop, 0)) == LSHIFTRT\n \t      && GET_CODE (XEXP (XEXP (varop, 0), 1)) == CONST_INT\n \t      && INTVAL (XEXP (XEXP (varop, 0), 1)) >= 0\n-\t      && INTVAL (XEXP (XEXP (varop, 0), 1)) < HOST_BITS_PER_INT\n+\t      && INTVAL (XEXP (XEXP (varop, 0), 1)) < HOST_BITS_PER_WIDE_INT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && (INTVAL (XEXP (varop, 1))\n \t\t  & ~ significant_bits (XEXP (varop, 0),\n \t\t\t\t\tGET_MODE (varop)) == 0))\n \t    {\n-\t      temp = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t      ((INTVAL (XEXP (varop, 1)) & constop)\n-\t\t\t       << INTVAL (XEXP (XEXP (varop, 0), 1))));\n+\t      temp = GEN_INT ((INTVAL (XEXP (varop, 1)) & constop)\n+\t\t\t      << INTVAL (XEXP (XEXP (varop, 0), 1)));\n \t      temp = gen_binary (GET_CODE (varop), GET_MODE (varop),\n \t\t\t\t XEXP (XEXP (varop, 0), 0), temp);\n \t      varop = gen_rtx_combine (LSHIFTRT, GET_MODE (varop),\n@@ -4953,9 +4959,9 @@ simplify_and_const_int (x, mode, varop, constop)\n \t      (mode, apply_distributive_law\n \t       (gen_rtx_combine\n \t\t(GET_CODE (varop), GET_MODE (varop),\n-\t\t simplify_and_const_int (0, GET_MODE (varop),\n+\t\t simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n \t\t\t\t\t XEXP (varop, 0), constop),\n-\t\t simplify_and_const_int (0, GET_MODE (varop),\n+\t\t simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n \t\t\t\t\t XEXP (varop, 1), constop))));\n \n \tcase NOT:\n@@ -4965,10 +4971,9 @@ simplify_and_const_int (x, mode, varop, constop)\n \t  if (GET_CODE (XEXP (varop, 0)) == LSHIFTRT\n \t      && GET_CODE (XEXP (XEXP (varop, 0), 1)) == CONST_INT\n \t      && INTVAL (XEXP (XEXP (varop, 0), 1)) >= 0\n-\t      && INTVAL (XEXP (XEXP (varop, 0), 1)) < HOST_BITS_PER_INT)\n+\t      && INTVAL (XEXP (XEXP (varop, 0), 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      temp = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t      constop << INTVAL (XEXP (XEXP (varop, 0), 1)));\n+\t      temp = GEN_INT (constop << INTVAL (XEXP (XEXP (varop, 0), 1)));\n \t      temp = gen_binary (XOR, GET_MODE (varop),\n \t\t\t\t XEXP (XEXP (varop, 0), 0), temp);\n \t      varop = gen_rtx_combine (LSHIFTRT, GET_MODE (varop),\n@@ -4980,7 +4985,8 @@ simplify_and_const_int (x, mode, varop, constop)\n \tcase ASHIFTRT:\n \t  /* If we are just looking for the sign bit, we don't need this\n \t     shift at all, even if it has a variable count.  */\n-\t  if (constop == 1 << (GET_MODE_BITSIZE (GET_MODE (varop)) - 1))\n+\t  if (constop == ((HOST_WIDE_INT) 1\n+\t\t\t  << (GET_MODE_BITSIZE (GET_MODE (varop)) - 1)))\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;\n@@ -4995,7 +5001,7 @@ simplify_and_const_int (x, mode, varop, constop)\n \t     the appropriate location.  */\n \t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && INTVAL (XEXP (varop, 1)) >= 0\n-\t      && INTVAL (XEXP (varop, 1)) < HOST_BITS_PER_INT)\n+\t      && INTVAL (XEXP (varop, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      int i = -1;\n \n@@ -5076,7 +5082,7 @@ simplify_and_const_int (x, mode, varop, constop)\n \n   /* If we have reached a constant, this whole thing is constant.  */\n   if (GET_CODE (varop) == CONST_INT)\n-    return gen_rtx (CONST_INT, VOIDmode, constop & INTVAL (varop));\n+    return GEN_INT (constop & INTVAL (varop));\n \n   /* See what bits are significant in VAROP.  */\n   significant = significant_bits (varop, mode);\n@@ -5110,14 +5116,13 @@ simplify_and_const_int (x, mode, varop, constop)\n \n   /* Otherwise, return an AND.  See how much, if any, of X we can use.  */\n   else if (x == 0 || GET_CODE (x) != AND || GET_MODE (x) != mode)\n-    x = gen_rtx_combine (AND, mode, varop,\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, constop));\n+    x = gen_rtx_combine (AND, mode, varop, GEN_INT (constop));\n \n   else\n     {\n       if (GET_CODE (XEXP (x, 1)) != CONST_INT\n \t  || INTVAL (XEXP (x, 1)) != constop)\n-\tSUBST (XEXP (x, 1), gen_rtx (CONST_INT, VOIDmode, constop));\n+\tSUBST (XEXP (x, 1), GEN_INT (constop));\n \n       SUBST (XEXP (x, 0), varop);\n     }\n@@ -5131,13 +5136,13 @@ simplify_and_const_int (x, mode, varop, constop)\n    For most X this is simply GET_MODE_MASK (GET_MODE (MODE)), but if X is\n    a shift, AND, or zero_extract, we can do better.  */\n \n-static unsigned\n+static unsigned HOST_WIDE_INT\n significant_bits (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n-  unsigned significant = GET_MODE_MASK (mode);\n-  unsigned inner_sig;\n+  unsigned HOST_WIDE_INT significant = GET_MODE_MASK (mode);\n+  unsigned HOST_WIDE_INT inner_sig;\n   enum rtx_code code;\n   int mode_width = GET_MODE_BITSIZE (mode);\n   rtx tem;\n@@ -5150,7 +5155,7 @@ significant_bits (x, mode)\n       mode_width = GET_MODE_BITSIZE (mode);\n     }\n \n-  if (mode_width > HOST_BITS_PER_INT)\n+  if (mode_width > HOST_BITS_PER_WIDE_INT)\n     /* Our only callers in this case look for single bit values.  So\n        just return the mode mask.  Those tests will then be false.  */\n     return significant;\n@@ -5250,7 +5255,8 @@ significant_bits (x, mode)\n \t{\n \t  inner_sig &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n \t  if (inner_sig &\n-\t      (1 << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1)))\n+\t      (((HOST_WIDE_INT) 1\n+\t\t<< (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1))))\n \t    inner_sig |= (GET_MODE_MASK (mode)\n \t\t\t  & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0))));\n \t}\n@@ -5278,8 +5284,8 @@ significant_bits (x, mode)\n \t computing the width (position of the highest-order non-zero bit)\n \t and the number of low-order zero bits for each value.  */\n       {\n-\tunsigned sig0 = significant_bits (XEXP (x, 0), mode);\n-\tunsigned sig1 = significant_bits (XEXP (x, 1), mode);\n+\tunsigned HOST_WIDE_INT sig0 = significant_bits (XEXP (x, 0), mode);\n+\tunsigned HOST_WIDE_INT sig1 = significant_bits (XEXP (x, 1), mode);\n \tint width0 = floor_log2 (sig0) + 1;\n \tint width1 = floor_log2 (sig1) + 1;\n \tint low0 = floor_log2 (sig0 & -sig0);\n@@ -5321,25 +5327,26 @@ significant_bits (x, mode)\n \t  }\n \n \tif (result_width < mode_width)\n-\t  significant &= (1 << result_width) - 1;\n+\t  significant &= ((HOST_WIDE_INT) 1 << result_width) - 1;\n \n \tif (result_low > 0)\n-\t  significant &= ~ ((1 << result_low) - 1);\n+\t  significant &= ~ (((HOST_WIDE_INT) 1 << result_low) - 1);\n       }\n       break;\n \n     case ZERO_EXTRACT:\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_INT)\n-\tsignificant &= (1 << INTVAL (XEXP (x, 1))) - 1;\n+\t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n+\tsignificant &= ((HOST_WIDE_INT) 1 << INTVAL (XEXP (x, 1))) - 1;\n       break;\n \n     case SUBREG:\n       /* If the inner mode is a single word for both the host and target\n \t machines, we can compute this from which bits of the inner\n \t object are known significant.  */\n       if (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) <= BITS_PER_WORD\n-\t  && GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) <= HOST_BITS_PER_INT)\n+\t  && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n+\t      <= HOST_BITS_PER_WIDE_INT))\n \t{\n \t  significant &= significant_bits (SUBREG_REG (x), mode);\n #ifndef BYTE_LOADS_ZERO_EXTEND\n@@ -5367,15 +5374,16 @@ significant_bits (x, mode)\n \t low-order bits by left shifts.  */\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0\n-\t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_INT)\n+\t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n \t{\n \t  enum machine_mode inner_mode = GET_MODE (x);\n \t  int width = GET_MODE_BITSIZE (inner_mode);\n \t  int count = INTVAL (XEXP (x, 1));\n-\t  unsigned mode_mask = GET_MODE_MASK (inner_mode);\n-\t  unsigned op_significant = significant_bits (XEXP (x, 0), mode);\n-\t  unsigned inner = op_significant & mode_mask;\n-\t  unsigned outer = 0;\n+\t  unsigned HOST_WIDE_INT mode_mask = GET_MODE_MASK (inner_mode);\n+\t  unsigned HOST_WIDE_INT op_significant\n+\t    = significant_bits (XEXP (x, 0), mode);\n+\t  unsigned HOST_WIDE_INT inner = op_significant & mode_mask;\n+\t  unsigned HOST_WIDE_INT outer = 0;\n \n \t  if (mode_width > width)\n \t    outer = (op_significant & significant & ~ mode_mask);\n@@ -5389,8 +5397,8 @@ significant_bits (x, mode)\n \t      /* If the sign bit was significant at before the shift, we\n \t\t need to mark all the places it could have been copied to\n \t\t by the shift significant.  */\n-\t      if (inner & (1 << (width - 1 - count)))\n-\t\tinner |= ((1 << count) - 1) << (width - count);\n+\t      if (inner & ((HOST_WIDE_INT) 1 << (width - 1 - count)))\n+\t\tinner |= (((HOST_WIDE_INT) 1 << count) - 1) << (width - count);\n \t    }\n \t  else if (code == LSHIFT || code == ASHIFT)\n \t    inner <<= count;\n@@ -5404,7 +5412,7 @@ significant_bits (x, mode)\n \n     case FFS:\n       /* This is at most the number of bits in the mode.  */\n-      significant = (1 << (floor_log2 (mode_width) + 1)) - 1;\n+      significant = ((HOST_WIDE_INT) 1 << (floor_log2 (mode_width) + 1)) - 1;\n       break;\n     }\n \n@@ -5423,7 +5431,7 @@ significant_bits (x, mode)\n \n    MODE is the mode in which the operation will be done.  No bits outside\n    the width of this mode matter.  It is assumed that the width of this mode\n-   is smaller than or equal to HOST_BITS_PER_INT.\n+   is smaller than or equal to HOST_BITS_PER_WIDE_INT.\n \n    If *POP0 or OP1 are NIL, it means no operation is required.  Only NEG, PLUS,\n    IOR, XOR, and AND are supported.  We may set *POP0 to SET if the proper\n@@ -5435,14 +5443,14 @@ significant_bits (x, mode)\n static int\n merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n      enum rtx_code *pop0;\n-     int *pconst0;\n+     HOST_WIDE_INT *pconst0;\n      enum rtx_code op1;\n-     int const1;\n+     HOST_WIDE_INT const1;\n      enum machine_mode mode;\n      int *pcomp_p;\n {\n   enum rtx_code op0 = *pop0;\n-  int const0 = *pconst0;\n+  HOST_WIDE_INT const0 = *pconst0;\n \n   const0 &= GET_MODE_MASK (mode);\n   const1 &= GET_MODE_MASK (mode);\n@@ -5562,7 +5570,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n     = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n   /* We form (outer_op (code varop count) (outer_const)).  */\n   enum rtx_code outer_op = NIL;\n-  int outer_const;\n+  HOST_WIDE_INT outer_const;\n   rtx const_rtx;\n   int complement_p = 0;\n   rtx new;\n@@ -5575,7 +5583,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       if (x)\n \treturn x;\n \n-      return gen_rtx (code, mode, varop, gen_rtx (CONST_INT, VOIDmode, count));\n+      return gen_rtx (code, mode, varop, GEN_INT (count));\n     }\n \n   /* Unless one of the branches of the `if' in this loop does a `continue',\n@@ -5643,10 +5651,11 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n \t `make_compound_operation' will convert it to a ASHIFTRT for\n \t those machines (such as Vax) that don't have a LSHIFTRT.  */\n-      if (GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_INT\n+      if (GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n \t  && code == ASHIFTRT\n-\t  && (significant_bits (varop, shift_mode)\n-\t      & (1 << (GET_MODE_BITSIZE (shift_mode) - 1))) == 0)\n+\t  && ((significant_bits (varop, shift_mode)\n+\t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (shift_mode) - 1)))\n+\t      == 0))\n \tcode = LSHIFTRT;\n \n       switch (GET_CODE (varop))\n@@ -5740,8 +5749,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop = gen_binary (ASHIFT, GET_MODE (varop), XEXP (varop, 0),\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t   exact_log2 (INTVAL (XEXP (varop, 1)))));\n+\t\t\t\t  GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));;\n \t      continue;\n \t    }\n \t  break;\n@@ -5752,8 +5760,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop = gen_binary (LSHIFTRT, GET_MODE (varop), XEXP (varop, 0),\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t   exact_log2 (INTVAL (XEXP (varop, 1)))));\n+\t\t\t\t  GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -5778,12 +5785,12 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && INTVAL (XEXP (varop, 1)) >= 0\n \t      && INTVAL (XEXP (varop, 1)) < GET_MODE_BITSIZE (GET_MODE (varop))\n-\t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_INT\n-\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT)\n+\t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      enum rtx_code first_code = GET_CODE (varop);\n \t      int first_count = INTVAL (XEXP (varop, 1));\n-\t      unsigned int mask;\n+\t      unsigned HOST_WIDE_INT mask;\n \t      rtx mask_rtx;\n \t      rtx inner;\n \n@@ -5803,11 +5810,12 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t{\n \t\t  /* C3 has the low-order C1 bits zero.  */\n \t\t  \n-\t\t  mask = GET_MODE_MASK (mode) & ~ ((1 << first_count) - 1);\n+\t\t  mask = (GET_MODE_MASK (mode)\n+\t\t\t  & ~ (((HOST_WIDE_INT) 1 << first_count) - 1));\n \n-\t\t  varop = simplify_and_const_int (0, result_mode,\n+\t\t  varop = simplify_and_const_int (NULL_RTX, result_mode,\n \t\t\t\t\t\t  XEXP (varop, 0), mask);\n-\t\t  varop = simplify_shift_const (0, ASHIFT, result_mode,\n+\t\t  varop = simplify_shift_const (NULL_RTX, ASHIFT, result_mode,\n \t\t\t\t\t\tvarop, count);\n \t\t  count = first_count;\n \t\t  code = ASHIFTRT;\n@@ -5830,8 +5838,12 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t  && (inner = get_last_value (XEXP (varop, 0))) != 0)\n \t\t{\n \t\t  if ((GET_CODE (inner) == CONST_INT\n-\t\t       && (INTVAL (inner) >> (HOST_BITS_PER_INT - (first_count + 1)) == 0\n-\t\t\t   || (INTVAL (inner) >> (HOST_BITS_PER_INT - (first_count + 1)) == -1)))\n+\t\t       && (((INTVAL (inner)\n+\t\t\t     >> (HOST_BITS_PER_WIDE_INT - (first_count + 1)))\n+\t\t\t    == 0)\n+\t\t\t   || ((INTVAL (inner)\n+\t\t\t\t>> (HOST_BITS_PER_WIDE_INT - (first_count + 1)))\n+\t\t\t       == -1)))\n \t\t      || (GET_CODE (inner) == SIGN_EXTEND\n \t\t\t  && ((GET_MODE_BITSIZE (GET_MODE (inner))\n \t\t\t       - GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (inner))))\n@@ -5876,7 +5888,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \n \t      if (code == ASHIFTRT\n \t\t  || (code == ROTATE && first_code == ASHIFTRT)\n-\t\t  || GET_MODE_BITSIZE (mode) > HOST_BITS_PER_INT\n+\t\t  || GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT\n \t\t  || (GET_MODE (varop) != result_mode\n \t\t      && (first_code == ASHIFTRT || first_code == ROTATE\n \t\t\t  || code == ROTATE)))\n@@ -5886,13 +5898,11 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t significant bits of the inner shift the same way the \n \t\t outer shift will.  */\n \n-\t      mask_rtx = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t  significant_bits (varop, GET_MODE (varop)));\n+\t      mask_rtx = GEN_INT (significant_bits (varop, GET_MODE (varop)));\n \n \t      mask_rtx\n \t\t= simplify_binary_operation (code, result_mode, mask_rtx,\n-\t\t\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t      count));\n+\t\t\t\t\t     GEN_INT (count));\n \t\t\t\t  \n \t      /* Give up if we can't compute an outer operation to use.  */\n \t      if (mask_rtx == 0\n@@ -5934,9 +5944,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t   && 0 != (new\n \t\t\t    = simplify_binary_operation (code, mode,\n \t\t\t\t\t\t\t XEXP (varop, 0),\n-\t\t\t\t\t\t\t gen_rtx (CONST_INT,\n-\t\t\t\t\t\t\t\t  VOIDmode,\n-\t\t\t\t\t\t\t\t  count))))\n+\t\t\t\t\t\t\t GEN_INT (count))))\n \t    {\n \t      varop = gen_rtx_combine (code, mode, new, XEXP (varop, 1));\n \t      count = 0;\n@@ -5947,8 +5955,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \tcase NOT:\n \t  /* Make this fit the case below.  */\n \t  varop = gen_rtx_combine (XOR, mode, XEXP (varop, 0),\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t    GET_MODE_MASK (mode)));\n+\t\t\t\t   GEN_INT (GET_MODE_MASK (mode)));\n \t  continue;\n \n \tcase IOR:\n@@ -5987,9 +5994,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && (new = simplify_binary_operation (code, result_mode,\n \t\t\t\t\t\t   XEXP (varop, 1),\n-\t\t\t\t\t\t   gen_rtx (CONST_INT,\n-\t\t\t\t\t\t\t    VOIDmode,\n-\t\t\t\t\t\t\t    count))) != 0\n+\t\t\t\t\t\t   GEN_INT (count))) != 0\n \t      && merge_outer_ops (&outer_op, &outer_const, GET_CODE (varop),\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n \t    {\n@@ -6001,9 +6006,9 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t     logical expression, make a new logical expression, and apply\n \t     the inverse distributive law.  */\n \t  {\n-\t    rtx lhs = simplify_shift_const (0, code, result_mode,\n+\t    rtx lhs = simplify_shift_const (NULL_RTX, code, result_mode,\n \t\t\t\t\t    XEXP (varop, 0), count);\n-\t    rtx rhs = simplify_shift_const (0, code, result_mode,\n+\t    rtx rhs = simplify_shift_const (NULL_RTX, code, result_mode,\n \t\t\t\t\t    XEXP (varop, 1), count);\n \n \t    varop = gen_binary (GET_CODE (varop), result_mode, lhs, rhs);\n@@ -6022,12 +6027,13 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      && XEXP (varop, 1) == const0_rtx\n \t      && GET_MODE (XEXP (varop, 0)) == result_mode\n \t      && count == GET_MODE_BITSIZE (result_mode) - 1\n-\t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_INT\n+\t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n \t      && ((STORE_FLAG_VALUE\n-\t\t   & (1 << (GET_MODE_BITSIZE (result_mode) - 1))))\n+\t\t   & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (result_mode) - 1))))\n \t      && significant_bits (XEXP (varop, 0), result_mode) == 1\n-\t      && merge_outer_ops (&outer_op, &outer_const, XOR, 1,\n-\t\t\t\t  result_mode, &complement_p))\n+\t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n+\t\t\t\t  (HOST_WIDE_INT) 1, result_mode,\n+\t\t\t\t  &complement_p))\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      count = 0;\n@@ -6048,8 +6054,9 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  /* NEG commutes with ASHIFT since it is multiplication.  Move the\n \t     NEG outside to allow shifts to combine.  */\n \t  if (code == ASHIFT\n-\t      && merge_outer_ops (&outer_op, &outer_const, NEG, 0,\n-\t\t\t\t  result_mode, &complement_p))\n+\t      && merge_outer_ops (&outer_op, &outer_const, NEG,\n+\t\t\t\t  (HOST_WIDE_INT) 0, result_mode,\n+\t\t\t\t  &complement_p))\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;\n@@ -6071,8 +6078,9 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  if (code == LSHIFTRT && count == GET_MODE_BITSIZE (result_mode) - 1\n \t      && XEXP (varop, 1) == constm1_rtx\n \t      && significant_bits (XEXP (varop, 0), result_mode) == 1\n-\t      && merge_outer_ops (&outer_op, &outer_const, XOR, 1,\n-\t\t\t\t  result_mode, &complement_p))\n+\t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n+\t\t\t\t  (HOST_WIDE_INT) 1, result_mode,\n+\t\t\t\t  &complement_p))\n \t    {\n \t      count = 0;\n \t      varop = XEXP (varop, 0);\n@@ -6086,7 +6094,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t     we are computing the size of a variable-size array.  */\n \n \t  if ((code == ASHIFTRT || code == LSHIFTRT)\n-\t      && count < HOST_BITS_PER_INT\n+\t      && count < HOST_BITS_PER_WIDE_INT\n \t      && significant_bits (XEXP (varop, 1), result_mode) >> count == 0\n \t      && (significant_bits (XEXP (varop, 1), result_mode)\n \t\t  & significant_bits (XEXP (varop, 0), result_mode)) == 0)\n@@ -6095,7 +6103,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      continue;\n \t    }\n \t  else if ((code == ASHIFTRT || code == LSHIFTRT)\n-\t\t   && count < HOST_BITS_PER_INT\n+\t\t   && count < HOST_BITS_PER_WIDE_INT\n \t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n \t\t\t    >> count)\n \t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n@@ -6111,9 +6119,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && (new = simplify_binary_operation (ASHIFT, result_mode,\n \t\t\t\t\t\t   XEXP (varop, 1),\n-\t\t\t\t\t\t   gen_rtx (CONST_INT,\n-\t\t\t\t\t\t\t    VOIDmode,\n-\t\t\t\t\t\t\t    count))) != 0\n+\t\t\t\t\t\t   GEN_INT (count))) != 0\n \t      && merge_outer_ops (&outer_op, &outer_const, PLUS,\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n \t    {\n@@ -6174,7 +6180,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       && INTVAL (XEXP (x, 1)) == count)\n     const_rtx = XEXP (x, 1);\n   else\n-    const_rtx = gen_rtx (CONST_INT, VOIDmode, count);\n+    const_rtx = GEN_INT (count);\n \n   if (x && GET_CODE (XEXP (x, 0)) == SUBREG\n       && GET_MODE (XEXP (x, 0)) == shift_mode\n@@ -6202,7 +6208,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n   /* If we were doing a LSHIFTRT in a wider mode than it was originally,\n      turn off all the bits that the shift would have turned off.  */\n   if (orig_code == LSHIFTRT && result_mode != shift_mode)\n-    x = simplify_and_const_int (0, shift_mode, x,\n+    x = simplify_and_const_int (NULL_RTX, shift_mode, x,\n \t\t\t\tGET_MODE_MASK (result_mode) >> orig_count);\n       \n   /* Do the remainder of the processing in RESULT_MODE.  */\n@@ -6215,20 +6221,19 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \n   if (outer_op != NIL)\n     {\n-      if (GET_MODE_BITSIZE (result_mode) < HOST_BITS_PER_INT)\n+      if (GET_MODE_BITSIZE (result_mode) < HOST_BITS_PER_WIDE_INT)\n \touter_const &= GET_MODE_MASK (result_mode);\n \n       if (outer_op == AND)\n-\tx = simplify_and_const_int (0, result_mode, x, outer_const);\n+\tx = simplify_and_const_int (NULL_RTX, result_mode, x, outer_const);\n       else if (outer_op == SET)\n \t/* This means that we have determined that the result is\n \t   equivalent to a constant.  This should be rare.  */\n-\tx = gen_rtx (CONST_INT, VOIDmode, outer_const);\n+\tx = GEN_INT (outer_const);\n       else if (GET_RTX_CLASS (outer_op) == '1')\n \tx = gen_unary (outer_op, result_mode, x);\n       else\n-\tx = gen_binary (outer_op, result_mode, x,\n-\t\t\tgen_rtx (CONST_INT, VOIDmode, outer_const));\n+\tx = gen_binary (outer_op, result_mode, x, GEN_INT (outer_const));\n     }\n \n   return x;\n@@ -6565,7 +6570,7 @@ simplify_comparison (code, pop0, pop1)\n \t this shift are not significant for either input and if the type of\n \t comparison is compatible with the shift.  */\n       if (GET_CODE (op0) == GET_CODE (op1)\n-\t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_INT\n+\t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n \t  && ((GET_CODE (op0) == ROTATE && (code == NE || code == EQ))\n \t      || ((GET_CODE (op0) == LSHIFTRT\n \t\t   || GET_CODE (op0) == ASHIFT || GET_CODE (op0) == LSHIFT)\n@@ -6575,11 +6580,11 @@ simplify_comparison (code, pop0, pop1)\n \t\t      && code != GEU && code != GEU)))\n \t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t  && INTVAL (XEXP (op0, 1)) >= 0\n-\t  && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_INT\n+\t  && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && XEXP (op0, 1) == XEXP (op1, 1))\n \t{\n \t  enum machine_mode mode = GET_MODE (op0);\n-\t  unsigned mask = GET_MODE_MASK (mode);\n+\t  unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n \t  int shift_count = INTVAL (XEXP (op0, 1));\n \n \t  if (GET_CODE (op0) == LSHIFTRT || GET_CODE (op0) == ASHIFTRT)\n@@ -6647,11 +6652,11 @@ simplify_comparison (code, pop0, pop1)\n     {\n       enum machine_mode mode = GET_MODE (op0);\n       int mode_width = GET_MODE_BITSIZE (mode);\n-      unsigned mask = GET_MODE_MASK (mode);\n+      unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n       int equality_comparison_p;\n       int sign_bit_comparison_p;\n       int unsigned_comparison_p;\n-      int const_op;\n+      HOST_WIDE_INT const_op;\n \n       /* We only want to handle integral modes.  This catches VOIDmode,\n \t CCmode, and the floating-point modes.  An exception is that we\n@@ -6667,7 +6672,7 @@ simplify_comparison (code, pop0, pop1)\n       /* Get the constant we are comparing against and turn off all bits\n \t not on in our mode.  */\n       const_op = INTVAL (op1);\n-      if (mode_width <= HOST_BITS_PER_INT)\n+      if (mode_width <= HOST_BITS_PER_WIDE_INT)\n \tconst_op &= mask;\n \n       /* If we are comparing against a constant power of two and the value\n@@ -6677,7 +6682,7 @@ simplify_comparison (code, pop0, pop1)\n       if (const_op\n \t  && (code == EQ || code == NE || code == GE || code == GEU\n \t      || code == LT || code == LTU)\n-\t  && mode_width <= HOST_BITS_PER_INT\n+\t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && exact_log2 (const_op) >= 0\n \t  && significant_bits (op0, mode) == const_op)\n \t{\n@@ -6696,7 +6701,7 @@ simplify_comparison (code, pop0, pop1)\n \t  if (const_op > 0)\n \t    {\n \t      const_op -= 1;\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      code = LE;\n \t      /* ... fall through to LE case below.  */\n \t    }\n@@ -6708,16 +6713,16 @@ simplify_comparison (code, pop0, pop1)\n \t  if (const_op < 0)\n \t    {\n \t      const_op += 1;\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      code = LT;\n \t    }\n \n \t  /* If we are doing a <= 0 comparison on a value known to have\n \t     a zero sign bit, we can replace this with == 0.  */\n \t  else if (const_op == 0\n-\t\t   && mode_width <= HOST_BITS_PER_INT\n+\t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t   && (significant_bits (op0, mode)\n-\t\t       & (1 << (mode_width - 1))) == 0)\n+\t\t       & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)\n \t    code = EQ;\n \t  break;\n \n@@ -6726,7 +6731,7 @@ simplify_comparison (code, pop0, pop1)\n \t  if (const_op > 0)\n \t    {\n \t      const_op -= 1;\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      code = GT;\n \t      /* ... fall through to GT below.  */\n \t    }\n@@ -6738,16 +6743,16 @@ simplify_comparison (code, pop0, pop1)\n \t  if (const_op < 0)\n \t    {\n \t      const_op += 1;\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      code = GE;\n \t    }\n \n \t  /* If we are doing a > 0 comparison on a value known to have\n \t     a zero sign bit, we can replace this with != 0.  */\n \t  else if (const_op == 0\n-\t\t   && mode_width <= HOST_BITS_PER_INT\n+\t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t   && (significant_bits (op0, mode)\n-\t\t       & (1 << (mode_width - 1))) == 0)\n+\t\t       & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)\n \t    code = NE;\n \t  break;\n \n@@ -6756,7 +6761,7 @@ simplify_comparison (code, pop0, pop1)\n \t  if (const_op > 0)\n \t    {\n \t      const_op -= 1;\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      code = LEU;\n \t      /* ... fall through ... */\n \t    }\n@@ -6774,7 +6779,7 @@ simplify_comparison (code, pop0, pop1)\n \t  if (const_op > 1)\n \t    {\n \t      const_op -= 1;\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      code = GTU;\n \t      /* ... fall through ... */\n \t    }\n@@ -6821,7 +6826,7 @@ simplify_comparison (code, pop0, pop1)\n #endif\n \n \t      op0 = XEXP (op0, 2);\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, i);\n+\t      op1 = GEN_INT (i);\n \t      const_op = i;\n \n \t      /* Result is nonzero iff shift count is equal to I.  */\n@@ -6880,9 +6885,9 @@ simplify_comparison (code, pop0, pop1)\n \n \t  if (sign_bit_comparison_p\n \t      && (GET_CODE (XEXP (op0, 0)) == ABS\n-\t\t  || (mode_width <= HOST_BITS_PER_INT\n+\t\t  || (mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t      && (significant_bits (XEXP (op0, 0), mode)\n-\t\t\t  & (1 << (mode_width - 1))) == 0)))\n+\t\t\t  & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)))\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      code = (code == LT ? NE : EQ);\n@@ -6935,11 +6940,12 @@ simplify_comparison (code, pop0, pop1)\n \t     bit.  This will be converted into a ZERO_EXTRACT.  */\n \t  if (const_op == 0 && sign_bit_comparison_p\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t      && mode_width <= HOST_BITS_PER_INT)\n+\t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      op0 = simplify_and_const_int (0, mode, XEXP (op0, 0),\n-\t\t\t\t\t    1 << (mode_width - 1\n-\t\t\t\t\t\t  - INTVAL (XEXP (op0, 1))));\n+\t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n+\t\t\t\t\t    ((HOST_WIDE_INT) 1\n+\t\t\t\t\t     << (mode_width - 1\n+\t\t\t\t\t\t - INTVAL (XEXP (op0, 1)))));\n \t      code = (code == LT ? NE : EQ);\n \t      continue;\n \t    }\n@@ -6963,9 +6969,10 @@ simplify_comparison (code, pop0, pop1)\n \t     with ZERO_EXTEND or a signed comparison with SIGN_EXTEND.  */\n \t  if (! unsigned_comparison_p\n \t      && (GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0)))\n-\t\t  <= HOST_BITS_PER_INT)\n-\t      && ((unsigned) const_op\n-\t\t  < (1 << (GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0))) - 1))))\n+\t\t  <= HOST_BITS_PER_WIDE_INT)\n+\t      && ((unsigned HOST_WIDE_INT) const_op\n+\t\t  < (((HOST_WIDE_INT) 1\n+\t\t      << (GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0))) - 1)))))\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      continue;\n@@ -6984,8 +6991,8 @@ simplify_comparison (code, pop0, pop1)\n \tcase ZERO_EXTEND:\n \t  if ((unsigned_comparison_p || equality_comparison_p)\n \t      && (GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0)))\n-\t\t  <= HOST_BITS_PER_INT)\n-\t      && ((unsigned) const_op\n+\t\t  <= HOST_BITS_PER_WIDE_INT)\n+\t      && ((unsigned HOST_WIDE_INT) const_op\n \t\t  < GET_MODE_MASK (GET_MODE (XEXP (op0, 0)))))\n \t    {\n \t      op0 = XEXP (op0, 0);\n@@ -7065,10 +7072,11 @@ simplify_comparison (code, pop0, pop1)\n \t     earlier test or the opposite of that result.  */\n \t  if (code == NE\n \t      || (code == EQ && reversible_comparison_p (op0))\n-\t      || (GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_INT\n+\t      || (GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n \t\t  && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n \t\t  && (STORE_FLAG_VALUE\n-\t\t      & (1 << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1)))\n+\t\t      & (((HOST_WIDE_INT) 1\n+\t\t\t  << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n \t\t  && (code == LT\n \t\t      || (code == GE && reversible_comparison_p (op0)))))\n \t    {\n@@ -7104,20 +7112,20 @@ simplify_comparison (code, pop0, pop1)\n \t\t(op0, mode, gen_rtx_combine (LSHIFTRT, mode,\n \t\t\t\t\t     XEXP (op0, 1),\n \t\t\t\t\t     XEXP (XEXP (op0, 0), 1)),\n-\t\t 1);\n+\t\t (HOST_WIDE_INT) 1);\n \t      continue;\n \t    }\n \n \t  /* If we are comparing (and (lshiftrt X C1) C2) for equality with\n \t     zero and X is a comparison and C1 and C2 describe only bits set\n \t     in STORE_FLAG_VALUE, we can compare with X.  */\n \t  if (const_op == 0 && equality_comparison_p\n-\t      && mode_width <= HOST_BITS_PER_INT\n+\t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && GET_CODE (XEXP (op0, 0)) == LSHIFTRT\n \t      && GET_CODE (XEXP (XEXP (op0, 0), 1)) == CONST_INT\n \t      && INTVAL (XEXP (XEXP (op0, 0), 1)) >= 0\n-\t      && INTVAL (XEXP (XEXP (op0, 0), 1)) < HOST_BITS_PER_INT)\n+\t      && INTVAL (XEXP (XEXP (op0, 0), 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      mask = ((INTVAL (XEXP (op0, 1)) & GET_MODE_MASK (mode))\n \t\t      << INTVAL (XEXP (XEXP (op0, 0), 1)));\n@@ -7137,9 +7145,9 @@ simplify_comparison (code, pop0, pop1)\n \t  if (equality_comparison_p\n \t      && const_op == 0\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t      && mode_width <= HOST_BITS_PER_INT\n+\t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && ((INTVAL (XEXP (op0, 1)) & GET_MODE_MASK (mode))\n-\t\t  == 1 << (mode_width - 1)))\n+\t\t  == (HOST_WIDE_INT) 1 << (mode_width - 1)))\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      code = (code == EQ ? GE : LT);\n@@ -7173,27 +7181,30 @@ simplify_comparison (code, pop0, pop1)\n \t  if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && INTVAL (XEXP (op0, 1)) >= 0\n \t      && ((INTVAL (XEXP (op0, 1)) + ! equality_comparison_p)\n-\t\t  < HOST_BITS_PER_INT)\n-\t      && (const_op &  ~ ((1 << INTVAL (XEXP (op0, 1))) - 1)) == 0\n-\t      && mode_width <= HOST_BITS_PER_INT\n+\t\t  < HOST_BITS_PER_WIDE_INT)\n+\t      && ((const_op\n+\t\t   &  ~ (((HOST_WIDE_INT) 1\n+\t\t\t  << INTVAL (XEXP (op0, 1))) - 1)) == 0)\n+\t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && (significant_bits (XEXP (op0, 0), mode)\n \t\t  & ~ (mask >> (INTVAL (XEXP (op0, 1))\n \t\t\t\t+ ! equality_comparison_p))) == 0)\n \t    {\n \t      const_op >>= INTVAL (XEXP (op0, 1));\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      op0 = XEXP (op0, 0);\n \t      continue;\n \t    }\n \n \t  /* If we are doing a sign bit comparison, it means we are testing\n \t     a particular bit.  Convert it to the appropriate AND.  */\n \t  if (sign_bit_comparison_p && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t      && mode_width <= HOST_BITS_PER_INT)\n+\t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      op0 = simplify_and_const_int (0, mode, XEXP (op0, 0),\n-\t\t\t\t\t    1 << ( mode_width - 1\n-\t\t\t\t\t\t  - INTVAL (XEXP (op0, 1))));\n+\t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n+\t\t\t\t\t    ((HOST_WIDE_INT) 1\n+\t\t\t\t\t     << (mode_width - 1\n+\t\t\t\t\t\t - INTVAL (XEXP (op0, 1)))));\n \t      code = (code == LT ? NE : EQ);\n \t      continue;\n \t    }\n@@ -7205,7 +7216,8 @@ simplify_comparison (code, pop0, pop1)\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && INTVAL (XEXP (op0, 1)) == mode_width - 1)\n \t    {\n-\t      op0 = simplify_and_const_int (0, mode, XEXP (op0, 0), 1);\n+\t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n+\t\t\t\t\t    (HOST_WIDE_INT) 1);\n \t      continue;\n \t    }\n \t  break;\n@@ -7219,8 +7231,9 @@ simplify_comparison (code, pop0, pop1)\n \t      && XEXP (op0, 1) == XEXP (XEXP (op0, 0), 1)\n \t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n \t\t\t\t\t MODE_INT, 1)) != VOIDmode\n-\t      && ((unsigned) const_op <= GET_MODE_MASK (tmode)\n-\t\t  || (unsigned) - const_op <= GET_MODE_MASK (tmode)))\n+\t      && ((unsigned HOST_WIDE_INT) const_op <= GET_MODE_MASK (tmode)\n+\t\t  || ((unsigned HOST_WIDE_INT) - const_op\n+\t\t      <= GET_MODE_MASK (tmode))))\n \t    {\n \t      op0 = gen_lowpart_for_combine (tmode, XEXP (XEXP (op0, 0), 0));\n \t      continue;\n@@ -7234,16 +7247,16 @@ simplify_comparison (code, pop0, pop1)\n \t     overflow occurs.  */\n \t  if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && INTVAL (XEXP (op0, 1)) >= 0\n-\t      && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_INT\n-\t      && mode_width <= HOST_BITS_PER_INT\n+\t      && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n+\t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && (significant_bits (XEXP (op0, 0), mode)\n-\t\t  & ((1 << INTVAL (XEXP (op0, 1))) - 1)) == 0\n+\t\t  & (((HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1))) - 1)) == 0\n \t      && (const_op == 0\n \t\t  || (floor_log2 (const_op) + INTVAL (XEXP (op0, 1))\n \t\t      < mode_width)))\n \t    {\n \t      const_op <<= INTVAL (XEXP (op0, 1));\n-\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      op1 = GEN_INT (const_op);\n \t      op0 = XEXP (op0, 0);\n \t      continue;\n \t    }\n@@ -7288,7 +7301,7 @@ simplify_comparison (code, pop0, pop1)\n   else if (GET_CODE (op0) == SUBREG && subreg_lowpart_p (op0)\n \t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n \t   && (code == NE || code == EQ)\n-\t   && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_INT\n+\t   && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n \t   && (significant_bits (SUBREG_REG (op0), GET_MODE (SUBREG_REG (op0)))\n \t       & ~ GET_MODE_MASK (GET_MODE (op0))) == 0\n \t   && (tem = gen_lowpart_for_combine (GET_MODE (SUBREG_REG (op0)),\n@@ -7311,23 +7324,24 @@ simplify_comparison (code, pop0, pop1)\n       && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n       && cmp_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n     for (tmode = GET_MODE_WIDER_MODE (mode);\n-\t tmode != VOIDmode && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_INT;\n+\t (tmode != VOIDmode\n+\t  && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT);\n \t tmode = GET_MODE_WIDER_MODE (tmode))\n       if (cmp_optab->handlers[(int) tmode].insn_code != CODE_FOR_nothing\n \t  && (significant_bits (op0, tmode) & ~ GET_MODE_MASK (mode)) == 0\n \t  && (significant_bits (op1, tmode) & ~ GET_MODE_MASK (mode)) == 0\n \t  && (code == EQ || code == NE\n \t      || (op1 == const0_rtx && (code == LT || code == GE)\n-\t\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT)))\n+\t\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)))\n \t{\n \t  op0 = gen_lowpart_for_combine (tmode, op0);\n \t  op1 = gen_lowpart_for_combine (tmode, op1);\n \n \t  if (code == LT || code == GE)\n \t    {\n \t      op0 = gen_binary (AND, tmode, op0,\n-\t\t\t\tgen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t 1 << (GET_MODE_BITSIZE (mode) - 1)));\n+\t\t\t\tGEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t << (GET_MODE_BITSIZE (mode) - 1)));\n \t      code = (code == LT) ? NE : EQ;\n \t    }\n \n@@ -7501,7 +7515,7 @@ record_dead_and_set_regs_1 (dest, setter)\n \t   gen_lowpart_for_combine (GET_MODE (SET_DEST (setter)),\n \t\t\t\t    SET_SRC (setter)));\n       else\n-\trecord_value_for_reg (dest, record_dead_insn, 0);\n+\trecord_value_for_reg (dest, record_dead_insn, NULL_RTX);\n     }\n   else if (GET_CODE (dest) == MEM\n \t   /* Ignore pushes, they clobber nothing.  */\n@@ -7527,7 +7541,7 @@ record_dead_and_set_regs (insn)\n       if (REG_NOTE_KIND (link) == REG_DEAD)\n \treg_last_death[REGNO (XEXP (link, 0))] = insn;\n       else if (REG_NOTE_KIND (link) == REG_INC)\n-\trecord_value_for_reg (XEXP (link, 0), insn, 0);\n+\trecord_value_for_reg (XEXP (link, 0), insn, NULL_RTX);\n     }\n \n   if (GET_CODE (insn) == CALL_INSN)\n@@ -7766,8 +7780,8 @@ reg_dead_at_p (reg, insn)\n     }\n \n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n-    if (basic_block_live_at_start[block][i / HOST_BITS_PER_INT]\n-\t& (1 << (i % HOST_BITS_PER_INT)))\n+    if (basic_block_live_at_start[block][i / REGSET_ELT_BITS]\n+\t& ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n       return 0;\n \n   return 1;\n@@ -8035,7 +8049,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t    place = from_insn;\n \t  else\n \t    {\n-\t      tem = find_reg_note (XEXP (note, 0), REG_LIBCALL, 0);\n+\t      tem = find_reg_note (XEXP (note, 0), REG_LIBCALL, NULL_RTX);\n \t      place = prev_real_insn (from_insn);\n \t      if (tem && place)\n \t\tXEXP (tem, 0) = place;\n@@ -8048,7 +8062,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t    place = from_insn;\n \t  else\n \t    {\n-\t      tem = find_reg_note (XEXP (note, 0), REG_RETVAL, 0);\n+\t      tem = find_reg_note (XEXP (note, 0), REG_RETVAL, NULL_RTX);\n \t      place = next_real_insn (from_insn);\n \t      if (tem && place)\n \t\tXEXP (tem, 0) = place;\n@@ -8105,7 +8119,8 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \t\t\tPATTERN (tem) = pc_rtx;\n \n-\t\t\tdistribute_notes (REG_NOTES (tem), tem, tem, 0, 0, 0);\n+\t\t\tdistribute_notes (REG_NOTES (tem), tem, tem,\n+\t\t\t\t\t  NULL_RTX, NULL_RTX, NULL_RTX);\n \t\t\tdistribute_links (LOG_LINKS (tem));\n \n \t\t\tPUT_CODE (tem, NOTE);"}, {"sha": "e910ff1f392853e9935812d59068cd590faa208e", "filename": "gcc/flow.c", "status": "modified", "additions": 71, "deletions": 52, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -455,7 +455,7 @@ find_basic_blocks (f, nonlocal_label_list)\n \t/* Make a list of all labels referred to other than by jumps.  */\n \tif (code == INSN || code == CALL_INSN)\n \t  {\n-\t    rtx note = find_reg_note (insn, REG_LABEL, 0);\n+\t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n \t    if (note != 0)\n \t      label_value_list = gen_rtx (EXPR_LIST, VOIDmode, XEXP (note, 0),\n \t\t\t\t\t  label_value_list);\n@@ -787,7 +787,7 @@ life_analysis (f, nregs)\n \t      && REGNO (SET_DEST (PATTERN (insn))) ==\n \t\t\tREGNO (SET_SRC (PATTERN (insn)))\n \t      /* Insns carrying these notes are useful later on.  */\n-\t      && ! find_reg_note (insn, REG_EQUAL, 0))\n+\t      && ! find_reg_note (insn, REG_EQUAL, NULL_RTX))\n \t    {\n \t      PUT_CODE (insn, NOTE);\n \t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n@@ -814,7 +814,7 @@ life_analysis (f, nregs)\n \t\t\n \t      if (i == XVECLEN (PATTERN (insn), 0)\n \t\t  /* Insns carrying these notes are useful later on.  */\n-\t\t  && ! find_reg_note (insn, REG_EQUAL, 0))\n+\t\t  && ! find_reg_note (insn, REG_EQUAL, NULL_RTX))\n \t\t{\n \t\t  PUT_CODE (insn, NOTE);\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n@@ -906,8 +906,9 @@ life_analysis (f, nregs)\n \n \t      for (j = 0; j < regset_size; j++)\n \t\t{\n-\t\t  register int x = (basic_block_new_live_at_end[i][j]\n-\t\t\t\t    & ~basic_block_live_at_end[i][j]);\n+\t\t  register REGSET_ELT_TYPE x\n+\t\t    = (basic_block_new_live_at_end[i][j]\n+\t\t       & ~basic_block_live_at_end[i][j]);\n \t\t  if (x)\n \t\t    consider = 1;\n \t\t  if (x & basic_block_significant[i][j])\n@@ -933,8 +934,9 @@ life_analysis (f, nregs)\n \t\t as live at start as well.  */\n \t      for (j = 0; j < regset_size; j++)\n \t\t{\n-\t\t  register int x = basic_block_new_live_at_end[i][j]\n-\t\t\t& ~basic_block_live_at_end[i][j];\n+\t\t  register REGSET_ELT_TYPE x\n+\t\t    = (basic_block_new_live_at_end[i][j]\n+\t\t       & ~basic_block_live_at_end[i][j]);\n \t\t  basic_block_live_at_start[i][j] |= x;\n \t\t  basic_block_live_at_end[i][j] |= x;\n \t\t}\n@@ -949,7 +951,8 @@ life_analysis (f, nregs)\n \t\t     basic_block_live_at_start[i], regset_bytes);\n \t      propagate_block (basic_block_live_at_start[i],\n \t\t\t       basic_block_head[i], basic_block_end[i], 0,\n-\t\t\t       first_pass ? basic_block_significant[i] : 0,\n+\t\t\t       first_pass ? basic_block_significant[i]\n+\t\t\t       : (regset) 0,\n \t\t\t       i);\n \t    }\n \n@@ -996,7 +999,7 @@ life_analysis (f, nregs)\n   if (n_basic_blocks > 0)\n     for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n       if (basic_block_live_at_start[0][i / REGSET_ELT_BITS]\n-\t  & (1 << (i % REGSET_ELT_BITS)))\n+\t  & ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n \treg_basic_block[i] = REG_BLOCK_GLOBAL;\n \n   /* Now the life information is accurate.\n@@ -1014,7 +1017,8 @@ life_analysis (f, nregs)\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       propagate_block (basic_block_live_at_end[i],\n-\t\t       basic_block_head[i], basic_block_end[i], 1, 0, i);\n+\t\t       basic_block_head[i], basic_block_end[i], 1,\n+\t\t       (regset) 0, i);\n #ifdef USE_C_ALLOCA\n       alloca (0);\n #endif\n@@ -1028,7 +1032,8 @@ life_analysis (f, nregs)\n      ANSI says only volatile variables need this.  */\n #ifdef LONGJMP_RESTORE_FROM_STACK\n   for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n-    if (regs_live_at_setjmp[i / REGSET_ELT_BITS] & (1 << (i % REGSET_ELT_BITS))\n+    if (regs_live_at_setjmp[i / REGSET_ELT_BITS]\n+\t& ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS))\n \t&& regno_reg_rtx[i] != 0 && ! REG_USERVAR_P (regno_reg_rtx[i]))\n       {\n \treg_live_length[i] = -1;\n@@ -1047,14 +1052,15 @@ life_analysis (f, nregs)\n      that hard reg where this pseudo is dead, thus clobbering the pseudo.\n      Conclusion: such a pseudo must not go in a hard reg.  */\n   for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n-    if (regs_live_at_setjmp[i / REGSET_ELT_BITS] & (1 << (i % REGSET_ELT_BITS))\n+    if ((regs_live_at_setjmp[i / REGSET_ELT_BITS]\n+\t & ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n \t&& regno_reg_rtx[i] != 0)\n       {\n \treg_live_length[i] = -1;\n \treg_basic_block[i] = -1;\n       }\n \n-  obstack_free (&flow_obstack, 0);\n+  obstack_free (&flow_obstack, NULL_PTR);\n }\n \f\n /* Subroutines of life analysis.  */\n@@ -1193,7 +1199,8 @@ propagate_block (old, first, last, final, significant, bnum)\n \n   if (final)\n     {\n-      register int i, offset, bit;\n+      register int i, offset;\n+      REGSET_ELT_TYPE bit;\n \n       num_scratch = 0;\n       maxlive = (regset) alloca (regset_bytes);\n@@ -1260,7 +1267,7 @@ propagate_block (old, first, last, final, significant, bnum)\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n \t  register int i;\n-\t  rtx note = find_reg_note (insn, REG_RETVAL, 0);\n+\t  rtx note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n \t  int insn_is_dead\n \t    = (insn_dead_p (PATTERN (insn), old, 0)\n \t       /* Don't delete something that refers to volatile storage!  */\n@@ -1337,7 +1344,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t  if (libcall_is_dead)\n \t    {\n \t      /* Mark the dest reg as `significant'.  */\n-\t      mark_set_regs (old, dead, PATTERN (insn), 0, significant);\n+\t      mark_set_regs (old, dead, PATTERN (insn), NULL_RTX, significant);\n \n \t      insn = XEXP (note, 0);\n \t      prev = PREV_INSN (insn);\n@@ -1358,8 +1365,8 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t DEAD gets those set by it.  Dead insns don't make anything\n \t\t live.  */\n \n-\t      mark_set_regs (old, dead, PATTERN (insn), final ? insn : 0,\n-\t\t\t     significant);\n+\t      mark_set_regs (old, dead, PATTERN (insn),\n+\t\t\t     final ? insn : NULL_RTX, significant);\n \n \t      /* If an insn doesn't use CC0, it becomes dead since we \n \t\t assume that every insn clobbers it.  So show it dead here;\n@@ -1388,19 +1395,20 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    if (call_used_regs[i] && ! global_regs[i])\n \t\t      dead[i / REGSET_ELT_BITS]\n-\t\t\t|= (1 << (i % REGSET_ELT_BITS));\n+\t\t\t|= ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS));\n \n \t\t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n \t\t  live[STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t\t    |= (1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS));\n+\t\t    |= ((REGSET_ELT_TYPE) 1\n+\t\t\t<< (STACK_POINTER_REGNUM % REGSET_ELT_BITS));\n \n \t\t  /* Calls may also reference any of the global registers,\n \t\t     so they are made live.  */\n \n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    if (global_regs[i])\n \t\t      live[i / REGSET_ELT_BITS]\n-\t\t\t|= (1 << (i % REGSET_ELT_BITS));\n+\t\t\t|= ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS));\n \n \t\t  /* Calls also clobber memory.  */\n \t\t  last_mem_set = 0;\n@@ -1435,18 +1443,18 @@ propagate_block (old, first, last, final, significant, bnum)\n \t    {\n \t      for (i = 0; i < regset_size; i++)\n \t\t{\n-\t\t  register int diff = live[i] & ~maxlive[i];\n+\t\t  register REGSET_ELT_TYPE diff = live[i] & ~maxlive[i];\n \n \t\t  if (diff)\n \t\t    {\n \t\t      register int regno;\n \t\t      maxlive[i] |= diff;\n \t\t      for (regno = 0; diff && regno < REGSET_ELT_BITS; regno++)\n-\t\t\tif (diff & (1 << regno))\n+\t\t\tif (diff & ((REGSET_ELT_TYPE) 1 << regno))\n \t\t\t  {\n \t\t\t    regs_sometimes_live[sometimes_max].offset = i;\n \t\t\t    regs_sometimes_live[sometimes_max].bit = regno;\n-\t\t\t    diff &= ~ (1 << regno);\n+\t\t\t    diff &= ~ ((REGSET_ELT_TYPE) 1 << regno);\n \t\t\t    sometimes_max++;\n \t\t\t  }\n \t\t    }\n@@ -1456,7 +1464,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\tregister struct foo *p = regs_sometimes_live;\n \t\tfor (i = 0; i < sometimes_max; i++, p++)\n \t\t  {\n-\t\t    if (old[p->offset] & (1 << p->bit))\n+\t\t    if (old[p->offset] & ((REGSET_ELT_TYPE) 1 << p->bit))\n \t\t      reg_live_length[p->offset * REGSET_ELT_BITS + p->bit]++;\n \t\t  }\n \t      }\n@@ -1513,7 +1521,8 @@ insn_dead_p (x, needed, call_ok)\n \t{\n \t  register int regno = REGNO (r);\n \t  register int offset = regno / REGSET_ELT_BITS;\n-\t  register int bit = 1 << (regno % REGSET_ELT_BITS);\n+\t  register REGSET_ELT_TYPE bit\n+\t    = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t  if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n \t      /* Make sure insns to set frame pointer aren't deleted.  */\n@@ -1535,7 +1544,8 @@ insn_dead_p (x, needed, call_ok)\n \n \t      while (--n > 0)\n \t\tif ((needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t     & 1 << ((regno + n) % REGSET_ELT_BITS)) != 0)\n+\t\t     & ((REGSET_ELT_TYPE) 1\n+\t\t\t<< ((regno + n) % REGSET_ELT_BITS))) != 0)\n \t\t  return 0;\n \t    }\n \n@@ -1639,7 +1649,7 @@ regno_uninitialized (regno)\n     return 0;\n \n   return (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n-\t  & (1 << (regno % REGSET_ELT_BITS)));\n+\t  & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS)));\n }\n \n /* 1 if register REGNO was alive at a place where `setjmp' was called\n@@ -1655,9 +1665,9 @@ regno_clobbered_at_setjmp (regno)\n \n   return ((reg_n_sets[regno] > 1\n \t   || (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n-\t       & (1 << (regno % REGSET_ELT_BITS))))\n+\t       & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n \t  && (regs_live_at_setjmp[regno / REGSET_ELT_BITS]\n-\t      & (1 << (regno % REGSET_ELT_BITS))));\n+\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))));\n }\n \f\n /* Process the registers that are set within X.\n@@ -1750,9 +1760,10 @@ mark_set_1 (needed, dead, x, insn, significant)\n     /* && regno != STACK_POINTER_REGNUM) -- let's try without this.  */\n     {\n       register int offset = regno / REGSET_ELT_BITS;\n-      register int bit = 1 << (regno % REGSET_ELT_BITS);\n-      int all_needed = (needed[offset] & bit) != 0;\n-      int some_needed = (needed[offset] & bit) != 0;\n+      register REGSET_ELT_TYPE bit\n+\t= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n+      REGSET_ELT_TYPE all_needed = (needed[offset] & bit);\n+      REGSET_ELT_TYPE some_needed = (needed[offset] & bit);\n \n       /* Mark it as a significant register for this basic block.  */\n       if (significant)\n@@ -1777,13 +1788,15 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t    {\n \t      if (significant)\n \t\tsignificant[(regno + n) / REGSET_ELT_BITS]\n-\t\t  |= 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t\t  |= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n \t      dead[(regno + n) / REGSET_ELT_BITS]\n-\t\t|= 1 << ((regno + n) % REGSET_ELT_BITS);\n-\t      some_needed |= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t      & 1 << ((regno + n) % REGSET_ELT_BITS));\n-\t      all_needed &= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t     & 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\t|= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t      some_needed\n+\t\t|= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t    & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t      all_needed\n+\t\t&= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t    & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n \t    }\n \t}\n       /* Additional data to record if this is the final pass.  */\n@@ -1870,7 +1883,8 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t      for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n \t\t   i >= 0; i--)\n \t\tif ((needed[(regno + i) / REGSET_ELT_BITS]\n-\t\t     & 1 << ((regno + i) % REGSET_ELT_BITS)) == 0)\n+\t\t     & ((REGSET_ELT_TYPE) 1\n+\t\t\t<< ((regno + i) % REGSET_ELT_BITS))) == 0)\n \t\t  REG_NOTES (insn)\n \t\t    = gen_rtx (EXPR_LIST, REG_UNUSED,\n \t\t\t       gen_rtx (REG, word_mode, regno + i),\n@@ -2002,7 +2016,7 @@ find_auto_inc (needed, x, insn)\n \t\t it as needed, we'll put a REG_DEAD note for it\n \t\t on this insn, which is incorrect.  */\n \t      needed[regno / REGSET_ELT_BITS]\n-\t\t|= 1 << (regno % REGSET_ELT_BITS);\n+\t\t|= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t      /* If there are any calls between INSN and INCR, show\n \t\t that REGNO now crosses them.  */\n@@ -2119,7 +2133,8 @@ mark_used_regs (needed, live, x, final, insn)\n       regno = REGNO (x);\n       {\n \tregister int offset = regno / REGSET_ELT_BITS;\n-\tregister int bit = 1 << (regno % REGSET_ELT_BITS);\n+\tregister REGSET_ELT_TYPE bit\n+\t  = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \tint all_needed = (needed[offset] & bit) != 0;\n \tint some_needed = (needed[offset] & bit) != 0;\n \n@@ -2158,11 +2173,13 @@ mark_used_regs (needed, live, x, final, insn)\n \t    while (--n > 0)\n \t      {\n \t\tlive[(regno + n) / REGSET_ELT_BITS]\n-\t\t  |= 1 << ((regno + n) % REGSET_ELT_BITS);\n-\t\tsome_needed |= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t\t& 1 << ((regno + n) % REGSET_ELT_BITS));\n-\t\tall_needed &= (needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t       & 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\t  |= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t\tsome_needed\n+\t\t  |= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t      & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n+\t\tall_needed\n+\t\t  &= (needed[(regno + n) / REGSET_ELT_BITS]\n+\t\t      & (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS));\n \t      }\n \t  }\n \tif (final)\n@@ -2231,7 +2248,8 @@ mark_used_regs (needed, live, x, final, insn)\n \t\t    for (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1;\n \t\t\t i >= 0; i--)\n \t\t      if ((needed[(regno + i) / REGSET_ELT_BITS]\n-\t\t\t   & 1 << ((regno + i) % REGSET_ELT_BITS)) == 0\n+\t\t\t   & ((REGSET_ELT_TYPE) 1\n+\t\t\t      << ((regno + i) % REGSET_ELT_BITS))) == 0\n \t\t\t  && ! dead_or_set_regno_p (insn, regno + i))\n \t\t\tREG_NOTES (insn)\n \t\t\t  = gen_rtx (EXPR_LIST, REG_DEAD,\n@@ -2313,11 +2331,12 @@ mark_used_regs (needed, live, x, final, insn)\n \t  || (! FRAME_POINTER_REQUIRED && flag_omit_frame_pointer))\n #endif\n \tlive[STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t  |= 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n+\t  |= (REGSET_ELT_TYPE) 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (global_regs[i])\n-\t  live[i / REGSET_ELT_BITS] |= 1 << (i % REGSET_ELT_BITS);\n+\t  live[i / REGSET_ELT_BITS]\n+\t    |= (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n       break;\n     }\n \n@@ -2358,7 +2377,7 @@ try_pre_increment_1 (insn)\n   /* Find the next use of this reg.  If in same basic block,\n      make it do pre-increment or pre-decrement if appropriate.  */\n   rtx x = PATTERN (insn);\n-  int amount = ((GET_CODE (SET_SRC (x)) == PLUS ? 1 : -1)\n+  HOST_WIDE_INT amount = ((GET_CODE (SET_SRC (x)) == PLUS ? 1 : -1)\n \t\t* INTVAL (XEXP (SET_SRC (x), 1)));\n   int regno = REGNO (SET_DEST (x));\n   rtx y = reg_next_use[regno];\n@@ -2396,7 +2415,7 @@ try_pre_increment_1 (insn)\n static int\n try_pre_increment (insn, reg, amount)\n      rtx insn, reg;\n-     int amount;\n+     HOST_WIDE_INT amount;\n {\n   register rtx use;\n "}, {"sha": "acf6ea1a915fdaa5a65874a01b0e81dc328dfaa7", "filename": "gcc/function.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -1205,7 +1205,7 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \t\t  /* Make the change and see if the insn remains valid.  */\n \t\t  INSN_CODE (insn) = -1;\n \t\t  XEXP (x, 0) = newmem;\n-\t\t  XEXP (x, 2) = gen_rtx (CONST_INT, VOIDmode, pos);\n+\t\t  XEXP (x, 2) = GEN_INT (pos);\n \n \t\t  if (recog_memoized (insn) >= 0)\n \t\t    return;\n@@ -1270,7 +1270,7 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \toptimize_bit_field (x, insn, 0);\n       if (GET_CODE (SET_SRC (x)) == SIGN_EXTRACT\n \t  || GET_CODE (SET_SRC (x)) == ZERO_EXTRACT)\n-\toptimize_bit_field (x, insn, 0);\n+\toptimize_bit_field (x, insn, NULL_PTR);\n \n       /* If SET_DEST is now a paradoxical SUBREG, put the result of this\n \t insn into a pseudo and store the low part of the pseudo into VAR. */\n@@ -1362,7 +1362,7 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \t\t    /* Make the change and see if the insn remains valid.  */\n \t\t    INSN_CODE (insn) = -1;\n \t\t    XEXP (outerdest, 0) = newmem;\n-\t\t    XEXP (outerdest, 2) = gen_rtx (CONST_INT, VOIDmode, pos);\n+\t\t    XEXP (outerdest, 2) = GEN_INT (pos);\n \t\t    \n \t\t    if (recog_memoized (insn) >= 0)\n \t\t      return;\n@@ -1867,7 +1867,7 @@ instantiate_virtual_regs (fndecl, insns)\n \t|| GET_CODE (insn) == CALL_INSN)\n       {\n \tinstantiate_virtual_regs_1 (&PATTERN (insn), insn, 1);\n-\tinstantiate_virtual_regs_1 (&REG_NOTES (insn), 0, 0);\n+\tinstantiate_virtual_regs_1 (&REG_NOTES (insn), NULL_RTX, 0);\n       }\n \n   /* Now instantiate the remaining register equivalences for debugging info.\n@@ -1904,11 +1904,13 @@ instantiate_decls (fndecl, valid_only)\n     {\n       if (DECL_RTL (decl) && GET_CODE (DECL_RTL (decl)) == MEM)\n \tinstantiate_virtual_regs_1 (&XEXP (DECL_RTL (decl), 0),\n-\t\t\t\t    valid_only ? DECL_RTL (decl) : 0, 0);\n+\t\t\t\t    (valid_only ? DECL_RTL (decl) : NULL_RTX),\n+\t\t\t\t    0);\n       if (DECL_INCOMING_RTL (decl)\n \t  && GET_CODE (DECL_INCOMING_RTL (decl)) == MEM)\n \tinstantiate_virtual_regs_1 (&XEXP (DECL_INCOMING_RTL (decl), 0),\n-\t\t\t\t    valid_only ? DECL_INCOMING_RTL (decl) : 0,\n+\t\t\t\t    (valid_only ? DECL_INCOMING_RTL (decl)\n+\t\t\t\t     : NULL_RTX),\n \t\t\t\t    0);\n     }\n \n@@ -1938,7 +1940,7 @@ instantiate_decls_1 (let, valid_only)\n   for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n     if (DECL_RTL (t) && GET_CODE (DECL_RTL (t)) == MEM)\n       instantiate_virtual_regs_1 (& XEXP (DECL_RTL (t), 0),\n-\t\t\t\t  valid_only ? DECL_RTL (t) : 0, 0);\n+\t\t\t\t  valid_only ? DECL_RTL (t) : NULL_RTX, 0);\n \n   /* Process all subblocks.  */\n   for (t = BLOCK_SUBBLOCKS (let); t; t = TREE_CHAIN (t))\n@@ -2023,10 +2025,10 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \n \t  start_sequence ();\n \t  if (GET_CODE (SET_SRC (x)) != REG)\n-\t    temp = force_operand (SET_SRC (x), 0);\n+\t    temp = force_operand (SET_SRC (x), NULL_RTX);\n \t  else\n \t    temp = SET_SRC (x);\n-\t  temp = force_operand (plus_constant (temp, offset), 0);\n+\t  temp = force_operand (plus_constant (temp, offset), NULL_RTX);\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n@@ -2128,7 +2130,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t\t  XEXP (x, 0) = old;\n \n \t\t  start_sequence ();\n-\t\t  temp = force_operand (new, 0);\n+\t\t  temp = force_operand (new, NULL_RTX);\n \t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \n@@ -2267,7 +2269,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t\treturn 0;\n \n \t      start_sequence ();\n-\t      temp = force_operand (temp, 0);\n+\t      temp = force_operand (temp, NULL_RTX);\n \t      seq = get_insns ();\n \t      end_sequence ();\n \n@@ -2490,7 +2492,7 @@ assign_parms (fndecl, second_time)\n     {\n       tree type = build_pointer_type (fntype);\n \n-      function_result_decl = build_decl (PARM_DECL, 0, type);\n+      function_result_decl = build_decl (PARM_DECL, NULL_TREE, type);\n \n       DECL_ARG_TYPE (function_result_decl) = type;\n       TREE_CHAIN (function_result_decl) = fnargs;\n@@ -2501,9 +2503,9 @@ assign_parms (fndecl, second_time)\n   bzero (parm_reg_stack_loc, nparmregs * sizeof (rtx));\n \n #ifdef INIT_CUMULATIVE_INCOMING_ARGS\n-  INIT_CUMULATIVE_INCOMING_ARGS (args_so_far, fntype, 0);\n+  INIT_CUMULATIVE_INCOMING_ARGS (args_so_far, fntype, NULL_PTR);\n #else\n-  INIT_CUMULATIVE_ARGS (args_so_far, fntype, 0);\n+  INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_PTR);\n #endif\n \n   /* We haven't yet found an argument that we must push and pretend the\n@@ -2849,7 +2851,7 @@ assign_parms (fndecl, second_time)\n \t\t  && REGNO (entry_parm) < FIRST_PSEUDO_REGISTER\n \t\t  && ! HARD_REGNO_MODE_OK (REGNO (entry_parm),\n \t\t\t\t\t   GET_MODE (entry_parm)))\n-\t\tconvert_move (parmreg, copy_to_reg (entry_parm));\n+\t\tconvert_move (parmreg, copy_to_reg (entry_parm), 0);\n \t      else\n \t\tconvert_move (parmreg, validize_mem (entry_parm), 0);\n \t    }\n@@ -2953,11 +2955,10 @@ assign_parms (fndecl, second_time)\n \n #ifdef ARGS_GROW_DOWNWARD\n   current_function_arg_offset_rtx\n-    = (stack_args_size.var == 0 ? gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t   -stack_args_size.constant)\n+    = (stack_args_size.var == 0 ? GEN_INT (-stack_args_size.constant)\n        : expand_expr (size_binop (MINUS_EXPR, stack_args_size.var,\t\n \t\t\t\t  size_int (-stack_args_size.constant)),   \n-\t\t      0, VOIDmode, 0));\n+\t\t      NULL_RTX, VOIDmode, 0));\n #else\n   current_function_arg_offset_rtx = ARGS_SIZE_RTX (stack_args_size);\n #endif\n@@ -3497,10 +3498,10 @@ round_trampoline_addr (tramp)\n   /* Round address up to desired boundary.  */\n   rtx temp = gen_reg_rtx (Pmode);\n   temp = expand_binop (Pmode, add_optab, tramp,\n-\t\t       gen_rtx (CONST_INT, VOIDmode, TRAMPOLINE_ALIGNMENT - 1),\n+\t\t       GEN_INT (TRAMPOLINE_ALIGNMENT - 1),\n \t\t       temp, 0, OPTAB_LIB_WIDEN);\n   tramp = expand_binop (Pmode, and_optab, temp,\n-\t\t\tgen_rtx (CONST_INT, VOIDmode, - TRAMPOLINE_ALIGNMENT),\n+\t\t\tGEN_INT (- TRAMPOLINE_ALIGNMENT),\n \t\t\ttemp, 0, OPTAB_LIB_WIDEN);\n #endif\n   return tramp;\n@@ -3615,7 +3616,7 @@ init_function_start (subr, filename, line)\n   /* Make sure first insn is a note even if we don't want linenums.\n      This makes sure the first insn will never be deleted.\n      Also, final expects a note to appear there.  */\n-  emit_note (0, NOTE_INSN_DELETED);\n+  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \n   /* Set flags used by final.c.  */\n   if (aggregate_value_p (DECL_RESULT (subr)))\n@@ -3795,12 +3796,12 @@ expand_function_start (subr, parms_have_cleanups)\n      The move is supposed to make sdb output more accurate.  */\n   /* Indicate the beginning of the function body,\n      as opposed to parm setup.  */\n-  emit_note (0, NOTE_INSN_FUNCTION_BEG);\n+  emit_note (NULL_PTR, NOTE_INSN_FUNCTION_BEG);\n \n   /* If doing stupid allocation, mark parms as born here.  */\n \n   if (GET_CODE (get_last_insn ()) != NOTE)\n-    emit_note (0, NOTE_INSN_DELETED);\n+    emit_note (NULL_PTR, NOTE_INSN_DELETED);\n   parm_birth_insn = get_last_insn ();\n \n   if (obey_regdecls)\n@@ -3841,11 +3842,11 @@ expand_function_start (subr, parms_have_cleanups)\n   /* After the display initializations is where the tail-recursion label\n      should go, if we end up needing one.   Ensure we have a NOTE here\n      since some things (like trampolines) get placed before this.  */\n-  tail_recursion_reentry = emit_note (0, NOTE_INSN_DELETED);\n+  tail_recursion_reentry = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \n   /* Evaluate now the sizes of any types declared among the arguments.  */\n   for (tem = nreverse (get_pending_sizes ()); tem; tem = TREE_CHAIN (tem))\n-    expand_expr (TREE_VALUE (tem), 0, VOIDmode, 0);\n+    expand_expr (TREE_VALUE (tem), NULL_RTX, VOIDmode, 0);\n \n   /* Make sure there is a line number after the function entry setup code.  */\n   force_next_line_note ();\n@@ -3905,8 +3906,7 @@ expand_function_end (filename, line)\n       start_sequence ();\n       tramp = change_address (initial_trampoline, BLKmode,\n \t\t\t      round_trampoline_addr (XEXP (tramp, 0)));\n-      emit_block_move (tramp, initial_trampoline,\n-\t\t       gen_rtx (CONST_INT, VOIDmode, TRAMPOLINE_SIZE),\n+      emit_block_move (tramp, initial_trampoline, GEN_INT (TRAMPOLINE_SIZE),\n \t\t       FUNCTION_BOUNDARY / BITS_PER_UNIT);\n       INITIALIZE_TRAMPOLINE (XEXP (tramp, 0),\n \t\t\t     XEXP (DECL_RTL (function), 0), context);\n@@ -3938,7 +3938,7 @@ expand_function_end (filename, line)\n \n   /* End any sequences that failed to be closed due to syntax errors.  */\n   while (in_sequence_p ())\n-    end_sequence (0);\n+    end_sequence ();\n \n   /* Outside function body, can't compute type's actual size\n      until next function's body starts.  */\n@@ -3971,7 +3971,7 @@ expand_function_end (filename, line)\n   /* Mark the end of the function body.\n      If control reaches this insn, the function can drop through\n      without returning a value.  */\n-  emit_note (0, NOTE_INSN_FUNCTION_END);\n+  emit_note (NULL_PTR, NOTE_INSN_FUNCTION_END);\n \n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */\n@@ -3997,7 +3997,7 @@ expand_function_end (filename, line)\n \trtx tem = 0;\n \n \temit_stack_save (SAVE_FUNCTION, &tem, parm_birth_insn);\n-\temit_stack_restore (SAVE_FUNCTION, tem, 0);\n+\temit_stack_restore (SAVE_FUNCTION, tem, NULL_RTX);\n       }\n \n   /* If scalar return value was computed in a pseudo-reg,\n@@ -4072,7 +4072,7 @@ expand_function_end (filename, line)\n   /* If you have any cleanups to do at this point,\n      and they need to create temporary variables,\n      then you will lose.  */\n-  fixup_gotos (0, 0, 0, get_insns (), 0);\n+  fixup_gotos (NULL_PTR, NULL_RTX, NULL_TREE, get_insns (), 0);\n }\n \f\n /* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */"}, {"sha": "10f75d1caab9dc5d90a489c2f1c6acad8a25b488", "filename": "gcc/genpeep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -106,7 +106,7 @@ gen_peephole (peep)\n       /* Walk the insn's pattern, remembering at all times the path\n \t down to the walking point.  */\n \n-      match_rtx (XVECEXP (peep, 0, i), 0, insn_code_number);\n+      match_rtx (XVECEXP (peep, 0, i), NULL_PTR, insn_code_number);\n     }\n \n   /* We get this far if the pattern matches."}, {"sha": "77c392f0c69b40ea569270bb55e96b118dd6795b", "filename": "gcc/halfpic.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fhalfpic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fhalfpic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.c?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -34,7 +34,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"tree.h\"\n #include \"rtl.h\"\n #include <stdio.h>\n-#include <string.h>\n #include \"obstack.h\"\n \n #define obstack_chunk_alloc xmalloc"}, {"sha": "4f9e03689d002778925ae079d1a7bcf5d418668a", "filename": "gcc/jump.c", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -1,5 +1,5 @@\n /* Optimize jump instructions, for GNU compiler.\n-   Copyright (C) 1987, 1988, 1989, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1991, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -368,8 +368,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  }\n \t\telse\n \t\t  XEXP (SET_SRC (PATTERN (stack_adjust_insn)), 1)\n-\t\t    = gen_rtx (CONST_INT, VOIDmode, \n-\t\t\t       stack_adjust_amount - total_pushed);\n+\t\t    = GEN_INT (stack_adjust_amount - total_pushed);\n \n \t\t/* Change the appropriate push insns to ordinary stores.  */\n \t\tp = insn;\n@@ -396,7 +395,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t    if (total_pushed < 0)\n \t\t      {\n \t\t\temit_insn_before (gen_add2_insn (stack_pointer_rtx,\n-\t\t\t\t\t\t\t gen_rtx (CONST_INT, VOIDmode, - total_pushed)),\n+\t\t\t\t\t\t\t GEN_INT (- total_pushed)),\n \t\t\t\t\t  p);\n \t\t\tbreak;\n \t\t      }\n@@ -433,8 +432,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\telse if (sreg >= 0 && dreg >= 0)\n \t\t  {\n \t\t    rtx trial;\n-\t\t    rtx tem = find_equiv_reg (0, insn, 0,\n-\t\t\t\t\t      sreg, 0, dreg,\n+\t\t    rtx tem = find_equiv_reg (NULL_RTX, insn, 0,\n+\t\t\t\t\t      sreg, NULL_PTR, dreg,\n \t\t\t\t\t      GET_MODE (SET_SRC (body)));\n \n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n@@ -463,8 +462,9 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t      }\n \t\t  }\n \t\telse if (dreg >= 0 && CONSTANT_P (SET_SRC (body))\n-\t\t\t && find_equiv_reg (SET_SRC (body), insn, 0, dreg, 0,\n-\t\t\t\t\t    0, GET_MODE (SET_DEST (body))))\n+\t\t\t && find_equiv_reg (SET_SRC (body), insn, 0, dreg,\n+\t\t\t\t\t    NULL_PTR, 0,\n+\t\t\t\t\t    GET_MODE (SET_DEST (body))))\n \t\t  {\n \t\t    /* This handles the case where we have two consecutive\n \t\t       assignments of the same constant to pseudos that didn't\n@@ -629,7 +629,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t     it into a RETURN insn, possibly a conditional one.  */\n \t  if (JUMP_LABEL (insn)\n \t      && next_active_insn (JUMP_LABEL (insn)) == 0)\n-\t    changed |= redirect_jump (insn, 0);\n+\t    changed |= redirect_jump (insn, NULL_RTX);\n \n \t  /* Detect jump to following insn.  */\n \t  if (reallabelprev == insn && condjump_p (insn))\n@@ -902,7 +902,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  if (normalizep != 1)\n \t\t    target = expand_and (yes, target,\n \t\t\t\t\t (GET_CODE (target) == REG\n-\t\t\t\t\t  ? target : 0));\n+\t\t\t\t\t  ? target : NULL_RTX));\n \t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (seq, temp5);\n@@ -1718,8 +1718,8 @@ duplicate_loop_exit_test (loop_start)\n \tcase JUMP_INSN:\n \tcase INSN:\n \t  if (++num_insns > 20\n-\t      || find_reg_note (insn, REG_RETVAL, 0)\n-\t      || find_reg_note (insn, REG_LIBCALL, 0))\n+\t      || find_reg_note (insn, REG_RETVAL, NULL_RTX)\n+\t      || find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n \t    return 0;\n \t  break;\n \t}\n@@ -1996,10 +1996,10 @@ find_cross_jump (e1, e2, minimum, f1, f2)\n \t  rtx equiv2;\n \n \t  if (!lose && GET_CODE (p1) == GET_CODE (p2)\n-\t      && ((equiv1 = find_reg_note (i1, REG_EQUAL, 0)) != 0\n-\t\t  || (equiv1 = find_reg_note (i1, REG_EQUIV, 0)) != 0)\n-\t      && ((equiv2 = find_reg_note (i2, REG_EQUAL, 0)) != 0\n-\t\t  || (equiv2 = find_reg_note (i2, REG_EQUIV, 0)) != 0)\n+\t      && ((equiv1 = find_reg_note (i1, REG_EQUAL, NULL_RTX)) != 0\n+\t\t  || (equiv1 = find_reg_note (i1, REG_EQUIV, NULL_RTX)) != 0)\n+\t      && ((equiv2 = find_reg_note (i2, REG_EQUAL, NULL_RTX)) != 0\n+\t\t  || (equiv2 = find_reg_note (i2, REG_EQUIV, NULL_RTX)) != 0)\n \t      /* If the equivalences are not to a constant, they may\n \t\t reference pseudos that no longer exist, so we can't\n \t\t use them.  */\n@@ -2743,7 +2743,7 @@ mark_jump_label (x, insn, cross_jump)\n \tint eltnum = code == ADDR_DIFF_VEC ? 1 : 0;\n \n \tfor (i = 0; i < XVECLEN (x, eltnum); i++)\n-\t  mark_jump_label (XVECEXP (x, eltnum, i), 0, cross_jump);\n+\t  mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX, cross_jump);\n \treturn;\n       }\n     }\n@@ -2788,7 +2788,7 @@ delete_jump (insn)\n \t  && sets_cc0_p (PATTERN (prev)))\n \t{\n \t  if (sets_cc0_p (PATTERN (prev)) > 0\n-\t      && !FIND_REG_INC_NOTE (prev, 0))\n+\t      && !FIND_REG_INC_NOTE (prev, NULL_RTX))\n \t    delete_insn (prev);\n \t  else\n \t    /* Otherwise, show that cc0 won't be used.  */\n@@ -2834,7 +2834,7 @@ delete_jump (insn)\n \n \t\tif (reg_set_p (XEXP (note, 0), PATTERN (our_prev)))\n \t\t  {\n-\t\t    if (FIND_REG_INC_NOTE (our_prev, 0))\n+\t\t    if (FIND_REG_INC_NOTE (our_prev, NULL_RTX))\n \t\t      break;\n \n \t\t    if (GET_CODE (PATTERN (our_prev)) == PARALLEL)\n@@ -3463,6 +3463,11 @@ rtx_renumbered_equal_p (x, y)\n       register int j;\n       switch (fmt[i])\n \t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))\n \t    return 0;\n@@ -3875,6 +3880,11 @@ rtx_equal_for_thread_p (x, y, yinsn)\n     {\n       switch (fmt[i])\n \t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'n':\n \tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))"}, {"sha": "8c0121bc6a7312c48f73fdd9637186f6f8ef5c42", "filename": "gcc/machmode.h", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -33,6 +33,34 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n #define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n \n+/* Find the largest host integer type and set its size and type.  */\n+\n+#ifndef HOST_BITS_PER_WIDE_INT\n+\n+#if HOST_BITS_PER_LONG > HOST_BITS_PER_INT\n+#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n+#define HOST_WIDE_INT long\n+#else\n+#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_INT\n+#define HOST_WIDE_INT int\n+#endif\n+\n+#endif\n+\n+/* Define the number of entries in an 8-bit `shorts' array needed to represent\n+   the largest supported constant, which is twice the width of the largest\n+   host integer type.  */\n+\n+#ifndef MAX_SHORTS\n+#define MAX_SHORTS (HOST_BITS_PER_WIDE_INT * 2 / 8)\n+#endif\n+\n+/* Provide a default way to print an address in hex via printf.  */\n+\n+#ifndef HOST_PTR_PRINTF\n+#define HOST_PTR_PRINTF sizeof (int) == sizeof (char *) ? \"%x\" : \"%lx\"\n+#endif\n+\n /* Make an enum class that gives all the machine modes.  */\n \n #define DEF_MACHMODE(SYM, NAME, TYPE, SIZE, UNIT, WIDER)  SYM,\n@@ -90,8 +118,8 @@ extern int mode_unit_size[];\n    that fit within mode MODE.  */\n \n #define GET_MODE_MASK(MODE)  \\\n-   ((GET_MODE_BITSIZE (MODE) >= HOST_BITS_PER_INT)  \\\n-    ? -1 : ((1 << GET_MODE_BITSIZE (MODE)) - 1))\n+   ((GET_MODE_BITSIZE (MODE) >= HOST_BITS_PER_WIDE_INT)  \\\n+    ?(HOST_WIDE_INT) ~0 : (((HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (MODE)) - 1))\n \n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n "}, {"sha": "c9d72517ef7a9511d45207981d3c75de74abb5f4", "filename": "gcc/rtl.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -464,7 +464,7 @@ DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ei\", 'x')\n    ---------------------------------------------------------------------- */\n \n /* numeric integer constant */\n-DEF_RTL_EXPR(CONST_INT, \"const_int\", \"i\", 'o')\n+DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", 'o')\n \n /* numeric double constant.\n    Operand 0 is the MEM that stores this constant in memory,\n@@ -473,7 +473,7 @@ DEF_RTL_EXPR(CONST_INT, \"const_int\", \"i\", 'o')\n    Remaining operands hold the actual value.\n    The number of operands may be more than 2 if cross-compiling;\n    see init_rtl.  */\n-DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", \"e0ii\", 'o')\n+DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", \"e0ww\", 'o')\n \n /* String constant.  Used only for attributes right now.  */\n DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", 'o')"}, {"sha": "f4712f639bf062d4d95f66f1b4cf7c9582466809", "filename": "gcc/rtl.h", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "patch": "@@ -55,6 +55,7 @@ extern char rtx_class[];\n \n typedef union rtunion_def\n {\n+  HOST_WIDE_INT rtwint;\n   int rtint;\n   char *rtstr;\n   struct rtx_def *rtx;\n@@ -132,6 +133,16 @@ typedef struct rtx_def\n \n #define NULL_RTX (rtx) 0\n \n+/* Define a generic NULL if one hasn't already been defined.  */\n+\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+#ifndef NULL_PTR\n+#define NULL_PTR (char *) NULL\n+#endif\n+\n /* Define macros to access the `code' field of the rtx.  */\n \n #ifdef SHORT_ENUM_BUG\n@@ -179,6 +190,7 @@ typedef struct rtvec_def{\n \n #define XEXP(RTX, N)\t((RTX)->fld[N].rtx)\n #define XINT(RTX, N)\t((RTX)->fld[N].rtint)\n+#define XWINT(RTX, N)\t((RTX)->fld[N].rtwint)\n #define XSTR(RTX, N)\t((RTX)->fld[N].rtstr)\n #define XVEC(RTX, N)\t((RTX)->fld[N].rtvec)\n #define XVECLEN(RTX, N)\t((RTX)->fld[N].rtvec->num_elem)\n@@ -399,7 +411,7 @@ extern char *note_insn_name[];\n \n /* For a CONST_INT rtx, INTVAL extracts the integer.  */\n \n-#define INTVAL(RTX) ((RTX)->fld[0].rtint)\n+#define INTVAL(RTX) ((RTX)->fld[0].rtwint)\n \n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n    SUBREG_WORD extracts the word-number.  */\n@@ -532,17 +544,36 @@ extern char *note_insn_name[];\n \f\n /* Generally useful functions.  */\n \n+/* The following functions accept a wide integer argument.  Rather than\n+   having to cast on every function call, we use a macro instead, that is\n+   defined here and in tree.h.  */\n+\n+#ifndef exact_log2\n+#define exact_log2(N) exact_log2_wide ((HOST_WIDE_INT) (N))\n+#define floor_log2(N) floor_log2_wide ((HOST_WIDE_INT) (N))\n+#endif\n+\n+#define plus_constant(X,C) plus_constant_wide (X, (HOST_WIDE_INT) (C))\n+\n+#define plus_constant_for_output(X,C)  \\\n+  plus_constant_for_output_wide (X, (HOST_WIDE_INT) (C))\n+\n+extern rtx plus_constant_wide (), plus_constant_for_output_wide ();\n+\n+#define GEN_INT(N) gen_rtx (CONST_INT, VOIDmode, (N))\n+\n+extern rtx gen_rtx ();\n+\n extern char *xmalloc ();\n extern void free ();\n extern rtx rtx_alloc ();\n extern rtvec rtvec_alloc ();\n extern rtx find_reg_note ();\n extern rtx find_regno_note ();\n-extern int get_integer_term ();\n+extern HOST_WIDE_INT get_integer_term ();\n extern rtx get_related_value ();\n extern rtx single_set ();\n extern rtx find_last_value ();\n-extern rtx gen_rtx ();\n extern rtx copy_rtx ();\n extern rtx copy_rtx_if_shared ();\n extern rtx copy_most_rtx ();\n@@ -623,7 +654,6 @@ extern enum rtx_code reverse_condition ();\n extern enum rtx_code swap_condition ();\n extern enum rtx_code unsigned_condition ();\n extern enum rtx_code signed_condition ();\n-extern rtx plus_constant (), plus_constant_for_output ();\n extern rtx find_equiv_reg ();\n extern rtx squeeze_notes ();\n extern rtx delete_insn ();"}]}