{"sha": "e7140c8da2bb3dd863bb5f43638d066462a82287", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcxNDBjOGRhMmJiM2RkODYzYmI1ZjQzNjM4ZDA2NjQ2MmE4MjI4Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-02-26T11:01:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-02-26T11:01:28Z"}, "message": "re PR debug/43161 (Wrong debug info in guality/vla-1.c (f2))\n\n\tPR debug/43161\n\t* regcprop.c (struct queued_debug_insn_change): New type.\n\t(struct value_data_entry): Add debug_insn_changes field.\n\t(struct value_data): Add n_debug_insn_changes field.\n\t(debug_insn_changes_pool): New variable.\n\t(free_debug_insn_changes, apply_debug_insn_changes,\n\tcprop_find_used_regs_1, cprop_find_used_regs): New functions.\n\t(kill_value_one_regno): Call free_debug_insn_changes if needed.\n\t(init_value_data): Clear debug_insn_changes and n_debug_insn_changes\n\tfields.\n\t(replace_oldest_value_reg): Don't change DEBUG_INSNs, instead queue\n\tchanges for them.\n\t(copyprop_hardreg_forward_1): Don't call apply_change_group for\n\tDEBUG_INSNs.  For a real insn, if there are queued DEBUG_INSN\n\tchanges, call cprop_find_used_regs via note_stores.\n\t(copyprop_hardreg_forward): When copying vd from predecessor\n\twhich has any queued DEBUG_INSN changes, make sure the pointers are\n\tcleared.  At the end call df_analyze and then if there are any\n\tDEBUG_INSN changes queued at the end of some basic block for still\n\tlive registers, apply them.\n\t(pass_cprop_hardreg): Set TODO_df_finish in todo_flags_finish.\n\nFrom-SVN: r157083", "tree": {"sha": "fa702f56527bb502176978eaa062fe31ff745b7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa702f56527bb502176978eaa062fe31ff745b7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7140c8da2bb3dd863bb5f43638d066462a82287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7140c8da2bb3dd863bb5f43638d066462a82287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7140c8da2bb3dd863bb5f43638d066462a82287", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7140c8da2bb3dd863bb5f43638d066462a82287/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "894b386f8e2c0c50d33bfb26cb0a9053c496a78f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894b386f8e2c0c50d33bfb26cb0a9053c496a78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894b386f8e2c0c50d33bfb26cb0a9053c496a78f"}], "stats": {"total": 202, "additions": 191, "deletions": 11}, "files": [{"sha": "dd79be31e89558dcfd8cb07c453ed49e4360bbc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7140c8da2bb3dd863bb5f43638d066462a82287/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7140c8da2bb3dd863bb5f43638d066462a82287/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7140c8da2bb3dd863bb5f43638d066462a82287", "patch": "@@ -1,3 +1,27 @@\n+2010-02-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43161\n+\t* regcprop.c (struct queued_debug_insn_change): New type.\n+\t(struct value_data_entry): Add debug_insn_changes field.\n+\t(struct value_data): Add n_debug_insn_changes field.\n+\t(debug_insn_changes_pool): New variable.\n+\t(free_debug_insn_changes, apply_debug_insn_changes,\n+\tcprop_find_used_regs_1, cprop_find_used_regs): New functions.\n+\t(kill_value_one_regno): Call free_debug_insn_changes if needed.\n+\t(init_value_data): Clear debug_insn_changes and n_debug_insn_changes\n+\tfields.\n+\t(replace_oldest_value_reg): Don't change DEBUG_INSNs, instead queue\n+\tchanges for them.\n+\t(copyprop_hardreg_forward_1): Don't call apply_change_group for\n+\tDEBUG_INSNs.  For a real insn, if there are queued DEBUG_INSN\n+\tchanges, call cprop_find_used_regs via note_stores.\n+\t(copyprop_hardreg_forward): When copying vd from predecessor\n+\twhich has any queued DEBUG_INSN changes, make sure the pointers are\n+\tcleared.  At the end call df_analyze and then if there are any\n+\tDEBUG_INSN changes queued at the end of some basic block for still\n+\tlive registers, apply them.\n+\t(pass_cprop_hardreg): Set TODO_df_finish in todo_flags_finish.\n+\n 2010-02-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config.gcc (i[34567]86-*-* | x86_64-*-*): Split long line."}, {"sha": "2666f78538949883ef7010bbd27a247b7f9b1bf2", "filename": "gcc/regcprop.c", "status": "modified", "additions": 167, "deletions": 11, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7140c8da2bb3dd863bb5f43638d066462a82287/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7140c8da2bb3dd863bb5f43638d066462a82287/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=e7140c8da2bb3dd863bb5f43638d066462a82287", "patch": "@@ -46,6 +46,18 @@\n    up some silly register allocation decisions made by reload.  This\n    code may be obsoleted by a new register allocator.  */\n \n+/* DEBUG_INSNs aren't changed right away, as doing so might extend the\n+   lifetime of a register and get the DEBUG_INSN subsequently reset.\n+   So they are queued instead, and updated only when the register is\n+   used in some subsequent real insn before it is set.  */\n+struct queued_debug_insn_change\n+{\n+  struct queued_debug_insn_change *next;\n+  rtx insn;\n+  rtx *loc;\n+  rtx new_rtx;\n+};\n+\n /* For each register, we have a list of registers that contain the same\n    value.  The OLDEST_REGNO field points to the head of the list, and\n    the NEXT_REGNO field runs through the list.  The MODE field indicates\n@@ -57,14 +69,18 @@ struct value_data_entry\n   enum machine_mode mode;\n   unsigned int oldest_regno;\n   unsigned int next_regno;\n+  struct queued_debug_insn_change *debug_insn_changes;\n };\n \n struct value_data\n {\n   struct value_data_entry e[FIRST_PSEUDO_REGISTER];\n   unsigned int max_value_regs;\n+  unsigned int n_debug_insn_changes;\n };\n \n+static alloc_pool debug_insn_changes_pool;\n+\n static void kill_value_one_regno (unsigned, struct value_data *);\n static void kill_value_regno (unsigned, unsigned, struct value_data *);\n static void kill_value (rtx, struct value_data *);\n@@ -91,6 +107,22 @@ extern void debug_value_data (struct value_data *);\n static void validate_value_data (struct value_data *);\n #endif\n \n+/* Free all queued updates for DEBUG_INSNs that change some reg to\n+   register REGNO.  */\n+\n+static void\n+free_debug_insn_changes (struct value_data *vd, unsigned int regno)\n+{\n+  struct queued_debug_insn_change *cur, *next;\n+  for (cur = vd->e[regno].debug_insn_changes; cur; cur = next)\n+    {\n+      next = cur->next;\n+      --vd->n_debug_insn_changes;\n+      pool_free (debug_insn_changes_pool, cur);\n+    }\n+  vd->e[regno].debug_insn_changes = NULL;\n+}\n+\n /* Kill register REGNO.  This involves removing it from any value\n    lists, and resetting the value mode to VOIDmode.  This is only a\n    helper function; it does not handle any hard registers overlapping\n@@ -118,6 +150,8 @@ kill_value_one_regno (unsigned int regno, struct value_data *vd)\n   vd->e[regno].mode = VOIDmode;\n   vd->e[regno].oldest_regno = regno;\n   vd->e[regno].next_regno = INVALID_REGNUM;\n+  if (vd->e[regno].debug_insn_changes)\n+    free_debug_insn_changes (vd, regno);\n \n #ifdef ENABLE_CHECKING\n   validate_value_data (vd);\n@@ -204,8 +238,10 @@ init_value_data (struct value_data *vd)\n       vd->e[i].mode = VOIDmode;\n       vd->e[i].oldest_regno = i;\n       vd->e[i].next_regno = INVALID_REGNUM;\n+      vd->e[i].debug_insn_changes = NULL;\n     }\n   vd->max_value_regs = 0;\n+  vd->n_debug_insn_changes = 0;\n }\n \n /* Called through note_stores.  If X is clobbered, kill its value.  */\n@@ -446,6 +482,24 @@ replace_oldest_value_reg (rtx *loc, enum reg_class cl, rtx insn,\n   rtx new_rtx = find_oldest_value_reg (cl, *loc, vd);\n   if (new_rtx)\n     {\n+      if (DEBUG_INSN_P (insn))\n+\t{\n+\t  struct queued_debug_insn_change *change;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"debug_insn %u: queued replacing reg %u with %u\\n\",\n+\t\t     INSN_UID (insn), REGNO (*loc), REGNO (new_rtx));\n+\n+\t  change = (struct queued_debug_insn_change *)\n+\t\t   pool_alloc (debug_insn_changes_pool);\n+\t  change->next = vd->e[REGNO (new_rtx)].debug_insn_changes;\n+\t  change->insn = insn;\n+\t  change->loc = loc;\n+\t  change->new_rtx = new_rtx;\n+\t  vd->e[REGNO (new_rtx)].debug_insn_changes = change;\n+\t  ++vd->n_debug_insn_changes;\n+\t  return true;\n+\t}\n       if (dump_file)\n \tfprintf (dump_file, \"insn %u: replaced reg %u with %u\\n\",\n \t\t INSN_UID (insn), REGNO (*loc), REGNO (new_rtx));\n@@ -622,6 +676,58 @@ replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n \t\t\t\t    GET_MODE (x), insn, vd);\n }\n \n+/* Apply all queued updates for DEBUG_INSNs that change some reg to\n+   register REGNO.  */\n+\n+static void\n+apply_debug_insn_changes (struct value_data *vd, unsigned int regno)\n+{\n+  struct queued_debug_insn_change *change;\n+  rtx last_insn = vd->e[regno].debug_insn_changes->insn;\n+\n+  for (change = vd->e[regno].debug_insn_changes;\n+       change;\n+       change = change->next)\n+    {\n+      if (last_insn != change->insn)\n+\t{\n+\t  apply_change_group ();\n+\t  last_insn = change->insn;\n+\t}\n+      validate_change (change->insn, change->loc, change->new_rtx, 1);\n+    }\n+  apply_change_group ();\n+}\n+\n+/* Called via for_each_rtx, for all used registers in a real\n+   insn apply DEBUG_INSN changes that change registers to the\n+   used register.  */\n+\n+static int\n+cprop_find_used_regs_1 (rtx *loc, void *data)\n+{\n+  if (REG_P (*loc))\n+    {\n+      struct value_data *vd = (struct value_data *) data;\n+      if (vd->e[REGNO (*loc)].debug_insn_changes)\n+\t{\n+\t  apply_debug_insn_changes (vd, REGNO (*loc));\n+\t  free_debug_insn_changes (vd, REGNO (*loc));\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Called via note_uses, for all used registers in a real insn\n+   apply DEBUG_INSN changes that change registers to the used\n+   registers.  */\n+\n+static void\n+cprop_find_used_regs (rtx *loc, void *vd)\n+{\n+  for_each_rtx (loc, cprop_find_used_regs_1, vd);\n+}\n+\n /* Perform the forward copy propagation on basic block BB.  */\n \n static bool\n@@ -643,15 +749,10 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  if (DEBUG_INSN_P (insn))\n \t    {\n \t      rtx loc = INSN_VAR_LOCATION_LOC (insn);\n-\t      if (!VAR_LOC_UNKNOWN_P (loc)\n-\t\t  && replace_oldest_value_addr (&INSN_VAR_LOCATION_LOC (insn),\n-\t\t\t\t\t\tALL_REGS, GET_MODE (loc),\n-\t\t\t\t\t\tinsn, vd))\n-\t\t{\n-\t\t  changed = apply_change_group ();\n-\t\t  gcc_assert (changed);\n-\t\t  anything_changed = true;\n-\t\t}\n+\t      if (!VAR_LOC_UNKNOWN_P (loc))\n+\t\treplace_oldest_value_addr (&INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t\t\t   ALL_REGS, GET_MODE (loc),\n+\t\t\t\t\t   insn, vd);\n \t    }\n \n \t  if (insn == BB_END (bb))\n@@ -684,6 +785,10 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t    recog_data.operand_type[i] = OP_INOUT;\n \t}\n \n+      /* Apply changes to earlier DEBUG_INSNs if possible.  */\n+      if (vd->n_debug_insn_changes)\n+\tnote_uses (&PATTERN (insn), cprop_find_used_regs, vd);\n+\n       /* For each earlyclobber operand, zap the value data.  */\n       for (i = 0; i < n_ops; i++)\n \tif (recog_op_alt[i][alt].earlyclobber)\n@@ -871,12 +976,18 @@ copyprop_hardreg_forward (void)\n   struct value_data *all_vd;\n   basic_block bb;\n   sbitmap visited;\n+  bool analyze_called = false;\n \n   all_vd = XNEWVEC (struct value_data, last_basic_block);\n \n   visited = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (visited);\n \n+  if (MAY_HAVE_DEBUG_STMTS)\n+    debug_insn_changes_pool\n+      = create_alloc_pool (\"debug insn changes pool\",\n+\t\t\t   sizeof (struct queued_debug_insn_change), 256);\n+\n   FOR_EACH_BB (bb)\n     {\n       SET_BIT (visited, bb->index);\n@@ -888,13 +999,57 @@ copyprop_hardreg_forward (void)\n       if (single_pred_p (bb)\n \t  && TEST_BIT (visited, single_pred (bb)->index)\n \t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n-\tall_vd[bb->index] = all_vd[single_pred (bb)->index];\n+\t{\n+\t  all_vd[bb->index] = all_vd[single_pred (bb)->index];\n+\t  if (all_vd[bb->index].n_debug_insn_changes)\n+\t    {\n+\t      unsigned int regno;\n+\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\t{\n+\t\t  if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t\t    {\n+\t\t      all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n+\t\t      if (--all_vd[bb->index].n_debug_insn_changes == 0)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n       else\n \tinit_value_data (all_vd + bb->index);\n \n       copyprop_hardreg_forward_1 (bb, all_vd + bb->index);\n     }\n \n+  if (MAY_HAVE_DEBUG_STMTS)\n+    {\n+      FOR_EACH_BB (bb)\n+\tif (TEST_BIT (visited, bb->index)\n+\t    && all_vd[bb->index].n_debug_insn_changes)\n+\t  {\n+\t    unsigned int regno;\n+\t    bitmap live;\n+\n+\t    if (!analyze_called)\n+\t      {\n+\t\tdf_analyze ();\n+\t\tanalyze_called = true;\n+\t      }\n+\t    live = df_get_live_out (bb);\n+\t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t      if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t\t{\n+\t\t  if (REGNO_REG_SET_P (live, regno))\n+\t\t    apply_debug_insn_changes (all_vd + bb->index, regno);\n+\t\t  if (all_vd[bb->index].n_debug_insn_changes == 0)\n+\t\t    break;\n+\t\t}\n+\t  }\n+\n+      free_alloc_pool (debug_insn_changes_pool);\n+    }\n+\n   sbitmap_free (visited);\n   free (all_vd);\n   return 0;\n@@ -1026,6 +1181,7 @@ struct rtl_opt_pass pass_cprop_hardreg =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  TODO_dump_func | TODO_verify_rtl_sharing /* todo_flags_finish */\n+  TODO_dump_func | TODO_df_finish\n+  | TODO_verify_rtl_sharing\t\t/* todo_flags_finish */\n  }\n };"}]}