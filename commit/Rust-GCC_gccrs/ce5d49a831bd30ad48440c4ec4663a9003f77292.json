{"sha": "ce5d49a831bd30ad48440c4ec4663a9003f77292", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U1ZDQ5YTgzMWJkMzBhZDQ4NDQwYzRlYzQ2NjNhOTAwM2Y3NzI5Mg==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@linaro.org", "date": "2013-10-31T06:20:20Z"}, "committer": {"name": "Zhenqiang Chen", "email": "zqchen@gcc.gnu.org", "date": "2013-10-31T06:20:20Z"}, "message": "lower-subreg.c (resolve_simple_move): Copy REG_INC note.\n\ngcc/ChangeLog:\n2013-10-31  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n\n\t* lower-subreg.c (resolve_simple_move): Copy REG_INC note.\n\ngcc/testsuite/ChangeLog:\n2013-10-31  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n\n\t* gcc.target/arm/lp1243022.c: New test.\n\nFrom-SVN: r204247", "tree": {"sha": "017e4e241988e199d429099251dce1c10d593401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/017e4e241988e199d429099251dce1c10d593401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce5d49a831bd30ad48440c4ec4663a9003f77292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce5d49a831bd30ad48440c4ec4663a9003f77292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce5d49a831bd30ad48440c4ec4663a9003f77292", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce5d49a831bd30ad48440c4ec4663a9003f77292/comments", "author": null, "committer": null, "parents": [{"sha": "8c1a9d4d380e155c44fdacf75c3c89decc777b3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1a9d4d380e155c44fdacf75c3c89decc777b3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1a9d4d380e155c44fdacf75c3c89decc777b3a"}], "stats": {"total": 232, "additions": 232, "deletions": 0}, "files": [{"sha": "fab5bc5c0eadf61710dbfbf802ab38a34dbf62d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce5d49a831bd30ad48440c4ec4663a9003f77292", "patch": "@@ -1,3 +1,7 @@\n+2013-10-31  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n+\n+\t* lower-subreg.c (resolve_simple_move): Copy REG_INC note.\n+\n 2013-10-30  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR bootstrap/58933"}, {"sha": "e67bc35648bceb039eef1959d50a491f3c9b7875", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=ce5d49a831bd30ad48440c4ec4663a9003f77292", "patch": "@@ -967,7 +967,20 @@ resolve_simple_move (rtx set, rtx insn)\n       rtx reg;\n \n       reg = gen_reg_rtx (orig_mode);\n+\n+#ifdef AUTO_INC_DEC\n+      {\n+\trtx move = emit_move_insn (reg, src);\n+\tif (MEM_P (src))\n+\t  {\n+\t    rtx note = find_reg_note (insn, REG_INC, NULL_RTX);\n+\t    if (note)\n+\t      add_reg_note (move, REG_INC, XEXP (note, 0));\n+\t  }\n+      }\n+#else\n       emit_move_insn (reg, src);\n+#endif\n       src = reg;\n     }\n \n@@ -1057,6 +1070,16 @@ resolve_simple_move (rtx set, rtx insn)\n \tmdest = simplify_gen_subreg (orig_mode, dest, GET_MODE (dest), 0);\n       minsn = emit_move_insn (real_dest, mdest);\n \n+#ifdef AUTO_INC_DEC\n+  if (MEM_P (real_dest)\n+      && !(resolve_reg_p (real_dest) || resolve_subreg_p (real_dest)))\n+    {\n+      rtx note = find_reg_note (insn, REG_INC, NULL_RTX);\n+      if (note)\n+\tadd_reg_note (minsn, REG_INC, XEXP (note, 0));\n+    }\n+#endif\n+\n       smove = single_set (minsn);\n       gcc_assert (smove != NULL_RTX);\n "}, {"sha": "4c722e7faa131448e09ba8164cd0810f9b1f9696", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce5d49a831bd30ad48440c4ec4663a9003f77292", "patch": "@@ -1,3 +1,7 @@\n+2013-10-31  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n+\n+\t* gcc.target/arm/lp1243022.c: New test.\n+\n 2013-10-30  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR other/58545"}, {"sha": "91a544d1b7d4c1e1ac987ae433022c1de735c245", "filename": "gcc/testsuite/gcc.target/arm/lp1243022.c", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Flp1243022.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce5d49a831bd30ad48440c4ec4663a9003f77292/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Flp1243022.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Flp1243022.c?ref=ce5d49a831bd30ad48440c4ec4663a9003f77292", "patch": "@@ -0,0 +1,201 @@\n+/* { dg-do compile { target arm_thumb2 } } */\n+/* { dg-options \"-O2 -fdump-rtl-subreg2\" } */\n+\n+/* { dg-final { scan-rtl-dump \"REG_INC\" \"subreg2\" } } */\n+/* { dg-final { cleanup-rtl-dump \"subreg2\" } } */\n+struct device;\n+typedef unsigned int __u32;\n+typedef unsigned long long u64;\n+typedef __u32 __le32;\n+typedef u64 dma_addr_t;\n+typedef unsigned gfp_t;\n+int dev_warn (const struct device *dev, const char *fmt, ...);\n+struct usb_bus\n+{\n+    struct device *controller;\n+};\n+struct usb_hcd\n+{\n+    struct usb_bus self;\n+};\n+struct xhci_generic_trb\n+{\n+    __le32 field[4];\n+};\n+union xhci_trb\n+{\n+    struct xhci_generic_trb generic;\n+};\n+struct xhci_segment\n+{\n+    union xhci_trb *trbs;\n+    dma_addr_t dma;\n+};\n+struct xhci_ring\n+{\n+    struct xhci_segment *first_seg;\n+};\n+struct xhci_hcd\n+{\n+    struct xhci_ring *cmd_ring;\n+    struct xhci_ring *event_ring;\n+};\n+struct usb_hcd *xhci_to_hcd (struct xhci_hcd *xhci)\n+{\n+}\n+dma_addr_t xhci_trb_virt_to_dma (struct xhci_segment * seg,\n+\t\t\t\t union xhci_trb * trb);\n+struct xhci_segment *trb_in_td (struct xhci_segment *start_seg,\n+\t\t\t\tdma_addr_t suspect_dma);\n+xhci_test_trb_in_td (struct xhci_hcd *xhci, struct xhci_segment *input_seg,\n+\t\t     union xhci_trb *start_trb, union xhci_trb *end_trb,\n+\t\t     dma_addr_t input_dma, struct xhci_segment *result_seg,\n+\t\t     char *test_name, int test_number)\n+{\n+    unsigned long long start_dma;\n+    unsigned long long end_dma;\n+    struct xhci_segment *seg;\n+    start_dma = xhci_trb_virt_to_dma (input_seg, start_trb);\n+    end_dma = xhci_trb_virt_to_dma (input_seg, end_trb);\n+    {\n+        dev_warn (xhci_to_hcd (xhci)->self.controller,\n+                  \"%d\\n\", test_number);\n+        dev_warn (xhci_to_hcd (xhci)->self.controller,\n+                  \"Expected seg %p, got seg %p\\n\", result_seg, seg);\n+    }\n+}\n+xhci_check_trb_in_td_math (struct xhci_hcd *xhci, gfp_t mem_flags)\n+{\n+    struct\n+    {\n+        dma_addr_t input_dma;\n+        struct xhci_segment *result_seg;\n+    }\n+    simple_test_vector[] =\n+        {\n+            {\n+                0, ((void *) 0)\n+            }\n+            ,\n+            {\n+                xhci->event_ring->first_seg->dma - 16, ((void *) 0)}\n+            ,\n+            {\n+                xhci->event_ring->first_seg->dma - 1, ((void *) 0)}\n+            ,\n+            {\n+                xhci->event_ring->first_seg->dma, xhci->event_ring->first_seg}\n+            ,\n+            {\n+                xhci->event_ring->first_seg->dma + (64 - 1) * 16,\n+                xhci->event_ring->first_seg\n+            }\n+            ,\n+            {\n+                xhci->event_ring->first_seg->dma + (64 - 1) * 16 + 1, ((void *) 0)}\n+            ,\n+            {\n+                xhci->event_ring->first_seg->dma + (64) * 16, ((void *) 0)}\n+            ,\n+            {\n+                (dma_addr_t) (~0), ((void *) 0)\n+            }\n+        };\n+    struct\n+    {\n+        struct xhci_segment *input_seg;\n+        union xhci_trb *start_trb;\n+        union xhci_trb *end_trb;\n+        dma_addr_t input_dma;\n+        struct xhci_segment *result_seg;\n+    }\n+    complex_test_vector[] =\n+        {\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                xhci->event_ring->first_seg->trbs,.end_trb =\n+                &xhci->event_ring->first_seg->trbs[64 - 1],.input_dma =\n+                xhci->cmd_ring->first_seg->dma,.result_seg = ((void *) 0),\n+            }\n+            ,\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                xhci->event_ring->first_seg->trbs,.end_trb =\n+                &xhci->cmd_ring->first_seg->trbs[64 - 1],.input_dma =\n+                xhci->cmd_ring->first_seg->dma,.result_seg = ((void *) 0),\n+            }\n+            ,\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                xhci->cmd_ring->first_seg->trbs,.end_trb =\n+                &xhci->cmd_ring->first_seg->trbs[64 - 1],.input_dma =\n+                xhci->cmd_ring->first_seg->dma,.result_seg = ((void *) 0),\n+            }\n+            ,\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                &xhci->event_ring->first_seg->trbs[0],.end_trb =\n+                &xhci->event_ring->first_seg->trbs[3],.input_dma =\n+                xhci->event_ring->first_seg->dma + 4 * 16,.result_seg = ((void *) 0),\n+            }\n+            ,\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                &xhci->event_ring->first_seg->trbs[3],.end_trb =\n+                &xhci->event_ring->first_seg->trbs[6],.input_dma =\n+                xhci->event_ring->first_seg->dma + 2 * 16,.result_seg = ((void *) 0),\n+            }\n+            ,\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                &xhci->event_ring->first_seg->trbs[64 - 3],.end_trb =\n+                &xhci->event_ring->first_seg->trbs[1],.input_dma =\n+                xhci->event_ring->first_seg->dma + 2 * 16,.result_seg = ((void *) 0),\n+            }\n+            ,\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                &xhci->event_ring->first_seg->trbs[64 - 3],.end_trb =\n+                &xhci->event_ring->first_seg->trbs[1],.input_dma =\n+                xhci->event_ring->first_seg->dma + (64 - 4) * 16,.result_seg =\n+                ((void *) 0),\n+            }\n+            ,\n+            {\n+                .input_seg = xhci->event_ring->first_seg,.start_trb =\n+                &xhci->event_ring->first_seg->trbs[64 - 3],.end_trb =\n+                &xhci->event_ring->first_seg->trbs[1],.input_dma =\n+                xhci->cmd_ring->first_seg->dma + 2 * 16,.result_seg = ((void *) 0),\n+            }\n+        };\n+    unsigned int num_tests;\n+    int i, ret;\n+    num_tests =\n+        (sizeof (simple_test_vector) / sizeof ((simple_test_vector)[0]) +\n+         (sizeof (struct\n+             {\n+         }\n+             )));\n+    for (i = 0; i < num_tests; i++)\n+    {\n+        ret =\n+            xhci_test_trb_in_td (xhci, xhci->event_ring->first_seg,\n+                                 xhci->event_ring->first_seg->trbs,\n+                                 &xhci->event_ring->first_seg->trbs[64 - 1],\n+                                 simple_test_vector[i].input_dma,\n+                                 simple_test_vector[i].result_seg, \"Simple\", i);\n+        if (ret < 0)\n+            return ret;\n+    }\n+    for (i = 0; i < num_tests; i++)\n+    {\n+        ret =\n+            xhci_test_trb_in_td (xhci, complex_test_vector[i].input_seg,\n+                                 complex_test_vector[i].start_trb,\n+                                 complex_test_vector[i].end_trb,\n+                                 complex_test_vector[i].input_dma,\n+                                 complex_test_vector[i].result_seg, \"Complex\", i);\n+        if (ret < 0)\n+            return ret;\n+    }\n+}"}]}