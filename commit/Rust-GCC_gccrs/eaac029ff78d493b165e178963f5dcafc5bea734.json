{"sha": "eaac029ff78d493b165e178963f5dcafc5bea734", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFhYzAyOWZmNzhkNDkzYjE2NWUxNzg5NjNmNWRjYWZjNWJlYTczNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-12-12T21:10:35Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-12-12T21:10:35Z"}, "message": "sparc.h (TARGET_SUPPORTS_WIDE_INT): Define to 1.\n\n\t* config/sparc/sparc.h (TARGET_SUPPORTS_WIDE_INT): Define to 1.\n\t* config/sparc/sparc.c (sparc_emit_set_const64): Remove code\n\tconditionalized on HOST_BITS_PER_WIDE_INT == 32.\n\t(sparc_cannot_force_const_mem) <CONST_WIDE_INT>: New case.\n\t<CONST_DOUBLE>: Remove VOIDmode test.\n\t(epilogue_renumber) <CONST_WIDE_INT>: New case.\n\t(sparc_print_operand): Remove support for CONST_DOUBLE with VOIDmode.\n\t(sparc_assemble_integer): Likewise.\n\t(set_extends): Likewise.\n\t(sparc_rtx_costs) <CONST_INT>: Use SMALL_INT.\n\t<CONST_WIDE_INT>: New case.\n\t<CONST_DOUBLE>: Remove support for VOIDmode.\n\t<MULT>: Remove support for CONST_DOUBLE with VOIDmode.\n\t* config/sparc/predicates.md (const_zero_operand): Add const_wide_int.\n\t(const_all_ones_operand): Likewise.\n\t(uns_small_int_operand): Remove const_double and code conditionalized\n\ton HOST_BITS_PER_WIDE_INT == 32.\n\t(arith_double_operand): Likewise.\n\t(arith_double_add_operand): Likewise.\n\t(input_operand): Remove support for CONST_DOUBLE with DImode.\n\t* config/sparc/sparc.md (DImode CONST_INT splitter): Remove code\n\tconditionalized on HOST_BITS_PER_WIDE_INT == 32.\n\t(DFmode CONST_DOUBLE splitter): Likewise.\n\t(*adddi3_insn_sp32): Likewise.\n\t(*subdi3_insn_sp32): Likewise.\n\t(DImode logical splitter): Likewise.\n\t(DImode CONST_DOUBLE splitter): Delete.\n\nFrom-SVN: r231586", "tree": {"sha": "6af2d65f9079b059e009932928bdcbeaa3b1e2f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6af2d65f9079b059e009932928bdcbeaa3b1e2f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaac029ff78d493b165e178963f5dcafc5bea734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaac029ff78d493b165e178963f5dcafc5bea734", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaac029ff78d493b165e178963f5dcafc5bea734", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaac029ff78d493b165e178963f5dcafc5bea734/comments", "author": null, "committer": null, "parents": [{"sha": "460263d0ef85e47cff2f39181a06d1d235ad4df7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460263d0ef85e47cff2f39181a06d1d235ad4df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/460263d0ef85e47cff2f39181a06d1d235ad4df7"}], "stats": {"total": 248, "additions": 73, "deletions": 175}, "files": [{"sha": "fb2bf2f77d47227a9101ccc94a5b02ef2edbc2cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaac029ff78d493b165e178963f5dcafc5bea734", "patch": "@@ -1,3 +1,33 @@\n+2015-12-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc.h (TARGET_SUPPORTS_WIDE_INT): Define to 1.\n+\t* config/sparc/sparc.c (sparc_emit_set_const64): Remove code\n+\tconditionalized on HOST_BITS_PER_WIDE_INT == 32.\n+\t(sparc_cannot_force_const_mem) <CONST_WIDE_INT>: New case.\n+\t<CONST_DOUBLE>: Remove VOIDmode test.\n+\t(epilogue_renumber) <CONST_WIDE_INT>: New case.\n+\t(sparc_print_operand): Remove support for CONST_DOUBLE with VOIDmode.\n+\t(sparc_assemble_integer): Likewise.\n+\t(set_extends): Likewise.\n+\t(sparc_rtx_costs) <CONST_INT>: Use SMALL_INT.\n+\t<CONST_WIDE_INT>: New case.\n+\t<CONST_DOUBLE>: Remove support for VOIDmode.\n+\t<MULT>: Remove support for CONST_DOUBLE with VOIDmode.\n+\t* config/sparc/predicates.md (const_zero_operand): Add const_wide_int.\n+\t(const_all_ones_operand): Likewise.\n+\t(uns_small_int_operand): Remove const_double and code conditionalized\n+\ton HOST_BITS_PER_WIDE_INT == 32.\n+\t(arith_double_operand): Likewise.\n+\t(arith_double_add_operand): Likewise.\n+\t(input_operand): Remove support for CONST_DOUBLE with DImode.\n+\t* config/sparc/sparc.md (DImode CONST_INT splitter): Remove code\n+\tconditionalized on HOST_BITS_PER_WIDE_INT == 32.\n+\t(DFmode CONST_DOUBLE splitter): Likewise.\n+\t(*adddi3_insn_sp32): Likewise.\n+\t(*subdi3_insn_sp32): Likewise.\n+\t(DImode logical splitter): Likewise.\n+\t(DImode CONST_DOUBLE splitter): Delete.\n+\n 2015-12-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR sanitizer/68418"}, {"sha": "44d5922d5879107dcf3ac0574adbc8a0aeb5fc4b", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=eaac029ff78d493b165e178963f5dcafc5bea734", "patch": "@@ -21,13 +21,12 @@\n \n ;; Return true if OP is the zero constant for MODE.\n (define_predicate \"const_zero_operand\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n+  (and (match_code \"const_int,const_wide_int,const_double,const_vector\")\n        (match_test \"op == CONST0_RTX (mode)\")))\n \n-;; Return true if the integer representation of OP is\n-;; all-ones.\n+;; Return true if the integer representation of OP is all ones.\n (define_predicate \"const_all_ones_operand\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n+  (and (match_code \"const_int,const_wide_int,const_double,const_vector\")\n        (match_test \"INTEGRAL_MODE_P (GET_MODE (op))\")\n        (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n \n@@ -47,20 +46,10 @@\n ;; instruction sign-extends immediate values just like all other SPARC\n ;; instructions, but interprets the extended result as an unsigned number.\n (define_predicate \"uns_small_int_operand\"\n-  (match_code \"const_int,const_double\")\n-{\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  return ((GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 0x1000)\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && (unsigned) CONST_DOUBLE_LOW (op) - 0xFFFFF000 < 0x1000));\n-#else\n-  return (GET_CODE (op) == CONST_INT\n-\t  && ((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n-\t      || (INTVAL (op) >= 0xFFFFF000\n-                  && INTVAL (op) <= 0xFFFFFFFF)));\n-#endif\n-})\n+  (and (match_code \"const_int\")\n+       (match_test \"((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n+\t\t    || (INTVAL (op) >= 0xFFFFF000\n+\t\t\t&& INTVAL (op) <= 0xFFFFFFFF))\")))\n \n ;; Return true if OP is a constant that can be loaded by the sethi instruction.\n ;; The first test avoids emitting sethi to load zero for example.\n@@ -308,25 +297,19 @@\n ;; representable by a couple of 13-bit signed fields.  This is an\n ;; acceptable operand for most 3-address splitters.\n (define_predicate \"arith_double_operand\"\n-  (match_code \"const_int,const_double,reg,subreg\")\n+  (match_code \"const_int,reg,subreg\")\n {\n   bool arith_simple_operand = arith_operand (op, mode);\n   HOST_WIDE_INT m1, m2;\n \n   if (TARGET_ARCH64 || arith_simple_operand)\n     return arith_simple_operand;\n \n-#if HOST_BITS_PER_WIDE_INT == 32\n-  if (GET_CODE (op) != CONST_DOUBLE)\n-    return false;\n-  m1 = CONST_DOUBLE_LOW (op);\n-  m2 = CONST_DOUBLE_HIGH (op);\n-#else\n   if (GET_CODE (op) != CONST_INT)\n     return false;\n+\n   m1 = trunc_int_for_mode (INTVAL (op), SImode);\n   m2 = trunc_int_for_mode (INTVAL (op) >> 32, SImode);\n-#endif\n \n   return SPARC_SIMM13_P (m1) && SPARC_SIMM13_P (m2);\n })\n@@ -338,11 +321,9 @@\n \n ;; Return true if OP is suitable as second double operand for add/sub.\n (define_predicate \"arith_double_add_operand\"\n-  (match_code \"const_int,const_double,reg,subreg\")\n+  (match_code \"const_int,reg,subreg\")\n {\n-  bool _arith_double_operand = arith_double_operand (op, mode);\n-\n-  if (_arith_double_operand)\n+  if (arith_double_operand (op, mode))\n     return true;\n \n   return TARGET_ARCH64 && const_4096_operand (op, mode);\n@@ -395,8 +376,8 @@\n \t\t|| (TARGET_ARCH64\n \t\t    && mode == DImode\n \t\t    && INTVAL (XEXP (op, 2)) > 51)));\n-  else\n-    return register_operand (op, mode);\n+\n+  return register_operand (op, mode);\n })\n \n ;; Return true if OP is a valid operand for the source of a move insn.\n@@ -419,9 +400,7 @@\n \n   /* If 32-bit mode and this is a DImode constant, allow it\n      so that the splits can be generated.  */\n-  if (TARGET_ARCH32\n-      && mode == DImode\n-      && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n+  if (TARGET_ARCH32 && mode == DImode && GET_CODE (op) == CONST_INT)\n     return true;\n \n   if (mclass == MODE_FLOAT && GET_CODE (op) == CONST_DOUBLE)"}, {"sha": "02addbcb5a1ea0cef59679739ea7c294b8921f14", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 23, "deletions": 62, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=eaac029ff78d493b165e178963f5dcafc5bea734", "patch": "@@ -2086,13 +2086,6 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp)\n     }\n }\n \n-#if HOST_BITS_PER_WIDE_INT == 32\n-static void\n-sparc_emit_set_const64 (rtx op0 ATTRIBUTE_UNUSED, rtx op1 ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable ();\n-}\n-#else\n /* These avoid problems when cross compiling.  If we do not\n    go through all this hair then the optimizer will see\n    invalid REG_EQUAL notes or in some cases none at all.  */\n@@ -2636,8 +2629,7 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n    *    sllx\t%reg, 32, %reg\n    *\tor\t%reg, low_bits, %reg\n    */\n-  if (SPARC_SIMM13_P(low_bits)\n-      && ((int)low_bits > 0))\n+  if (SPARC_SIMM13_P (low_bits) && ((int)low_bits > 0))\n     {\n       sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_bits, 32);\n       return;\n@@ -2646,7 +2638,6 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n   /* The easiest way when all else fails, is full decomposition.  */\n   sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits);\n }\n-#endif /* HOST_BITS_PER_WIDE_INT == 32 */\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n@@ -3675,6 +3666,7 @@ sparc_cannot_force_const_mem (machine_mode mode, rtx x)\n   switch (GET_CODE (x))\n     {\n     case CONST_INT:\n+    case CONST_WIDE_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n       /* Accept all non-symbolic constants.  */\n@@ -3775,9 +3767,6 @@ sparc_legitimate_constant_p (machine_mode mode, rtx x)\n       break;\n \n     case CONST_DOUBLE:\n-      if (GET_MODE (x) == VOIDmode)\n-        return true;\n-\n       /* Floating point constants are generally not ok.\n \t The only exception is 0.0 and all-ones in VIS.  */\n       if (TARGET_VIS\n@@ -3832,7 +3821,7 @@ constant_address_p (rtx x)\n \n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and\n-   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+   that X satisfies CONSTANT_P.  */\n \n bool\n legitimate_pic_operand_p (rtx x)\n@@ -8351,6 +8340,7 @@ epilogue_renumber (register rtx *where, int test)\n     case CC0:\n     case PC:\n     case CONST_INT:\n+    case CONST_WIDE_INT:\n     case CONST_DOUBLE:\n       return 0;\n \n@@ -8896,8 +8886,6 @@ sparc_print_operand (FILE *file, rtx x, int code)\n \tHOST_WIDE_INT i;\n \tif (GET_CODE(x) == CONST_INT)\n \t  i = INTVAL (x);\n-\telse if (GET_CODE(x) == CONST_DOUBLE)\n-\t  i = CONST_DOUBLE_LOW (x);\n \telse\n \t  {\n \t    output_operand_lossage (\"invalid %%s operand\");\n@@ -8944,21 +8932,10 @@ sparc_print_operand (FILE *file, rtx x, int code)\n       output_addr_const (file, XEXP (x, 1));\n       fputc (')', file);\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE\n-\t   && (GET_MODE (x) == VOIDmode\n-\t       || GET_MODE_CLASS (GET_MODE (x)) == MODE_INT))\n-    {\n-      if (CONST_DOUBLE_HIGH (x) == 0)\n-\tfprintf (file, \"%u\", (unsigned int) CONST_DOUBLE_LOW (x));\n-      else if (CONST_DOUBLE_HIGH (x) == -1\n-\t       && CONST_DOUBLE_LOW (x) < 0)\n-\tfprintf (file, \"%d\", (int) CONST_DOUBLE_LOW (x));\n-      else\n-\toutput_operand_lossage (\"long long constant not a valid immediate operand\");\n-    }\n   else if (GET_CODE (x) == CONST_DOUBLE)\n-    output_operand_lossage (\"floating point constant not a valid immediate operand\");\n-  else { output_addr_const (file, x); }\n+    output_operand_lossage (\"floating-point constant not a valid immediate operand\");\n+  else\n+    output_addr_const (file, x);\n }\n \n /* Implement TARGET_PRINT_OPERAND_ADDRESS.  */\n@@ -9052,8 +9029,7 @@ sparc_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   /* ??? We only output .xword's for symbols and only then in environments\n      where the assembler can handle them.  */\n-  if (aligned_p && size == 8\n-      && (GET_CODE (x) != CONST_INT && GET_CODE (x) != CONST_DOUBLE))\n+  if (aligned_p && size == 8 && GET_CODE (x) != CONST_INT)\n     {\n       if (TARGET_V9)\n \t{\n@@ -9602,10 +9578,8 @@ set_extends (rtx_insn *insn)\n     case LSHIFTRT:\n       return GET_MODE (SET_SRC (pat)) == SImode;\n       /* Positive integers leave the high bits zero.  */\n-    case CONST_DOUBLE:\n-      return ! (CONST_DOUBLE_LOW (SET_SRC (pat)) & 0x80000000);\n     case CONST_INT:\n-      return ! (INTVAL (SET_SRC (pat)) & 0x80000000);\n+      return !(INTVAL (SET_SRC (pat)) & 0x80000000);\n     case ASHIFTRT:\n     case SIGN_EXTEND:\n       return - (GET_MODE (SET_SRC (pat)) == SImode);\n@@ -10903,12 +10877,19 @@ sparc_rtx_costs (rtx x, machine_mode mode, int outer_code,\n   switch (code)\n     {\n     case CONST_INT:\n-      if (INTVAL (x) < 0x1000 && INTVAL (x) >= -0x1000)\n-\t{\n-\t  *total = 0;\n-\t  return true;\n-\t}\n-      /* FALLTHRU */\n+      if (SMALL_INT (x))\n+\t*total = 0;\n+      else\n+\t*total = 2;\n+      return true;\n+\n+    case CONST_WIDE_INT:\n+      *total = 0;\n+      if (!SPARC_SIMM13_P (CONST_WIDE_INT_ELT (x, 0)))\n+\t*total += 2;\n+      if (!SPARC_SIMM13_P (CONST_WIDE_INT_ELT (x, 1)))\n+\t*total += 2;\n+      return true;\n \n     case HIGH:\n       *total = 2;\n@@ -10921,15 +10902,7 @@ sparc_rtx_costs (rtx x, machine_mode mode, int outer_code,\n       return true;\n \n     case CONST_DOUBLE:\n-      if (mode == VOIDmode\n-\t  && ((CONST_DOUBLE_HIGH (x) == 0\n-\t       && CONST_DOUBLE_LOW (x) < 0x1000)\n-\t      || (CONST_DOUBLE_HIGH (x) == -1\n-\t\t  && CONST_DOUBLE_LOW (x) < 0\n-\t\t  && CONST_DOUBLE_LOW (x) >= -0x1000)))\n-\t*total = 0;\n-      else\n-\t*total = 8;\n+      *total = 8;\n       return true;\n \n     case MEM:\n@@ -11002,18 +10975,6 @@ sparc_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t\t  for (nbits = 0; value != 0; value &= value - 1)\n \t\t    nbits++;\n \t\t}\n-\t      else if (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n-\t\t       && GET_MODE (XEXP (x, 1)) == VOIDmode)\n-\t\t{\n-\t\t  rtx x1 = XEXP (x, 1);\n-\t\t  unsigned HOST_WIDE_INT value1 = CONST_DOUBLE_LOW (x1);\n-\t\t  unsigned HOST_WIDE_INT value2 = CONST_DOUBLE_HIGH (x1);\n-\n-\t\t  for (nbits = 0; value1 != 0; value1 &= value1 - 1)\n-\t\t    nbits++;\n-\t\t  for (; value2 != 0; value2 &= value2 - 1)\n-\t\t    nbits++;\n-\t\t}\n \t      else\n \t\tnbits = 7;\n "}, {"sha": "ae8e962d111c99c469bcea0943f0ad30a15e204c", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=eaac029ff78d493b165e178963f5dcafc5bea734", "patch": "@@ -506,6 +506,7 @@ extern enum cmodel sparc_cmodel;\n /* FIXME, this is wrong when TARGET_ARCH64 and TARGET_STACK_BIAS, because\n    then %sp+2047 is 128-bit aligned so %sp is really only byte-aligned.  */\n #define STACK_BOUNDARY (TARGET_ARCH64 ? 128 : 64)\n+\n /* Temporary hack until the FIXME above is fixed.  */\n #define SPARC_STACK_BOUNDARY_HACK (TARGET_ARCH64 && TARGET_STACK_BIAS)\n \n@@ -1801,3 +1802,5 @@ extern int sparc_indent_opcode;\n \n /* Define this to 1 if the FE_EXCEPT values defined in fenv.h start at 1.  */\n #define SPARC_LOW_FE_EXCEPT_VALUES 0\n+\n+#define TARGET_SUPPORTS_WIDE_INT 1"}, {"sha": "e1ffcc084340440629be412e052fc5ce631a29fa", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 3, "deletions": 78, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaac029ff78d493b165e178963f5dcafc5bea734/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=eaac029ff78d493b165e178963f5dcafc5bea734", "patch": "@@ -1880,14 +1880,6 @@\n    && reload_completed\"\n   [(clobber (const_int 0))]\n {\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n-\t\t\t(INTVAL (operands[1]) < 0) ?\n-\t\t\tconstm1_rtx :\n-\t\t\tconst0_rtx));\n-  emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\toperands[1]));\n-#else\n   HOST_WIDE_INT low, high;\n \n   low = trunc_int_for_mode (INTVAL (operands[1]), SImode);\n@@ -1903,40 +1895,7 @@\n \t\t\t  gen_highpart (SImode, operands[0])));\n   else\n     emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), GEN_INT (low)));\n-#endif\n-  DONE;\n-})\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-        (match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"reload_completed\n-   && (! TARGET_V9\n-       || (! TARGET_ARCH64\n-           && ((GET_CODE (operands[0]) == REG\n-                && SPARC_INT_REG_P (REGNO (operands[0])))\n-               || (GET_CODE (operands[0]) == SUBREG\n-                   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-                   && SPARC_INT_REG_P (REGNO (SUBREG_REG (operands[0])))))))\"\n-  [(clobber (const_int 0))]\n-{\n-  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n-\t\t\tGEN_INT (CONST_DOUBLE_HIGH (operands[1]))));\n \n-  /* Slick... but this trick loses if this subreg constant part\n-     can be done in one insn.  */\n-  if (CONST_DOUBLE_LOW (operands[1]) == CONST_DOUBLE_HIGH (operands[1])\n-      && ! SPARC_SETHI32_P (CONST_DOUBLE_HIGH (operands[1]))\n-      && ! SPARC_SIMM13_P (CONST_DOUBLE_HIGH (operands[1])))\n-    {\n-      emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t    gen_highpart (SImode, operands[0])));\n-    }\n-  else\n-    {\n-      emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t    GEN_INT (CONST_DOUBLE_LOW (operands[1]))));\n-    }\n   DONE;\n })\n \n@@ -2358,13 +2317,9 @@\n \n   if (TARGET_ARCH64)\n     {\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      gcc_unreachable ();\n-#else\n       machine_mode mode = GET_MODE (operands[1]);\n       rtx tem = simplify_subreg (DImode, operands[1], mode, 0);\n       emit_insn (gen_movdi (operands[0], tem));\n-#endif\n     }\n   else\n     {\n@@ -3682,17 +3637,7 @@\n   operands[5] = gen_lowpart (SImode, operands[2]);\n   operands[6] = gen_highpart (SImode, operands[0]);\n   operands[7] = gen_highpart_mode (SImode, DImode, operands[1]);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      if (INTVAL (operands[2]) < 0)\n-\toperands[8] = constm1_rtx;\n-      else\n-\toperands[8] = const0_rtx;\n-    }\n-  else\n-#endif\n-    operands[8] = gen_highpart_mode (SImode, DImode, operands[2]);\n+  operands[8] = gen_highpart_mode (SImode, DImode, operands[2]);\n }\n   [(set_attr \"length\" \"2\")])\n \n@@ -3872,17 +3817,7 @@\n   operands[5] = gen_lowpart (SImode, operands[2]);\n   operands[6] = gen_highpart (SImode, operands[0]);\n   operands[7] = gen_highpart (SImode, operands[1]);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      if (INTVAL (operands[2]) < 0)\n-\toperands[8] = constm1_rtx;\n-      else\n-\toperands[8] = const0_rtx;\n-    }\n-  else\n-#endif\n-    operands[8] = gen_highpart_mode (SImode, DImode, operands[2]);\n+  operands[8] = gen_highpart_mode (SImode, DImode, operands[2]);\n }\n   [(set_attr \"length\" \"2\")])\n \n@@ -5034,17 +4969,7 @@\n   operands[5] = gen_lowpart (SImode, operands[0]);\n   operands[6] = gen_highpart (SImode, operands[2]);\n   operands[7] = gen_lowpart (SImode, operands[2]);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    {\n-      if (INTVAL (operands[3]) < 0)\n-\toperands[8] = constm1_rtx;\n-      else\n-\toperands[8] = const0_rtx;\n-    }\n-  else\n-#endif\n-    operands[8] = gen_highpart_mode (SImode, DImode, operands[3]);\n+  operands[8] = gen_highpart_mode (SImode, DImode, operands[3]);\n   operands[9] = gen_lowpart (SImode, operands[3]);\n })\n "}]}