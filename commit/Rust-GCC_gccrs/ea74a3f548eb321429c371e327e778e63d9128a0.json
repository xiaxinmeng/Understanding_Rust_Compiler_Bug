{"sha": "ea74a3f548eb321429c371e327e778e63d9128a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE3NGEzZjU0OGViMzIxNDI5YzM3MWUzMjdlNzc4ZTYzZDkxMjhhMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-20T13:16:30Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-20T13:16:30Z"}, "message": "vect: Fix VLA SLP invariant optimisation [PR98535]\n\nduplicate_and_interleave is the main fallback way of loading\na repeating sequence of elements into variable-length vectors.\nThe code handles cases in which the number of elements in the\nsequence is potentially several times greater than the number\nof elements in a vector.\n\nLet:\n\n- NE be the (compile-time) number of elements in the sequence\n- NR be the (compile-time) number of vector results and\n- VE be the (run-time) number of elements in each vector\n\nThe basic approach is to duplicate each element into a\nseparate vector, giving NE vectors in total, then use\nlog2(NE) rows of NE permutes to generate NE results.\n\nIn the worst case \u2014 when VE has no known compile-time factor\nand NR >= NE \u2014 all of these permutes are necessary.  However,\nif VE is known to be a multiple of 2**F, then each of the\nfirst F permute rows produces duplicate results; specifically,\nthe high permute for a given pair is the same as the low permute.\nThe code dealt with this by reusing the low result for the\nhigh result.  This part was OK.\n\nHowever, having duplicate results from one row meant that the\nnext row did duplicate work.  The redundancies would be optimised\naway by later passes, but the code tried to avoid generating them\nin the first place.  This is the part that went wrong.\n\nSpecifically, NR is typically less than NE when some permutes are\nredundant, so the code tried to use NR to reduce the amount of work\nperformed.  The problem was that, although it correctly calculated\na conservative bound on how many results were needed in each row,\nit chose the wrong results for anything other than the final row.\n\nThis doesn't usually matter for fully-packed SVE vectors.  We first\ntry to coalesce smaller elements into larger ones, so normally\nVE ends up being 2**VQ (where VQ is the number of 128-bit blocks\nin an SVE vector).  In that situation we'd only apply the faulty\noptimisation to the final row, i.e. the case it handled correctly.\nE.g. for things like:\n\n  void\n  f (long *x)\n  {\n    for (int i = 0; i < 100; i += 8)\n      {\n        x[i] += 1;\n        x[i + 1] += 2;\n        x[i + 2] += 3;\n        x[i + 3] += 4;\n        x[i + 4] += 5;\n        x[i + 5] += 6;\n        x[i + 6] += 7;\n        x[i + 7] += 8;\n      }\n  }\n\n(already tested by the testsuite), we'd have 3 rows of permutes\nproducing 4 vector results.  The schemne produced:\n\n1st row: 8 results from 4 permutes, highs duplicates of lows\n2nd row: 8 results from 8 permutes (half of which are actually redundant)\n3rd row: 4 results from 4 permutes\n\nHowever, coalescing elements is trickier for unpacked vectors,\nand at the moment we don't try to do it (see the GET_MODE_SIZE\ncheck in can_duplicate_and_interleave_p).  Unpacked vectors\ntherefore stress the code in ways that packed vectors didn't.\n\nThe patch fixes this by removing the redundancies from each row,\nrather than trying to work around them later.  This also removes\nthe redundant work in the second row of the example above.\n\ngcc/\n\tPR tree-optimization/98535\n\t* tree-vect-slp.c (duplicate_and_interleave): Use quick_grow_cleared.\n\tIf the high and low permutes are the same, remove the high permutes\n\tfrom the working set and only continue with the low ones.", "tree": {"sha": "70742d63713750a913d111f500d3281447d38565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70742d63713750a913d111f500d3281447d38565"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea74a3f548eb321429c371e327e778e63d9128a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea74a3f548eb321429c371e327e778e63d9128a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea74a3f548eb321429c371e327e778e63d9128a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea74a3f548eb321429c371e327e778e63d9128a0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a95538b6c5a9ea480e341da9ca8fbf201417dba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a95538b6c5a9ea480e341da9ca8fbf201417dba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a95538b6c5a9ea480e341da9ca8fbf201417dba5"}], "stats": {"total": 67, "additions": 46, "deletions": 21}, "files": [{"sha": "6873a38734d21791535606a388b9966779631142", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr98535.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea74a3f548eb321429c371e327e778e63d9128a0/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr98535.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea74a3f548eb321429c371e327e778e63d9128a0/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr98535.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr98535.c?ref=ea74a3f548eb321429c371e327e778e63d9128a0", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-O3 -mtune=neoverse-v1\" } */\n+\n+typedef short a;\n+\n+typedef struct {\n+  a b, c, d, e;\n+} f;\n+\n+f *g;\n+\n+long h;\n+\n+void\n+i() {\n+  f j;\n+  for (; h; h++)\n+    *g++ = j;\n+}"}, {"sha": "4465cf7494ee1608e34ed1091ac2c0428cd4de2e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea74a3f548eb321429c371e327e778e63d9128a0/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea74a3f548eb321429c371e327e778e63d9128a0/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ea74a3f548eb321429c371e327e778e63d9128a0", "patch": "@@ -5063,7 +5063,7 @@ duplicate_and_interleave (vec_info *vinfo, gimple_seq *seq, tree vector_type,\n \n   tree_vector_builder partial_elts;\n   auto_vec<tree, 32> pieces (nvectors * 2);\n-  pieces.quick_grow (nvectors * 2);\n+  pieces.quick_grow_cleared (nvectors * 2);\n   for (unsigned int i = 0; i < nvectors; ++i)\n     {\n       /* (2) Replace ELTS[0:NELTS] with ELTS'[0:NELTS'], where each element of\n@@ -5082,53 +5082,60 @@ duplicate_and_interleave (vec_info *vinfo, gimple_seq *seq, tree vector_type,\n   /* (4) Use a tree of VEC_PERM_EXPRs to create a single VM with the\n \t correct byte contents.\n \n-     We need to repeat the following operation log2(nvectors) times:\n+     Conceptually, we need to repeat the following operation log2(nvectors)\n+     times, where hi_start = nvectors / 2:\n \n \tout[i * 2] = VEC_PERM_EXPR (in[i], in[i + hi_start], lo_permute);\n \tout[i * 2 + 1] = VEC_PERM_EXPR (in[i], in[i + hi_start], hi_permute);\n \n      However, if each input repeats every N elements and the VF is\n-     a multiple of N * 2, the HI result is the same as the LO.  */\n+     a multiple of N * 2, the HI result is the same as the LO result.\n+     This will be true for the first N1 iterations of the outer loop,\n+     followed by N2 iterations for which both the LO and HI results\n+     are needed.  I.e.:\n+\n+\tN1 + N2 = log2(nvectors)\n+\n+     Each \"N1 iteration\" doubles the number of redundant vectors and the\n+     effect of the process as a whole is to have a sequence of nvectors/2**N1\n+     vectors that repeats 2**N1 times.  Rather than generate these redundant\n+     vectors, we halve the number of vectors for each N1 iteration.  */\n   unsigned int in_start = 0;\n   unsigned int out_start = nvectors;\n-  unsigned int hi_start = nvectors / 2;\n-  /* A bound on the number of outputs needed to produce NRESULTS results\n-     in the final iteration.  */\n-  unsigned int noutputs_bound = nvectors * nresults;\n+  unsigned int new_nvectors = nvectors;\n   for (unsigned int in_repeat = 1; in_repeat < nvectors; in_repeat *= 2)\n     {\n-      noutputs_bound /= 2;\n-      unsigned int limit = MIN (noutputs_bound, nvectors);\n-      for (unsigned int i = 0; i < limit; ++i)\n+      unsigned int hi_start = new_nvectors / 2;\n+      unsigned int out_i = 0;\n+      for (unsigned int in_i = 0; in_i < new_nvectors; ++in_i)\n \t{\n-\t  if ((i & 1) != 0\n+\t  if ((in_i & 1) != 0\n \t      && multiple_p (TYPE_VECTOR_SUBPARTS (new_vector_type),\n \t\t\t     2 * in_repeat))\n-\t    {\n-\t      pieces[out_start + i] = pieces[out_start + i - 1];\n-\t      continue;\n-\t    }\n+\t    continue;\n \n \t  tree output = make_ssa_name (new_vector_type);\n-\t  tree input1 = pieces[in_start + (i / 2)];\n-\t  tree input2 = pieces[in_start + (i / 2) + hi_start];\n+\t  tree input1 = pieces[in_start + (in_i / 2)];\n+\t  tree input2 = pieces[in_start + (in_i / 2) + hi_start];\n \t  gassign *stmt = gimple_build_assign (output, VEC_PERM_EXPR,\n \t\t\t\t\t       input1, input2,\n-\t\t\t\t\t       permutes[i & 1]);\n+\t\t\t\t\t       permutes[in_i & 1]);\n \t  gimple_seq_add_stmt (seq, stmt);\n-\t  pieces[out_start + i] = output;\n+\t  pieces[out_start + out_i] = output;\n+\t  out_i += 1;\n \t}\n       std::swap (in_start, out_start);\n+      new_nvectors = out_i;\n     }\n \n   /* (5) Use VIEW_CONVERT_EXPR to cast the final VM to the required type.  */\n   results.reserve (nresults);\n   for (unsigned int i = 0; i < nresults; ++i)\n-    if (i < nvectors)\n+    if (i < new_nvectors)\n       results.quick_push (gimple_build (seq, VIEW_CONVERT_EXPR, vector_type,\n \t\t\t\t\tpieces[in_start + i]));\n     else\n-      results.quick_push (results[i - nvectors]);\n+      results.quick_push (results[i - new_nvectors]);\n }\n \n "}]}