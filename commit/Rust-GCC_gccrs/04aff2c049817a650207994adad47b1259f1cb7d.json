{"sha": "04aff2c049817a650207994adad47b1259f1cb7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRhZmYyYzA0OTgxN2E2NTAyMDc5OTRhZGFkNDdiMTI1OWYxY2I3ZA==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2006-01-12T21:40:27Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-01-12T21:40:27Z"}, "message": "addsub.md (addhi3): Add two more alternatives, for mova with fb, and for fb+0 -> An.\n\n* config/m32c/addsub.md (addhi3): Add two more alternatives, for\nmova with fb, and for fb+0 -> An.\n\n* config/m32c/mov.md (peephole2): Fix enabling logic.\n\n* config/m32c/m32c.h (CTOR_LIST_BEGIN, CTOR_LIST_END,\nDTOR_LIST_BEGIN, DTOR_LIST_END, CTORS_SECTION_ASM_OP,\nDTORS_SECTION_ASM_OP, INIT_ARRAY_SECTION_ASM_OP,\nFINI_ARRAY_SECTION_ASM_OP): Define.\n\n* config/m32c/m32c.c (m32c_legitimize_address): Remove temporary variable.\n(m32c_legitimize_reload_address): New logic to reload FB to An.\n(m32c_output_reg_push): Add newline.\n(m32c_output_reg_pop): Likewise.\n\nFrom-SVN: r109648", "tree": {"sha": "3c9709b82aeef81ad29374bab01bfada3c2f6841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c9709b82aeef81ad29374bab01bfada3c2f6841"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04aff2c049817a650207994adad47b1259f1cb7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04aff2c049817a650207994adad47b1259f1cb7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04aff2c049817a650207994adad47b1259f1cb7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04aff2c049817a650207994adad47b1259f1cb7d/comments", "author": null, "committer": null, "parents": [{"sha": "664a90c055c8f86cccd5556f48c74e94a6b7cc05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/664a90c055c8f86cccd5556f48c74e94a6b7cc05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/664a90c055c8f86cccd5556f48c74e94a6b7cc05"}], "stats": {"total": 115, "additions": 104, "deletions": 11}, "files": [{"sha": "38405e70e65051318178e62aae34ca881cef43e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04aff2c049817a650207994adad47b1259f1cb7d", "patch": "@@ -1,3 +1,20 @@\n+2006-01-12  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/addsub.md (addhi3): Add two more alternatives, for\n+\tmova with fb, and for fb+0 -> An.\n+\n+\t* config/m32c/mov.md (peephole2): Fix enabling logic.\n+\n+\t* config/m32c/m32c.h (CTOR_LIST_BEGIN, CTOR_LIST_END,\n+\tDTOR_LIST_BEGIN, DTOR_LIST_END, CTORS_SECTION_ASM_OP,\n+\tDTORS_SECTION_ASM_OP, INIT_ARRAY_SECTION_ASM_OP,\n+\tFINI_ARRAY_SECTION_ASM_OP): Define.\n+\n+\t* config/m32c/m32c.c (m32c_legitimize_address): Remove temporary variable.\n+\t(m32c_legitimize_reload_address): New logic to reload FB to An.\n+\t(m32c_output_reg_push): Add newline.\n+\t(m32c_output_reg_pop): Likewise.\n+\n 2006-01-12  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* struct-equiv.c (find_dying_inputs): Fix off-by-one bug."}, {"sha": "104709c96bb883bad640b4699d951033698be409", "filename": "gcc/config/m32c/addsub.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Faddsub.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Faddsub.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Faddsub.md?ref=04aff2c049817a650207994adad47b1259f1cb7d", "patch": "@@ -36,11 +36,11 @@\n \n (define_insn \"addhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\"\n-\t \t  \"=SdRhi,SdRhi,??Rmm,??Rmm, SdRhi,??Rmm, Rhi, !Rsp\")\n+\t \t  \"=SdRhi,SdRhi,??Rmm,??Rmm, SdRhi,??Rmm, Rhi, Raw, Raw, !Rsp\")\n \t(plus:HI (match_operand:HI 1 \"general_operand\"\n-\t\t  \"%0,0,0,0, 0,0, Raw, 0\")\n+\t\t  \"%0,0,0,0, 0,0, Raw, Rfb, Rfb, 0\")\n \t\t (match_operand:HI 2 \"general_operand\"\n-\t\t  \"IU2sSdRhi,?Rmm,IU2sSdRhi,?Rmm, IM2,IM2, IS2IU2, i\")))]\n+\t\t  \"IU2sSdRhi,?Rmm,IU2sSdRhi,?Rmm, IM2,IM2, IS2IU2, I00, IS1, i\")))]\n   \"\"\n   \"@\n    add.w\\t%2,%0\n@@ -50,8 +50,10 @@\n    sub.w\\t%m2,%0\n    sub.w\\t%m2,%0\n    mova\\t%d2[%1],%0\n+   stc\\t%1,%0\n+   mova\\t%D2[%1],%0\n    add.w\\t%2,%0\"\n-  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,oszc,oszc,oszc\")]\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,oszc,oszc,oszc,oszc,oszc\")]\n   )\n \n (define_insn \"addpsi3\""}, {"sha": "87121312cc6584cb5e2554ba04546a4094b1ac34", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=04aff2c049817a650207994adad47b1259f1cb7d", "patch": "@@ -1822,6 +1822,31 @@ m32c_reg_ok_for_base_p (rtx x, int strict)\n     }\n }\n \n+/* We have three choices for choosing fb->aN offsets.  If we choose -128,\n+   we need one MOVA -128[fb],aN opcode and 16 bit aN displacements,\n+   like this:\n+       EB 4B FF    mova    -128[$fb],$a0\n+       D8 0C FF FF mov.w:Q #0,-1[$a0]\n+\n+   Alternately, we subtract the frame size, and hopefully use 8 bit aN\n+   displacements:\n+       7B F4       stc $fb,$a0\n+       77 54 00 01 sub #256,$a0\n+       D8 08 01    mov.w:Q #0,1[$a0]\n+\n+   If we don't offset (i.e. offset by zero), we end up with:\n+       7B F4       stc $fb,$a0\n+       D8 0C 00 FF mov.w:Q #0,-256[$a0]\n+\n+   We have to subtract *something* so that we have a PLUS rtx to mark\n+   that we've done this reload.  The -128 offset will never result in\n+   an 8 bit aN offset, and the payoff for the second case is five\n+   loads *if* those loads are within 256 bytes of the other end of the\n+   frame, so the third case seems best.  Note that we subtract the\n+   zero, but detect that in the addhi3 pattern.  */\n+\n+#define BIG_FB_ADJ 0\n+\n /* Implements LEGITIMIZE_ADDRESS.  The only address we really have to\n    worry about is frame base offsets, as $fb has a limited\n    displacement range.  We deal with this by attempting to reload $fb\n@@ -1846,10 +1871,9 @@ m32c_legitimize_address (rtx * x ATTRIBUTE_UNUSED,\n \t  || INTVAL (XEXP (*x, 1)) > (128 - GET_MODE_SIZE (mode))))\n     {\n       /* reload FB to A_REGS */\n-      rtx foo;\n       rtx temp = gen_reg_rtx (Pmode);\n       *x = copy_rtx (*x);\n-      foo = emit_insn (gen_rtx_SET (VOIDmode, temp, XEXP (*x, 0)));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, XEXP (*x, 0)));\n       XEXP (*x, 0) = temp;\n       return 1;\n     }\n@@ -1875,7 +1899,47 @@ m32c_legitimize_reload_address (rtx * x,\n      *also* still trying to reload the whole address, and we'd run out\n      of address registers.  So we let gcc do the naive (but safe)\n      reload instead, when the above function doesn't handle it for\n-     us.  */\n+     us.\n+\n+     The code below is a second attempt at the above.  */\n+\n+  if (GET_CODE (*x) == PLUS\n+      && GET_CODE (XEXP (*x, 0)) == REG\n+      && REGNO (XEXP (*x, 0)) == FB_REGNO\n+      && GET_CODE (XEXP (*x, 1)) == CONST_INT\n+      && (INTVAL (XEXP (*x, 1)) < -128\n+\t  || INTVAL (XEXP (*x, 1)) > (128 - GET_MODE_SIZE (mode))))\n+    {\n+      rtx sum;\n+      int offset = INTVAL (XEXP (*x, 1));\n+      int adjustment = -BIG_FB_ADJ;\n+\n+      sum = gen_rtx_PLUS (Pmode, XEXP (*x, 0),\n+\t\t\t  GEN_INT (adjustment));\n+      *x = gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - adjustment));\n+      if (type == RELOAD_OTHER)\n+\ttype = RELOAD_FOR_OTHER_ADDRESS;\n+      push_reload (sum, NULL_RTX, &XEXP (*x, 0), NULL,\n+\t\t   A_REGS, Pmode, VOIDmode, 0, 0, opnum,\n+\t\t   type);\n+      return 1;\n+    }\n+\n+  if (GET_CODE (*x) == PLUS\n+      && GET_CODE (XEXP (*x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (*x, 0), 0)) == REG\n+      && REGNO (XEXP (XEXP (*x, 0), 0)) == FB_REGNO\n+      && GET_CODE (XEXP (XEXP (*x, 0), 1)) == CONST_INT\n+      && GET_CODE (XEXP (*x, 1)) == CONST_INT\n+      )\n+    {\n+      if (type == RELOAD_OTHER)\n+\ttype = RELOAD_FOR_OTHER_ADDRESS;\n+      push_reload (XEXP (*x, 0), NULL_RTX, &XEXP (*x, 0), NULL,\n+\t\t   A_REGS, Pmode, VOIDmode, 0, 0, opnum,\n+\t\t   type);\n+      return 1;\n+    }\n \n   return 0;\n }\n@@ -2386,7 +2450,7 @@ m32c_output_reg_push (FILE * s, int regno)\n   if (regno == FLG_REGNO)\n     fprintf (s, \"\\tpushc\\tflg\\n\");\n   else\n-    fprintf (s, \"\\tpush.%c\\t%s\",\n+    fprintf (s, \"\\tpush.%c\\t%s\\n\",\n \t     \" bwll\"[reg_push_size (regno)], reg_names[regno]);\n }\n \n@@ -2397,7 +2461,7 @@ m32c_output_reg_pop (FILE * s, int regno)\n   if (regno == FLG_REGNO)\n     fprintf (s, \"\\tpopc\\tflg\\n\");\n   else\n-    fprintf (s, \"\\tpop.%c\\t%s\",\n+    fprintf (s, \"\\tpop.%c\\t%s\\n\",\n \t     \" bwll\"[reg_push_size (regno)], reg_names[regno]);\n }\n "}, {"sha": "98400a0096b07d1c9ce518d838c34fd289da869e", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=04aff2c049817a650207994adad47b1259f1cb7d", "patch": "@@ -575,6 +575,15 @@ typedef struct m32c_cumulative_args\n #define DATA_SECTION_ASM_OP \".data\"\n #define BSS_SECTION_ASM_OP \".bss\"\n \n+#define CTOR_LIST_BEGIN\n+#define CTOR_LIST_END\n+#define DTOR_LIST_BEGIN\n+#define DTOR_LIST_END\n+#define CTORS_SECTION_ASM_OP \"\\t.section\\t.init_array,\\\"aw\\\",%init_array\"\n+#define DTORS_SECTION_ASM_OP \"\\t.section\\t.fini_array,\\\"aw\\\",%fini_array\"\n+#define INIT_ARRAY_SECTION_ASM_OP \"\\t.section\\t.init_array,\\\"aw\\\",%init_array\"\n+#define FINI_ARRAY_SECTION_ASM_OP \"\\t.section\\t.fini_array,\\\"aw\\\",%fini_array\"\n+\n /* The Overall Framework of an Assembler File */\n \n #define ASM_COMMENT_START \";\""}, {"sha": "c3794a3b2ed96f6adadbe5d4cf3b2dfe02e20cb6", "filename": "gcc/config/m32c/mov.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Fmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04aff2c049817a650207994adad47b1259f1cb7d/gcc%2Fconfig%2Fm32c%2Fmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fmov.md?ref=04aff2c049817a650207994adad47b1259f1cb7d", "patch": "@@ -115,8 +115,9 @@\n \t(mem:QHSI (match_operand:HPSI 4 \"register_operand\" \"\")))]\n   \"REGNO (operands[0]) == REGNO (operands[1])\n    && REGNO (operands[0]) == REGNO (operands[4])\n-   && dead_or_set_p (peep2_next_insn (1), operands[4])\n-   && ! reg_mentioned_p (operands[0], operands[3])\"\n+   && (rtx_equal_p (operands[0], operands[3])\n+       || (dead_or_set_p (peep2_next_insn (1), operands[4])\n+          && ! reg_mentioned_p (operands[0], operands[3])))\"\n   [(set (match_dup 3)\n \t(mem:QHSI (plus:HPSI (match_dup 1)\n \t\t\t     (match_dup 2))))]"}]}