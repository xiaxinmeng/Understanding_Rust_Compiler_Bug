{"sha": "29ef83dee9acfdee32507bff8c536ae26f922402", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjllZjgzZGVlOWFjZmRlZTMyNTA3YmZmOGM1MzZhZTI2ZjkyMjQwMg==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2004-11-25T16:55:34Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2004-11-25T16:55:34Z"}, "message": "Friend class name lookup 2/n, PR c++/14513, c++/15410\n\n\tFriend class name lookup 2/n, PR c++/14513, c++/15410\n\t* name-lookup.c (lookup_name_real): Simplify.\n\t(lookup_type_scope): Add SCOPE parameter.  Handle friend class\n\tlookup.\n\t* name-lookup.h (tag_scope): New enum type.\n\t(lookup_type_scope): Adjust declaration.\n\t* decl.c (lookup_and_check_tag, xref_tag, xref_tag_from_type):\n\tChange bool parameter GLOBALIZED to TAG_SCOPE parameter SCOPE.\n\t(start_enum): Likewise.  Add assertion test that NAME is\n\tIDENTIFIER_NODE.  Use anonymous name for dummy ENUMERAL_TYPE in\n\tcase of error.\n\t* cp-tree.h (xref_tag, xref_tag_from_type): Adjust declarations.\n\t* parser.c (cp_parser_elaborated_type_specifier,\n\tcp_parser_class_head): Adjust call to xref_tag.\n\t* pt.c (lookup_template_class, instantiate_class_template):\n\tLikewise.\n\t* rtti.c (init_rtti_processing, build_dynamic_cast_1,\n\ttinfo_base_init, emit_support_tinfos): Likewise.\n\n\t* g++.dg/lookup/friend2.C: New test.\n\t* g++.dg/template/friend31.C: Likewise.\n\nFrom-SVN: r91299", "tree": {"sha": "09d2e60d7ceba6434ad38c297762a3642c26dfda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09d2e60d7ceba6434ad38c297762a3642c26dfda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ef83dee9acfdee32507bff8c536ae26f922402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ef83dee9acfdee32507bff8c536ae26f922402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ef83dee9acfdee32507bff8c536ae26f922402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ef83dee9acfdee32507bff8c536ae26f922402/comments", "author": null, "committer": null, "parents": [{"sha": "3c13948a7e6fcce9f01ae3ec4f6153fb9d696fa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c13948a7e6fcce9f01ae3ec4f6153fb9d696fa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c13948a7e6fcce9f01ae3ec4f6153fb9d696fa6"}], "stats": {"total": 231, "additions": 176, "deletions": 55}, "files": [{"sha": "8acfe55b86ba5499ab7b7aa7d08a41f682491a21", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -1,3 +1,24 @@\n+2004-11-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tFriend class name lookup 2/n, PR c++/14513, c++/15410\n+\t* name-lookup.c (lookup_name_real): Simplify.\n+\t(lookup_type_scope): Add SCOPE parameter.  Handle friend class\n+\tlookup.\n+\t* name-lookup.h (tag_scope): New enum type.\n+\t(lookup_type_scope): Adjust declaration.\n+\t* decl.c (lookup_and_check_tag, xref_tag, xref_tag_from_type):\n+\tChange bool parameter GLOBALIZED to TAG_SCOPE parameter SCOPE.\n+\t(start_enum): Likewise.  Add assertion test that NAME is \n+\tIDENTIFIER_NODE.  Use anonymous name for dummy ENUMERAL_TYPE in\n+\tcase of error.\n+\t* cp-tree.h (xref_tag, xref_tag_from_type): Adjust declarations.\n+\t* parser.c (cp_parser_elaborated_type_specifier,\n+\tcp_parser_class_head): Adjust call to xref_tag.\n+\t* pt.c (lookup_template_class, instantiate_class_template):\n+\tLikewise.\n+\t* rtti.c (init_rtti_processing, build_dynamic_cast_1,\n+\ttinfo_base_init, emit_support_tinfos): Likewise.\n+\n 2004-11-25  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* g++spec.c, lex.c: Avoid ` as left quote in diagnostics."}, {"sha": "0f0bfb290679c55a80eb47421629c3202a91123f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -3745,8 +3745,8 @@ extern tree get_scope_of_declarator             (const cp_declarator *);\n extern void grok_special_member_properties\t(tree);\n extern int grok_ctor_properties\t\t\t(tree, tree);\n extern bool grok_op_properties\t\t\t(tree, int, bool);\n-extern tree xref_tag\t\t\t\t(enum tag_types, tree, bool, bool);\n-extern tree xref_tag_from_type\t\t\t(tree, tree, int);\n+extern tree xref_tag\t\t\t\t(enum tag_types, tree, tag_scope, bool);\n+extern tree xref_tag_from_type\t\t\t(tree, tree, tag_scope);\n extern void xref_basetypes\t\t\t(tree, tree);\n extern tree start_enum\t\t\t\t(tree);\n extern void finish_enum\t\t\t\t(tree);"}, {"sha": "98ca4f944ad870d56e0268ccbcd3a90adb066a7e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -82,7 +82,7 @@ static int typename_compare (const void *, const void *);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n static tree record_builtin_java_type (const char *, int);\n static const char *tag_name (enum tag_types);\n-static tree lookup_and_check_tag (enum tag_types, tree, bool globalize, bool);\n+static tree lookup_and_check_tag (enum tag_types, tree, tag_scope, bool);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n static int walk_globals_r (tree, void*);\n static int walk_vtables_r (tree, void*);\n@@ -9122,20 +9122,20 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n }\n \n /* Lookup NAME in elaborate type specifier in scope according to\n-   GLOBALIZE and issue diagnostics if necessary.\n+   SCOPE and issue diagnostics if necessary.\n    Return *_TYPE node upon success, NULL_TREE when the NAME is not\n    found, and ERROR_MARK_NODE for type error.  */\n \n static tree\n lookup_and_check_tag (enum tag_types tag_code, tree name,\n-\t\t      bool globalize, bool template_header_p)\n+\t\t      tag_scope scope, bool template_header_p)\n {\n   tree t;\n   tree decl;\n-  if (globalize)\n+  if (scope == ts_global)\n     decl = lookup_name (name, 2);\n   else\n-    decl = lookup_type_scope (name);\n+    decl = lookup_type_scope (name, scope);\n \n   if (decl && DECL_CLASS_TEMPLATE_P (decl))\n     decl = DECL_TEMPLATE_RESULT (decl);\n@@ -9174,16 +9174,18 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n    If a declaration is given, process it here, and report an error if\n    multiple declarations are not identical.\n \n-   GLOBALIZE is false when this is also a definition.  Only look in\n+   SCOPE is TS_CURRENT when this is also a definition.  Only look in\n    the current frame for the name (since C++ allows new names in any\n-   scope.)\n+   scope.)  It is TS_WITHIN_ENCLOSING_NON_CLASS if this is a friend\n+   declaration.  Only look beginning from the current scope outward up\n+   till the nearest non-class scope.  Otherwise it is TS_GLOBAL.\n \n    TEMPLATE_HEADER_P is true when this declaration is preceded by\n    a set of template parameters.  */\n \n tree\n xref_tag (enum tag_types tag_code, tree name,\n-\t  bool globalize, bool template_header_p)\n+\t  tag_scope scope, bool template_header_p)\n {\n   enum tree_code code;\n   tree t;\n@@ -9215,16 +9217,16 @@ xref_tag (enum tag_types tag_code, tree name,\n     t = NULL_TREE;\n   else\n     t = lookup_and_check_tag  (tag_code, name,\n-\t\t\t       globalize, template_header_p);\n+\t\t\t       scope, template_header_p);\n \n   if (t == error_mark_node)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n-  if (globalize && t && current_class_type\n+  if (scope != ts_current && t && current_class_type\n       && template_class_depth (current_class_type)\n       && template_header_p)\n     {\n-      /* Since GLOBALIZE is nonzero, we are not looking at a\n+      /* Since SCOPE is not TS_CURRENT, we are not looking at a\n \t definition of this tag.  Since, in addition, we are currently\n \t processing a (member) template declaration of a template\n \t class, we must be very careful; consider:\n@@ -9279,12 +9281,13 @@ xref_tag (enum tag_types tag_code, tree name,\n \t{\n \t  t = make_aggr_type (code);\n \t  TYPE_CONTEXT (t) = context;\n-\t  pushtag (name, t, globalize);\n+\t  /* pushtag only cares whether SCOPE is zero or not.  */\n+\t  pushtag (name, t, scope != ts_current);\n \t}\n     }\n   else\n     {\n-      if (!globalize && processing_template_decl && IS_AGGR_TYPE (t))\n+      if (template_header_p && IS_AGGR_TYPE (t))\n \tredeclare_class_template (t, current_template_parms);\n       else if (!processing_template_decl\n \t       && CLASS_TYPE_P (t)\n@@ -9299,7 +9302,7 @@ xref_tag (enum tag_types tag_code, tree name,\n }\n \n tree\n-xref_tag_from_type (tree old, tree id, int globalize)\n+xref_tag_from_type (tree old, tree id, tag_scope scope)\n {\n   enum tag_types tag_kind;\n \n@@ -9311,7 +9314,7 @@ xref_tag_from_type (tree old, tree id, int globalize)\n   if (id == NULL_TREE)\n     id = TYPE_IDENTIFIER (old);\n \n-  return xref_tag (tag_kind, id, globalize, false);\n+  return xref_tag (tag_kind, id, scope, false);\n }\n \n /* Create the binfo hierarchy for REF with (possibly NULL) base list\n@@ -9499,22 +9502,25 @@ xref_basetypes (tree ref, tree base_list)\n \n \f\n /* Begin compiling the definition of an enumeration type.\n-   NAME is its name (or null if anonymous).\n+   NAME is its name.\n    Returns the type object, as yet incomplete.\n    Also records info about it so that build_enumerator\n    may be used to declare the individual values as they are read.  */\n \n tree\n start_enum (tree name)\n {\n-  tree enumtype = NULL_TREE;\n+  tree enumtype;\n+\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n      forward reference.  */\n \n-  if (name != NULL_TREE)\n-    enumtype = lookup_and_check_tag (enum_type, name, 0, 0);\n+  enumtype = lookup_and_check_tag (enum_type, name,\n+\t\t\t\t   /*tag_scope=*/ts_current,\n+\t\t\t\t   /*template_header_p=*/false);\n \n   if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n     {\n@@ -9525,6 +9531,11 @@ start_enum (tree name)\n     }\n   else\n     {\n+      /* In case of error, make a dummy enum to allow parsing to\n+\t continue.  */\n+      if (enumtype == error_mark_node)\n+\tname = make_anon_name ();\n+\n       enumtype = make_node (ENUMERAL_TYPE);\n       pushtag (name, enumtype, 0);\n     }"}, {"sha": "a0188620759b21d6f32b929863aa98c95a43bd35", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -4088,11 +4088,7 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n \n   /* Now lookup in namespace scopes.  */\n   if (!val)\n-    {\n-      tree t = unqualified_namespace_lookup (name, flags);\n-      if (t)\n-\tval = t;\n-    }\n+    val = unqualified_namespace_lookup (name, flags);\n \n   if (val)\n     {\n@@ -4128,15 +4124,18 @@ lookup_name (tree name, int prefer_type)\n }\n \n /* Look up NAME for type used in elaborated name specifier in\n-   the current scope (possibly more if cleanup or template parameter\n-   scope is encounter).  Unlike lookup_name_real, we make sure that\n-   NAME is actually declared in the desired scope, not from inheritance,\n-   using declaration, nor using directive.  A TYPE_DECL best matching\n-   the NAME is returned.  Catching error and issuing diagnostics are\n-   caller's responsibility.  */\n+   the scopes given by SCOPE.  SCOPE can be either TS_CURRENT or\n+   TS_WITHIN_ENCLOSING_NON_CLASS (possibly more scope is checked if \n+   cleanup or template parameter scope is encountered).\n+\n+   Unlike lookup_name_real, we make sure that NAME is actually\n+   declared in the desired scope, not from inheritance, using \n+   declaration, nor using directive.  A TYPE_DECL best matching\n+   the NAME is returned.  Catching error and issuing diagnostics\n+   are caller's responsibility.  */\n \n tree\n-lookup_type_scope (tree name)\n+lookup_type_scope (tree name, tag_scope scope)\n {\n   cxx_binding *iter = NULL;\n   tree val = NULL_TREE;\n@@ -4149,19 +4148,22 @@ lookup_type_scope (tree name)\n   for (; iter; iter = outer_binding (name, iter, /*class_p=*/ true))\n     {\n       /* Check if this is the kind of thing we're looking for.\n-\t Make sure it doesn't come from base class.  For ITER->VALUE,\n-\t we can simply use INHERITED_VALUE_BINDING_P.  For ITER->TYPE,\n-\t we have to use our own check.\n+\t If SCOPE is TS_CURRENT, also make sure it doesn't come from \n+\t base class.  For ITER->VALUE, we can simply use\n+\t INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to use \n+\t our own check.\n \n \t We check ITER->TYPE before ITER->VALUE in order to handle\n \t   typedef struct C {} C;\n \t correctly.  */\n \n       if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES)\n-\t  && (LOCAL_BINDING_P (iter)\n+\t  && (scope != ts_current\n+\t      || LOCAL_BINDING_P (iter)\n \t      || DECL_CONTEXT (iter->type) == iter->scope->this_entity))\n \tval = iter->type;\n-      else if (!INHERITED_VALUE_BINDING_P (iter)\n+      else if ((scope != ts_current\n+\t\t|| !INHERITED_VALUE_BINDING_P (iter))\n \t       && qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n \tval = iter->value;\n \n@@ -4177,16 +4179,21 @@ lookup_type_scope (tree name)\n \n       if (iter)\n \t{\n-\t  /* If this is the kind of thing we're looking for, we're done.  */\n-\t  if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES))\n+\t  /* If this is the kind of thing we're looking for, we're done.\n+\t     Ignore names found via using declaration.  See DR138 for\n+\t     current status.  */\n+\t  if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES)\n+\t      && (CP_DECL_CONTEXT (iter->type) == iter->scope->this_entity))\n \t    val = iter->type;\n-\t  else if (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n+\t  else if (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES)\n+\t\t   && (CP_DECL_CONTEXT (iter->value)\n+\t\t       == iter->scope->this_entity))\n \t    val = iter->value;\n \t}\n \t\n     }\n \n-  /* Type found, check if it is in the current scope, ignoring cleanup\n+  /* Type found, check if it is in the allowed scopes, ignoring cleanup\n      and template parameter scopes.  */\n   if (val)\n     {\n@@ -4198,6 +4205,9 @@ lookup_type_scope (tree name)\n \n \t  if (b->kind == sk_cleanup || b->kind == sk_template_parms)\n \t    b = b->level_chain;\n+\t  else if (b->kind == sk_class\n+\t\t   && scope == ts_within_enclosing_non_class)\n+\t    b = b->level_chain;\n \t  else\n \t    break;\n \t}"}, {"sha": "08a9ba504b9e99307832a0841add3ba61934a971", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -125,6 +125,22 @@ typedef enum scope_kind {\n \t\t\t\"template <>\", this scope is always empty.  */\n } scope_kind;\n \n+/* The scope where the class/struct/union/enum tag applies.  */\n+typedef enum tag_scope {\n+  ts_current = 0,\t/* Current scope only.  This is for the\n+\t\t\t     class-key identifier;\n+\t\t\t   case mentioned in [basic.lookup.elab]/2,\n+\t\t\t   or the class/enum definition\n+\t\t\t     class-key identifier { ... };  */\n+  ts_global = 1,\t/* All scopes.  This is the 3.4.1\n+\t\t\t   [basic.lookup.unqual] lookup mentioned\n+\t\t\t   in [basic.lookup.elab]/2.  */\n+  ts_within_enclosing_non_class = 2\t/* Search within enclosing non-class\n+\t\t\t\t\t   only, for friend class lookup\n+\t\t\t\t\t   according to [namespace.memdef]/3\n+\t\t\t\t\t   and [class.friend]/9.  */\n+} tag_scope;\n+\n typedef struct cp_class_binding GTY(())\n {\n   cxx_binding base;\n@@ -303,7 +319,7 @@ extern tree lookup_tag (enum tree_code, tree, cxx_scope *, int);\n extern tree lookup_tag_reverse (tree, tree);\n extern tree lookup_name\t(tree, int);\n extern tree lookup_name_real (tree, int, int, bool, int, int);\n-extern tree lookup_type_scope (tree);\n+extern tree lookup_type_scope (tree, tag_scope);\n extern tree namespace_binding (tree, tree);\n extern void set_namespace_binding (tree, tree, tree);\n extern tree lookup_namespace_name (tree, tree);"}, {"sha": "3548b45c117515e13b38f022c9aae6a9b77f874d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -9731,15 +9731,23 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t     definition of a new type; a new type can only be declared in a\n \t     declaration context.  */\n \n+\t  tag_scope ts;\n+\t  if (is_friend)\n+\t    /* Friends have special name lookup rules.  */\n+\t    ts = ts_within_enclosing_non_class;\n+\t  else if (is_declaration\n+\t\t   && cp_lexer_next_token_is (parser->lexer,\n+\t\t\t\t\t      CPP_SEMICOLON))\n+\t    /* This is a `class-key identifier ;' */\n+\t    ts = ts_current;\n+\t  else\n+\t    ts = ts_global;\n+\n  \t  /* Warn about attributes. They are ignored.  */\n  \t  if (attributes)\n \t    warning (\"type attributes are honored only at type definition\");\n \n-\t  type = xref_tag (tag_type, identifier,\n-\t\t\t   (is_friend\n-\t\t\t    || !is_declaration\n-\t\t\t    || cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t\t\t\t   CPP_SEMICOLON)),\n+\t  type = xref_tag (tag_type, identifier, ts,\n \t\t\t   parser->num_template_parameter_lists);\n \t}\n     }\n@@ -12642,7 +12650,7 @@ cp_parser_class_head (cp_parser* parser,\n       /* If the class was unnamed, create a dummy name.  */\n       if (!id)\n \tid = make_anon_name ();\n-      type = xref_tag (class_key, id, /*globalize=*/false,\n+      type = xref_tag (class_key, id, /*tag_scope=*/ts_current,\n \t\t       parser->num_template_parameter_lists);\n     }\n   else"}, {"sha": "b514cc1430137d0cf36a542a5a382d1f2bcde727", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -4576,7 +4576,7 @@ lookup_template_class (tree d1,\n \t{\n \t  found = xref_tag_from_type (TREE_TYPE (template),\n \t\t\t\t      DECL_NAME (template),\n-\t\t\t\t      /*globalize=*/1);\n+\t\t\t\t      /*tag_scope=*/ts_global);\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \t}\n       \n@@ -5788,7 +5788,8 @@ instantiate_class_template (tree type)\n \t\t     classes.  */\n \t\t  push_nested_namespace (ns);\n \t\t  friend_type = \n-\t\t    xref_tag_from_type (friend_type, NULL_TREE, 1);\n+\t\t    xref_tag_from_type (friend_type, NULL_TREE, \n+\t\t\t\t\t/*tag_scope=*/ts_global);\n \t\t  pop_nested_namespace (ns);\n \t\t}\n "}, {"sha": "cf66904b9b6dfdf36ac31b2e75da4e6bbd564aa1", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -113,7 +113,7 @@ init_rtti_processing (void)\n   push_namespace (std_identifier);\n   type_info_type_node \n     = xref_tag (class_type, get_identifier (\"type_info\"),\n-\t\ttrue, false);\n+\t\t/*tag_scope=*/ts_global, false);\n   pop_namespace ();\n   const_type_info_type = build_qualified_type (type_info_type_node, \n \t\t\t\t\t       TYPE_QUAL_CONST);\n@@ -628,7 +628,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      push_nested_namespace (ns);\n \t      tinfo_ptr = xref_tag (class_type,\n \t\t\t\t    get_identifier (\"__class_type_info\"),\n-\t\t\t\t    true, false);\n+\t\t\t\t    /*tag_scope=*/ts_global, false);\n \t      \n \t      tinfo_ptr = build_pointer_type\n \t\t(build_qualified_type\n@@ -808,7 +808,7 @@ tinfo_base_init (tree desc, tree target)\n   \n       push_nested_namespace (abi_node);\n       real_type = xref_tag (class_type, TINFO_REAL_NAME (desc),\n-\t\t\t    true, false);\n+\t\t\t    /*tag_scope=*/ts_global, false);\n       pop_nested_namespace (abi_node);\n   \n       if (!COMPLETE_TYPE_P (real_type))\n@@ -1340,7 +1340,7 @@ emit_support_tinfos (void)\n   push_nested_namespace (abi_node);\n   bltn_type = xref_tag (class_type,\n \t\t\tget_identifier (\"__fundamental_type_info\"), \n-\t\t\ttrue, false);\n+\t\t\t/*tag_scope=*/ts_global, false);\n   pop_nested_namespace (abi_node);\n   if (!COMPLETE_TYPE_P (bltn_type))\n     return;"}, {"sha": "e82c3fd17db67ab75710ca4811302ca9153536ae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -1,3 +1,9 @@\n+2004-11-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tFriend class name lookup 2/n, PR c++/14513, c++/15410\n+\t* g++.dg/lookup/friend2.C: New test.\n+\t* g++.dg/template/friend31.C: Likewise.\n+\n 2004-11-24  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* lib/target-libpath.exp (orig_ld_library_path_saved): Add missing set."}, {"sha": "765c69b67eb4862022a7b8887c2553dee7cb7aae", "filename": "gcc/testsuite/g++.dg/lookup/friend2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend2.C?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+\n+// Origin: Albert Chin <bugzilla-gcc@thewrittenword.com>\n+//\t   Wolfgang Bangerth <bangerth@dealii.org>\n+\n+// PR c++/14513, unqualified lookup of friend class.\n+\n+struct S {\n+    void test (void);\n+};\n+\n+namespace NS {\n+  class X {\n+      friend class S;\n+      static int *i;\t// { dg-error \"private\" }\n+  };\n+}\n+\n+void S::test () {\n+  NS::X::i;\t\t// { dg-error \"this context\" }\n+}"}, {"sha": "2d62f878a21a0cd0f8df7242770e1583521a53df", "filename": "gcc/testsuite/g++.dg/template/friend31.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef83dee9acfdee32507bff8c536ae26f922402/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend31.C?ref=29ef83dee9acfdee32507bff8c536ae26f922402", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+\n+// Origin: Ivan Godard <igodard@pacbell.net>\n+\n+// PR c++/15410: Declaration of friend class template with wrong\n+// template parameter.\n+\n+template <typename T, typename U> struct F; // { dg-error \"previous declaration\" }\n+\n+class W\n+{\n+  template<int i> friend class F;\t// { dg-error \"template parameter\" }\n+  int x;\n+};\n+\n+template <typename T, typename U> struct F\n+{\n+  void Look(W& w) { w.x = 3; }\n+};\n+\n+int main()\n+{\n+  W w;\n+  F<char, bool> f;\n+  f.Look(w);\n+  return 0;\n+}"}]}