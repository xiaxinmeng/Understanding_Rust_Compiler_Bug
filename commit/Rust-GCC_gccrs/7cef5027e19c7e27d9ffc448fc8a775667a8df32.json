{"sha": "7cef5027e19c7e27d9ffc448fc8a775667a8df32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NlZjUwMjdlMTljN2UyN2Q5ZmZjNDQ4ZmM4YTc3NTY2N2E4ZGYzMg==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2004-05-10T15:08:07Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-05-10T15:08:07Z"}, "message": "parse.y (check_pkg_class_access): Add new argument and use it when cl is NULL to call lookup_cl on it.\n\n2004-05-10  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        * parse.y (check_pkg_class_access): Add new argument\n        and use it when cl is NULL to call lookup_cl on it.\n        (parser_check_super_interface): Do not call lookup_cl.\n        Pass this_decl to check_pkg_class_access and NULL\n        instead of lookup_cl.\n        (parser_check_super): Update for change in\n        check_pkg_class_access.\n        (do_resolve_class): Likewise.\n        (process_imports): Likewise.\n        (find_in_imports_on_demand): Likewise.\n        (resolve_qualified_expression_name): Likewise.\n\nFrom-SVN: r81668", "tree": {"sha": "a0c4c23c7a38d0d6d91ec8b2ee6d9f789decdc4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0c4c23c7a38d0d6d91ec8b2ee6d9f789decdc4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cef5027e19c7e27d9ffc448fc8a775667a8df32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cef5027e19c7e27d9ffc448fc8a775667a8df32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cef5027e19c7e27d9ffc448fc8a775667a8df32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cef5027e19c7e27d9ffc448fc8a775667a8df32/comments", "author": null, "committer": null, "parents": [{"sha": "731d47a63b3841de6310a01280dc7ff0d00a22bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731d47a63b3841de6310a01280dc7ff0d00a22bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/731d47a63b3841de6310a01280dc7ff0d00a22bf"}], "stats": {"total": 38, "additions": 27, "deletions": 11}, "files": [{"sha": "683fa60662e1020cd2974abd479dd52d7cb15e3b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cef5027e19c7e27d9ffc448fc8a775667a8df32/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cef5027e19c7e27d9ffc448fc8a775667a8df32/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=7cef5027e19c7e27d9ffc448fc8a775667a8df32", "patch": "@@ -1,3 +1,17 @@\n+2004-05-10  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* parse.y (check_pkg_class_access): Add new argument\n+\tand use it when cl is NULL to call lookup_cl on it.\n+\t(parser_check_super_interface): Do not call lookup_cl.\n+\tPass this_decl to check_pkg_class_access and NULL\n+\tinstead of lookup_cl.\n+\t(parser_check_super): Update for change in\n+\tcheck_pkg_class_access.\n+\t(do_resolve_class): Likewise.\n+\t(process_imports): Likewise.\n+\t(find_in_imports_on_demand): Likewise.\n+\t(resolve_qualified_expression_name): Likewise.\n+\n 2004-05-06  Ranjit Mathew  <rmathew@hotmail.com>\n \n \tFixes PR java/9685, PR java/15073"}, {"sha": "0649dbe6de19103211bd72f5e7813dc9942d0484", "filename": "gcc/java/parse.y", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cef5027e19c7e27d9ffc448fc8a775667a8df32/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cef5027e19c7e27d9ffc448fc8a775667a8df32/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=7cef5027e19c7e27d9ffc448fc8a775667a8df32", "patch": "@@ -107,7 +107,7 @@ static void read_import_dir (tree);\n static int find_in_imports_on_demand (tree, tree);\n static void find_in_imports (tree, tree);\n static void check_inner_class_access (tree, tree, tree);\n-static int check_pkg_class_access (tree, tree, bool);\n+static int check_pkg_class_access (tree, tree, bool, tree);\n static void register_package (tree);\n static tree resolve_package (tree, tree *, tree *);\n static tree resolve_class (tree, tree, tree, tree);\n@@ -5079,7 +5079,7 @@ parser_check_super_interface (tree super_decl, tree this_decl, tree this_wfl)\n      access rules (6.6.1). */\n   if (! INNER_CLASS_P (super_type)\n       && check_pkg_class_access (DECL_NAME (super_decl),\n-\t\t\t\t lookup_cl (this_decl), true))\n+\t\t\t\t NULL_TREE, true, this_decl))\n     return 1;\n \n   SOURCE_FRONTEND_DEBUG ((\"Completing interface %s with %s\",\n@@ -5117,7 +5117,7 @@ parser_check_super (tree super_decl, tree this_decl, tree wfl)\n   /* Check top-level class scope. Inner classes are subject to member access\n      rules (6.6.1). */\n   if (! INNER_CLASS_P (super_type)\n-      && (check_pkg_class_access (DECL_NAME (super_decl), wfl, true)))\n+      && (check_pkg_class_access (DECL_NAME (super_decl), wfl, true, NULL_TREE)))\n     return 1;\n \n   SOURCE_FRONTEND_DEBUG ((\"Completing class %s with %s\",\n@@ -5857,7 +5857,7 @@ do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n      by the caller. */\n   if (cl)\n     {\n-      if (check_pkg_class_access (TYPE_NAME (class_type), cl, true))\n+      if (check_pkg_class_access (TYPE_NAME (class_type), cl, true, NULL_TREE))\n         return NULL_TREE;\n     }\n \n@@ -6817,7 +6817,7 @@ process_imports (void)\n \t  QUALIFIED_P (to_be_found) = 1;\n \t  load_class (to_be_found, 0);\n \t  error_found =\n-\t    check_pkg_class_access (to_be_found, TREE_PURPOSE (import), true);\n+\t    check_pkg_class_access (to_be_found, TREE_PURPOSE (import), true, NULL_TREE);\n \n \t  /* We found it, we can bail out */\n \t  if (IDENTIFIER_CLASS_VALUE (to_be_found))\n@@ -7061,7 +7061,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \t}\n       if (decl && ! INNER_CLASS_P (TREE_TYPE (decl)))\n \taccess_check = check_pkg_class_access (node, TREE_PURPOSE (import),\n-\t\t\t\t\t       false);\n+\t\t\t\t\t       false, NULL_TREE);\n       else\n \t/* 6.6.1: Inner classes are subject to member access rules. */\n \taccess_check = 0;\n@@ -7247,10 +7247,11 @@ check_inner_class_access (tree decl, tree enclosing_decl, tree cl)\n /* Accessibility check for top-level classes. If CLASS_NAME is in a\n    foreign package, it must be PUBLIC. Return 0 if no access\n    violations were found, 1 otherwise. If VERBOSE is true and an error\n-   was found, it is reported and accounted for.  */\n+   was found, it is reported and accounted for.  If CL is NULL then \n+   look it up with THIS_DECL.  */\n \n static int\n-check_pkg_class_access (tree class_name, tree cl, bool verbose)\n+check_pkg_class_access (tree class_name, tree cl, bool verbose, tree this_decl)\n {\n   tree type;\n \n@@ -7275,7 +7276,8 @@ check_pkg_class_access (tree class_name, tree cl, bool verbose)\n \n       if (verbose)\n \tparse_error_context\n-\t  (cl, \"Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed\",\n+\t  (cl == NULL ? lookup_cl (this_decl): cl,\n+           \"Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed\",\n \t   (CLASS_INTERFACE (TYPE_NAME (type)) ? \"interface\" : \"class\"),\n \t   IDENTIFIER_POINTER (class_name));\n       return 1;\n@@ -9836,7 +9838,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      tree list;\n \t      *where_found = decl;\n \n-\t      check_pkg_class_access (DECL_NAME (decl), qual_wfl, true);\n+\t      check_pkg_class_access (DECL_NAME (decl), qual_wfl, true, NULL);\n \n \t      /* We want to be absolutely sure that the class is laid\n                  out. We're going to search something inside it. */\n@@ -9888,7 +9890,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t      return 1;\n \t    }\n \n-\t  check_pkg_class_access (DECL_NAME (decl), qual_wfl, true);\n+\t  check_pkg_class_access (DECL_NAME (decl), qual_wfl, true, NULL);\n           \n \t  check_deprecation (qual_wfl, decl);\n "}]}