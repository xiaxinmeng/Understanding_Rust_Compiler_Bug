{"sha": "51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f", "node_id": "C_kwDOANBUbNoAKDUxZTM4ZjNiMjg3MzU1NGY2NDgxYjBkYzFlN2NkNGI4MzU5YTJiNWY", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2021-09-14T00:14:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-25T15:07:22Z"}, "message": "[Ada] Spurious error on user-defined literal and operator\n\ngcc/ada/\n\n\t* sem_ch4.adb (Has_Possible_Literal_Aspects): If analysis of an\n\toperator node fails to find  a possible interpretation, and one\n\tof its operands is a literal or a named number, assign to the\n\tnode the corresponding class type (Any_Integer, Any_String,\n\tetc).\n\t(Operator_Check): Call it before emitting a type error.\n\t* sem_res.adb (Has_Applicable_User_Defined_Literal): Given a\n\tliteral and a type, determine whether the type has a\n\tuser_defined aspect that can apply to the literal, and rewrite\n\tthe node as call to the corresponding function. Most of the code\n\twas previously in procedure Resolve.\n\t(Try_User_Defined_Literal): Check operands of a predefined\n\toperator that fails to resolve, and apply\n\tHas_Applicable_User_Defined_Literal to literal operands if any,\n\tto find if a conversion will allow the operator to resolve\n\tproperly.\n\t(Resolve): Call the above when a literal or an operator with a\n\tliteral operand fails to resolve.", "tree": {"sha": "467ebbdb854f114de48f555e0646e46df8febac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/467ebbdb854f114de48f555e0646e46df8febac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42b39995546a63fe7d9313744cdab21f356346b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42b39995546a63fe7d9313744cdab21f356346b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42b39995546a63fe7d9313744cdab21f356346b2"}], "stats": {"total": 484, "additions": 339, "deletions": 145}, "files": [{"sha": "22039f5f245b8000b0f061c8b632836b28c1a5d8", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f", "patch": "@@ -281,6 +281,19 @@ package body Sem_Ch4 is\n    --  type is not directly visible. The routine uses this type to emit a more\n    --  informative message.\n \n+   function Has_Possible_Literal_Aspects (N : Node_Id) return Boolean;\n+   --  Ada_2022: if an operand is a literal it may be subject to an\n+   --  implicit conversion to a type for which a user-defined literal\n+   --  function exists. During the first pass of type resolution we do\n+   --  not know the context imposed on the literal, so we assume that\n+   --  the literal type is a valid candidate and rely on the second pass\n+   --  of resolution to find the type with the proper aspect. We only\n+   --  add this interpretation if no other one was found, which may be\n+   --  too restrictive but seems sufficient to handle most proper uses\n+   --  of the new aspect. It is unclear whether a full implementation of\n+   --  these aspects can be achieved without larger modifications to the\n+   --  two-pass resolution algorithm.\n+\n    procedure Remove_Abstract_Operations (N : Node_Id);\n    --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n    --  operation is not a candidate interpretation.\n@@ -7541,6 +7554,9 @@ package body Sem_Ch4 is\n             then\n                return;\n \n+            elsif Has_Possible_Literal_Aspects (N) then\n+               return;\n+\n             --  If we have a logical operator, one of whose operands is\n             --  Boolean, then we know that the other operand cannot resolve to\n             --  Boolean (since we got no interpretations), but in that case we\n@@ -7857,6 +7873,69 @@ package body Sem_Ch4 is\n       end if;\n    end Operator_Check;\n \n+   ----------------------------------\n+   -- Has_Possible_Literal_Aspects --\n+   ----------------------------------\n+\n+   function Has_Possible_Literal_Aspects (N : Node_Id) return Boolean is\n+      R : constant Node_Id := Right_Opnd (N);\n+      L : Node_Id := Empty;\n+\n+      procedure Check_Literal_Opnd (Opnd : Node_Id);\n+      --  If an operand is a literal to which an aspect may apply,\n+      --  add the corresponding type to operator node.\n+\n+      ------------------------\n+      -- Check_Literal_Opnd --\n+      ------------------------\n+\n+      procedure Check_Literal_Opnd (Opnd : Node_Id) is\n+      begin\n+         if Nkind (Opnd) in N_Numeric_Or_String_Literal\n+           or else (Is_Entity_Name (Opnd)\n+             and then Present (Entity (Opnd))\n+             and then Is_Named_Number (Entity (Opnd)))\n+         then\n+            Add_One_Interp (N, Etype (Opnd), Etype (Opnd));\n+         end if;\n+      end Check_Literal_Opnd;\n+\n+   --  Start of processing for Has_Possible_Literal_Aspects\n+\n+   begin\n+      if Ada_Version < Ada_2022 then\n+         return False;\n+      end if;\n+\n+      if Nkind (N) in N_Binary_Op then\n+         L := Left_Opnd (N);\n+      else\n+         L := Empty;\n+      end if;\n+      Check_Literal_Opnd (R);\n+\n+      --  Check left operand only if right one did not provide a\n+      --  possible interpretation. Note that literal types are not\n+      --  overloadable, in the sense that there is no overloadable\n+      --  entity name whose several interpretations can be used to\n+      --  indicate possible resulting types, so there is no way to\n+      --  provide more than one interpretation to the operator node.\n+      --  The choice of one operand over the other is arbitrary at\n+      --  this point, and may lead to spurious resolution when both\n+      --  operands are literals of different kinds, but the second\n+      --  pass of resolution will examine anew both operands to\n+      --  determine whether a user-defined literal may apply to\n+      --  either or both.\n+\n+      if Present (L)\n+        and then Etype (N) = Any_Type\n+      then\n+         Check_Literal_Opnd (L);\n+      end if;\n+\n+      return Etype (N) /= Any_Type;\n+   end Has_Possible_Literal_Aspects;\n+\n    --------------------------------\n    -- Remove_Abstract_Operations --\n    --------------------------------"}, {"sha": "09a76f1993006ea96ebd1106eaf2b62bbb152966", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 260, "deletions": 145, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=51e38f3b2873554f6481b0dc1e7cd4b8359a2b5f", "patch": "@@ -103,6 +103,14 @@ package body Sem_Res is\n \n    --  Note that Resolve_Attribute is separated off in Sem_Attr\n \n+   function Has_Applicable_User_Defined_Literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean;\n+   --  If N is a literal or a named number, check whether Typ\n+   --  has a user-defined literal aspect that can apply to N.\n+   --  If present, replace N with a call to the corresponding\n+   --  function and return True.\n+\n    procedure Check_Discriminant_Use (N : Node_Id);\n    --  Enforce the restrictions on the use of discriminants when constraining\n    --  a component of a discriminated type (record or concurrent type).\n@@ -286,6 +294,15 @@ package body Sem_Res is\n    --  is only one requires a search over all visible entities, and happens\n    --  only in very pathological cases (see 6115-006).\n \n+   function Try_User_Defined_Literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean;\n+   --  If an operator node has a literal operand, check whether the type\n+   --  of the context, or the type of the other operand has a user-defined\n+   --  literal aspect that can be applied to the literal to resolve the node.\n+   --  If such aspect exists, replace literal with a call to the\n+   --  corresponing function and return True, return false otherwise.\n+\n    -------------------------\n    -- Ambiguous_Character --\n    -------------------------\n@@ -409,6 +426,165 @@ package body Sem_Res is\n       end if;\n    end Analyze_And_Resolve;\n \n+   -------------------------------------\n+   -- Has_Applicable_User_Defined_Literal --\n+   -------------------------------------\n+\n+   function Has_Applicable_User_Defined_Literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean\n+   is\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Literal_Aspect_Map :\n+        constant array (N_Numeric_Or_String_Literal) of Aspect_Id :=\n+          (N_Integer_Literal => Aspect_Integer_Literal,\n+           N_Real_Literal    => Aspect_Real_Literal,\n+           N_String_Literal  => Aspect_String_Literal);\n+\n+      Named_Number_Aspect_Map : constant array (Named_Kind) of Aspect_Id :=\n+        (E_Named_Integer => Aspect_Integer_Literal,\n+         E_Named_Real    => Aspect_Real_Literal);\n+\n+      Lit_Aspect : Aspect_Id;\n+\n+      Callee : Entity_Id;\n+      Name   : Node_Id;\n+      Param1 : Node_Id;\n+      Param2 : Node_Id;\n+      Params : List_Id;\n+      Call   : Node_Id;\n+      Expr   : Node_Id;\n+\n+   begin\n+      if (Nkind (N) in N_Numeric_Or_String_Literal\n+           and then Present\n+            (Find_Aspect (Typ, Literal_Aspect_Map (Nkind (N)))))\n+        or else\n+          (Nkind (N) = N_Identifier\n+            and then Is_Named_Number (Entity (N))\n+            and then\n+              Present\n+                (Find_Aspect\n+                  (Typ, Named_Number_Aspect_Map (Ekind (Entity (N))))))\n+      then\n+         Lit_Aspect :=\n+           (if Nkind (N) = N_Identifier\n+            then Named_Number_Aspect_Map (Ekind (Entity (N)))\n+            else Literal_Aspect_Map (Nkind (N)));\n+         Callee :=\n+           Entity (Expression (Find_Aspect (Typ, Lit_Aspect)));\n+         Name := Make_Identifier (Loc, Chars (Callee));\n+\n+         if Is_Derived_Type (Typ)\n+           and then Is_Tagged_Type (Typ)\n+           and then Base_Type (Etype (Callee)) /= Base_Type (Typ)\n+         then\n+            Callee :=\n+              Corresponding_Primitive_Op\n+                (Ancestor_Op     => Callee,\n+                 Descendant_Type => Base_Type (Typ));\n+         end if;\n+\n+         --  Handle an identifier that denotes a named number.\n+\n+         if Nkind (N) = N_Identifier then\n+            Expr := Expression (Declaration_Node (Entity (N)));\n+\n+            if Ekind (Entity (N)) = E_Named_Integer then\n+               UI_Image (Expr_Value (Expr), Decimal);\n+               Start_String;\n+               Store_String_Chars\n+                 (UI_Image_Buffer (1 .. UI_Image_Length));\n+               Param1 := Make_String_Literal (Loc, End_String);\n+               Params := New_List (Param1);\n+\n+            else\n+               UI_Image (Norm_Num (Expr_Value_R (Expr)), Decimal);\n+               Start_String;\n+\n+               if UR_Is_Negative (Expr_Value_R (Expr)) then\n+                  Store_String_Chars (\"-\");\n+               end if;\n+\n+               Store_String_Chars\n+                 (UI_Image_Buffer (1 .. UI_Image_Length));\n+               Param1 := Make_String_Literal (Loc, End_String);\n+\n+               --  Note: Set_Etype is called below on Param1\n+\n+               UI_Image (Norm_Den (Expr_Value_R (Expr)), Decimal);\n+               Start_String;\n+               Store_String_Chars\n+                 (UI_Image_Buffer (1 .. UI_Image_Length));\n+               Param2 := Make_String_Literal (Loc, End_String);\n+               Set_Etype (Param2, Standard_String);\n+\n+               Params := New_List (Param1, Param2);\n+\n+               if Present (Related_Expression (Callee)) then\n+                  Callee := Related_Expression (Callee);\n+               else\n+                  Error_Msg_NE\n+                    (\"cannot resolve & for a named real\", N, Callee);\n+                  return False;\n+               end if;\n+            end if;\n+\n+         elsif Nkind (N) = N_String_Literal then\n+            Param1 := Make_String_Literal (Loc, Strval (N));\n+            Params := New_List (Param1);\n+\n+         else\n+            Param1 :=\n+              Make_String_Literal\n+                (Loc, String_From_Numeric_Literal (N));\n+            Params := New_List (Param1);\n+         end if;\n+\n+         Call :=\n+           Make_Function_Call\n+             (Sloc                   => Loc,\n+              Name                   => Name,\n+              Parameter_Associations => Params);\n+\n+         Set_Entity (Name, Callee);\n+         Set_Is_Overloaded (Name, False);\n+\n+         if Lit_Aspect = Aspect_String_Literal then\n+            Set_Etype (Param1, Standard_Wide_Wide_String);\n+         else\n+            Set_Etype (Param1, Standard_String);\n+         end if;\n+\n+         Set_Etype (Call, Etype (Callee));\n+\n+         if Base_Type (Etype (Call)) /= Base_Type (Typ) then\n+            --  Conversion may be needed in case of an inherited\n+            --  aspect of a derived type. For a null extension, we\n+            --  use a null extension aggregate instead because the\n+            --  downward type conversion would be illegal.\n+\n+            if Is_Null_Extension_Of\n+                 (Descendant => Typ,\n+                  Ancestor   => Etype (Call))\n+            then\n+               Call := Make_Extension_Aggregate (Loc,\n+                         Ancestor_Part       => Call,\n+                         Null_Record_Present => True);\n+            else\n+               Call := Convert_To (Typ, Call);\n+            end if;\n+         end if;\n+\n+         Rewrite (N, Call);\n+\n+         Analyze_And_Resolve (N, Typ);\n+         return True;\n+      else\n+         return False;\n+      end if;\n+   end Has_Applicable_User_Defined_Literal;\n+\n    ----------------------------\n    -- Check_Discriminant_Use --\n    ----------------------------\n@@ -2156,16 +2332,6 @@ package body Sem_Res is\n          return;\n       end Resolution_Failed;\n \n-      Literal_Aspect_Map :\n-        constant array (N_Numeric_Or_String_Literal) of Aspect_Id :=\n-          (N_Integer_Literal => Aspect_Integer_Literal,\n-           N_Real_Literal    => Aspect_Real_Literal,\n-           N_String_Literal  => Aspect_String_Literal);\n-\n-      Named_Number_Aspect_Map : constant array (Named_Kind) of Aspect_Id :=\n-        (E_Named_Integer => Aspect_Integer_Literal,\n-         E_Named_Real    => Aspect_Real_Literal);\n-\n    --  Start of processing for Resolve\n \n    begin\n@@ -2884,143 +3050,14 @@ package body Sem_Res is\n                end;\n             end if;\n \n-            --  Rewrite Literal as a call if the corresponding literal aspect\n-            --  is set.\n+            --  If node is a literal and context type has a user-defined\n+            --  literal aspect, rewrite node as a call to the corresponding\n+            --  function, which plays the role of an implicit conversion.\n \n-            if (Nkind (N) in N_Numeric_Or_String_Literal\n-                 and then\n-                   Present\n-                     (Find_Aspect (Typ, Literal_Aspect_Map (Nkind (N)))))\n-              or else\n-                (Nkind (N) = N_Identifier\n-                  and then Is_Named_Number (Entity (N))\n-                  and then\n-                    Present\n-                      (Find_Aspect\n-                        (Typ, Named_Number_Aspect_Map (Ekind (Entity (N))))))\n+            if Nkind (N) in\n+                N_Numeric_Or_String_Literal | N_Identifier\n+              and then Has_Applicable_User_Defined_Literal (N, Typ)\n             then\n-               declare\n-                  Lit_Aspect : constant Aspect_Id :=\n-                    (if Nkind (N) = N_Identifier\n-                     then Named_Number_Aspect_Map (Ekind (Entity (N)))\n-                     else Literal_Aspect_Map (Nkind (N)));\n-\n-                  Loc  : constant Source_Ptr := Sloc (N);\n-\n-                  Callee : Entity_Id :=\n-                    Entity (Expression (Find_Aspect (Typ, Lit_Aspect)));\n-\n-                  Name : constant Node_Id :=\n-                    Make_Identifier (Loc, Chars (Callee));\n-\n-                  Param1 : Node_Id;\n-                  Param2 : Node_Id;\n-                  Params : List_Id;\n-                  Call   : Node_Id;\n-                  Expr   : Node_Id;\n-\n-               begin\n-                  if Is_Derived_Type (Typ)\n-                    and then Is_Tagged_Type (Typ)\n-                    and then Base_Type (Etype (Callee)) /= Base_Type (Typ)\n-                  then\n-                     Callee :=\n-                       Corresponding_Primitive_Op\n-                         (Ancestor_Op     => Callee,\n-                          Descendant_Type => Base_Type (Typ));\n-                  end if;\n-\n-                  if Nkind (N) = N_Identifier then\n-                     Expr := Expression (Declaration_Node (Entity (N)));\n-\n-                     if Ekind (Entity (N)) = E_Named_Integer then\n-                        UI_Image (Expr_Value (Expr), Decimal);\n-                        Start_String;\n-                        Store_String_Chars\n-                          (UI_Image_Buffer (1 .. UI_Image_Length));\n-                        Param1 := Make_String_Literal (Loc, End_String);\n-                        Params := New_List (Param1);\n-\n-                     else\n-                        UI_Image (Norm_Num (Expr_Value_R (Expr)), Decimal);\n-                        Start_String;\n-\n-                        if UR_Is_Negative (Expr_Value_R (Expr)) then\n-                           Store_String_Chars (\"-\");\n-                        end if;\n-\n-                        Store_String_Chars\n-                          (UI_Image_Buffer (1 .. UI_Image_Length));\n-                        Param1 := Make_String_Literal (Loc, End_String);\n-\n-                        --  Note: Set_Etype is called below on Param1\n-\n-                        UI_Image (Norm_Den (Expr_Value_R (Expr)), Decimal);\n-                        Start_String;\n-                        Store_String_Chars\n-                          (UI_Image_Buffer (1 .. UI_Image_Length));\n-                        Param2 := Make_String_Literal (Loc, End_String);\n-                        Set_Etype (Param2, Standard_String);\n-\n-                        Params := New_List (Param1, Param2);\n-\n-                        if Present (Related_Expression (Callee)) then\n-                           Callee := Related_Expression (Callee);\n-                        else\n-                           Error_Msg_NE\n-                             (\"cannot resolve & for a named real\", N, Callee);\n-                           return;\n-                        end if;\n-                     end if;\n-\n-                  elsif Nkind (N) = N_String_Literal then\n-                     Param1 := Make_String_Literal (Loc, Strval (N));\n-                     Params := New_List (Param1);\n-                  else\n-                     Param1 :=\n-                       Make_String_Literal\n-                         (Loc, String_From_Numeric_Literal (N));\n-                     Params := New_List (Param1);\n-                  end if;\n-\n-                  Call :=\n-                    Make_Function_Call\n-                      (Sloc                   => Loc,\n-                       Name                   => Name,\n-                       Parameter_Associations => Params);\n-\n-                  Set_Entity (Name, Callee);\n-                  Set_Is_Overloaded (Name, False);\n-\n-                  if Lit_Aspect = Aspect_String_Literal then\n-                     Set_Etype (Param1, Standard_Wide_Wide_String);\n-                  else\n-                     Set_Etype (Param1, Standard_String);\n-                  end if;\n-\n-                  Set_Etype (Call, Etype (Callee));\n-\n-                  if Base_Type (Etype (Call)) /= Base_Type (Typ) then\n-                     --  Conversion may be needed in case of an inherited\n-                     --  aspect of a derived type. For a null extension, we\n-                     --  use a null extension aggregate instead because the\n-                     --  downward type conversion would be illegal.\n-\n-                     if Is_Null_Extension_Of\n-                          (Descendant => Typ,\n-                           Ancestor   => Etype (Call))\n-                     then\n-                        Call := Make_Extension_Aggregate (Loc,\n-                                  Ancestor_Part       => Call,\n-                                  Null_Record_Present => True);\n-                     else\n-                        Call := Convert_To (Typ, Call);\n-                     end if;\n-                  end if;\n-\n-                  Rewrite (N, Call);\n-               end;\n-\n                Analyze_And_Resolve (N, Typ);\n                return;\n             end if;\n@@ -3116,6 +3153,14 @@ package body Sem_Res is\n                     (\"missing ALL or SOME in quantified expression\",\n                      Defining_Identifier (First (Component_Associations (N))));\n \n+               --  For an operator with no interpretation, check whether\n+               --  one of its operands may be a user-defined literal.\n+\n+               elsif Nkind (N) in N_Op\n+                 and then Try_User_Defined_Literal (N, Typ)\n+               then\n+                  return;\n+\n                else\n                   Wrong_Type (N, Typ);\n                end if;\n@@ -12847,6 +12892,76 @@ package body Sem_Res is\n       end if;\n    end Simplify_Type_Conversion;\n \n+   ------------------------------\n+   -- Try_User_Defined_Literal --\n+   ------------------------------\n+\n+   function Try_User_Defined_Literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean\n+   is\n+   begin\n+      if Nkind (N) in N_Op_Add | N_Op_Divide | N_Op_Mod | N_Op_Multiply\n+        | N_Op_Rem | N_Op_Subtract\n+      then\n+\n+         --  Both operands must have the same type as the context.\n+         --  (ignoring for now fixed-point and exponentiation ops).\n+\n+         if Has_Applicable_User_Defined_Literal (Right_Opnd (N), Typ) then\n+            Resolve (Left_Opnd (N), Typ);\n+            Analyze_And_Resolve (N, Typ);\n+            return True;\n+         end if;\n+\n+         if\n+           Has_Applicable_User_Defined_Literal (Left_Opnd (N), Typ)\n+         then\n+            Resolve (Right_Opnd (N), Typ);\n+            Analyze_And_Resolve (N, Typ);\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+\n+      elsif Nkind (N) in N_Binary_Op then\n+         --  For other operators the context does not impose a type on\n+         --  the operands, but their types must match.\n+\n+         if (Nkind (Left_Opnd (N))\n+           not in N_Integer_Literal | N_String_Literal | N_Real_Literal)\n+         and then\n+           Has_Applicable_User_Defined_Literal\n+             (Right_Opnd (N), Etype (Left_Opnd (N)))\n+         then\n+            Analyze_And_Resolve (N, Typ);\n+            return True;\n+\n+         elsif (Nkind (Right_Opnd (N))\n+           not in N_Integer_Literal | N_String_Literal | N_Real_Literal)\n+         and then\n+           Has_Applicable_User_Defined_Literal\n+             (Left_Opnd (N), Etype (Right_Opnd (N)))\n+         then\n+            Analyze_And_Resolve (N, Typ);\n+            return True;\n+         else\n+            return False;\n+         end if;\n+\n+      elsif Nkind (N) in N_Unary_Op\n+        and then\n+          Has_Applicable_User_Defined_Literal (Right_Opnd (N), Typ)\n+      then\n+         Analyze_And_Resolve (N, Typ);\n+         return True;\n+\n+      else   --  Other operators\n+         return False;\n+      end if;\n+   end Try_User_Defined_Literal;\n+\n    -----------------------------\n    -- Unique_Fixed_Point_Type --\n    -----------------------------"}]}