{"sha": "e57cabac809559538ae7f3bf2866b66401a321e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU3Y2FiYWM4MDk1NTk1MzhhZTdmM2JmMjg2NmI2NjQwMWEzMjFlNw==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "2001-01-25T00:18:16Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "2001-01-25T00:18:16Z"}, "message": "dwarf2out.c (prefix_of): New function.\n\n\t* dwarf2out.c (prefix_of): New function.  Determine longest common\n\tprefix of the two arguments.  The units are whole path components.\n\t(output_file_names): When adding a new directory find the one entry\n\twith the longest common prefix already in the list.  Artificially\n\tgenerate entry if there is none for this prefix.\n\tFix test to check whether the zeroth directory entry is used.\n: ----------------------------------------------------------------------\n\nFrom-SVN: r39253", "tree": {"sha": "5bd79f238424aed5db38184eae8d9364f0875614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bd79f238424aed5db38184eae8d9364f0875614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e57cabac809559538ae7f3bf2866b66401a321e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57cabac809559538ae7f3bf2866b66401a321e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e57cabac809559538ae7f3bf2866b66401a321e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57cabac809559538ae7f3bf2866b66401a321e7/comments", "author": null, "committer": null, "parents": [{"sha": "c499d4d23ae57bc5705db8eb991fa938b6933298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c499d4d23ae57bc5705db8eb991fa938b6933298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c499d4d23ae57bc5705db8eb991fa938b6933298"}], "stats": {"total": 98, "additions": 85, "deletions": 13}, "files": [{"sha": "367b9338d678473cc49094ceabfee7a156fa556f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57cabac809559538ae7f3bf2866b66401a321e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57cabac809559538ae7f3bf2866b66401a321e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e57cabac809559538ae7f3bf2866b66401a321e7", "patch": "@@ -1,3 +1,12 @@\n+2001-01-24  Ulrich Drepper  <drepper@redhat.com>\n+\n+\t* dwarf2out.c (prefix_of): New function.  Determine longest common\n+\tprefix of the two arguments.  The units are whole path components.\n+\t(output_file_names): When adding a new directory find the one entry\n+\twith the longest common prefix already in the list.  Artificially\n+\tgenerate entry if there is none for this prefix.\n+\tFix test to check whether the zeroth directory entry is used.\n+\n Wed Jan 24 23:51:55 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* reload1.c (reload_reg_free_for_value_p): New parameter start_regno.\n@@ -46,7 +55,7 @@ Wed Jan 24 23:51:55 2001  J\"orn Rennecke <amylaar@redhat.com>\n \t* cpp.texi (-M, -MM): Document -M -include behaviour.\n \n 2001-01-24  Roger Collins <roger@ProProject.com>\n-\t  \n+\n         * config/i386/xm-i386.h: Make __i386__ a boolean macro.\n \n 2001-01-24  Will Cohen  <wcohen@redhat.com>\n@@ -67,7 +76,7 @@ Wed Jan 24 23:51:55 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* bb-reorder.c (make_reorder_chain_1): Handle case where\n \tjump edge goes to the same block as the fallthru edge.\n- \n+\n 2001-01-23  Jim Wilson  <wilson@redhat.com>\n \n \t* dwarf2out.c (dwarf2out_line): Make last_file_num be unsigned.\n@@ -92,7 +101,7 @@ Wed Jan 24 23:51:55 2001  J\"orn Rennecke <amylaar@redhat.com>\n \t(flushrs): Add explicit stop bit at end.\n \t* config/ia64/lib1funcs.asm (__ia64_restore_stack_nonlocal): Change\n \ttrailing \\ to >.\n-\t\n+\n 2001-01-23  Chris Demetriou  <cgd@broadcom.com>\n \n \t* libgcc-std.ver (GCC_3.0): Add __terminate_func_set to list\n@@ -172,7 +181,7 @@ Wed Jan 24 23:51:55 2001  J\"orn Rennecke <amylaar@redhat.com>\n \tUse the saved register pointer array as the source of the CFA.\n \t(throw_helper): Rewrite.  Unwind once rather than twice and keep\n \ttrack of saved registers as we go.\n- \n+\n 2001-01-23  Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n \t* c4x-protos.h (c4x_legitimize_reload_address): Remove.\n@@ -236,7 +245,7 @@ Mon Jan 22 16:53:06 2001  J\"orn Rennecke <amylaar@redhat.com>\n \tmemory.\n \t(c4x_r11_set_p, c4x_check_laj_p): New functions.\n \t* c4x-protos.h (c4x_check_laj_p): Add prototype.\n-\t* c4x.md (in_annul_slot_3): Do not allow auto-increment in last \n+\t* c4x.md (in_annul_slot_3): Do not allow auto-increment in last\n \tanulling slot because of silicon bug.\n \t(laj, lajv): Call c4x_check_laj_p to check for silicon bug.\n "}, {"sha": "a360a19b455e243b6f4d587dcd215d3bed316211", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 71, "deletions": 8, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57cabac809559538ae7f3bf2866b66401a321e7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57cabac809559538ae7f3bf2866b66401a321e7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e57cabac809559538ae7f3bf2866b66401a321e7", "patch": "@@ -6494,6 +6494,33 @@ file_info_cmp (p1, p2)\n     }\n }\n \n+/* Compute the maximum prefix of P2 appearing also in P1.  Entire\n+   directory names must match.  */\n+static int prefix_of PARAMS ((struct dir_info *, struct dir_info *));\n+static int\n+prefix_of (p1, p2)\n+     struct dir_info *p1;\n+     struct dir_info *p2;\n+{\n+  char *s1 = p1->path;\n+  char *s2 = p2->path;\n+  int len = p1->length < p2->length ? p1->length : p2->length;\n+\n+  while (*s1 == *s2 && s1 < p1->path + len)\n+    ++s1, ++s2;\n+\n+  if (*s1 == '/' && *s2 == '/')\n+    /* The whole of P1 is the prefix.  */\n+    return p1->length;\n+\n+  /* Go back to the last directory component.  */\n+  while (s1 > p1->path)\n+    if (*--s1 == '/')\n+      return s1 - p1->path + 1;\n+\n+  return 0;\n+}\n+\n /* Output the directory table and the file name table.  We try to minimize\n    the total amount of memory needed.  A heuristic is used to avoid large\n    slowdowns with many input files.  */\n@@ -6513,7 +6540,7 @@ output_file_names ()\n   /* Allocate the various arrays we need.  */\n   files = (struct file_info *) alloca (line_file_table.in_use\n \t\t\t\t       * sizeof (struct file_info));\n-  dirs = (struct dir_info *) alloca (line_file_table.in_use\n+  dirs = (struct dir_info *) alloca (line_file_table.in_use * 2\n \t\t\t\t     * sizeof (struct dir_info));\n \n   /* Sort the file names.  */\n@@ -6562,6 +6589,8 @@ output_file_names ()\n     else\n       {\n \tint j;\n+\tint max_idx;\n+\tint max_len;\n \n \t/* This is a new directory.  */\n \tdirs[ndirs].path = files[i].path;\n@@ -6573,12 +6602,46 @@ output_file_names ()\n \tfiles[i].dir_idx = ndirs;\n \n \t/* Search for a prefix.  */\n-\tdirs[ndirs].prefix = -1;\n+\tmax_len = 0;\n+\tmax_idx = 0;\n \tfor (j = 0; j < ndirs; ++j)\n-\t  if (dirs[j].length < dirs[ndirs].length\n-\t      && dirs[j].length != 0\n-\t      && memcmp (dirs[j].path, dirs[ndirs].path, dirs[j].length) == 0)\n-\t    dirs[ndirs].prefix = j;\n+\t  if (dirs[j].length > max_len)\n+\t    {\n+\t      int this_len = prefix_of (&dirs[j], &dirs[ndirs]);\n+\n+\t      if (this_len > max_len)\n+\t\t{\n+\t\t  max_len = this_len;\n+\t\t  max_idx = j;\n+\t\t}\n+\t    }\n+\n+\t/* Remember the prefix.  If this is a known prefix simply\n+\t   remember the index.  Otherwise we will have to create an\n+\t   artificial entry.  */\n+\tif (max_len == dirs[max_idx].length)\n+\t  /* This is our prefix.  */\n+\t  dirs[ndirs].prefix = max_idx;\n+\telse if (max_len > 0)\n+\t  {\n+\t    /* Create an entry without associated file.  Since we have\n+\t       to keep the dirs array sorted (means, entries with paths\n+\t       which come first) we have to move the new entry in the\n+\t       place of the old one.  */\n+\t    dirs[++ndirs] = dirs[max_idx];\n+\n+\t    /* We don't have to set .path.  */\n+\t    dirs[max_idx].length = max_len;\n+\t    dirs[max_idx].nbytes = 0;\n+\t    dirs[max_idx].count = 0;\n+\t    dirs[max_idx].dir_idx = ndirs;\n+\t    dirs[max_idx].used = 0;\n+\t    dirs[max_idx].prefix = dirs[ndirs].prefix;\n+\n+\t    dirs[ndirs - 1].prefix = dirs[ndirs].prefix = max_idx;\n+\t  }\n+\telse\n+\t  dirs[ndirs].prefix = -1;\n \n \t++ndirs;\n       }\n@@ -6666,7 +6729,7 @@ output_file_names ()\n      confuse these indices with the one for the constructed table\n      (even though most of the time they are identical).  */\n   idx = 1;\n-  idx_offset = dirs[0].path[0] == '/' ? 1 : 0;\n+  idx_offset = dirs[0].length > 0 ? 1 : 0;\n   for (i = 1 - idx_offset; i < ndirs; ++i)\n     if (dirs[i].used != 0)\n       {\n@@ -7856,7 +7919,7 @@ loc_descriptor_from_tree (loc, addressp)\n     case NON_LVALUE_EXPR:\n     case SAVE_EXPR:\n       return loc_descriptor_from_tree (TREE_OPERAND (loc, 0), addressp);\n-      \n+\n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n     case ARRAY_REF:"}]}