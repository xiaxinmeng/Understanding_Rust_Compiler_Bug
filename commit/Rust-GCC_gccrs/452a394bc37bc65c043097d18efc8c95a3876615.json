{"sha": "452a394bc37bc65c043097d18efc8c95a3876615", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUyYTM5NGJjMzdiYzY1YzA0MzA5N2QxOGVmYzhjOTVhMzg3NjYxNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-08-04T18:41:00Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-08-04T18:41:00Z"}, "message": "cp-tree.h (add_method): Change prototype.\n\n\t* cp-tree.h (add_method): Change prototype.\n\t* class.c (add_method): Remove FIELDS parameter.  Add ERROR_P.\n\tDon't double the size of the method vector in the error case.\n\t(handle_using_decl): Adjust call to add_method.\n\t(add_implicitly_declared_members): Likewise.\n\t(clone_function_decl): Likewise.\n\t* decl2.c (check_classfn): Likewise.\n\t* semantics.c (finish_member_declaration): Likewise.\n\nFrom-SVN: r35490", "tree": {"sha": "dd32bc545603afee2ec2a4f3daf8ad5ab3742f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd32bc545603afee2ec2a4f3daf8ad5ab3742f0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/452a394bc37bc65c043097d18efc8c95a3876615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/452a394bc37bc65c043097d18efc8c95a3876615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/452a394bc37bc65c043097d18efc8c95a3876615", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/452a394bc37bc65c043097d18efc8c95a3876615/comments", "author": null, "committer": null, "parents": [{"sha": "ca2eed217f7de558a5fa3feccfad9ed73e13da1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca2eed217f7de558a5fa3feccfad9ed73e13da1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca2eed217f7de558a5fa3feccfad9ed73e13da1f"}], "stats": {"total": 365, "additions": 200, "deletions": 165}, "files": [{"sha": "f6c1683dc3342ee53e795d4b56c5f78a46a2c6f5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=452a394bc37bc65c043097d18efc8c95a3876615", "patch": "@@ -1,3 +1,14 @@\n+2000-08-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (add_method): Change prototype.\n+\t* class.c (add_method): Remove FIELDS parameter.  Add ERROR_P.\n+\tDon't double the size of the method vector in the error case.\n+\t(handle_using_decl): Adjust call to add_method.\n+\t(add_implicitly_declared_members): Likewise.\n+\t(clone_function_decl): Likewise.\n+\t* decl2.c (check_classfn): Likewise.\n+\t* semantics.c (finish_member_declaration): Likewise.\n+\t\n 2000-08-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* decl.c (flag_isoc94): New variable."}, {"sha": "aafecbe4fbbf0f104aadb9ff85e6e0fd35faf4f5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 171, "deletions": 162, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=452a394bc37bc65c043097d18efc8c95a3876615", "patch": "@@ -1155,190 +1155,199 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n \f\n extern struct obstack *current_obstack;\n \n-/* Add method METHOD to class TYPE.\n-\n-   If non-NULL, FIELDS is the entry in the METHOD_VEC vector entry of\n-   the class type where the method should be added.  */\n+/* Add method METHOD to class TYPE.  If ERROR_P is true, we are adding\n+   the method after the class has already been defined because a\n+   declaration for it was seen.  (Even though that is erroneous, we\n+   add the method for improved error recovery.)  */\n \n void\n-add_method (type, fields, method)\n-     tree type, *fields, method;\n+add_method (type, method, error_p)\n+     tree type;\n+     tree method;\n+     int error_p;\n {\n   int using = (DECL_CONTEXT (method) != type);\n-  \n-  if (fields && *fields)\n-    *fields = build_overload (method, *fields);\n-  else \n+  int len;\n+  int slot;\n+  tree method_vec;\n+\n+  if (!CLASSTYPE_METHOD_VEC (type))\n+    /* Make a new method vector.  We start with 8 entries.  We must\n+       allocate at least two (for constructors and destructors), and\n+       we're going to end up with an assignment operator at some point\n+       as well.\n+       \n+       We could use a TREE_LIST for now, and convert it to a TREE_VEC\n+       in finish_struct, but we would probably waste more memory\n+       making the links in the list than we would by over-allocating\n+       the size of the vector here.  Furthermore, we would complicate\n+       all the code that expects this to be a vector.  */\n+    CLASSTYPE_METHOD_VEC (type) = make_tree_vec (8);\n+\n+  method_vec = CLASSTYPE_METHOD_VEC (type);\n+  len = TREE_VEC_LENGTH (method_vec);\n+\n+  /* Constructors and destructors go in special slots.  */\n+  if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (method))\n+    slot = CLASSTYPE_CONSTRUCTOR_SLOT;\n+  else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n+    slot = CLASSTYPE_DESTRUCTOR_SLOT;\n+  else\n     {\n-      int len;\n-      int slot;\n-      tree method_vec;\n-\n-      if (!CLASSTYPE_METHOD_VEC (type))\n-\t/* Make a new method vector.  We start with 8 entries.  We must\n-\t   allocate at least two (for constructors and destructors), and\n-\t   we're going to end up with an assignment operator at some\n-\t   point as well.  \n-\n-\t   We could use a TREE_LIST for now, and convert it to a\n-\t   TREE_VEC in finish_struct, but we would probably waste more\n-\t   memory making the links in the list than we would by\n-\t   over-allocating the size of the vector here.  Furthermore,\n-\t   we would complicate all the code that expects this to be a\n-\t   vector.  */\n-\tCLASSTYPE_METHOD_VEC (type) = make_tree_vec (8);\n-\n-      method_vec = CLASSTYPE_METHOD_VEC (type);\n-      len = TREE_VEC_LENGTH (method_vec);\n-\n-      /* Constructors and destructors go in special slots.  */\n-      if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (method))\n-\tslot = CLASSTYPE_CONSTRUCTOR_SLOT;\n-      else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n-\tslot = CLASSTYPE_DESTRUCTOR_SLOT;\n-      else\n-\t{\n-\t  /* See if we already have an entry with this name.  */\n-\t  for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; slot < len; ++slot)\n-\t    if (!TREE_VEC_ELT (method_vec, slot)\n-\t\t|| (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, \n-\t\t\t\t\t\t\t  slot))) \n-\t\t    == DECL_NAME (method)))\n-\t      break;\n+      /* See if we already have an entry with this name.  */\n+      for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; slot < len; ++slot)\n+\tif (!TREE_VEC_ELT (method_vec, slot)\n+\t    || (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, \n+\t\t\t\t\t\t      slot))) \n+\t\t== DECL_NAME (method)))\n+\t  break;\n \t\t\n-\t  if (slot == len)\n-\t    {\n-\t      /* We need a bigger method vector.  */\n-\t      tree new_vec = make_tree_vec (2 * len);\n-\t      bcopy ((PTR) &TREE_VEC_ELT (method_vec, 0),\n-\t\t     (PTR) &TREE_VEC_ELT (new_vec, 0),\n-\t\t     len * sizeof (tree));\n-\t      len = 2 * len;\n-\t      method_vec = CLASSTYPE_METHOD_VEC (type) = new_vec;\n-\t    }\n+      if (slot == len)\n+\t{\n+\t  /* We need a bigger method vector.  */\n+\t  int new_len;\n+\t  tree new_vec;\n+\n+\t  /* In the non-error case, we are processing a class\n+\t     definition.  Double the size of the vector to give room\n+\t     for new methods.  */\n+\t  if (!error_p)\n+\t    new_len = 2 * len;\n+\t  /* In the error case, the vector is already complete.  We\n+\t     don't expect many errors, and the rest of the front-end\n+\t     will get confused if there are empty slots in the vector.  */\n+\t  else\n+\t    new_len = len + 1;\n+\n+\t  new_vec = make_tree_vec (new_len);\n+\t  bcopy ((PTR) &TREE_VEC_ELT (method_vec, 0),\n+\t\t (PTR) &TREE_VEC_ELT (new_vec, 0),\n+\t\t len * sizeof (tree));\n+\t  len = new_len;\n+\t  method_vec = CLASSTYPE_METHOD_VEC (type) = new_vec;\n+\t}\n \n-\t  if (DECL_CONV_FN_P (method) && !TREE_VEC_ELT (method_vec, slot))\n+      if (DECL_CONV_FN_P (method) && !TREE_VEC_ELT (method_vec, slot))\n+\t{\n+\t  /* Type conversion operators have to come before ordinary\n+\t     methods; add_conversions depends on this to speed up\n+\t     looking for conversion operators.  So, if necessary, we\n+\t     slide some of the vector elements up.  In theory, this\n+\t     makes this algorithm O(N^2) but we don't expect many\n+\t     conversion operators.  */\n+\t  for (slot = 2; slot < len; ++slot)\n \t    {\n-\t      /* Type conversion operators have to come before\n-\t\t ordinary methods; add_conversions depends on this to\n-\t\t speed up looking for conversion operators.  So, if\n-\t\t necessary, we slide some of the vector elements up.\n-\t\t In theory, this makes this algorithm O(N^2) but we\n-\t\t don't expect many conversion operators.  */\n-\t      for (slot = 2; slot < len; ++slot)\n-\t\t{\n-\t\t  tree fn = TREE_VEC_ELT (method_vec, slot);\n+\t      tree fn = TREE_VEC_ELT (method_vec, slot);\n   \n-\t\t  if (!fn)\n-\t\t    /* There are no more entries in the vector, so we\n-\t\t       can insert the new conversion operator here.  */\n-\t\t    break;\n+\t      if (!fn)\n+\t\t/* There are no more entries in the vector, so we\n+\t\t   can insert the new conversion operator here.  */\n+\t\tbreak;\n   \t\t  \n-\t\t  if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n-\t\t    /* We can insert the new function right at the\n-\t\t       SLOTth position.  */\n-\t\t    break;\n-\t\t}\n+\t      if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+\t\t/* We can insert the new function right at the\n+\t\t   SLOTth position.  */\n+\t\tbreak;\n+\t    }\n   \n-\t      if (!TREE_VEC_ELT (method_vec, slot))\n-\t\t/* There is nothing in the Ith slot, so we can avoid\n-\t\t   moving anything.  */\n+\t  if (!TREE_VEC_ELT (method_vec, slot))\n+\t    /* There is nothing in the Ith slot, so we can avoid\n+\t       moving anything.  */\n \t\t; \n-\t      else\n-\t\t{\n-\t\t  /* We know the last slot in the vector is empty\n-\t\t     because we know that at this point there's room\n-\t\t     for a new function.  */\n-\t\t  bcopy ((PTR) &TREE_VEC_ELT (method_vec, slot),\n-\t\t\t (PTR) &TREE_VEC_ELT (method_vec, slot + 1),\n-\t\t\t (len - slot - 1) * sizeof (tree));\n-\t\t  TREE_VEC_ELT (method_vec, slot) = NULL_TREE;\n-\t\t}\n+\t  else\n+\t    {\n+\t      /* We know the last slot in the vector is empty\n+\t\t because we know that at this point there's room\n+\t\t for a new function.  */\n+\t      bcopy ((PTR) &TREE_VEC_ELT (method_vec, slot),\n+\t\t     (PTR) &TREE_VEC_ELT (method_vec, slot + 1),\n+\t\t     (len - slot - 1) * sizeof (tree));\n+\t      TREE_VEC_ELT (method_vec, slot) = NULL_TREE;\n \t    }\n \t}\n+    }\n       \n-      if (template_class_depth (type))\n-\t/* TYPE is a template class.  Don't issue any errors now; wait\n-\t   until instantiation time to complain.  */\n-\t  ;\n-      else\n-\t{\n-\t  tree fns;\n+  if (template_class_depth (type))\n+    /* TYPE is a template class.  Don't issue any errors now; wait\n+       until instantiation time to complain.  */\n+    ;\n+  else\n+    {\n+      tree fns;\n \n-\t  /* Check to see if we've already got this method.  */\n-\t  for (fns = TREE_VEC_ELT (method_vec, slot);\n-\t       fns;\n-\t       fns = OVL_NEXT (fns))\n-\t    {\n-\t      tree fn = OVL_CURRENT (fns);\n+      /* Check to see if we've already got this method.  */\n+      for (fns = TREE_VEC_ELT (method_vec, slot);\n+\t   fns;\n+\t   fns = OVL_NEXT (fns))\n+\t{\n+\t  tree fn = OVL_CURRENT (fns);\n \t\t \n-\t      if (TREE_CODE (fn) != TREE_CODE (method))\n-\t\tcontinue;\n+\t  if (TREE_CODE (fn) != TREE_CODE (method))\n+\t    continue;\n \n-\t      if (TREE_CODE (method) != TEMPLATE_DECL)\n+\t  if (TREE_CODE (method) != TEMPLATE_DECL)\n+\t    {\n+\t      /* [over.load] Member function declarations with the\n+\t\t same name and the same parameter types cannot be\n+\t\t overloaded if any of them is a static member\n+\t\t function declaration.  */\n+\t      if ((DECL_STATIC_FUNCTION_P (fn)\n+\t\t   != DECL_STATIC_FUNCTION_P (method))\n+\t\t  || using)\n \t\t{\n-\t\t  /* [over.load] Member function declarations with the\n-\t\t     same name and the same parameter types cannot be\n-\t\t     overloaded if any of them is a static member\n-\t\t     function declaration.  */\n-\t\t  if ((DECL_STATIC_FUNCTION_P (fn)\n-\t\t       != DECL_STATIC_FUNCTION_P (method))\n-\t\t      || using)\n+\t\t  tree parms1 = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t\t  tree parms2 = TYPE_ARG_TYPES (TREE_TYPE (method));\n+\n+\t\t  if (! DECL_STATIC_FUNCTION_P (fn))\n+\t\t    parms1 = TREE_CHAIN (parms1);\n+\t\t  if (! DECL_STATIC_FUNCTION_P (method))\n+\t\t    parms2 = TREE_CHAIN (parms2);\n+\n+\t\t  if (compparms (parms1, parms2))\n \t\t    {\n-\t\t      tree parms1 = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\t\t      tree parms2 = TYPE_ARG_TYPES (TREE_TYPE (method));\n-\n-\t\t      if (! DECL_STATIC_FUNCTION_P (fn))\n-\t\t\tparms1 = TREE_CHAIN (parms1);\n-\t\t      if (! DECL_STATIC_FUNCTION_P (method))\n-\t\t\tparms2 = TREE_CHAIN (parms2);\n-\n-\t\t      if (compparms (parms1, parms2))\n-\t\t\t{\n-\t\t\t  if (using)\n-\t\t\t    /* Defer to the local function.  */\n-\t\t\t    return;\n-\t\t\t  else\n-\t\t\t    cp_error (\"`%#D' and `%#D' cannot be overloaded\",\n-\t\t\t\t      fn, method);\n-\t\t\t}\n+\t\t      if (using)\n+\t\t\t/* Defer to the local function.  */\n+\t\t\treturn;\n+\t\t      else\n+\t\t\tcp_error (\"`%#D' and `%#D' cannot be overloaded\",\n+\t\t\t\t  fn, method);\n \t\t    }\n-\n-\t\t  /* Since this is an ordinary function in a\n-\t\t     non-template class, it's mangled name can be used\n-\t\t     as a unique identifier.  This technique is only\n-\t\t     an optimization; we would get the same results if\n-\t\t     we just used decls_match here.  */\n-\t\t  if (DECL_ASSEMBLER_NAME (fn) \n-\t\t      != DECL_ASSEMBLER_NAME (method))\n-\t\t    continue;\n \t\t}\n-\t      else if (!decls_match (fn, method))\n+\n+\t      /* Since this is an ordinary function in a\n+\t\t non-template class, it's mangled name can be used\n+\t\t as a unique identifier.  This technique is only\n+\t\t an optimization; we would get the same results if\n+\t\t we just used decls_match here.  */\n+\t      if (DECL_ASSEMBLER_NAME (fn) \n+\t\t  != DECL_ASSEMBLER_NAME (method))\n \t\tcontinue;\n+\t    }\n+\t  else if (!decls_match (fn, method))\n+\t    continue;\n \n-\t      /* There has already been a declaration of this method\n-\t\t or member template.  */\n-\t      cp_error_at (\"`%D' has already been declared in `%T'\", \n-\t\t\t   method, type);\n+\t  /* There has already been a declaration of this method\n+\t     or member template.  */\n+\t  cp_error_at (\"`%D' has already been declared in `%T'\", \n+\t\t       method, type);\n \n-\t      /* We don't call duplicate_decls here to merge the\n-\t\t declarations because that will confuse things if the\n-\t\t methods have inline definitions.  In particular, we\n-\t\t will crash while processing the definitions.  */\n-\t      return;\n-\t    }\n+\t  /* We don't call duplicate_decls here to merge the\n+\t     declarations because that will confuse things if the\n+\t     methods have inline definitions.  In particular, we\n+\t     will crash while processing the definitions.  */\n+\t  return;\n \t}\n+    }\n \n-      /* Actually insert the new method.  */\n-      TREE_VEC_ELT (method_vec, slot) \n-\t= build_overload (method, TREE_VEC_ELT (method_vec, slot));\n+  /* Actually insert the new method.  */\n+  TREE_VEC_ELT (method_vec, slot) \n+    = build_overload (method, TREE_VEC_ELT (method_vec, slot));\n \n       /* Add the new binding.  */ \n-      if (!DECL_CONSTRUCTOR_P (method)\n-\t  && !DECL_DESTRUCTOR_P (method))\n-\tpush_class_level_binding (DECL_NAME (method),\n-\t\t\t\t  TREE_VEC_ELT (method_vec, slot));\n-    }\n+  if (!DECL_CONSTRUCTOR_P (method)\n+      && !DECL_DESTRUCTOR_P (method))\n+    push_class_level_binding (DECL_NAME (method),\n+\t\t\t      TREE_VEC_ELT (method_vec, slot));\n }\n \n /* Subroutines of finish_struct.  */\n@@ -1567,7 +1576,7 @@ handle_using_decl (using_decl, t)\n   if (flist)\n     for (; flist; flist = OVL_NEXT (flist))\n       {\n-\tadd_method (t, 0, OVL_CURRENT (flist));\n+\tadd_method (t, OVL_CURRENT (flist), /*error_p=*/0);\n \talter_access (t, OVL_CURRENT (flist), access);\n       }\n   else\n@@ -3146,7 +3155,7 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n   /* Now, hook all of the new functions on to TYPE_METHODS,\n      and add them to the CLASSTYPE_METHOD_VEC.  */\n   for (f = &implicit_fns; *f; f = &TREE_CHAIN (*f))\n-    add_method (t, 0, *f);\n+    add_method (t, *f, /*error_p=*/0);\n   *f = TYPE_METHODS (t);\n   TYPE_METHODS (t) = implicit_fns;\n \n@@ -4203,10 +4212,10 @@ clone_function_decl (fn, update_method_vec_p)\n \t and a not-in-charge version.  */\n       clone = build_clone (fn, complete_ctor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n       clone = build_clone (fn, base_ctor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n     }\n   else\n     {\n@@ -4220,13 +4229,13 @@ clone_function_decl (fn, update_method_vec_p)\n \t function table.  */\n       clone = build_clone (fn, deleting_dtor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n       clone = build_clone (fn, complete_dtor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n       clone = build_clone (fn, base_dtor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n     }\n }\n "}, {"sha": "2c534f38d301ed043d222422193973af8a9c7b3f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=452a394bc37bc65c043097d18efc8c95a3876615", "patch": "@@ -3805,7 +3805,7 @@ extern tree build_vbase_path\t\t\tPARAMS ((enum tree_code, tree, tree, tree, int));\n extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n extern tree build_vfn_ref\t\t\tPARAMS ((tree *, tree, tree));\n extern tree get_vtable_decl                     PARAMS ((tree, int));\n-extern void add_method\t\t\t\tPARAMS ((tree, tree *, tree));\n+extern void add_method\t\t\t\tPARAMS ((tree, tree, int));\n extern int currently_open_class\t\t\tPARAMS ((tree));\n extern tree currently_open_derived_class\tPARAMS ((tree));\n extern tree get_vfield_offset\t\t\tPARAMS ((tree));"}, {"sha": "514b9c6ef0739cf3a4bd72415471a9f06aaf5297", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=452a394bc37bc65c043097d18efc8c95a3876615", "patch": "@@ -1549,7 +1549,7 @@ check_classfn (ctype, function)\n      case we'll only confuse ourselves when the function is declared\n      properly within the class.  */\n   if (COMPLETE_TYPE_P (ctype))\n-    add_method (ctype, methods, function);\n+    add_method (ctype, function, /*error_p=*/1);\n   return NULL_TREE;\n }\n "}, {"sha": "9dc6bca5a81aba9dd1c801e30a8e1a9d631cf930", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=452a394bc37bc65c043097d18efc8c95a3876615", "patch": "@@ -1969,7 +1969,7 @@ finish_member_declaration (decl)\n     {\n       /* We also need to add this function to the\n \t CLASSTYPE_METHOD_VEC.  */\n-      add_method (current_class_type, 0, decl);\n+      add_method (current_class_type, decl, /*error_p=*/0);\n \n       TREE_CHAIN (decl) = TYPE_METHODS (current_class_type);\n       TYPE_METHODS (current_class_type) = decl;"}, {"sha": "e9e642f7f794724dde536d87040a7c5014f2f676", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash21.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/452a394bc37bc65c043097d18efc8c95a3876615/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash21.C?ref=452a394bc37bc65c043097d18efc8c95a3876615", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+// Origin: Gabriel Dos Reis <gdr@codesourcery.com>\n+\n+struct  A {\n+  virtual void f(int&) const;\n+};\n+\n+struct B : public A {\n+  int x;\n+};\n+\n+void B::f(int& t)\n+{\n+  x = t;\n+}"}]}