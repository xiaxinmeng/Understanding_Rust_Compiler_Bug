{"sha": "f0033821c1c9ba386a1983499a666d5759cdd943", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAwMzM4MjFjMWM5YmEzODZhMTk4MzQ5OWE2NjZkNTc1OWNkZDk0Mw==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2019-08-14T13:14:59Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2019-08-14T13:14:59Z"}, "message": "Add generic support for noinit attribute.\n\n    Similar to what already exists for TI msp430 or in TI compilers for\n    arm, this patch adds support for the \"noinit\" attribute.\n\n    It is convenient for embedded targets where the user wants to keep the\n    value of some data when the program is restarted: such variables are\n    not zero-initialized. It is mostly a helper/shortcut to placing\n    variables in a dedicated section.\n\n    It's probably desirable to add the following chunk to the GNU linker:\n    diff --git a/ld/emulparams/armelf.sh b/ld/emulparams/armelf.sh\n    index 272a8bc..9555cec 100644\n    --- a/ld/emulparams/armelf.sh\n    +++ b/ld/emulparams/armelf.sh\n    @@ -10,7 +10,19 @@ OTHER_TEXT_SECTIONS='*(.glue_7t) *(.glue_7)\n    *(.vfp11_veneer) *(.v4_bx)'\n     OTHER_BSS_SYMBOLS=\"${CREATE_SHLIB+PROVIDE (}__bss_start__ =\n    .${CREATE_SHLIB+)};\"\n     OTHER_BSS_END_SYMBOLS=\"${CREATE_SHLIB+PROVIDE (}_bss_end__ =\n    .${CREATE_SHLIB+)}; ${CREATE_SHLIB+PROVIDE (}__bss_end__ =\n    .${CREATE_SHLIB+)};\"\n     OTHER_END_SYMBOLS=\"${CREATE_SHLIB+PROVIDE (}__end__ = .${CREATE_SHLIB+)};\"\n     -OTHER_SECTIONS='.note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }'\n     +OTHER_SECTIONS='\n     +.note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }\n     +  /* This section contains data that is not initialised during load\n     +     *or* application reset.  */\n     +   .noinit (NOLOAD) :\n     +   {\n     +     . = ALIGN(2);\n     +     PROVIDE (__noinit_start = .);\n     +     *(.noinit)\n     +     . = ALIGN(2);\n     +     PROVIDE (__noinit_end = .);\n     +   }\n     +'\n\n    so that the noinit section has the \"NOLOAD\" flag.\n\n    I added a testcase if gcc.c-torture/execute, gated by the new noinit\n    effective-target.\n\n    Finally, I tested on arm-eabi, but not on msp430 for which I do not\n    have the environment.\n\ngcc/ChangeLog:\n\n2019-08-14  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\t* doc/extend.texi: Add \"noinit\" attribute documentation.\n\t* doc/sourcebuild.texi: Add noinit effective target documentation.\n\t* varasm.c (default_section_type_flags): Add support for \"noinit\" section.\n\t(default_elf_select_section): Add support for \"noinit\" attribute.\n\t* config/msp430/msp430.c (msp430_attribute_table): Remove \"noinit\" entry.\n\ngcc/c-family/ChangeLog:\n\n2019-08-14  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\t* c-attribs.c (c_common_attribute_table): Add \"noinit\" entry. Add\n\texclusion with \"section\" attribute.\n\t(attr_noinit_exclusions): New table.\n\t(handle_noinit_attribute): New function.\n\ngcc/testsuite/ChangeLog:\n\n2019-08-14  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\t* lib/target-supports.exp (check_effective_target_noinit): New\n\tproc.\n\t* gcc.c-torture/execute/noinit-attribute.c: New test.\n\nFrom-SVN: r274482", "tree": {"sha": "fb03464b4e6202043a7a8c16d3c468949bca950b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb03464b4e6202043a7a8c16d3c468949bca950b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0033821c1c9ba386a1983499a666d5759cdd943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0033821c1c9ba386a1983499a666d5759cdd943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0033821c1c9ba386a1983499a666d5759cdd943", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0033821c1c9ba386a1983499a666d5759cdd943/comments", "author": null, "committer": null, "parents": [{"sha": "93cf5515729f526761489ec3892c6f0ea0d7105b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cf5515729f526761489ec3892c6f0ea0d7105b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93cf5515729f526761489ec3892c6f0ea0d7105b"}], "stats": {"total": 179, "additions": 176, "deletions": 3}, "files": [{"sha": "30665a69f0ca869a175c95c9753327094f6907d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -1,3 +1,12 @@\n+2019-08-14  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* doc/extend.texi: Add \"noinit\" attribute documentation.\n+\t* doc/sourcebuild.texi: Add noinit effective target documentation.\n+\t* varasm.c (default_section_type_flags): Add support for \"noinit\"\n+\tsection.\n+\t(default_elf_select_section): Add support for \"noinit\" attribute.\n+\t* config/msp430/msp430.c (msp430_attribute_table): Remove \"noinit\" entry.\n+\n 2019-08-14  Richard Biener  <rguenther@suse.de>\n \tUro\u0161 Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "48e59366123394d3e2ea1bab546689b5a1c2717d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -1,3 +1,10 @@\n+2019-08-14  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* c-attribs.c (c_common_attribute_table): Add \"noinit\" entry. Add\n+\texclusion with \"section\" attribute.\n+\t(attr_noinit_exclusions): New table.\n+\t(handle_noinit_attribute): New function.\n+\n 2019-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR middle-end/91421"}, {"sha": "820c83fa3b96c6c6774f524c0b9261d58e10b657", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -92,6 +92,7 @@ static tree handle_section_attribute (tree *, tree, tree, int, bool *);\n static tree handle_aligned_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_if_not_aligned_attribute (tree *, tree, tree,\n \t\t\t\t\t\t  int, bool *);\n+static tree handle_noinit_attribute (tree *, tree, tree, int, bool *);\n static tree handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_noplt_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_alias_ifunc_attribute (bool, tree *, tree, tree, bool *);\n@@ -235,6 +236,13 @@ static const struct attribute_spec::exclusions attr_const_pure_exclusions[] =\n   ATTR_EXCL (NULL, false, false, false)\n };\n \n+static const struct attribute_spec::exclusions attr_noinit_exclusions[] =\n+{\n+  ATTR_EXCL (\"noinit\", true, true, true),\n+  ATTR_EXCL (\"section\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n /* Table of machine-independent attributes common to all C-like languages.\n \n    Current list of processed common attributes: nonnull.  */\n@@ -307,7 +315,7 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"mode\",                   1, 1, false,  true, false, false,\n \t\t\t      handle_mode_attribute, NULL },\n   { \"section\",                1, 1, true,  false, false, false,\n-\t\t\t      handle_section_attribute, NULL },\n+\t\t\t      handle_section_attribute, attr_noinit_exclusions },\n   { \"aligned\",                0, 1, false, false, false, false,\n \t\t\t      handle_aligned_attribute,\n \t                      attr_aligned_exclusions },\n@@ -458,6 +466,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_nocf_check_attribute, NULL },\n   { \"copy\",                   1, 1, false, false, false, false,\n \t\t\t      handle_copy_attribute, NULL },\n+  { \"noinit\",\t\t      0, 0, true,  false, false, false,\n+\t\t\t      handle_noinit_attribute, attr_noinit_exclusions },\n   { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -2224,6 +2234,54 @@ handle_weak_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"noinit\" attribute; arguments as in struct\n+   attribute_spec.handler.  Check whether the attribute is allowed\n+   here and add the attribute to the variable decl tree or otherwise\n+   issue a diagnostic.  This function checks NODE is of the expected\n+   type and issues diagnostics otherwise using NAME.  If it is not of\n+   the expected type *NO_ADD_ATTRS will be set to true.  */\n+\n+static tree\n+handle_noinit_attribute (tree * node,\n+\t\t  tree   name,\n+\t\t  tree   args,\n+\t\t  int    flags ATTRIBUTE_UNUSED,\n+\t\t  bool *no_add_attrs)\n+{\n+  const char *message = NULL;\n+\n+  gcc_assert (DECL_P (*node));\n+  gcc_assert (args == NULL);\n+\n+  if (TREE_CODE (*node) != VAR_DECL)\n+    message = G_(\"%qE attribute only applies to variables\");\n+\n+  /* Check that it's possible for the variable to have a section.  */\n+  else if ((TREE_STATIC (*node) || DECL_EXTERNAL (*node) || in_lto_p)\n+\t   && DECL_SECTION_NAME (*node))\n+    message = G_(\"%qE attribute cannot be applied to variables \"\n+\t\t \"with specific sections\");\n+\n+  else if (!targetm.have_switchable_bss_sections)\n+    message = G_(\"%qE attribute is specific to ELF targets\");\n+\n+  if (message)\n+    {\n+      warning (OPT_Wattributes, message, name);\n+      *no_add_attrs = true;\n+    }\n+  else\n+    /* If this var is thought to be common, then change this.  Common\n+       variables are assigned to sections before the backend has a\n+       chance to process them.  Do this only if the attribute is\n+       valid.  */\n+    if (DECL_COMMON (*node))\n+      DECL_COMMON (*node) = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+\n /* Handle a \"noplt\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "369cb264e89f578a5643d52568ee6bb2024dd7d9", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -1521,8 +1521,6 @@ const struct attribute_spec msp430_attribute_table[] =\n   { ATTR_EITHER,      0, 0, true,  false, false, false, msp430_section_attr,\n     NULL },\n \n-  { ATTR_NOINIT,      0, 0, true,  false, false, false, msp430_data_attr,\n-    NULL },\n   { ATTR_PERSIST,     0, 0, true,  false, false, false, msp430_data_attr,\n     NULL },\n \n@@ -1751,6 +1749,8 @@ msp430_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n     {\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \treturn text_section;\n+      /* FIXME: ATTR_NOINIT is handled generically in\n+\t default_elf_select_section.  */\n       else if (has_attr (ATTR_NOINIT, decl))\n \treturn noinit_section;\n       else if (has_attr (ATTR_PERSIST, decl))"}, {"sha": "2ba9b74811aecbb2bffde0f85b4417fd557b9193", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -7156,6 +7156,14 @@ The @code{visibility} attribute is described in\n The @code{weak} attribute is described in\n @ref{Common Function Attributes}.\n \n+@item noinit\n+@cindex @code{noinit} variable attribute\n+Any data with the @code{noinit} attribute will not be initialized by\n+the C runtime startup code, or the program loader.  Not initializing\n+data in this way can reduce program startup times.  This attribute is\n+specific to ELF targets and relies on the linker to place such data in\n+the right location\n+\n @end table\n \n @node ARC Variable Attributes"}, {"sha": "f9fcd0916b3a55fb1ea5708a13efd7fb1a7cd568", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -2302,6 +2302,9 @@ Target uses natural alignment (aligned to type size) for types of\n Target uses natural alignment (aligned to type size) for types of\n 64 bits or less.\n \n+@item noinit\n+Target supports the @code{noinit} variable attribute.\n+\n @item nonpic\n Target does not generate PIC by default.\n "}, {"sha": "3a5155e202bce88a2c5ba00e299867e6598c8472", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -1,3 +1,9 @@\n+2019-08-14  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* lib/target-supports.exp (check_effective_target_noinit): New\n+\tproc.\n+\t* gcc.c-torture/execute/noinit-attribute.c: New test.\n+\n 2019-08-14  Richard Biener  <rguenther@suse.de>\n \n \tPR target/91154"}, {"sha": "ffcf8c6b3da0623c800cf2868c3abfbbf3b162fb", "filename": "gcc/testsuite/gcc.c-torture/execute/noinit-attribute.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fnoinit-attribute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fnoinit-attribute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fnoinit-attribute.c?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target noinit */\n+/* { dg-options \"-O2\" } */\n+\n+/* This test checks that noinit data is handled correctly.  */\n+\n+extern void _start (void) __attribute__ ((noreturn));\n+extern void abort (void) __attribute__ ((noreturn));\n+extern void exit (int) __attribute__ ((noreturn));\n+\n+int var_common;\n+int var_zero = 0;\n+int var_one = 1;\n+int __attribute__((noinit)) var_noinit;\n+int var_init = 2;\n+\n+int __attribute__((noinit)) func(); /* { dg-warning \"attribute only applies to variables\" } */\n+int __attribute__((section (\"mysection\"), noinit)) var_section1; /* { dg-warning \"because it conflicts with attribute\" } */\n+int __attribute__((noinit, section (\"mysection\"))) var_section2; /* { dg-warning \"because it conflicts with attribute\" } */\n+\n+\n+int\n+main (void)\n+{\n+  /* Make sure that the C startup code has correctly initialized the ordinary variables.  */\n+  if (var_common != 0)\n+    abort ();\n+\n+  /* Initialized variables are not re-initialized during startup, so\n+     check their original values only during the first run of this\n+     test.  */\n+  if (var_init == 2)\n+    if (var_zero != 0 || var_one != 1)\n+      abort ();\n+\n+  switch (var_init)\n+    {\n+    case 2:\n+      /* First time through - change all the values.  */\n+      var_common = var_zero = var_one = var_noinit = var_init = 3;\n+      break;\n+\n+    case 3:\n+      /* Second time through - make sure that d has not been reset.  */\n+      if (var_noinit != 3)\n+\tabort ();\n+      exit (0);\n+\n+    default:\n+      /* Any other value for var_init is an error.  */\n+      abort ();\n+    }\n+\n+  /* Simulate a processor reset by calling the C startup code.  */\n+  _start ();\n+\n+  /* Should never reach here.  */\n+  abort ();\n+}"}, {"sha": "300d22a2d650b8f556b51b3e12d612855bbbfa73", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -364,6 +364,18 @@ proc check_weak_override_available { } {\n     return [check_weak_available]\n }\n \n+# The noinit attribute is only supported by some targets.\n+# This proc returns 1 if it's supported, 0 if it's not.\n+\n+proc check_effective_target_noinit { } {\n+    if { [istarget arm*-*-eabi]\n+\t || [istarget msp430-*-*] } {\n+\treturn 1\n+    }\n+\n+    return 0\n+}\n+\n ###############################\n # proc check_visibility_available { what_kind }\n ###############################"}, {"sha": "ae25f4d9c1672e6e9f215e693290d139b0ab634d", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0033821c1c9ba386a1983499a666d5759cdd943/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f0033821c1c9ba386a1983499a666d5759cdd943", "patch": "@@ -6430,6 +6430,9 @@ default_section_type_flags (tree decl, const char *name, int reloc)\n       || strncmp (name, \".gnu.linkonce.tb.\", 17) == 0)\n     flags |= SECTION_TLS | SECTION_BSS;\n \n+  if (strcmp (name, \".noinit\") == 0)\n+    flags |= SECTION_WRITE | SECTION_BSS | SECTION_NOTYPE;\n+\n   /* Various sections have special ELF types that the assembler will\n      assign by default based on the name.  They are neither SHT_PROGBITS\n      nor SHT_NOBITS, so when changing sections we don't want to print a\n@@ -6755,6 +6758,7 @@ default_elf_select_section (tree decl, int reloc,\n \t\t\t    unsigned HOST_WIDE_INT align)\n {\n   const char *sname;\n+\n   switch (categorize_decl_for_section (decl, reloc))\n     {\n     case SECCAT_TEXT:\n@@ -6792,6 +6796,13 @@ default_elf_select_section (tree decl, int reloc,\n       sname = \".tdata\";\n       break;\n     case SECCAT_BSS:\n+      if (DECL_P (decl)\n+\t  && lookup_attribute (\"noinit\", DECL_ATTRIBUTES (decl)) != NULL_TREE)\n+\t{\n+\t  sname = \".noinit\";\n+\t  break;\n+\t}\n+\n       if (bss_section)\n \treturn bss_section;\n       sname = \".bss\";"}]}