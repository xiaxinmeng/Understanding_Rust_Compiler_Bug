{"sha": "bf95e88b668dde68de8c5512980eca6c5c9b315b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY5NWU4OGI2NjhkZGU2OGRlOGM1NTEyOTgwZWNhNmM1YzliMzE1Yg==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2014-10-18T15:53:59Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2014-10-18T15:53:59Z"}, "message": "invoke.texi: Update documentation of hppa -mjump-in-delay option.\n\n\t* doc/invoke.texi: Update documentation of hppa -mjump-in-delay option.\n\t* config/pa/pa-protos.h (pa_following_call): Delete declaration.\n\t(pa_jump_in_call_delay): Likewise.\n\t* config/pa/pa.c (pa_option_override): Remove jump in call delay\n\toverride.\n\t(pa_output_millicode_call): Remove support for jump in call delay.\n\t(pa_output_call): Likewise.\n\t(pa_jump_in_call_delay): Delete.\n\t(pa_following_call): Likewise.\n\t* config/pa/pa.md (in_call_delay): Remove jump in delay check.\n\t(uncond_branch): Remove following call check from attribute length.\n\nFrom-SVN: r216428", "tree": {"sha": "9b76c4c357fd8b348a5d4b8493ef0ab2dd5cd69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b76c4c357fd8b348a5d4b8493ef0ab2dd5cd69d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf95e88b668dde68de8c5512980eca6c5c9b315b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf95e88b668dde68de8c5512980eca6c5c9b315b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf95e88b668dde68de8c5512980eca6c5c9b315b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf95e88b668dde68de8c5512980eca6c5c9b315b/comments", "author": null, "committer": null, "parents": [{"sha": "22c23886dbe53c6a4677d45dee9ed8c2e56a2f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c23886dbe53c6a4677d45dee9ed8c2e56a2f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22c23886dbe53c6a4677d45dee9ed8c2e56a2f2c"}], "stats": {"total": 217, "additions": 36, "deletions": 181}, "files": [{"sha": "2e24871d658cff2c8ab5929d828b5325eabbeefd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf95e88b668dde68de8c5512980eca6c5c9b315b", "patch": "@@ -1,3 +1,17 @@\n+2014-10-18  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* doc/invoke.texi: Update documentation of hppa -mjump-in-delay option.\n+\t* config/pa/pa-protos.h (pa_following_call): Delete declaration.\n+\t(pa_jump_in_call_delay): Likewise.\n+\t* config/pa/pa.c (pa_option_override): Remove jump in call delay\n+\toverride.\n+\t(pa_output_millicode_call): Remove support for jump in call delay.\n+\t(pa_output_call): Likewise.\n+\t(pa_jump_in_call_delay): Delete.\n+\t(pa_following_call): Likewise.\n+\t* config/pa/pa.md (in_call_delay): Remove jump in delay check.\n+\t(uncond_branch): Remove following call check from attribute length.\n+\n 2014-10-18  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/53513"}, {"sha": "cf78554390004328593641d6e869e546fa907830", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=bf95e88b668dde68de8c5512980eca6c5c9b315b", "patch": "@@ -21,9 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Prototype function used in various macros.  */\n extern rtx pa_eh_return_handler_rtx (void);\n \n-/* Used in insn-*.c.  */\n-extern int pa_following_call (rtx_insn *);\n-\n /* Define functions in pa.c and used in insn-output.c.  */\n \n extern const char *pa_output_and (rtx *);\n@@ -63,7 +60,6 @@ extern void pa_emit_bcond_fp (rtx[]);\n extern int pa_emit_move_sequence (rtx *, enum machine_mode, rtx);\n extern int pa_emit_hpdiv_const (rtx *, int);\n extern int pa_is_function_label_plus_const (rtx);\n-extern int pa_jump_in_call_delay (rtx_insn *);\n extern int pa_fpstore_bypass_p (rtx_insn *, rtx_insn *);\n extern int pa_attr_length_millicode_call (rtx_insn *);\n extern int pa_attr_length_call (rtx_insn *, int);"}, {"sha": "4584ec266a4803492f349344295a29a0e4166ff6", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 13, "deletions": 153, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=bf95e88b668dde68de8c5512980eca6c5c9b315b", "patch": "@@ -498,15 +498,6 @@ pa_option_override (void)\n \t  }\n       }\n \n-  /* Unconditional branches in the delay slot are not compatible with dwarf2\n-     call frame information.  There is no benefit in using this optimization\n-     on PA8000 and later processors.  */\n-  if (pa_cpu >= PROCESSOR_8000\n-      || (targetm_common.except_unwind_info (&global_options) == UI_DWARF2\n-\t  && flag_exceptions)\n-      || flag_unwind_tables)\n-    target_flags &= ~MASK_JUMP_IN_DELAY;\n-\n   if (flag_pic && TARGET_PORTABLE_RUNTIME)\n     {\n       warning (0, \"PIC code generation is not supported in the portable runtime model\");\n@@ -7542,8 +7533,7 @@ pa_attr_length_millicode_call (rtx_insn *insn)\n     }\n }\n \n-/* INSN is a function call.  It may have an unconditional jump\n-   in its delay slot.\n+/* INSN is a function call.\n \n    CALL_DEST is the routine we are calling.  */\n \n@@ -7552,8 +7542,6 @@ pa_output_millicode_call (rtx_insn *insn, rtx call_dest)\n {\n   int attr_length = get_attr_length (insn);\n   int seq_length = dbr_sequence_length ();\n-  int distance;\n-  rtx seq_insn;\n   rtx xoperands[3];\n \n   xoperands[0] = call_dest;\n@@ -7655,39 +7643,6 @@ pa_output_millicode_call (rtx_insn *insn, rtx call_dest)\n   if (seq_length == 0)\n     output_asm_insn (\"nop\", xoperands);\n \n-  /* We are done if there isn't a jump in the delay slot.  */\n-  if (seq_length == 0 || ! JUMP_P (NEXT_INSN (insn)))\n-    return \"\";\n-\n-  /* This call has an unconditional jump in its delay slot.  */\n-  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-\n-  /* See if the return address can be adjusted.  Use the containing\n-     sequence insn's address.  */\n-  if (INSN_ADDRESSES_SET_P ())\n-    {\n-      seq_insn = NEXT_INSN (PREV_INSN (final_sequence->insn (0)));\n-      distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n-\t\t  - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n-\n-      if (VAL_14_BITS_P (distance))\n-\t{\n-\t  xoperands[1] = gen_label_rtx ();\n-\t  output_asm_insn (\"ldo %0-%1(%2),%2\", xoperands);\n-\t  targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t\t  CODE_LABEL_NUMBER (xoperands[1]));\n-\t}\n-      else\n-\t/* ??? This branch may not reach its target.  */\n-\toutput_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n-    }\n-  else\n-    /* ??? This branch may not reach its target.  */\n-    output_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n-\n-  /* Delete the jump.  */\n-  SET_INSN_DELETED (NEXT_INSN (insn));\n-\n   return \"\";\n }\n \n@@ -7789,16 +7744,13 @@ pa_attr_length_call (rtx_insn *insn, int sibcall)\n   return length;\n }\n \n-/* INSN is a function call.  It may have an unconditional jump\n-   in its delay slot.\n+/* INSN is a function call.\n \n    CALL_DEST is the routine we are calling.  */\n \n const char *\n pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n {\n-  int delay_insn_deleted = 0;\n-  int delay_slot_filled = 0;\n   int seq_length = dbr_sequence_length ();\n   tree call_decl = SYMBOL_REF_DECL (call_dest);\n   int local_call = call_decl && targetm.binds_local_p (call_decl);\n@@ -7826,17 +7778,17 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \n \t  /* If this isn't a sibcall, we put the load of %r27 into the\n \t     delay slot.  We can't do this in a sibcall as we don't\n-\t     have a second call-clobbered scratch register available.  */\n-\t  if (seq_length != 0\n-\t      && ! JUMP_P (NEXT_INSN (insn))\n-\t      && !sibcall)\n+\t     have a second call-clobbered scratch register available.\n+\t     We don't need to do anything when generating fast indirect\n+\t     calls.  */\n+\t  if (seq_length != 0 && !sibcall)\n \t    {\n \t      final_scan_insn (NEXT_INSN (insn), asm_out_file,\n \t\t\t       optimize, 0, NULL);\n \n \t      /* Now delete the delay insn.  */\n \t      SET_INSN_DELETED (NEXT_INSN (insn));\n-\t      delay_insn_deleted = 1;\n+\t      seq_length = 0;\n \t    }\n \n \t  output_asm_insn (\"addil LT'%0,%%r27\", xoperands);\n@@ -7854,7 +7806,7 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \t      output_asm_insn (\"ldd 16(%%r1),%%r2\", xoperands);\n \t      output_asm_insn (\"bve,l (%%r2),%%r2\", xoperands);\n \t      output_asm_insn (\"ldd 24(%%r1),%%r27\", xoperands);\n-\t      delay_slot_filled = 1;\n+\t      seq_length = 1;\n \t    }\n \t}\n       else\n@@ -7872,7 +7824,6 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \t    indirect_call = 1;\n \n \t  if (seq_length != 0\n-\t      && ! JUMP_P (NEXT_INSN (insn))\n \t      && !sibcall\n \t      && (!TARGET_PA_20\n \t\t  || indirect_call\n@@ -7886,7 +7837,7 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \n \t      /* Now delete the delay insn.  */\n \t      SET_INSN_DELETED (NEXT_INSN (insn));\n-\t      delay_insn_deleted = 1;\n+\t      seq_length = 0;\n \t    }\n \n \t  if ((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)\n@@ -7908,7 +7859,7 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \t\t    output_asm_insn (\"ble R'%0(%%sr4,%%r1)\", xoperands);\n \n \t\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n-\t\t  delay_slot_filled = 1;\n+\t\t  seq_length = 1;\n \t\t}\n \t    }\n \t  else\n@@ -7995,7 +7946,7 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \t\t\t{\n \t\t\t  output_asm_insn (\"bve,l (%%r1),%%r2\", xoperands);\n \t\t\t  output_asm_insn (\"stw %%r2,-24(%%sp)\", xoperands);\n-\t\t\t  delay_slot_filled = 1;\n+\t\t\t  seq_length = 1;\n \t\t\t}\n \t\t      else\n \t\t\toutput_asm_insn (\"bve,l (%%r1),%%r2\", xoperands);\n@@ -8025,55 +7976,16 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)\n \t\t\toutput_asm_insn (\"stw %%r31,-24(%%sp)\", xoperands);\n \t\t      else\n \t\t\toutput_asm_insn (\"copy %%r31,%%r2\", xoperands);\n-\t\t      delay_slot_filled = 1;\n+\t\t      seq_length = 1;\n \t\t    }\n \t\t}\n \t    }\n \t}\n     }\n \n-  if (!delay_slot_filled && (seq_length == 0 || delay_insn_deleted))\n+  if (seq_length == 0)\n     output_asm_insn (\"nop\", xoperands);\n \n-  /* We are done if there isn't a jump in the delay slot.  */\n-  if (seq_length == 0\n-      || delay_insn_deleted\n-      || ! JUMP_P (NEXT_INSN (insn)))\n-    return \"\";\n-\n-  /* A sibcall should never have a branch in the delay slot.  */\n-  gcc_assert (!sibcall);\n-\n-  /* This call has an unconditional jump in its delay slot.  */\n-  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-\n-  if (!delay_slot_filled && INSN_ADDRESSES_SET_P ())\n-    {\n-      /* See if the return address can be adjusted.  Use the containing\n-         sequence insn's address.  This would break the regular call/return@\n-         relationship assumed by the table based eh unwinder, so only do that\n-         if the call is not possibly throwing.  */\n-      rtx seq_insn = NEXT_INSN (PREV_INSN (final_sequence->insn (0)));\n-      int distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n-\t\t      - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n-\n-      if (VAL_14_BITS_P (distance)\n-\t  && !(can_throw_internal (insn) || can_throw_external (insn)))\n-\t{\n-\t  xoperands[1] = gen_label_rtx ();\n-\t  output_asm_insn (\"ldo %0-%1(%%r2),%%r2\", xoperands);\n-\t  targetm.asm_out.internal_label (asm_out_file, \"L\",\n-\t\t\t\t\t  CODE_LABEL_NUMBER (xoperands[1]));\n-\t}\n-      else\n-\toutput_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n-    }\n-  else\n-    output_asm_insn (\"b,n %0\", xoperands);\n-\n-  /* Delete the jump.  */\n-  SET_INSN_DELETED (NEXT_INSN (insn));\n-\n   return \"\";\n }\n \n@@ -8822,28 +8734,6 @@ forward_branch_p (rtx_insn *insn)\n   return false;\n }\n \n-/* Return 1 if INSN is in the delay slot of a call instruction.  */\n-int\n-pa_jump_in_call_delay (rtx_insn *insn)\n-{\n-\n-  if (! JUMP_P (insn))\n-    return 0;\n-\n-  if (PREV_INSN (insn)\n-      && PREV_INSN (PREV_INSN (insn))\n-      && NONJUMP_INSN_P (next_real_insn (PREV_INSN (PREV_INSN (insn)))))\n-    {\n-      rtx test_insn = next_real_insn (PREV_INSN (PREV_INSN (insn)));\n-\n-      return (GET_CODE (PATTERN (test_insn)) == SEQUENCE\n-\t      && XVECEXP (PATTERN (test_insn), 0, 1) == insn);\n-\n-    }\n-  else\n-    return 0;\n-}\n-\n /* Output an unconditional move and branch insn.  */\n \n const char *\n@@ -8916,36 +8806,6 @@ pa_output_parallel_addb (rtx *operands, rtx_insn *insn)\n   return pa_output_lbranch (operands[3], insn, 1);\n }\n \n-/* Return nonzero if INSN (a jump insn) immediately follows a call\n-   to a named function.  This is used to avoid filling the delay slot\n-   of the jump since it can usually be eliminated by modifying RP in\n-   the delay slot of the call.  */\n-\n-int\n-pa_following_call (rtx_insn *insn)\n-{\n-  if (! TARGET_JUMP_IN_DELAY)\n-    return 0;\n-\n-  /* Find the previous real insn, skipping NOTEs.  */\n-  insn = PREV_INSN (insn);\n-  while (insn && NOTE_P (insn))\n-    insn = PREV_INSN (insn);\n-\n-  /* Check for CALL_INSNs and millicode calls.  */\n-  if (insn\n-      && ((CALL_P (insn)\n-\t   && get_attr_type (insn) != TYPE_DYNCALL)\n-\t  || (NONJUMP_INSN_P (insn)\n-\t      && GET_CODE (PATTERN (insn)) != SEQUENCE\n-\t      && GET_CODE (PATTERN (insn)) != USE\n-\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t      && get_attr_type (insn) == TYPE_MILLI)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* We use this hook to perform a PA specific optimization which is difficult\n    to do in earlier passes.  */\n "}, {"sha": "268f4467defd0df71ad66324c12bf87a5fd963cb", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=bf95e88b668dde68de8c5512980eca6c5c9b315b", "patch": "@@ -181,19 +181,13 @@\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n-;; For calls and millicode calls.  Allow unconditional branches in the\n-;; delay slot.\n+;; For calls and millicode calls.\n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch\")\n-\t      (eq_attr \"length\" \"4\")\n-\t      (not (match_test \"RTX_FRAME_RELATED_P (insn)\")))\n-\t   (const_string \"true\")\n-\t (eq_attr \"type\" \"uncond_branch\")\n-\t   (if_then_else (match_test \"TARGET_JUMP_IN_DELAY\")\n-\t\t\t (const_string \"true\")\n-\t\t\t (const_string \"false\"))]\n-\t(const_string \"false\")))\n-\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch\")\n+\t\t     (eq_attr \"length\" \"4\")\n+\t\t     (not (match_test \"RTX_FRAME_RELATED_P (insn)\")))\n+\t\t(const_string \"true\")\n+\t\t(const_string \"false\")))\n \n ;; Call delay slot description.\n (define_delay (eq_attr \"type\" \"call\")\n@@ -229,8 +223,7 @@\n    (and (eq_attr \"in_nullified_branch_delay\" \"true\")\n \t(attr_flag \"backward\"))])\n \n-(define_delay (and (eq_attr \"type\" \"uncond_branch\")\n-\t\t   (not (match_test \"pa_following_call (insn)\")))\n+(define_delay (eq_attr \"type\" \"uncond_branch\")\n   [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n ;; Memory. Disregarding Cache misses, the Mustang memory times are:\n@@ -6884,13 +6877,7 @@\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"pa_combine_type\" \"uncond_branch\")\n    (set (attr \"length\")\n-    (cond [(match_test \"pa_jump_in_call_delay (insn)\")\n-\t   (if_then_else (lt (abs (minus (match_dup 0)\n-\t\t\t\t\t (plus (pc) (const_int 8))))\n-\t\t\t     (const_int MAX_12BIT_OFFSET))\n-\t   (const_int 4)\n-\t   (const_int 8))\n-\t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int MAX_17BIT_OFFSET))\n \t   (const_int 4)\n \t   (match_test \"TARGET_PORTABLE_RUNTIME\")"}, {"sha": "9f02888353ca4343fe129bbb9067ffbcdf21d8de", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf95e88b668dde68de8c5512980eca6c5c9b315b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bf95e88b668dde68de8c5512980eca6c5c9b315b", "patch": "@@ -14862,9 +14862,7 @@ Synonyms for @option{-march=1.0}, @option{-march=1.1}, and @option{-march=2.0} r\n \n @item -mjump-in-delay\n @opindex mjump-in-delay\n-Fill delay slots of function calls with unconditional jump instructions\n-by modifying the return pointer for the function call to be the target\n-of the conditional jump.\n+This option is ignored and provided for compatibility purposes only.\n \n @item -mdisable-fpregs\n @opindex mdisable-fpregs"}]}