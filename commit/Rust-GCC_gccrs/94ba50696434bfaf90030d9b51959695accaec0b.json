{"sha": "94ba50696434bfaf90030d9b51959695accaec0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRiYTUwNjk2NDM0YmZhZjkwMDMwZDliNTE5NTk2OTVhY2NhZWMwYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-13T20:19:42Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-13T20:19:42Z"}, "message": "(set_init_index): Don't allow variable indices.\n\n(output_init_element): When putting an elt into a\nCONSTRUCTOR, always set the TREE_PURPOSE (even for arrays).\nCopy the node if it's an INTEGER_CST.\n(output_pending_init_elements): If have gap and not incremental,\nadvance constructor_unfilled_fields or constructor_unfilled_index.\n\n(push_init_level): Pop any implicit levels\nthat have been filled up.\nDon't die if constructor_type is 0.\n(process_init_element): If VALUE is 0 for union type,\nupdate constructor_bit_index.\n\nFrom-SVN: r5317", "tree": {"sha": "960e2e8f443b962db140a9b8c1312ffbc471e382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/960e2e8f443b962db140a9b8c1312ffbc471e382"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94ba50696434bfaf90030d9b51959695accaec0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94ba50696434bfaf90030d9b51959695accaec0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94ba50696434bfaf90030d9b51959695accaec0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94ba50696434bfaf90030d9b51959695accaec0b/comments", "author": null, "committer": null, "parents": [{"sha": "ecd4cee03c1299324409ee653b673e8acc84ec58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd4cee03c1299324409ee653b673e8acc84ec58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecd4cee03c1299324409ee653b673e8acc84ec58"}], "stats": {"total": 81, "additions": 65, "deletions": 16}, "files": [{"sha": "89767c3f4bd1d63b6b7d3b7d739d305192a8a675", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94ba50696434bfaf90030d9b51959695accaec0b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94ba50696434bfaf90030d9b51959695accaec0b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=94ba50696434bfaf90030d9b51959695accaec0b", "patch": "@@ -5378,8 +5378,24 @@ void\n push_init_level (implicit)\n      int implicit;\n {\n-  struct constructor_stack *p\n-    = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n+  struct constructor_stack *p;\n+\n+  /* If we've exhausted any levels that didn't have braces,\n+     pop them now.  */\n+  while (constructor_stack->implicit)\n+    {\n+      if ((TREE_CODE (constructor_type) == RECORD_TYPE\n+\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t  && constructor_fields == 0)\n+\tprocess_init_element (pop_init_level (1));\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n+\t       && tree_int_cst_lt (constructor_max_index, constructor_index))\n+\tprocess_init_element (pop_init_level (1));\n+      else\n+\tbreak;\n+    }\n+\n+  p = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n   p->type = constructor_type;\n   p->fields = constructor_fields;\n   p->index = constructor_index;\n@@ -5407,8 +5423,12 @@ push_init_level (implicit)\n   constructor_elements = 0;\n   constructor_pending_elts = 0;\n \n-  if (TREE_CODE (constructor_type) == RECORD_TYPE\n-      || TREE_CODE (constructor_type) == UNION_TYPE)\n+  /* Don't die if an entire brace-pair level is superfluous\n+     in the containing level.  */\n+  if (constructor_type == 0)\n+    ;\n+  else if (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n     {\n       /* Don't die if there are extra init elts at the end.  */\n       if (constructor_fields == 0)\n@@ -5426,7 +5446,8 @@ push_init_level (implicit)\n     }\n \n   /* Turn off constructor_incremental if type is a struct with bitfields.  */\n-  check_init_type_bitfields (constructor_type);\n+  if (constructor_type != 0)\n+    check_init_type_bitfields (constructor_type);\n \n   if (constructor_type == 0)\n     {\n@@ -5688,7 +5709,11 @@ void\n set_init_index (first, last)\n      tree first, last;\n {\n-  if (tree_int_cst_lt (first, constructor_unfilled_index))\n+  if (TREE_CODE (first) != INTEGER_CST)\n+    error_init (\"nonconstant array index in initializer%s\", \" for `%s'\", NULL);\n+  else if (last != 0 && TREE_CODE (last) != INTEGER_CST)\n+    error_init (\"nonconstant array index in initializer%s\", \" for `%s'\", NULL);\n+  else if (tree_int_cst_lt (first, constructor_unfilled_index))\n     error_init (\"duplicate array index in initializer%s\", \" for `%s'\", NULL);\n   else\n     {\n@@ -5710,7 +5735,7 @@ set_init_index (first, last)\n \n /* Within a struct initializer, specify the next field to be initialized.  */\n \n-void \n+void\n set_init_label (fieldname)\n      tree fieldname;\n {\n@@ -5851,11 +5876,13 @@ output_init_element (value, type, field, pending)\n       if (!duplicate)\n \t{\n \t  if (! constructor_incremental)\n-\t    constructor_elements\n-\t      = tree_cons ((TREE_CODE (constructor_type) != ARRAY_TYPE\n-\t\t\t    ? field : NULL),\n-\t\t\t   digest_init (type, value, 0, 0),\n-\t\t\t   constructor_elements);\n+\t    {\n+\t      if (TREE_CODE (field) == INTEGER_CST)\n+\t\tfield = copy_node (field);\n+\t      constructor_elements\n+\t\t= tree_cons (field, digest_init (type, value, 0, 0),\n+\t\t\t     constructor_elements);\n+\t    }\n \t  else\n \t    {\n \t      /* Structure elements may require alignment.\n@@ -6031,6 +6058,22 @@ output_pending_init_elements (all)\n \t  assemble_zeros (nextpos - TREE_INT_CST_LOW (filled));\n \t}\n     }\n+  else\n+    {\n+      /* If it's not incremental, just skip over the gap,\n+\t so that after jumping to retry we will output the next\n+\t successive element.  */\n+      if (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n+\tconstructor_unfilled_fields = next;\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+\t{\n+\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n+\t    = TREE_INT_CST_LOW (next);\n+\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n+\t    = TREE_INT_CST_HIGH (next);\n+\t}\n+    }\n \n   goto retry;\n }\n@@ -6192,10 +6235,16 @@ process_init_element (value)\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n-\t    /* If we are doing the bookkeeping for an element that was\n-\t       directly output as a constructor,\n-\t       we must update constructor_unfilled_fields.  */\n-\t    constructor_unfilled_fields = 0;\n+\t    /* Do the bookkeeping for an element that was\n+\t       directly output as a constructor.  */\n+\t    {\n+\t      TREE_INT_CST_LOW (constructor_bit_index)\n+\t\t= TREE_INT_CST_LOW (DECL_SIZE (constructor_fields));\n+\t      TREE_INT_CST_HIGH (constructor_bit_index)\n+\t\t= TREE_INT_CST_HIGH (DECL_SIZE (constructor_fields));\n+\n+\t      constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n+\t    }\n \n \t  constructor_fields = 0;\n \t  break;"}]}