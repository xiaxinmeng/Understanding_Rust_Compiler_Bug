{"sha": "3ca950c3525527846f13e8c547368ef432547a23", "node_id": "C_kwDOANBUbNoAKDNjYTk1MGMzNTI1NTI3ODQ2ZjEzZThjNTQ3MzY4ZWY0MzI1NDdhMjM", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-29T21:25:50Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-10-06T13:18:09Z"}, "message": "Introduce a param-switch-limit for EVRP.\n\nVery large switches cause a lot of range calculations with multiple subranges\nto happen.  This can cause quadratic or even exponetial time increases in\nlarge testcases.  This patch introduces a param variable to limit\nthe size of switches EVRP will process.\n\n\t* gimple-range-edge.cc (gimple_outgoing_range::gimple_outgoing_range):\n\tAdd parameter to limit size when recognizing switches.\n\t(gimple_outgoing_range::edge_range_p): Check size limit.\n\t* gimple-range-edge.h (gimple_outgoing_range): Add size field.\n\t* gimple-range-gori.cc (gori_map::calculate_gori): Ignore switches\n\tthat exceed the size limit.\n\t(gori_compute::gori_compute): Add initializer.\n\t* params.opt (evrp-switch-limit): New.\n\t* doc/invoke.texi: Update docs.", "tree": {"sha": "84156fb071b8bf136365d9ddfce681ef78a181b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84156fb071b8bf136365d9ddfce681ef78a181b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ca950c3525527846f13e8c547368ef432547a23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca950c3525527846f13e8c547368ef432547a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca950c3525527846f13e8c547368ef432547a23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca950c3525527846f13e8c547368ef432547a23/comments", "author": null, "committer": null, "parents": [{"sha": "e828f4b5898896240b2ae5d5030c539aff28ea24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e828f4b5898896240b2ae5d5030c539aff28ea24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e828f4b5898896240b2ae5d5030c539aff28ea24"}], "stats": {"total": 23, "additions": 20, "deletions": 3}, "files": [{"sha": "80bc7fe41e053fa6229c15dbde65a7e053e4e136", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3ca950c3525527846f13e8c547368ef432547a23", "patch": "@@ -14505,6 +14505,9 @@ Maximum number of basic blocks before EVRP uses a sparse cache.\n @item evrp-mode\n Specifies the mode Early VRP should operate in.\n \n+@item evrp-switch-limit\n+Specifies the maximum number of switch cases before EVRP ignores a switch.\n+\n @item unroll-jam-min-percent\n The minimum percentage of memory references that must be optimized\n away for the unroll-and-jam transformation to be considered profitable."}, {"sha": "afffc8dbcae1c494571dfb746b6884b24078cb67", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=3ca950c3525527846f13e8c547368ef432547a23", "patch": "@@ -65,9 +65,10 @@ gcond_edge_range (irange &r, edge e)\n }\n \n \n-gimple_outgoing_range::gimple_outgoing_range ()\n+gimple_outgoing_range::gimple_outgoing_range (int max_sw_edges)\n {\n   m_edge_table = NULL;\n+  m_max_edges = max_sw_edges;\n }\n \n \n@@ -192,6 +193,10 @@ gimple_outgoing_range::edge_range_p (irange &r, edge e)\n       return s;\n     }\n \n+  // Only process switches if it within the size limit.\n+  if (EDGE_COUNT (e->src->succs) > (unsigned)m_max_edges)\n+    return NULL;\n+\n   gcc_checking_assert (is_a<gswitch *> (s));\n   gswitch *sw = as_a<gswitch *> (s);\n   tree type = TREE_TYPE (gimple_switch_index (sw));"}, {"sha": "03e8e82bd038d64f92ed088a08f3798e8adcf1d8", "filename": "gcc/gimple-range-edge.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fgimple-range-edge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fgimple-range-edge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.h?ref=3ca950c3525527846f13e8c547368ef432547a23", "patch": "@@ -38,13 +38,14 @@ along with GCC; see the file COPYING3.  If not see\n class gimple_outgoing_range\n {\n public:\n-  gimple_outgoing_range ();\n+  gimple_outgoing_range (int max_sw_edges = INT_MAX);\n   ~gimple_outgoing_range ();\n   gimple *edge_range_p (irange &r, edge e);\n private:\n   void calc_switch_ranges (gswitch *sw);\n   bool get_edge_range (irange &r, gimple *s, edge e);\n \n+  int m_max_edges;\n   hash_map<edge, irange *> *m_edge_table;\n   irange_allocator m_range_allocator;\n };"}, {"sha": "6946fa65dda4e19c7fb204fcaac878338048b289", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=3ca950c3525527846f13e8c547368ef432547a23", "patch": "@@ -565,6 +565,9 @@ gori_map::calculate_gori (basic_block bb)\n     }\n   else\n     {\n+      // Do not process switches if they are too large.\n+      if (EDGE_COUNT (bb->succs) > (unsigned)param_evrp_switch_limit)\n+\treturn;\n       gswitch *gs = as_a<gswitch *>(stmt);\n       name = gimple_range_ssa_p (gimple_switch_index (gs));\n       maybe_add_gori (name, gimple_bb (stmt));\n@@ -634,7 +637,8 @@ debug (gori_map &g)\n \n // Construct a gori_compute object.\n \n-gori_compute::gori_compute (int not_executable_flag) : tracer (\"GORI \")\n+gori_compute::gori_compute (int not_executable_flag)\n+\t\t      : outgoing (param_evrp_switch_limit), tracer (\"GORI \")\n {\n   m_not_executable_flag = not_executable_flag;\n   // Create a boolean_type true and false range."}, {"sha": "82ddbb8b1211608fde98d335cf0c660c37e0b6a3", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca950c3525527846f13e8c547368ef432547a23/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=3ca950c3525527846f13e8c547368ef432547a23", "patch": "@@ -130,6 +130,10 @@ Maximal estimated growth of function body caused by early inlining of single cal\n Common Joined UInteger Var(param_evrp_sparse_threshold) Init(800) Optimization Param\n Maximum number of basic blocks before EVRP uses a sparse cache.\n \n+-param=evrp-switch-limit=\n+Common Joined UInteger Var(param_evrp_switch_limit) Init(50) Optimization Param\n+Maximum number of outgoing edges in a switch before EVRP will not process it.\n+\n -param=evrp-mode=\n Common Joined Var(param_evrp_mode) Enum(evrp_mode) Init(EVRP_MODE_RVRP_ONLY) Param Optimization\n --param=evrp-mode=[legacy|ranger|legacy-first|ranger-first|trace|gori|cache|tracegori|debug] Specifies the mode Early VRP should operate in."}]}