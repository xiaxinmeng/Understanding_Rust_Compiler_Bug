{"sha": "f8305d18b8a10fcf63ca8fac1079e619d3b67e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgzMDVkMThiOGExMGZjZjYzY2E4ZmFjMTA3OWU2MTlkM2I2N2UxMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-08-28T06:22:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-08-28T06:22:16Z"}, "message": "combine-stack-adj.c: Include rtl-iter.h.\n\ngcc/\n\t* combine-stack-adj.c: Include rtl-iter.h.\n\t(record_stack_refs_data): Delete.\n\t(record_stack_refs): Turn from being a for_each_rtx callback\n\tto being a function that examines each subrtx itself.\n\tTake a pointer to the reflist.  Invert sense of return value\n\tso that true means success and false means failure.  Don't\n\thandle null rtxes.\n\t(combine_stack_adjustments_for_block): Update accordingly.\n\nFrom-SVN: r214625", "tree": {"sha": "7a2a5fe28eb8a5d89e9d5df30bb16a58f0184c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a2a5fe28eb8a5d89e9d5df30bb16a58f0184c10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8305d18b8a10fcf63ca8fac1079e619d3b67e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8305d18b8a10fcf63ca8fac1079e619d3b67e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8305d18b8a10fcf63ca8fac1079e619d3b67e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8305d18b8a10fcf63ca8fac1079e619d3b67e10/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46bbda0375e18a3cdec4c7e40df934de0a468165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46bbda0375e18a3cdec4c7e40df934de0a468165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46bbda0375e18a3cdec4c7e40df934de0a468165"}], "stats": {"total": 124, "additions": 65, "deletions": 59}, "files": [{"sha": "853d36a1c7bbdf0cda5808beb6fec7fe9bc421ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8305d18b8a10fcf63ca8fac1079e619d3b67e10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8305d18b8a10fcf63ca8fac1079e619d3b67e10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8305d18b8a10fcf63ca8fac1079e619d3b67e10", "patch": "@@ -1,3 +1,14 @@\n+2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* combine-stack-adj.c: Include rtl-iter.h.\n+\t(record_stack_refs_data): Delete.\n+\t(record_stack_refs): Turn from being a for_each_rtx callback\n+\tto being a function that examines each subrtx itself.\n+\tTake a pointer to the reflist.  Invert sense of return value\n+\tso that true means success and false means failure.  Don't\n+\thandle null rtxes.\n+\t(combine_stack_adjustments_for_block): Update accordingly.\n+\n 2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* combine.c (record_truncated_value): Turn from being a for_each_rtx"}, {"sha": "aebdf87d80752e927e457da1a88eac3afa09cf77", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8305d18b8a10fcf63ca8fac1079e619d3b67e10/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8305d18b8a10fcf63ca8fac1079e619d3b67e10/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=f8305d18b8a10fcf63ca8fac1079e619d3b67e10", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"reload.h\"\n #include \"tree-pass.h\"\n+#include \"rtl-iter.h\"\n \n \f\n /* Turn STACK_GROWS_DOWNWARD into a boolean.  */\n@@ -86,7 +87,6 @@ static struct csa_reflist *record_one_stack_ref (rtx_insn *, rtx *,\n static int try_apply_stack_adjustment (rtx_insn *, struct csa_reflist *,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT);\n static void combine_stack_adjustments_for_block (basic_block);\n-static int record_stack_refs (rtx *, void *);\n \n \n /* Main entry point for stack adjustment combination.  */\n@@ -237,61 +237,63 @@ try_apply_stack_adjustment (rtx_insn *insn, struct csa_reflist *reflist,\n     return 0;\n }\n \n-/* Called via for_each_rtx and used to record all stack memory and other\n-   references in the insn and discard all other stack pointer references.  */\n-struct record_stack_refs_data\n-{\n-  rtx_insn *insn;\n-  struct csa_reflist *reflist;\n-};\n+/* For non-debug insns, record all stack memory references in INSN\n+   and return true if there were no other (unrecorded) references to the\n+   stack pointer.  For debug insns, record all stack references regardless\n+   of context and unconditionally return true.  */\n \n-static int\n-record_stack_refs (rtx *xp, void *data)\n+static bool\n+record_stack_refs (rtx_insn *insn, struct csa_reflist **reflist)\n {\n-  rtx x = *xp;\n-  struct record_stack_refs_data *d =\n-    (struct record_stack_refs_data *) data;\n-  if (!x)\n-    return 0;\n-  switch (GET_CODE (x))\n+  subrtx_ptr_iterator::array_type array;\n+  FOR_EACH_SUBRTX_PTR (iter, array, &PATTERN (insn), NONCONST)\n     {\n-    case MEM:\n-      if (!reg_mentioned_p (stack_pointer_rtx, x))\n-\treturn -1;\n-      /* We are not able to handle correctly all possible memrefs containing\n-         stack pointer, so this check is necessary.  */\n-      if (stack_memref_p (x))\n-\t{\n-\t  d->reflist = record_one_stack_ref (d->insn, xp, d->reflist);\n-\t  return -1;\n-\t}\n-      /* Try harder for DEBUG_INSNs, handle e.g. (mem (mem (sp + 16) + 4).  */\n-      return !DEBUG_INSN_P (d->insn);\n-    case REG:\n-      /* ??? We want be able to handle non-memory stack pointer\n-\t references later.  For now just discard all insns referring to\n-\t stack pointer outside mem expressions.  We would probably\n-\t want to teach validate_replace to simplify expressions first.\n-\n-\t We can't just compare with STACK_POINTER_RTX because the\n-\t reference to the stack pointer might be in some other mode.\n-\t In particular, an explicit clobber in an asm statement will\n-\t result in a QImode clobber.\n-\n-\t In DEBUG_INSNs, we want to replace all occurrences, otherwise\n-\t they will cause -fcompare-debug failures.  */\n-      if (REGNO (x) == STACK_POINTER_REGNUM)\n+      rtx *loc = *iter;\n+      rtx x = *loc;\n+      switch (GET_CODE (x))\n \t{\n-\t  if (!DEBUG_INSN_P (d->insn))\n-\t    return 1;\n-\t  d->reflist = record_one_stack_ref (d->insn, xp, d->reflist);\n-\t  return -1;\n+\tcase MEM:\n+\t  if (!reg_mentioned_p (stack_pointer_rtx, x))\n+\t    iter.skip_subrtxes ();\n+\t  /* We are not able to handle correctly all possible memrefs\n+\t     containing stack pointer, so this check is necessary.  */\n+\t  else if (stack_memref_p (x))\n+\t    {\n+\t      *reflist = record_one_stack_ref (insn, loc, *reflist);\n+\t      iter.skip_subrtxes ();\n+\t    }\n+\t  /* Try harder for DEBUG_INSNs, handle e.g.\n+\t     (mem (mem (sp + 16) + 4).  */\n+\t  else if (!DEBUG_INSN_P (insn))\n+\t    return false;\n+\t  break;\n+\n+\tcase REG:\n+\t  /* ??? We want be able to handle non-memory stack pointer\n+\t     references later.  For now just discard all insns referring to\n+\t     stack pointer outside mem expressions.  We would probably\n+\t     want to teach validate_replace to simplify expressions first.\n+\n+\t     We can't just compare with STACK_POINTER_RTX because the\n+\t     reference to the stack pointer might be in some other mode.\n+\t     In particular, an explicit clobber in an asm statement will\n+\t     result in a QImode clobber.\n+\n+\t     In DEBUG_INSNs, we want to replace all occurrences, otherwise\n+\t     they will cause -fcompare-debug failures.  */\n+\t  if (REGNO (x) == STACK_POINTER_REGNUM)\n+\t    {\n+\t      if (!DEBUG_INSN_P (insn))\n+\t\treturn false;\n+\t      *reflist = record_one_stack_ref (insn, loc, *reflist);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n-      break;\n-    default:\n-      break;\n     }\n-  return 0;\n+  return true;\n }\n \n /* If INSN has a REG_ARGS_SIZE note, move it to LAST.\n@@ -432,7 +434,6 @@ combine_stack_adjustments_for_block (basic_block bb)\n   struct csa_reflist *reflist = NULL;\n   rtx_insn *insn, *next;\n   rtx set;\n-  struct record_stack_refs_data data;\n   bool end_of_block = false;\n \n   for (insn = BB_HEAD (bb); !end_of_block ; insn = next)\n@@ -583,15 +584,9 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t    }\n \t}\n \n-      data.insn = insn;\n-      data.reflist = reflist;\n       if (!CALL_P (insn) && last_sp_set\n-\t  && !for_each_rtx (&PATTERN (insn), record_stack_refs, &data))\n-\t{\n-\t   reflist = data.reflist;\n-\t   continue;\n-\t}\n-      reflist = data.reflist;\n+\t  && record_stack_refs (insn, &reflist))\n+\tcontinue;\n \n       /* Otherwise, we were not able to process the instruction.\n \t Do not continue collecting data across such a one.  */"}]}