{"sha": "1bde5bc4681ac3713d54d6511cfb6000be57114f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJkZTViYzQ2ODFhYzM3MTNkNTRkNjUxMWNmYjYwMDBiZTU3MTE0Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-04-06T10:22:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-04-06T10:22:23Z"}, "message": "decl.c (rest_of_type_decl_compilation_no_defer): New local function used to process all the variants of the specified type.\n\n\t* decl.c (rest_of_type_decl_compilation_no_defer): New local function\n\tused to process all the variants of the specified type.\n\t(gnat_to_gnu_entity): Invoke rest_of_type_decl_compilation for enumeral\n\ttypes too.  Call rest_of_type_decl_compilation_no_defer if undeferring.\n\t(rest_of_type_decl_compilation): Likewise.\n\t* utils.c (gnat_pushdecl): Propagate the name to all variants of type.\n\nFrom-SVN: r133957", "tree": {"sha": "42de824735fa6830fb3e6d3b17e3783804163d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42de824735fa6830fb3e6d3b17e3783804163d36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bde5bc4681ac3713d54d6511cfb6000be57114f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bde5bc4681ac3713d54d6511cfb6000be57114f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bde5bc4681ac3713d54d6511cfb6000be57114f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bde5bc4681ac3713d54d6511cfb6000be57114f/comments", "author": null, "committer": null, "parents": [{"sha": "d7d7db8b40e645ae15a530348b55d2b11a7d3135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7d7db8b40e645ae15a530348b55d2b11a7d3135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7d7db8b40e645ae15a530348b55d2b11a7d3135"}], "stats": {"total": 73, "additions": 59, "deletions": 14}, "files": [{"sha": "a6f14035db3fff0e11237d64961e8454c07a6ac4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde5bc4681ac3713d54d6511cfb6000be57114f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde5bc4681ac3713d54d6511cfb6000be57114f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1bde5bc4681ac3713d54d6511cfb6000be57114f", "patch": "@@ -1,7 +1,16 @@\n+2008-04-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (rest_of_type_decl_compilation_no_defer): New local function\n+\tused to process all the variants of the specified type.\n+\t(gnat_to_gnu_entity): Invoke rest_of_type_decl_compilation for enumeral\n+\ttypes too.  Call rest_of_type_decl_compilation_no_defer if undeferring.\n+\t(rest_of_type_decl_compilation): Likewise.\n+\t* utils.c (gnat_pushdecl): Propagate the name to all variants of type.\n+\n 2008-04-03  Paolo Bonzini  <bonzini@gnu.org>\n \n-        * gigi.h (insert_block): Kill.\n-        * utils.c (insert_block): Kill.\n+\t* gigi.h (insert_block): Kill.\n+\t* utils.c (insert_block): Kill.\n \n 2008-04-02  Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "e31b52528ed86c5a4cfb28e3a666eccaaacbd5c6", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde5bc4681ac3713d54d6511cfb6000be57114f/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde5bc4681ac3713d54d6511cfb6000be57114f/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=1bde5bc4681ac3713d54d6511cfb6000be57114f", "patch": "@@ -119,7 +119,8 @@ static tree make_type_from_size (tree, tree, bool);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static unsigned int ceil_alignment (unsigned HOST_WIDE_INT);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n-static int  compatible_signatures_p (tree ftype1, tree ftype2);\n+static int compatible_signatures_p (tree ftype1, tree ftype2);\n+static void rest_of_type_decl_compilation_no_defer (tree);\n \n /* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n    GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n@@ -4417,12 +4418,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       if (TREE_CODE (gnu_scalar_type) == ENUMERAL_TYPE)\n \t{\n-\t  TYPE_STUB_DECL (gnu_scalar_type) = gnu_decl;\n-\n \t  /* Since this has both a typedef and a tag, avoid outputting\n \t     the name twice.  */\n \t  DECL_ARTIFICIAL (gnu_decl) = 1;\n-\t  rest_of_type_compilation (gnu_scalar_type, global_bindings_p ());\n+\t  rest_of_type_decl_compilation (gnu_decl);\n \t}\n     }\n \n@@ -4462,12 +4461,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t now proceed with the finalization of the deferred types.  */\n       if (defer_finalize_level == 0 && defer_finalize_list)\n \t{\n-\t  int toplev = global_bindings_p ();\n \t  unsigned int i;\n \t  tree t;\n \n \t  for (i = 0; VEC_iterate (tree, defer_finalize_list, i, t); i++)\n-\t    rest_of_decl_compilation (t, toplev, 0);\n+\t    rest_of_type_decl_compilation_no_defer (t);\n \n \t  VEC_free (tree, heap, defer_finalize_list);\n \t}\n@@ -4514,17 +4512,46 @@ gnat_to_gnu_field_decl (Entity_Id gnat_entity)\n   return gnu_field;\n }\n \n-/* Wrap up compilation of T, a TYPE_DECL, possibly deferring it.  */\n+/* Wrap up compilation of DECL, a TYPE_DECL, possibly deferring it.\n+   Every TYPE_DECL generated for a type definition must be passed\n+   to this function once everything else has been done for it.  */\n \n void\n-rest_of_type_decl_compilation (tree t)\n+rest_of_type_decl_compilation (tree decl)\n {\n   /* We need to defer finalizing the type if incomplete types\n      are being deferred or if they are being processed.  */\n   if (defer_incomplete_level || defer_finalize_level)\n-    VEC_safe_push (tree, heap, defer_finalize_list, t);\n+    VEC_safe_push (tree, heap, defer_finalize_list, decl);\n   else\n-    rest_of_decl_compilation (t, global_bindings_p (), 0);\n+    rest_of_type_decl_compilation_no_defer (decl);\n+}\n+\n+/* Same as above but without deferring the compilation.  This\n+   function should not be invoked directly on a TYPE_DECL.  */\n+\n+static void\n+rest_of_type_decl_compilation_no_defer (tree decl)\n+{\n+  const int toplev = global_bindings_p ();\n+  tree t = TREE_TYPE (decl);\n+\n+  rest_of_decl_compilation (decl, toplev, 0);\n+\n+  /* Now process all the variants.  This is needed for STABS.  */\n+  for (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n+    {\n+      if (t == TREE_TYPE (decl))\n+\tcontinue;\n+\n+      if (!TYPE_STUB_DECL (t))\n+\t{\n+\t  TYPE_STUB_DECL (t) = build_decl (TYPE_DECL, DECL_NAME (decl), t);\n+\t  DECL_ARTIFICIAL (TYPE_STUB_DECL (t)) = 1;\n+\t}\n+\n+      rest_of_type_compilation (t, toplev);\n+    }\n }\n \n /* Finalize any From_With_Type incomplete types.  We do this after processing"}, {"sha": "d13897606bac14986f5bb8fdb29670114b0fc459", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bde5bc4681ac3713d54d6511cfb6000be57114f/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bde5bc4681ac3713d54d6511cfb6000be57114f/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=1bde5bc4681ac3713d54d6511cfb6000be57114f", "patch": "@@ -447,17 +447,26 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n       tree t = TREE_TYPE (decl);\n \n       if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) == IDENTIFIER_NODE)\n-\tTYPE_NAME (t) = decl;\n+\t;\n       else if (TYPE_FAT_POINTER_P (t))\n \t{\n \t  tree tt = build_variant_type_copy (t);\n \t  TYPE_NAME (tt) = decl;\n \t  TREE_USED (tt) = TREE_USED (t);\n \t  TREE_TYPE (decl) = tt;\n \t  DECL_ORIGINAL_TYPE (decl) = t;\n+\t  t = NULL_TREE;\n \t}\n       else if (DECL_ARTIFICIAL (TYPE_NAME (t)) && !DECL_ARTIFICIAL (decl))\n-\tTYPE_NAME (t) = decl;\n+\t;\n+      else\n+\tt = NULL_TREE;\n+\n+      /* Propagate the name to all the variants.  This is needed for\n+\t the type qualifiers machinery to work properly.  */\n+      if (t)\n+\tfor (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n+\t  TYPE_NAME (t) = decl;\n     }\n }\n \f"}]}