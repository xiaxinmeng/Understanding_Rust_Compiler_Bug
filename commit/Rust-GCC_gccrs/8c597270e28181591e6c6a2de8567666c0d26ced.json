{"sha": "8c597270e28181591e6c6a2de8567666c0d26ced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM1OTcyNzBlMjgxODE1OTFlNmM2YTJkZTg1Njc2NjZjMGQyNmNlZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-21T19:44:20Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-21T19:44:20Z"}, "message": "(expand_binop): Synthesize double word shifts and rotates from single word\nshifts.\n\nFrom-SVN: r4949", "tree": {"sha": "c1ba9b147f35d16bed5acdc0a6e578ee943e4062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1ba9b147f35d16bed5acdc0a6e578ee943e4062"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c597270e28181591e6c6a2de8567666c0d26ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c597270e28181591e6c6a2de8567666c0d26ced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c597270e28181591e6c6a2de8567666c0d26ced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c597270e28181591e6c6a2de8567666c0d26ced/comments", "author": null, "committer": null, "parents": [{"sha": "c52d2678eda8c7d7fda087a4ec60a8fc08adcdd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c52d2678eda8c7d7fda087a4ec60a8fc08adcdd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c52d2678eda8c7d7fda087a4ec60a8fc08adcdd1"}], "stats": {"total": 214, "additions": 214, "deletions": 0}, "files": [{"sha": "1dd9b823908090118d8cbe33b9c00e189084a7d7", "filename": "gcc/optabs.c", "status": "modified", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c597270e28181591e6c6a2de8567666c0d26ced/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c597270e28181591e6c6a2de8567666c0d26ced/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8c597270e28181591e6c6a2de8567666c0d26ced", "patch": "@@ -569,6 +569,220 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       return target;\n     }\n \n+  /* Synthesize double word shifts from single word shifts.  */\n+  if ((binoptab == lshl_optab || binoptab == lshr_optab\n+       || binoptab == ashl_optab || binoptab == ashr_optab)\n+      && class == MODE_INT\n+      && GET_CODE (op1) == CONST_INT\n+      && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n+      && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n+      && ashl_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n+      && lshr_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+    {\n+      rtx insns, equiv_value;\n+      rtx into_target, outof_target;\n+      rtx into_input, outof_input;\n+      int shift_count, left_shift, outof_word;\n+\n+      /* If TARGET is the same as one of the operands, the REG_EQUAL note\n+\t won't be accurate, so use a new target.  */\n+      if (target == 0 || target == op0 || target == op1)\n+\ttarget = gen_reg_rtx (mode);\n+\n+      start_sequence ();\n+\n+      shift_count = INTVAL (op1);\n+\n+      /* OUTOF_* is the word we are shifting bits away from, and\n+\t INTO_* is the word that we are shifting bits towards, thus\n+\t they differ depending on the direction of the shift and\n+\t WORDS_BIG_ENDIAN.  */\n+\n+      left_shift = (binoptab == ashl_optab || binoptab == lshl_optab);\n+      outof_word = left_shift ^ ! WORDS_BIG_ENDIAN;\n+\n+      outof_target = operand_subword (target, outof_word, 1, mode);\n+      into_target = operand_subword (target, 1 - outof_word, 1, mode);\n+\n+      outof_input = operand_subword_force (op0, outof_word, mode);\n+      into_input = operand_subword_force (op0, 1 - outof_word, mode);\n+\n+      if (shift_count >= BITS_PER_WORD)\n+\t{\n+\t  emit_move_insn (into_target,\n+\t\t\t  expand_binop (word_mode, binoptab,\n+\t\t\t\t\toutof_input,\n+\t\t\t\t\tGEN_INT (shift_count - BITS_PER_WORD),\n+\t\t\t\t\tinto_target, unsignedp, methods));\n+\n+\t  /* For a signed right shift, we must fill the word we are shifting\n+\t     out of with copies of the sign bit.  Otherwise it is zeroed.  */\n+\t  if (binoptab != ashr_optab)\n+\t    emit_move_insn (outof_target, CONST0_RTX (word_mode));\n+\t  else\n+\t    emit_move_insn (outof_target,\n+\t\t\t    expand_binop (word_mode, binoptab,\n+\t\t\t\t\t  outof_input,\n+\t\t\t\t\t  GEN_INT (BITS_PER_WORD - 1),\n+\t\t\t\t\t  outof_target, unsignedp, methods));\n+\t}\n+      else\n+\t{\n+\t  rtx carries, into_temp;\n+\t  optab reverse_unsigned_shift, unsigned_shift;\n+\n+\t  /* For a shift of less then BITS_PER_WORD, to compute the carry,\n+\t     we must do a logical shift in the opposite direction of the\n+\t     desired shift.  */\n+\n+\t  /* We use ashl_optab instead of lshl_optab, because ashl is\n+\t     guaranteed to exist, but lshl may or may not exist.  */\n+\n+\t  reverse_unsigned_shift = (left_shift ? lshr_optab : ashl_optab);\n+\n+\t  /* For a shift of less than BITS_PER_WORD, to compute the word\n+\t     shifted towards, we need to unsigned shift the orig value of\n+\t     that word.  */\n+\n+\t  unsigned_shift = (left_shift ? ashl_optab : lshr_optab);\n+\n+\t  carries = expand_binop (word_mode, reverse_unsigned_shift,\n+\t\t\t\t  outof_input,\n+\t\t\t\t  GEN_INT (BITS_PER_WORD - shift_count),\n+\t\t\t\t  0, unsignedp, methods);\n+\n+\t  emit_move_insn (outof_target,\n+\t\t\t  expand_binop (word_mode, binoptab,\n+\t\t\t\t\toutof_input,\n+\t\t\t\t\top1, outof_target, unsignedp, methods));\n+\t  into_temp = expand_binop (word_mode, unsigned_shift,\n+\t\t\t\t    into_input,\n+\t\t\t\t    op1, 0, unsignedp, methods);\n+\n+\t  emit_move_insn (into_target,\n+\t\t\t  expand_binop (word_mode, ior_optab,\n+\t\t\t\t\tcarries, into_temp,\n+\t\t\t\t\tinto_target, unsignedp, methods));\n+\t}\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      if (binoptab->code != UNKNOWN)\n+\tequiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n+      else\n+\tequiv_value = 0;\n+\n+      emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+      return target;\n+    }\n+\n+  /* Synthesize double word rotates from single word shifts.  */\n+  if ((binoptab == rotl_optab || binoptab == rotr_optab)\n+      && class == MODE_INT\n+      && GET_CODE (op1) == CONST_INT\n+      && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n+      && ashl_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n+      && lshr_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n+    {\n+      rtx insns, equiv_value;\n+      rtx into_target, outof_target;\n+      rtx into_input, outof_input;\n+      int shift_count, left_shift, outof_word;\n+\n+      /* If TARGET is the same as one of the operands, the REG_EQUAL note\n+\t won't be accurate, so use a new target.  */\n+      if (target == 0 || target == op0 || target == op1)\n+\ttarget = gen_reg_rtx (mode);\n+\n+      start_sequence ();\n+\n+      shift_count = INTVAL (op1);\n+\n+      /* OUTOF_* is the word we are shifting bits away from, and\n+\t INTO_* is the word that we are shifting bits towards, thus\n+\t they differ depending on the direction of the shift and\n+\t WORDS_BIG_ENDIAN.  */\n+\n+      left_shift = (binoptab == rotl_optab);\n+      outof_word = left_shift ^ ! WORDS_BIG_ENDIAN;\n+\n+      outof_target = operand_subword (target, outof_word, 1, mode);\n+      into_target = operand_subword (target, 1 - outof_word, 1, mode);\n+\n+      outof_input = operand_subword_force (op0, outof_word, mode);\n+      into_input = operand_subword_force (op0, 1 - outof_word, mode);\n+\n+      if (shift_count == BITS_PER_WORD)\n+\t{\n+\t  /* This is just a word swap.  */\n+\t  emit_move_insn (outof_target, into_input);\n+\t  emit_move_insn (into_target, outof_input);\n+\t}\n+      else\n+\t{\n+\t  rtx into_temp1, into_temp2, outof_temp1, outof_temp2;\n+\t  rtx first_shift_count, second_shift_count;\n+\t  optab reverse_unsigned_shift, unsigned_shift;\n+\n+\t  reverse_unsigned_shift = (left_shift ^ (shift_count < BITS_PER_WORD)\n+\t\t\t\t    ? lshr_optab : ashl_optab);\n+\n+\t  unsigned_shift = (left_shift ^ (shift_count < BITS_PER_WORD)\n+\t\t\t    ? ashl_optab : lshr_optab);\n+\n+\t  if (shift_count > BITS_PER_WORD)\n+\t    {\n+\t      first_shift_count = GEN_INT (shift_count - BITS_PER_WORD);\n+\t      second_shift_count = GEN_INT (2*BITS_PER_WORD - shift_count);\n+\t    }\n+\t  else\n+\t    {\n+\t      first_shift_count = GEN_INT (BITS_PER_WORD - shift_count);\n+\t      second_shift_count = GEN_INT (shift_count);\n+\t    }\n+\n+\t  into_temp1 = expand_binop (word_mode, unsigned_shift,\n+\t\t\t\t     outof_input, first_shift_count,\n+\t\t\t\t     0, unsignedp, methods);\n+\t  into_temp2 = expand_binop (word_mode, reverse_unsigned_shift,\n+\t\t\t\t     into_input, second_shift_count,\n+\t\t\t\t     into_target, unsignedp, methods);\n+\t  emit_move_insn (into_target,\n+\t\t\t  expand_binop (word_mode, ior_optab,\n+\t\t\t\t\tinto_temp1, into_temp2,\n+\t\t\t\t\tinto_target, unsignedp, methods));\n+\n+\t  outof_temp1 = expand_binop (word_mode, unsigned_shift,\n+\t\t\t\t      into_input, first_shift_count,\n+\t\t\t\t      0, unsignedp, methods);\n+\t  outof_temp2 = expand_binop (word_mode, reverse_unsigned_shift,\n+\t\t\t\t      outof_input, second_shift_count,\n+\t\t\t\t      outof_target, unsignedp, methods);\n+\t  emit_move_insn (outof_target,\n+\t\t\t  expand_binop (word_mode, ior_optab,\n+\t\t\t\t\toutof_temp1, outof_temp2,\n+\t\t\t\t\toutof_target, unsignedp, methods));\n+\t}\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      if (binoptab->code != UNKNOWN)\n+\tequiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n+      else\n+\tequiv_value = 0;\n+\n+      /* We can't make this a no conflict block if this is a word swap,\n+\t because the word swap case fails if the input and output values\n+\t are in the same register.  */\n+      if (shift_count != BITS_PER_WORD)\n+\temit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+      else\n+\temit_insns (insns);\n+      return target;\n+    }\n+\n   /* These can be done a word at a time by propagating carries.  */\n   if ((binoptab == add_optab || binoptab == sub_optab)\n       && class == MODE_INT"}]}