{"sha": "f3a880f8ce05db480187117358a742b6c27389e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNhODgwZjhjZTA1ZGI0ODAxODcxMTczNThhNzQyYjZjMjczODllNg==", "commit": {"author": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-09-13T16:14:15Z"}, "committer": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-09-13T16:14:15Z"}, "message": "Revert r202554, r202540 and r202539.\n\n - r202554: Fix uninitialized variables causing breakage with -Werror.\n - r202540: Support using 'auto' in a function parameter list to introduce an implicit template parameter.\n - r202539: Support lambda templates.\n\nFrom-SVN: r202570", "tree": {"sha": "b3a6ccfb5b51b1de42bc371b1ac6993f040d4704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3a6ccfb5b51b1de42bc371b1ac6993f040d4704"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3a880f8ce05db480187117358a742b6c27389e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a880f8ce05db480187117358a742b6c27389e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3a880f8ce05db480187117358a742b6c27389e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a880f8ce05db480187117358a742b6c27389e6/comments", "author": null, "committer": null, "parents": [{"sha": "19ba6aab7b0980c7c07ec76426541c7fea430c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19ba6aab7b0980c7c07ec76426541c7fea430c15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19ba6aab7b0980c7c07ec76426541c7fea430c15"}], "stats": {"total": 609, "additions": 64, "deletions": 545}, "files": [{"sha": "ad47fef03140ae13721b4d32f33e13a9568fc3f2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -1,62 +1,8 @@\n-2013-09-13  Adam Butcher  <adam@jessamine.co.uk>\n-\n-\t* lambda.c (maybe_add_lambda_conv_op): Initialize direct_argvec and call\n-\tto nullptr to avoid breakage with -Werror.\n-\n 2013-09-12  Brooks Moses  <bmoses@google.com>\n \n \tPR driver/42955\n \t* Make-lang.in: Do not install driver binaries in $(target)/bin.\n \n-2013-09-12  Adam Butcher  <adam@jessamine.co.uk>\n-\n-\t* cp-tree.h (type_uses_auto_or_concept): Declare.\n-\t(is_auto_or_concept): Declare.\n-\t* decl.c (grokdeclarator): Allow 'auto' parameters in lambdas with\n-\t-std=gnu++1y or -std=c++1y or, as a GNU extension, in plain functions.\n-\t* type-utils.h: New header defining ...\n-\t(find_type_usage): ... this new function based on pt.c (type_uses_auto)\n-\tfor searching a type tree given a predicate.\n-\t* pt.c (type_uses_auto): Reimplement via type-utils.h (find_type_usage).\n-\t(is_auto_or_concept): New function.\n-\t(type_uses_auto_or_concept): New function.\n-\t* parser.h (struct cp_parser): Add fully_implicit_function_template_p.\n-\t* parser.c (cp_parser_new): Initialize fully_implicit_function_template_p.\n-\t(cp_parser_new): Initialize fully_implicit_function_template_p.\n-\t(cp_parser_lambda_expression): Copy and restore value of\n-\tfully_implicit_function_template_p as per other parser fields.\n-\t(cp_parser_parameter_declaration_list): Count generic\n-\tparameters and call ...\n-\t(add_implicit_template_parms): ... this new function to synthesize them\n-\twith help from type-utils.h (find_type_usage), ...\n-\t(tree_type_is_auto_or_concept): ... this new static function and ...\n-\t(make_generic_type_name): ... this new static function.\n-\t(cp_parser_direct_declarator): Account for implicit template parameters.\n-\t(cp_parser_lambda_declarator_opt): Finish fully implicit template if\n-\tnecessary by calling ...\n-\t(finish_fully_implicit_template): ... this new function.\n-\t(cp_parser_member_declaration): Likewise.\n-\t(cp_parser_function_definition_after_declarator): Likewise.\n-\t* Make-lang.in (cp/pt.o): Add dependency on type-utils.h.\n-\t(cp/parser.o): Likewise.\n-\n-2013-09-12  Adam Butcher  <adam@jessamine.co.uk>\n-\n-\t* parser.c (cp_parser_lambda_declarator_opt): Accept template parameter\n-\tlist with std=c++1y or std=gnu++1y.\n-\t(cp_parser_lambda_body): Don't call 'expand_or_defer_fn' for lambda call\n-\toperator template to avoid adding template result to symbol table.\n-\t* lambda.c (lambda_function): Return template result if call operator is\n-\ta template.\n-\t(maybe_add_lambda_conv_op): Move declarations to point of use.  Refactor\n-\toperator call building in order to support conversion of a non-capturing\n-\tlambda template to a function pointer with help from ...\n-\t(prepare_op_call): ... this new function.\n-\t* decl2.c (check_member_template): Don't reject lambda call operator\n-\ttemplate in local [lambda] class.\n-\t* pt.c (instantiate_class_template_1): Don't instantiate lambda call\n-\toperator template when instantiating lambda class.\n-\n 2013-09-12  Adam Butcher  <adam@jessamine.co.uk>\n \n \t* pt.c (instantiate_decl): Save/restore cp_unevaluated_operand and"}, {"sha": "9a804346e4d840c9e416d96d18c8e7d1d468396e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -312,7 +312,7 @@ cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/cp-objcp-common.h \\\n   toplev.h $(TREE_INLINE_H) pointer-set.h gt-cp-pt.h intl.h \\\n-  c-family/c-objc.h cp/type-utils.h\n+  c-family/c-objc.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_H) \\\n   $(FLAGS_H) $(REAL_H) $(LANGHOOKS_DEF_H) $(CXX_PRETTY_PRINT_H) \\\n   tree-diagnostic.h tree-pretty-print.h pointer-set.h c-family/c-objc.h\n@@ -331,8 +331,7 @@ cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H) $(CGRAPH_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n   gt-cp-parser.h $(TARGET_H) $(PLUGIN_H) intl.h cp/decl.h \\\n-  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR_H) \\\n-  cp/type-utils.h\n+  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR_H)\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h $(SPLAY_TREE_H)\n cp/vtable-class-hierarchy.o: cp/vtable-class-hierarchy.c \\"}, {"sha": "0d8bd9544ca1bd4cd0cf734b2117f7827c7fd588", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -5455,12 +5455,10 @@ extern tree make_auto\t\t\t\t(void);\n extern tree make_decltype_auto\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);\n-extern tree type_uses_auto_or_concept\t\t(tree);\n extern void append_type_to_template_for_access_check (tree, tree, tree,\n \t\t\t\t\t\t      location_t);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n-extern bool is_auto_or_concept\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, location_t, tree, \n \t\t\t\t\t\t bool, bool);\n extern tree end_template_parm_list\t\t(tree);"}, {"sha": "b4223aa5706358db5f57f8403e6d0dd1fa40fe92", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -10320,23 +10320,8 @@ grokdeclarator (const cp_declarator *declarator,\n \n       if (type_uses_auto (type))\n \t{\n-\t  if (current_class_type && LAMBDA_TYPE_P (current_class_type))\n-\t    {\n-\t      if (cxx_dialect < cxx1y)\n-\t\tpedwarn (location_of (type), 0,\n-\t\t\t \"use of %<auto%> in lambda parameter declaration \"\n-\t\t\t \"only available with \"\n-\t\t\t \"-std=c++1y or -std=gnu++1y\");\n-\t    }\n-\t  else if (cxx_dialect < cxx1y)\n-\t    pedwarn (location_of (type), 0,\n-\t\t     \"use of %<auto%> in parameter declaration \"\n-\t\t     \"only available with \"\n-\t\t     \"-std=c++1y or -std=gnu++1y\");\n-\t  else\n-\t    pedwarn (location_of (type), OPT_Wpedantic,\n-\t\t     \"ISO C++ forbids use of %<auto%> in parameter \"\n-\t\t     \"declaration\");\n+\t  error (\"parameter declared %<auto%>\");\n+\t  type = error_mark_node;\n \t}\n \n       /* A parameter declared as an array of T is really a pointer to T."}, {"sha": "d5d29127cfd269ddd349db113834c9a408141516", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -507,9 +507,8 @@ check_member_template (tree tmpl)\n       || (TREE_CODE (decl) == TYPE_DECL\n \t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (decl))))\n     {\n-      /* The parser rejects template declarations in local classes\n-\t (with the exception of generic lambdas).  */\n-      gcc_assert (!current_function_decl || LAMBDA_FUNCTION_P (decl));\n+      /* The parser rejects template declarations in local classes.  */\n+      gcc_assert (!current_function_decl);\n       /* The parser rejects any use of virtual in a function template.  */\n       gcc_assert (!(TREE_CODE (decl) == FUNCTION_DECL\n \t\t    && DECL_VIRTUAL_P (decl)));"}, {"sha": "a53e692d48b462ca94db0bb456681cf45d833c29", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 32, "deletions": 157, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -196,7 +196,7 @@ lambda_function (tree lambda)\n \t\t\t  /*protect=*/0, /*want_type=*/false,\n \t\t\t  tf_warning_or_error);\n   if (lambda)\n-    lambda = STRIP_TEMPLATE (get_first_fn (lambda));\n+    lambda = BASELINK_FUNCTIONS (lambda);\n   return lambda;\n }\n \n@@ -741,22 +741,6 @@ nonlambda_method_basetype (void)\n   return TYPE_METHOD_BASETYPE (TREE_TYPE (fn));\n }\n \n-/* Helper function for maybe_add_lambda_conv_op; build a CALL_EXPR with\n-   indicated FN and NARGS, but do not initialize the return type or any of the\n-   argument slots.  */\n-\n-static tree\n-prepare_op_call (tree fn, int nargs)\n-{\n-  tree t;\n-\n-  t = build_vl_exp (CALL_EXPR, nargs + 3);\n-  CALL_EXPR_FN (t) = fn;\n-  CALL_EXPR_STATIC_CHAIN (t) = NULL;\n-\n-  return t;\n-}\n-\n /* If the closure TYPE has a static op(), also add a conversion to function\n    pointer.  */\n \n@@ -765,145 +749,33 @@ maybe_add_lambda_conv_op (tree type)\n {\n   bool nested = (current_function_decl != NULL_TREE);\n   tree callop = lambda_function (type);\n+  tree rettype, name, fntype, fn, body, compound_stmt;\n+  tree thistype, stattype, statfn, convfn, call, arg;\n+  vec<tree, va_gc> *argvec;\n \n   if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)\n     return;\n \n   if (processing_template_decl)\n     return;\n \n-  bool const generic_lambda_p\n-    = (DECL_TEMPLATE_INFO (callop)\n-    && DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (callop)) == callop);\n-\n   if (DECL_INITIAL (callop) == NULL_TREE)\n     {\n       /* If the op() wasn't instantiated due to errors, give up.  */\n       gcc_assert (errorcount || sorrycount);\n       return;\n     }\n \n-  /* Non-template conversion operators are defined directly with build_call_a\n-     and using DIRECT_ARGVEC for arguments (including 'this').  Templates are\n-     deferred and the CALL is built in-place.  In the case of a deduced return\n-     call op, the decltype expression, DECLTYPE_CALL, used as a substitute for\n-     the return type is also built in-place.  The arguments of DECLTYPE_CALL in\n-     the return expression may differ in flags from those in the body CALL.  In\n-     particular, parameter pack expansions are marked PACK_EXPANSION_LOCAL_P in\n-     the body CALL, but not in DECLTYPE_CALL.  */\n-\n-  vec<tree, va_gc> *direct_argvec = 0;\n-  tree decltype_call = 0, call = 0;\n-  tree fn_result = TREE_TYPE (TREE_TYPE (callop));\n-\n-  if (generic_lambda_p)\n-    {\n-      /* Prepare the dependent member call for the static member function\n-\t '_FUN' and, potentially, prepare another call to be used in a decltype\n-\t return expression for a deduced return call op to allow for simple\n-\t implementation of the conversion operator.  */\n-\n-      tree instance = build_nop (type, null_pointer_node);\n-      tree objfn = build_min (COMPONENT_REF, NULL_TREE,\n-\t\t\t      instance, DECL_NAME (callop), NULL_TREE);\n-      int nargs = list_length (DECL_ARGUMENTS (callop)) - 1;\n-\n-      call = prepare_op_call (objfn, nargs);\n-      if (type_uses_auto (fn_result))\n-\tdecltype_call = prepare_op_call (objfn, nargs);\n-    }\n-  else\n-    {\n-      direct_argvec = make_tree_vector ();\n-      direct_argvec->quick_push (build1 (NOP_EXPR,\n-\t\t\t\t\t TREE_TYPE (DECL_ARGUMENTS (callop)),\n-\t\t\t\t\t null_pointer_node));\n-    }\n-\n-  /* Copy CALLOP's argument list (as per 'copy_list') as FN_ARGS in order to\n-     declare the static member function \"_FUN\" below.  For each arg append to\n-     DIRECT_ARGVEC (for the non-template case) or populate the pre-allocated\n-     call args (for the template case).  If a parameter pack is found, expand\n-     it, flagging it as PACK_EXPANSION_LOCAL_P for the body call.  */\n-\n-  tree fn_args = NULL_TREE;\n-  {\n-    int ix = 0;\n-    tree src = DECL_CHAIN (DECL_ARGUMENTS (callop));\n-    tree tgt;\n-\n-    while (src)\n-      {\n-\ttree new_node = copy_node (src);\n-\n-\tif (!fn_args)\n-\t  fn_args = tgt = new_node;\n-\telse\n-\t  {\n-\t    TREE_CHAIN (tgt) = new_node;\n-\t    tgt = new_node;\n-\t  }\n-\n-\tmark_exp_read (tgt);\n-\n-\tif (generic_lambda_p)\n-\t  {\n-\t    if (FUNCTION_PARAMETER_PACK_P (tgt))\n-\t      {\n-\t\ttree a = make_pack_expansion (tgt);\n-\t\tif (decltype_call)\n-\t\t  CALL_EXPR_ARG (decltype_call, ix) = copy_node (a);\n-\t\tPACK_EXPANSION_LOCAL_P (a) = true;\n-\t\tCALL_EXPR_ARG (call, ix) = a;\n-\t      }\n-\t    else\n-\t      {\n-\t\ttree a = convert_from_reference (tgt);\n-\t\tCALL_EXPR_ARG (call, ix) = a;\n-\t\tif (decltype_call)\n-\t\t  CALL_EXPR_ARG (decltype_call, ix) = copy_node (a);\n-\t      }\n-\t    ++ix;\n-\t  }\n-\telse\n-\t  vec_safe_push (direct_argvec, tgt);\n-\n-\tsrc = TREE_CHAIN (src);\n-      }\n-  }\n-\n-\n-  if (generic_lambda_p)\n-    {\n-      if (decltype_call)\n-\t{\n-\t  ++processing_template_decl;\n-\t  fn_result = finish_decltype_type\n-\t    (decltype_call, /*id_expression_or_member_access_p=*/false,\n-\t     tf_warning_or_error);\n-\t  --processing_template_decl;\n-\t}\n-    }\n-  else\n-    {\n-      call = build_call_a (callop,\n-\t\t\t   direct_argvec->length (),\n-\t\t\t   direct_argvec->address ());\n-      if (MAYBE_CLASS_TYPE_P (TREE_TYPE (call)))\n-\tcall = build_cplus_new (TREE_TYPE (call), call, tf_warning_or_error);\n-    }\n-  CALL_FROM_THUNK_P (call) = 1;\n-\n-  tree stattype = build_function_type (fn_result, FUNCTION_ARG_CHAIN (callop));\n+  stattype = build_function_type (TREE_TYPE (TREE_TYPE (callop)),\n+\t\t\t\t  FUNCTION_ARG_CHAIN (callop));\n \n   /* First build up the conversion op.  */\n \n-  tree rettype = build_pointer_type (stattype);\n-  tree name = mangle_conv_op_name_for_type (rettype);\n-  tree thistype = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n-  tree fntype = build_method_type_directly (thistype, rettype, void_list_node);\n-  tree convfn = build_lang_decl (FUNCTION_DECL, name, fntype);\n-  tree fn = convfn;\n+  rettype = build_pointer_type (stattype);\n+  name = mangle_conv_op_name_for_type (rettype);\n+  thistype = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+  fntype = build_method_type_directly (thistype, rettype, void_list_node);\n+  fn = convfn = build_lang_decl (FUNCTION_DECL, name, fntype);\n   DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n \n   if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n@@ -922,9 +794,6 @@ maybe_add_lambda_conv_op (tree type)\n   if (nested)\n     DECL_INTERFACE_KNOWN (fn) = 1;\n \n-  if (generic_lambda_p)\n-    fn = add_inherited_template_parms (fn, DECL_TI_TEMPLATE (callop));\n-\n   add_method (type, fn, NULL_TREE);\n \n   /* Generic thunk code fails for varargs; we'll complain in mark_used if\n@@ -938,8 +807,7 @@ maybe_add_lambda_conv_op (tree type)\n   /* Now build up the thunk to be returned.  */\n \n   name = get_identifier (\"_FUN\");\n-  tree statfn = build_lang_decl (FUNCTION_DECL, name, stattype);\n-  fn = statfn;\n+  fn = statfn = build_lang_decl (FUNCTION_DECL, name, stattype);\n   DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n   if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n       && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n@@ -952,8 +820,8 @@ maybe_add_lambda_conv_op (tree type)\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_STATIC_FUNCTION_P (fn) = 1;\n-  DECL_ARGUMENTS (fn) = fn_args;\n-  for (tree arg = fn_args; arg; arg = DECL_CHAIN (arg))\n+  DECL_ARGUMENTS (fn) = copy_list (DECL_CHAIN (DECL_ARGUMENTS (callop)));\n+  for (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n     {\n       /* Avoid duplicate -Wshadow warnings.  */\n       DECL_NAME (arg) = NULL_TREE;\n@@ -962,9 +830,6 @@ maybe_add_lambda_conv_op (tree type)\n   if (nested)\n     DECL_INTERFACE_KNOWN (fn) = 1;\n \n-  if (generic_lambda_p)\n-    fn = add_inherited_template_parms (fn, DECL_TI_TEMPLATE (callop));\n-\n   add_method (type, fn, NULL_TREE);\n \n   if (nested)\n@@ -985,17 +850,29 @@ maybe_add_lambda_conv_op (tree type)\n \t ((symtab_node) cgraph_get_create_node (statfn),\n           (symtab_node) cgraph_get_create_node (callop));\n     }\n-  tree body = begin_function_body ();\n-  tree compound_stmt = begin_compound_stmt (0);\n+  body = begin_function_body ();\n+  compound_stmt = begin_compound_stmt (0);\n+\n+  arg = build1 (NOP_EXPR, TREE_TYPE (DECL_ARGUMENTS (callop)),\n+\t\tnull_pointer_node);\n+  argvec = make_tree_vector ();\n+  argvec->quick_push (arg);\n+  for (arg = DECL_ARGUMENTS (statfn); arg; arg = DECL_CHAIN (arg))\n+    {\n+      mark_exp_read (arg);\n+      vec_safe_push (argvec, arg);\n+    }\n+  call = build_call_a (callop, argvec->length (), argvec->address ());\n+  CALL_FROM_THUNK_P (call) = 1;\n+  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (call)))\n+    call = build_cplus_new (TREE_TYPE (call), call, tf_warning_or_error);\n   call = convert_from_reference (call);\n   finish_return_stmt (call);\n \n   finish_compound_stmt (compound_stmt);\n   finish_function_body (body);\n \n-  fn = finish_function (/*inline*/2);\n-  if (!generic_lambda_p)\n-    expand_or_defer_fn (fn);\n+  expand_or_defer_fn (finish_function (2));\n \n   /* Generate the body of the conversion op.  */\n \n@@ -1011,9 +888,7 @@ maybe_add_lambda_conv_op (tree type)\n   finish_compound_stmt (compound_stmt);\n   finish_function_body (body);\n \n-  fn = finish_function (/*inline*/2);\n-  if (!generic_lambda_p)\n-    expand_or_defer_fn (fn);\n+  expand_or_defer_fn (finish_function (2));\n \n   if (nested)\n     pop_function_context ();"}, {"sha": "e00e56c6e012a7cf0f9f8e6206f65ab47e56d0ad", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 225, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -38,7 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"tree-pretty-print.h\"\n #include \"parser.h\"\n-#include \"type-utils.h\"\n \n \f\n /* The lexer.  */\n@@ -2064,11 +2063,6 @@ static vec<constructor_elt, va_gc> *cp_parser_initializer_list\n static bool cp_parser_ctor_initializer_opt_and_function_body\n   (cp_parser *, bool);\n \n-static tree add_implicit_template_parms\n-  (cp_parser *, size_t, tree);\n-static tree finish_fully_implicit_template\n-  (cp_parser *, tree);\n-\n /* Classes [gram.class] */\n \n static tree cp_parser_class_name\n@@ -3391,9 +3385,6 @@ cp_parser_new (void)\n   /* No template parameters apply.  */\n   parser->num_template_parameter_lists = 0;\n \n-  /* Not declaring an implicit function template.  */\n-  parser->fully_implicit_function_template_p = false;\n-\n   return parser;\n }\n \n@@ -8558,12 +8549,10 @@ cp_parser_lambda_expression (cp_parser* parser)\n         = parser->num_template_parameter_lists;\n     unsigned char in_statement = parser->in_statement;\n     bool in_switch_statement_p = parser->in_switch_statement_p;\n-    bool fully_implicit_function_template_p = parser->fully_implicit_function_template_p;\n \n     parser->num_template_parameter_lists = 0;\n     parser->in_statement = 0;\n     parser->in_switch_statement_p = false;\n-    parser->fully_implicit_function_template_p = false;\n \n     /* By virtue of defining a local class, a lambda expression has access to\n        the private variables of enclosing classes.  */\n@@ -8587,7 +8576,6 @@ cp_parser_lambda_expression (cp_parser* parser)\n     parser->num_template_parameter_lists = saved_num_template_parameter_lists;\n     parser->in_statement = in_statement;\n     parser->in_switch_statement_p = in_switch_statement_p;\n-    parser->fully_implicit_function_template_p = fully_implicit_function_template_p;\n   }\n \n   pop_deferring_access_checks ();\n@@ -8795,7 +8783,6 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n /* Parse the (optional) middle of a lambda expression.\n \n    lambda-declarator:\n-     < template-parameter-list [opt] >\n      ( parameter-declaration-clause [opt] )\n        attribute-specifier [opt]\n        mutable [opt]\n@@ -8815,30 +8802,9 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n   tree param_list = void_list_node;\n   tree attributes = NULL_TREE;\n   tree exception_spec = NULL_TREE;\n-  tree template_param_list = NULL_TREE;\n-\n-  /* The template-parameter-list is optional, but must begin with\n-     an opening angle if present.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n-    {\n-      if (cxx_dialect < cxx1y)\n-\tpedwarn (parser->lexer->next_token->location, 0,\n-\t\t \"lambda templates are only available with \"\n-\t\t \"-std=c++1y or -std=gnu++1y\");\n-\n-      cp_lexer_consume_token (parser->lexer);\n-\n-      template_param_list = cp_parser_template_parameter_list (parser);\n \n-      cp_parser_skip_to_end_of_template_parameter_list (parser);\n-\n-      /* We just processed one more parameter list.  */\n-      ++parser->num_template_parameter_lists;\n-    }\n-\n-  /* The parameter-declaration-clause is optional (unless\n-     template-parameter-list was given), but must begin with an\n-     opening parenthesis if present.  */\n+  /* The lambda-declarator is optional, but must begin with an opening\n+     parenthesis if present.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n       cp_lexer_consume_token (parser->lexer);\n@@ -8881,8 +8847,6 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n          trailing-return-type in case of decltype.  */\n       pop_bindings_and_leave_scope ();\n     }\n-  else if (template_param_list != NULL_TREE) // generate diagnostic\n-    cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n   /* Create the function call operator.\n \n@@ -8926,14 +8890,6 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \tDECL_ARTIFICIAL (fco) = 1;\n \t/* Give the object parameter a different name.  */\n \tDECL_NAME (DECL_ARGUMENTS (fco)) = get_identifier (\"__closure\");\n-\tif (template_param_list)\n-\t  {\n-\t    fco = finish_member_template_decl (fco);\n-\t    finish_template_decl (template_param_list);\n-\t    --parser->num_template_parameter_lists;\n-\t  }\n-\telse if (parser->fully_implicit_function_template_p)\n-\t  fco = finish_fully_implicit_template (parser, fco);\n       }\n \n     finish_member_declaration (fco);\n@@ -9056,11 +9012,7 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n     finish_lambda_scope ();\n \n     /* Finish the function and generate code for it if necessary.  */\n-    tree fn = finish_function (/*inline*/2);\n-\n-    /* Only expand if the call op is not a template.  */\n-    if (!DECL_TEMPLATE_INFO (fco))\n-      expand_or_defer_fn (fn);\n+    expand_or_defer_fn (finish_function (/*inline*/2));\n   }\n \n   parser->local_variables_forbidden_p = local_variables_forbidden_p;\n@@ -16804,10 +16756,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      /* Parse the parameter-declaration-clause.  */\n \t      params = cp_parser_parameter_declaration_clause (parser);\n \n-\t      /* Restore saved template parameter lists accounting for implicit\n-\t\t template parameters.  */\n \t      parser->num_template_parameter_lists\n-\t\t+= saved_num_template_parameter_lists;\n+\t\t= saved_num_template_parameter_lists;\n \n \t      /* Consume the `)'.  */\n \t      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n@@ -17905,7 +17855,6 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   tree *tail = &parameters; \n   bool saved_in_unbraced_linkage_specification_p;\n   int index = 0;\n-  int implicit_template_parms = 0;\n \n   /* Assume all will go well.  */\n   *is_error = false;\n@@ -17933,18 +17882,11 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n       deprecated_state = DEPRECATED_SUPPRESS;\n \n       if (parameter)\n-\t{\n-\t  decl = grokdeclarator (parameter->declarator,\n-\t\t\t\t &parameter->decl_specifiers,\n-\t\t\t\t PARM,\n-\t\t\t\t parameter->default_argument != NULL_TREE,\n-\t\t\t\t &parameter->decl_specifiers.attributes);\n-\n-\t  if (TREE_TYPE (decl) != error_mark_node\n-\t      && parameter->decl_specifiers.type\n-\t      && is_auto_or_concept (parameter->decl_specifiers.type))\n-\t      ++implicit_template_parms;\n-\t}\n+\tdecl = grokdeclarator (parameter->declarator,\n+\t\t\t       &parameter->decl_specifiers,\n+\t\t\t       PARM,\n+\t\t\t       parameter->default_argument != NULL_TREE,\n+\t\t\t       &parameter->decl_specifiers.attributes);\n \n       deprecated_state = DEPRECATED_NORMAL;\n \n@@ -18032,11 +17974,6 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   parser->in_unbraced_linkage_specification_p\n     = saved_in_unbraced_linkage_specification_p;\n \n-  if (parameters != error_mark_node && implicit_template_parms)\n-    parameters = add_implicit_template_parms (parser,\n-\t\t\t\t\t      implicit_template_parms,\n-\t\t\t\t\t      parameters);\n-\n   return parameters;\n }\n \n@@ -20043,11 +19980,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t\t\t\t      attributes);\n \t\t  /* If the member was not a friend, declare it here.  */\n \t\t  if (!friend_p)\n-\t\t    {\n-\t\t      if (parser->fully_implicit_function_template_p)\n-\t\t\tdecl = finish_fully_implicit_template (parser, decl);\n-\t\t      finish_member_declaration (decl);\n-\t\t    }\n+\t\t    finish_member_declaration (decl);\n \t\t  /* Peek at the next token.  */\n \t\t  token = cp_lexer_peek_token (parser->lexer);\n \t\t  /* If the next token is a semicolon, consume it.  */\n@@ -20063,8 +19996,6 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t  initializer, /*init_const_expr_p=*/true,\n \t\t\t\t  asm_specification,\n \t\t\t\t  attributes);\n-\t\tif (parser->fully_implicit_function_template_p)\n-\t\t  decl = finish_fully_implicit_template (parser, decl);\n \t    }\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n@@ -22332,9 +22263,6 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n     = saved_num_template_parameter_lists;\n   parser->in_function_body = saved_in_function_body;\n \n-  if (parser->fully_implicit_function_template_p)\n-    finish_fully_implicit_template (parser, /*member_decl_opt=*/0);\n-\n   return fn;\n }\n \n@@ -28880,147 +28808,4 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n-/* Create an identifier for a generic parameter type (a synthesized\n-   template parameter implied by `auto' or a concept identifier). */\n-\n-static tree\n-make_generic_type_name (int i)\n-{\n-  char buf[32];\n-  sprintf (buf, \"__GenT%d\", i);\n-  return get_identifier (buf);\n-}\n-\n-/* Predicate that behaves as is_auto_or_concept but matches the parent\n-   node of the generic type rather than the generic type itself.  This\n-   allows for type transformation in add_implicit_template_parms.  */\n-\n-static inline bool\n-tree_type_is_auto_or_concept (const_tree t)\n-{\n-  return TREE_TYPE (t) && is_auto_or_concept (TREE_TYPE (t));\n-}\n-\n-/* Add COUNT implicit template parameters gleaned from the generic\n-   type parameters in PARAMETERS to the CURRENT_TEMPLATE_PARMS\n-   (creating a new template parameter list if necessary).  Returns\n-   PARAMETERS suitably rewritten to reference the newly created types\n-   or ERROR_MARK_NODE on failure.  */\n-\n-tree\n-add_implicit_template_parms (cp_parser *parser, size_t count, tree parameters)\n-{\n-  gcc_assert (current_binding_level->kind == sk_function_parms);\n-\n-  cp_binding_level *fn_parms_scope = current_binding_level;\n-\n-  bool become_template =\n-    fn_parms_scope->level_chain->kind != sk_template_parms;\n-\n-  size_t synth_idx = 0;\n-\n-  /* Roll back a scope level and either introduce a new template parameter list\n-     or update an existing one.  The function scope is added back after template\n-     parameter synthesis below.  */\n-  current_binding_level = fn_parms_scope->level_chain;\n-\n-  /* TPARMS tracks the function's template parameter list.  This is either a new\n-     chain in the case of a fully implicit function template or an extension of\n-     the function's explicitly specified template parameter list.  */\n-  tree tparms = NULL_TREE;\n-\n-  if (become_template)\n-    {\n-      push_deferring_access_checks (dk_deferred);\n-      begin_template_parm_list ();\n-\n-      parser->fully_implicit_function_template_p = true;\n-      ++parser->num_template_parameter_lists;\n-    }\n-  else\n-    {\n-      /* Roll back the innermost template parameter list such that it may be\n-\t extended in the loop below as if it were being explicitly declared.  */\n-\n-      gcc_assert (current_template_parms);\n-\n-      /* Pop the innermost template parms into TPARMS.  */\n-      tree inner_vec = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n-      current_template_parms = TREE_CHAIN (current_template_parms);\n-\n-      size_t inner_vec_len = TREE_VEC_LENGTH (inner_vec);\n-      if (inner_vec_len != 0)\n-\t{\n-\t  tree t = tparms = TREE_VEC_ELT (inner_vec, 0);\n-\t  for (size_t n = 1; n < inner_vec_len; ++n)\n-\t    t = TREE_CHAIN (t) = TREE_VEC_ELT (inner_vec, n);\n-\t}\n-\n-      ++processing_template_parmlist;\n-    }\n-\n-  for (tree p = parameters; p && synth_idx < count; p = TREE_CHAIN (p))\n-    {\n-      tree generic_type_ptr\n-\t= find_type_usage (TREE_VALUE (p), tree_type_is_auto_or_concept);\n-\n-      if (!generic_type_ptr)\n-\tcontinue;\n-\n-      tree synth_id = make_generic_type_name (synth_idx++);\n-      tree synth_tmpl_parm = finish_template_type_parm (class_type_node,\n-\t\t\t\t\t\t\tsynth_id);\n-      tparms = process_template_parm (tparms, DECL_SOURCE_LOCATION (TREE_VALUE\n-\t\t\t\t\t\t\t\t    (p)),\n-\t\t\t\t      build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t       synth_tmpl_parm),\n-\t\t\t\t      /*non_type=*/false,\n-\t\t\t\t      /*param_pack=*/false);\n-\n-      /* Rewrite the type of P to be the template_parm added above (getdecls is\n-         used to retrieve it since it is the most recent declaration in this\n-         scope).  Qualifiers need to be preserved also.  */\n-\n-      tree& cur_type = TREE_TYPE (generic_type_ptr);\n-      tree new_type = TREE_TYPE (getdecls ());\n-\n-      if (TYPE_QUALS (cur_type))\n-\tcur_type = cp_build_qualified_type (new_type, TYPE_QUALS (cur_type));\n-      else\n-\tcur_type = new_type;\n-    }\n-\n-  gcc_assert (synth_idx == count);\n-\n-  push_binding_level (fn_parms_scope);\n-\n-  end_template_parm_list (tparms);\n-\n-  return parameters;\n-}\n-\n-/* Finish the declaration of a fully implicit function template.  Such a\n-   template has no explicit template parameter list so has not been through the\n-   normal template head and tail processing.  add_implicit_template_parms tries\n-   to do the head; this tries to do the tail.  MEMBER_DECL_OPT should be\n-   provided if the declaration is a class member such that its template\n-   declaration can be completed.  If MEMBER_DECL_OPT is provided the finished\n-   form is returned.  Otherwise NULL_TREE is returned. */\n-\n-tree\n-finish_fully_implicit_template (cp_parser *parser, tree member_decl_opt)\n-{\n-  gcc_assert (parser->fully_implicit_function_template_p);\n-\n-  pop_deferring_access_checks ();\n-  if (member_decl_opt)\n-    member_decl_opt = finish_member_template_decl (member_decl_opt);\n-  end_template_decl ();\n-\n-  parser->fully_implicit_function_template_p = false;\n-  --parser->num_template_parameter_lists;\n-\n-  return member_decl_opt;\n-}\n-\n #include \"gt-cp-parser.h\""}, {"sha": "3d8bb742d221c4bf3814257ac9adb9f81ba8eedd", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -341,12 +341,6 @@ typedef struct GTY(()) cp_parser {\n   /* The number of template parameter lists that apply directly to the\n      current declaration.  */\n   unsigned num_template_parameter_lists;\n-\n-  /* TRUE if the function being declared was made a template due to its\n-     parameter list containing generic type specifiers (`auto' or concept\n-     identifiers) rather than an explicit template parameter list.  */\n-  bool fully_implicit_function_template_p;\n-\n } cp_parser;\n \n /* In parser.c  */"}, {"sha": "3ae679a055b1d8a6357661a44391c879849b383f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a880f8ce05db480187117358a742b6c27389e6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f3a880f8ce05db480187117358a742b6c27389e6", "patch": "@@ -41,7 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"timevar.h\"\n #include \"tree-iterator.h\"\n-#include \"type-utils.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -9104,9 +9103,7 @@ instantiate_class_template_1 (tree type)\n       tree decl = lambda_function (type);\n       if (decl)\n \t{\n-\t  if (!DECL_TEMPLATE_INFO (decl)\n-\t      || DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (decl)) != decl)\n-\t    instantiate_decl (decl, false, false);\n+\t  instantiate_decl (decl, false, false);\n \n \t  /* We need to instantiate the capture list from the template\n \t     after we've instantiated the closure members, but before we\n@@ -21111,35 +21108,31 @@ is_auto (const_tree type)\n     return false;\n }\n \n-/* Returns the TEMPLATE_TYPE_PARM in TYPE representing `auto' iff TYPE contains\n-   a use of `auto'.  Returns NULL_TREE otherwise.  */\n+/* Returns true iff TYPE contains a use of 'auto'.  Since auto can only\n+   appear as a type-specifier for the declaration in question, we don't\n+   have to look through the whole type.  */\n \n tree\n type_uses_auto (tree type)\n {\n-  return find_type_usage (type, is_auto);\n-}\n+  enum tree_code code;\n+  if (is_auto (type))\n+    return type;\n \n-/* Returns true iff TYPE is a TEMPLATE_TYPE_PARM representing 'auto',\n-   'decltype(auto)' or a concept.  */\n+  code = TREE_CODE (type);\n \n-bool\n-is_auto_or_concept (const_tree type)\n-{\n-  return is_auto (type); // or concept\n-}\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n+      || code == OFFSET_TYPE || code == FUNCTION_TYPE\n+      || code == METHOD_TYPE || code == ARRAY_TYPE)\n+    return type_uses_auto (TREE_TYPE (type));\n \n-/* Returns the TEMPLATE_TYPE_PARM in TYPE representing a generic type (`auto' or\n-   a concept identifier) iff TYPE contains a use of a generic type.  Returns\n-   NULL_TREE otherwise.  */\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    return type_uses_auto (TREE_TYPE (TREE_TYPE\n+\t\t\t\t   (TYPE_PTRMEMFUNC_FN_TYPE (type))));\n \n-tree\n-type_uses_auto_or_concept (tree type)\n-{\n-  return find_type_usage (type, is_auto_or_concept);\n+  return NULL_TREE;\n }\n \n-\n /* For a given template T, return the vector of typedefs referenced\n    in T for which access check is needed at T instantiation time.\n    T is either  a FUNCTION_DECL or a RECORD_TYPE."}, {"sha": "3e82ca4f9576b7d25d76f71eb888689d432e01b6", "filename": "gcc/cp/type-utils.h", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19ba6aab7b0980c7c07ec76426541c7fea430c15/gcc%2Fcp%2Ftype-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19ba6aab7b0980c7c07ec76426541c7fea430c15/gcc%2Fcp%2Ftype-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftype-utils.h?ref=19ba6aab7b0980c7c07ec76426541c7fea430c15", "patch": "@@ -1,55 +0,0 @@\n-/* Utilities for querying and manipulating type trees.\n-   Copyright (C) 2013 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_CP_TYPE_UTILS_H\n-#define GCC_CP_TYPE_UTILS_H\n-\n-/* Returns the first tree within T that is directly matched by PRED.  T may be a\n-   type or PARM_DECL and is incrementally decomposed toward its type-specifier\n-   until a match is found.  NULL_TREE is returned if PRED does not match any\n-   part of T.\n-\n-   This is primarily intended for detecting whether T uses `auto' or a concept\n-   identifier.  Since either of these can only appear as a type-specifier for\n-   the declaration in question, only top-level qualifications are traversed;\n-   find_type_usage does not look through the whole type.  */\n-\n-inline tree\n-find_type_usage (tree t, bool (*pred) (const_tree))\n-{\n-  enum tree_code code;\n-  if (pred (t))\n-    return t;\n-\n-  code = TREE_CODE (t);\n-\n-  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n-      || code == PARM_DECL || code == OFFSET_TYPE\n-      || code == FUNCTION_TYPE || code == METHOD_TYPE\n-      || code == ARRAY_TYPE)\n-    return find_type_usage (TREE_TYPE (t), pred);\n-\n-  if (TYPE_PTRMEMFUNC_P (t))\n-    return find_type_usage\n-      (TREE_TYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t))), pred);\n-\n-  return NULL_TREE;\n-}\n-\n-#endif // GCC_CP_TYPE_UTILS_H"}]}