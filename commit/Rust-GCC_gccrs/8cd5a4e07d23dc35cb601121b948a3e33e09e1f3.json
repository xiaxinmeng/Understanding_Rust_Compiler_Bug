{"sha": "8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkNWE0ZTA3ZDIzZGMzNWNiNjAxMTIxYjk0OGEzZTMzZTA5ZTFmMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-14T06:24:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-14T06:24:27Z"}, "message": "target.h (struct gcc_target): Add calls.pass_by_reference.\n\n\t* target.h (struct gcc_target): Add calls.pass_by_reference.\n\t* target-def.h (TARGET_PASS_BY_REFERENCE): New.\n\t* function.c (pass_by_reference): Use the hook.\n\t* system.h (FUNCTION_ARG_PASS_BY_REFERENCE): Poison.\n\t* targhooks.c, targhooks.h (hook_pass_by_reference_false): New.\n\t(hook_pass_by_reference_must_pass_in_stack): New.\n\t* config/alpha/alpha.c (function_arg): Don't query pass-by-ref.\n\t(alpha_pass_by_reference): New.\n\t(TARGET_PASS_BY_REFERENCE): New.\n\t* config/alpha/alpha.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/arc/arc.c (arc_pass_by_reference): New.\n\t(TARGET_PASS_BY_REFERENCE): New.\n\t* config/arc/arc.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t(FUNCTION_ARG_CALLEE_COPIES): True.\n\t* config/arm/arm-protos.h (arm_function_arg_pass_by_reference): Remove.\n\t* config/arm/arm.c (TARGET_PASS_BY_REFERENCE): New.\n\t(arm_pass_by_reference): Rename from arm_function_arg_pass_by_reference.\n\t* config/arm/arm.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/c4x/c4x.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/cris/cris.c (cris_pass_by_reference): New.\n\t(TARGET_PASS_BY_REFERENCE): New.\n\t* config/cris/cris.h (FUNCTION_ARG): Don't query pass-by-ref.\n\t(FUNCTION_INCOMING_ARG, FUNCTION_ARG_ADVANCE): Likewise.\n\t(FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/fr30/fr30.c (TARGET_PASS_BY_REFERENCE): New.\n\t* config/fr30/fr30.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/frv/frv-protos.h (frv_function_arg_pass_by_reference): Kill.\n\t* config/frv/frv.c (TARGET_PASS_BY_REFERENCE): New.\n\t(frv_function_arg_pass_by_reference): Remove.\n\t* config/frv/frv.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/i386/i386-protos.h (function_arg_pass_by_reference): Remove.\n\t* config/i386/i386.c (TARGET_PASS_BY_REFERENCE): New.\n\t(ix86_pass_by_reference): Rename from function_arg_pass_by_reference.\n\t* config/i386/i386.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/ia64/ia64-protos.h (ia64_function_arg_pass_by_reference): Kill.\n\t* config/ia64/ia64.c (TARGET_PASS_BY_REFERENCE): New.\n\t(ia64_pass_by_reference): Rename from\n\tia64_function_arg_pass_by_reference.\n\t* config/ia64/ia64.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/ip2k/ip2k.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/iq2000/iq2000-protos.h (function_arg_pass_by_reference): Kill.\n\t* config/iq2000/iq2000.c (TARGET_PASS_BY_REFERENCE): New.\n\t(iq2000_pass_by_reference): Rename from function_arg_pass_by_reference.\n\t* config/iq2000/iq2000.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t(FUNCTION_ARG_CALLEE_COPIES): Don't reference pass-by-ref.\n\t* config/m32r/m32r-protos.h (m32r_pass_by_reference): Remove.\n\t* config/m32r/m32r.c (TARGET_PASS_BY_REFERENCE): New.\n\t(m32r_pass_by_reference): Adjust prototype.  Make static.\n\tHandle mode sizes correctly.\n\t* config/m32r/m32r.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/m68hc11/m68hc11-protos.h, config/m68hc11/m68hc11.c\n\t(m68hc11_function_arg_pass_by_reference): Remove.\n\t* config/m68hc11/m68hc11.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t(FUNCTION_ARG_CALLEE_COPIES): Don't reference pass-by-ref.\n\t* config/mcore/mcore.c (TARGET_PASS_BY_REFERENCE): New.\n\t* config/mcore/mcore.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/mips/mips-protos.h (function_arg_pass_by_reference): Remove.\n\t* config/mips/mips.c (TARGET_PASS_BY_REFERENCE): New.\n\t(mips_va_arg): Use pass_by_reference.\n\t(mips_pass_by_reference): Rename from function_arg_pass_by_reference.\n\tHandle mode sizes correctly.\n\t* config/mips/mips.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n        (FUNCTION_ARG_CALLEE_COPIES): Don't reference pass-by-ref.\n\t* config/mmix/mmix-protos.h (mmix_function_arg_pass_by_reference): Kill.\n\t* config/mmix/mmix.c (TARGET_PASS_BY_REFERENCE): New.\n\t(mmix_pass_by_reference): Rename from\n\tmmix_function_arg_pass_by_reference.\n\t* config/mmix/mmix.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t(FUNCTION_ARG_CALLEE_COPIES): True.\n\t* config/mn10300/mn10300.c (TARGET_PASS_BY_REFERENCE): New.\n\t(mn10300_pass_by_reference): New.\n\t* config/mn10300/mn10300.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t(FUNCTION_ARG_CALLEE_COPIES): True.\n\t* config/pa/pa.c (pa_pass_by_reference): New.\n\t(TARGET_PASS_BY_REFERENCE): New.\n\t* config/pa/pa.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n        (FUNCTION_ARG_CALLEE_COPIES): True.\n\t* config/rs6000/rs6000-protos.h (function_arg_pass_by_reference): Kill.\n\t* config/rs6000/rs6000.c (TARGET_PASS_BY_REFERENCE): New.\n\t(rs6000_pass_by_reference): Rename from function_arg_pass_by_reference.\n\t* config/rs6000/rs6000.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/s390/s390-protos.h (s390_function_arg_pass_by_reference): Kill.\n\t* config/s390/s390.c (TARGET_PASS_BY_REFERENCE): New.\n\t(s390_pass_by_reference): Rename from\n\ts390_function_arg_pass_by_reference.\n\t(s390_function_arg_advance): Don't query pass-by-ref.\n\t(s390_function_arg): Likewise.\n\t(s390_gimplify_va_arg): Use pass_by_reference.\n\t(s390_call_saved_register_used): Likewise.\n\t* config/s390/s390.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/sh/sh.c (TARGET_PASS_BY_REFERENCE): New.\n\t(shcompact_byref, sh_pass_by_reference): New.\n\t* config/sh/sh.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t(SHCOMPACT_BYREF): Remove.\n\t* config/sparc/sparc-protos.h (function_arg_pass_by_reference): Kill.\n\t* config/sparc/sparc.c (TARGET_PASS_BY_REFERENCE): New.\n\t(sparc_pass_by_reference): Rename from function_arg_pass_by_reference.\n\t(sparc_gimplify_va_arg): Use pass_by_reference.\n\t* config/sparc/sparc.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/stormy16/stormy16.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t* config/v850/v850.c (TARGET_PASS_BY_REFERENCE): New.\n\t(v850_pass_by_reference): New.\n\t* config/v850/v850.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n\t(FUNCTION_ARG_CALLEE_COPIES): True.\n\t* doc/tm.texi (TARGET_PASS_BY_REFERENCE): Update from\n\tFUNCTION_ARG_PASS_BY_REFERENCE docs.\n\nFrom-SVN: r84672", "tree": {"sha": "0831bbea139cb77f60030d22ed84f1ab3e43068a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0831bbea139cb77f60030d22ed84f1ab3e43068a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/comments", "author": null, "committer": null, "parents": [{"sha": "0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd"}], "stats": {"total": 828, "additions": 463, "deletions": 365}, "files": [{"sha": "cdf3aaec381b68570f458eb5d2bf0b688234227d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1,3 +1,112 @@\n+2004-07-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* target.h (struct gcc_target): Add calls.pass_by_reference.\n+\t* target-def.h (TARGET_PASS_BY_REFERENCE): New.\n+\t* function.c (pass_by_reference): Use the hook.\n+\t* system.h (FUNCTION_ARG_PASS_BY_REFERENCE): Poison.\n+\t* targhooks.c, targhooks.h (hook_pass_by_reference_false): New.\n+\t(hook_pass_by_reference_must_pass_in_stack): New.\n+\t* config/alpha/alpha.c (function_arg): Don't query pass-by-ref.\n+\t(alpha_pass_by_reference): New.\n+\t(TARGET_PASS_BY_REFERENCE): New.\n+\t* config/alpha/alpha.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/arc/arc.c (arc_pass_by_reference): New.\n+\t(TARGET_PASS_BY_REFERENCE): New.\n+\t* config/arc/arc.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t(FUNCTION_ARG_CALLEE_COPIES): True.\n+\t* config/arm/arm-protos.h (arm_function_arg_pass_by_reference): Remove.\n+\t* config/arm/arm.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(arm_pass_by_reference): Rename from arm_function_arg_pass_by_reference.\n+\t* config/arm/arm.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/c4x/c4x.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/cris/cris.c (cris_pass_by_reference): New.\n+\t(TARGET_PASS_BY_REFERENCE): New.\n+\t* config/cris/cris.h (FUNCTION_ARG): Don't query pass-by-ref.\n+\t(FUNCTION_INCOMING_ARG, FUNCTION_ARG_ADVANCE): Likewise.\n+\t(FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/fr30/fr30.c (TARGET_PASS_BY_REFERENCE): New.\n+\t* config/fr30/fr30.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/frv/frv-protos.h (frv_function_arg_pass_by_reference): Kill.\n+\t* config/frv/frv.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(frv_function_arg_pass_by_reference): Remove.\n+\t* config/frv/frv.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/i386/i386-protos.h (function_arg_pass_by_reference): Remove.\n+\t* config/i386/i386.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(ix86_pass_by_reference): Rename from function_arg_pass_by_reference.\n+\t* config/i386/i386.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/ia64/ia64-protos.h (ia64_function_arg_pass_by_reference): Kill.\n+\t* config/ia64/ia64.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(ia64_pass_by_reference): Rename from\n+\tia64_function_arg_pass_by_reference.\n+\t* config/ia64/ia64.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/ip2k/ip2k.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/iq2000/iq2000-protos.h (function_arg_pass_by_reference): Kill.\n+\t* config/iq2000/iq2000.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(iq2000_pass_by_reference): Rename from function_arg_pass_by_reference.\n+\t* config/iq2000/iq2000.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t(FUNCTION_ARG_CALLEE_COPIES): Don't reference pass-by-ref.\n+\t* config/m32r/m32r-protos.h (m32r_pass_by_reference): Remove.\n+\t* config/m32r/m32r.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(m32r_pass_by_reference): Adjust prototype.  Make static.\n+\tHandle mode sizes correctly.\n+\t* config/m32r/m32r.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/m68hc11/m68hc11-protos.h, config/m68hc11/m68hc11.c\n+\t(m68hc11_function_arg_pass_by_reference): Remove.\n+\t* config/m68hc11/m68hc11.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t(FUNCTION_ARG_CALLEE_COPIES): Don't reference pass-by-ref.\n+\t* config/mcore/mcore.c (TARGET_PASS_BY_REFERENCE): New.\n+\t* config/mcore/mcore.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/mips/mips-protos.h (function_arg_pass_by_reference): Remove.\n+\t* config/mips/mips.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(mips_va_arg): Use pass_by_reference.\n+\t(mips_pass_by_reference): Rename from function_arg_pass_by_reference.\n+\tHandle mode sizes correctly.\n+\t* config/mips/mips.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+        (FUNCTION_ARG_CALLEE_COPIES): Don't reference pass-by-ref.\n+\t* config/mmix/mmix-protos.h (mmix_function_arg_pass_by_reference): Kill.\n+\t* config/mmix/mmix.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(mmix_pass_by_reference): Rename from\n+\tmmix_function_arg_pass_by_reference.\n+\t* config/mmix/mmix.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t(FUNCTION_ARG_CALLEE_COPIES): True.\n+\t* config/mn10300/mn10300.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(mn10300_pass_by_reference): New.\n+\t* config/mn10300/mn10300.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t(FUNCTION_ARG_CALLEE_COPIES): True.\n+\t* config/pa/pa.c (pa_pass_by_reference): New.\n+\t(TARGET_PASS_BY_REFERENCE): New.\n+\t* config/pa/pa.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+        (FUNCTION_ARG_CALLEE_COPIES): True.\n+\t* config/rs6000/rs6000-protos.h (function_arg_pass_by_reference): Kill.\n+\t* config/rs6000/rs6000.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(rs6000_pass_by_reference): Rename from function_arg_pass_by_reference.\n+\t* config/rs6000/rs6000.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/s390/s390-protos.h (s390_function_arg_pass_by_reference): Kill.\n+\t* config/s390/s390.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(s390_pass_by_reference): Rename from\n+\ts390_function_arg_pass_by_reference.\n+\t(s390_function_arg_advance): Don't query pass-by-ref.\n+\t(s390_function_arg): Likewise.\n+\t(s390_gimplify_va_arg): Use pass_by_reference.\n+\t(s390_call_saved_register_used): Likewise.\n+\t* config/s390/s390.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/sh/sh.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(shcompact_byref, sh_pass_by_reference): New.\n+\t* config/sh/sh.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t(SHCOMPACT_BYREF): Remove.\n+\t* config/sparc/sparc-protos.h (function_arg_pass_by_reference): Kill.\n+\t* config/sparc/sparc.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(sparc_pass_by_reference): Rename from function_arg_pass_by_reference.\n+\t(sparc_gimplify_va_arg): Use pass_by_reference.\n+\t* config/sparc/sparc.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/stormy16/stormy16.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t* config/v850/v850.c (TARGET_PASS_BY_REFERENCE): New.\n+\t(v850_pass_by_reference): New.\n+\t* config/v850/v850.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove.\n+\t(FUNCTION_ARG_CALLEE_COPIES): True.\n+\t* doc/tm.texi (TARGET_PASS_BY_REFERENCE): Update from\n+\tFUNCTION_ARG_PASS_BY_REFERENCE docs.\n+\n 2004-07-14  Richard Henderson  <rth@redhat.com>\n \t    Richard Sandiford  <rsandifo@redhat.com>\n "}, {"sha": "8ed7b78d72cd8586fb7a29b9045bbd3d5ee8a4e5", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -5922,8 +5922,6 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n \tbasereg = 16;\n       else if (targetm.calls.must_pass_in_stack (mode, type))\n \treturn NULL_RTX;\n-      else if (FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named))\n-\tbasereg = 16;\n     }\n #else\n #error Unhandled ABI\n@@ -5979,6 +5977,17 @@ alpha_return_in_memory (tree type, tree fndecl ATTRIBUTE_UNUSED)\n   return size > UNITS_PER_WORD;\n }\n \n+/* Return true if TYPE should be passed by invisible reference.  */\n+\n+static bool\n+alpha_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode,\n+\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t bool named ATTRIBUTE_UNUSED)\n+{\n+  return mode == TFmode || mode == TCmode;\n+}\n+\n /* Define how to find the value returned by a function.  VALTYPE is the\n    data type of the value (as a tree).  If the precise function being\n    called is known, FUNC is its FUNCTION_DECL; otherwise, FUNC is 0.\n@@ -10187,6 +10196,8 @@ alpha_init_libfuncs (void)\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_false\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY alpha_return_in_memory\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE alpha_pass_by_reference\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS alpha_setup_incoming_varargs\n #undef TARGET_STRICT_ARGUMENT_NAMING"}, {"sha": "b77a9bce2901ae1b9d472ac892cc1b1b429fe8c0", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1063,15 +1063,6 @@ extern int alpha_memory_latency;\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n   function_arg((CUM), (MODE), (TYPE), (NAMED))\n \n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of\n-   the argument itself.  The pointer is passed in whatever way is\n-   appropriate for passing a pointer to that type.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  ((MODE) == TFmode || (MODE) == TCmode)\n-\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */"}, {"sha": "cbc0efaca6922e991b3148c185e554adc0783354", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -102,6 +102,8 @@ static bool arc_rtx_costs (rtx, int, int, int *);\n static int arc_address_cost (rtx);\n static void arc_external_libcall (rtx);\n static bool arc_return_in_memory (tree, tree);\n+static bool arc_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t   tree, bool);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -138,6 +140,8 @@ static bool arc_return_in_memory (tree, tree);\n \n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY arc_return_in_memory\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE arc_pass_by_reference\n \n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS arc_setup_incoming_varargs\n@@ -2333,3 +2337,26 @@ arc_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n       return (size == -1 || size > 8);\n     }\n }\n+\n+/* For ARC, All aggregates and arguments greater than 8 bytes are\n+   passed by reference.  */\n+\n+static bool\n+arc_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t       enum machine_mode mode, tree type,\n+\t\t       bool named ATTRIBUTE_UNUSED)\n+{\n+  unsigned HOST_WIDE_INT size;\n+\n+  if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type))\n+\treturn true;\n+      size = int_size_in_bytes (type);\n+    }\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  return size > 8;\n+}\n+"}, {"sha": "d615364069d4fc9b5a91500924b39f01e35a58d1", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -696,26 +696,14 @@ extern enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    registers.  */\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of\n-   the argument itself.  The pointer is passed in whatever way is\n-   appropriate for passing a pointer to that type.  */\n-/* All aggregates and arguments greater than 8 bytes are passed this way.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-(TYPE\t\t\t\t\t\\\n- && (AGGREGATE_TYPE_P (TYPE)\t\t\\\n-     || int_size_in_bytes (TYPE) > 8))\n-\n /* A C expression that indicates when it is the called function's\n    responsibility to make copies of arguments passed by reference.\n    If the callee can determine that the argument won't be modified, it can\n    avoid the copy.  */\n /* ??? We'd love to be able to use NAMED here.  Unfortunately, it doesn't\n    include the last named argument so we keep track of the args ourselves.  */\n \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n-FUNCTION_ARG_PASS_BY_REFERENCE ((CUM), (MODE), (TYPE), (NAMED))\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE."}, {"sha": "ce3ff6aff69d3764f73bac0e137ae146e248e7a7", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -156,8 +156,6 @@ extern const char *vfp_output_fstmx (rtx *);\n extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern rtx arm_va_arg (tree, tree);\n-extern int arm_function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n-\t\t\t\t\t       enum machine_mode, tree, int);\n extern bool arm_needs_doubleword_align (enum machine_mode, tree);\n extern rtx arm_function_value(tree, tree);\n #endif"}, {"sha": "a94b82bbec53338af10ac62e772279f764c71c76", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -157,6 +157,8 @@ static void aof_file_end (void);\n static rtx arm_struct_value_rtx (tree, int);\n static void arm_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\ttree, int *, int);\n+static bool arm_pass_by_reference (CUMULATIVE_ARGS *,\n+\t\t\t\t   enum machine_mode, tree, bool);\n static bool arm_promote_prototypes (tree);\n static bool arm_default_short_enums (void);\n static bool arm_align_anon_bitfield (void);\n@@ -255,6 +257,8 @@ static bool arm_cookie_has_size (void);\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_true\n #undef TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES arm_promote_prototypes\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE arm_pass_by_reference\n \n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX arm_struct_value_rtx\n@@ -2396,10 +2400,10 @@ arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n /* Variable sized types are passed by reference.  This is a GCC\n    extension to the ARM ABI.  */\n \n-int\n-arm_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-\t\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n+static bool\n+arm_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       tree type, bool named ATTRIBUTE_UNUSED)\n {\n   return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n }"}, {"sha": "ad006c555b00bf8f98b9cc3f2a3226a5480b3cb3", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1700,14 +1700,6 @@ typedef struct\n    && (CUM).can_split)\t\t\t\t\t\t\\\n    ?   NUM_ARG_REGS - (CUM).nregs : 0)\n \n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of\n-   the argument itself.  The pointer is passed in whatever way is\n-   appropriate for passing a pointer to that type.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  arm_function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0."}, {"sha": "ff2e634b14fab2c315fa4f9506868048354fed00", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1130,10 +1130,6 @@ CUMULATIVE_ARGS;\n \n #define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n \n-/* Never pass data by reference.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) 0\n-\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n /* 1 if N is a possible register number for function argument passing.  */"}, {"sha": "50f5e59bf78adcb06591270ffb870dffb9beb419", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -115,6 +115,8 @@ static void cris_init_libfuncs (void);\n \n static bool cris_rtx_costs (rtx, int, int, int *);\n static int cris_address_cost (rtx);\n+static bool cris_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t    tree, bool);\n \n /* The function cris_target_asm_function_epilogue puts the last insn to\n    output here.  It always fits; there won't be a symbol operand.  Used in\n@@ -183,12 +185,12 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n \n #undef TARGET_PROMOTE_FUNCTION_ARGS\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_true\n-\n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX cris_struct_value_rtx\n-\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS cris_setup_incoming_varargs\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE cris_pass_by_reference\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -3160,6 +3162,19 @@ cris_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n     }\n }\n \n+/* Return true if TYPE must be passed by invisible reference.\n+   For cris, we pass <= 8 bytes by value, others by reference.  */\n+\n+static bool\n+cris_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode, tree type,\n+\t\t\tbool named ATTRIBUTE_UNUSED)\n+{\n+  return (targetm.calls.must_pass_in_stack (mode, type)\n+\t  || CRIS_FUNCTION_ARG_SIZE (mode, type) > 8);\n+}\n+\n+\n #if 0\n /* Various small functions to replace macros.  Only called from a\n    debugger.  They might collide with gcc functions or system functions,"}, {"sha": "a308412e7acb5fb74aff9a8fb651e195a439c7e3", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -68,7 +68,6 @@ Boston, MA 02111-1307, USA.  */\n #define CRIS_PLT_GOTOFFSET_SUFFIX \":PLTG\"\n #define CRIS_PLT_PCOFFSET_SUFFIX \":PLT\"\n \n-/* If you tweak this, don't forget to check cris_expand_builtin_va_arg.  */\n #define CRIS_FUNCTION_ARG_SIZE(MODE, TYPE)\t\\\n   ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)\t\\\n    : (unsigned) int_size_in_bytes (TYPE))\n@@ -939,23 +938,18 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n \n /* Node: Register Arguments */\n \n-/* The void_type_node is sent as a \"closing\" call.  We have to stop it\n-   since it's invalid to FUNCTION_ARG_PASS_BY_REFERENCE (or was invalid at\n-   some time).  */\n+/* The void_type_node is sent as a \"closing\" call.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n  ((CUM).regs < CRIS_MAX_ARGS_IN_REGS\t\t\t\t\\\n-  && (TYPE) != void_type_node\t\t\t\t\t\\\n-  && ! FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED)\t\\\n   ? gen_rtx_REG (MODE, (CRIS_FIRST_ARG_REG) + (CUM).regs)\t\\\n   : NULL_RTX)\n \n /* The differences between this and the previous, is that this one checks\n    that an argument is named, since incoming stdarg/varargs arguments are\n    pushed onto the stack, and we don't have to check against the \"closing\"\n    void_type_node TYPE parameter.  */\n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n- (((NAMED) && (CUM).regs < CRIS_MAX_ARGS_IN_REGS\t\t\t\\\n-   && ! FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\t\\\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\\\n+ ((NAMED) && (CUM).regs < CRIS_MAX_ARGS_IN_REGS\t\t\t\\\n   ? gen_rtx_REG (MODE, CRIS_FIRST_ARG_REG + (CUM).regs)\t\t\\\n   : NULL_RTX)\n \n@@ -966,13 +960,6 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n    && CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) <= 8)\t\t\t\\\n   ? 1 : 0)\n \n-/* Structs may be passed by value, but they must not be more than 8\n-   bytes long.  If you tweak this, don't forget to adjust\n-   cris_expand_builtin_va_arg.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n- (targetm.calls.must_pass_in_stack (MODE, TYPE)\t\t\t\t\\\n-  || CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) > 8)\t\t\t\t\\\n-\n /* Contrary to what you'd believe, defining FUNCTION_ARG_CALLEE_COPIES\n    seems like a (small total) loss, at least for gcc-2.7.2 compiling and\n    running gcc-2.1 (small win in size, small loss running -- 100.1%),\n@@ -991,11 +978,7 @@ struct cum_args {int regs;};\n  ((CUM).regs = 0)\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n- ((CUM).regs\t\t\t\t\t\t\t\\\n-  = (FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n-     ? (CRIS_MAX_ARGS_IN_REGS) + 1\t\t\t\t\\\n-     : ((CUM).regs\t\t\t\t\t\t\\\n-\t+ (3 + (CRIS_FUNCTION_ARG_SIZE (MODE, TYPE))) / 4)))\n+ ((CUM).regs += (3 + CRIS_FUNCTION_ARG_SIZE (MODE, TYPE)) / 4)\n \n #define FUNCTION_ARG_REGNO_P(REGNO)\t\t\t\\\n  ((REGNO) >= CRIS_FIRST_ARG_REG\t\t\t\t\\"}, {"sha": "55d1154bc4c4c5e32d461ed6c6fc9f5f4b0ab54c", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -152,6 +152,9 @@ static bool fr30_must_pass_in_stack (enum machine_mode, tree);\n \n #undef  TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE hook_pass_by_reference_must_pass_in_stack\n+\n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS fr30_setup_incoming_varargs\n #undef  TARGET_MUST_PASS_IN_STACK"}, {"sha": "201690a424225513da6642204b17737fc7b806cd", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -694,9 +694,6 @@ enum reg_class\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\\\n   fr30_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  targetm.calls.must_pass_in_stack (MODE, TYPE)\n-\n /* A C statement (sans semicolon) for initializing the variable CUM for the\n    state at the beginning of the argument list.  The variable has type\n    `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node for the data type"}, {"sha": "a63669b36cc85885fec985a4f2db0dd26cb2414b", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -84,10 +84,6 @@ extern int frv_function_arg_partial_nregs\t(CUMULATIVE_ARGS *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, int);\n \n-extern int frv_function_arg_pass_by_reference\t(CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t tree, int);\n-\n extern int frv_function_arg_callee_copies\t(CUMULATIVE_ARGS *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, int);"}, {"sha": "5e4a12f5c4a3aa5967aeb9aa60f7c6ef450dd02e", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -48,6 +48,7 @@ Boston, MA 02111-1307, USA.  */\n #include <ctype.h>\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"targhooks.h\"\n #include \"integrate.h\"\n \n #ifndef FRV_INLINE\n@@ -329,6 +330,8 @@ static bool frv_must_pass_in_stack (enum machine_mode mode, tree type);\n #define TARGET_STRUCT_VALUE_RTX frv_struct_value_rtx\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK frv_must_pass_in_stack\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE hook_pass_by_reference_must_pass_in_stack\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS frv_expand_builtin_saveregs\n@@ -3147,15 +3150,6 @@ frv_function_arg_partial_nregs (CUMULATIVE_ARGS *cum,\n }\n \n \f\n-int\n-frv_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-                                    enum machine_mode mode,\n-                                    tree type,\n-                                    int named ATTRIBUTE_UNUSED)\n-{\n-  return targetm.calls.must_pass_in_stack (mode, type);\n-}\n-\n /* If defined, a C expression that indicates when it is the called function's\n    responsibility to make a copy of arguments passed by invisible reference.\n    Normally, the caller makes a copy and passes the address of the copy to the"}, {"sha": "838ca176114a6a1f7ae5b6fee6eab7e6aef40680", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1901,9 +1901,6 @@ struct machine_function GTY(())\n \n /* extern int frv_function_arg_partial_nregs (CUMULATIVE_ARGS, int, Tree, int);  */\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  frv_function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n-\n /* If defined, a C expression that indicates when it is the called function's\n    responsibility to make a copy of arguments passed by invisible reference.\n    Normally, the caller makes a copy and passes the address of the copy to the"}, {"sha": "aae3c7acb0f0e8e826a3071cb63574695d5949d5", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -190,8 +190,6 @@ extern enum rtx_code ix86_reverse_condition (enum rtx_code, enum machine_mode);\n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n-extern int function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n-\t\t\t\t\t   enum machine_mode, tree, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int);\n extern rtx ix86_function_value (tree);"}, {"sha": "0349979fb141bdee1002838aac5bec4eb3121df7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -929,6 +929,8 @@ static bool ix86_rtx_costs (rtx, int, int, int *);\n static int min_insn_size (rtx);\n static tree ix86_md_asm_clobbers (tree clobbers);\n static bool ix86_must_pass_in_stack (enum machine_mode mode, tree type);\n+static bool ix86_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t    tree, bool);\n \n #if defined (DO_GLOBAL_CTORS_BODY) && defined (HAS_INIT_SECTION)\n static void ix86_svr3_asm_out_constructor (rtx, int);\n@@ -1074,6 +1076,8 @@ static void init_ext_80387_constants (void);\n #define TARGET_SETUP_INCOMING_VARARGS ix86_setup_incoming_varargs\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK ix86_must_pass_in_stack\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE ix86_pass_by_reference\n \n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg\n@@ -2775,10 +2779,10 @@ function_arg (CUMULATIVE_ARGS *cum,\t/* current arg information */\n    the argument itself.  The pointer is passed in whatever way is\n    appropriate for passing a pointer to that type.  */\n \n-int\n-function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-\t\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t\ttree type, int named ATTRIBUTE_UNUSED)\n+static bool\n+ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n   if (!TARGET_64BIT)\n     return 0;"}, {"sha": "c85c8892893ee1991653cdb1a35b60363a0e856f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1765,15 +1765,6 @@ typedef struct ix86_args {\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of\n-   the argument itself.  The pointer is passed in whatever way is\n-   appropriate for passing a pointer to that type.  */\n- \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_pass_by_reference(&CUM, MODE, TYPE, NAMED)\n- \n /* Implement `va_start' for varargs and stdarg.  */\n #define EXPAND_BUILTIN_VA_START(VALIST, NEXTARG) \\\n   ix86_va_start (VALIST, NEXTARG)"}, {"sha": "e59dff5afbe345df0449c8dd32fdaf1cc4608abd", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -118,8 +118,6 @@ extern int ia64_function_arg_partial_nregs (CUMULATIVE_ARGS *,\n \t\t\t\t\t    enum machine_mode, tree, int);\n extern void ia64_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       tree, int);\n-extern int ia64_function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n-\t\t\t\t\t\tenum machine_mode, tree, int);\n extern void ia64_asm_output_external (FILE *, tree, const char *);\n #endif /* TREE_CODE */\n "}, {"sha": "7e19f6ba043acfad960c30dd6a56f84b7c50a8ee", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -189,6 +189,8 @@ static rtx gen_fr_restore_x (rtx, rtx, rtx);\n static enum machine_mode hfa_element_mode (tree, int);\n static void ia64_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n+static bool ia64_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t    tree, bool);\n static bool ia64_function_ok_for_sibcall (tree, tree);\n static bool ia64_return_in_memory (tree, tree);\n static bool ia64_rtx_costs (rtx, int, int, int *);\n@@ -360,6 +362,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ia64_function_ok_for_sibcall\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE ia64_pass_by_reference\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK ia64_output_mi_thunk\n@@ -3940,10 +3944,10 @@ ia64_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Variable sized types are passed by reference.  */\n /* ??? At present this is a GCC extension to the IA-64 ABI.  */\n \n-int\n-ia64_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-\t\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t\t     tree type, int named ATTRIBUTE_UNUSED)\n+static bool\n+ia64_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n   return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n }"}, {"sha": "28fe2d54c9f68da310165828ce5db07e62269e54", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1319,15 +1319,6 @@ enum reg_class\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n  ia64_function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n \n-/* A C expression that indicates when an argument must be passed by reference.\n-   If nonzero for an argument, a copy of that argument is made in memory and a\n-   pointer to the argument is passed instead of the argument itself.  The\n-   pointer is passed in whatever way is appropriate for passing a pointer to\n-   that type.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  ia64_function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n-\n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the type\n    `int' suffices and can hold the number of bytes of argument so far.  */"}, {"sha": "aecc8cdf56b59966937a2461f34f9455f3d76df2", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -455,9 +455,6 @@ enum reg_class {\n \n #define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_RESULT)\n \n-/* Indicate that large structures are passed by reference.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED)\t0\n-\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n #define EPILOGUE_USES(REGNO) 0"}, {"sha": "c0eae3b01f1f5040a11a3e820f74ef529bda01bd", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -35,7 +35,6 @@ extern void             iq2000_expand_prologue (void);\n extern void             iq2000_expand_epilogue (void);\n extern void             iq2000_expand_eh_return (rtx);\n extern int              iq2000_can_use_return_insn (void);\n-extern int              function_arg_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern int              iq2000_adjust_insn_length (rtx, int);\n extern char *           iq2000_output_conditional_branch (rtx, rtx *, int, int, int, int);\n extern void             print_operand_address (FILE *, rtx);"}, {"sha": "0e2f7c146f6360632afed4c3acff28db7f074fb7", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -171,6 +171,8 @@ static bool iq2000_rtx_costs          (rtx, int, int, int *);\n static int  iq2000_address_cost       (rtx);\n static void iq2000_select_section     (tree, int, unsigned HOST_WIDE_INT);\n static bool iq2000_return_in_memory   (tree, tree);\n+static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t       tree, bool);\n \n #undef  TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS \t\tiq2000_init_builtins\n@@ -194,6 +196,8 @@ static bool iq2000_return_in_memory   (tree, tree);\n \n #undef  TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY\t\tiq2000_return_in_memory\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE\tiq2000_pass_by_reference\n \n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS\tiq2000_setup_incoming_varargs\n@@ -2471,13 +2475,11 @@ iq2000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   return gen_rtx_REG (mode, reg);\n }\n \f\n-/* The implementation of FUNCTION_ARG_PASS_BY_REFERENCE.  Return\n-   nonzero when an argument must be passed by reference.  */\n+/* Return true when an argument must be passed by reference.  */\n \n-int\n-function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-\t\t\t\tenum machine_mode mode, tree type,\n-\t\t\t\tint named ATTRIBUTE_UNUSED)\n+static bool\n+iq2000_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t  tree type, bool named ATTRIBUTE_UNUSED)\n {\n   int size;\n "}, {"sha": "f6f381089e29672d11e5bba5ed6bf27bd6ee2d63", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -441,11 +441,7 @@ enum reg_class\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   function_arg_partial_nregs (& CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  function_arg_pass_by_reference (& CUM, MODE, TYPE, NAMED)\n-\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n-  ((NAMED) && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) (NAMED)\n \n #define MAX_ARGS_IN_REGISTERS 8\n "}, {"sha": "f01203334e78474e3753c9b70d8b24dc09a29606", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -94,9 +94,6 @@ extern int    reg_or_zero_operand (rtx, Mmode);\n \n #endif /* HAVE_MACHINE_MODES */\n \n-#ifdef TREE_CODE\n-extern int m32r_pass_by_reference (tree);\n-#endif /* TREE_CODE */\n #endif /* RTX_CODE */\n \n #undef  Mmode"}, {"sha": "c46bff52ae490dcf20e0da2dd2a0f26dd2f15083", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -99,6 +99,8 @@ static void m32r_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static void init_idents (void);\n static bool m32r_rtx_costs (rtx, int, int, int *);\n+static bool m32r_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t    tree, bool);\n \f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ATTRIBUTE_TABLE\n@@ -142,6 +144,8 @@ static bool m32r_rtx_costs (rtx, int, int, int *);\n #define TARGET_SETUP_INCOMING_VARARGS m32r_setup_incoming_varargs\n #undef  TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE m32r_pass_by_reference\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -969,19 +973,21 @@ large_insn_p (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return get_attr_length (op) != 2;\n }\n \n-/* Return nonzero if TYPE must be passed or returned in memory.\n-   The m32r treats both directions the same so we handle both directions\n-   in this function.  */\n+/* Return nonzero if TYPE must be passed by indirect reference.  */\n \n-int\n-m32r_pass_by_reference (tree type)\n+static bool\n+m32r_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode, tree type,\n+\t\t\tbool named ATTRIBUTE_UNUSED)\n {\n-  int size = int_size_in_bytes (type);\n+  int size;\n \n-  if (size < 0 || size > 8)\n-    return 1;\n+  if (type)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n \n-  return 0;\n+  return (size < 0 || size > 8);\n }\n \f\n /* Comparisons.  */\n@@ -1347,7 +1353,7 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n static bool\n m32r_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n {\n-  return m32r_pass_by_reference (type);\n+  return m32r_pass_by_reference (NULL, TYPE_MODE (type), type, false);\n }\n \n /* Do any needed setup for a variadic function.  For the M32R, we must"}, {"sha": "2f38e0a725d9d63543d6ed3c59f3fe42c8ae19cd", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1110,15 +1110,6 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   function_arg_partial_nregs (&CUM, (int)MODE, TYPE, NAMED)\n \n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of\n-   the argument itself.  The pointer is passed in whatever way is\n-   appropriate for passing a pointer to that type.  */\n-/* All arguments greater than 8 bytes are passed this way.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  ((TYPE) && m32r_pass_by_reference (TYPE))\n-\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */"}, {"sha": "af8c35b8a1c099e090841ca943d1fbbb908a5ccc", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -123,10 +123,6 @@ extern void m68hc11_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx);\n extern rtx m68hc11_function_arg (const CUMULATIVE_ARGS* ,\n                                  enum machine_mode,\n                                  tree, int);\n-extern int m68hc11_function_arg_pass_by_reference (const CUMULATIVE_ARGS*,\n-                                                   enum machine_mode,\n-                                                   tree,\n-                                                   int);\n extern int m68hc11_function_arg_padding (enum machine_mode, tree);\n \n extern void m68hc11_function_epilogue (FILE*,int);"}, {"sha": "ba58e8b9a10321eabc0cdc794f38c71e6a5225d3", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1472,24 +1472,6 @@ m68hc11_is_trap_symbol (rtx sym)\n \n /* Argument support functions.  */\n \n-/* Handle the FUNCTION_ARG_PASS_BY_REFERENCE macro.\n-   Arrays are passed by references and other types by value.\n-\n-   SCz: I tried to pass DImode by reference but it seems that this\n-   does not work very well.  */\n-int\n-m68hc11_function_arg_pass_by_reference (const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-                                        enum machine_mode mode ATTRIBUTE_UNUSED,\n-                                        tree type,\n-                                        int named ATTRIBUTE_UNUSED)\n-{\n-  return ((type && TREE_CODE (type) == ARRAY_TYPE)\n-\t  /* Consider complex values as aggregates, so care for TCmode.  */\n-\t  /*|| GET_MODE_SIZE (mode) > 4 SCz, temporary */\n-\t  /*|| (type && AGGREGATE_TYPE_P (type))) */ );\n-}\n-\n-\n /* Define the offset between two registers, one to be eliminated, and the\n    other its replacement, at the start of a routine.  */\n int"}, {"sha": "9732219c298204a7b0aa89976c08f91b4e9faa31", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1036,17 +1036,6 @@ typedef struct m68hc11_args\n   int nregs;\n } CUMULATIVE_ARGS;\n \n-/* A C expression that indicates when an argument must be passed by reference.\n-   If nonzero for an argument, a copy of that argument is made in memory and a\n-   pointer to the argument is passed instead of the argument itself.\n-   The pointer is passed in whatever way is appropriate for passing a pointer\n-   to that type.\n- \n-   64-bit numbers are passed by reference.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-    m68hc11_function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))\n-\n-\n /* If defined, a C expression which determines whether, and in which direction,\n    to pad out an argument with extra space.  The value should be of type\n    `enum direction': either `upward' to pad above the argument,\n@@ -1069,8 +1058,7 @@ typedef struct m68hc11_args\n    value.  The called function must not modify this value.  If it can\n    be determined that the value won't be modified, it need not make a\n    copy; otherwise a copy must be made.  */\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n-    ((NAMED) && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) (NAMED)\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n    function whose data type is FNTYPE. For a library call, FNTYPE is 0.  */"}, {"sha": "c41ce8f41d5beae8790371a5d4c79e42e1df90e4", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -194,6 +194,8 @@ static bool       mcore_return_in_memory\t(tree, tree);\n #define TARGET_RETURN_IN_MEMORY\t\tmcore_return_in_memory\n #undef  TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK\tmust_pass_in_stack_var_size\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE  hook_pass_by_reference_must_pass_in_stack\n \n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS\tmcore_setup_incoming_varargs"}, {"sha": "b800a9326590ef4828e7028cea0e6b27155d032f", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -712,14 +712,6 @@ extern const enum reg_class reg_class_from_letter[];\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   mcore_function_arg (CUM, MODE, TYPE, NAMED)\n \n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of\n-   the argument itself.  The pointer is passed in whatever way is\n-   appropriate for passing a pointer to that type.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  targetm.calls.must_pass_in_stack (MODE, TYPE)\n-\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero."}, {"sha": "820d75f9cc0f42407f4ab048980fddf1f394e2b7", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -181,8 +181,6 @@ extern void mips_expand_prologue (void);\n extern void mips_expand_epilogue (int);\n extern int mips_can_use_return_insn (void);\n extern struct rtx_def *mips_function_value (tree, tree, enum machine_mode);\n-extern int function_arg_pass_by_reference (const CUMULATIVE_ARGS *,\n-\t\t\t\t\t   enum machine_mode, tree, int);\n \n extern bool mips_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);"}, {"sha": "02231f39171d6237d420f955235c6a55eb324549", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -290,6 +290,8 @@ static void mips_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static tree mips_build_builtin_va_list (void);\n static tree mips_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n+static bool mips_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode mode,\n+\t\t\t\t    tree, bool);\n \n #if TARGET_IRIX\n static void irix_asm_named_section_1 (const char *, unsigned int,\n@@ -744,6 +746,8 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #define TARGET_STRICT_ARGUMENT_NAMING mips_strict_argument_naming\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE mips_pass_by_reference\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -4045,8 +4049,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n   tree addr;\n   bool indirect;\n \n-  indirect\n-    = function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n+  indirect = pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n \n   if (indirect)\n     type = build_pointer_type (type);\n@@ -7321,13 +7324,12 @@ mips_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n   return gen_rtx_REG (mode, GP_RETURN);\n }\n \n-/* The implementation of FUNCTION_ARG_PASS_BY_REFERENCE.  Return\n-   nonzero when an argument must be passed by reference.  */\n+/* Return nonzero when an argument must be passed by reference.  */\n \n-int\n-function_arg_pass_by_reference (const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-\t\t\t\tenum machine_mode mode, tree type,\n-\t\t\t\tint named ATTRIBUTE_UNUSED)\n+static bool\n+mips_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode, tree type,\n+\t\t\tbool named ATTRIBUTE_UNUSED)\n {\n   if (mips_abi == ABI_EABI)\n     {\n@@ -7337,7 +7339,11 @@ function_arg_pass_by_reference (const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n       if (type == NULL_TREE || mode == DImode || mode == DFmode)\n \treturn 0;\n \n-      size = int_size_in_bytes (type);\n+      if (type)\n+        size = int_size_in_bytes (type);\n+      else\n+\tsize = GET_MODE_SIZE (mode);\n+\n       return size == -1 || size > UNITS_PER_WORD;\n     }\n   else"}, {"sha": "a4c7be938f101ce457ff4764f89ed80c76ed089b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -2351,18 +2351,14 @@ typedef struct mips_args {\n \t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n \t\t: GET_MODE_ALIGNMENT(MODE)))\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n-\n #define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\\\n   (mips_pad_arg_upward (MODE, TYPE) ? upward : downward)\n \n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST)\t\t\\\n   (mips_pad_reg_upward (MODE, TYPE) ? upward : downward)\n \n #define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (mips_abi == ABI_EABI && (NAMED)\t\t\t\t\t\\\n-   && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n+  (mips_abi == ABI_EABI && (NAMED))\n \n /* True if using EABI and varargs can be passed in floating-point\n    registers.  Under these conditions, we need a more complex form"}, {"sha": "c2f02ccb772413c5adc8ca1e20a3bcab84000a59", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -53,8 +53,6 @@ extern int mmix_local_regno (int);\n extern int mmix_dbx_register_number (int);\n extern int mmix_use_simple_return (void);\n extern void mmix_make_decl_one_only (tree);\n-extern int mmix_function_arg_pass_by_reference\n-  (const CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern rtx mmix_function_outgoing_value (tree, tree);\n extern int mmix_function_value_regno_p (int);\n extern int mmix_data_alignment (tree, int);"}, {"sha": "ae69548a2220840c6fc9a0d7b850b2dea9a3b073", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -139,7 +139,8 @@ static void mmix_file_start (void);\n static void mmix_file_end (void);\n static bool mmix_rtx_costs (rtx, int, int, int *);\n static rtx mmix_struct_value_rtx (tree, int);\n-\n+static bool mmix_pass_by_reference (const CUMULATIVE_ARGS *,\n+\t\t\t\t    enum machine_mode, tree, bool);\n \n /* Target structure macros.  Listed by node.  See `Using and Porting GCC'\n    for a general description.  */\n@@ -201,9 +202,10 @@ static rtx mmix_struct_value_rtx (tree, int);\n \n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX mmix_struct_value_rtx\n-\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS mmix_setup_incoming_varargs\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE mmix_pass_by_reference\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -590,11 +592,9 @@ mmix_function_arg (const CUMULATIVE_ARGS *argsp,\n /* Returns nonzero for everything that goes by reference, 0 for\n    everything that goes by value.  */\n \n-int\n-mmix_function_arg_pass_by_reference (const CUMULATIVE_ARGS *argsp,\n-\t\t\t\t     enum machine_mode mode,\n-\t\t\t\t     tree type,\n-\t\t\t\t     int named ATTRIBUTE_UNUSED)\n+static bool\n+mmix_pass_by_reference (const CUMULATIVE_ARGS *argsp, enum machine_mode mode,\n+\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n   /* FIXME: Check: I'm not sure the must_pass_in_stack check is\n      necessary.  */"}, {"sha": "6894337b2ff30c22c39fee937d31b1981be1dece", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -720,18 +720,7 @@ enum reg_class\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\\\n  mmix_function_arg (&(CUM), MODE, TYPE, NAMED, 1)\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n- mmix_function_arg_pass_by_reference (&(CUM), MODE, TYPE, NAMED)\n-\n-/* This *sounds* good, but does not seem to be implemented correctly to\n-   be a win; at least it wasn't in 2.7.2.  FIXME: Check and perhaps\n-   replace with a big comment.\n-   The definition needs to match or be a subset of\n-   FUNCTION_ARG_PASS_BY_REFERENCE, since not all callers check that before\n-   usage.  Watch lots of C++ testcases fail if set to 1, for example\n-   g++.dg/init/byval1.C.  */\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n- mmix_function_arg_pass_by_reference (&(CUM), MODE, TYPE, NAMED)\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n \n typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n "}, {"sha": "a67a75d3225ea4401a08f747fb7d954ab15a08bb", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -71,6 +71,8 @@ static bool mn10300_rtx_costs (rtx, int, int, int *);\n static void mn10300_file_start (void);\n static bool mn10300_return_in_memory (tree, tree);\n static rtx mn10300_builtin_saveregs (void);\n+static bool mn10300_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t       tree, bool);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -91,9 +93,10 @@ static rtx mn10300_builtin_saveregs (void);\n \n #undef TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n-\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY mn10300_return_in_memory\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE mn10300_pass_by_reference\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS mn10300_builtin_saveregs\n@@ -1456,6 +1459,23 @@ mn10300_va_start (tree valist, rtx nextarg)\n   std_expand_builtin_va_start (valist, nextarg);\n }\n \n+/* Return true when a parameter should be passed by reference.  */\n+\n+static bool\n+mn10300_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode, tree type,\n+\t\t\t   bool named ATTRIBUTE_UNUSED)\n+{\n+  unsigned HOST_WIDE_INT size;\n+\n+  if (type)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  return size > 8;\n+}\n+\n /* Return an RTX to represent where a value with mode MODE will be returned\n    from a function.  If the result is 0, the argument is pushed.  */\n "}, {"sha": "e77f9d26e44adc88b908cc97c77297db1b015b18", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -611,11 +611,7 @@ struct cum_arg {int nbytes; };\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n \f\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n- \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n-  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree)."}, {"sha": "7f4ba45c2c6d759d7c1f8045558276cbfb0ada9e", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -143,6 +143,9 @@ static void output_deferred_plabels (void);\n static void pa_hpux_init_libfuncs (void);\n #endif\n static rtx pa_struct_value_rtx (tree, int);\n+static bool pa_pass_by_reference (CUMULATIVE_ARGS *ca, enum machine_mode,\n+\t\t\t\t  tree, bool);\n+\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -267,6 +270,8 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_RETURN_IN_MEMORY pa_return_in_memory\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE pa_pass_by_reference\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS hppa_builtin_saveregs\n@@ -5838,6 +5843,37 @@ secondary_reload_class (enum reg_class class, enum machine_mode mode, rtx in)\n   return NO_REGS;\n }\n \n+/* In the 32-bit runtime, arguments larger than eight bytes are passed\n+   by invisible reference.  As a GCC extension, we also pass anything\n+   with a zero or variable size by reference.\n+\n+   The 64-bit runtime does not describe passing any types by invisible\n+   reference.  The internals of GCC can't currently handle passing\n+   empty structures, and zero or variable length arrays when they are\n+   not passed entirely on the stack or by reference.  Thus, as a GCC\n+   extension, we pass these types by reference.  The HP compiler doesn't\n+   support these types, so hopefully there shouldn't be any compatibility\n+   issues.  This may have to be revisited when HP releases a C99 compiler\n+   or updates the ABI.  */\n+\n+static bool\n+pa_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t      enum machine_mode mode, tree type,\n+\t\t      bool named ATTRIBUTE_UNUSED)\n+{\n+  HOST_WIDE_INT size;\n+\n+  if (type)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  if (TARGET_64BIT)\n+    return size <= 0;\n+  else\n+    return size <= 0 || size > 8;\n+}\n+\n enum direction\n function_arg_padding (enum machine_mode mode, tree type)\n {"}, {"sha": "0ceedc6834832e4edb659054c63be32cce929b67", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -913,27 +913,7 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n     : GET_MODE_SIZE(MODE) <= UNITS_PER_WORD)\t\t\t\t\\\n    ? PARM_BOUNDARY : MAX_PARM_BOUNDARY)\n \n-/* In the 32-bit runtime, arguments larger than eight bytes are passed\n-   by invisible reference.  As a GCC extension, we also pass anything\n-   with a zero or variable size by reference.\n-\n-   The 64-bit runtime does not describe passing any types by invisible\n-   reference.  The internals of GCC can't currently handle passing\n-   empty structures, and zero or variable length arrays when they are\n-   not passed entirely on the stack or by reference.  Thus, as a GCC\n-   extension, we pass these types by reference.  The HP compiler doesn't\n-   support these types, so hopefully there shouldn't be any compatibility\n-   issues.  This may have to be revisited when HP releases a C99 compiler\n-   or updates the ABI.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n-   ? ((TYPE) && int_size_in_bytes (TYPE) <= 0)\t\t\t\t\\\n-   : (((TYPE) && (int_size_in_bytes (TYPE) > 8\t\t\t\t\\\n-\t\t  || int_size_in_bytes (TYPE) <= 0))\t\t\t\\\n-      || ((MODE) && GET_MODE_SIZE (MODE) > 8)))\n- \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \t\t\\\n-  FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED)\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n \n \f\n extern GTY(()) rtx hppa_compare_op0;"}, {"sha": "c096808b3373609871360817d997d39b58be3c5a", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -156,9 +156,6 @@ extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t\t     enum machine_mode, tree, int);\n extern int function_arg_partial_nregs (CUMULATIVE_ARGS *,\n \t\t\t\t\t       enum machine_mode, tree, int);\n-extern int function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t\t   tree, int);\n extern rtx rs6000_function_value (tree, tree);\n extern rtx rs6000_libcall_value (enum machine_mode);\n extern struct rtx_def *rs6000_va_arg (tree, tree);"}, {"sha": "1013f971072d0fcc068be040abc8f2334a1c01c8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -735,6 +735,8 @@ static void rs6000_move_block_from_reg (int regno, rtx x, int nregs);\n static void setup_incoming_varargs (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree,\n \t\t\t\t    int *, int);\n+static bool rs6000_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t      tree, bool);\n #if TARGET_MACHO\n static void macho_branch_islands (void);\n static void add_compiler_branch_island (tree, tree, int);\n@@ -951,6 +953,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_SPLIT_COMPLEX_ARG hook_bool_tree_true\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK rs6000_must_pass_in_stack\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE rs6000_pass_by_reference\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST rs6000_build_builtin_va_list\n@@ -5182,10 +5186,10 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    As an extension to all ABIs, variable sized types are passed by\n    reference.  */\n \n-int\n-function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED, \n-\t\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED, \n-\t\t\t\ttree type, int named ATTRIBUTE_UNUSED)\n+static bool\n+rs6000_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED, \n+\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED, \n+\t\t\t  tree type, bool named ATTRIBUTE_UNUSED)\n {\n   if ((DEFAULT_ABI == ABI_V4\n        && ((type && AGGREGATE_TYPE_P (type))"}, {"sha": "fdf3d4afef9b636f3b90a5cfd072e4deb4457894", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1735,15 +1735,6 @@ typedef struct rs6000_args\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n \n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of\n-   the argument itself.  The pointer is passed in whatever way is\n-   appropriate for passing a pointer to that type.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_pass_by_reference(&CUM, MODE, TYPE, NAMED)\n-\n /* If defined, a C expression which determines whether, and in which\n    direction, to pad out an argument with extra space.  The value\n    should be of type `enum direction': either `upward' to pad above"}, {"sha": "447edff9b2108a3bc22a008aa6d45f606a0977af", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -96,7 +96,6 @@ extern rtx s390_load_got (void);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern int s390_function_arg_pass_by_reference (enum machine_mode, tree);\n extern void s390_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       tree, int);\n #ifdef RTX_CODE"}, {"sha": "4d4aef8c9c85eae0c2187dd9f57fea0a2ae4b29b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -81,6 +81,8 @@ static tree s390_build_builtin_va_list (void);\n static tree s390_gimplify_va_arg (tree, tree, tree *, tree *);\n static bool s390_function_ok_for_sibcall (tree, tree);\n static bool s390_call_saved_register_used (tree);\n+static bool s390_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode mode,\n+\t\t\t\t    tree, bool);\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n@@ -155,6 +157,8 @@ static bool s390_call_saved_register_used (tree);\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_true\n #undef TARGET_PROMOTE_FUNCTION_RETURN\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_true\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE s390_pass_by_reference\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL s390_function_ok_for_sibcall\n@@ -6324,8 +6328,10 @@ s390_function_arg_integer (enum machine_mode mode, tree type)\n    all other structures (and complex numbers) are passed by\n    reference.  */\n \n-int\n-s390_function_arg_pass_by_reference (enum machine_mode mode, tree type)\n+static bool\n+s390_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode, tree type,\n+\t\t\tbool named ATTRIBUTE_UNUSED)\n {\n   int size = s390_function_arg_size (mode, type);\n   if (size > 8)\n@@ -6354,11 +6360,7 @@ void\n s390_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t   tree type, int named ATTRIBUTE_UNUSED)\n {\n-  if (s390_function_arg_pass_by_reference (mode, type))\n-    {\n-      cum->gprs += 1;\n-    }\n-  else if (s390_function_arg_float (mode, type))\n+  if (s390_function_arg_float (mode, type))\n     {\n       cum->fprs += 1;\n     }\n@@ -6394,9 +6396,6 @@ rtx\n s390_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n \t\t   int named ATTRIBUTE_UNUSED)\n {\n-  if (s390_function_arg_pass_by_reference (mode, type))\n-      return 0;\n-\n   if (s390_function_arg_float (mode, type))\n     {\n       if (cum->fprs + 1 > (TARGET_64BIT? 4 : 2))\n@@ -6652,7 +6651,7 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n \n   size = int_size_in_bytes (type);\n \n-  if (s390_function_arg_pass_by_reference (TYPE_MODE (type), type))\n+  if (pass_by_reference (NULL, TYPE_MODE (type), type, false))\n     {\n       if (TARGET_DEBUG_ARG)\n \t{\n@@ -7364,7 +7363,7 @@ s390_call_saved_register_used (tree argument_list)\n       if (! (mode = TYPE_MODE (TREE_TYPE (parameter))))\n \tabort();\n \n-      if (s390_function_arg_pass_by_reference (mode, type))\n+      if (pass_by_reference (&cum, mode, type, true))\n  \t{\n  \t  mode = Pmode;\n  \t  type = build_pointer_type (type);"}, {"sha": "d804599a3f7212ab766a9fe6be5881eec72e16f1", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -665,9 +665,6 @@ CUMULATIVE_ARGS;\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)   \\\n   s390_function_arg (&CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-  s390_function_arg_pass_by_reference (MODE, TYPE)\n-\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n /* Arguments can be placed in general registers 2 to 6,"}, {"sha": "b3b2ab381b5e7e9695d6dca294f1a3b555c4787e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -282,6 +282,8 @@ static bool sh_strict_argument_naming (CUMULATIVE_ARGS *);\n static bool sh_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n static tree sh_build_builtin_va_list (void);\n static tree sh_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n+static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t  tree, bool);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -438,6 +440,8 @@ static tree sh_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n #define TARGET_PRETEND_OUTGOING_VARARGS_NAMED sh_pretend_outgoing_varargs_named\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE sh_pass_by_reference\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST sh_build_builtin_va_list\n@@ -6504,6 +6508,51 @@ sh_promote_prototypes (tree type)\n   return ! sh_attr_renesas_p (type);\n }\n \n+/* Whether an argument must be passed by reference.  On SHcompact, we\n+   pretend arguments wider than 32-bits that would have been passed in\n+   registers are passed by reference, so that an SHmedia trampoline\n+   loads them into the full 64-bits registers.  */\n+\n+static int\n+shcompact_byref (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t tree type, bool named)\n+{\n+  unsigned HOST_WIDE_INT size;\n+\n+  if (type)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  if (cum->arg_count[SH_ARG_INT] < NPARM_REGS (SImode)\n+      && (!named\n+\t  || GET_SH_ARG_CLASS (mode) == SH_ARG_INT\n+\t  || (GET_SH_ARG_CLASS (mode) == SH_ARG_FLOAT\n+\t      && cum->arg_count[SH_ARG_FLOAT] >= NPARM_REGS (SFmode)))\n+      && size > 4\n+      && !SHCOMPACT_FORCE_ON_STACK (mode, type)\n+      && !SH5_WOULD_BE_PARTIAL_NREGS (*cum, mode, type, named))\n+    return size;\n+  else\n+    return 0;\n+}\n+\n+static bool\n+sh_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t      tree type, bool named)\n+{\n+  if (targetm.calls.must_pass_in_stack (mode, type))\n+    return true;\n+\n+  if (TARGET_SHCOMPACT)\n+    {\n+      cum->byref = shcompact_byref (cum, mode, type, named);\n+      return cum->byref != 0;\n+    }\n+\n+  return false;\n+}\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument."}, {"sha": "e38361f186a18bfedd00215d31e2c3c5514c736c", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1826,8 +1826,8 @@ struct sh_args {\n      used to pass arguments, if the arguments didn't have to be passed\n      by reference.  */\n     int byref_regs;\n-  /* Set by SHCOMPACT_BYREF if the current argument is to be passed by\n-     reference.  */\n+  /* Set as by shcompact_byref if the current argument is to be passed\n+     by reference.  */\n     int byref;\n \n   /* call_cookie is a bitmask used by call expanders, as well as\n@@ -2033,31 +2033,6 @@ struct sh_args {\n    foo (float a, __complex float b); a: fr5 b.real: fr4 b.imag: fr7  */\n #define FUNCTION_ARG_SCmode_WART 1\n \n-/* Whether an argument must be passed by reference.  On SHcompact, we\n-   pretend arguments wider than 32-bits that would have been passed in\n-   registers are passed by reference, so that an SHmedia trampoline\n-   loads them into the full 64-bits registers.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED) \\\n-  (targetm.calls.must_pass_in_stack ((MODE), (TYPE)) \\\n-   || SHCOMPACT_BYREF ((CUM), (MODE), (TYPE), (NAMED)))\n-\n-#define SHCOMPACT_BYREF(CUM, MODE, TYPE, NAMED) \\\n-  ((CUM).byref\t\t\t\t\t\t\t\t\\\n-   = (TARGET_SHCOMPACT\t\t\t\t\t\t\t\\\n-      && (CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\t\\\n-      && (! (NAMED) || GET_SH_ARG_CLASS (MODE) == SH_ARG_INT\t\t\\\n-\t  || (GET_SH_ARG_CLASS (MODE) == SH_ARG_FLOAT\t\t\t\\\n-\t      && ((CUM).arg_count[(int) SH_ARG_FLOAT]\t\t\t\\\n- \t\t  >= NPARM_REGS (SFmode))))\t\t\t\t\\\n-      && ((MODE) == BLKmode ? int_size_in_bytes (TYPE)\t\t\t\\\n-\t  : GET_MODE_SIZE (MODE)) > 4\t\t\t\t       \t\\\n-      && ! SHCOMPACT_FORCE_ON_STACK ((MODE), (TYPE))\t\t\t\\\n-      && ! SH5_WOULD_BE_PARTIAL_NREGS ((CUM), (MODE),\t\t\t\\\n-\t\t\t\t       (TYPE), (NAMED)))\t\t\\\n-      ? ((MODE) == BLKmode ? int_size_in_bytes (TYPE)\t\t\t\\\n-\t : GET_MODE_SIZE (MODE))\t\t\t\t\t\\\n-      : 0)\n-\n /* If an argument of size 5, 6 or 7 bytes is to be passed in a 64-bit\n    register in SHcompact mode, it must be padded in the most\n    significant end.  This means that passing it by reference wouldn't"}, {"sha": "bc4d6ac5c2835013ea84aab6cdd507cf4c98f8a8", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -32,8 +32,6 @@ extern struct rtx_def *function_arg (const CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, int, int);\n extern int function_arg_partial_nregs (const CUMULATIVE_ARGS *,\n \t\t\t\t       enum machine_mode, tree, int);\n-extern int function_arg_pass_by_reference (const CUMULATIVE_ARGS *,\n-\t\t\t\t\t   enum machine_mode, tree, int);\n #ifdef RTX_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern void sparc_va_start (tree, rtx);"}, {"sha": "1dbd0020f8aaf0d0b6b5438aec4e83f043f99aef", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -332,6 +332,8 @@ static rtx sparc_struct_value_rtx (tree, int);\n static bool sparc_return_in_memory (tree, tree);\n static bool sparc_strict_argument_naming (CUMULATIVE_ARGS *);\n static tree sparc_gimplify_va_arg (tree, tree, tree *, tree *);\n+static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n+\t\t\t\t     enum machine_mode, tree, bool);\n \f\n /* Option handling.  */\n \n@@ -436,6 +438,8 @@ enum processor_type sparc_cpu;\n #define TARGET_RETURN_IN_MEMORY sparc_return_in_memory\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE sparc_pass_by_reference\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS sparc_builtin_saveregs\n@@ -5707,8 +5711,8 @@ function_arg_partial_nregs (const struct sparc_args *cum,\n     }\n   else\n     {\n-      /* We are guaranteed by function_arg_pass_by_reference that the size\n-\t of the argument is not greater than 16 bytes, so we only need to\n+      /* We are guaranteed by pass_by_reference that the size of the\n+\t argument is not greater than 16 bytes, so we only need to\n \t return 1 if the argument is partially passed in registers.  */\n \n       if (type && AGGREGATE_TYPE_P (type))\n@@ -5739,16 +5743,16 @@ function_arg_partial_nregs (const struct sparc_args *cum,\n   return 0;\n }\n \n-/* Handle the FUNCTION_ARG_PASS_BY_REFERENCE macro.\n+/* Return true if the argument should be passed by reference.\n    !v9: The SPARC ABI stipulates passing struct arguments (of any size) and\n    quad-precision floats by invisible reference.\n    v9: Aggregates greater than 16 bytes are passed by reference.\n    For Pascal, also pass arrays by reference.  */\n \n-int\n-function_arg_pass_by_reference (const struct sparc_args *cum ATTRIBUTE_UNUSED,\n-\t\t\t\tenum machine_mode mode, tree type,\n-\t\t\t\tint named ATTRIBUTE_UNUSED)\n+static bool\n+sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode, tree type,\n+\t\t\t bool named ATTRIBUTE_UNUSED)\n {\n   if (TARGET_ARCH32)\n     {\n@@ -6003,7 +6007,7 @@ sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   bool indirect;\n   tree ptrtype = build_pointer_type (type);\n \n-  if (function_arg_pass_by_reference (0, TYPE_MODE (type), type, 0))\n+  if (pass_by_reference (NULL, TYPE_MODE (type), type, 0))\n     {\n       indirect = true;\n       size = rsize = UNITS_PER_WORD;"}, {"sha": "4b073377869324ddeb34ae611ffd90dcd4f92b33", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -1742,15 +1742,6 @@ function_arg (& (CUM), (MODE), (TYPE), (NAMED), 1)\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n function_arg_partial_nregs (& (CUM), (MODE), (TYPE), (NAMED))\n \n-/* A C expression that indicates when an argument must be passed by reference.\n-   If nonzero for an argument, a copy of that argument is made in memory and a\n-   pointer to the argument is passed instead of the argument itself.\n-   The pointer is passed in whatever way is appropriate for passing a pointer\n-   to that type.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))\n-\n /* If defined, a C expression which determines whether, and in which direction,\n    to pad out an argument with extra space.  The value should be of type\n    `enum direction': either `upward' to pad above the argument,"}, {"sha": "31eb43e2b293c1950d7409b9d70b2922bde410ba", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -418,8 +418,6 @@ enum reg_class\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) 0\n-\n /* For this platform, the value of CUMULATIVE_ARGS is the number of words\n    of arguments that have been passed in registers so far.  */\n #define CUMULATIVE_ARGS int"}, {"sha": "11311c3fbf28776f62d79f05766b3cda819413f7", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -67,6 +67,8 @@ static void v850_encode_section_info (tree, rtx, int);\n static bool v850_return_in_memory    (tree, tree);\n static void v850_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n+static bool v850_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t    tree, bool);\n \n /* Information about the various small memory areas.  */\n struct small_memory_info small_memory[ (int)SMALL_MEMORY_max ] =\n@@ -129,6 +131,9 @@ static int v850_interrupt_p = FALSE;\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY v850_return_in_memory\n \n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE v850_pass_by_reference\n+\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS v850_setup_incoming_varargs\n \n@@ -178,6 +183,20 @@ override_options (void)\n }\n \n \f\n+static bool\n+v850_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode, tree type,\n+\t\t\tbool named ATTRIBUTE_UNUSED)\n+{\n+  unsigned HOST_WIDE_INT size;\n+\n+  if (type)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  return size > 8;\n+}\n \n /* Return an RTX to represent where a value with mode MODE will be returned\n    from a function.  If the result is 0, the argument is pushed.  */"}, {"sha": "5643a9df7496d2230c427741d627a7def0f367a4", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -773,11 +773,7 @@ struct cum_arg { int nbytes; int anonymous_args; };\n    space allocated by the caller.  */\n #define OUTGOING_REG_PARM_STACK_SPACE\n \n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  ((TYPE) && (unsigned HOST_WIDE_INT) int_size_in_bytes (TYPE) > 8)\n- \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n-  FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED)\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n \n /* 1 if N is a possible register number for function argument passing.  */\n "}, {"sha": "72f0fb4db254cac1752c6d0317246325c516e6be", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -3722,22 +3722,17 @@ register to be used by the caller for this argument; likewise\n @code{FUNCTION_INCOMING_ARG}, for the called function.\n @end defmac\n \n-@defmac FUNCTION_ARG_PASS_BY_REFERENCE (@var{cum}, @var{mode}, @var{type}, @var{named})\n-A C expression that indicates when an argument must be passed by reference.\n-If nonzero for an argument, a copy of that argument is made in memory and a\n+@deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n+This target hook should return @code{true} if an argument at the \n+position indicated by @var{cum} should be passed by reference.  This\n+predicate is queried after target independent reasons for being \n+passed by reference, such as @code{TREE_ADDRESSABLE (type)}.\n+\n+If the hook returns true, a copy of that argument is made in memory and a\n pointer to the argument is passed instead of the argument itself.\n The pointer is passed in whatever way is appropriate for passing a pointer\n to that type.\n-\n-On machines where @code{REG_PARM_STACK_SPACE} is not defined, a suitable\n-definition of this macro might be\n-@smallexample\n-#define FUNCTION_ARG_PASS_BY_REFERENCE\\\n-(CUM, MODE, TYPE, NAMED)  \\\n-  targetm.calls.must_pass_in_stack (MODE, TYPE)\n-@end smallexample\n-@c this is *still* too long.  --mew 5feb93\n-@end defmac\n+@end deftypefn\n \n @defmac FUNCTION_ARG_CALLEE_COPIES (@var{cum}, @var{mode}, @var{type}, @var{named})\n If defined, a C expression that indicates when it is the called function's"}, {"sha": "2d6a976e892d80cb94ca19237d624c818721e083", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -2029,9 +2029,8 @@ use_register_for_decl (tree decl)\n /* Return true if TYPE should be passed by invisible reference.  */\n \n bool\n-pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t   tree type, bool named_arg ATTRIBUTE_UNUSED)\n+pass_by_reference (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t   tree type, bool named_arg)\n {\n   if (type)\n     {\n@@ -2046,11 +2045,7 @@ pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n \treturn true;\n     }\n \n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n-  return FUNCTION_ARG_PASS_BY_REFERENCE (*ca, mode, type, named_arg);\n-#else\n-  return false;\n-#endif\n+  return targetm.calls.pass_by_reference (ca, mode, type, named_arg);\n }\n \n /* Structures to communicate between the subroutines of assign_parms."}, {"sha": "26dccf4c70aef32ce94b698b2ab3a9686cf71409", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -585,7 +585,7 @@ extern int snprintf (char *, size_t, const char *, ...);\n \tSETUP_INCOMING_VARARGS EXPAND_BUILTIN_SAVEREGS\t\t\t\\\n \tDEFAULT_SHORT_ENUMS SPLIT_COMPLEX_ARGS MD_ASM_CLOBBERS\t\t\\\n \tHANDLE_PRAGMA_REDEFINE_EXTNAME HANDLE_PRAGMA_EXTERN_PREFIX\t\\\n-\tMUST_PASS_IN_STACK\n+\tMUST_PASS_IN_STACK FUNCTION_ARG_PASS_BY_REFERENCE\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "5671b1b43fe6507e0b9190e76f21b3c375620df1", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -362,6 +362,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_GIMPLIFY_VA_ARG_EXPR std_gimplify_va_arg_expr\n #endif\n \n+#define TARGET_PASS_BY_REFERENCE hook_pass_by_reference_false\n+\n #define TARGET_LATE_RTL_PROLOGUE_EPILOGUE false\n \n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size_or_pad\n@@ -373,6 +375,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_STRUCT_VALUE_RTX,\t\t\t\t\t\\\n    TARGET_RETURN_IN_MEMORY,\t\t\t\t\t\\\n    TARGET_RETURN_IN_MSB,\t\t\t\t\t\\\n+   TARGET_PASS_BY_REFERENCE,\t\t\t\t\t\\\n    TARGET_EXPAND_BUILTIN_SAVEREGS,\t\t\t\t\\\n    TARGET_SETUP_INCOMING_VARARGS,\t\t\t\t\\\n    TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\"}, {"sha": "f4f4984b7a1d715f4d12f3858cd55aa36f7b3de9", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -448,6 +448,13 @@ struct gcc_target\n     rtx (*struct_value_rtx) (tree fndecl, int incoming);\n     bool (*return_in_memory) (tree type, tree fndecl);\n     bool (*return_in_msb) (tree type);\n+\n+    /* Return true if a parameter must be passed by reference.  TYPE may\n+       be null if this is a libcall.  CA may be null if this query is\n+       from __builtin_va_arg.  */\n+    bool (*pass_by_reference) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\t       tree type, bool named_arg);\n+\n     rtx (*expand_builtin_saveregs) (void);\n     /* Returns pretend_argument_size.  */\n     void (*setup_incoming_varargs) (CUMULATIVE_ARGS *ca, enum machine_mode mode,"}, {"sha": "be4d1446e066ee3b5b9981a1cb64fd254236eec7", "filename": "gcc/targhooks.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -168,3 +168,25 @@ default_cxx_get_cookie_size (tree type)\n \n   return cookie_size;\n }\n+\n+/* This version of the TARGET_PASS_BY_REFERENCE hook adds no conditions\n+   beyond those mandated by generic code.  */\n+\n+bool\n+hook_pass_by_reference_false (CUMULATIVE_ARGS *c ATTRIBUTE_UNUSED,\n+\tenum machine_mode mode ATTRIBUTE_UNUSED, tree type ATTRIBUTE_UNUSED,\n+\tbool named_arg ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+/* Return true if a parameter must be passed by reference.  This version\n+   of the TARGET_PASS_BY_REFERENCE hook uses just MUST_PASS_IN_STACK.  */\n+\n+bool\n+hook_pass_by_reference_must_pass_in_stack (CUMULATIVE_ARGS *c ATTRIBUTE_UNUSED,\n+\tenum machine_mode mode ATTRIBUTE_UNUSED, tree type ATTRIBUTE_UNUSED,\n+\tbool named_arg ATTRIBUTE_UNUSED)\n+{\n+  return targetm.calls.must_pass_in_stack (mode, type);\n+}"}, {"sha": "6d3295c229705e13fd6445acd6f3d57ea4baef4d", "filename": "gcc/targhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5a4e07d23dc35cb601121b948a3e33e09e1f3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=8cd5a4e07d23dc35cb601121b948a3e33e09e1f3", "patch": "@@ -34,3 +34,8 @@ extern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n extern bool hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS *);\n extern tree default_cxx_guard_type (void);\n extern tree default_cxx_get_cookie_size (tree);\n+\n+extern bool hook_pass_by_reference_false\n+  (CUMULATIVE_ARGS *, enum machine_mode mode, tree, bool);\n+extern bool hook_pass_by_reference_must_pass_in_stack\n+  (CUMULATIVE_ARGS *, enum machine_mode mode, tree, bool);"}]}