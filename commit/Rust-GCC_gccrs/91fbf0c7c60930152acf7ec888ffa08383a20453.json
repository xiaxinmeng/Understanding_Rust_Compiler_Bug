{"sha": "91fbf0c7c60930152acf7ec888ffa08383a20453", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFmYmYwYzdjNjA5MzAxNTJhY2Y3ZWM4ODhmZmEwODM4M2EyMDQ1Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-16T21:49:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-16T21:49:36Z"}, "message": "cgraph.c (cgraph_clone_node): Take decl argument and insert clone into hash when it is different from orig.\n\n\t* cgraph.c (cgraph_clone_node): Take decl argument and insert\n\tclone into hash when it is different from orig.\n\t(cgraph_create_virtual_clone): Update use of cgraph_clone_node.\n\t* cgraph.h (cgraph_clone_node): Update prototype.\n\t* lto-cgrpah.c (lto_cgraph_encoder_new): Create body map.\n\t(lto_cgraph_encoder_delete): Delete body map.\n\t(lto_cgraph_encoder_size): Move to header.\n\t(lto_cgraph_encoder_encode_body_p, lto_set_cgraph_encoder_encode_body): New.\n\t(lto_output_node): Do not take written_decls argument; output clone_of\n\tpointer.\n\t(add_node_to): Add include_body_argument; call\n\tlto_set_cgraph_encoder_encode_body on master of the clone.\n\t(add_references): Update use of add_node_to.\n\t(compute_ltrans_boundary): Likewise.\n\t(output_cgraph): Do not create written_decls bitmap.\n\t(input_node): Take nodes argument; stream in clone_of correctly.\n\t(input_cgraph_1): Update use of input_node.\n\t* lto-streamer-out.c (lto_output): Use encoder info to decide\n\twhat bodies to output.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes,\n\tcgraph_decide_recursive_inlining): Update call of cgraph_clone_node.\n\t* lto-streamer.h (lto_cgraph_encoder_d): Add body.\n\t(lto_cgraph_encoder_size): Define here.\n\t(lto_cgraph_encoder_encode_body_p, lto_varpool_encoder_encode_body_p):\n\tDeclare.\n\nFrom-SVN: r159466", "tree": {"sha": "b941299e1cca65763fc24db9b4af875a72897cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b941299e1cca65763fc24db9b4af875a72897cdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91fbf0c7c60930152acf7ec888ffa08383a20453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91fbf0c7c60930152acf7ec888ffa08383a20453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91fbf0c7c60930152acf7ec888ffa08383a20453", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91fbf0c7c60930152acf7ec888ffa08383a20453/comments", "author": null, "committer": null, "parents": [{"sha": "cdc6637d7c78ec66bff42ef5a38c1f5a4cd2074d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc6637d7c78ec66bff42ef5a38c1f5a4cd2074d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdc6637d7c78ec66bff42ef5a38c1f5a4cd2074d"}], "stats": {"total": 192, "additions": 132, "deletions": 60}, "files": [{"sha": "6053f009a852ef794a83aaeb10de685473904f07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91fbf0c7c60930152acf7ec888ffa08383a20453", "patch": "@@ -1,3 +1,31 @@\n+2010-05-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_clone_node): Take decl argument and insert\n+\tclone into hash when it is different from orig.\n+\t(cgraph_create_virtual_clone): Update use of cgraph_clone_node.\n+\t* cgraph.h (cgraph_clone_node): Update prototype.\n+\t* lto-cgrpah.c (lto_cgraph_encoder_new): Create body map.\n+\t(lto_cgraph_encoder_delete): Delete body map.\n+\t(lto_cgraph_encoder_size): Move to header.\n+\t(lto_cgraph_encoder_encode_body_p, lto_set_cgraph_encoder_encode_body): New.\n+\t(lto_output_node): Do not take written_decls argument; output clone_of\n+\tpointer.\n+\t(add_node_to): Add include_body_argument; call\n+\tlto_set_cgraph_encoder_encode_body on master of the clone.\n+\t(add_references): Update use of add_node_to.\n+\t(compute_ltrans_boundary): Likewise.\n+\t(output_cgraph): Do not create written_decls bitmap.\n+\t(input_node): Take nodes argument; stream in clone_of correctly.\n+\t(input_cgraph_1): Update use of input_node.\n+\t* lto-streamer-out.c (lto_output): Use encoder info to decide\n+\twhat bodies to output.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes,\n+\tcgraph_decide_recursive_inlining): Update call of cgraph_clone_node.\n+\t* lto-streamer.h (lto_cgraph_encoder_d): Add body.\n+\t(lto_cgraph_encoder_size): Define here.\n+\t(lto_cgraph_encoder_encode_body_p, lto_varpool_encoder_encode_body_p):\n+\tDeclare.\n+\n 2010-05-16  Richard Guenther  <rguenther@suse.de>\n \n \t* doc/invoke.texi (-fipa-struct-reorg): Do not mention"}, {"sha": "6e30ec1435d48662721108d00d7d768c9d3040ba", "filename": "gcc/cgraph.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=91fbf0c7c60930152acf7ec888ffa08383a20453", "patch": "@@ -2051,7 +2051,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n    function's profile to reflect the fact that part of execution is handled\n    by node.  */\n struct cgraph_node *\n-cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n+cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \t\t   int loop_nest, bool update_original,\n \t\t   VEC(cgraph_edge_p,heap) *redirect_callers)\n {\n@@ -2060,7 +2060,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n   gcov_type count_scale;\n   unsigned i;\n \n-  new_node->decl = n->decl;\n+  new_node->decl = decl;\n   new_node->origin = n->origin;\n   if (new_node->origin)\n     {\n@@ -2118,6 +2118,24 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n   new_node->clone_of = n;\n \n   cgraph_call_node_duplication_hooks (n, new_node);\n+  if (n->decl != decl)\n+    {\n+      struct cgraph_node **slot;\n+      slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, new_node, INSERT);\n+      gcc_assert (!*slot);\n+      *slot = new_node;\n+      if (assembler_name_hash)\n+\t{\n+\t  void **aslot;\n+\t  tree name = DECL_ASSEMBLER_NAME (decl);\n+\n+\t  aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t\t    decl_assembler_name_hash (name),\n+\t\t\t\t\t    INSERT);\n+\t  gcc_assert (!*aslot);\n+\t  *aslot = new_node;\n+\t}\n+    }\n   return new_node;\n }\n \n@@ -2159,7 +2177,6 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   tree old_decl = old_node->decl;\n   struct cgraph_node *new_node = NULL;\n   tree new_decl;\n-  struct cgraph_node key, **slot;\n   size_t i;\n   struct ipa_replace_map *map;\n \n@@ -2177,10 +2194,9 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n   SET_DECL_RTL (new_decl, NULL);\n \n-  new_node = cgraph_clone_node (old_node, old_node->count,\n+  new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n \t\t\t\tCGRAPH_FREQ_BASE, 0, false,\n \t\t\t\tredirect_callers);\n-  new_node->decl = new_decl;\n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n      that is not weak also.\n@@ -2243,21 +2259,6 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   new_node->lowered = true;\n   new_node->reachable = true;\n \n-  key.decl = new_decl;\n-  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n-  gcc_assert (!*slot);\n-  *slot = new_node;\n-  if (assembler_name_hash)\n-    {\n-      void **aslot;\n-      tree name = DECL_ASSEMBLER_NAME (new_decl);\n-\n-      aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t\tdecl_assembler_name_hash (name),\n-\t\t\t\t\tINSERT);\n-      gcc_assert (!*aslot);\n-      *aslot = new_node;\n-    }\n \n   return new_node;\n }"}, {"sha": "d0f7e9a704723f9b6283b7aa164c9d2b203ab1bd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=91fbf0c7c60930152acf7ec888ffa08383a20453", "patch": "@@ -544,7 +544,7 @@ const char * cgraph_node_name (struct cgraph_node *);\n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tstruct cgraph_node *, gimple,\n \t\t\t\t\tunsigned, gcov_type, int, int, bool);\n-struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int,\n+struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type, int,\n \t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);"}, {"sha": "e1de7ce25cc8a579dc11ae2c6d6a49f92564ac25", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=91fbf0c7c60930152acf7ec888ffa08383a20453", "patch": "@@ -268,7 +268,8 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n       else\n \t{\n \t  struct cgraph_node *n;\n-\t  n = cgraph_clone_node (e->callee, e->count, e->frequency, e->loop_nest,\n+\t  n = cgraph_clone_node (e->callee, e->callee->decl,\n+\t\t\t\t e->count, e->frequency, e->loop_nest,\n \t\t\t\t update_original, NULL);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n@@ -808,7 +809,8 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n \t     cgraph_node_name (node));\n \n   /* We need original clone to copy around.  */\n-  master_clone = cgraph_clone_node (node, node->count, CGRAPH_FREQ_BASE, 1,\n+  master_clone = cgraph_clone_node (node, node->decl,\n+\t\t\t\t    node->count, CGRAPH_FREQ_BASE, 1,\n   \t\t\t\t    false, NULL);\n   master_clone->needed = true;\n   for (e = master_clone->callees; e; e = e->next_callee)"}, {"sha": "c6ef21f6338333f37ac1263e466ee56ca6327bbc", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=91fbf0c7c60930152acf7ec888ffa08383a20453", "patch": "@@ -71,6 +71,7 @@ lto_cgraph_encoder_new (void)\n   lto_cgraph_encoder_t encoder = XCNEW (struct lto_cgraph_encoder_d);\n   encoder->map = pointer_map_create ();\n   encoder->nodes = NULL;\n+  encoder->body = pointer_set_create ();\n   return encoder;\n }\n \n@@ -82,6 +83,7 @@ lto_cgraph_encoder_delete (lto_cgraph_encoder_t encoder)\n {\n    VEC_free (cgraph_node_ptr, heap, encoder->nodes);\n    pointer_map_destroy (encoder->map);\n+   pointer_set_destroy (encoder->body);\n    free (encoder);\n }\n \n@@ -137,12 +139,22 @@ lto_cgraph_encoder_deref (lto_cgraph_encoder_t encoder, int ref)\n }\n \n \n-/* Return number of encoded nodes in ENCODER.  */\n+/* Return TRUE if we should encode initializer of NODE (if any).  */\n \n-static int\n-lto_cgraph_encoder_size (lto_cgraph_encoder_t encoder)\n+bool\n+lto_cgraph_encoder_encode_body_p (lto_cgraph_encoder_t encoder,\n+\t\t\t\t  struct cgraph_node *node)\n+{\n+  return pointer_set_contains (encoder->body, node);\n+}\n+\n+/* Return TRUE if we should encode body of NODE (if any).  */\n+\n+static void\n+lto_set_cgraph_encoder_encode_body (lto_cgraph_encoder_t encoder,\n+\t\t\t\t    struct cgraph_node *node)\n {\n-  return VEC_length (cgraph_node_ptr, encoder->nodes);\n+  pointer_set_insert (encoder->body, node);\n }\n \n /* Create a new varpool encoder.  */\n@@ -394,17 +406,16 @@ reachable_from_this_partition_p (struct cgraph_node *node, cgraph_node_set set)\n static void\n lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t\t lto_cgraph_encoder_t encoder, cgraph_node_set set,\n-\t\t varpool_node_set vset,\n-\t\t bitmap written_decls)\n+\t\t varpool_node_set vset)\n {\n   unsigned int tag;\n   struct bitpack_d *bp;\n-  bool boundary_p, wrote_decl_p;\n+  bool boundary_p;\n   intptr_t ref;\n   bool in_other_partition = false;\n+  struct cgraph_node *clone_of;\n \n   boundary_p = !cgraph_node_in_set_p (node, set);\n-  wrote_decl_p = bitmap_bit_p (written_decls, DECL_UID (node->decl));\n \n   if (node->analyzed && !boundary_p)\n     tag = LTO_cgraph_analyzed_node;\n@@ -436,10 +447,18 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       in_other_partition = 1;\n     }\n \n-  lto_output_uleb128_stream (ob->main_stream, wrote_decl_p);\n+  clone_of = node->clone_of;\n+  while (clone_of\n+\t && (ref = lto_cgraph_encoder_lookup (encoder, node->clone_of)) == LCC_NOT_FOUND)\n+    if (clone_of->prev_sibling_clone)\n+      clone_of = clone_of->prev_sibling_clone;\n+    else\n+      clone_of = clone_of->clone_of;\n+  if (!clone_of)\n+    lto_output_sleb128_stream (ob->main_stream, LCC_NOT_FOUND);\n+  else\n+    lto_output_sleb128_stream (ob->main_stream, ref);\n \n-  if (!wrote_decl_p)\n-    bitmap_set_bit (written_decls, DECL_UID (node->decl));\n \n   lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n   lto_output_sleb128_stream (ob->main_stream, node->count);\n@@ -636,11 +655,15 @@ output_profile_summary (struct lto_simple_output_block *ob)\n \n /* Add NODE into encoder as well as nodes it is cloned from.\n    Do it in a way so clones appear first.  */\n+\n static void\n-add_node_to (lto_cgraph_encoder_t encoder, struct cgraph_node *node)\n+add_node_to (lto_cgraph_encoder_t encoder, struct cgraph_node *node,\n+\t     bool include_body)\n {\n   if (node->clone_of)\n-    add_node_to (encoder, node->clone_of);\n+    add_node_to (encoder, node->clone_of, include_body);\n+  else if (include_body)\n+    lto_set_cgraph_encoder_encode_body (encoder, node);\n   lto_cgraph_encoder_encode (encoder, node);\n }\n \n@@ -655,7 +678,7 @@ add_references (lto_cgraph_encoder_t encoder,\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n     if (ref->refered_type == IPA_REF_CGRAPH)\n-      add_node_to (encoder, ipa_ref_node (ref));\n+      add_node_to (encoder, ipa_ref_node (ref), false);\n     else\n       {\n \tstruct varpool_node *vnode = ipa_ref_varpool_node (ref);\n@@ -757,7 +780,7 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n-      add_node_to (encoder, node);\n+      add_node_to (encoder, node, true);\n       add_references (encoder, varpool_encoder, &node->ref_list);\n     }\n   for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n@@ -797,7 +820,7 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n \t    {\n \t      /* We should have moved all the inlines.  */\n \t      gcc_assert (!callee->global.inlined_to);\n-\t      add_node_to (encoder, callee);\n+\t      add_node_to (encoder, callee, false);\n \t    }\n \t}\n     }\n@@ -812,7 +835,6 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n   struct lto_simple_output_block *ob;\n   cgraph_node_set_iterator csi;\n   int i, n_nodes;\n-  bitmap written_decls;\n   lto_cgraph_encoder_t encoder;\n   lto_varpool_encoder_t varpool_encoder;\n   struct cgraph_asm_node *can;\n@@ -828,23 +850,16 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n   encoder = ob->decl_state->cgraph_node_encoder;\n   varpool_encoder = ob->decl_state->varpool_node_encoder;\n \n-  /* The FUNCTION_DECLs for which we have written a node.  The first\n-     node found is written as the \"original\" node, the remaining nodes\n-     are considered its clones.  */\n-  written_decls = lto_bitmap_alloc ();\n-\n   /* Write out the nodes.  We must first output a node and then its clones,\n      otherwise at a time reading back the node there would be nothing to clone\n      from.  */\n   n_nodes = lto_cgraph_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n     {\n       node = lto_cgraph_encoder_deref (encoder, i);\n-      lto_output_node (ob, node, encoder, set, vset, written_decls);\n+      lto_output_node (ob, node, encoder, set, vset);\n     }\n \n-  lto_bitmap_free (written_decls);\n-\n   /* Go over the nodes in SET again to write edges.  */\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n@@ -950,30 +965,32 @@ output_varpool (cgraph_node_set set, varpool_node_set vset)\n static struct cgraph_node *\n input_node (struct lto_file_decl_data *file_data,\n \t    struct lto_input_block *ib,\n-\t    enum LTO_cgraph_tags tag)\n+\t    enum LTO_cgraph_tags tag,\n+\t    VEC(cgraph_node_ptr, heap) *nodes)\n {\n   tree fn_decl;\n   struct cgraph_node *node;\n   struct bitpack_d *bp;\n   int stack_size = 0;\n   unsigned decl_index;\n-  bool clone_p;\n   int ref = LCC_NOT_FOUND, ref2 = LCC_NOT_FOUND;\n   int self_time = 0;\n   int self_size = 0;\n   int time_inlining_benefit = 0;\n   int size_inlining_benefit = 0;\n   unsigned long same_body_count = 0;\n+  int clone_ref;\n \n-  clone_p = (lto_input_uleb128 (ib) != 0);\n+  clone_ref = lto_input_sleb128 (ib);\n \n   decl_index = lto_input_uleb128 (ib);\n   fn_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n \n-  if (clone_p)\n-    node = cgraph_clone_node (cgraph_node (fn_decl), 0,\n-\t\t\t      CGRAPH_FREQ_BASE, 0, false, NULL);\n-\n+  if (clone_ref != LCC_NOT_FOUND)\n+    {\n+      node = cgraph_clone_node (VEC_index (cgraph_node_ptr, nodes, clone_ref), fn_decl,\n+\t\t\t\t0, CGRAPH_FREQ_BASE, 0, false, NULL);\n+    }\n   else\n     node = cgraph_node (fn_decl);\n \n@@ -1214,7 +1231,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n         input_edge (ib, nodes, true);\n       else\n \t{\n-\t  node = input_node (file_data, ib, tag);\n+\t  node = input_node (file_data, ib, tag,nodes);\n \t  if (node == NULL || node->decl == NULL_TREE)\n \t    internal_error (\"bytecode stream: found empty cgraph node\");\n \t  VEC_safe_push (cgraph_node_ptr, heap, nodes, node);"}, {"sha": "520f29afa5988ce4838a38753f5862b8c1773539", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=91fbf0c7c60930152acf7ec888ffa08383a20453", "patch": "@@ -2090,18 +2090,25 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n {\n   struct cgraph_node *node;\n   struct lto_out_decl_state *decl_state;\n-  cgraph_node_set_iterator csi;\n+#ifdef ENABLE_CHECKING\n   bitmap output = lto_bitmap_alloc ();\n+#endif\n+  int i, n_nodes;\n+  lto_cgraph_encoder_t encoder = lto_get_out_decl_state ()->cgraph_node_encoder;\n \n   lto_writer_init ();\n \n+  n_nodes = lto_cgraph_encoder_size (encoder);\n   /* Process only the functions with bodies.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+  for (i = 0; i < n_nodes; i++)\n     {\n-      node = csi_node (csi);\n-      if (node->analyzed && !bitmap_bit_p (output, DECL_UID (node->decl)))\n+      node = lto_cgraph_encoder_deref (encoder, i);\n+      if (lto_cgraph_encoder_encode_body_p (encoder, node))\n \t{\n+#ifdef ENABLE_CHECKING\n+\t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n \t  bitmap_set_bit (output, DECL_UID (node->decl));\n+#endif\n \t  decl_state = lto_new_out_decl_state ();\n \t  lto_push_out_decl_state (decl_state);\n \t  if (!flag_wpa)"}, {"sha": "d86811a7fbcf73744d614548fa4f4790f9ab5c02", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fbf0c7c60930152acf7ec888ffa08383a20453/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=91fbf0c7c60930152acf7ec888ffa08383a20453", "patch": "@@ -467,10 +467,22 @@ struct lto_cgraph_encoder_d\n \n   /* Map reference number to node. */\n   VEC(cgraph_node_ptr,heap) *nodes;\n+\n+  /* Map of nodes where we want to output body.  */\n+  struct pointer_set_t *body;\n };\n \n typedef struct lto_cgraph_encoder_d *lto_cgraph_encoder_t;\n \n+/* Return number of encoded nodes in ENCODER.  */\n+\n+static inline int\n+lto_cgraph_encoder_size (lto_cgraph_encoder_t encoder)\n+{\n+  return VEC_length (cgraph_node_ptr, encoder->nodes);\n+}\n+\n+\n /* Encoder data structure used to stream callgraph nodes.  */\n struct lto_varpool_encoder_d\n {\n@@ -851,6 +863,11 @@ int lto_cgraph_encoder_lookup (lto_cgraph_encoder_t, struct cgraph_node *);\n lto_cgraph_encoder_t lto_cgraph_encoder_new (void);\n int lto_cgraph_encoder_encode (lto_cgraph_encoder_t, struct cgraph_node *);\n void lto_cgraph_encoder_delete (lto_cgraph_encoder_t);\n+bool lto_cgraph_encoder_encode_body_p (lto_cgraph_encoder_t,\n+\t\t\t\t       struct cgraph_node *);\n+\n+bool lto_varpool_encoder_encode_body_p (lto_varpool_encoder_t,\n+\t\t\t\t        struct varpool_node *);\n struct varpool_node *lto_varpool_encoder_deref (lto_varpool_encoder_t, int);\n int lto_varpool_encoder_lookup (lto_varpool_encoder_t, struct varpool_node *);\n lto_varpool_encoder_t lto_varpool_encoder_new (void);"}]}