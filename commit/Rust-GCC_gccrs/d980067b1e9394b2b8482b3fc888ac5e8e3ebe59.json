{"sha": "d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk4MDA2N2IxZTkzOTRiMmI4NDgyYjNmYzg4OGFjNWU4ZTNlYmU1OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:27:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:27:05Z"}, "message": "Use explicit encodings for simple permutes\n\nThis patch makes users of vec_perm_builders use the compressed encoding\nwhere possible.  This means that they work with variable-length vectors.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* optabs.c (expand_vec_perm_var): Use an explicit encoding for\n\tthe broadcast of the low byte.\n\t(expand_mult_highpart): Use an explicit encoding for the permutes.\n\t* optabs-query.c (can_mult_highpart_p): Likewise.\n\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Likewise.\n\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n\t(vectorizable_bswap): Likewise.\n\t* tree-vect-data-refs.c (vect_grouped_store_supported): Use an\n\texplicit encoding for the power-of-2 permutes.\n\t(vect_permute_store_chain): Likewise.\n\t(vect_grouped_load_supported): Likewise.\n\t(vect_permute_load_chain): Likewise.\n\nFrom-SVN: r256097", "tree": {"sha": "ebde117c5d31c80df9b86ffd24c029b7dfc3f5db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebde117c5d31c80df9b86ffd24c029b7dfc3f5db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/comments", "author": null, "committer": null, "parents": [{"sha": "736d0f28783f12fa042892bc186866dd5101088f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/736d0f28783f12fa042892bc186866dd5101088f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/736d0f28783f12fa042892bc186866dd5101088f"}], "stats": {"total": 115, "additions": 74, "deletions": 41}, "files": [{"sha": "c5b62cd3628e1ab6cc152197b549e3d741d71321", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "patch": "@@ -1,3 +1,18 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* optabs.c (expand_vec_perm_var): Use an explicit encoding for\n+\tthe broadcast of the low byte.\n+\t(expand_mult_highpart): Use an explicit encoding for the permutes.\n+\t* optabs-query.c (can_mult_highpart_p): Likewise.\n+\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Likewise.\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n+\t(vectorizable_bswap): Likewise.\n+\t* tree-vect-data-refs.c (vect_grouped_store_supported): Use an\n+\texplicit encoding for the power-of-2 permutes.\n+\t(vect_permute_store_chain): Likewise.\n+\t(vect_grouped_load_supported): Likewise.\n+\t(vect_permute_load_chain): Likewise.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* vec-perm-indices.h (vec_perm_indices_to_tree): Declare."}, {"sha": "c715cb662edc39158a71c8f1f33de2366088ee9d", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "patch": "@@ -516,8 +516,9 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n       op = uns_p ? vec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n       if (optab_handler (op, mode) != CODE_FOR_nothing)\n \t{\n-\t  vec_perm_builder sel (nunits, nunits, 1);\n-\t  for (i = 0; i < nunits; ++i)\n+\t  /* The encoding has 2 interleaved stepped patterns.  */\n+\t  vec_perm_builder sel (nunits, 2, 3);\n+\t  for (i = 0; i < 6; ++i)\n \t    sel.quick_push (!BYTES_BIG_ENDIAN\n \t\t\t    + (i & ~1)\n \t\t\t    + ((i & 1) ? nunits : 0));\n@@ -533,8 +534,9 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n       op = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n       if (optab_handler (op, mode) != CODE_FOR_nothing)\n \t{\n-\t  vec_perm_builder sel (nunits, nunits, 1);\n-\t  for (i = 0; i < nunits; ++i)\n+\t  /* The encoding has a single stepped pattern.  */\n+\t  vec_perm_builder sel (nunits, 1, 3);\n+\t  for (int i = 0; i < 3; ++i)\n \t    sel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n \t  vec_perm_indices indices (sel, 2, nunits);\n \t  if (can_vec_perm_const_p (mode, indices))"}, {"sha": "e9ce42fb9eefed64307792ec2d52d5e73d921877", "filename": "gcc/optabs.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "patch": "@@ -5646,15 +5646,14 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n \t\t\t       NULL, 0, OPTAB_DIRECT);\n   gcc_assert (sel != NULL);\n \n-  /* Broadcast the low byte each element into each of its bytes.  */\n-  vec_perm_builder const_sel (w, w, 1);\n-  for (i = 0; i < w; ++i)\n-    {\n-      int this_e = i / u * u;\n-      if (BYTES_BIG_ENDIAN)\n-\tthis_e += u - 1;\n-      const_sel.quick_push (this_e);\n-    }\n+  /* Broadcast the low byte each element into each of its bytes.\n+     The encoding has U interleaved stepped patterns, one for each\n+     byte of an element.  */\n+  vec_perm_builder const_sel (w, u, 3);\n+  unsigned int low_byte_in_u = BYTES_BIG_ENDIAN ? u - 1 : 0;\n+  for (i = 0; i < 3; ++i)\n+    for (unsigned int j = 0; j < u; ++j)\n+      const_sel.quick_push (i * u + low_byte_in_u);\n   sel = gen_lowpart (qimode, sel);\n   sel = expand_vec_perm_const (qimode, sel, sel, const_sel, qimode, NULL);\n   gcc_assert (sel != NULL);\n@@ -5895,16 +5894,20 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n   expand_insn (optab_handler (tab2, mode), 3, eops);\n   m2 = gen_lowpart (mode, eops[0].value);\n \n-  vec_perm_builder sel (nunits, nunits, 1);\n+  vec_perm_builder sel;\n   if (method == 2)\n     {\n-      for (i = 0; i < nunits; ++i)\n+      /* The encoding has 2 interleaved stepped patterns.  */\n+      sel.new_vector (nunits, 2, 3);\n+      for (i = 0; i < 6; ++i)\n \tsel.quick_push (!BYTES_BIG_ENDIAN + (i & ~1)\n \t\t\t+ ((i & 1) ? nunits : 0));\n     }\n   else\n     {\n-      for (i = 0; i < nunits; ++i)\n+      /* The encoding has a single interleaved stepped pattern.  */\n+      sel.new_vector (nunits, 1, 3);\n+      for (i = 0; i < 3; ++i)\n \tsel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n     }\n "}, {"sha": "594e06a0a61513d76fa27f8e54dd0610d586dbb7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "patch": "@@ -4579,14 +4579,13 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int i, nelt = GET_MODE_NUNITS (mode);\n-      vec_perm_builder sel (nelt, nelt, 1);\n-      sel.quick_grow (nelt);\n-\n       if (count == 3)\n \t{\n \t  unsigned int j0 = 0, j1 = 0, j2 = 0;\n \t  unsigned int i, j;\n \n+\t  vec_perm_builder sel (nelt, nelt, 1);\n+\t  sel.quick_grow (nelt);\n \t  vec_perm_indices indices;\n \t  for (j = 0; j < 3; j++)\n \t    {\n@@ -4636,15 +4635,18 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t  /* If length is not equal to 3 then only power of 2 is supported.  */\n \t  gcc_assert (pow2p_hwi (count));\n \n-\t  for (i = 0; i < nelt / 2; i++)\n+\t  /* The encoding has 2 interleaved stepped patterns.  */\n+\t  vec_perm_builder sel (nelt, 2, 3);\n+\t  sel.quick_grow (6);\n+\t  for (i = 0; i < 3; i++)\n \t    {\n \t      sel[i * 2] = i;\n \t      sel[i * 2 + 1] = i + nelt;\n \t    }\n \t  vec_perm_indices indices (sel, 2, nelt);\n \t  if (can_vec_perm_const_p (mode, indices))\n \t    {\n-\t      for (i = 0; i < nelt; i++)\n+\t      for (i = 0; i < 6; i++)\n \t\tsel[i] += nelt / 2;\n \t      indices.new_vector (sel, 2, nelt);\n \t      if (can_vec_perm_const_p (mode, indices))\n@@ -4749,9 +4751,6 @@ vect_permute_store_chain (vec<tree> dr_chain,\n   unsigned int i, n, log_length = exact_log2 (length);\n   unsigned int j, nelt = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  vec_perm_builder sel (nelt, nelt, 1);\n-  sel.quick_grow (nelt);\n-\n   result_chain->quick_grow (length);\n   memcpy (result_chain->address (), dr_chain.address (),\n \t  length * sizeof (tree));\n@@ -4760,6 +4759,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n     {\n       unsigned int j0 = 0, j1 = 0, j2 = 0;\n \n+      vec_perm_builder sel (nelt, nelt, 1);\n+      sel.quick_grow (nelt);\n       vec_perm_indices indices;\n       for (j = 0; j < 3; j++)\n         {\n@@ -4821,15 +4822,18 @@ vect_permute_store_chain (vec<tree> dr_chain,\n       /* If length is not equal to 3 then only power of 2 is supported.  */\n       gcc_assert (pow2p_hwi (length));\n \n-      for (i = 0, n = nelt / 2; i < n; i++)\n+      /* The encoding has 2 interleaved stepped patterns.  */\n+      vec_perm_builder sel (nelt, 2, 3);\n+      sel.quick_grow (6);\n+      for (i = 0; i < 3; i++)\n \t{\n \t  sel[i * 2] = i;\n \t  sel[i * 2 + 1] = i + nelt;\n \t}\n \tvec_perm_indices indices (sel, 2, nelt);\n \tperm_mask_high = vect_gen_perm_mask_checked (vectype, indices);\n \n-\tfor (i = 0; i < nelt; i++)\n+\tfor (i = 0; i < 6; i++)\n \t  sel[i] += nelt / 2;\n \tindices.new_vector (sel, 2, nelt);\n \tperm_mask_low = vect_gen_perm_mask_checked (vectype, indices);\n@@ -5177,11 +5181,11 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int i, j, nelt = GET_MODE_NUNITS (mode);\n-      vec_perm_builder sel (nelt, nelt, 1);\n-      sel.quick_grow (nelt);\n \n       if (count == 3)\n \t{\n+\t  vec_perm_builder sel (nelt, nelt, 1);\n+\t  sel.quick_grow (nelt);\n \t  vec_perm_indices indices;\n \t  unsigned int k;\n \t  for (k = 0; k < 3; k++)\n@@ -5222,12 +5226,15 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t  /* If length is not equal to 3 then only power of 2 is supported.  */\n \t  gcc_assert (pow2p_hwi (count));\n \n-\t  for (i = 0; i < nelt; i++)\n+\t  /* The encoding has a single stepped pattern.  */\n+\t  vec_perm_builder sel (nelt, 1, 3);\n+\t  sel.quick_grow (3);\n+\t  for (i = 0; i < 3; i++)\n \t    sel[i] = i * 2;\n \t  vec_perm_indices indices (sel, 2, nelt);\n \t  if (can_vec_perm_const_p (mode, indices))\n \t    {\n-\t      for (i = 0; i < nelt; i++)\n+\t      for (i = 0; i < 3; i++)\n \t\tsel[i] = i * 2 + 1;\n \t      indices.new_vector (sel, 2, nelt);\n \t      if (can_vec_perm_const_p (mode, indices))\n@@ -5345,9 +5352,6 @@ vect_permute_load_chain (vec<tree> dr_chain,\n   unsigned int i, j, log_length = exact_log2 (length);\n   unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  vec_perm_builder sel (nelt, nelt, 1);\n-  sel.quick_grow (nelt);\n-\n   result_chain->quick_grow (length);\n   memcpy (result_chain->address (), dr_chain.address (),\n \t  length * sizeof (tree));\n@@ -5356,6 +5360,8 @@ vect_permute_load_chain (vec<tree> dr_chain,\n     {\n       unsigned int k;\n \n+      vec_perm_builder sel (nelt, nelt, 1);\n+      sel.quick_grow (nelt);\n       vec_perm_indices indices;\n       for (k = 0; k < 3; k++)\n \t{\n@@ -5403,12 +5409,15 @@ vect_permute_load_chain (vec<tree> dr_chain,\n       /* If length is not equal to 3 then only power of 2 is supported.  */\n       gcc_assert (pow2p_hwi (length));\n \n-      for (i = 0; i < nelt; ++i)\n+      /* The encoding has a single stepped pattern.  */\n+      vec_perm_builder sel (nelt, 1, 3);\n+      sel.quick_grow (3);\n+      for (i = 0; i < 3; ++i)\n \tsel[i] = i * 2;\n       vec_perm_indices indices (sel, 2, nelt);\n       perm_mask_even = vect_gen_perm_mask_checked (vectype, indices);\n \n-      for (i = 0; i < nelt; ++i)\n+      for (i = 0; i < 3; ++i)\n \tsel[i] = i * 2 + 1;\n       indices.new_vector (sel, 2, nelt);\n       perm_mask_odd = vect_gen_perm_mask_checked (vectype, indices);"}, {"sha": "31a396b8790f543924f3c19d35da1a5aceda4687", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "patch": "@@ -3715,8 +3715,10 @@ static void\n calc_vec_perm_mask_for_shift (unsigned int offset, unsigned int nelt,\n \t\t\t      vec_perm_builder *sel)\n {\n-  sel->new_vector (nelt, nelt, 1);\n-  for (unsigned int i = 0; i < nelt; i++)\n+  /* The encoding is a single stepped pattern.  Any wrap-around is handled\n+     by vec_perm_indices.  */\n+  sel->new_vector (nelt, 1, 3);\n+  for (unsigned int i = 0; i < 3; i++)\n     sel->quick_push (i + offset);\n }\n "}, {"sha": "0f77567c9d918cd13b22d4616831a7e8a6809cac", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d980067b1e9394b2b8482b3fc888ac5e8e3ebe59/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d980067b1e9394b2b8482b3fc888ac5e8e3ebe59", "patch": "@@ -1717,8 +1717,9 @@ perm_mask_for_reverse (tree vectype)\n \n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  vec_perm_builder sel (nunits, nunits, 1);\n-  for (i = 0; i < nunits; ++i)\n+  /* The encoding has a single stepped pattern.  */\n+  vec_perm_builder sel (nunits, 1, 3);\n+  for (i = 0; i < 3; ++i)\n     sel.quick_push (nunits - 1 - i);\n \n   vec_perm_indices indices (sel, 1, nunits);\n@@ -2504,8 +2505,9 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n   unsigned int num_bytes = TYPE_VECTOR_SUBPARTS (char_vectype);\n   unsigned word_bytes = num_bytes / nunits;\n \n-  vec_perm_builder elts (num_bytes, num_bytes, 1);\n-  for (unsigned i = 0; i < nunits; ++i)\n+  /* The encoding uses one stepped pattern for each byte in the word.  */\n+  vec_perm_builder elts (num_bytes, word_bytes, 3);\n+  for (unsigned i = 0; i < 3; ++i)\n     for (unsigned j = 0; j < word_bytes; ++j)\n       elts.quick_push ((i + 1) * word_bytes - j - 1);\n "}]}