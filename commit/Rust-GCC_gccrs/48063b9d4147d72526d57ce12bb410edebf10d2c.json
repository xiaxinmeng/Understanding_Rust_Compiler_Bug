{"sha": "48063b9d4147d72526d57ce12bb410edebf10d2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgwNjNiOWQ0MTQ3ZDcyNTI2ZDU3Y2UxMmJiNDEwZWRlYmYxMGQyYw==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2013-06-04T16:16:58Z"}, "committer": {"name": "Ian Bolton", "email": "ibolton@gcc.gnu.org", "date": "2013-06-04T16:16:58Z"}, "message": "AArch64 - Improve MOVI handling (3/5)\n\nFrom-SVN: r199656", "tree": {"sha": "56a98ff7ccc07ea25c37340027397860e25d0e34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56a98ff7ccc07ea25c37340027397860e25d0e34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48063b9d4147d72526d57ce12bb410edebf10d2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48063b9d4147d72526d57ce12bb410edebf10d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48063b9d4147d72526d57ce12bb410edebf10d2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48063b9d4147d72526d57ce12bb410edebf10d2c/comments", "author": null, "committer": null, "parents": [{"sha": "3ea63f60c0ba5650378fb1f5301cbe1245060a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea63f60c0ba5650378fb1f5301cbe1245060a71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea63f60c0ba5650378fb1f5301cbe1245060a71"}], "stats": {"total": 175, "additions": 96, "deletions": 79}, "files": [{"sha": "bf163a3f16ace870419466e9615445702399032c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48063b9d4147d72526d57ce12bb410edebf10d2c", "patch": "@@ -1,3 +1,18 @@\n+2013-06-04  Ian Bolton  <ian.bolton@arm.com>\n+\n+\t* config/aarch64/aarch64.c (simd_immediate_info): Struct to hold\n+\tinformation completed by aarch64_simd_valid_immediate.\n+\t(aarch64_legitimate_constant_p): Update arguments.\n+\t(aarch64_simd_valid_immediate): Work with struct rather than many\n+\tpointers.\n+\t(aarch64_simd_scalar_immediate_valid_for_move): Update arguments.\n+\t(aarch64_simd_make_constant): Update arguments.\n+\t(aarch64_output_simd_mov_immediate): Work with struct rather than\n+\tmany pointers.  Output immediate directly rather than as operand.\n+\t* config/aarch64/aarch64-protos.h (aarch64_simd_valid_immediate):\n+\tUpdate prototype.\n+\t* config/aarch64/constraints.md (Dn): Update arguments.\n+\n 2013-06-04  Ian Bolton  <ian.bolton@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_simd_valid_immediate): No"}, {"sha": "d3d9223d16c5cbc20eb655a21ee553bdd0b08ab0", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=48063b9d4147d72526d57ce12bb410edebf10d2c", "patch": "@@ -157,8 +157,8 @@ bool aarch64_simd_imm_scalar_p (rtx x, enum machine_mode mode);\n bool aarch64_simd_imm_zero_p (rtx, enum machine_mode);\n bool aarch64_simd_scalar_immediate_valid_for_move (rtx, enum machine_mode);\n bool aarch64_simd_shift_imm_p (rtx, enum machine_mode, bool);\n-bool aarch64_simd_valid_immediate (rtx, enum machine_mode, int, rtx *,\n-\t\t\t\t   int *, unsigned char *, int *, int *);\n+bool aarch64_simd_valid_immediate (rtx, enum machine_mode, bool,\n+\t\t\t\t   struct simd_immediate_info *);\n bool aarch64_symbolic_address_p (rtx);\n bool aarch64_symbolic_constant_p (rtx, enum aarch64_symbol_context,\n \t\t\t\t  enum aarch64_symbol_type *);"}, {"sha": "12a7c336a99f3f3651d7db160813e548fac9c24e", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 77, "deletions": 74, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=48063b9d4147d72526d57ce12bb410edebf10d2c", "patch": "@@ -87,6 +87,15 @@ struct aarch64_address_info {\n   enum aarch64_symbol_type symbol_type;\n };\n \n+struct simd_immediate_info\n+{\n+  rtx value;\n+  int shift;\n+  int element_width;\n+  unsigned char element_char;\n+  bool mvn;\n+};\n+\n /* The current code model.  */\n enum aarch64_code_model aarch64_cmodel;\n \n@@ -5150,8 +5159,7 @@ aarch64_legitimate_constant_p (enum machine_mode mode, rtx x)\n   /* This could probably go away because\n      we now decompose CONST_INTs according to expand_mov_immediate.  */\n   if ((GET_CODE (x) == CONST_VECTOR\n-       && aarch64_simd_valid_immediate (x, mode, false,\n-\t\t\t\t\tNULL, NULL, NULL, NULL, NULL))\n+       && aarch64_simd_valid_immediate (x, mode, false, NULL))\n       || CONST_INT_P (x) || aarch64_valid_floating_const (mode, x))\n \treturn !targetm.cannot_force_const_mem (mode, x);\n \n@@ -6144,10 +6152,8 @@ aarch64_vect_float_const_representable_p (rtx x)\n \n /* Return true for valid and false for invalid.  */\n bool\n-aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n-\t\t\t      rtx *modconst, int *elementwidth,\n-\t\t\t      unsigned char *elementchar,\n-\t\t\t      int *mvn, int *shift)\n+aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n+\t\t\t      struct simd_immediate_info *info)\n {\n #define CHECK(STRIDE, ELSIZE, CLASS, TEST, SHIFT, NEG)\t\\\n   matches = 1;\t\t\t\t\t\t\\\n@@ -6181,17 +6187,14 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n \t    || aarch64_vect_float_const_representable_p (op)))\n \treturn false;\n \n-      if (modconst)\n-\t*modconst = CONST_VECTOR_ELT (op, 0);\n-\n-      if (elementwidth)\n-\t*elementwidth = elem_width;\n-\n-      if (elementchar)\n-\t*elementchar = sizetochar (elem_width);\n-\n-      if (shift)\n-\t*shift = 0;\n+      if (info)\n+\t{\n+\t  info->value = CONST_VECTOR_ELT (op, 0);\n+\t  info->element_width = elem_width;\n+\t  info->element_char = sizetochar (elem_width);\n+\t  info->mvn = false;\n+\t  info->shift = 0;\n+\t}\n \n       return true;\n     }\n@@ -6293,21 +6296,13 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n       || immtype == 18)\n     return false;\n \n-\n-  if (elementwidth)\n-    *elementwidth = elsize;\n-\n-  if (elementchar)\n-    *elementchar = elchar;\n-\n-  if (mvn)\n-    *mvn = emvn;\n-\n-  if (shift)\n-    *shift = eshift;\n-\n-  if (modconst)\n+  if (info)\n     {\n+      info->element_width = elsize;\n+      info->element_char = elchar;\n+      info->mvn = emvn != 0;\n+      info->shift = eshift;\n+\n       unsigned HOST_WIDE_INT imm = 0;\n \n       /* Un-invert bytes of recognized vector, if necessary.  */\n@@ -6324,26 +6319,24 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n             imm |= (unsigned HOST_WIDE_INT) (bytes[i] ? 0xff : 0)\n \t      << (i * BITS_PER_UNIT);\n \n-          *modconst = GEN_INT (imm);\n-        }\n-      else\n-        {\n-          unsigned HOST_WIDE_INT imm = 0;\n \n-          for (i = 0; i < elsize / BITS_PER_UNIT; i++)\n-            imm |= (unsigned HOST_WIDE_INT) bytes[i] << (i * BITS_PER_UNIT);\n+\t  info->value = GEN_INT (imm);\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < elsize / BITS_PER_UNIT; i++)\n+\t    imm |= (unsigned HOST_WIDE_INT) bytes[i] << (i * BITS_PER_UNIT);\n \n \t  /* Construct 'abcdefgh' because the assembler cannot handle\n-\t     generic constants.  */\n-\t  gcc_assert (shift != NULL && mvn != NULL);\n-\t  if (*mvn)\n+\t     generic constants.\t */\n+\t  if (info->mvn)\n \t    imm = ~imm;\n-\t  imm = (imm >> *shift) & 0xff;\n-          *modconst = GEN_INT (imm);\n-        }\n+\t  imm = (imm >> info->shift) & 0xff;\n+\t  info->value = GEN_INT (imm);\n+\t}\n     }\n \n-  return (immtype >= 0);\n+  return true;\n #undef CHECK\n }\n \n@@ -6451,8 +6444,7 @@ aarch64_simd_scalar_immediate_valid_for_move (rtx op, enum machine_mode mode)\n   gcc_assert (!VECTOR_MODE_P (mode));\n   vmode = aarch64_preferred_simd_mode (mode);\n   rtx op_v = aarch64_simd_gen_const_vector_dup (vmode, INTVAL (op));\n-  return aarch64_simd_valid_immediate (op_v, vmode, 0, NULL,\n-\t\t\t\t       NULL, NULL, NULL, NULL);\n+  return aarch64_simd_valid_immediate (op_v, vmode, false, NULL);\n }\n \n /* Construct and return a PARALLEL RTX vector.  */\n@@ -6680,8 +6672,7 @@ aarch64_simd_make_constant (rtx vals)\n     gcc_unreachable ();\n \n   if (const_vec != NULL_RTX\n-      && aarch64_simd_valid_immediate (const_vec, mode, 0, NULL,\n-\t\t\t\t       NULL, NULL, NULL, NULL))\n+      && aarch64_simd_valid_immediate (const_vec, mode, false, NULL))\n     /* Load using MOVI/MVNI.  */\n     return const_vec;\n   else if ((const_dup = aarch64_simd_dup_constant (vals)) != NULL_RTX)\n@@ -7244,45 +7235,57 @@ aarch64_output_simd_mov_immediate (rtx *const_vector,\n \t\t\t\t   unsigned width)\n {\n   bool is_valid;\n-  unsigned char widthc;\n-  int lane_width_bits;\n   static char templ[40];\n-  int shift = 0, mvn = 0;\n   const char *mnemonic;\n   unsigned int lane_count = 0;\n \n-/* This will return true to show const_vector is legal for use as either\n-   a AdvSIMD MOVI instruction (or, implicitly, MVNI) immediate.  It\n-   writes back various values via the int pointers and it modifies the\n-   operand pointed to by CONST_VECTOR in-place, if required.  */\n-  is_valid =\n-    aarch64_simd_valid_immediate (*const_vector, mode, 0,\n-\t\t\t\t  const_vector, &lane_width_bits,\n-\t\t\t\t  &widthc, &mvn, &shift);\n+  struct simd_immediate_info info;\n+\n+  /* This will return true to show const_vector is legal for use as either\n+     a AdvSIMD MOVI instruction (or, implicitly, MVNI) immediate.  It will\n+     also update INFO to show how the immediate should be generated.  */\n+  is_valid = aarch64_simd_valid_immediate (*const_vector, mode, false, &info);\n   gcc_assert (is_valid);\n \n+  gcc_assert (info.element_width != 0);\n+  lane_count = width / info.element_width;\n+\n   mode = GET_MODE_INNER (mode);\n   if (mode == SFmode || mode == DFmode)\n     {\n-      bool zero_p =\n-\taarch64_float_const_zero_rtx_p (*const_vector);\n-      gcc_assert (shift == 0);\n-      mnemonic = zero_p ? \"movi\" : \"fmov\";\n+      gcc_assert (info.shift == 0 && ! info.mvn);\n+      if (aarch64_float_const_zero_rtx_p (info.value))\n+        info.value = GEN_INT (0);\n+      else\n+\t{\n+#define buf_size 20\n+\t  REAL_VALUE_TYPE r;\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, info.value);\n+\t  char float_buf[buf_size] = {'\\0'};\n+\t  real_to_decimal_for_mode (float_buf, &r, buf_size, buf_size, 1, mode);\n+#undef buf_size\n+\n+\t  if (lane_count == 1)\n+\t    snprintf (templ, sizeof (templ), \"fmov\\t%%d0, %s\", float_buf);\n+\t  else\n+\t    snprintf (templ, sizeof (templ), \"fmov\\t%%0.%d%c, %s\",\n+\t\t      lane_count, info.element_char, float_buf);\n+\t  return templ;\n+\t}\n     }\n-  else\n-    mnemonic = mvn ? \"mvni\" : \"movi\";\n \n-  gcc_assert (lane_width_bits != 0);\n-  lane_count = width / lane_width_bits;\n+  mnemonic = info.mvn ? \"mvni\" : \"movi\";\n \n   if (lane_count == 1)\n-    snprintf (templ, sizeof (templ), \"%s\\t%%d0, %%1\", mnemonic);\n-  else if (shift)\n-    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, %%1, lsl %d\",\n-\t      mnemonic, lane_count, widthc, shift);\n+    snprintf (templ, sizeof (templ), \"%s\\t%%d0, \" HOST_WIDE_INT_PRINT_HEX,\n+\t      mnemonic, UINTVAL (info.value));\n+  else if (info.shift)\n+    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \" HOST_WIDE_INT_PRINT_HEX\n+\t      \", lsl %d\", mnemonic, lane_count, info.element_char,\n+\t      UINTVAL (info.value), info.shift);\n   else\n-    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, %%1\",\n-\t      mnemonic, lane_count, widthc);\n+    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \" HOST_WIDE_INT_PRINT_HEX,\n+\t      mnemonic, lane_count, info.element_char, UINTVAL (info.value));\n   return templ;\n }\n "}, {"sha": "7cafc08fdd9f3c028b9cf9f30be2e5ccf670e398", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48063b9d4147d72526d57ce12bb410edebf10d2c/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=48063b9d4147d72526d57ce12bb410edebf10d2c", "patch": "@@ -143,9 +143,8 @@\n   \"@internal\n  A constraint that matches vector of immediates.\"\n  (and (match_code \"const_vector\")\n-      (match_test \"aarch64_simd_valid_immediate (op, GET_MODE (op), 0,\n-\t\t\t\t\t\t NULL, NULL, NULL,\n-\t\t\t\t\t\t NULL, NULL)\")))\n+      (match_test \"aarch64_simd_valid_immediate (op, GET_MODE (op),\n+\t\t\t\t\t\t false, NULL)\")))\n \n (define_constraint \"Dh\"\n   \"@internal"}]}