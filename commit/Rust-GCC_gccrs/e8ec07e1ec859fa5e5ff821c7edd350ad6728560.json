{"sha": "e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlYzA3ZTFlYzg1OWZhNWU1ZmY4MjFjN2VkZDM1MGFkNjcyODU2MA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-01T07:39:08Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-10-01T07:39:08Z"}, "message": "re PR fortran/16404 (should reject invalid code with -pedantic -std=f95 ? (x8))\n\n2005-10-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16404\n\tPR fortran/20835\n\tPR fortran/20890\n\tPR fortran/20899\n\tPR fortran/20900\n\tPR fortran/20901\n\tPR fortran/20902\n\t* gfortran.h: Prototype for gfc_add_in_equivalence.\n\t* match.c (gfc_match_equivalence): Make a structure component\n\tan explicit,rather than a syntax, error in an equivalence\n\tgroup.  Call gfc_add_in_equivalence to add the constraints\n\timposed in check_conflict.\n\t* resolve.c (resolve_symbol): Add constraints: No public\n\tstructures with private-type components and no public\n\tprocedures with private-type dummy arguments.\n\t(resolve_equivalence_derived): Add constraint that prevents\n\ta structure equivalence member from having a default\n\tinitializer.\n\t(sequence_type): New static function to determine whether an\n\tobject is default numeric, default character, non-default\n\tor mixed sequence. Add corresponding enum typespec.\n\t(resolve_equivalence): Add constraints to equivalence groups\n\tor their members: No more than one initialized member and\n\tthat different types are not equivalenced for std=f95.  All\n\tthe simple constraints have been moved to check_conflict.\n\t* symbol.c (check_conflict): Simple equivalence constraints\n\tadded, including those removed from resolve_symbol.\n\t(gfc_add_in_equivalence): New function to interface calls\n\tmatch_equivalence to check_conflict.\n\n2005-10-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16404\n\tPR fortran/20835\n\tPR fortran/20890\n\tPR fortran/20899\n\tPR fortran/20900\n\tPR fortran/20901\n\tPR fortran/20902\n\tgfortran.dg/equiv_constraint_1.f90: New test.\n\tgfortran.dg/equiv_constraint_2.f90: New test.\n\tgfortran.dg/equiv_constraint_3.f90: New test.\n\tgfortran.dg/equiv_constraint_4.f90: New test.\n\tgfortran.dg/equiv_constraint_5.f90: New test.\n\tgfortran.dg/equiv_constraint_6.f90: New test.\n\tgfortran.dg/equiv_constraint_7.f90: New test.\n\tgfortran.dg/equiv_constraint_8.f90: New test.\n\tgfortran.dg/private_type_1.f90: New test.\n\tgfortran.dg/private_type_2.f90: New test.\n\tgfortran.dg/g77/980628-2.f, 980628-3.f, 980628-9.f,\n\t980628-10.f: Assert std=gnu to permit mixing of\n\ttypes in equivalence statements.\n\nFrom-SVN: r104850", "tree": {"sha": "4f7afb184987461657573418267617d9f5e4ef27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f7afb184987461657573418267617d9f5e4ef27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/comments", "author": null, "committer": null, "parents": [{"sha": "0363db460d75a19d143a437479e2e122743430c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0363db460d75a19d143a437479e2e122743430c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0363db460d75a19d143a437479e2e122743430c7"}], "stats": {"total": 562, "additions": 523, "deletions": 39}, "files": [{"sha": "145d10be62f0c6e664e26ba501b42060437cdb2a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -1,3 +1,35 @@\n+2005-10-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/16404\n+\tPR fortran/20835\n+\tPR fortran/20890\n+\tPR fortran/20899\n+\tPR fortran/20900\n+\tPR fortran/20901\n+\tPR fortran/20902\n+\t* gfortran.h: Prototype for gfc_add_in_equivalence.\n+\t* match.c (gfc_match_equivalence): Make a structure component\n+\tan explicit,rather than a syntax, error in an equivalence\n+\tgroup.  Call gfc_add_in_equivalence to add the constraints\n+\timposed in check_conflict.\n+\t* resolve.c (resolve_symbol): Add constraints: No public\n+\tstructures with private-type components and no public\n+\tprocedures with private-type dummy arguments.\n+\t(resolve_equivalence_derived): Add constraint that prevents\n+\ta structure equivalence member from having a default\n+\tinitializer.\n+\t(sequence_type): New static function to determine whether an\n+\tobject is default numeric, default character, non-default\n+\tor mixed sequence. Add corresponding enum typespec.\n+\t(resolve_equivalence): Add constraints to equivalence groups\n+\tor their members: No more than one initialized member and\n+\tthat different types are not equivalenced for std=f95.  All\n+\tthe simple constraints have been moved to check_conflict.\n+\t* symbol.c (check_conflict): Simple equivalence constraints\n+\tadded, including those removed from resolve_symbol.\n+\t(gfc_add_in_equivalence): New function to interface calls\n+\tmatch_equivalence to check_conflict.\n+\n 2005-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/18518"}, {"sha": "1923826d7bd3d17b1419d0fd6668891ff602fbc8", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -1639,6 +1639,7 @@ try gfc_add_dummy (symbol_attribute *, const char *, locus *);\n try gfc_add_generic (symbol_attribute *, const char *, locus *);\n try gfc_add_common (symbol_attribute *, locus *);\n try gfc_add_in_common (symbol_attribute *, const char *, locus *);\n+try gfc_add_in_equivalence (symbol_attribute *, const char *, locus *);\n try gfc_add_data (symbol_attribute *, const char *, locus *);\n try gfc_add_in_namelist (symbol_attribute *, const char *, locus *);\n try gfc_add_sequence (symbol_attribute *, const char *, locus *);"}, {"sha": "3f9487414a2f9eaf60990fdaf243cce8e80a377f", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -2622,6 +2622,13 @@ gfc_match_equivalence (void)\n \t  if (m == MATCH_NO)\n \t    goto syntax;\n \n+\t  if (gfc_match_char ('%') == MATCH_YES)\n+\t    {\n+\t      gfc_error (\"Derived type component %C is not a \"\n+\t\t\t \"permitted EQUIVALENCE member\");\n+\t      goto cleanup;\n+\t    }\n+\n \t  for (ref = set->expr->ref; ref; ref = ref->next)\n \t    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)\n \t      {\n@@ -2631,14 +2638,18 @@ gfc_match_equivalence (void)\n \t\tgoto cleanup;\n \t      }\n \n-\t  if (set->expr->symtree->n.sym->attr.in_common)\n+\t  sym = set->expr->symtree->n.sym;\n+\n+\t  if (gfc_add_in_equivalence (&sym->attr, sym->name, NULL)\n+\t\t== FAILURE)\n+\t    goto cleanup;\n+\n+\t  if (sym->attr.in_common)\n \t    {\n \t      common_flag = TRUE;\n-\t      common_head = set->expr->symtree->n.sym->common_head;\n+\t      common_head = sym->common_head;\n \t    }\n \n-\t  set->expr->symtree->n.sym->attr.in_equivalence = 1;\n-\n \t  if (gfc_match_char (')') == MATCH_YES)\n \t    break;\n \t  if (gfc_match_char (',') != MATCH_YES)"}, {"sha": "192a18c372c3dea6bf50c7ae327b35055b4faf6f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 223, "deletions": 34, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -25,6 +25,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor,Boston, MA\n #include \"gfortran.h\"\n #include \"arith.h\"  /* For gfc_compare_expr().  */\n \n+/* Types used in equivalence statements.  */\n+\n+typedef enum seq_type\n+{\n+  SEQ_NONDEFAULT, SEQ_NUMERIC, SEQ_CHARACTER, SEQ_MIXED\n+}\n+seq_type;\n \n /* Stack to push the current if we descend into a block during\n    resolution.  See resolve_branch() and resolve_code().  */\n@@ -4124,6 +4131,8 @@ resolve_symbol (gfc_symbol * sym)\n   gfc_symtree * symtree;\n   gfc_symtree * this_symtree;\n   gfc_namespace * ns;\n+  gfc_component * c;\n+  gfc_formal_arglist * arg;\n \n   if (sym->attr.flavor == FL_UNKNOWN)\n     {\n@@ -4274,6 +4283,48 @@ resolve_symbol (gfc_symbol * sym)\n         }\n     }\n \n+  /* Ensure that derived type components of a public derived type\n+     are not of a private type.  */\n+  if (sym->attr.flavor == FL_DERIVED\n+\t&& gfc_check_access(sym->attr.access, sym->ns->default_access))\n+    {\n+      for (c = sym->components; c; c = c->next)\n+\t{\n+\t  if (c->ts.type == BT_DERIVED\n+\t\t&& !c->ts.derived->attr.use_assoc\n+\t\t&& !gfc_check_access(c->ts.derived->attr.access,\n+\t\t\t\t     c->ts.derived->ns->default_access))\n+\t    {\n+\t      gfc_error (\"The component '%s' is a PRIVATE type and cannot be \"\n+\t\t\t \"a component of '%s', which is PUBLIC at %L\",\n+\t\t\t c->name, sym->name, &sym->declared_at);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  /* Ensure that derived type formal arguments of a public procedure\n+     are not of a private type.  */\n+  if (sym->attr.flavor == FL_PROCEDURE\n+\t&& gfc_check_access(sym->attr.access, sym->ns->default_access))\n+    {\n+      for (arg = sym->formal; arg; arg = arg->next)\n+\t{\n+\t  if (arg->sym\n+\t\t&& arg->sym->ts.type == BT_DERIVED\n+\t\t&& !gfc_check_access(arg->sym->ts.derived->attr.access,\n+\t\t\t\t     arg->sym->ts.derived->ns->default_access))\n+\t    {\n+\t      gfc_error_now (\"'%s' is a PRIVATE type and cannot be \"\n+\t\t\t     \"a dummy argument of '%s', which is PUBLIC at %L\",\n+\t\t\t     arg->sym->name, sym->name, &sym->declared_at);\n+\t      /* Stop this message from recurring.  */\n+\t      arg->sym->ts.derived->attr.access = ACCESS_PUBLIC;\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n   /* Constraints on deferred shape variable.  */\n   if (sym->attr.flavor == FL_VARIABLE\n       || (sym->attr.flavor == FL_PROCEDURE\n@@ -4802,6 +4853,65 @@ warn_unused_label (gfc_namespace * ns)\n }\n \n \n+/* Returns the sequence type of a symbol or sequence.  */\n+\n+static seq_type\n+sequence_type (gfc_typespec ts)\n+{\n+  seq_type result;\n+  gfc_component *c;\n+\n+  switch (ts.type)\n+  {\n+    case BT_DERIVED:\n+\n+      if (ts.derived->components == NULL)\n+\treturn SEQ_NONDEFAULT;\n+\n+      result = sequence_type (ts.derived->components->ts);\n+      for (c = ts.derived->components->next; c; c = c->next)\n+\tif (sequence_type (c->ts) != result)\n+\t  return SEQ_MIXED;\n+\n+      return result;\n+\n+    case BT_CHARACTER:\n+      if (ts.kind != gfc_default_character_kind)\n+\t  return SEQ_NONDEFAULT;\n+\n+      return SEQ_CHARACTER;\n+\n+    case BT_INTEGER:\n+      if (ts.kind != gfc_default_integer_kind)\n+\t  return SEQ_NONDEFAULT;\n+\n+      return SEQ_NUMERIC;\n+\n+    case BT_REAL:\n+      if (!(ts.kind == gfc_default_real_kind\n+\t     || ts.kind == gfc_default_double_kind))\n+\t  return SEQ_NONDEFAULT;\n+\n+      return SEQ_NUMERIC;\n+\n+    case BT_COMPLEX:\n+      if (ts.kind != gfc_default_complex_kind)\n+\t  return SEQ_NONDEFAULT;\n+\n+      return SEQ_NUMERIC;\n+\n+    case BT_LOGICAL:\n+      if (ts.kind != gfc_default_logical_kind)\n+\t  return SEQ_NONDEFAULT;\n+\n+      return SEQ_NUMERIC;\n+\n+    default:\n+      return SEQ_NONDEFAULT;\n+  }\n+}\n+\n+\n /* Resolve derived type EQUIVALENCE object.  */\n \n static try\n@@ -4831,7 +4941,14 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n          in the structure.  */\n       if (c->pointer)\n         {\n-          gfc_error (\"Derived type variable '%s' at %L has pointer componet(s) \"\n+          gfc_error (\"Derived type variable '%s' at %L with pointer component(s) \"\n+                     \"cannot be an EQUIVALENCE object\", sym->name, &e->where);\n+          return FAILURE;\n+        }\n+\n+      if (c->initializer)\n+        {\n+          gfc_error (\"Derived type variable '%s' at %L with default initializer \"\n                      \"cannot be an EQUIVALENCE object\", sym->name, &e->where);\n           return FAILURE;\n         }\n@@ -4841,22 +4958,38 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n \n \n /* Resolve equivalence object. \n-   An EQUIVALENCE object shall not be a dummy argument, a pointer, an\n-   allocatable array, an object of nonsequence derived type, an object of\n+   An EQUIVALENCE object shall not be a dummy argument, a pointer, a target,\n+   an allocatable array, an object of nonsequence derived type, an object of\n    sequence derived type containing a pointer at any level of component\n    selection, an automatic object, a function name, an entry name, a result\n    name, a named constant, a structure component, or a subobject of any of\n-   the preceding objects.  A substring shall not have length zero.  */\n+   the preceding objects.  A substring shall not have length zero.  A\n+   derived type shall not have components with default initialization nor\n+   shall two objects of an equivalence group be initialized.\n+   The simple constraints are done in symbol.c(check_conflict) and the rest\n+   are implemented here.  */\n \n static void\n resolve_equivalence (gfc_equiv *eq)\n {\n   gfc_symbol *sym;\n   gfc_symbol *derived;\n+  gfc_symbol *first_sym;\n   gfc_expr *e;\n   gfc_ref *r;\n+  locus *last_where = NULL;\n+  seq_type eq_type, last_eq_type;\n+  gfc_typespec *last_ts;\n+  int object;\n+  const char *value_name;\n+  const char *msg;\n+\n+  value_name = NULL;\n+  last_ts = &eq->expr->symtree->n.sym->ts;\n \n-  for (; eq; eq = eq->eq)\n+  first_sym = eq->expr->symtree->n.sym;\n+\n+  for (object = 1; eq; eq = eq->eq, object++)\n     {\n       e = eq->expr;\n \n@@ -4926,38 +5059,31 @@ resolve_equivalence (gfc_equiv *eq)\n         continue;\n \n       sym = e->symtree->n.sym;\n-     \n-      /* Shall not be a dummy argument.  */\n-      if (sym->attr.dummy)\n-        {\n-          gfc_error (\"Dummy argument '%s' at %L cannot be an EQUIVALENCE \"\n-                     \"object\", sym->name, &e->where);\n-          continue;\n-        }\n \n-      /* Shall not be an allocatable array.  */\n-      if (sym->attr.allocatable)\n-        {\n-          gfc_error (\"Allocatable array '%s' at %L cannot be an EQUIVALENCE \"\n-                     \"object\", sym->name, &e->where);\n-          continue;\n-        }\n+      /* An equivalence statement cannot have more than one initialized\n+\t object.  */\n+      if (sym->value)\n+\t{\n+\t  if (value_name != NULL)\n+\t    {\n+\t      gfc_error (\"Initialized objects '%s' and '%s'  cannot both \"\n+\t\t\t \"be in the EQUIVALENCE statement at %L\",\n+\t\t\t value_name, sym->name, &e->where);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    value_name = sym->name;\n+\t}\n \n-      /* Shall not be a pointer.  */\n-      if (sym->attr.pointer)\n+      /* Shall not equivalence common block variables in a PURE procedure.  */\n+      if (sym->ns->proc_name \n+\t    && sym->ns->proc_name->attr.pure\n+\t    && sym->attr.in_common)\n         {\n-          gfc_error (\"Pointer '%s' at %L cannot be an EQUIVALENCE object\",\n-                     sym->name, &e->where);\n-          continue;\n-        }\n-      \n-      /* Shall not be a function name, ...  */\n-      if (sym->attr.function || sym->attr.result || sym->attr.entry\n-          || sym->attr.subroutine)\n-        {\n-          gfc_error (\"Entity '%s' at %L cannot be an EQUIVALENCE object\",\n-                     sym->name, &e->where);\n-          continue;\n+          gfc_error (\"Common block member '%s' at %L cannot be an EQUIVALENCE \"\n+\t\t     \"object in the pure procedure '%s'\",\n+\t\t     sym->name, &e->where, sym->ns->proc_name->name);\n+          break;\n         }\n \n       /* Shall not be a named constant.  */      \n@@ -4972,6 +5098,69 @@ resolve_equivalence (gfc_equiv *eq)\n       if (derived && resolve_equivalence_derived (derived, sym, e) == FAILURE)\n         continue;\n \n+      /* Check that the types correspond correctly:\n+\t Note 5.28:\n+\t A numeric sequence structure may be equivalenced to another sequence\n+\t structure, an object of default integer type, default real type, double\n+\t precision real type, default logical type such that components of the\n+\t structure ultimately only become associated to objects of the same\n+\t kind. A character sequence structure may be equivalenced to an object\n+\t of default character kind or another character sequence structure.\n+\t Other objects may be equivalenced only to objects of the same type and\n+\t kind parameters.  */\n+\n+      /* Identical types are unconditionally OK.  */\n+      if (object == 1 || gfc_compare_types (last_ts, &sym->ts))\n+\tgoto identical_types;\n+\n+      last_eq_type = sequence_type (*last_ts);\n+      eq_type = sequence_type (sym->ts);\n+\n+      /* Since the pair of objects is not of the same type, mixed or\n+\t non-default sequences can be rejected.  */\n+\n+      msg = \"Sequence %s with mixed components in EQUIVALENCE \"\n+\t    \"statement at %L with different type objects\";\n+      if ((object ==2\n+\t       && last_eq_type == SEQ_MIXED\n+\t       && gfc_notify_std (GFC_STD_GNU, msg, first_sym->name,\n+\t\t\t\t  last_where) == FAILURE)\n+\t   ||  (eq_type == SEQ_MIXED\n+\t       && gfc_notify_std (GFC_STD_GNU, msg,sym->name,\n+\t\t\t\t  &e->where) == FAILURE))\n+\tcontinue;\n+\n+      msg = \"Non-default type object or sequence %s in EQUIVALENCE \"\n+\t    \"statement at %L with objects of different type\";\n+      if ((object ==2\n+\t       && last_eq_type == SEQ_NONDEFAULT\n+\t       && gfc_notify_std (GFC_STD_GNU, msg, first_sym->name,\n+\t\t\t\t  last_where) == FAILURE)\n+\t   ||  (eq_type == SEQ_NONDEFAULT\n+\t       && gfc_notify_std (GFC_STD_GNU, msg, sym->name,\n+\t\t\t\t  &e->where) == FAILURE))\n+\tcontinue;\n+\n+      msg =\"Non-CHARACTER object '%s' in default CHARACTER \"\n+\t   \"EQUIVALENCE statement at %L\";\n+      if (last_eq_type == SEQ_CHARACTER\n+\t    && eq_type != SEQ_CHARACTER\n+\t    && gfc_notify_std (GFC_STD_GNU, msg, sym->name,\n+\t\t\t\t  &e->where) == FAILURE)\n+\t\tcontinue;\n+\n+      msg =\"Non-NUMERIC object '%s' in default NUMERIC \"\n+\t   \"EQUIVALENCE statement at %L\";\n+      if (last_eq_type == SEQ_NUMERIC\n+\t    && eq_type != SEQ_NUMERIC\n+\t    && gfc_notify_std (GFC_STD_GNU, msg, sym->name,\n+\t\t\t\t  &e->where) == FAILURE)\n+\t\tcontinue;\n+\n+  identical_types:\n+      last_ts =&sym->ts;\n+      last_where = &e->where;\n+\n       if (!e->ref)\n         continue;\n "}, {"sha": "aceac5b7423e204812aa95f68aac307327bb7544", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -262,7 +262,8 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n     *in_common = \"COMMON\", *result = \"RESULT\", *in_namelist = \"NAMELIST\",\n     *public = \"PUBLIC\", *optional = \"OPTIONAL\", *entry = \"ENTRY\",\n     *function = \"FUNCTION\", *subroutine = \"SUBROUTINE\",\n-    *dimension = \"DIMENSION\";\n+    *dimension = \"DIMENSION\", *in_equivalence = \"EQUIVALENCE\",\n+    *use_assoc = \"USE ASSOCIATED\";\n \n   const char *a1, *a2;\n \n@@ -323,6 +324,15 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   conf (in_common, result);\n   conf (dummy, result);\n \n+  conf (in_equivalence, use_assoc);\n+  conf (in_equivalence, dummy);\n+  conf (in_equivalence, target);\n+  conf (in_equivalence, pointer);\n+  conf (in_equivalence, function);\n+  conf (in_equivalence, result);\n+  conf (in_equivalence, entry);\n+  conf (in_equivalence, allocatable);\n+\n   conf (in_namelist, pointer);\n   conf (in_namelist, allocatable);\n \n@@ -726,6 +736,21 @@ gfc_add_in_common (symbol_attribute * attr, const char *name, locus * where)\n   return gfc_add_flavor (attr, FL_VARIABLE, name, where);\n }\n \n+try\n+gfc_add_in_equivalence (symbol_attribute * attr, const char *name, locus * where)\n+{\n+\n+  /* Duplicate attribute already checked for.  */\n+  attr->in_equivalence = 1;\n+  if (check_conflict (attr, name, where) == FAILURE)\n+    return FAILURE;\n+\n+  if (attr->flavor == FL_VARIABLE)\n+    return SUCCESS;\n+\n+  return gfc_add_flavor (attr, FL_VARIABLE, name, where);\n+}\n+\n \n try\n gfc_add_data (symbol_attribute *attr, const char *name, locus *where)"}, {"sha": "00b067a34a56670f034de34ade91f67b7a4b7442", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -1,3 +1,26 @@\n+2005-10-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/16404\n+\tPR fortran/20835\n+\tPR fortran/20890\n+\tPR fortran/20899\n+\tPR fortran/20900\n+\tPR fortran/20901\n+\tPR fortran/20902\n+\tgfortran.dg/equiv_constraint_1.f90: New test.\n+\tgfortran.dg/equiv_constraint_2.f90: New test.\n+\tgfortran.dg/equiv_constraint_3.f90: New test.\n+\tgfortran.dg/equiv_constraint_4.f90: New test.\n+\tgfortran.dg/equiv_constraint_5.f90: New test.\n+\tgfortran.dg/equiv_constraint_6.f90: New test.\n+\tgfortran.dg/equiv_constraint_7.f90: New test.\n+\tgfortran.dg/equiv_constraint_8.f90: New test.\n+\tgfortran.dg/private_type_1.f90: New test.\n+\tgfortran.dg/private_type_2.f90: New test.\n+\tgfortran.dg/g77/980628-2.f, 980628-3.f, 980628-9.f,\n+\t980628-10.f: Assert std=gnu to permit mixing of\n+\ttypes in equivalence statements.\n+\n 2005-09-30  Janne Blomqvist <jblomqvi@cc.hut.fi>\n \n \tPR 24112"}, {"sha": "75c3aa8131a762a85b39149a6bd0d541c820d449", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_1.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+! PR20901 - F95 constrains mixing of types in equivalence.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+ character(len=4) :: a\n+ integer :: i\n+ equivalence(a,i) ! { dg-error \"in default CHARACTER EQUIVALENCE statement at\" }\n+ END\n+\n+"}, {"sha": "2c3578da0d3a4c559edcba3989f46f298fad947f", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_2.f90", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_2.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,74 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n+! PR20901 - Checks resolution of types in EQUIVALENCE statement when\n+! f95 standard is imposed.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+  type   :: numeric_type\n+    sequence\n+    integer  :: i\n+    real     :: x\n+    real*8   :: d\n+    complex  :: z\n+    logical  :: l\n+  end type numeric_type\n+\n+  type (numeric_type) :: my_num, thy_num\n+\n+  type   :: numeric_type2\n+    sequence\n+    integer  :: i\n+    real     :: x\n+    real*8   :: d\n+    complex  :: z\n+    logical  :: l\n+  end type numeric_type2\n+\n+  type (numeric_type2) :: his_num\n+\n+  type       :: char_type\n+    sequence\n+    character*4 :: ch\n+    character*4 :: cha (6)\n+  end type char_type\n+\n+  type (char_type) ::  my_char\n+\n+  type       :: mixed_type\n+    sequence\n+    integer*4 :: i(4)\n+    character*4 :: cha (6)\n+  end type mixed_type\n+\n+  type (mixed_type) ::  my_mixed, thy_mixed\n+\n+  character(len=4) :: ch\n+  integer :: num\n+  integer*8 :: non_def\n+  complex*16 :: my_z, thy_z\n+\n+! Permitted: character with character sequence\n+!            numeric with numeric sequence\n+!            numeric sequence with numeric sequence\n+!            non-default of same type\n+!            mixed sequences of same type\n+  equivalence (ch, my_char)\n+  equivalence (num, my_num)\n+  equivalence (my_num, his_num, thy_num)\n+  equivalence (my_z, thy_z)\n+  equivalence (my_mixed, thy_mixed)\n+\n+! Not permitted by the standard - OK with -std=gnu\n+  equivalence (my_mixed, my_num) ! { dg-error \"with mixed components in EQUIVALENCE\" }\n+  equivalence (my_z, num) ! { dg-error \"Non-default type object or sequence\" }\n+  equivalence (my_char, my_num) ! { dg-error \"in default CHARACTER EQUIVALENCE\" }\n+  equivalence (ch, my_num) ! { dg-error \"in default CHARACTER EQUIVALENCE\" }\n+  equivalence (my_num, ch) ! { dg-error \"in default NUMERIC EQUIVALENCE\" }\n+  equivalence (num, my_char) ! { dg-error \"in default NUMERIC EQUIVALENCE\" }\n+  equivalence (my_char, num) ! { dg-error \"in default CHARACTER EQUIVALENCE\" }\n+  equivalence (non_def, ch) ! { dg-error \"Non-default type object or sequence\" }\n+  equivalence (my_z, ch) ! { dg-error \"Non-default type object or sequence\" }\n+  equivalence (my_z, num) ! { dg-error \"Non-default type object or sequence\" }\n+ END"}, {"sha": "89d4fcb416c95ff4332a49aa7820f559242b09a3", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_3.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_3.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! PR20900 - USE associated variables cannot be equivalenced.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+MODULE TEST\n+ INTEGER :: I\n+END MODULE\n+! note 11.7\n+USE TEST, ONLY : K=>I\n+INTEGER :: L\n+EQUIVALENCE(K,L) ! { dg-error \"conflicts with USE ASSOCIATED attribute\" }\n+END\n+\n+"}, {"sha": "be9591afbb4cdb724b7b3e1323f9a76d564102b6", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_4.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_4.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-O0\" }\n+! PR20901 - check that derived/numeric equivalence works with std!=f95.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+TYPE data_type\n+ SEQUENCE\n+ INTEGER :: I\n+END TYPE data_type\n+INTEGER :: J = 7\n+TYPE(data_type) :: dd\n+EQUIVALENCE(dd,J)\n+if (dd%i.ne.7) call abort ()\n+END\n+\n+\n+"}, {"sha": "1eefa8121a49a40c063ca134fb2cf1bfe0899d07", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_5.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-O0\" }\n+! PR20902 - Structure with default initializer cannot be equivalence memeber.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+TYPE T1\n+ sequence\n+ integer :: i=1\n+END TYPE T1\n+TYPE T2\n+ sequence\n+ integer :: i      ! drop original initializer to pick up error below.\n+END TYPE T2\n+TYPE(T1) :: a1\n+TYPE(T2) :: a2\n+EQUIVALENCE(a1,a2) ! { dg-error \"initializer cannot be an EQUIVALENCE\" }\n+write(6,*) a1,a2\n+END\n+"}, {"sha": "9cc4c9bbe217510b36a26962942a786e9105c1b1", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_6.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_6.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+! PR16404 test 3 and PR20835 - Target cannot be equivalence object.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+  REAL :: A\n+  REAL, TARGET :: B\n+  EQUIVALENCE(A,B) ! { dg-error \"conflicts with TARGET attribute\" }\n+END\n+"}, {"sha": "ec4579f21dbcab3cd8b170f05d74d749a5705046", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_7.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+! { dg-options \"-O0\" }\n+! PR20890 - Equivalence cannot contain more than one initialized variables.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+ BLOCK DATA\n+  INTEGER :: I=1,J=2\n+  EQUIVALENCE(I,J)  ! { dg-error \"cannot both be in the EQUIVALENCE\" }\n+ END BLOCK DATA\n+ END"}, {"sha": "9a742eec5c42fecd774234c09d2b4f534f6a1e25", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_8.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_8.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! { dg-options \"-O0\" }\n+! PR20899 - Common block variables cannot be equivalenced in a pure procedure.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+common /z/ i\n+contains\n+pure integer function test(j)\n+  integer, intent(in) :: j\n+  common /z/ i\n+  integer :: k\n+  equivalence(i,k) ! { dg-error \"EQUIVALENCE object in the pure\" }\n+  k=1 ! { dg-error \"in PURE procedure at\" }\n+  test=i*j\n+end function test\n+end\n+"}, {"sha": "b7429e4c9cb425e875bbbe543805421d2a65a422", "filename": "gcc/testsuite/gfortran.dg/g77/980628-10.f", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-10.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-10.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-10.f?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -1,4 +1,5 @@\n c { dg-do run }\n+c { dg-options \"-std=gnu\" }\n * g77 0.5.23 and previous had bugs involving too little space\n * allocated for EQUIVALENCE and COMMON areas needing initial\n * padding to meet alignment requirements of the system."}, {"sha": "89a9e235422c94bad5f1f319ecbc358af7a5a8dd", "filename": "gcc/testsuite/gfortran.dg/g77/980628-2.f", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-2.f?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -1,4 +1,5 @@\n c { dg-do run }\n+c { dg-options \"-std=gnu\" }\n * g77 0.5.23 and previous had bugs involving too little space\n * allocated for EQUIVALENCE and COMMON areas needing initial\n * padding to meet alignment requirements of the system."}, {"sha": "dea368d02bde57f40995411f9b444597a47e403d", "filename": "gcc/testsuite/gfortran.dg/g77/980628-3.f", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-3.f?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -1,4 +1,6 @@\n c { dg-do run }\n+c { dg-options \"-std=gnu\" }\n+c\n * g77 0.5.23 and previous had bugs involving too little space\n * allocated for EQUIVALENCE and COMMON areas needing initial\n * padding to meet alignment requirements of the system."}, {"sha": "7e2f2279f2394372c9231e56a3dbef9a0c49ca80", "filename": "gcc/testsuite/gfortran.dg/g77/980628-9.f", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-9.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-9.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980628-9.f?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -1,4 +1,5 @@\n c { dg-do run }\n+c { dg-options \"-std=gnu\" }\n * g77 0.5.23 and previous had bugs involving too little space\n * allocated for EQUIVALENCE and COMMON areas needing initial\n * padding to meet alignment requirements of the system."}, {"sha": "e36e20a5e5ae498a9529a81dfdbe4799ec09432a", "filename": "gcc/testsuite/gfortran.dg/private_type_1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_1.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! PR21986 - test based on original example.\n+! A public subroutine must not have private-type, dummy arguments.\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+module modboom\n+  implicit none\n+  private\n+  public:: dummysub ! { dg-error \"PRIVATE type and cannot be a dummy argument\" }\n+  type:: intwrapper\n+    integer n\n+  end type intwrapper\n+contains\n+  subroutine dummysub(size, arg_array)\n+   type(intwrapper) :: size\n+   real, dimension(size%n) :: arg_array\n+   real :: local_array(4)\n+  end subroutine dummysub\n+end module modboom\n+"}, {"sha": "6078293743f4df5b8b9014f4ca039a65e4cbe0ad", "filename": "gcc/testsuite/gfortran.dg/private_type_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ec07e1ec859fa5e5ff821c7edd350ad6728560/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_2.f90?ref=e8ec07e1ec859fa5e5ff821c7edd350ad6728560", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! PR16404 test 6 - A public type cannot have private-type components.\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+MODULE TEST\n+  PRIVATE\n+  TYPE :: info_type\n+   INTEGER :: value\n+  END TYPE info_type\n+  TYPE :: all_type! { dg-error \"PRIVATE type and cannot be a component\" }\n+    TYPE(info_type) :: info\n+  END TYPE\n+  public  all_type\n+END MODULE\n+END\n+"}]}