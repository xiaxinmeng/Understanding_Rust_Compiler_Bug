{"sha": "d5c23c6ceacf666f218676b648801379044e326a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVjMjNjNmNlYWNmNjY2ZjIxODY3NmI2NDg4MDEzNzkwNDRlMzI2YQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2020-01-10T15:08:41Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2020-01-10T15:08:41Z"}, "message": "OpenACC \u2013 support \"if\" + \"if_present\" clauses with \"host_data\"\n\n2020-01-10  Gerg\u00f6 Barany  <gergo@codesourcery.com>\n\t    Thomas Schwinge <thomas@codesourcery.com>\n\t    Julian Brown  <julian@codesourcery.com>\n\t    Tobias Burnus  <tobias@codesourcery.com>\n\n        gcc/c/\n        * c-parser.c (OACC_HOST_DATA_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_IF\n        and PRAGMA_OACC_CLAUSE_IF_PRESENT.\n\n        gcc/cp/\n        * parser.c (OACC_HOST_DATA_CLAUSE_MASK): Add PRAGMA_OACC_CLAUSE_IF\n        and PRAGMA_OACC_CLAUSE_IF_PRESENT.\n\n        gcc/fortran/\n        * openmp.c (OACC_HOST_DATA_CLAUSES): Add PRAGMA_OACC_CLAUSE_IF\n        and PRAGMA_OACC_CLAUSE_IF_PRESENT.\n\n\tgcc/\n\t* omp-low.c (lower_omp_target): Use GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT\n\tif PRAGMA_OACC_CLAUSE_IF_PRESENT exist.\n\n\tgcc/testsuite/\n\t* c-c++-common/goacc/host_data-1.c: Added tests of if and if_present\n\tclauses on host_data.\n\t* gfortran.dg/goacc/host_data-tree.f95: Likewise.\n\n\tinclude/\n\t* gomp-constants.h (enum gomp_map_kind): New enumeration constant\n\tGOMP_MAP_USE_DEVICE_PTR_IF_PRESENT.\n        \n\tlibgomp/\n\t* oacc-parallel.c (GOACC_data_start): Handle\n\tGOMP_MAP_USE_DEVICE_PTR_IF_PRESENT.\n\t* target.c (gomp_map_vars_async): Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/host_data-7.c: New.\n\t* testsuite/libgomp.oacc-fortran/host_data-5.F90: New.\n\nFrom-SVN: r280115", "tree": {"sha": "27ff72e6195bc05973f17caeee04c66ed8f1db57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27ff72e6195bc05973f17caeee04c66ed8f1db57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5c23c6ceacf666f218676b648801379044e326a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c23c6ceacf666f218676b648801379044e326a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c23c6ceacf666f218676b648801379044e326a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c23c6ceacf666f218676b648801379044e326a/comments", "author": null, "committer": null, "parents": [{"sha": "7cee96370cf624dbda81fcd3cd32ddb48a2fc3d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cee96370cf624dbda81fcd3cd32ddb48a2fc3d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cee96370cf624dbda81fcd3cd32ddb48a2fc3d3"}], "stats": {"total": 237, "additions": 229, "deletions": 8}, "files": [{"sha": "bf9e3e05d3e83e9a6a2f40fa6fe4c3ec97dba8e0", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -16701,7 +16701,9 @@ c_parser_oacc_enter_exit_data (c_parser *parser, bool enter)\n */\n \n #define OACC_HOST_DATA_CLAUSE_MASK\t\t\t\t\t\\\n-\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_USE_DEVICE) )\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_USE_DEVICE)          \\\n+\t | (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)                  \\\n+\t | (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF_PRESENT) )\n \n static tree\n c_parser_oacc_host_data (location_t loc, c_parser *parser, bool *if_p)"}, {"sha": "2ddbe138ae66ade924bf137c1a9348a16e957c43", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -40487,7 +40487,9 @@ cp_parser_oacc_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n   structured-block  */\n \n #define OACC_HOST_DATA_CLAUSE_MASK\t\t\t\t\t\\\n-  ( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_USE_DEVICE) )\n+  ( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_USE_DEVICE)                \\\n+   | (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)                        \\\n+   | (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF_PRESENT) )\n \n static tree\n cp_parser_oacc_host_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)"}, {"sha": "10622129659b9db2df126ef65c05a2a1ab0a7438", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -2031,7 +2031,10 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n   (OACC_LOOP_CLAUSES | OACC_KERNELS_CLAUSES)\n #define OACC_SERIAL_LOOP_CLAUSES \\\n   (OACC_LOOP_CLAUSES | OACC_SERIAL_CLAUSES)\n-#define OACC_HOST_DATA_CLAUSES omp_mask (OMP_CLAUSE_USE_DEVICE)\n+#define OACC_HOST_DATA_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_USE_DEVICE)\t\t\t\t\t      \\\n+   | OMP_CLAUSE_IF\t\t\t\t\t\t\t      \\\n+   | OMP_CLAUSE_IF_PRESENT)\n #define OACC_DECLARE_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_COPY) | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT\t      \\\n    | OMP_CLAUSE_CREATE | OMP_CLAUSE_DEVICEPTR | OMP_CLAUSE_DEVICE_RESIDENT    \\"}, {"sha": "9a36192e8ef0489e2b5cf0e0479878bb38909532", "filename": "gcc/omp-low.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -12006,6 +12006,9 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\ttkind = GOMP_MAP_FIRSTPRIVATE_INT;\n \t\tx = build_sender_ref (ovar, ctx);\n \t      }\n+\t    if (tkind == GOMP_MAP_USE_DEVICE_PTR\n+\t\t&& omp_find_clause (clauses, OMP_CLAUSE_IF_PRESENT))\n+\t      tkind = GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT;\n \t    type = TREE_TYPE (ovar);\n \t    if (lang_hooks.decls.omp_array_data (ovar, true))\n \t      var = lang_hooks.decls.omp_array_data (ovar, false);"}, {"sha": "658b7a677bc70825a327099b21d7bd44ab0d8fb4", "filename": "gcc/testsuite/c-c++-common/goacc/host_data-1.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-1.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -7,6 +7,9 @@ f (void)\n {\n #pragma acc host_data use_device(v1)\n   ;\n+\n+#pragma acc host_data use_device(v1) if_present\n+  ;\n }\n \n \n@@ -16,9 +19,32 @@ void\n foo (float *x, float *y)\n {\n   int n = 1 << 10;\n-#pragma acc data create(x[0:n]) copyout(y[0:n])\n+#pragma acc data create(x[0:n])\n   {\n+    bar (x, y);\n+\n+    /* This should fail at run time because y is not mapped.  */\n #pragma acc host_data use_device(x,y)\n     bar (x, y);\n+\n+    /* y is still not mapped, but this should not fail at run time but\n+       continue execution with y remaining as the host address.  */\n+#pragma acc host_data use_device(x,y) if_present\n+    bar (x, y);\n+\n+#pragma acc data copyout(y[0:n])\n+    {\n+#pragma acc host_data use_device(x,y)\n+      bar (x, y);\n+\n+#pragma acc host_data use_device(x,y) if_present\n+      bar (x, y);\n+\n+#pragma acc host_data use_device(x,y) if(x != y)\n+      bar (x, y);\n+\n+#pragma acc host_data use_device(x,y) if_present if(x != y)\n+      bar (x, y);\n+    }\n   }\n }"}, {"sha": "2ac1c0d66d62a511178d9471edc77ca7f3d74a09", "filename": "gcc/testsuite/gfortran.dg/goacc/host_data-tree.f95", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -7,5 +7,15 @@ program test\n \n   !$acc host_data use_device(p)\n   !$acc end host_data\n+\n+  !$acc host_data use_device(p) if (p == 42)\n+  !$acc end host_data\n+\n+  !$acc host_data use_device(p) if_present if (p == 43)\n+  !$acc end host_data\n end program test\n-! { dg-final { scan-tree-dump-times \"pragma acc host_data use_device_ptr\\\\(p\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma acc host_data use_device_ptr\\\\(p\\\\)\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"D.\\[0-9\\]+ = \\\\*p == 42;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma acc host_data use_device_ptr\\\\(p\\\\) if\\\\(D.\\[0-9\\]+\\\\)\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"D.\\[0-9\\]+ = \\\\*p == 43;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma acc host_data use_device_ptr\\\\(p\\\\) if\\\\(D.\\[0-9\\]+\\\\) if_present\" 1 \"original\" } }"}, {"sha": "5a7cc2c3f011adadf54eb9f5b33c4b5898072f95", "filename": "include/gomp-constants.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -79,7 +79,7 @@ enum gomp_map_kind\n     /* OpenACC link.  */\n     GOMP_MAP_LINK =\t\t\t(GOMP_MAP_FLAG_SPECIAL_1 | 2),\n     /* Use device data if present, fall back to host address otherwise.  */\n-    GOMP_MAP_IF_PRESENT =\t\t\t(GOMP_MAP_FLAG_SPECIAL_1 | 3),\n+    GOMP_MAP_IF_PRESENT =\t\t(GOMP_MAP_FLAG_SPECIAL_1 | 3),\n     /* Do not map, copy bits for firstprivate instead.  */\n     GOMP_MAP_FIRSTPRIVATE =\t\t(GOMP_MAP_FLAG_SPECIAL | 0),\n     /* Similarly, but store the value in the pointer rather than\n@@ -101,6 +101,10 @@ enum gomp_map_kind\n     GOMP_MAP_FORCE_FROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_FROM),\n     /* ..., and copy to and from device.  */\n     GOMP_MAP_FORCE_TOFROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_TOFROM),\n+    /* Like GOMP_MAP_USE_DEVICE_PTR above, translate a host to a device\n+       address.  If translation fails because the target is not mapped,\n+       continue using the host address. */\n+    GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT = (GOMP_MAP_FLAG_SPECIAL_2 | 0),\n     /* If not already present, allocate.  And unconditionally copy to\n        device.  */\n     GOMP_MAP_ALWAYS_TO =\t\t(GOMP_MAP_FLAG_SPECIAL_2 | GOMP_MAP_TO),"}, {"sha": "c7e46e35bd6b8d67a575329bb32af046b5894dd7", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -415,7 +415,8 @@ GOACC_data_start (int flags_m, size_t mapnum,\n \t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n       enter_data_event_info.other_event.parent_construct = acc_construct_data;\n       for (int i = 0; i < mapnum; ++i)\n-\tif ((kinds[i] & 0xff) == GOMP_MAP_USE_DEVICE_PTR)\n+\tif ((kinds[i] & 0xff) == GOMP_MAP_USE_DEVICE_PTR\n+\t    || (kinds[i] & 0xff) == GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT)\n \t  {\n \t    /* If there is one such data mapping kind, then this is actually an\n \t       OpenACC 'host_data' construct.  (GCC maps the OpenACC"}, {"sha": "522b69e6d5d17642041776a083058f614592394e", "filename": "libgomp/target.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -720,7 +720,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t  tgt->list[i].offset = OFFSET_INLINED;\n \t  continue;\n \t}\n-      else if ((kind & typemask) == GOMP_MAP_USE_DEVICE_PTR)\n+      else if ((kind & typemask) == GOMP_MAP_USE_DEVICE_PTR\n+\t       || (kind & typemask) == GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT)\n \t{\n \t  tgt->list[i].key = NULL;\n \t  if (!not_found_cnt)\n@@ -741,6 +742,12 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t      splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);\n \t      if (n == NULL)\n \t\t{\n+\t\t  if ((kind & typemask) == GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT)\n+\t\t    {\n+\t\t      /* If not present, continue using the host address.  */\n+\t\t      tgt->list[i].offset = 0;\n+\t\t      continue;\n+\t\t    }\n \t\t  gomp_mutex_unlock (&devicep->lock);\n \t\t  gomp_fatal (\"use_device_ptr pointer wasn't mapped\");\n \t\t}\n@@ -974,13 +981,18 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t      case GOMP_MAP_ZERO_LEN_ARRAY_SECTION:\n \t\tcontinue;\n \t      case GOMP_MAP_USE_DEVICE_PTR:\n+\t      case GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT:\n \t\tif (tgt->list[i].offset == 0)\n \t\t  {\n \t\t    cur_node.host_start = (uintptr_t) hostaddrs[i];\n \t\t    cur_node.host_end = cur_node.host_start;\n \t\t    n = gomp_map_lookup (mem_map, &cur_node);\n \t\t    if (n == NULL)\n \t\t      {\n+\t\t\tif ((kind & typemask)\n+\t\t\t    == GOMP_MAP_USE_DEVICE_PTR_IF_PRESENT)\n+\t\t\t  /* If not present, continue using the host address.  */\n+\t\t\t  continue;\n \t\t\tgomp_mutex_unlock (&devicep->lock);\n \t\t\tgomp_fatal (\"use_device_ptr pointer wasn't mapped\");\n \t\t      }"}, {"sha": "6830ef1e7edb8d4e7f47625a2458cd87a8715692", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/host_data-7.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fhost_data-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fhost_data-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fhost_data-7.c?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run } */\n+\n+/* Test if, if_present clauses on host_data construct.  */\n+/* C/C++ variant of 'libgomp.oacc-fortran/host_data-5.F90' */\n+\n+#include <assert.h>\n+#include <stdint.h>\n+\n+void\n+foo (float *p, intptr_t host_p, int cond)\n+{\n+  assert (p == (float *) host_p);\n+\n+#pragma acc data copyin(host_p)\n+  {\n+#pragma acc host_data use_device(p) if_present\n+    /* p not mapped yet, so it will be equal to the host pointer.  */\n+    assert (p == (float *) host_p);\n+\n+#pragma acc data copy(p[0:100])\n+    {\n+      /* Not inside a host_data construct, so p is still the host pointer.  */\n+      assert (p == (float *) host_p);\n+\n+#pragma acc host_data use_device(p)\n+      {\n+#if ACC_MEM_SHARED\n+\tassert (p == (float *) host_p);\n+#else\n+\t/* The device address is different from host address.  */\n+\tassert (p != (float *) host_p);\n+#endif\n+      }\n+\n+#pragma acc host_data use_device(p) if_present\n+      {\n+#if ACC_MEM_SHARED\n+\tassert (p == (float *) host_p);\n+#else\n+\t/* p is present now, so this is the same as above.  */\n+\tassert (p != (float *) host_p);\n+#endif\n+      }\n+\n+#pragma acc host_data use_device(p) if(cond)\n+      {\n+#if ACC_MEM_SHARED\n+\tassert (p == (float *) host_p);\n+#else\n+\t/* p is the device pointer iff cond is true.  */\n+\tassert ((p != (float *) host_p) == cond);\n+#endif\n+      }\n+    }\n+  }\n+}\n+\n+int\n+main (void)\n+{\n+  float arr[100];\n+  foo (arr, (intptr_t) arr, 0);\n+  foo (arr, (intptr_t) arr, 1);\n+\n+  return 0;\n+}"}, {"sha": "483ac3fb668f26b2765ca6f2876d27af2cd3293a", "filename": "libgomp/testsuite/libgomp.oacc-fortran/host_data-5.F90", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fhost_data-5.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c23c6ceacf666f218676b648801379044e326a/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fhost_data-5.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fhost_data-5.F90?ref=d5c23c6ceacf666f218676b648801379044e326a", "patch": "@@ -0,0 +1,92 @@\n+! { dg-do run }\n+!\n+! Test if, if_present clauses on host_data construct.\n+!\n+! Fortran variant of 'libgomp.oacc-c-c++-common/host_data-7.c'.\n+!\n+program main\n+  use iso_c_binding\n+  implicit none\n+  real, target :: var, arr(100)\n+  integer(c_intptr_t) :: host_p, host_parr\n+  host_p = transfer(c_loc(var), host_p)\n+  host_parr = transfer(c_loc(arr), host_parr)\n+  call foo (var, arr, host_p, host_parr, .false.)\n+  call foo (var, arr, host_p, host_parr, .true.)\n+\n+contains\n+\n+subroutine foo (p2, parr, host_p, host_parr, cond)\n+  use openacc\n+  implicit none\n+  real, target, intent(in) :: parr(:), p2\n+  integer(c_intptr_t), value, intent(in) :: host_p, host_parr\n+  logical, value, intent(in) :: cond\n+  real, pointer :: p\n+  p => p2\n+\n+  if (host_p /= transfer(c_loc(p), host_p)) stop 1\n+  if (host_parr /= transfer(c_loc(parr), host_parr)) stop 2\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present(p, c_sizeof(p))) stop 3\n+  if (acc_is_present(parr, 1)) stop 4\n+#endif\n+  \n+  !$acc data copyin(host_p, host_parr)\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present(p, c_sizeof(p))) stop 5\n+    if (acc_is_present(parr, 1)) stop 6\n+#endif\n+    !$acc host_data use_device(p, parr) if_present\n+      ! not mapped yet, so it will be equal to the host pointer.\n+      if (transfer(c_loc(p), host_p) /= host_p) stop 7\n+      if (transfer(c_loc(parr), host_parr) /= host_parr) stop 8\n+    !$acc end host_data\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present(p, c_sizeof(p))) stop 9\n+    if (acc_is_present(parr, 1)) stop 10\n+#endif\n+\n+    !$acc data copy(p, parr)\n+      if (.not. acc_is_present(p, c_sizeof(p))) stop 11\n+      if (.not. acc_is_present(parr, 1)) stop 12\n+      ! Not inside a host_data construct, so still the host pointer.\n+      if (transfer(c_loc(p), host_p) /= host_p) stop 13\n+      if (transfer(c_loc(parr), host_parr) /= host_parr) stop 14\n+      \n+      !$acc host_data use_device(p, parr)\n+#if ACC_MEM_SHARED\n+        if (transfer(c_loc(p), host_p) /= host_p) stop 15\n+        if (transfer(c_loc(parr), host_parr) /= host_parr) stop 16\n+#else\n+        ! The device address is different from host address.\n+        if (transfer(c_loc(p), host_p) == host_p) stop 17\n+        if (transfer(c_loc(parr), host_parr) == host_parr) stop 18\n+#endif\n+      !$acc end host_data\n+\n+      !$acc host_data use_device(p, parr) if_present\n+#if ACC_MEM_SHARED\n+        if (transfer(c_loc(p), host_p) /= host_p) stop 19\n+        if (transfer(c_loc(parr), host_parr) /= host_parr) stop 20\n+#else\n+        ! is present now, so this is the same as above.\n+        if (transfer(c_loc(p), host_p) == host_p) stop 21\n+        if (transfer(c_loc(parr), host_parr) == host_parr) stop 22\n+#endif\n+      !$acc end host_data\n+\n+      !$acc host_data use_device(p, parr) if(cond)\n+#if ACC_MEM_SHARED\n+        if (transfer(c_loc(p), host_p) /= host_p) stop 23\n+        if (transfer(c_loc(parr), host_parr) /= host_parr) stop 24\n+#else\n+        ! is the device pointer iff cond is true.\n+        if ((transfer(c_loc(p), host_p) /= host_p) .neqv. cond) stop 25\n+        if ((transfer(c_loc(parr), host_parr) /= host_parr) .neqv. cond) stop 26\n+#endif\n+      !$acc end host_data\n+    !$acc end data\n+  !$acc end data\n+end subroutine foo\n+end"}]}