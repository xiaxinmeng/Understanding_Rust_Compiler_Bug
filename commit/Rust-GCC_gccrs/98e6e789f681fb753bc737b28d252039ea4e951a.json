{"sha": "98e6e789f681fb753bc737b28d252039ea4e951a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThlNmU3ODlmNjgxZmI3NTNiYzczN2IyOGQyNTIwMzllYTRlOTUxYQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-12-22T00:27:01Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-12-22T00:27:01Z"}, "message": "configure.in: Change GLIBCPP_ENABLE_SHADOW to GLIBCPP_ENABLE_CHEADERS.\n\n\n2000-12-21  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* configure.in: Change GLIBCPP_ENABLE_SHADOW to\n\tGLIBCPP_ENABLE_CHEADERS.\n\t* acinclude.m4 (GLIBCPP_ENABLE_SHADOW): Change to\n\tENABLE_CHEADERS.  C_INCLUDE_DIR defaults to c_std from c.\n\t* aclocal.m4: Regenerate.\n\t* configure: Regenerate.\n\t* include/c: Move to ...\n\t* include/c_std: ...here.\n\t* include/c_std: Move to ...\n\t* include/c_shadow: ...here.\n\t* include/c: Repopulate, with simple headers.\n\t* docs/html/configopts.html: Adjust docs.\n\nFrom-SVN: r38440", "tree": {"sha": "cec738754aa77485007fa794218db3040789c01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cec738754aa77485007fa794218db3040789c01c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98e6e789f681fb753bc737b28d252039ea4e951a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e6e789f681fb753bc737b28d252039ea4e951a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e6e789f681fb753bc737b28d252039ea4e951a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e6e789f681fb753bc737b28d252039ea4e951a/comments", "author": null, "committer": null, "parents": [{"sha": "74da183aea421b2123cb7c53c70b85dc9bc1f5fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74da183aea421b2123cb7c53c70b85dc9bc1f5fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74da183aea421b2123cb7c53c70b85dc9bc1f5fd"}], "stats": {"total": 2504, "additions": 758, "deletions": 1746}, "files": [{"sha": "c61df979bface8d5b0b257c43e51ba22a596d654", "filename": "libstdc++-v3/include/c_std/bits/cmath.tcc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fcmath.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fcmath.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fcmath.tcc?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -0,0 +1,53 @@\n+// -*- C++ -*- C math library.\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file was written by Gabriel Dos Reis <gdr@codesourcery.com>\n+\n+#ifndef _CPP_BITS_CMATH_TCC\n+#define _CPP_BITS_CMATH_TCC 1\n+\n+namespace std {\n+  export template<typename _Tp>\n+    _Tp\n+    __cmath_power(_Tp __x, unsigned int __n)\n+    {\n+      _Tp __y = __n % 2 ? __x : 1;\n+\n+      while (__n >>= 1)\n+        {\n+          __x = __x * __x;\n+          if (__n % 2)\n+            __y = __y * __x;\n+        }\n+\n+      return __y;\n+    }\n+}\n+\n+#endif"}, {"sha": "e06927493ab28d620c77a76cd4ccdcff3de9f9d6", "filename": "libstdc++-v3/include/c_std/bits/std_cassert.h", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cassert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cassert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cassert.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,31 +31,19 @@\n // ISO C++ 14882: 19.2  Assertions\n //\n \n-// NB: This is assumed to be a conforming implementation.\n+// Note: This is not a conforming implementation.\n+\n+// No include guards on this header...\n+\n+#pragma GCC system_header\n+#include <assert.h>\n+\n \n-// ISO/IEC 9899:1999 (E), section 7.2\n-// assert.h\n-// ..defines the assert macro...\n \n-// ISO 14882\n-// 17.4.1.2 Headers\n-// ... declarations and definitions (except for macros) are within\n-// namespace scope of the namepace std...\n \n \n-//#ifndef _CPP_CASSERT\n-//#define _CPP_CASSERT 1\n \n-//namespace _C_legacy {\n-  extern \"C\" {\n-//#   define _IN_C_LEGACY_\n-#   pragma GCC system_header\n-#   include_next <assert.h>\n-  }\n-//} // namespace _C_legacy\n \n-//#undef _IN_C_LEGACY_\n \n-//#endif\n \n "}, {"sha": "a6a882bc8a2ed8313e1622934e1106b28dbdd075", "filename": "libstdc++-v3/include/c_std/bits/std_cctype.h", "status": "modified", "additions": 41, "deletions": 96, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cctype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cctype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cctype.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -27,118 +27,63 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-// ISO C++ 14882: 22\n //\n+// ISO C++ 14882: <ccytpe>\n+//\n+\n+// Note: This is not a conforming implementation.\n \n #ifndef _CPP_CCTYPE\n #define _CPP_CCTYPE 1\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <ctype.h>\n-  }\n-\n-  inline int \n-  _CPP_isalnum_capture(int c) { return isalnum(c); }\n-\n-  inline int \n-  _CPP_isalpha_capture(int c) { return isalpha(c); }\n-\n-  inline int \n-  _CPP_iscntrl_capture(int c) { return iscntrl(c); }\n-\n-  inline int \n-  _CPP_isdigit_capture(int c) { return isdigit(c); }\n-\n-  inline int \n-  _CPP_isgraph_capture(int c) { return isgraph(c); }\n-\n-  inline int \n-  _CPP_islower_capture(int c) { return islower(c); }\n-\n-  inline int \n-  _CPP_isprint_capture(int c) { return isprint(c); }\n-\n-  inline int \n-  _CPP_ispunct_capture(int c) { return ispunct(c); }\n-\n-  inline int \n-  _CPP_isspace_capture(int c) { return isspace(c); }\n-\n-  inline int \n-  _CPP_isupper_capture(int c) { return isupper(c); }\n-\n-  inline int \n-  _CPP_isxdigit_capture(int c) { return isxdigit(c); }\n-\n-  inline int \n-  _CPP_tolower_capture(int c) { return tolower(c); }\n-\n-  inline int \n-  _CPP_toupper_capture(int c) { return toupper(c); }\n-} // namespace _C_legacy\n-\n-# undef isalnum\n-# undef isalpha\n-# undef iscntrl\n-# undef isdigit\n-# undef isgraph\n-# undef islower\n-# undef isprint\n-# undef ispunct\n-# undef isspace\n-# undef isupper\n-# undef isxdigit\n-\n-# undef tolower\n-# undef toupper\n-\n-namespace std {\n-  inline int \n-  isalnum(int __c) { return _C_legacy::_CPP_isalnum_capture(__c); }\n-\n-  inline int \n-  isalpha(int __c) { return _C_legacy::_CPP_isalpha_capture(__c); }\n+#include <bits/c++config.h>\n \n-  inline int \n-  iscntrl(int __c) { return _C_legacy::_CPP_iscntrl_capture(__c); }\n+#pragma GCC system_header\n+#include <ctype.h>\n \n-  inline int \n-  isdigit(int __c) { return _C_legacy::_CPP_isdigit_capture(__c); }\n+// Get rid of those macros defined in <ctype.h> in lieu of real functions.\n+#undef isalnum\n+#undef isalpha\n+#undef isblank\n+#undef iscntrl\n+#undef isdigit\n+#undef isgraph\n+#undef islower\n+#undef isprint\n+#undef ispunct\n+#undef isspace\n+#undef isupper\n+#undef isxdigit\n+#undef tolower\n+#undef toupper\n \n-  inline int \n-  isgraph(int __c) { return _C_legacy::_CPP_isgraph_capture(__c); }\n+namespace std\n+{\n+  extern \"C\" int isalnum(int __c);\n+  extern \"C\" int isalpha(int __c);\n+  extern \"C\" int isblank(int __c);\n+  extern \"C\" int iscntrl(int __c);\n+  extern \"C\" int isdigit(int __c);\n+  extern \"C\" int isgraph(int __c);\n+  extern \"C\" int islower(int __c);\n+  extern \"C\" int isprint(int __c);\n+  extern \"C\" int ispunct(int __c);\n+  extern \"C\" int isspace(int __c);\n+  extern \"C\" int isupper(int __c);\n+  extern \"C\" int isxdigit(int __c);\n+  extern \"C\" int tolower(int __c);\n+  extern \"C\" int toupper(int __c);\n+}\n \n-  inline int \n-  islower(int __c) { return _C_legacy::_CPP_islower_capture(__c); }\n+#endif \n \n-  inline int \n-  isprint(int __c) { return _C_legacy::_CPP_isprint_capture(__c); }\n \n-  inline int \n-  ispunct(int __c) { return _C_legacy::_CPP_ispunct_capture(__c); }\n \n-  inline int \n-  isspace(int __c) { return _C_legacy::_CPP_isspace_capture(__c); }\n \n-  inline int \n-  isupper(int __c) { return _C_legacy::_CPP_isupper_capture(__c); }\n \n-  inline int \n-  isxdigit(int __c) { return _C_legacy::_CPP_isxdigit_capture(__c); }\n \n-  inline int \n-  tolower(int __c) { return _C_legacy::_CPP_tolower_capture(__c); }\n \n-  inline int \n-  toupper(int __c) { return _C_legacy::_CPP_toupper_capture(__c); }\n-} // namespace std\n-  \n-# undef _IN_C_LEGACY_\n \n-#endif\n \n \n "}, {"sha": "682882768b30412d884f54e9020005abce1e3096", "filename": "libstdc++-v3/include/c_std/bits/std_cerrno.h", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cerrno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cerrno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cerrno.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,6 +1,6 @@\n-// -*- C++ -*- header wrapper.\n+// The -*- C++ -*- error number header.\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,22 +27,25 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n+//\n // ISO C++ 14882: 19.3  Error numbers\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CERRNO\n #define _CPP_CERRNO 1\n \n-//namespace _C_legacy {\n-  extern \"C\" {\n-//#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <errno.h>\n-  }\n-//} // namespace _C_legacy::\n+#pragma GCC system_header\n+#include <errno.h>\n \n-//# undef _IN_C_LEGACY_\n+namespace std \n+{\n+  extern \"C\" int errno;\n+}\n \n #endif\n \n \n+\n+"}, {"sha": "1444be1ecfbcbebf1b8e7636c191846093d9a801", "filename": "libstdc++-v3/include/c_std/bits/std_cfloat.h", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cfloat.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,24 +31,13 @@\n // ISO C++ 14882: 18.2.2  Implementation properties: C library\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CFLOAT\n #define _CPP_CFLOAT 1\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <float.h>\n-  }\n-} // namespace _C_legacy\n-\n-# undef _IN_C_LEGACY_\n+#pragma GCC system_header\n+#include <float.h>\n \n #endif\n \n-\n-\n-\n-\n-\n-"}, {"sha": "071dd0594f9eae0432be4aaadefee5d24e85732e", "filename": "libstdc++-v3/include/c_std/bits/std_climits.h", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_climits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_climits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_climits.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,27 +31,17 @@\n // ISO C++ 14882: 18.2.2  Implementation properties: C library\n //\n \n-#ifndef _CPP_CLIMITS\n-#define _CPP_CLIMITS 1\n+// Note: This is not a conforming implementation.\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <limits.h>\n-  }\n-} // namespace _C_legacy\n+#ifndef _CPP_CLIMITS\n+#define _CPP_CLIMITS\t1\n \n-# undef _IN_C_LEGACY_\n+#pragma GCC system_header\n+#include <limits.h>\n \n #endif\n \n \n \n \n \n-\n-\n-\n-\n-"}, {"sha": "18d73dd8cd44045a064c6f8aedfc1990cd26e932", "filename": "libstdc++-v3/include/c_std/bits/std_clocale.h", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_clocale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_clocale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_clocale.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,40 +31,22 @@\n // ISO C++ 14882: 18.2.2  Implementation properties: C library\n //\n \n-#ifndef _CPP_CLOCALE\n-#define _CPP_CLOCALE     1\n-\n-# include <bits/std_cstddef.h> \n-\n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <locale.h>\n-  }\n-\n-  typedef lconv _CPP_lconv_capture;\n-} // namespace _C_legacy\n-\n-#  undef lconv\n-#  undef setlocale\n-#  undef localeconv\n+// Note: This is not a conforming implementation.\n \n-namespace std {\n-  // Adopt C names into std::\n-  struct lconv : _C_legacy::_CPP_lconv_capture  { };\n-\n-  using _C_legacy::setlocale;  \n-\n-  inline lconv* \n-  localeconv() { return reinterpret_cast<lconv*>(_C_legacy::localeconv()); }\n-} // namespace std\n-\n-# undef _IN_C_LEGACY_\n+#ifndef _CPP_CLOCALE\n+#define _CPP_CLOCALE 1\n \n-#endif \n+#pragma GCC system_header\n+#include <locale.h>\n \n+namespace std\n+{\n+  using ::lconv;\n+  extern \"C\" char* setlocale(int, const char*); \n+  extern \"C\" struct lconv* localeconv(void);\n+}\n \n+#endif\n \n \n "}, {"sha": "01cf652548d308d49d98c28deeb78201f78e24b8", "filename": "libstdc++-v3/include/c_std/bits/std_cmath.h", "status": "modified", "additions": 225, "deletions": 466, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cmath.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,6 +1,6 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- C math library.\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,803 +31,562 @@\n // ISO C++ 14882: 26.5  C library\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CMATH\n #define _CPP_CMATH 1\n \n-# include <bits/c++config.h>\n+#include <bits/c++config.h>\n+#include <bits/std_cstdlib.h>\n+ \n+#pragma GCC system_header\n+#include <math.h>\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <math.h>\n-  }\n+namespace std \n+{\n+  // Forward declaration of a helper function.  This really should be\n+  // an `exported' forward declaration.\n+  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);\n+\n+  template<typename _Tp>\n+  inline _Tp\n+    __cmath_abs(_Tp __x)\n+    {\n+      return __x < _Tp() ? -__x : __x;\n+    }\n+\n+  inline long \n+  abs(long __i) { return ::labs(__i); }\n+\n+  inline ldiv_t\n+  div(long __i, long __j) { return ::ldiv(__i, __j); }\n+\n+#if _GLIBCPP_HAVE___BUILTIN_FABSF\n+  inline float \n+  abs(float __x) { return __builtin_fabsf(__x); }\n+#elif _GLIBCPP_HAVE_FABSF\n+  inline float \n+  abs(float __x) { return ::fabsf(__x); }\n+#else\n+  inline float \n+  abs(float __x) { return __cmath_abs(__x); }\n+#endif\n \n #if _GLIBCPP_HAVE_ACOSF\n   inline float \n-  _CPP_acos_capture(float __x) { return acosf(__x); }\n+  acos(float __x) { return ::acosf(__x); }\n #else\n   inline float \n-  _CPP_acos_capture(float __x) { return acos(static_cast<double>(__x)); }\n+  acos(float __x) { return ::acos(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_ASINF\n   inline float \n-  _CPP_asin_capture(float __x) { return asinf(__x); }\n+  asin(float __x) { return ::asinf(__x); }\n #else\n   inline float \n-  _CPP_asin_capture(float __x) { return asin(static_cast<double>(__x)); }\n+  asin(float __x) { return ::asin(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_ATANF\n   inline float \n-  _CPP_atan_capture(float __x) { return atanf(__x); }\n+  atan(float __x) { return ::atanf(__x); }\n #else\n   inline float \n-  _CPP_atan_capture(float __x) { return atan(static_cast<double>(__x)); }\n+  atan(float __x) { return ::atan(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_ATAN2F\n   inline float \n-  _CPP_atan2_capture(float __y, float __x) { return atan2f(__y, __x); }\n+  atan2(float __y, float __x) { return ::atan2f(__y, __x); }\n #else\n   inline float \n-  _CPP_atan2_capture(float __y, float __x) \n-  { return atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n+  atan2(float __y, float __x)\n+  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_CEILF\n   inline float \n-  _CPP_ceil_capture(float __x) { return ceilf(__x); }\n+  ceil(float __x) { return ::ceilf(__x); }\n #else\n   inline float \n-  _CPP_ceil_capture(float __x) { return ceil(static_cast<double>(__x)); }\n+  ceil(float __x) { return ::ceil(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE___BUILTIN_COSF\n   inline float \n-  _CPP_cos_capture(float __x) { return __builtin_cosf(__x); }\n+  cos(float __x) { return __builtin_cosf(__x); }\n #elif _GLIBCPP_HAVE_COSF\n   inline float \n-  _CPP_cos_capture(float __x) { return cosf(__x); }\n+  cos(float __x) { return ::cosf(__x); }\n #else\n   inline float \n-  _CPP_cos_capture(float __x) { return cos(static_cast<double>(__x)); }\n+  cos(float __x) { return ::cos(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_COSHF\n   inline float \n-  _CPP_cosh_capture(float __x) { return coshf(__x); }\n+  cosh(float __x) { return ::coshf(__x); }\n #else\n   inline float \n-  _CPP_cosh_capture(float __x) { return cosh(static_cast<double>(__x)); }\n+  cosh(float __x) { return ::cosh(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_EXPF\n   inline float \n-  _CPP_exp_capture(float __x) { return expf(__x); }\n+  exp(float __x) { return ::expf(__x); }\n #else\n   inline float \n-  _CPP_exp_capture(float __x) { return exp(static_cast<double>(__x)); }\n+  exp(float __x) { return ::exp(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE___BUILTIN_FABSF\n   inline float \n-  _CPP_fabs_capture(float __x) { return __builtin_fabsf(__x); }\n+  fabs(float __x) { return __builtin_fabsf(__x); }\n #elif _GLIBCPP_HAVE_FABSF\n   inline float \n-  _CPP_fabs_capture(float __x) { return fabsf(__x); }\n+  fabs(float __x) { return ::fabsf(__x); }\n #else\n   inline float \n-  _CPP_fabs_capture(float __x) { return fabs(static_cast<double>(__x)); }\n+  fabs(float __x) { return __cmath_abs(__x); }\n #endif\n \n #if _GLIBCPP_HAVE_FLOORF\n   inline float \n-  _CPP_floor_capture(float __x) { return floorf(__x); }\n+  floor(float __x) { return ::floorf(__x); }\n #else\n   inline float \n-  _CPP_floor_capture(float __x) { return floor(static_cast<double>(__x)); }\n+  floor(float __x) { return ::floor(static_cast<double>(__x)); }\n #endif\n \n-#if _GLIBCPP_HAVE_FMODFF\n+#if _GLIBCPP_HAVE_FMODF\n   inline float \n-  _CPP_fmod_capture(float __x, float __y) { return fmodf(__x, __y); }\n+  fmod(float __x, float __y) { return ::fmodf(__x, __y); }\n #else\n   inline float \n-  _CPP_fmod_capture(float __x, float __y) \n-  { return fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n+  fmod(float __x, float __y)\n+  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n #if _GLIBCPP_HAVE_FREXPF\n   inline float \n-  _CPP_frexp_capture(float __x, int* __exp) { return frexpf(__x, __exp); }\n+  frexp(float __x, int* __exp) { return ::frexpf(__x, __exp); }\n #else\n   inline float \n-  _CPP_frexp_capture(float __x, int* __exp) { return frexp(__x, __exp); }\n+  frexp(float __x, int* __exp) { return ::frexp(__x, __exp); }\n #endif\n \n #if _GLIBCPP_HAVE_LDEXPF\n   inline float \n-  _CPP_ldexp_capture(float __x, int __exp) { return ldexpf(__x, __exp); }\n+  ldexp(float __x, int __exp) { return ::ldexpf(__x, __exp); }\n #else\n   inline float \n-  _CPP_ldexp_capture(float __x, int __exp) \n-  { return ldexp(static_cast<double>(__x), __exp); }\n+  ldexp(float __x, int __exp)\n+  { return ::ldexp(static_cast<double>(__x), __exp); }\n #endif\n \n #if _GLIBCPP_HAVE_LOGF\n   inline float \n-  _CPP_log_capture(float __x) { return logf(__x); }\n+  log(float __x) { return ::logf(__x); }\n #else\n-  inline float \n-  _CPP_log_capture(float __x) { return log(static_cast<double>(__x)); }\n+  inline float log(float __x)\n+  { return ::log(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_LOG10F\n   inline float \n-  _CPP_log10_capture(float __x) { return log10f(__x); }\n+  log10(float __x) { return ::log10f(__x); }\n #else\n   inline float \n-  _CPP_log10_capture(float __x) { return log10(static_cast<double>(__x)); }\n+  log10(float __x) { return ::log10(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_MODFF\n   inline float \n-  _CPP_modf_capture(float __x, float* __iptr) { return modff(__x, __iptr); }\n+  modf(float __x, float* __iptr) { return ::modff(__x, __iptr); }\n #else\n   inline float \n-  _CPP_modf_capture(float __x, float* __iptr)\n+  modf(float __x, float* __iptr)\n   {\n     double __tmp;\n-    double __res = _C_legacy::modf(static_cast<double>(__x), &__tmp);\n-    *__iptr = static_cast<float> (__tmp);\n+    double __res = ::modf(static_cast<double>(__x), &__tmp);\n+    *__iptr = static_cast<float>(__tmp);\n     return __res;\n   }\n #endif\n+\n+  template<typename _Tp>\n+    inline _Tp\n+    __pow_helper(_Tp __x, int __n)\n+    {\n+      return __n < 0\n+        ? _Tp(1)/__cmath_power(__x, -__n)\n+        : __cmath_power(__x, __n);\n+    }\n   \n #if _GLIBCPP_HAVE_POWF\n   inline float \n-  _CPP_pow_capture(float __x, float __y) { return powf(__x, __y); }\n+  pow(float __x, float __y) { return ::powf(__x, __y); }\n #else\n   inline float \n-  _CPP_pow_capture(float __x, float __y)\n-  { return pow(static_cast<double>(__x), static_cast<double>(__y)); }\n+  pow(float __x, float __y)\n+  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n-  float pow(float, int);\n+  inline float \n+  pow(float __x, int __n)\n+  {\n+    return __pow_helper(__x, __n);\n+  }\n \n #if _GLIBCPP_HAVE___BUILTIN_SINF\n   inline float \n-  _CPP_sin_capture(float __x) { return __builtin_sinf(__x); }\n+  sin(float __x) { return __builtin_sinf(__x); }\n #elif _GLIBCPP_HAVE_SINF\n   inline float \n-  _CPP_sin_capture(float __x) { return sinf(__x); }\n+  sin(float __x) { return ::sinf(__x); }\n #else\n   inline float \n-  _CPP_sin_capture(float __x) { return sin(static_cast<double>(__x)); }\n+  sin(float __x) { return ::sin(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_SINHF\n   inline float \n-  _CPP_sinh_capture(float __x) { return sinhf(__x); }\n+  sinh(float __x) { return ::sinhf(__x); }\n #else\n   inline float \n-  _CPP_sinh_capture(float __x) { return sinh(static_cast<double>(__x)); }\n+  sinh(float __x) { return ::sinh(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE___BUILTIN_SQRTF\n   inline float \n-  _CPP_sqrt_capture(float __x) { return __builtin_sqrtf(__x); }\n+  sqrt(float __x) { return __builtin_sqrtf(__x); }\n #elif _GLIBCPP_HAVE_SQRTF\n   inline float \n-  _CPP_sqrt_capture(float __x) { return sqrtf(__x); }\n+  sqrt(float __x) { return ::sqrtf(__x); }\n #else\n   inline float \n-  _CPP_sqrt_capture(float __x) { return sqrt(static_cast<double>(__x)); }\n+  sqrt(float __x) { return ::sqrt(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_TANF\n   inline float \n-  _CPP_tan_capture(float __x) { return tanf(__x); }\n+  tan(float __x) { return ::tanf(__x); }\n #else\n   inline float \n-  _CPP_tan_capture(float __x) { return tan(static_cast<double>(__x)); }\n+  tan(float __x) { return ::tan(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_TANHF\n   inline float \n-  _CPP_tanh_capture(float __x) { return tanhf(__x); }\n+  tanh(float __x) { return ::tanhf(__x); }\n #else\n   inline float \n-  _CPP_tanh_capture(float __x) { return tanh(static_cast<double>(__x)); }\n+  tanh(float __x) { return ::tanh(static_cast<double>(__x)); }\n #endif\n \n \n-  inline double \n-  _CPP_acos_capture(double __x) { return acos(__x); }\n+  extern \"C\" double acos(double __x);\n \n-  inline double \n-  _CPP_asin_capture(double __x) { return asin(__x); }\n+  extern \"C\" double asin(double __x);\n \n-  inline double \n-  _CPP_atan_capture(double __x) { return atan(__x); }\n+  extern \"C\" double atan(double __x);\n \n-  inline double \n-  _CPP_atan2_capture(double __y, double __x) { return atan2(__y, __x); }\n+  extern \"C\" double atan2(double __y, double __x);\n \n-  inline double \n-  _CPP_ceil_capture(double __x) { return ceil(__x); }\n+  extern \"C\" double ceil(double __x);\n \n #if _GLIBCPP_HAVE___BUILTIN_COS\n   inline double \n-  _CPP_cos_capture(double __x) { return __builtin_cos(__x); }\n+  cos(double __x) { return __builtin_cos(__x); }\n #else\n-  inline double \n-  _CPP_cos_capture(double __x) { return cos(__x); }\n+  extern \"C\" double cos(double __x);\n #endif\n \n-  inline double \n-  _CPP_cosh_capture(double __x) { return cosh(__x); }\n+  extern \"C\" double cosh(double __x);\n \n-  inline double \n-  _CPP_exp_capture(double __x) { return exp(__x); }\n+  extern \"C\" double exp(double __x);\n \n #if _GLIBCPP_HAVE___BUILTIN_FABS\n   inline double \n-  _CPP_fabs_capture(double __x) { return __builtin_fabs(__x); }\n+  fabs(double __x) { return __builtin_fabs(__x); }\n #else\n-  inline double \n-  _CPP_fabs_capture(double __x) { return fabs(__x); }\n+  extern \"C\" double fabs(double __x);\n #endif\n \n+#if _GLIBCPP_HAVE___BUILTIN_FABS\n   inline double \n-  _CPP_floor_capture(double __x) { return floor(__x); }\n+  abs(double __x) { return __builtin_fabs(__x); }\n+#else\n+  inline double\n+  abs(double __x) { return fabs(__x); }\n+#endif\n \n-  inline double \n-  _CPP_fmod_capture(double __x, double __y) { return fmod(__x, __y); }\n+  extern \"C\" double floor(double __x);\n \n-  inline double \n-  _CPP_frexp_capture(double __x, int* __exp) { return frexp(__x, __exp); }\n+  extern \"C\" double fmod(double __x, double __y);\n \n-  inline double \n-  _CPP_ldexp_capture(double __x, int __exp) { return ldexp(__x, __exp); }\n+  extern \"C\" double frexp(double __x, int* __exp);\n \n-  inline double \n-  _CPP_log_capture(double __x) { return log(__x); }\n+  extern \"C\" double ldexp(double __x, int __exp);\n \n-  inline double \n-  _CPP_log10_capture(double __x) { return log10(__x); }\n+  extern \"C\" double log(double __x);\n \n-  inline double \n-  _CPP_modf_capture(double __x, double* __iptr) { return modf(__x, __iptr); }\n+  extern \"C\" double log10(double __x);\n+\n+  extern \"C\" double modf(double __x, double* __iptr);\n+\n+  extern \"C\" double pow(double __x, double __y);\n \n   inline double \n-  _CPP_pow_capture(double __x, double __y) { return pow(__x, __y); }\n+  pow(double __x, int __i)\n+  {\n+    return __pow_helper(__x, __i);\n+  }\n \n #if _GLIBCPP_HAVE___BUILTIN_SIN\n   inline double \n-  _CPP_sin_capture(double __x) { return __builtin_sin(__x); }\n+  sin(double __x) { return __builtin_sin(__x); }\n #else\n-  inline double \n-  _CPP_sin_capture(double __x) { return sin(__x); }\n+  extern \"C\" double sin(double __x);\n #endif\n \n-  inline double \n-  _CPP_sinh_capture(double __x) { return sinh(__x); }\n+  extern \"C\" double sinh(double __x);\n \n #if _GLIBCPP_HAVE___BUILTIN_SQRT\n   inline double \n-  _CPP_sqrt_capture(double __x) { return __builtin_fsqrt(__x); }\n+  sqrt(double __x) { return __builtin_fsqrt(__x); }\n #else\n-  inline double \n-  _CPP_sqrt_capture(double __x) { return sqrt(__x); }\n+  extern \"C\" double sqrt(double __x);\n #endif\n \n-  inline double \n-  _CPP_tan_capture(double __x) { return tan(__x); }\n+  extern \"C\" double tan(double __x);\n \n-  inline double \n-  _CPP_tanh_capture(double __x) { return tanh(__x); }\n+  extern \"C\" double tanh(double __x);\n+\n+\n+#if _GLIBCPP_HAVE___BUILTIN_FABSL\n+  inline long double \n+  abs(long double __x) { return __builtin_fabsl(__x); }\n+#elif _GLIBCPP_HAVE_FABSL\n+  inline long double \n+  abs(long double __x) { return ::fabsl(__x); }\n+#else\n+  inline long double \n+  abs(long double __x) { return __cmath_abs(__x); }\n+#endif\n \n #if _GLIBCPP_HAVE_ACOSL\n   inline long double \n-  _CPP_acos_capture(long double __x) { return acosl(__x); }\n+  acos(long double __x) { return ::acosl(__x); }\n #else\n   inline long double \n-  _CPP_acos_capture(long double __x) { return acos(static_cast<double>(__x)); }\n+  acos(long double __x) { return ::acos(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_ASINL\n   inline long double \n-  _CPP_asin_capture(long double __x) { return asinl(__x); }\n+  asin(long double __x) { return ::asinl(__x); }\n #else\n   inline long double \n-  _CPP_asin_capture(long double __x) { return asin(static_cast<double>(__x)); }\n+  asin(long double __x) { return ::asin(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_ATANL\n   inline long double \n-  _CPP_atan_capture(long double __x) { return atanl(__x); }\n+  atan(long double __x) { return ::atanl(__x); }\n #else\n   inline long double \n-  _CPP_atan_capture(long double __x) { return atan(static_cast<double>(__x)); }\n+  atan(long double __x) { return ::atan(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_ATAN2L\n   inline long double \n-  _CPP_atan2_capture(long double __y, long double __x)\n-  { return atan2l(__y, __x); }\n+  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }\n #else\n   inline long double \n-  _CPP_atan2_capture(long double __y, long double __x) \n-  { return atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n+  atan2(long double __y, long double __x) \n+  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_CEILL\n   inline long double \n-  _CPP_ceil_capture(long double __x) { return ceill(__x); }\n+  ceil(long double __x) { return ::ceill(__x); }\n #else\n   inline long double \n-  _CPP_ceil_capture(long double __x) { return ceil(static_cast<double>(__x)); }\n+  ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE___BUILTIN_COSL\n   inline long double \n-  _CPP_cos_capture(long double __x) { return __builtin_cosl(__x); }\n+  cos(long double __x) { return __builtin_cosl(__x); }\n #elif _GLIBCPP_HAVE_COSL\n   inline long double \n-  _CPP_cos_capture(long double __x) { return cosl(__x); }\n+  cos(long double __x) { return ::cosl(__x); }\n #else\n   inline long double \n-  _CPP_cos_capture(long double __x) { return cos(static_cast<double>(__x)); }\n+  cos(long double __x) { return ::cos(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_COSHL\n   inline long double \n-  _CPP_cosh_capture(long double __x) { return coshl(__x); }\n+  cosh(long double __x) { return ::coshl(__x); }\n #else\n   inline long double \n-  _CPP_cosh_capture(long double __x) { return cosh(static_cast<double>(__x)); }\n+  cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_EXPL\n   inline long double \n-  _CPP_exp_capture(long double __x) { return expl(__x); }\n+  exp(long double __x) { return ::expl(__x); }\n #else\n   inline long double \n-  _CPP_exp_capture(long double __x) { return exp(static_cast<double>(__x)); }\n+  exp(long double __x) { return ::exp(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE___BUILTIN_FABSL\n   inline long double \n-  _CPP_fabs_capture(long double __x) { return __builtin_fabsl(__x); }\n+  fabs(long double __x) { return __builtin_fabsl(__x); }\n #elif _GLIBCPP_HAVE_FABSL\n   inline long double \n-  _CPP_fabs_capture(long double __x) { return fabsl(__x); }\n+  fabs(long double __x) { return ::fabsl(__x); }\n #else\n   inline long double \n-  _CPP_fabs_capture(long double __x) { return fabs(static_cast<double>(__x)); }\n+  fabs(long double __x) { return __cmath_abs(__x); }\n #endif\n \n #if _GLIBCPP_HAVE_FLOORL\n   inline long double \n-  _CPP_floor_capture(long double __x) { return floorl(__x); }\n+  floor(long double __x) { return ::floorl(__x); }\n #else\n   inline long double \n-  _CPP_floor_capture(long double __x) \n-  { return floor(static_cast<double>(__x)); }\n+  floor(long double __x) { return ::floor(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_FMODL\n   inline long double \n-  _CPP_fmod_capture(long double __x, long double __y) \n-  { return fmodl(__x, __y); }\n+  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }\n #else\n   inline long double \n-  _CPP_fmod_capture(long double __x, long double __y)\n-  { return fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n+  fmod(long double __x, long double __y) \n+  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n #if _GLIBCPP_HAVE_FREXPL\n   inline long double \n-  _CPP_frexp_capture(long double __x, int* __exp) \n-  { return frexpl(__x, __exp); }\n+  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }\n #else\n   inline long double \n-  _CPP_frexp_capture(long double __x, int* __exp)\n-  { return frexp(static_cast<double>(__x), __exp); }\n+  frexp(long double __x, int* __exp) \n+  { return ::frexp(static_cast<double>(__x), __exp); }\n #endif\n \n #if _GLIBCPP_HAVE_LDEXPL\n   inline long double \n-  _CPP_ldexp_capture(long double __x, int __exp) { return ldexpl(__x, __exp); }\n+  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }\n #else\n   inline long double \n-  _CPP_ldexp_capture(long double __x, int __exp)\n-  { return ldexp(static_cast<double>(__x), __exp); }\n+  ldexp(long double __x, int __exp) \n+  { return ::ldexp(static_cast<double>(__x), __exp); }\n #endif\n \n #if _GLIBCPP_HAVE_LOGL\n   inline long double \n-  _CPP_log_capture(long double __x) { return logl(__x); }\n+  log(long double __x) { return ::logl(__x); }\n #else\n   inline long double \n-  _CPP_log_capture(long double __x) { return log(static_cast<double>(__x)); }\n+  log(long double __x) { return ::log(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_LOG10L\n   inline long double \n-  _CPP_log10_capture(long double __x) { return log10l(__x); }\n+  log10(long double __x) { return ::log10l(__x); }\n #else\n   inline long double \n-  _CPP_log10_capture(long double __x) \n-  { return log10(static_cast<double>(__x)); }\n+  log10(long double __x) { return ::log10(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_MODFL\n   inline long double \n-  _CPP_modf_capture(long double __x, long double* __iptr)\n-  { return modfl(__x, __iptr); }\n+  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }\n #else\n   inline long double \n-  _CPP_modf_capture(long double __x, long double* __iptr)\n-  {\n+  modf(long double __x, long double* __iptr) \n+  { \n     double __tmp;\n-    double __res = _C_legacy::modf(static_cast<double>(__x), &__tmp);\n-    *__iptr = static_cast<long double> (__tmp);\n+    double __res = ::modf(static_cast<double>(__x), &__tmp);\n+    * __iptr = static_cast<long double>(__tmp);\n     return __res;\n   }\n #endif\n \n #if _GLIBCPP_HAVE_POWL\n   inline long double \n-  _CPP_pow_capture(long double __x, long double __y) { return powl(__x, __y); }\n+  pow(long double __x, long double __y) { return ::powl(__x, __y); }\n #else\n   inline long double \n-  _CPP_pow_capture(long double __x, long double __y)\n-  { return pow(static_cast<double>(__x), static_cast<double>(__y)); }\n+  pow(long double __x, long double __y) \n+  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n+  inline long double \n+  pow(long double __x, int __n)\n+  {\n+    return __pow_helper(__x, __n);\n+  }\n+\n #if _GLIBCPP_HAVE___BUILTIN_SINL\n   inline long double \n-  _CPP_sin_capture(long double __x) { return __builtin_sinl(__x); }\n+  sin(long double __x) { return __builtin_sinl(__x); }\n #elif _GLIBCPP_HAVE_SINL\n   inline long double \n-  _CPP_sin_capture(long double __x) { return sinl(__x); }\n+  sin(long double __x) { return ::sinl(__x); }\n #else\n   inline long double \n-  _CPP_sin_capture(long double __x) { return sin(static_cast<double>(__x)); }\n+  sin(long double __x) { return ::sin(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_SINHL\n   inline long double \n-  _CPP_sinh_capture(long double __x) { return sinhl(__x); }\n+  sinh(long double __x) { return ::sinhl(__x); }\n #else\n   inline long double \n-  _CPP_sinh_capture(long double __x) { return sinh(static_cast<double>(__x)); }\n+  sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE___BUILTIN_SQRTL\n   inline long double \n-  _CPP_sqrt_capture(long double __x) { return __builtin_sqrtl(__x); }\n+  sqrt(long double __x) { return __builtin_sqrtl(__x); }\n #elif _GLIBCPP_HAVE_SQRTL\n   inline long double \n-  _CPP_sqrt_capture(long double __x) { return sqrtl(__x); }\n+  sqrt(long double __x) { return ::sqrtl(__x); }\n #else\n   inline long double \n-  _CPP_sqrt_capture(long double __x) { return sqrt(static_cast<double>(__x)); }\n+  sqrt(long double __x) { return ::sqrt(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_TANL\n   inline long double \n-  _CPP_tan_capture(long double __x) { return tanl(__x); }\n+  tan(long double __x) { return ::tanl(__x); }\n #else\n   inline long double \n-  _CPP_tan_capture(long double __x) { return tan(static_cast<double>(__x)); }\n+  tan(long double __x) { return ::tan(static_cast<double>(__x)); }\n #endif\n \n #if _GLIBCPP_HAVE_TANHL\n   inline long double \n-  _CPP_tanh_capture(long double __x) { return tanhl(__x); }\n+  tanh(long double __x) { return ::tanhl(__x); }\n #else\n   inline long double \n-  _CPP_tanh_capture(long double __x) { return tanh(static_cast<double>(__x)); }\n+  tanh(long double __x) { return ::tanh(static_cast<double>(__x)); }\n #endif\n-} // namespace _C_legacy\n-\n-# undef abs\n-# undef acos\n-# undef asin\n-# undef atan\n-# undef atan2\n-# undef ceil\n-# undef cos\n-# undef cosh\n-# undef exp\n-# undef fabs\n-# undef floor\n-# undef fmod\n-# undef frexp\n-# undef ldexp\n-# undef log\n-# undef log10\n-# undef modf\n-# undef pow\n-# undef sin\n-# undef sinh\n-# undef sqrt\n-# undef tan\n-# undef tanh\n-\n-namespace std {\n-  inline float \n-  abs(float __x) { return _C_legacy::_CPP_fabs_capture(__x); }\n-\n-  inline float \n-  acos(float __x) { return _C_legacy::_CPP_acos_capture(__x); }\n-\n-  inline float \n-  asin(float __x) { return _C_legacy::_CPP_asin_capture(__x); }\n-\n-  inline float \n-  atan(float __x) { return _C_legacy::_CPP_atan_capture(__x); }\n-\n-  inline float \n-  atan2(float __y, float __x) \n-  { return _C_legacy::_CPP_atan2_capture(__y, __x); }\n-\n-  inline float \n-  ceil(float __x) { return _C_legacy::_CPP_ceil_capture(__x); }\n-\n-  inline float \n-  cos(float __x) { return _C_legacy::_CPP_cos_capture(__x); }\n-\n-  inline float \n-  cosh(float __x) { return _C_legacy::_CPP_cosh_capture(__x); }\n-\n-  inline float \n-  exp(float __x) { return _C_legacy::_CPP_exp_capture(__x); }\n-\n-  inline float \n-  fabs(float __x) { return _C_legacy::_CPP_fabs_capture(__x); }\n-\n-  inline float \n-  floor(float __x) { return _C_legacy::_CPP_floor_capture(__x); }\n-\n-  inline float \n-  fmod(float __x, float __y) \n-  { return _C_legacy::_CPP_fmod_capture(__x, __y); }\n-\n-  inline float \n-  frexp(float __x, int* __exp) \n-  { return _C_legacy::_CPP_frexp_capture(__x, __exp); }\n-\n-  inline float \n-  ldexp(float __x, int __exp)\n-  { return _C_legacy::_CPP_ldexp_capture(__x, __exp); }\n-\n-  inline float \n-  log(float __x) { return _C_legacy::_CPP_log_capture(__x); }\n-\n-  inline float \n-  log10(float __x) { return _C_legacy::_CPP_log10_capture(__x); }\n-\n-  inline float \n-  modf(float __x, float* __iptr) \n-  { return _C_legacy::_CPP_modf_capture(__x, __iptr); }\n-\n-  inline float \n-  pow(float __x, float __y) { return _C_legacy::_CPP_pow_capture(__x, __y); }\n-\n-  float \n-  pow(float, int);\n-\n-  inline float \n-  sin(float __x) { return _C_legacy::_CPP_sin_capture(__x); }\n-\n-  inline float \n-  sinh(float __x) { return _C_legacy::_CPP_sinh_capture(__x); }\n \n-  inline float \n-  sqrt(float __x) { return _C_legacy::_CPP_sqrt_capture(__x); }\n-\n-  inline float \n-  tan(float __x) { return _C_legacy::_CPP_tan_capture(__x); }\n-\n-  inline float \n-  tanh(float __x) { return _C_legacy::_CPP_tanh_capture(__x); }\n-\n-  inline double \n-  abs(double __x) { return _C_legacy::_CPP_fabs_capture(__x); }\n \n-  inline double \n-  acos(double __x) { return _C_legacy::_CPP_acos_capture(__x); }\n-\n-  inline double \n-  asin(double __x) { return _C_legacy::_CPP_asin_capture(__x); }\n-\n-  inline double \n-  atan(double __x) { return _C_legacy::_CPP_atan_capture(__x); }\n-\n-  inline double \n-  atan2(double __y, double __x) \n-  { return _C_legacy::_CPP_atan2_capture(__y, __x); }\n-\n-  inline double \n-  ceil(double __x) { return _C_legacy::_CPP_ceil_capture(__x); }\n-\n-  inline double \n-  cos(double __x) { return _C_legacy::_CPP_cos_capture(__x); }\n-\n-  inline double \n-  cosh(double __x) { return _C_legacy::_CPP_cosh_capture(__x); }\n-\n-  inline double \n-  exp(double __x) { return _C_legacy::_CPP_exp_capture(__x); }\n-\n-  inline double \n-  fabs(double __x) { return _C_legacy::_CPP_fabs_capture(__x); }\n-\n-  inline double \n-  floor(double __x) { return _C_legacy::_CPP_floor_capture(__x); }\n-\n-  inline double \n-  fmod(double __x, double __y) \n-  { return _C_legacy::_CPP_fmod_capture(__x, __y); }\n-\n-  inline double \n-  frexp(double __x, int* __exp) \n-  { return _C_legacy::_CPP_frexp_capture(__x, __exp); }\n-\n-  inline double \n-  ldexp(double __x, int __exp)\n-  { return _C_legacy::_CPP_ldexp_capture(__x, __exp); }\n-\n-  inline double \n-  log(double __x) { return _C_legacy::_CPP_log_capture(__x); }\n-\n-  inline double \n-  log10(double __x) { return _C_legacy::_CPP_log10_capture(__x); }\n-\n-  inline double \n-  modf(double __x, double* __iptr) \n-  { return _C_legacy::_CPP_modf_capture(__x, __iptr); }\n-\n-  inline double \n-  pow(double __x, double __y) \n-  { return _C_legacy::_CPP_pow_capture(__x, __y); }\n-\n-  double \n-  pow(double, int);\n-\n-  inline double \n-  sin(double __x) { return _C_legacy::_CPP_sin_capture(__x); }\n-\n-  inline double \n-  sinh(double __x) { return _C_legacy::_CPP_sinh_capture(__x); }\n-\n-  inline double \n-  sqrt(double __x) { return _C_legacy::_CPP_sqrt_capture(__x); }\n-\n-  inline double \n-  tan(double __x) { return _C_legacy::_CPP_tan_capture(__x); }\n-\n-  inline double \n-  tanh(double __x) { return _C_legacy::_CPP_tanh_capture(__x); }\n-\n-  inline long double \n-  abs(long double __x) { return _C_legacy::_CPP_fabs_capture(__x); }\n-\n-  inline long double \n-  acos(long double __x) { return _C_legacy::_CPP_acos_capture(__x); }\n-\n-  inline long double \n-  asin(long double __x) { return _C_legacy::_CPP_asin_capture(__x); }\n-\n-  inline long double \n-  atan(long double __x) { return _C_legacy::_CPP_atan_capture(__x); }\n-\n-  inline long double \n-  atan2(long double __y, long double __x) \n-  { return _C_legacy::_CPP_atan2_capture(__y, __x); }\n-\n-  inline long double \n-  ceil(long double __x) { return _C_legacy::_CPP_ceil_capture(__x); }\n-\n-  inline long double \n-  cos(long double __x) { return _C_legacy::_CPP_cos_capture(__x); }\n-\n-  inline long double \n-  cosh(long double __x) { return _C_legacy::_CPP_cosh_capture(__x); }\n-\n-  inline long double \n-  exp(long double __x) { return _C_legacy::_CPP_exp_capture(__x); }\n-\n-  inline long double \n-  fabs(long double __x) { return _C_legacy::_CPP_fabs_capture(__x); }\n-\n-  inline long double \n-  floor(long double __x) { return _C_legacy::_CPP_floor_capture(__x); }\n-\n-  inline long double \n-  fmod(long double __x, long double __y) \n-  { return _C_legacy::_CPP_fmod_capture(__x, __y); }\n-\n-  inline long double \n-  frexp(long double __x, int* __exp)\n-  { return _C_legacy::_CPP_frexp_capture(__x, __exp); }\n-\n-  inline long double \n-  ldexp(long double __x, int __exp)\n-  { return _C_legacy::_CPP_ldexp_capture(__x, __exp); }\n-\n-  inline long double \n-  log(long double __x) { return _C_legacy::_CPP_log_capture(__x); }\n-\n-  inline long double \n-  log10(long double __x) { return _C_legacy::_CPP_log10_capture(__x); }\n-\n-  inline long double \n-  modf(long double __x, long double* __iptr) \n-  { return _C_legacy::_CPP_modf_capture(__x, __iptr); }\n-\n-  inline long double \n-  pow(long double __x, long double __y)\n-  { return _C_legacy::_CPP_pow_capture(__x, __y); }\n-\n-  long double \n-  pow(long double, int);\n-\n-  inline long double \n-  sin(long double __x) { return _C_legacy::_CPP_sin_capture(__x); }\n-\n-  inline long double \n-  sinh(long double __x) { return _C_legacy::_CPP_sinh_capture(__x); }\n-\n-  inline long double \n-  sqrt(long double __x) { return _C_legacy::_CPP_sqrt_capture(__x); }\n-\n-  inline long double \n-  tan(long double __x) { return _C_legacy::_CPP_tan_capture(__x); }\n-\n-  inline long double \n-  tanh(long double __x) { return _C_legacy::_CPP_tanh_capture(__x); }\n-\n-} // namespace std\n-\n-# undef _IN_C_LEGACY_\n+} // std\n \n+#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT\n+#  define export\n+#  include <bits/cmath.tcc>\n #endif\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n+#endif"}, {"sha": "ea30d8d868d10a0a92546e7c9c5ffa18d538e9f1", "filename": "libstdc++-v3/include/c_std/bits/std_csetjmp.h", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_csetjmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_csetjmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_csetjmp.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,33 +31,18 @@\n // ISO C++ 14882: 20.4.6  C library\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CSETJMP\n #define _CPP_CSETJMP 1\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <setjmp.h>\n-  }\n-  inline int \n-  _CPP_setjmp_capture(jmp_buf __jb) { return setjmp(__jb); }\n-} // namespace _C_legacy\n-\n-#  undef jmp_buf\n-#  undef setjmp\n-#  define setjmp(__jb) _C_legacy::_CPP_setjmp_capture(__jb)\n-#  undef longjmp\n-\n-namespace std {\n-  // Adopt C names into std::\n-  using _C_legacy::jmp_buf;\n-  using _C_legacy::longjmp;\n-} // namespace std\n-  \n-# undef _IN_C_LEGACY_\n-\n-#endif\n-\n+#pragma GCC system_header\n+#include <setjmp.h>\n \n+namespace std\n+{\n+  using ::jmp_buf;\n+  extern \"C\" void longjmp(jmp_buf, int);\n+}\n \n+#endif"}, {"sha": "e54db8aa8125a2618e888aac9dbf7bb0e7989490", "filename": "libstdc++-v3/include/c_std/bits/std_csignal.h", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_csignal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_csignal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_csignal.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,37 +31,19 @@\n // ISO C++ 14882: 20.4.6  C library\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CSIGNAL\n #define _CPP_CSIGNAL 1\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-    // XXX\n-#     undef __need_sig_atomic_t\n-#     undef __need_sigset_t\n-\n-#     pragma GCC system_header\n-#     include_next <signal.h>\n-  }\n-} // namespace _C_legacy\n+#pragma GCC system_header\n+#include <signal.h>\n \n-#  undef sig_atomic_t\n-#  undef raise\n-#  undef signal\n-\n-namespace std {\n-  // Adopt C names into std::\n-  using _C_legacy::sig_atomic_t;\n-  using _C_legacy::raise;\n-  using _C_legacy::signal;\n-} // namespace std\n-  \n-# undef _IN_C_LEGACY_\n+namespace std\n+{\n+  using ::sig_atomic_t;\n+  extern \"C\" void (*signal(int, void (*__func)(int)))(int); \n+  extern \"C\" int raise(int);\n+}\n \n #endif\n-\n-\n-\n-\n-"}, {"sha": "817cee5e5794d0b0ad3066635d4db52b35238f97", "filename": "libstdc++-v3/include/c_std/bits/std_cstdarg.h", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdarg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdarg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdarg.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,24 +31,17 @@\n // ISO C++ 14882: 20.4.6  C library\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CSTDARG\n #define _CPP_CSTDARG 1\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <stdarg.h>\n-  }\n-} // namespace _C_legacy\n-\n-#  undef va_list\n+#pragma GCC system_header\n+#include <stdarg.h>\n \n-namespace std {\n-  using _C_legacy::va_list;\n-} // namespace std\n-\n-# undef _IN_C_LEGACY_\n+namespace std\n+{\n+  using ::va_list;\n+}\n \n #endif\n-"}, {"sha": "184a533cfe3048557380e7b4a498396527eae6f9", "filename": "libstdc++-v3/include/c_std/bits/std_cstddef.h", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstddef.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,29 +31,18 @@\n // ISO C++ 14882: 18.1  Types\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CSTDDEF\n #define _CPP_CSTDDEF 1\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-// XXX\n-#   define __need_size_t\n-#   define __need_ptrdiff_t\n-#   define __need_NULL\n-#   include_next <stddef.h>\n-  }\n-} // namespace _C_legacy\n-\n-#  undef ptrdiff_t  \n-#  undef size_t  \n-\n-namespace std {\n-  using _C_legacy::ptrdiff_t;\n-  using _C_legacy::size_t;\n-} // namespace std\n-  \n-# undef _IN_C_LEGACY_\n+#pragma GCC system_header\n+#include <stddef.h>\n+\n+namespace std \n+{\n+  using ::ptrdiff_t;\n+  using ::size_t;\n+}\n \n #endif"}, {"sha": "62a19aabf2b9d38a803d8a06a9a2da8acba860da", "filename": "libstdc++-v3/include/c_std/bits/std_cstdio.h", "status": "modified", "additions": 71, "deletions": 239, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdio.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,253 +31,85 @@\n // ISO C++ 14882: 27.8.2  C Library files\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CSTDIO\n #define _CPP_CSTDIO 1\n \n-# include <bits/std_cstddef.h>  \n-# include <bits/std_cstdarg.h>  \n-\n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     undef __need_FILE\n-#     pragma GCC system_header\n-#     include_next <stdio.h>\n-  }\n-\n-  typedef FILE _CPP_FILE_capture;\n-  typedef fpos_t _CPP_fpos_t_capture;\n-\n-  inline FILE* \n-  _CPP_stderr_capture() { return stderr; }\n-\n-  inline FILE* \n-  _CPP_stdin_capture()  { return stdin; }\n-\n-  inline FILE* \n-  _CPP_stdout_capture() { return stdout; }\n-\n-  inline int \n-  _CPP_getc_capture(FILE* __f) { return getc(__f); }\n-\n-  inline int \n-  _CPP_getchar_capture() { return getchar(); }\n-\n-  inline int \n-  _CPP_putc_capture(int __c, FILE* __f) { return putc(__c, __f); }\n-  \n-  inline int \n-  _CPP_putchar_capture(int __c) { return putchar(__c); }\n- \n-  inline int \n-  _CPP_feof_capture(FILE* __f) { return feof(__f); }\n-\n-} // namespace _C_legacy\n-\n-# undef FILE \n-# undef fpos_t \n-\n-# undef remove\n-# undef rename\n-# undef tmpfile\n-# undef tmpnam\n-# undef fclose\n-# undef fflush\n-# undef fopen\n-# undef freopen\n-# undef setbuf\n-# undef setvbuf\n-# undef fprintf\n-# undef fscanf\n-# undef printf\n-# undef scanf\n-# undef sprintf\n-# undef sscanf\n-# undef vfprintf\n-# undef vprintf\n-# undef vsprintf\n-# undef fgetc\n-# undef fgets\n-# undef fputc\n-# undef fputs\n-# undef getc\n-# undef getchar\n-# undef gets\n-# undef putc\n-# undef putchar\n-# undef puts\n-# undef ungetc\n-# undef fread\n-# undef fwrite\n-# undef fgetpos\n-# undef fseek\n-# undef fsetpos\n-# undef ftell\n-# undef rewind\n-# undef clearerr\n-# undef feof\n-# undef ferror\n-# undef perror\n-  \n-# undef stderr\n-# define stderr std::_CPP_stderr()\n-# undef stdin\n-# define stdin  std::_CPP_stdin()\n-# undef stdout\n-# define stdout std::_CPP_stdout()\n-\n-namespace std {\n-  struct FILE : _C_legacy::_CPP_FILE_capture { };\n-  struct fpos_t { _C_legacy::_CPP_fpos_t_capture _M_dummy; };\n-\n-  using _C_legacy::remove;\n-  using _C_legacy::rename;\n-  using _C_legacy::tmpnam;\n-  using _C_legacy::printf;\n-  using _C_legacy::scanf;\n-  using _C_legacy::sprintf;\n-  using _C_legacy::sscanf;\n-  using _C_legacy::gets;\n-  using _C_legacy::perror;\n-\n-  inline FILE* \n-  _CPP_stderr()\n-  { return reinterpret_cast<FILE*>(_C_legacy::_CPP_stderr_capture() ); }\n-\n-  inline FILE* \n-  _CPP_stdin()\n-  { return reinterpret_cast<FILE*>(_C_legacy::_CPP_stdin_capture() ); }\n-\n-  inline FILE* \n-  _CPP_stdout()\n-  { return reinterpret_cast<FILE*>(_C_legacy::_CPP_stdout_capture() ); }\n-\n-  inline FILE*\n-  tmpfile() { return reinterpret_cast<FILE*>(_C_legacy::tmpfile()); }\n-\n-  inline int\n-  fclose(FILE* __f) { return _C_legacy::fclose(__f); }\n-\n-  inline int\n-  fflush(FILE* __f) { return _C_legacy::fflush(__f); }\n-\n-  inline FILE*\n-  fopen(char const* __name, char const* __mode) \n-  { return reinterpret_cast<FILE*>(_C_legacy::fopen(__name,__mode)); }\n-\n-  inline FILE*\n-  freopen(char const* __name, char const* __mode, FILE* __f) \n-  { return reinterpret_cast<FILE*>(_C_legacy::freopen(__name,__mode,__f)); }\n-\n-  inline void\n-  setbuf(FILE* __f, char* __buf) \n-  { return _C_legacy::setbuf(__f, __buf); }\n+#include <bits/std_cstdarg.h>\n+\n+#pragma GCC system_header\n+#include <stdio.h>\n+\n+// Get rid of those macros defined in <stdio.h> in lieu of real functions.\n+#undef clearerr\n+#undef feof\n+#undef ferror\n+#undef fileno\n+#undef getc\n+#undef getchar\n+#undef putc\n+#undef putchar\n+\n+namespace std \n+{\n+  using ::FILE;\n+  using ::fpos_t;\n+\n+  extern \"C\" int remove(const char*); \n+  extern \"C\" int rename(const char*, const char*); \n+  extern \"C\" FILE* tmpfile(void); \n+  extern \"C\" char* tmpnam(char*); \n+  extern \"C\" int fclose(FILE*); \n+  extern \"C\" int fflush(FILE*); \n+  extern \"C\" FILE* fopen(const char*, const char*); \n+  extern \"C\" FILE* freopen(const char*, const char*, FILE*); \n+  extern \"C\" void setbuf(FILE*, char*);\n+  extern \"C\" int setvbuf(FILE*, char*, int, size_t); \n+  extern \"C\" int fprintf(FILE*, const char*, ...); \n+  extern \"C\" int fscanf(FILE*, const char*, ...); \n+  extern \"C\" int printf(const char*, ...); \n+  extern \"C\" int scanf(const char*, ...); \n+  extern \"C\" int snprintf(char *, size_t, const char*, ...);\n+  extern \"C\" int sprintf(char *, const char*, ...); \n+  extern \"C\" int sscanf(const char*, const char*, ...); \n+  extern \"C\" int vfprintf(FILE*, const char*, va_list); \n+  extern \"C\" int vfscanf(FILE*, const char*, va_list); \n+  extern \"C\" int vprintf(const char*, va_list); \n+  extern \"C\" int vscanf(const char*, va_list); \n+  extern \"C\" int vsnprintf(char*, size_t, const char*, va_list); \n+  extern \"C\" int vsprintf(char*, const char*, va_list); \n+  extern \"C\" int vsscanf(const char*, const char*, va_list); \n+  extern \"C\" int fgetc(FILE *); \n+  extern \"C\" char *fgets(char*, int, FILE*); \n+  extern \"C\" int fputc(int, FILE*); \n+  extern \"C\" int fputs(const char*, FILE*); \n+  extern \"C\" int getc(FILE*); \n+  extern \"C\" int getchar(void); \n+  extern \"C\" char *gets(char*); \n+  extern \"C\" int putc(int, FILE*); \n+  extern \"C\" int putchar(int); \n+  extern \"C\" int puts(const char*); \n+  extern \"C\" int ungetc(int, FILE*);\n+  extern \"C\" size_t fread(void*, size_t, size_t, FILE*); \n+  extern \"C\" size_t fwrite(const void*, size_t, size_t, FILE*); \n+  extern \"C\" int fgetpos(FILE*, fpos_t*); \n+  extern \"C\" int fseek(FILE*, long int, int); \n+  extern \"C\" int fsetpos(FILE*, const fpos_t*); \n+  extern \"C\" long int ftell(FILE*); \n+  extern \"C\" void rewind(FILE*); \n+  extern \"C\" void clearerr(FILE*); \n+  extern \"C\" int feof(FILE*); \n+  extern \"C\" int ferror(FILE*); \n+  extern \"C\" void perror(const char*);\n+}\n \n-  inline int\n-  setvbuf(FILE* __f, char* __buf, int __mode, size_t __size) \n-  { return _C_legacy::setvbuf(__f, __buf, __mode, __size); }\n-\n-  inline int\n-  fprintf(FILE* __f, char const* __fmt, ...)\n-  { \n-    va_list __v; \n-    va_start(__v,__fmt); \n-    int __i = _C_legacy::vfprintf(__f, __fmt, __v); \n-    va_end(__v);\n-    return __i; \n-  }\n-\n-  inline int\n-  fscanf(FILE* __f, char const* __fmt, ...)\n-  { \n-    va_list __v; \n-    va_start(__v,__fmt); \n-    int __i = _C_legacy::vfscanf(__f, __fmt, __v); \n-    va_end(__v);\n-    return __i; \n-  }\n-\n-  inline int\n-  vfprintf(FILE* __f, char const* __fmt, va_list __v)\n-  { return _C_legacy::vfprintf(__f, __fmt, __v); }\n-\n-  inline int\n-  vprintf(char const* __fmt, va_list __v)\n-  { return _C_legacy::vprintf(__fmt, __v); }\n-\n-  inline int\n-  vsprintf(char* __buf, char const* __fmt, va_list __v)\n-  { return _C_legacy::vsprintf(__buf, __fmt, __v); }\n-\n-  inline int\n-  fgetc(FILE* __f) { return _C_legacy::fgetc(__f); }\n-\n-  inline char*\n-  fgets(char* __buf, int __n, FILE* __f) \n-  { return _C_legacy::fgets(__buf, __n, __f); }\n-\n-  inline int\n-  fputc(int __c, FILE* __f) { return _C_legacy::fputc(__c, __f); }\n-\n-  inline int\n-  fputs(char const* __s, FILE* __f) \n-  { return _C_legacy::fputs(__s, __f); }\n-\n-  inline int\n-  getc(FILE* __f) { return _C_legacy::_CPP_getc_capture(__f); }\n-\n-  inline int\n-  getchar() { return _C_legacy::_CPP_getchar_capture(); }\n-\n-  inline int\n-  putc(int __c, FILE* __f) \n-  { return _C_legacy::_CPP_putc_capture(__c, __f); }\n-\n-  inline int\n-  putchar(int __c) { return _C_legacy::_CPP_putchar_capture(__c); }\n-\n-  using _C_legacy::puts;\n-\n-  inline int\n-  ungetc(int __c, FILE* __f) { return _C_legacy::ungetc(__c, __f); }\n-\n-  inline size_t\n-  fread(void* __p, size_t __z, size_t __n, FILE* __f)\n-  { return _C_legacy::fread(__p,__z,__n,__f); }\n-\n-  inline size_t\n-  fwrite(void const* __p, size_t __z, size_t __n, FILE* __f)\n-  { return _C_legacy::fwrite(__p,__z,__n,__f); }\n-\n-  inline int\n-  fgetpos(FILE* __f, fpos_t* __pos)\n-  { return _C_legacy::fgetpos(__f,&__pos->_M_dummy); }\n-\n-  inline int\n-  fseek(FILE* __f, long __off, int __how)\n-  { return _C_legacy::fseek(__f,__off,__how); }\n-\n-  inline int\n-  fsetpos(FILE* __f, fpos_t const* __pos)\n-  { return _C_legacy::fsetpos(__f,&__pos->_M_dummy); }\n+#endif\n \n-  inline long\n-  ftell(FILE* __f) { return _C_legacy::ftell(__f); }\n \n-  inline void\n-  rewind(FILE* __f) { return _C_legacy::rewind(__f); }\n \n-  inline void\n-  clearerr(FILE* __f) { return _C_legacy::clearerr(__f); }\n \n-  inline int\n-  feof(FILE* __f) { return _C_legacy::_CPP_feof_capture(__f); }\n \n-  inline int\n-  ferror(FILE* __f) { return _C_legacy::ferror(__f); }\n-} // namespace std\n \n-# undef _IN_C_LEGACY_\n \n-#endif\n "}, {"sha": "a43c1c58b909c51adace6cdfed2de7a76191db19", "filename": "libstdc++-v3/include/c_std/bits/std_cstdlib.h", "status": "modified", "additions": 62, "deletions": 133, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstdlib.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,167 +31,96 @@\n // ISO C++ 14882: 20.4.6  C library\n //\n \n-// Function decls in this header are overloaded on the \n-// extern \"C\"-ness of arguments.  This is a rich ground\n-// for compiler bugs.\n+// Note: This is not a conforming implementation.\n \n #ifndef _CPP_CSTDLIB\n #define _CPP_CSTDLIB 1\n \n-# include <bits/c++config.h>\n-# include <bits/std_cstddef.h>  \n+#include <bits/c++config.h>\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <stdlib.h>\n-      typedef int (*_C_cmp_fun_ptr)(const void*, const void*);  // C fn ptr\n-    }\n+#pragma GCC system_header\n+#include <stdlib.h>\n \n-  typedef div_t   _CPP_div_t_capture;\n-  typedef ldiv_t  _CPP_ldiv_t_capture;\n-\n-# if _GLIBCPP_HAVE_LLDIV_T\n-  typedef lldiv_t  _CPP_lldiv_t_capture;\n-# endif\n-} // namespace _C_legacy\n-\n-#  undef wchar_t\n-#  undef div_t\n-#  undef ldiv_t\n-\n-#  undef atof\n-#  undef atoi\n-#  undef atol\n-#  undef strtod\n-#  undef strtol\n-#  undef strtoul\n-#ifdef _GLIBCPP_HAVE_STRTOLD\n-#  undef strtold\n-#endif\n-#  undef rand\n-#  undef srand\n-#  undef calloc\n-#  undef free\n-#  undef malloc\n-#  undef realloc\n-#  undef abort\n-#  undef atexit\n-#  undef exit\n-#  undef getenv\n-#  undef system\n-#  undef bsearch\n-#  undef qsort\n-#  undef abs\n-#  undef div\n-#  undef labs\n-#  undef ldiv\n-#ifdef _GLIBCPP_USE_LONG_LONG\n-#  undef llabs\n-#  undef lldiv\n-#endif\n-#  undef mblen\n-#  undef mbtowc\n-#  undef wctomb\n-#  undef mbstowcs\n-#  undef wcstombs\n-\n-namespace std {\n-  struct div_t : _C_legacy::_CPP_div_t_capture { };\n-  struct ldiv_t : _C_legacy::_CPP_ldiv_t_capture { };\n+namespace std \n+{\n+  using ::div_t;\n+  using ::ldiv_t;\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n # ifdef _GLIBCPP_HAVE_LLDIV_T\n-  struct lldiv_t : _C_legacy::_CPP_lldiv_t_captur { };\n+  using ::lldiv_t;\n # else\n   struct lldiv_t\n   {\n     long long quot;\n     long long rem;\n   };\n # endif\n-#endif\n-\n-  using _C_legacy::atof;\n-  using _C_legacy::atoi;\n-  using _C_legacy::atol;\n-  using _C_legacy::strtod;\n-  using _C_legacy::strtol;\n-  using _C_legacy::strtoul;\n-  using _C_legacy::rand;\n-  using _C_legacy::srand;\n-  using _C_legacy::calloc;\n-  using _C_legacy::free;\n-  using _C_legacy::malloc;\n-  using _C_legacy::realloc;\n-\n-  //  using _C_legacy::abort;\n-  using _C_legacy::atexit;\n-  //  using _C_legacy::exit;\n-  using _C_legacy::bsearch;\n-  using _C_legacy::qsort; \n-\n-  using _C_legacy::getenv;\n-  using _C_legacy::system;\n-  using _C_legacy::mbtowc;\n-  using _C_legacy::wctomb;\n-  using _C_legacy::mbstowcs;\n-  using _C_legacy::wcstombs;\n-\n-  using _C_legacy::strtof;\n-\n-#ifdef _GLIBCPP_USE_LONG_LONG\n-  using _C_legacy::strtoll;\n-  using _C_legacy::strtoull;\n-#endif\n-\n-#ifdef _GLIBCPP_HAVE_STRTOLD\n-  using _C_legacy::strtold;\n-#endif\n-\n-  using _C_legacy::mblen;\n-\n-  inline int \n-  abs(int __x) { return __x >= 0 ? __x : -__x; }\n-\n-  inline div_t \n-  div(int __n, int __d)\n-  { div_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }\n-\n-  inline long \n-  labs(long __x) { return __x >= 0 ? __x : -__x; }\n-\n-  inline long \n-  abs(long __x) { return __x >= 0 ? __x : -__x; }\n-\n-  inline ldiv_t \n-  ldiv(long __n, long __d)\n-  { ldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }\n-\n-  inline ldiv_t \n-  div(long __n, long __d)\n-  { ldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }\n+#endif \n+\n+  extern \"C\" double atof(const char*); \n+  extern \"C\" int atoi(const char*); \n+  extern \"C\" long int atol(const char*); \n+  extern \"C\" double strtod(const char*, char**); \n+  extern \"C\" float strtof(const char*, char**); \n+  extern \"C\" long int strtol(const char*, char**, int); \n+  extern \"C\" unsigned long int strtoul(const char*, char**, int);\n+  extern \"C\" int rand(void); \n+  extern \"C\" void srand(unsigned int); \n+  extern \"C\" void* calloc(size_t, size_t); \n+  extern \"C\" void free(void*); \n+  extern \"C\" void* malloc(size_t); \n+  extern \"C\" void* realloc(void*, size_t); \n+  extern \"C\" void abort(void); \n+  extern \"C\" int atexit(void (*func)(void)); \n+  extern \"C\" void exit(int); \n+  extern \"C\" void _Exit(int); \n+  extern \"C\" char*getenv(const char*); \n+  extern \"C\" int system(const char*); \n+  extern \"C\" void* bsearch(const void*, const void*, size_t, size_t, \n+\t\t\t   int (*comp)(const void *, const void *)); \n+  extern \"C\" void qsort(void*, size_t, size_t, \n+\t\t\tint (*comp)(const void *, const void *)); \n+  extern \"C\" int abs(int); \n+  extern \"C\" long int labs(long int); \n+  extern \"C\" div_t div(int, int); \n+  extern \"C\" ldiv_t ldiv(long int, long int); \n+  extern \"C\" int mblen(const char*, size_t); \n+  extern \"C\" int mbtowc(wchar_t*, const char*, size_t); \n+  extern \"C\" int wctomb(char*, wchar_t); \n+  extern \"C\" size_t mbstowcs(wchar_t*, const char*, size_t); \n+  extern \"C\" size_t wcstombs(char*, const wchar_t*, size_t);\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n   inline long long \n-  llabs(long long __x) { return __x >= 0 ? __x : -__x; }\n+  abs(long long __x) { return __x >= 0 ? __x : -__x; }\n \n   inline long long \n-  abs(long long __x) { return __x >= 0 ? __x : -__x; }\n+  llabs(long long __x) { return __x >= 0 ? __x : -__x; }\n \n   inline lldiv_t \n-  lldiv(long long __n, long long __d)\n+  div(long long __n, long long __d)\n   { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }\n \n   inline lldiv_t \n-  div(long long __n, long long __d)\n+  lldiv(long long __n, long long __d)\n   { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }\n+\n+  extern \"C\" long long int atoll(const char*); \n+  extern \"C\" long long int strtoll(const char*, char**, int); \n+  extern \"C\" unsigned long long int strtoull(const char*, char**, int); \n #endif\n-} // namespace std\n-  \n-# undef _IN_C_LEGACY_\n \n+#ifdef _GLIBCPP_HAVE_STRTOLD\n+  extern \"C\" long double strtold(const char*, char**); \n #endif\n+}\n+\n+#endif \n+\n+\n+\n+\n+\n \n "}, {"sha": "581c7a72863d5915464ece3374c82decb829cde4", "filename": "libstdc++-v3/include/c_std/bits/std_cstring.h", "status": "modified", "additions": 34, "deletions": 240, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstring.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstring.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cstring.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,249 +31,43 @@\n // ISO C++ 14882: 20.4.6  C library\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CSTRING\n #define _CPP_CSTRING 1\n \n-# if defined __GLIBC__ && __GLIBC__ >= 2\n-// We must not see the optimized string functions GNU libc defines.\n-#  define __NO_STRING_INLINES\n-# endif\n-\n-# include <bits/std_cstddef.h>  \n-\n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <string.h>\n-  }\n-\n-  // We do inline captures of most of these in case they\n-  // have been optimized with macros.  \n-  inline void* \n-  _CPP_memcpy_capture(void* __s1, void const* __s2, size_t __n)\n-  { return memcpy(__s1, __s2, __n); }\n-\n-  inline void* \n-  _CPP_memmove_capture(void* __s1, void const* __s2, size_t __n)\n-  { return memmove(__s1, __s2, __n); }\n-\n-  inline void* \n-  _CPP_strcpy_capture(char* __s1, char const* __s2)\n-  { return strcpy(__s1, __s2); }\n-\n-  inline char* \n-  _CPP_strncpy_capture(char* __s1, char const* __s2, size_t __n)\n-  { return strncpy(__s1, __s2, __n); }\n-\n-  inline char* \n-  _CPP_strcat_capture(char* __s1, char const* __s2)\n-  { return strcat(__s1, __s2); }\n-\n-  inline char* \n-  _CPP_strncat_capture(char* __s1, char const* __s2, size_t __n)\n-  { return strncat(__s1, __s2, __n); }\n-\n-  inline int \n-  _CPP_memcmp_capture(void const* __s1, void const* __s2, size_t __n)\n-  { return memcmp(__s1, __s2, __n); }\n-\n-  inline int \n-  _CPP_strcmp_capture(char const* __s1, char const* __s2)\n-  { return strcmp(__s1, __s2); }\n-\n-  inline int \n-  _CPP_strcoll_capture(char const* __s1, char const* __s2)\n-  { return strcoll(__s1, __s2); }\n-\n-  inline int \n-  _CPP_strncmp_capture(char const* __s1, char const* __s2, size_t __n)\n-  { return strncmp(__s1, __s2, __n); }\n-\n-  inline size_t \n-  _CPP_strxfrm_capture(char* __b, char const* __s, size_t __n)\n-  { return strxfrm(__b, __s, __n); }\n-\n-  inline void* \n-  _CPP_memchr_capture(void const* __s1, int __c, size_t __n)\n-  { return memchr(__s1, __c, __n); }\n-\n-  inline char* \n-  _CPP_strchr_capture(char const* __s1, int __c)\n-  { return strchr(__s1, __c); }\n-\n-  inline size_t \n-  _CPP_strcspn_capture(char const* __s1, char const* __s2)\n-  { return strcspn(__s1, __s2); }\n-\n-  inline char* \n-  _CPP_strpbrk_capture(char const* __s1, char const* __s2)\n-  { return strpbrk(__s1, __s2); }\n-\n-  inline char* \n-  _CPP_strrchr_capture(char const* __s1, int __c)\n-  { return strrchr(__s1, __c); }\n-\n-  inline size_t \n-  _CPP_strspn_capture(char const* __s1, char const* __s2)\n-  { return strspn(__s1, __s2); }\n-\n-  inline char* \n-  _CPP_strstr_capture(char const* __s1, char const* __s2)\n-  { return strstr(__s1, __s2); }\n-\n-  inline char* \n-  _CPP_strtok_capture(char* __s1, char const* __s2)\n-  { return strtok(__s1, __s2); }\n-\n-  inline void* \n-  _CPP_memset_capture(void* __s, int __c, size_t __n)\n-  { return memset(__s, __c, __n); }\n-\n-  // inline char* \n-  // _CPP_strerror_capture(int __num)\n-  // { return strerror(__num); }\n-\n-  inline size_t \n-  _CPP_strlen_capture(char const* __s)\n-  { return strlen(__s); }\n-} // namespace _C_legacy\n-\n-# undef memcpy\n-# undef memmove\n-# undef strcpy\n-# undef strncpy\n-# undef strcat\n-# undef strncat\n-# undef memcmp\n-# undef strcmp\n-# undef strcoll\n-# undef strncmp\n-# undef strxfrm\n-# undef memchr\n-# undef strchr\n-# undef strcspn\n-# undef strpbrk\n-# undef strrchr\n-# undef strspn\n-# undef strstr\n-# undef strtok\n-# undef memset\n-# undef strerror\n-# undef strlen\n-\n-namespace std {\n-  // Redefine most of these inline.  Note that the \n-  // C++ definition differs from C in some cases.\n-  inline void* \n-  memcpy(void* __s1, void const* __s2, size_t __n)\n-  { return _C_legacy::_CPP_memcpy_capture(__s1, __s2, __n); }\n-\n-  inline void* \n-  memmove(void* __s1, void const* __s2, size_t __n)\n-  { return _C_legacy::_CPP_memmove_capture(__s1, __s2, __n); }\n+#include <bits/c++config.h>\n+\n+#pragma GCC system_header\n+#include <string.h>\n+\n+namespace std \n+{\n+  extern \"C\" void* memcpy(void*, const void*, size_t); \n+  extern \"C\" void* memmove(void*, const void*, size_t); \n+  extern \"C\" char* strcpy(char*, const char*); \n+  extern \"C\" char* strncpy(char*, const char*, size_t); \n+  extern \"C\" char* strcat(char*, const char*); \n+  extern \"C\" char* strncat(char*, const char*, size_t); \n+  extern \"C\" int memcmp(const void*, const void*, size_t); \n+  extern \"C\" int strcmp(const char*, const char*); \n+  extern \"C\" int strcoll(const char*, const char*); \n+  extern \"C\" int strncmp(const char*, const char*, size_t); \n+  extern \"C\" size_t strxfrm(char*, const char*, size_t); \n+  extern \"C\" void* memchr(const void*, int, size_t); \n+  extern \"C\" char* strchr(const char*, int); \n+  extern \"C\" size_t strcspn(const char*, const char*); \n+  extern \"C\" char* strpbrk(const char*, const char*); \n+  extern \"C\" char* strrchr(const char*, int); \n+  extern \"C\" size_t strspn(const char*, const char*); \n+  extern \"C\" char* strstr(const char*, const char*); \n+  extern \"C\" char* strtok(char*, const char*); \n+  extern \"C\" void* memset(void*, int, size_t); \n+  extern \"C\" char* strerror(int); \n+  extern \"C\" size_t strlen(const char*);\n+}\n \n-  inline void* \n-  strcpy(char* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strcpy_capture(__s1, __s2); }\n-\n-  inline char* \n-  strncpy(char* __s1, char const* __s2, size_t __n)\n-  { return _C_legacy::_CPP_strncpy_capture(__s1, __s2, __n); }\n-\n-  inline char* \n-  strcat(char* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strcat_capture(__s1, __s2); }\n-\n-  inline char* \n-  strncat(char* __s1, char const* __s2, size_t __n)\n-  { return _C_legacy::_CPP_strncat_capture(__s1, __s2, __n); }\n-\n-  inline int \n-  memcmp(void const* __s1, void const* __s2, size_t __n)\n-  { return _C_legacy::_CPP_memcmp_capture(__s1, __s2, __n); }\n-\n-  inline int \n-  strcmp(char const* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strcmp_capture(__s1, __s2); }\n-\n-  inline int \n-  strcoll(char const* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strcoll_capture(__s1, __s2); }\n-\n-  inline int \n-  strncmp(char const* __s1, char const* __s2, size_t __n)\n-  { return _C_legacy::_CPP_strncmp_capture(__s1, __s2, __n); }\n-\n-  inline size_t \n-  strxfrm(char* __b, char const* __s, size_t __n)\n-  { return _C_legacy::_CPP_strxfrm_capture(__b, __s, __n); }\n-\n-  inline void \n-  const* memchr(void const* __s1, int __c, size_t __n)\n-  { return _C_legacy::_CPP_memchr_capture(__s1, __c, __n); }\n-\n-  inline void* \n-  memchr(void* __s1, int __c, size_t __n)\n-  { return _C_legacy::_CPP_memchr_capture(__s1, __c, __n); }\n-\n-  inline char const* \n-  strchr(char const* __s1, int __c)\n-  { return _C_legacy::_CPP_strchr_capture(__s1, __c); }\n-\n-  inline char*\n-  strchr(char* __s1, int __c)\n-  { return _C_legacy::_CPP_strchr_capture(__s1, __c); }\n-\n-  inline size_t \n-  strcspn(char const* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strcspn_capture(__s1, __s2); }\n-\n-  inline char const* \n-  strpbrk(char const* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strpbrk_capture(__s1, __s2); }\n-\n-  inline char* \n-  strpbrk(char* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strpbrk_capture(__s1, __s2); }\n-\n-  inline char const* \n-  strrchr(char const* __s1, int __c)\n-  { return _C_legacy::_CPP_strrchr_capture(__s1, __c); }\n-\n-  inline char* \n-  strrchr(char* __s1, int __c)\n-  { return _C_legacy::_CPP_strrchr_capture(__s1, __c); }\n-\n-  inline size_t \n-  strspn(char const* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strspn_capture(__s1, __s2); }\n-\n-  inline char const* \n-  strstr(char const* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strstr_capture(__s1, __s2); }\n-\n-  inline char* \n-  strstr(char* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strstr_capture(__s1, __s2); }\n-\n-  inline char* \n-  strtok(char* __s1, char const* __s2)\n-  { return _C_legacy::_CPP_strtok_capture(__s1, __s2); }\n-\n-  inline void* \n-  memset(void* __s, int __c, size_t __n)\n-  { return _C_legacy::_CPP_memset_capture(__s, __c, __n); }\n-\n-  using _C_legacy::strerror;\n-\n-  inline size_t \n-  strlen(char const* __s)\n-  { return _C_legacy::_CPP_strlen_capture(__s); }\n-\n-} // namespace std\n+#endif\n \n-# undef _IN_C_LEGACY_\n \n-#endif\n "}, {"sha": "f340c8e4b92c77096c6c5db0ff5818da975b457b", "filename": "libstdc++-v3/include/c_std/bits/std_ctime.h", "status": "modified", "additions": 22, "deletions": 70, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_ctime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_ctime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_ctime.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -31,77 +31,29 @@\n // ISO C++ 14882: 20.5  Date and time\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CTIME\n #define _CPP_CTIME 1\n \n-# include <bits/std_cstddef.h>  \n-\n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-\n-      // XXX\n-      // glibc 2.1.x time.h is on crack\n-#     undef __need_time_t\n-#     undef __need_clock_t\n-#     undef __need_timespec\n-\n-#     include_next <time.h>\n-  }\n-\n-  typedef clock_t\t_CPP_clock_t_capture;\n-  typedef time_t    \t_CPP_time_t_capture;\n-  typedef tm \t\t_CPP_tm_capture;\n-\n-} // namespace _C_legacy\n-\n-#  undef clock_t\n-#  undef time_t\n-#  undef tm\n-#  undef clock\n-#  undef difftime\n-#  undef mktime\n-#  undef time\n-#  undef asctime\n-#  undef ctime\n-#  undef gmtime\n-#  undef localtime\n-#  undef strftime\n-\n-namespace std {\n-\n-  // Adopt C names into std::\n-  typedef _C_legacy::_CPP_clock_t_capture  clock_t;\n-  typedef _C_legacy::_CPP_time_t_capture   time_t;\n-  struct tm : _C_legacy::_CPP_tm_capture  { };\n-\n-  using _C_legacy::clock;\n-  using _C_legacy::difftime;\n-  using _C_legacy::mktime;\n-  using _C_legacy::time;\n-  using _C_legacy::ctime;\n-\n-  inline char* \n-  asctime(const tm* __t) \n-  { return _C_legacy::asctime(static_cast<_C_legacy::_CPP_tm_capture const*>(__t)); }\n-\n-  inline tm* \n-  gmtime(time_t const* __tp) \n-  { return reinterpret_cast<tm*>(_C_legacy::gmtime(__tp)); }\n-\n-  inline tm* \n-  localtime(const time_t* __tp) \n-  { return reinterpret_cast<tm*>(_C_legacy::localtime(__tp)); } \n-    \n-  inline size_t \n-  strftime(char* __buf, size_t __maxsz, char const* __fmt, tm const* __tp) \n-  { return _C_legacy::strftime(__buf, __maxsz, __fmt,\n-\t       \t       static_cast<_C_legacy::_CPP_tm_capture const*>(__tp)); }\n-\n-} // namespace std\n-  \n-# undef _IN_C_LEGACY_\n+#pragma GCC system_header\n+#include <time.h>\n+\n+namespace std\n+{\n+  using ::clock_t;\n+  using ::time_t;\n+  using ::tm;\n+\n+  extern \"C\" clock_t clock(void); \n+  extern \"C\" double difftime(time_t, time_t); \n+  extern \"C\" time_t mktime(struct tm*); \n+  extern \"C\" time_t time(time_t*); \n+  extern \"C\" char* asctime(const struct tm*); \n+  extern \"C\" char* ctime(const time_t*); \n+  extern \"C\" struct tm* gmtime(const time_t*); \n+  extern \"C\" struct tm* localtime(const time_t*); \n+  extern \"C\" size_t strftime(char*, size_t, const char*, const struct tm*);\n+}\n \n #endif\n-"}, {"sha": "c9ccc86b7c2d4e00d4e1b39246d05d22181de6bf", "filename": "libstdc++-v3/include/c_std/bits/std_cwchar.h", "status": "modified", "additions": 110, "deletions": 228, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cwchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cwchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cwchar.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,6 +1,6 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -28,246 +28,128 @@\n // the GNU General Public License.\n \n //\n-// ISO C++ 14882: 21\n+// ISO C++ 14882: ???\n+//\n \n-#ifndef _CPP_CWCHAR\n-# define _CPP_CWCHAR 1\n-# include <bits/std_cstdio.h> \n+// Note: This is not a conforming implementation.\n \n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <wchar.h>\n-  }\n+#ifndef _CPP_CWCHAR\n+#define _CPP_CWCHAR 1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_cstdio.h>\n+#include <bits/std_cstdarg.h>\n+\n+#if _GLIBCPP_USE_WCHAR_T\n+#pragma GCC system_header\n+#include <wchar.h>\n+\n+// Get rid of those macros defined in <wchar.h> in lieu of real functions.\n+#undef getwchar\n+\n+namespace std\n+{\n+  using ::wint_t;\n+  using ::mbstate_t;\n+\n+  extern \"C\" wint_t btowc(int); \n+  extern \"C\" int wctob(wint_t); \n+  extern \"C\" wint_t fgetwc(FILE*); \n+  extern \"C\" wchar_t* fgetws(wchar_t*, int, FILE*); \n+  extern \"C\" wint_t fputwc(wchar_t, FILE*); \n+  extern \"C\" int fputws(const wchar_t*, FILE*); \n+  extern \"C\" int fwide(FILE*, int); \n+  extern \"C\" int fwprintf(FILE*, const wchar_t*, ...); \n+  extern \"C\" int fwscanf(FILE*, const wchar_t*, ...); \n+  extern \"C\" int swprintf(wchar_t*, size_t, const wchar_t*, ...); \n+  extern \"C\" int swscanf(const wchar_t*, const wchar_t*, ...); \n+  extern \"C\" int vfwprintf(FILE*, const wchar_t*, va_list); \n+  extern \"C\" int vfwscanf(FILE*, const wchar_t*, va_list); \n+  extern \"C\" int vswprintf(wchar_t*, size_t, const wchar_t*, va_list); \n+  extern \"C\" int vswscanf(const wchar_t*, const wchar_t*, va_list); \n+  extern \"C\" int vwprintf(const wchar_t*, va_list); \n+  extern \"C\" int vwscanf(const wchar_t*, va_list); \n+  extern \"C\" int wprintf(const wchar_t*, ...); \n+  extern \"C\" int wscanf(const wchar_t*, ...); \n+  extern \"C\" wint_t getwc(FILE* stream); \n+  extern \"C\" wint_t getwchar(void); \n+  extern \"C\" int mbsinit(const mbstate_t*); \n+  extern \"C\" size_t mbrlen(const char*, size_t, mbstate_t*); \n+  extern \"C\" size_t mbrtowc(wchar_t*, const char*, size_t, mbstate_t*); \n+  extern \"C\" size_t mbsrtowcs(wchar_t*, const char**, size_t, mbstate_t*); \n+  extern \"C\" size_t wcsrtombs(char*, const wchar_t **, size_t, mbstate_t*);\n+  extern \"C\" wint_t putwc(wchar_t, FILE*); \n+  extern \"C\" wint_t putwchar(wchar_t); \n+  extern \"C\" wint_t ungetwc(wint_t, FILE*);\n+  extern \"C\" size_t wcrtomb(char*, wchar_t, mbstate_t*); \n+  extern \"C\" double wcstod(const wchar_t*, wchar_t**); \n+  extern \"C\" float wcstof(const wchar_t*, wchar_t**); \n+  extern \"C\" long int wcstol(const wchar_t*, wchar_t**, int); \n+  extern \"C\" unsigned long int wcstoul(const wchar_t*, wchar_t**, int); \n+  extern \"C\" wchar_t* wcscpy(wchar_t* s1, const wchar_t*); \n+  extern \"C\" wchar_t* wcsncpy(wchar_t*, const wchar_t*, size_t); \n+  extern \"C\" wchar_t* wcscat(wchar_t*, const wchar_t*); \n+  extern \"C\" wchar_t* wcsncat(wchar_t*, const wchar_t*, size_t); \n+  extern \"C\" int wcscmp(const wchar_t*, const wchar_t*); \n+  extern \"C\" int wcscoll(const wchar_t*, const wchar_t*); \n+  extern \"C\" int wcsncmp(const wchar_t*, const wchar_t*, size_t); \n+  extern \"C\" size_t wcsxfrm(wchar_t*, const wchar_t*, size_t); \n+  extern \"C\" wchar_t* wcschr(const wchar_t*, wchar_t); \n+  extern \"C\" size_t wcscspn(const wchar_t*, const wchar_t*); \n+  extern \"C\" size_t wcslen(const wchar_t*); \n+  extern \"C\" wchar_t* wcspbrk(const wchar_t*, const wchar_t*); \n+  extern \"C\" wchar_t* wcsrchr(const wchar_t*, wchar_t); \n+  extern \"C\" size_t wcsspn(const wchar_t*, const wchar_t*); \n+  extern \"C\" wchar_t* wcsstr(const wchar_t*, const wchar_t*); \n+  extern \"C\" wchar_t* wcstok(wchar_t*, const wchar_t*, wchar_t**); \n+  extern \"C\" wchar_t* wmemchr(const wchar_t*, wchar_t, size_t);\n+  extern \"C\" int wmemcmp(const wchar_t*, const wchar_t*, size_t); \n+  //extern \"C\" int wmemcmp(wchar_t*, const wchar_t*, size_t); \n+  extern \"C\" wchar_t* wmemcpy(wchar_t*, const wchar_t*, size_t); \n+  extern \"C\" wchar_t* wmemmove(wchar_t*, const wchar_t*, size_t); \n+  extern \"C\" wchar_t* wmemset(wchar_t*, wchar_t, size_t); \n+  extern \"C\" size_t wcsftime(wchar_t*, size_t, const wchar_t*, const struct tm*); \n \n #if 0\n-  // XXX\n-  inline int \n-  fwprintf(FILE* __stream, const wchar_t* __format, ...); \n-\n-  inline int \n-  fwscanf(FILE* __stream, const wchar_t* __format, ...); \n-\n-  inline int \n-  vfwprintf(FILE* __stream, const wchar_t* __format, va_list __arg); \n-\n-  inline int \n-  vfwscanf(FILE* __stream, const wchar_t* __format, va_list __arg);\n-\n-  inline wint_t \n-  _CPP_fgetwc_capture(FILE* __stream)\n-  { return fgetwc(__stream); }\n-\n-  inline wchar_t*\n-  _CPP_fgetws_capture(wchar_t* __s, int __n, FILE* __stream)\n-  { return fgetws(__s, __n, __stream); }\n-\n-  inline wint_t \n-  _CPP_fputwc_capture(wchar_t __c, FILE* __stream)\n-  { return fputwc(__c, __stream); }\n-\n-  inline int \n-  _CPP_fputws_capture(const wchar_t* __s, FILE* __stream)\n-  { return fputws(__s, __stream); }\n-\n-  inline int \n-  _CPP_fwide_capture(FILE* __stream, int __mode) \n-  { return fwide(__stream, __mode); }\n-\n-  inline wint_t \n-  _CPP_fgetwc_capture(FILE* __stream)\n-  { return fgetwc(__stream); }\n-\n-  inline wint_t \n-  _CPP_putwc_capture(wchar_t __c, FILE* __stream)\n-  { return putwc(__c, __stream); }\n-  \n-  inline wint_t \n-  _CPP_ungetwc_capture(wint_t __c, FILE* __stream)\n-  { return ungetwc(__c, __stream); }\n+  // Full C99 listing\n+  extern \"C\" long double wcstold(const wchar_t*, wchar_t**); \n+  extern \"C\" long long int wcstoll(const wchar_t*, wchar_t**, int); \n+  extern \"C\" unsigned long long int wcstoull(const wchar_t*, wchar_t**, int); \n #endif\n-} // namespace _C_legacy\n-\n-# undef wchar_t\n-# undef wint_t\n-# undef mbstate_t\n-\n-# undef fwprintf\n-# undef fwscanf\n-# undef swprintf\n-# undef swscanf\n-# undef vfwprintf\n-# undef vfwscanf\n-# undef vswprintf\n-# undef vswscanf\n-# undef vwprintf\n-# undef vwscanf\n-# undef wprintf\n-# undef wscanf\n-# undef fgetwc\n-# undef fgetws\n-# undef fputwc\n-# undef fputws\n-# undef fwide\n-# undef getwc\n-# undef getwchar\n-# undef putwc\n-# undef putwchar\n-# undef ungetwc\n-# undef wcstod\n-# undef wcstof\n-# undef wcstold\n-# undef wcstol\n-# undef wcstoll\n-# undef wcstoul\n-# undef wcstoull\n-# undef wcscpy\n-# undef wcsncpy\n-# undef wcscat\n-# undef wcsncat\n-# undef wcsmp\n-# undef wcscoll\n-# undef wcsncmp\n-# undef wcsxfrm\n-# undef wcschr\n-# undef wcscspn\n-# undef wcslen\n-# undef wcspbrk\n-# undef wcsrchr\n-# undef wcsspn\n-# undef wcsstr\n-# undef wcstok\n-# undef wmemchr\n-# undef wmemcmp\n-# undef wmemcpy\n-# undef wmemmove\n-# undef wmemset\n-# undef wcsftime\n-# undef btowc\n-# undef wctob\n-# undef mbsinit\n-# undef mbrlen\n-# undef mbrtowc\n-# undef wcrtomb\n-# undef mbsrtowcs\n-# undef wcsrtombs\n-\n-namespace std {\n-\n-  using _C_legacy::wint_t; \n-  using _C_legacy::mbstate_t;\n+}\n+\n+#else\n+extern \"C\" \n+{\n+  typedef struct \n+  {\n+    int __fill[6];\n+  } mbstate_t;\n+}\n+\n+namespace std \n+{\n+  using ::mbstate_t;\n+}\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+\n+#endif \n+\n+\n+\n+\n+\n+\n \n-#if 0\n-  using _C_legacy::swprintf;\n-  using _C_legacy::swscanf;\n-  using _C_legacy::vswprintf;\n-  using _C_legacy::vswscanf;\n-  using _C_legacy::vwprintf;\n-  using _C_legacy::vwscanf;\n-  using _C_legacy::wprintf;\n-  using _C_legacy::wscanf;\n-  using _C_legacy::getwchar;\n-  using _C_legacy::putwchar;\n-#endif\n \n-  using _C_legacy::wcstod;\n-  using _C_legacy::wcstof;\n-  using _C_legacy::wcstold;\n-  using _C_legacy::wcstol;\n-  using _C_legacy::wcstoll;\n-  using _C_legacy::wcstoul;\n-  using _C_legacy::wcstoull;\n-  using _C_legacy::wcscpy;\n-  using _C_legacy::wcsncpy;\n-  using _C_legacy::wcscat;\n-  using _C_legacy::wcsncat;\n \n-#if 0\n-  using _C_legacy::wcsmp;\n-#endif\n \n-  using _C_legacy::wcscoll;\n-  using _C_legacy::wcsncmp;\n-  using _C_legacy::wcsxfrm;\n-  using _C_legacy::wcschr;\n-  using _C_legacy::wcscspn;\n-  using _C_legacy::wcslen;\n-  using _C_legacy::wcspbrk;\n-  using _C_legacy::wcsrchr;\n-  using _C_legacy::wcsspn;\n-  using _C_legacy::wcsstr;\n-  using _C_legacy::wcstok;\n-  using _C_legacy::wmemchr;\n-  using _C_legacy::wmemcmp;\n-  using _C_legacy::wmemcpy;\n-  using _C_legacy::wmemmove;\n-  using _C_legacy::wmemset;\n \n-#if 0\n-  using _C_legacy::wcsftime;\n-#endif\n \n-  using _C_legacy::btowc;\n-  using _C_legacy::wctob;\n-  using _C_legacy::mbsinit;\n-  using _C_legacy::mbrlen;\n-  using _C_legacy::mbrtowc;\n-  using _C_legacy::wcrtomb;\n-  using _C_legacy::mbsrtowcs;\n-  using _C_legacy::wcsrtombs;\n \n-#if 0\n-  // XXX\n-  inline int \n-  fwprintf(FILE* __stream, const wchar_t* __format, ...); \n-\n-  inline int \n-  fwscanf(FILE* __stream, const wchar_t* __format, ...); \n-\n-  inline int \n-  vfwprintf(FILE* __stream, const wchar_t* __format, va_list __arg); \n-\n-  inline int \n-  vfwscanf(FILE* __stream, const wchar_t* __format, va_list __arg);\n-\n-  inline wint_t \n-  fgetwc(FILE* __stream)\n-  { return _C_legacy::_CPP_fgetwc_capture(__stream); }\n-\n-  inline wchar_t*\n-  fgetws(wchar_t* __s, int __n, FILE* __stream) \n-  { return _C_legacy::_CPP_fgetws_capture(__s, __n, __stream); }\n-\n-  inline wint_t \n-  fputwc(wchar_t __c, FILE* __stream)\n-  { return _C_legacy::_CPP_fputwc_capture(__c, __stream); }\n-\n-  inline int \n-  fputws(const wchar_t* __s, FILE* __stream)\n-  { return _C_legacy::_CPP_fputws_capture(__s, __stream); }\n-\n-  inline int \n-  fwide(FILE* __stream, int __mode)\n-  { return _C_legacy::_CPP_fwide_capture(__stream, __mode); }\n-\n-  inline wint_t \n-  getwc(FILE* __stream)\n-  { return _C_legacy::_CPP_getwc_capture(__stream); }\n-\n-  inline wint_t \n-  putwc(wchar_t __c, FILE* __stream)\n-  { return _C_legacy::_CPP_putwc_capture(__c, __stream); }\n-  \n-  inline wint_t \n-  ungetwc(wint_t __c, FILE* __stream)\n-  { return _C_legacy::_CPP_ungetwc_capture(__c, __stream); }\n-#endif\n-}\n \n-# undef _IN_C_LEGACY_\n \n-#endif\n \n \n "}, {"sha": "fda9f45940278d6282d2e20021e13dfc688cf2c6", "filename": "libstdc++-v3/include/c_std/bits/std_cwctype.h", "status": "modified", "additions": 53, "deletions": 88, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cwctype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6e789f681fb753bc737b28d252039ea4e951a/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cwctype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cwctype.h?ref=98e6e789f681fb753bc737b28d252039ea4e951a", "patch": "@@ -1,4 +1,4 @@\n-// -*- C++ -*- header wrapper.\n+// -*- C++ -*- forwarding header.\n \n // Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n@@ -28,102 +28,67 @@\n // the GNU General Public License.\n \n //\n-// ISO C++ 14882: \n+// ISO C++ 14882: <cwctype>\n //\n \n+// Note: This is not a conforming implementation.\n+\n #ifndef _CPP_CWCTYPE\n #define _CPP_CWCTYPE 1\n \n-# include <bits/std_cwchar.h>  \n-\n-namespace _C_legacy {\n-  extern \"C\" {\n-#     define _IN_C_LEGACY_\n-#     pragma GCC system_header\n-#     include_next <wctype.h>\n-  }\n-} // namespace _C_legacy\n-\n-\n-# undef wctype_t\n-# undef wctrans_t\n-# undef iswalpha\n-# undef iswupper\n-# undef iswlower\n-# undef iswdigit\n-# undef iswxdigit\n-# undef iswalnum\n-# undef iswspace\n-# undef iswpunct\n-# undef iswprint\n-# undef iswgraph\n-# undef iswcntrl\n-# undef iswctype\n-# undef towctrans\n-# undef towlower\n-# undef towupper\n-# undef wctrans\n-# undef wctype\n-\n-namespace std {\n-  using _C_legacy::wctype_t;\n-  using _C_legacy::wctrans_t;\n-\n-  inline int \n-  iswalpha(wint_t __wc) { return _C_legacy::iswalpha(__wc); }\n-\n-  inline int \n-  iswupper(wint_t __wc) { return _C_legacy::iswupper(__wc); }\n-\n-  inline int \n-  iswlower(wint_t __wc) { return _C_legacy::iswlower(__wc); }\n-\n-  inline int \n-  iswdigit(wint_t __wc) { return _C_legacy::iswdigit(__wc); }\n-\n-  inline int \n-  iswxdigit(wint_t __wc) { return _C_legacy::iswxdigit(__wc); }\n-\n-  inline int \n-  iswalnum(wint_t __wc) { return _C_legacy::iswalnum(__wc); }\n-\n-  inline int \n-  iswspace(wint_t __wc) { return _C_legacy::iswspace(__wc); }\n-\n-  inline int \n-  iswpunct(wint_t __wc) { return _C_legacy::iswpunct(__wc); }\n-\n-  inline int \n-  iswprint(wint_t __wc) { return _C_legacy::iswprint(__wc); }\n-\n-  inline int \n-  iswgraph(wint_t __wc) { return _C_legacy::iswgraph(__wc); }\n-\n-  inline int \n-  iswcntrl(wint_t __wc) { return _C_legacy::iswcntrl(__wc); }\n-\n-  inline int \n-  towlower(wint_t __wc) { return _C_legacy::towlower(__wc); }\n+#pragma GCC system_header\n+#include <wctype.h>\n+\n+// Get rid of those macros defined in <wctype.h> in lieu of real functions.\n+#undef iswalnum\n+#undef iswalpha\n+#undef iswblank\n+#undef iswcntrl\n+#undef iswdigit\n+#undef iswgraph\n+#undef iswlower\n+#undef iswprint\n+#undef iswprint\n+#undef iswpunct\n+#undef iswspace\n+#undef iswupper\n+#undef iswxdigit\n+#undef iswctype  \n+#undef towlower\n+#undef towupper\n+#undef towctrans\n+#undef wctrans\n+\n+namespace std\n+{\n+  using ::wctype_t;\n+  using ::wctrans_t;\n+\n+  extern \"C\" int iswalnum(wint_t); \n+  extern \"C\" int iswalpha(wint_t); \n+  extern \"C\" int iswblank(wint_t); \n+  extern \"C\" int iswcntrl(wint_t); \n+  extern \"C\" int iswdigit(wint_t); \n+  extern \"C\" int iswgraph(wint_t); \n+  extern \"C\" int iswlower(wint_t); \n+  extern \"C\" int iswprint(wint_t); \n+  extern \"C\" int iswpunct(wint_t); \n+  extern \"C\" int iswspace(wint_t); \n+  extern \"C\" int iswupper(wint_t); \n+  extern \"C\" int iswxdigit(wint_t);\n+  extern \"C\" int iswctype(wint_t, wctype_t); \n+  extern \"C\" wctype_t wctype(const char *); \n+  extern \"C\" wint_t towlower(wint_t); \n+  extern \"C\" wint_t towupper(wint_t); \n+  extern \"C\" wint_t towctrans(wint_t, wctrans_t); \n+  extern \"C\" wctrans_t wctrans(const char*);\n+}\n+\n+#endif \n \n-  inline int \n-  towupper(wint_t __wc) { return _C_legacy::towupper(__wc); }\n \n-  inline int \n-  iswctype(wint_t __wc, wctype_t __desc) \n-  { return _C_legacy::iswctype(__wc, __desc); }\n \n-  inline wint_t \n-  towctrans(wint_t __wc, wctrans_t __desc)\n-  { return _C_legacy::towctrans (__wc, __desc); }\n-  \n-  inline wctrans_t \n-  wctrans(const char *__property) { return _C_legacy::wctrans(__property); }\n \n-  inline wctype_t \n-  wctype(char const* __property) { return _C_legacy::wctype(__property); }\n-} // namespace std\n \n-# undef _IN_C_LEGACY_\n \n-#endif\n "}]}