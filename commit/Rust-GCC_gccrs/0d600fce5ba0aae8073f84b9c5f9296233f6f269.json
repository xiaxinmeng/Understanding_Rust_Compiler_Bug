{"sha": "0d600fce5ba0aae8073f84b9c5f9296233f6f269", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ2MDBmY2U1YmEwYWFlODA3M2Y4NGI5YzVmOTI5NjIzM2Y2ZjI2OQ==", "commit": {"author": {"name": "Jie Zhang", "email": "jie@codesourcery.com", "date": "2010-10-26T16:13:04Z"}, "committer": {"name": "Jie Zhang", "email": "jiez@gcc.gnu.org", "date": "2010-10-26T16:13:04Z"}, "message": "invoke.texi: Improve documentation of -fstrict-volatile-bitfields.\n\n\t* doc/invoke.texi: Improve documentation of\n\t-fstrict-volatile-bitfields.\n\nFrom-SVN: r165971", "tree": {"sha": "1def84239e3f47c486cb01d95ea163c2e57e1573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1def84239e3f47c486cb01d95ea163c2e57e1573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d600fce5ba0aae8073f84b9c5f9296233f6f269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d600fce5ba0aae8073f84b9c5f9296233f6f269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d600fce5ba0aae8073f84b9c5f9296233f6f269", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d600fce5ba0aae8073f84b9c5f9296233f6f269/comments", "author": null, "committer": null, "parents": [{"sha": "75264e61bdb256689fb9fc1492bf6586ae2449fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75264e61bdb256689fb9fc1492bf6586ae2449fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75264e61bdb256689fb9fc1492bf6586ae2449fe"}], "stats": {"total": 19, "additions": 13, "deletions": 6}, "files": [{"sha": "661e0c15fa82d0d5c7472424acccb0ddb02c0627", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d600fce5ba0aae8073f84b9c5f9296233f6f269/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d600fce5ba0aae8073f84b9c5f9296233f6f269/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d600fce5ba0aae8073f84b9c5f9296233f6f269", "patch": "@@ -1,3 +1,8 @@\n+2010-10-26  Jie Zhang  <jie@codesourcery.com>\n+\n+\t* doc/invoke.texi: Improve documentation of\n+\t-fstrict-volatile-bitfields.\n+\n 2010-10-26  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/46167"}, {"sha": "7ea042f67751ac0261945d59b74eeefe21d7eeca", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d600fce5ba0aae8073f84b9c5f9296233f6f269/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d600fce5ba0aae8073f84b9c5f9296233f6f269/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0d600fce5ba0aae8073f84b9c5f9296233f6f269", "patch": "@@ -18120,8 +18120,8 @@ is at @uref{http://gcc.gnu.org/@/wiki/@/Visibility}.\n @opindex fstrict-volatile-bitfields\n This option should be used if accesses to volatile bitfields (or other\n structure fields, although the compiler usually honors those types\n-anyway) should use a single access in a mode of the same size as the\n-container's type, aligned to a natural alignment if possible.  For\n+anyway) should use a single access of the width of the\n+field's type, aligned to a natural alignment if possible.  For\n example, targets with memory-mapped peripheral registers might require\n all such accesses to be 16 bits wide; with this flag the user could\n declare all peripheral bitfields as ``unsigned short'' (assuming short\n@@ -18134,11 +18134,13 @@ instruction, even though that will access bytes that do not contain\n any portion of the bitfield, or memory-mapped registers unrelated to\n the one being updated.\n \n-If the target requires strict alignment, and honoring the container\n+If the target requires strict alignment, and honoring the field\n type would require violating this alignment, a warning is issued.\n-However, the access happens as the user requested, under the\n-assumption that the user knows something about the target hardware\n-that GCC is unaware of.\n+If the field has @code{packed} attribute, the access is done without\n+honoring the field type.  If the field doesn't have @code{packed}\n+attribute, the access is done honoring the field type.  In both cases,\n+GCC assumes that the user knows something about the target hardware\n+that it is unaware of.\n \n The default value of this option is determined by the application binary\n interface for the target processor."}]}