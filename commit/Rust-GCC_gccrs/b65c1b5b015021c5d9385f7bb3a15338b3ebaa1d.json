{"sha": "b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY1YzFiNWIwMTUwMjFjNWQ5Mzg1ZjdiYjNhMTUzMzhiM2ViYWExZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-24T00:40:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-24T00:40:58Z"}, "message": "(subst, case SUBREG): Handle paradoxical SUBREG of constant.\n\n(IF_THEN_ELSE): Add missing \"else\" and check for comparison before\ncalling reversible_comparison_p.\n\nFrom-SVN: r6419", "tree": {"sha": "6cb881e88fb00543603561ed94327e1193a31b12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cb881e88fb00543603561ed94327e1193a31b12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d/comments", "author": null, "committer": null, "parents": [{"sha": "127e4d19bd9e7e6df4724e81da15722f7bc71481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/127e4d19bd9e7e6df4724e81da15722f7bc71481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/127e4d19bd9e7e6df4724e81da15722f7bc71481"}], "stats": {"total": 19, "additions": 13, "deletions": 6}, "files": [{"sha": "d682939eb28a2f4c6776c4b992cf8903918a9bca", "filename": "gcc/combine.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b65c1b5b015021c5d9385f7bb3a15338b3ebaa1d", "patch": "@@ -3216,6 +3216,12 @@ subst (x, from, to, in_dest, unique_copy)\n \t  )\n \treturn gen_lowpart_for_combine (mode, SUBREG_REG (x));\n \n+      /* A paradoxical SUBREG of a VOIDmode constant is the same constant,\n+\t since we are saying that the high bits don't matter.  */\n+      if (CONSTANT_P (SUBREG_REG (x)) && GET_MODE (SUBREG_REG (x)) == VOIDmode\n+\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (op0_mode))\n+\treturn SUBREG_REG (x);\n+\n       /* If we are narrowing an integral object, we need to see if we can\n \t simplify the expression for the object knowing that we only need the\n \t low-order bits.  */\n@@ -4002,12 +4008,13 @@ subst (x, from, to, in_dest, unique_copy)\n \t      m = GET_MODE (XEXP (t, 0));\n \t    }\n \n-\t  if (reversible_comparison_p (XEXP (x, 0))\n-\t      && (GET_CODE (f) == PLUS || GET_CODE (f) == MINUS\n-\t\t  || GET_CODE (f) == IOR || GET_CODE (f) == XOR\n-\t\t  || GET_CODE (f) == ASHIFT\n-\t\t  || GET_CODE (f) == LSHIFTRT || GET_CODE (f) == ASHIFTRT)\n-\t      && rtx_equal_p (XEXP (f, 0), t))\n+\t  else if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t\t   && reversible_comparison_p (XEXP (x, 0))\n+\t\t   && (GET_CODE (f) == PLUS || GET_CODE (f) == MINUS\n+\t\t       || GET_CODE (f) == IOR || GET_CODE (f) == XOR\n+\t\t       || GET_CODE (f) == ASHIFT\n+\t\t       || GET_CODE (f) == LSHIFTRT || GET_CODE (f) == ASHIFTRT)\n+\t\t   && rtx_equal_p (XEXP (f, 0), t))\n \t    {\n \t      c1 = XEXP (f, 1), op = GET_CODE (f), z = t;\n \t      cond_op = reverse_condition (cond_op);"}]}