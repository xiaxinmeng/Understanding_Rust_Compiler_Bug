{"sha": "26a2e6aed46f0690aee229788887908b7116f515", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZhMmU2YWVkNDZmMDY5MGFlZTIyOTc4ODg4NzkwOGI3MTE2ZjUxNQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2016-01-20T20:30:24Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2016-01-20T20:30:24Z"}, "message": "ppc-auxv.h: New file.\n\ngcc/\n\t* config/rs6000/ppc-auxv.h: New file.\n\t* config/rs6000/rs6000-builtin.def (cpu_init): Add new builtin.\n\t(cpu_is): Likewise.\n\t(cpu_supports): Likewise.\n\t* config/rs6000/rs6000.c: include \"ppc-auxv.h\".\n\t(cpu_is_info): New variable.\n\t(cpu_supports_info): Likewise.\n\t(tcb_verification_symbol): Likewise.\n\t(cpu_builtin_p): Likewise.\n\t(cpu_expand_builtin): New function.\n\t(rs6000_expand_ternop_builtin): Add support for CPU builtin functions.\n\t(rs6000_init_builtins): Likewise.\n\t(rs6000_elf_file_end): Emit HWCAP in TCB verification symbol.\n\t* config/rs6000/rs6000.h (TLS_REGNUM): New define.\n\t* configure.ac (gcc_cv_libc_provides_hwcap_in_tcb): New test.\n\t* configure: Regenerate.\n\t* config.in: Likewise.\n\t* doc/extend.texi (PowerPC Built-in Functions): Document\n\t__builtin_cpu_init, __builtin_cpu_is and __builtin_cpu_supports.\n\ngcc/testsuite/\n\t* gcc.target/powerpc/cpu-builtin-1.c: New test.\n\nFrom-SVN: r232634", "tree": {"sha": "5eeec1f45b34f7f29a1f977751983a8316485957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eeec1f45b34f7f29a1f977751983a8316485957"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26a2e6aed46f0690aee229788887908b7116f515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a2e6aed46f0690aee229788887908b7116f515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a2e6aed46f0690aee229788887908b7116f515", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a2e6aed46f0690aee229788887908b7116f515/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11c7bfe6737c940cc35c87ff35e4cd18897f20d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11c7bfe6737c940cc35c87ff35e4cd18897f20d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11c7bfe6737c940cc35c87ff35e4cd18897f20d8"}], "stats": {"total": 603, "additions": 603, "deletions": 0}, "files": [{"sha": "f2eb93636f02407c71192a7d926dc329818047b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -1,3 +1,25 @@\n+2016-01-20  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* config/rs6000/ppc-auxv.h: New file.\n+\t* config/rs6000/rs6000-builtin.def (cpu_init): Add new builtin.\n+\t(cpu_is): Likewise.\n+\t(cpu_supports): Likewise.\n+\t* config/rs6000/rs6000.c: include \"ppc-auxv.h\".\n+\t(cpu_is_info): New variable.\n+\t(cpu_supports_info): Likewise.\n+\t(tcb_verification_symbol): Likewise.\n+\t(cpu_builtin_p): Likewise.\n+\t(cpu_expand_builtin): New function.\n+\t(rs6000_expand_ternop_builtin): Add support for CPU builtin functions.\n+\t(rs6000_init_builtins): Likewise.\n+\t(rs6000_elf_file_end): Emit HWCAP in TCB verification symbol.\n+\t* config/rs6000/rs6000.h (TLS_REGNUM): New define.\n+\t* configure.ac (gcc_cv_libc_provides_hwcap_in_tcb): New test.\n+\t* configure: Regenerate.\n+\t* config.in: Likewise.\n+\t* doc/extend.texi (PowerPC Built-in Functions): Document\n+\t__builtin_cpu_init, __builtin_cpu_is and __builtin_cpu_supports.\n+\n 2016-01-20  David Edelsohn  <dje.gcc@gmail.com>\n \n \tPR target/68609"}, {"sha": "1796e1d895e3b091469dc57dc40be90c6476b262", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -2074,6 +2074,12 @@\n #endif\n \n \n+/* Define if your target C Library provides the AT_HWCAP value in the TCB */\n+#ifndef USED_FOR_TARGET\n+#undef TARGET_LIBC_PROVIDES_HWCAP_IN_TCB\n+#endif\n+\n+\n /* Define if your target C library provides stack protector support */\n #ifndef USED_FOR_TARGET\n #undef TARGET_LIBC_PROVIDES_SSP"}, {"sha": "590fdb8a298c4a2ac93779d7bcddf1e93bce7400", "filename": "gcc/config/rs6000/ppc-auxv.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Fppc-auxv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Fppc-auxv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fppc-auxv.h?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -0,0 +1,105 @@\n+/* PowerPC support for accessing the AUXV AT_PLATFORM, AT_HWCAP and AT_HWCAP2\n+   values from the Thread Control Block (TCB).\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Peter Bergner <bergner@vnet.ibm.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _PPC_AUXV_H\n+#define _PPC_AUXV_H\n+\n+/* The PLATFORM value stored in the TCB is offset by _DL_FIRST_PLATFORM.  */\n+#define _DL_FIRST_PLATFORM             32\n+\n+/* AT_PLATFORM bits.  These must match the values defined in GLIBC. */\n+#define PPC_PLATFORM_POWER4            0\n+#define PPC_PLATFORM_PPC970            1\n+#define PPC_PLATFORM_POWER5            2\n+#define PPC_PLATFORM_POWER5_PLUS       3\n+#define PPC_PLATFORM_POWER6            4\n+#define PPC_PLATFORM_CELL_BE           5\n+#define PPC_PLATFORM_POWER6X           6\n+#define PPC_PLATFORM_POWER7            7\n+#define PPC_PLATFORM_PPCA2             8\n+#define PPC_PLATFORM_PPC405            9\n+#define PPC_PLATFORM_PPC440            10\n+#define PPC_PLATFORM_PPC464            11\n+#define PPC_PLATFORM_PPC476            12\n+#define PPC_PLATFORM_POWER8            13\n+#define PPC_PLATFORM_POWER9            14\n+\n+/* AT_HWCAP bits.  These must match the values defined in the Linux kernel.  */\n+#define PPC_FEATURE_32              0x80000000\n+#define PPC_FEATURE_64              0x40000000\n+#define PPC_FEATURE_601_INSTR       0x20000000\n+#define PPC_FEATURE_HAS_ALTIVEC     0x10000000\n+#define PPC_FEATURE_HAS_FPU         0x08000000\n+#define PPC_FEATURE_HAS_MMU         0x04000000\n+#define PPC_FEATURE_HAS_4xxMAC      0x02000000\n+#define PPC_FEATURE_UNIFIED_CACHE   0x01000000\n+#define PPC_FEATURE_HAS_SPE         0x00800000\n+#define PPC_FEATURE_HAS_EFP_SINGLE  0x00400000\n+#define PPC_FEATURE_HAS_EFP_DOUBLE  0x00200000\n+#define PPC_FEATURE_NO_TB           0x00100000\n+#define PPC_FEATURE_POWER4          0x00080000\n+#define PPC_FEATURE_POWER5          0x00040000\n+#define PPC_FEATURE_POWER5_PLUS     0x00020000\n+#define PPC_FEATURE_CELL_BE         0x00010000\n+#define PPC_FEATURE_BOOKE           0x00008000\n+#define PPC_FEATURE_SMT             0x00004000\n+#define PPC_FEATURE_ICACHE_SNOOP    0x00002000\n+#define PPC_FEATURE_ARCH_2_05       0x00001000\n+#define PPC_FEATURE_PA6T            0x00000800\n+#define PPC_FEATURE_HAS_DFP         0x00000400\n+#define PPC_FEATURE_POWER6_EXT      0x00000200\n+#define PPC_FEATURE_ARCH_2_06       0x00000100\n+#define PPC_FEATURE_HAS_VSX         0x00000080\n+#define PPC_FEATURE_PERFMON_COMPAT  0x00000040\n+#define PPC_FEATURE_TRUE_LE         0x00000002\n+#define PPC_FEATURE_PPC_LE          0x00000001\n+\n+/* AT_HWCAP2 bits.  These must match the values defined in the Linux kernel.  */\n+#define PPC_FEATURE2_ARCH_2_07      0x80000000\n+#define PPC_FEATURE2_HAS_HTM        0x40000000\n+#define PPC_FEATURE2_HAS_DSCR       0x20000000\n+#define PPC_FEATURE2_HAS_EBB        0x10000000\n+#define PPC_FEATURE2_HAS_ISEL       0x08000000\n+#define PPC_FEATURE2_HAS_TAR        0x04000000\n+#define PPC_FEATURE2_HAS_VEC_CRYPTO 0x02000000\n+#define PPC_FEATURE2_HTM_NOSC       0x01000000\n+#define PPC_FEATURE2_ARCH_3_00      0x00800000\n+#define PPC_FEATURE2_HAS_IEEE128    0x00400000\n+\n+\n+/* Thread Control Block (TCB) offsets of the AT_PLATFORM, AT_HWCAP and\n+   AT_HWCAP2 values.  These must match the values defined in GLIBC.  */\n+#define TCB_PLATFORM_OFFSET ((TARGET_64BIT) ? -28764 : -28724)\n+#define TCB_HWCAP_BASE_OFFSET ((TARGET_64BIT) ? -28776 : -28736)\n+#define TCB_HWCAP1_OFFSET \\\n+  ((BYTES_BIG_ENDIAN) ? TCB_HWCAP_BASE_OFFSET : TCB_HWCAP_BASE_OFFSET+4)\n+#define TCB_HWCAP2_OFFSET \\\n+  ((BYTES_BIG_ENDIAN) ? TCB_HWCAP_BASE_OFFSET+4 : TCB_HWCAP_BASE_OFFSET)\n+#define TCB_HWCAP_OFFSET(ID) \\\n+  (((ID) == 0) ? TCB_HWCAP1_OFFSET : TCB_HWCAP2_OFFSET)\n+\n+#endif /* _PPC_AUXV_H */"}, {"sha": "5b82b00449e3a0740e78aad67430a7c373127795", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -2013,6 +2013,15 @@ RS6000_BUILTIN_X (RS6000_BUILTIN_MTFSF, \"__builtin_mtfsf\",\n \t          RS6000_BTC_MISC | RS6000_BTC_UNARY | RS6000_BTC_VOID,\n \t\t  CODE_FOR_rs6000_mtfsf)\n \n+BU_SPECIAL_X (RS6000_BUILTIN_CPU_INIT, \"__builtin_cpu_init\",\n+\t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n+\n+BU_SPECIAL_X (RS6000_BUILTIN_CPU_IS, \"__builtin_cpu_is\",\n+\t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n+\n+BU_SPECIAL_X (RS6000_BUILTIN_CPU_SUPPORTS, \"__builtin_cpu_supports\",\n+\t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n+\n /* Darwin CfString builtin.  */\n BU_SPECIAL_X (RS6000_BUILTIN_CFSTRING, \"__builtin_cfstring\", RS6000_BTM_ALWAYS,\n \t      RS6000_BTC_MISC)"}, {"sha": "b0ce68e5b3896437f6048de1c5b7f0f224875328", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -71,6 +71,7 @@\n #include \"gstab.h\"  /* for N_SLINE */\n #endif\n #include \"case-cfn-macros.h\"\n+#include \"ppc-auxv.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -293,6 +294,88 @@ static struct\n   { \"rsqrtd\",\t (RECIP_DF_RSQRT | RECIP_V2DF_RSQRT) },\n };\n \n+/* Used by __builtin_cpu_is(), mapping from PLATFORM names to values.  */\n+static const struct\n+{\n+  const char *cpu;\n+  unsigned int cpuid;\n+} cpu_is_info[] = {\n+  { \"power9\",\t   PPC_PLATFORM_POWER9 },\n+  { \"power8\",\t   PPC_PLATFORM_POWER8 },\n+  { \"power7\",\t   PPC_PLATFORM_POWER7 },\n+  { \"power6x\",\t   PPC_PLATFORM_POWER6X },\n+  { \"power6\",\t   PPC_PLATFORM_POWER6 },\n+  { \"power5+\",\t   PPC_PLATFORM_POWER5_PLUS },\n+  { \"power5\",\t   PPC_PLATFORM_POWER5 },\n+  { \"ppc970\",\t   PPC_PLATFORM_PPC970 },\n+  { \"power4\",\t   PPC_PLATFORM_POWER4 },\n+  { \"ppca2\",\t   PPC_PLATFORM_PPCA2 },\n+  { \"ppc476\",\t   PPC_PLATFORM_PPC476 },\n+  { \"ppc464\",\t   PPC_PLATFORM_PPC464 },\n+  { \"ppc440\",\t   PPC_PLATFORM_PPC440 },\n+  { \"ppc405\",\t   PPC_PLATFORM_PPC405 },\n+  { \"ppc-cell-be\", PPC_PLATFORM_CELL_BE }\n+};\n+\n+/* Used by __builtin_cpu_supports(), mapping from HWCAP names to masks.  */\n+static const struct\n+{\n+  const char *hwcap;\n+  int mask;\n+  unsigned int id;\n+} cpu_supports_info[] = {\n+  /* AT_HWCAP masks.  */\n+  { \"4xxmac\",\t\tPPC_FEATURE_HAS_4xxMAC,\t\t0 },\n+  { \"altivec\",\t\tPPC_FEATURE_HAS_ALTIVEC,\t0 },\n+  { \"arch_2_05\",\tPPC_FEATURE_ARCH_2_05,\t\t0 },\n+  { \"arch_2_06\",\tPPC_FEATURE_ARCH_2_06,\t\t0 },\n+  { \"archpmu\",\t\tPPC_FEATURE_PERFMON_COMPAT,\t0 },\n+  { \"booke\",\t\tPPC_FEATURE_BOOKE,\t\t0 },\n+  { \"cellbe\",\t\tPPC_FEATURE_CELL_BE,\t\t0 },\n+  { \"dfp\",\t\tPPC_FEATURE_HAS_DFP,\t\t0 },\n+  { \"efpdouble\",\tPPC_FEATURE_HAS_EFP_DOUBLE,\t0 },\n+  { \"efpsingle\",\tPPC_FEATURE_HAS_EFP_SINGLE,\t0 },\n+  { \"fpu\",\t\tPPC_FEATURE_HAS_FPU,\t\t0 },\n+  { \"ic_snoop\",\t\tPPC_FEATURE_ICACHE_SNOOP,\t0 },\n+  { \"mmu\",\t\tPPC_FEATURE_HAS_MMU,\t\t0 },\n+  { \"notb\",\t\tPPC_FEATURE_NO_TB,\t\t0 },\n+  { \"pa6t\",\t\tPPC_FEATURE_PA6T,\t\t0 },\n+  { \"power4\",\t\tPPC_FEATURE_POWER4,\t\t0 },\n+  { \"power5\",\t\tPPC_FEATURE_POWER5,\t\t0 },\n+  { \"power5+\",\t\tPPC_FEATURE_POWER5_PLUS,\t0 },\n+  { \"power6x\",\t\tPPC_FEATURE_POWER6_EXT,\t\t0 },\n+  { \"ppc32\",\t\tPPC_FEATURE_32,\t\t\t0 },\n+  { \"ppc601\",\t\tPPC_FEATURE_601_INSTR,\t\t0 },\n+  { \"ppc64\",\t\tPPC_FEATURE_64,\t\t\t0 },\n+  { \"ppcle\",\t\tPPC_FEATURE_PPC_LE,\t\t0 },\n+  { \"smt\",\t\tPPC_FEATURE_SMT,\t\t0 },\n+  { \"spe\",\t\tPPC_FEATURE_HAS_SPE,\t\t0 },\n+  { \"true_le\",\t\tPPC_FEATURE_TRUE_LE,\t\t0 },\n+  { \"ucache\",\t\tPPC_FEATURE_UNIFIED_CACHE,\t0 },\n+  { \"vsx\",\t\tPPC_FEATURE_HAS_VSX,\t\t0 },\n+\n+  /* AT_HWCAP2 masks.  */\n+  { \"arch_2_07\",\tPPC_FEATURE2_ARCH_2_07,\t\t1 },\n+  { \"dscr\",\t\tPPC_FEATURE2_HAS_DSCR,\t\t1 },\n+  { \"ebb\",\t\tPPC_FEATURE2_HAS_EBB,\t\t1 },\n+  { \"htm\",\t\tPPC_FEATURE2_HAS_HTM,\t\t1 },\n+  { \"htm-nosc\",\t\tPPC_FEATURE2_HTM_NOSC,\t\t1 },\n+  { \"isel\",\t\tPPC_FEATURE2_HAS_ISEL,\t\t1 },\n+  { \"tar\",\t\tPPC_FEATURE2_HAS_TAR,\t\t1 },\n+  { \"vcrypto\",\t\tPPC_FEATURE2_HAS_VEC_CRYPTO,\t1 },\n+  { \"arch_3_00\",\tPPC_FEATURE2_ARCH_3_00,\t\t1 },\n+  { \"ieee128\",\t\tPPC_FEATURE2_HAS_IEEE128,\t1 }\n+};\n+\n+/* Newer LIBCs explicitly export this symbol to declare that they provide\n+   the AT_PLATFORM and AT_HWCAP/AT_HWCAP2 values in the TCB.  We emit a\n+   reference to this symbol whenever we expand a CPU builtin, so that\n+   we never link against an old LIBC.  */\n+const char *tcb_verification_symbol = \"__parse_hwcap_and_convert_at_platform\";\n+\n+/* True if we have expanded a CPU builtin.  */\n+bool cpu_builtin_p;\n+\n /* Pointer to function (in rs6000-c.c) that can define or undefine target\n    macros that have changed.  Languages that don't support the preprocessor\n    don't link in rs6000-c.c, so we can't call it directly.  */\n@@ -13380,6 +13463,101 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)\n   return NULL_RTX;\n }\n \n+/* Expand the CPU builtin in FCODE and store the result in TARGET.  */\n+\n+static rtx\n+cpu_expand_builtin (enum rs6000_builtins fcode, tree exp ATTRIBUTE_UNUSED,\n+\t\t    rtx target)\n+{\n+  /* __builtin_cpu_init () is a nop, so expand to nothing.  */\n+  if (fcode == RS6000_BUILTIN_CPU_INIT)\n+    return const0_rtx;\n+\n+  if (target == 0 || GET_MODE (target) != SImode)\n+    target = gen_reg_rtx (SImode);\n+\n+#ifdef TARGET_LIBC_PROVIDES_HWCAP_IN_TCB\n+  tree arg = TREE_OPERAND (CALL_EXPR_ARG (exp, 0), 0);\n+  if (TREE_CODE (arg) != STRING_CST)\n+    {\n+      error (\"builtin %s only accepts a string argument\",\n+\t     rs6000_builtin_info[(size_t) fcode].name);\n+      return const0_rtx;\n+    }\n+\n+  if (fcode == RS6000_BUILTIN_CPU_IS)\n+    {\n+      const char *cpu = TREE_STRING_POINTER (arg);\n+      rtx cpuid = NULL_RTX;\n+      for (size_t i = 0; i < ARRAY_SIZE (cpu_is_info); i++)\n+\tif (strcmp (cpu, cpu_is_info[i].cpu) == 0)\n+\t  {\n+\t    /* The CPUID value in the TCB is offset by _DL_FIRST_PLATFORM.  */\n+\t    cpuid = GEN_INT (cpu_is_info[i].cpuid + _DL_FIRST_PLATFORM);\n+\t    break;\n+\t  }\n+      if (cpuid == NULL_RTX)\n+\t{\n+\t  /* Invalid CPU argument.  */\n+\t  error (\"cpu %s is an invalid argument to builtin %s\",\n+\t\t cpu, rs6000_builtin_info[(size_t) fcode].name);\n+\t  return const0_rtx;\n+\t}\n+\n+      rtx platform = gen_reg_rtx (SImode);\n+      rtx tcbmem = gen_const_mem (SImode,\n+\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\tgen_rtx_REG (Pmode, TLS_REGNUM),\n+\t\t\t\t\t\tGEN_INT (TCB_PLATFORM_OFFSET)));\n+      emit_move_insn (platform, tcbmem);\n+      emit_insn (gen_eqsi3 (target, platform, cpuid));\n+    }\n+  else if (fcode == RS6000_BUILTIN_CPU_SUPPORTS)\n+    {\n+      const char *hwcap = TREE_STRING_POINTER (arg);\n+      rtx mask = NULL_RTX;\n+      int hwcap_offset;\n+      for (size_t i = 0; i < ARRAY_SIZE (cpu_supports_info); i++)\n+\tif (strcmp (hwcap, cpu_supports_info[i].hwcap) == 0)\n+\t  {\n+\t    mask = GEN_INT (cpu_supports_info[i].mask);\n+\t    hwcap_offset = TCB_HWCAP_OFFSET (cpu_supports_info[i].id);\n+\t    break;\n+\t  }\n+      if (mask == NULL_RTX)\n+\t{\n+\t  /* Invalid HWCAP argument.  */\n+\t  error (\"hwcap %s is an invalid argument to builtin %s\",\n+\t\t hwcap, rs6000_builtin_info[(size_t) fcode].name);\n+\t  return const0_rtx;\n+\t}\n+\n+      rtx tcb_hwcap = gen_reg_rtx (SImode);\n+      rtx tcbmem = gen_const_mem (SImode,\n+\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\tgen_rtx_REG (Pmode, TLS_REGNUM),\n+\t\t\t\t\t\tGEN_INT (hwcap_offset)));\n+      emit_move_insn (tcb_hwcap, tcbmem);\n+      rtx scratch1 = gen_reg_rtx (SImode);\n+      emit_insn (gen_rtx_SET (scratch1, gen_rtx_AND (SImode, tcb_hwcap, mask)));\n+      rtx scratch2 = gen_reg_rtx (SImode);\n+      emit_insn (gen_eqsi3 (scratch2, scratch1, const0_rtx));\n+      emit_insn (gen_rtx_SET (target, gen_rtx_XOR (SImode, scratch2, const1_rtx)));\n+    }\n+\n+  /* Record that we have expanded a CPU builtin, so that we can later\n+     emit a reference to the special symbol exported by LIBC to ensure we\n+     do not link against an old LIBC that doesn't support this feature.  */\n+  cpu_builtin_p = true;\n+\n+#else\n+  /* For old LIBCs, always return FALSE.  */\n+  emit_move_insn (target, GEN_INT (0));\n+#endif /* TARGET_LIBC_PROVIDES_HWCAP_IN_TCB */\n+\n+  return target;\n+}\n+\n static rtx\n rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n {\n@@ -14706,6 +14884,11 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case RS6000_BUILTIN_MTFSF:\n       return rs6000_expand_mtfsf_builtin (CODE_FOR_rs6000_mtfsf, exp);\n \n+    case RS6000_BUILTIN_CPU_INIT:\n+    case RS6000_BUILTIN_CPU_IS:\n+    case RS6000_BUILTIN_CPU_SUPPORTS:\n+      return cpu_expand_builtin (fcode, exp, target);\n+\n     case ALTIVEC_BUILTIN_MASK_FOR_LOAD:\n     case ALTIVEC_BUILTIN_MASK_FOR_STORE:\n       {\n@@ -15095,6 +15278,14 @@ rs6000_init_builtins (void)\n \t\t\t\t    NULL_TREE);\n   def_builtin (\"__builtin_mtfsf\", ftype, RS6000_BUILTIN_MTFSF);\n \n+  ftype = build_function_type_list (void_type_node, NULL_TREE);\n+  def_builtin (\"__builtin_cpu_init\", ftype, RS6000_BUILTIN_CPU_INIT);\n+\n+  ftype = build_function_type_list (bool_int_type_node, const_ptr_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (\"__builtin_cpu_is\", ftype, RS6000_BUILTIN_CPU_IS);\n+  def_builtin (\"__builtin_cpu_supports\", ftype, RS6000_BUILTIN_CPU_SUPPORTS);\n+\n #if TARGET_XCOFF\n   /* AIX libm provides clog as __clog.  */\n   if ((tdecl = builtin_decl_explicit (BUILT_IN_CLOG)) != NULL_TREE)\n@@ -31601,6 +31792,17 @@ rs6000_elf_file_end (void)\n \n   if (flag_split_stack)\n     file_end_indicate_split_stack ();\n+\n+  if (cpu_builtin_p)\n+    {\n+      /* We have expanded a CPU builtin, so we need to emit a reference to\n+\t the special symbol that LIBC uses to declare it supports the\n+\t AT_PLATFORM and AT_HWCAP/AT_HWCAP2 in the TCB feature.  */\n+      switch_to_section (data_section);\n+      fprintf (asm_out_file, \"\\t.align %u\\n\", TARGET_32BIT ? 2 : 3);\n+      fprintf (asm_out_file, \"\\t%s %s\\n\",\n+\t       TARGET_32BIT ? \".long\" : \".quad\", tcb_verification_symbol);\n+    }\n }\n #endif\n "}, {"sha": "8c6bd07dd5e58cbe887533f9057288d65a96a57a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -1361,6 +1361,9 @@ enum data_align { align_abi, align_opt, align_both };\n /* Place to put static chain when calling a function that requires it.  */\n #define STATIC_CHAIN_REGNUM 11\n \n+/* Base register for access to thread local storage variables.  */\n+#define TLS_REGNUM ((TARGET_64BIT) ? 13 : 2)\n+\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants."}, {"sha": "42e97a8a8af9d61f63091e2ad1161ba501968d06", "filename": "gcc/configure", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -28539,6 +28539,24 @@ $as_echo \"#define TARGET_DEFAULT_LONG_DOUBLE_128 1\" >>confdefs.h\n \n fi\n \n+# Check if the target LIBC supports exporting the AT_PLATFORM and AT_HWCAP\n+# values in the TCB.  Currently, only GLIBC 2.23 and later support this.\n+gcc_cv_libc_provides_hwcap_in_tcb=no\n+case \"$target\" in\n+  powerpc*-*-linux*)\n+\n+if test $glibc_version_major -gt 2 \\\n+  || ( test $glibc_version_major -eq 2 && test $glibc_version_minor -ge 23 ); then :\n+  gcc_cv_libc_provides_hwcap_in_tcb=yes\n+fi\n+    ;;\n+esac\n+if test x$gcc_cv_libc_provides_hwcap_in_tcb = xyes; then\n+\n+$as_echo \"#define TARGET_LIBC_PROVIDES_HWCAP_IN_TCB 1\" >>confdefs.h\n+\n+fi\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking dl_iterate_phdr in target C library\" >&5\n $as_echo_n \"checking dl_iterate_phdr in target C library... \" >&6; }\n gcc_cv_target_dl_iterate_phdr=unknown"}, {"sha": "bf38dfe986baf98760417fc2e984dd75cc2b9c71", "filename": "gcc/configure.ac", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -5544,6 +5544,19 @@ if test x$gcc_cv_target_ldbl128 = xyes; then\n \t    [Define if TFmode long double should be the default])\n fi\n \n+# Check if the target LIBC supports exporting the AT_PLATFORM and AT_HWCAP\n+# values in the TCB.  Currently, only GLIBC 2.23 and later support this.\n+gcc_cv_libc_provides_hwcap_in_tcb=no\n+case \"$target\" in\n+  powerpc*-*-linux*)\n+    GCC_GLIBC_VERSION_GTE_IFELSE([2], [23], [gcc_cv_libc_provides_hwcap_in_tcb=yes], )\n+    ;;\n+esac\n+if test x$gcc_cv_libc_provides_hwcap_in_tcb = xyes; then\n+  AC_DEFINE(TARGET_LIBC_PROVIDES_HWCAP_IN_TCB, 1,\n+\t    [Define if your target C Library provides the AT_HWCAP value in the TCB])\n+fi\n+\n AC_MSG_CHECKING(dl_iterate_phdr in target C library)\n gcc_cv_target_dl_iterate_phdr=unknown\n case \"$target\" in"}, {"sha": "0dab6465b70c4b4310e47f57c3071287b2016324", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -13527,6 +13527,162 @@ implementing assertions.\n @node PowerPC Built-in Functions\n @subsection PowerPC Built-in Functions\n \n+The following built-in functions are always available and can be used to\n+check the PowerPC target platform type:\n+\n+@deftypefn {Built-in Function} void __builtin_cpu_init (void)\n+This function is a @code{nop} on the PowerPC platform and is included solely\n+to maintain API compatibility with the x86 builtins.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_cpu_is (const char *@var{cpuname})\n+This function returns a value of @code{1} if the run-time CPU is of type\n+@var{cpuname} and returns @code{0} otherwise. The following CPU names can be\n+detected:\n+\n+@table @samp\n+@item power9\n+IBM POWER9 Server CPU.\n+@item power8\n+IBM POWER8 Server CPU.\n+@item power7\n+IBM POWER7 Server CPU.\n+@item power6x\n+IBM POWER6 Server CPU (RAW mode).\n+@item power6\n+IBM POWER6 Server CPU (Architected mode).\n+@item power5+\n+IBM POWER5+ Server CPU.\n+@item power5\n+IBM POWER5 Server CPU.\n+@item ppc970\n+IBM 970 Server CPU (ie, Apple G5).\n+@item power4\n+IBM POWER4 Server CPU.\n+@item ppca2\n+IBM A2 64-bit Embedded CPU\n+@item ppc476\n+IBM PowerPC 476FP 32-bit Embedded CPU.\n+@item ppc464\n+IBM PowerPC 464 32-bit Embedded CPU.\n+@item ppc440\n+PowerPC 440 32-bit Embedded CPU.\n+@item ppc405\n+PowerPC 405 32-bit Embedded CPU.\n+@item ppc-cell-be\n+IBM PowerPC Cell Broadband Engine Architecture CPU.\n+@end table\n+\n+Here is an example:\n+@smallexample\n+if (__builtin_cpu_is (\"power8\"))\n+  @{\n+     do_power8 (); // POWER8 specific implementation.\n+  @}\n+else\n+  @{\n+     do_generic (); // Generic implementation.\n+  @}\n+@end smallexample\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_cpu_supports (const char *@var{feature})\n+This function returns a value of @code{1} if the run-time CPU supports the HWCAP\n+feature @var{feature} and returns @code{0} otherwise. The following features can be\n+detected:\n+\n+@table @samp\n+@item 4xxmac\n+4xx CPU has a Multiply Accumulator.\n+@item altivec\n+CPU has a SIMD/Vector Unit.\n+@item arch_2_05\n+CPU supports ISA 2.05 (eg, POWER6)\n+@item arch_2_06\n+CPU supports ISA 2.06 (eg, POWER7)\n+@item arch_2_07\n+CPU supports ISA 2.07 (eg, POWER8)\n+@item arch_3_00\n+CPU supports ISA 3.00 (eg, POWER9)\n+@item archpmu\n+CPU supports the set of compatible performance monitoring events.\n+@item booke\n+CPU supports the Embedded ISA category.\n+@item cellbe\n+CPU has a CELL broadband engine.\n+@item dfp\n+CPU has a decimal floating point unit.\n+@item dscr\n+CPU supports the data stream control register.\n+@item ebb\n+CPU supports event base branching.\n+@item efpdouble\n+CPU has a SPE double precision floating point unit.\n+@item efpsingle\n+CPU has a SPE single precision floating point unit.\n+@item fpu\n+CPU has a floating point unit.\n+@item htm\n+CPU has hardware transaction memory instructions.\n+@item htm-nosc\n+Kernel aborts hardware transactions when a syscall is made.\n+@item ic_snoop\n+CPU supports icache snooping capabilities.\n+@item ieee128\n+CPU supports 128-bit IEEE binary floating point instructions.\n+@item isel\n+CPU supports the integer select instruction.\n+@item mmu\n+CPU has a memory management unit.\n+@item notb\n+CPU does not have a timebase (eg, 601 and 403gx).\n+@item pa6t\n+CPU supports the PA Semi 6T CORE ISA.\n+@item power4\n+CPU supports ISA 2.00 (eg, POWER4)\n+@item power5\n+CPU supports ISA 2.02 (eg, POWER5)\n+@item power5+\n+CPU supports ISA 2.03 (eg, POWER5+)\n+@item power6x\n+CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.\n+@item ppc32\n+CPU supports 32-bit mode execution.\n+@item ppc601\n+CPU supports the old POWER ISA (eg, 601)\n+@item ppc64\n+CPU supports 64-bit mode execution.\n+@item ppcle\n+CPU supports a little-endian mode that uses address swizzling.\n+@item smt\n+CPU support simultaneous multi-threading.\n+@item spe\n+CPU has a signal processing extension unit.\n+@item tar\n+CPU supports the target address register.\n+@item true_le\n+CPU supports true little-endian mode.\n+@item ucache\n+CPU has unified I/D cache.\n+@item vcrypto\n+CPU supports the vector cryptography instructions.\n+@item vsx\n+CPU supports the vector-scalar extension.\n+@end table\n+\n+Here is an example:\n+@smallexample\n+if (__builtin_cpu_supports (\"fpu\"))\n+  @{\n+     asm(\"fadd %0,%1,%2\" : \"=d\"(dst) : \"d\"(src1), \"d\"(src2));\n+  @}\n+else\n+  @{\n+     dst = __fadd (src1, src2); // Software FP addition function.\n+  @}\n+@end smallexample\n+@end deftypefn\n+\n These built-in functions are available for the PowerPC family of\n processors:\n @smallexample"}, {"sha": "bd23b3654838d7f602c2582b689e74e653570daa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -1,3 +1,7 @@\n+2016-01-20  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/cpu-builtin-1.c: New test.\n+\n 2016-01-20  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR c/24293"}, {"sha": "a0e30410050d4306b099e286c6be6cd1fc01989e", "filename": "gcc/testsuite/gcc.target/powerpc/cpu-builtin-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcpu-builtin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a2e6aed46f0690aee229788887908b7116f515/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcpu-builtin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcpu-builtin-1.c?ref=26a2e6aed46f0690aee229788887908b7116f515", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+\n+void\n+use_cpu_is_builtins (unsigned int *p)\n+{\n+  p[0] = __builtin_cpu_is (\"power9\");\n+  p[1] = __builtin_cpu_is (\"power8\");\n+  p[2] = __builtin_cpu_is (\"power7\");\n+  p[3] = __builtin_cpu_is (\"power6x\");\n+  p[4] = __builtin_cpu_is (\"power6\");\n+  p[5] = __builtin_cpu_is (\"power5+\");\n+  p[6] = __builtin_cpu_is (\"power5\");\n+  p[7] = __builtin_cpu_is (\"ppc970\");\n+  p[8] = __builtin_cpu_is (\"power4\");\n+  p[9] = __builtin_cpu_is (\"ppca2\");\n+  p[10] = __builtin_cpu_is (\"ppc476\");\n+  p[11] = __builtin_cpu_is (\"ppc464\");\n+  p[12] = __builtin_cpu_is (\"ppc440\");\n+  p[13] = __builtin_cpu_is (\"ppc405\");\n+  p[14] = __builtin_cpu_is (\"ppc-cell-be\");\n+}\n+\n+void\n+use_cpu_supports_builtins (unsigned int *p)\n+{\n+  p[0] = __builtin_cpu_supports (\"4xxmac\");\n+  p[1] = __builtin_cpu_supports (\"altivec\");\n+  p[2] = __builtin_cpu_supports (\"arch_2_05\");\n+  p[3] = __builtin_cpu_supports (\"arch_2_06\");\n+  p[4] = __builtin_cpu_supports (\"arch_2_07\");\n+  p[5] = __builtin_cpu_supports (\"arch_3_00\");\n+  p[6] = __builtin_cpu_supports (\"archpmu\");\n+  p[7] = __builtin_cpu_supports (\"booke\");\n+  p[8] = __builtin_cpu_supports (\"cellbe\");\n+  p[9] = __builtin_cpu_supports (\"dfp\");\n+  p[10] = __builtin_cpu_supports (\"dscr\");\n+  p[11] = __builtin_cpu_supports (\"ebb\");\n+  p[12] = __builtin_cpu_supports (\"efpdouble\");\n+  p[13] = __builtin_cpu_supports (\"efpsingle\");\n+  p[14] = __builtin_cpu_supports (\"fpu\");\n+  p[15] = __builtin_cpu_supports (\"htm\");\n+  p[16] = __builtin_cpu_supports (\"htm-nosc\");\n+  p[17] = __builtin_cpu_supports (\"ic_snoop\");\n+  p[18] = __builtin_cpu_supports (\"ieee128\");\n+  p[19] = __builtin_cpu_supports (\"isel\");\n+  p[20] = __builtin_cpu_supports (\"mmu\");\n+  p[21] = __builtin_cpu_supports (\"notb\");\n+  p[22] = __builtin_cpu_supports (\"pa6t\");\n+  p[23] = __builtin_cpu_supports (\"power4\");\n+  p[24] = __builtin_cpu_supports (\"power5\");\n+  p[25] = __builtin_cpu_supports (\"power5+\");\n+  p[26] = __builtin_cpu_supports (\"power6x\");\n+  p[27] = __builtin_cpu_supports (\"ppc32\");\n+  p[28] = __builtin_cpu_supports (\"ppc601\");\n+  p[29] = __builtin_cpu_supports (\"ppc64\");\n+  p[30] = __builtin_cpu_supports (\"ppcle\");\n+  p[31] = __builtin_cpu_supports (\"smt\");\n+  p[32] = __builtin_cpu_supports (\"spe\");\n+  p[33] = __builtin_cpu_supports (\"tar\");\n+  p[34] = __builtin_cpu_supports (\"true_le\");\n+  p[35] = __builtin_cpu_supports (\"ucache\");\n+  p[36] = __builtin_cpu_supports (\"vcrypto\");\n+  p[37] = __builtin_cpu_supports (\"vsx\");\n+}"}]}