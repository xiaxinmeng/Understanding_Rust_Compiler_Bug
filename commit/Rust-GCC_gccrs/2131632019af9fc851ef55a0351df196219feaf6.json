{"sha": "2131632019af9fc851ef55a0351df196219feaf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEzMTYzMjAxOWFmOWZjODUxZWY1NWEwMzUxZGYxOTYyMTlmZWFmNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-05-26T21:38:19Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-05-26T21:38:19Z"}, "message": "rs6000.c (rs6000_emit_p9_fp_minmax): New function for ISA 3.0 min/max support.\n\n[gcc]\n2016-05-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_emit_p9_fp_minmax): New function\n\tfor ISA 3.0 min/max support.\n\t(rs6000_emit_p9_fp_cmove): New function for ISA 3.0 floating point\n\tconditional move support.\n\t(rs6000_emit_cmove): Call rs6000_emit_p9_fp_minmax and\n\trs6000_emit_p9_fp_cmove if the ISA 3.0 instructions are\n\tavailable.\n\t* config/rs6000/rs6000.md (SFDF2): New iterator to allow doing\n\tconditional moves where the comparison type is different from move\n\ttype.\n\t(fp_minmax): New code iterator for smin/smax.\n\t(minmax): New code attributes for min/max.\n\t(SMINMAX): Likewise.\n\t(smax<mode>3): Combine min, max insns into one insn using the\n\tfp_minmax code iterator.  Add support for ISA 3.0 min/max\n\tinstructions that don't need -ffast-math.\n\t(s<minmax><mode>3): Likewise.\n\t(smax<mode>3_vsx): Likewise.\n\t(smin<mode>3): Likewise.\n\t(s<minmax><mode>3_vsx): Likewise.\n\t(smin<mode>3_vsx): Likewise.\n\t(pre-VSX min/max splitters): Likewise.\n\t(s<minmax><mode>3_fpr): Likewise.\n\t(movsfcc): Rewrite floating point conditional moves to combine\n\tSFmode/DFmode into a single insn.\n\t(mov<mode>cc): Likewise.\n\t(movdfcc): Likewise.\n\t(fselsfsf4): Combine FSEL cases into a single insn, using SFDF and\n\tSFDF2 iterators to handle all combinations.\n\t(fseldfsf4): Likewise.\n\t(fsel<SFDF:mode><SFDF2:mode>4): Likewise.\n\t(fseldfdf4): Likewise.\n\t(fselsfdf4): Likewise.\n\t(mov<SFDF:mode><SFDF2:mode>cc_p9): Add support for the ISA 3.0\n\tcomparison instructions that set a 0/-1 mask, and use it for\n\tfloating point conditional move via XXSEL.\n\t(fpmask<mode>): Likewise.\n\t(xxsel<mode>): Likewise.\n\t* config/rs6000/predicates.md (min_max_operator): Delete, no\n\tlonger used.\n\t(fpmask_comparison_operaton): New insn for ISA 3.0 comparison\n\tinstructions that generate a 0/-1 mask for use with XXSEL.\n\t* config/rs6000/rs6000.h (TARGET_MINMAX_SF): New helper macros to\n\tsay whether floating point min/max is available, either through\n\tFSEL, ISA 2.06 min/max, and ISA 3.0 min/max instrucitons.\n\t(TARGET_MINMAX_DF): Likewise.\n\n[gcc/testsuite]\n2016-05-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p9-minmax-1.c: New tests for ISA 3.0\n\tfloating point min/max/comparison instructions.\n\t* gcc.target/powerpc/p9-minmax-2.c: Likewise.\n\nFrom-SVN: r236795", "tree": {"sha": "71ba80056ccfa5ccfc5c5c9b6301d3290427df27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71ba80056ccfa5ccfc5c5c9b6301d3290427df27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2131632019af9fc851ef55a0351df196219feaf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2131632019af9fc851ef55a0351df196219feaf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2131632019af9fc851ef55a0351df196219feaf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2131632019af9fc851ef55a0351df196219feaf6/comments", "author": null, "committer": null, "parents": [{"sha": "7211a0975c25b21baa8e31ebc2946f4d6d136fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7211a0975c25b21baa8e31ebc2946f4d6d136fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7211a0975c25b21baa8e31ebc2946f4d6d136fed"}], "stats": {"total": 769, "additions": 641, "deletions": 128}, "files": [{"sha": "ab5d2e9266253397b8ab652d08766d6f10902a3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -1,3 +1,52 @@\n+2016-05-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_p9_fp_minmax): New function\n+\tfor ISA 3.0 min/max support.\n+\t(rs6000_emit_p9_fp_cmove): New function for ISA 3.0 floating point\n+\tconditional move support.\n+\t(rs6000_emit_cmove): Call rs6000_emit_p9_fp_minmax and\n+\trs6000_emit_p9_fp_cmove if the ISA 3.0 instructions are\n+\tavailable.\n+\t* config/rs6000/rs6000.md (SFDF2): New iterator to allow doing\n+\tconditional moves where the comparison type is different from move\n+\ttype.\n+\t(fp_minmax): New code iterator for smin/smax.\n+\t(minmax): New code attributes for min/max.\n+\t(SMINMAX): Likewise.\n+\t(smax<mode>3): Combine min, max insns into one insn using the\n+\tfp_minmax code iterator.  Add support for ISA 3.0 min/max\n+\tinstructions that don't need -ffast-math.\n+\t(s<minmax><mode>3): Likewise.\n+\t(smax<mode>3_vsx): Likewise.\n+\t(smin<mode>3): Likewise.\n+\t(s<minmax><mode>3_vsx): Likewise.\n+\t(smin<mode>3_vsx): Likewise.\n+\t(pre-VSX min/max splitters): Likewise.\n+\t(s<minmax><mode>3_fpr): Likewise.\n+\t(movsfcc): Rewrite floating point conditional moves to combine\n+\tSFmode/DFmode into a single insn.\n+\t(mov<mode>cc): Likewise.\n+\t(movdfcc): Likewise.\n+\t(fselsfsf4): Combine FSEL cases into a single insn, using SFDF and\n+\tSFDF2 iterators to handle all combinations.\n+\t(fseldfsf4): Likewise.\n+\t(fsel<SFDF:mode><SFDF2:mode>4): Likewise.\n+\t(fseldfdf4): Likewise.\n+\t(fselsfdf4): Likewise.\n+\t(mov<SFDF:mode><SFDF2:mode>cc_p9): Add support for the ISA 3.0\n+\tcomparison instructions that set a 0/-1 mask, and use it for\n+\tfloating point conditional move via XXSEL.\n+\t(fpmask<mode>): Likewise.\n+\t(xxsel<mode>): Likewise.\n+\t* config/rs6000/predicates.md (min_max_operator): Delete, no\n+\tlonger used.\n+\t(fpmask_comparison_operaton): New insn for ISA 3.0 comparison\n+\tinstructions that generate a 0/-1 mask for use with XXSEL.\n+\t* config/rs6000/rs6000.h (TARGET_MINMAX_SF): New helper macros to\n+\tsay whether floating point min/max is available, either through\n+\tFSEL, ISA 2.06 min/max, and ISA 3.0 min/max instrucitons.\n+\t(TARGET_MINMAX_DF): Likewise.\n+\n 2016-05-27  Alan Modra  <amodra@gmail.com>\n \n \tPR rtl-optimization/71275"}, {"sha": "ed3e84ebb14b2a2a7f963842f7d8adbe4fa7c955", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -1109,10 +1109,6 @@\n (define_special_predicate \"equality_operator\"\n   (match_code \"eq,ne\"))\n \n-;; Return true if operand is MIN or MAX operator.\n-(define_predicate \"min_max_operator\"\n-  (match_code \"smin,smax,umin,umax\"))\n-\n ;; Return 1 if OP is a comparison operation that is valid for a branch\n ;; instruction.  We check the opcode against the mode of the CC value.\n ;; validate_condition_mode is an assertion.\n@@ -1155,6 +1151,11 @@\n   (and (match_operand 0 \"branch_comparison_operator\")\n        (match_code \"ne,le,ge,leu,geu,ordered\")))\n \n+;; Return 1 if OP is a comparison operator suitable for vector/scalar\n+;; comparisons that generate a -1/0 mask.\n+(define_predicate \"fpmask_comparison_operator\"\n+  (match_code \"eq,gt,ge\"))\n+\n ;; Return 1 if OP is a comparison operation that is valid for a branch\n ;; insn, which is true if the corresponding bit in the CC register is set.\n (define_predicate \"branch_positive_comparison_operator\""}, {"sha": "c6b2b6ad4f4dd848a44426f66bb97c0b2c576743", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -22643,6 +22643,101 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n   return 1;\n }\n \n+/* ISA 3.0 (power9) minmax subcase to emit a XSMAXCDP or XSMINCDP instruction\n+   for SF/DF scalars.  Move TRUE_COND to DEST if OP of the operands of the last\n+   comparison is nonzero/true, FALSE_COND if it is zero/false.  Return 0 if the\n+   hardware has no such operation.  */\n+\n+static int\n+rs6000_emit_p9_fp_minmax (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  rtx op0 = XEXP (op, 0);\n+  rtx op1 = XEXP (op, 1);\n+  machine_mode compare_mode = GET_MODE (op0);\n+  machine_mode result_mode = GET_MODE (dest);\n+  bool max_p = false;\n+\n+  if (result_mode != compare_mode)\n+    return 0;\n+\n+  if (code == GE || code == GT)\n+    max_p = true;\n+  else if (code == LE || code == LT)\n+    max_p = false;\n+  else\n+    return 0;\n+\n+  if (rtx_equal_p (op0, true_cond) && rtx_equal_p (op1, false_cond))\n+    ;\n+\n+  else if (rtx_equal_p (op1, true_cond) && rtx_equal_p (op0, false_cond))\n+    max_p = !max_p;\n+\n+  else\n+    return 0;\n+\n+  rs6000_emit_minmax (dest, max_p ? SMAX : SMIN, op0, op1);\n+  return 1;\n+}\n+\n+/* ISA 3.0 (power9) conditional move subcase to emit XSCMP{EQ,GE,GT,NE}DP and\n+   XXSEL instructions for SF/DF scalars.  Move TRUE_COND to DEST if OP of the\n+   operands of the last comparison is nonzero/true, FALSE_COND if it is\n+   zero/false.  Return 0 if the hardware has no such operation.  */\n+\n+static int\n+rs6000_emit_p9_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  rtx op0 = XEXP (op, 0);\n+  rtx op1 = XEXP (op, 1);\n+  machine_mode result_mode = GET_MODE (dest);\n+  rtx compare_rtx;\n+  rtx cmove_rtx;\n+  rtx clobber_rtx;\n+\n+  if (!can_create_pseudo_p ())\n+    return 0;\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case GE:\n+    case GT:\n+      break;\n+\n+    case NE:\n+    case LT:\n+    case LE:\n+      code = swap_condition (code);\n+      std::swap (op0, op1);\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  /* Generate:\t[(parallel [(set (dest)\n+\t\t\t\t (if_then_else (op (cmp1) (cmp2))\n+\t\t\t\t\t       (true)\n+\t\t\t\t\t       (false)))\n+\t\t\t    (clobber (scratch))])].  */\n+\n+  compare_rtx = gen_rtx_fmt_ee (code, CCFPmode, op0, op1);\n+  cmove_rtx = gen_rtx_SET (dest,\n+\t\t\t   gen_rtx_IF_THEN_ELSE (result_mode,\n+\t\t\t\t\t\t compare_rtx,\n+\t\t\t\t\t\t true_cond,\n+\t\t\t\t\t\t false_cond));\n+\n+  clobber_rtx = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (V2DImode));\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t       gen_rtvec (2, cmove_rtx, clobber_rtx)));\n+\n+  return 1;\n+}\n+\n /* Emit a conditional move: move TRUE_COND to DEST if OP of the\n    operands of the last comparison is nonzero/true, FALSE_COND if it\n    is zero/false.  Return 0 if the hardware has no such operation.  */\n@@ -22669,6 +22764,18 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   if (GET_MODE (false_cond) != result_mode)\n     return 0;\n \n+  /* See if we can use the ISA 3.0 (power9) min/max/compare functions.  */\n+  if (TARGET_P9_MINMAX\n+      && (compare_mode == SFmode || compare_mode == DFmode)\n+      && (result_mode == SFmode || result_mode == DFmode))\n+    {\n+      if (rs6000_emit_p9_fp_minmax (dest, op, true_cond, false_cond))\n+\treturn 1;\n+\n+      if (rs6000_emit_p9_fp_cmove (dest, op, true_cond, false_cond))\n+\treturn 1;\n+    }\n+\n   /* Don't allow using floating point comparisons for integer results for\n      now.  */\n   if (FLOAT_MODE_P (compare_mode) && !FLOAT_MODE_P (result_mode))"}, {"sha": "5f5510a6146788cd79d794dab4559214e9725e3d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -594,6 +594,15 @@ extern int rs6000_vector_align[];\n    in the register.  */\n #define TARGET_NO_SDMODE_STACK\t(TARGET_LFIWZX && TARGET_STFIWX && TARGET_DFP)\n \n+/* ISA 3.0 has new min/max functions that don't need fast math that are being\n+   phased in.  Min/max using FSEL or XSMAXDP/XSMINDP do not return the correct\n+   answers if the arguments are not in the normal range.  */\n+#define TARGET_MINMAX_SF\t(TARGET_SF_FPR && TARGET_PPC_GFXOPT\t\\\n+\t\t\t\t && (TARGET_P9_MINMAX || !flag_trapping_math))\n+\n+#define TARGET_MINMAX_DF\t(TARGET_DF_FPR && TARGET_PPC_GFXOPT\t\\\n+\t\t\t\t && (TARGET_P9_MINMAX || !flag_trapping_math))\n+\n /* In switching from using target_flags to using rs6000_isa_flags, the options\n    machinery creates OPTION_MASK_<xxx> instead of MASK_<xxx>.  For now map\n    OPTION_MASK_<xxx> back into MASK_<xxx>.  */"}, {"sha": "6628bc691f4999107393b6a3b5ee65acf93f1d6b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 103, "deletions": 124, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -489,6 +489,10 @@\n ; Iterator for just SF/DF\n (define_mode_iterator SFDF [SF DF])\n \n+; Like SFDF, but a different name to match conditional move where the\n+; comparison operands may be a different mode than the input operands.\n+(define_mode_iterator SFDF2 [SF DF])\n+\n ; Iterator for 128-bit floating point that uses the IBM double-double format\n (define_mode_iterator IBM128 [(IF \"FLOAT128_IBM_P (IFmode)\")\n \t\t\t      (TF \"FLOAT128_IBM_P (TFmode)\")])\n@@ -700,6 +704,15 @@\n (define_mode_iterator RELOAD [V16QI V8HI V4SI V2DI V4SF V2DF V1TI\n \t\t\t      SF SD SI DF DD DI TI PTI KF IF TF])\n \n+;; Iterate over smin, smax\n+(define_code_iterator fp_minmax\t[smin smax])\n+\n+(define_code_attr     minmax\t[(smin \"min\")\n+\t\t\t\t (smax \"max\")])\n+\n+(define_code_attr     SMINMAX\t[(smin \"SMIN\")\n+\t\t\t\t (smax \"SMAX\")])\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -4629,74 +4642,45 @@\n ;; On VSX, we only check for TARGET_VSX instead of checking for a vsx/p8 vector\n ;; to allow either DF/SF to use only traditional registers.\n \n-(define_expand \"smax<mode>3\"\n+(define_expand \"s<minmax><mode>3\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:SFDF (ge (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n-\t\t\t       (match_operand:SFDF 2 \"gpc_reg_operand\" \"\"))\n-\t\t\t   (match_dup 1)\n-\t\t\t   (match_dup 2)))]\n-  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math\"\n+\t(fp_minmax:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t(match_operand:SFDF 2 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_MINMAX_<MODE>\"\n {\n-  rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]);\n+  rs6000_emit_minmax (operands[0], <SMINMAX>, operands[1], operands[2]);\n   DONE;\n })\n \n-(define_insn \"*smax<mode>3_vsx\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n-\t(smax:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv>\")\n-\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_<MODE>_FPR && TARGET_VSX\"\n-  \"xsmaxdp %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"smin<mode>3\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:SFDF (ge (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n-\t\t\t       (match_operand:SFDF 2 \"gpc_reg_operand\" \"\"))\n-\t\t\t   (match_dup 2)\n-\t\t\t   (match_dup 1)))]\n-  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math\"\n+(define_insn \"*s<minmax><mode>3_vsx\"\n+  [(set (match_operand:SFDF 0 \"vsx_register_operand\" \"=<Fv>\")\n+\t(fp_minmax:SFDF (match_operand:SFDF 1 \"vsx_register_operand\" \"<Fv>\")\n+\t\t\t(match_operand:SFDF 2 \"vsx_register_operand\" \"<Fv>\")))]\n+  \"TARGET_VSX && TARGET_<MODE>_FPR\"\n {\n-  rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]);\n-  DONE;\n-})\n-\n-(define_insn \"*smin<mode>3_vsx\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n-\t(smin:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv>\")\n-\t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_<MODE>_FPR && TARGET_VSX\"\n-  \"xsmindp %x0,%x1,%x2\"\n+  return (TARGET_P9_MINMAX\n+\t  ? \"xs<minmax>cdp %x0,%x1,%x2\"\n+\t  : \"xs<minmax>dp %x0,%x1,%x2\");\n+}\n   [(set_attr \"type\" \"fp\")])\n \n-(define_split\n+;; The conditional move instructions allow us to perform max and min operations\n+;; even when we don't have the appropriate max/min instruction using the FSEL\n+;; instruction.\n+\n+(define_insn_and_split \"*s<minmax><mode>3_fpr\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operator:SFDF 3 \"min_max_operator\"\n-\t [(match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")]))]\n-  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT && !flag_trapping_math\n-   && !TARGET_VSX\"\n+\t(fp_minmax:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t(match_operand:SFDF 2 \"gpc_reg_operand\" \"\")))]\n+  \"!TARGET_VSX && TARGET_MINMAX_<MODE>\"\n+  \"#\"\n+  \"&& 1\"\n   [(const_int 0)]\n {\n-  rs6000_emit_minmax (operands[0], GET_CODE (operands[3]), operands[1],\n-\t\t      operands[2]);\n+  rs6000_emit_minmax (operands[0], <SMINMAX>, operands[1], operands[2]);\n   DONE;\n })\n \n-(define_split\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operator:SF 3 \"min_max_operator\"\n-\t [(match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:SF 2 \"gpc_reg_operand\" \"\")]))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS \n-   && TARGET_SINGLE_FLOAT && !flag_trapping_math\"\n-  [(const_int 0)]\n-  \"\n-{ rs6000_emit_minmax (operands[0], GET_CODE (operands[3]),\n-\t\t      operands[1], operands[2]);\n-  DONE;\n-}\")\n-\n (define_expand \"mov<mode>cc\"\n    [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n \t (if_then_else:GPR (match_operand 1 \"comparison_operator\" \"\")\n@@ -4779,12 +4763,13 @@\n   [(set_attr \"type\" \"isel\")\n    (set_attr \"length\" \"4\")])\n \n-(define_expand \"movsfcc\"\n-   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t (if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+;; Floating point conditional move\n+(define_expand \"mov<mode>cc\"\n+   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+\t (if_then_else:SFDF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t    (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")\n+\t\t\t    (match_operand:SFDF 3 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT\"\n   \"\n {\n   if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n@@ -4793,76 +4778,70 @@\n     FAIL;\n }\")\n \n-(define_insn \"*fselsfsf4\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(if_then_else:SF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t     (match_operand:SF 4 \"zero_fp_constant\" \"F\"))\n-\t\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+(define_insn \"*fsel<SFDF:mode><SFDF2:mode>4\"\n+  [(set (match_operand:SFDF 0 \"fpr_reg_operand\" \"=&<SFDF:rreg2>\")\n+\t(if_then_else:SFDF\n+\t (ge (match_operand:SFDF2 1 \"fpr_reg_operand\" \"<SFDF2:rreg2>\")\n+\t     (match_operand:SFDF2 4 \"zero_fp_constant\" \"F\"))\n+\t (match_operand:SFDF 2 \"fpr_reg_operand\" \"<SFDF:rreg2>\")\n+\t (match_operand:SFDF 3 \"fpr_reg_operand\" \"<SFDF:rreg2>\")))]\n+  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT\"\n   \"fsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"*fseldfsf4\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(if_then_else:SF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"d\")\n-\t\t\t     (match_operand:DF 4 \"zero_fp_constant\" \"F\"))\n-\t\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_SINGLE_FLOAT\"\n-  \"fsel %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-;; The conditional move instructions allow us to perform max and min\n-;; operations even when\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operator:DF 3 \"min_max_operator\"\n-\t [(match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t  (match_operand:DF 2 \"gpc_reg_operand\" \"\")]))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n-   && !flag_trapping_math\"\n-  [(const_int 0)]\n-  \"\n-{ rs6000_emit_minmax (operands[0], GET_CODE (operands[3]),\n-\t\t      operands[1], operands[2]);\n-  DONE;\n-}\")\n-\n-(define_expand \"movdfcc\"\n-   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t (if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t  (match_operand:DF 2 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:DF 3 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n-  \"\n+(define_insn_and_split \"*mov<SFDF:mode><SFDF2:mode>cc_p9\"\n+  [(set (match_operand:SFDF 0 \"vsx_register_operand\" \"=&<SFDF:Fv>,<SFDF:Fv>\")\n+\t(if_then_else:SFDF\n+\t (match_operator:CCFP 1 \"fpmask_comparison_operator\"\n+\t\t[(match_operand:SFDF2 2 \"vsx_register_operand\" \"<SFDF2:Fv>,<SFDF2:Fv>\")\n+\t\t (match_operand:SFDF2 3 \"vsx_register_operand\" \"<SFDF2:Fv>,<SFDF2:Fv>\")])\n+\t (match_operand:SFDF 4 \"vsx_register_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")\n+\t (match_operand:SFDF 5 \"vsx_register_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")))\n+   (clobber (match_scratch:V2DI 6 \"=0,&wa\"))]\n+  \"TARGET_P9_MINMAX\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 6)\n+\t(if_then_else:V2DI (match_dup 1)\n+\t\t\t   (match_dup 7)\n+\t\t\t   (match_dup 8)))\n+   (set (match_dup 0)\n+\t(if_then_else:SFDF (ne (match_dup 6)\n+\t\t\t       (match_dup 8))\n+\t\t\t   (match_dup 4)\n+\t\t\t   (match_dup 5)))]\n {\n-  if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n-    DONE;\n-  else\n-    FAIL;\n-}\")\n+  if (GET_CODE (operands[6]) == SCRATCH)\n+    operands[6] = gen_reg_rtx (V2DImode);\n \n-(define_insn \"*fseldfdf4\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(if_then_else:DF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"d\")\n-\t\t\t     (match_operand:DF 4 \"zero_fp_constant\" \"F\"))\n-\t\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"d\")\n-\t\t\t (match_operand:DF 3 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n-  \"fsel %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n+  operands[7] = CONSTM1_RTX (V2DImode);\n+  operands[8] = CONST0_RTX (V2DImode);\n+}\n+ [(set_attr \"length\" \"8\")\n+  (set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"*fpmask<mode>\"\n+  [(set (match_operand:V2DI 0 \"vsx_register_operand\" \"=wa\")\n+\t(if_then_else:V2DI\n+\t (match_operator:CCFP 1 \"fpmask_comparison_operator\"\n+\t\t[(match_operand:SFDF 2 \"vsx_register_operand\" \"<Fv>\")\n+\t\t (match_operand:SFDF 3 \"vsx_register_operand\" \"<Fv>\")])\n+\t (match_operand:V2DI 4 \"all_ones_constant\" \"\")\n+\t (match_operand:V2DI 5 \"zero_constant\" \"\")))]\n+  \"TARGET_P9_MINMAX\"\n+  \"xscmp%V1dp %x0,%x2,%x3\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n+(define_insn \"*xxsel<mode>\"\n+  [(set (match_operand:SFDF 0 \"vsx_register_operand\" \"=<Fv>\")\n+\t(if_then_else:SFDF (ne (match_operand:V2DI 1 \"vsx_register_operand\" \"wa\")\n+\t\t\t       (match_operand:V2DI 2 \"zero_constant\" \"\"))\n+\t\t\t   (match_operand:SFDF 3 \"vsx_register_operand\" \"<Fv>\")\n+\t\t\t   (match_operand:SFDF 4 \"vsx_register_operand\" \"<Fv>\")))]\n+  \"TARGET_P9_MINMAX\"\n+  \"xxsel %x0,%x1,%x3,%x4\"\n+  [(set_attr \"type\" \"vecperm\")])\n \n-(define_insn \"*fselsfdf4\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(if_then_else:DF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t     (match_operand:SF 4 \"zero_fp_constant\" \"F\"))\n-\t\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"d\")\n-\t\t\t (match_operand:DF 3 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_SINGLE_FLOAT\"\n-  \"fsel %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n \f\n ;; Conversions to and from floating-point.\n "}, {"sha": "f046e40c8d26ae83106b2c2a68b5e65ee2449106", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -1,3 +1,9 @@\n+2016-05-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p9-minmax-1.c: New tests for ISA 3.0\n+\tfloating point min/max/comparison instructions.\n+\t* gcc.target/powerpc/p9-minmax-2.c: Likewise.\n+\n 2016-05-26  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-c++-common/gomp/schedule-1.c: New test."}, {"sha": "c182da9470e46a9ef0c3aeaee76c4feeacfe67af", "filename": "gcc/testsuite/gcc.target/powerpc/p9-minmax-1.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-minmax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-minmax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-minmax-1.c?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -0,0 +1,171 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mpower9-minmax -ffast-math\" } */\n+/* { dg-final { scan-assembler-not \"fsel\"      } } */\n+/* { dg-final { scan-assembler     \"xscmpeqdp\" } } */\n+/* { dg-final { scan-assembler     \"xscmpgtdp\" } } */\n+/* { dg-final { scan-assembler     \"xscmpgedp\" } } */\n+/* { dg-final { scan-assembler-not \"xscmpodp\"  } } */\n+/* { dg-final { scan-assembler-not \"xscmpudp\"  } } */\n+/* { dg-final { scan-assembler     \"xsmaxcdp\"  } } */\n+/* { dg-final { scan-assembler-not \"xsmaxdp\"   } } */\n+/* { dg-final { scan-assembler     \"xsmincdp\"  } } */\n+/* { dg-final { scan-assembler-not \"xsmindp\"   } } */\n+/* { dg-final { scan-assembler     \"xxsel\"     } } */\n+\n+double\n+dbl_max1 (double a, double b)\n+{\n+  return (a >= b) ? a : b;\n+}\n+\n+double\n+dbl_max2 (double a, double b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_min1 (double a, double b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+double\n+dbl_min2 (double a, double b)\n+{\n+  return (a <= b) ? a : b;\n+}\n+\n+double\n+dbl_cmp_eq (double a, double b, double c, double d)\n+{\n+  return (a == b) ? c : d;\n+}\n+\n+double\n+dbl_cmp_ne (double a, double b, double c, double d)\n+{\n+  return (a != b) ? c : d;\n+}\n+\n+double\n+dbl_cmp_gt (double a, double b, double c, double d)\n+{\n+  return (a > b) ? c : d;\n+}\n+\n+double\n+dbl_cmp_ge (double a, double b, double c, double d)\n+{\n+  return (a >= b) ? c : d;\n+}\n+\n+double\n+dbl_cmp_lt (double a, double b, double c, double d)\n+{\n+  return (a < b) ? c : d;\n+}\n+\n+double\n+dbl_cmp_le (double a, double b, double c, double d)\n+{\n+  return (a <= b) ? c : d;\n+}\n+\n+float\n+flt_max1 (float a, float b)\n+{\n+  return (a >= b) ? a : b;\n+}\n+\n+float\n+flt_max2 (float a, float b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+float\n+flt_min1 (float a, float b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+float\n+flt_min2 (float a, float b)\n+{\n+  return (a <= b) ? a : b;\n+}\n+\n+float\n+flt_cmp_eq (float a, float b, float c, float d)\n+{\n+  return (a == b) ? c : d;\n+}\n+\n+float\n+flt_cmp_ne (float a, float b, float c, float d)\n+{\n+  return (a != b) ? c : d;\n+}\n+\n+float\n+flt_cmp_gt (float a, float b, float c, float d)\n+{\n+  return (a > b) ? c : d;\n+}\n+\n+float\n+flt_cmp_ge (float a, float b, float c, float d)\n+{\n+  return (a >= b) ? c : d;\n+}\n+\n+float\n+flt_cmp_lt (float a, float b, float c, float d)\n+{\n+  return (a < b) ? c : d;\n+}\n+\n+float\n+flt_cmp_le (float a, float b, float c, float d)\n+{\n+  return (a <= b) ? c : d;\n+}\n+\n+double\n+dbl_flt_max1 (float a, float b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_flt_max2 (double a, float b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_flt_max3 (float a, double b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_flt_min1 (float a, float b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+double\n+dbl_flt_min2 (double a, float b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+double\n+dbl_flt_min3 (float a, double b)\n+{\n+  return (a < b) ? a : b;\n+}"}, {"sha": "f674214296634de11c5364e83fee1ec87dbb2512", "filename": "gcc/testsuite/gcc.target/powerpc/p9-minmax-2.c", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-minmax-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2131632019af9fc851ef55a0351df196219feaf6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-minmax-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-minmax-2.c?ref=2131632019af9fc851ef55a0351df196219feaf6", "patch": "@@ -0,0 +1,191 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2 -mpower9-minmax\" } */\n+/* { dg-final { scan-assembler-not \"fsel\"      } } */\n+/* { dg-final { scan-assembler     \"xscmpeqdp\" } } */\n+/* { dg-final { scan-assembler     \"xscmpgtdp\" } } */\n+/* { dg-final { scan-assembler-not \"xscmpodp\"  } } */\n+/* { dg-final { scan-assembler-not \"xscmpudp\"  } } */\n+/* { dg-final { scan-assembler     \"xsmaxcdp\"  } } */\n+/* { dg-final { scan-assembler-not \"xsmaxdp\"   } } */\n+/* { dg-final { scan-assembler     \"xsmincdp\"  } } */\n+/* { dg-final { scan-assembler-not \"xsmindp\"   } } */\n+/* { dg-final { scan-assembler     \"xxsel\"     } } */\n+\n+/* Due to NaN support, <= and >= are not handled presently unless -ffast-math\n+   is used.  At some point this will be fixed and the xscmpgedp instruction can\n+   be generated normally. The <= and >= tests are bracketed with\n+   #ifdef DO_GE_LE.  */\n+\n+#ifdef DO_GE_LE\n+double\n+dbl_max1 (double a, double b)\n+{\n+  return (a >= b) ? a : b;\n+}\n+#endif\n+\n+double\n+dbl_max2 (double a, double b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_min1 (double a, double b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+#ifdef DO_GE_LE\n+double\n+dbl_min2 (double a, double b)\n+{\n+  return (a <= b) ? a : b;\n+}\n+#endif\n+\n+double\n+dbl_cmp_eq (double a, double b, double c, double d)\n+{\n+  return (a == b) ? c : d;\n+}\n+\n+double\n+dbl_cmp_ne (double a, double b, double c, double d)\n+{\n+  return (a != b) ? c : d;\n+}\n+\n+double\n+dbl_cmp_gt (double a, double b, double c, double d)\n+{\n+  return (a > b) ? c : d;\n+}\n+\n+#ifdef DO_GE_LE\n+double\n+dbl_cmp_ge (double a, double b, double c, double d)\n+{\n+  return (a >= b) ? c : d;\n+}\n+#endif\n+\n+double\n+dbl_cmp_lt (double a, double b, double c, double d)\n+{\n+  return (a < b) ? c : d;\n+}\n+\n+#ifdef DO_GE_LE\n+double\n+dbl_cmp_le (double a, double b, double c, double d)\n+{\n+  return (a <= b) ? c : d;\n+}\n+#endif\n+\n+#ifdef DO_GE_LE\n+float\n+flt_max1 (float a, float b)\n+{\n+  return (a >= b) ? a : b;\n+}\n+#endif\n+\n+float\n+flt_max2 (float a, float b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+float\n+flt_min1 (float a, float b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+#ifdef DO_GE_LE\n+float\n+flt_min2 (float a, float b)\n+{\n+  return (a <= b) ? a : b;\n+}\n+#endif\n+\n+float\n+flt_cmp_eq (float a, float b, float c, float d)\n+{\n+  return (a == b) ? c : d;\n+}\n+\n+float\n+flt_cmp_ne (float a, float b, float c, float d)\n+{\n+  return (a != b) ? c : d;\n+}\n+\n+float\n+flt_cmp_gt (float a, float b, float c, float d)\n+{\n+  return (a > b) ? c : d;\n+}\n+\n+#ifdef DO_GE_LE\n+float\n+flt_cmp_ge (float a, float b, float c, float d)\n+{\n+  return (a >= b) ? c : d;\n+}\n+#endif\n+\n+float\n+flt_cmp_lt (float a, float b, float c, float d)\n+{\n+  return (a < b) ? c : d;\n+}\n+\n+#ifdef DO_GE_LE\n+float\n+flt_cmp_le (float a, float b, float c, float d)\n+{\n+  return (a <= b) ? c : d;\n+}\n+#endif\n+\n+double\n+dbl_flt_max1 (float a, float b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_flt_max2 (double a, float b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_flt_max3 (float a, double b)\n+{\n+  return (a > b) ? a : b;\n+}\n+\n+double\n+dbl_flt_min1 (float a, float b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+double\n+dbl_flt_min2 (double a, float b)\n+{\n+  return (a < b) ? a : b;\n+}\n+\n+double\n+dbl_flt_min3 (float a, double b)\n+{\n+  return (a < b) ? a : b;\n+}"}]}