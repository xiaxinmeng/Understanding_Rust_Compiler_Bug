{"sha": "4cda35d4c9c295f51e6fc6a5348c8553f5e7675a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNkYTM1ZDRjOWMyOTVmNTFlNmZjNmE1MzQ4Yzg1NTNmNWU3Njc1YQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-01-22T02:23:14Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-22T02:23:14Z"}, "message": "loop.c (loops_info): New variable.\n\n\t* loop.c (loops_info): New variable.\n\t(loop_optimize): Allocate loops->array and free it on exit.\n\tAllocate memory for loops_info and assign to each loop,\n \treplacing alloca.\n\t(find_and_verify_loops): Do not allocate loops->array.\n\nFrom-SVN: r31556", "tree": {"sha": "a4cf402d42dea98c81adbc839979edee2912f926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4cf402d42dea98c81adbc839979edee2912f926"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a/comments", "author": null, "committer": null, "parents": [{"sha": "e8736c0002353a4007f35764c06dda4f68a342be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8736c0002353a4007f35764c06dda4f68a342be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8736c0002353a4007f35764c06dda4f68a342be"}], "stats": {"total": 33, "additions": 20, "deletions": 13}, "files": [{"sha": "13bd549feac4bac049d97ae0be749b06016c407a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cda35d4c9c295f51e6fc6a5348c8553f5e7675a", "patch": "@@ -1,3 +1,11 @@\n+2000-01-22  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.c (loops_info): New variable.\n+\t(loop_optimize): Allocate loops->array and free it on exit.\n+\tAllocate memory for loops_info and assign to each loop,\n+ \treplacing alloca.  \n+\t(find_and_verify_loops): Do not allocate loops->array.\n+\n 2000-01-21  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* fixinc/fixfixes.c (machine_name_fix): Don't free 'scratch'."}, {"sha": "833a0a9a205cfa97350fd1e8d456db109df039c8", "filename": "gcc/loop.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cda35d4c9c295f51e6fc6a5348c8553f5e7675a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4cda35d4c9c295f51e6fc6a5348c8553f5e7675a", "patch": "@@ -419,6 +419,7 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   register int i;\n   struct loops loops_data;\n   struct loops *loops = &loops_data;\n+  struct loop_info *loops_info;\n \n   loop_dump_stream = dumpfile;\n \n@@ -455,10 +456,19 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   uid_loop = (struct loop **) xcalloc (max_uid_for_loop, \n \t\t\t\t       sizeof (struct loop *));\n \n+  /* Allocate storage for array of loops.  */\n+  loops->array = (struct loop *)\n+    xcalloc (loops->num, sizeof (struct loop));\n+\n   /* Find and process each loop.\n      First, find them, and record them in order of their beginnings.  */\n   find_and_verify_loops (f, loops);\n \n+  /* Allocate and initialize auxiliary loop information.  */\n+  loops_info = xcalloc (loops->num, sizeof (struct loop_info));\n+  for (i = 0; i < loops->num; i++)\n+    loops->array[i].info = loops_info + i;\n+\n   /* Now find all register lifetimes.  This must be done after\n      find_and_verify_loops, because it might reorder the insns in the\n      function.  */\n@@ -510,15 +520,6 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n      this prevents low overhead loop instructions from being used.  */\n   indirect_jump_in_function = indirect_jump_in_function_p (f);\n \n-  /* Allocate and initialize auxiliary loop information.  */\n-  for (i = max_loop_num - 1; i >= 0; i--)\n-    {\n-      struct loop *loop = &loops->array[i];\n-\n-      loop->info = (struct loop_info *) alloca (sizeof (struct loop_info));\n-      memset (loop->info, 0, sizeof (struct loop_info));\n-    }\n-\n   /* Now scan the loops, last ones first, since this means inner ones are done\n      before outer ones.  */\n   for (i = max_loop_num - 1; i >= 0; i--)\n@@ -539,6 +540,8 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   free (moved_once);\n   free (uid_luid);\n   free (uid_loop);\n+  free (loops_info);\n+  free (loops->array);\n }\n \f\n /* Returns the next insn, in execution order, after INSN.  START and\n@@ -2596,10 +2599,6 @@ find_and_verify_loops (f, loops)\n      This also avoids writing past end of tables when there are no loops.  */\n   uid_loop[0] = NULL;\n \n-  loops->array = (struct loop *)\n-    xmalloc (num_loops * sizeof (struct loop));\n-  bzero ((char *)loops->array, num_loops * sizeof (struct loop));\n-      \n   /* Find boundaries of loops, mark which loops are contained within\n      loops, and invalidate loops that have setjmp.  */\n "}]}