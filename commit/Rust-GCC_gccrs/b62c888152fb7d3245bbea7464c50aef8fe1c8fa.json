{"sha": "b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYyYzg4ODE1MmZiN2QzMjQ1YmJlYTc0NjRjNTBhZWY4ZmUxYzhmYQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2001-07-06T18:19:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2001-07-06T18:19:47Z"}, "message": "basic-block.h (first_insn_after_basic_block_note): Declare.\n\n        * basic-block.h (first_insn_after_basic_block_note): Declare.\n        * flow.c (first_insn_after_basic_block_note): Define.  Moved\n        from...\n        * ssa.c (first_insn_after_basic_block_note): Remove.\n        * ssa-dce.c (find_inherently_necessary): Consider BARRIERs\n        necessary.\n        (ssa_eliminate_dead_code): Properly update the CFG and PHI\n        nodes when we find a dead conditional branch.  Insert BARRIERs\n        after any blocks with no successors, but which do not have\n        any BARRIERs.\n\nFrom-SVN: r43816", "tree": {"sha": "67a0b8b6cde5491a35db8bb2eecd5ab0f821a64e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67a0b8b6cde5491a35db8bb2eecd5ab0f821a64e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/comments", "author": null, "committer": null, "parents": [{"sha": "9d99ca5b1edb6322b3e7429cc17ff26e972677b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d99ca5b1edb6322b3e7429cc17ff26e972677b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d99ca5b1edb6322b3e7429cc17ff26e972677b4"}], "stats": {"total": 205, "additions": 145, "deletions": 60}, "files": [{"sha": "c60c6035eba7822bea103d652a301e953e3b91a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "patch": "@@ -1,3 +1,16 @@\n+Fri Jul  6 11:47:59 2001  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* basic-block.h (first_insn_after_basic_block_note): Declare.\n+\t* flow.c (first_insn_after_basic_block_note): Define.  Moved\n+\tfrom...\n+\t* ssa.c (first_insn_after_basic_block_note): Remove.\n+\t* ssa-dce.c (find_inherently_necessary): Consider BARRIERs\n+\tnecessary.\n+\t(ssa_eliminate_dead_code): Properly update the CFG and PHI\n+\tnodes when we find a dead conditional branch.  Insert BARRIERs\n+\tafter any blocks with no successors, but which do not have\n+\tany BARRIERs.\n+\n 2001-07-06  Zack Weinberg  <zackw@stanford.edu>\n \n \t* varray.c (varray_check_failed): Use internal_error."}, {"sha": "256492ebfb2199c46b49aa70e1c15b3e7efe5606", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "patch": "@@ -294,7 +294,7 @@ extern int flow_depth_first_order_compute\tPARAMS ((int *, int *));\n extern void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n extern void clear_edges\t\t\tPARAMS ((void));\n extern void mark_critical_edges\t\tPARAMS ((void));\n-\n+extern rtx first_insn_after_basic_block_note\tPARAMS ((basic_block));\n \n /* Structure to hold information for each natural loop.  */\n struct loop"}, {"sha": "e578b504c426754102b20d1b63065c3bca6462ab", "filename": "gcc/flow.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "patch": "@@ -1088,6 +1088,28 @@ create_basic_block (index, head, end, bb_note)\n   bb->aux = bb;\n }\n \f\n+/* Return the INSN immediately following the NOTE_INSN_BASIC_BLOCK\n+   note associated with the BLOCK.  */\n+\n+rtx\n+first_insn_after_basic_block_note (block)\n+     basic_block block;\n+{\n+  rtx insn;\n+\n+  /* Get the first instruction in the block.  */\n+  insn = block->head;\n+\n+  if (insn == NULL_RTX)\n+    return NULL_RTX;\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    insn = NEXT_INSN (insn);\n+  if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n+    abort ();\n+\n+  return NEXT_INSN (insn);\n+}\n+\n /* Records the basic block struct in BB_FOR_INSN, for every instruction\n    indexed by INSN_UID.  MAX is the size of the array.  */\n "}, {"sha": "142126baa2d2120f0ebe3bac4b89b6768e4a8fd1", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 109, "deletions": 35, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "patch": "@@ -370,17 +370,15 @@ find_inherently_necessary (x)\n     return !0;\n   else\n     switch (GET_CODE (x))\n-      {\n+      {  \n       case CALL_INSN:\n+      case BARRIER:\n \treturn !0;\n       case CODE_LABEL:\n       case NOTE:\n-      case BARRIER:\n \treturn 0;\n-\tbreak;\n       case JUMP_INSN:\n \treturn JUMP_TABLE_DATA_P (x) || computed_jump_p (x) != 0;\n-\tbreak;\n       case INSN:\n \t{\n \t  int inherently_necessary_set = 0;\n@@ -626,50 +624,126 @@ ssa_eliminate_dead_code ()\n   {\n     if (any_condjump_p (insn))\n       {\n-      /* Convert unnecessary conditional insn to an unconditional\n-\t jump to immediate postdominator block.  */\n-\trtx old_label = JUMP_LABEL (insn);\n-\tint pdom_block_number =\n-\t  find_pdom (pdom, BLOCK_FOR_INSN (insn))->index;\n-\n-\t/* Prevent the conditional jump's label from being deleted so\n-\t   we do not have to modify the basic block structure.  */\n-\t++LABEL_NUSES (old_label);\n-\n-\tif (pdom_block_number != EXIT_BLOCK\n-\t    && pdom_block_number != INVALID_BLOCK)\n+\tbasic_block bb = BLOCK_FOR_INSN (insn);\n+\tbasic_block pdom_bb = find_pdom (pdom, bb);\n+\trtx lbl;\n+\tedge e;\n+\n+\t/* Egad.  The immediate post dominator is the exit block.  We\n+\t   would like to optimize this conditional jump to jump directly\n+\t   to the exit block.  That can be difficult as we may not have\n+\t   a suitable CODE_LABEL that allows us to fall unmolested into\n+\t   the exit block.\n+\n+\t   So, we just delete the conditional branch by turning it into\n+\t   a deleted note.   That is safe, but just not as optimal as\n+\t   it could be.  */\n+\tif (pdom_bb == EXIT_BLOCK_PTR)\n+\t  {\n+\t    /* Since we're going to just delete the branch, we need\n+\t       look at all the edges and remove all those which are not\n+\t       a fallthru edge.  */\n+\t    e = bb->succ;\n+\t    while (e)\n+\t      {\n+\t\tedge temp = e;\n+\n+\t\te = e->succ_next;\n+\t\tif ((temp->flags & EDGE_FALLTHRU) == 0)\n+\t\t  {\n+\t\t    /* We've found a non-fallthru edge, find any PHI nodes\n+\t\t       at the target and clean them up.  */\n+\t\t    if (temp->dest != EXIT_BLOCK_PTR)\n+\t\t      {\n+\t\t        rtx insn\n+\t\t\t  = first_insn_after_basic_block_note (temp->dest);\n+\n+\t\t        while (PHI_NODE_P (insn))\n+\t\t\t  {\n+\t\t\t    remove_phi_alternative (PATTERN (insn), temp->src);\n+\t\t\t    insn = NEXT_INSN (insn);\n+\t\t\t  }\n+\t\t      }\n+\n+\t\t    remove_edge (temp);\n+\t\t  }\n+\t      }\n+\n+\t    /* Now \"delete\" the conditional jump.  */\n+\t    PUT_CODE (insn, NOTE);\n+\t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t    continue;\n+\t  }\n+\n+\t/* We've found a conditional branch that is unnecessary.\n+\n+\t   First, remove all outgoing edges from this block, updating\n+\t   PHI nodes as appropriate.  */\n+\te = bb->succ;\n+\twhile (e)\n \t  {\n-\t    rtx lbl = find_block_label (BASIC_BLOCK (pdom_block_number));\n-\t    rtx new_jump = emit_jump_insn_before (gen_jump (lbl), insn);\n+\t    edge temp = e;\n \n-\t    /* Let jump know that label is in use.  */\n-\t    JUMP_LABEL (new_jump) = lbl;\n-\t    ++LABEL_NUSES (lbl);\n+\t    e = e->succ_next;\n \n-\t    delete_insn_bb (insn);\n+\t    if (temp->flags & EDGE_ABNORMAL)\n+\t      continue;\n \n-\t    /* A conditional branch is unnecessary if and only if any\n-\t       block control-dependent on it is unnecessary.  Thus,\n-\t       any phi nodes in these unnecessary blocks are also\n-\t       removed and these nodes need not be updated.  */\n+\t    /* We found an edge that is not executable.  First simplify\n+\t       the PHI nodes in the target block.  */\n+\t    if (temp->dest != EXIT_BLOCK_PTR)\n+\t      {\n+\t\trtx insn = first_insn_after_basic_block_note (temp->dest);\n \n-\t    /* A barrier must follow any unconditional jump.  Barriers\n-\t       are not in basic blocks so this must occur after\n-\t       deleting the conditional jump.  */\n-\t    emit_barrier_after (new_jump);\n+\t\twhile (PHI_NODE_P (insn))\n+\t\t  {\n+\t\t    remove_phi_alternative (PATTERN (insn), temp->src);\n+\t\t    insn = NEXT_INSN (insn);\n+\t\t  }\n+\t      }\n+\n+\t    remove_edge (temp);\n \t  }\n-\telse\n-\t  /* The block drops off the end of the function and the\n-\t     ending conditional jump is not needed.  */\n-\t  delete_insn_bb (insn);\n+\n+\t/* Create an edge from this block to the post dominator.  \n+\t   What about the PHI nodes at the target?  */\n+\tmake_edge (NULL, bb, pdom_bb, 0);\n+\n+\t/* Third, transform this insn into an unconditional\n+\t   jump to the label for the immediate postdominator.  */\n+\tlbl = find_block_label (pdom_bb);\n+\tSET_SRC (PATTERN (insn)) = gen_rtx_LABEL_REF (VOIDmode, lbl);\n+\tINSN_CODE (insn) = -1;\n+\tJUMP_LABEL (insn) = lbl;\n+\tLABEL_NUSES (lbl)++;\n+\n+\t/* A barrier must follow any unconditional jump.  Barriers\n+\t   are not in basic blocks so this must occur after\n+\t   deleting the conditional jump.  */\n+\temit_barrier_after (insn);\n       }\n     else if (!JUMP_P (insn))\n       delete_insn_bb (insn);\n   });\n-\n+  \n   /* Remove fake edges from the CFG.  */\n   remove_fake_edges ();\n \n+  /* Find any blocks with no successors and ensure they are followed\n+     by a BARRIER.  delete_insn has the nasty habit of deleting barriers\n+     when deleting insns.  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+\n+      if (bb->succ == NULL)\n+\t{\n+\t  rtx next = NEXT_INSN (bb->end);\n+\n+\t  if (!next || GET_CODE (next) != BARRIER)\n+\t    emit_barrier_after (bb->end);\n+\t}\n+    }\n   /* Release allocated memory.  */\n   for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n     RESURRECT_INSN (insn);"}, {"sha": "cad10ca71a6e6a71338f025f924145c024bc0241", "filename": "gcc/ssa.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b62c888152fb7d3245bbea7464c50aef8fe1c8fa/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "patch": "@@ -162,8 +162,6 @@ struct rename_context;\n \n static inline rtx * phi_alternative\n   PARAMS ((rtx, int));\n-static rtx first_insn_after_basic_block_note\n-  PARAMS ((basic_block));\n static void compute_dominance_frontiers_1\n   PARAMS ((sbitmap *frontiers, int *idom, int bb, sbitmap done));\n static void find_evaluations_1\n@@ -633,28 +631,6 @@ compute_iterated_dominance_frontiers (idfs, frontiers, evals, nregs)\n     }\n }\n \n-/* Return the INSN immediately following the NOTE_INSN_BASIC_BLOCK\n-   note associated with the BLOCK.  */\n-\n-static rtx\n-first_insn_after_basic_block_note (block)\n-     basic_block block;\n-{\n-  rtx insn;\n-\n-  /* Get the first instruction in the block.  */\n-  insn = block->head;\n-\n-  if (insn == NULL_RTX)\n-    return NULL_RTX;\n-  if (GET_CODE (insn) == CODE_LABEL)\n-    insn = NEXT_INSN (insn);\n-  if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n-    abort ();\n-\n-  return NEXT_INSN (insn);\n-}\n-\n /* Insert the phi nodes.  */\n \n static void"}]}