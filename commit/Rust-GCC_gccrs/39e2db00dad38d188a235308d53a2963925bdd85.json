{"sha": "39e2db00dad38d188a235308d53a2963925bdd85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzllMmRiMDBkYWQzOGQxODhhMjM1MzA4ZDUzYTI5NjM5MjViZGQ4NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-11T13:01:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-11T13:01:53Z"}, "message": "lto-symtab.c (lto_cgraph_replace_node): Kill same body alias code.\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Kill same body alias code.\n\t(lto_symtab_resolve_can_prevail_p): Likewise.\n\t(lto_symtab_merge_cgraph_nodes): Update merging of aliases.\n\t* cgraph.c (same_body_aliases_done): New global var.\n\t(cgraph_same_body_alias_1): Rename to ...\n\t(cgraph_create_function_alias): ... this one; reorg to new\n\trepresentation.\n\t(cgraph_same_body_alias): Use cgraph_create_function_alias;\n\trecord references when asked to.\n\t(cgraph_add_thunk): Fix formating.\n\t(cgraph_get_node): Kill same body alias code.\n\t(cgraph_node_for_asm): Likewise.\n\t(cgraph_remove_same_body_alias): Remove.\n\t(cgraph_remove_node): Kill same body alias code.\n\t(cgraph_mark_address_taken_node): Mark also the aliased function\n\tas having address taken.\n\t(dump_cgraph_node): Dump same body aliases.\n\t(cgraph_for_node_thunks_and_aliases): Update for new alias\n\trepresentation.\n\t(cgraph_for_node_and_aliases): Likewise.\n\t* cgraph.h (same_body): Kll pointer.\n\t(same_body_alias): Update comment.\n\t(same_body_aliases_done): Declare.\n\t(cgraph_remove_same_body_alias): Remove declaration.\n\t(cgraph_create_function_alias): Declare.\n\t(cgraph_process_same_body_aliases): Declare.\n\t(cgraph_function_with_gimple_body_p): Check for alias.\n\t(cgraph_can_remove_if_no_direct_calls_p): Look for aliases.\n\t(cgraph_alias_aliased_node): New function.\n\t(cgraph_function_node): Update for new aliases.\n\t(cgraph_function_or_thunk_node): Likewise.\n\t* ipa-inline-transform.c (can_remove_node_now_p): Look for aliases.\n\t(inline_call): Remove dead aliases.\n\t* cgraphunit.c (cgraph_decide_is_function_needed): Disable assembler name\n\thack for same body aliases.\n\t(clone_of_p): Look through aliases.\n\t(verify_cgraph_node): Verify aliases.\n\t(cgraph_analyze_function): Analyze aliases; fixup C++ bugs.\n\t(cgraph_process_same_body_aliases): New function.\n\t(process_function_and_variable_attributes): Disable weakref warning on\n\talias.\n\t(cgraph_analyze_functions): Handle aliases.\n\t(cgraph_mark_functions_to_output): Handle aliases same way as thunks.\n\t(assemble_thunks): Rename to ...\n\t(assemble_thunks_and_aliases): ... this one; handle aliases, too.\n\t(cgraph_expand_function): Remove alias output code.\n\t(cgraph_output_in_order): Skip aliases.\n\t(cgraph_preserve_function_body_p): Aliases don't need preserving.\n\t* ipa-ref.c (ipa_ref_use_name): Add alias reference.\n\t(ipa_record_reference): Do not assert on alias references.\n\t(ipa_ref_has_aliases_p): New function.\n\t* ipa-ref.h (enum ipa_ref_use): Add IPA_REF_ALIAS.\n\t(ipa_ref_has_aliases_p): Declare.\n\t* lto-cgraph.c (lto_output_node): Handle aliases.\n\t(input_node): Likewise.\n\t* lto-streamer-out.c (lto_output): Skip aliases.\n\t(produce_symtab): Kill same_body_alias code.\n\t* ipa-utils.c (ipa_reverse_postorder): Add FIXME.\n\t(ipa_reverse_postorder): Use cgraph_only_called_directly_or_aliased_p.\n\t* ipa-inline.c (update_caller_keys): Walk aliases.\n\t(inline_small_functions): Fix thinko in previous patch.\n\t* ipa.c (cgraph_externally_visible_p): Do not walk aliases.\n\t(function_and_variable_visibility): Do not walk same body aliases.\n\t* tree-ssa-structalias.c (associate_varinfo_to_alias): New function.\n\t(ipa_pta_execute): Use it.\n\n\t* lto.c (add_cgraph_node_to_partition_1): Break out from ...\n\t(add_cgraph_node_to_partition) ... here; walk aliases.\n\t(lto_1_to_1_map): Remove same body alias code.\n\t(promote_fn): Likewise.\n\t(lto_promote_cross_file_statics): Update comment.\n\n\t* decl2.c (cp_write_global_declarations): Process aliases; look trhough\n\tsame body aliases.\n\nFrom-SVN: r174952", "tree": {"sha": "c6e4afcefa6681889da1ab377bb53466f789c2ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e4afcefa6681889da1ab377bb53466f789c2ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39e2db00dad38d188a235308d53a2963925bdd85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39e2db00dad38d188a235308d53a2963925bdd85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39e2db00dad38d188a235308d53a2963925bdd85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39e2db00dad38d188a235308d53a2963925bdd85/comments", "author": null, "committer": null, "parents": [{"sha": "c44ddf96154254b489122754237ecde53cdf7987", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c44ddf96154254b489122754237ecde53cdf7987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c44ddf96154254b489122754237ecde53cdf7987"}], "stats": {"total": 814, "additions": 472, "deletions": 342}, "files": [{"sha": "73c5fb46a871d994df39fad2b92b364be589ae0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -1,3 +1,71 @@\n+2011-06-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Kill same body alias code.\n+\t(lto_symtab_resolve_can_prevail_p): Likewise.\n+\t(lto_symtab_merge_cgraph_nodes): Update merging of aliases.\n+\t* cgraph.c (same_body_aliases_done): New global var.\n+\t(cgraph_same_body_alias_1): Rename to ...\n+\t(cgraph_create_function_alias): ... this one; reorg to new\n+\trepresentation.\n+\t(cgraph_same_body_alias): Use cgraph_create_function_alias;\n+\trecord references when asked to.\n+\t(cgraph_add_thunk): Fix formating.\n+\t(cgraph_get_node): Kill same body alias code.\n+\t(cgraph_node_for_asm): Likewise.\n+\t(cgraph_remove_same_body_alias): Remove.\n+\t(cgraph_remove_node): Kill same body alias code.\n+\t(cgraph_mark_address_taken_node): Mark also the aliased function\n+\tas having address taken.\n+\t(dump_cgraph_node): Dump same body aliases.\n+\t(cgraph_for_node_thunks_and_aliases): Update for new alias\n+\trepresentation.\n+\t(cgraph_for_node_and_aliases): Likewise.\n+\t* cgraph.h (same_body): Kll pointer.\n+\t(same_body_alias): Update comment.\n+\t(same_body_aliases_done): Declare.\n+\t(cgraph_remove_same_body_alias): Remove declaration.\n+\t(cgraph_create_function_alias): Declare.\n+\t(cgraph_process_same_body_aliases): Declare.\n+\t(cgraph_function_with_gimple_body_p): Check for alias.\n+\t(cgraph_can_remove_if_no_direct_calls_p): Look for aliases.\n+\t(cgraph_alias_aliased_node): New function.\n+\t(cgraph_function_node): Update for new aliases.\n+\t(cgraph_function_or_thunk_node): Likewise.\n+\t* ipa-inline-transform.c (can_remove_node_now_p): Look for aliases.\n+\t(inline_call): Remove dead aliases.\n+\t* cgraphunit.c (cgraph_decide_is_function_needed): Disable assembler name\n+\thack for same body aliases.\n+\t(clone_of_p): Look through aliases.\n+\t(verify_cgraph_node): Verify aliases.\n+\t(cgraph_analyze_function): Analyze aliases; fixup C++ bugs.\n+\t(cgraph_process_same_body_aliases): New function.\n+\t(process_function_and_variable_attributes): Disable weakref warning on\n+\talias.\n+\t(cgraph_analyze_functions): Handle aliases.\n+\t(cgraph_mark_functions_to_output): Handle aliases same way as thunks.\n+\t(assemble_thunks): Rename to ...\n+\t(assemble_thunks_and_aliases): ... this one; handle aliases, too.\n+\t(cgraph_expand_function): Remove alias output code.\n+\t(cgraph_output_in_order): Skip aliases.\n+\t(cgraph_preserve_function_body_p): Aliases don't need preserving.\n+\t* ipa-ref.c (ipa_ref_use_name): Add alias reference.\n+\t(ipa_record_reference): Do not assert on alias references.\n+\t(ipa_ref_has_aliases_p): New function.\n+\t* ipa-ref.h (enum ipa_ref_use): Add IPA_REF_ALIAS.\n+\t(ipa_ref_has_aliases_p): Declare.\n+\t* lto-cgraph.c (lto_output_node): Handle aliases.\n+\t(input_node): Likewise.\n+\t* lto-streamer-out.c (lto_output): Skip aliases.\n+\t(produce_symtab): Kill same_body_alias code.\n+\t* ipa-utils.c (ipa_reverse_postorder): Add FIXME.\n+\t(ipa_reverse_postorder): Use cgraph_only_called_directly_or_aliased_p.\n+\t* ipa-inline.c (update_caller_keys): Walk aliases.\n+\t(inline_small_functions): Fix thinko in previous patch.\n+\t* ipa.c (cgraph_externally_visible_p): Do not walk aliases.\n+\t(function_and_variable_visibility): Do not walk same body aliases.\n+\t* tree-ssa-structalias.c (associate_varinfo_to_alias): New function.\n+\t(ipa_pta_execute): Use it.\n+\n 2011-06-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (vec_dupv4sf): Correct mode of forced register."}, {"sha": "2805d46dfadc403fe9c843cf18668e528bc08932", "filename": "gcc/cgraph.c", "status": "modified", "additions": 68, "deletions": 112, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -208,6 +208,9 @@ static GTY(()) struct cgraph_node *free_nodes;\n    Do not GTY((delete)) this list so UIDs gets reliably recycled.  */\n static GTY(()) struct cgraph_edge *free_edges;\n \n+/* Did procss_same_body_aliases run?  */\n+bool same_body_aliases_done;\n+\n /* Macros to access the next item in the list of free cgraph nodes and\n    edges. */\n #define NEXT_FREE_NODE(NODE) (NODE)->next\n@@ -542,33 +545,23 @@ cgraph_get_create_node (tree decl)\n /* Mark ALIAS as an alias to DECL.  DECL_NODE is cgraph node representing\n    the function body is associated with (not neccesarily cgraph_node (DECL).  */\n \n-static struct cgraph_node *\n-cgraph_same_body_alias_1 (struct cgraph_node *decl_node, tree alias, tree decl)\n+struct cgraph_node *\n+cgraph_create_function_alias (tree alias, tree decl)\n {\n-  struct cgraph_node key, *alias_node, **slot;\n+  struct cgraph_node *alias_node;\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   gcc_assert (TREE_CODE (alias) == FUNCTION_DECL);\n-\n-  key.decl = alias;\n-\n-  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n-\n-  /* If the cgraph_node has been already created, fail.  */\n-  if (*slot)\n-    return NULL;\n-\n-  alias_node = cgraph_allocate_node ();\n-  alias_node->decl = alias;\n-  alias_node->same_body_alias = 1;\n-  alias_node->same_body = decl_node;\n-  alias_node->previous = NULL;\n-  if (decl_node->same_body)\n-    decl_node->same_body->previous = alias_node;\n-  alias_node->next = decl_node->same_body;\n+  alias_node = cgraph_get_create_node (alias);\n+  gcc_assert (!alias_node->local.finalized);\n   alias_node->thunk.alias = decl;\n-  decl_node->same_body = alias_node;\n-  *slot = alias_node;\n+  alias_node->local.finalized = true;\n+  alias_node->alias = 1;\n+\n+  if ((TREE_PUBLIC (alias) && !DECL_COMDAT (alias) && !DECL_EXTERNAL (alias))\n+      || (DECL_VIRTUAL_P (alias)\n+\t  && (DECL_COMDAT (alias) || DECL_EXTERNAL (alias))))\n+    cgraph_mark_reachable_node (alias_node);\n   return alias_node;\n }\n \n@@ -578,16 +571,24 @@ cgraph_same_body_alias_1 (struct cgraph_node *decl_node, tree alias, tree decl)\n    and cgraph_get_node (ALIAS) transparently returns cgraph_get_node (DECL).  */\n \n struct cgraph_node *\n-cgraph_same_body_alias (struct cgraph_node *decl_node, tree alias, tree decl)\n+cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree alias, tree decl)\n {\n+  struct cgraph_node *n;\n #ifndef ASM_OUTPUT_DEF\n   /* If aliases aren't supported by the assembler, fail.  */\n   return NULL;\n #endif\n+  /* Langhooks can create same body aliases of symbols not defined.\n+     Those are useless. Drop them on the floor.  */\n+  if (cgraph_global_info_ready)\n+    return NULL;\n \n-  /*gcc_assert (!assembler_name_hash);*/\n-\n-  return cgraph_same_body_alias_1 (decl_node, alias, decl);\n+  n = cgraph_create_function_alias (alias, decl);\n+  n->same_body_alias = true;\n+  if (same_body_aliases_done)\n+    ipa_record_reference (n, NULL, cgraph_get_node (decl), NULL, IPA_REF_ALIAS,\n+\t\t\t  NULL);\n+  return n;\n }\n \n /* Add thunk alias into callgraph.  The alias declaration is ALIAS and it\n@@ -633,6 +634,7 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n       || (DECL_VIRTUAL_P (decl)\n \t  && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n     cgraph_mark_reachable_node (node);\n+\n   return node;\n }\n \n@@ -678,11 +680,7 @@ cgraph_get_node (const_tree decl)\n \t\t\t\t\t\t NO_INSERT);\n \n   if (slot && *slot)\n-    {\n-      node = *slot;\n-      if (node->same_body_alias)\n-\tnode = node->same_body;\n-    }\n+    node = *slot;\n   return node;\n }\n \n@@ -745,21 +743,6 @@ cgraph_node_for_asm (tree asmname)\n \t       so lets hope for the best.  */\n \t    if (!*slot)\n \t      *slot = node;\n-\t    if (node->same_body)\n-\t      {\n-\t\tstruct cgraph_node *alias;\n-\n-\t\tfor (alias = node->same_body; alias; alias = alias->next)\n-\t\t  {\n-\t\t    hashval_t hash;\n-\t\t    name = DECL_ASSEMBLER_NAME (alias->decl);\n-\t\t    hash = decl_assembler_name_hash (name);\n-\t\t    slot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t\t\t     hash,  INSERT);\n-\t\t    if (!*slot)\n-\t\t      *slot = alias;\n-\t\t  }\n-\t      }\n \t  }\n     }\n \n@@ -770,8 +753,6 @@ cgraph_node_for_asm (tree asmname)\n   if (slot)\n     {\n       node = (struct cgraph_node *) *slot;\n-      if (node->same_body_alias)\n-\tnode = node->same_body;\n       return node;\n     }\n   return NULL;\n@@ -1432,44 +1413,6 @@ cgraph_release_function_body (struct cgraph_node *node)\n     DECL_INITIAL (node->decl) = error_mark_node;\n }\n \n-/* Remove same body alias node.  */\n-\n-void\n-cgraph_remove_same_body_alias (struct cgraph_node *node)\n-{\n-  void **slot;\n-  int uid = node->uid;\n-\n-  gcc_assert (node->same_body_alias);\n-  if (node->previous)\n-    node->previous->next = node->next;\n-  else\n-    node->same_body->same_body = node->next;\n-  if (node->next)\n-    node->next->previous = node->previous;\n-  node->next = NULL;\n-  node->previous = NULL;\n-  slot = htab_find_slot (cgraph_hash, node, NO_INSERT);\n-  if (*slot == node)\n-    htab_clear_slot (cgraph_hash, slot);\n-  if (assembler_name_hash)\n-    {\n-      tree name = DECL_ASSEMBLER_NAME (node->decl);\n-      slot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t       decl_assembler_name_hash (name),\n-\t\t\t\t       NO_INSERT);\n-      if (slot && *slot == node)\n-\thtab_clear_slot (assembler_name_hash, slot);\n-    }\n-\n-  /* Clear out the node to NULL all pointers and add the node to the free\n-     list.  */\n-  memset (node, 0, sizeof(*node));\n-  node->uid = uid;\n-  NEXT_FREE_NODE (node) = free_nodes;\n-  free_nodes = node;\n-}\n-\n /* Remove the node from cgraph.  */\n \n void\n@@ -1631,9 +1574,6 @@ cgraph_remove_node (struct cgraph_node *node)\n \t}\n     }\n \n-  while (node->same_body)\n-    cgraph_remove_same_body_alias (node->same_body);\n-\n   if (node->same_comdat_group)\n     {\n       struct cgraph_node *prev;\n@@ -1747,6 +1687,14 @@ cgraph_mark_address_taken_node (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n   cgraph_mark_reachable_node (node);\n+  /* FIXME: address_taken flag is used both as a shortcut for testing whether\n+     IPA_REF_ADDR reference exists (and thus it should be set on node\n+     representing alias we take address of) and as a test whether address\n+     of the object was taken (and thus it should be set on node alias is\n+     referring to).  We should remove the first use and the remove the\n+     following set.  */\n+  node->address_taken = 1;\n+  node = cgraph_function_or_thunk_node (node, NULL);\n   node->address_taken = 1;\n }\n \n@@ -1902,6 +1850,15 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t       (int)node->thunk.virtual_value,\n \t       (int)node->thunk.virtual_offset_p);\n     }\n+  if (node->alias && node->thunk.alias)\n+    {\n+      fprintf (f, \"  alias of %s\",\n+\t       lang_hooks.decl_printable_name (node->thunk.alias, 2));\n+      if (DECL_ASSEMBLER_NAME_SET_P (node->thunk.alias))\n+        fprintf (f, \" (asm: %s)\",\n+\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->thunk.alias)));\n+      fprintf (f, \"\\n\");\n+    }\n   \n   fprintf (f, \"  called by: \");\n \n@@ -1952,19 +1909,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (indirect_calls_count)\n     fprintf (f, \"  has %i outgoing edges for indirect calls.\\n\",\n \t     indirect_calls_count);\n-\n-  if (node->same_body)\n-    {\n-      struct cgraph_node *n;\n-      fprintf (f, \"  aliases:\");\n-      for (n = node->same_body; n; n = n->next)\n-        {\n-          fprintf (f, \" %s/%i\", cgraph_node_name (n), n->uid);\n-\t  if (DECL_ASSEMBLER_NAME_SET_P (n->decl))\n-\t    fprintf (f, \" (asm: %s)\", IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (n->decl)));\n-\t}\n-      fprintf (f, \"\\n\");\n-    }\n }\n \n \n@@ -2614,18 +2558,24 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n \t\t\t\t    bool include_overwritable)\n {\n   struct cgraph_edge *e;\n-  struct cgraph_node *alias;\n+  int i;\n+  struct ipa_ref *ref;\n \n   if (callback (node, data))\n     return true;\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    if (callback (alias, data))\n-      return true;\n   for (e = node->callers; e; e = e->next_caller)\n     if (e->caller->thunk.thunk_p\n \t&& (include_overwritable\n-\t    || cgraph_function_body_availability (e->caller) > AVAIL_OVERWRITABLE))\n+\t    || cgraph_function_body_availability (e->caller)))\n       cgraph_for_node_thunks_and_aliases (e->caller, callback, data, include_overwritable);\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      {\n+\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+\tif (include_overwritable\n+\t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n+          cgraph_for_node_thunks_and_aliases (alias, callback, data, include_overwritable);\n+      }\n   return false;\n }\n \n@@ -2637,15 +2587,21 @@ bool\n cgraph_for_node_and_aliases (struct cgraph_node *node,\n \t\t\t     bool (*callback) (struct cgraph_node *, void *),\n \t\t\t     void *data,\n-\t\t\t     bool include_overwritable ATTRIBUTE_UNUSED)\n+\t\t\t     bool include_overwritable)\n {\n-  struct cgraph_node *alias;\n+  int i;\n+  struct ipa_ref *ref;\n \n   if (callback (node, data))\n     return true;\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    if (callback (alias, data))\n-      return true;\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      {\n+\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+\tif (include_overwritable\n+\t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n+          cgraph_for_node_and_aliases (alias, callback, data, include_overwritable);\n+      }\n   return false;\n }\n "}, {"sha": "09d99b1c1f7426f4018aa40a4645fb352d36de01", "filename": "gcc/cgraph.h", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -165,9 +165,6 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   struct cgraph_node *prev_sibling_clone;\n   struct cgraph_node *clones;\n   struct cgraph_node *clone_of;\n-  /* For normal nodes pointer to the list of alias and thunk nodes,\n-     in alias/thunk nodes pointer to the normal node.  */\n-  struct cgraph_node *same_body;\n   /* Circular list of nodes in the same comdat group if non-NULL.  */\n   struct cgraph_node *same_comdat_group;\n   /* For functions with many calls sites it holds map from call expression\n@@ -236,8 +233,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   unsigned process : 1;\n   /* Set for aliases once they got through assemble_alias.  */\n   unsigned alias : 1;\n-  /* Set for alias and thunk nodes, same_body points to the node they are alias\n-     of and they are linked through the next/previous pointers.  */\n+  /* Set for aliases created as C++ same body aliases.  */\n   unsigned same_body_alias : 1;\n   /* How commonly executed the node is.  Initialized during branch\n      probabilities pass.  */\n@@ -463,6 +459,7 @@ extern GTY(()) struct cgraph_node *cgraph_new_nodes;\n \n extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n extern GTY(()) int cgraph_order;\n+extern bool same_body_aliases_done;\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n@@ -488,7 +485,6 @@ struct cgraph_node * cgraph_get_create_node (tree);\n struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);\n struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, tree, tree);\n-void cgraph_remove_same_body_alias (struct cgraph_node *);\n struct cgraph_node *cgraph_node_for_asm (tree);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n@@ -508,6 +504,7 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n \t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *,\n \t\t\t\t\tbool);\n+struct cgraph_node *cgraph_create_function_alias (tree, tree);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *,\n@@ -577,6 +574,7 @@ void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*, bool, bi\n \t\t\t       bitmap, basic_block);\n void record_references_in_initializer (tree, bool);\n bool cgraph_process_new_functions (void);\n+void cgraph_process_same_body_aliases (void);\n \n bool cgraph_decide_is_function_needed (struct cgraph_node *, tree);\n \n@@ -746,7 +744,7 @@ cgraph_next_defined_function (struct cgraph_node *node)\n static inline bool\n cgraph_function_with_gimple_body_p (struct cgraph_node *node)\n {\n-  return node->analyzed && !node->thunk.thunk_p;\n+  return node->analyzed && !node->thunk.thunk_p && !node->alias;\n }\n \n /* Return first function with body defined.  */\n@@ -934,7 +932,8 @@ cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n   if (DECL_EXTERNAL (node->decl))\n     return true;\n   return (!node->address_taken\n-\t  && cgraph_can_remove_if_no_direct_calls_and_refs_p (node));\n+\t  && cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n+\t  && !ipa_ref_has_aliases_p (&node->ref_list));\n }\n \n /* Return true when function NODE can be removed from callgraph\n@@ -968,6 +967,20 @@ htab_t constant_pool_htab (void);\n /* FIXME: inappropriate dependency of cgraph on IPA.  */\n #include \"ipa-ref-inline.h\"\n \n+/* Return node that alias N is aliasing.  */\n+\n+static inline struct cgraph_node *\n+cgraph_alias_aliased_node (struct cgraph_node *n)\n+{\n+  struct ipa_ref *ref;\n+\n+  ipa_ref_list_reference_iterate (&n->ref_list, 0, ref);\n+  gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n+  if (ref->refered_type == IPA_REF_CGRAPH)\n+    return ipa_ref_node (ref);\n+  return NULL;\n+}\n+\n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n    Walk through thunk, too.\n    When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n@@ -979,18 +992,22 @@ cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n     *availability = cgraph_function_body_availability (node);\n   while (node)\n     {\n-      if (node->thunk.thunk_p)\n+      if (node->alias && node->analyzed)\n+\tnode = cgraph_alias_aliased_node (node);\n+      else if (node->thunk.thunk_p)\n \tnode = node->callees->callee;\n       else\n \treturn node;\n-      if (availability)\n+      if (node && availability)\n \t{\n \t  enum availability a;\n \t  a = cgraph_function_body_availability (node);\n \t  if (a < *availability)\n \t    *availability = a;\n \t}\n     }\n+  if (*availability)\n+    *availability = AVAIL_NOT_AVAILABLE;\n   return NULL;\n }\n \n@@ -1003,7 +1020,22 @@ cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *avai\n {\n   if (availability)\n     *availability = cgraph_function_body_availability (node);\n-  return node;\n+  while (node)\n+    {\n+      if (node->alias && node->analyzed)\n+\tnode = cgraph_alias_aliased_node (node);\n+      else\n+\treturn node;\n+      if (node && availability)\n+\t{\n+\t  enum availability a;\n+\t  a = cgraph_function_body_availability (node);\n+\t  if (a < *availability)\n+\t    *availability = a;\n+\t}\n+    }\n+  if (*availability)\n+    *availability = AVAIL_NOT_AVAILABLE;\n   return NULL;\n }\n "}, {"sha": "b01f22b2b23ecab17bd67f7f106ed8c235b441b0", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 141, "deletions": 45, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -167,6 +167,7 @@ cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n      the name later after finalizing the function and the fact is noticed\n      in assemble_name then.  This is arguably a bug.  */\n   if (DECL_ASSEMBLER_NAME_SET_P (decl)\n+      && (!node->thunk.thunk_p && !node->same_body_alias)\n       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n     return true;\n \n@@ -391,6 +392,8 @@ cgraph_mark_if_needed (tree decl)\n static bool\n clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n {\n+  node = cgraph_function_or_thunk_node (node, NULL);\n+  node2 = cgraph_function_or_thunk_node (node2, NULL);\n   while (node != node2 && node2)\n     node2 = node2->clone_of;\n   return node2 != NULL;\n@@ -619,6 +622,36 @@ verify_cgraph_node (struct cgraph_node *node)\n       while (n != node);\n     }\n \n+  if (node->analyzed && node->alias)\n+    {\n+      bool ref_found = false;\n+      int i;\n+      struct ipa_ref *ref;\n+\n+      if (node->callees)\n+\t{\n+\t  error (\"Alias has call edges\");\n+          error_found = true;\n+\t}\n+      for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\tif (ref->use != IPA_REF_ALIAS)\n+\t  {\n+\t    error (\"Alias has non-alias refernece\");\n+\t    error_found = true;\n+\t  }\n+\telse if (ref_found)\n+\t  {\n+\t    error (\"Alias has more than one alias reference\");\n+\t    error_found = true;\n+\t  }\n+\telse\n+\t  ref_found = true;\n+\tif (!ref_found)\n+\t  {\n+\t    error (\"Analyzed alias has no reference\");\n+\t    error_found = true;\n+\t  }\n+    }\n   if (node->analyzed && node->thunk.thunk_p)\n     {\n       if (!node->callees)\n@@ -669,19 +702,17 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t  }\n \t\t\tif (!e->indirect_unknown_callee)\n \t\t\t  {\n-\t\t\t    if (e->callee->same_body_alias)\n-\t\t\t      {\n-\t\t\t\terror (\"edge points to same body alias:\");\n-\t\t\t\tdebug_tree (e->callee->decl);\n-\t\t\t\terror_found = true;\n-\t\t\t      }\n-\t\t\t    else if (!e->callee->global.inlined_to\n-\t\t\t\t     && decl\n-\t\t\t\t     && cgraph_get_node (decl)\n-\t\t\t\t     && (e->callee->former_clone_of\n-\t\t\t\t\t != cgraph_get_node (decl)->decl)\n-\t\t\t\t     && !clone_of_p (cgraph_get_node (decl),\n-\t\t\t\t\t\t     e->callee))\n+\t\t\t    if (!e->callee->global.inlined_to\n+\t\t\t        && decl\n+\t\t\t        && cgraph_get_node (decl)\n+\t\t\t        && (e->callee->former_clone_of\n+\t\t\t\t    != cgraph_get_node (decl)->decl)\n+\t\t\t\t/* IPA-CP sometimes redirect edge to clone and then back to the former\n+\t\t\t\t   function.  This ping-pong has to go, eventaully.  */\n+\t\t\t\t&& (cgraph_function_or_thunk_node (cgraph_get_node (decl), NULL)\n+\t\t\t\t    != cgraph_function_or_thunk_node (e->callee, NULL))\n+\t\t\t\t&& !clone_of_p (cgraph_get_node (decl),\n+\t\t\t\t\t        e->callee))\n \t\t\t      {\n \t\t\t\terror (\"edge points to wrong declaration:\");\n \t\t\t\tdebug_tree (e->callee->decl);\n@@ -781,7 +812,53 @@ cgraph_analyze_function (struct cgraph_node *node)\n   tree save = current_function_decl;\n   tree decl = node->decl;\n \n-  if (node->thunk.thunk_p)\n+  if (node->alias && node->thunk.alias)\n+    {\n+      struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n+      if (!VEC_length (ipa_ref_t, node->ref_list.references))\n+        ipa_record_reference (node, NULL, tgt, NULL, IPA_REF_ALIAS, NULL);\n+      if (node->same_body_alias)\n+\t{ \n+\t  DECL_VIRTUAL_P (node->decl) = DECL_VIRTUAL_P (node->thunk.alias);\n+\t  DECL_DECLARED_INLINE_P (node->decl)\n+\t     = DECL_DECLARED_INLINE_P (node->thunk.alias);\n+\t  DECL_DISREGARD_INLINE_LIMITS (node->decl)\n+\t     = DECL_DISREGARD_INLINE_LIMITS (node->thunk.alias);\n+\t}\n+\n+      /* Fixup visibility nonsences C++ frontend produce on same body aliases.  */\n+      if (TREE_PUBLIC (node->decl) && node->same_body_alias)\n+\t{\n+          DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (node->thunk.alias);\n+\t  if (DECL_COMDAT (node->thunk.alias))\n+\t    {\n+\t      DECL_COMDAT (node->decl) = 1;\n+\t      DECL_COMDAT_GROUP (node->decl) = DECL_COMDAT_GROUP (node->thunk.alias);\n+\t      if (DECL_ONE_ONLY (node->thunk.alias) && !node->same_comdat_group)\n+\t\t{\n+\t\t  struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n+\t\t  node->same_comdat_group = tgt;\n+\t\t  if (!tgt->same_comdat_group)\n+\t\t    tgt->same_comdat_group = node;\n+\t\t  else\n+\t\t    {\n+\t\t      struct cgraph_node *n;\n+\t\t      for (n = tgt->same_comdat_group;\n+\t\t\t   n->same_comdat_group != tgt;\n+\t\t\t   n = n->same_comdat_group)\n+\t\t\t;\n+\t\t      n->same_comdat_group = node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      cgraph_mark_reachable_node (cgraph_alias_aliased_node (node));\n+      if (node->address_taken)\n+\tcgraph_mark_address_taken_node (cgraph_alias_aliased_node (node));\n+      if (cgraph_decide_is_function_needed (node, node->decl))\n+\tcgraph_mark_needed_node (node);\n+    }\n+  else if (node->thunk.thunk_p)\n     {\n       cgraph_create_edge (node, cgraph_get_node (node->thunk.alias),\n \t\t\t  NULL, 0, CGRAPH_FREQ_BASE);\n@@ -809,6 +886,26 @@ cgraph_analyze_function (struct cgraph_node *node)\n   current_function_decl = save;\n }\n \n+/* C++ frontend produce same body aliases all over the place, even before PCH\n+   gets streamed out. It relies on us linking the aliases with their function\n+   in order to do the fixups, but ipa-ref is not PCH safe.  Consequentely we\n+   first produce aliases without links, but once C++ FE is sure he won't sream\n+   PCH we build the links via this function.  */\n+\n+void\n+cgraph_process_same_body_aliases (void)\n+{\n+  struct cgraph_node *node;\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->same_body_alias\n+\t&& !VEC_length (ipa_ref_t, node->ref_list.references))\n+      {\n+        struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n+        ipa_record_reference (node, NULL, tgt, NULL, IPA_REF_ALIAS, NULL);\n+      }\n+  same_body_aliases_done = true;\n+}\n+\n /* Process attributes common for vars and functions.  */\n \n static void\n@@ -880,7 +977,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t     cgraph_mark_needed_node (node);\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n-\t  && node->local.finalized)\n+\t  && (node->local.finalized && !node->alias))\n \t{\n \t  warning_at (DECL_SOURCE_LOCATION (node->decl), OPT_Wattributes,\n \t\t      \"%<weakref%> attribute ignored\"\n@@ -979,6 +1076,7 @@ cgraph_analyze_functions (void)\n \t weak alias attribute to kill its body. See\n \t gcc.c-torture/compile/20011119-1.c  */\n       if (!DECL_STRUCT_FUNCTION (decl)\n+\t  && (!node->alias || !node->thunk.alias)\n \t  && !node->thunk.thunk_p)\n \t{\n \t  cgraph_reset_node (node);\n@@ -1046,11 +1144,13 @@ cgraph_analyze_functions (void)\n       next = node->next;\n \n       if (node->local.finalized && !gimple_has_body_p (decl)\n+\t  && (!node->alias || !node->thunk.alias)\n \t  && !node->thunk.thunk_p)\n \tcgraph_reset_node (node);\n \n       if (!node->reachable\n-\t  && (gimple_has_body_p (decl) || node->thunk.thunk_p))\n+\t  && (gimple_has_body_p (decl) || node->thunk.thunk_p\n+\t      || (node->alias && node->thunk.alias)))\n \t{\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n@@ -1060,6 +1160,7 @@ cgraph_analyze_functions (void)\n       else\n \tnode->next_needed = NULL;\n       gcc_assert (!node->local.finalized || node->thunk.thunk_p\n+\t\t  || node->alias\n \t\t  || gimple_has_body_p (decl));\n       gcc_assert (node->analyzed == node->local.finalized);\n     }\n@@ -1157,9 +1258,11 @@ cgraph_mark_functions_to_output (void)\n \t outside the current compilation unit.  */\n       if (node->analyzed\n \t  && !node->thunk.thunk_p\n+\t  && !node->alias\n \t  && !node->global.inlined_to\n \t  && (!cgraph_only_called_directly_p (node)\n-\t      || (e && node->reachable))\n+\t      || ((e || ipa_ref_has_aliases_p (&node->ref_list))\n+\t\t  && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n \t{\n@@ -1170,7 +1273,7 @@ cgraph_mark_functions_to_output (void)\n \t      for (next = node->same_comdat_group;\n \t\t   next != node;\n \t\t   next = next->same_comdat_group)\n-\t\tif (!next->thunk.thunk_p)\n+\t\tif (!next->thunk.thunk_p && !next->alias)\n \t\t  next->process = 1;\n \t    }\n \t}\n@@ -1190,6 +1293,7 @@ cgraph_mark_functions_to_output (void)\n \t\t are inside partition, we can end up not removing the body since we no longer\n \t\t have analyzed node pointing to it.  */\n \t      && !node->in_other_partition\n+\t      && !node->alias\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);\n@@ -1219,7 +1323,7 @@ cgraph_mark_functions_to_output (void)\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);\n-\t      internal_error (\"failed to reclaim unneeded function\");\n+\t      internal_error (\"failed to reclaim unneeded functionin same comdat group\");\n \t    }\n \t}\n #endif\n@@ -1569,23 +1673,35 @@ assemble_thunk (struct cgraph_node *node)\n }\n \n \n-/* Assemble thunks asociated to NODE.  */\n+\n+/* Assemble thunks and aliases asociated to NODE.  */\n \n static void\n-assemble_thunks (struct cgraph_node *node)\n+assemble_thunks_and_aliases (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n+  int i;\n+  struct ipa_ref *ref;\n+\n   for (e = node->callers; e;)\n     if (e->caller->thunk.thunk_p)\n       {\n \tstruct cgraph_node *thunk = e->caller;\n \n \te = e->next_caller;\n-\tassemble_thunks (thunk);\n+\tassemble_thunks_and_aliases (thunk);\n         assemble_thunk (thunk);\n       }\n     else\n       e = e->next_caller;\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      {\n+\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+\tassemble_alias (alias->decl,\n+\t\t\tDECL_ASSEMBLER_NAME (alias->thunk.alias));\n+\tassemble_thunks_and_aliases (alias);\n+      }\n }\n \n /* Expand function specified by NODE.  */\n@@ -1600,27 +1716,7 @@ cgraph_expand_function (struct cgraph_node *node)\n \n   announce_function (decl);\n   node->process = 0;\n-  if (node->same_body)\n-    {\n-      struct cgraph_node *alias, *next;\n-      bool saved_alias = node->alias;\n-      for (alias = node->same_body;\n-      \t   alias && alias->next; alias = alias->next)\n-        ;\n-      /* Walk aliases in the order they were created; it is possible that\n-         thunks refers to the aliases made earlier.  */\n-      for (; alias; alias = next)\n-        {\n-\t  next = alias->previous;\n-\t  if (!alias->thunk.thunk_p)\n-\t    assemble_alias (alias->decl,\n-\t\t\t    DECL_ASSEMBLER_NAME (alias->thunk.alias));\n-\t}\n-      node->alias = saved_alias;\n-      cgraph_process_new_functions ();\n-    }\n-\n-  assemble_thunks (node);\n+  assemble_thunks_and_aliases (node);\n   gcc_assert (node->lowered);\n \n   /* Generate RTL for the body of DECL.  */\n@@ -1736,7 +1832,7 @@ cgraph_output_in_order (void)\n \n   for (pf = cgraph_nodes; pf; pf = pf->next)\n     {\n-      if (pf->process && !pf->thunk.thunk_p)\n+      if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n \t{\n \t  i = pf->order;\n \t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n@@ -1810,7 +1906,7 @@ bool\n cgraph_preserve_function_body_p (struct cgraph_node *node)\n {\n   gcc_assert (cgraph_global_info_ready);\n-  gcc_assert (!node->same_body_alias);\n+  gcc_assert (!node->alias && !node->thunk.thunk_p);\n \n   /* Look if there is any clone around.  */\n   if (node->clones)"}, {"sha": "d214ea2f6de4d80ffac899c4975c5b5f0fc5edc4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -1,3 +1,8 @@\n+2011-06-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (cp_write_global_declarations): Process aliases; look trhough\n+\tsame body aliases.\n+\n 2011-06-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/41769"}, {"sha": "d2f075dab0a2b032e343869232f6470888d3ad3a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -3672,6 +3672,8 @@ cp_write_global_declarations (void)\n   if (pch_file)\n     c_common_write_pch ();\n \n+  cgraph_process_same_body_aliases ();\n+\n   /* Handle -fdump-ada-spec[-slim] */\n   if (dump_enabled_p (TDI_ada))\n     {\n@@ -3869,6 +3871,8 @@ cp_write_global_declarations (void)\n \t      struct cgraph_node *node, *next;\n \n \t      node = cgraph_get_node (decl);\n+\t      if (node->same_body_alias)\n+\t\tnode = cgraph_alias_aliased_node (node);\n \n \t      cgraph_for_node_and_aliases (node, clear_decl_external,\n \t\t\t\t\t   NULL, true);"}, {"sha": "c1824b4626ba3377a010fb0d7d7db011176e4171", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -3363,9 +3363,8 @@ cp_fix_function_decl_p (tree decl)\n \n       /* Don't fix same_body aliases.  Although they don't have their own\n \t CFG, they share it with what they alias to.  */\n-      if (!node\n-\t  || node->decl == decl\n-\t  || !node->same_body)\n+      if (!node || !node->alias\n+\t  || !VEC_length (ipa_ref_t, node->ref_list.references))\n \treturn true;\n     }\n "}, {"sha": "b62e50b93f0c7f9da926307229d035fa4e91fbf7", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -88,6 +88,7 @@ can_remove_node_now_p (struct cgraph_node *node)\n      can remove its offline copy, but we would need to keep unanalyzed node in\n      the callgraph so references can point to it.  */\n   return (!node->address_taken\n+\t  && !ipa_ref_has_aliases_p (&node->ref_list)\n \t  && cgraph_can_remove_if_no_direct_calls_p (node)\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed.\n@@ -192,7 +193,22 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   /* If aliases are involved, redirect edge to the actual destination and\n      possibly remove the aliases.  */\n   if (e->callee != callee)\n-    cgraph_redirect_edge_callee (e, callee);\n+    {\n+      struct cgraph_node *alias = e->callee, *next_alias;\n+      cgraph_redirect_edge_callee (e, callee);\n+      while (alias && alias != callee)\n+\t{\n+\t  if (!alias->callers\n+\t      && can_remove_node_now_p (alias))\n+\t    {\n+\t      next_alias = cgraph_alias_aliased_node (alias);\n+\t      cgraph_remove_node (alias);\n+\t      alias = next_alias;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+    }\n \n   clone_inlined_nodes (e, true, update_original, overall_size);\n "}, {"sha": "4283770a1c3e87b1ff10f74052562d998ebec975", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -965,6 +965,8 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t    struct cgraph_edge *check_inlinablity_for)\n {\n   struct cgraph_edge *edge;\n+  int i;\n+  struct ipa_ref *ref;\n \n   if (!inline_summary (node)->inlinable\n       || cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE\n@@ -973,6 +975,13 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n \n+  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      {\n+\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+        update_caller_keys (heap, alias, updated_nodes, check_inlinablity_for);\n+      }\n+\n   for (edge = node->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       {\n@@ -1451,7 +1460,7 @@ inline_small_functions (void)\n \t  where = edge->caller;\n \t  while (where->global.inlined_to)\n \t    {\n-\t      if (where->decl == edge->callee->decl)\n+\t      if (where->decl == callee->decl)\n \t\touter_node = where, depth++;\n \t      where = where->callers->caller;\n \t    }"}, {"sha": "f5fd03f67fba09abb8035a7fa91ac96d600815a9", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cgraph.h\"\n \n-static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\"};\n+static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\"};\n \n /* Return ipa reference from REFERING_NODE or REFERING_VARPOOL_NODE\n    to REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n@@ -46,6 +46,7 @@ ipa_record_reference (struct cgraph_node *refering_node,\n   gcc_assert ((!refering_node) ^ (!refering_varpool_node));\n   gcc_assert ((!refered_node) ^ (!refered_varpool_node));\n   gcc_assert (!stmt || refering_node);\n+  gcc_assert (use_type != IPA_REF_ALIAS || !stmt);\n \n   list = (refering_node ? &refering_node->ref_list\n \t  : &refering_varpool_node->ref_list);\n@@ -73,7 +74,7 @@ ipa_record_reference (struct cgraph_node *refering_node,\n     {\n       ref->refered.cgraph_node = refered_node;\n       ref->refered_type = IPA_REF_CGRAPH;\n-      gcc_assert (use_type == IPA_REF_ADDR);\n+      gcc_assert (use_type == IPA_REF_ADDR || use_type == IPA_REF_ALIAS);\n     }\n   else\n     {\n@@ -241,3 +242,15 @@ ipa_ref_cannot_lead_to_return (struct ipa_ref *ref)\n {\n   return cgraph_node_cannot_return (ipa_ref_refering_node (ref));\n }\n+\n+/* Return true if list contains an alias.  */\n+bool\n+ipa_ref_has_aliases_p (struct ipa_ref_list *ref_list)\n+{\n+  struct ipa_ref *ref;\n+  int i;\n+  for (i = 0; ipa_ref_list_refering_iterate (ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      return true;\n+  return false;\n+}"}, {"sha": "2fdb6ba4158f1ff7ae33de01fb5a86c537f40bb0", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -27,7 +27,8 @@ enum GTY(()) ipa_ref_use\n {\n   IPA_REF_LOAD,\n   IPA_REF_STORE,\n-  IPA_REF_ADDR\n+  IPA_REF_ADDR,\n+  IPA_REF_ALIAS\n };\n \n /* Type of refering or refered type.  */\n@@ -89,4 +90,4 @@ void ipa_dump_refering (FILE *, struct ipa_ref_list *);\n void ipa_clone_references (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n void ipa_clone_refering (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n bool ipa_ref_cannot_lead_to_return (struct ipa_ref *);\n-\n+bool ipa_ref_has_aliases_p (struct ipa_ref_list *);"}, {"sha": "9abc82dbbd9b88dc53040e3d743aeccbb3d3bda7", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -234,7 +234,8 @@ ipa_free_postorder_info (void)\n }\n \n /* Fill array order with all nodes with output flag set in the reverse\n-   topological order.  Return the number of elements in the array.  */\n+   topological order.  Return the number of elements in the array.\n+   FIXME: While walking, consider aliases, too.  */\n \n int\n ipa_reverse_postorder (struct cgraph_node **order)\n@@ -260,7 +261,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t  && (pass\n \t      || (!node->address_taken\n \t\t  && !node->global.inlined_to\n-\t\t  && !cgraph_only_called_directly_p (node))))\n+\t\t  && !cgraph_only_called_directly_or_aliased_p (node))))\n \t{\n \t  node2 = node;\n \t  if (!node->callers)"}, {"sha": "a80f9ba2ba47ba06316b2a4d3661f496268e4ba6", "filename": "gcc/ipa.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -581,9 +581,9 @@ cgraph_comdat_can_be_unshared_p (struct cgraph_node *node)\n /* Return true when function NODE should be considered externally visible.  */\n \n static bool\n-cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool aliased)\n+cgraph_externally_visible_p (struct cgraph_node *node,\n+\t\t\t     bool whole_program, bool aliased)\n {\n-  struct cgraph_node *alias;\n   if (!node->local.finalized)\n     return false;\n   if (!DECL_COMDAT (node->decl)\n@@ -630,18 +630,6 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n       && cgraph_comdat_can_be_unshared_p (node))\n     return false;\n \n-  /* See if we have linker information about symbol not being used or\n-     if we need to make guess based on the declaration.\n-\n-     Even if the linker clams the symbol is unused, never bring internal\n-     symbols that are declared by user as used or externally visible.\n-     This is needed for i.e. references from asm statements.   */\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    if (alias->resolution != LDPR_PREVAILING_DEF_IRONLY)\n-      break;\n-  if (!alias && node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n-    return false;\n-\n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n       && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n@@ -881,12 +869,9 @@ function_and_variable_visibility (bool whole_program)\n       if (!node->local.externally_visible && node->analyzed\n \t  && !DECL_EXTERNAL (node->decl))\n \t{\n-          struct cgraph_node *alias;\n \t  gcc_assert (whole_program || in_lto_p || !TREE_PUBLIC (node->decl));\n \t  cgraph_make_decl_local (node->decl);\n \t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t  for (alias = node->same_body; alias; alias = alias->next)\n-\t    cgraph_make_decl_local (alias->decl);\n \t  if (node->same_comdat_group)\n \t    /* cgraph_externally_visible_p has already checked all other nodes\n \t       in the group and they will all be made local.  We need to\n@@ -900,8 +885,7 @@ function_and_variable_visibility (bool whole_program)\n \t{\n \t  struct cgraph_node *decl_node = node;\n \n-\t  while (decl_node->thunk.thunk_p)\n-\t    decl_node = decl_node->callees->callee;\n+\t  decl_node = cgraph_function_node (decl_node->callees->callee, NULL);\n \n \t  /* Thunks have the same visibility as function they are attached to.\n \t     For some reason C++ frontend don't seem to care. I.e. in \n@@ -933,9 +917,9 @@ function_and_variable_visibility (bool whole_program)\n \t  if (DECL_EXTERNAL (decl_node->decl))\n \t    DECL_EXTERNAL (node->decl) = 1;\n \t}\n-      node->local.local = cgraph_local_node_p (node);\n-\n     }\n+  for (node = cgraph_nodes; node; node = node->next)\n+    node->local.local = cgraph_local_node_p (node);\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {\n       /* weak flag makes no sense on local variables.  */"}, {"sha": "169de382dbe3a35df6437064fc0344e4afa7039e", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -504,7 +504,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t\t     || referenced_from_other_partition_p (&node->ref_list, set, vset)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n-  bp_pack_value (&bp, node->alias, 1);\n+  bp_pack_value (&bp, node->alias && !boundary_p, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n@@ -523,32 +523,15 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t\t\t\t node->thunk.fixed_offset);\n       lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t node->thunk.virtual_value);\n-      lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t\tnode->thunk.alias);\n     }\n-\n-  if (node->same_body)\n+  if ((node->alias || node->thunk.thunk_p) && !boundary_p)\n     {\n-      struct cgraph_node *alias;\n-      unsigned long alias_count = 1;\n-      for (alias = node->same_body; alias->next; alias = alias->next)\n-\talias_count++;\n-      lto_output_uleb128_stream (ob->main_stream, alias_count);\n-      do\n-\t{\n-\t  lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t\t    alias->decl);\n-\t  lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t\t    alias->thunk.alias);\n-\t  gcc_assert (cgraph_get_node (alias->thunk.alias) == node);\n-\t  lto_output_enum (ob->main_stream, ld_plugin_symbol_resolution,\n-\t\t\t   LDPR_NUM_KNOWN, alias->resolution);\n-\t  alias = alias->previous;\n-\t}\n-      while (alias);\n+      lto_output_int_in_range (ob->main_stream, 0, 1,\n+\t\t\t       node->thunk.alias != NULL);\n+      if (node->thunk.alias != NULL)\n+        lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n+\t\t\t          node->thunk.alias);\n     }\n-  else\n-    lto_output_uleb128_stream (ob->main_stream, 0);\n }\n \n /* Output the varpool NODE to OB. \n@@ -997,7 +980,6 @@ input_node (struct lto_file_decl_data *file_data,\n   struct bitpack_d bp;\n   unsigned decl_index;\n   int ref = LCC_NOT_FOUND, ref2 = LCC_NOT_FOUND;\n-  unsigned long same_body_count = 0;\n   int clone_ref;\n \n   clone_ref = lto_input_sleb128 (ib);\n@@ -1043,31 +1025,20 @@ input_node (struct lto_file_decl_data *file_data,\n       int type = lto_input_uleb128 (ib);\n       HOST_WIDE_INT fixed_offset = lto_input_uleb128 (ib);\n       HOST_WIDE_INT virtual_value = lto_input_uleb128 (ib);\n-      tree real_alias;\n \n-      decl_index = lto_input_uleb128 (ib);\n-      real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n       node->thunk.fixed_offset = fixed_offset;\n       node->thunk.this_adjusting = (type & 2);\n       node->thunk.virtual_value = virtual_value;\n       node->thunk.virtual_offset_p = (type & 4);\n-      node->thunk.alias = real_alias;\n     }\n-\n-  same_body_count = lto_input_uleb128 (ib);\n-  while (same_body_count-- > 0)\n+  if (node->thunk.thunk_p || node->alias)\n     {\n-      tree alias_decl, real_alias;\n-      struct cgraph_node *alias;\n-\n-      decl_index = lto_input_uleb128 (ib);\n-      alias_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-      decl_index = lto_input_uleb128 (ib);\n-      real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-      alias = cgraph_same_body_alias (node, alias_decl, real_alias);\n-      gcc_assert (alias);\n-      alias->resolution = lto_input_enum (ib, ld_plugin_symbol_resolution,\n-\t\t\t\t\t  LDPR_NUM_KNOWN);\n+      if (lto_input_int_in_range (ib, \"alias nonzero flag\", 0, 1))\n+\t{\n+          decl_index = lto_input_uleb128 (ib);\n+          node->thunk.alias = lto_file_decl_data_get_fn_decl (file_data,\n+\t\t\t\t\t\t\t      decl_index);\n+\t}\n     }\n   return node;\n }"}, {"sha": "7a2f3f02361b63b4804926286bf2f962a4c5fd62", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -2253,6 +2253,7 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n     {\n       node = lto_cgraph_encoder_deref (encoder, i);\n       if (lto_cgraph_encoder_encode_body_p (encoder, node)\n+\t  && !node->alias\n \t  && !node->thunk.thunk_p)\n \t{\n #ifdef ENABLE_CHECKING\n@@ -2551,7 +2552,7 @@ produce_symtab (struct output_block *ob,\n   struct lto_streamer_cache_d *cache = ob->writer_cache;\n   char *section_name = lto_get_section_name (LTO_section_symtab, NULL, NULL);\n   struct pointer_set_t *seen;\n-  struct cgraph_node *node, *alias;\n+  struct cgraph_node *node;\n   struct varpool_node *vnode, *valias;\n   struct lto_output_stream stream;\n   lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n@@ -2584,8 +2585,6 @@ produce_symtab (struct output_block *ob,\n       if (node->alias || node->global.inlined_to)\n \tcontinue;\n       write_symbol (cache, &stream, node->decl, seen, false);\n-      for (alias = node->same_body; alias; alias = alias->next)\n-        write_symbol (cache, &stream, alias->decl, seen, true);\n     }\n   for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n     {\n@@ -2598,8 +2597,6 @@ produce_symtab (struct output_block *ob,\n       if (node->alias || node->global.inlined_to)\n \tcontinue;\n       write_symbol (cache, &stream, node->decl, seen, false);\n-      for (alias = node->same_body; alias; alias = alias->next)\n-        write_symbol (cache, &stream, alias->decl, seen, true);\n     }\n \n   /* Write all variables.  */"}, {"sha": "d58da8df2db7e3d2b9f1435788cacc99ccfa0edc", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 6, "deletions": 50, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -209,7 +209,6 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \t\t\t struct cgraph_node *prevailing_node)\n {\n   struct cgraph_edge *e, *next;\n-  bool no_aliases_please = false;\n   bool compatible_p;\n \n   if (cgraph_dump_file)\n@@ -223,13 +222,6 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)))));\n     }\n \n-  if (prevailing_node->same_body_alias)\n-    {\n-      if (prevailing_node->thunk.thunk_p)\n-\tno_aliases_please = true;\n-      prevailing_node = prevailing_node->same_body;\n-    }\n-\n   /* Merge node flags.  */\n   if (node->needed)\n     cgraph_mark_needed_node (prevailing_node);\n@@ -259,36 +251,8 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   /* Redirect incomming references.  */\n   ipa_clone_refering (prevailing_node, NULL, &node->ref_list);\n \n-  /* If we have aliases, redirect them to the prevailing node.  */\n-  if (!node->same_body_alias && node->same_body)\n-    {\n-      struct cgraph_node *alias, *last;\n-      /* We prevail aliases/tunks by a thunk.  This is doable but\n-         would need thunk combination.  Hopefully no ABI changes will\n-         every be crazy enough.  */\n-      gcc_assert (!no_aliases_please);\n-\n-      for (alias = node->same_body; alias; alias = alias->next)\n-\t{\n-\t  last = alias;\n-\t  gcc_assert (alias->same_body_alias);\n-\t  alias->same_body = prevailing_node;\n-\t}\n-      last->next = prevailing_node->same_body;\n-      /* Node with aliases is prevailed by alias.\n-\t We could handle this, but combining thunks together will be tricky.\n-\t Hopefully this does not happen.  */\n-      if (prevailing_node->same_body)\n-\tprevailing_node->same_body->previous = last;\n-      prevailing_node->same_body = node->same_body;\n-      node->same_body = NULL;\n-    }\n-\n   /* Finally remove the replaced node.  */\n-  if (node->same_body_alias)\n-    cgraph_remove_same_body_alias (node);\n-  else\n-    cgraph_remove_node (node);\n+  cgraph_remove_node (node);\n }\n \n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n@@ -472,9 +436,7 @@ lto_symtab_resolve_can_prevail_p (lto_symtab_entry_t e)\n \n   /* For functions we need a non-discarded body.  */\n   if (TREE_CODE (e->decl) == FUNCTION_DECL)\n-    return (e->node\n-\t    && (e->node->analyzed\n-\t        || (e->node->same_body_alias && e->node->same_body->analyzed)));\n+    return (e->node && e->node->analyzed);\n \n   /* A variable should have a size.  */\n   else if (TREE_CODE (e->decl) == VAR_DECL)\n@@ -816,20 +778,14 @@ lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n void\n lto_symtab_merge_cgraph_nodes (void)\n {\n-  struct cgraph_node *node, *alias, *next;\n+  struct cgraph_node *node;\n   lto_symtab_maybe_init_hash_table ();\n   htab_traverse (lto_symtab_identifiers, lto_symtab_merge_cgraph_nodes_1, NULL);\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      if (node->thunk.thunk_p)\n-        node->thunk.alias = lto_symtab_prevailing_decl (node->thunk.alias);\n-      for (alias = node->same_body; alias; alias = next)\n-\t{\n-\t  next = alias->next;\n-\t  alias->thunk.alias = lto_symtab_prevailing_decl (alias->thunk.alias);\n-\t}\n-    }\n+    if ((node->thunk.thunk_p || node->alias)\n+\t&& node->thunk.alias)\n+      node->thunk.alias = lto_symtab_prevailing_decl (node->thunk.alias);\n }\n \n /* Given the decl DECL, return the prevailing decl with the same name. */"}, {"sha": "9956d791ce3ee302c8353d892b9addcdddad33ef", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -1,3 +1,12 @@\n+2011-06-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (add_cgraph_node_to_partition_1): Break out from ...\n+\t(add_cgraph_node_to_partition) ... here; walk aliases.\n+\t(lto_1_to_1_map): Remove same body alias code.\n+\t(promote_fn): Likewise.\n+\t(lto_promote_cross_file_statics): Update comment.\n+\n+\n 2011-06-07  Diego Novillo  <dnovillo@google.com>\n \n \t* lto.c (uniquify_nodes): Move code to register decls to"}, {"sha": "f13ee0e03f259538e86317016c4cb66e6ac8cea8", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -1319,7 +1319,7 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n   for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n     {\n       if (ref->refered_type == IPA_REF_CGRAPH\n-\t  && DECL_COMDAT (ipa_ref_node (ref)->decl)\n+\t  && DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref), NULL)->decl)\n \t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n \tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n       else\n@@ -1330,49 +1330,69 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n     }\n }\n \n+/* Worker for add_cgraph_node_to_partition.  */\n+\n+static bool\n+add_cgraph_node_to_partition_1 (struct cgraph_node *node, void *data)\n+{\n+  ltrans_partition part = (ltrans_partition) data;\n+\n+  /* non-COMDAT aliases of COMDAT functions needs to be output just once.  */\n+  if (!DECL_COMDAT (node->decl)\n+      && !node->global.inlined_to\n+      && node->aux)\n+    {\n+      gcc_assert (node->thunk.thunk_p || node->alias);\n+      return false;\n+    }\n+\n+  if (node->aux)\n+    {\n+      node->in_other_partition = 1;\n+      if (cgraph_dump_file)\n+        fprintf (cgraph_dump_file, \"Node %s/%i now used in multiple partitions\\n\",\n+\t\t cgraph_node_name (node), node->uid);\n+    }\n+  node->aux = (void *)((size_t)node->aux + 1);\n+  cgraph_node_set_add (part->cgraph_set, node);\n+  return false;\n+}\n+\n /* Add NODE to partition as well as the inline callees and referred comdats into partition PART. */\n \n static void\n add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n   cgraph_node_set_iterator csi;\n+  struct cgraph_node *n;\n+\n+  /* We always decide on functions, not associated thunks and aliases.  */\n+  node = cgraph_function_node (node, NULL);\n \n   /* If NODE is already there, we have nothing to do.  */\n   csi = cgraph_node_set_find (part->cgraph_set, node);\n   if (!csi_end_p (csi))\n     return;\n \n+  cgraph_for_node_thunks_and_aliases (node, add_cgraph_node_to_partition_1, part, true);\n+\n   part->insns += inline_summary (node)->self_size;\n \n-  if (node->aux)\n-    {\n-      node->in_other_partition = 1;\n-      if (cgraph_dump_file)\n-        fprintf (cgraph_dump_file, \"Node %s/%i now used in multiple partitions\\n\",\n-\t\t cgraph_node_name (node), node->uid);\n-    }\n-  node->aux = (void *)((size_t)node->aux + 1);\n \n   cgraph_node_set_add (part->cgraph_set, node);\n \n-  /* Thunks always must go along with function they reffer to.  */\n-  if (node->thunk.thunk_p)\n-    add_cgraph_node_to_partition (part, node->callees->callee);\n-  for (e = node->callers; e; e = e->next_caller)\n-    if (e->caller->thunk.thunk_p)\n-      add_cgraph_node_to_partition (part, e->caller);\n-\n   for (e = node->callees; e; e = e->next_callee)\n-    if ((!e->inline_failed || DECL_COMDAT (e->callee->decl))\n+    if ((!e->inline_failed\n+\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->decl))\n \t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n       add_cgraph_node_to_partition (part, e->callee);\n \n   add_references_to_partition (part, &node->ref_list);\n \n-  if (node->same_comdat_group\n-      && !cgraph_node_in_set_p (node->same_comdat_group, part->cgraph_set))\n-    add_cgraph_node_to_partition (part, node->same_comdat_group);\n+  if (node->same_comdat_group)\n+    for (n = node->same_comdat_group; n != node; n = n->same_comdat_group)\n+      add_cgraph_node_to_partition (part, n);\n }\n \n /* Add VNODE to partition as well as comdat references partition PART. */\n@@ -1500,7 +1520,6 @@ lto_1_to_1_map (void)\n \tcontinue;\n \n       file_data = node->local.lto_file_data;\n-      gcc_assert (!node->same_body_alias);\n \n       if (file_data)\n \t{\n@@ -1900,17 +1919,6 @@ promote_fn (struct cgraph_node *node)\n   TREE_PUBLIC (node->decl) = 1;\n   DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n   DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n-  if (node->same_body)\n-    {\n-      struct cgraph_node *alias;\n-      for (alias = node->same_body;\n-\t   alias; alias = alias->next)\n-\t{\n-\t  TREE_PUBLIC (alias->decl) = 1;\n-\t  DECL_VISIBILITY (alias->decl) = VISIBILITY_HIDDEN;\n-\t  DECL_VISIBILITY_SPECIFIED (alias->decl) = true;\n-\t}\n-    }\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n \t     \"Promoting function as hidden: %s/%i\\n\",\n@@ -1944,8 +1952,8 @@ lto_promote_cross_file_statics (void)\n       set = part->cgraph_set;\n       vset = part->varpool_set;\n \n-      /* If node has either address taken (and we have no clue from where)\n-\t or it is called from other partition, it needs to be globalized.  */\n+      /* If node called or referred to from other partition, it needs to be\n+\t globalized.  */\n       for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n \t{\n \t  struct cgraph_node *node = csi_node (csi);"}, {"sha": "3544cafa20cb1ce57ebdf6ab8ffdf71fb08f050a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e2db00dad38d188a235308d53a2963925bdd85/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=39e2db00dad38d188a235308d53a2963925bdd85", "patch": "@@ -6675,6 +6675,16 @@ gate_ipa_pta (void)\n struct pt_solution ipa_escaped_pt\n   = { true, false, false, false, false, false, false, NULL };\n \n+/* Associate node with varinfo DATA. Worker for\n+   cgraph_for_node_and_aliases.  */\n+static bool\n+associate_varinfo_to_alias (struct cgraph_node *node, void *data)\n+{\n+  if (node->alias || node->thunk.thunk_p)\n+    insert_vi_for_tree (node->decl, (varinfo_t)data);\n+  return false;\n+}\n+\n /* Execute the driver for IPA PTA.  */\n static unsigned int\n ipa_pta_execute (void)\n@@ -6690,22 +6700,17 @@ ipa_pta_execute (void)\n   /* Build the constraints.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      struct cgraph_node *alias;\n       varinfo_t vi;\n-\n       /* Nodes without a body are not interesting.  Especially do not\n          visit clones at this point for now - we get duplicate decls\n \t there for inline clones at least.  */\n-      if (!gimple_has_body_p (node->decl)\n+      if (!cgraph_function_with_gimple_body_p (node)\n \t  || node->clone_of)\n \tcontinue;\n \n       vi = create_function_info_for (node->decl,\n-\t\t\t\t     alias_get_name (node->decl));\n-\n-      /* Associate the varinfo node with all aliases.  */\n-      for (alias = node->same_body; alias; alias = alias->next)\n-\tinsert_vi_for_tree (alias->decl, vi);\n+\t\t\t             alias_get_name (node->decl));\n+      cgraph_for_node_and_aliases (node, associate_varinfo_to_alias, vi, true);\n     }\n \n   /* Create constraints for global variables and their initializers.  */\n@@ -6737,7 +6742,7 @@ ipa_pta_execute (void)\n       tree old_func_decl;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!gimple_has_body_p (node->decl)\n+      if (!cgraph_function_with_gimple_body_p (node)\n \t  || node->clone_of)\n \tcontinue;\n \n@@ -6846,7 +6851,7 @@ ipa_pta_execute (void)\n       struct cgraph_edge *e;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!gimple_has_body_p (node->decl)\n+      if (!cgraph_function_with_gimple_body_p (node)\n \t  || node->clone_of)\n \tcontinue;\n "}]}