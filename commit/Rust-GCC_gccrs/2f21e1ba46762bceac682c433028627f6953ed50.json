{"sha": "2f21e1ba46762bceac682c433028627f6953ed50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyMWUxYmE0Njc2MmJjZWFjNjgyYzQzMzAyODYyN2Y2OTUzZWQ1MA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2014-11-06T17:20:13Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2014-11-06T17:20:13Z"}, "message": "Add a hook to inform a port about call arguments.\n\n\t* target.def (call_args, end_call_args): New hooks.\n\t* hooks.c (hook_void_rtx_tree): New empty function.\n\t* hooks.h (hook_void_rtx_tree): Declare.\n\t* doc/tm.texi.in (TARGET_CALL_ARGS, TARGET_END_CALL_ARGS): Add.\n\t* doc/tm.texi: Regenerate.\n\t* calls.c (expand_call): Slightly rearrange the code.  Use the two new\n\thooks.\n\t(expand_library_call_value_1): Use the two new hooks.\n\nFrom-SVN: r217199", "tree": {"sha": "4999300131a9d6c5e23e1edd7447e5a3a181005a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4999300131a9d6c5e23e1edd7447e5a3a181005a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f21e1ba46762bceac682c433028627f6953ed50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f21e1ba46762bceac682c433028627f6953ed50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f21e1ba46762bceac682c433028627f6953ed50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f21e1ba46762bceac682c433028627f6953ed50/comments", "author": null, "committer": null, "parents": [{"sha": "11717c64bf8b17397a6267638833ae6fca606a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11717c64bf8b17397a6267638833ae6fca606a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11717c64bf8b17397a6267638833ae6fca606a07"}], "stats": {"total": 173, "additions": 134, "deletions": 39}, "files": [{"sha": "75ab1fa7bbfafe105365bb0dc3447f82453a38fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f21e1ba46762bceac682c433028627f6953ed50", "patch": "@@ -1,5 +1,14 @@\n 2014-11-06  Bernd Schmidt  <bernds@codesourcery.com>\n \n+\t* target.def (call_args, end_call_args): New hooks.\n+\t* hooks.c (hook_void_rtx_tree): New empty function.\n+\t* hooks.h (hook_void_rtx_tree): Declare.\n+\t* doc/tm.texi.in (TARGET_CALL_ARGS, TARGET_END_CALL_ARGS): Add.\n+\t* doc/tm.texi: Regenerate.\n+\t* calls.c (expand_call): Slightly rearrange the code.  Use the two new\n+\thooks.\n+\t(expand_library_call_value_1): Use the two new hooks.\n+\n \t* expr.c (use_reg_mode): Just return for pseudo registers.\n \n \t* combine.c (try_combine): Don't allow a call as one of the source"}, {"sha": "06b8485ff7fa82708a8f290b6c90b76cf0321731", "filename": "gcc/calls.c", "status": "modified", "additions": 65, "deletions": 39, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2f21e1ba46762bceac682c433028627f6953ed50", "patch": "@@ -3103,45 +3103,6 @@ expand_call (tree exp, rtx target, int ignore)\n \n       funexp = rtx_for_function_call (fndecl, addr);\n \n-      /* Figure out the register where the value, if any, will come back.  */\n-      valreg = 0;\n-      valbnd = 0;\n-      if (TYPE_MODE (rettype) != VOIDmode\n-\t  && ! structure_value_addr)\n-\t{\n-\t  if (pcc_struct_value)\n-\t    {\n-\t      valreg = hard_function_value (build_pointer_type (rettype),\n-\t\t\t\t\t    fndecl, NULL, (pass == 0));\n-\t      if (CALL_WITH_BOUNDS_P (exp))\n-\t\tvalbnd = targetm.calls.\n-\t\t  chkp_function_value_bounds (build_pointer_type (rettype),\n-\t\t\t\t\t      fndecl, (pass == 0));\n-\t    }\n-\t  else\n-\t    {\n-\t      valreg = hard_function_value (rettype, fndecl, fntype,\n-\t\t\t\t\t    (pass == 0));\n-\t      if (CALL_WITH_BOUNDS_P (exp))\n-\t\tvalbnd = targetm.calls.chkp_function_value_bounds (rettype,\n-\t\t\t\t\t\t\t\t   fndecl,\n-\t\t\t\t\t\t\t\t   (pass == 0));\n-\t    }\n-\n-\t  /* If VALREG is a PARALLEL whose first member has a zero\n-\t     offset, use that.  This is for targets such as m68k that\n-\t     return the same value in multiple places.  */\n-\t  if (GET_CODE (valreg) == PARALLEL)\n-\t    {\n-\t      rtx elem = XVECEXP (valreg, 0, 0);\n-\t      rtx where = XEXP (elem, 0);\n-\t      rtx offset = XEXP (elem, 1);\n-\t      if (offset == const0_rtx\n-\t\t  && GET_MODE (where) == GET_MODE (valreg))\n-\t\tvalreg = where;\n-\t    }\n-\t}\n-\n       /* Precompute all register parameters.  It isn't safe to compute anything\n \t once we have started filling any specific hard regs.  */\n       precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n@@ -3223,6 +3184,55 @@ expand_call (tree exp, rtx target, int ignore)\n \t\tsibcall_failure = 1;\n \t    }\n \n+      bool any_regs = false;\n+      for (i = 0; i < num_actuals; i++)\n+\tif (args[i].reg != NULL_RTX)\n+\t  {\n+\t    any_regs = true;\n+\t    targetm.calls.call_args (args[i].reg, funtype);\n+\t  }\n+      if (!any_regs)\n+\ttargetm.calls.call_args (pc_rtx, funtype);\n+\n+      /* Figure out the register where the value, if any, will come back.  */\n+      valreg = 0;\n+      valbnd = 0;\n+      if (TYPE_MODE (rettype) != VOIDmode\n+\t  && ! structure_value_addr)\n+\t{\n+\t  if (pcc_struct_value)\n+\t    {\n+\t      valreg = hard_function_value (build_pointer_type (rettype),\n+\t\t\t\t\t    fndecl, NULL, (pass == 0));\n+\t      if (CALL_WITH_BOUNDS_P (exp))\n+\t\tvalbnd = targetm.calls.\n+\t\t  chkp_function_value_bounds (build_pointer_type (rettype),\n+\t\t\t\t\t      fndecl, (pass == 0));\n+\t    }\n+\t  else\n+\t    {\n+\t      valreg = hard_function_value (rettype, fndecl, fntype,\n+\t\t\t\t\t    (pass == 0));\n+\t      if (CALL_WITH_BOUNDS_P (exp))\n+\t\tvalbnd = targetm.calls.chkp_function_value_bounds (rettype,\n+\t\t\t\t\t\t\t\t   fndecl,\n+\t\t\t\t\t\t\t\t   (pass == 0));\n+\t    }\n+\n+\t  /* If VALREG is a PARALLEL whose first member has a zero\n+\t     offset, use that.  This is for targets such as m68k that\n+\t     return the same value in multiple places.  */\n+\t  if (GET_CODE (valreg) == PARALLEL)\n+\t    {\n+\t      rtx elem = XVECEXP (valreg, 0, 0);\n+\t      rtx where = XEXP (elem, 0);\n+\t      rtx offset = XEXP (elem, 1);\n+\t      if (offset == const0_rtx\n+\t\t  && GET_MODE (where) == GET_MODE (valreg))\n+\t\tvalreg = where;\n+\t    }\n+\t}\n+\n       /* Store all bounds not passed in registers.  */\n       for (i = 0; i < num_actuals; i++)\n \t{\n@@ -3582,6 +3592,8 @@ expand_call (tree exp, rtx target, int ignore)\n       for (i = 0; i < num_actuals; ++i)\n \tfree (args[i].aligned_regs);\n \n+      targetm.calls.end_call_args ();\n+\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -4111,6 +4123,18 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n     }\n #endif\n \n+  /* When expanding a normal call, args are stored in push order,\n+     which is the reverse of what we have here.  */\n+  bool any_regs = false;\n+  for (int i = nargs; i-- > 0; )\n+    if (argvec[i].reg != NULL_RTX)\n+      {\n+\ttargetm.calls.call_args (argvec[i].reg, NULL_TREE);\n+\tany_regs = true;\n+      }\n+  if (!any_regs)\n+    targetm.calls.call_args (pc_rtx, NULL_TREE);\n+\n   /* Push the args that need to be pushed.  */\n \n   /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n@@ -4351,6 +4375,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       valreg = gen_rtx_REG (TYPE_MODE (tfom), REGNO (valreg));\n     }\n \n+  targetm.calls.end_call_args ();\n+\n   /* For calls to `setjmp', etc., inform function.c:setjmp_warnings\n      that it should complain if nonvolatile values are live.  For\n      functions that cannot return, inform flow that control does not"}, {"sha": "a55206d6c051d6781615ed8e980e599426423d93", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2f21e1ba46762bceac682c433028627f6953ed50", "patch": "@@ -4976,6 +4976,29 @@ except the last are treated as named.\n You need not define this hook if it always returns @code{false}.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_CALL_ARGS (rtx, @var{tree})\n+While generating RTL for a function call, this target hook is invoked once\n+for each argument passed to the function, either a register returned by\n+@code{TARGET_FUNCTION_ARG} or a memory location.  It is called just\n+before the point where argument registers are stored.  The type of the\n+function to be called is also passed as the second argument; it is\n+@code{NULL_TREE} for libcalls.  The @code{TARGET_END_CALL_ARGS} hook is\n+invoked just after the code to copy the return reg has been emitted.\n+This functionality can be used to perform special setup of call argument\n+registers if a target needs it.\n+For functions without arguments, the hook is called once with @code{pc_rtx}\n+passed instead of an argument register.\n+Most ports do not need to implement anything for this hook.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_END_CALL_ARGS (void)\n+This target hook is invoked while generating RTL for a function call,\n+just after the point where the return reg is copied into a pseudo.  It\n+signals that all the call argument and return registers for the just\n+emitted call are now no longer in use.\n+Most ports do not need to implement anything for this hook.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED (cumulative_args_t @var{ca})\n If you need to conditionally change ABIs so that one works with\n @code{TARGET_SETUP_INCOMING_VARARGS}, but the other works like neither"}, {"sha": "e0c52c8a37a084c05afae532e7f54d2ce0839bd8", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=2f21e1ba46762bceac682c433028627f6953ed50", "patch": "@@ -3860,6 +3860,10 @@ These machine description macros help implement varargs:\n \n @hook TARGET_STRICT_ARGUMENT_NAMING\n \n+@hook TARGET_CALL_ARGS\n+\n+@hook TARGET_END_CALL_ARGS\n+\n @hook TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n \n @hook TARGET_LOAD_BOUNDS_FOR_ARG"}, {"sha": "91e17cd70c2be987f238070638cd67bed17388ae", "filename": "gcc/hooks.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=2f21e1ba46762bceac682c433028627f6953ed50", "patch": "@@ -244,6 +244,11 @@ hook_void_tree (tree a ATTRIBUTE_UNUSED)\n {\n }\n \n+void\n+hook_void_rtx_tree (rtx, tree)\n+{\n+}\n+\n void\n hook_void_constcharptr (const char *a ATTRIBUTE_UNUSED)\n {"}, {"sha": "4006cad3412cb9a0aeedb279210c6bd4788649dd", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=2f21e1ba46762bceac682c433028627f6953ed50", "patch": "@@ -71,6 +71,7 @@ extern void hook_void_constcharptr (const char *);\n extern void hook_void_rtx_insn_int (rtx_insn *, int);\n extern void hook_void_FILEptr_constcharptr (FILE *, const char *);\n extern bool hook_bool_FILEptr_rtx_false (FILE *, rtx);\n+extern void hook_void_rtx_tree (rtx, tree);\n extern void hook_void_tree (tree);\n extern void hook_void_tree_treeptr (tree, tree *);\n extern void hook_void_int_int (int, int);"}, {"sha": "d6198ad3569ca94605b611f2fec170d74509677d", "filename": "gcc/target.def", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f21e1ba46762bceac682c433028627f6953ed50/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=2f21e1ba46762bceac682c433028627f6953ed50", "patch": "@@ -4001,6 +4001,33 @@ into the stack.  Arguments meaning is similar to\\n\\\n \tint *pretend_args_size, int second_time),\n  default_setup_incoming_vararg_bounds)\n \n+DEFHOOK\n+(call_args,\n+ \"While generating RTL for a function call, this target hook is invoked once\\n\\\n+for each argument passed to the function, either a register returned by\\n\\\n+@code{TARGET_FUNCTION_ARG} or a memory location.  It is called just\\n\\\n+before the point where argument registers are stored.  The type of the\\n\\\n+function to be called is also passed as the second argument; it is\\n\\\n+@code{NULL_TREE} for libcalls.  The @code{TARGET_END_CALL_ARGS} hook is\\n\\\n+invoked just after the code to copy the return reg has been emitted.\\n\\\n+This functionality can be used to perform special setup of call argument\\n\\\n+registers if a target needs it.\\n\\\n+For functions without arguments, the hook is called once with @code{pc_rtx}\\n\\\n+passed instead of an argument register.\\n\\\n+Most ports do not need to implement anything for this hook.\",\n+ void, (rtx, tree),\n+ hook_void_rtx_tree)\n+\n+DEFHOOK\n+(end_call_args,\n+ \"This target hook is invoked while generating RTL for a function call,\\n\\\n+just after the point where the return reg is copied into a pseudo.  It\\n\\\n+signals that all the call argument and return registers for the just\\n\\\n+emitted call are now no longer in use.\\n\\\n+Most ports do not need to implement anything for this hook.\",\n+ void, (void),\n+ hook_void_void)\n+\n DEFHOOK\n (strict_argument_naming,\n  \"Define this hook to return @code{true} if the location where a function\\n\\"}]}