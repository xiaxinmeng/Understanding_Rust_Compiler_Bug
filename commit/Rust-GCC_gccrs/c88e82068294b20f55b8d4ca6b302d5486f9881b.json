{"sha": "c88e82068294b20f55b8d4ca6b302d5486f9881b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg4ZTgyMDY4Mjk0YjIwZjU1YjhkNGNhNmIzMDJkNTQ4NmY5ODgxYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-18T22:20:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-18T22:20:27Z"}, "message": "basic-block.h (set_block_num): Declare.\n\n        * basic-block.h (set_block_num): Declare.\n        * flow.c (update_life_info): Don't call compute_bb_for_insn\n        or free_basic_block_vars.\n        * haifa-sched.c (remove_dependence): Conditionalize on HAVE_cc0.\n        (insn_orig_block): Remove.\n        (INSN_BLOCK): Remove.  Update all callers to use BLOCK_NUM.\n        (schedule_block): Keep BLOCK_NUM up-to-date.\n        (schedule_insns): Use compute_bb_for_insn.\n        * recog.c (split_all_insns): Likewise.\n        (peephole2_optimize): Likewise.\n\nFrom-SVN: r30073", "tree": {"sha": "ad7060cd4617a41e224844edcb92fdc6b9b65814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad7060cd4617a41e224844edcb92fdc6b9b65814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c88e82068294b20f55b8d4ca6b302d5486f9881b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c88e82068294b20f55b8d4ca6b302d5486f9881b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c88e82068294b20f55b8d4ca6b302d5486f9881b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c88e82068294b20f55b8d4ca6b302d5486f9881b/comments", "author": null, "committer": null, "parents": [{"sha": "87b5c7e5e4321f5c069e047836e1160e371365e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b5c7e5e4321f5c069e047836e1160e371365e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87b5c7e5e4321f5c069e047836e1160e371365e8"}], "stats": {"total": 97, "additions": 58, "deletions": 39}, "files": [{"sha": "4631489fc31d475ba1b26b0dd4ef33e670c278cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c88e82068294b20f55b8d4ca6b302d5486f9881b", "patch": "@@ -1,3 +1,16 @@\n+Mon Oct 18 15:19:41 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* basic-block.h (set_block_num): Declare.\n+\t* flow.c (update_life_info): Don't call compute_bb_for_insn\n+\tor free_basic_block_vars.\n+\t* haifa-sched.c (remove_dependence): Conditionalize on HAVE_cc0.\n+\t(insn_orig_block): Remove.\n+\t(INSN_BLOCK): Remove.  Update all callers to use BLOCK_NUM.\n+\t(schedule_block): Keep BLOCK_NUM up-to-date.\n+\t(schedule_insns): Use compute_bb_for_insn.\n+\t* recog.c (split_all_insns): Likewise.\n+\t(peephole2_optimize): Likewise.\n+\n Mon Oct 18 18:50:51 1999  Andreas Schwab  <schwab@suse.de>\n \n \t* config/m68k/m68k.h (INITIAL_FRAME_POINTER_OFFSET): Add one word"}, {"sha": "ad2d15c9398bcd7be5882496df79cd04cf893cd5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c88e82068294b20f55b8d4ca6b302d5486f9881b", "patch": "@@ -245,6 +245,7 @@ extern varray_type basic_block_for_insn;\n \n extern void compute_bb_for_insn\t\tPROTO ((int));\n extern void set_block_for_insn\t\tPROTO ((rtx, basic_block));\n+extern void set_block_num\t\tPROTO ((rtx, int));\n \n extern void dump_bb_data\t\tPROTO ((FILE *, int_list_ptr *,\n \t\t\t\t\t\tint_list_ptr *, int));"}, {"sha": "aaa006ae104bb42d2cf151cbe946f8353be7a8c3", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c88e82068294b20f55b8d4ca6b302d5486f9881b", "patch": "@@ -2544,6 +2544,8 @@ verify_local_live_at_start (new_live_at_start, bb)\n    If we find registers removed from live_at_start, that means we have\n    a broken peephole that is killing a register it shouldn't.\n \n+   BLOCK_FOR_INSN is assumed to be correct.\n+\n    ??? This is not true in one situation -- when a pre-reload splitter\n    generates subregs of a multi-word pseudo, current life analysis will\n    lose the kill.  So we _can_ have a pseudo go live.  How irritating.  */\n@@ -2556,7 +2558,6 @@ update_life_info (blocks, extent)\n   regset tmp;\n   int i;\n \n-  compute_bb_for_insn (get_max_uid ());\n   tmp = ALLOCA_REG_SET ();\n \n   /* For a global update, we go through the relaxation process again.  */\n@@ -2584,7 +2585,6 @@ update_life_info (blocks, extent)\n     });\n \n   FREE_REG_SET (tmp);\n-  free_basic_block_vars (1);\n }\n \n /* Free the variables allocated by find_basic_blocks."}, {"sha": "f6e6325797b87c6b43dd321d3f096735eb1bed23", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c88e82068294b20f55b8d4ca6b302d5486f9881b", "patch": "@@ -397,7 +397,9 @@ static int *insn_tick;\n \n /* Forward declarations.  */\n static void add_dependence PROTO ((rtx, rtx, enum reg_note));\n+#ifdef HAVE_cc0\n static void remove_dependence PROTO ((rtx, rtx));\n+#endif\n static rtx find_insn_list PROTO ((rtx, rtx));\n static int insn_unit PROTO ((rtx));\n static unsigned int blockage_range PROTO ((int, rtx));\n@@ -425,10 +427,6 @@ static char *safe_concat PROTO ((char *, char *, const char *));\n static int insn_issue_delay PROTO ((rtx));\n static void adjust_priority PROTO ((rtx));\n \n-/* Mapping of insns to their original block prior to scheduling.  */\n-static int *insn_orig_block;\n-#define INSN_BLOCK(insn) (insn_orig_block[INSN_UID (insn)])\n-\n /* Some insns (e.g. call) are not allowed to move across blocks.  */\n static char *cant_move;\n #define CANT_MOVE(insn) (cant_move[INSN_UID (insn)])\n@@ -637,9 +635,9 @@ static edgeset *ancestor_edges;\n static void compute_dom_prob_ps PROTO ((int));\n \n #define ABS_VALUE(x) (((x)<0)?(-(x)):(x))\n-#define INSN_PROBABILITY(INSN) (SRC_PROB (BLOCK_TO_BB (INSN_BLOCK (INSN))))\n-#define IS_SPECULATIVE_INSN(INSN) (IS_SPECULATIVE (BLOCK_TO_BB (INSN_BLOCK (INSN))))\n-#define INSN_BB(INSN) (BLOCK_TO_BB (INSN_BLOCK (INSN)))\n+#define INSN_PROBABILITY(INSN) (SRC_PROB (BLOCK_TO_BB (BLOCK_NUM (INSN))))\n+#define IS_SPECULATIVE_INSN(INSN) (IS_SPECULATIVE (BLOCK_TO_BB (BLOCK_NUM (INSN))))\n+#define INSN_BB(INSN) (BLOCK_TO_BB (BLOCK_NUM (INSN)))\n \n /* Parameters affecting the decision of rank_for_schedule().  */\n #define MIN_DIFF_PRIORITY 2\n@@ -828,6 +826,7 @@ add_dependence (insn, elem, dep_type)\n   PUT_REG_NOTE_KIND (link, dep_type);\n }\n \n+#ifdef HAVE_cc0\n /* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n    of INSN.  Abort if not found.  */\n \n@@ -867,6 +866,7 @@ remove_dependence (insn, elem)\n     abort ();\n   return;\n }\n+#endif /* HAVE_cc0 */\n \f\n #ifndef INSN_SCHEDULING\n void\n@@ -2333,7 +2333,7 @@ find_conditional_protection (insn, load_insn_bb)\n   for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n     {\n       rtx next = XEXP (link, 0);\n-      if ((CONTAINING_RGN (INSN_BLOCK (next)) ==\n+      if ((CONTAINING_RGN (BLOCK_NUM (next)) ==\n \t   CONTAINING_RGN (BB_TO_BLOCK (load_insn_bb)))\n \t  && IS_REACHABLE (INSN_BB (next), load_insn_bb)\n \t  && load_insn_bb != INSN_BB (next)\n@@ -2377,7 +2377,7 @@ is_conditionally_protected (load_insn, bb_src, bb_trg)\n \n       /* Must exist a path: region-entry -> ... -> bb_trg -> ... load_insn.  */\n       if (INSN_BB (insn1) == bb_src\n-\t  || (CONTAINING_RGN (INSN_BLOCK (insn1))\n+\t  || (CONTAINING_RGN (BLOCK_NUM (insn1))\n \t      != CONTAINING_RGN (BB_TO_BLOCK (bb_src)))\n \t  || (!IS_REACHABLE (bb_trg, INSN_BB (insn1))\n \t      && !IS_REACHABLE (INSN_BB (insn1), bb_trg)))\n@@ -2448,7 +2448,7 @@ is_pfree (load_insn, bb_src, bb_trg)\n \t\t    /* insn2 is the similar load, in the target block.  */\n \t\t    return 1;\n \n-\t\t  if (*(candp->split_bbs.first_member) == INSN_BLOCK (insn2))\n+\t\t  if (*(candp->split_bbs.first_member) == BLOCK_NUM (insn2))\n \t\t    /* insn2 is a similar load, in a split-block.  */\n \t\t    return 1;\n \t\t}\n@@ -3108,7 +3108,7 @@ priority (insn)\n \t    next = XEXP (link, 0);\n \n \t    /* Critical path is meaningful in block boundaries only.  */\n-\t    if (INSN_BLOCK (next) != INSN_BLOCK (insn))\n+\t    if (BLOCK_NUM (next) != BLOCK_NUM (insn))\n \t      continue;\n \n \t    next_priority = insn_cost (insn, link, next) + priority (next);\n@@ -3738,6 +3738,7 @@ sched_analyze_insn (x, insn, loop_notes)\n       for (i = 0; i < maxreg; i++)\n \t{\n \t  free_INSN_LIST_list (&reg_last_sets[i]);\n+\t  free_INSN_LIST_list (&reg_last_clobbers[i]);\n \t  reg_last_sets[i] = alloc_INSN_LIST (insn, NULL_RTX);\n \t}\n \n@@ -4087,7 +4088,7 @@ queue_insn (insn, n_cycles)\n       fprintf (dump, \";;\\t\\tReady-->Q: insn %d: \", INSN_UID (insn));\n \n       if (INSN_BB (insn) != target_bb)\n-\tfprintf (dump, \"(b%d) \", INSN_BLOCK (insn));\n+\tfprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n \n       fprintf (dump, \"queued for %d cycles.\\n\", n_cycles);\n     }\n@@ -4185,7 +4186,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \t\t       INSN_UID (next));\n \n \t      if (current_nr_blocks > 1 && INSN_BB (next) != target_bb)\n-\t\tfprintf (dump, \"/b%d \", INSN_BLOCK (next));\n+\t\tfprintf (dump, \"/b%d \", BLOCK_NUM (next));\n \n \t      if (effective_cost < 1)\n \t\tfprintf (dump, \"into ready\\n\");\n@@ -4630,7 +4631,7 @@ queue_to_ready (ready, n_ready)\n \tfprintf (dump, \";;\\t\\tQ-->Ready: insn %d: \", INSN_UID (insn));\n \n       if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n-\tfprintf (dump, \"(b%d) \", INSN_BLOCK (insn));\n+\tfprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n \n       ready[n_ready++] = insn;\n       if (sched_verbose >= 2)\n@@ -4657,7 +4658,7 @@ queue_to_ready (ready, n_ready)\n \t\t    fprintf (dump, \";;\\t\\tQ-->Ready: insn %d: \", INSN_UID (insn));\n \n \t\t  if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n-\t\t    fprintf (dump, \"(b%d) \", INSN_BLOCK (insn));\n+\t\t    fprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n \n \t\t  ready[n_ready++] = insn;\n \t\t  if (sched_verbose >= 2)\n@@ -4691,7 +4692,7 @@ debug_ready_list (ready, n_ready)\n     {\n       fprintf (dump, \"  %d\", INSN_UID (ready[i]));\n       if (current_nr_blocks > 1 && INSN_BB (ready[i]) != target_bb)\n-\tfprintf (dump, \"/b%d\", INSN_BLOCK (ready[i]));\n+\tfprintf (dump, \"/b%d\", BLOCK_NUM (ready[i]));\n     }\n   fprintf (dump, \"\\n\");\n }\n@@ -5895,8 +5896,6 @@ schedule_block (bb, rgn_n_insns)\n   /* Loop until all the insns in BB are scheduled.  */\n   while (sched_target_n_insns < target_n_insns)\n     {\n-      int b1;\n-\n       clock_var++;\n \n       /* Add to the ready list all pending insns that can be issued now.\n@@ -5949,6 +5948,7 @@ schedule_block (bb, rgn_n_insns)\n \t  if (INSN_BB (insn) != target_bb)\n \t    {\n \t      rtx temp;\n+\t      basic_block b1;\n \n \t      if (IS_SPECULATIVE_INSN (insn))\n \t\t{\n@@ -5964,35 +5964,40 @@ schedule_block (bb, rgn_n_insns)\n \t\t}\n \t      nr_inter++;\n \n+\t      /* Find the beginning of the scheduling group; update the\n+\t\t containing block number for the insns.  */\n \t      temp = insn;\n-\t      while (SCHED_GROUP_P (temp))\n-\t\ttemp = PREV_INSN (temp);\n+\t      set_block_num (temp, target_bb);\n+\t      while (SCHED_GROUP_P (insn))\n+\t\t{\n+\t\t  temp = PREV_INSN (temp);\n+\t\t  set_block_num (temp, target_bb);\n+\t\t}\n \n \t      /* Update source block boundaries.   */\n-\t      b1 = INSN_BLOCK (temp);\n-\t      if (temp == BLOCK_HEAD (b1)\n-\t\t  && insn == BLOCK_END (b1))\n+\t      b1 = BLOCK_FOR_INSN (temp);\n+\t      if (temp == b1->head && insn == b1->end)\n \t\t{\n \t\t  /* We moved all the insns in the basic block.\n \t\t     Emit a note after the last insn and update the\n \t\t     begin/end boundaries to point to the note.  */\n-\t\t  emit_note_after (NOTE_INSN_DELETED, insn);\n-\t\t  BLOCK_END (b1) = NEXT_INSN (insn);\n-\t\t  BLOCK_HEAD (b1) = NEXT_INSN (insn);\n+\t\t  rtx note = emit_note_after (NOTE_INSN_DELETED, insn);\n+\t\t  b1->head = note;\n+\t\t  b1->end = note;\n \t\t}\n-\t      else if (insn == BLOCK_END (b1))\n+\t      else if (insn == b1->end)\n \t\t{\n \t\t  /* We took insns from the end of the basic block,\n \t\t     so update the end of block boundary so that it\n \t\t     points to the first insn we did not move.  */\n-\t\t  BLOCK_END (b1) = PREV_INSN (temp);\n+\t\t  b1->end = PREV_INSN (temp);\n \t\t}\n-\t      else if (temp == BLOCK_HEAD (b1))\n+\t      else if (temp == b1->head)\n \t\t{\n \t\t  /* We took insns from the start of the basic block,\n \t\t     so update the start of block boundary so that\n \t\t     it points to the first insn we did not move.  */\n-\t\t  BLOCK_HEAD (b1) = NEXT_INSN (insn);\n+\t\t  b1->head = NEXT_INSN (insn);\n \t\t}\n \t    }\n \t  else\n@@ -6858,25 +6863,22 @@ schedule_insns (dump_file)\n \n   split_all_insns (1);\n \n-  max_uid = (get_max_uid () + 1);\n+  /* We use LUID 0 for the fake insn (UID 0) which holds dependencies for\n+     pseudos which do not cross calls.  */\n+  max_uid = get_max_uid () + 1;\n \n   cant_move = xcalloc (max_uid, sizeof (char));\n   fed_by_spec_load = xcalloc (max_uid, sizeof (char));\n   is_load_insn = xcalloc (max_uid, sizeof (char));\n \n-  insn_orig_block = (int *) xmalloc (max_uid * sizeof (int));\n   insn_luid = (int *) xmalloc (max_uid * sizeof (int));\n \n-  /* We use LUID 0 for the fake insn (UID 0) which holds dependencies for\n-     pseudos which do not cross calls.  */\n   insn_luid[0] = 0;\n   luid = 1;\n   for (b = 0; b < n_basic_blocks; b++)\n     for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n       {\n-\tINSN_BLOCK (insn) = b;\n \tINSN_LUID (insn) = luid++;\n-\n \tif (insn == BLOCK_END (b))\n \t  break;\n       }\n@@ -6899,6 +6901,8 @@ schedule_insns (dump_file)\n   block_to_bb = (int *) alloca ((n_basic_blocks) * sizeof (int));\n   containing_rgn = (int *) alloca ((n_basic_blocks) * sizeof (int));\n \n+  compute_bb_for_insn (max_uid);\n+\n   /* Compute regions for scheduling.  */\n   if (reload_completed\n       || n_basic_blocks == 1\n@@ -7068,7 +7072,6 @@ schedule_insns (dump_file)\n   free (cant_move);\n   free (fed_by_spec_load);\n   free (is_load_insn);\n-  free (insn_orig_block);\n   free (insn_luid);\n \n   free (insn_priority);"}, {"sha": "157f0df34ef248857b5ec1bf29e21473f2a1f597", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c88e82068294b20f55b8d4ca6b302d5486f9881b/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c88e82068294b20f55b8d4ca6b302d5486f9881b", "patch": "@@ -2659,6 +2659,7 @@ split_all_insns (upd_life)\n \n   if (changed && upd_life)\n     {\n+      compute_bb_for_insn (get_max_uid ());\n       count_or_remove_death_notes (blocks, 1);\n       update_life_info (blocks, UPDATE_LIFE_LOCAL);\n     }\n@@ -2759,6 +2760,7 @@ peephole2_optimize (dump_file)\n \n   free_resource_info ();\n \n+  compute_bb_for_insn (get_max_uid ());\n   count_or_remove_death_notes (blocks, 1);\n   update_life_info (blocks, UPDATE_LIFE_LOCAL);\n }"}]}