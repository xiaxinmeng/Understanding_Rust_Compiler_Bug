{"sha": "2803bc3bbca332f53801770715a5b592b2467492", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwM2JjM2JiY2EzMzJmNTM4MDE3NzA3MTVhNWI1OTJiMjQ2NzQ5Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-14T08:54:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-14T08:54:33Z"}, "message": "[AArch64] Handle more SVE predicate constants\n\nThis patch handles more predicate constants by using TRN1, TRN2\nand EOR.  For now, only one operation is allowed before we fall\nback to loading from memory or doing an integer move and a compare.\nThe EOR support includes the important special case of an inverted\npredicate.\n\nThe real motivating case for this is the ACLE svdupq function,\nwhich allows a repeating 16-bit predicate to be built from\nindividual scalar booleans.  It's not easy to test properly\nbefore that support is merged.\n\n2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_expand_sve_const_pred_eor)\n\t(aarch64_expand_sve_const_pred_trn): New functions.\n\t(aarch64_expand_sve_const_pred_1): Add a recurse_p parameter and\n\tuse the above functions when the parameter is true.\n\t(aarch64_expand_sve_const_pred): Update call accordingly.\n\t* config/aarch64/aarch64-sve.md (*aarch64_sve_<perm_insn><mode>):\n\tRename to...\n\t(@aarch64_sve_<perm_insn><mode>): ...this.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/peel_ind_1.c: Look for an inverted .B VL1.\n\t* gcc.target/aarch64/sve/peel_ind_2.c: Likewise .S VL7.\n\nFrom-SVN: r274434", "tree": {"sha": "548124933434638ccd4547c05bcd60c69cbb4924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/548124933434638ccd4547c05bcd60c69cbb4924"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2803bc3bbca332f53801770715a5b592b2467492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2803bc3bbca332f53801770715a5b592b2467492", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2803bc3bbca332f53801770715a5b592b2467492", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2803bc3bbca332f53801770715a5b592b2467492/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df4ac85fd90affab9a7108a8fab6454277ced0ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4ac85fd90affab9a7108a8fab6454277ced0ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4ac85fd90affab9a7108a8fab6454277ced0ab"}], "stats": {"total": 192, "additions": 188, "deletions": 4}, "files": [{"sha": "95da8b50e5054bdd7d6b09264d9db75e45712d6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803bc3bbca332f53801770715a5b592b2467492/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803bc3bbca332f53801770715a5b592b2467492/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2803bc3bbca332f53801770715a5b592b2467492", "patch": "@@ -1,3 +1,14 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_expand_sve_const_pred_eor)\n+\t(aarch64_expand_sve_const_pred_trn): New functions.\n+\t(aarch64_expand_sve_const_pred_1): Add a recurse_p parameter and\n+\tuse the above functions when the parameter is true.\n+\t(aarch64_expand_sve_const_pred): Update call accordingly.\n+\t* config/aarch64/aarch64-sve.md (*aarch64_sve_<perm_insn><mode>):\n+\tRename to...\n+\t(@aarch64_sve_<perm_insn><mode>): ...this.\n+\n 2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_sve_same_pred_for_ptest_p):"}, {"sha": "9893660cb53c5b3aa64dd309528ce65db13eb157", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=2803bc3bbca332f53801770715a5b592b2467492", "patch": "@@ -3676,7 +3676,7 @@\n \n ;; Permutes that take half the elements from one vector and half the\n ;; elements from the other.\n-(define_insn \"*aarch64_sve_<perm_insn><mode>\"\n+(define_insn \"@aarch64_sve_<perm_insn><mode>\"\n   [(set (match_operand:PRED_ALL 0 \"register_operand\" \"=Upa\")\n \t(unspec:PRED_ALL [(match_operand:PRED_ALL 1 \"register_operand\" \"Upa\")\n \t\t\t  (match_operand:PRED_ALL 2 \"register_operand\" \"Upa\")]"}, {"sha": "27a9a5fd28dc0a87fa44699da4a5aeed878d9a0f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 169, "deletions": 3, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=2803bc3bbca332f53801770715a5b592b2467492", "patch": "@@ -3751,13 +3751,163 @@ aarch64_sve_move_pred_via_while (rtx target, machine_mode mode,\n   return target;\n }\n \n+static rtx\n+aarch64_expand_sve_const_pred_1 (rtx, rtx_vector_builder &, bool);\n+\n+/* BUILDER is a constant predicate in which the index of every set bit\n+   is a multiple of ELT_SIZE (which is <= 8).  Try to load the constant\n+   by inverting every element at a multiple of ELT_SIZE and EORing the\n+   result with an ELT_SIZE PTRUE.\n+\n+   Return a register that contains the constant on success, otherwise\n+   return null.  Use TARGET as the register if it is nonnull and\n+   convenient.  */\n+\n+static rtx\n+aarch64_expand_sve_const_pred_eor (rtx target, rtx_vector_builder &builder,\n+\t\t\t\t   unsigned int elt_size)\n+{\n+  /* Invert every element at a multiple of ELT_SIZE, keeping the\n+     other bits zero.  */\n+  rtx_vector_builder inv_builder (VNx16BImode, builder.npatterns (),\n+\t\t\t\t  builder.nelts_per_pattern ());\n+  for (unsigned int i = 0; i < builder.encoded_nelts (); ++i)\n+    if ((i & (elt_size - 1)) == 0 && INTVAL (builder.elt (i)) == 0)\n+      inv_builder.quick_push (const1_rtx);\n+    else\n+      inv_builder.quick_push (const0_rtx);\n+  inv_builder.finalize ();\n+\n+  /* See if we can load the constant cheaply.  */\n+  rtx inv = aarch64_expand_sve_const_pred_1 (NULL_RTX, inv_builder, false);\n+  if (!inv)\n+    return NULL_RTX;\n+\n+  /* EOR the result with an ELT_SIZE PTRUE.  */\n+  rtx mask = aarch64_ptrue_all (elt_size);\n+  mask = force_reg (VNx16BImode, mask);\n+  target = aarch64_target_reg (target, VNx16BImode);\n+  emit_insn (gen_aarch64_pred_z (XOR, VNx16BImode, target, mask, inv, mask));\n+  return target;\n+}\n+\n+/* BUILDER is a constant predicate in which the index of every set bit\n+   is a multiple of ELT_SIZE (which is <= 8).  Try to load the constant\n+   using a TRN1 of size PERMUTE_SIZE, which is >= ELT_SIZE.  Return the\n+   register on success, otherwise return null.  Use TARGET as the register\n+   if nonnull and convenient.  */\n+\n+static rtx\n+aarch64_expand_sve_const_pred_trn (rtx target, rtx_vector_builder &builder,\n+\t\t\t\t   unsigned int elt_size,\n+\t\t\t\t   unsigned int permute_size)\n+{\n+  /* We're going to split the constant into two new constants A and B,\n+     with element I of BUILDER going into A if (I & PERMUTE_SIZE) == 0\n+     and into B otherwise.  E.g. for PERMUTE_SIZE == 4 && ELT_SIZE == 1:\n+\n+     A: { 0, 1, 2, 3, _, _, _, _, 8, 9, 10, 11, _, _, _, _ }\n+     B: { 4, 5, 6, 7, _, _, _, _, 12, 13, 14, 15, _, _, _, _ }\n+\n+     where _ indicates elements that will be discarded by the permute.\n+\n+     First calculate the ELT_SIZEs for A and B.  */\n+  unsigned int a_elt_size = GET_MODE_SIZE (DImode);\n+  unsigned int b_elt_size = GET_MODE_SIZE (DImode);\n+  for (unsigned int i = 0; i < builder.encoded_nelts (); i += elt_size)\n+    if (INTVAL (builder.elt (i)) != 0)\n+      {\n+\tif (i & permute_size)\n+\t  b_elt_size |= i - permute_size;\n+\telse\n+\t  a_elt_size |= i;\n+      }\n+  a_elt_size &= -a_elt_size;\n+  b_elt_size &= -b_elt_size;\n+\n+  /* Now construct the vectors themselves.  */\n+  rtx_vector_builder a_builder (VNx16BImode, builder.npatterns (),\n+\t\t\t\tbuilder.nelts_per_pattern ());\n+  rtx_vector_builder b_builder (VNx16BImode, builder.npatterns (),\n+\t\t\t\tbuilder.nelts_per_pattern ());\n+  unsigned int nelts = builder.encoded_nelts ();\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    if (i & (elt_size - 1))\n+      {\n+\ta_builder.quick_push (const0_rtx);\n+\tb_builder.quick_push (const0_rtx);\n+      }\n+    else if ((i & permute_size) == 0)\n+      {\n+\t/* The A and B elements are significant.  */\n+\ta_builder.quick_push (builder.elt (i));\n+\tb_builder.quick_push (builder.elt (i + permute_size));\n+      }\n+    else\n+      {\n+\t/* The A and B elements are going to be discarded, so pick whatever\n+\t   is likely to give a nice constant.  We are targeting element\n+\t   sizes A_ELT_SIZE and B_ELT_SIZE for A and B respectively,\n+\t   with the aim of each being a sequence of ones followed by\n+\t   a sequence of zeros.  So:\n+\n+\t   * if X_ELT_SIZE <= PERMUTE_SIZE, the best approach is to\n+\t     duplicate the last X_ELT_SIZE element, to extend the\n+\t     current sequence of ones or zeros.\n+\n+\t   * if X_ELT_SIZE > PERMUTE_SIZE, the best approach is to add a\n+\t     zero, so that the constant really does have X_ELT_SIZE and\n+\t     not a smaller size.  */\n+\tif (a_elt_size > permute_size)\n+\t  a_builder.quick_push (const0_rtx);\n+\telse\n+\t  a_builder.quick_push (a_builder.elt (i - a_elt_size));\n+\tif (b_elt_size > permute_size)\n+\t  b_builder.quick_push (const0_rtx);\n+\telse\n+\t  b_builder.quick_push (b_builder.elt (i - b_elt_size));\n+      }\n+  a_builder.finalize ();\n+  b_builder.finalize ();\n+\n+  /* Try loading A into a register.  */\n+  rtx_insn *last = get_last_insn ();\n+  rtx a = aarch64_expand_sve_const_pred_1 (NULL_RTX, a_builder, false);\n+  if (!a)\n+    return NULL_RTX;\n+\n+  /* Try loading B into a register.  */\n+  rtx b = a;\n+  if (a_builder != b_builder)\n+    {\n+      b = aarch64_expand_sve_const_pred_1 (NULL_RTX, b_builder, false);\n+      if (!b)\n+\t{\n+\t  delete_insns_since (last);\n+\t  return NULL_RTX;\n+\t}\n+    }\n+\n+  /* Emit the TRN1 itself.  */\n+  machine_mode mode = aarch64_sve_pred_mode (permute_size).require ();\n+  target = aarch64_target_reg (target, mode);\n+  emit_insn (gen_aarch64_sve (UNSPEC_TRN1, mode, target,\n+\t\t\t      gen_lowpart (mode, a),\n+\t\t\t      gen_lowpart (mode, b)));\n+  return target;\n+}\n+\n /* Subroutine of aarch64_expand_sve_const_pred.  Try to load the VNx16BI\n    constant in BUILDER into an SVE predicate register.  Return the register\n    on success, otherwise return null.  Use TARGET for the register if\n-   nonnull and convenient.  */\n+   nonnull and convenient.\n+\n+   ALLOW_RECURSE_P is true if we can use methods that would call this\n+   function recursively.  */\n \n static rtx\n-aarch64_expand_sve_const_pred_1 (rtx target, rtx_vector_builder &builder)\n+aarch64_expand_sve_const_pred_1 (rtx target, rtx_vector_builder &builder,\n+\t\t\t\t bool allow_recurse_p)\n {\n   if (builder.encoded_nelts () == 1)\n     /* A PFALSE or a PTRUE .B ALL.  */\n@@ -3775,6 +3925,22 @@ aarch64_expand_sve_const_pred_1 (rtx target, rtx_vector_builder &builder)\n       return aarch64_sve_move_pred_via_while (target, mode, vl);\n     }\n \n+  if (!allow_recurse_p)\n+    return NULL_RTX;\n+\n+  /* Try inverting the vector in element size ELT_SIZE and then EORing\n+     the result with an ELT_SIZE PTRUE.  */\n+  if (INTVAL (builder.elt (0)) == 0)\n+    if (rtx res = aarch64_expand_sve_const_pred_eor (target, builder,\n+\t\t\t\t\t\t     elt_size))\n+      return res;\n+\n+  /* Try using TRN1 to permute two simpler constants.  */\n+  for (unsigned int i = elt_size; i <= 8; i *= 2)\n+    if (rtx res = aarch64_expand_sve_const_pred_trn (target, builder,\n+\t\t\t\t\t\t     elt_size, i))\n+      return res;\n+\n   return NULL_RTX;\n }\n \n@@ -3789,7 +3955,7 @@ static rtx\n aarch64_expand_sve_const_pred (rtx target, rtx_vector_builder &builder)\n {\n   /* Try loading the constant using pure predicate operations.  */\n-  if (rtx res = aarch64_expand_sve_const_pred_1 (target, builder))\n+  if (rtx res = aarch64_expand_sve_const_pred_1 (target, builder, true))\n     return res;\n \n   /* Try forcing the constant to memory.  */"}, {"sha": "db38df3766bbbf635fe84d653022019104c5976f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2803bc3bbca332f53801770715a5b592b2467492", "patch": "@@ -1,3 +1,8 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/peel_ind_1.c: Look for an inverted .B VL1.\n+\t* gcc.target/aarch64/sve/peel_ind_2.c: Likewise .S VL7.\n+\n 2019-08-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/parse/typedef9.C: Test locations too."}, {"sha": "156d04ae5ca222ddea3e12a3b785050c6113a548", "filename": "gcc/testsuite/gcc.target/aarch64/sve/peel_ind_1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpeel_ind_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpeel_ind_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpeel_ind_1.c?ref=2803bc3bbca332f53801770715a5b592b2467492", "patch": "@@ -25,3 +25,4 @@ foo (void)\n /* We should use an induction that starts at -5, with only the last\n    7 elements of the first iteration being active.  */\n /* { dg-final { scan-assembler {\\tindex\\tz[0-9]+\\.s, #-5, #5\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\t(p[0-9]+\\.b), vl1\\n.*\\tnot\\tp[0-7]\\.b, p[0-7]/z, \\1\\n} } } */"}, {"sha": "e792cdf2cad297e7044fdecd576343c9ac212078", "filename": "gcc/testsuite/gcc.target/aarch64/sve/peel_ind_2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpeel_ind_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803bc3bbca332f53801770715a5b592b2467492/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpeel_ind_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpeel_ind_2.c?ref=2803bc3bbca332f53801770715a5b592b2467492", "patch": "@@ -20,3 +20,4 @@ foo (void)\n /* { dg-final { scan-assembler {\\t(adrp|adr)\\tx[0-9]+, x\\n} } } */\n /* We should unroll the loop three times.  */\n /* { dg-final { scan-assembler-times \"\\tst1w\\t\" 3 } } */\n+/* { dg-final { scan-assembler {\\tptrue\\t(p[0-9]+)\\.s, vl7\\n.*\\teor\\tp[0-7]\\.b, (p[0-7])/z, (\\1\\.b, \\2\\.b|\\2\\.b, \\1\\.b)\\n} } } */"}]}