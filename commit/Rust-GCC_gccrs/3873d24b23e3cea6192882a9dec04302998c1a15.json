{"sha": "3873d24b23e3cea6192882a9dec04302998c1a15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg3M2QyNGIyM2UzY2VhNjE5Mjg4MmE5ZGVjMDQzMDI5OThjMWExNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-09-20T19:11:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-09-20T19:11:13Z"}, "message": "alpha.c (alpha_sr_alias_set): New variable.\n\n        * alpha.c (alpha_sr_alias_set): New variable.\n        (override_options): Set it.\n        (alpha_expand_prologue, alpha_expand_epilogue): Use it.\n        (mode_mask_operand): Fix signed-unsigned comparision warning.\n        (alpha_expand_block_move): Likewise.\n        (print_operand): Likewise.\n        (get_aligned_mem): Use change_address.\n        (alpha_set_memflags, alpha_set_memflags_1): Set the alias set.\n        (alphaev4_insn_pipe, alphaev4_next_group): New functions.\n        (alphaev4_next_nop, alphaev5_next_nop): New functions.\n        (alpha_align_insns): Remade from old alphaev5_align_insns\n        to handle multiple processors.\n        (alpha_reorg): Call alpha_align_insns for both ev4 and ev5.\n        * output.h (label_to_alignment): Prototype.\n\nFrom-SVN: r22505", "tree": {"sha": "74fa371b606fe8fd703ad7ccf687e2ab602fdcde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74fa371b606fe8fd703ad7ccf687e2ab602fdcde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3873d24b23e3cea6192882a9dec04302998c1a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3873d24b23e3cea6192882a9dec04302998c1a15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3873d24b23e3cea6192882a9dec04302998c1a15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3873d24b23e3cea6192882a9dec04302998c1a15/comments", "author": null, "committer": null, "parents": [{"sha": "2ba573431ea23d88372e6c40a7652046d8afbd54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba573431ea23d88372e6c40a7652046d8afbd54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba573431ea23d88372e6c40a7652046d8afbd54"}], "stats": {"total": 423, "additions": 338, "deletions": 85}, "files": [{"sha": "efc4457668be0b14954836467998f92b35003a57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3873d24b23e3cea6192882a9dec04302998c1a15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3873d24b23e3cea6192882a9dec04302998c1a15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3873d24b23e3cea6192882a9dec04302998c1a15", "patch": "@@ -1,5 +1,20 @@\n Sun Sep 20 19:01:51 1998  Richard Henderson  <rth@cygnus.com>\n \n+\t* alpha.c (alpha_sr_alias_set): New variable.\n+\t(override_options): Set it.\n+\t(alpha_expand_prologue, alpha_expand_epilogue): Use it.\n+\t(mode_mask_operand): Fix signed-unsigned comparision warning.\n+\t(alpha_expand_block_move): Likewise.\n+\t(print_operand): Likewise.\n+\t(get_aligned_mem): Use change_address.\n+\t(alpha_set_memflags, alpha_set_memflags_1): Set the alias set.\n+\t(alphaev4_insn_pipe, alphaev4_next_group): New functions.\n+\t(alphaev4_next_nop, alphaev5_next_nop): New functions.\n+\t(alpha_align_insns): Remade from old alphaev5_align_insns\n+\tto handle multiple processors.\n+\t(alpha_reorg): Call alpha_align_insns for both ev4 and ev5.\n+\t* output.h (label_to_alignment): Prototype.\n+\n         * tree.c (new_alias_set): New function.\n         * tree.h (new_alias_set): Declare it.\n         * c-common.c (c_get_alias_set): Use it."}, {"sha": "d8f71ad423065f5e6cf7b0b989b83e9e11262b4d", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 319, "deletions": 85, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3873d24b23e3cea6192882a9dec04302998c1a15/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3873d24b23e3cea6192882a9dec04302998c1a15/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=3873d24b23e3cea6192882a9dec04302998c1a15", "patch": "@@ -100,9 +100,13 @@ int alpha_memory_latency = 3;\n \n static int alpha_function_needs_gp;\n \n+/* The alias set for prologue/epilogue register save/restore.  */\n+\n+static int alpha_sr_alias_set;\n+\n /* Declarations of static functions.  */\n static void alpha_set_memflags_1\n-  PROTO((rtx, int, int, int));\n+  PROTO((rtx, int, int, int, int));\n static rtx alpha_emit_set_const_1\n   PROTO((rtx, enum machine_mode, HOST_WIDE_INT, int));\n static void alpha_expand_unaligned_load_words\n@@ -302,6 +306,9 @@ override_options ()\n   /* Default the definition of \"small data\" to 8 bytes.  */\n   if (!g_switch_set)\n     g_switch_value = 8;\n+\n+  /* Acquire a unique set number for our register saves and restores.  */\n+  alpha_sr_alias_set = new_alias_set ();\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -487,9 +494,9 @@ mode_mask_operand (op, mode)\n   return (GET_CODE (op) == CONST_INT\n \t  && (INTVAL (op) == 0xff\n \t      || INTVAL (op) == 0xffff\n-\t      || INTVAL (op) == 0xffffffff\n+\t      || INTVAL (op) == (HOST_WIDE_INT)0xffffffff\n #if HOST_BITS_PER_WIDE_INT == 64\n-\t      || INTVAL (op) == 0xffffffffffffffff\n+\t      || INTVAL (op) == -1\n #endif\n \t      ));\n }\n@@ -870,11 +877,8 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n \n-  *paligned_mem = gen_rtx_MEM (SImode,\n-\t\t\t   plus_constant (base, offset & ~3));\n-  MEM_IN_STRUCT_P (*paligned_mem) = MEM_IN_STRUCT_P (ref);\n-  MEM_VOLATILE_P (*paligned_mem) = MEM_VOLATILE_P (ref);\n-  RTX_UNCHANGING_P (*paligned_mem) = RTX_UNCHANGING_P (ref);\n+  *paligned_mem = change_address (ref, SImode, \n+\t\t\t\t  plus_constant (base, offset & ~3));\n \n   *pbitnum = GEN_INT ((offset & 3) * 8);\n }\n@@ -918,9 +922,9 @@ get_unaligned_address (ref, extra_offset)\n    found in part of X.  */\n \n static void\n-alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n+alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p, alias_set)\n      rtx x;\n-     int in_struct_p, volatile_p, unchanging_p;\n+     int in_struct_p, volatile_p, unchanging_p, alias_set;\n {\n   int i;\n \n@@ -930,25 +934,26 @@ alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n     case PARALLEL:\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \talpha_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p,\n-\t\t\t      unchanging_p);\n+\t\t\t      unchanging_p, alias_set);\n       break;\n \n     case INSN:\n       alpha_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p);\n+\t\t\t    unchanging_p, alias_set);\n       break;\n \n     case SET:\n       alpha_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p);\n+\t\t\t    unchanging_p, alias_set);\n       alpha_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p);\n+\t\t\t    unchanging_p, alias_set);\n       break;\n \n     case MEM:\n       MEM_IN_STRUCT_P (x) = in_struct_p;\n       MEM_VOLATILE_P (x) = volatile_p;\n       RTX_UNCHANGING_P (x) = unchanging_p;\n+      MEM_ALIAS_SET (x) = alias_set;\n       break;\n \n     default:\n@@ -967,17 +972,24 @@ alpha_set_memflags (insn, ref)\n      rtx insn;\n      rtx ref;\n {\n-  /* Note that it is always safe to get these flags, though they won't\n-     be what we think if REF is not a MEM.  */\n-  int in_struct_p = MEM_IN_STRUCT_P (ref);\n-  int volatile_p = MEM_VOLATILE_P (ref);\n-  int unchanging_p = RTX_UNCHANGING_P (ref);\n-\n-  if (GET_CODE (ref) != MEM\n-      || (! in_struct_p && ! volatile_p && ! unchanging_p))\n+  int in_struct_p, volatile_p, unchanging_p, alias_set;\n+\n+  if (GET_CODE (ref) != MEM)\n     return;\n \n-  alpha_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p);\n+  in_struct_p = MEM_IN_STRUCT_P (ref);\n+  volatile_p = MEM_VOLATILE_P (ref);\n+  unchanging_p = RTX_UNCHANGING_P (ref);\n+  alias_set = MEM_ALIAS_SET (ref);\n+\n+  /* This is only called from alpha.md, after having had something \n+     generated from one of the insn patterns.  So if everything is\n+     zero, the pattern is already up-to-date.  */\n+  if (! in_struct_p && ! volatile_p && ! unchanging_p && ! alias_set)\n+    return;\n+\n+  alpha_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p,\n+\t\t\talias_set);\n }\n \f\n /* Try to output insns to set TARGET equal to the constant C if it can be\n@@ -1979,7 +1991,7 @@ alpha_expand_block_move (operands)\n     }\n  src_done:\n \n-  if (nregs > sizeof(data_regs)/sizeof(*data_regs))\n+  if (nregs > (int)(sizeof(data_regs)/sizeof(*data_regs)))\n     abort();\n \n   /*\n@@ -2730,7 +2742,7 @@ print_operand (file, x, code)\n \t       && CONST_DOUBLE_LOW (x) == -1)\n \tfprintf (file, \"q\");\n #else\n-      else if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0xffffffffffffffff)\n+      else if (GET_CODE (x) == CONST_INT && INTVAL (x) == -1)\n \tfprintf (file, \"q\");\n       else if (GET_CODE (x) == CONST_DOUBLE\n \t       && CONST_DOUBLE_HIGH (x) == 0\n@@ -3253,7 +3265,7 @@ alpha_expand_prologue ()\n   HOST_WIDE_INT frame_size;\n   /* Offset from base reg to register save area.  */\n   HOST_WIDE_INT reg_offset;\n-  rtx sa_reg;\n+  rtx sa_reg, mem;\n   int i;\n \n   sa_size = alpha_sa_size ();\n@@ -3367,16 +3379,17 @@ alpha_expand_prologue ()\n   /* Save regs in stack order.  Beginning with VMS PV.  */\n   if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n     {\n-      FRP (emit_move_insn (gen_rtx_MEM (DImode, stack_pointer_rtx),\n-\t\t           gen_rtx_REG (DImode, REG_PV)));\n+      mem = gen_rtx_MEM (DImode, stack_pointer_rtx);\n+      MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_PV)));\n     }\n \n   /* Save register RA next.  */\n   if (imask & (1L << REG_RA))\n     {\n-      FRP (emit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t\tplus_constant (sa_reg, reg_offset)),\n-\t\t           gen_rtx_REG (DImode, REG_RA)));\n+      mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n+      MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n       imask &= ~(1L << REG_RA);\n       reg_offset += 8;\n     }\n@@ -3385,18 +3398,18 @@ alpha_expand_prologue ()\n   for (i = 0; i < 32; i++)\n     if (imask & (1L << i))\n       {\n-\tFRP (emit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t          plus_constant (sa_reg, reg_offset)),\n-\t\t\t     gen_rtx_REG (DImode, i)));\n+\tmem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n+\tMEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\tFRP (emit_move_insn (mem, gen_rtx_REG (DImode, i)));\n \treg_offset += 8;\n       }\n \n   for (i = 0; i < 32; i++)\n     if (fmask & (1L << i))\n       {\n-\tFRP (emit_move_insn (gen_rtx_MEM (DFmode,\n-\t\t\t\t          plus_constant (sa_reg, reg_offset)),\n-\t\t\t     gen_rtx_REG (DFmode, i+32)));\n+\tmem = gen_rtx_MEM (DFmode, plus_constant (sa_reg, reg_offset));\n+\tMEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\tFRP (emit_move_insn (mem, gen_rtx_REG (DFmode, i+32)));\n \treg_offset += 8;\n       }\n \n@@ -3675,7 +3688,7 @@ alpha_expand_epilogue ()\n   HOST_WIDE_INT reg_offset;\n   int fp_is_frame_pointer, fp_offset;\n   rtx sa_reg, sa_reg_exp = NULL;\n-  rtx sp_adj1, sp_adj2;\n+  rtx sp_adj1, sp_adj2, mem;\n   int i;\n \n   sa_size = alpha_sa_size ();\n@@ -3734,10 +3747,9 @@ alpha_expand_epilogue ()\n \n       if (! alpha_eh_epilogue_sp_ofs)\n \t{\n-          FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA),\n-\t\t               gen_rtx_MEM (DImode,\n-\t\t\t\t\t    plus_constant(sa_reg,\n-\t\t\t\t\t\t\t  reg_offset))));\n+\t  mem = gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset));\n+\t  MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+          FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n \t}\n       reg_offset += 8;\n       imask &= ~(1L << REG_RA);\n@@ -3749,21 +3761,19 @@ alpha_expand_epilogue ()\n \t      fp_offset = reg_offset;\n \t    else\n \t      {\n-\t\tFRP (emit_move_insn (gen_rtx_REG (DImode, i),\n-\t\t\t\t     gen_rtx_MEM (DImode,\n-\t\t\t\t\t          plus_constant(sa_reg,\n-\t\t\t\t\t\t                reg_offset))));\n+\t\tmem = gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset));\n+\t\tMEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\t\tFRP (emit_move_insn (gen_rtx_REG (DImode, i), mem));\n \t      }\n \t    reg_offset += 8;\n \t  }\n \n       for (i = 0; i < 32; ++i)\n \tif (fmask & (1L << i))\n \t  {\n-\t    FRP (emit_move_insn (gen_rtx_REG (DFmode, i+32),\n-\t\t\t         gen_rtx_MEM (DFmode,\n-\t\t\t\t\t      plus_constant(sa_reg,\n-\t\t\t\t\t\t\t    reg_offset))));\n+\t    mem = gen_rtx_MEM (DFmode, plus_constant(sa_reg, reg_offset));\n+\t    MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\t    FRP (emit_move_insn (gen_rtx_REG (DFmode, i+32), mem));\n \t    reg_offset += 8;\n \t  }\n     }\n@@ -3820,9 +3830,9 @@ alpha_expand_epilogue ()\n       if (fp_is_frame_pointer)\n \t{\n \t  emit_insn (gen_blockage ());\n-\t  FRP (emit_move_insn (hard_frame_pointer_rtx,\n-\t\t\t       gen_rtx_MEM (DImode,\n-\t\t\t\t            plus_constant(sa_reg, fp_offset))));\n+\t  mem = gen_rtx_MEM (DImode, plus_constant(sa_reg, fp_offset));\n+\t  MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+\t  FRP (emit_move_insn (hard_frame_pointer_rtx, mem));\n \t}\n       else if (TARGET_OPEN_VMS)\n \t{\n@@ -4281,6 +4291,13 @@ alpha_handle_trap_shadows (insns)\n /* Alpha can only issue instruction groups simultaneously if they are\n    suitibly aligned.  This is very processor-specific.  */\n \n+enum alphaev4_pipe {\n+  EV4_STOP = 0,\n+  EV4_IB0 = 1,\n+  EV4_IB1 = 2,\n+  EV4_IBX = 4\n+};\n+\n enum alphaev5_pipe {\n   EV5_STOP = 0,\n   EV5_NONE = 1,\n@@ -4292,6 +4309,58 @@ enum alphaev5_pipe {\n   EV5_FM = 64\n };\n \n+static enum alphaev4_pipe alphaev4_insn_pipe PROTO((rtx));\n+static enum alphaev5_pipe alphaev5_insn_pipe PROTO((rtx));\n+static rtx alphaev4_next_group PROTO((rtx, int*, int*));\n+static rtx alphaev5_next_group PROTO((rtx, int*, int*));\n+static rtx alphaev4_next_nop PROTO((int*));\n+static rtx alphaev5_next_nop PROTO((int*));\n+\n+static void alpha_align_insns\n+  PROTO((rtx, int, rtx (*)(rtx, int*, int*), rtx (*)(int*), int));\n+\n+static enum alphaev4_pipe\n+alphaev4_insn_pipe (insn)\n+     rtx insn;\n+{\n+  if (recog_memoized (insn) < 0)\n+    return EV4_STOP;\n+  if (get_attr_length (insn) != 4)\n+    return EV4_STOP;\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_ILD:\n+    case TYPE_FLD:\n+      return EV4_IBX;\n+\n+    case TYPE_LDSYM:\n+    case TYPE_IADD:\n+    case TYPE_ILOG:\n+    case TYPE_ICMOV:\n+    case TYPE_ICMP:\n+    case TYPE_IST:\n+    case TYPE_FST:\n+    case TYPE_SHIFT:\n+    case TYPE_IMUL:\n+    case TYPE_FBR:\n+      return EV4_IB0;\n+\n+    case TYPE_MISC:\n+    case TYPE_IBR:\n+    case TYPE_JSR:\n+    case TYPE_FCPYS:\n+    case TYPE_FCMOV:\n+    case TYPE_FADD:\n+    case TYPE_FDIV:\n+    case TYPE_FMUL:\n+      return EV4_IB1;\n+\n+    default:\n+      abort();\n+    }\n+}\n+\n static enum alphaev5_pipe\n alphaev5_insn_pipe (insn)\n      rtx insn;\n@@ -4341,10 +4410,109 @@ alphaev5_insn_pipe (insn)\n     }\n }\n \n-/* IN_USE is a mask of the slots currently filled within the\n-   insn group.  The mask bits come from alphaev5_pipe above.\n-   If EV5_E01 is set, then the insn in EV5_E0 can be swapp\n-   by the hardware into EV5_E1. \n+/* IN_USE is a mask of the slots currently filled within the insn group. \n+   The mask bits come from alphaev4_pipe above.  If EV4_IBX is set, then\n+   the insn in EV4_IB0 can be swapped by the hardware into EV4_IB1. \n+\n+   LEN is, of course, the length of the group in bytes.  */\n+\n+static rtx\n+alphaev4_next_group (insn, pin_use, plen)\n+     rtx insn;\n+     int *pin_use, *plen;\n+{\n+  int len, in_use;\n+\n+  len = in_use = 0;\n+\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i'\n+      || GET_CODE (PATTERN (insn)) == CLOBBER\n+      || GET_CODE (PATTERN (insn)) == USE)\n+    goto next_and_done;\n+\n+  while (1)\n+    {\n+      enum alphaev4_pipe pipe;\n+\n+      pipe = alphaev4_insn_pipe (insn);\n+      switch (pipe)\n+\t{\n+\tcase EV4_STOP:\n+\t  /* Force complex instructions to start new groups.  */\n+\t  if (in_use)\n+\t    goto done;\n+\n+\t  /* If this is a completely unrecognized insn, its an asm.\n+\t     We don't know how long it is, so record length as -1 to\n+\t     signal a needed realignment.  */\n+\t  if (recog_memoized (insn) < 0)\n+\t    len = -1;\n+\t  else\n+\t    len = get_attr_length (insn);\n+\t  goto next_and_done;\n+\n+\tcase EV4_IBX:\n+\t  if (in_use & EV4_IB0)\n+\t    {\n+\t      if (in_use & EV4_IB1)\n+\t\tgoto done;\n+\t      in_use |= EV4_IB1;\n+\t    }\n+\t  else\n+\t    in_use |= EV4_IB0 | EV4_IBX;\n+\t  break;\n+\n+\tcase EV4_IB0:\n+\t  if (in_use & EV4_IB0)\n+\t    {\n+\t      if (!(in_use & EV4_IBX) || (in_use & EV4_IB1))\n+\t\tgoto done;\n+\t      in_use |= EV4_IB1;\n+\t    }\n+\t  in_use |= EV4_IB0;\n+\t  break;\n+\n+\tcase EV4_IB1:\n+\t  if (in_use & EV4_IB1)\n+\t    goto done;\n+\t  in_use |= EV4_IB1;\n+\t  break;\n+\n+\tdefault:\n+\t  abort();\n+\t}\n+      len += 4;\n+      \n+      /* Haifa doesn't do well scheduling branches.  */\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\tgoto next_and_done;\n+\n+    next:\n+      insn = next_nonnote_insn (insn);\n+\n+      if (!insn || GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tgoto done;\n+\n+      /* Let Haifa tell us where it thinks insn group boundaries are.  */\n+      if (GET_MODE (insn) == TImode)\n+\tgoto done;\n+\n+      if (GET_CODE (insn) == CLOBBER || GET_CODE (insn) == USE)\n+\tgoto next;\n+    }\n+\n+ next_and_done:\n+  insn = next_nonnote_insn (insn);\n+\n+ done:\n+  *plen = len;\n+  *pin_use = in_use;\n+  return insn;\n+}\n+\n+/* IN_USE is a mask of the slots currently filled within the insn group. \n+   The mask bits come from alphaev5_pipe above.  If EV5_E01 is set, then\n+   the insn in EV5_E0 can be swapped by the hardware into EV5_E1. \n \n    LEN is, of course, the length of the group in bytes.  */\n \n@@ -4402,7 +4570,7 @@ alphaev5_next_group (insn, pin_use, plen)\n \tcase EV5_E0:\n \t  if (in_use & EV5_E0)\n \t    {\n-\t      if (!(in_use & EV5_E01) || in_use & EV5_E1)\n+\t      if (!(in_use & EV5_E01) || (in_use & EV5_E1))\n \t\tgoto done;\n \t      in_use |= EV5_E1;\n \t    }\n@@ -4475,9 +4643,73 @@ alphaev5_next_group (insn, pin_use, plen)\n   return insn;\n }\n \n+static rtx\n+alphaev4_next_nop (pin_use)\n+     int *pin_use;\n+{\n+  int in_use = *pin_use;\n+  rtx nop;\n+\n+  if (!(in_use & EV4_IB0))\n+    {\n+      in_use |= EV4_IB0;\n+      nop = gen_nop ();\n+    }\n+  else if ((in_use & (EV4_IBX|EV4_IB1)) == EV4_IBX)\n+    {\n+      in_use |= EV4_IB1;\n+      nop = gen_nop ();\n+    }\n+  else if (TARGET_FP && !(in_use & EV4_IB1))\n+    {\n+      in_use |= EV4_IB1;\n+      nop = gen_fnop ();\n+    }\n+  else\n+    nop = gen_unop ();\n+\n+  *pin_use = in_use;\n+  return nop;\n+}\n+\n+static rtx\n+alphaev5_next_nop (pin_use)\n+     int *pin_use;\n+{\n+  int in_use = *pin_use;\n+  rtx nop;\n+\n+  if (!(in_use & EV5_E1))\n+    {\n+      in_use |= EV5_E1;\n+      nop = gen_nop ();\n+    }\n+  else if (TARGET_FP && !(in_use & EV5_FA))\n+    {\n+      in_use |= EV5_FA;\n+      nop = gen_fnop ();\n+    }\n+  else if (TARGET_FP && !(in_use & EV5_FM))\n+    {\n+      in_use |= EV5_FM;\n+      nop = gen_fnop ();\n+    }\n+  else\n+    nop = gen_unop ();\n+\n+  *pin_use = in_use;\n+  return nop;\n+}\n+\n+/* The instruction group alignment main loop.  */\n+\n static void\n-alphaev5_align_insns (insns)\n+alpha_align_insns (insns, max_align, next_group, next_nop, gp_in_use)\n      rtx insns;\n+     int max_align;\n+     rtx (*next_group) PROTO((rtx, int*, int*));\n+     rtx (*next_nop) PROTO((int*));\n+     int gp_in_use;\n {\n   /* ALIGN is the known alignment for the insn group.  */\n   int align;\n@@ -4489,30 +4721,33 @@ alphaev5_align_insns (insns)\n   /* Let shorten branches care for assigning alignments to code labels.  */\n   shorten_branches (insns);\n \n+  /* Account for the initial GP load, which happens before the scheduled\n+     prologue we emitted as RTL.  */\n   ofs = prev_in_use = 0;\n   if (alpha_does_function_need_gp())\n     {\n       ofs = 8;\n-      prev_in_use = EV5_E01 | EV5_E0;\n+      prev_in_use = gp_in_use;\n     }\n-  align = (FUNCTION_BOUNDARY/BITS_PER_UNIT < 16\n-\t   ? FUNCTION_BOUNDARY/BITS_PER_UNIT : 16);\n+\n+  align = (FUNCTION_BOUNDARY/BITS_PER_UNIT < max_align\n+\t   ? FUNCTION_BOUNDARY/BITS_PER_UNIT : max_align);\n \n   i = insns;\n   if (GET_CODE (i) == NOTE)\n     i = next_nonnote_insn (i);\n \n   while (i)\n     {\n-      next = alphaev5_next_group (i, &in_use, &len);\n+      next = (*next_group)(i, &in_use, &len);\n \n       /* When we see a label, resync alignment etc.  */\n       if (GET_CODE (i) == CODE_LABEL)\n \t{\n \t  int new_align = 1 << label_to_alignment (i);\n \t  if (new_align >= align)\n \t    {\n-\t      align = new_align < 16 ? new_align : 16;\n+\t      align = new_align < max_align ? new_align : max_align;\n \t      ofs = 0;\n \t    }\n \t  else if (ofs & (new_align-1))\n@@ -4562,30 +4797,25 @@ alphaev5_align_insns (insns)\n \t  int nop_count = (align - ofs) / 4;\n \t  rtx where;\n \n+\t  /* Insert nops before labels and branches to truely merge the\n+\t     execution of the nops with the previous instruction group.  */\n \t  where = prev_nonnote_insn (i);\n-\t  if (!where || GET_CODE (where) != CODE_LABEL)\n-\t    where = i;\n-\n-\t  do \n+\t  if (where)\n \t    {\n-\t      if (!(prev_in_use & EV5_E1))\n-\t\t{\n-\t\t  prev_in_use |= EV5_E1;\n-\t\t  emit_insn_before (gen_nop(), where);\n-\t\t}\n-\t      else if (TARGET_FP && !(prev_in_use & EV5_FA))\n-\t\t{\n-\t\t  prev_in_use |= EV5_FA;\n-\t\t  emit_insn_before (gen_fnop(), where);\n-\t\t}\n-\t      else if (TARGET_FP && !(prev_in_use & EV5_FM))\n+\t      if (GET_CODE (where) == CODE_LABEL)\n \t\t{\n-\t\t  prev_in_use |= EV5_FM;\n-\t\t  emit_insn_before (gen_fnop(), where);\n+\t\t  rtx where2 = prev_nonnote_insn (where);\n+\t\t  if (where2 && GET_CODE (where2) == JUMP_INSN)\n+\t\t    where = where2;\n \t\t}\n-\t      else\n-\t\temit_insn_before (gen_unop(), where);\n+\t      else if (GET_CODE (where) != JUMP_INSN)\n+\t\twhere = i;\n \t    }\n+\t  else\n+\t    where = i;\n+\n+\t  do \n+\t    emit_insn_before ((*next_nop)(&prev_in_use), where);\n \t  while (--nop_count);\n \t  ofs = 0;\n \t}\n@@ -4614,8 +4844,12 @@ alpha_reorg (insns)\n       && alpha_tp != ALPHA_TP_INSN\n       && flag_schedule_insns_after_reload)\n     {\n-      if (alpha_cpu == PROCESSOR_EV5)\n-\talphaev5_align_insns (insns);\n+      if (alpha_cpu == PROCESSOR_EV4)\n+\talpha_align_insns (insns, 8, alphaev4_next_group,\n+\t\t\t   alphaev4_next_nop, EV4_IB0);\n+      else if (alpha_cpu == PROCESSOR_EV5)\n+\talpha_align_insns (insns, 16, alphaev5_next_group,\n+\t\t\t   alphaev5_next_nop, EV5_E01 | EV5_E0);\n     }\n #endif\n }"}, {"sha": "1d1a2afd8cd5e4dfaa935fd3429e22ea0089dfd4", "filename": "gcc/output.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3873d24b23e3cea6192882a9dec04302998c1a15/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3873d24b23e3cea6192882a9dec04302998c1a15/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=3873d24b23e3cea6192882a9dec04302998c1a15", "patch": "@@ -88,6 +88,10 @@ extern void output_asm_insn\tPROTO((char *, rtx *));\n    Defined in final.c.  */\n extern int insn_current_reference_address\tPROTO((rtx));\n \n+/* Find the alignment associated with a CODE_LABEL.\n+   Defined in final.c.  */\n+extern int label_to_alignment\tPROTO((rtx));\n+\n /* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\n extern void output_asm_label\tPROTO((rtx));\n "}]}