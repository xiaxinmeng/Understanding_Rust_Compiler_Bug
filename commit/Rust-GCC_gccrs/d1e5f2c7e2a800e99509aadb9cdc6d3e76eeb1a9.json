{"sha": "d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFlNWYyYzdlMmE4MDBlOTk1MDlhYWRiOWNkYzZkM2U3NmVlYjFhOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-12-09T20:00:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-12-09T20:00:07Z"}, "message": "Add jit-tempdir.{c|h}\n\ngcc/jit/ChangeLog:\n        PR jit/64206\n\t* Make-lang.in (jit_OBJS): Add jit/jit-tempdir.o.\n\t* jit-common.h (gcc::jit::tempdir): New forward decl.\n\t* jit-playback.c: Include jit-tempdir.h.\n\t(gcc::jit::playback::context::context): Initialize m_tempdir.\n\t(gcc::jit::playback::context::~context): Move tempdir\n\tcleanup to new file jit-tempdir.c\n\t(make_tempdir_path_template): Move to new file jit-tempdir.c.\n\t(gcc::jit::playback::context::compile): Move tempdir creation\n\tto new tempdir object in new file jit-tempdir.c.\n\t(gcc::jit::playback::context::make_fake_args): Get path from\n\ttempdir object rather than from member data.\n\t(gcc::jit::playback::context::convert_to_dso): Likewise.\n\t(gcc::jit::playback::context::dlopen_built_dso): Likewise.\n\t(gcc::jit::playback::context::dump_generated_code): Likewise.\n\t(gcc::jit::playback::context::get_path_c_file): New function.\n\t(gcc::jit::playback::context::get_path_s_file): New function.\n\t(gcc::jit::playback::context::get_path_so_file): New function.\n\t* jit-playback.h (gcc::jit::playback::context::get_path_c_file):\n\tNew function.\n\t(gcc::jit::playback::context::get_path_s_file): New function.\n\t(gcc::jit::playback::context::get_path_so_file): New function.\n\t(gcc::jit::playback::context): Move fields \"m_path_template\",\n\t\"m_path_tempdir\", \"m_path_c_file\", \"m_path_s_file\",\n\t\"m_path_so_file\" to new jit::tempdir class; add field \"m_tempdir\".\n\t* jit-tempdir.c: New file.\n\t* jit-tempdir.h: New file.\n\nFrom-SVN: r218533", "tree": {"sha": "83b8fc521cc13d74c7018f55655bf98202b25e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83b8fc521cc13d74c7018f55655bf98202b25e4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "661fce82a67307196182f81dd7d627d05aef4816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661fce82a67307196182f81dd7d627d05aef4816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/661fce82a67307196182f81dd7d627d05aef4816"}], "stats": {"total": 375, "additions": 292, "deletions": 83}, "files": [{"sha": "9a95c79fef2df4894a1008abe389f62457719d01", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "patch": "@@ -1,3 +1,33 @@\n+2014-12-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+        PR jit/64206\n+\t* Make-lang.in (jit_OBJS): Add jit/jit-tempdir.o.\n+\t* jit-common.h (gcc::jit::tempdir): New forward decl.\n+\t* jit-playback.c: Include jit-tempdir.h.\n+\t(gcc::jit::playback::context::context): Initialize m_tempdir.\n+\t(gcc::jit::playback::context::~context): Move tempdir\n+\tcleanup to new file jit-tempdir.c\n+\t(make_tempdir_path_template): Move to new file jit-tempdir.c.\n+\t(gcc::jit::playback::context::compile): Move tempdir creation\n+\tto new tempdir object in new file jit-tempdir.c.\n+\t(gcc::jit::playback::context::make_fake_args): Get path from\n+\ttempdir object rather than from member data.\n+\t(gcc::jit::playback::context::convert_to_dso): Likewise.\n+\t(gcc::jit::playback::context::dlopen_built_dso): Likewise.\n+\t(gcc::jit::playback::context::dump_generated_code): Likewise.\n+\t(gcc::jit::playback::context::get_path_c_file): New function.\n+\t(gcc::jit::playback::context::get_path_s_file): New function.\n+\t(gcc::jit::playback::context::get_path_so_file): New function.\n+\t* jit-playback.h (gcc::jit::playback::context::get_path_c_file):\n+\tNew function.\n+\t(gcc::jit::playback::context::get_path_s_file): New function.\n+\t(gcc::jit::playback::context::get_path_so_file): New function.\n+\t(gcc::jit::playback::context): Move fields \"m_path_template\",\n+\t\"m_path_tempdir\", \"m_path_c_file\", \"m_path_s_file\",\n+\t\"m_path_so_file\" to new jit::tempdir class; add field \"m_tempdir\".\n+\t* jit-tempdir.c: New file.\n+\t* jit-tempdir.h: New file.\n+\n 2014-12-09  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-playback.c (gcc::jit::playback::context::compile): Acquire the"}, {"sha": "818e14b10b3b7b4c3a2a6bfbb65add1f4576680b", "filename": "gcc/jit/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FMake-lang.in?ref=d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "patch": "@@ -65,6 +65,7 @@ jit_OBJS = attribs.o \\\n \tjit/jit-recording.o \\\n \tjit/jit-playback.o \\\n \tjit/jit-result.o \\\n+\tjit/jit-tempdir.o \\\n \tjit/jit-builtins.o\n \n # Use strict warnings for this front end."}, {"sha": "25c2c6f9fcc0e2da25bcf8447e265a6679eb4e3f", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "patch": "@@ -98,6 +98,7 @@ namespace jit {\n class result;\n class dump;\n class builtins_manager; // declared within jit-builtins.h\n+class tempdir;\n \n namespace recording {\n "}, {"sha": "84989005b446bc5d308d3734c436e656c00a2d24", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 45, "deletions": 73, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"jit-playback.h\"\n #include \"jit-result.h\"\n #include \"jit-builtins.h\"\n+#include \"jit-tempdir.h\"\n \n \n /* gcc::jit::playback::context::build_cast uses the convert.h API,\n@@ -86,6 +87,7 @@ namespace jit {\n \n playback::context::context (recording::context *ctxt)\n   : m_recording_ctxt (ctxt),\n+    m_tempdir (NULL),\n     m_char_array_type_node (NULL),\n     m_const_char_ptr (NULL)\n {\n@@ -98,25 +100,8 @@ playback::context::context (recording::context *ctxt)\n \n playback::context::~context ()\n {\n-  if (get_bool_option (GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES))\n-    fprintf (stderr, \"intermediate files written to %s\\n\", m_path_tempdir);\n-  else\n-    {\n-      /* Clean up .s/.so and tempdir. */\n-      if (m_path_s_file)\n-        unlink (m_path_s_file);\n-      if (m_path_so_file)\n-        unlink (m_path_so_file);\n-      if (m_path_tempdir)\n-        rmdir (m_path_tempdir);\n-    }\n-\n-  free (m_path_template);\n-  /* m_path_tempdir aliases m_path_template, or is NULL, so don't\n-     attempt to free it .  */\n-  free (m_path_c_file);\n-  free (m_path_s_file);\n-  free (m_path_so_file);\n+  if (m_tempdir)\n+    delete m_tempdir;\n   m_functions.release ();\n }\n \n@@ -1515,44 +1500,6 @@ block (function *func,\n   m_label_expr = NULL;\n }\n \n-/* Construct a tempdir path template suitable for use by mkdtemp\n-   e.g. \"/tmp/libgccjit-XXXXXX\", but respecting the rules in\n-   libiberty's choose_tempdir rather than hardcoding \"/tmp/\".\n-\n-   The memory is allocated using malloc and must be freed.\n-   Aborts the process if allocation fails. */\n-\n-static char *\n-make_tempdir_path_template ()\n-{\n-  const char *tmpdir_buf;\n-  size_t tmpdir_len;\n-  const char *file_template_buf;\n-  size_t file_template_len;\n-  char *result;\n-\n-  /* The result of choose_tmpdir is a cached buffer within libiberty, so\n-     we must *not* free it.  */\n-  tmpdir_buf = choose_tmpdir ();\n-\n-  /* choose_tmpdir aborts on malloc failure.  */\n-  gcc_assert (tmpdir_buf);\n-\n-  tmpdir_len = strlen (tmpdir_buf);\n-  /* tmpdir_buf should now have a dir separator as the final byte.  */\n-  gcc_assert (tmpdir_len > 0);\n-  gcc_assert (tmpdir_buf[tmpdir_len - 1] == DIR_SEPARATOR);\n-\n-  file_template_buf = \"libgccjit-XXXXXX\";\n-  file_template_len = strlen (file_template_buf);\n-\n-  result = XNEWVEC (char, tmpdir_len + file_template_len + 1);\n-  strcpy (result, tmpdir_buf);\n-  strcpy (result + tmpdir_len, file_template_buf);\n-\n-  return result;\n-}\n-\n /* A subclass of auto_vec <char *> that frees all of its elements on\n    deletion.  */\n \n@@ -1589,19 +1536,12 @@ compile ()\n   const char *ctxt_progname;\n   result *result_obj = NULL;\n \n-  m_path_template = make_tempdir_path_template ();\n-  if (!m_path_template)\n-    return NULL;\n+  int keep_intermediates =\n+    get_bool_option (GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES);\n \n-  /* Create tempdir using mkdtemp.  This is created with 0700 perms and\n-     is unique.  Hence no other (non-root) users should have access to\n-     the paths within it.  */\n-  m_path_tempdir = mkdtemp (m_path_template);\n-  if (!m_path_tempdir)\n+  m_tempdir = new tempdir (keep_intermediates);\n+  if (!m_tempdir->create ())\n     return NULL;\n-  m_path_c_file = concat (m_path_tempdir, \"/fake.c\", NULL);\n-  m_path_s_file = concat (m_path_tempdir, \"/fake.s\", NULL);\n-  m_path_so_file = concat (m_path_tempdir, \"/fake.so\", NULL);\n \n   /* Call into the rest of gcc.\n      For now, we have to assemble command-line options to pass into\n@@ -1706,7 +1646,7 @@ make_fake_args (vec <char *> *argvec,\n #define ADD_ARG_TAKE_OWNERSHIP(arg) argvec->safe_push (arg)\n \n   ADD_ARG (ctxt_progname);\n-  ADD_ARG (m_path_c_file);\n+  ADD_ARG (get_path_c_file ());\n   ADD_ARG (\"-fPIC\");\n \n   /* Handle int options: */\n@@ -1886,10 +1826,10 @@ convert_to_dso (const char *ctxt_progname)\n   argv[0] = gcc_driver_name;\n   argv[1] = \"-shared\";\n   /* The input: assembler.  */\n-  argv[2] = m_path_s_file;\n+  argv[2] = m_tempdir->get_path_s_file ();\n   /* The output: shared library.  */\n   argv[3] = \"-o\";\n-  argv[4] = m_path_so_file;\n+  argv[4] = m_tempdir->get_path_so_file ();\n \n   /* Don't use the linker plugin.\n      If running with just a \"make\" and not a \"make install\", then we'd\n@@ -1953,7 +1893,8 @@ dlopen_built_dso ()\n   /* Clear any existing error.  */\n   dlerror ();\n \n-  handle = dlopen (m_path_so_file, RTLD_NOW | RTLD_LOCAL);\n+  handle = dlopen (m_tempdir->get_path_so_file (),\n+\t\t   RTLD_NOW | RTLD_LOCAL);\n   if ((error = dlerror()) != NULL)  {\n     add_error (NULL, \"%s\", error);\n   }\n@@ -2038,7 +1979,7 @@ dump_generated_code ()\n {\n   char buf[4096];\n   size_t sz;\n-  FILE *f_in = fopen (m_path_s_file, \"r\");\n+  FILE *f_in = fopen (get_path_s_file (), \"r\");\n   if (!f_in)\n     return;\n \n@@ -2048,6 +1989,37 @@ dump_generated_code ()\n   fclose (f_in);\n }\n \n+/* Get the supposed path of the notional \"fake.c\" file within the\n+   tempdir.  This file doesn't exist, but the rest of the compiler\n+   needs a name.  */\n+\n+const char *\n+playback::context::\n+get_path_c_file () const\n+{\n+  return m_tempdir->get_path_c_file ();\n+}\n+\n+/* Get the path of the assembler output file \"fake.s\" file within the\n+   tempdir. */\n+\n+const char *\n+playback::context::\n+get_path_s_file () const\n+{\n+  return m_tempdir->get_path_s_file ();\n+}\n+\n+/* Get the path of the DSO object file \"fake.so\" file within the\n+   tempdir. */\n+\n+const char *\n+playback::context::\n+get_path_so_file () const\n+{\n+  return m_tempdir->get_path_so_file ();\n+}\n+\n /* qsort comparator for comparing pairs of playback::source_line *,\n    ordering them by line number.  */\n "}, {"sha": "22fc2834fbfe7c2454203cd531e1d5f914c3ce1d", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "patch": "@@ -231,6 +231,10 @@ class context\n \n   void handle_locations ();\n \n+  const char * get_path_c_file () const;\n+  const char * get_path_s_file () const;\n+  const char * get_path_so_file () const;\n+\n private:\n \n   /* Functions for implementing \"compile\".  */\n@@ -259,16 +263,7 @@ class context\n private:\n   ::gcc::jit::recording::context *m_recording_ctxt;\n \n-  /* Allocated using xmalloc (by xstrdup).  */\n-  char *m_path_template;\n-\n-  /* This either aliases m_path_template, or is NULL.  */\n-  char *m_path_tempdir;\n-\n-  /* The following are allocated using xmalloc.  */\n-  char *m_path_c_file;\n-  char *m_path_s_file;\n-  char *m_path_so_file;\n+  tempdir *m_tempdir;\n \n   auto_vec<function *> m_functions;\n   tree m_char_array_type_node;"}, {"sha": "f64fbee3a564b18a62538ae640d137aee950ea85", "filename": "gcc/jit/jit-tempdir.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-tempdir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-tempdir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-tempdir.c?ref=d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "patch": "@@ -0,0 +1,129 @@\n+/* Managing temporary directories and their content within libgccjit.so\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"jit-tempdir.h\"\n+\n+\n+/* Construct a tempdir path template suitable for use by mkdtemp\n+   e.g. \"/tmp/libgccjit-XXXXXX\", but respecting the rules in\n+   libiberty's choose_tempdir rather than hardcoding \"/tmp/\".\n+\n+   The memory is allocated using malloc and must be freed.\n+   Aborts the process if allocation fails. */\n+\n+static char *\n+make_tempdir_path_template ()\n+{\n+  const char *tmpdir_buf;\n+  size_t tmpdir_len;\n+  const char *file_template_buf;\n+  size_t file_template_len;\n+  char *result;\n+\n+  /* The result of choose_tmpdir is a cached buffer within libiberty, so\n+     we must *not* free it.  */\n+  tmpdir_buf = choose_tmpdir ();\n+\n+  /* choose_tmpdir aborts on malloc failure.  */\n+  gcc_assert (tmpdir_buf);\n+\n+  tmpdir_len = strlen (tmpdir_buf);\n+  /* tmpdir_buf should now have a dir separator as the final byte.  */\n+  gcc_assert (tmpdir_len > 0);\n+  gcc_assert (tmpdir_buf[tmpdir_len - 1] == DIR_SEPARATOR);\n+\n+  file_template_buf = \"libgccjit-XXXXXX\";\n+  file_template_len = strlen (file_template_buf);\n+\n+  result = XNEWVEC (char, tmpdir_len + file_template_len + 1);\n+  strcpy (result, tmpdir_buf);\n+  strcpy (result + tmpdir_len, file_template_buf);\n+\n+  return result;\n+}\n+\n+/* The constructor for the jit::tempdir object.\n+   The real work is done by the jit::tempdir::create method.  */\n+\n+gcc::jit::tempdir::tempdir (int keep_intermediates)\n+  : m_keep_intermediates (keep_intermediates),\n+    m_path_template (NULL),\n+    m_path_tempdir (NULL),\n+    m_path_c_file (NULL),\n+    m_path_s_file (NULL),\n+    m_path_so_file (NULL)\n+{\n+}\n+\n+/* Do the real work of creating the on-disk tempdir.\n+   We do this here, rather than in the jit::tempdir constructor\n+   so that we can handle failure without needing exceptions.  */\n+\n+bool\n+gcc::jit::tempdir::create ()\n+{\n+  m_path_template = make_tempdir_path_template ();\n+  if (!m_path_template)\n+    return false;\n+\n+  /* Create tempdir using mkdtemp.  This is created with 0700 perms and\n+     is unique.  Hence no other (non-root) users should have access to\n+     the paths within it.  */\n+  m_path_tempdir = mkdtemp (m_path_template);\n+  if (!m_path_tempdir)\n+    return false;\n+  m_path_c_file = concat (m_path_tempdir, \"/fake.c\", NULL);\n+  m_path_s_file = concat (m_path_tempdir, \"/fake.s\", NULL);\n+  m_path_so_file = concat (m_path_tempdir, \"/fake.so\", NULL);\n+\n+  /* Success.  */\n+  return true;\n+}\n+\n+/* The destructor for the jit::tempdir object, which\n+   cleans up the filesystem directory and its contents\n+   (unless keep_intermediates was set).  */\n+\n+gcc::jit::tempdir::~tempdir ()\n+{\n+  if (m_keep_intermediates)\n+    fprintf (stderr, \"intermediate files written to %s\\n\", m_path_tempdir);\n+  else\n+    {\n+      /* Clean up .s/.so and tempdir. */\n+      if (m_path_s_file)\n+        unlink (m_path_s_file);\n+      if (m_path_so_file)\n+        unlink (m_path_so_file);\n+      if (m_path_tempdir)\n+        rmdir (m_path_tempdir);\n+    }\n+\n+  free (m_path_template);\n+  /* m_path_tempdir aliases m_path_template, or is NULL, so don't\n+     attempt to free it .  */\n+  free (m_path_c_file);\n+  free (m_path_s_file);\n+  free (m_path_so_file);\n+}"}, {"sha": "31636ddcaa7f9cdafd067ea8ddd86ec8d633203a", "filename": "gcc/jit/jit-tempdir.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-tempdir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9/gcc%2Fjit%2Fjit-tempdir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-tempdir.h?ref=d1e5f2c7e2a800e99509aadb9cdc6d3e76eeb1a9", "patch": "@@ -0,0 +1,81 @@\n+/* Managing temporary directories and their content within libgccjit.so\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef JIT_TEMPDIR_H\n+#define JIT_TEMPDIR_H\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+/* A class to keep track of the jit::playback::context's tempdir.\n+\n+   The tempdir has the following layout:\n+\n+     /tmp/libgccjit-XXXXXX/\n+\t\t\t ./fake.c\n+\t\t\t    (doesn't exist, but the rest of the\n+\t\t\t     compiler needs a source code filename)\n+\n+\t\t\t ./fake.s\n+\t\t\t      (created by toplev::main)\n+\n+\t\t\t ./fake.so\n+\t\t\t      (created by playback::context::convert_to_dso).\n+\n+  It is normally deleted from the filesystem in the playback::context's\n+  dtor, unless GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES was set.  */\n+\n+class tempdir\n+{\n+ public:\n+  tempdir (int keep_intermediates);\n+  ~tempdir ();\n+\n+  bool create ();\n+\n+  const char * get_path () const { return m_path_tempdir; }\n+  const char * get_path_c_file () const { return m_path_c_file; }\n+  const char * get_path_s_file () const { return m_path_s_file; }\n+  const char * get_path_so_file () const { return m_path_so_file; }\n+\n+ private:\n+  /* Was GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES set?  If so, keep the\n+     on-disk tempdir around after this wrapper object goes away.  */\n+  int m_keep_intermediates;\n+\n+  /* Allocated using xmalloc (by xstrdup).  */\n+  char *m_path_template;\n+\n+  /* This either aliases m_path_template, or is NULL.  */\n+  char *m_path_tempdir;\n+\n+  /* The following are allocated using xmalloc.  */\n+  char *m_path_c_file;\n+  char *m_path_s_file;\n+  char *m_path_so_file;\n+\n+};\n+\n+} // namespace gcc::jit\n+\n+} // namespace gcc\n+\n+#endif /* JIT_TEMPDIR_H */"}]}