{"sha": "27a4cd485d3731293a42b7b324a7432a4af13443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdhNGNkNDg1ZDM3MzEyOTNhNDJiN2IzMjRhNzQzMmE0YWYxMzQ0Mw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-08-05T20:16:05Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-08-05T20:16:05Z"}, "message": "Automated conversion of passes to C++ classes\n\ngcc/\n\n\tPatch autogenerated by refactor_passes.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 03fe39476a4c4ea450b49e087cfa817b5f92021e\n\n\t* asan.c (pass_asan): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_asan): ...new pass_data instance and...\n\t(make_pass_asan): ...new function.\n\t(pass_asan_O0): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_asan_O0): ...new pass_data instance and...\n\t(make_pass_asan_O0): ...new function.\n\t* auto-inc-dec.c (pass_inc_dec): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_inc_dec): ...new pass_data instance and...\n\t(make_pass_inc_dec): ...new function.\n\t* bb-reorder.c (pass_reorder_blocks): Convert from a global struct to\n\ta subclass of rtl_opt_pass along with...\n\t(pass_data_reorder_blocks): ...new pass_data instance and...\n\t(make_pass_reorder_blocks): ...new function.\n\t(pass_duplicate_computed_gotos): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_duplicate_computed_gotos): ...new pass_data instance and...\n\t(make_pass_duplicate_computed_gotos): ...new function.\n\t(pass_partition_blocks): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_partition_blocks): ...new pass_data instance and...\n\t(make_pass_partition_blocks): ...new function.\n\t* bt-load.c (pass_branch_target_load_optimize1): Convert from a global\n\tstruct to a subclass of rtl_opt_pass along with...\n\t(pass_data_branch_target_load_optimize1): ...new pass_data instance\n\tand...\n\t(make_pass_branch_target_load_optimize1): ...new function.\n\t(pass_branch_target_load_optimize2): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_branch_target_load_optimize2): ...new pass_data instance\n\tand...\n\t(make_pass_branch_target_load_optimize2): ...new function.\n\t* cfgcleanup.c (pass_jump): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_jump): ...new pass_data instance and...\n\t(make_pass_jump): ...new function.\n\t(pass_jump2): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_jump2): ...new pass_data instance and...\n\t(make_pass_jump2): ...new function.\n\t* cfgexpand.c (pass_expand): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_expand): ...new pass_data instance and...\n\t(make_pass_expand): ...new function.\n\t* cfgrtl.c (pass_free_cfg): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_free_cfg): ...new pass_data instance and...\n\t(make_pass_free_cfg): ...new function.\n\t(pass_into_cfg_layout_mode): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_into_cfg_layout_mode): ...new pass_data instance and...\n\t(make_pass_into_cfg_layout_mode): ...new function.\n\t(pass_outof_cfg_layout_mode): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_outof_cfg_layout_mode): ...new pass_data instance and...\n\t(make_pass_outof_cfg_layout_mode): ...new function.\n\t* cgraphbuild.c (pass_build_cgraph_edges): Convert from a global\n\tstruct to a subclass of gimple_opt_pass along with...\n\t(pass_data_build_cgraph_edges): ...new pass_data instance and...\n\t(make_pass_build_cgraph_edges): ...new function.\n\t(pass_rebuild_cgraph_edges): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_rebuild_cgraph_edges): ...new pass_data instance and...\n\t(make_pass_rebuild_cgraph_edges): ...new function.\n\t(pass_remove_cgraph_callee_edges): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_remove_cgraph_callee_edges): ...new pass_data instance\n\tand...\n\t(make_pass_remove_cgraph_callee_edges): ...new function.\n\t* combine-stack-adj.c (pass_stack_adjustments): Convert from a global\n\tstruct to a subclass of rtl_opt_pass along with...\n\t(pass_data_stack_adjustments): ...new pass_data instance and...\n\t(make_pass_stack_adjustments): ...new function.\n\t* combine.c (pass_combine): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_combine): ...new pass_data instance and...\n\t(make_pass_combine): ...new function.\n\t* compare-elim.c (pass_compare_elim_after_reload): Convert from a\n\tglobal struct to a subclass of rtl_opt_pass along with...\n\t(pass_data_compare_elim_after_reload): ...new pass_data instance\n\tand...\n\t(make_pass_compare_elim_after_reload): ...new function.\n\t* cprop.c (pass_rtl_cprop): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_rtl_cprop): ...new pass_data instance and...\n\t(make_pass_rtl_cprop): ...new function.\n\t* cse.c (pass_cse): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_cse): ...new pass_data instance and...\n\t(make_pass_cse): ...new function.\n\t(pass_cse2): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_cse2): ...new pass_data instance and...\n\t(make_pass_cse2): ...new function.\n\t(pass_cse_after_global_opts): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_cse_after_global_opts): ...new pass_data instance and...\n\t(make_pass_cse_after_global_opts): ...new function.\n\t* dce.c (pass_ud_rtl_dce): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_ud_rtl_dce): ...new pass_data instance and...\n\t(make_pass_ud_rtl_dce): ...new function.\n\t(pass_fast_rtl_dce): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_fast_rtl_dce): ...new pass_data instance and...\n\t(make_pass_fast_rtl_dce): ...new function.\n\t* df-core.c (pass_df_initialize_opt): Convert from a global struct to\n\ta subclass of rtl_opt_pass along with...\n\t(pass_data_df_initialize_opt): ...new pass_data instance and...\n\t(make_pass_df_initialize_opt): ...new function.\n\t(pass_df_initialize_no_opt): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_df_initialize_no_opt): ...new pass_data instance and...\n\t(make_pass_df_initialize_no_opt): ...new function.\n\t(pass_df_finish): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_df_finish): ...new pass_data instance and...\n\t(make_pass_df_finish): ...new function.\n\t* dse.c (pass_rtl_dse1): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_dse1): ...new pass_data instance and...\n\t(make_pass_rtl_dse1): ...new function.\n\t(pass_rtl_dse2): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_dse2): ...new pass_data instance and...\n\t(make_pass_rtl_dse2): ...new function.\n\t* dwarf2cfi.c (pass_dwarf2_frame): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_dwarf2_frame): ...new pass_data instance and...\n\t(make_pass_dwarf2_frame): ...new function.\n\t* except.c (pass_set_nothrow_function_flags): Convert from a global\n\tstruct to a subclass of rtl_opt_pass along with...\n\t(pass_data_set_nothrow_function_flags): ...new pass_data instance\n\tand...\n\t(make_pass_set_nothrow_function_flags): ...new function.\n\t(pass_convert_to_eh_region_ranges): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_convert_to_eh_region_ranges): ...new pass_data instance\n\tand...\n\t(make_pass_convert_to_eh_region_ranges): ...new function.\n\t* final.c (pass_compute_alignments): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_compute_alignments): ...new pass_data instance and...\n\t(make_pass_compute_alignments): ...new function.\n\t(pass_final): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_final): ...new pass_data instance and...\n\t(make_pass_final): ...new function.\n\t(pass_shorten_branches): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_shorten_branches): ...new pass_data instance and...\n\t(make_pass_shorten_branches): ...new function.\n\t(pass_clean_state): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_clean_state): ...new pass_data instance and...\n\t(make_pass_clean_state): ...new function.\n\t* function.c (pass_instantiate_virtual_regs): Convert from a global\n\tstruct to a subclass of rtl_opt_pass along with...\n\t(pass_data_instantiate_virtual_regs): ...new pass_data instance and...\n\t(make_pass_instantiate_virtual_regs): ...new function.\n\t(pass_leaf_regs): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_leaf_regs): ...new pass_data instance and...\n\t(make_pass_leaf_regs): ...new function.\n\t(pass_thread_prologue_and_epilogue): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_thread_prologue_and_epilogue): ...new pass_data instance\n\tand...\n\t(make_pass_thread_prologue_and_epilogue): ...new function.\n\t(pass_match_asm_constraints): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_match_asm_constraints): ...new pass_data instance and...\n\t(make_pass_match_asm_constraints): ...new function.\n\t* fwprop.c (pass_rtl_fwprop): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_rtl_fwprop): ...new pass_data instance and...\n\t(make_pass_rtl_fwprop): ...new function.\n\t(pass_rtl_fwprop_addr): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_fwprop_addr): ...new pass_data instance and...\n\t(make_pass_rtl_fwprop_addr): ...new function.\n\t* gcse.c (pass_rtl_pre): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_pre): ...new pass_data instance and...\n\t(make_pass_rtl_pre): ...new function.\n\t(pass_rtl_hoist): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_hoist): ...new pass_data instance and...\n\t(make_pass_rtl_hoist): ...new function.\n\t* gimple-low.c (pass_lower_cf): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_lower_cf): ...new pass_data instance and...\n\t(make_pass_lower_cf): ...new function.\n\t* gimple-ssa-strength-reduction.c (pass_strength_reduction): Convert\n\tfrom a global struct to a subclass of gimple_opt_pass along with...\n\t(pass_data_strength_reduction): ...new pass_data instance and...\n\t(make_pass_strength_reduction): ...new function.\n\t* ifcvt.c (pass_rtl_ifcvt): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_rtl_ifcvt): ...new pass_data instance and...\n\t(make_pass_rtl_ifcvt): ...new function.\n\t(pass_if_after_combine): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_if_after_combine): ...new pass_data instance and...\n\t(make_pass_if_after_combine): ...new function.\n\t(pass_if_after_reload): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_if_after_reload): ...new pass_data instance and...\n\t(make_pass_if_after_reload): ...new function.\n\t* init-regs.c (pass_initialize_regs): Convert from a global struct to\n\ta subclass of rtl_opt_pass along with...\n\t(pass_data_initialize_regs): ...new pass_data instance and...\n\t(make_pass_initialize_regs): ...new function.\n\t* ipa-cp.c (pass_ipa_cp): Convert from a global struct to a subclass\n\tof ipa_opt_pass_d along with...\n\t(pass_data_ipa_cp): ...new pass_data instance and...\n\t(make_pass_ipa_cp): ...new function.\n\t* ipa-inline-analysis.c (pass_inline_parameters): Convert from a\n\tglobal struct to a subclass of gimple_opt_pass along with...\n\t(pass_data_inline_parameters): ...new pass_data instance and...\n\t(make_pass_inline_parameters): ...new function.\n\t* ipa-inline.c (pass_early_inline): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_early_inline): ...new pass_data instance and...\n\t(make_pass_early_inline): ...new function.\n\t(pass_ipa_inline): Convert from a global struct to a subclass of\n\tipa_opt_pass_d along with...\n\t(pass_data_ipa_inline): ...new pass_data instance and...\n\t(make_pass_ipa_inline): ...new function.\n\t* ipa-pure-const.c (pass_local_pure_const): Convert from a global\n\tstruct to a subclass of gimple_opt_pass along with...\n\t(pass_data_local_pure_const): ...new pass_data instance and...\n\t(make_pass_local_pure_const): ...new function.\n\t(pass_ipa_pure_const): Convert from a global struct to a subclass of\n\tipa_opt_pass_d along with...\n\t(pass_data_ipa_pure_const): ...new pass_data instance and...\n\t(make_pass_ipa_pure_const): ...new function.\n\t* ipa-reference.c (pass_ipa_reference): Convert from a global struct\n\tto a subclass of ipa_opt_pass_d along with...\n\t(pass_data_ipa_reference): ...new pass_data instance and...\n\t(make_pass_ipa_reference): ...new function.\n\t* ipa-split.c (pass_split_functions): Convert from a global struct to\n\ta subclass of gimple_opt_pass along with...\n\t(pass_data_split_functions): ...new pass_data instance and...\n\t(make_pass_split_functions): ...new function.\n\t(pass_feedback_split_functions): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_feedback_split_functions): ...new pass_data instance and...\n\t(make_pass_feedback_split_functions): ...new function.\n\t* ipa.c (pass_ipa_function_and_variable_visibility): Convert from a\n\tglobal struct to a subclass of simple_ipa_opt_pass along with...\n\t(pass_data_ipa_function_and_variable_visibility): ...new pass_data\n\tinstance and...\n\t(make_pass_ipa_function_and_variable_visibility): ...new function.\n\t(pass_ipa_free_inline_summary): Convert from a global struct to a\n\tsubclass of simple_ipa_opt_pass along with...\n\t(pass_data_ipa_free_inline_summary): ...new pass_data instance and...\n\t(make_pass_ipa_free_inline_summary): ...new function.\n\t(pass_ipa_whole_program_visibility): Convert from a global struct to a\n\tsubclass of ipa_opt_pass_d along with...\n\t(pass_data_ipa_whole_program_visibility): ...new pass_data instance\n\tand...\n\t(make_pass_ipa_whole_program_visibility): ...new function.\n\t(pass_ipa_profile): Convert from a global struct to a subclass of\n\tipa_opt_pass_d along with...\n\t(pass_data_ipa_profile): ...new pass_data instance and...\n\t(make_pass_ipa_profile): ...new function.\n\t(pass_ipa_cdtor_merge): Convert from a global struct to a subclass of\n\tipa_opt_pass_d along with...\n\t(pass_data_ipa_cdtor_merge): ...new pass_data instance and...\n\t(make_pass_ipa_cdtor_merge): ...new function.\n\t* ira.c (pass_ira): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_ira): ...new pass_data instance and...\n\t(make_pass_ira): ...new function.\n\t(pass_reload): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_reload): ...new pass_data instance and...\n\t(make_pass_reload): ...new function.\n\t* jump.c (pass_cleanup_barriers): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_cleanup_barriers): ...new pass_data instance and...\n\t(make_pass_cleanup_barriers): ...new function.\n\t* loop-init.c (pass_loop2): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_loop2): ...new pass_data instance and...\n\t(make_pass_loop2): ...new function.\n\t(pass_rtl_loop_init): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_loop_init): ...new pass_data instance and...\n\t(make_pass_rtl_loop_init): ...new function.\n\t(pass_rtl_loop_done): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_loop_done): ...new pass_data instance and...\n\t(make_pass_rtl_loop_done): ...new function.\n\t(pass_rtl_move_loop_invariants): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_rtl_move_loop_invariants): ...new pass_data instance and...\n\t(make_pass_rtl_move_loop_invariants): ...new function.\n\t(pass_rtl_unswitch): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_unswitch): ...new pass_data instance and...\n\t(make_pass_rtl_unswitch): ...new function.\n\t(pass_rtl_unroll_and_peel_loops): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_rtl_unroll_and_peel_loops): ...new pass_data instance\n\tand...\n\t(make_pass_rtl_unroll_and_peel_loops): ...new function.\n\t(pass_rtl_doloop): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_rtl_doloop): ...new pass_data instance and...\n\t(make_pass_rtl_doloop): ...new function.\n\t* lower-subreg.c (pass_lower_subreg): Convert from a global struct to\n\ta subclass of rtl_opt_pass along with...\n\t(pass_data_lower_subreg): ...new pass_data instance and...\n\t(make_pass_lower_subreg): ...new function.\n\t(pass_lower_subreg2): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_lower_subreg2): ...new pass_data instance and...\n\t(make_pass_lower_subreg2): ...new function.\n\t* lto-streamer-out.c (pass_ipa_lto_gimple_out): Convert from a global\n\tstruct to a subclass of ipa_opt_pass_d along with...\n\t(pass_data_ipa_lto_gimple_out): ...new pass_data instance and...\n\t(make_pass_ipa_lto_gimple_out): ...new function.\n\t(pass_ipa_lto_finish_out): Convert from a global struct to a subclass\n\tof ipa_opt_pass_d along with...\n\t(pass_data_ipa_lto_finish_out): ...new pass_data instance and...\n\t(make_pass_ipa_lto_finish_out): ...new function.\n\t* mode-switching.c (pass_mode_switching): Convert from a global struct\n\tto a subclass of rtl_opt_pass along with...\n\t(pass_data_mode_switching): ...new pass_data instance and...\n\t(make_pass_mode_switching): ...new function.\n\t* modulo-sched.c (pass_sms): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_sms): ...new pass_data instance and...\n\t(make_pass_sms): ...new function.\n\t* omp-low.c (pass_expand_omp): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_expand_omp): ...new pass_data instance and...\n\t(make_pass_expand_omp): ...new function.\n\t(pass_lower_omp): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_lower_omp): ...new pass_data instance and...\n\t(make_pass_lower_omp): ...new function.\n\t(pass_diagnose_omp_blocks): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_diagnose_omp_blocks): ...new pass_data instance and...\n\t(make_pass_diagnose_omp_blocks): ...new function.\n\t* passes.c (pass_early_local_passes): Convert from a global struct to\n\ta subclass of simple_ipa_opt_pass along with...\n\t(pass_data_early_local_passes): ...new pass_data instance and...\n\t(make_pass_early_local_passes): ...new function.\n\t(pass_all_early_optimizations): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_all_early_optimizations): ...new pass_data instance and...\n\t(make_pass_all_early_optimizations): ...new function.\n\t(pass_all_optimizations): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_all_optimizations): ...new pass_data instance and...\n\t(make_pass_all_optimizations): ...new function.\n\t(pass_all_optimizations_g): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_all_optimizations_g): ...new pass_data instance and...\n\t(make_pass_all_optimizations_g): ...new function.\n\t(pass_rest_of_compilation): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_rest_of_compilation): ...new pass_data instance and...\n\t(make_pass_rest_of_compilation): ...new function.\n\t(pass_postreload): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_postreload): ...new pass_data instance and...\n\t(make_pass_postreload): ...new function.\n\t* postreload-gcse.c (pass_gcse2): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_gcse2): ...new pass_data instance and...\n\t(make_pass_gcse2): ...new function.\n\t* postreload.c (pass_postreload_cse): Convert from a global struct to\n\ta subclass of rtl_opt_pass along with...\n\t(pass_data_postreload_cse): ...new pass_data instance and...\n\t(make_pass_postreload_cse): ...new function.\n\t* predict.c (pass_profile): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_profile): ...new pass_data instance and...\n\t(make_pass_profile): ...new function.\n\t(pass_strip_predict_hints): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_strip_predict_hints): ...new pass_data instance and...\n\t(make_pass_strip_predict_hints): ...new function.\n\t* recog.c (pass_peephole2): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_peephole2): ...new pass_data instance and...\n\t(make_pass_peephole2): ...new function.\n\t(pass_split_all_insns): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_split_all_insns): ...new pass_data instance and...\n\t(make_pass_split_all_insns): ...new function.\n\t(pass_split_after_reload): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_split_after_reload): ...new pass_data instance and...\n\t(make_pass_split_after_reload): ...new function.\n\t(pass_split_before_regstack): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_split_before_regstack): ...new pass_data instance and...\n\t(make_pass_split_before_regstack): ...new function.\n\t(pass_split_before_sched2): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_split_before_sched2): ...new pass_data instance and...\n\t(make_pass_split_before_sched2): ...new function.\n\t(pass_split_for_shorten_branches): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_split_for_shorten_branches): ...new pass_data instance\n\tand...\n\t(make_pass_split_for_shorten_branches): ...new function.\n\t* ree.c (pass_ree): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_ree): ...new pass_data instance and...\n\t(make_pass_ree): ...new function.\n\t* reg-stack.c (pass_stack_regs): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_stack_regs): ...new pass_data instance and...\n\t(make_pass_stack_regs): ...new function.\n\t(pass_stack_regs_run): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_stack_regs_run): ...new pass_data instance and...\n\t(make_pass_stack_regs_run): ...new function.\n\t* regcprop.c (pass_cprop_hardreg): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_cprop_hardreg): ...new pass_data instance and...\n\t(make_pass_cprop_hardreg): ...new function.\n\t* reginfo.c (pass_reginfo_init): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_reginfo_init): ...new pass_data instance and...\n\t(make_pass_reginfo_init): ...new function.\n\t* regmove.c (pass_regmove): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_regmove): ...new pass_data instance and...\n\t(make_pass_regmove): ...new function.\n\t* regrename.c (pass_regrename): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_regrename): ...new pass_data instance and...\n\t(make_pass_regrename): ...new function.\n\t* reorg.c (pass_delay_slots): Convert from a global struct to a\n\tsubclass of rtl_opt_pass along with...\n\t(pass_data_delay_slots): ...new pass_data instance and...\n\t(make_pass_delay_slots): ...new function.\n\t(pass_machine_reorg): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_machine_reorg): ...new pass_data instance and...\n\t(make_pass_machine_reorg): ...new function.\n\t* sched-rgn.c (pass_sched): Convert from a global struct to a subclass\n\tof rtl_opt_pass along with...\n\t(pass_data_sched): ...new pass_data instance and...\n\t(make_pass_sched): ...new function.\n\t(pass_sched2): Convert from a global struct to a subclass of\n\trtl_opt_pass along with...\n\t(pass_data_sched2): ...new pass_data instance and...\n\t(make_pass_sched2): ...new function.\n\t* stack-ptr-mod.c (pass_stack_ptr_mod): Convert from a global struct\n\tto a subclass of rtl_opt_pass along with...\n\t(pass_data_stack_ptr_mod): ...new pass_data instance and...\n\t(make_pass_stack_ptr_mod): ...new function.\n\t* store-motion.c (pass_rtl_store_motion): Convert from a global struct\n\tto a subclass of rtl_opt_pass along with...\n\t(pass_data_rtl_store_motion): ...new pass_data instance and...\n\t(make_pass_rtl_store_motion): ...new function.\n\t* tracer.c (pass_tracer): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_tracer): ...new pass_data instance and...\n\t(make_pass_tracer): ...new function.\n\t* trans-mem.c (pass_diagnose_tm_blocks): Convert from a global struct\n\tto a subclass of gimple_opt_pass along with...\n\t(pass_data_diagnose_tm_blocks): ...new pass_data instance and...\n\t(make_pass_diagnose_tm_blocks): ...new function.\n\t(pass_lower_tm): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_lower_tm): ...new pass_data instance and...\n\t(make_pass_lower_tm): ...new function.\n\t(pass_tm_init): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_tm_init): ...new pass_data instance and...\n\t(make_pass_tm_init): ...new function.\n\t(pass_tm_mark): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_tm_mark): ...new pass_data instance and...\n\t(make_pass_tm_mark): ...new function.\n\t(pass_tm_edges): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_tm_edges): ...new pass_data instance and...\n\t(make_pass_tm_edges): ...new function.\n\t(pass_tm_memopt): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_tm_memopt): ...new pass_data instance and...\n\t(make_pass_tm_memopt): ...new function.\n\t(pass_ipa_tm): Convert from a global struct to a subclass of\n\tsimple_ipa_opt_pass along with...\n\t(pass_data_ipa_tm): ...new pass_data instance and...\n\t(make_pass_ipa_tm): ...new function.\n\t* tree-call-cdce.c (pass_call_cdce): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_call_cdce): ...new pass_data instance and...\n\t(make_pass_call_cdce): ...new function.\n\t* tree-cfg.c (pass_build_cfg): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_build_cfg): ...new pass_data instance and...\n\t(make_pass_build_cfg): ...new function.\n\t(pass_split_crit_edges): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_split_crit_edges): ...new pass_data instance and...\n\t(make_pass_split_crit_edges): ...new function.\n\t(pass_warn_function_return): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_warn_function_return): ...new pass_data instance and...\n\t(make_pass_warn_function_return): ...new function.\n\t(pass_warn_function_noreturn): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_warn_function_noreturn): ...new pass_data instance and...\n\t(make_pass_warn_function_noreturn): ...new function.\n\t(pass_warn_unused_result): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_warn_unused_result): ...new pass_data instance and...\n\t(make_pass_warn_unused_result): ...new function.\n\t* tree-cfgcleanup.c (pass_merge_phi): Convert from a global struct to\n\ta subclass of gimple_opt_pass along with...\n\t(pass_data_merge_phi): ...new pass_data instance and...\n\t(make_pass_merge_phi): ...new function.\n\t* tree-complex.c (pass_lower_complex): Convert from a global struct to\n\ta subclass of gimple_opt_pass along with...\n\t(pass_data_lower_complex): ...new pass_data instance and...\n\t(make_pass_lower_complex): ...new function.\n\t(pass_lower_complex_O0): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_lower_complex_O0): ...new pass_data instance and...\n\t(make_pass_lower_complex_O0): ...new function.\n\t* tree-eh.c (pass_lower_eh): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_lower_eh): ...new pass_data instance and...\n\t(make_pass_lower_eh): ...new function.\n\t(pass_refactor_eh): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_refactor_eh): ...new pass_data instance and...\n\t(make_pass_refactor_eh): ...new function.\n\t(pass_lower_resx): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_lower_resx): ...new pass_data instance and...\n\t(make_pass_lower_resx): ...new function.\n\t(pass_lower_eh_dispatch): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_lower_eh_dispatch): ...new pass_data instance and...\n\t(make_pass_lower_eh_dispatch): ...new function.\n\t(pass_cleanup_eh): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_cleanup_eh): ...new pass_data instance and...\n\t(make_pass_cleanup_eh): ...new function.\n\t* tree-emutls.c (pass_ipa_lower_emutls): Convert from a global struct\n\tto a subclass of simple_ipa_opt_pass along with...\n\t(pass_data_ipa_lower_emutls): ...new pass_data instance and...\n\t(make_pass_ipa_lower_emutls): ...new function.\n\t* tree-if-conv.c (pass_if_conversion): Convert from a global struct to\n\ta subclass of gimple_opt_pass along with...\n\t(pass_data_if_conversion): ...new pass_data instance and...\n\t(make_pass_if_conversion): ...new function.\n\t* tree-into-ssa.c (pass_build_ssa): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_build_ssa): ...new pass_data instance and...\n\t(make_pass_build_ssa): ...new function.\n\t* tree-loop-distribution.c (pass_loop_distribution): Convert from a\n\tglobal struct to a subclass of gimple_opt_pass along with...\n\t(pass_data_loop_distribution): ...new pass_data instance and...\n\t(make_pass_loop_distribution): ...new function.\n\t* tree-mudflap.c (pass_mudflap_1): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_mudflap_1): ...new pass_data instance and...\n\t(make_pass_mudflap_1): ...new function.\n\t(pass_mudflap_2): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_mudflap_2): ...new pass_data instance and...\n\t(make_pass_mudflap_2): ...new function.\n\t* tree-nomudflap.c (pass_mudflap_1): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_mudflap_1): ...new pass_data instance and...\n\t(make_pass_mudflap_1): ...new function.\n\t(pass_mudflap_2): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_mudflap_2): ...new pass_data instance and...\n\t(make_pass_mudflap_2): ...new function.\n\t* tree-nrv.c (pass_nrv): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_nrv): ...new pass_data instance and...\n\t(make_pass_nrv): ...new function.\n\t(pass_return_slot): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_return_slot): ...new pass_data instance and...\n\t(make_pass_return_slot): ...new function.\n\t* tree-object-size.c (pass_object_sizes): Convert from a global struct\n\tto a subclass of gimple_opt_pass along with...\n\t(pass_data_object_sizes): ...new pass_data instance and...\n\t(make_pass_object_sizes): ...new function.\n\t* tree-optimize.c (pass_cleanup_cfg_post_optimizing): Convert from a\n\tglobal struct to a subclass of gimple_opt_pass along with...\n\t(pass_data_cleanup_cfg_post_optimizing): ...new pass_data instance\n\tand...\n\t(make_pass_cleanup_cfg_post_optimizing): ...new function.\n\t(pass_fixup_cfg): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_fixup_cfg): ...new pass_data instance and...\n\t(make_pass_fixup_cfg): ...new function.\n\t* tree-pass.h (pass_mudflap_1): Replace declaration with that of...\n\t(make_pass_mudflap_1): ...new function.\n\t(pass_mudflap_2): Replace declaration with that of...\n\t(make_pass_mudflap_2): ...new function.\n\t(pass_asan): Replace declaration with that of...\n\t(make_pass_asan): ...new function.\n\t(pass_asan_O0): Replace declaration with that of...\n\t(make_pass_asan_O0): ...new function.\n\t(pass_tsan): Replace declaration with that of...\n\t(make_pass_tsan): ...new function.\n\t(pass_tsan_O0): Replace declaration with that of...\n\t(make_pass_tsan_O0): ...new function.\n\t(pass_lower_cf): Replace declaration with that of...\n\t(make_pass_lower_cf): ...new function.\n\t(pass_refactor_eh): Replace declaration with that of...\n\t(make_pass_refactor_eh): ...new function.\n\t(pass_lower_eh): Replace declaration with that of...\n\t(make_pass_lower_eh): ...new function.\n\t(pass_lower_eh_dispatch): Replace declaration with that of...\n\t(make_pass_lower_eh_dispatch): ...new function.\n\t(pass_lower_resx): Replace declaration with that of...\n\t(make_pass_lower_resx): ...new function.\n\t(pass_build_cfg): Replace declaration with that of...\n\t(make_pass_build_cfg): ...new function.\n\t(pass_early_tree_profile): Replace declaration with that of...\n\t(make_pass_early_tree_profile): ...new function.\n\t(pass_cleanup_eh): Replace declaration with that of...\n\t(make_pass_cleanup_eh): ...new function.\n\t(pass_sra): Replace declaration with that of...\n\t(make_pass_sra): ...new function.\n\t(pass_sra_early): Replace declaration with that of...\n\t(make_pass_sra_early): ...new function.\n\t(pass_early_ipa_sra): Replace declaration with that of...\n\t(make_pass_early_ipa_sra): ...new function.\n\t(pass_tail_recursion): Replace declaration with that of...\n\t(make_pass_tail_recursion): ...new function.\n\t(pass_tail_calls): Replace declaration with that of...\n\t(make_pass_tail_calls): ...new function.\n\t(pass_tree_loop): Replace declaration with that of...\n\t(make_pass_tree_loop): ...new function.\n\t(pass_tree_loop_init): Replace declaration with that of...\n\t(make_pass_tree_loop_init): ...new function.\n\t(pass_lim): Replace declaration with that of...\n\t(make_pass_lim): ...new function.\n\t(pass_tree_unswitch): Replace declaration with that of...\n\t(make_pass_tree_unswitch): ...new function.\n\t(pass_predcom): Replace declaration with that of...\n\t(make_pass_predcom): ...new function.\n\t(pass_iv_canon): Replace declaration with that of...\n\t(make_pass_iv_canon): ...new function.\n\t(pass_scev_cprop): Replace declaration with that of...\n\t(make_pass_scev_cprop): ...new function.\n\t(pass_empty_loop): Replace declaration with that of...\n\t(make_pass_empty_loop): ...new function.\n\t(pass_record_bounds): Replace declaration with that of...\n\t(make_pass_record_bounds): ...new function.\n\t(pass_graphite): Replace declaration with that of...\n\t(make_pass_graphite): ...new function.\n\t(pass_graphite_transforms): Replace declaration with that of...\n\t(make_pass_graphite_transforms): ...new function.\n\t(pass_if_conversion): Replace declaration with that of...\n\t(make_pass_if_conversion): ...new function.\n\t(pass_loop_distribution): Replace declaration with that of...\n\t(make_pass_loop_distribution): ...new function.\n\t(pass_vectorize): Replace declaration with that of...\n\t(make_pass_vectorize): ...new function.\n\t(pass_slp_vectorize): Replace declaration with that of...\n\t(make_pass_slp_vectorize): ...new function.\n\t(pass_complete_unroll): Replace declaration with that of...\n\t(make_pass_complete_unroll): ...new function.\n\t(pass_complete_unrolli): Replace declaration with that of...\n\t(make_pass_complete_unrolli): ...new function.\n\t(pass_parallelize_loops): Replace declaration with that of...\n\t(make_pass_parallelize_loops): ...new function.\n\t(pass_loop_prefetch): Replace declaration with that of...\n\t(make_pass_loop_prefetch): ...new function.\n\t(pass_iv_optimize): Replace declaration with that of...\n\t(make_pass_iv_optimize): ...new function.\n\t(pass_tree_loop_done): Replace declaration with that of...\n\t(make_pass_tree_loop_done): ...new function.\n\t(pass_ch): Replace declaration with that of...\n\t(make_pass_ch): ...new function.\n\t(pass_ccp): Replace declaration with that of...\n\t(make_pass_ccp): ...new function.\n\t(pass_phi_only_cprop): Replace declaration with that of...\n\t(make_pass_phi_only_cprop): ...new function.\n\t(pass_build_ssa): Replace declaration with that of...\n\t(make_pass_build_ssa): ...new function.\n\t(pass_build_alias): Replace declaration with that of...\n\t(make_pass_build_alias): ...new function.\n\t(pass_build_ealias): Replace declaration with that of...\n\t(make_pass_build_ealias): ...new function.\n\t(pass_dominator): Replace declaration with that of...\n\t(make_pass_dominator): ...new function.\n\t(pass_dce): Replace declaration with that of...\n\t(make_pass_dce): ...new function.\n\t(pass_dce_loop): Replace declaration with that of...\n\t(make_pass_dce_loop): ...new function.\n\t(pass_cd_dce): Replace declaration with that of...\n\t(make_pass_cd_dce): ...new function.\n\t(pass_call_cdce): Replace declaration with that of...\n\t(make_pass_call_cdce): ...new function.\n\t(pass_merge_phi): Replace declaration with that of...\n\t(make_pass_merge_phi): ...new function.\n\t(pass_split_crit_edges): Replace declaration with that of...\n\t(make_pass_split_crit_edges): ...new function.\n\t(pass_pre): Replace declaration with that of...\n\t(make_pass_pre): ...new function.\n\t(pass_profile): Replace declaration with that of...\n\t(make_pass_profile): ...new function.\n\t(pass_strip_predict_hints): Replace declaration with that of...\n\t(make_pass_strip_predict_hints): ...new function.\n\t(pass_lower_complex_O0): Replace declaration with that of...\n\t(make_pass_lower_complex_O0): ...new function.\n\t(pass_lower_complex): Replace declaration with that of...\n\t(make_pass_lower_complex): ...new function.\n\t(pass_lower_vector): Replace declaration with that of...\n\t(make_pass_lower_vector): ...new function.\n\t(pass_lower_vector_ssa): Replace declaration with that of...\n\t(make_pass_lower_vector_ssa): ...new function.\n\t(pass_lower_omp): Replace declaration with that of...\n\t(make_pass_lower_omp): ...new function.\n\t(pass_diagnose_omp_blocks): Replace declaration with that of...\n\t(make_pass_diagnose_omp_blocks): ...new function.\n\t(pass_expand_omp): Replace declaration with that of...\n\t(make_pass_expand_omp): ...new function.\n\t(pass_expand_omp_ssa): Replace declaration with that of...\n\t(make_pass_expand_omp_ssa): ...new function.\n\t(pass_object_sizes): Replace declaration with that of...\n\t(make_pass_object_sizes): ...new function.\n\t(pass_strlen): Replace declaration with that of...\n\t(make_pass_strlen): ...new function.\n\t(pass_fold_builtins): Replace declaration with that of...\n\t(make_pass_fold_builtins): ...new function.\n\t(pass_stdarg): Replace declaration with that of...\n\t(make_pass_stdarg): ...new function.\n\t(pass_early_warn_uninitialized): Replace declaration with that of...\n\t(make_pass_early_warn_uninitialized): ...new function.\n\t(pass_late_warn_uninitialized): Replace declaration with that of...\n\t(make_pass_late_warn_uninitialized): ...new function.\n\t(pass_cse_reciprocals): Replace declaration with that of...\n\t(make_pass_cse_reciprocals): ...new function.\n\t(pass_cse_sincos): Replace declaration with that of...\n\t(make_pass_cse_sincos): ...new function.\n\t(pass_optimize_bswap): Replace declaration with that of...\n\t(make_pass_optimize_bswap): ...new function.\n\t(pass_optimize_widening_mul): Replace declaration with that of...\n\t(make_pass_optimize_widening_mul): ...new function.\n\t(pass_warn_function_return): Replace declaration with that of...\n\t(make_pass_warn_function_return): ...new function.\n\t(pass_warn_function_noreturn): Replace declaration with that of...\n\t(make_pass_warn_function_noreturn): ...new function.\n\t(pass_cselim): Replace declaration with that of...\n\t(make_pass_cselim): ...new function.\n\t(pass_phiopt): Replace declaration with that of...\n\t(make_pass_phiopt): ...new function.\n\t(pass_forwprop): Replace declaration with that of...\n\t(make_pass_forwprop): ...new function.\n\t(pass_phiprop): Replace declaration with that of...\n\t(make_pass_phiprop): ...new function.\n\t(pass_tree_ifcombine): Replace declaration with that of...\n\t(make_pass_tree_ifcombine): ...new function.\n\t(pass_dse): Replace declaration with that of...\n\t(make_pass_dse): ...new function.\n\t(pass_nrv): Replace declaration with that of...\n\t(make_pass_nrv): ...new function.\n\t(pass_rename_ssa_copies): Replace declaration with that of...\n\t(make_pass_rename_ssa_copies): ...new function.\n\t(pass_sink_code): Replace declaration with that of...\n\t(make_pass_sink_code): ...new function.\n\t(pass_fre): Replace declaration with that of...\n\t(make_pass_fre): ...new function.\n\t(pass_check_data_deps): Replace declaration with that of...\n\t(make_pass_check_data_deps): ...new function.\n\t(pass_copy_prop): Replace declaration with that of...\n\t(make_pass_copy_prop): ...new function.\n\t(pass_vrp): Replace declaration with that of...\n\t(make_pass_vrp): ...new function.\n\t(pass_uncprop): Replace declaration with that of...\n\t(make_pass_uncprop): ...new function.\n\t(pass_return_slot): Replace declaration with that of...\n\t(make_pass_return_slot): ...new function.\n\t(pass_reassoc): Replace declaration with that of...\n\t(make_pass_reassoc): ...new function.\n\t(pass_rebuild_cgraph_edges): Replace declaration with that of...\n\t(make_pass_rebuild_cgraph_edges): ...new function.\n\t(pass_remove_cgraph_callee_edges): Replace declaration with that of...\n\t(make_pass_remove_cgraph_callee_edges): ...new function.\n\t(pass_build_cgraph_edges): Replace declaration with that of...\n\t(make_pass_build_cgraph_edges): ...new function.\n\t(pass_local_pure_const): Replace declaration with that of...\n\t(make_pass_local_pure_const): ...new function.\n\t(pass_tracer): Replace declaration with that of...\n\t(make_pass_tracer): ...new function.\n\t(pass_warn_unused_result): Replace declaration with that of...\n\t(make_pass_warn_unused_result): ...new function.\n\t(pass_diagnose_tm_blocks): Replace declaration with that of...\n\t(make_pass_diagnose_tm_blocks): ...new function.\n\t(pass_lower_tm): Replace declaration with that of...\n\t(make_pass_lower_tm): ...new function.\n\t(pass_tm_init): Replace declaration with that of...\n\t(make_pass_tm_init): ...new function.\n\t(pass_tm_mark): Replace declaration with that of...\n\t(make_pass_tm_mark): ...new function.\n\t(pass_tm_memopt): Replace declaration with that of...\n\t(make_pass_tm_memopt): ...new function.\n\t(pass_tm_edges): Replace declaration with that of...\n\t(make_pass_tm_edges): ...new function.\n\t(pass_split_functions): Replace declaration with that of...\n\t(make_pass_split_functions): ...new function.\n\t(pass_feedback_split_functions): Replace declaration with that of...\n\t(make_pass_feedback_split_functions): ...new function.\n\t(pass_strength_reduction): Replace declaration with that of...\n\t(make_pass_strength_reduction): ...new function.\n\t(pass_ipa_lower_emutls): Replace declaration with that of...\n\t(make_pass_ipa_lower_emutls): ...new function.\n\t(pass_ipa_function_and_variable_visibility): Replace declaration with\n\tthat of...\n\t(make_pass_ipa_function_and_variable_visibility): ...new function.\n\t(pass_ipa_tree_profile): Replace declaration with that of...\n\t(make_pass_ipa_tree_profile): ...new function.\n\t(pass_early_local_passes): Replace declaration with that of...\n\t(make_pass_early_local_passes): ...new function.\n\t(pass_ipa_whole_program_visibility): Replace declaration with that\n\tof...\n\t(make_pass_ipa_whole_program_visibility): ...new function.\n\t(pass_ipa_lto_gimple_out): Replace declaration with that of...\n\t(make_pass_ipa_lto_gimple_out): ...new function.\n\t(pass_ipa_increase_alignment): Replace declaration with that of...\n\t(make_pass_ipa_increase_alignment): ...new function.\n\t(pass_ipa_inline): Replace declaration with that of...\n\t(make_pass_ipa_inline): ...new function.\n\t(pass_ipa_free_lang_data): Replace declaration with that of...\n\t(make_pass_ipa_free_lang_data): ...new function.\n\t(pass_ipa_free_inline_summary): Replace declaration with that of...\n\t(make_pass_ipa_free_inline_summary): ...new function.\n\t(pass_ipa_cp): Replace declaration with that of...\n\t(make_pass_ipa_cp): ...new function.\n\t(pass_ipa_reference): Replace declaration with that of...\n\t(make_pass_ipa_reference): ...new function.\n\t(pass_ipa_pure_const): Replace declaration with that of...\n\t(make_pass_ipa_pure_const): ...new function.\n\t(pass_ipa_pta): Replace declaration with that of...\n\t(make_pass_ipa_pta): ...new function.\n\t(pass_ipa_lto_finish_out): Replace declaration with that of...\n\t(make_pass_ipa_lto_finish_out): ...new function.\n\t(pass_ipa_tm): Replace declaration with that of...\n\t(make_pass_ipa_tm): ...new function.\n\t(pass_ipa_profile): Replace declaration with that of...\n\t(make_pass_ipa_profile): ...new function.\n\t(pass_ipa_cdtor_merge): Replace declaration with that of...\n\t(make_pass_ipa_cdtor_merge): ...new function.\n\t(pass_cleanup_cfg_post_optimizing): Replace declaration with that\n\tof...\n\t(make_pass_cleanup_cfg_post_optimizing): ...new function.\n\t(pass_init_datastructures): Replace declaration with that of...\n\t(make_pass_init_datastructures): ...new function.\n\t(pass_fixup_cfg): Replace declaration with that of...\n\t(make_pass_fixup_cfg): ...new function.\n\t(pass_expand): Replace declaration with that of...\n\t(make_pass_expand): ...new function.\n\t(pass_instantiate_virtual_regs): Replace declaration with that of...\n\t(make_pass_instantiate_virtual_regs): ...new function.\n\t(pass_rtl_fwprop): Replace declaration with that of...\n\t(make_pass_rtl_fwprop): ...new function.\n\t(pass_rtl_fwprop_addr): Replace declaration with that of...\n\t(make_pass_rtl_fwprop_addr): ...new function.\n\t(pass_jump): Replace declaration with that of...\n\t(make_pass_jump): ...new function.\n\t(pass_jump2): Replace declaration with that of...\n\t(make_pass_jump2): ...new function.\n\t(pass_lower_subreg): Replace declaration with that of...\n\t(make_pass_lower_subreg): ...new function.\n\t(pass_cse): Replace declaration with that of...\n\t(make_pass_cse): ...new function.\n\t(pass_fast_rtl_dce): Replace declaration with that of...\n\t(make_pass_fast_rtl_dce): ...new function.\n\t(pass_ud_rtl_dce): Replace declaration with that of...\n\t(make_pass_ud_rtl_dce): ...new function.\n\t(pass_rtl_dce): Replace declaration with that of...\n\t(make_pass_rtl_dce): ...new function.\n\t(pass_rtl_dse1): Replace declaration with that of...\n\t(make_pass_rtl_dse1): ...new function.\n\t(pass_rtl_dse2): Replace declaration with that of...\n\t(make_pass_rtl_dse2): ...new function.\n\t(pass_rtl_dse3): Replace declaration with that of...\n\t(make_pass_rtl_dse3): ...new function.\n\t(pass_rtl_cprop): Replace declaration with that of...\n\t(make_pass_rtl_cprop): ...new function.\n\t(pass_rtl_pre): Replace declaration with that of...\n\t(make_pass_rtl_pre): ...new function.\n\t(pass_rtl_hoist): Replace declaration with that of...\n\t(make_pass_rtl_hoist): ...new function.\n\t(pass_rtl_store_motion): Replace declaration with that of...\n\t(make_pass_rtl_store_motion): ...new function.\n\t(pass_cse_after_global_opts): Replace declaration with that of...\n\t(make_pass_cse_after_global_opts): ...new function.\n\t(pass_rtl_ifcvt): Replace declaration with that of...\n\t(make_pass_rtl_ifcvt): ...new function.\n\t(pass_into_cfg_layout_mode): Replace declaration with that of...\n\t(make_pass_into_cfg_layout_mode): ...new function.\n\t(pass_outof_cfg_layout_mode): Replace declaration with that of...\n\t(make_pass_outof_cfg_layout_mode): ...new function.\n\t(pass_loop2): Replace declaration with that of...\n\t(make_pass_loop2): ...new function.\n\t(pass_rtl_loop_init): Replace declaration with that of...\n\t(make_pass_rtl_loop_init): ...new function.\n\t(pass_rtl_move_loop_invariants): Replace declaration with that of...\n\t(make_pass_rtl_move_loop_invariants): ...new function.\n\t(pass_rtl_unswitch): Replace declaration with that of...\n\t(make_pass_rtl_unswitch): ...new function.\n\t(pass_rtl_unroll_and_peel_loops): Replace declaration with that of...\n\t(make_pass_rtl_unroll_and_peel_loops): ...new function.\n\t(pass_rtl_doloop): Replace declaration with that of...\n\t(make_pass_rtl_doloop): ...new function.\n\t(pass_rtl_loop_done): Replace declaration with that of...\n\t(make_pass_rtl_loop_done): ...new function.\n\t(pass_web): Replace declaration with that of...\n\t(make_pass_web): ...new function.\n\t(pass_cse2): Replace declaration with that of...\n\t(make_pass_cse2): ...new function.\n\t(pass_df_initialize_opt): Replace declaration with that of...\n\t(make_pass_df_initialize_opt): ...new function.\n\t(pass_df_initialize_no_opt): Replace declaration with that of...\n\t(make_pass_df_initialize_no_opt): ...new function.\n\t(pass_reginfo_init): Replace declaration with that of...\n\t(make_pass_reginfo_init): ...new function.\n\t(pass_inc_dec): Replace declaration with that of...\n\t(make_pass_inc_dec): ...new function.\n\t(pass_stack_ptr_mod): Replace declaration with that of...\n\t(make_pass_stack_ptr_mod): ...new function.\n\t(pass_initialize_regs): Replace declaration with that of...\n\t(make_pass_initialize_regs): ...new function.\n\t(pass_combine): Replace declaration with that of...\n\t(make_pass_combine): ...new function.\n\t(pass_if_after_combine): Replace declaration with that of...\n\t(make_pass_if_after_combine): ...new function.\n\t(pass_ree): Replace declaration with that of...\n\t(make_pass_ree): ...new function.\n\t(pass_partition_blocks): Replace declaration with that of...\n\t(make_pass_partition_blocks): ...new function.\n\t(pass_match_asm_constraints): Replace declaration with that of...\n\t(make_pass_match_asm_constraints): ...new function.\n\t(pass_regmove): Replace declaration with that of...\n\t(make_pass_regmove): ...new function.\n\t(pass_split_all_insns): Replace declaration with that of...\n\t(make_pass_split_all_insns): ...new function.\n\t(pass_fast_rtl_byte_dce): Replace declaration with that of...\n\t(make_pass_fast_rtl_byte_dce): ...new function.\n\t(pass_lower_subreg2): Replace declaration with that of...\n\t(make_pass_lower_subreg2): ...new function.\n\t(pass_mode_switching): Replace declaration with that of...\n\t(make_pass_mode_switching): ...new function.\n\t(pass_sms): Replace declaration with that of...\n\t(make_pass_sms): ...new function.\n\t(pass_sched): Replace declaration with that of...\n\t(make_pass_sched): ...new function.\n\t(pass_ira): Replace declaration with that of...\n\t(make_pass_ira): ...new function.\n\t(pass_reload): Replace declaration with that of...\n\t(make_pass_reload): ...new function.\n\t(pass_clean_state): Replace declaration with that of...\n\t(make_pass_clean_state): ...new function.\n\t(pass_branch_prob): Replace declaration with that of...\n\t(make_pass_branch_prob): ...new function.\n\t(pass_value_profile_transformations): Replace declaration with that\n\tof...\n\t(make_pass_value_profile_transformations): ...new function.\n\t(pass_postreload_cse): Replace declaration with that of...\n\t(make_pass_postreload_cse): ...new function.\n\t(pass_gcse2): Replace declaration with that of...\n\t(make_pass_gcse2): ...new function.\n\t(pass_split_after_reload): Replace declaration with that of...\n\t(make_pass_split_after_reload): ...new function.\n\t(pass_branch_target_load_optimize1): Replace declaration with that\n\tof...\n\t(make_pass_branch_target_load_optimize1): ...new function.\n\t(pass_thread_prologue_and_epilogue): Replace declaration with that\n\tof...\n\t(make_pass_thread_prologue_and_epilogue): ...new function.\n\t(pass_stack_adjustments): Replace declaration with that of...\n\t(make_pass_stack_adjustments): ...new function.\n\t(pass_peephole2): Replace declaration with that of...\n\t(make_pass_peephole2): ...new function.\n\t(pass_if_after_reload): Replace declaration with that of...\n\t(make_pass_if_after_reload): ...new function.\n\t(pass_regrename): Replace declaration with that of...\n\t(make_pass_regrename): ...new function.\n\t(pass_cprop_hardreg): Replace declaration with that of...\n\t(make_pass_cprop_hardreg): ...new function.\n\t(pass_reorder_blocks): Replace declaration with that of...\n\t(make_pass_reorder_blocks): ...new function.\n\t(pass_branch_target_load_optimize2): Replace declaration with that\n\tof...\n\t(make_pass_branch_target_load_optimize2): ...new function.\n\t(pass_leaf_regs): Replace declaration with that of...\n\t(make_pass_leaf_regs): ...new function.\n\t(pass_split_before_sched2): Replace declaration with that of...\n\t(make_pass_split_before_sched2): ...new function.\n\t(pass_compare_elim_after_reload): Replace declaration with that of...\n\t(make_pass_compare_elim_after_reload): ...new function.\n\t(pass_sched2): Replace declaration with that of...\n\t(make_pass_sched2): ...new function.\n\t(pass_stack_regs): Replace declaration with that of...\n\t(make_pass_stack_regs): ...new function.\n\t(pass_stack_regs_run): Replace declaration with that of...\n\t(make_pass_stack_regs_run): ...new function.\n\t(pass_df_finish): Replace declaration with that of...\n\t(make_pass_df_finish): ...new function.\n\t(pass_compute_alignments): Replace declaration with that of...\n\t(make_pass_compute_alignments): ...new function.\n\t(pass_duplicate_computed_gotos): Replace declaration with that of...\n\t(make_pass_duplicate_computed_gotos): ...new function.\n\t(pass_variable_tracking): Replace declaration with that of...\n\t(make_pass_variable_tracking): ...new function.\n\t(pass_free_cfg): Replace declaration with that of...\n\t(make_pass_free_cfg): ...new function.\n\t(pass_machine_reorg): Replace declaration with that of...\n\t(make_pass_machine_reorg): ...new function.\n\t(pass_cleanup_barriers): Replace declaration with that of...\n\t(make_pass_cleanup_barriers): ...new function.\n\t(pass_delay_slots): Replace declaration with that of...\n\t(make_pass_delay_slots): ...new function.\n\t(pass_split_for_shorten_branches): Replace declaration with that of...\n\t(make_pass_split_for_shorten_branches): ...new function.\n\t(pass_split_before_regstack): Replace declaration with that of...\n\t(make_pass_split_before_regstack): ...new function.\n\t(pass_convert_to_eh_region_ranges): Replace declaration with that\n\tof...\n\t(make_pass_convert_to_eh_region_ranges): ...new function.\n\t(pass_shorten_branches): Replace declaration with that of...\n\t(make_pass_shorten_branches): ...new function.\n\t(pass_set_nothrow_function_flags): Replace declaration with that of...\n\t(make_pass_set_nothrow_function_flags): ...new function.\n\t(pass_dwarf2_frame): Replace declaration with that of...\n\t(make_pass_dwarf2_frame): ...new function.\n\t(pass_final): Replace declaration with that of...\n\t(make_pass_final): ...new function.\n\t(pass_rtl_seqabstr): Replace declaration with that of...\n\t(make_pass_rtl_seqabstr): ...new function.\n\t(pass_release_ssa_names): Replace declaration with that of...\n\t(make_pass_release_ssa_names): ...new function.\n\t(pass_early_inline): Replace declaration with that of...\n\t(make_pass_early_inline): ...new function.\n\t(pass_inline_parameters): Replace declaration with that of...\n\t(make_pass_inline_parameters): ...new function.\n\t(pass_update_address_taken): Replace declaration with that of...\n\t(make_pass_update_address_taken): ...new function.\n\t(pass_convert_switch): Replace declaration with that of...\n\t(make_pass_convert_switch): ...new function.\n\t* tree-profile.c (pass_ipa_tree_profile): Convert from a global struct\n\tto a subclass of simple_ipa_opt_pass along with...\n\t(pass_data_ipa_tree_profile): ...new pass_data instance and...\n\t(make_pass_ipa_tree_profile): ...new function.\n\t* tree-sra.c (pass_sra_early): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_sra_early): ...new pass_data instance and...\n\t(make_pass_sra_early): ...new function.\n\t(pass_sra): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_sra): ...new pass_data instance and...\n\t(make_pass_sra): ...new function.\n\t(pass_early_ipa_sra): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_early_ipa_sra): ...new pass_data instance and...\n\t(make_pass_early_ipa_sra): ...new function.\n\t* tree-ssa-ccp.c (pass_ccp): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_ccp): ...new pass_data instance and...\n\t(make_pass_ccp): ...new function.\n\t(pass_fold_builtins): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_fold_builtins): ...new pass_data instance and...\n\t(make_pass_fold_builtins): ...new function.\n\t* tree-ssa-copy.c (pass_copy_prop): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_copy_prop): ...new pass_data instance and...\n\t(make_pass_copy_prop): ...new function.\n\t* tree-ssa-copyrename.c (pass_rename_ssa_copies): Convert from a\n\tglobal struct to a subclass of gimple_opt_pass along with...\n\t(pass_data_rename_ssa_copies): ...new pass_data instance and...\n\t(make_pass_rename_ssa_copies): ...new function.\n\t* tree-ssa-dce.c (pass_dce): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_dce): ...new pass_data instance and...\n\t(make_pass_dce): ...new function.\n\t(pass_dce_loop): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_dce_loop): ...new pass_data instance and...\n\t(make_pass_dce_loop): ...new function.\n\t(pass_cd_dce): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_cd_dce): ...new pass_data instance and...\n\t(make_pass_cd_dce): ...new function.\n\t* tree-ssa-dom.c (pass_dominator): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_dominator): ...new pass_data instance and...\n\t(make_pass_dominator): ...new function.\n\t(pass_phi_only_cprop): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_phi_only_cprop): ...new pass_data instance and...\n\t(make_pass_phi_only_cprop): ...new function.\n\t* tree-ssa-dse.c (pass_dse): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_dse): ...new pass_data instance and...\n\t(make_pass_dse): ...new function.\n\t* tree-ssa-forwprop.c (pass_forwprop): Convert from a global struct to\n\ta subclass of gimple_opt_pass along with...\n\t(pass_data_forwprop): ...new pass_data instance and...\n\t(make_pass_forwprop): ...new function.\n\t* tree-ssa-ifcombine.c (pass_tree_ifcombine): Convert from a global\n\tstruct to a subclass of gimple_opt_pass along with...\n\t(pass_data_tree_ifcombine): ...new pass_data instance and...\n\t(make_pass_tree_ifcombine): ...new function.\n\t* tree-ssa-loop-ch.c (pass_ch): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_ch): ...new pass_data instance and...\n\t(make_pass_ch): ...new function.\n\t* tree-ssa-loop.c (pass_tree_loop): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_tree_loop): ...new pass_data instance and...\n\t(make_pass_tree_loop): ...new function.\n\t(pass_tree_loop_init): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_tree_loop_init): ...new pass_data instance and...\n\t(make_pass_tree_loop_init): ...new function.\n\t(pass_lim): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_lim): ...new pass_data instance and...\n\t(make_pass_lim): ...new function.\n\t(pass_tree_unswitch): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_tree_unswitch): ...new pass_data instance and...\n\t(make_pass_tree_unswitch): ...new function.\n\t(pass_predcom): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_predcom): ...new pass_data instance and...\n\t(make_pass_predcom): ...new function.\n\t(pass_vectorize): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_vectorize): ...new pass_data instance and...\n\t(make_pass_vectorize): ...new function.\n\t(pass_graphite): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_graphite): ...new pass_data instance and...\n\t(make_pass_graphite): ...new function.\n\t(pass_graphite_transforms): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_graphite_transforms): ...new pass_data instance and...\n\t(make_pass_graphite_transforms): ...new function.\n\t(pass_check_data_deps): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_check_data_deps): ...new pass_data instance and...\n\t(make_pass_check_data_deps): ...new function.\n\t(pass_iv_canon): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_iv_canon): ...new pass_data instance and...\n\t(make_pass_iv_canon): ...new function.\n\t(pass_scev_cprop): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_scev_cprop): ...new pass_data instance and...\n\t(make_pass_scev_cprop): ...new function.\n\t(pass_record_bounds): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_record_bounds): ...new pass_data instance and...\n\t(make_pass_record_bounds): ...new function.\n\t(pass_complete_unroll): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_complete_unroll): ...new pass_data instance and...\n\t(make_pass_complete_unroll): ...new function.\n\t(pass_complete_unrolli): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_complete_unrolli): ...new pass_data instance and...\n\t(make_pass_complete_unrolli): ...new function.\n\t(pass_parallelize_loops): Convert from a global struct to a subclass\n\tof gimple_opt_pass along with...\n\t(pass_data_parallelize_loops): ...new pass_data instance and...\n\t(make_pass_parallelize_loops): ...new function.\n\t(pass_loop_prefetch): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_loop_prefetch): ...new pass_data instance and...\n\t(make_pass_loop_prefetch): ...new function.\n\t(pass_iv_optimize): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_iv_optimize): ...new pass_data instance and...\n\t(make_pass_iv_optimize): ...new function.\n\t(pass_tree_loop_done): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_tree_loop_done): ...new pass_data instance and...\n\t(make_pass_tree_loop_done): ...new function.\n\t* tree-ssa-math-opts.c (pass_cse_reciprocals): Convert from a global\n\tstruct to a subclass of gimple_opt_pass along with...\n\t(pass_data_cse_reciprocals): ...new pass_data instance and...\n\t(make_pass_cse_reciprocals): ...new function.\n\t(pass_cse_sincos): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_cse_sincos): ...new pass_data instance and...\n\t(make_pass_cse_sincos): ...new function.\n\t(pass_optimize_bswap): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_optimize_bswap): ...new pass_data instance and...\n\t(make_pass_optimize_bswap): ...new function.\n\t(pass_optimize_widening_mul): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_optimize_widening_mul): ...new pass_data instance and...\n\t(make_pass_optimize_widening_mul): ...new function.\n\t* tree-ssa-phiopt.c (pass_phiopt): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_phiopt): ...new pass_data instance and...\n\t(make_pass_phiopt): ...new function.\n\t(pass_cselim): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_cselim): ...new pass_data instance and...\n\t(make_pass_cselim): ...new function.\n\t* tree-ssa-phiprop.c (pass_phiprop): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_phiprop): ...new pass_data instance and...\n\t(make_pass_phiprop): ...new function.\n\t* tree-ssa-pre.c (pass_pre): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_pre): ...new pass_data instance and...\n\t(make_pass_pre): ...new function.\n\t(pass_fre): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_fre): ...new pass_data instance and...\n\t(make_pass_fre): ...new function.\n\t* tree-ssa-reassoc.c (pass_reassoc): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_reassoc): ...new pass_data instance and...\n\t(make_pass_reassoc): ...new function.\n\t* tree-ssa-sink.c (pass_sink_code): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_sink_code): ...new pass_data instance and...\n\t(make_pass_sink_code): ...new function.\n\t* tree-ssa-strlen.c (pass_strlen): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_strlen): ...new pass_data instance and...\n\t(make_pass_strlen): ...new function.\n\t* tree-ssa-structalias.c (pass_build_alias): Convert from a global\n\tstruct to a subclass of gimple_opt_pass along with...\n\t(pass_data_build_alias): ...new pass_data instance and...\n\t(make_pass_build_alias): ...new function.\n\t(pass_build_ealias): Convert from a global struct to a subclass of\n\tgimple_opt_pass along with...\n\t(pass_data_build_ealias): ...new pass_data instance and...\n\t(make_pass_build_ealias): ...new function.\n\t(pass_ipa_pta): Convert from a global struct to a subclass of\n\tsimple_ipa_opt_pass along with...\n\t(pass_data_ipa_pta): ...new pass_data instance and...\n\t(make_pass_ipa_pta): ...new function.\n\t* tree-ssa-uncprop.c (pass_uncprop): Convert from a global struct to a\n\tsubclass of gimple_opt_pass along with...\n\t(pass_data_uncprop): ...new pass_data instance and...\n\t(make_pass_uncprop): ...new function.\n\t* tree-ssa-uninit.c (pass_late_warn_uninitialized): Convert from a\n\tglobal struct to a subclass of gimple_opt_pass along with...\n\t(pass_data_late_warn_uninitialized): ...new p\u2026", "tree": {"sha": "b105e4acdb46cfea28e3a0daa677474f84a2b4b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b105e4acdb46cfea28e3a0daa677474f84a2b4b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27a4cd485d3731293a42b7b324a7432a4af13443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a4cd485d3731293a42b7b324a7432a4af13443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27a4cd485d3731293a42b7b324a7432a4af13443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a4cd485d3731293a42b7b324a7432a4af13443/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a389ed508822befad6d8b994874b04a521431cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a389ed508822befad6d8b994874b04a521431cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a389ed508822befad6d8b994874b04a521431cc"}], "stats": {"total": 14176, "additions": 9811, "deletions": 4365}, "files": [{"sha": "f45646972cdca8429447d3cbb8c5d29e890a4c0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1373, "deletions": 0, "changes": 1373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1,3 +1,1376 @@\n+2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tThis is the automated part of the conversion of passes from C\n+\tstructs to C++ classes.\n+\n+\tPatch autogenerated by refactor_passes.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 03fe39476a4c4ea450b49e087cfa817b5f92021e\n+\n+\t* asan.c (pass_asan): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_asan): ...new pass_data instance and...\n+\t(make_pass_asan): ...new function.\n+\t(pass_asan_O0): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_asan_O0): ...new pass_data instance and...\n+\t(make_pass_asan_O0): ...new function.\n+\t* auto-inc-dec.c (pass_inc_dec): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_inc_dec): ...new pass_data instance and...\n+\t(make_pass_inc_dec): ...new function.\n+\t* bb-reorder.c (pass_reorder_blocks): Convert from a global struct to\n+\ta subclass of rtl_opt_pass along with...\n+\t(pass_data_reorder_blocks): ...new pass_data instance and...\n+\t(make_pass_reorder_blocks): ...new function.\n+\t(pass_duplicate_computed_gotos): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_duplicate_computed_gotos): ...new pass_data instance and...\n+\t(make_pass_duplicate_computed_gotos): ...new function.\n+\t(pass_partition_blocks): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_partition_blocks): ...new pass_data instance and...\n+\t(make_pass_partition_blocks): ...new function.\n+\t* bt-load.c (pass_branch_target_load_optimize1): Convert from a global\n+\tstruct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_branch_target_load_optimize1): ...new pass_data instance\n+\tand...\n+\t(make_pass_branch_target_load_optimize1): ...new function.\n+\t(pass_branch_target_load_optimize2): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_branch_target_load_optimize2): ...new pass_data instance\n+\tand...\n+\t(make_pass_branch_target_load_optimize2): ...new function.\n+\t* cfgcleanup.c (pass_jump): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_jump): ...new pass_data instance and...\n+\t(make_pass_jump): ...new function.\n+\t(pass_jump2): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_jump2): ...new pass_data instance and...\n+\t(make_pass_jump2): ...new function.\n+\t* cfgexpand.c (pass_expand): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_expand): ...new pass_data instance and...\n+\t(make_pass_expand): ...new function.\n+\t* cfgrtl.c (pass_free_cfg): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_free_cfg): ...new pass_data instance and...\n+\t(make_pass_free_cfg): ...new function.\n+\t(pass_into_cfg_layout_mode): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_into_cfg_layout_mode): ...new pass_data instance and...\n+\t(make_pass_into_cfg_layout_mode): ...new function.\n+\t(pass_outof_cfg_layout_mode): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_outof_cfg_layout_mode): ...new pass_data instance and...\n+\t(make_pass_outof_cfg_layout_mode): ...new function.\n+\t* cgraphbuild.c (pass_build_cgraph_edges): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_build_cgraph_edges): ...new pass_data instance and...\n+\t(make_pass_build_cgraph_edges): ...new function.\n+\t(pass_rebuild_cgraph_edges): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_rebuild_cgraph_edges): ...new pass_data instance and...\n+\t(make_pass_rebuild_cgraph_edges): ...new function.\n+\t(pass_remove_cgraph_callee_edges): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_remove_cgraph_callee_edges): ...new pass_data instance\n+\tand...\n+\t(make_pass_remove_cgraph_callee_edges): ...new function.\n+\t* combine-stack-adj.c (pass_stack_adjustments): Convert from a global\n+\tstruct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_stack_adjustments): ...new pass_data instance and...\n+\t(make_pass_stack_adjustments): ...new function.\n+\t* combine.c (pass_combine): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_combine): ...new pass_data instance and...\n+\t(make_pass_combine): ...new function.\n+\t* compare-elim.c (pass_compare_elim_after_reload): Convert from a\n+\tglobal struct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_compare_elim_after_reload): ...new pass_data instance\n+\tand...\n+\t(make_pass_compare_elim_after_reload): ...new function.\n+\t* cprop.c (pass_rtl_cprop): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_rtl_cprop): ...new pass_data instance and...\n+\t(make_pass_rtl_cprop): ...new function.\n+\t* cse.c (pass_cse): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_cse): ...new pass_data instance and...\n+\t(make_pass_cse): ...new function.\n+\t(pass_cse2): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_cse2): ...new pass_data instance and...\n+\t(make_pass_cse2): ...new function.\n+\t(pass_cse_after_global_opts): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_cse_after_global_opts): ...new pass_data instance and...\n+\t(make_pass_cse_after_global_opts): ...new function.\n+\t* dce.c (pass_ud_rtl_dce): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_ud_rtl_dce): ...new pass_data instance and...\n+\t(make_pass_ud_rtl_dce): ...new function.\n+\t(pass_fast_rtl_dce): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_fast_rtl_dce): ...new pass_data instance and...\n+\t(make_pass_fast_rtl_dce): ...new function.\n+\t* df-core.c (pass_df_initialize_opt): Convert from a global struct to\n+\ta subclass of rtl_opt_pass along with...\n+\t(pass_data_df_initialize_opt): ...new pass_data instance and...\n+\t(make_pass_df_initialize_opt): ...new function.\n+\t(pass_df_initialize_no_opt): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_df_initialize_no_opt): ...new pass_data instance and...\n+\t(make_pass_df_initialize_no_opt): ...new function.\n+\t(pass_df_finish): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_df_finish): ...new pass_data instance and...\n+\t(make_pass_df_finish): ...new function.\n+\t* dse.c (pass_rtl_dse1): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_dse1): ...new pass_data instance and...\n+\t(make_pass_rtl_dse1): ...new function.\n+\t(pass_rtl_dse2): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_dse2): ...new pass_data instance and...\n+\t(make_pass_rtl_dse2): ...new function.\n+\t* dwarf2cfi.c (pass_dwarf2_frame): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_dwarf2_frame): ...new pass_data instance and...\n+\t(make_pass_dwarf2_frame): ...new function.\n+\t* except.c (pass_set_nothrow_function_flags): Convert from a global\n+\tstruct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_set_nothrow_function_flags): ...new pass_data instance\n+\tand...\n+\t(make_pass_set_nothrow_function_flags): ...new function.\n+\t(pass_convert_to_eh_region_ranges): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_convert_to_eh_region_ranges): ...new pass_data instance\n+\tand...\n+\t(make_pass_convert_to_eh_region_ranges): ...new function.\n+\t* final.c (pass_compute_alignments): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_compute_alignments): ...new pass_data instance and...\n+\t(make_pass_compute_alignments): ...new function.\n+\t(pass_final): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_final): ...new pass_data instance and...\n+\t(make_pass_final): ...new function.\n+\t(pass_shorten_branches): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_shorten_branches): ...new pass_data instance and...\n+\t(make_pass_shorten_branches): ...new function.\n+\t(pass_clean_state): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_clean_state): ...new pass_data instance and...\n+\t(make_pass_clean_state): ...new function.\n+\t* function.c (pass_instantiate_virtual_regs): Convert from a global\n+\tstruct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_instantiate_virtual_regs): ...new pass_data instance and...\n+\t(make_pass_instantiate_virtual_regs): ...new function.\n+\t(pass_leaf_regs): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_leaf_regs): ...new pass_data instance and...\n+\t(make_pass_leaf_regs): ...new function.\n+\t(pass_thread_prologue_and_epilogue): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_thread_prologue_and_epilogue): ...new pass_data instance\n+\tand...\n+\t(make_pass_thread_prologue_and_epilogue): ...new function.\n+\t(pass_match_asm_constraints): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_match_asm_constraints): ...new pass_data instance and...\n+\t(make_pass_match_asm_constraints): ...new function.\n+\t* fwprop.c (pass_rtl_fwprop): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_rtl_fwprop): ...new pass_data instance and...\n+\t(make_pass_rtl_fwprop): ...new function.\n+\t(pass_rtl_fwprop_addr): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_fwprop_addr): ...new pass_data instance and...\n+\t(make_pass_rtl_fwprop_addr): ...new function.\n+\t* gcse.c (pass_rtl_pre): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_pre): ...new pass_data instance and...\n+\t(make_pass_rtl_pre): ...new function.\n+\t(pass_rtl_hoist): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_hoist): ...new pass_data instance and...\n+\t(make_pass_rtl_hoist): ...new function.\n+\t* gimple-low.c (pass_lower_cf): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_lower_cf): ...new pass_data instance and...\n+\t(make_pass_lower_cf): ...new function.\n+\t* gimple-ssa-strength-reduction.c (pass_strength_reduction): Convert\n+\tfrom a global struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_strength_reduction): ...new pass_data instance and...\n+\t(make_pass_strength_reduction): ...new function.\n+\t* ifcvt.c (pass_rtl_ifcvt): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_rtl_ifcvt): ...new pass_data instance and...\n+\t(make_pass_rtl_ifcvt): ...new function.\n+\t(pass_if_after_combine): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_if_after_combine): ...new pass_data instance and...\n+\t(make_pass_if_after_combine): ...new function.\n+\t(pass_if_after_reload): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_if_after_reload): ...new pass_data instance and...\n+\t(make_pass_if_after_reload): ...new function.\n+\t* init-regs.c (pass_initialize_regs): Convert from a global struct to\n+\ta subclass of rtl_opt_pass along with...\n+\t(pass_data_initialize_regs): ...new pass_data instance and...\n+\t(make_pass_initialize_regs): ...new function.\n+\t* ipa-cp.c (pass_ipa_cp): Convert from a global struct to a subclass\n+\tof ipa_opt_pass_d along with...\n+\t(pass_data_ipa_cp): ...new pass_data instance and...\n+\t(make_pass_ipa_cp): ...new function.\n+\t* ipa-inline-analysis.c (pass_inline_parameters): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_inline_parameters): ...new pass_data instance and...\n+\t(make_pass_inline_parameters): ...new function.\n+\t* ipa-inline.c (pass_early_inline): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_early_inline): ...new pass_data instance and...\n+\t(make_pass_early_inline): ...new function.\n+\t(pass_ipa_inline): Convert from a global struct to a subclass of\n+\tipa_opt_pass_d along with...\n+\t(pass_data_ipa_inline): ...new pass_data instance and...\n+\t(make_pass_ipa_inline): ...new function.\n+\t* ipa-pure-const.c (pass_local_pure_const): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_local_pure_const): ...new pass_data instance and...\n+\t(make_pass_local_pure_const): ...new function.\n+\t(pass_ipa_pure_const): Convert from a global struct to a subclass of\n+\tipa_opt_pass_d along with...\n+\t(pass_data_ipa_pure_const): ...new pass_data instance and...\n+\t(make_pass_ipa_pure_const): ...new function.\n+\t* ipa-reference.c (pass_ipa_reference): Convert from a global struct\n+\tto a subclass of ipa_opt_pass_d along with...\n+\t(pass_data_ipa_reference): ...new pass_data instance and...\n+\t(make_pass_ipa_reference): ...new function.\n+\t* ipa-split.c (pass_split_functions): Convert from a global struct to\n+\ta subclass of gimple_opt_pass along with...\n+\t(pass_data_split_functions): ...new pass_data instance and...\n+\t(make_pass_split_functions): ...new function.\n+\t(pass_feedback_split_functions): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_feedback_split_functions): ...new pass_data instance and...\n+\t(make_pass_feedback_split_functions): ...new function.\n+\t* ipa.c (pass_ipa_function_and_variable_visibility): Convert from a\n+\tglobal struct to a subclass of simple_ipa_opt_pass along with...\n+\t(pass_data_ipa_function_and_variable_visibility): ...new pass_data\n+\tinstance and...\n+\t(make_pass_ipa_function_and_variable_visibility): ...new function.\n+\t(pass_ipa_free_inline_summary): Convert from a global struct to a\n+\tsubclass of simple_ipa_opt_pass along with...\n+\t(pass_data_ipa_free_inline_summary): ...new pass_data instance and...\n+\t(make_pass_ipa_free_inline_summary): ...new function.\n+\t(pass_ipa_whole_program_visibility): Convert from a global struct to a\n+\tsubclass of ipa_opt_pass_d along with...\n+\t(pass_data_ipa_whole_program_visibility): ...new pass_data instance\n+\tand...\n+\t(make_pass_ipa_whole_program_visibility): ...new function.\n+\t(pass_ipa_profile): Convert from a global struct to a subclass of\n+\tipa_opt_pass_d along with...\n+\t(pass_data_ipa_profile): ...new pass_data instance and...\n+\t(make_pass_ipa_profile): ...new function.\n+\t(pass_ipa_cdtor_merge): Convert from a global struct to a subclass of\n+\tipa_opt_pass_d along with...\n+\t(pass_data_ipa_cdtor_merge): ...new pass_data instance and...\n+\t(make_pass_ipa_cdtor_merge): ...new function.\n+\t* ira.c (pass_ira): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_ira): ...new pass_data instance and...\n+\t(make_pass_ira): ...new function.\n+\t(pass_reload): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_reload): ...new pass_data instance and...\n+\t(make_pass_reload): ...new function.\n+\t* jump.c (pass_cleanup_barriers): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_cleanup_barriers): ...new pass_data instance and...\n+\t(make_pass_cleanup_barriers): ...new function.\n+\t* loop-init.c (pass_loop2): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_loop2): ...new pass_data instance and...\n+\t(make_pass_loop2): ...new function.\n+\t(pass_rtl_loop_init): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_loop_init): ...new pass_data instance and...\n+\t(make_pass_rtl_loop_init): ...new function.\n+\t(pass_rtl_loop_done): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_loop_done): ...new pass_data instance and...\n+\t(make_pass_rtl_loop_done): ...new function.\n+\t(pass_rtl_move_loop_invariants): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_rtl_move_loop_invariants): ...new pass_data instance and...\n+\t(make_pass_rtl_move_loop_invariants): ...new function.\n+\t(pass_rtl_unswitch): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_unswitch): ...new pass_data instance and...\n+\t(make_pass_rtl_unswitch): ...new function.\n+\t(pass_rtl_unroll_and_peel_loops): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_rtl_unroll_and_peel_loops): ...new pass_data instance\n+\tand...\n+\t(make_pass_rtl_unroll_and_peel_loops): ...new function.\n+\t(pass_rtl_doloop): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_rtl_doloop): ...new pass_data instance and...\n+\t(make_pass_rtl_doloop): ...new function.\n+\t* lower-subreg.c (pass_lower_subreg): Convert from a global struct to\n+\ta subclass of rtl_opt_pass along with...\n+\t(pass_data_lower_subreg): ...new pass_data instance and...\n+\t(make_pass_lower_subreg): ...new function.\n+\t(pass_lower_subreg2): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_lower_subreg2): ...new pass_data instance and...\n+\t(make_pass_lower_subreg2): ...new function.\n+\t* lto-streamer-out.c (pass_ipa_lto_gimple_out): Convert from a global\n+\tstruct to a subclass of ipa_opt_pass_d along with...\n+\t(pass_data_ipa_lto_gimple_out): ...new pass_data instance and...\n+\t(make_pass_ipa_lto_gimple_out): ...new function.\n+\t(pass_ipa_lto_finish_out): Convert from a global struct to a subclass\n+\tof ipa_opt_pass_d along with...\n+\t(pass_data_ipa_lto_finish_out): ...new pass_data instance and...\n+\t(make_pass_ipa_lto_finish_out): ...new function.\n+\t* mode-switching.c (pass_mode_switching): Convert from a global struct\n+\tto a subclass of rtl_opt_pass along with...\n+\t(pass_data_mode_switching): ...new pass_data instance and...\n+\t(make_pass_mode_switching): ...new function.\n+\t* modulo-sched.c (pass_sms): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_sms): ...new pass_data instance and...\n+\t(make_pass_sms): ...new function.\n+\t* omp-low.c (pass_expand_omp): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_expand_omp): ...new pass_data instance and...\n+\t(make_pass_expand_omp): ...new function.\n+\t(pass_lower_omp): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_lower_omp): ...new pass_data instance and...\n+\t(make_pass_lower_omp): ...new function.\n+\t(pass_diagnose_omp_blocks): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_diagnose_omp_blocks): ...new pass_data instance and...\n+\t(make_pass_diagnose_omp_blocks): ...new function.\n+\t* passes.c (pass_early_local_passes): Convert from a global struct to\n+\ta subclass of simple_ipa_opt_pass along with...\n+\t(pass_data_early_local_passes): ...new pass_data instance and...\n+\t(make_pass_early_local_passes): ...new function.\n+\t(pass_all_early_optimizations): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_all_early_optimizations): ...new pass_data instance and...\n+\t(make_pass_all_early_optimizations): ...new function.\n+\t(pass_all_optimizations): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_all_optimizations): ...new pass_data instance and...\n+\t(make_pass_all_optimizations): ...new function.\n+\t(pass_all_optimizations_g): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_all_optimizations_g): ...new pass_data instance and...\n+\t(make_pass_all_optimizations_g): ...new function.\n+\t(pass_rest_of_compilation): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_rest_of_compilation): ...new pass_data instance and...\n+\t(make_pass_rest_of_compilation): ...new function.\n+\t(pass_postreload): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_postreload): ...new pass_data instance and...\n+\t(make_pass_postreload): ...new function.\n+\t* postreload-gcse.c (pass_gcse2): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_gcse2): ...new pass_data instance and...\n+\t(make_pass_gcse2): ...new function.\n+\t* postreload.c (pass_postreload_cse): Convert from a global struct to\n+\ta subclass of rtl_opt_pass along with...\n+\t(pass_data_postreload_cse): ...new pass_data instance and...\n+\t(make_pass_postreload_cse): ...new function.\n+\t* predict.c (pass_profile): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_profile): ...new pass_data instance and...\n+\t(make_pass_profile): ...new function.\n+\t(pass_strip_predict_hints): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_strip_predict_hints): ...new pass_data instance and...\n+\t(make_pass_strip_predict_hints): ...new function.\n+\t* recog.c (pass_peephole2): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_peephole2): ...new pass_data instance and...\n+\t(make_pass_peephole2): ...new function.\n+\t(pass_split_all_insns): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_split_all_insns): ...new pass_data instance and...\n+\t(make_pass_split_all_insns): ...new function.\n+\t(pass_split_after_reload): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_split_after_reload): ...new pass_data instance and...\n+\t(make_pass_split_after_reload): ...new function.\n+\t(pass_split_before_regstack): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_split_before_regstack): ...new pass_data instance and...\n+\t(make_pass_split_before_regstack): ...new function.\n+\t(pass_split_before_sched2): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_split_before_sched2): ...new pass_data instance and...\n+\t(make_pass_split_before_sched2): ...new function.\n+\t(pass_split_for_shorten_branches): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_split_for_shorten_branches): ...new pass_data instance\n+\tand...\n+\t(make_pass_split_for_shorten_branches): ...new function.\n+\t* ree.c (pass_ree): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_ree): ...new pass_data instance and...\n+\t(make_pass_ree): ...new function.\n+\t* reg-stack.c (pass_stack_regs): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_stack_regs): ...new pass_data instance and...\n+\t(make_pass_stack_regs): ...new function.\n+\t(pass_stack_regs_run): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_stack_regs_run): ...new pass_data instance and...\n+\t(make_pass_stack_regs_run): ...new function.\n+\t* regcprop.c (pass_cprop_hardreg): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_cprop_hardreg): ...new pass_data instance and...\n+\t(make_pass_cprop_hardreg): ...new function.\n+\t* reginfo.c (pass_reginfo_init): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_reginfo_init): ...new pass_data instance and...\n+\t(make_pass_reginfo_init): ...new function.\n+\t* regmove.c (pass_regmove): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_regmove): ...new pass_data instance and...\n+\t(make_pass_regmove): ...new function.\n+\t* regrename.c (pass_regrename): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_regrename): ...new pass_data instance and...\n+\t(make_pass_regrename): ...new function.\n+\t* reorg.c (pass_delay_slots): Convert from a global struct to a\n+\tsubclass of rtl_opt_pass along with...\n+\t(pass_data_delay_slots): ...new pass_data instance and...\n+\t(make_pass_delay_slots): ...new function.\n+\t(pass_machine_reorg): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_machine_reorg): ...new pass_data instance and...\n+\t(make_pass_machine_reorg): ...new function.\n+\t* sched-rgn.c (pass_sched): Convert from a global struct to a subclass\n+\tof rtl_opt_pass along with...\n+\t(pass_data_sched): ...new pass_data instance and...\n+\t(make_pass_sched): ...new function.\n+\t(pass_sched2): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_sched2): ...new pass_data instance and...\n+\t(make_pass_sched2): ...new function.\n+\t* stack-ptr-mod.c (pass_stack_ptr_mod): Convert from a global struct\n+\tto a subclass of rtl_opt_pass along with...\n+\t(pass_data_stack_ptr_mod): ...new pass_data instance and...\n+\t(make_pass_stack_ptr_mod): ...new function.\n+\t* store-motion.c (pass_rtl_store_motion): Convert from a global struct\n+\tto a subclass of rtl_opt_pass along with...\n+\t(pass_data_rtl_store_motion): ...new pass_data instance and...\n+\t(make_pass_rtl_store_motion): ...new function.\n+\t* tracer.c (pass_tracer): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_tracer): ...new pass_data instance and...\n+\t(make_pass_tracer): ...new function.\n+\t* trans-mem.c (pass_diagnose_tm_blocks): Convert from a global struct\n+\tto a subclass of gimple_opt_pass along with...\n+\t(pass_data_diagnose_tm_blocks): ...new pass_data instance and...\n+\t(make_pass_diagnose_tm_blocks): ...new function.\n+\t(pass_lower_tm): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_lower_tm): ...new pass_data instance and...\n+\t(make_pass_lower_tm): ...new function.\n+\t(pass_tm_init): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tm_init): ...new pass_data instance and...\n+\t(make_pass_tm_init): ...new function.\n+\t(pass_tm_mark): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tm_mark): ...new pass_data instance and...\n+\t(make_pass_tm_mark): ...new function.\n+\t(pass_tm_edges): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tm_edges): ...new pass_data instance and...\n+\t(make_pass_tm_edges): ...new function.\n+\t(pass_tm_memopt): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tm_memopt): ...new pass_data instance and...\n+\t(make_pass_tm_memopt): ...new function.\n+\t(pass_ipa_tm): Convert from a global struct to a subclass of\n+\tsimple_ipa_opt_pass along with...\n+\t(pass_data_ipa_tm): ...new pass_data instance and...\n+\t(make_pass_ipa_tm): ...new function.\n+\t* tree-call-cdce.c (pass_call_cdce): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_call_cdce): ...new pass_data instance and...\n+\t(make_pass_call_cdce): ...new function.\n+\t* tree-cfg.c (pass_build_cfg): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_build_cfg): ...new pass_data instance and...\n+\t(make_pass_build_cfg): ...new function.\n+\t(pass_split_crit_edges): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_split_crit_edges): ...new pass_data instance and...\n+\t(make_pass_split_crit_edges): ...new function.\n+\t(pass_warn_function_return): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_warn_function_return): ...new pass_data instance and...\n+\t(make_pass_warn_function_return): ...new function.\n+\t(pass_warn_function_noreturn): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_warn_function_noreturn): ...new pass_data instance and...\n+\t(make_pass_warn_function_noreturn): ...new function.\n+\t(pass_warn_unused_result): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_warn_unused_result): ...new pass_data instance and...\n+\t(make_pass_warn_unused_result): ...new function.\n+\t* tree-cfgcleanup.c (pass_merge_phi): Convert from a global struct to\n+\ta subclass of gimple_opt_pass along with...\n+\t(pass_data_merge_phi): ...new pass_data instance and...\n+\t(make_pass_merge_phi): ...new function.\n+\t* tree-complex.c (pass_lower_complex): Convert from a global struct to\n+\ta subclass of gimple_opt_pass along with...\n+\t(pass_data_lower_complex): ...new pass_data instance and...\n+\t(make_pass_lower_complex): ...new function.\n+\t(pass_lower_complex_O0): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_lower_complex_O0): ...new pass_data instance and...\n+\t(make_pass_lower_complex_O0): ...new function.\n+\t* tree-eh.c (pass_lower_eh): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_lower_eh): ...new pass_data instance and...\n+\t(make_pass_lower_eh): ...new function.\n+\t(pass_refactor_eh): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_refactor_eh): ...new pass_data instance and...\n+\t(make_pass_refactor_eh): ...new function.\n+\t(pass_lower_resx): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_lower_resx): ...new pass_data instance and...\n+\t(make_pass_lower_resx): ...new function.\n+\t(pass_lower_eh_dispatch): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_lower_eh_dispatch): ...new pass_data instance and...\n+\t(make_pass_lower_eh_dispatch): ...new function.\n+\t(pass_cleanup_eh): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_cleanup_eh): ...new pass_data instance and...\n+\t(make_pass_cleanup_eh): ...new function.\n+\t* tree-emutls.c (pass_ipa_lower_emutls): Convert from a global struct\n+\tto a subclass of simple_ipa_opt_pass along with...\n+\t(pass_data_ipa_lower_emutls): ...new pass_data instance and...\n+\t(make_pass_ipa_lower_emutls): ...new function.\n+\t* tree-if-conv.c (pass_if_conversion): Convert from a global struct to\n+\ta subclass of gimple_opt_pass along with...\n+\t(pass_data_if_conversion): ...new pass_data instance and...\n+\t(make_pass_if_conversion): ...new function.\n+\t* tree-into-ssa.c (pass_build_ssa): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_build_ssa): ...new pass_data instance and...\n+\t(make_pass_build_ssa): ...new function.\n+\t* tree-loop-distribution.c (pass_loop_distribution): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_loop_distribution): ...new pass_data instance and...\n+\t(make_pass_loop_distribution): ...new function.\n+\t* tree-mudflap.c (pass_mudflap_1): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_mudflap_1): ...new pass_data instance and...\n+\t(make_pass_mudflap_1): ...new function.\n+\t(pass_mudflap_2): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_mudflap_2): ...new pass_data instance and...\n+\t(make_pass_mudflap_2): ...new function.\n+\t* tree-nomudflap.c (pass_mudflap_1): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_mudflap_1): ...new pass_data instance and...\n+\t(make_pass_mudflap_1): ...new function.\n+\t(pass_mudflap_2): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_mudflap_2): ...new pass_data instance and...\n+\t(make_pass_mudflap_2): ...new function.\n+\t* tree-nrv.c (pass_nrv): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_nrv): ...new pass_data instance and...\n+\t(make_pass_nrv): ...new function.\n+\t(pass_return_slot): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_return_slot): ...new pass_data instance and...\n+\t(make_pass_return_slot): ...new function.\n+\t* tree-object-size.c (pass_object_sizes): Convert from a global struct\n+\tto a subclass of gimple_opt_pass along with...\n+\t(pass_data_object_sizes): ...new pass_data instance and...\n+\t(make_pass_object_sizes): ...new function.\n+\t* tree-optimize.c (pass_cleanup_cfg_post_optimizing): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_cleanup_cfg_post_optimizing): ...new pass_data instance\n+\tand...\n+\t(make_pass_cleanup_cfg_post_optimizing): ...new function.\n+\t(pass_fixup_cfg): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_fixup_cfg): ...new pass_data instance and...\n+\t(make_pass_fixup_cfg): ...new function.\n+\t* tree-pass.h (pass_mudflap_1): Replace declaration with that of...\n+\t(make_pass_mudflap_1): ...new function.\n+\t(pass_mudflap_2): Replace declaration with that of...\n+\t(make_pass_mudflap_2): ...new function.\n+\t(pass_asan): Replace declaration with that of...\n+\t(make_pass_asan): ...new function.\n+\t(pass_asan_O0): Replace declaration with that of...\n+\t(make_pass_asan_O0): ...new function.\n+\t(pass_tsan): Replace declaration with that of...\n+\t(make_pass_tsan): ...new function.\n+\t(pass_tsan_O0): Replace declaration with that of...\n+\t(make_pass_tsan_O0): ...new function.\n+\t(pass_lower_cf): Replace declaration with that of...\n+\t(make_pass_lower_cf): ...new function.\n+\t(pass_refactor_eh): Replace declaration with that of...\n+\t(make_pass_refactor_eh): ...new function.\n+\t(pass_lower_eh): Replace declaration with that of...\n+\t(make_pass_lower_eh): ...new function.\n+\t(pass_lower_eh_dispatch): Replace declaration with that of...\n+\t(make_pass_lower_eh_dispatch): ...new function.\n+\t(pass_lower_resx): Replace declaration with that of...\n+\t(make_pass_lower_resx): ...new function.\n+\t(pass_build_cfg): Replace declaration with that of...\n+\t(make_pass_build_cfg): ...new function.\n+\t(pass_early_tree_profile): Replace declaration with that of...\n+\t(make_pass_early_tree_profile): ...new function.\n+\t(pass_cleanup_eh): Replace declaration with that of...\n+\t(make_pass_cleanup_eh): ...new function.\n+\t(pass_sra): Replace declaration with that of...\n+\t(make_pass_sra): ...new function.\n+\t(pass_sra_early): Replace declaration with that of...\n+\t(make_pass_sra_early): ...new function.\n+\t(pass_early_ipa_sra): Replace declaration with that of...\n+\t(make_pass_early_ipa_sra): ...new function.\n+\t(pass_tail_recursion): Replace declaration with that of...\n+\t(make_pass_tail_recursion): ...new function.\n+\t(pass_tail_calls): Replace declaration with that of...\n+\t(make_pass_tail_calls): ...new function.\n+\t(pass_tree_loop): Replace declaration with that of...\n+\t(make_pass_tree_loop): ...new function.\n+\t(pass_tree_loop_init): Replace declaration with that of...\n+\t(make_pass_tree_loop_init): ...new function.\n+\t(pass_lim): Replace declaration with that of...\n+\t(make_pass_lim): ...new function.\n+\t(pass_tree_unswitch): Replace declaration with that of...\n+\t(make_pass_tree_unswitch): ...new function.\n+\t(pass_predcom): Replace declaration with that of...\n+\t(make_pass_predcom): ...new function.\n+\t(pass_iv_canon): Replace declaration with that of...\n+\t(make_pass_iv_canon): ...new function.\n+\t(pass_scev_cprop): Replace declaration with that of...\n+\t(make_pass_scev_cprop): ...new function.\n+\t(pass_empty_loop): Replace declaration with that of...\n+\t(make_pass_empty_loop): ...new function.\n+\t(pass_record_bounds): Replace declaration with that of...\n+\t(make_pass_record_bounds): ...new function.\n+\t(pass_graphite): Replace declaration with that of...\n+\t(make_pass_graphite): ...new function.\n+\t(pass_graphite_transforms): Replace declaration with that of...\n+\t(make_pass_graphite_transforms): ...new function.\n+\t(pass_if_conversion): Replace declaration with that of...\n+\t(make_pass_if_conversion): ...new function.\n+\t(pass_loop_distribution): Replace declaration with that of...\n+\t(make_pass_loop_distribution): ...new function.\n+\t(pass_vectorize): Replace declaration with that of...\n+\t(make_pass_vectorize): ...new function.\n+\t(pass_slp_vectorize): Replace declaration with that of...\n+\t(make_pass_slp_vectorize): ...new function.\n+\t(pass_complete_unroll): Replace declaration with that of...\n+\t(make_pass_complete_unroll): ...new function.\n+\t(pass_complete_unrolli): Replace declaration with that of...\n+\t(make_pass_complete_unrolli): ...new function.\n+\t(pass_parallelize_loops): Replace declaration with that of...\n+\t(make_pass_parallelize_loops): ...new function.\n+\t(pass_loop_prefetch): Replace declaration with that of...\n+\t(make_pass_loop_prefetch): ...new function.\n+\t(pass_iv_optimize): Replace declaration with that of...\n+\t(make_pass_iv_optimize): ...new function.\n+\t(pass_tree_loop_done): Replace declaration with that of...\n+\t(make_pass_tree_loop_done): ...new function.\n+\t(pass_ch): Replace declaration with that of...\n+\t(make_pass_ch): ...new function.\n+\t(pass_ccp): Replace declaration with that of...\n+\t(make_pass_ccp): ...new function.\n+\t(pass_phi_only_cprop): Replace declaration with that of...\n+\t(make_pass_phi_only_cprop): ...new function.\n+\t(pass_build_ssa): Replace declaration with that of...\n+\t(make_pass_build_ssa): ...new function.\n+\t(pass_build_alias): Replace declaration with that of...\n+\t(make_pass_build_alias): ...new function.\n+\t(pass_build_ealias): Replace declaration with that of...\n+\t(make_pass_build_ealias): ...new function.\n+\t(pass_dominator): Replace declaration with that of...\n+\t(make_pass_dominator): ...new function.\n+\t(pass_dce): Replace declaration with that of...\n+\t(make_pass_dce): ...new function.\n+\t(pass_dce_loop): Replace declaration with that of...\n+\t(make_pass_dce_loop): ...new function.\n+\t(pass_cd_dce): Replace declaration with that of...\n+\t(make_pass_cd_dce): ...new function.\n+\t(pass_call_cdce): Replace declaration with that of...\n+\t(make_pass_call_cdce): ...new function.\n+\t(pass_merge_phi): Replace declaration with that of...\n+\t(make_pass_merge_phi): ...new function.\n+\t(pass_split_crit_edges): Replace declaration with that of...\n+\t(make_pass_split_crit_edges): ...new function.\n+\t(pass_pre): Replace declaration with that of...\n+\t(make_pass_pre): ...new function.\n+\t(pass_profile): Replace declaration with that of...\n+\t(make_pass_profile): ...new function.\n+\t(pass_strip_predict_hints): Replace declaration with that of...\n+\t(make_pass_strip_predict_hints): ...new function.\n+\t(pass_lower_complex_O0): Replace declaration with that of...\n+\t(make_pass_lower_complex_O0): ...new function.\n+\t(pass_lower_complex): Replace declaration with that of...\n+\t(make_pass_lower_complex): ...new function.\n+\t(pass_lower_vector): Replace declaration with that of...\n+\t(make_pass_lower_vector): ...new function.\n+\t(pass_lower_vector_ssa): Replace declaration with that of...\n+\t(make_pass_lower_vector_ssa): ...new function.\n+\t(pass_lower_omp): Replace declaration with that of...\n+\t(make_pass_lower_omp): ...new function.\n+\t(pass_diagnose_omp_blocks): Replace declaration with that of...\n+\t(make_pass_diagnose_omp_blocks): ...new function.\n+\t(pass_expand_omp): Replace declaration with that of...\n+\t(make_pass_expand_omp): ...new function.\n+\t(pass_expand_omp_ssa): Replace declaration with that of...\n+\t(make_pass_expand_omp_ssa): ...new function.\n+\t(pass_object_sizes): Replace declaration with that of...\n+\t(make_pass_object_sizes): ...new function.\n+\t(pass_strlen): Replace declaration with that of...\n+\t(make_pass_strlen): ...new function.\n+\t(pass_fold_builtins): Replace declaration with that of...\n+\t(make_pass_fold_builtins): ...new function.\n+\t(pass_stdarg): Replace declaration with that of...\n+\t(make_pass_stdarg): ...new function.\n+\t(pass_early_warn_uninitialized): Replace declaration with that of...\n+\t(make_pass_early_warn_uninitialized): ...new function.\n+\t(pass_late_warn_uninitialized): Replace declaration with that of...\n+\t(make_pass_late_warn_uninitialized): ...new function.\n+\t(pass_cse_reciprocals): Replace declaration with that of...\n+\t(make_pass_cse_reciprocals): ...new function.\n+\t(pass_cse_sincos): Replace declaration with that of...\n+\t(make_pass_cse_sincos): ...new function.\n+\t(pass_optimize_bswap): Replace declaration with that of...\n+\t(make_pass_optimize_bswap): ...new function.\n+\t(pass_optimize_widening_mul): Replace declaration with that of...\n+\t(make_pass_optimize_widening_mul): ...new function.\n+\t(pass_warn_function_return): Replace declaration with that of...\n+\t(make_pass_warn_function_return): ...new function.\n+\t(pass_warn_function_noreturn): Replace declaration with that of...\n+\t(make_pass_warn_function_noreturn): ...new function.\n+\t(pass_cselim): Replace declaration with that of...\n+\t(make_pass_cselim): ...new function.\n+\t(pass_phiopt): Replace declaration with that of...\n+\t(make_pass_phiopt): ...new function.\n+\t(pass_forwprop): Replace declaration with that of...\n+\t(make_pass_forwprop): ...new function.\n+\t(pass_phiprop): Replace declaration with that of...\n+\t(make_pass_phiprop): ...new function.\n+\t(pass_tree_ifcombine): Replace declaration with that of...\n+\t(make_pass_tree_ifcombine): ...new function.\n+\t(pass_dse): Replace declaration with that of...\n+\t(make_pass_dse): ...new function.\n+\t(pass_nrv): Replace declaration with that of...\n+\t(make_pass_nrv): ...new function.\n+\t(pass_rename_ssa_copies): Replace declaration with that of...\n+\t(make_pass_rename_ssa_copies): ...new function.\n+\t(pass_sink_code): Replace declaration with that of...\n+\t(make_pass_sink_code): ...new function.\n+\t(pass_fre): Replace declaration with that of...\n+\t(make_pass_fre): ...new function.\n+\t(pass_check_data_deps): Replace declaration with that of...\n+\t(make_pass_check_data_deps): ...new function.\n+\t(pass_copy_prop): Replace declaration with that of...\n+\t(make_pass_copy_prop): ...new function.\n+\t(pass_vrp): Replace declaration with that of...\n+\t(make_pass_vrp): ...new function.\n+\t(pass_uncprop): Replace declaration with that of...\n+\t(make_pass_uncprop): ...new function.\n+\t(pass_return_slot): Replace declaration with that of...\n+\t(make_pass_return_slot): ...new function.\n+\t(pass_reassoc): Replace declaration with that of...\n+\t(make_pass_reassoc): ...new function.\n+\t(pass_rebuild_cgraph_edges): Replace declaration with that of...\n+\t(make_pass_rebuild_cgraph_edges): ...new function.\n+\t(pass_remove_cgraph_callee_edges): Replace declaration with that of...\n+\t(make_pass_remove_cgraph_callee_edges): ...new function.\n+\t(pass_build_cgraph_edges): Replace declaration with that of...\n+\t(make_pass_build_cgraph_edges): ...new function.\n+\t(pass_local_pure_const): Replace declaration with that of...\n+\t(make_pass_local_pure_const): ...new function.\n+\t(pass_tracer): Replace declaration with that of...\n+\t(make_pass_tracer): ...new function.\n+\t(pass_warn_unused_result): Replace declaration with that of...\n+\t(make_pass_warn_unused_result): ...new function.\n+\t(pass_diagnose_tm_blocks): Replace declaration with that of...\n+\t(make_pass_diagnose_tm_blocks): ...new function.\n+\t(pass_lower_tm): Replace declaration with that of...\n+\t(make_pass_lower_tm): ...new function.\n+\t(pass_tm_init): Replace declaration with that of...\n+\t(make_pass_tm_init): ...new function.\n+\t(pass_tm_mark): Replace declaration with that of...\n+\t(make_pass_tm_mark): ...new function.\n+\t(pass_tm_memopt): Replace declaration with that of...\n+\t(make_pass_tm_memopt): ...new function.\n+\t(pass_tm_edges): Replace declaration with that of...\n+\t(make_pass_tm_edges): ...new function.\n+\t(pass_split_functions): Replace declaration with that of...\n+\t(make_pass_split_functions): ...new function.\n+\t(pass_feedback_split_functions): Replace declaration with that of...\n+\t(make_pass_feedback_split_functions): ...new function.\n+\t(pass_strength_reduction): Replace declaration with that of...\n+\t(make_pass_strength_reduction): ...new function.\n+\t(pass_ipa_lower_emutls): Replace declaration with that of...\n+\t(make_pass_ipa_lower_emutls): ...new function.\n+\t(pass_ipa_function_and_variable_visibility): Replace declaration with\n+\tthat of...\n+\t(make_pass_ipa_function_and_variable_visibility): ...new function.\n+\t(pass_ipa_tree_profile): Replace declaration with that of...\n+\t(make_pass_ipa_tree_profile): ...new function.\n+\t(pass_early_local_passes): Replace declaration with that of...\n+\t(make_pass_early_local_passes): ...new function.\n+\t(pass_ipa_whole_program_visibility): Replace declaration with that\n+\tof...\n+\t(make_pass_ipa_whole_program_visibility): ...new function.\n+\t(pass_ipa_lto_gimple_out): Replace declaration with that of...\n+\t(make_pass_ipa_lto_gimple_out): ...new function.\n+\t(pass_ipa_increase_alignment): Replace declaration with that of...\n+\t(make_pass_ipa_increase_alignment): ...new function.\n+\t(pass_ipa_inline): Replace declaration with that of...\n+\t(make_pass_ipa_inline): ...new function.\n+\t(pass_ipa_free_lang_data): Replace declaration with that of...\n+\t(make_pass_ipa_free_lang_data): ...new function.\n+\t(pass_ipa_free_inline_summary): Replace declaration with that of...\n+\t(make_pass_ipa_free_inline_summary): ...new function.\n+\t(pass_ipa_cp): Replace declaration with that of...\n+\t(make_pass_ipa_cp): ...new function.\n+\t(pass_ipa_reference): Replace declaration with that of...\n+\t(make_pass_ipa_reference): ...new function.\n+\t(pass_ipa_pure_const): Replace declaration with that of...\n+\t(make_pass_ipa_pure_const): ...new function.\n+\t(pass_ipa_pta): Replace declaration with that of...\n+\t(make_pass_ipa_pta): ...new function.\n+\t(pass_ipa_lto_finish_out): Replace declaration with that of...\n+\t(make_pass_ipa_lto_finish_out): ...new function.\n+\t(pass_ipa_tm): Replace declaration with that of...\n+\t(make_pass_ipa_tm): ...new function.\n+\t(pass_ipa_profile): Replace declaration with that of...\n+\t(make_pass_ipa_profile): ...new function.\n+\t(pass_ipa_cdtor_merge): Replace declaration with that of...\n+\t(make_pass_ipa_cdtor_merge): ...new function.\n+\t(pass_cleanup_cfg_post_optimizing): Replace declaration with that\n+\tof...\n+\t(make_pass_cleanup_cfg_post_optimizing): ...new function.\n+\t(pass_init_datastructures): Replace declaration with that of...\n+\t(make_pass_init_datastructures): ...new function.\n+\t(pass_fixup_cfg): Replace declaration with that of...\n+\t(make_pass_fixup_cfg): ...new function.\n+\t(pass_expand): Replace declaration with that of...\n+\t(make_pass_expand): ...new function.\n+\t(pass_instantiate_virtual_regs): Replace declaration with that of...\n+\t(make_pass_instantiate_virtual_regs): ...new function.\n+\t(pass_rtl_fwprop): Replace declaration with that of...\n+\t(make_pass_rtl_fwprop): ...new function.\n+\t(pass_rtl_fwprop_addr): Replace declaration with that of...\n+\t(make_pass_rtl_fwprop_addr): ...new function.\n+\t(pass_jump): Replace declaration with that of...\n+\t(make_pass_jump): ...new function.\n+\t(pass_jump2): Replace declaration with that of...\n+\t(make_pass_jump2): ...new function.\n+\t(pass_lower_subreg): Replace declaration with that of...\n+\t(make_pass_lower_subreg): ...new function.\n+\t(pass_cse): Replace declaration with that of...\n+\t(make_pass_cse): ...new function.\n+\t(pass_fast_rtl_dce): Replace declaration with that of...\n+\t(make_pass_fast_rtl_dce): ...new function.\n+\t(pass_ud_rtl_dce): Replace declaration with that of...\n+\t(make_pass_ud_rtl_dce): ...new function.\n+\t(pass_rtl_dce): Replace declaration with that of...\n+\t(make_pass_rtl_dce): ...new function.\n+\t(pass_rtl_dse1): Replace declaration with that of...\n+\t(make_pass_rtl_dse1): ...new function.\n+\t(pass_rtl_dse2): Replace declaration with that of...\n+\t(make_pass_rtl_dse2): ...new function.\n+\t(pass_rtl_dse3): Replace declaration with that of...\n+\t(make_pass_rtl_dse3): ...new function.\n+\t(pass_rtl_cprop): Replace declaration with that of...\n+\t(make_pass_rtl_cprop): ...new function.\n+\t(pass_rtl_pre): Replace declaration with that of...\n+\t(make_pass_rtl_pre): ...new function.\n+\t(pass_rtl_hoist): Replace declaration with that of...\n+\t(make_pass_rtl_hoist): ...new function.\n+\t(pass_rtl_store_motion): Replace declaration with that of...\n+\t(make_pass_rtl_store_motion): ...new function.\n+\t(pass_cse_after_global_opts): Replace declaration with that of...\n+\t(make_pass_cse_after_global_opts): ...new function.\n+\t(pass_rtl_ifcvt): Replace declaration with that of...\n+\t(make_pass_rtl_ifcvt): ...new function.\n+\t(pass_into_cfg_layout_mode): Replace declaration with that of...\n+\t(make_pass_into_cfg_layout_mode): ...new function.\n+\t(pass_outof_cfg_layout_mode): Replace declaration with that of...\n+\t(make_pass_outof_cfg_layout_mode): ...new function.\n+\t(pass_loop2): Replace declaration with that of...\n+\t(make_pass_loop2): ...new function.\n+\t(pass_rtl_loop_init): Replace declaration with that of...\n+\t(make_pass_rtl_loop_init): ...new function.\n+\t(pass_rtl_move_loop_invariants): Replace declaration with that of...\n+\t(make_pass_rtl_move_loop_invariants): ...new function.\n+\t(pass_rtl_unswitch): Replace declaration with that of...\n+\t(make_pass_rtl_unswitch): ...new function.\n+\t(pass_rtl_unroll_and_peel_loops): Replace declaration with that of...\n+\t(make_pass_rtl_unroll_and_peel_loops): ...new function.\n+\t(pass_rtl_doloop): Replace declaration with that of...\n+\t(make_pass_rtl_doloop): ...new function.\n+\t(pass_rtl_loop_done): Replace declaration with that of...\n+\t(make_pass_rtl_loop_done): ...new function.\n+\t(pass_web): Replace declaration with that of...\n+\t(make_pass_web): ...new function.\n+\t(pass_cse2): Replace declaration with that of...\n+\t(make_pass_cse2): ...new function.\n+\t(pass_df_initialize_opt): Replace declaration with that of...\n+\t(make_pass_df_initialize_opt): ...new function.\n+\t(pass_df_initialize_no_opt): Replace declaration with that of...\n+\t(make_pass_df_initialize_no_opt): ...new function.\n+\t(pass_reginfo_init): Replace declaration with that of...\n+\t(make_pass_reginfo_init): ...new function.\n+\t(pass_inc_dec): Replace declaration with that of...\n+\t(make_pass_inc_dec): ...new function.\n+\t(pass_stack_ptr_mod): Replace declaration with that of...\n+\t(make_pass_stack_ptr_mod): ...new function.\n+\t(pass_initialize_regs): Replace declaration with that of...\n+\t(make_pass_initialize_regs): ...new function.\n+\t(pass_combine): Replace declaration with that of...\n+\t(make_pass_combine): ...new function.\n+\t(pass_if_after_combine): Replace declaration with that of...\n+\t(make_pass_if_after_combine): ...new function.\n+\t(pass_ree): Replace declaration with that of...\n+\t(make_pass_ree): ...new function.\n+\t(pass_partition_blocks): Replace declaration with that of...\n+\t(make_pass_partition_blocks): ...new function.\n+\t(pass_match_asm_constraints): Replace declaration with that of...\n+\t(make_pass_match_asm_constraints): ...new function.\n+\t(pass_regmove): Replace declaration with that of...\n+\t(make_pass_regmove): ...new function.\n+\t(pass_split_all_insns): Replace declaration with that of...\n+\t(make_pass_split_all_insns): ...new function.\n+\t(pass_fast_rtl_byte_dce): Replace declaration with that of...\n+\t(make_pass_fast_rtl_byte_dce): ...new function.\n+\t(pass_lower_subreg2): Replace declaration with that of...\n+\t(make_pass_lower_subreg2): ...new function.\n+\t(pass_mode_switching): Replace declaration with that of...\n+\t(make_pass_mode_switching): ...new function.\n+\t(pass_sms): Replace declaration with that of...\n+\t(make_pass_sms): ...new function.\n+\t(pass_sched): Replace declaration with that of...\n+\t(make_pass_sched): ...new function.\n+\t(pass_ira): Replace declaration with that of...\n+\t(make_pass_ira): ...new function.\n+\t(pass_reload): Replace declaration with that of...\n+\t(make_pass_reload): ...new function.\n+\t(pass_clean_state): Replace declaration with that of...\n+\t(make_pass_clean_state): ...new function.\n+\t(pass_branch_prob): Replace declaration with that of...\n+\t(make_pass_branch_prob): ...new function.\n+\t(pass_value_profile_transformations): Replace declaration with that\n+\tof...\n+\t(make_pass_value_profile_transformations): ...new function.\n+\t(pass_postreload_cse): Replace declaration with that of...\n+\t(make_pass_postreload_cse): ...new function.\n+\t(pass_gcse2): Replace declaration with that of...\n+\t(make_pass_gcse2): ...new function.\n+\t(pass_split_after_reload): Replace declaration with that of...\n+\t(make_pass_split_after_reload): ...new function.\n+\t(pass_branch_target_load_optimize1): Replace declaration with that\n+\tof...\n+\t(make_pass_branch_target_load_optimize1): ...new function.\n+\t(pass_thread_prologue_and_epilogue): Replace declaration with that\n+\tof...\n+\t(make_pass_thread_prologue_and_epilogue): ...new function.\n+\t(pass_stack_adjustments): Replace declaration with that of...\n+\t(make_pass_stack_adjustments): ...new function.\n+\t(pass_peephole2): Replace declaration with that of...\n+\t(make_pass_peephole2): ...new function.\n+\t(pass_if_after_reload): Replace declaration with that of...\n+\t(make_pass_if_after_reload): ...new function.\n+\t(pass_regrename): Replace declaration with that of...\n+\t(make_pass_regrename): ...new function.\n+\t(pass_cprop_hardreg): Replace declaration with that of...\n+\t(make_pass_cprop_hardreg): ...new function.\n+\t(pass_reorder_blocks): Replace declaration with that of...\n+\t(make_pass_reorder_blocks): ...new function.\n+\t(pass_branch_target_load_optimize2): Replace declaration with that\n+\tof...\n+\t(make_pass_branch_target_load_optimize2): ...new function.\n+\t(pass_leaf_regs): Replace declaration with that of...\n+\t(make_pass_leaf_regs): ...new function.\n+\t(pass_split_before_sched2): Replace declaration with that of...\n+\t(make_pass_split_before_sched2): ...new function.\n+\t(pass_compare_elim_after_reload): Replace declaration with that of...\n+\t(make_pass_compare_elim_after_reload): ...new function.\n+\t(pass_sched2): Replace declaration with that of...\n+\t(make_pass_sched2): ...new function.\n+\t(pass_stack_regs): Replace declaration with that of...\n+\t(make_pass_stack_regs): ...new function.\n+\t(pass_stack_regs_run): Replace declaration with that of...\n+\t(make_pass_stack_regs_run): ...new function.\n+\t(pass_df_finish): Replace declaration with that of...\n+\t(make_pass_df_finish): ...new function.\n+\t(pass_compute_alignments): Replace declaration with that of...\n+\t(make_pass_compute_alignments): ...new function.\n+\t(pass_duplicate_computed_gotos): Replace declaration with that of...\n+\t(make_pass_duplicate_computed_gotos): ...new function.\n+\t(pass_variable_tracking): Replace declaration with that of...\n+\t(make_pass_variable_tracking): ...new function.\n+\t(pass_free_cfg): Replace declaration with that of...\n+\t(make_pass_free_cfg): ...new function.\n+\t(pass_machine_reorg): Replace declaration with that of...\n+\t(make_pass_machine_reorg): ...new function.\n+\t(pass_cleanup_barriers): Replace declaration with that of...\n+\t(make_pass_cleanup_barriers): ...new function.\n+\t(pass_delay_slots): Replace declaration with that of...\n+\t(make_pass_delay_slots): ...new function.\n+\t(pass_split_for_shorten_branches): Replace declaration with that of...\n+\t(make_pass_split_for_shorten_branches): ...new function.\n+\t(pass_split_before_regstack): Replace declaration with that of...\n+\t(make_pass_split_before_regstack): ...new function.\n+\t(pass_convert_to_eh_region_ranges): Replace declaration with that\n+\tof...\n+\t(make_pass_convert_to_eh_region_ranges): ...new function.\n+\t(pass_shorten_branches): Replace declaration with that of...\n+\t(make_pass_shorten_branches): ...new function.\n+\t(pass_set_nothrow_function_flags): Replace declaration with that of...\n+\t(make_pass_set_nothrow_function_flags): ...new function.\n+\t(pass_dwarf2_frame): Replace declaration with that of...\n+\t(make_pass_dwarf2_frame): ...new function.\n+\t(pass_final): Replace declaration with that of...\n+\t(make_pass_final): ...new function.\n+\t(pass_rtl_seqabstr): Replace declaration with that of...\n+\t(make_pass_rtl_seqabstr): ...new function.\n+\t(pass_release_ssa_names): Replace declaration with that of...\n+\t(make_pass_release_ssa_names): ...new function.\n+\t(pass_early_inline): Replace declaration with that of...\n+\t(make_pass_early_inline): ...new function.\n+\t(pass_inline_parameters): Replace declaration with that of...\n+\t(make_pass_inline_parameters): ...new function.\n+\t(pass_update_address_taken): Replace declaration with that of...\n+\t(make_pass_update_address_taken): ...new function.\n+\t(pass_convert_switch): Replace declaration with that of...\n+\t(make_pass_convert_switch): ...new function.\n+\t* tree-profile.c (pass_ipa_tree_profile): Convert from a global struct\n+\tto a subclass of simple_ipa_opt_pass along with...\n+\t(pass_data_ipa_tree_profile): ...new pass_data instance and...\n+\t(make_pass_ipa_tree_profile): ...new function.\n+\t* tree-sra.c (pass_sra_early): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_sra_early): ...new pass_data instance and...\n+\t(make_pass_sra_early): ...new function.\n+\t(pass_sra): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_sra): ...new pass_data instance and...\n+\t(make_pass_sra): ...new function.\n+\t(pass_early_ipa_sra): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_early_ipa_sra): ...new pass_data instance and...\n+\t(make_pass_early_ipa_sra): ...new function.\n+\t* tree-ssa-ccp.c (pass_ccp): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_ccp): ...new pass_data instance and...\n+\t(make_pass_ccp): ...new function.\n+\t(pass_fold_builtins): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_fold_builtins): ...new pass_data instance and...\n+\t(make_pass_fold_builtins): ...new function.\n+\t* tree-ssa-copy.c (pass_copy_prop): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_copy_prop): ...new pass_data instance and...\n+\t(make_pass_copy_prop): ...new function.\n+\t* tree-ssa-copyrename.c (pass_rename_ssa_copies): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_rename_ssa_copies): ...new pass_data instance and...\n+\t(make_pass_rename_ssa_copies): ...new function.\n+\t* tree-ssa-dce.c (pass_dce): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_dce): ...new pass_data instance and...\n+\t(make_pass_dce): ...new function.\n+\t(pass_dce_loop): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_dce_loop): ...new pass_data instance and...\n+\t(make_pass_dce_loop): ...new function.\n+\t(pass_cd_dce): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_cd_dce): ...new pass_data instance and...\n+\t(make_pass_cd_dce): ...new function.\n+\t* tree-ssa-dom.c (pass_dominator): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_dominator): ...new pass_data instance and...\n+\t(make_pass_dominator): ...new function.\n+\t(pass_phi_only_cprop): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_phi_only_cprop): ...new pass_data instance and...\n+\t(make_pass_phi_only_cprop): ...new function.\n+\t* tree-ssa-dse.c (pass_dse): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_dse): ...new pass_data instance and...\n+\t(make_pass_dse): ...new function.\n+\t* tree-ssa-forwprop.c (pass_forwprop): Convert from a global struct to\n+\ta subclass of gimple_opt_pass along with...\n+\t(pass_data_forwprop): ...new pass_data instance and...\n+\t(make_pass_forwprop): ...new function.\n+\t* tree-ssa-ifcombine.c (pass_tree_ifcombine): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_tree_ifcombine): ...new pass_data instance and...\n+\t(make_pass_tree_ifcombine): ...new function.\n+\t* tree-ssa-loop-ch.c (pass_ch): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_ch): ...new pass_data instance and...\n+\t(make_pass_ch): ...new function.\n+\t* tree-ssa-loop.c (pass_tree_loop): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_tree_loop): ...new pass_data instance and...\n+\t(make_pass_tree_loop): ...new function.\n+\t(pass_tree_loop_init): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tree_loop_init): ...new pass_data instance and...\n+\t(make_pass_tree_loop_init): ...new function.\n+\t(pass_lim): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_lim): ...new pass_data instance and...\n+\t(make_pass_lim): ...new function.\n+\t(pass_tree_unswitch): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tree_unswitch): ...new pass_data instance and...\n+\t(make_pass_tree_unswitch): ...new function.\n+\t(pass_predcom): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_predcom): ...new pass_data instance and...\n+\t(make_pass_predcom): ...new function.\n+\t(pass_vectorize): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_vectorize): ...new pass_data instance and...\n+\t(make_pass_vectorize): ...new function.\n+\t(pass_graphite): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_graphite): ...new pass_data instance and...\n+\t(make_pass_graphite): ...new function.\n+\t(pass_graphite_transforms): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_graphite_transforms): ...new pass_data instance and...\n+\t(make_pass_graphite_transforms): ...new function.\n+\t(pass_check_data_deps): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_check_data_deps): ...new pass_data instance and...\n+\t(make_pass_check_data_deps): ...new function.\n+\t(pass_iv_canon): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_iv_canon): ...new pass_data instance and...\n+\t(make_pass_iv_canon): ...new function.\n+\t(pass_scev_cprop): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_scev_cprop): ...new pass_data instance and...\n+\t(make_pass_scev_cprop): ...new function.\n+\t(pass_record_bounds): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_record_bounds): ...new pass_data instance and...\n+\t(make_pass_record_bounds): ...new function.\n+\t(pass_complete_unroll): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_complete_unroll): ...new pass_data instance and...\n+\t(make_pass_complete_unroll): ...new function.\n+\t(pass_complete_unrolli): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_complete_unrolli): ...new pass_data instance and...\n+\t(make_pass_complete_unrolli): ...new function.\n+\t(pass_parallelize_loops): Convert from a global struct to a subclass\n+\tof gimple_opt_pass along with...\n+\t(pass_data_parallelize_loops): ...new pass_data instance and...\n+\t(make_pass_parallelize_loops): ...new function.\n+\t(pass_loop_prefetch): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_loop_prefetch): ...new pass_data instance and...\n+\t(make_pass_loop_prefetch): ...new function.\n+\t(pass_iv_optimize): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_iv_optimize): ...new pass_data instance and...\n+\t(make_pass_iv_optimize): ...new function.\n+\t(pass_tree_loop_done): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tree_loop_done): ...new pass_data instance and...\n+\t(make_pass_tree_loop_done): ...new function.\n+\t* tree-ssa-math-opts.c (pass_cse_reciprocals): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_cse_reciprocals): ...new pass_data instance and...\n+\t(make_pass_cse_reciprocals): ...new function.\n+\t(pass_cse_sincos): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_cse_sincos): ...new pass_data instance and...\n+\t(make_pass_cse_sincos): ...new function.\n+\t(pass_optimize_bswap): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_optimize_bswap): ...new pass_data instance and...\n+\t(make_pass_optimize_bswap): ...new function.\n+\t(pass_optimize_widening_mul): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_optimize_widening_mul): ...new pass_data instance and...\n+\t(make_pass_optimize_widening_mul): ...new function.\n+\t* tree-ssa-phiopt.c (pass_phiopt): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_phiopt): ...new pass_data instance and...\n+\t(make_pass_phiopt): ...new function.\n+\t(pass_cselim): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_cselim): ...new pass_data instance and...\n+\t(make_pass_cselim): ...new function.\n+\t* tree-ssa-phiprop.c (pass_phiprop): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_phiprop): ...new pass_data instance and...\n+\t(make_pass_phiprop): ...new function.\n+\t* tree-ssa-pre.c (pass_pre): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_pre): ...new pass_data instance and...\n+\t(make_pass_pre): ...new function.\n+\t(pass_fre): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_fre): ...new pass_data instance and...\n+\t(make_pass_fre): ...new function.\n+\t* tree-ssa-reassoc.c (pass_reassoc): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_reassoc): ...new pass_data instance and...\n+\t(make_pass_reassoc): ...new function.\n+\t* tree-ssa-sink.c (pass_sink_code): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_sink_code): ...new pass_data instance and...\n+\t(make_pass_sink_code): ...new function.\n+\t* tree-ssa-strlen.c (pass_strlen): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_strlen): ...new pass_data instance and...\n+\t(make_pass_strlen): ...new function.\n+\t* tree-ssa-structalias.c (pass_build_alias): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_build_alias): ...new pass_data instance and...\n+\t(make_pass_build_alias): ...new function.\n+\t(pass_build_ealias): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_build_ealias): ...new pass_data instance and...\n+\t(make_pass_build_ealias): ...new function.\n+\t(pass_ipa_pta): Convert from a global struct to a subclass of\n+\tsimple_ipa_opt_pass along with...\n+\t(pass_data_ipa_pta): ...new pass_data instance and...\n+\t(make_pass_ipa_pta): ...new function.\n+\t* tree-ssa-uncprop.c (pass_uncprop): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_uncprop): ...new pass_data instance and...\n+\t(make_pass_uncprop): ...new function.\n+\t* tree-ssa-uninit.c (pass_late_warn_uninitialized): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_late_warn_uninitialized): ...new pass_data instance and...\n+\t(make_pass_late_warn_uninitialized): ...new function.\n+\t* tree-ssa.c (pass_init_datastructures): Convert from a global struct\n+\tto a subclass of gimple_opt_pass along with...\n+\t(pass_data_init_datastructures): ...new pass_data instance and...\n+\t(make_pass_init_datastructures): ...new function.\n+\t(pass_early_warn_uninitialized): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_early_warn_uninitialized): ...new pass_data instance and...\n+\t(make_pass_early_warn_uninitialized): ...new function.\n+\t(pass_update_address_taken): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_update_address_taken): ...new pass_data instance and...\n+\t(make_pass_update_address_taken): ...new function.\n+\t* tree-ssanames.c (pass_release_ssa_names): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_release_ssa_names): ...new pass_data instance and...\n+\t(make_pass_release_ssa_names): ...new function.\n+\t* tree-stdarg.c (pass_stdarg): Convert from a global struct to a\n+\tsubclass of gimple_opt_pass along with...\n+\t(pass_data_stdarg): ...new pass_data instance and...\n+\t(make_pass_stdarg): ...new function.\n+\t* tree-switch-conversion.c (pass_convert_switch): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_convert_switch): ...new pass_data instance and...\n+\t(make_pass_convert_switch): ...new function.\n+\t* tree-tailcall.c (pass_tail_recursion): Convert from a global struct\n+\tto a subclass of gimple_opt_pass along with...\n+\t(pass_data_tail_recursion): ...new pass_data instance and...\n+\t(make_pass_tail_recursion): ...new function.\n+\t(pass_tail_calls): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tail_calls): ...new pass_data instance and...\n+\t(make_pass_tail_calls): ...new function.\n+\t* tree-vect-generic.c (pass_lower_vector): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_lower_vector): ...new pass_data instance and...\n+\t(make_pass_lower_vector): ...new function.\n+\t(pass_lower_vector_ssa): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_lower_vector_ssa): ...new pass_data instance and...\n+\t(make_pass_lower_vector_ssa): ...new function.\n+\t* tree-vectorizer.c (pass_slp_vectorize): Convert from a global struct\n+\tto a subclass of gimple_opt_pass along with...\n+\t(pass_data_slp_vectorize): ...new pass_data instance and...\n+\t(make_pass_slp_vectorize): ...new function.\n+\t(pass_ipa_increase_alignment): Convert from a global struct to a\n+\tsubclass of simple_ipa_opt_pass along with...\n+\t(pass_data_ipa_increase_alignment): ...new pass_data instance and...\n+\t(make_pass_ipa_increase_alignment): ...new function.\n+\t* tree-vrp.c (pass_vrp): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_vrp): ...new pass_data instance and...\n+\t(make_pass_vrp): ...new function.\n+\t* tree.c (pass_ipa_free_lang_data): Convert from a global struct to a\n+\tsubclass of simple_ipa_opt_pass along with...\n+\t(pass_data_ipa_free_lang_data): ...new pass_data instance and...\n+\t(make_pass_ipa_free_lang_data): ...new function.\n+\t* tsan.c (pass_tsan): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tsan): ...new pass_data instance and...\n+\t(make_pass_tsan): ...new function.\n+\t(pass_tsan_O0): Convert from a global struct to a subclass of\n+\tgimple_opt_pass along with...\n+\t(pass_data_tsan_O0): ...new pass_data instance and...\n+\t(make_pass_tsan_O0): ...new function.\n+\t* var-tracking.c (pass_variable_tracking): Convert from a global\n+\tstruct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_variable_tracking): ...new pass_data instance and...\n+\t(make_pass_variable_tracking): ...new function.\n+\t* web.c (pass_web): Convert from a global struct to a subclass of\n+\trtl_opt_pass along with...\n+\t(pass_data_web): ...new pass_data instance and...\n+\t(make_pass_web): ...new function.\n+\t* config/epiphany/epiphany.h (pass_mode_switch_use): Replace\n+\tdeclaration with that of...\n+\t(make_pass_mode_switch_use): ...new function.\n+\t(pass_resolve_sw_modes): Replace declaration with that of...\n+\t(make_pass_resolve_sw_modes): ...new function.\n+\t* config/epiphany/mode-switch-use.c (pass_mode_switch_use): Convert\n+\tfrom a global struct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_mode_switch_use): ...new pass_data instance and...\n+\t(make_pass_mode_switch_use): ...new function.\n+\t* config/epiphany/resolve-sw-modes.c (pass_resolve_sw_modes): Convert\n+\tfrom a global struct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_resolve_sw_modes): ...new pass_data instance and...\n+\t(make_pass_resolve_sw_modes): ...new function.\n+\t* config/i386/i386.c (pass_insert_vzeroupper): Convert from a global\n+\tstruct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_insert_vzeroupper): ...new pass_data instance and...\n+\t(make_pass_insert_vzeroupper): ...new function.\n+\t* config/sparc/sparc.c (pass_work_around_errata): Convert from a\n+\tglobal struct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_work_around_errata): ...new pass_data instance and...\n+\t(make_pass_work_around_errata): ...new function.\n+\t* config/mips/mips.c (pass_mips_machine_reorg2): Convert from a global\n+\tstruct to a subclass of rtl_opt_pass along with...\n+\t(pass_data_mips_machine_reorg2): ...new pass_data instance and...\n+\t(make_pass_mips_machine_reorg2): ...new function.\n+\n 2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n \n \t* passes.c (pass_manager::operator new): New."}, {"sha": "78321b0ed39c33f54cd2986a619b95549b5c8844", "filename": "gcc/asan.c", "status": "modified", "additions": 73, "deletions": 36, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2241,52 +2241,89 @@ gate_asan (void)\n \t\t\t\tDECL_ATTRIBUTES (current_function_decl));\n }\n \n-struct gimple_opt_pass pass_asan =\n+namespace {\n+\n+const pass_data pass_data_asan =\n {\n- {\n-  GIMPLE_PASS,\n-  \"asan\",\t\t\t\t/* name  */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  gate_asan,\t\t\t\t/* gate  */\n-  asan_instrument,\t\t\t/* execute  */\n-  NULL,\t\t\t\t\t/* sub  */\n-  NULL,\t\t\t\t\t/* next  */\n-  0,\t\t\t\t\t/* static_pass_number  */\n-  TV_NONE,\t\t\t\t/* tv_id  */\n-  PROP_ssa | PROP_cfg | PROP_gimple_leh,/* properties_required  */\n-  0,\t\t\t\t\t/* properties_provided  */\n-  0,\t\t\t\t\t/* properties_destroyed  */\n-  0,\t\t\t\t\t/* todo_flags_start  */\n-  TODO_verify_flow | TODO_verify_stmts\n-  | TODO_update_ssa\t\t\t/* todo_flags_finish  */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"asan\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_ssa | PROP_cfg | PROP_gimple_leh ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_flow | TODO_verify_stmts\n+    | TODO_update_ssa ), /* todo_flags_finish */\n };\n \n+class pass_asan : public gimple_opt_pass\n+{\n+public:\n+  pass_asan(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_asan, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_asan (ctxt_); }\n+  bool gate () { return gate_asan (); }\n+  unsigned int execute () { return asan_instrument (); }\n+\n+}; // class pass_asan\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_asan (gcc::context *ctxt)\n+{\n+  return new pass_asan (ctxt);\n+}\n+\n static bool\n gate_asan_O0 (void)\n {\n   return !optimize && gate_asan ();\n }\n \n-struct gimple_opt_pass pass_asan_O0 =\n+namespace {\n+\n+const pass_data pass_data_asan_O0 =\n {\n- {\n-  GIMPLE_PASS,\n-  \"asan0\",\t\t\t\t/* name  */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  gate_asan_O0,\t\t\t\t/* gate  */\n-  asan_instrument,\t\t\t/* execute  */\n-  NULL,\t\t\t\t\t/* sub  */\n-  NULL,\t\t\t\t\t/* next  */\n-  0,\t\t\t\t\t/* static_pass_number  */\n-  TV_NONE,\t\t\t\t/* tv_id  */\n-  PROP_ssa | PROP_cfg | PROP_gimple_leh,/* properties_required  */\n-  0,\t\t\t\t\t/* properties_provided  */\n-  0,\t\t\t\t\t/* properties_destroyed  */\n-  0,\t\t\t\t\t/* todo_flags_start  */\n-  TODO_verify_flow | TODO_verify_stmts\n-  | TODO_update_ssa\t\t\t/* todo_flags_finish  */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"asan0\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_ssa | PROP_cfg | PROP_gimple_leh ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_flow | TODO_verify_stmts\n+    | TODO_update_ssa ), /* todo_flags_finish */\n };\n \n+class pass_asan_O0 : public gimple_opt_pass\n+{\n+public:\n+  pass_asan_O0(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_asan_O0, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_asan_O0 (); }\n+  unsigned int execute () { return asan_instrument (); }\n+\n+}; // class pass_asan_O0\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_asan_O0 (gcc::context *ctxt)\n+{\n+  return new pass_asan_O0 (ctxt);\n+}\n+\n #include \"gt-asan.h\""}, {"sha": "0d92b1d79b502467c10e537e6cd0b467c7e9b289", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1506,22 +1506,40 @@ gate_auto_inc_dec (void)\n }\n \n \n-struct rtl_opt_pass pass_inc_dec =\n+namespace {\n+\n+const pass_data pass_data_inc_dec =\n {\n- {\n-  RTL_PASS,\n-  \"auto_inc_dec\",                       /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_auto_inc_dec,                    /* gate */\n-  rest_of_handle_auto_inc_dec,          /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_AUTO_INC_DEC,                      /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish,                       /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"auto_inc_dec\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_AUTO_INC_DEC, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n };\n+\n+class pass_inc_dec : public rtl_opt_pass\n+{\n+public:\n+  pass_inc_dec(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_inc_dec, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_auto_inc_dec (); }\n+  unsigned int execute () { return rest_of_handle_auto_inc_dec (); }\n+\n+}; // class pass_inc_dec\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_inc_dec (gcc::context *ctxt)\n+{\n+  return new pass_inc_dec (ctxt);\n+}"}, {"sha": "526ede632d4820394fb751fd57db0e65a09b2d35", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 105, "deletions": 51, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2179,26 +2179,44 @@ rest_of_handle_reorder_blocks (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_reorder_blocks =\n+namespace {\n+\n+const pass_data pass_data_reorder_blocks =\n {\n- {\n-  RTL_PASS,\n-  \"bbro\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_reorder_blocks,           /* gate */\n-  rest_of_handle_reorder_blocks,        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REORDER_BLOCKS,                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing,              /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"bbro\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_REORDER_BLOCKS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_reorder_blocks : public rtl_opt_pass\n+{\n+public:\n+  pass_reorder_blocks(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_reorder_blocks, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_reorder_blocks (); }\n+  unsigned int execute () { return rest_of_handle_reorder_blocks (); }\n+\n+}; // class pass_reorder_blocks\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_reorder_blocks (gcc::context *ctxt)\n+{\n+  return new pass_reorder_blocks (ctxt);\n+}\n+\n /* Duplicate the blocks containing computed gotos.  This basically unfactors\n    computed gotos that were factored early on in the compilation process to\n    speed up edge based data flow.  We used to not unfactoring them again,\n@@ -2327,26 +2345,44 @@ duplicate_computed_gotos (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_duplicate_computed_gotos =\n+namespace {\n+\n+const pass_data pass_data_duplicate_computed_gotos =\n {\n- {\n-  RTL_PASS,\n-  \"compgotos\",                          /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_duplicate_computed_gotos,        /* gate */\n-  duplicate_computed_gotos,             /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REORDER_BLOCKS,                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing,/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"compgotos\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_REORDER_BLOCKS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_duplicate_computed_gotos : public rtl_opt_pass\n+{\n+public:\n+  pass_duplicate_computed_gotos(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_duplicate_computed_gotos, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_duplicate_computed_gotos (); }\n+  unsigned int execute () { return duplicate_computed_gotos (); }\n+\n+}; // class pass_duplicate_computed_gotos\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_duplicate_computed_gotos (gcc::context *ctxt)\n+{\n+  return new pass_duplicate_computed_gotos (ctxt);\n+}\n+\n static bool\n gate_handle_partition_blocks (void)\n {\n@@ -2533,22 +2569,40 @@ partition_hot_cold_basic_blocks (void)\n   return TODO_verify_flow | TODO_verify_rtl_sharing;\n }\n \n-struct rtl_opt_pass pass_partition_blocks =\n+namespace {\n+\n+const pass_data pass_data_partition_blocks =\n {\n- {\n-  RTL_PASS,\n-  \"bbpart\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_partition_blocks,         /* gate */\n-  partition_hot_cold_basic_blocks,      /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REORDER_BLOCKS,                    /* tv_id */\n-  PROP_cfglayout,                       /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"bbpart\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_REORDER_BLOCKS, /* tv_id */\n+  PROP_cfglayout, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_partition_blocks : public rtl_opt_pass\n+{\n+public:\n+  pass_partition_blocks(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_partition_blocks, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_partition_blocks (); }\n+  unsigned int execute () { return partition_hot_cold_basic_blocks (); }\n+\n+}; // class pass_partition_blocks\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_partition_blocks (gcc::context *ctxt)\n+{\n+  return new pass_partition_blocks (ctxt);\n+}"}, {"sha": "b53435680ec4c1a877d6e8f21605b3b407a954a2", "filename": "gcc/bt-load.c", "status": "modified", "additions": 74, "deletions": 34, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1504,26 +1504,46 @@ rest_of_handle_branch_target_load_optimize1 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_branch_target_load_optimize1 =\n+namespace {\n+\n+const pass_data pass_data_branch_target_load_optimize1 =\n {\n- {\n-  RTL_PASS,\n-  \"btl1\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_branch_target_load_optimize1,      /* gate */\n-  rest_of_handle_branch_target_load_optimize1,   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,\t                        /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing,              /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"btl1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_branch_target_load_optimize1 : public rtl_opt_pass\n+{\n+public:\n+  pass_branch_target_load_optimize1(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_branch_target_load_optimize1, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_branch_target_load_optimize1 (); }\n+  unsigned int execute () {\n+    return rest_of_handle_branch_target_load_optimize1 ();\n+  }\n+\n+}; // class pass_branch_target_load_optimize1\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_branch_target_load_optimize1 (gcc::context *ctxt)\n+{\n+  return new pass_branch_target_load_optimize1 (ctxt);\n+}\n+\n static bool\n gate_handle_branch_target_load_optimize2 (void)\n {\n@@ -1553,22 +1573,42 @@ rest_of_handle_branch_target_load_optimize2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_branch_target_load_optimize2 =\n+namespace {\n+\n+const pass_data pass_data_branch_target_load_optimize2 =\n {\n- {\n-  RTL_PASS,\n-  \"btl2\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_branch_target_load_optimize2,      /* gate */\n-  rest_of_handle_branch_target_load_optimize2,   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"btl2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_branch_target_load_optimize2 : public rtl_opt_pass\n+{\n+public:\n+  pass_branch_target_load_optimize2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_branch_target_load_optimize2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_branch_target_load_optimize2 (); }\n+  unsigned int execute () {\n+    return rest_of_handle_branch_target_load_optimize2 ();\n+  }\n+\n+}; // class pass_branch_target_load_optimize2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_branch_target_load_optimize2 (gcc::context *ctxt)\n+{\n+  return new pass_branch_target_load_optimize2 (ctxt);\n+}"}, {"sha": "f4f58cb588d8b5b1e7dc89660ce5ee322cdf09dd", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3040,25 +3040,42 @@ execute_jump (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_jump =\n+namespace {\n+\n+const pass_data pass_data_jump =\n {\n- {\n-  RTL_PASS,\n-  \"jump\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_jump,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_JUMP,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_rtl_sharing,\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"jump\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_JUMP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n+\n+class pass_jump : public rtl_opt_pass\n+{\n+public:\n+  pass_jump(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_jump, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_jump (); }\n+\n+}; // class pass_jump\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_jump (gcc::context *ctxt)\n+{\n+  return new pass_jump (ctxt);\n+}\n \f\n static unsigned int\n execute_jump2 (void)\n@@ -3067,22 +3084,39 @@ execute_jump2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_jump2 =\n+namespace {\n+\n+const pass_data pass_data_jump2 =\n {\n- {\n-  RTL_PASS,\n-  \"jump2\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_jump2,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_JUMP,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_rtl_sharing,\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"jump2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_JUMP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n+\n+class pass_jump2 : public rtl_opt_pass\n+{\n+public:\n+  pass_jump2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_jump2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_jump2 (); }\n+\n+}; // class pass_jump2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_jump2 (gcc::context *ctxt)\n+{\n+  return new pass_jump2 (ctxt);\n+}"}, {"sha": "a7d9170779c68b0500498a03720fd3fa0ab5a40e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -4906,25 +4906,42 @@ gimple_expand_cfg (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_expand =\n+namespace {\n+\n+const pass_data pass_data_expand =\n {\n- {\n-  RTL_PASS,\n-  \"expand\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  gimple_expand_cfg,\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_EXPAND,\t\t\t\t/* tv_id */\n-  PROP_ssa | PROP_gimple_leh | PROP_cfg\n+  RTL_PASS, /* type */\n+  \"expand\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_EXPAND, /* tv_id */\n+  ( PROP_ssa | PROP_gimple_leh | PROP_cfg\n     | PROP_gimple_lcx\n-    | PROP_gimple_lvec,\t\t\t/* properties_required */\n-  PROP_rtl,                             /* properties_provided */\n-  PROP_ssa | PROP_trees,\t\t/* properties_destroyed */\n-  TODO_verify_ssa | TODO_verify_flow\n-    | TODO_verify_stmts,\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+    | PROP_gimple_lvec ), /* properties_required */\n+  PROP_rtl, /* properties_provided */\n+  ( PROP_ssa | PROP_trees ), /* properties_destroyed */\n+  ( TODO_verify_ssa | TODO_verify_flow\n+    | TODO_verify_stmts ), /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_expand : public rtl_opt_pass\n+{\n+public:\n+  pass_expand(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_expand, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return gimple_expand_cfg (); }\n+\n+}; // class pass_expand\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_expand (gcc::context *ctxt)\n+{\n+  return new pass_expand (ctxt);\n+}"}, {"sha": "610fccc46dd79070ffec6d43a9e5706ebc625d84", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 102, "deletions": 51, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -459,26 +459,43 @@ rest_of_pass_free_cfg (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_free_cfg =\n+namespace {\n+\n+const pass_data pass_data_free_cfg =\n {\n- {\n-  RTL_PASS,\n-  \"*free_cfg\",                          /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_pass_free_cfg,                /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  PROP_cfg,                             /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"*free_cfg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  PROP_cfg, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_free_cfg : public rtl_opt_pass\n+{\n+public:\n+  pass_free_cfg(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_free_cfg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_pass_free_cfg (); }\n+\n+}; // class pass_free_cfg\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_free_cfg (gcc::context *ctxt)\n+{\n+  return new pass_free_cfg (ctxt);\n+}\n+\n /* Return RTX to emit after when we want to emit code on the entry of function.  */\n rtx\n entry_of_function (void)\n@@ -3297,45 +3314,79 @@ outof_cfg_layout_mode (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_into_cfg_layout_mode =\n+namespace {\n+\n+const pass_data pass_data_into_cfg_layout_mode =\n {\n- {\n-  RTL_PASS,\n-  \"into_cfglayout\",                     /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  into_cfg_layout_mode,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CFG,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  PROP_cfglayout,                       /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"into_cfglayout\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_CFG, /* tv_id */\n+  0, /* properties_required */\n+  PROP_cfglayout, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n-struct rtl_opt_pass pass_outof_cfg_layout_mode =\n+class pass_into_cfg_layout_mode : public rtl_opt_pass\n {\n- {\n-  RTL_PASS,\n-  \"outof_cfglayout\",                    /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  outof_cfg_layout_mode,                /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CFG,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  PROP_cfglayout,                       /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+public:\n+  pass_into_cfg_layout_mode(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_into_cfg_layout_mode, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return into_cfg_layout_mode (); }\n+\n+}; // class pass_into_cfg_layout_mode\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_into_cfg_layout_mode (gcc::context *ctxt)\n+{\n+  return new pass_into_cfg_layout_mode (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_outof_cfg_layout_mode =\n+{\n+  RTL_PASS, /* type */\n+  \"outof_cfglayout\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_CFG, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  PROP_cfglayout, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_outof_cfg_layout_mode : public rtl_opt_pass\n+{\n+public:\n+  pass_outof_cfg_layout_mode(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_outof_cfg_layout_mode, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return outof_cfg_layout_mode (); }\n+\n+}; // class pass_outof_cfg_layout_mode\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_outof_cfg_layout_mode (gcc::context *ctxt)\n+{\n+  return new pass_outof_cfg_layout_mode (ctxt);\n+}\n \f\n \n /* Link the basic blocks in the correct order, compacting the basic"}, {"sha": "a7872dea9e163eafb90a31288b31465f8c9394ab", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 106, "deletions": 51, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -370,26 +370,43 @@ build_cgraph_edges (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_build_cgraph_edges =\n+namespace {\n+\n+const pass_data pass_data_build_cgraph_edges =\n {\n- {\n-  GIMPLE_PASS,\n-  \"*build_cgraph_edges\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  build_cgraph_edges,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"*build_cgraph_edges\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_build_cgraph_edges : public gimple_opt_pass\n+{\n+public:\n+  pass_build_cgraph_edges(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_build_cgraph_edges, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return build_cgraph_edges (); }\n+\n+}; // class pass_build_cgraph_edges\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_build_cgraph_edges (gcc::context *ctxt)\n+{\n+  return new pass_build_cgraph_edges (ctxt);\n+}\n+\n /* Record references to functions and other variables present in the\n    initial value of DECL, a variable.\n    When ONLY_VARS is true, we mark needed only variables, not functions.  */\n@@ -478,26 +495,44 @@ cgraph_rebuild_references (void)\n   record_eh_tables (node, cfun);\n }\n \n-struct gimple_opt_pass pass_rebuild_cgraph_edges =\n+namespace {\n+\n+const pass_data pass_data_rebuild_cgraph_edges =\n {\n- {\n-  GIMPLE_PASS,\n-  \"*rebuild_cgraph_edges\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  rebuild_cgraph_edges,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_CGRAPH,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"*rebuild_cgraph_edges\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_CGRAPH, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_rebuild_cgraph_edges : public gimple_opt_pass\n+{\n+public:\n+  pass_rebuild_cgraph_edges(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_rebuild_cgraph_edges, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_rebuild_cgraph_edges (ctxt_); }\n+  unsigned int execute () { return rebuild_cgraph_edges (); }\n+\n+}; // class pass_rebuild_cgraph_edges\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_rebuild_cgraph_edges (gcc::context *ctxt)\n+{\n+  return new pass_rebuild_cgraph_edges (ctxt);\n+}\n+\n \n static unsigned int\n remove_cgraph_callee_edges (void)\n@@ -506,22 +541,42 @@ remove_cgraph_callee_edges (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_remove_cgraph_callee_edges =\n+namespace {\n+\n+const pass_data pass_data_remove_cgraph_callee_edges =\n {\n- {\n-  GIMPLE_PASS,\n-  \"*remove_cgraph_callee_edges\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  remove_cgraph_callee_edges,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"*remove_cgraph_callee_edges\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_remove_cgraph_callee_edges : public gimple_opt_pass\n+{\n+public:\n+  pass_remove_cgraph_callee_edges(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_remove_cgraph_callee_edges, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () {\n+    return new pass_remove_cgraph_callee_edges (ctxt_);\n+  }\n+  unsigned int execute () { return remove_cgraph_callee_edges (); }\n+\n+}; // class pass_remove_cgraph_callee_edges\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_remove_cgraph_callee_edges (gcc::context *ctxt)\n+{\n+  return new pass_remove_cgraph_callee_edges (ctxt);\n+}"}, {"sha": "be47665ebc0782c94e9ba0767966f8d814818684", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -643,22 +643,40 @@ rest_of_handle_stack_adjustments (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_stack_adjustments =\n+namespace {\n+\n+const pass_data pass_data_stack_adjustments =\n {\n- {\n-  RTL_PASS,\n-  \"csa\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_stack_adjustments,        /* gate */\n-  rest_of_handle_stack_adjustments,     /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_COMBINE_STACK_ADJUST,              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"csa\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_COMBINE_STACK_ADJUST, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_stack_adjustments : public rtl_opt_pass\n+{\n+public:\n+  pass_stack_adjustments(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_stack_adjustments, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_stack_adjustments (); }\n+  unsigned int execute () { return rest_of_handle_stack_adjustments (); }\n+\n+}; // class pass_stack_adjustments\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_stack_adjustments (gcc::context *ctxt)\n+{\n+  return new pass_stack_adjustments (ctxt);\n+}"}, {"sha": "d0aae69f2698cb0c20768d0223ed9b81546bd968", "filename": "gcc/combine.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -13840,22 +13840,40 @@ rest_of_handle_combine (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_combine =\n+namespace {\n+\n+const pass_data pass_data_combine =\n {\n- {\n-  RTL_PASS,\n-  \"combine\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_combine,                  /* gate */\n-  rest_of_handle_combine,               /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_COMBINE,                           /* tv_id */\n-  PROP_cfglayout,                       /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"combine\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_COMBINE, /* tv_id */\n+  PROP_cfglayout, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_combine : public rtl_opt_pass\n+{\n+public:\n+  pass_combine(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_combine, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_combine (); }\n+  unsigned int execute () { return rest_of_handle_combine (); }\n+\n+}; // class pass_combine\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_combine (gcc::context *ctxt)\n+{\n+  return new pass_combine (ctxt);\n+}"}, {"sha": "e907376c577fbc4ea1521333260884eb4f0151c9", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -651,24 +651,41 @@ gate_compare_elim_after_reload (void)\n   return flag_compare_elim_after_reload;\n }\n \n-struct rtl_opt_pass pass_compare_elim_after_reload =\n+namespace {\n+\n+const pass_data pass_data_compare_elim_after_reload =\n {\n- {\n-  RTL_PASS,\n-  \"cmpelim\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_compare_elim_after_reload,\t/* gate */\n-  execute_compare_elim_after_reload,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_df_finish\n-  | TODO_df_verify\n-  | TODO_verify_rtl_sharing\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"cmpelim\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_df_verify\n+    | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_compare_elim_after_reload : public rtl_opt_pass\n+{\n+public:\n+  pass_compare_elim_after_reload(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_compare_elim_after_reload, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_compare_elim_after_reload (); }\n+  unsigned int execute () { return execute_compare_elim_after_reload (); }\n+\n+}; // class pass_compare_elim_after_reload\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_compare_elim_after_reload (gcc::context *ctxt)\n+{\n+  return new pass_compare_elim_after_reload (ctxt);\n+}"}, {"sha": "f16ab85dde93d19dff620339fbf544a3f4a5df86", "filename": "gcc/config/epiphany/epiphany.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -929,8 +929,8 @@ enum\n };\n \n extern int epiphany_normal_fp_rounding;\n-extern struct rtl_opt_pass pass_mode_switch_use;\n-extern struct rtl_opt_pass pass_resolve_sw_modes;\n+extern rtl_opt_pass *make_pass_mode_switch_use (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_resolve_sw_modes (gcc::context *ctxt);\n \n /* This will need to be adjusted when FP_CONTRACT_ON is properly\n    implemented.  */"}, {"sha": "8e278583215b18794bc700ea56022fda98a4d450", "filename": "gcc/config/epiphany/mode-switch-use.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -71,22 +71,39 @@ insert_uses (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_mode_switch_use =\n+namespace {\n+\n+const pass_data pass_data_mode_switch_use =\n {\n- {\n-  RTL_PASS,\n-  \"mode_switch_use\",\t\t\t/* name */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  insert_uses,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"mode_switch_use\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_mode_switch_use : public rtl_opt_pass\n+{\n+public:\n+  pass_mode_switch_use(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_mode_switch_use, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return insert_uses (); }\n+\n+}; // class pass_mode_switch_use\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_mode_switch_use (gcc::context *ctxt)\n+{\n+  return new pass_mode_switch_use (ctxt);\n+}"}, {"sha": "b43b4d953cdf8579a3fa6cdf70b24a0f71c667c1", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -161,23 +161,40 @@ resolve_sw_modes (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_resolve_sw_modes =\n+namespace {\n+\n+const pass_data pass_data_resolve_sw_modes =\n {\n- {\n-  RTL_PASS,\n-  \"resolve_sw_modes\",\t\t\t/* name */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  gate_resolve_sw_modes,\t\t/* gate */\n-  resolve_sw_modes,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_MODE_SWITCH,\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"resolve_sw_modes\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_MODE_SWITCH, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n };\n+\n+class pass_resolve_sw_modes : public rtl_opt_pass\n+{\n+public:\n+  pass_resolve_sw_modes(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_resolve_sw_modes, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_resolve_sw_modes (); }\n+  unsigned int execute () { return resolve_sw_modes (); }\n+\n+}; // class pass_resolve_sw_modes\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_resolve_sw_modes (gcc::context *ctxt)\n+{\n+  return new pass_resolve_sw_modes (ctxt);\n+}"}, {"sha": "a85a13cd7c004d1ef141fe1dcb6e257cb66c3deb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2602,27 +2602,44 @@ rest_of_handle_insert_vzeroupper (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_insert_vzeroupper =\n-{\n- {\n-  RTL_PASS,\n-  \"vzeroupper\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  gate_insert_vzeroupper,\t\t/* gate */\n-  rest_of_handle_insert_vzeroupper,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  0,\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_insert_vzeroupper =\n+{\n+  RTL_PASS, /* type */\n+  \"vzeroupper\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n };\n \n+class pass_insert_vzeroupper : public rtl_opt_pass\n+{\n+public:\n+  pass_insert_vzeroupper(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_insert_vzeroupper, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_insert_vzeroupper (); }\n+  unsigned int execute () { return rest_of_handle_insert_vzeroupper (); }\n+\n+}; // class pass_insert_vzeroupper\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_insert_vzeroupper (gcc::context *ctxt)\n+{\n+  return new pass_insert_vzeroupper (ctxt);\n+}\n+\n /* Return true if a red-zone is in use.  */\n \n static inline bool"}, {"sha": "05ba003b7bdfd99eaff0944ce7373b56d7d60513", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -16337,26 +16337,43 @@ mips_machine_reorg2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_mips_machine_reorg2 =\n-{\n- {\n-  RTL_PASS,\n-  \"mach2\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  mips_machine_reorg2,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_MACH_DEP,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_rtl_sharing,\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_mips_machine_reorg2 =\n+{\n+  RTL_PASS, /* type */\n+  \"mach2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_MACH_DEP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_mips_machine_reorg2 : public rtl_opt_pass\n+{\n+public:\n+  pass_mips_machine_reorg2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_mips_machine_reorg2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return mips_machine_reorg2 (); }\n+\n+}; // class pass_mips_machine_reorg2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_mips_machine_reorg2 (gcc::context *ctxt)\n+{\n+  return new pass_mips_machine_reorg2 (ctxt);\n+}\n+\n struct register_pass_info insert_pass_mips_machine_reorg2 =\n {\n   &pass_mips_machine_reorg2.pass,\t/* pass */"}, {"sha": "66c33f7212d453795ea47dda23b291c8ad4294de", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1000,26 +1000,44 @@ sparc_do_work_around_errata (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_work_around_errata =\n-{\n- {\n-  RTL_PASS,\n-  \"errata\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  sparc_gate_work_around_errata,\t/* gate */\n-  sparc_do_work_around_errata,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_MACH_DEP,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_rtl_sharing,\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_work_around_errata =\n+{\n+  RTL_PASS, /* type */\n+  \"errata\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_MACH_DEP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_work_around_errata : public rtl_opt_pass\n+{\n+public:\n+  pass_work_around_errata(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_work_around_errata, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return sparc_gate_work_around_errata (); }\n+  unsigned int execute () { return sparc_do_work_around_errata (); }\n+\n+}; // class pass_work_around_errata\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_work_around_errata (gcc::context *ctxt)\n+{\n+  return new pass_work_around_errata (ctxt);\n+}\n+\n struct register_pass_info insert_pass_work_around_errata =\n {\n   &pass_work_around_errata.pass,\t/* pass */"}, {"sha": "3518fd839ceea3d7d4b22ffe7fcd009cda1aeb84", "filename": "gcc/cprop.c", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1913,23 +1913,42 @@ execute_rtl_cprop (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_cprop =\n+namespace {\n+\n+const pass_data pass_data_rtl_cprop =\n {\n- {\n-  RTL_PASS,\n-  \"cprop\",                              /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_rtl_cprop,                       /* gate */\n-  execute_rtl_cprop,  \t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CPROP,                             /* tv_id */\n-  PROP_cfglayout,                       /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"cprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CPROP, /* tv_id */\n+  PROP_cfglayout, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_rtl_cprop : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_cprop(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_cprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_rtl_cprop (ctxt_); }\n+  bool gate () { return gate_rtl_cprop (); }\n+  unsigned int execute () { return execute_rtl_cprop (); }\n+\n+}; // class pass_rtl_cprop\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_cprop (gcc::context *ctxt)\n+{\n+  return new pass_rtl_cprop (ctxt);\n+}"}, {"sha": "ee1b7be1170e7141b6fb9fe8ae4f38b445e9184f", "filename": "gcc/cse.c", "status": "modified", "additions": 110, "deletions": 54, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -7449,27 +7449,45 @@ rest_of_handle_cse (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_cse =\n+namespace {\n+\n+const pass_data pass_data_cse =\n {\n- {\n-  RTL_PASS,\n-  \"cse1\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_cse,                      /* gate */\n-  rest_of_handle_cse,\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CSE,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"cse1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CSE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n \n+class pass_cse : public rtl_opt_pass\n+{\n+public:\n+  pass_cse(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_cse, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_cse (); }\n+  unsigned int execute () { return rest_of_handle_cse (); }\n+\n+}; // class pass_cse\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_cse (gcc::context *ctxt)\n+{\n+  return new pass_cse (ctxt);\n+}\n+\n \n static bool\n gate_handle_cse2 (void)\n@@ -7511,27 +7529,45 @@ rest_of_handle_cse2 (void)\n }\n \n \n-struct rtl_opt_pass pass_cse2 =\n+namespace {\n+\n+const pass_data pass_data_cse2 =\n {\n- {\n-  RTL_PASS,\n-  \"cse2\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_cse2,                     /* gate */\n-  rest_of_handle_cse2,\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CSE2,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"cse2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CSE2, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n \n+class pass_cse2 : public rtl_opt_pass\n+{\n+public:\n+  pass_cse2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_cse2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_cse2 (); }\n+  unsigned int execute () { return rest_of_handle_cse2 (); }\n+\n+}; // class pass_cse2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_cse2 (gcc::context *ctxt)\n+{\n+  return new pass_cse2 (ctxt);\n+}\n+\n static bool\n gate_handle_cse_after_global_opts (void)\n {\n@@ -7571,23 +7607,43 @@ rest_of_handle_cse_after_global_opts (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_cse_after_global_opts =\n+namespace {\n+\n+const pass_data pass_data_cse_after_global_opts =\n {\n- {\n-  RTL_PASS,\n-  \"cse_local\",                          /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_cse_after_global_opts,    /* gate */\n-  rest_of_handle_cse_after_global_opts, /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CSE,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"cse_local\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CSE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_cse_after_global_opts : public rtl_opt_pass\n+{\n+public:\n+  pass_cse_after_global_opts(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_cse_after_global_opts, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_cse_after_global_opts (); }\n+  unsigned int execute () {\n+    return rest_of_handle_cse_after_global_opts ();\n+  }\n+\n+}; // class pass_cse_after_global_opts\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_cse_after_global_opts (gcc::context *ctxt)\n+{\n+  return new pass_cse_after_global_opts (ctxt);\n+}"}, {"sha": "fa22316b5cc8f9e8bd8959cc3d8dadbf7b1fa0ff", "filename": "gcc/dce.c", "status": "modified", "additions": 70, "deletions": 34, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -786,26 +786,44 @@ gate_ud_dce (void)\n     && dbg_cnt (dce_ud);\n }\n \n-struct rtl_opt_pass pass_ud_rtl_dce =\n+namespace {\n+\n+const pass_data pass_data_ud_rtl_dce =\n {\n- {\n-  RTL_PASS,\n-  \"ud_dce\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_ud_dce,                          /* gate */\n-  rest_of_handle_ud_dce,                /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DCE,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"ud_dce\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_DCE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n \n+class pass_ud_rtl_dce : public rtl_opt_pass\n+{\n+public:\n+  pass_ud_rtl_dce(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_ud_rtl_dce, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ud_dce (); }\n+  unsigned int execute () { return rest_of_handle_ud_dce (); }\n+\n+}; // class pass_ud_rtl_dce\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_ud_rtl_dce (gcc::context *ctxt)\n+{\n+  return new pass_ud_rtl_dce (ctxt);\n+}\n+\n \n /* -------------------------------------------------------------------------\n    Fast DCE functions\n@@ -1201,22 +1219,40 @@ gate_fast_dce (void)\n     && dbg_cnt (dce_fast);\n }\n \n-struct rtl_opt_pass pass_fast_rtl_dce =\n+namespace {\n+\n+const pass_data pass_data_fast_rtl_dce =\n {\n- {\n-  RTL_PASS,\n-  \"rtl_dce\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_fast_dce,                        /* gate */\n-  rest_of_handle_fast_dce,              /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DCE,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"rtl_dce\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_DCE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_fast_rtl_dce : public rtl_opt_pass\n+{\n+public:\n+  pass_fast_rtl_dce(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_fast_rtl_dce, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_fast_dce (); }\n+  unsigned int execute () { return rest_of_handle_fast_dce (); }\n+\n+}; // class pass_fast_rtl_dce\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_fast_rtl_dce (gcc::context *ctxt)\n+{\n+  return new pass_fast_rtl_dce (ctxt);\n+}"}, {"sha": "95df1c1b05697ddee36deddbf01be0b870126232", "filename": "gcc/df-core.c", "status": "modified", "additions": 107, "deletions": 54, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -746,26 +746,44 @@ gate_opt (void)\n }\n \n \n-struct rtl_opt_pass pass_df_initialize_opt =\n-{\n- {\n-  RTL_PASS,\n-  \"dfinit\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_opt,                             /* gate */\n-  rest_of_handle_df_initialize,         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DF_SCAN,                           /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_df_initialize_opt =\n+{\n+  RTL_PASS, /* type */\n+  \"dfinit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_DF_SCAN, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_df_initialize_opt : public rtl_opt_pass\n+{\n+public:\n+  pass_df_initialize_opt(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_df_initialize_opt, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_opt (); }\n+  unsigned int execute () { return rest_of_handle_df_initialize (); }\n+\n+}; // class pass_df_initialize_opt\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_df_initialize_opt (gcc::context *ctxt)\n+{\n+  return new pass_df_initialize_opt (ctxt);\n+}\n+\n \n static bool\n gate_no_opt (void)\n@@ -774,26 +792,44 @@ gate_no_opt (void)\n }\n \n \n-struct rtl_opt_pass pass_df_initialize_no_opt =\n-{\n- {\n-  RTL_PASS,\n-  \"no-opt dfinit\",                      /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_no_opt,                          /* gate */\n-  rest_of_handle_df_initialize,         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DF_SCAN,                           /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_df_initialize_no_opt =\n+{\n+  RTL_PASS, /* type */\n+  \"no-opt dfinit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_DF_SCAN, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_df_initialize_no_opt : public rtl_opt_pass\n+{\n+public:\n+  pass_df_initialize_no_opt(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_df_initialize_no_opt, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_no_opt (); }\n+  unsigned int execute () { return rest_of_handle_df_initialize (); }\n+\n+}; // class pass_df_initialize_no_opt\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_df_initialize_no_opt (gcc::context *ctxt)\n+{\n+  return new pass_df_initialize_no_opt (ctxt);\n+}\n+\n \n /* Free all the dataflow info and the DF structure.  This should be\n    called from the df_finish macro which also NULLs the parm.  */\n@@ -822,26 +858,43 @@ rest_of_handle_df_finish (void)\n }\n \n \n-struct rtl_opt_pass pass_df_finish =\n-{\n- {\n-  RTL_PASS,\n-  \"dfinish\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  rest_of_handle_df_finish,             /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_df_finish =\n+{\n+  RTL_PASS, /* type */\n+  \"dfinish\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_df_finish : public rtl_opt_pass\n+{\n+public:\n+  pass_df_finish(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_df_finish, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_df_finish (); }\n+\n+}; // class pass_df_finish\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_df_finish (gcc::context *ctxt)\n+{\n+  return new pass_df_finish (ctxt);\n+}\n+\n \n \n "}, {"sha": "8b132eb2c91031c83dd2cb031a74b20247bf0000", "filename": "gcc/dse.c", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3729,42 +3729,78 @@ gate_dse2 (void)\n     && dbg_cnt (dse2);\n }\n \n-struct rtl_opt_pass pass_rtl_dse1 =\n-{\n- {\n-  RTL_PASS,\n-  \"dse1\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_dse1,                            /* gate */\n-  rest_of_handle_dse,                   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DSE1,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rtl_dse1 =\n+{\n+  RTL_PASS, /* type */\n+  \"dse1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_DSE1, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n \n-struct rtl_opt_pass pass_rtl_dse2 =\n-{\n- {\n-  RTL_PASS,\n-  \"dse2\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_dse2,                            /* gate */\n-  rest_of_handle_dse,                   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DSE2,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+class pass_rtl_dse1 : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_dse1(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_dse1, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_dse1 (); }\n+  unsigned int execute () { return rest_of_handle_dse (); }\n+\n+}; // class pass_rtl_dse1\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_dse1 (gcc::context *ctxt)\n+{\n+  return new pass_rtl_dse1 (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_rtl_dse2 =\n+{\n+  RTL_PASS, /* type */\n+  \"dse2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_DSE2, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_rtl_dse2 : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_dse2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_dse2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_dse2 (); }\n+  unsigned int execute () { return rest_of_handle_dse (); }\n+\n+}; // class pass_rtl_dse2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_dse2 (gcc::context *ctxt)\n+{\n+  return new pass_rtl_dse2 (ctxt);\n+}"}, {"sha": "ee8d42c9b2842f2e1f8594fbb57c341035f1554c", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3370,24 +3370,42 @@ gate_dwarf2_frame (void)\n   return dwarf2out_do_frame ();\n }\n \n-struct rtl_opt_pass pass_dwarf2_frame =\n-{\n- {\n-  RTL_PASS,\n-  \"dwarf2\",\t\t\t/* name */\n-  OPTGROUP_NONE,                /* optinfo_flags */\n-  gate_dwarf2_frame,\t\t/* gate */\n-  execute_dwarf2_frame,\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_FINAL,\t\t\t/* tv_id */\n-  0,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_dwarf2_frame =\n+{\n+  RTL_PASS, /* type */\n+  \"dwarf2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_FINAL, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_dwarf2_frame : public rtl_opt_pass\n+{\n+public:\n+  pass_dwarf2_frame(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_dwarf2_frame, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_dwarf2_frame (); }\n+  unsigned int execute () { return execute_dwarf2_frame (); }\n+\n+}; // class pass_dwarf2_frame\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_dwarf2_frame (gcc::context *ctxt)\n+{\n+  return new pass_dwarf2_frame (ctxt);\n+}\n+\n #include \"gt-dwarf2cfi.h\""}, {"sha": "2d41d7b332dee0e901a86bce9b741d59c0609064", "filename": "gcc/except.c", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2001,26 +2001,43 @@ set_nothrow_function_flags (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_set_nothrow_function_flags =\n-{\n- {\n-  RTL_PASS,\n-  \"nothrow\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  set_nothrow_function_flags,           /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_set_nothrow_function_flags =\n+{\n+  RTL_PASS, /* type */\n+  \"nothrow\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_set_nothrow_function_flags : public rtl_opt_pass\n+{\n+public:\n+  pass_set_nothrow_function_flags(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_set_nothrow_function_flags, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return set_nothrow_function_flags (); }\n+\n+}; // class pass_set_nothrow_function_flags\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_set_nothrow_function_flags (gcc::context *ctxt)\n+{\n+  return new pass_set_nothrow_function_flags (ctxt);\n+}\n+\n \f\n /* Various hooks for unwind library.  */\n \n@@ -2615,25 +2632,43 @@ gate_convert_to_eh_region_ranges (void)\n   return true;\n }\n \n-struct rtl_opt_pass pass_convert_to_eh_region_ranges =\n-{\n- {\n-  RTL_PASS,\n-  \"eh_ranges\",                          /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_convert_to_eh_region_ranges,\t/* gate */\n-  convert_to_eh_region_ranges,          /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0              \t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_convert_to_eh_region_ranges =\n+{\n+  RTL_PASS, /* type */\n+  \"eh_ranges\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_convert_to_eh_region_ranges : public rtl_opt_pass\n+{\n+public:\n+  pass_convert_to_eh_region_ranges(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_convert_to_eh_region_ranges, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_convert_to_eh_region_ranges (); }\n+  unsigned int execute () { return convert_to_eh_region_ranges (); }\n+\n+}; // class pass_convert_to_eh_region_ranges\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_convert_to_eh_region_ranges (gcc::context *ctxt)\n+{\n+  return new pass_convert_to_eh_region_ranges (ctxt);\n+}\n \f\n static void\n push_uleb128 (vec<uchar, va_gc> **data_area, unsigned int value)"}, {"sha": "b755957bebd2526a282d7cdea10c64819442dec6", "filename": "gcc/final.c", "status": "modified", "additions": 136, "deletions": 68, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -795,26 +795,43 @@ compute_alignments (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_compute_alignments =\n+namespace {\n+\n+const pass_data pass_data_compute_alignments =\n {\n- {\n-  RTL_PASS,\n-  \"alignments\",                         /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  compute_alignments,                   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing               /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"alignments\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_compute_alignments : public rtl_opt_pass\n+{\n+public:\n+  pass_compute_alignments(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_compute_alignments, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return compute_alignments (); }\n+\n+}; // class pass_compute_alignments\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_compute_alignments (gcc::context *ctxt)\n+{\n+  return new pass_compute_alignments (ctxt);\n+}\n+\n \f\n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n@@ -4409,26 +4426,43 @@ rest_of_handle_final (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_final =\n+namespace {\n+\n+const pass_data pass_data_final =\n {\n- {\n-  RTL_PASS,\n-  \"final\",                              /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_final,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_FINAL,                             /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"final\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_FINAL, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_final : public rtl_opt_pass\n+{\n+public:\n+  pass_final(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_final, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_final (); }\n+\n+}; // class pass_final\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_final (gcc::context *ctxt)\n+{\n+  return new pass_final (ctxt);\n+}\n+\n \n static unsigned int\n rest_of_handle_shorten_branches (void)\n@@ -4438,26 +4472,43 @@ rest_of_handle_shorten_branches (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_shorten_branches =\n+namespace {\n+\n+const pass_data pass_data_shorten_branches =\n {\n- {\n-  RTL_PASS,\n-  \"shorten\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_shorten_branches,      /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_SHORTEN_BRANCH,                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"shorten\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_SHORTEN_BRANCH, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_shorten_branches : public rtl_opt_pass\n+{\n+public:\n+  pass_shorten_branches(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_shorten_branches, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_shorten_branches (); }\n+\n+}; // class pass_shorten_branches\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_shorten_branches (gcc::context *ctxt)\n+{\n+  return new pass_shorten_branches (ctxt);\n+}\n+\n \n static unsigned int\n rest_of_clean_state (void)\n@@ -4585,22 +4636,39 @@ rest_of_clean_state (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_clean_state =\n+namespace {\n+\n+const pass_data pass_data_clean_state =\n {\n- {\n-  RTL_PASS,\n-  \"*clean_state\",                       /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_clean_state,                  /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_FINAL,                             /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  PROP_rtl,                             /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"*clean_state\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_FINAL, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  PROP_rtl, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_clean_state : public rtl_opt_pass\n+{\n+public:\n+  pass_clean_state(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_clean_state, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_clean_state (); }\n+\n+}; // class pass_clean_state\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_clean_state (gcc::context *ctxt)\n+{\n+  return new pass_clean_state (ctxt);\n+}"}, {"sha": "4685cb02727344d2cb11a0751d5f3461428ec741", "filename": "gcc/function.c", "status": "modified", "additions": 143, "deletions": 73, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1948,26 +1948,43 @@ instantiate_virtual_regs (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_instantiate_virtual_regs =\n-{\n- {\n-  RTL_PASS,\n-  \"vregs\",                              /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  instantiate_virtual_regs,             /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_instantiate_virtual_regs =\n+{\n+  RTL_PASS, /* type */\n+  \"vregs\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_instantiate_virtual_regs : public rtl_opt_pass\n+{\n+public:\n+  pass_instantiate_virtual_regs(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_instantiate_virtual_regs, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return instantiate_virtual_regs (); }\n+\n+}; // class pass_instantiate_virtual_regs\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_instantiate_virtual_regs (gcc::context *ctxt)\n+{\n+  return new pass_instantiate_virtual_regs (ctxt);\n+}\n+\n \f\n /* Return 1 if EXP is an aggregate type (or a value with aggregate type).\n    This means a type for which function calls must pass an address to the\n@@ -6973,26 +6990,43 @@ types_used_by_var_decl_insert (tree type, tree var_decl)\n     }\n }\n \n-struct rtl_opt_pass pass_leaf_regs =\n-{\n- {\n-  RTL_PASS,\n-  \"*leaf_regs\",                         /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_check_leaf_regs,       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_leaf_regs =\n+{\n+  RTL_PASS, /* type */\n+  \"*leaf_regs\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_leaf_regs : public rtl_opt_pass\n+{\n+public:\n+  pass_leaf_regs(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_leaf_regs, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_check_leaf_regs (); }\n+\n+}; // class pass_leaf_regs\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_leaf_regs (gcc::context *ctxt)\n+{\n+  return new pass_leaf_regs (ctxt);\n+}\n+\n static unsigned int\n rest_of_handle_thread_prologue_and_epilogue (void)\n {\n@@ -7012,26 +7046,45 @@ rest_of_handle_thread_prologue_and_epilogue (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_thread_prologue_and_epilogue =\n-{\n- {\n-  RTL_PASS,\n-  \"pro_and_epilogue\",                   /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_thread_prologue_and_epilogue, /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_THREAD_PROLOGUE_AND_EPILOGUE,      /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  TODO_verify_flow,                     /* todo_flags_start */\n-  TODO_df_verify | TODO_df_finish\n-  | TODO_verify_rtl_sharing             /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_thread_prologue_and_epilogue =\n+{\n+  RTL_PASS, /* type */\n+  \"pro_and_epilogue\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_THREAD_PROLOGUE_AND_EPILOGUE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  TODO_verify_flow, /* todo_flags_start */\n+  ( TODO_df_verify | TODO_df_finish\n+    | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_thread_prologue_and_epilogue : public rtl_opt_pass\n+{\n+public:\n+  pass_thread_prologue_and_epilogue(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_thread_prologue_and_epilogue, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () {\n+    return rest_of_handle_thread_prologue_and_epilogue ();\n+  }\n+\n+}; // class pass_thread_prologue_and_epilogue\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_thread_prologue_and_epilogue (gcc::context *ctxt)\n+{\n+  return new pass_thread_prologue_and_epilogue (ctxt);\n+}\n \f\n \n /* This mini-pass fixes fall-out from SSA in asm statements that have\n@@ -7213,25 +7266,42 @@ rest_of_match_asm_constraints (void)\n   return TODO_df_finish;\n }\n \n-struct rtl_opt_pass pass_match_asm_constraints =\n-{\n- {\n-  RTL_PASS,\n-  \"asmcons\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  rest_of_match_asm_constraints,\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_match_asm_constraints =\n+{\n+  RTL_PASS, /* type */\n+  \"asmcons\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_match_asm_constraints : public rtl_opt_pass\n+{\n+public:\n+  pass_match_asm_constraints(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_match_asm_constraints, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_match_asm_constraints (); }\n+\n+}; // class pass_match_asm_constraints\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_match_asm_constraints (gcc::context *ctxt)\n+{\n+  return new pass_match_asm_constraints (ctxt);\n+}\n+\n \n #include \"gt-function.h\""}, {"sha": "8fe02ac2a4338dc978f132cf1364a574054dff46", "filename": "gcc/fwprop.c", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1485,28 +1485,45 @@ fwprop (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_fwprop =\n+namespace {\n+\n+const pass_data pass_data_rtl_fwprop =\n {\n- {\n-  RTL_PASS,\n-  \"fwprop1\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_fwprop,\t\t\t\t/* gate */\n-  fwprop,\t\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_FWPROP,                            /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish\n-    | TODO_verify_flow\n-    | TODO_verify_rtl_sharing           /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"fwprop1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_FWPROP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_flow\n+    | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n \n+class pass_rtl_fwprop : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_fwprop(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_fwprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_fwprop (); }\n+  unsigned int execute () { return fwprop (); }\n+\n+}; // class pass_rtl_fwprop\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_fwprop (gcc::context *ctxt)\n+{\n+  return new pass_rtl_fwprop (ctxt);\n+}\n+\n static unsigned int\n fwprop_addr (void)\n {\n@@ -1535,22 +1552,40 @@ fwprop_addr (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_fwprop_addr =\n+namespace {\n+\n+const pass_data pass_data_rtl_fwprop_addr =\n {\n- {\n-  RTL_PASS,\n-  \"fwprop2\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_fwprop,\t\t\t\t/* gate */\n-  fwprop_addr,\t\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_FWPROP,                            /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing  /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"fwprop2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_FWPROP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_rtl_fwprop_addr : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_fwprop_addr(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_fwprop_addr, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_fwprop (); }\n+  unsigned int execute () { return fwprop_addr (); }\n+\n+}; // class pass_rtl_fwprop_addr\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_fwprop_addr (gcc::context *ctxt)\n+{\n+  return new pass_rtl_fwprop_addr (ctxt);\n+}"}, {"sha": "422d6f060eb0b0a394418665e8f8765b4837b10b", "filename": "gcc/gcse.c", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -4148,46 +4148,82 @@ execute_rtl_hoist (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_pre =\n+namespace {\n+\n+const pass_data pass_data_rtl_pre =\n {\n- {\n-  RTL_PASS,\n-  \"rtl pre\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_rtl_pre,                         /* gate */\n-  execute_rtl_pre,    \t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_PRE,                               /* tv_id */\n-  PROP_cfglayout,                       /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"rtl pre\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_PRE, /* tv_id */\n+  PROP_cfglayout, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n \n-struct rtl_opt_pass pass_rtl_hoist =\n+class pass_rtl_pre : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_pre(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_pre, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rtl_pre (); }\n+  unsigned int execute () { return execute_rtl_pre (); }\n+\n+}; // class pass_rtl_pre\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_pre (gcc::context *ctxt)\n+{\n+  return new pass_rtl_pre (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_rtl_hoist =\n {\n- {\n-  RTL_PASS,\n-  \"hoist\",                              /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_rtl_hoist,                       /* gate */\n-  execute_rtl_hoist,  \t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_HOIST,                             /* tv_id */\n-  PROP_cfglayout,                       /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"hoist\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_HOIST, /* tv_id */\n+  PROP_cfglayout, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n \n+class pass_rtl_hoist : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_hoist(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_hoist, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rtl_hoist (); }\n+  unsigned int execute () { return execute_rtl_hoist (); }\n+\n+}; // class pass_rtl_hoist\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_hoist (gcc::context *ctxt)\n+{\n+  return new pass_rtl_hoist (ctxt);\n+}\n+\n #include \"gt-gcse.h\""}, {"sha": "2884b6ff6fb9c2c7576611901f2abbfd47b4c347", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -177,26 +177,43 @@ lower_function_body (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_lower_cf =\n+namespace {\n+\n+const pass_data pass_data_lower_cf =\n {\n- {\n-  GIMPLE_PASS,\n-  \"lower\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  lower_function_body,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_gimple_any,\t\t\t/* properties_required */\n-  PROP_gimple_lcf,\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"lower\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  PROP_gimple_lcf, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_lower_cf : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_cf(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_cf, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return lower_function_body (); }\n+\n+}; // class pass_lower_cf\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_cf (gcc::context *ctxt)\n+{\n+  return new pass_lower_cf (ctxt);\n+}\n+\n \n \n /* Verify if the type of the argument matches that of the function"}, {"sha": "c6f305c35eaaf563263559dc798264bd91db750c", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3478,22 +3478,40 @@ gate_strength_reduction (void)\n   return flag_tree_slsr;\n }\n \n-struct gimple_opt_pass pass_strength_reduction =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"slsr\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_strength_reduction,\t\t/* gate */\n-  execute_strength_reduction,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_GIMPLE_SLSR,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_strength_reduction =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"slsr\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_GIMPLE_SLSR, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_strength_reduction : public gimple_opt_pass\n+{\n+public:\n+  pass_strength_reduction(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_strength_reduction, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_strength_reduction (); }\n+  unsigned int execute () { return execute_strength_reduction (); }\n+\n+}; // class pass_strength_reduction\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_strength_reduction (gcc::context *ctxt)\n+{\n+  return new pass_strength_reduction (ctxt);\n+}"}, {"sha": "5698b4f5e7242a63449b5fcd1444a7673aefa015", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 105, "deletions": 52, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -4480,27 +4480,44 @@ rest_of_handle_if_conversion (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_ifcvt =\n+namespace {\n+\n+const pass_data pass_data_rtl_ifcvt =\n {\n- {\n-  RTL_PASS,\n-  \"ce1\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_if_conversion,            /* gate */\n-  rest_of_handle_if_conversion,         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_IFCVT,                             /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"ce1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IFCVT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n };\n \n+class pass_rtl_ifcvt : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_ifcvt(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_ifcvt, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_if_conversion (); }\n+  unsigned int execute () { return rest_of_handle_if_conversion (); }\n+\n+}; // class pass_rtl_ifcvt\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_ifcvt (gcc::context *ctxt)\n+{\n+  return new pass_rtl_ifcvt (ctxt);\n+}\n+\n static bool\n gate_handle_if_after_combine (void)\n {\n@@ -4518,26 +4535,44 @@ rest_of_handle_if_after_combine (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_if_after_combine =\n+namespace {\n+\n+const pass_data pass_data_if_after_combine =\n {\n- {\n-  RTL_PASS,\n-  \"ce2\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_if_after_combine,         /* gate */\n-  rest_of_handle_if_after_combine,      /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_IFCVT,                             /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"ce2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IFCVT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n \n+class pass_if_after_combine : public rtl_opt_pass\n+{\n+public:\n+  pass_if_after_combine(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_if_after_combine, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_if_after_combine (); }\n+  unsigned int execute () { return rest_of_handle_if_after_combine (); }\n+\n+}; // class pass_if_after_combine\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_if_after_combine (gcc::context *ctxt)\n+{\n+  return new pass_if_after_combine (ctxt);\n+}\n+\n \n static bool\n gate_handle_if_after_reload (void)\n@@ -4554,22 +4589,40 @@ rest_of_handle_if_after_reload (void)\n }\n \n \n-struct rtl_opt_pass pass_if_after_reload =\n+namespace {\n+\n+const pass_data pass_data_if_after_reload =\n {\n- {\n-  RTL_PASS,\n-  \"ce3\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_if_after_reload,          /* gate */\n-  rest_of_handle_if_after_reload,       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_IFCVT2,                            /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"ce3\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IFCVT2, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_if_after_reload : public rtl_opt_pass\n+{\n+public:\n+  pass_if_after_reload(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_if_after_reload, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_if_after_reload (); }\n+  unsigned int execute () { return rest_of_handle_if_after_reload (); }\n+\n+}; // class pass_if_after_reload\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_if_after_reload (gcc::context *ctxt)\n+{\n+  return new pass_if_after_reload (ctxt);\n+}"}, {"sha": "ddb0b3792bae06cc09d233dfcef3b5b57e25b87f", "filename": "gcc/init-regs.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -138,22 +138,40 @@ rest_of_handle_initialize_regs (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_initialize_regs =\n+namespace {\n+\n+const pass_data pass_data_initialize_regs =\n {\n- {\n-  RTL_PASS,\n-  \"init-regs\",                          /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_initialize_regs,                 /* gate */\n-  rest_of_handle_initialize_regs,       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish                        /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"init-regs\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n };\n+\n+class pass_initialize_regs : public rtl_opt_pass\n+{\n+public:\n+  pass_initialize_regs(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_initialize_regs, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_initialize_regs (); }\n+  unsigned int execute () { return rest_of_handle_initialize_regs (); }\n+\n+}; // class pass_initialize_regs\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_initialize_regs (gcc::context *ctxt)\n+{\n+  return new pass_initialize_regs (ctxt);\n+}"}, {"sha": "688209dd49c08c4337ff164274d35a8f047f0e61", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3652,32 +3652,51 @@ cgraph_gate_cp (void)\n   return flag_ipa_cp && optimize;\n }\n \n-struct ipa_opt_pass_d pass_ipa_cp =\n-{\n- {\n-  IPA_PASS,\n-  \"cp\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                /* optinfo_flags */\n-  cgraph_gate_cp,\t\t/* gate */\n-  ipcp_driver,\t\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_IPA_CONSTANT_PROP,\t\t/* tv_id */\n-  0,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_dump_symtab |\n-  TODO_remove_functions         /* todo_flags_finish */\n- },\n- ipcp_generate_summary,\t\t\t/* generate_summary */\n- ipcp_write_summary,\t\t\t/* write_summary */\n- ipcp_read_summary,\t\t\t/* read_summary */\n- ipa_prop_write_all_agg_replacement,\t/* write_optimization_summary */\n- ipa_prop_read_all_agg_replacement,\t/* read_optimization_summary */\n- NULL,\t\t\t \t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- ipcp_transform_function,\t\t/* function_transform */\n- NULL,\t\t\t\t\t/* variable_transform */\n+namespace {\n+\n+const pass_data pass_data_ipa_cp =\n+{\n+  IPA_PASS, /* type */\n+  \"cp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_CONSTANT_PROP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_dump_symtab | TODO_remove_functions ), /* todo_flags_finish */\n };\n+\n+class pass_ipa_cp : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_cp(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_cp, ctxt,\n+\t\t     ipcp_generate_summary, /* generate_summary */\n+\t\t     ipcp_write_summary, /* write_summary */\n+\t\t     ipcp_read_summary, /* read_summary */\n+\t\t     ipa_prop_write_all_agg_replacement, /*\n+\t\t     write_optimization_summary */\n+\t\t     ipa_prop_read_all_agg_replacement, /*\n+\t\t     read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     ipcp_transform_function, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return cgraph_gate_cp (); }\n+  unsigned int execute () { return ipcp_driver (); }\n+\n+}; // class pass_ipa_cp\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_cp (gcc::context *ctxt)\n+{\n+  return new pass_ipa_cp (ctxt);\n+}"}, {"sha": "2f30797443a39a35c81a6a697352870e603d55e4", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2715,26 +2715,46 @@ compute_inline_parameters_for_current (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_inline_parameters = \n-{\n- {\n-  GIMPLE_PASS,\n-  \"inline_param\",\t\t/* name */\n-  OPTGROUP_INLINE,\t\t/* optinfo_flags */\n-  NULL,\t\t\t/* gate */\n-  compute_inline_parameters_for_current,\t/* execute */\n-  NULL,\t\t\t/* sub */\n-  NULL,\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_INLINE_PARAMETERS,\t/* tv_id */\n-  0,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t/* todo_flags_finish */\n-  }\n+namespace {\n+\n+const pass_data pass_data_inline_parameters =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"inline_param\", /* name */\n+  OPTGROUP_INLINE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_INLINE_PARAMETERS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_inline_parameters : public gimple_opt_pass\n+{\n+public:\n+  pass_inline_parameters(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_inline_parameters, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_inline_parameters (ctxt_); }\n+  unsigned int execute () {\n+    return compute_inline_parameters_for_current ();\n+  }\n+\n+}; // class pass_inline_parameters\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_inline_parameters (gcc::context *ctxt)\n+{\n+  return new pass_inline_parameters (ctxt);\n+}\n+\n \n /* Estimate benefit devirtualizing indirect edge IE, provided KNOWN_VALS and\n    KNOWN_BINFOS.  */"}, {"sha": "96cbc9a0133f2d8f93857f8660696e3d026df3eb", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 78, "deletions": 44, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2086,26 +2086,43 @@ early_inliner (void)\n   return todo;\n }\n \n-struct gimple_opt_pass pass_early_inline =\n+namespace {\n+\n+const pass_data pass_data_early_inline =\n {\n- {\n-  GIMPLE_PASS,\n-  \"einline\",\t \t\t\t/* name */\n-  OPTGROUP_INLINE,                      /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  early_inliner,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_EARLY_INLINING,\t\t\t/* tv_id */\n-  PROP_ssa,                             /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                 \t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"einline\", /* name */\n+  OPTGROUP_INLINE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_EARLY_INLINING, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_early_inline : public gimple_opt_pass\n+{\n+public:\n+  pass_early_inline(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_early_inline, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return early_inliner (); }\n+\n+}; // class pass_early_inline\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_early_inline (gcc::context *ctxt)\n+{\n+  return new pass_early_inline (ctxt);\n+}\n+\n \n /* When to run IPA inlining.  Inlining of always-inline functions\n    happens during early inlining.\n@@ -2119,32 +2136,49 @@ gate_ipa_inline (void)\n   return optimize || flag_lto || flag_wpa;\n }\n \n-struct ipa_opt_pass_d pass_ipa_inline =\n+namespace {\n+\n+const pass_data pass_data_ipa_inline =\n {\n- {\n-  IPA_PASS,\n-  \"inline\",\t\t\t\t/* name */\n-  OPTGROUP_INLINE,                      /* optinfo_flags */\n-  gate_ipa_inline,\t\t\t/* gate */\n-  ipa_inline,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_INLINING,      \t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  TODO_remove_functions,\t\t/* todo_flags_finish */\n-  TODO_dump_symtab \n-  | TODO_remove_functions\t\t/* todo_flags_finish */\n- },\n- inline_generate_summary,\t\t/* generate_summary */\n- inline_write_summary,\t\t\t/* write_summary */\n- inline_read_summary,\t\t\t/* read_summary */\n- NULL,\t\t\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- inline_transform,\t\t\t/* function_transform */\n- NULL,\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"inline\", /* name */\n+  OPTGROUP_INLINE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_INLINING, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  TODO_remove_functions, /* todo_flags_start */\n+  ( TODO_dump_symtab | TODO_remove_functions ), /* todo_flags_finish */\n };\n+\n+class pass_ipa_inline : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_inline(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_inline, ctxt,\n+\t\t     inline_generate_summary, /* generate_summary */\n+\t\t     inline_write_summary, /* write_summary */\n+\t\t     inline_read_summary, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     inline_transform, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ipa_inline (); }\n+  unsigned int execute () { return ipa_inline (); }\n+\n+}; // class pass_ipa_inline\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_inline (gcc::context *ctxt)\n+{\n+  return new pass_ipa_inline (ctxt);\n+}"}, {"sha": "7a293657114b6defa209f4bf3c1dc0f85df1fd52", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 80, "deletions": 43, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1498,35 +1498,53 @@ gate_pure_const (void)\n \t  && !seen_error ());\n }\n \n-struct ipa_opt_pass_d pass_ipa_pure_const =\n+namespace {\n+\n+const pass_data pass_data_ipa_pure_const =\n {\n- {\n-  IPA_PASS,\n-  \"pure-const\",\t\t                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_pure_const,\t\t\t/* gate */\n-  propagate,\t\t\t        /* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_PURE_CONST,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- },\n- pure_const_generate_summary,\t\t/* generate_summary */\n- pure_const_write_summary,\t\t/* write_summary */\n- pure_const_read_summary,\t\t/* read_summary */\n- NULL,\t\t\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t                /* function_transform */\n- NULL\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"pure-const\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_PURE_CONST, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_ipa_pure_const : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_pure_const(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_pure_const, ctxt,\n+\t\t     pure_const_generate_summary, /* generate_summary */\n+\t\t     pure_const_write_summary, /* write_summary */\n+\t\t     pure_const_read_summary, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_pure_const (); }\n+  unsigned int execute () { return propagate (); }\n+\n+}; // class pass_ipa_pure_const\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_pure_const (gcc::context *ctxt)\n+{\n+  return new pass_ipa_pure_const (ctxt);\n+}\n+\n /* Return true if function should be skipped for local pure const analysis.  */\n \n static bool\n@@ -1664,22 +1682,41 @@ local_pure_const (void)\n     return 0;\n }\n \n-struct gimple_opt_pass pass_local_pure_const =\n+namespace {\n+\n+const pass_data pass_data_local_pure_const =\n {\n- {\n-  GIMPLE_PASS,\n-  \"local-pure-const\",\t                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_pure_const,\t\t\t/* gate */\n-  local_pure_const,\t\t        /* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_PURE_CONST,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"local-pure-const\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_PURE_CONST, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_local_pure_const : public gimple_opt_pass\n+{\n+public:\n+  pass_local_pure_const(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_local_pure_const, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_local_pure_const (ctxt_); }\n+  bool gate () { return gate_pure_const (); }\n+  unsigned int execute () { return local_pure_const (); }\n+\n+}; // class pass_local_pure_const\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_local_pure_const (gcc::context *ctxt)\n+{\n+  return new pass_local_pure_const (ctxt);\n+}"}, {"sha": "3742474ed65f536dac6ca425def9fc1d7fbf0296", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1155,31 +1155,51 @@ gate_reference (void)\n \t  && !seen_error ());\n }\n \n-struct ipa_opt_pass_d pass_ipa_reference =\n+namespace {\n+\n+const pass_data pass_data_ipa_reference =\n {\n- {\n-  IPA_PASS,\n-  \"static-var\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_reference,\t\t\t/* gate */\n-  propagate,\t\t\t        /* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_REFERENCE,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- },\n- NULL,\t\t\t\t        /* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t \t/* read_summary */\n- ipa_reference_write_optimization_summary,/* write_optimization_summary */\n- ipa_reference_read_optimization_summary,/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t                /* function_transform */\n- NULL\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"static-var\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_REFERENCE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_ipa_reference : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_reference(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_reference, ctxt,\n+\t\t     NULL, /* generate_summary */\n+\t\t     NULL, /* write_summary */\n+\t\t     NULL, /* read_summary */\n+\t\t     ipa_reference_write_optimization_summary, /*\n+\t\t     write_optimization_summary */\n+\t\t     ipa_reference_read_optimization_summary, /*\n+\t\t     read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_reference (); }\n+  unsigned int execute () { return propagate (); }\n+\n+}; // class pass_ipa_reference\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_reference (gcc::context *ctxt)\n+{\n+  return new pass_ipa_reference (ctxt);\n+}"}, {"sha": "c83c4d04dbfa5c8c74edb303de9ecbf6482a24f2", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 70, "deletions": 34, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1624,26 +1624,44 @@ gate_split_functions (void)\n \t  && !profile_arc_flag && !flag_branch_probabilities);\n }\n \n-struct gimple_opt_pass pass_split_functions =\n+namespace {\n+\n+const pass_data pass_data_split_functions =\n {\n- {\n-  GIMPLE_PASS,\n-  \"fnsplit\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_split_functions,\t\t\t/* gate */\n-  execute_split_functions,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_FNSPLIT,\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_all      \t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"fnsplit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_FNSPLIT, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_all, /* todo_flags_finish */\n };\n \n+class pass_split_functions : public gimple_opt_pass\n+{\n+public:\n+  pass_split_functions(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_split_functions, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_split_functions (); }\n+  unsigned int execute () { return execute_split_functions (); }\n+\n+}; // class pass_split_functions\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_split_functions (gcc::context *ctxt)\n+{\n+  return new pass_split_functions (ctxt);\n+}\n+\n /* Gate feedback driven function splitting pass.\n    We don't need to split when profiling at all, we are producing\n    lousy code anyway.  */\n@@ -1666,22 +1684,40 @@ execute_feedback_split_functions (void)\n   return retval;\n }\n \n-struct gimple_opt_pass pass_feedback_split_functions =\n+namespace {\n+\n+const pass_data pass_data_feedback_split_functions =\n {\n- {\n-  GIMPLE_PASS,\n-  \"feedback_fnsplit\",\t\t\t/* name */\n-  OPTGROUP_NONE,                      /* optinfo_flags */\n-  gate_feedback_split_functions,\t/* gate */\n-  execute_feedback_split_functions,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_FNSPLIT,\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_all      \t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"feedback_fnsplit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_FNSPLIT, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_all, /* todo_flags_finish */\n };\n+\n+class pass_feedback_split_functions : public gimple_opt_pass\n+{\n+public:\n+  pass_feedback_split_functions(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_feedback_split_functions, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_feedback_split_functions (); }\n+  unsigned int execute () { return execute_feedback_split_functions (); }\n+\n+}; // class pass_feedback_split_functions\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_feedback_split_functions (gcc::context *ctxt)\n+{\n+  return new pass_feedback_split_functions (ctxt);\n+}"}, {"sha": "01e9bee2e28e7ac6b286083b5c559beb20a9e831", "filename": "gcc/ipa.c", "status": "modified", "additions": 206, "deletions": 112, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1012,26 +1012,45 @@ local_function_and_variable_visibility (void)\n   return function_and_variable_visibility (flag_whole_program && !flag_lto);\n }\n \n-struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility =\n+namespace {\n+\n+const pass_data pass_data_ipa_function_and_variable_visibility =\n {\n- {\n-  SIMPLE_IPA_PASS,\n-  \"visibility\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  local_function_and_variable_visibility,/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_CGRAPHOPT,\t\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_remove_functions | TODO_dump_symtab /* todo_flags_finish */\n- }\n+  SIMPLE_IPA_PASS, /* type */\n+  \"visibility\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_CGRAPHOPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_remove_functions | TODO_dump_symtab ), /* todo_flags_finish */\n };\n \n+class pass_ipa_function_and_variable_visibility : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_function_and_variable_visibility(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_function_and_variable_visibility, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () {\n+    return local_function_and_variable_visibility ();\n+  }\n+\n+}; // class pass_ipa_function_and_variable_visibility\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_function_and_variable_visibility (gcc::context *ctxt)\n+{\n+  return new pass_ipa_function_and_variable_visibility (ctxt);\n+}\n+\n /* Free inline summary.  */\n \n static unsigned\n@@ -1041,26 +1060,43 @@ free_inline_summary (void)\n   return 0;\n }\n \n-struct simple_ipa_opt_pass pass_ipa_free_inline_summary =\n+namespace {\n+\n+const pass_data pass_data_ipa_free_inline_summary =\n {\n- {\n-  SIMPLE_IPA_PASS,\n-  \"*free_inline_summary\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  free_inline_summary,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_FREE_INLINE_SUMMARY,\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  SIMPLE_IPA_PASS, /* type */\n+  \"*free_inline_summary\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_FREE_INLINE_SUMMARY, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_ipa_free_inline_summary : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_free_inline_summary(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_free_inline_summary, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return free_inline_summary (); }\n+\n+}; // class pass_ipa_free_inline_summary\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_free_inline_summary (gcc::context *ctxt)\n+{\n+  return new pass_ipa_free_inline_summary (ctxt);\n+}\n+\n /* Do not re-run on ltrans stage.  */\n \n static bool\n@@ -1080,35 +1116,57 @@ whole_program_function_and_variable_visibility (void)\n   return 0;\n }\n \n-struct ipa_opt_pass_d pass_ipa_whole_program_visibility =\n+namespace {\n+\n+const pass_data pass_data_ipa_whole_program_visibility =\n {\n- {\n-  IPA_PASS,\n-  \"whole-program\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_whole_program_function_and_variable_visibility,/* gate */\n-  whole_program_function_and_variable_visibility,/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_CGRAPHOPT,\t\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_remove_functions | TODO_dump_symtab /* todo_flags_finish */\n- },\n- NULL,\t\t\t\t\t/* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n- NULL,\t\t\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t\t\t/* function_transform */\n- NULL,\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"whole-program\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CGRAPHOPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_remove_functions | TODO_dump_symtab ), /* todo_flags_finish */\n };\n \n+class pass_ipa_whole_program_visibility : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_whole_program_visibility(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_whole_program_visibility, ctxt,\n+\t\t     NULL, /* generate_summary */\n+\t\t     NULL, /* write_summary */\n+\t\t     NULL, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () {\n+    return gate_whole_program_function_and_variable_visibility ();\n+  }\n+  unsigned int execute () {\n+    return whole_program_function_and_variable_visibility ();\n+  }\n+\n+}; // class pass_ipa_whole_program_visibility\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_whole_program_visibility (gcc::context *ctxt)\n+{\n+  return new pass_ipa_whole_program_visibility (ctxt);\n+}\n+\n /* Entry in the histogram.  */\n \n struct histogram_entry\n@@ -1427,35 +1485,53 @@ gate_ipa_profile (void)\n   return flag_ipa_profile;\n }\n \n-struct ipa_opt_pass_d pass_ipa_profile =\n+namespace {\n+\n+const pass_data pass_data_ipa_profile =\n {\n- {\n-  IPA_PASS,\n-  \"profile_estimate\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_ipa_profile,\t\t\t/* gate */\n-  ipa_profile,\t\t\t        /* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_PROFILE,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- },\n- ipa_profile_generate_summary,\t        /* generate_summary */\n- ipa_profile_write_summary,\t\t/* write_summary */\n- ipa_profile_read_summary,\t\t/* read_summary */\n- NULL,\t\t\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t                /* function_transform */\n- NULL\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"profile_estimate\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_PROFILE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_ipa_profile : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_profile(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_profile, ctxt,\n+\t\t     ipa_profile_generate_summary, /* generate_summary */\n+\t\t     ipa_profile_write_summary, /* write_summary */\n+\t\t     ipa_profile_read_summary, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ipa_profile (); }\n+  unsigned int execute () { return ipa_profile (); }\n+\n+}; // class pass_ipa_profile\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_profile (gcc::context *ctxt)\n+{\n+  return new pass_ipa_profile (ctxt);\n+}\n+\n /* Generate and emit a static constructor or destructor.  WHICH must\n    be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n    is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n@@ -1738,31 +1814,49 @@ gate_ipa_cdtor_merge (void)\n   return !targetm.have_ctors_dtors || (optimize && in_lto_p);\n }\n \n-struct ipa_opt_pass_d pass_ipa_cdtor_merge =\n+namespace {\n+\n+const pass_data pass_data_ipa_cdtor_merge =\n {\n- {\n-  IPA_PASS,\n-  \"cdtor\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_ipa_cdtor_merge,\t\t\t/* gate */\n-  ipa_cdtor_merge,\t\t        /* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_CGRAPHOPT,\t\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- },\n- NULL,\t\t\t\t        /* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n- NULL,\t\t\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t                /* function_transform */\n- NULL\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"cdtor\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CGRAPHOPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_ipa_cdtor_merge : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_cdtor_merge(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_cdtor_merge, ctxt,\n+\t\t     NULL, /* generate_summary */\n+\t\t     NULL, /* write_summary */\n+\t\t     NULL, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ipa_cdtor_merge (); }\n+  unsigned int execute () { return ipa_cdtor_merge (); }\n+\n+}; // class pass_ipa_cdtor_merge\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_cdtor_merge (gcc::context *ctxt)\n+{\n+  return new pass_ipa_cdtor_merge (ctxt);\n+}"}, {"sha": "487746ee6375ed6d355b43df2426da35b85a2379", "filename": "gcc/ira.c", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -4775,49 +4775,83 @@ rest_of_handle_ira (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_ira =\n+namespace {\n+\n+const pass_data pass_data_ira =\n {\n- {\n-  RTL_PASS,\n-  \"ira\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_ira,\t\t        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_IRA,\t                        /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_do_not_ggc_collect               /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"ira\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_IRA, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_do_not_ggc_collect, /* todo_flags_finish */\n };\n \n+class pass_ira : public rtl_opt_pass\n+{\n+public:\n+  pass_ira(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_ira, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_ira (); }\n+\n+}; // class pass_ira\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_ira (gcc::context *ctxt)\n+{\n+  return new pass_ira (ctxt);\n+}\n+\n static unsigned int\n rest_of_handle_reload (void)\n {\n   do_reload ();\n   return 0;\n }\n \n-struct rtl_opt_pass pass_reload =\n+namespace {\n+\n+const pass_data pass_data_reload =\n {\n- {\n-  RTL_PASS,\n-  \"reload\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_reload,\t        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_RELOAD,\t                        /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"reload\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_RELOAD, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_reload : public rtl_opt_pass\n+{\n+public:\n+  pass_reload(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_reload, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_reload (); }\n+\n+}; // class pass_reload\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_reload (gcc::context *ctxt)\n+{\n+  return new pass_reload (ctxt);\n+}"}, {"sha": "6f7bcb72d1c45d8336e8a5fda23a12e719a88c89", "filename": "gcc/jump.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -139,26 +139,43 @@ cleanup_barriers (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_cleanup_barriers =\n+namespace {\n+\n+const pass_data pass_data_cleanup_barriers =\n {\n- {\n-  RTL_PASS,\n-  \"barriers\",                           /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  cleanup_barriers,                     /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"barriers\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_cleanup_barriers : public rtl_opt_pass\n+{\n+public:\n+  pass_cleanup_barriers(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_cleanup_barriers, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return cleanup_barriers (); }\n+\n+}; // class pass_cleanup_barriers\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_cleanup_barriers (gcc::context *ctxt)\n+{\n+  return new pass_cleanup_barriers (ctxt);\n+}\n+\n \f\n /* Initialize LABEL_NUSES and JUMP_LABEL fields, add REG_LABEL_TARGET\n    for remaining targets for JUMP_P.  Delete any REG_LABEL_OPERAND"}, {"sha": "80c31ef70cd6ccb708a6d429b95deddb656e031a", "filename": "gcc/loop-init.c", "status": "modified", "additions": 250, "deletions": 128, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -316,26 +316,43 @@ gate_handle_loop2 (void)\n     } \n }\n \n-struct rtl_opt_pass pass_loop2 =\n-{\n- {\n-  RTL_PASS,\n-  \"loop2\",                              /* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_handle_loop2, \t\t        /* gate */\n-  NULL,                                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOOP,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_loop2 =\n+{\n+  RTL_PASS, /* type */\n+  \"loop2\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_LOOP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_loop2 : public rtl_opt_pass\n+{\n+public:\n+  pass_loop2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_loop2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_loop2 (); }\n+\n+}; // class pass_loop2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_loop2 (gcc::context *ctxt)\n+{\n+  return new pass_loop2 (ctxt);\n+}\n+\n \f\n /* Initialization of the RTL loop passes.  */\n static unsigned int\n@@ -353,26 +370,43 @@ rtl_loop_init (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_loop_init =\n-{\n- {\n-  RTL_PASS,\n-  \"loop2_init\",                           /* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rtl_loop_init,                        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOOP,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing               /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rtl_loop_init =\n+{\n+  RTL_PASS, /* type */\n+  \"loop2_init\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOOP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_rtl_loop_init : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_loop_init(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_loop_init, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rtl_loop_init (); }\n+\n+}; // class pass_rtl_loop_init\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_loop_init (gcc::context *ctxt)\n+{\n+  return new pass_rtl_loop_init (ctxt);\n+}\n+\n \f\n /* Finalization of the RTL loop passes.  */\n \n@@ -394,27 +428,43 @@ rtl_loop_done (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_loop_done =\n-{\n- {\n-  RTL_PASS,\n-  \"loop2_done\",                          /* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rtl_loop_done,                        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOOP,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  PROP_loops,                           /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_flow\n-    | TODO_verify_rtl_sharing           /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rtl_loop_done =\n+{\n+  RTL_PASS, /* type */\n+  \"loop2_done\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOOP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  PROP_loops, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_flow | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n \n+class pass_rtl_loop_done : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_loop_done(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_loop_done, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rtl_loop_done (); }\n+\n+}; // class pass_rtl_loop_done\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_loop_done (gcc::context *ctxt)\n+{\n+  return new pass_rtl_loop_done (ctxt);\n+}\n+\n \f\n /* Loop invariant code motion.  */\n static bool\n@@ -431,27 +481,45 @@ rtl_move_loop_invariants (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_move_loop_invariants =\n-{\n- {\n-  RTL_PASS,\n-  \"loop2_invariant\",                    /* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_rtl_move_loop_invariants,        /* gate */\n-  rtl_move_loop_invariants,             /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOOP_MOVE_INVARIANTS,              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_verify |\n-  TODO_df_finish | TODO_verify_rtl_sharing  /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rtl_move_loop_invariants =\n+{\n+  RTL_PASS, /* type */\n+  \"loop2_invariant\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOOP_MOVE_INVARIANTS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_verify | TODO_df_finish\n+    | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n \n+class pass_rtl_move_loop_invariants : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_move_loop_invariants(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_move_loop_invariants, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rtl_move_loop_invariants (); }\n+  unsigned int execute () { return rtl_move_loop_invariants (); }\n+\n+}; // class pass_rtl_move_loop_invariants\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_move_loop_invariants (gcc::context *ctxt)\n+{\n+  return new pass_rtl_move_loop_invariants (ctxt);\n+}\n+\n \f\n /* Loop unswitching for RTL.  */\n static bool\n@@ -468,26 +536,44 @@ rtl_unswitch (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_unswitch =\n-{\n- {\n-  RTL_PASS,\n-  \"loop2_unswitch\",                      /* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_rtl_unswitch,                    /* gate */\n-  rtl_unswitch,                         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOOP_UNSWITCH,                     /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing,              /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rtl_unswitch =\n+{\n+  RTL_PASS, /* type */\n+  \"loop2_unswitch\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOOP_UNSWITCH, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_rtl_unswitch : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_unswitch(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_unswitch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rtl_unswitch (); }\n+  unsigned int execute () { return rtl_unswitch (); }\n+\n+}; // class pass_rtl_unswitch\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_unswitch (gcc::context *ctxt)\n+{\n+  return new pass_rtl_unswitch (ctxt);\n+}\n+\n \f\n /* Loop unswitching for RTL.  */\n static bool\n@@ -517,26 +603,44 @@ rtl_unroll_and_peel_loops (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_unroll_and_peel_loops =\n-{\n- {\n-  RTL_PASS,\n-  \"loop2_unroll\",                        /* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_rtl_unroll_and_peel_loops,       /* gate */\n-  rtl_unroll_and_peel_loops,            /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOOP_UNROLL,                       /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing,              /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rtl_unroll_and_peel_loops =\n+{\n+  RTL_PASS, /* type */\n+  \"loop2_unroll\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOOP_UNROLL, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_rtl_unroll_and_peel_loops : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_unroll_and_peel_loops(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_unroll_and_peel_loops, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rtl_unroll_and_peel_loops (); }\n+  unsigned int execute () { return rtl_unroll_and_peel_loops (); }\n+\n+}; // class pass_rtl_unroll_and_peel_loops\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_unroll_and_peel_loops (gcc::context *ctxt)\n+{\n+  return new pass_rtl_unroll_and_peel_loops (ctxt);\n+}\n+\n \f\n /* The doloop optimization.  */\n static bool\n@@ -559,22 +663,40 @@ rtl_doloop (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_doloop =\n-{\n- {\n-  RTL_PASS,\n-  \"loop2_doloop\",                        /* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_rtl_doloop,                      /* gate */\n-  rtl_doloop,                           /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOOP_DOLOOP,                       /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing               /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rtl_doloop =\n+{\n+  RTL_PASS, /* type */\n+  \"loop2_doloop\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOOP_DOLOOP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n+\n+class pass_rtl_doloop : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_doloop(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_doloop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rtl_doloop (); }\n+  unsigned int execute () { return rtl_doloop (); }\n+\n+}; // class pass_rtl_doloop\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_doloop (gcc::context *ctxt)\n+{\n+  return new pass_rtl_doloop (ctxt);\n+}"}, {"sha": "ac67398a2db73260a7114e6802c82e6f34bc71c5", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 71, "deletions": 35, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1689,43 +1689,79 @@ rest_of_handle_lower_subreg2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_lower_subreg =\n+namespace {\n+\n+const pass_data pass_data_lower_subreg =\n {\n- {\n-  RTL_PASS,\n-  \"subreg1\",\t                        /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_lower_subreg,             /* gate */\n-  rest_of_handle_lower_subreg,          /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOWER_SUBREG,                      /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"subreg1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOWER_SUBREG, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n };\n \n-struct rtl_opt_pass pass_lower_subreg2 =\n+class pass_lower_subreg : public rtl_opt_pass\n+{\n+public:\n+  pass_lower_subreg(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_lower_subreg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_lower_subreg (); }\n+  unsigned int execute () { return rest_of_handle_lower_subreg (); }\n+\n+}; // class pass_lower_subreg\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_lower_subreg (gcc::context *ctxt)\n+{\n+  return new pass_lower_subreg (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_lower_subreg2 =\n {\n- {\n-  RTL_PASS,\n-  \"subreg2\",\t                        /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_lower_subreg,             /* gate */\n-  rest_of_handle_lower_subreg2,          /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOWER_SUBREG,                      /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"subreg2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LOWER_SUBREG, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_lower_subreg2 : public rtl_opt_pass\n+{\n+public:\n+  pass_lower_subreg2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_lower_subreg2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_lower_subreg (); }\n+  unsigned int execute () { return rest_of_handle_lower_subreg2 (); }\n+\n+}; // class pass_lower_subreg2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_lower_subreg2 (gcc::context *ctxt)\n+{\n+  return new pass_lower_subreg2 (ctxt);\n+}"}, {"sha": "5649bd8443e6f386c9b974fad8708e269a894ebf", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 86, "deletions": 52, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1988,35 +1988,52 @@ lto_output (void)\n #endif\n }\n \n-struct ipa_opt_pass_d pass_ipa_lto_gimple_out =\n+namespace {\n+\n+const pass_data pass_data_ipa_lto_gimple_out =\n {\n- {\n-  IPA_PASS,\n-  \"lto_gimple_out\",\t                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_lto_out,\t\t\t        /* gate */\n-  NULL,\t\t                \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_LTO_GIMPLE_OUT,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,            \t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- },\n- NULL,\t\t                        /* generate_summary */\n- lto_output,           \t\t\t/* write_summary */\n- NULL,\t\t         \t\t/* read_summary */\n- lto_output,           \t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t                /* function_transform */\n- NULL\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"lto_gimple_out\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_IPA_LTO_GIMPLE_OUT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_ipa_lto_gimple_out : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_lto_gimple_out(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_lto_gimple_out, ctxt,\n+\t\t     NULL, /* generate_summary */\n+\t\t     lto_output, /* write_summary */\n+\t\t     NULL, /* read_summary */\n+\t\t     lto_output, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_lto_out (); }\n+\n+}; // class pass_ipa_lto_gimple_out\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_lto_gimple_out (gcc::context *ctxt)\n+{\n+  return new pass_ipa_lto_gimple_out (ctxt);\n+}\n+\n \n /* Write each node in encoded by ENCODER to OB, as well as those reachable\n    from it and required for correct representation of its semantics.\n@@ -2443,31 +2460,48 @@ produce_asm_for_decls (void)\n }\n \n \n-struct ipa_opt_pass_d pass_ipa_lto_finish_out =\n+namespace {\n+\n+const pass_data pass_data_ipa_lto_finish_out =\n {\n- {\n-  IPA_PASS,\n-  \"lto_decls_out\",\t                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_lto_out,\t\t\t        /* gate */\n-  NULL,        \t                        /* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_LTO_DECL_OUT,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,            \t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- },\n- NULL,\t\t                        /* generate_summary */\n- produce_asm_for_decls,\t\t\t/* write_summary */\n- NULL,\t\t         \t\t/* read_summary */\n- produce_asm_for_decls,\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t                /* function_transform */\n- NULL\t\t\t\t\t/* variable_transform */\n+  IPA_PASS, /* type */\n+  \"lto_decls_out\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_IPA_LTO_DECL_OUT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_ipa_lto_finish_out : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_lto_finish_out(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_lto_finish_out, ctxt,\n+\t\t     NULL, /* generate_summary */\n+\t\t     produce_asm_for_decls, /* write_summary */\n+\t\t     NULL, /* read_summary */\n+\t\t     produce_asm_for_decls, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_lto_out (); }\n+\n+}; // class pass_ipa_lto_finish_out\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_lto_finish_out (gcc::context *ctxt)\n+{\n+  return new pass_ipa_lto_finish_out (ctxt);\n+}"}, {"sha": "c941eb11672dec619845814bc719c5092d213e0b", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -784,23 +784,40 @@ rest_of_handle_mode_switching (void)\n }\n \n \n-struct rtl_opt_pass pass_mode_switching =\n+namespace {\n+\n+const pass_data pass_data_mode_switching =\n {\n- {\n-  RTL_PASS,\n-  \"mode_sw\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_mode_switching,                  /* gate */\n-  rest_of_handle_mode_switching,        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_MODE_SWITCH,                       /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"mode_sw\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_MODE_SWITCH, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n };\n+\n+class pass_mode_switching : public rtl_opt_pass\n+{\n+public:\n+  pass_mode_switching(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_mode_switching, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_mode_switching (); }\n+  unsigned int execute () { return rest_of_handle_mode_switching (); }\n+\n+}; // class pass_mode_switching\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_mode_switching (gcc::context *ctxt)\n+{\n+  return new pass_mode_switching (ctxt);\n+}"}, {"sha": "0df5fb61a2554055f6807338720523d0a0939fce", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3351,24 +3351,41 @@ rest_of_handle_sms (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_sms =\n-{\n- {\n-  RTL_PASS,\n-  \"sms\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_sms,                      /* gate */\n-  rest_of_handle_sms,                   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_SMS,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish\n-    | TODO_verify_flow\n-    | TODO_verify_rtl_sharing           /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_sms =\n+{\n+  RTL_PASS, /* type */\n+  \"sms\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_SMS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_flow\n+    | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_sms : public rtl_opt_pass\n+{\n+public:\n+  pass_sms(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_sms, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_sms (); }\n+  unsigned int execute () { return rest_of_handle_sms (); }\n+\n+}; // class pass_sms\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_sms (gcc::context *ctxt)\n+{\n+  return new pass_sms (ctxt);\n+}"}, {"sha": "e5eaddb51fc084103f5e1e5fcda15be070532b1d", "filename": "gcc/omp-low.c", "status": "modified", "additions": 109, "deletions": 54, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -6018,25 +6018,43 @@ gate_expand_omp (void)\n   return (flag_openmp != 0 && !seen_error ());\n }\n \n-struct gimple_opt_pass pass_expand_omp =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"ompexp\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_expand_omp,\t\t\t/* gate */\n-  execute_expand_omp,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_gimple_any,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                      \t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_expand_omp =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ompexp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_expand_omp : public gimple_opt_pass\n+{\n+public:\n+  pass_expand_omp(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_expand_omp, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_expand_omp (); }\n+  unsigned int execute () { return execute_expand_omp (); }\n+\n+}; // class pass_expand_omp\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_expand_omp (gcc::context *ctxt)\n+{\n+  return new pass_expand_omp (ctxt);\n+}\n \f\n /* Routines to lower OpenMP directives into OMP-GIMPLE.  */\n \n@@ -7193,25 +7211,42 @@ execute_lower_omp (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_lower_omp =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"omplower\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_lower_omp,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_gimple_any,\t\t\t/* properties_required */\n-  PROP_gimple_lomp,\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_lower_omp =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"omplower\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  PROP_gimple_lomp, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_lower_omp : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_omp(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_omp, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_lower_omp (); }\n+\n+}; // class pass_lower_omp\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_omp (gcc::context *ctxt)\n+{\n+  return new pass_lower_omp (ctxt);\n+}\n \f\n /* The following is a utility to diagnose OpenMP structured block violations.\n    It is not part of the \"omplower\" pass, as that's invoked too late.  It\n@@ -7457,24 +7492,44 @@ gate_diagnose_omp_blocks (void)\n   return flag_openmp != 0;\n }\n \n-struct gimple_opt_pass pass_diagnose_omp_blocks =\n-{\n-  {\n-    GIMPLE_PASS,\n-    \"*diagnose_omp_blocks\",\t\t/* name */\n-    OPTGROUP_NONE,                      /* optinfo_flags */\n-    gate_diagnose_omp_blocks,\t\t/* gate */\n-    diagnose_omp_structured_block_errors,\t/* execute */\n-    NULL,\t\t\t\t/* sub */\n-    NULL,\t\t\t\t/* next */\n-    0,\t\t\t\t\t/* static_pass_number */\n-    TV_NONE,\t\t\t\t/* tv_id */\n-    PROP_gimple_any,\t\t\t/* properties_required */\n-    0,\t\t\t\t\t/* properties_provided */\n-    0,\t\t\t\t\t/* properties_destroyed */\n-    0,\t\t\t\t\t/* todo_flags_start */\n-    0,\t\t\t\t\t/* todo_flags_finish */\n-  }\n+namespace {\n+\n+const pass_data pass_data_diagnose_omp_blocks =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*diagnose_omp_blocks\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_diagnose_omp_blocks : public gimple_opt_pass\n+{\n+public:\n+  pass_diagnose_omp_blocks(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_diagnose_omp_blocks, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_diagnose_omp_blocks (); }\n+  unsigned int execute () {\n+    return diagnose_omp_structured_block_errors ();\n+  }\n+\n+}; // class pass_diagnose_omp_blocks\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_diagnose_omp_blocks (gcc::context *ctxt)\n+{\n+  return new pass_diagnose_omp_blocks (ctxt);\n+}\n+\n #include \"gt-omp-low.h\""}, {"sha": "fd82c4ccb772fd4eed6718c8b37ea342abcd1e6b", "filename": "gcc/passes.c", "status": "modified", "additions": 211, "deletions": 108, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -330,26 +330,44 @@ gate_all_early_local_passes (void)\n   return (!seen_error () && !in_lto_p);\n }\n \n-struct simple_ipa_opt_pass pass_early_local_passes =\n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"early_local_cleanups\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_all_early_local_passes,\t\t/* gate */\n-  execute_all_early_local_passes,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_EARLY_LOCAL,\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_remove_functions\t \t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_early_local_passes =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"early_local_cleanups\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_EARLY_LOCAL, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_remove_functions, /* todo_flags_finish */\n };\n \n+class pass_early_local_passes : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_early_local_passes(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_early_local_passes, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_all_early_local_passes (); }\n+  unsigned int execute () { return execute_all_early_local_passes (); }\n+\n+}; // class pass_early_local_passes\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_early_local_passes (gcc::context *ctxt)\n+{\n+  return new pass_early_local_passes (ctxt);\n+}\n+\n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n \n static bool\n@@ -360,26 +378,43 @@ gate_all_early_optimizations (void)\n \t  && !seen_error ());\n }\n \n-static struct gimple_opt_pass pass_all_early_optimizations =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"early_optimizations\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_all_early_optimizations,\t\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_all_early_optimizations =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"early_optimizations\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_all_early_optimizations : public gimple_opt_pass\n+{\n+public:\n+  pass_all_early_optimizations(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_all_early_optimizations, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_all_early_optimizations (); }\n+\n+}; // class pass_all_early_optimizations\n+\n+} // anon namespace\n+\n+static gimple_opt_pass *\n+make_pass_all_early_optimizations (gcc::context *ctxt)\n+{\n+  return new pass_all_early_optimizations (ctxt);\n+}\n+\n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n \n static bool\n@@ -388,26 +423,43 @@ gate_all_optimizations (void)\n   return optimize >= 1 && !optimize_debug;\n }\n \n-static struct gimple_opt_pass pass_all_optimizations =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*all_optimizations\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_all_optimizations,\t\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_OPTIMIZE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_all_optimizations =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*all_optimizations\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_OPTIMIZE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_all_optimizations : public gimple_opt_pass\n+{\n+public:\n+  pass_all_optimizations(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_all_optimizations, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_all_optimizations (); }\n+\n+}; // class pass_all_optimizations\n+\n+} // anon namespace\n+\n+static gimple_opt_pass *\n+make_pass_all_optimizations (gcc::context *ctxt)\n+{\n+  return new pass_all_optimizations (ctxt);\n+}\n+\n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n \n static bool\n@@ -416,26 +468,43 @@ gate_all_optimizations_g (void)\n   return optimize >= 1 && optimize_debug;\n }\n \n-static struct gimple_opt_pass pass_all_optimizations_g =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*all_optimizations_g\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_all_optimizations_g,\t\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_OPTIMIZE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_all_optimizations_g =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*all_optimizations_g\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_OPTIMIZE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_all_optimizations_g : public gimple_opt_pass\n+{\n+public:\n+  pass_all_optimizations_g(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_all_optimizations_g, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_all_optimizations_g (); }\n+\n+}; // class pass_all_optimizations_g\n+\n+} // anon namespace\n+\n+static gimple_opt_pass *\n+make_pass_all_optimizations_g (gcc::context *ctxt)\n+{\n+  return new pass_all_optimizations_g (ctxt);\n+}\n+\n static bool\n gate_rest_of_compilation (void)\n {\n@@ -444,52 +513,86 @@ gate_rest_of_compilation (void)\n   return !(rtl_dump_and_exit || flag_syntax_only || seen_error ());\n }\n \n-static struct rtl_opt_pass pass_rest_of_compilation =\n-{\n- {\n-  RTL_PASS,\n-  \"*rest_of_compilation\",               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_rest_of_compilation,             /* gate */\n-  NULL,                                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REST_OF_COMPILATION,               /* tv_id */\n-  PROP_rtl,                             /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_rest_of_compilation =\n+{\n+  RTL_PASS, /* type */\n+  \"*rest_of_compilation\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_REST_OF_COMPILATION, /* tv_id */\n+  PROP_rtl, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_rest_of_compilation : public rtl_opt_pass\n+{\n+public:\n+  pass_rest_of_compilation(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rest_of_compilation, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rest_of_compilation (); }\n+\n+}; // class pass_rest_of_compilation\n+\n+} // anon namespace\n+\n+static rtl_opt_pass *\n+make_pass_rest_of_compilation (gcc::context *ctxt)\n+{\n+  return new pass_rest_of_compilation (ctxt);\n+}\n+\n static bool\n gate_postreload (void)\n {\n   return reload_completed;\n }\n \n-static struct rtl_opt_pass pass_postreload =\n-{\n- {\n-  RTL_PASS,\n-  \"*all-postreload\",                        /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_postreload,                      /* gate */\n-  NULL,                                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_POSTRELOAD,                        /* tv_id */\n-  PROP_rtl,                             /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing               /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_postreload =\n+{\n+  RTL_PASS, /* type */\n+  \"*all-postreload\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_POSTRELOAD, /* tv_id */\n+  PROP_rtl, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n \n+class pass_postreload : public rtl_opt_pass\n+{\n+public:\n+  pass_postreload(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_postreload, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_postreload (); }\n+\n+}; // class pass_postreload\n+\n+} // anon namespace\n+\n+static rtl_opt_pass *\n+make_pass_postreload (gcc::context *ctxt)\n+{\n+  return new pass_postreload (ctxt);\n+}\n+\n \n \n /* Set the static pass number of pass PASS to ID and record that"}, {"sha": "0f3ed7acda65eaed4fd437ae856b9e75a990604b", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1324,23 +1324,40 @@ rest_of_handle_gcse2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_gcse2 =\n+namespace {\n+\n+const pass_data pass_data_gcse2 =\n {\n- {\n-  RTL_PASS,\n-  \"gcse2\",                              /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_gcse2,                    /* gate */\n-  rest_of_handle_gcse2,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_GCSE_AFTER_RELOAD,                 /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing\n-  | TODO_verify_flow                    /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"gcse2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_GCSE_AFTER_RELOAD, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_rtl_sharing | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_gcse2 : public rtl_opt_pass\n+{\n+public:\n+  pass_gcse2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_gcse2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_gcse2 (); }\n+  unsigned int execute () { return rest_of_handle_gcse2 (); }\n+\n+}; // class pass_gcse2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_gcse2 (gcc::context *ctxt)\n+{\n+  return new pass_gcse2 (ctxt);\n+}"}, {"sha": "97d7e5d03325a4a7268a5cb8ea3b8d6710a2d973", "filename": "gcc/postreload.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2339,23 +2339,40 @@ rest_of_handle_postreload (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_postreload_cse =\n+namespace {\n+\n+const pass_data pass_data_postreload_cse =\n {\n- {\n-  RTL_PASS,\n-  \"postreload\",                         /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_postreload,               /* gate */\n-  rest_of_handle_postreload,            /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_RELOAD_CSE_REGS,                   /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"postreload\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_RELOAD_CSE_REGS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n };\n+\n+class pass_postreload_cse : public rtl_opt_pass\n+{\n+public:\n+  pass_postreload_cse(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_postreload_cse, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_postreload (); }\n+  unsigned int execute () { return rest_of_handle_postreload (); }\n+\n+}; // class pass_postreload_cse\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_postreload_cse (gcc::context *ctxt)\n+{\n+  return new pass_postreload_cse (ctxt);\n+}"}, {"sha": "ec7933826580644cf7d67784c6e115a99d257d1b", "filename": "gcc/predict.c", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2900,46 +2900,82 @@ predictor_name (enum br_predictor predictor)\n   return predictor_info[predictor].name;\n }\n \n-struct gimple_opt_pass pass_profile =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"profile_estimate\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_estimate_probability,\t\t/* gate */\n-  tree_estimate_probability_driver,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_BRANCH_PROB,\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_profile =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"profile_estimate\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_BRANCH_PROB, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_strip_predict_hints =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*strip_predict_hints\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  strip_predict_hints,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_BRANCH_PROB,\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+class pass_profile : public gimple_opt_pass\n+{\n+public:\n+  pass_profile(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_profile, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_estimate_probability (); }\n+  unsigned int execute () { return tree_estimate_probability_driver (); }\n+\n+}; // class pass_profile\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_profile (gcc::context *ctxt)\n+{\n+  return new pass_profile (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_strip_predict_hints =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*strip_predict_hints\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_BRANCH_PROB, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n \n+class pass_strip_predict_hints : public gimple_opt_pass\n+{\n+public:\n+  pass_strip_predict_hints(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_strip_predict_hints, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_strip_predict_hints (ctxt_); }\n+  unsigned int execute () { return strip_predict_hints (); }\n+\n+}; // class pass_strip_predict_hints\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_strip_predict_hints (gcc::context *ctxt)\n+{\n+  return new pass_strip_predict_hints (ctxt);\n+}\n+\n /* Rebuild function frequencies.  Passes are in general expected to\n    maintain profile by hand, however in some cases this is not possible:\n    for example when inlining several functions with loops freuqencies might run"}, {"sha": "352fbac896dc39afc4cbf4e40036e843a4867663", "filename": "gcc/recog.c", "status": "modified", "additions": 216, "deletions": 109, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3778,54 +3778,88 @@ rest_of_handle_peephole2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_peephole2 =\n-{\n- {\n-  RTL_PASS,\n-  \"peephole2\",                          /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_peephole2,                /* gate */\n-  rest_of_handle_peephole2,             /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_PEEPHOLE2,                         /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  0                                    /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_peephole2 =\n+{\n+  RTL_PASS, /* type */\n+  \"peephole2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_PEEPHOLE2, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n };\n \n+class pass_peephole2 : public rtl_opt_pass\n+{\n+public:\n+  pass_peephole2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_peephole2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_peephole2 (); }\n+  unsigned int execute () { return rest_of_handle_peephole2 (); }\n+\n+}; // class pass_peephole2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_peephole2 (gcc::context *ctxt)\n+{\n+  return new pass_peephole2 (ctxt);\n+}\n+\n static unsigned int\n rest_of_handle_split_all_insns (void)\n {\n   split_all_insns ();\n   return 0;\n }\n \n-struct rtl_opt_pass pass_split_all_insns =\n-{\n- {\n-  RTL_PASS,\n-  \"split1\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_split_all_insns,       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_split_all_insns =\n+{\n+  RTL_PASS, /* type */\n+  \"split1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_split_all_insns : public rtl_opt_pass\n+{\n+public:\n+  pass_split_all_insns(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_split_all_insns, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_split_all_insns (); }\n+\n+}; // class pass_split_all_insns\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_split_all_insns (gcc::context *ctxt)\n+{\n+  return new pass_split_all_insns (ctxt);\n+}\n+\n static unsigned int\n rest_of_handle_split_after_reload (void)\n {\n@@ -3837,26 +3871,43 @@ rest_of_handle_split_after_reload (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_split_after_reload =\n-{\n- {\n-  RTL_PASS,\n-  \"split2\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_split_after_reload,    /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_split_after_reload =\n+{\n+  RTL_PASS, /* type */\n+  \"split2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_split_after_reload : public rtl_opt_pass\n+{\n+public:\n+  pass_split_after_reload(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_split_after_reload, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_split_after_reload (); }\n+\n+}; // class pass_split_after_reload\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_split_after_reload (gcc::context *ctxt)\n+{\n+  return new pass_split_after_reload (ctxt);\n+}\n+\n static bool\n gate_handle_split_before_regstack (void)\n {\n@@ -3882,26 +3933,46 @@ rest_of_handle_split_before_regstack (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_split_before_regstack =\n-{\n- {\n-  RTL_PASS,\n-  \"split3\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_split_before_regstack,    /* gate */\n-  rest_of_handle_split_before_regstack, /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_split_before_regstack =\n+{\n+  RTL_PASS, /* type */\n+  \"split3\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_split_before_regstack : public rtl_opt_pass\n+{\n+public:\n+  pass_split_before_regstack(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_split_before_regstack, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_split_before_regstack (); }\n+  unsigned int execute () {\n+    return rest_of_handle_split_before_regstack ();\n+  }\n+\n+}; // class pass_split_before_regstack\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_split_before_regstack (gcc::context *ctxt)\n+{\n+  return new pass_split_before_regstack (ctxt);\n+}\n+\n static bool\n gate_handle_split_before_sched2 (void)\n {\n@@ -3921,26 +3992,44 @@ rest_of_handle_split_before_sched2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_split_before_sched2 =\n-{\n- {\n-  RTL_PASS,\n-  \"split4\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_split_before_sched2,      /* gate */\n-  rest_of_handle_split_before_sched2,   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_split_before_sched2 =\n+{\n+  RTL_PASS, /* type */\n+  \"split4\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n };\n \n+class pass_split_before_sched2 : public rtl_opt_pass\n+{\n+public:\n+  pass_split_before_sched2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_split_before_sched2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_split_before_sched2 (); }\n+  unsigned int execute () { return rest_of_handle_split_before_sched2 (); }\n+\n+}; // class pass_split_before_sched2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_split_before_sched2 (gcc::context *ctxt)\n+{\n+  return new pass_split_before_sched2 (ctxt);\n+}\n+\n /* The placement of the splitting that we do for shorten_branches\n    depends on whether regstack is used by the target or not.  */\n static bool\n@@ -3953,22 +4042,40 @@ gate_do_final_split (void)\n #endif\n }\n \n-struct rtl_opt_pass pass_split_for_shorten_branches =\n-{\n- {\n-  RTL_PASS,\n-  \"split5\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_do_final_split,                  /* gate */\n-  split_all_insns_noflow,               /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing               /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_split_for_shorten_branches =\n+{\n+  RTL_PASS, /* type */\n+  \"split5\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_rtl_sharing, /* todo_flags_finish */\n };\n+\n+class pass_split_for_shorten_branches : public rtl_opt_pass\n+{\n+public:\n+  pass_split_for_shorten_branches(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_split_for_shorten_branches, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_do_final_split (); }\n+  unsigned int execute () { return split_all_insns_noflow (); }\n+\n+}; // class pass_split_for_shorten_branches\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_split_for_shorten_branches (gcc::context *ctxt)\n+{\n+  return new pass_split_for_shorten_branches (ctxt);\n+}"}, {"sha": "4dab6e9199592ce6071740d692a00eaab5fd41d7", "filename": "gcc/ree.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -940,23 +940,40 @@ gate_handle_ree (void)\n   return (optimize > 0 && flag_ree);\n }\n \n-struct rtl_opt_pass pass_ree =\n+namespace {\n+\n+const pass_data pass_data_ree =\n {\n- {\n-  RTL_PASS,\n-  \"ree\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_ree,                      /* gate */\n-  rest_of_handle_ree,                   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REE,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish\n-    | TODO_verify_rtl_sharing,          /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"ree\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_REE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_ree : public rtl_opt_pass\n+{\n+public:\n+  pass_ree(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_ree, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_ree (); }\n+  unsigned int execute () { return rest_of_handle_ree (); }\n+\n+}; // class pass_ree\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_ree (gcc::context *ctxt)\n+{\n+  return new pass_ree (ctxt);\n+}"}, {"sha": "b3574e66d1736380209c72891c8efbbb66d45dc5", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3292,26 +3292,43 @@ gate_handle_stack_regs (void)\n #endif\n }\n \n-struct rtl_opt_pass pass_stack_regs =\n+namespace {\n+\n+const pass_data pass_data_stack_regs =\n {\n- {\n-  RTL_PASS,\n-  \"*stack_regs\",                        /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_stack_regs,               /* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REG_STACK,                         /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"*stack_regs\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_REG_STACK, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_stack_regs : public rtl_opt_pass\n+{\n+public:\n+  pass_stack_regs(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_stack_regs, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_stack_regs (); }\n+\n+}; // class pass_stack_regs\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_stack_regs (gcc::context *ctxt)\n+{\n+  return new pass_stack_regs (ctxt);\n+}\n+\n /* Convert register usage from flat register file usage to a stack\n    register file.  */\n static unsigned int\n@@ -3324,22 +3341,39 @@ rest_of_handle_stack_regs (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_stack_regs_run =\n+namespace {\n+\n+const pass_data pass_data_stack_regs_run =\n {\n- {\n-  RTL_PASS,\n-  \"stack\",                              /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_stack_regs,            /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REG_STACK,                         /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"stack\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_REG_STACK, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_stack_regs_run : public rtl_opt_pass\n+{\n+public:\n+  pass_stack_regs_run(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_stack_regs_run, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_stack_regs (); }\n+\n+}; // class pass_stack_regs_run\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_stack_regs_run (gcc::context *ctxt)\n+{\n+  return new pass_stack_regs_run (ctxt);\n+}"}, {"sha": "19f3349517075dc3df4fbe3c8477515789088ef5", "filename": "gcc/regcprop.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1236,23 +1236,40 @@ gate_handle_cprop (void)\n }\n \n \n-struct rtl_opt_pass pass_cprop_hardreg =\n+namespace {\n+\n+const pass_data pass_data_cprop_hardreg =\n {\n- {\n-  RTL_PASS,\n-  \"cprop_hardreg\",                      /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_cprop,                    /* gate */\n-  copyprop_hardreg_forward,             /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CPROP_REGISTERS,                   /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish\n-  | TODO_verify_rtl_sharing\t\t/* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"cprop_hardreg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CPROP_REGISTERS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_cprop_hardreg : public rtl_opt_pass\n+{\n+public:\n+  pass_cprop_hardreg(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_cprop_hardreg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_cprop (); }\n+  unsigned int execute () { return copyprop_hardreg_forward (); }\n+\n+}; // class pass_cprop_hardreg\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_cprop_hardreg (gcc::context *ctxt)\n+{\n+  return new pass_cprop_hardreg (ctxt);\n+}"}, {"sha": "1fb6b5d226b3f75bfadc1ef33fc762666a69ea1d", "filename": "gcc/reginfo.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -965,26 +965,43 @@ reginfo_init (void)\n   return 1;\n }\n \n-struct rtl_opt_pass pass_reginfo_init =\n+namespace {\n+\n+const pass_data pass_data_reginfo_init =\n {\n- {\n-  RTL_PASS,\n-  \"reginfo\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  reginfo_init,                         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"reginfo\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_reginfo_init : public rtl_opt_pass\n+{\n+public:\n+  pass_reginfo_init(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_reginfo_init, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return reginfo_init (); }\n+\n+}; // class pass_reginfo_init\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_reginfo_init (gcc::context *ctxt)\n+{\n+  return new pass_reginfo_init (ctxt);\n+}\n+\n \f\n \n /* Set up preferred, alternate, and allocno classes for REGNO as"}, {"sha": "da7fac9844eb457ab7830685a21a3a6656baa1ee", "filename": "gcc/regmove.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1361,22 +1361,40 @@ gate_handle_regmove (void)\n }\n \n \n-struct rtl_opt_pass pass_regmove =\n+namespace {\n+\n+const pass_data pass_data_regmove =\n {\n- {\n-  RTL_PASS,\n-  \"regmove\",                            /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_regmove,                  /* gate */\n-  regmove_optimize,\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REGMOVE,                           /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"regmove\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_REGMOVE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_regmove : public rtl_opt_pass\n+{\n+public:\n+  pass_regmove(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_regmove, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_regmove (); }\n+  unsigned int execute () { return regmove_optimize (); }\n+\n+}; // class pass_regmove\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_regmove (gcc::context *ctxt)\n+{\n+  return new pass_regmove (ctxt);\n+}"}, {"sha": "6830bd8389a0a2b69223e52fd5ad80b65f89d0b8", "filename": "gcc/regrename.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1842,23 +1842,40 @@ gate_handle_regrename (void)\n   return (optimize > 0 && (flag_rename_registers));\n }\n \n-struct rtl_opt_pass pass_regrename =\n+namespace {\n+\n+const pass_data pass_data_regrename =\n {\n- {\n-  RTL_PASS,\n-  \"rnreg\",                              /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_regrename,                /* gate */\n-  regrename_optimize,                   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_RENAME_REGISTERS,                  /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"rnreg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_RENAME_REGISTERS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing | 0 ), /* todo_flags_finish */\n };\n+\n+class pass_regrename : public rtl_opt_pass\n+{\n+public:\n+  pass_regrename(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_regrename, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_regrename (); }\n+  unsigned int execute () { return regrename_optimize (); }\n+\n+}; // class pass_regrename\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_regrename (gcc::context *ctxt)\n+{\n+  return new pass_regrename (ctxt);\n+}"}, {"sha": "78804088a43f34f1e486af1de8755fc19a0965ee", "filename": "gcc/reorg.c", "status": "modified", "additions": 70, "deletions": 34, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3852,26 +3852,44 @@ rest_of_handle_delay_slots (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_delay_slots =\n+namespace {\n+\n+const pass_data pass_data_delay_slots =\n {\n- {\n-  RTL_PASS,\n-  \"dbr\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_delay_slots,              /* gate */\n-  rest_of_handle_delay_slots,           /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DBR_SCHED,                         /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"dbr\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_DBR_SCHED, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_delay_slots : public rtl_opt_pass\n+{\n+public:\n+  pass_delay_slots(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_delay_slots, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_delay_slots (); }\n+  unsigned int execute () { return rest_of_handle_delay_slots (); }\n+\n+}; // class pass_delay_slots\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_delay_slots (gcc::context *ctxt)\n+{\n+  return new pass_delay_slots (ctxt);\n+}\n+\n /* Machine dependent reorg pass.  */\n static bool\n gate_handle_machine_reorg (void)\n@@ -3887,22 +3905,40 @@ rest_of_handle_machine_reorg (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_machine_reorg =\n+namespace {\n+\n+const pass_data pass_data_machine_reorg =\n {\n- {\n-  RTL_PASS,\n-  \"mach\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_machine_reorg,            /* gate */\n-  rest_of_handle_machine_reorg,         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_MACH_DEP,                          /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"mach\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_MACH_DEP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_machine_reorg : public rtl_opt_pass\n+{\n+public:\n+  pass_machine_reorg(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_machine_reorg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_machine_reorg (); }\n+  unsigned int execute () { return rest_of_handle_machine_reorg (); }\n+\n+}; // class pass_machine_reorg\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_machine_reorg (gcc::context *ctxt)\n+{\n+  return new pass_machine_reorg (ctxt);\n+}"}, {"sha": "e1a2dce16a2b337b5de8462357dfe136a9e22459", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3617,44 +3617,80 @@ rest_of_handle_sched2 (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_sched =\n-{\n- {\n-  RTL_PASS,\n-  \"sched1\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_sched,                    /* gate */\n-  rest_of_handle_sched,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_SCHED,                             /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_sched =\n+{\n+  RTL_PASS, /* type */\n+  \"sched1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_SCHED, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n \n-struct rtl_opt_pass pass_sched2 =\n-{\n- {\n-  RTL_PASS,\n-  \"sched2\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_sched2,                   /* gate */\n-  rest_of_handle_sched2,                /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_SCHED2,                            /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+class pass_sched : public rtl_opt_pass\n+{\n+public:\n+  pass_sched(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_sched, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_sched (); }\n+  unsigned int execute () { return rest_of_handle_sched (); }\n+\n+}; // class pass_sched\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_sched (gcc::context *ctxt)\n+{\n+  return new pass_sched (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_sched2 =\n+{\n+  RTL_PASS, /* type */\n+  \"sched2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_SCHED2, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_sched2 : public rtl_opt_pass\n+{\n+public:\n+  pass_sched2(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_sched2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_sched2 (); }\n+  unsigned int execute () { return rest_of_handle_sched2 (); }\n+\n+}; // class pass_sched2\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_sched2 (gcc::context *ctxt)\n+{\n+  return new pass_sched2 (ctxt);\n+}"}, {"sha": "737a07f57274c15a6738c3702f111f0fb4556932", "filename": "gcc/stack-ptr-mod.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -90,22 +90,39 @@ rest_of_handle_stack_ptr_mod (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_stack_ptr_mod =\n+namespace {\n+\n+const pass_data pass_data_stack_ptr_mod =\n {\n- {\n-  RTL_PASS,\n-  \"*stack_ptr_mod\",                     /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,                                 /* gate */\n-  rest_of_handle_stack_ptr_mod,         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"*stack_ptr_mod\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_stack_ptr_mod : public rtl_opt_pass\n+{\n+public:\n+  pass_stack_ptr_mod(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_stack_ptr_mod, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rest_of_handle_stack_ptr_mod (); }\n+\n+}; // class pass_stack_ptr_mod\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_stack_ptr_mod (gcc::context *ctxt)\n+{\n+  return new pass_stack_ptr_mod (ctxt);\n+}"}, {"sha": "e0b58477d4cd82254da687b1d13a4b0f91d88261", "filename": "gcc/store-motion.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1235,23 +1235,41 @@ execute_rtl_store_motion (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_store_motion =\n+namespace {\n+\n+const pass_data pass_data_rtl_store_motion =\n {\n- {\n-  RTL_PASS,\n-  \"store_motion\",                       /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_rtl_store_motion,                /* gate */\n-  execute_rtl_store_motion,\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LSM,                               /* tv_id */\n-  PROP_cfglayout,                       /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_verify_flow                      /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"store_motion\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LSM, /* tv_id */\n+  PROP_cfglayout, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_rtl_store_motion : public rtl_opt_pass\n+{\n+public:\n+  pass_rtl_store_motion(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rtl_store_motion, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_rtl_store_motion (); }\n+  unsigned int execute () { return execute_rtl_store_motion (); }\n+\n+}; // class pass_rtl_store_motion\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rtl_store_motion (gcc::context *ctxt)\n+{\n+  return new pass_rtl_store_motion (ctxt);\n+}"}, {"sha": "757c9f274248416c962c79c535e7e2010b3341d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1,3 +1,26 @@\n+2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by refactor_passes.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 03fe39476a4c4ea450b49e087cfa817b5f92021e\n+\n+\t* gcc.dg/plugin/one_time_plugin.c (one_pass): Convert from a global\n+\tstruct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_one_pass): ...new pass_data instance and...\n+\t(make_one_pass): ...new function.\n+\t* gcc.dg/plugin/selfassign.c (pass_warn_self_assign): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_warn_self_assign): ...new pass_data instance and...\n+\t(make_pass_warn_self_assign): ...new function.\n+\t* g++.dg/plugin/dumb_plugin.c (pass_dumb_plugin_example): Convert from\n+\ta global struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_dumb_plugin_example): ...new pass_data instance and...\n+\t(make_pass_dumb_plugin_example): ...new function.\n+\t* g++.dg/plugin/selfassign.c (pass_warn_self_assign): Convert from a\n+\tglobal struct to a subclass of gimple_opt_pass along with...\n+\t(pass_data_warn_self_assign): ...new pass_data instance and...\n+\t(make_pass_warn_self_assign): ...new function.\n+\n 2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n \n \t* g++.dg/plugin/dumb_plugin.c (plugin_init): Rework how the pass"}, {"sha": "e197d667251f51af14cb1bfc5cd3c57318af8d03", "filename": "gcc/testsuite/g++.dg/plugin/dumb_plugin.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -58,26 +58,44 @@ gate_dumb_plugin_example (void)\n   return true;\n }\n \n-static struct gimple_opt_pass pass_dumb_plugin_example =\n+namespace {\n+\n+const pass_data pass_data_dumb_plugin_example =\n {\n-  {\n-    GIMPLE_PASS,\n-    \"dumb_plugin_example\",                /* name */\n-    OPTGROUP_NONE,                        /* optinfo_flags */\n-    gate_dumb_plugin_example,             /* gate */\n-    execute_dumb_plugin_example,          /* execute */\n-    NULL,                                 /* sub */\n-    NULL,                                 /* next */\n-    0,                                    /* static_pass_number */\n-    TV_NONE,                              /* tv_id */\n-    PROP_cfg,                             /* properties_required */\n-    0,                                    /* properties_provided */\n-    0,                                    /* properties_destroyed */\n-    0,                                    /* todo_flags_start */\n-    0\t\t\t\t\t  /* todo_flags_finish */\n-  }\n+  GIMPLE_PASS, /* type */\n+  \"dumb_plugin_example\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_dumb_plugin_example : public gimple_opt_pass\n+{\n+public:\n+  pass_dumb_plugin_example(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_dumb_plugin_example, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_dumb_plugin_example (); }\n+  unsigned int execute () { return execute_dumb_plugin_example (); }\n+\n+}; // class pass_dumb_plugin_example\n+\n+} // anon namespace\n+\n+static gimple_opt_pass *\n+make_pass_dumb_plugin_example (gcc::context *ctxt)\n+{\n+  return new pass_dumb_plugin_example (ctxt);\n+}\n+\n /* Initialization function that GCC calls. This plugin takes an argument\n    that specifies the name of the reference pass and an instance number,\n    both of which determine where the plugin pass should be inserted.  */"}, {"sha": "7235089c7d31a7f53b3252fd0ba19d5eb21f7d8b", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -264,26 +264,44 @@ gate_warn_self_assign (void)\n   return true;\n }\n \n-static struct gimple_opt_pass pass_warn_self_assign =\n+namespace {\n+\n+const pass_data pass_data_warn_self_assign =\n {\n-  {\n-    GIMPLE_PASS,\n-    \"warn_self_assign\",                   /* name */\n-    OPTGROUP_NONE,                        /* optinfo_flags */\n-    gate_warn_self_assign,                /* gate */\n-    execute_warn_self_assign,             /* execute */\n-    NULL,                                 /* sub */\n-    NULL,                                 /* next */\n-    0,                                    /* static_pass_number */\n-    TV_NONE,                              /* tv_id */\n-    PROP_ssa,                             /* properties_required */\n-    0,                                    /* properties_provided */\n-    0,                                    /* properties_destroyed */\n-    0,                                    /* todo_flags_start */\n-    0\t\t\t\t\t  /* todo_flags_finish */\n-  }\n+  GIMPLE_PASS, /* type */\n+  \"warn_self_assign\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_warn_self_assign : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_self_assign(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_warn_self_assign, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_warn_self_assign (); }\n+  unsigned int execute () { return execute_warn_self_assign (); }\n+\n+}; // class pass_warn_self_assign\n+\n+} // anon namespace\n+\n+static gimple_opt_pass *\n+make_pass_warn_self_assign (gcc::context *ctxt)\n+{\n+  return new pass_warn_self_assign (ctxt);\n+}\n+\n /* The initialization routine exposed to and called by GCC. The spec of this\n    function is defined in gcc/gcc-plugin.h.\n "}, {"sha": "2d996da1235f131cbcf00b14c376102c00b628d0", "filename": "gcc/testsuite/gcc.dg/plugin/one_time_plugin.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -28,26 +28,44 @@ static unsigned int one_pass_exec (void)\n  return 0;\n }\n \n-struct gimple_opt_pass one_pass = \n+namespace {\n+\n+const pass_data pass_data_one_pass =\n {\n-  {\n-  GIMPLE_PASS,\n-  \"cfg\",                           /* name */\n-  OPTGROUP_NONE,                         /* optinfo_flags */\n-  one_pass_gate,                         /* gate */\n-  one_pass_exec,       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  PROP_gimple_any,                      /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n-  }\n+  GIMPLE_PASS, /* type */\n+  \"cfg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class one_pass : public gimple_opt_pass\n+{\n+public:\n+  one_pass(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_one_pass, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return one_pass_gate (); }\n+  unsigned int execute () { return one_pass_exec (); }\n+\n+}; // class one_pass\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_one_pass (gcc::context *ctxt)\n+{\n+  return new one_pass (ctxt);\n+}\n+\n \n int plugin_init (struct plugin_name_args *plugin_info,\n                  struct plugin_gcc_version *version)"}, {"sha": "7235089c7d31a7f53b3252fd0ba19d5eb21f7d8b", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -264,26 +264,44 @@ gate_warn_self_assign (void)\n   return true;\n }\n \n-static struct gimple_opt_pass pass_warn_self_assign =\n+namespace {\n+\n+const pass_data pass_data_warn_self_assign =\n {\n-  {\n-    GIMPLE_PASS,\n-    \"warn_self_assign\",                   /* name */\n-    OPTGROUP_NONE,                        /* optinfo_flags */\n-    gate_warn_self_assign,                /* gate */\n-    execute_warn_self_assign,             /* execute */\n-    NULL,                                 /* sub */\n-    NULL,                                 /* next */\n-    0,                                    /* static_pass_number */\n-    TV_NONE,                              /* tv_id */\n-    PROP_ssa,                             /* properties_required */\n-    0,                                    /* properties_provided */\n-    0,                                    /* properties_destroyed */\n-    0,                                    /* todo_flags_start */\n-    0\t\t\t\t\t  /* todo_flags_finish */\n-  }\n+  GIMPLE_PASS, /* type */\n+  \"warn_self_assign\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_warn_self_assign : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_self_assign(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_warn_self_assign, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_warn_self_assign (); }\n+  unsigned int execute () { return execute_warn_self_assign (); }\n+\n+}; // class pass_warn_self_assign\n+\n+} // anon namespace\n+\n+static gimple_opt_pass *\n+make_pass_warn_self_assign (gcc::context *ctxt)\n+{\n+  return new pass_warn_self_assign (ctxt);\n+}\n+\n /* The initialization routine exposed to and called by GCC. The spec of this\n    function is defined in gcc/gcc-plugin.h.\n "}, {"sha": "0139669aa16efdab4e05b640c889216ad562614e", "filename": "gcc/tracer.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -397,23 +397,40 @@ gate_tracer (void)\n   return (optimize > 0 && flag_tracer && flag_reorder_blocks);\n }\n \n-struct gimple_opt_pass pass_tracer =\n+namespace {\n+\n+const pass_data pass_data_tracer =\n {\n- {\n-  GIMPLE_PASS,\n-  \"tracer\",                             /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tracer,                          /* gate */\n-  tracer,                               /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_TRACER,                            /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_update_ssa\n-    | TODO_verify_ssa                   /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"tracer\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TRACER, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_tracer : public gimple_opt_pass\n+{\n+public:\n+  pass_tracer(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tracer, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tracer (); }\n+  unsigned int execute () { return tracer (); }\n+\n+}; // class pass_tracer\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tracer (gcc::context *ctxt)\n+{\n+  return new pass_tracer (ctxt);\n+}"}, {"sha": "220ded277b53e986ef5484ca6693f0d533f3865f", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 249, "deletions": 128, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -801,25 +801,43 @@ diagnose_tm_blocks (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_diagnose_tm_blocks =\n-{\n-  {\n-    GIMPLE_PASS,\n-    \"*diagnose_tm_blocks\",\t\t/* name */\n-    OPTGROUP_NONE,                      /* optinfo_flags */\n-    gate_tm,\t\t\t\t/* gate */\n-    diagnose_tm_blocks,\t\t\t/* execute */\n-    NULL,\t\t\t\t/* sub */\n-    NULL,\t\t\t\t/* next */\n-    0,\t\t\t\t\t/* static_pass_number */\n-    TV_TRANS_MEM,\t\t\t/* tv_id */\n-    PROP_gimple_any,\t\t\t/* properties_required */\n-    0,\t\t\t\t\t/* properties_provided */\n-    0,\t\t\t\t\t/* properties_destroyed */\n-    0,\t\t\t\t\t/* todo_flags_start */\n-    0,\t\t\t\t\t/* todo_flags_finish */\n-  }\n+namespace {\n+\n+const pass_data pass_data_diagnose_tm_blocks =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*diagnose_tm_blocks\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TRANS_MEM, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_diagnose_tm_blocks : public gimple_opt_pass\n+{\n+public:\n+  pass_diagnose_tm_blocks(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_diagnose_tm_blocks, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tm (); }\n+  unsigned int execute () { return diagnose_tm_blocks (); }\n+\n+}; // class pass_diagnose_tm_blocks\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_diagnose_tm_blocks (gcc::context *ctxt)\n+{\n+  return new pass_diagnose_tm_blocks (ctxt);\n+}\n \f\n /* Instead of instrumenting thread private memory, we save the\n    addresses in a log which we later use to save/restore the addresses\n@@ -1706,25 +1724,43 @@ execute_lower_tm (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_lower_tm =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"tmlower\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tm,\t\t\t\t/* gate */\n-  execute_lower_tm,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TRANS_MEM,\t\t\t\t/* tv_id */\n-  PROP_gimple_lcf,\t\t\t/* properties_required */\n-  0,\t\t\t                /* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,             \t\t        /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_lower_tm =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"tmlower\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TRANS_MEM, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_lower_tm : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_tm(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_tm, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tm (); }\n+  unsigned int execute () { return execute_lower_tm (); }\n+\n+}; // class pass_lower_tm\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_tm (gcc::context *ctxt)\n+{\n+  return new pass_lower_tm (ctxt);\n+}\n \f\n /* Collect region information for each transaction.  */\n \n@@ -1968,25 +2004,42 @@ gate_tm_init (void)\n   return true;\n }\n \n-struct gimple_opt_pass pass_tm_init =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*tminit\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tm_init,\t\t\t\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TRANS_MEM,\t\t\t\t/* tv_id */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required */\n-  0,\t\t\t                /* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tm_init =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*tminit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_TRANS_MEM, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_tm_init : public gimple_opt_pass\n+{\n+public:\n+  pass_tm_init(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tm_init, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tm_init (); }\n+\n+}; // class pass_tm_init\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tm_init (gcc::context *ctxt)\n+{\n+  return new pass_tm_init (ctxt);\n+}\n \f\n /* Add FLAGS to the GIMPLE_TRANSACTION subcode for the transaction region\n    represented by STATE.  */\n@@ -2927,26 +2980,42 @@ execute_tm_mark (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_tm_mark =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"tmmark\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_tm_mark,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TRANS_MEM,\t\t\t\t/* tv_id */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required */\n-  0,\t\t\t                /* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_ssa, \t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tm_mark =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"tmmark\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TRANS_MEM, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_tm_mark : public gimple_opt_pass\n+{\n+public:\n+  pass_tm_mark(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tm_mark, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_tm_mark (); }\n+\n+}; // class pass_tm_mark\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tm_mark (gcc::context *ctxt)\n+{\n+  return new pass_tm_mark (ctxt);\n+}\n \f\n \n /* Create an abnormal edge from STMT at iter, splitting the block\n@@ -3094,26 +3163,42 @@ execute_tm_edges (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_tm_edges =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"tmedge\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_tm_edges,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TRANS_MEM,\t\t\t\t/* tv_id */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required */\n-  0,\t\t\t                /* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_ssa,\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tm_edges =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"tmedge\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TRANS_MEM, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_tm_edges : public gimple_opt_pass\n+{\n+public:\n+  pass_tm_edges(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tm_edges, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_tm_edges (); }\n+\n+}; // class pass_tm_edges\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tm_edges (gcc::context *ctxt)\n+{\n+  return new pass_tm_edges (ctxt);\n+}\n \f\n /* Helper function for expand_regions.  Expand REGION and recurse to\n    the inner region.  Call CALLBACK on each region.  CALLBACK returns\n@@ -3818,26 +3903,44 @@ gate_tm_memopt (void)\n   return flag_tm && optimize > 0;\n }\n \n-struct gimple_opt_pass pass_tm_memopt =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"tmmemopt\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tm_memopt,\t\t\t/* gate */\n-  execute_tm_memopt,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TRANS_MEM,\t\t\t\t/* tv_id */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required */\n-  0,\t\t\t                /* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,            \t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tm_memopt =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"tmmemopt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TRANS_MEM, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_tm_memopt : public gimple_opt_pass\n+{\n+public:\n+  pass_tm_memopt(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tm_memopt, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tm_memopt (); }\n+  unsigned int execute () { return execute_tm_memopt (); }\n+\n+}; // class pass_tm_memopt\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tm_memopt (gcc::context *ctxt)\n+{\n+  return new pass_tm_memopt (ctxt);\n+}\n+\n \f\n /* Interprocedual analysis for the creation of transactional clones.\n    The aim of this pass is to find which functions are referenced in\n@@ -5435,24 +5538,42 @@ ipa_tm_execute (void)\n   return 0;\n }\n \n-struct simple_ipa_opt_pass pass_ipa_tm =\n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"tmipa\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tm,\t\t\t\t/* gate */\n-  ipa_tm_execute,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TRANS_MEM,\t\t\t\t/* tv_id */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required */\n-  0,\t\t\t                /* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n- },\n+namespace {\n+\n+const pass_data pass_data_ipa_tm =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"tmipa\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TRANS_MEM, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_ipa_tm : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_tm(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_tm, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tm (); }\n+  unsigned int execute () { return ipa_tm_execute (); }\n+\n+}; // class pass_ipa_tm\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_tm (gcc::context *ctxt)\n+{\n+  return new pass_ipa_tm (ctxt);\n+}\n+\n #include \"gt-trans-mem.h\""}, {"sha": "8edcad93b8b34a210e768ae4159bf144917adfe5", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -913,22 +913,40 @@ gate_call_cdce (void)\n   return flag_tree_builtin_call_dce != 0 && optimize_function_for_speed_p (cfun);\n }\n \n-struct gimple_opt_pass pass_call_cdce =\n+namespace {\n+\n+const pass_data pass_data_call_cdce =\n {\n- {\n-  GIMPLE_PASS,\n-  \"cdce\",                               /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_call_cdce,                       /* gate */\n-  tree_call_cdce,                       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_TREE_CALL_CDCE,                    /* tv_id */\n-  PROP_cfg | PROP_ssa,                  /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_ssa                       /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"cdce\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_CALL_CDCE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_call_cdce : public gimple_opt_pass\n+{\n+public:\n+  pass_call_cdce(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_call_cdce, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_call_cdce (); }\n+  unsigned int execute () { return tree_call_cdce (); }\n+\n+}; // class pass_call_cdce\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_call_cdce (gcc::context *ctxt)\n+{\n+  return new pass_call_cdce (ctxt);\n+}"}, {"sha": "af8685c7a753f0573a68bce4ea98d92be60eed04", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 177, "deletions": 90, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -253,26 +253,43 @@ execute_build_cfg (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_build_cfg =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"cfg\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_build_cfg,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_CFG,\t\t\t\t/* tv_id */\n-  PROP_gimple_leh, \t\t\t/* properties_required */\n-  PROP_cfg | PROP_loops,\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_stmts\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_build_cfg =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"cfg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_CFG, /* tv_id */\n+  PROP_gimple_leh, /* properties_required */\n+  ( PROP_cfg | PROP_loops ), /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_stmts, /* todo_flags_finish */\n };\n \n+class pass_build_cfg : public gimple_opt_pass\n+{\n+public:\n+  pass_build_cfg(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_build_cfg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_build_cfg (); }\n+\n+}; // class pass_build_cfg\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_build_cfg (gcc::context *ctxt)\n+{\n+  return new pass_build_cfg (ctxt);\n+}\n+\n \n /* Return true if T is a computed goto.  */\n \n@@ -7890,26 +7907,43 @@ split_critical_edges (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_split_crit_edges =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"crited\",                          /* name */\n-  OPTGROUP_NONE,                 /* optinfo_flags */\n-  NULL,                          /* gate */\n-  split_critical_edges,          /* execute */\n-  NULL,                          /* sub */\n-  NULL,                          /* next */\n-  0,                             /* static_pass_number */\n-  TV_TREE_SPLIT_EDGES,           /* tv_id */\n-  PROP_cfg,                      /* properties required */\n-  PROP_no_crit_edges,            /* properties_provided */\n-  0,                             /* properties_destroyed */\n-  0,                             /* todo_flags_start */\n-  TODO_verify_flow               /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_split_crit_edges =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"crited\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SPLIT_EDGES, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  PROP_no_crit_edges, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n };\n \n+class pass_split_crit_edges : public gimple_opt_pass\n+{\n+public:\n+  pass_split_crit_edges(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_split_crit_edges, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return split_critical_edges (); }\n+\n+}; // class pass_split_crit_edges\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_split_crit_edges (gcc::context *ctxt)\n+{\n+  return new pass_split_crit_edges (ctxt);\n+}\n+\n \n /* Build a ternary operation and gimplify it.  Emit code before GSI.\n    Return the gimple_val holding the result.  */\n@@ -8044,26 +8078,43 @@ extract_true_false_edges_from_block (basic_block b,\n     }\n }\n \n-struct gimple_opt_pass pass_warn_function_return =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*warn_function_return\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_warn_function_return,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_warn_function_return =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*warn_function_return\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_warn_function_return : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_function_return(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_warn_function_return, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_warn_function_return (); }\n+\n+}; // class pass_warn_function_return\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_warn_function_return (gcc::context *ctxt)\n+{\n+  return new pass_warn_function_return (ctxt);\n+}\n+\n /* Emit noreturn warnings.  */\n \n static unsigned int\n@@ -8081,26 +8132,44 @@ gate_warn_function_noreturn (void)\n   return warn_suggest_attribute_noreturn;\n }\n \n-struct gimple_opt_pass pass_warn_function_noreturn =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*warn_function_noreturn\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_warn_function_noreturn,\t\t/* gate */\n-  execute_warn_function_noreturn,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_warn_function_noreturn =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*warn_function_noreturn\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_warn_function_noreturn : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_function_noreturn(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_warn_function_noreturn, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_warn_function_noreturn (); }\n+  unsigned int execute () { return execute_warn_function_noreturn (); }\n+\n+}; // class pass_warn_function_noreturn\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_warn_function_noreturn (gcc::context *ctxt)\n+{\n+  return new pass_warn_function_noreturn (ctxt);\n+}\n+\n \n /* Walk a gimplified function and warn for functions whose return value is\n    ignored and attribute((warn_unused_result)) is set.  This is done before\n@@ -8180,26 +8249,44 @@ gate_warn_unused_result (void)\n   return flag_warn_unused_result;\n }\n \n-struct gimple_opt_pass pass_warn_unused_result =\n-{\n-  {\n-    GIMPLE_PASS,\n-    \"*warn_unused_result\",\t\t/* name */\n-    OPTGROUP_NONE,                        /* optinfo_flags */\n-    gate_warn_unused_result,\t\t/* gate */\n-    run_warn_unused_result,\t\t/* execute */\n-    NULL,\t\t\t\t/* sub */\n-    NULL,\t\t\t\t/* next */\n-    0,\t\t\t\t\t/* static_pass_number */\n-    TV_NONE,\t\t\t\t/* tv_id */\n-    PROP_gimple_any,\t\t\t/* properties_required */\n-    0,\t\t\t\t\t/* properties_provided */\n-    0,\t\t\t\t\t/* properties_destroyed */\n-    0,\t\t\t\t\t/* todo_flags_start */\n-    0,\t\t\t\t\t/* todo_flags_finish */\n-  }\n+namespace {\n+\n+const pass_data pass_data_warn_unused_result =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*warn_unused_result\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_warn_unused_result : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_unused_result(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_warn_unused_result, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_warn_unused_result (); }\n+  unsigned int execute () { return run_warn_unused_result (); }\n+\n+}; // class pass_warn_unused_result\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_warn_unused_result (gcc::context *ctxt)\n+{\n+  return new pass_warn_unused_result (ctxt);\n+}\n+\n \n /* Garbage collection support for edge_def.  */\n "}, {"sha": "8917f855705dc43802000702185af8bf816d8c9a", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -989,22 +989,41 @@ gate_merge_phi (void)\n   return 1;\n }\n \n-struct gimple_opt_pass pass_merge_phi =\n+namespace {\n+\n+const pass_data pass_data_merge_phi =\n {\n- {\n-  GIMPLE_PASS,\n-  \"mergephi\",\t\t\t/* name */\n-  OPTGROUP_NONE,                /* optinfo_flags */\n-  gate_merge_phi,\t\t/* gate */\n-  merge_phi_nodes,\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_MERGE_PHI,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa               /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"mergephi\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_MERGE_PHI, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_merge_phi : public gimple_opt_pass\n+{\n+public:\n+  pass_merge_phi(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_merge_phi, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_merge_phi (ctxt_); }\n+  bool gate () { return gate_merge_phi (); }\n+  unsigned int execute () { return merge_phi_nodes (); }\n+\n+}; // class pass_merge_phi\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_merge_phi (gcc::context *ctxt)\n+{\n+  return new pass_merge_phi (ctxt);\n+}"}, {"sha": "225728fdaeb73517d6a68d3886284494a5780b67", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1637,27 +1637,44 @@ tree_lower_complex (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_lower_complex =\n+namespace {\n+\n+const pass_data pass_data_lower_complex =\n {\n- {\n-  GIMPLE_PASS,\n-  \"cplxlower\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  0,\t\t\t\t\t/* gate */\n-  tree_lower_complex,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  PROP_gimple_lcx,\t\t\t/* properties_provided */\n-  0,                       \t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_stmts\t \t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"cplxlower\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  PROP_gimple_lcx, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_stmts ), /* todo_flags_finish */\n };\n \n+class pass_lower_complex : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_complex(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_complex, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_lower_complex (ctxt_); }\n+  unsigned int execute () { return tree_lower_complex (); }\n+\n+}; // class pass_lower_complex\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_complex (gcc::context *ctxt)\n+{\n+  return new pass_lower_complex (ctxt);\n+}\n+\n \f\n static bool\n gate_no_optimization (void)\n@@ -1667,23 +1684,40 @@ gate_no_optimization (void)\n   return !(cfun->curr_properties & PROP_gimple_lcx);\n }\n \n-struct gimple_opt_pass pass_lower_complex_O0 =\n+namespace {\n+\n+const pass_data pass_data_lower_complex_O0 =\n {\n- {\n-  GIMPLE_PASS,\n-  \"cplxlower0\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_no_optimization,\t\t\t/* gate */\n-  tree_lower_complex,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  PROP_gimple_lcx,\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_stmts\t \t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"cplxlower0\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  PROP_gimple_lcx, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_stmts ), /* todo_flags_finish */\n };\n+\n+class pass_lower_complex_O0 : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_complex_O0(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_complex_O0, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_no_optimization (); }\n+  unsigned int execute () { return tree_lower_complex (); }\n+\n+}; // class pass_lower_complex_O0\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_complex_O0 (gcc::context *ctxt)\n+{\n+  return new pass_lower_complex_O0 (ctxt);\n+}"}, {"sha": "6ffbd26671117f6ff947019d6311e3f9868b3d49", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 176, "deletions": 85, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2157,25 +2157,42 @@ lower_eh_constructs (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_lower_eh =\n+namespace {\n+\n+const pass_data pass_data_lower_eh =\n {\n- {\n-  GIMPLE_PASS,\n-  \"eh\",\t\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  lower_eh_constructs,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_EH,\t\t\t\t/* tv_id */\n-  PROP_gimple_lcf,\t\t\t/* properties_required */\n-  PROP_gimple_leh,\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"eh\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_EH, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  PROP_gimple_leh, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_lower_eh : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_eh(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_eh, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return lower_eh_constructs (); }\n+\n+}; // class pass_lower_eh\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_eh (gcc::context *ctxt)\n+{\n+  return new pass_lower_eh (ctxt);\n+}\n \f\n /* Create the multiple edges from an EH_DISPATCH statement to all of\n    the possible handlers for its EH region.  Return true if there's\n@@ -3017,25 +3034,43 @@ gate_refactor_eh (void)\n   return flag_exceptions != 0;\n }\n \n-struct gimple_opt_pass pass_refactor_eh =\n+namespace {\n+\n+const pass_data pass_data_refactor_eh =\n {\n- {\n-  GIMPLE_PASS,\n-  \"ehopt\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_refactor_eh,\t\t\t/* gate */\n-  refactor_eh,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_EH,\t\t\t\t/* tv_id */\n-  PROP_gimple_lcf,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"ehopt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_EH, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_refactor_eh : public gimple_opt_pass\n+{\n+public:\n+  pass_refactor_eh(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_refactor_eh, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_refactor_eh (); }\n+  unsigned int execute () { return refactor_eh (); }\n+\n+}; // class pass_refactor_eh\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_refactor_eh (gcc::context *ctxt)\n+{\n+  return new pass_refactor_eh (ctxt);\n+}\n \f\n /* At the end of gimple optimization, we can lower RESX.  */\n \n@@ -3226,26 +3261,44 @@ gate_lower_resx (void)\n   return flag_exceptions != 0;\n }\n \n-struct gimple_opt_pass pass_lower_resx =\n+namespace {\n+\n+const pass_data pass_data_lower_resx =\n {\n- {\n-  GIMPLE_PASS,\n-  \"resx\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_lower_resx,\t\t\t/* gate */\n-  execute_lower_resx,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_EH,\t\t\t\t/* tv_id */\n-  PROP_gimple_lcf,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_flow\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"resx\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_EH, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n };\n \n+class pass_lower_resx : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_resx(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_resx, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_lower_resx (); }\n+  unsigned int execute () { return execute_lower_resx (); }\n+\n+}; // class pass_lower_resx\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_resx (gcc::context *ctxt)\n+{\n+  return new pass_lower_resx (ctxt);\n+}\n+\n /* Try to optimize var = {v} {CLOBBER} stmts followed just by\n    external throw.  */\n \n@@ -3619,25 +3672,43 @@ gate_lower_eh_dispatch (void)\n   return cfun->eh->region_tree != NULL;\n }\n \n-struct gimple_opt_pass pass_lower_eh_dispatch =\n+namespace {\n+\n+const pass_data pass_data_lower_eh_dispatch =\n {\n- {\n-  GIMPLE_PASS,\n-  \"ehdisp\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_lower_eh_dispatch,\t\t/* gate */\n-  execute_lower_eh_dispatch,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_EH,\t\t\t\t/* tv_id */\n-  PROP_gimple_lcf,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_flow\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"ehdisp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_EH, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n };\n+\n+class pass_lower_eh_dispatch : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_eh_dispatch(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_eh_dispatch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_lower_eh_dispatch (); }\n+  unsigned int execute () { return execute_lower_eh_dispatch (); }\n+\n+}; // class pass_lower_eh_dispatch\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_eh_dispatch (gcc::context *ctxt)\n+{\n+  return new pass_lower_eh_dispatch (ctxt);\n+}\n \f\n /* Walk statements, see what regions and, optionally, landing pads\n    are really referenced.\n@@ -4445,24 +4516,44 @@ gate_cleanup_eh (void)\n   return cfun->eh != NULL && cfun->eh->region_tree != NULL;\n }\n \n-struct gimple_opt_pass pass_cleanup_eh = {\n-  {\n-   GIMPLE_PASS,\n-   \"ehcleanup\",\t\t\t/* name */\n-   OPTGROUP_NONE,               /* optinfo_flags */\n-   gate_cleanup_eh,\t\t/* gate */\n-   execute_cleanup_eh,\t\t/* execute */\n-   NULL,\t\t\t/* sub */\n-   NULL,\t\t\t/* next */\n-   0,\t\t\t\t/* static_pass_number */\n-   TV_TREE_EH,\t\t\t/* tv_id */\n-   PROP_gimple_lcf,\t\t/* properties_required */\n-   0,\t\t\t\t/* properties_provided */\n-   0,\t\t\t\t/* properties_destroyed */\n-   0,\t\t\t\t/* todo_flags_start */\n-   TODO_verify_ssa    \t\t/* todo_flags_finish */\n-   }\n+namespace {\n+\n+const pass_data pass_data_cleanup_eh =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ehcleanup\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_EH, /* tv_id */\n+  PROP_gimple_lcf, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_cleanup_eh : public gimple_opt_pass\n+{\n+public:\n+  pass_cleanup_eh(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_cleanup_eh, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_cleanup_eh (ctxt_); }\n+  bool gate () { return gate_cleanup_eh (); }\n+  unsigned int execute () { return execute_cleanup_eh (); }\n+\n+}; // class pass_cleanup_eh\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_cleanup_eh (gcc::context *ctxt)\n+{\n+  return new pass_cleanup_eh (ctxt);\n+}\n \f\n /* Verify that BB containing STMT as the last statement, has precisely the\n    edge that make_eh_edges would create.  */"}, {"sha": "ed8edc3569c27e59398cf07bfe41f0f9184a783f", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -811,22 +811,40 @@ gate_emutls (void)\n   return !targetm.have_tls;\n }\n \n-struct simple_ipa_opt_pass pass_ipa_lower_emutls =\n+namespace {\n+\n+const pass_data pass_data_ipa_lower_emutls =\n {\n- {\n-  SIMPLE_IPA_PASS,\n-  \"emutls\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_emutls,\t\t\t\t/* gate */\n-  ipa_lower_emutls,\t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_IPA_OPT,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n- }\n+  SIMPLE_IPA_PASS, /* type */\n+  \"emutls\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_OPT, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_ipa_lower_emutls : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_lower_emutls(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_lower_emutls, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_emutls (); }\n+  unsigned int execute () { return ipa_lower_emutls (); }\n+\n+}; // class pass_ipa_lower_emutls\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_lower_emutls (gcc::context *ctxt)\n+{\n+  return new pass_ipa_lower_emutls (ctxt);\n+}"}, {"sha": "a886169ed00586fb5c89cc3183851a77afcacbfd", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1853,23 +1853,40 @@ gate_tree_if_conversion (void)\n \t  || flag_tree_loop_if_convert_stores == 1);\n }\n \n-struct gimple_opt_pass pass_if_conversion =\n+namespace {\n+\n+const pass_data pass_data_if_conversion =\n {\n- {\n-  GIMPLE_PASS,\n-  \"ifcvt\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tree_if_conversion,\t\t/* gate */\n-  main_tree_if_conversion,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_stmts | TODO_verify_flow\n-                                        /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"ifcvt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_stmts | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_if_conversion : public gimple_opt_pass\n+{\n+public:\n+  pass_if_conversion(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_if_conversion, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_if_conversion (); }\n+  unsigned int execute () { return main_tree_if_conversion (); }\n+\n+}; // class pass_if_conversion\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_if_conversion (gcc::context *ctxt)\n+{\n+  return new pass_if_conversion (ctxt);\n+}"}, {"sha": "33d4ba8c623593e223489ccde34918cbe6c956d3", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2410,27 +2410,43 @@ rewrite_into_ssa (void)\n }\n \n \n-struct gimple_opt_pass pass_build_ssa =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"ssa\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  rewrite_into_ssa,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SSA_OTHER,\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  PROP_ssa,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-    | TODO_remove_unused_locals\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_build_ssa =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ssa\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SSA_OTHER, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  PROP_ssa, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_remove_unused_locals ), /* todo_flags_finish */\n };\n \n+class pass_build_ssa : public gimple_opt_pass\n+{\n+public:\n+  pass_build_ssa(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_build_ssa, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return rewrite_into_ssa (); }\n+\n+}; // class pass_build_ssa\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_build_ssa (gcc::context *ctxt)\n+{\n+  return new pass_build_ssa (ctxt);\n+}\n+\n \n /* Mark the definition of VAR at STMT and BB as interesting for the\n    renamer.  BLOCKS is the set of blocks that need updating.  */"}, {"sha": "2317edcc7a391688d410d923a055954f209c6e1d", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1589,22 +1589,40 @@ gate_tree_loop_distribution (void)\n     || flag_tree_loop_distribute_patterns;\n }\n \n-struct gimple_opt_pass pass_loop_distribution =\n+namespace {\n+\n+const pass_data pass_data_loop_distribution =\n {\n- {\n-  GIMPLE_PASS,\n-  \"ldist\",\t\t\t/* name */\n-  OPTGROUP_LOOP,                /* optinfo_flags */\n-  gate_tree_loop_distribution,  /* gate */\n-  tree_loop_distribution,       /* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_LOOP_DISTRIBUTION,    /* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa               /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"ldist\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_DISTRIBUTION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_loop_distribution : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_distribution(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_loop_distribution, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_loop_distribution (); }\n+  unsigned int execute () { return tree_loop_distribution (); }\n+\n+}; // class pass_loop_distribution\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_loop_distribution (gcc::context *ctxt)\n+{\n+  return new pass_loop_distribution (ctxt);\n+}"}, {"sha": "adf2f7bd7d27870ea5006ba7ef431149206081a4", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 71, "deletions": 35, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1378,45 +1378,81 @@ gate_mudflap (void)\n   return flag_mudflap != 0;\n }\n \n-struct gimple_opt_pass pass_mudflap_1 =\n+namespace {\n+\n+const pass_data pass_data_mudflap_1 =\n {\n- {\n-  GIMPLE_PASS,\n-  \"mudflap1\",                           /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_mudflap,                         /* gate */\n-  execute_mudflap_function_decls,       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  PROP_gimple_any,                      /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"mudflap1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_mudflap_2 =\n+class pass_mudflap_1 : public gimple_opt_pass\n+{\n+public:\n+  pass_mudflap_1(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_mudflap_1, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_mudflap (); }\n+  unsigned int execute () { return execute_mudflap_function_decls (); }\n+\n+}; // class pass_mudflap_1\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_mudflap_1 (gcc::context *ctxt)\n+{\n+  return new pass_mudflap_1 (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_mudflap_2 =\n {\n- {\n-  GIMPLE_PASS,\n-  \"mudflap2\",                           /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_mudflap,                         /* gate */\n-  execute_mudflap_function_ops,         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  PROP_ssa | PROP_cfg | PROP_gimple_leh,/* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_flow | TODO_verify_stmts\n-  | TODO_update_ssa                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"mudflap2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_ssa | PROP_cfg | PROP_gimple_leh ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_flow | TODO_verify_stmts\n+    | TODO_update_ssa ), /* todo_flags_finish */\n };\n \n+class pass_mudflap_2 : public gimple_opt_pass\n+{\n+public:\n+  pass_mudflap_2(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_mudflap_2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_mudflap (); }\n+  unsigned int execute () { return execute_mudflap_function_ops (); }\n+\n+}; // class pass_mudflap_2\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_mudflap_2 (gcc::context *ctxt)\n+{\n+  return new pass_mudflap_2 (ctxt);\n+}\n+\n #include \"gt-tree-mudflap.h\""}, {"sha": "6659f05f5b1002d63b5cb5d0a8591ecdada2f7ae", "filename": "gcc/tree-nomudflap.c", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-nomudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-nomudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nomudflap.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -85,46 +85,80 @@ gate_mudflap (void)\n   return flag_mudflap != 0;\n }\n \n-struct gimple_opt_pass pass_mudflap_1 =\n+namespace {\n+\n+const pass_data pass_data_mudflap_1 =\n {\n- {\n-  GIMPLE_PASS,\n-  \"mudflap1\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_mudflap,                         /* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"mudflap1\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_mudflap_2 =\n+class pass_mudflap_1 : public gimple_opt_pass\n+{\n+public:\n+  pass_mudflap_1(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_mudflap_1, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_mudflap (); }\n+\n+}; // class pass_mudflap_1\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_mudflap_1 (gcc::context *ctxt)\n+{\n+  return new pass_mudflap_1 (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_mudflap_2 =\n {\n- {\n-  GIMPLE_PASS,\n-  \"mudflap2\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_mudflap,                         /* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"mudflap2\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_mudflap_2 : public gimple_opt_pass\n+{\n+public:\n+  pass_mudflap_2(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_mudflap_2, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_mudflap (); }\n+\n+}; // class pass_mudflap_2\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_mudflap_2 (gcc::context *ctxt)\n+{\n+  return new pass_mudflap_2 (ctxt);\n+}\n+\n /* Instead of:\n #include \"gt-tree-mudflap.h\"\n We prepare a little dummy struct here."}, {"sha": "2acb2ebaa343aabe8477a09a690c9b952b8e4f8f", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -269,26 +269,44 @@ gate_pass_return_slot (void)\n   return optimize > 0;\n }\n \n-struct gimple_opt_pass pass_nrv =\n+namespace {\n+\n+const pass_data pass_data_nrv =\n {\n- {\n-  GIMPLE_PASS,\n-  \"nrv\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_pass_return_slot,\t\t/* gate */\n-  tree_nrv,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_NRV,\t\t\t\t/* tv_id */\n-  PROP_ssa | PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"nrv\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_NRV, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_nrv : public gimple_opt_pass\n+{\n+public:\n+  pass_nrv(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_nrv, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_pass_return_slot (); }\n+  unsigned int execute () { return tree_nrv (); }\n+\n+}; // class pass_nrv\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_nrv (gcc::context *ctxt)\n+{\n+  return new pass_nrv (ctxt);\n+}\n+\n /* Determine (pessimistically) whether DEST is available for NRV\n    optimization, where DEST is expected to be the LHS of a modify\n    expression where the RHS is a function returning an aggregate.\n@@ -355,22 +373,39 @@ execute_return_slot_opt (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_return_slot =\n+namespace {\n+\n+const pass_data pass_data_return_slot =\n {\n- {\n-  GIMPLE_PASS,\n-  \"retslot\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_return_slot_opt,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"retslot\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_return_slot : public gimple_opt_pass\n+{\n+public:\n+  pass_return_slot(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_return_slot, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_return_slot_opt (); }\n+\n+}; // class pass_return_slot\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_return_slot (gcc::context *ctxt)\n+{\n+  return new pass_return_slot (ctxt);\n+}"}, {"sha": "1a52a416a632db2ee08e9d1db07b6990322b11a5", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1262,22 +1262,40 @@ compute_object_sizes (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_object_sizes =\n+namespace {\n+\n+const pass_data pass_data_object_sizes =\n {\n- {\n-  GIMPLE_PASS,\n-  \"objsz\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  compute_object_sizes,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"objsz\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_object_sizes : public gimple_opt_pass\n+{\n+public:\n+  pass_object_sizes(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_object_sizes, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_object_sizes (ctxt_); }\n+  unsigned int execute () { return compute_object_sizes (); }\n+\n+}; // class pass_object_sizes\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_object_sizes (gcc::context *ctxt)\n+{\n+  return new pass_object_sizes (ctxt);\n+}"}, {"sha": "9c99ec23a2e7bd623d0f498bdbdb1f18d73a291c", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 71, "deletions": 34, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -88,26 +88,45 @@ execute_cleanup_cfg_post_optimizing (void)\n   return todo;\n }\n \n-struct gimple_opt_pass pass_cleanup_cfg_post_optimizing =\n+namespace {\n+\n+const pass_data pass_data_cleanup_cfg_post_optimizing =\n {\n- {\n-  GIMPLE_PASS,\n-  \"optimized\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_cleanup_cfg_post_optimizing,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_CLEANUP_CFG,\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_remove_unused_locals             /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"optimized\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_CLEANUP_CFG, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_remove_unused_locals, /* todo_flags_finish */\n };\n \n+class pass_cleanup_cfg_post_optimizing : public gimple_opt_pass\n+{\n+public:\n+  pass_cleanup_cfg_post_optimizing(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_cleanup_cfg_post_optimizing, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () {\n+    return execute_cleanup_cfg_post_optimizing ();\n+  }\n+\n+}; // class pass_cleanup_cfg_post_optimizing\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_cleanup_cfg_post_optimizing (gcc::context *ctxt)\n+{\n+  return new pass_cleanup_cfg_post_optimizing (ctxt);\n+}\n+\n /* IPA passes, compilation of earlier functions or inlining\n    might have changed some properties, such as marked functions nothrow,\n    pure, const or noreturn.\n@@ -211,22 +230,40 @@ execute_fixup_cfg (void)\n   return todo;\n }\n \n-struct gimple_opt_pass pass_fixup_cfg =\n+namespace {\n+\n+const pass_data pass_data_fixup_cfg =\n {\n- {\n-  GIMPLE_PASS,\n-  \"*free_cfg_annotations\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_fixup_cfg,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"*free_cfg_annotations\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_fixup_cfg : public gimple_opt_pass\n+{\n+public:\n+  pass_fixup_cfg(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_fixup_cfg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_fixup_cfg (ctxt_); }\n+  unsigned int execute () { return execute_fixup_cfg (); }\n+\n+}; // class pass_fixup_cfg\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_fixup_cfg (gcc::context *ctxt)\n+{\n+  return new pass_fixup_cfg (ctxt);\n+}"}, {"sha": "41d5d92c8a9bad6083fb6145bac66f430138fe84", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 238, "deletions": 228, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -330,237 +330,247 @@ struct register_pass_info\n   enum pass_positioning_ops pos_op; /* how to insert the new pass.  */\n };\n \n-extern struct gimple_opt_pass pass_mudflap_1;\n-extern struct gimple_opt_pass pass_mudflap_2;\n-extern struct gimple_opt_pass pass_asan;\n-extern struct gimple_opt_pass pass_asan_O0;\n-extern struct gimple_opt_pass pass_tsan;\n-extern struct gimple_opt_pass pass_tsan_O0;\n-extern struct gimple_opt_pass pass_lower_cf;\n-extern struct gimple_opt_pass pass_refactor_eh;\n-extern struct gimple_opt_pass pass_lower_eh;\n-extern struct gimple_opt_pass pass_lower_eh_dispatch;\n-extern struct gimple_opt_pass pass_lower_resx;\n-extern struct gimple_opt_pass pass_build_cfg;\n-extern struct gimple_opt_pass pass_early_tree_profile;\n-extern struct gimple_opt_pass pass_cleanup_eh;\n-extern struct gimple_opt_pass pass_sra;\n-extern struct gimple_opt_pass pass_sra_early;\n-extern struct gimple_opt_pass pass_early_ipa_sra;\n-extern struct gimple_opt_pass pass_tail_recursion;\n-extern struct gimple_opt_pass pass_tail_calls;\n-extern struct gimple_opt_pass pass_tree_loop;\n-extern struct gimple_opt_pass pass_tree_loop_init;\n-extern struct gimple_opt_pass pass_lim;\n-extern struct gimple_opt_pass pass_tree_unswitch;\n-extern struct gimple_opt_pass pass_predcom;\n-extern struct gimple_opt_pass pass_iv_canon;\n-extern struct gimple_opt_pass pass_scev_cprop;\n-extern struct gimple_opt_pass pass_empty_loop;\n-extern struct gimple_opt_pass pass_record_bounds;\n-extern struct gimple_opt_pass pass_graphite;\n-extern struct gimple_opt_pass pass_graphite_transforms;\n-extern struct gimple_opt_pass pass_if_conversion;\n-extern struct gimple_opt_pass pass_loop_distribution;\n-extern struct gimple_opt_pass pass_vectorize;\n-extern struct gimple_opt_pass pass_slp_vectorize;\n-extern struct gimple_opt_pass pass_complete_unroll;\n-extern struct gimple_opt_pass pass_complete_unrolli;\n-extern struct gimple_opt_pass pass_parallelize_loops;\n-extern struct gimple_opt_pass pass_loop_prefetch;\n-extern struct gimple_opt_pass pass_iv_optimize;\n-extern struct gimple_opt_pass pass_tree_loop_done;\n-extern struct gimple_opt_pass pass_ch;\n-extern struct gimple_opt_pass pass_ccp;\n-extern struct gimple_opt_pass pass_phi_only_cprop;\n-extern struct gimple_opt_pass pass_build_ssa;\n-extern struct gimple_opt_pass pass_build_alias;\n-extern struct gimple_opt_pass pass_build_ealias;\n-extern struct gimple_opt_pass pass_dominator;\n-extern struct gimple_opt_pass pass_dce;\n-extern struct gimple_opt_pass pass_dce_loop;\n-extern struct gimple_opt_pass pass_cd_dce;\n-extern struct gimple_opt_pass pass_call_cdce;\n-extern struct gimple_opt_pass pass_merge_phi;\n-extern struct gimple_opt_pass pass_split_crit_edges;\n-extern struct gimple_opt_pass pass_pre;\n+extern gimple_opt_pass *make_pass_mudflap_1 (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_mudflap_2 (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_asan (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_asan_O0 (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tsan (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tsan_O0 (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_cf (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_refactor_eh (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_eh (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_eh_dispatch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_resx (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_build_cfg (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_early_tree_profile (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_cleanup_eh (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_sra (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_sra_early (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_early_ipa_sra (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tail_recursion (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tail_calls (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tree_loop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tree_loop_init (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lim (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tree_unswitch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_predcom (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_iv_canon (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_scev_cprop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_empty_loop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_record_bounds (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_graphite (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_graphite_transforms (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_if_conversion (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_loop_distribution (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_vectorize (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_slp_vectorize (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_complete_unroll (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_complete_unrolli (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_parallelize_loops (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_loop_prefetch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_iv_optimize (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tree_loop_done (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_ch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_ccp (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_phi_only_cprop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_build_ssa (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_build_alias (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_build_ealias (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_dominator (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_dce (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_dce_loop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_cd_dce (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_call_cdce (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_merge_phi (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_split_crit_edges (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_pre (gcc::context *ctxt);\n extern unsigned int tail_merge_optimize (unsigned int);\n-extern struct gimple_opt_pass pass_profile;\n-extern struct gimple_opt_pass pass_strip_predict_hints;\n-extern struct gimple_opt_pass pass_lower_complex_O0;\n-extern struct gimple_opt_pass pass_lower_complex;\n-extern struct gimple_opt_pass pass_lower_vector;\n-extern struct gimple_opt_pass pass_lower_vector_ssa;\n-extern struct gimple_opt_pass pass_lower_omp;\n-extern struct gimple_opt_pass pass_diagnose_omp_blocks;\n-extern struct gimple_opt_pass pass_expand_omp;\n-extern struct gimple_opt_pass pass_expand_omp_ssa;\n-extern struct gimple_opt_pass pass_object_sizes;\n-extern struct gimple_opt_pass pass_strlen;\n-extern struct gimple_opt_pass pass_fold_builtins;\n-extern struct gimple_opt_pass pass_stdarg;\n-extern struct gimple_opt_pass pass_early_warn_uninitialized;\n-extern struct gimple_opt_pass pass_late_warn_uninitialized;\n-extern struct gimple_opt_pass pass_cse_reciprocals;\n-extern struct gimple_opt_pass pass_cse_sincos;\n-extern struct gimple_opt_pass pass_optimize_bswap;\n-extern struct gimple_opt_pass pass_optimize_widening_mul;\n-extern struct gimple_opt_pass pass_warn_function_return;\n-extern struct gimple_opt_pass pass_warn_function_noreturn;\n-extern struct gimple_opt_pass pass_cselim;\n-extern struct gimple_opt_pass pass_phiopt;\n-extern struct gimple_opt_pass pass_forwprop;\n-extern struct gimple_opt_pass pass_phiprop;\n-extern struct gimple_opt_pass pass_tree_ifcombine;\n-extern struct gimple_opt_pass pass_dse;\n-extern struct gimple_opt_pass pass_nrv;\n-extern struct gimple_opt_pass pass_rename_ssa_copies;\n-extern struct gimple_opt_pass pass_sink_code;\n-extern struct gimple_opt_pass pass_fre;\n-extern struct gimple_opt_pass pass_check_data_deps;\n-extern struct gimple_opt_pass pass_copy_prop;\n-extern struct gimple_opt_pass pass_vrp;\n-extern struct gimple_opt_pass pass_uncprop;\n-extern struct gimple_opt_pass pass_return_slot;\n-extern struct gimple_opt_pass pass_reassoc;\n-extern struct gimple_opt_pass pass_rebuild_cgraph_edges;\n-extern struct gimple_opt_pass pass_remove_cgraph_callee_edges;\n-extern struct gimple_opt_pass pass_build_cgraph_edges;\n-extern struct gimple_opt_pass pass_local_pure_const;\n-extern struct gimple_opt_pass pass_tracer;\n-extern struct gimple_opt_pass pass_warn_unused_result;\n-extern struct gimple_opt_pass pass_diagnose_tm_blocks;\n-extern struct gimple_opt_pass pass_lower_tm;\n-extern struct gimple_opt_pass pass_tm_init;\n-extern struct gimple_opt_pass pass_tm_mark;\n-extern struct gimple_opt_pass pass_tm_memopt;\n-extern struct gimple_opt_pass pass_tm_edges;\n-extern struct gimple_opt_pass pass_split_functions;\n-extern struct gimple_opt_pass pass_feedback_split_functions;\n-extern struct gimple_opt_pass pass_strength_reduction;\n+extern gimple_opt_pass *make_pass_profile (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_strip_predict_hints (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_complex_O0 (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_complex (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_vector (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_vector_ssa (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_omp (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_diagnose_omp_blocks (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_expand_omp (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_expand_omp_ssa (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_strlen (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_fold_builtins (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_stdarg (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_early_warn_uninitialized (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_late_warn_uninitialized (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_cse_reciprocals (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_cse_sincos (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_optimize_bswap (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_optimize_widening_mul (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_warn_function_return (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_warn_function_noreturn (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_cselim (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_phiopt (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_forwprop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_phiprop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tree_ifcombine (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_dse (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_nrv (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_rename_ssa_copies (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_sink_code (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_fre (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_check_data_deps (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_copy_prop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_vrp (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_uncprop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_return_slot (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_reassoc (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_rebuild_cgraph_edges (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_remove_cgraph_callee_edges (gcc::context\n+\t\t\t\t\t\t\t      *ctxt);\n+extern gimple_opt_pass *make_pass_build_cgraph_edges (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_local_pure_const (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tracer (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_warn_unused_result (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_diagnose_tm_blocks (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_tm (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tm_init (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tm_mark (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tm_memopt (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_tm_edges (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_split_functions (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_feedback_split_functions (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_strength_reduction (gcc::context *ctxt);\n \n /* IPA Passes */\n-extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;\n-extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;\n-extern struct simple_ipa_opt_pass pass_ipa_tree_profile;\n-\n-extern struct simple_ipa_opt_pass pass_early_local_passes;\n-\n-extern struct ipa_opt_pass_d pass_ipa_whole_program_visibility;\n-extern struct ipa_opt_pass_d pass_ipa_lto_gimple_out;\n-extern struct simple_ipa_opt_pass pass_ipa_increase_alignment;\n-extern struct ipa_opt_pass_d pass_ipa_inline;\n-extern struct simple_ipa_opt_pass pass_ipa_free_lang_data;\n-extern struct simple_ipa_opt_pass pass_ipa_free_inline_summary;\n-extern struct ipa_opt_pass_d pass_ipa_cp;\n-extern struct ipa_opt_pass_d pass_ipa_reference;\n-extern struct ipa_opt_pass_d pass_ipa_pure_const;\n-extern struct simple_ipa_opt_pass pass_ipa_pta;\n-extern struct ipa_opt_pass_d pass_ipa_lto_finish_out;\n-extern struct simple_ipa_opt_pass pass_ipa_tm;\n-extern struct ipa_opt_pass_d pass_ipa_profile;\n-extern struct ipa_opt_pass_d pass_ipa_cdtor_merge;\n-\n-extern struct gimple_opt_pass pass_cleanup_cfg_post_optimizing;\n-extern struct gimple_opt_pass pass_init_datastructures;\n-extern struct gimple_opt_pass pass_fixup_cfg;\n-\n-extern struct rtl_opt_pass pass_expand;\n-extern struct rtl_opt_pass pass_instantiate_virtual_regs;\n-extern struct rtl_opt_pass pass_rtl_fwprop;\n-extern struct rtl_opt_pass pass_rtl_fwprop_addr;\n-extern struct rtl_opt_pass pass_jump;\n-extern struct rtl_opt_pass pass_jump2;\n-extern struct rtl_opt_pass pass_lower_subreg;\n-extern struct rtl_opt_pass pass_cse;\n-extern struct rtl_opt_pass pass_fast_rtl_dce;\n-extern struct rtl_opt_pass pass_ud_rtl_dce;\n-extern struct rtl_opt_pass pass_rtl_dce;\n-extern struct rtl_opt_pass pass_rtl_dse1;\n-extern struct rtl_opt_pass pass_rtl_dse2;\n-extern struct rtl_opt_pass pass_rtl_dse3;\n-extern struct rtl_opt_pass pass_rtl_cprop;\n-extern struct rtl_opt_pass pass_rtl_pre;\n-extern struct rtl_opt_pass pass_rtl_hoist;\n-extern struct rtl_opt_pass pass_rtl_store_motion;\n-extern struct rtl_opt_pass pass_cse_after_global_opts;\n-extern struct rtl_opt_pass pass_rtl_ifcvt;\n-\n-extern struct rtl_opt_pass pass_into_cfg_layout_mode;\n-extern struct rtl_opt_pass pass_outof_cfg_layout_mode;\n-\n-extern struct rtl_opt_pass pass_loop2;\n-extern struct rtl_opt_pass pass_rtl_loop_init;\n-extern struct rtl_opt_pass pass_rtl_move_loop_invariants;\n-extern struct rtl_opt_pass pass_rtl_unswitch;\n-extern struct rtl_opt_pass pass_rtl_unroll_and_peel_loops;\n-extern struct rtl_opt_pass pass_rtl_doloop;\n-extern struct rtl_opt_pass pass_rtl_loop_done;\n-\n-extern struct rtl_opt_pass pass_web;\n-extern struct rtl_opt_pass pass_cse2;\n-extern struct rtl_opt_pass pass_df_initialize_opt;\n-extern struct rtl_opt_pass pass_df_initialize_no_opt;\n-extern struct rtl_opt_pass pass_reginfo_init;\n-extern struct rtl_opt_pass pass_inc_dec;\n-extern struct rtl_opt_pass pass_stack_ptr_mod;\n-extern struct rtl_opt_pass pass_initialize_regs;\n-extern struct rtl_opt_pass pass_combine;\n-extern struct rtl_opt_pass pass_if_after_combine;\n-extern struct rtl_opt_pass pass_ree;\n-extern struct rtl_opt_pass pass_partition_blocks;\n-extern struct rtl_opt_pass pass_match_asm_constraints;\n-extern struct rtl_opt_pass pass_regmove;\n-extern struct rtl_opt_pass pass_split_all_insns;\n-extern struct rtl_opt_pass pass_fast_rtl_byte_dce;\n-extern struct rtl_opt_pass pass_lower_subreg2;\n-extern struct rtl_opt_pass pass_mode_switching;\n-extern struct rtl_opt_pass pass_sms;\n-extern struct rtl_opt_pass pass_sched;\n-extern struct rtl_opt_pass pass_ira;\n-extern struct rtl_opt_pass pass_reload;\n-extern struct rtl_opt_pass pass_clean_state;\n-extern struct rtl_opt_pass pass_branch_prob;\n-extern struct rtl_opt_pass pass_value_profile_transformations;\n-extern struct rtl_opt_pass pass_postreload_cse;\n-extern struct rtl_opt_pass pass_gcse2;\n-extern struct rtl_opt_pass pass_split_after_reload;\n-extern struct rtl_opt_pass pass_branch_target_load_optimize1;\n-extern struct rtl_opt_pass pass_thread_prologue_and_epilogue;\n-extern struct rtl_opt_pass pass_stack_adjustments;\n-extern struct rtl_opt_pass pass_peephole2;\n-extern struct rtl_opt_pass pass_if_after_reload;\n-extern struct rtl_opt_pass pass_regrename;\n-extern struct rtl_opt_pass pass_cprop_hardreg;\n-extern struct rtl_opt_pass pass_reorder_blocks;\n-extern struct rtl_opt_pass pass_branch_target_load_optimize2;\n-extern struct rtl_opt_pass pass_leaf_regs;\n-extern struct rtl_opt_pass pass_split_before_sched2;\n-extern struct rtl_opt_pass pass_compare_elim_after_reload;\n-extern struct rtl_opt_pass pass_sched2;\n-extern struct rtl_opt_pass pass_stack_regs;\n-extern struct rtl_opt_pass pass_stack_regs_run;\n-extern struct rtl_opt_pass pass_df_finish;\n-extern struct rtl_opt_pass pass_compute_alignments;\n-extern struct rtl_opt_pass pass_duplicate_computed_gotos;\n-extern struct rtl_opt_pass pass_variable_tracking;\n-extern struct rtl_opt_pass pass_free_cfg;\n-extern struct rtl_opt_pass pass_machine_reorg;\n-extern struct rtl_opt_pass pass_cleanup_barriers;\n-extern struct rtl_opt_pass pass_delay_slots;\n-extern struct rtl_opt_pass pass_split_for_shorten_branches;\n-extern struct rtl_opt_pass pass_split_before_regstack;\n-extern struct rtl_opt_pass pass_convert_to_eh_region_ranges;\n-extern struct rtl_opt_pass pass_shorten_branches;\n-extern struct rtl_opt_pass pass_set_nothrow_function_flags;\n-extern struct rtl_opt_pass pass_dwarf2_frame;\n-extern struct rtl_opt_pass pass_final;\n-extern struct rtl_opt_pass pass_rtl_seqabstr;\n-extern struct gimple_opt_pass pass_release_ssa_names;\n-extern struct gimple_opt_pass pass_early_inline;\n-extern struct gimple_opt_pass pass_inline_parameters;\n-extern struct gimple_opt_pass pass_update_address_taken;\n-extern struct gimple_opt_pass pass_convert_switch;\n+extern simple_ipa_opt_pass *make_pass_ipa_lower_emutls (gcc::context *ctxt);\n+extern simple_ipa_opt_pass\n+\t\t\t\t\t\t\t      *make_pass_ipa_function_and_variable_visibility (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_tree_profile (gcc::context *ctxt);\n+\n+extern simple_ipa_opt_pass *make_pass_early_local_passes (gcc::context *ctxt);\n+\n+extern ipa_opt_pass_d *make_pass_ipa_whole_program_visibility (gcc::context\n+\t\t\t\t\t\t\t       *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_lto_gimple_out (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_increase_alignment (gcc::context\n+\t\t\t\t\t\t\t      *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_inline (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_free_lang_data (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_free_inline_summary (gcc::context\n+\t\t\t\t\t\t\t       *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_cp (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_reference (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_pure_const (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_pta (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_lto_finish_out (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_tm (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_profile (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_cdtor_merge (gcc::context *ctxt);\n+\n+extern gimple_opt_pass *make_pass_cleanup_cfg_post_optimizing (gcc::context\n+\t\t\t\t\t\t\t       *ctxt);\n+extern gimple_opt_pass *make_pass_init_datastructures (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_fixup_cfg (gcc::context *ctxt);\n+\n+extern rtl_opt_pass *make_pass_expand (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_instantiate_virtual_regs (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_fwprop (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_fwprop_addr (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_jump (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_jump2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_lower_subreg (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_cse (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_fast_rtl_dce (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_ud_rtl_dce (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_dce (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_dse1 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_dse2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_dse3 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_cprop (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_pre (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_hoist (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_store_motion (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_cse_after_global_opts (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_ifcvt (gcc::context *ctxt);\n+\n+extern rtl_opt_pass *make_pass_into_cfg_layout_mode (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_outof_cfg_layout_mode (gcc::context *ctxt);\n+\n+extern rtl_opt_pass *make_pass_loop2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_loop_init (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_move_loop_invariants (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_unswitch (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_unroll_and_peel_loops (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_doloop (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_loop_done (gcc::context *ctxt);\n+\n+extern rtl_opt_pass *make_pass_web (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_cse2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_df_initialize_opt (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_df_initialize_no_opt (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_reginfo_init (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_inc_dec (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_stack_ptr_mod (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_initialize_regs (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_combine (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_if_after_combine (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_ree (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_partition_blocks (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_match_asm_constraints (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_regmove (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_split_all_insns (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_fast_rtl_byte_dce (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_lower_subreg2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_mode_switching (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_sms (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_sched (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_ira (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_reload (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_clean_state (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_branch_prob (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_value_profile_transformations (gcc::context\n+\t\t\t\t\t\t\t      *ctxt);\n+extern rtl_opt_pass *make_pass_postreload_cse (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_gcse2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_split_after_reload (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_branch_target_load_optimize1 (gcc::context\n+\t\t\t\t\t\t\t     *ctxt);\n+extern rtl_opt_pass *make_pass_thread_prologue_and_epilogue (gcc::context\n+\t\t\t\t\t\t\t     *ctxt);\n+extern rtl_opt_pass *make_pass_stack_adjustments (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_peephole2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_if_after_reload (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_regrename (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_cprop_hardreg (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_reorder_blocks (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_branch_target_load_optimize2 (gcc::context\n+\t\t\t\t\t\t\t     *ctxt);\n+extern rtl_opt_pass *make_pass_leaf_regs (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_split_before_sched2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_compare_elim_after_reload (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_sched2 (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_stack_regs (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_stack_regs_run (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_df_finish (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_compute_alignments (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_duplicate_computed_gotos (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_variable_tracking (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_free_cfg (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_machine_reorg (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_cleanup_barriers (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_delay_slots (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_split_for_shorten_branches (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_split_before_regstack (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_convert_to_eh_region_ranges (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_shorten_branches (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_set_nothrow_function_flags (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_dwarf2_frame (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_final (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_seqabstr (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_release_ssa_names (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_early_inline (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_inline_parameters (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_update_address_taken (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_convert_switch (gcc::context *ctxt);\n \n /* Current optimization pass.  */\n extern struct opt_pass *current_pass;"}, {"sha": "e276a592b2f3bb99bb1bcec6e359cebf561cf6ac", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -561,24 +561,42 @@ gate_tree_profile_ipa (void)\n \t      || profile_arc_flag));\n }\n \n-struct simple_ipa_opt_pass pass_ipa_tree_profile =\n+namespace {\n+\n+const pass_data pass_data_ipa_tree_profile =\n {\n- {\n-  SIMPLE_IPA_PASS,\n-  \"profile\",  \t\t               /* name */\n-  OPTGROUP_NONE,                       /* optinfo_flags */\n-  gate_tree_profile_ipa,               /* gate */\n-  tree_profiling,                      /* execute */\n-  NULL,                                /* sub */\n-  NULL,                                /* next */\n-  0,                                   /* static_pass_number */\n-  TV_IPA_PROFILE,                      /* tv_id */\n-  0,                                   /* properties_required */\n-  0,                                   /* properties_provided */\n-  0,                                   /* properties_destroyed */\n-  0,                                   /* todo_flags_start */\n-  0                                    /* todo_flags_finish */\n- }\n+  SIMPLE_IPA_PASS, /* type */\n+  \"profile\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_PROFILE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_ipa_tree_profile : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_tree_profile(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_tree_profile, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_profile_ipa (); }\n+  unsigned int execute () { return tree_profiling (); }\n+\n+}; // class pass_ipa_tree_profile\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_tree_profile (gcc::context *ctxt)\n+{\n+  return new pass_ipa_tree_profile (ctxt);\n+}\n+\n #include \"gt-tree-profile.h\""}, {"sha": "2bce84843b9a4d1a567bfb8a1a7f7b3b628749ec", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 105, "deletions": 53, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3442,48 +3442,82 @@ gate_intra_sra (void)\n }\n \n \n-struct gimple_opt_pass pass_sra_early =\n+namespace {\n+\n+const pass_data pass_data_sra_early =\n {\n- {\n-  GIMPLE_PASS,\n-  \"esra\",\t \t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_intra_sra,\t\t\t/* gate */\n-  early_intra_sra,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SRA,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,                  /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"esra\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SRA, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_sra =\n+class pass_sra_early : public gimple_opt_pass\n+{\n+public:\n+  pass_sra_early(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_sra_early, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_intra_sra (); }\n+  unsigned int execute () { return early_intra_sra (); }\n+\n+}; // class pass_sra_early\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_sra_early (gcc::context *ctxt)\n+{\n+  return new pass_sra_early (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_sra =\n {\n- {\n-  GIMPLE_PASS,\n-  \"sra\",\t \t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_intra_sra,\t\t\t/* gate */\n-  late_intra_sra,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SRA,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,                  /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  TODO_update_address_taken,\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"sra\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SRA, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  TODO_update_address_taken, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n \n+class pass_sra : public gimple_opt_pass\n+{\n+public:\n+  pass_sra(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_sra, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_intra_sra (); }\n+  unsigned int execute () { return late_intra_sra (); }\n+\n+}; // class pass_sra\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_sra (gcc::context *ctxt)\n+{\n+  return new pass_sra (ctxt);\n+}\n+\n \n /* Return true iff PARM (which must be a parm_decl) is an unused scalar\n    parameter.  */\n@@ -5018,22 +5052,40 @@ ipa_early_sra_gate (void)\n   return flag_ipa_sra && dbg_cnt (eipa_sra);\n }\n \n-struct gimple_opt_pass pass_early_ipa_sra =\n+namespace {\n+\n+const pass_data pass_data_early_ipa_sra =\n {\n- {\n-  GIMPLE_PASS,\n-  \"eipa_sra\",\t \t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  ipa_early_sra_gate,\t\t\t/* gate */\n-  ipa_early_sra,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_SRA,\t\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_symtab              \t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"eipa_sra\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_SRA, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_dump_symtab, /* todo_flags_finish */\n };\n+\n+class pass_early_ipa_sra : public gimple_opt_pass\n+{\n+public:\n+  pass_early_ipa_sra(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_early_ipa_sra, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return ipa_early_sra_gate (); }\n+  unsigned int execute () { return ipa_early_sra (); }\n+\n+}; // class pass_early_ipa_sra\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_early_ipa_sra (gcc::context *ctxt)\n+{\n+  return new pass_early_ipa_sra (ctxt);\n+}"}, {"sha": "6472f484e3349eca8a6744c51e763703d1e4ef5b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 72, "deletions": 37, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2121,28 +2121,46 @@ gate_ccp (void)\n }\n \n \n-struct gimple_opt_pass pass_ccp =\n+namespace {\n+\n+const pass_data pass_data_ccp =\n {\n- {\n-  GIMPLE_PASS,\n-  \"ccp\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_ccp,\t\t\t\t/* gate */\n-  do_ssa_ccp,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_CCP,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-  | TODO_update_address_taken\n-  | TODO_verify_stmts\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"ccp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_CCP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_update_address_taken\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n };\n \n+class pass_ccp : public gimple_opt_pass\n+{\n+public:\n+  pass_ccp(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_ccp, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_ccp (ctxt_); }\n+  bool gate () { return gate_ccp (); }\n+  unsigned int execute () { return do_ssa_ccp (); }\n+\n+}; // class pass_ccp\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_ccp (gcc::context *ctxt)\n+{\n+  return new pass_ccp (ctxt);\n+}\n+\n \n \n /* Try to optimize out __builtin_stack_restore.  Optimize it out\n@@ -2521,23 +2539,40 @@ execute_fold_all_builtins (void)\n }\n \n \n-struct gimple_opt_pass pass_fold_builtins =\n+namespace {\n+\n+const pass_data pass_data_fold_builtins =\n {\n- {\n-  GIMPLE_PASS,\n-  \"fab\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_fold_all_builtins,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-    | TODO_update_ssa\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"fab\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_update_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_fold_builtins : public gimple_opt_pass\n+{\n+public:\n+  pass_fold_builtins(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_fold_builtins, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_fold_builtins (ctxt_); }\n+  unsigned int execute () { return execute_fold_all_builtins (); }\n+\n+}; // class pass_fold_builtins\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_fold_builtins (gcc::context *ctxt)\n+{\n+  return new pass_fold_builtins (ctxt);\n+}"}, {"sha": "75ab54aeda6e426577b8923b83ccfc69738d3577", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -823,24 +823,42 @@ gate_copy_prop (void)\n   return flag_tree_copy_prop != 0;\n }\n \n-struct gimple_opt_pass pass_copy_prop =\n+namespace {\n+\n+const pass_data pass_data_copy_prop =\n {\n- {\n-  GIMPLE_PASS,\n-  \"copyprop\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_copy_prop,\t\t\t/* gate */\n-  execute_copy_prop,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_COPY_PROP,\t\t\t/* tv_id */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_verify_ssa\n-    | TODO_update_ssa\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"copyprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_COPY_PROP, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_verify_ssa\n+    | TODO_update_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_copy_prop : public gimple_opt_pass\n+{\n+public:\n+  pass_copy_prop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_copy_prop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_copy_prop (ctxt_); }\n+  bool gate () { return gate_copy_prop (); }\n+  unsigned int execute () { return execute_copy_prop (); }\n+\n+}; // class pass_copy_prop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_copy_prop (gcc::context *ctxt)\n+{\n+  return new pass_copy_prop (ctxt);\n+}"}, {"sha": "990598ef29ba8e4a2c73d4a18d29cf5569bf319f", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -435,22 +435,41 @@ gate_copyrename (void)\n   return flag_tree_copyrename != 0;\n }\n \n-struct gimple_opt_pass pass_rename_ssa_copies =\n+namespace {\n+\n+const pass_data pass_data_rename_ssa_copies =\n {\n- {\n-  GIMPLE_PASS,\n-  \"copyrename\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_copyrename,\t\t\t/* gate */\n-  rename_ssa_copies,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_COPY_RENAME,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa                       /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"copyrename\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_COPY_RENAME, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_rename_ssa_copies : public gimple_opt_pass\n+{\n+public:\n+  pass_rename_ssa_copies(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_rename_ssa_copies, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_rename_ssa_copies (ctxt_); }\n+  bool gate () { return gate_copyrename (); }\n+  unsigned int execute () { return rename_ssa_copies (); }\n+\n+}; // class pass_rename_ssa_copies\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_rename_ssa_copies (gcc::context *ctxt)\n+{\n+  return new pass_rename_ssa_copies (ctxt);\n+}"}, {"sha": "4fd3cd8ad246db0747a3d673ce28d28d39d91880", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 108, "deletions": 52, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1643,63 +1643,119 @@ gate_dce (void)\n   return flag_tree_dce != 0;\n }\n \n-struct gimple_opt_pass pass_dce =\n+namespace {\n+\n+const pass_data pass_data_dce =\n {\n- {\n-  GIMPLE_PASS,\n-  \"dce\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_dce,\t\t\t\t/* gate */\n-  tree_ssa_dce,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_DCE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"dce\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_DCE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_dce_loop =\n+class pass_dce : public gimple_opt_pass\n+{\n+public:\n+  pass_dce(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_dce, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_dce (ctxt_); }\n+  bool gate () { return gate_dce (); }\n+  unsigned int execute () { return tree_ssa_dce (); }\n+\n+}; // class pass_dce\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_dce (gcc::context *ctxt)\n+{\n+  return new pass_dce (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_dce_loop =\n {\n- {\n-  GIMPLE_PASS,\n-  \"dceloop\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_dce,\t\t\t\t/* gate */\n-  tree_ssa_dce_loop,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_DCE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"dceloop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_DCE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_cd_dce =\n+class pass_dce_loop : public gimple_opt_pass\n {\n- {\n-  GIMPLE_PASS,\n-  \"cddce\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_dce,\t\t\t\t/* gate */\n-  tree_ssa_cd_dce,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_CD_DCE,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-  | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+public:\n+  pass_dce_loop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_dce_loop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_dce_loop (ctxt_); }\n+  bool gate () { return gate_dce (); }\n+  unsigned int execute () { return tree_ssa_dce_loop (); }\n+\n+}; // class pass_dce_loop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_dce_loop (gcc::context *ctxt)\n+{\n+  return new pass_dce_loop (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_cd_dce =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"cddce\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_CD_DCE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_cd_dce : public gimple_opt_pass\n+{\n+public:\n+  pass_cd_dce(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_cd_dce, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_cd_dce (ctxt_); }\n+  bool gate () { return gate_dce (); }\n+  unsigned int execute () { return tree_ssa_cd_dce (); }\n+\n+}; // class pass_cd_dce\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_cd_dce (gcc::context *ctxt)\n+{\n+  return new pass_cd_dce (ctxt);\n+}"}, {"sha": "691e6f905a221cf42f3854e9e23f9ff067a042d0", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 76, "deletions": 40, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -919,29 +919,47 @@ gate_dominator (void)\n   return flag_tree_dom != 0;\n }\n \n-struct gimple_opt_pass pass_dominator =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"dom\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_dominator,\t\t\t/* gate */\n-  tree_ssa_dominator_optimize,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SSA_DOMINATOR_OPTS,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_update_ssa\n+namespace {\n+\n+const pass_data pass_data_dominator =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"dom\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SSA_DOMINATOR_OPTS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_update_ssa\n     | TODO_verify_ssa\n-    | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n \n+class pass_dominator : public gimple_opt_pass\n+{\n+public:\n+  pass_dominator(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_dominator, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_dominator (ctxt_); }\n+  bool gate () { return gate_dominator (); }\n+  unsigned int execute () { return tree_ssa_dominator_optimize (); }\n+\n+}; // class pass_dominator\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_dominator (gcc::context *ctxt)\n+{\n+  return new pass_dominator (ctxt);\n+}\n+\n \n /* Given a conditional statement CONDSTMT, convert the\n    condition to a canonical form.  */\n@@ -3094,25 +3112,43 @@ eliminate_degenerate_phis (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_phi_only_cprop =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"phicprop\",                           /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_dominator,                       /* gate */\n-  eliminate_degenerate_phis,            /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_TREE_PHI_CPROP,                    /* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,                                    /* properties_provided */\n-  0,\t\t                        /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_verify_ssa\n+namespace {\n+\n+const pass_data pass_data_phi_only_cprop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"phicprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PHI_CPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_verify_ssa\n     | TODO_verify_stmts\n-    | TODO_update_ssa\t\t\t/* todo_flags_finish */\n- }\n+    | TODO_update_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_phi_only_cprop : public gimple_opt_pass\n+{\n+public:\n+  pass_phi_only_cprop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_phi_only_cprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_phi_only_cprop (ctxt_); }\n+  bool gate () { return gate_dominator (); }\n+  unsigned int execute () { return eliminate_degenerate_phis (); }\n+\n+}; // class pass_phi_only_cprop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_phi_only_cprop (gcc::context *ctxt)\n+{\n+  return new pass_phi_only_cprop (ctxt);\n+}"}, {"sha": "65787582a28394b1d4a6fb7e86240961ee7fd6aa", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -366,22 +366,41 @@ gate_dse (void)\n   return flag_tree_dse != 0;\n }\n \n-struct gimple_opt_pass pass_dse =\n+namespace {\n+\n+const pass_data pass_data_dse =\n {\n- {\n-  GIMPLE_PASS,\n-  \"dse\",\t\t\t/* name */\n-  OPTGROUP_NONE,                /* optinfo_flags */\n-  gate_dse,\t\t\t/* gate */\n-  tree_ssa_dse,\t\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_DSE,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"dse\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_DSE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_dse : public gimple_opt_pass\n+{\n+public:\n+  pass_dse(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_dse, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_dse (ctxt_); }\n+  bool gate () { return gate_dse (); }\n+  unsigned int execute () { return tree_ssa_dse (); }\n+\n+}; // class pass_dse\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_dse (gcc::context *ctxt)\n+{\n+  return new pass_dse (ctxt);\n+}"}, {"sha": "c3e0fac07759e1951de5cc78b97e16cc1ceb7a7d", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -3548,23 +3548,41 @@ gate_forwprop (void)\n   return flag_tree_forwprop;\n }\n \n-struct gimple_opt_pass pass_forwprop =\n+namespace {\n+\n+const pass_data pass_data_forwprop =\n {\n- {\n-  GIMPLE_PASS,\n-  \"forwprop\",\t\t\t/* name */\n-  OPTGROUP_NONE,                /* optinfo_flags */\n-  gate_forwprop,\t\t/* gate */\n-  ssa_forward_propagate_and_combine,\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_FORWPROP,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_ssa\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"forwprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_FORWPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_forwprop : public gimple_opt_pass\n+{\n+public:\n+  pass_forwprop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_forwprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_forwprop (ctxt_); }\n+  bool gate () { return gate_forwprop (); }\n+  unsigned int execute () { return ssa_forward_propagate_and_combine (); }\n+\n+}; // class pass_forwprop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_forwprop (gcc::context *ctxt)\n+{\n+  return new pass_forwprop (ctxt);\n+}"}, {"sha": "984a7634ef6dd74021e3201544895ffcb75e6989", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -648,23 +648,40 @@ gate_ifcombine (void)\n   return 1;\n }\n \n-struct gimple_opt_pass pass_tree_ifcombine =\n+namespace {\n+\n+const pass_data pass_data_tree_ifcombine =\n {\n- {\n-  GIMPLE_PASS,\n-  \"ifcombine\",\t\t\t/* name */\n-  OPTGROUP_NONE,                /* optinfo_flags */\n-  gate_ifcombine,\t\t/* gate */\n-  tree_ssa_ifcombine,\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_IFCOMBINE,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_ssa\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"ifcombine\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_IFCOMBINE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_tree_ifcombine : public gimple_opt_pass\n+{\n+public:\n+  pass_tree_ifcombine(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tree_ifcombine, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ifcombine (); }\n+  unsigned int execute () { return tree_ssa_ifcombine (); }\n+\n+}; // class pass_tree_ifcombine\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tree_ifcombine (gcc::context *ctxt)\n+{\n+  return new pass_tree_ifcombine (ctxt);\n+}"}, {"sha": "f500761c9c214cd674c9d1d083ed22a9700571f6", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -256,24 +256,41 @@ gate_ch (void)\n   return flag_tree_ch != 0;\n }\n \n-struct gimple_opt_pass pass_ch =\n+namespace {\n+\n+const pass_data pass_data_ch =\n {\n- {\n-  GIMPLE_PASS,\n-  \"ch\",\t\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_ch,\t\t\t\t/* gate */\n-  copy_loop_headers,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_CH,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_verify_ssa\n-    | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"ch\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_CH, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_verify_ssa\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_ch : public gimple_opt_pass\n+{\n+public:\n+  pass_ch(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_ch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ch (); }\n+  unsigned int execute () { return copy_loop_headers (); }\n+\n+}; // class pass_ch\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_ch (gcc::context *ctxt)\n+{\n+  return new pass_ch (ctxt);\n+}"}, {"sha": "717f54ee93286c04d979cbd865d2a2fb7b6a2b58", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 645, "deletions": 328, "changes": 973, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -41,26 +41,43 @@ gate_tree_loop (void)\n   return flag_tree_loop_optimize != 0;\n }\n \n-struct gimple_opt_pass pass_tree_loop =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"loop\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_loop,\t\t\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_LOOP,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tree_loop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"loop\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_TREE_LOOP, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n \n+class pass_tree_loop : public gimple_opt_pass\n+{\n+public:\n+  pass_tree_loop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tree_loop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_loop (); }\n+\n+}; // class pass_tree_loop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tree_loop (gcc::context *ctxt)\n+{\n+  return new pass_tree_loop (ctxt);\n+}\n+\n /* Loop optimizer initialization.  */\n \n static unsigned int\n@@ -80,26 +97,43 @@ tree_ssa_loop_init (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_tree_loop_init =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"loopinit\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  tree_ssa_loop_init,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tree_loop_init =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"loopinit\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_tree_loop_init : public gimple_opt_pass\n+{\n+public:\n+  pass_tree_loop_init(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tree_loop_init, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return tree_ssa_loop_init (); }\n+\n+}; // class pass_tree_loop_init\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tree_loop_init (gcc::context *ctxt)\n+{\n+  return new pass_tree_loop_init (ctxt);\n+}\n+\n /* Loop invariant motion pass.  */\n \n static unsigned int\n@@ -117,26 +151,45 @@ gate_tree_ssa_loop_im (void)\n   return flag_tree_loop_im != 0;\n }\n \n-struct gimple_opt_pass pass_lim =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"lim\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_ssa_loop_im,\t\t/* gate */\n-  tree_ssa_loop_im,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_LIM,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_lim =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"lim\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LIM, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_lim : public gimple_opt_pass\n+{\n+public:\n+  pass_lim(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lim, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_lim (ctxt_); }\n+  bool gate () { return gate_tree_ssa_loop_im (); }\n+  unsigned int execute () { return tree_ssa_loop_im (); }\n+\n+}; // class pass_lim\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lim (gcc::context *ctxt)\n+{\n+  return new pass_lim (ctxt);\n+}\n+\n /* Loop unswitching pass.  */\n \n static unsigned int\n@@ -154,26 +207,44 @@ gate_tree_ssa_loop_unswitch (void)\n   return flag_unswitch_loops != 0;\n }\n \n-struct gimple_opt_pass pass_tree_unswitch =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"unswitch\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_ssa_loop_unswitch,\t\t/* gate */\n-  tree_ssa_loop_unswitch,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_LOOP_UNSWITCH,\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tree_unswitch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"unswitch\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_UNSWITCH, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_tree_unswitch : public gimple_opt_pass\n+{\n+public:\n+  pass_tree_unswitch(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tree_unswitch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_ssa_loop_unswitch (); }\n+  unsigned int execute () { return tree_ssa_loop_unswitch (); }\n+\n+}; // class pass_tree_unswitch\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tree_unswitch (gcc::context *ctxt)\n+{\n+  return new pass_tree_unswitch (ctxt);\n+}\n+\n /* Predictive commoning.  */\n \n static unsigned\n@@ -191,26 +262,44 @@ gate_tree_predictive_commoning (void)\n   return flag_predictive_commoning != 0;\n }\n \n-struct gimple_opt_pass pass_predcom =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"pcom\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_predictive_commoning,\t/* gate */\n-  run_tree_predictive_commoning,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_PREDCOM,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa_only_virtuals \t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_predcom =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"pcom\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_PREDCOM, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa_only_virtuals, /* todo_flags_finish */\n };\n \n+class pass_predcom : public gimple_opt_pass\n+{\n+public:\n+  pass_predcom(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_predcom, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_predictive_commoning (); }\n+  unsigned int execute () { return run_tree_predictive_commoning (); }\n+\n+}; // class pass_predcom\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_predcom (gcc::context *ctxt)\n+{\n+  return new pass_predcom (ctxt);\n+}\n+\n /* Loop autovectorization.  */\n \n static unsigned int\n@@ -228,27 +317,44 @@ gate_tree_vectorize (void)\n   return flag_tree_vectorize;\n }\n \n-struct gimple_opt_pass pass_vectorize =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"vect\",                               /* name */\n-  OPTGROUP_LOOP\n-  | OPTGROUP_VEC,                       /* optinfo_flags */\n-  gate_tree_vectorize,                  /* gate */\n-  tree_vectorize,                       /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_TREE_VECTORIZATION,                /* tv_id */\n-  PROP_cfg | PROP_ssa,                  /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_vectorize =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"vect\", /* name */\n+  OPTGROUP_LOOP | OPTGROUP_VEC, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_VECTORIZATION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_vectorize : public gimple_opt_pass\n+{\n+public:\n+  pass_vectorize(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_vectorize, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_vectorize (); }\n+  unsigned int execute () { return tree_vectorize (); }\n+\n+}; // class pass_vectorize\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_vectorize (gcc::context *ctxt)\n+{\n+  return new pass_vectorize (ctxt);\n+}\n+\n /* GRAPHITE optimizations.  */\n \n static unsigned int\n@@ -278,46 +384,81 @@ gate_graphite_transforms (void)\n   return flag_graphite != 0;\n }\n \n-struct gimple_opt_pass pass_graphite =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"graphite0\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_graphite_transforms,\t\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_GRAPHITE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_graphite =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"graphite0\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_GRAPHITE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_graphite_transforms =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"graphite\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_graphite_transforms,\t\t/* gate */\n-  graphite_transforms,       \t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_GRAPHITE_TRANSFORMS,  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+class pass_graphite : public gimple_opt_pass\n+{\n+public:\n+  pass_graphite(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_graphite, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_graphite_transforms (); }\n+\n+}; // class pass_graphite\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_graphite (gcc::context *ctxt)\n+{\n+  return new pass_graphite (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_graphite_transforms =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"graphite\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_GRAPHITE_TRANSFORMS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_graphite_transforms : public gimple_opt_pass\n+{\n+public:\n+  pass_graphite_transforms(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_graphite_transforms, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_graphite_transforms (); }\n+  unsigned int execute () { return graphite_transforms (); }\n+\n+}; // class pass_graphite_transforms\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_graphite_transforms (gcc::context *ctxt)\n+{\n+  return new pass_graphite_transforms (ctxt);\n+}\n+\n /* Check the correctness of the data dependence analyzers.  */\n \n static unsigned int\n@@ -336,26 +477,44 @@ gate_check_data_deps (void)\n   return flag_check_data_deps != 0;\n }\n \n-struct gimple_opt_pass pass_check_data_deps =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"ckdd\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_check_data_deps,\t        \t/* gate */\n-  check_data_deps,       \t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_CHECK_DATA_DEPS,  \t        \t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                             \t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_check_data_deps =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ckdd\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_CHECK_DATA_DEPS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_check_data_deps : public gimple_opt_pass\n+{\n+public:\n+  pass_check_data_deps(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_check_data_deps, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_check_data_deps (); }\n+  unsigned int execute () { return check_data_deps (); }\n+\n+}; // class pass_check_data_deps\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_check_data_deps (gcc::context *ctxt)\n+{\n+  return new pass_check_data_deps (ctxt);\n+}\n+\n /* Canonical induction variable creation pass.  */\n \n static unsigned int\n@@ -373,26 +532,44 @@ gate_tree_ssa_loop_ivcanon (void)\n   return flag_tree_loop_ivcanon != 0;\n }\n \n-struct gimple_opt_pass pass_iv_canon =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"ivcanon\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_ssa_loop_ivcanon,\t\t/* gate */\n-  tree_ssa_loop_ivcanon,\t       \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_LOOP_IVCANON,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_iv_canon =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ivcanon\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_IVCANON, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_iv_canon : public gimple_opt_pass\n+{\n+public:\n+  pass_iv_canon(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_iv_canon, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_ssa_loop_ivcanon (); }\n+  unsigned int execute () { return tree_ssa_loop_ivcanon (); }\n+\n+}; // class pass_iv_canon\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_iv_canon (gcc::context *ctxt)\n+{\n+  return new pass_iv_canon (ctxt);\n+}\n+\n /* Propagation of constants using scev.  */\n \n static bool\n@@ -401,28 +578,45 @@ gate_scev_const_prop (void)\n   return flag_tree_scev_cprop;\n }\n \n-struct gimple_opt_pass pass_scev_cprop =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"sccp\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_scev_const_prop,\t\t\t/* gate */\n-  scev_const_prop,\t       \t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_SCEV_CONST,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_update_ssa_only_virtuals\n-\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_scev_cprop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"sccp\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_SCEV_CONST, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg\n+    | TODO_update_ssa_only_virtuals ), /* todo_flags_finish */\n };\n \n+class pass_scev_cprop : public gimple_opt_pass\n+{\n+public:\n+  pass_scev_cprop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_scev_cprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_scev_const_prop (); }\n+  unsigned int execute () { return scev_const_prop (); }\n+\n+}; // class pass_scev_cprop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_scev_cprop (gcc::context *ctxt)\n+{\n+  return new pass_scev_cprop (ctxt);\n+}\n+\n /* Record bounds on numbers of iterations of loops.  */\n \n static unsigned int\n@@ -436,26 +630,43 @@ tree_ssa_loop_bounds (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_record_bounds =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*record_bounds\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  tree_ssa_loop_bounds,\t\t       \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_LOOP_BOUNDS,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t              \t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_record_bounds =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*record_bounds\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_BOUNDS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_record_bounds : public gimple_opt_pass\n+{\n+public:\n+  pass_record_bounds(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_record_bounds, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return tree_ssa_loop_bounds (); }\n+\n+}; // class pass_record_bounds\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_record_bounds (gcc::context *ctxt)\n+{\n+  return new pass_record_bounds (ctxt);\n+}\n+\n /* Complete unrolling of loops.  */\n \n static unsigned int\n@@ -475,26 +686,44 @@ gate_tree_complete_unroll (void)\n   return true;\n }\n \n-struct gimple_opt_pass pass_complete_unroll =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"cunroll\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_complete_unroll,\t\t/* gate */\n-  tree_complete_unroll,\t\t       \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_COMPLETE_UNROLL,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_complete_unroll =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"cunroll\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_COMPLETE_UNROLL, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_complete_unroll : public gimple_opt_pass\n+{\n+public:\n+  pass_complete_unroll(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_complete_unroll, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_complete_unroll (); }\n+  unsigned int execute () { return tree_complete_unroll (); }\n+\n+}; // class pass_complete_unroll\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_complete_unroll (gcc::context *ctxt)\n+{\n+  return new pass_complete_unroll (ctxt);\n+}\n+\n /* Complete unrolling of inner loops.  */\n \n static unsigned int\n@@ -522,26 +751,44 @@ gate_tree_complete_unroll_inner (void)\n   return optimize >= 2;\n }\n \n-struct gimple_opt_pass pass_complete_unrolli =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"cunrolli\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_complete_unroll_inner,\t/* gate */\n-  tree_complete_unroll_inner,\t       \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_COMPLETE_UNROLL,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_complete_unrolli =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"cunrolli\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_COMPLETE_UNROLL, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n };\n \n+class pass_complete_unrolli : public gimple_opt_pass\n+{\n+public:\n+  pass_complete_unrolli(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_complete_unrolli, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_complete_unroll_inner (); }\n+  unsigned int execute () { return tree_complete_unroll_inner (); }\n+\n+}; // class pass_complete_unrolli\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_complete_unrolli (gcc::context *ctxt)\n+{\n+  return new pass_complete_unrolli (ctxt);\n+}\n+\n /* Parallelization.  */\n \n static bool\n@@ -561,26 +808,44 @@ tree_parallelize_loops (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_parallelize_loops =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"parloops\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_parallelize_loops,\t\t/* gate */\n-  tree_parallelize_loops,      \t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PARALLELIZE_LOOPS,  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_parallelize_loops =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"parloops\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PARALLELIZE_LOOPS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n };\n \n+class pass_parallelize_loops : public gimple_opt_pass\n+{\n+public:\n+  pass_parallelize_loops(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_parallelize_loops, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_parallelize_loops (); }\n+  unsigned int execute () { return tree_parallelize_loops (); }\n+\n+}; // class pass_parallelize_loops\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_parallelize_loops (gcc::context *ctxt)\n+{\n+  return new pass_parallelize_loops (ctxt);\n+}\n+\n /* Prefetching.  */\n \n static unsigned int\n@@ -598,26 +863,44 @@ gate_tree_ssa_loop_prefetch (void)\n   return flag_prefetch_loop_arrays > 0;\n }\n \n-struct gimple_opt_pass pass_loop_prefetch =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"aprefetch\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_ssa_loop_prefetch,\t\t/* gate */\n-  tree_ssa_loop_prefetch,\t       \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PREFETCH,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_loop_prefetch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"aprefetch\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PREFETCH, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_loop_prefetch : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_prefetch(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_loop_prefetch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_ssa_loop_prefetch (); }\n+  unsigned int execute () { return tree_ssa_loop_prefetch (); }\n+\n+}; // class pass_loop_prefetch\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_loop_prefetch (gcc::context *ctxt)\n+{\n+  return new pass_loop_prefetch (ctxt);\n+}\n+\n /* Induction variable optimizations.  */\n \n static unsigned int\n@@ -636,26 +919,44 @@ gate_tree_ssa_loop_ivopts (void)\n   return flag_ivopts != 0;\n }\n \n-struct gimple_opt_pass pass_iv_optimize =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"ivopts\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  gate_tree_ssa_loop_ivopts,\t\t/* gate */\n-  tree_ssa_loop_ivopts,\t\t       \t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_LOOP_IVOPTS,\t  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_iv_optimize =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ivopts\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_IVOPTS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n };\n \n+class pass_iv_optimize : public gimple_opt_pass\n+{\n+public:\n+  pass_iv_optimize(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_iv_optimize, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_ssa_loop_ivopts (); }\n+  unsigned int execute () { return tree_ssa_loop_ivopts (); }\n+\n+}; // class pass_iv_optimize\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_iv_optimize (gcc::context *ctxt)\n+{\n+  return new pass_iv_optimize (ctxt);\n+}\n+\n /* Loop optimizer finalization.  */\n \n static unsigned int\n@@ -667,23 +968,39 @@ tree_ssa_loop_done (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_tree_loop_done =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"loopdone\",\t\t\t\t/* name */\n-  OPTGROUP_LOOP,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  tree_ssa_loop_done,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_tree_loop_done =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"loopdone\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_tree_loop_done : public gimple_opt_pass\n+{\n+public:\n+  pass_tree_loop_done(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tree_loop_done, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return tree_ssa_loop_done (); }\n+\n+}; // class pass_tree_loop_done\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tree_loop_done (gcc::context *ctxt)\n+{\n+  return new pass_tree_loop_done (ctxt);\n+}"}, {"sha": "d1691478c4bf0c874a9b52866ad10316a3c4a736", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 143, "deletions": 72, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -636,27 +636,45 @@ execute_cse_reciprocals (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_cse_reciprocals =\n+namespace {\n+\n+const pass_data pass_data_cse_reciprocals =\n {\n- {\n-  GIMPLE_PASS,\n-  \"recip\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_cse_reciprocals,\t\t\t/* gate */\n-  execute_cse_reciprocals,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa | TODO_verify_ssa\n-    | TODO_verify_stmts                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"recip\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n };\n \n+class pass_cse_reciprocals : public gimple_opt_pass\n+{\n+public:\n+  pass_cse_reciprocals(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_cse_reciprocals, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_cse_reciprocals (); }\n+  unsigned int execute () { return execute_cse_reciprocals (); }\n+\n+}; // class pass_cse_reciprocals\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_cse_reciprocals (gcc::context *ctxt)\n+{\n+  return new pass_cse_reciprocals (ctxt);\n+}\n+\n /* Records an occurrence at statement USE_STMT in the vector of trees\n    STMTS if it is dominated by *TOP_BB or dominates it or this basic block\n    is not yet initialized.  Returns true if the occurrence was pushed on\n@@ -1535,27 +1553,45 @@ gate_cse_sincos (void)\n   return optimize;\n }\n \n-struct gimple_opt_pass pass_cse_sincos =\n+namespace {\n+\n+const pass_data pass_data_cse_sincos =\n {\n- {\n-  GIMPLE_PASS,\n-  \"sincos\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_cse_sincos,\t\t\t/* gate */\n-  execute_cse_sincos,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa | TODO_verify_ssa\n-    | TODO_verify_stmts                 /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"sincos\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n };\n \n+class pass_cse_sincos : public gimple_opt_pass\n+{\n+public:\n+  pass_cse_sincos(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_cse_sincos, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_cse_sincos (); }\n+  unsigned int execute () { return execute_cse_sincos (); }\n+\n+}; // class pass_cse_sincos\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_cse_sincos (gcc::context *ctxt)\n+{\n+  return new pass_cse_sincos (ctxt);\n+}\n+\n /* A symbolic number is used to detect byte permutation and selection\n    patterns.  Therefore the field N contains an artificial number\n    consisting of byte size markers:\n@@ -2008,26 +2044,44 @@ gate_optimize_bswap (void)\n   return flag_expensive_optimizations && optimize;\n }\n \n-struct gimple_opt_pass pass_optimize_bswap =\n+namespace {\n+\n+const pass_data pass_data_optimize_bswap =\n {\n- {\n-  GIMPLE_PASS,\n-  \"bswap\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_optimize_bswap,                  /* gate */\n-  execute_optimize_bswap,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"bswap\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_optimize_bswap : public gimple_opt_pass\n+{\n+public:\n+  pass_optimize_bswap(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_optimize_bswap, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_optimize_bswap (); }\n+  unsigned int execute () { return execute_optimize_bswap (); }\n+\n+}; // class pass_optimize_bswap\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_optimize_bswap (gcc::context *ctxt)\n+{\n+  return new pass_optimize_bswap (ctxt);\n+}\n+\n /* Return true if stmt is a type conversion operation that can be stripped\n    when used in a widening multiply operation.  */\n static bool\n@@ -2795,24 +2849,41 @@ gate_optimize_widening_mul (void)\n   return flag_expensive_optimizations && optimize;\n }\n \n-struct gimple_opt_pass pass_optimize_widening_mul =\n+namespace {\n+\n+const pass_data pass_data_optimize_widening_mul =\n {\n- {\n-  GIMPLE_PASS,\n-  \"widening_mul\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_optimize_widening_mul,\t\t/* gate */\n-  execute_optimize_widening_mul,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-  | TODO_verify_stmts\n-  | TODO_update_ssa                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"widening_mul\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_verify_stmts\n+    | TODO_update_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_optimize_widening_mul : public gimple_opt_pass\n+{\n+public:\n+  pass_optimize_widening_mul(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_optimize_widening_mul, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_optimize_widening_mul (); }\n+  unsigned int execute () { return execute_optimize_widening_mul (); }\n+\n+}; // class pass_optimize_widening_mul\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_optimize_widening_mul (gcc::context *ctxt)\n+{\n+  return new pass_optimize_widening_mul (ctxt);\n+}"}, {"sha": "ddcd040ba7c3e2edf326447f9b439986ed9782a1", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 73, "deletions": 38, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2015,52 +2015,87 @@ gate_phiopt (void)\n   return 1;\n }\n \n-struct gimple_opt_pass pass_phiopt =\n+namespace {\n+\n+const pass_data pass_data_phiopt =\n {\n- {\n-  GIMPLE_PASS,\n-  \"phiopt\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_phiopt,\t\t\t\t/* gate */\n-  tree_ssa_phiopt,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PHIOPT,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-    | TODO_verify_flow\n-    | TODO_verify_stmts\t \t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"phiopt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PHIOPT, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_verify_flow\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n };\n \n+class pass_phiopt : public gimple_opt_pass\n+{\n+public:\n+  pass_phiopt(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_phiopt, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_phiopt (ctxt_); }\n+  bool gate () { return gate_phiopt (); }\n+  unsigned int execute () { return tree_ssa_phiopt (); }\n+\n+}; // class pass_phiopt\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_phiopt (gcc::context *ctxt)\n+{\n+  return new pass_phiopt (ctxt);\n+}\n+\n static bool\n gate_cselim (void)\n {\n   return flag_tree_cselim;\n }\n \n-struct gimple_opt_pass pass_cselim =\n+namespace {\n+\n+const pass_data pass_data_cselim =\n {\n- {\n-  GIMPLE_PASS,\n-  \"cselim\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_cselim,\t\t\t\t/* gate */\n-  tree_ssa_cs_elim,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PHIOPT,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-    | TODO_verify_flow\n-    | TODO_verify_stmts\t \t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"cselim\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PHIOPT, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_verify_flow\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n };\n+\n+class pass_cselim : public gimple_opt_pass\n+{\n+public:\n+  pass_cselim(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_cselim, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_cselim (); }\n+  unsigned int execute () { return tree_ssa_cs_elim (); }\n+\n+}; // class pass_cselim\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_cselim (gcc::context *ctxt)\n+{\n+  return new pass_cselim (ctxt);\n+}"}, {"sha": "1257334f51b9d051a84d6614c27ed150cd53984e", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -394,23 +394,40 @@ gate_phiprop (void)\n   return flag_tree_phiprop;\n }\n \n-struct gimple_opt_pass pass_phiprop =\n+namespace {\n+\n+const pass_data pass_data_phiprop =\n {\n- {\n-  GIMPLE_PASS,\n-  \"phiprop\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_phiprop,\t\t\t/* gate */\n-  tree_ssa_phiprop,\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_PHIPROP,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-  | TODO_verify_ssa\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"phiprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PHIPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_phiprop : public gimple_opt_pass\n+{\n+public:\n+  pass_phiprop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_phiprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_phiprop (); }\n+  unsigned int execute () { return tree_ssa_phiprop (); }\n+\n+}; // class pass_phiprop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_phiprop (gcc::context *ctxt)\n+{\n+  return new pass_phiprop (ctxt);\n+}"}, {"sha": "f6928a8c0b3175e923f7a078fde6b8cf78daa04f", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 71, "deletions": 35, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -4786,27 +4786,44 @@ gate_pre (void)\n   return flag_tree_pre != 0;\n }\n \n-struct gimple_opt_pass pass_pre =\n+namespace {\n+\n+const pass_data pass_data_pre =\n {\n- {\n-  GIMPLE_PASS,\n-  \"pre\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_pre,\t\t\t\t/* gate */\n-  do_pre,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PRE,\t\t\t\t/* tv_id */\n-  PROP_no_crit_edges | PROP_cfg\n-    | PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  TODO_rebuild_alias,\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"pre\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PRE, /* tv_id */\n+  ( PROP_no_crit_edges | PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  TODO_rebuild_alias, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n \n+class pass_pre : public gimple_opt_pass\n+{\n+public:\n+  pass_pre(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_pre, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_pre (); }\n+  unsigned int execute () { return do_pre (); }\n+\n+}; // class pass_pre\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_pre (gcc::context *ctxt)\n+{\n+  return new pass_pre (ctxt);\n+}\n+\n \n /* Gate and execute functions for FRE.  */\n \n@@ -4839,22 +4856,41 @@ gate_fre (void)\n   return flag_tree_fre != 0;\n }\n \n-struct gimple_opt_pass pass_fre =\n+namespace {\n+\n+const pass_data pass_data_fre =\n {\n- {\n-  GIMPLE_PASS,\n-  \"fre\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_fre,\t\t\t\t/* gate */\n-  execute_fre,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_FRE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"fre\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_FRE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_fre : public gimple_opt_pass\n+{\n+public:\n+  pass_fre(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_fre, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_fre (ctxt_); }\n+  bool gate () { return gate_fre (); }\n+  unsigned int execute () { return execute_fre (); }\n+\n+}; // class pass_fre\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_fre (gcc::context *ctxt)\n+{\n+  return new pass_fre (ctxt);\n+}"}, {"sha": "7e1d8c77a3f991e34ea3dcf8b9b7cf52efeccf72", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -4450,24 +4450,43 @@ gate_tree_ssa_reassoc (void)\n   return flag_tree_reassoc != 0;\n }\n \n-struct gimple_opt_pass pass_reassoc =\n+namespace {\n+\n+const pass_data pass_data_reassoc =\n {\n- {\n-  GIMPLE_PASS,\n-  \"reassoc\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tree_ssa_reassoc,\t\t/* gate */\n-  execute_reassoc,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_REASSOC,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\n-  | TODO_update_ssa_only_virtuals\n-  | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"reassoc\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_REASSOC, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa\n+    | TODO_update_ssa_only_virtuals\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_reassoc : public gimple_opt_pass\n+{\n+public:\n+  pass_reassoc(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_reassoc, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_reassoc (ctxt_); }\n+  bool gate () { return gate_tree_ssa_reassoc (); }\n+  unsigned int execute () { return execute_reassoc (); }\n+\n+}; // class pass_reassoc\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_reassoc (gcc::context *ctxt)\n+{\n+  return new pass_reassoc (ctxt);\n+}"}, {"sha": "e8540e80534d06c6e7a3819ee0c9433370c3278d", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -586,25 +586,41 @@ gate_sink (void)\n   return flag_tree_sink != 0;\n }\n \n-struct gimple_opt_pass pass_sink_code =\n+namespace {\n+\n+const pass_data pass_data_sink_code =\n {\n- {\n-  GIMPLE_PASS,\n-  \"sink\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_sink,\t\t\t\t/* gate */\n-  do_sink,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SINK,\t\t\t\t/* tv_id */\n-  PROP_no_crit_edges | PROP_cfg\n-    | PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\n-    | TODO_verify_ssa\n-    | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"sink\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SINK, /* tv_id */\n+  ( PROP_no_crit_edges | PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_sink_code : public gimple_opt_pass\n+{\n+public:\n+  pass_sink_code(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_sink_code, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_sink (); }\n+  unsigned int execute () { return do_sink (); }\n+\n+}; // class pass_sink_code\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_sink_code (gcc::context *ctxt)\n+{\n+  return new pass_sink_code (ctxt);\n+}"}, {"sha": "75d27f1989badcedeafc4c2d3102089dce25978b", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2065,22 +2065,40 @@ gate_strlen (void)\n   return flag_optimize_strlen != 0;\n }\n \n-struct gimple_opt_pass pass_strlen =\n+namespace {\n+\n+const pass_data pass_data_strlen =\n {\n- {\n-  GIMPLE_PASS,\n-  \"strlen\",\t\t\t/* name */\n-  OPTGROUP_NONE,                /* optinfo_flags */\n-  gate_strlen,\t\t\t/* gate */\n-  tree_ssa_strlen,\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_STRLEN,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"strlen\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_STRLEN, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_strlen : public gimple_opt_pass\n+{\n+public:\n+  pass_strlen(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_strlen, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_strlen (); }\n+  unsigned int execute () { return tree_ssa_strlen (); }\n+\n+}; // class pass_strlen\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_strlen (gcc::context *ctxt)\n+{\n+  return new pass_strlen (ctxt);\n+}"}, {"sha": "a29db7f4df4717497262d776de196d5671b410d8", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 106, "deletions": 54, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -6960,49 +6960,83 @@ gate_tree_pta (void)\n /* A dummy pass to cause points-to information to be computed via\n    TODO_rebuild_alias.  */\n \n-struct gimple_opt_pass pass_build_alias =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"alias\",\t\t    /* name */\n-  OPTGROUP_NONE,            /* optinfo_flags */\n-  gate_tree_pta,\t    /* gate */\n-  NULL,                     /* execute */\n-  NULL,                     /* sub */\n-  NULL,                     /* next */\n-  0,                        /* static_pass_number */\n-  TV_NONE,                  /* tv_id */\n-  PROP_cfg | PROP_ssa,      /* properties_required */\n-  0,\t\t\t    /* properties_provided */\n-  0,                        /* properties_destroyed */\n-  0,                        /* todo_flags_start */\n-  TODO_rebuild_alias        /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_build_alias =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"alias\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_rebuild_alias, /* todo_flags_finish */\n };\n \n+class pass_build_alias : public gimple_opt_pass\n+{\n+public:\n+  pass_build_alias(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_build_alias, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_pta (); }\n+\n+}; // class pass_build_alias\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_build_alias (gcc::context *ctxt)\n+{\n+  return new pass_build_alias (ctxt);\n+}\n+\n /* A dummy pass to cause points-to information to be computed via\n    TODO_rebuild_alias.  */\n \n-struct gimple_opt_pass pass_build_ealias =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"ealias\",\t\t    /* name */\n-  OPTGROUP_NONE,            /* optinfo_flags */\n-  gate_tree_pta,\t    /* gate */\n-  NULL,                     /* execute */\n-  NULL,                     /* sub */\n-  NULL,                     /* next */\n-  0,                        /* static_pass_number */\n-  TV_NONE,                  /* tv_id */\n-  PROP_cfg | PROP_ssa,      /* properties_required */\n-  0,\t\t\t    /* properties_provided */\n-  0,                        /* properties_destroyed */\n-  0,                        /* todo_flags_start */\n-  TODO_rebuild_alias        /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_build_ealias =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ealias\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_rebuild_alias, /* todo_flags_finish */\n };\n \n+class pass_build_ealias : public gimple_opt_pass\n+{\n+public:\n+  pass_build_ealias(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_build_ealias, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_pta (); }\n+\n+}; // class pass_build_ealias\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_build_ealias (gcc::context *ctxt)\n+{\n+  return new pass_build_ealias (ctxt);\n+}\n+\n \n /* Return true if we should execute IPA PTA.  */\n static bool\n@@ -7359,22 +7393,40 @@ ipa_pta_execute (void)\n   return 0;\n }\n \n-struct simple_ipa_opt_pass pass_ipa_pta =\n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"pta\",\t\t                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_ipa_pta,\t\t\t/* gate */\n-  ipa_pta_execute,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_PTA,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa                       /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_ipa_pta =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"pta\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_PTA, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n };\n+\n+class pass_ipa_pta : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_pta(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_pta, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ipa_pta (); }\n+  unsigned int execute () { return ipa_pta_execute (); }\n+\n+}; // class pass_ipa_pta\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_pta (gcc::context *ctxt)\n+{\n+  return new pass_ipa_pta (ctxt);\n+}"}, {"sha": "837c4eaf066f94f64a5b38ad1978158a0bfa8165", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -585,22 +585,41 @@ gate_uncprop (void)\n   return flag_tree_dom != 0;\n }\n \n-struct gimple_opt_pass pass_uncprop =\n+namespace {\n+\n+const pass_data pass_data_uncprop =\n {\n- {\n-  GIMPLE_PASS,\n-  \"uncprop\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_uncprop,\t\t\t\t/* gate */\n-  tree_ssa_uncprop,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SSA_UNCPROP,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"uncprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SSA_UNCPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_uncprop : public gimple_opt_pass\n+{\n+public:\n+  pass_uncprop(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_uncprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_uncprop (ctxt_); }\n+  bool gate () { return gate_uncprop (); }\n+  unsigned int execute () { return tree_ssa_uncprop (); }\n+\n+}; // class pass_uncprop\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_uncprop (gcc::context *ctxt)\n+{\n+  return new pass_uncprop (ctxt);\n+}"}, {"sha": "6d2d768a24310a5874e49f650d52a7f4ea965726", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -2046,22 +2046,41 @@ gate_warn_uninitialized (void)\n   return warn_uninitialized != 0;\n }\n \n-struct gimple_opt_pass pass_late_warn_uninitialized =\n+namespace {\n+\n+const pass_data pass_data_late_warn_uninitialized =\n {\n- {\n-  GIMPLE_PASS,\n-  \"uninit\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_warn_uninitialized,\t\t/* gate */\n-  execute_late_warn_uninitialized,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,     \t        \t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"uninit\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_late_warn_uninitialized : public gimple_opt_pass\n+{\n+public:\n+  pass_late_warn_uninitialized(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_late_warn_uninitialized, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_late_warn_uninitialized (ctxt_); }\n+  bool gate () { return gate_warn_uninitialized (); }\n+  unsigned int execute () { return execute_late_warn_uninitialized (); }\n+\n+}; // class pass_late_warn_uninitialized\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_late_warn_uninitialized (gcc::context *ctxt)\n+{\n+  return new pass_late_warn_uninitialized (ctxt);\n+}"}, {"sha": "83a265c43ac8c78c2dd0c81f9349686cb1688db0", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 102, "deletions": 51, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1088,26 +1088,43 @@ execute_init_datastructures (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_init_datastructures =\n+namespace {\n+\n+const pass_data pass_data_init_datastructures =\n {\n- {\n-  GIMPLE_PASS,\n-  \"*init_datastructures\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_init_datastructures,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"*init_datastructures\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_init_datastructures : public gimple_opt_pass\n+{\n+public:\n+  pass_init_datastructures(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_init_datastructures, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return execute_init_datastructures (); }\n+\n+}; // class pass_init_datastructures\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_init_datastructures (gcc::context *ctxt)\n+{\n+  return new pass_init_datastructures (ctxt);\n+}\n+\n /* Deallocate memory associated with SSA data structures for FNDECL.  */\n \n void\n@@ -1698,26 +1715,44 @@ gate_warn_uninitialized (void)\n   return warn_uninitialized != 0;\n }\n \n-struct gimple_opt_pass pass_early_warn_uninitialized =\n+namespace {\n+\n+const pass_data pass_data_early_warn_uninitialized =\n {\n- {\n-  GIMPLE_PASS,\n-  \"*early_warn_uninitialized\",\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_warn_uninitialized,\t\t/* gate */\n-  execute_early_warn_uninitialized,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_UNINIT,\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"*early_warn_uninitialized\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_UNINIT, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_early_warn_uninitialized : public gimple_opt_pass\n+{\n+public:\n+  pass_early_warn_uninitialized(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_early_warn_uninitialized, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_warn_uninitialized (); }\n+  unsigned int execute () { return execute_early_warn_uninitialized (); }\n+\n+}; // class pass_early_warn_uninitialized\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_early_warn_uninitialized (gcc::context *ctxt)\n+{\n+  return new pass_early_warn_uninitialized (ctxt);\n+}\n+\n \n /* If necessary, rewrite the base of the reference tree *TP from\n    a MEM_REF to a plain or converted symbol.  */\n@@ -2130,22 +2165,38 @@ execute_update_addresses_taken (void)\n   timevar_pop (TV_ADDRESS_TAKEN);\n }\n \n-struct gimple_opt_pass pass_update_address_taken =\n+namespace {\n+\n+const pass_data pass_data_update_address_taken =\n {\n- {\n-  GIMPLE_PASS,\n-  \"addressables\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_ADDRESS_TAKEN,\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_address_taken             /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"addressables\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  false, /* has_execute */\n+  TV_ADDRESS_TAKEN, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_address_taken, /* todo_flags_finish */\n };\n+\n+class pass_update_address_taken : public gimple_opt_pass\n+{\n+public:\n+  pass_update_address_taken(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_update_address_taken, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+\n+}; // class pass_update_address_taken\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_update_address_taken (gcc::context *ctxt)\n+{\n+  return new pass_update_address_taken (ctxt);\n+}"}, {"sha": "a6af3da192cfd67c7c2ffafeb4363ecc008229de", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -440,22 +440,39 @@ release_dead_ssa_names (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_release_ssa_names =\n+namespace {\n+\n+const pass_data pass_data_release_ssa_names =\n {\n- {\n-  GIMPLE_PASS,\n-  \"release_ssa\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  release_dead_ssa_names,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SSA_OTHER,\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  TODO_remove_unused_locals,\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"release_ssa\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SSA_OTHER, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  TODO_remove_unused_locals, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_release_ssa_names : public gimple_opt_pass\n+{\n+public:\n+  pass_release_ssa_names(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_release_ssa_names, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return release_dead_ssa_names (); }\n+\n+}; // class pass_release_ssa_names\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_release_ssa_names (gcc::context *ctxt)\n+{\n+  return new pass_release_ssa_names (ctxt);\n+}"}, {"sha": "50592c03a365b65af934bc5610bf390fc6d4831e", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -985,22 +985,40 @@ execute_optimize_stdarg (void)\n }\n \n \n-struct gimple_opt_pass pass_stdarg =\n+namespace {\n+\n+const pass_data pass_data_stdarg =\n {\n- {\n-  GIMPLE_PASS,\n-  \"stdarg\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_optimize_stdarg,\t\t\t/* gate */\n-  execute_optimize_stdarg,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0             \t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"stdarg\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_stdarg : public gimple_opt_pass\n+{\n+public:\n+  pass_stdarg(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_stdarg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_optimize_stdarg (); }\n+  unsigned int execute () { return execute_optimize_stdarg (); }\n+\n+}; // class pass_stdarg\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_stdarg (gcc::context *ctxt)\n+{\n+  return new pass_stdarg (ctxt);\n+}"}, {"sha": "0d128981e38d8ba753c0ccdccbd28f2f81b0bc91", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1463,25 +1463,42 @@ switchconv_gate (void)\n   return flag_tree_switch_conversion != 0;\n }\n \n-struct gimple_opt_pass pass_convert_switch =\n+namespace {\n+\n+const pass_data pass_data_convert_switch =\n {\n- {\n-  GIMPLE_PASS,\n-  \"switchconv\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  switchconv_gate,\t\t\t/* gate */\n-  do_switchconv,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SWITCH_CONVERSION,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa \n-  | TODO_verify_ssa\n-  | TODO_verify_stmts\n-  | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"switchconv\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SWITCH_CONVERSION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_convert_switch : public gimple_opt_pass\n+{\n+public:\n+  pass_convert_switch(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_convert_switch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return switchconv_gate (); }\n+  unsigned int execute () { return do_switchconv (); }\n+\n+}; // class pass_convert_switch\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_convert_switch (gcc::context *ctxt)\n+{\n+  return new pass_convert_switch (ctxt);\n+}"}, {"sha": "8cd7255e49b3847328368544662b0b8a8200a522", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 71, "deletions": 34, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1048,42 +1048,79 @@ execute_tail_calls (void)\n   return tree_optimize_tail_calls_1 (true);\n }\n \n-struct gimple_opt_pass pass_tail_recursion =\n+namespace {\n+\n+const pass_data pass_data_tail_recursion =\n {\n- {\n-  GIMPLE_PASS,\n-  \"tailr\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tail_calls,\t\t\t/* gate */\n-  execute_tail_recursion,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"tailr\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_tail_calls =\n+class pass_tail_recursion : public gimple_opt_pass\n+{\n+public:\n+  pass_tail_recursion(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tail_recursion, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_tail_recursion (ctxt_); }\n+  bool gate () { return gate_tail_calls (); }\n+  unsigned int execute () { return execute_tail_recursion (); }\n+\n+}; // class pass_tail_recursion\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tail_recursion (gcc::context *ctxt)\n+{\n+  return new pass_tail_recursion (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_tail_calls =\n {\n- {\n-  GIMPLE_PASS,\n-  \"tailc\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_tail_calls,\t\t\t/* gate */\n-  execute_tail_calls,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_ssa\t                /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"tailc\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n };\n+\n+class pass_tail_calls : public gimple_opt_pass\n+{\n+public:\n+  pass_tail_calls(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tail_calls, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tail_calls (); }\n+  unsigned int execute () { return execute_tail_calls (); }\n+\n+}; // class pass_tail_calls\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tail_calls (gcc::context *ctxt)\n+{\n+  return new pass_tail_calls (ctxt);\n+}"}, {"sha": "b2a6944687c144619bee7deb8d97fb285e38dc21", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 76, "deletions": 40, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -1454,50 +1454,86 @@ expand_vector_operations (void)\n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }\n \n-struct gimple_opt_pass pass_lower_vector =\n+namespace {\n+\n+const pass_data pass_data_lower_vector =\n {\n- {\n-  GIMPLE_PASS,\n-  \"veclower\",\t\t\t\t/* name */\n-  OPTGROUP_VEC,                         /* optinfo_flags */\n-  gate_expand_vector_operations_ssa,    /* gate */\n-  expand_vector_operations,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  PROP_gimple_lvec,\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\t                /* todo_flags_finish */\n-    | TODO_verify_ssa\n-    | TODO_verify_stmts | TODO_verify_flow\n-    | TODO_cleanup_cfg\n- }\n+  GIMPLE_PASS, /* type */\n+  \"veclower\", /* name */\n+  OPTGROUP_VEC, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  PROP_gimple_lvec, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts\n+    | TODO_verify_flow\n+    | TODO_cleanup_cfg ), /* todo_flags_finish */\n };\n \n-struct gimple_opt_pass pass_lower_vector_ssa =\n+class pass_lower_vector : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_vector(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_vector, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_expand_vector_operations_ssa (); }\n+  unsigned int execute () { return expand_vector_operations (); }\n+\n+}; // class pass_lower_vector\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_vector (gcc::context *ctxt)\n+{\n+  return new pass_lower_vector (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_lower_vector_ssa =\n {\n- {\n-  GIMPLE_PASS,\n-  \"veclower2\",\t\t\t\t/* name */\n-  OPTGROUP_VEC,                         /* optinfo_flags */\n-  0,\t                                /* gate */\n-  expand_vector_operations,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  PROP_gimple_lvec,\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa\t                /* todo_flags_finish */\n-    | TODO_verify_ssa\n-    | TODO_verify_stmts | TODO_verify_flow\n-    | TODO_cleanup_cfg\n- }\n+  GIMPLE_PASS, /* type */\n+  \"veclower2\", /* name */\n+  OPTGROUP_VEC, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  PROP_gimple_lvec, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts\n+    | TODO_verify_flow\n+    | TODO_cleanup_cfg ), /* todo_flags_finish */\n };\n \n+class pass_lower_vector_ssa : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_vector_ssa(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_lower_vector_ssa, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_lower_vector_ssa (ctxt_); }\n+  unsigned int execute () { return expand_vector_operations (); }\n+\n+}; // class pass_lower_vector_ssa\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_vector_ssa (gcc::context *ctxt)\n+{\n+  return new pass_lower_vector_ssa (ctxt);\n+}\n+\n #include \"gt-tree-vect-generic.h\""}, {"sha": "cfcc95d06f2cbc2373be89ba2202550b64c91be9", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -197,29 +197,45 @@ gate_vect_slp (void)\n           || flag_tree_slp_vectorize == 1);\n }\n \n-struct gimple_opt_pass pass_slp_vectorize =\n+namespace {\n+\n+const pass_data pass_data_slp_vectorize =\n {\n- {\n-  GIMPLE_PASS,\n-  \"slp\",                                /* name */\n-  OPTGROUP_LOOP\n-  | OPTGROUP_VEC,                       /* optinfo_flags */\n-  gate_vect_slp,                        /* gate */\n-  execute_vect_slp,                     /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_TREE_SLP_VECTORIZATION,            /* tv_id */\n-  PROP_ssa | PROP_cfg,                  /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_ssa\n-    | TODO_update_ssa\n-    | TODO_verify_stmts                 /* todo_flags_finish */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"slp\", /* name */\n+  OPTGROUP_LOOP | OPTGROUP_VEC, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_SLP_VECTORIZATION, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_ssa | TODO_update_ssa\n+    | TODO_verify_stmts ), /* todo_flags_finish */\n };\n \n+class pass_slp_vectorize : public gimple_opt_pass\n+{\n+public:\n+  pass_slp_vectorize(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_slp_vectorize, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_vect_slp (); }\n+  unsigned int execute () { return execute_vect_slp (); }\n+\n+}; // class pass_slp_vectorize\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_slp_vectorize (gcc::context *ctxt)\n+{\n+  return new pass_slp_vectorize (ctxt);\n+}\n+\n \n /* Increase alignment of global arrays to improve vectorization potential.\n    TODO:\n@@ -272,23 +288,40 @@ gate_increase_alignment (void)\n }\n \n \n-struct simple_ipa_opt_pass pass_ipa_increase_alignment =\n+namespace {\n+\n+const pass_data pass_data_ipa_increase_alignment =\n {\n- {\n-  SIMPLE_IPA_PASS,\n-  \"increase_alignment\",                 /* name */\n-  OPTGROUP_LOOP\n-  | OPTGROUP_VEC,                       /* optinfo_flags */\n-  gate_increase_alignment,              /* gate */\n-  increase_alignment,                   /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_IPA_OPT,                           /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n+  SIMPLE_IPA_PASS, /* type */\n+  \"increase_alignment\", /* name */\n+  OPTGROUP_LOOP | OPTGROUP_VEC, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_OPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n+\n+class pass_ipa_increase_alignment : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_increase_alignment(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_increase_alignment, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_increase_alignment (); }\n+  unsigned int execute () { return increase_alignment (); }\n+\n+}; // class pass_ipa_increase_alignment\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_increase_alignment (gcc::context *ctxt)\n+{\n+  return new pass_ipa_increase_alignment (ctxt);\n+}"}, {"sha": "ff82591f5f476b557e7b5ebec5fb34994bd4bc9f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -9584,25 +9584,43 @@ gate_vrp (void)\n   return flag_tree_vrp != 0;\n }\n \n-struct gimple_opt_pass pass_vrp =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"vrp\",\t\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_vrp,\t\t\t\t/* gate */\n-  execute_vrp,\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_VRP,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg\n-    | TODO_update_ssa\n+namespace {\n+\n+const pass_data pass_data_vrp =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"vrp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_VRP, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_update_ssa\n     | TODO_verify_ssa\n-    | TODO_verify_flow\t\t\t/* todo_flags_finish */\n- }\n+    | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_vrp : public gimple_opt_pass\n+{\n+public:\n+  pass_vrp(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_vrp, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_vrp (ctxt_); }\n+  bool gate () { return gate_vrp (); }\n+  unsigned int execute () { return execute_vrp (); }\n+\n+}; // class pass_vrp\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_vrp (gcc::context *ctxt)\n+{\n+  return new pass_vrp (ctxt);\n+}"}, {"sha": "a1c0deab21e33014ffbdef76242258fcb7ceedbc", "filename": "gcc/tree.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -5505,26 +5505,43 @@ free_lang_data (void)\n }\n \n \n-struct simple_ipa_opt_pass pass_ipa_free_lang_data =\n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"*free_lang_data\",\t\t\t/* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  free_lang_data,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_FREE_LANG_DATA,\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_ipa_free_lang_data =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"*free_lang_data\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_FREE_LANG_DATA, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n };\n \n+class pass_ipa_free_lang_data : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_free_lang_data(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_ipa_free_lang_data, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return free_lang_data (); }\n+\n+}; // class pass_ipa_free_lang_data\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_free_lang_data (gcc::context *ctxt)\n+{\n+  return new pass_ipa_free_lang_data (ctxt);\n+}\n+\n /* The backbone of is_attribute_p().  ATTR_LEN is the string length of\n    ATTR_NAME.  Also used internally by remove_attribute().  */\n bool"}, {"sha": "b9171c803aa1d8cbbb4b5264ffddf00ba08829fc", "filename": "gcc/tsan.c", "status": "modified", "additions": 71, "deletions": 34, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -733,48 +733,85 @@ tsan_finish_file (void)\n \n /* The pass descriptor.  */\n \n-struct gimple_opt_pass pass_tsan =\n+namespace {\n+\n+const pass_data pass_data_tsan =\n {\n- {\n-  GIMPLE_PASS,\n-  \"tsan\",\t\t\t\t/* name  */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  tsan_gate,\t\t\t\t/* gate  */\n-  tsan_pass,\t\t\t\t/* execute  */\n-  NULL,\t\t\t\t\t/* sub  */\n-  NULL,\t\t\t\t\t/* next  */\n-  0,\t\t\t\t\t/* static_pass_number  */\n-  TV_NONE,\t\t\t\t/* tv_id  */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required  */\n-  0,\t\t\t\t\t/* properties_provided  */\n-  0,\t\t\t\t\t/* properties_destroyed  */\n-  0,\t\t\t\t\t/* todo_flags_start  */\n-  TODO_verify_all | TODO_update_ssa\t/* todo_flags_finish  */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"tsan\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_all | TODO_update_ssa ), /* todo_flags_finish */\n };\n \n+class pass_tsan : public gimple_opt_pass\n+{\n+public:\n+  pass_tsan(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tsan, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_tsan (ctxt_); }\n+  bool gate () { return tsan_gate (); }\n+  unsigned int execute () { return tsan_pass (); }\n+\n+}; // class pass_tsan\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tsan (gcc::context *ctxt)\n+{\n+  return new pass_tsan (ctxt);\n+}\n+\n static bool\n tsan_gate_O0 (void)\n {\n   return flag_tsan != 0 && !optimize;\n }\n \n-struct gimple_opt_pass pass_tsan_O0 =\n+namespace {\n+\n+const pass_data pass_data_tsan_O0 =\n {\n- {\n-  GIMPLE_PASS,\n-  \"tsan0\",\t\t\t\t/* name  */\n-  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n-  tsan_gate_O0,\t\t\t\t/* gate  */\n-  tsan_pass,\t\t\t\t/* execute  */\n-  NULL,\t\t\t\t\t/* sub  */\n-  NULL,\t\t\t\t\t/* next  */\n-  0,\t\t\t\t\t/* static_pass_number  */\n-  TV_NONE,\t\t\t\t/* tv_id  */\n-  PROP_ssa | PROP_cfg,\t\t\t/* properties_required  */\n-  0,\t\t\t\t\t/* properties_provided  */\n-  0,\t\t\t\t\t/* properties_destroyed  */\n-  0,\t\t\t\t\t/* todo_flags_start  */\n-  TODO_verify_all | TODO_update_ssa\t/* todo_flags_finish  */\n- }\n+  GIMPLE_PASS, /* type */\n+  \"tsan0\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  ( PROP_ssa | PROP_cfg ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_all | TODO_update_ssa ), /* todo_flags_finish */\n };\n+\n+class pass_tsan_O0 : public gimple_opt_pass\n+{\n+public:\n+  pass_tsan_O0(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_tsan_O0, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return tsan_gate_O0 (); }\n+  unsigned int execute () { return tsan_pass (); }\n+\n+}; // class pass_tsan_O0\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tsan_O0 (gcc::context *ctxt)\n+{\n+  return new pass_tsan_O0 (ctxt);\n+}"}, {"sha": "d82d2621fc69ea7dbdff5b9547fe200102c46206", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -10218,23 +10218,40 @@ gate_handle_var_tracking (void)\n \n \n \n-struct rtl_opt_pass pass_variable_tracking =\n-{\n- {\n-  RTL_PASS,\n-  \"vartrack\",                           /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_var_tracking,             /* gate */\n-  variable_tracking_main,               /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_VAR_TRACKING,                      /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing\n-   | TODO_verify_flow                   /* todo_flags_finish */\n- }\n+namespace {\n+\n+const pass_data pass_data_variable_tracking =\n+{\n+  RTL_PASS, /* type */\n+  \"vartrack\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_VAR_TRACKING, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_verify_rtl_sharing | TODO_verify_flow ), /* todo_flags_finish */\n };\n+\n+class pass_variable_tracking : public rtl_opt_pass\n+{\n+public:\n+  pass_variable_tracking(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_variable_tracking, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_var_tracking (); }\n+  unsigned int execute () { return variable_tracking_main (); }\n+\n+}; // class pass_variable_tracking\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_variable_tracking (gcc::context *ctxt)\n+{\n+  return new pass_variable_tracking (ctxt);\n+}"}, {"sha": "90c18a81401beabde3811f2bd5d97ef9c97b7010", "filename": "gcc/web.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a4cd485d3731293a42b7b324a7432a4af13443/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=27a4cd485d3731293a42b7b324a7432a4af13443", "patch": "@@ -449,22 +449,40 @@ web_main (void)\n   return 0;\n }\n \f\n-struct rtl_opt_pass pass_web =\n+namespace {\n+\n+const pass_data pass_data_web =\n {\n- {\n-  RTL_PASS,\n-  \"web\",                                /* name */\n-  OPTGROUP_NONE,                        /* optinfo_flags */\n-  gate_handle_web,                      /* gate */\n-  web_main,\t\t                /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_WEB,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing  /* todo_flags_finish */\n- }\n+  RTL_PASS, /* type */\n+  \"web\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_WEB, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_finish | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n };\n+\n+class pass_web : public rtl_opt_pass\n+{\n+public:\n+  pass_web(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_web, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_handle_web (); }\n+  unsigned int execute () { return web_main (); }\n+\n+}; // class pass_web\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_web (gcc::context *ctxt)\n+{\n+  return new pass_web (ctxt);\n+}"}]}