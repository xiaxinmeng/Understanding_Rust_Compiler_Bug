{"sha": "80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBkZDEzZjVjM2JkYzc4OTllZTZlODYzZTA1YjI1NDgxNWVjMGNlZg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-17T15:49:21Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-22T12:11:44Z"}, "message": "Add relational support to range-op.\n\nThis patch integrates relations with range-op functionality so that any\nknown relations can be used to help reduce or resolve ranges.\nInitially handle  EQ_EXPR, NE_EXPR, LE_EXPR, LT_EXPR, GT_EXPR and GE_EXPR.\n\n\t* range-op.cc (range_operator::wi_fold): Apply relation effect.\n\t(range_operator::fold_range): Adjust and apply relation effect.\n\t(*::fold_range): Add relation parameters.\n\t(*::op1_range): Ditto.\n\t(*::op2_range): Ditto.\n\t(range_operator::lhs_op1_relation): New.\n\t(range_operator::lhs_op2_relation): New.\n\t(range_operator::op1_op2_relation): New.\n\t(range_operator::op1_op2_relation_effect): New.\n\t(relop_early_resolve): New.\n\t(operator_equal::op1_op2_relation): New.\n\t(operator_equal::fold_range): Call relop_early_resolve.\n\t(operator_not_equal::op1_op2_relation): New.\n\t(operator_not_equal::fold_range): Call relop_early_resolve.\n\t(operator_lt::op1_op2_relation): New.\n\t(operator_lt::fold_range): Call relop_early_resolve.\n\t(operator_le::op1_op2_relation): New.\n\t(operator_le::fold_range): Call relop_early_resolve.\n\t(operator_gt::op1_op2_relation): New.\n\t(operator_gt::fold_range): Call relop_early_resolve.\n\t(operator_ge::op1_op2_relation): New.\n\t(operator_ge::fold_range): Call relop_early_resolve.\n\t* range-op.h (class range_operator): Adjust parameters and methods.", "tree": {"sha": "011828c50185a5df40c282f2fa95bb154998136e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/011828c50185a5df40c282f2fa95bb154998136e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80dd13f5c3bdc7899ee6e863e05b254815ec0cef/comments", "author": null, "committer": null, "parents": [{"sha": "3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f"}], "stats": {"total": 608, "additions": 469, "deletions": 139}, "files": [{"sha": "d807693900ae52bb168d7e4d2615ad13baac29a5", "filename": "gcc/range-op.cc", "status": "modified", "additions": 448, "deletions": 136, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80dd13f5c3bdc7899ee6e863e05b254815ec0cef/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80dd13f5c3bdc7899ee6e863e05b254815ec0cef/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-walk.h\"\n #include \"tree-cfg.h\"\n #include \"wide-int.h\"\n+#include \"value-relation.h\"\n #include \"range-op.h\"\n \n // Return the upper limit for a type.\n@@ -138,7 +139,8 @@ range_operator::wi_fold (irange &r, tree type,\n bool\n range_operator::fold_range (irange &r, tree type,\n \t\t\t    const irange &lh,\n-\t\t\t    const irange &rh) const\n+\t\t\t    const irange &rh,\n+\t\t\t    relation_kind rel) const\n {\n   gcc_checking_assert (irange::supports_type_p (type));\n   if (empty_range_varying (r, type, lh, rh))\n@@ -152,6 +154,7 @@ range_operator::fold_range (irange &r, tree type,\n     {\n       wi_fold (r, type, lh.lower_bound (0), lh.upper_bound (0),\n \t       rh.lower_bound (0), rh.upper_bound (0));\n+      op1_op2_relation_effect (r, type, lh, rh, rel);\n       return true;\n     }\n \n@@ -167,8 +170,12 @@ range_operator::fold_range (irange &r, tree type,\n \twi_fold (tmp, type, lh_lb, lh_ub, rh_lb, rh_ub);\n \tr.union_ (tmp);\n \tif (r.varying_p ())\n-\t  return true;\n+\t  {\n+\t    op1_op2_relation_effect (r, type, lh, rh, rel);\n+\t    return true;\n+\t  }\n       }\n+  op1_op2_relation_effect (r, type, lh, rh, rel);\n   return true;\n }\n \n@@ -178,7 +185,8 @@ bool\n range_operator::op1_range (irange &r ATTRIBUTE_UNUSED,\n \t\t\t   tree type ATTRIBUTE_UNUSED,\n \t\t\t   const irange &lhs ATTRIBUTE_UNUSED,\n-\t\t\t   const irange &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t   const irange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return false;\n }\n@@ -189,11 +197,47 @@ bool\n range_operator::op2_range (irange &r ATTRIBUTE_UNUSED,\n \t\t\t   tree type ATTRIBUTE_UNUSED,\n \t\t\t   const irange &lhs ATTRIBUTE_UNUSED,\n-\t\t\t   const irange &op1 ATTRIBUTE_UNUSED) const\n+\t\t\t   const irange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return false;\n }\n \n+// The default relation routines return VREL_NONE.\n+\n+enum tree_code\n+range_operator::lhs_op1_relation (const irange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t  const irange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t  const irange &op2 ATTRIBUTE_UNUSED) const\n+{\n+  return VREL_NONE;\n+}\n+\n+enum tree_code\n+range_operator::lhs_op2_relation (const irange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t  const irange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t  const irange &op2 ATTRIBUTE_UNUSED) const\n+{\n+  return VREL_NONE;\n+}\n+\n+enum tree_code\n+range_operator::op1_op2_relation (const irange &lhs ATTRIBUTE_UNUSED) const\n+{\n+  return VREL_NONE;\n+}\n+\n+// Default is no relation affects the LHS.\n+\n+bool\n+range_operator::op1_op2_relation_effect (irange &lhs_range ATTRIBUTE_UNUSED,\n+\t\t\t\t       tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t       const irange &op1_range ATTRIBUTE_UNUSED,\n+\t\t\t\t       const irange &op2_range ATTRIBUTE_UNUSED,\n+\t\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n \n // Create and return a range from a pair of wide-ints that are known\n // to have overflowed (or underflowed).\n@@ -385,27 +429,82 @@ get_bool_state (irange &r, const irange &lhs, tree val_type)\n   return BRS_TRUE;\n }\n \n+// For relation opcodes, first try to see if the supplied relation\n+// forces a true or false result, and return that.\n+// Then check for undefined operands.  If none of this applies,\n+// return false.\n+\n+static inline bool\n+relop_early_resolve (irange &r, tree type, const irange &op1,\n+\t\t     const irange &op2, relation_kind rel,\n+\t\t     relation_kind my_rel)\n+{\n+  // If known relation is a complete subset of this relation, always true.\n+  if (relation_union (rel, my_rel) == my_rel)\n+    {\n+      r = range_true (type);\n+      return true;\n+    }\n+\n+  // If known relation has no subset of this relation, always false.\n+  if (relation_intersect (rel, my_rel) == VREL_EMPTY)\n+    {\n+      r = range_false (type);\n+      return true;\n+    }\n+\n+  // If either operand is undefined, return VARYING.\n+  if (empty_range_varying (r, type, op1, op2))\n+    return true;\n+\n+  return false;\n+}\n+\n \n class operator_equal : public range_operator\n {\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &val) const;\n+\t\t\t  const irange &val,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &val) const;\n+\t\t\t  const irange &val,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n } op_equal;\n \n+// Check if the LHS range indicates a relation between OP1 and OP2.\n+\n+enum tree_code\n+operator_equal::op1_op2_relation (const irange &lhs) const\n+{\n+  if (lhs.undefined_p ())\n+    return VREL_EMPTY;\n+\n+  // FALSE = op1 == op2 indicates NE_EXPR.\n+  if (lhs.zero_p ())\n+    return NE_EXPR;\n+\n+  // TRUE = op1 == op2 indicates EQ_EXPR.\n+  if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n+    return EQ_EXPR;\n+  return VREL_NONE;\n+}\n+\n+\n bool\n operator_equal::fold_range (irange &r, tree type,\n \t\t\t    const irange &op1,\n-\t\t\t    const irange &op2) const\n+\t\t\t    const irange &op2,\n+\t\t\t    relation_kind rel) const\n {\n-  if (empty_range_varying (r, type, op1, op2))\n+  if (relop_early_resolve (r, type, op1, op2, rel, EQ_EXPR))\n     return true;\n \n   // We can be sure the values are always equal or not if both ranges\n@@ -435,7 +534,8 @@ operator_equal::fold_range (irange &r, tree type,\n bool\n operator_equal::op1_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n-\t\t\t   const irange &op2) const\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -465,32 +565,55 @@ operator_equal::op1_range (irange &r, tree type,\n bool\n operator_equal::op2_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n-\t\t\t   const irange &op1) const\n+\t\t\t   const irange &op1,\n+\t\t\t   relation_kind rel) const\n {\n-  return operator_equal::op1_range (r, type, lhs, op1);\n+  return operator_equal::op1_range (r, type, lhs, op1, rel);\n }\n \n-\n class operator_not_equal : public range_operator\n {\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n } op_not_equal;\n \n+// Check if the LHS range indicates a relation between OP1 and OP2.\n+\n+enum tree_code\n+operator_not_equal::op1_op2_relation (const irange &lhs) const\n+{\n+  if (lhs.undefined_p ())\n+    return VREL_EMPTY;\n+\n+  // FALSE = op1 != op2  indicates EQ_EXPR.\n+  if (lhs.zero_p ())\n+    return EQ_EXPR;\n+\n+  // TRUE = op1 != op2  indicates NE_EXPR.\n+  if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n+    return NE_EXPR;\n+  return VREL_NONE;\n+}\n+\n bool\n operator_not_equal::fold_range (irange &r, tree type,\n \t\t\t\tconst irange &op1,\n-\t\t\t\tconst irange &op2) const\n+\t\t\t\tconst irange &op2,\n+\t\t\t\trelation_kind rel) const\n {\n-  if (empty_range_varying (r, type, op1, op2))\n+  if (relop_early_resolve (r, type, op1, op2, rel, NE_EXPR))\n     return true;\n \n   // We can be sure the values are always equal or not if both ranges\n@@ -520,7 +643,8 @@ operator_not_equal::fold_range (irange &r, tree type,\n bool\n operator_not_equal::op1_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n-\t\t\t       const irange &op2) const\n+\t\t\t       const irange &op2,\n+\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -551,9 +675,10 @@ operator_not_equal::op1_range (irange &r, tree type,\n bool\n operator_not_equal::op2_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n-\t\t\t       const irange &op1) const\n+\t\t\t       const irange &op1,\n+\t\t\t       relation_kind rel) const\n {\n-  return operator_not_equal::op1_range (r, type, lhs, op1);\n+  return operator_not_equal::op1_range (r, type, lhs, op1, rel);\n }\n \n // (X < VAL) produces the range of [MIN, VAL - 1].\n@@ -607,21 +732,44 @@ class operator_lt :  public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n } op_lt;\n \n+// Check if the LHS range indicates a relation between OP1 and OP2.\n+\n+enum tree_code\n+operator_lt::op1_op2_relation (const irange &lhs) const\n+{\n+  if (lhs.undefined_p ())\n+    return VREL_EMPTY;\n+\n+  // FALSE = op1 < op2 indicates GE_EXPR.\n+  if (lhs.zero_p ())\n+    return GE_EXPR;\n+\n+  // TRUE = op1 < op2 indicates LT_EXPR.\n+  if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n+    return LT_EXPR;\n+  return VREL_NONE;\n+}\n+\n bool\n operator_lt::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n-\t\t\t const irange &op2) const\n+\t\t\t const irange &op2,\n+\t\t\t relation_kind rel) const\n {\n-  if (empty_range_varying (r, type, op1, op2))\n+  if (relop_early_resolve (r, type, op1, op2, rel, LT_EXPR))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -639,7 +787,8 @@ operator_lt::fold_range (irange &r, tree type,\n bool\n operator_lt::op1_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n-\t\t\tconst irange &op2) const\n+\t\t\tconst irange &op2,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -660,7 +809,8 @@ operator_lt::op1_range (irange &r, tree type,\n bool\n operator_lt::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n-\t\t\tconst irange &op1) const\n+\t\t\tconst irange &op1,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -684,21 +834,44 @@ class operator_le :  public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n } op_le;\n \n+// Check if the LHS range indicates a relation between OP1 and OP2.\n+\n+enum tree_code\n+operator_le::op1_op2_relation (const irange &lhs) const\n+{\n+  if (lhs.undefined_p ())\n+    return VREL_EMPTY;\n+\n+  // FALSE = op1 <= op2 indicates GT_EXPR.\n+  if (lhs.zero_p ())\n+    return GT_EXPR;\n+\n+  // TRUE = op1 <= op2 indicates LE_EXPR.\n+  if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n+    return LE_EXPR;\n+  return VREL_NONE;\n+}\n+\n bool\n operator_le::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n-\t\t\t const irange &op2) const\n+\t\t\t const irange &op2,\n+\t\t\t relation_kind rel) const\n {\n-  if (empty_range_varying (r, type, op1, op2))\n+  if (relop_early_resolve (r, type, op1, op2, rel, LE_EXPR))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -716,7 +889,8 @@ operator_le::fold_range (irange &r, tree type,\n bool\n operator_le::op1_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n-\t\t\tconst irange &op2) const\n+\t\t\tconst irange &op2,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -737,7 +911,8 @@ operator_le::op1_range (irange &r, tree type,\n bool\n operator_le::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n-\t\t\tconst irange &op1) const\n+\t\t\tconst irange &op1,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -761,20 +936,44 @@ class operator_gt :  public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n } op_gt;\n \n+// Check if the LHS range indicates a relation between OP1 and OP2.\n+\n+enum tree_code\n+operator_gt::op1_op2_relation (const irange &lhs) const\n+{\n+  if (lhs.undefined_p ())\n+    return VREL_EMPTY;\n+\n+  // FALSE = op1 > op2 indicates LE_EXPR.\n+  if (lhs.zero_p ())\n+    return LE_EXPR;\n+\n+  // TRUE = op1 > op2 indicates GT_EXPR.\n+  if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n+    return GT_EXPR;\n+  return VREL_NONE;\n+}\n+\n+\n bool\n operator_gt::fold_range (irange &r, tree type,\n-\t\t\t const irange &op1, const irange &op2) const\n+\t\t\t const irange &op1, const irange &op2,\n+\t\t\t relation_kind rel) const\n {\n-  if (empty_range_varying (r, type, op1, op2))\n+  if (relop_early_resolve (r, type, op1, op2, rel, GT_EXPR))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -791,7 +990,8 @@ operator_gt::fold_range (irange &r, tree type,\n \n bool\n operator_gt::op1_range (irange &r, tree type,\n-\t\t\tconst irange &lhs, const irange &op2) const\n+\t\t\tconst irange &lhs, const irange &op2,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -812,7 +1012,8 @@ operator_gt::op1_range (irange &r, tree type,\n bool\n operator_gt::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n-\t\t\tconst irange &op1) const\n+\t\t\tconst irange &op1,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -836,21 +1037,44 @@ class operator_ge :  public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n } op_ge;\n \n+// Check if the LHS range indicates a relation between OP1 and OP2.\n+\n+enum tree_code\n+operator_ge::op1_op2_relation (const irange &lhs) const\n+{\n+  if (lhs.undefined_p ())\n+    return VREL_EMPTY;\n+\n+  // FALSE = op1 >= op2 indicates LT_EXPR.\n+  if (lhs.zero_p ())\n+    return LT_EXPR;\n+\n+  // TRUE = op1 >= op2 indicates GE_EXPR.\n+  if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n+    return GE_EXPR;\n+  return VREL_NONE;\n+}\n+\n bool\n operator_ge::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n-\t\t\t const irange &op2) const\n+\t\t\t const irange &op2,\n+\t\t\t relation_kind rel) const\n {\n-  if (empty_range_varying (r, type, op1, op2))\n+  if (relop_early_resolve (r, type, op1, op2, rel, GE_EXPR))\n     return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n@@ -868,7 +1092,8 @@ operator_ge::fold_range (irange &r, tree type,\n bool\n operator_ge::op1_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n-\t\t\tconst irange &op2) const\n+\t\t\tconst irange &op2,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -889,7 +1114,8 @@ operator_ge::op1_range (irange &r, tree type,\n bool\n operator_ge::op2_range (irange &r, tree type,\n \t\t\tconst irange &lhs,\n-\t\t\tconst irange &op1) const\n+\t\t\tconst irange &op1,\n+\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -913,10 +1139,12 @@ class operator_plus : public range_operator\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -939,15 +1167,17 @@ operator_plus::wi_fold (irange &r, tree type,\n bool\n operator_plus::op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op2);\n }\n \n bool\n operator_plus::op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op1);\n }\n@@ -958,10 +1188,12 @@ class operator_minus : public range_operator\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -984,15 +1216,17 @@ operator_minus::wi_fold (irange &r, tree type,\n bool\n operator_minus::op1_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n-\t\t\t   const irange &op2) const\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return range_op_handler (PLUS_EXPR, type)->fold_range (r, type, lhs, op2);\n }\n \n bool\n operator_minus::op2_range (irange &r, tree type,\n \t\t\t   const irange &lhs,\n-\t\t\t   const irange &op1) const\n+\t\t\t   const irange &op1,\n+\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return fold_range (r, type, op1, lhs);\n }\n@@ -1127,15 +1361,18 @@ class operator_mult : public cross_product_operator\n \t\t\t\tconst wide_int &w0, const wide_int &w1) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n } op_mult;\n \n bool\n operator_mult::op1_range (irange &r, tree type,\n-\t\t\t  const irange &lhs, const irange &op2) const\n+\t\t\t  const irange &lhs, const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   tree offset;\n \n@@ -1153,9 +1390,10 @@ operator_mult::op1_range (irange &r, tree type,\n \n bool\n operator_mult::op2_range (irange &r, tree type,\n-\t\t\t  const irange &lhs, const irange &op1) const\n+\t\t\t  const irange &lhs, const irange &op1,\n+\t\t\t  relation_kind rel) const\n {\n-  return operator_mult::op1_range (r, type, lhs, op1);\n+  return operator_mult::op1_range (r, type, lhs, op1, rel);\n }\n \n bool\n@@ -1391,14 +1629,16 @@ class operator_exact_divide : public operator_div\n   operator_exact_divide () : operator_div (TRUNC_DIV_EXPR) { }\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n \n } op_exact_div;\n \n bool\n operator_exact_divide::op1_range (irange &r, tree type,\n \t\t\t\t  const irange &lhs,\n-\t\t\t\t  const irange &op2) const\n+\t\t\t\t  const irange &op2,\n+\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   tree offset;\n   // [2, 4] = op1 / [3,3]   since its exact divide, no need to worry about\n@@ -1419,10 +1659,12 @@ class operator_lshift : public cross_product_operator\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n \n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n@@ -1438,7 +1680,8 @@ class operator_rshift : public cross_product_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb,\n \t\t\tconst wide_int &lh_ub,\n@@ -1450,14 +1693,16 @@ class operator_rshift : public cross_product_operator\n \t\t\t\tconst wide_int &w1) const;\n   virtual bool op1_range (irange &, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_rshift;\n \n \n bool\n operator_lshift::fold_range (irange &r, tree type,\n \t\t\t     const irange &op1,\n-\t\t\t     const irange &op2) const\n+\t\t\t     const irange &op2,\n+\t\t\t     relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   int_range_max shift_range;\n   if (!get_shift_range (shift_range, type, op2))\n@@ -1572,7 +1817,8 @@ bool\n operator_lshift::op1_range (irange &r,\n \t\t\t    tree type,\n \t\t\t    const irange &lhs,\n-\t\t\t    const irange &op2) const\n+\t\t\t    const irange &op2,\n+\t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   tree shift_amount;\n   if (op2.singleton_p (&shift_amount))\n@@ -1632,7 +1878,8 @@ bool\n operator_rshift::op1_range (irange &r,\n \t\t\t    tree type,\n \t\t\t    const irange &lhs,\n-\t\t\t    const irange &op2) const\n+\t\t\t    const irange &op2,\n+\t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   tree shift;\n   if (op2.singleton_p (&shift))\n@@ -1708,7 +1955,8 @@ operator_rshift::wi_op_overflows (wide_int &res,\n bool\n operator_rshift::fold_range (irange &r, tree type,\n \t\t\t     const irange &op1,\n-\t\t\t     const irange &op2) const\n+\t\t\t     const irange &op2,\n+\t\t\t     relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   int_range_max shift;\n   if (!get_shift_range (shift, type, op2))\n@@ -1737,10 +1985,12 @@ class operator_cast: public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n private:\n   bool truncating_cast_p (const irange &inner, const irange &outer) const;\n   bool inside_domain_p (const wide_int &min, const wide_int &max,\n@@ -1818,7 +2068,8 @@ operator_cast::fold_pair (irange &r, unsigned index,\n bool\n operator_cast::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t   const irange &inner,\n-\t\t\t   const irange &outer) const\n+\t\t\t   const irange &outer,\n+\t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, inner, outer))\n     return true;\n@@ -1844,7 +2095,8 @@ operator_cast::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n bool\n operator_cast::op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   tree lhs_type = lhs.type ();\n   gcc_checking_assert (types_compatible_p (op2.type(), type));\n@@ -1954,20 +2206,24 @@ class operator_logical_and : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n-\t\t\t   const irange &rh) const;\n+\t\t\t   const irange &rh,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_logical_and;\n \n \n bool\n operator_logical_and::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n-\t\t\t\t  const irange &rh) const\n+\t\t\t\t  const irange &rh,\n+\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -1989,7 +2245,8 @@ operator_logical_and::fold_range (irange &r, tree type,\n bool\n operator_logical_and::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t\t const irange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n    switch (get_bool_state (r, lhs, type))\n      {\n@@ -2010,7 +2267,8 @@ operator_logical_and::op1_range (irange &r, tree type,\n bool\n operator_logical_and::op2_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op1) const\n+\t\t\t\t const irange &op1,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return operator_logical_and::op1_range (r, type, lhs, op1);\n }\n@@ -2021,13 +2279,16 @@ class operator_bitwise_and : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n-\t\t\t   const irange &rh) const;\n+\t\t\t   const irange &rh,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -2106,7 +2367,8 @@ operator_bitwise_and::remove_impossible_ranges (irange &r,\n bool\n operator_bitwise_and::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n-\t\t\t\t  const irange &rh) const\n+\t\t\t\t  const irange &rh,\n+\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (range_operator::fold_range (r, type, lh, rh))\n     {\n@@ -2397,7 +2659,8 @@ operator_bitwise_and::simple_op1_range_solver (irange &r, tree type,\n bool\n operator_bitwise_and::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op2) const\n+\t\t\t\t const irange &op2,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (types_compatible_p (type, boolean_type_node))\n     return op_logical_and.op1_range (r, type, lhs, op2);\n@@ -2420,7 +2683,8 @@ operator_bitwise_and::op1_range (irange &r, tree type,\n bool\n operator_bitwise_and::op2_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op1) const\n+\t\t\t\t const irange &op1,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return operator_bitwise_and::op1_range (r, type, lhs, op1);\n }\n@@ -2431,19 +2695,23 @@ class operator_logical_or : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n-\t\t\t   const irange &rh) const;\n+\t\t\t   const irange &rh,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_logical_or;\n \n bool\n operator_logical_or::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const irange &lh,\n-\t\t\t\t const irange &rh) const\n+\t\t\t\t const irange &rh,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -2456,7 +2724,8 @@ operator_logical_or::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n bool\n operator_logical_or::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst irange &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t\tconst irange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n    switch (get_bool_state (r, lhs, type))\n      {\n@@ -2477,7 +2746,8 @@ operator_logical_or::op1_range (irange &r, tree type,\n bool\n operator_logical_or::op2_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst irange &op1) const\n+\t\t\t\tconst irange &op1,\n+\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return operator_logical_or::op1_range (r, type, lhs, op1);\n }\n@@ -2488,10 +2758,12 @@ class operator_bitwise_or : public range_operator\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel= VREL_NONE) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n@@ -2553,7 +2825,8 @@ operator_bitwise_or::wi_fold (irange &r, tree type,\n bool\n operator_bitwise_or::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst irange &op2) const\n+\t\t\t\tconst irange &op2,\n+\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   // If this is really a logical wi_fold, call that.\n   if (types_compatible_p (type, boolean_type_node))\n@@ -2572,7 +2845,8 @@ operator_bitwise_or::op1_range (irange &r, tree type,\n bool\n operator_bitwise_or::op2_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst irange &op1) const\n+\t\t\t\tconst irange &op1,\n+\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return operator_bitwise_or::op1_range (r, type, lhs, op1);\n }\n@@ -2588,10 +2862,12 @@ class operator_bitwise_xor : public range_operator\n \t\t        const wide_int &rh_ub) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_bitwise_xor;\n \n void\n@@ -2628,7 +2904,8 @@ operator_bitwise_xor::wi_fold (irange &r, tree type,\n bool\n operator_bitwise_xor::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op2) const\n+\t\t\t\t const irange &op2,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (lhs.undefined_p () || lhs.varying_p ())\n     {\n@@ -2662,7 +2939,8 @@ operator_bitwise_xor::op1_range (irange &r, tree type,\n bool\n operator_bitwise_xor::op2_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op1) const\n+\t\t\t\t const irange &op1,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return operator_bitwise_xor::op1_range (r, type, lhs, op1);\n }\n@@ -2677,10 +2955,12 @@ class operator_trunc_mod : public range_operator\n \t\t        const wide_int &rh_ub) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n } op_trunc_mod;\n \n void\n@@ -2730,7 +3010,8 @@ operator_trunc_mod::wi_fold (irange &r, tree type,\n bool\n operator_trunc_mod::op1_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n-\t\t\t       const irange &) const\n+\t\t\t       const irange &,\n+\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   // PR 91029.\n   signop sign = TYPE_SIGN (type);\n@@ -2753,7 +3034,8 @@ operator_trunc_mod::op1_range (irange &r, tree type,\n bool\n operator_trunc_mod::op2_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n-\t\t\t       const irange &) const\n+\t\t\t       const irange &,\n+\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   // PR 91029.\n   signop sign = TYPE_SIGN (type);\n@@ -2792,10 +3074,12 @@ class operator_logical_not : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n-\t\t\t   const irange &rh) const;\n+\t\t\t   const irange &rh,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_logical_not;\n \n // Folding a logical NOT, oddly enough, involves doing nothing on the\n@@ -2815,7 +3099,8 @@ class operator_logical_not : public range_operator\n bool\n operator_logical_not::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n-\t\t\t\t  const irange &rh ATTRIBUTE_UNUSED) const\n+\t\t\t\t  const irange &rh ATTRIBUTE_UNUSED,\n+\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -2831,7 +3116,8 @@ bool\n operator_logical_not::op1_range (irange &r,\n \t\t\t\t tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op2) const\n+\t\t\t\t const irange &op2,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   // Logical NOT is involutary...do it again.\n   return fold_range (r, type, lhs, op2);\n@@ -2843,16 +3129,19 @@ class operator_bitwise_not : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n-\t\t\t   const irange &rh) const;\n+\t\t\t   const irange &rh,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_bitwise_not;\n \n bool\n operator_bitwise_not::fold_range (irange &r, tree type,\n \t\t\t\t  const irange &lh,\n-\t\t\t\t  const irange &rh) const\n+\t\t\t\t  const irange &rh,\n+\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -2870,7 +3159,8 @@ operator_bitwise_not::fold_range (irange &r, tree type,\n bool\n operator_bitwise_not::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op2) const\n+\t\t\t\t const irange &op2,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (types_compatible_p (type, boolean_type_node))\n     return op_logical_not.op1_range (r, type, lhs, op2);\n@@ -2885,13 +3175,15 @@ class operator_cst : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n } op_integer_cst;\n \n bool\n operator_cst::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t  const irange &lh,\n-\t\t\t  const irange &rh ATTRIBUTE_UNUSED) const\n+\t\t\t  const irange &rh ATTRIBUTE_UNUSED,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   r = lh;\n   return true;\n@@ -2903,16 +3195,19 @@ class operator_identity : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_identity;\n \n bool\n operator_identity::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t       const irange &lh,\n-\t\t\t       const irange &rh ATTRIBUTE_UNUSED) const\n+\t\t\t       const irange &rh ATTRIBUTE_UNUSED,\n+\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   r = lh;\n   return true;\n@@ -2921,7 +3216,8 @@ operator_identity::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n bool\n operator_identity::op1_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t      const irange &lhs,\n-\t\t\t      const irange &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t      const irange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t      relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   r = lhs;\n   return true;\n@@ -2933,13 +3229,15 @@ class operator_unknown : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n } op_unknown;\n \n bool\n operator_unknown::fold_range (irange &r, tree type,\n \t\t\t      const irange &lh ATTRIBUTE_UNUSED,\n-\t\t\t      const irange &rh ATTRIBUTE_UNUSED) const\n+\t\t\t      const irange &rh ATTRIBUTE_UNUSED,\n+\t\t\t      relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   r.set_varying (type);\n   return true;\n@@ -2956,7 +3254,8 @@ class operator_abs : public range_operator\n \t\t        const wide_int &rh_ub) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const;\n } op_abs;\n \n void\n@@ -3036,7 +3335,8 @@ operator_abs::wi_fold (irange &r, tree type,\n bool\n operator_abs::op1_range (irange &r, tree type,\n \t\t\t const irange &lhs,\n-\t\t\t const irange &op2) const\n+\t\t\t const irange &op2,\n+\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, lhs, op2))\n     return true;\n@@ -3108,16 +3408,19 @@ class operator_negate : public range_operator\n  public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_negate;\n \n bool\n operator_negate::fold_range (irange &r, tree type,\n \t\t\t     const irange &lh,\n-\t\t\t     const irange &rh) const\n+\t\t\t     const irange &rh,\n+\t\t\t     relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -3130,7 +3433,8 @@ operator_negate::fold_range (irange &r, tree type,\n bool\n operator_negate::op1_range (irange &r, tree type,\n \t\t\t    const irange &lhs,\n-\t\t\t    const irange &op2) const\n+\t\t\t    const irange &op2,\n+\t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   // NEGATE is involutory.\n   return fold_range (r, type, lhs, op2);\n@@ -3142,16 +3446,19 @@ class operator_addr_expr : public range_operator\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n+\t\t\t   const irange &op2,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n } op_addr;\n \n bool\n operator_addr_expr::fold_range (irange &r, tree type,\n \t\t\t\tconst irange &lh,\n-\t\t\t\tconst irange &rh) const\n+\t\t\t\tconst irange &rh,\n+\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n@@ -3169,7 +3476,8 @@ operator_addr_expr::fold_range (irange &r, tree type,\n bool\n operator_addr_expr::op1_range (irange &r, tree type,\n \t\t\t       const irange &lhs,\n-\t\t\t       const irange &op2) const\n+\t\t\t       const irange &op2,\n+\t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return operator_addr_expr::fold_range (r, type, lhs, op2);\n }\n@@ -3288,10 +3596,12 @@ class pointer_or_operator : public range_operator\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual void wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n@@ -3300,7 +3610,8 @@ class pointer_or_operator : public range_operator\n bool\n pointer_or_operator::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst irange &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t\tconst irange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   if (lhs.zero_p ())\n     {\n@@ -3315,7 +3626,8 @@ pointer_or_operator::op1_range (irange &r, tree type,\n bool\n pointer_or_operator::op2_range (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst irange &op1) const\n+\t\t\t\tconst irange &op1,\n+\t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n   return pointer_or_operator::op1_range (r, type, lhs, op1);\n }"}, {"sha": "2b5db64bb98b58ef71b134adbed5ad89008dc951", "filename": "gcc/range-op.h", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80dd13f5c3bdc7899ee6e863e05b254815ec0cef/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80dd13f5c3bdc7899ee6e863e05b254815ec0cef/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "patch": "@@ -52,7 +52,8 @@ class range_operator\n   // Perform an operation between 2 ranges and return it.\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n-\t\t\t   const irange &rh) const;\n+\t\t\t   const irange &rh,\n+\t\t\t   relation_kind rel = VREL_NONE) const;\n \n   // Return the range for op[12] in the general case.  LHS is the range for\n   // the LHS of the expression, OP[12]is the range for the other\n@@ -67,18 +68,35 @@ class range_operator\n   // is re-formed as R = [LHS] - OP2.\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n+\t\t\t  const irange &op2,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n   virtual bool op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n-\t\t\t  const irange &op1) const;\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_kind rel = VREL_NONE) const;\n \n+  // The following routines are used to represent relations between the\n+  // various operations.  If the caller knows where the symbolics are,\n+  // it can query for relationships between them given known ranges.\n+  virtual enum tree_code lhs_op1_relation (const irange &lhs,\n+\t\t\t\t\t   const irange &op1,\n+\t\t\t\t\t   const irange &op2) const;\n+  virtual enum tree_code lhs_op2_relation (const irange &lhs,\n+\t\t\t\t\t   const irange &op1,\n+\t\t\t\t\t   const irange &op2) const;\n+  virtual enum tree_code op1_op2_relation (const irange &lhs) const;\n protected:\n   // Perform an integral operation between 2 sub-ranges and return it.\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n+  // Side effect of relation for generic fold_range clients.\n+  virtual bool op1_op2_relation_effect (irange &lhs_range, tree type,\n+\t\t\t\t\tconst irange &op1_range,\n+\t\t\t\t\tconst irange &op2_range,\n+\t\t\t\t\trelation_kind rel) const;\n };\n \n extern range_operator *range_op_handler (enum tree_code code, tree type);"}]}