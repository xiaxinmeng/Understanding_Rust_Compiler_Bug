{"sha": "729a01f72ca6c1bd106cb2285187191c3568201b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5YTAxZjcyY2E2YzFiZDEwNmNiMjI4NTE4NzE5MWMzNTY4MjAxYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-08-16T19:18:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-08-16T19:18:42Z"}, "message": "[PATCH] Macro definition parameter parsing\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-08/msg00977.html\n\tlibcpp/\n\t* internal.h (_cpp_save_parameter): Take parmno, not macro.\n\t(_cpp_unsave_parameters): Declare.\n\t* macro.c (_cpp_save_parameter): Take parm number, not macro.\n\tReturn true on success.\n\t(_cpp_unsave_parameters): New.\n\t(parse_params): Take parm_no and variadic pointers, not macro.\n\tReimplement parsing logic.\n\t(create_iso_definition): Adjust parse_params changes.  Call\n\t_cpp_unsave_parameters here.\n\t(_cpp_create_definition): Don't unsave params here.\n\t* traditional.c (scan_parameters): Take n_param pointer, adjust.\n\t(_cpp_create_trad_definition): Ajust scan_parameters change.  Call\n\t_cpp_unsave_parameters.\n\tgcc/testsuite/\n\t* gcc.dg/cpp/macsyntx.c: Adjust expected errors.\n\t* gcc.dg/cpp/macsyntx2.c: likewise.\n\nFrom-SVN: r263600", "tree": {"sha": "8cba46feaa371a76edad8a772eeab6d7071b0b7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cba46feaa371a76edad8a772eeab6d7071b0b7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/729a01f72ca6c1bd106cb2285187191c3568201b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729a01f72ca6c1bd106cb2285187191c3568201b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729a01f72ca6c1bd106cb2285187191c3568201b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729a01f72ca6c1bd106cb2285187191c3568201b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c37da7c0e8d022f4ad85bd0adf7f80886df9c94e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37da7c0e8d022f4ad85bd0adf7f80886df9c94e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37da7c0e8d022f4ad85bd0adf7f80886df9c94e"}], "stats": {"total": 337, "additions": 190, "deletions": 147}, "files": [{"sha": "0753e9cf1c61460c8d84d5872982d7e3318e35ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a01f72ca6c1bd106cb2285187191c3568201b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a01f72ca6c1bd106cb2285187191c3568201b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=729a01f72ca6c1bd106cb2285187191c3568201b", "patch": "@@ -1,3 +1,8 @@\n+2018-08-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcc.dg/cpp/macsyntx.c: Adjust expected errors.\n+\t* gcc.dg/cpp/macsyntx2.c: likewise.\n+\n 2018-08-15  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR testsuite/86745"}, {"sha": "dab1e9d30c3f54595533ff59d3d1429d8a748f6a", "filename": "gcc/testsuite/gcc.dg/cpp/macsyntx.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a01f72ca6c1bd106cb2285187191c3568201b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a01f72ca6c1bd106cb2285187191c3568201b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx.c?ref=729a01f72ca6c1bd106cb2285187191c3568201b", "patch": "@@ -21,14 +21,14 @@\n \n #define ;\t\t\t/* { dg-error \"identifier\" } */\n #define SEMI;\t\t\t/* { dg-warning \"space\" } */\n-#define foo(X\t\t\t/* { dg-error \"missing\" } */\n+#define foo(X\t\t\t/* { dg-error \"expected\" } */\n #define foo\\\n (X,)\t\t\t\t/* { dg-error \"parameter name\" } */\n #define foo(, X)\t\t/* { dg-error \"parameter name\" } */\n #define foo(X, X)\t\t/* { dg-error \"duplicate\" } */\n-#define foo(X Y)\t\t/* { dg-error \"comma\" } */\n-#define foo(()\t\t\t/* { dg-error \"may not appear\" } */\n-#define foo(..., X)\t\t/* { dg-error \"missing\" } */\n+#define foo(X Y)\t\t/* { dg-error \"expected\" } */\n+#define foo(()\t\t\t/* { dg-error \"parameter name\" } */\n+#define foo(..., X)\t\t/* { dg-error \"expected\" } */\n #define foo \\\n __VA_ARGS__\t\t\t/* { dg-warning \"__VA_ARGS__\" } */\n #define goo(__VA_ARGS__)\t/* { dg-warning \"__VA_ARGS__\" } */"}, {"sha": "f0fcf528400cb3457532d29d5c8a6785b554a2f7", "filename": "gcc/testsuite/gcc.dg/cpp/macsyntx2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a01f72ca6c1bd106cb2285187191c3568201b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a01f72ca6c1bd106cb2285187191c3568201b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx2.c?ref=729a01f72ca6c1bd106cb2285187191c3568201b", "patch": "@@ -21,14 +21,14 @@\n \n #define ;\t\t\t/* { dg-error \"identifier\" } */\n #define SEMI;\t\t\t/* { dg-warning \"space\" } */\n-#define foo(X\t\t\t/* { dg-error \"missing\" } */\n+#define foo(X\t\t\t/* { dg-error \"expected\" } */\n #define foo\\\n (X,)\t\t\t\t/* { dg-error \"parameter name\" } */\n #define foo(, X)\t\t/* { dg-error \"parameter name\" } */\n #define foo(X, X)\t\t/* { dg-error \"duplicate\" } */\n-#define foo(X Y)\t\t/* { dg-error \"comma\" } */\n-#define foo(()\t\t\t/* { dg-error \"may not appear\" } */\n-#define foo(..., X)\t\t/* { dg-error \"missing\" } */\n+#define foo(X Y)\t\t/* { dg-error \"expected\" } */\n+#define foo(()\t\t\t/* { dg-error \"parameter name\" } */\n+#define foo(..., X)\t\t/* { dg-error \"expected\" } */\n #define foo \\\n __VA_ARGS__\t\t\t/* { dg-warning \"__VA_ARGS__\" } */\n #define goo(__VA_ARGS__)\t/* { dg-warning \"__VA_ARGS__\" } */"}, {"sha": "5f087ece0f8f437459f854253c3f5cf91262a1dc", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=729a01f72ca6c1bd106cb2285187191c3568201b", "patch": "@@ -1,6 +1,19 @@\n 2018-08-16  Nathan Sidwell  <nathan@acm.org>\n \n-\tlibcpp/\n+\t* internal.h (_cpp_save_parameter): Take parmno, not macro.\n+\t(_cpp_unsave_parameters): Declare.\n+\t* macro.c (_cpp_save_parameter): Take parm number, not macro.\n+\tReturn true on success.\n+\t(_cpp_unsave_parameters): New.\n+\t(parse_params): Take parm_no and variadic pointers, not macro.\n+\tReimplement parsing logic.\n+\t(create_iso_definition): Adjust parse_params changes.  Call\n+\t_cpp_unsave_parameters here.\n+\t(_cpp_create_definition): Don't unsave params here.\n+\t* traditional.c (scan_parameters): Take n_param pointer, adjust.\n+\t(_cpp_create_trad_definition): Ajust scan_parameters change.  Call\n+\t_cpp_unsave_parameters.\n+\n \t* include/cpplib.h (cpp_user_macro_p, cpp_builtin_macro_p)\n \t(cpp_macro_p): New inlines.\n \t* directives.c (do_pragma_poison): Use cpp_macro_p."}, {"sha": "001252085cb7bb0a14be8e9a81807693eeb40286", "filename": "libcpp/internal.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=729a01f72ca6c1bd106cb2285187191c3568201b", "patch": "@@ -632,8 +632,9 @@ extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);\n extern void _cpp_pop_context (cpp_reader *);\n extern void _cpp_push_text_context (cpp_reader *, cpp_hashnode *,\n \t\t\t\t    const unsigned char *, size_t);\n-extern bool _cpp_save_parameter (cpp_reader *, cpp_macro *, cpp_hashnode *,\n+extern bool _cpp_save_parameter (cpp_reader *, unsigned, cpp_hashnode *,\n \t\t\t\t cpp_hashnode *);\n+extern void _cpp_unsave_parameters (cpp_reader *, unsigned);\n extern bool _cpp_arguments_ok (cpp_reader *, cpp_macro *, const cpp_hashnode *,\n \t\t\t       unsigned int);\n extern const unsigned char *_cpp_builtin_macro_text (cpp_reader *,"}, {"sha": "52098efe63cf2655cd7a8e7023a00412ccd3f1de", "filename": "libcpp/macro.c", "status": "modified", "additions": 148, "deletions": 132, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=729a01f72ca6c1bd106cb2285187191c3568201b", "patch": "@@ -316,7 +316,7 @@ static cpp_token *alloc_expansion_token (cpp_reader *, cpp_macro *);\n static cpp_token *lex_expansion_token (cpp_reader *, cpp_macro *);\n static bool warn_of_redefinition (cpp_reader *, cpp_hashnode *,\n \t\t\t\t  const cpp_macro *);\n-static bool parse_params (cpp_reader *, cpp_macro *);\n+static bool parse_params (cpp_reader *, unsigned *, bool *);\n static void check_trad_stringification (cpp_reader *, const cpp_macro *,\n \t\t\t\t\tconst cpp_string *);\n static bool reached_end_of_context (cpp_context *);\n@@ -3053,146 +3053,177 @@ _cpp_free_definition (cpp_hashnode *h)\n }\n \n /* Save parameter NODE (spelling SPELLING) to the parameter list of\n-   macro MACRO.  Returns zero on success, nonzero if the parameter is\n-   a duplicate.  */\n+   macro MACRO.  Returns true on success, false on failure.   */\n bool\n-_cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node,\n+_cpp_save_parameter (cpp_reader *pfile, unsigned n, cpp_hashnode *node,\n \t\t     cpp_hashnode *spelling)\n {\n-  unsigned int len;\n   /* Constraint 6.10.3.6 - duplicate parameter names.  */\n   if (node->flags & NODE_MACRO_ARG)\n     {\n       cpp_error (pfile, CPP_DL_ERROR, \"duplicate macro parameter \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n-      return true;\n+      return false;\n     }\n \n-  if (BUFF_ROOM (pfile->a_buff)\n-      < (macro->paramc + 1) * sizeof (cpp_hashnode *))\n-    _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_hashnode *));\n-\n-  ((cpp_hashnode **) BUFF_FRONT (pfile->a_buff))[macro->paramc++] = spelling;\n-  node->flags |= NODE_MACRO_ARG;\n-  len = macro->paramc * sizeof (struct macro_arg_saved_data);\n+  unsigned len = (n + 1) * sizeof (struct macro_arg_saved_data);\n   if (len > pfile->macro_buffer_len)\n     {\n-      pfile->macro_buffer = XRESIZEVEC (unsigned char, pfile->macro_buffer,\n-                                        len);\n+      pfile->macro_buffer\n+\t= XRESIZEVEC (unsigned char, pfile->macro_buffer, len);\n       pfile->macro_buffer_len = len;\n     }\n-  struct macro_arg_saved_data save;\n-  save.value = node->value;\n-  save.canonical_node = node;\n-  ((struct macro_arg_saved_data *) pfile->macro_buffer)[macro->paramc - 1]\n-    = save;\n   \n-  node->value.arg_index  = macro->paramc;\n-  return false;\n+  macro_arg_saved_data *saved = (macro_arg_saved_data *)pfile->macro_buffer;\n+  saved[n].canonical_node = node;\n+  saved[n].value = node->value;\n+\n+  if (BUFF_ROOM (pfile->a_buff) < (n + 1) * sizeof (cpp_hashnode *))\n+    _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_hashnode *));\n+\n+  ((cpp_hashnode **) BUFF_FRONT (pfile->a_buff))[n] = spelling;\n+\n+  /* Morph into a macro arg.  */\n+  node->flags |= NODE_MACRO_ARG;\n+  /* Index is 1 based.  */\n+  node->value.arg_index = n + 1;\n+\n+  return true;\n }\n \n-/* Check the syntax of the parameters in a MACRO definition.  Returns\n-   false if an error occurs.  */\n+/* Restore the parameters to their previous state.  */\n+void\n+_cpp_unsave_parameters (cpp_reader *pfile, unsigned n)\n+{\n+  /* Clear the fast argument lookup indices.  */\n+  while (n--)\n+    {\n+      struct macro_arg_saved_data *save =\n+\t&((struct macro_arg_saved_data *) pfile->macro_buffer)[n];\n+\n+      struct cpp_hashnode *node = save->canonical_node;\n+      node->value = save->value;\n+      node->flags &= ~NODE_MACRO_ARG;\n+    }\n+}\n+\n+/* Check the syntax of the parameters in a MACRO definition.  Return\n+   false on failure.  Set *N_PTR and *VARADIC_PTR as appropriate.\n+   '(' ')'\n+   '(' parm-list ',' last-parm ')'\n+   '(' last-parm ')'\n+   parm-list: name\n+            | parm-list, name\n+   last-parm: name\n+   \t    | name '...'\n+            | '...'\n+*/\n static bool\n-parse_params (cpp_reader *pfile, cpp_macro *macro)\n+parse_params (cpp_reader *pfile, unsigned *n_ptr, bool *varadic_ptr)\n {\n-  unsigned int prev_ident = 0;\n+  unsigned nparms = 0;\n+  bool ok = false;\n \n-  for (;;)\n+  for (bool prev_ident = false;;)\n     {\n       const cpp_token *token = _cpp_lex_token (pfile);\n \n       switch (token->type)\n \t{\n-\tdefault:\n+\tcase CPP_COMMENT:\n \t  /* Allow/ignore comments in parameter lists if we are\n \t     preserving comments in macro expansions.  */\n-\t  if (token->type == CPP_COMMENT\n-\t      && ! CPP_OPTION (pfile, discard_comments_in_macro_exp))\n-\t    continue;\n+\t  if (!CPP_OPTION (pfile, discard_comments_in_macro_exp))\n+\t    break;\n \n-\t  cpp_error (pfile, CPP_DL_ERROR,\n-\t\t     \"\\\"%s\\\" may not appear in macro parameter list\",\n-\t\t     cpp_token_as_text (pfile, token));\n-\t  return false;\n+\t  /* FALLTHRU  */\n+\tdefault:\n+\tbad:\n+\t  {\n+\t    const char *const msgs[5] =\n+\t      {\n+\t       N_(\"expected parameter name, found \\\"%s\\\"\"),\n+\t       N_(\"expected ',' or ')', found \\\"%s\\\"\"),\n+\t       N_(\"expected parameter name before end of line\"),\n+\t       N_(\"expected ')' before end of line\"),\n+\t       N_(\"expected ')' after \\\"...\\\"\")\n+\t      };\n+\t    unsigned ix = prev_ident;\n+\t    const unsigned char *as_text = NULL;\n+\t    if (*varadic_ptr)\n+\t      ix = 4;\n+\t    else if (token->type == CPP_EOF)\n+\t      ix += 2;\n+\t    else\n+\t      as_text = cpp_token_as_text (pfile, token);\n+\t    cpp_error (pfile, CPP_DL_ERROR, msgs[ix], as_text);\n+\t  }\n+\t  goto out;\n \n \tcase CPP_NAME:\n-\t  if (prev_ident)\n-\t    {\n-\t      cpp_error (pfile, CPP_DL_ERROR,\n-\t\t\t \"macro parameters must be comma-separated\");\n-\t      return false;\n-\t    }\n-\t  prev_ident = 1;\n-\n-\t  if (_cpp_save_parameter (pfile, macro, token->val.node.node,\n-\t\t\t\t   token->val.node.spelling))\n-\t    return false;\n-\t  continue;\n+\t  if (prev_ident || *varadic_ptr)\n+\t    goto bad;\n+\t  prev_ident = true;\n+\n+\t  if (!_cpp_save_parameter (pfile, nparms, token->val.node.node,\n+\t\t\t\t    token->val.node.spelling))\n+\t    goto out;\n+\t  nparms++;\n+\t  break;\n \n \tcase CPP_CLOSE_PAREN:\n-\t  if (prev_ident || macro->paramc == 0)\n-\t    return true;\n+\t  if (prev_ident || !nparms || *varadic_ptr)\n+\t    {\n+\t      ok = true;\n+\t      goto out;\n+\t    }\n \n-\t  /* Fall through to pick up the error.  */\n \t  /* FALLTHRU */\n \tcase CPP_COMMA:\n-\t  if (!prev_ident)\n-\t    {\n-\t      cpp_error (pfile, CPP_DL_ERROR, \"parameter name missing\");\n-\t      return false;\n-\t    }\n-\t  prev_ident = 0;\n-\t  continue;\n+\t  if (!prev_ident || *varadic_ptr)\n+\t    goto bad;\n+\t  prev_ident = false;\n+\t  break;\n \n \tcase CPP_ELLIPSIS:\n-\t  macro->variadic = 1;\n+\t  if (*varadic_ptr)\n+\t    goto bad;\n+\t  *varadic_ptr = true;\n \t  if (!prev_ident)\n \t    {\n-\t      _cpp_save_parameter (pfile, macro,\n+\t      /* An ISO bare ellipsis.  */\n+\t      _cpp_save_parameter (pfile, nparms,\n \t\t\t\t   pfile->spec_nodes.n__VA_ARGS__,\n \t\t\t\t   pfile->spec_nodes.n__VA_ARGS__);\n+\t      nparms++;\n \t      pfile->state.va_args_ok = 1;\n \t      if (! CPP_OPTION (pfile, c99)\n \t\t  && CPP_OPTION (pfile, cpp_pedantic)\n \t\t  && CPP_OPTION (pfile, warn_variadic_macros))\n-\t\t{\n-\t\t  if (CPP_OPTION (pfile, cplusplus))\n-\t\t    cpp_pedwarning\n-\t\t\t(pfile, CPP_W_VARIADIC_MACROS,\n-\t\t\t\"anonymous variadic macros were introduced in C++11\");\n-\t\t  else\n-\t\t    cpp_pedwarning\n-\t\t\t(pfile, CPP_W_VARIADIC_MACROS,\n-\t\t\t\"anonymous variadic macros were introduced in C99\");\n-\t\t}\n+\t\tcpp_pedwarning\n+\t\t  (pfile, CPP_W_VARIADIC_MACROS,\n+\t\t   CPP_OPTION (pfile, cplusplus)\n+\t\t   ? N_(\"anonymous variadic macros were introduced in C++11\")\n+\t\t   : N_(\"anonymous variadic macros were introduced in C99\"));\n \t      else if (CPP_OPTION (pfile, cpp_warn_c90_c99_compat) > 0\n \t\t       && ! CPP_OPTION (pfile, cplusplus))\n \t\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t\t   \"anonymous variadic macros were introduced in C99\");\n \t    }\n \t  else if (CPP_OPTION (pfile, cpp_pedantic)\n \t\t   && CPP_OPTION (pfile, warn_variadic_macros))\n-\t    {\n-\t      if (CPP_OPTION (pfile, cplusplus))\n-\t\tcpp_pedwarning (pfile, CPP_W_VARIADIC_MACROS,\n-\t\t            \"ISO C++ does not permit named variadic macros\");\n-\t      else\n-\t\tcpp_pedwarning (pfile, CPP_W_VARIADIC_MACROS,\n-\t\t            \"ISO C does not permit named variadic macros\");\n-\t    }\n-\n-\t  /* We're at the end, and just expect a closing parenthesis.  */\n-\t  token = _cpp_lex_token (pfile);\n-\t  if (token->type == CPP_CLOSE_PAREN)\n-\t    return true;\n-\t  /* Fall through.  */\n-\n-\tcase CPP_EOF:\n-\t  cpp_error (pfile, CPP_DL_ERROR, \"missing ')' in macro parameter list\");\n-\t  return false;\n+\t    cpp_pedwarning (pfile, CPP_W_VARIADIC_MACROS,\n+\t\t\t    CPP_OPTION (pfile, cplusplus)\n+\t\t\t    ? N_(\"ISO C++ does not permit named variadic macros\")\n+\t\t\t    : N_(\"ISO C does not permit named variadic macros\"));\n+\t  break;\n \t}\n     }\n+\n+ out:\n+  *n_ptr = nparms;\n+\n+  return ok;\n }\n \n /* Allocate room for a token from a macro's replacement list.  */\n@@ -3242,17 +3273,24 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n   const char *paste_op_error_msg =\n     N_(\"'##' cannot appear at either end of a macro expansion\");\n   unsigned int num_extra_tokens = 0;\n+  unsigned nparms = 0;\n+  bool varadic = false;\n+  bool ok = false;\n \n   /* Get the first token of the expansion (or the '(' of a\n      function-like macro).  */\n   ctoken = _cpp_lex_token (pfile);\n \n-  if (ctoken->type == CPP_OPEN_PAREN && !(ctoken->flags & PREV_WHITE))\n+  if (ctoken->flags & PREV_WHITE)\n+    /* Preceeded by space, must be part of expansion.  */;\n+  else if (ctoken->type == CPP_OPEN_PAREN)\n     {\n-      bool ok = parse_params (pfile, macro);\n+      /* An open-paren, get a parameter list.  */\n+      if (!parse_params (pfile, &nparms, &varadic))\n+\tgoto out;\n+      macro->variadic = varadic;\n+      macro->paramc = nparms;\n       macro->params = (cpp_hashnode **) BUFF_FRONT (pfile->a_buff);\n-      if (!ok)\n-\treturn false;\n \n       /* Success.  Commit or allocate the parameter array.  */\n       if (pfile->hash_table->alloc_subobject)\n@@ -3274,14 +3312,10 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t in a macro definition, ISO C90 with TC1 allows characters\n \t from the basic source character set there.  */\n       if (CPP_OPTION (pfile, c99))\n-\t{\n-\t  if (CPP_OPTION (pfile, cplusplus))\n-\t    cpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t       \"ISO C++11 requires whitespace after the macro name\");\n-\t  else\n-\t    cpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t       \"ISO C99 requires whitespace after the macro name\");\n-\t}\n+\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t   CPP_OPTION (pfile, cplusplus)\n+\t\t   ? N_(\"ISO C++11 requires whitespace after the macro name\")\n+\t\t   : N_(\"ISO C99 requires whitespace after the macro name\"));\n       else\n \t{\n \t  int warntype = CPP_DL_WARNING;\n@@ -3317,10 +3351,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n       *token = *ctoken;\n     }\n \n-  /* The argument doesn't matter here.  */\n-  vaopt_state vaopt_tracker (pfile, macro->variadic, true);\n-\n-  for (;;)\n+  for (  vaopt_state vaopt_tracker (pfile, macro->variadic, true);;)\n     {\n       /* Check the stringifying # constraint 6.10.3.2.1 of\n \t function-like macros when lexing the subsequent token.  */\n@@ -3343,7 +3374,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t    {\n \t      cpp_error (pfile, CPP_DL_ERROR,\n \t\t\t \"'#' is not followed by a macro parameter\");\n-\t      return false;\n+\t      goto out;\n \t    }\n \t}\n \n@@ -3355,8 +3386,10 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t  if (following_paste_op)\n \t    {\n \t      cpp_error (pfile, CPP_DL_ERROR, paste_op_error_msg);\n-\t      return false;\n+\t      goto out;\n \t    }\n+\t  if (!vaopt_tracker.completed ())\n+\t    goto out;\n \t  break;\n \t}\n \n@@ -3368,7 +3401,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t  if (macro->count == 1)\n \t    {\n \t      cpp_error (pfile, CPP_DL_ERROR, paste_op_error_msg);\n-\t      return false;\n+\t      goto out;\n \t    }\n \n \t  if (token[-1].flags & PASTE_LEFT)\n@@ -3389,14 +3422,14 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t}\n \n       if (vaopt_tracker.update (token) == vaopt_state::ERROR)\n-\treturn false;\n+\tgoto out;\n \n       following_paste_op = (token->type == CPP_PASTE);\n       token = lex_expansion_token (pfile, macro);\n     }\n \n-  if (!vaopt_tracker.completed ())\n-    return false;\n+  /* We're committed to winning now.  */\n+  ok = true;\n \n   macro->exp.tokens = (cpp_token *) BUFF_FRONT (pfile->a_buff);\n   macro->traditional = 0;\n@@ -3440,15 +3473,18 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n   else\n     BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->exp.tokens[macro->count];\n \n-  return true;\n+ out:\n+  pfile->state.va_args_ok = 0;\n+  _cpp_unsave_parameters (pfile, nparms);\n+\n+  return ok;\n }\n \n /* Parse a macro and save its expansion.  Returns nonzero on success.  */\n bool\n _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n {\n   cpp_macro *macro;\n-  unsigned int i;\n   bool ok;\n \n   if (pfile->hash_table->alloc_subobject)\n@@ -3470,27 +3506,7 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   if (CPP_OPTION (pfile, traditional))\n     ok = _cpp_create_trad_definition (pfile, macro);\n   else\n-    {\n-      ok = create_iso_definition (pfile, macro);\n-\n-      /* We set the type for SEEN_EOL() in directives.c.\n-\n-\t Longer term we should lex the whole line before coming here,\n-\t and just copy the expansion.  */\n-\n-      /* Stop the lexer accepting __VA_ARGS__.  */\n-      pfile->state.va_args_ok = 0;\n-    }\n-\n-  /* Clear the fast argument lookup indices.  */\n-  for (i = macro->paramc; i-- > 0; )\n-    {\n-      struct macro_arg_saved_data *save =\n-\t&((struct macro_arg_saved_data *) pfile->macro_buffer)[i];\n-      struct cpp_hashnode *node = save->canonical_node;\n-      node->flags &= ~ NODE_MACRO_ARG;\n-      node->value = save->value;\n-    }\n+    ok = create_iso_definition (pfile, macro);\n \n   if (!ok)\n     return ok;"}, {"sha": "f4842369c3a168393760c15e194de830a4df88f2", "filename": "libcpp/traditional.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a01f72ca6c1bd106cb2285187191c3568201b/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=729a01f72ca6c1bd106cb2285187191c3568201b", "patch": "@@ -89,7 +89,7 @@ static cpp_hashnode *lex_identifier (cpp_reader *, const uchar *);\n static const uchar *copy_comment (cpp_reader *, const uchar *, int);\n static void check_output_buffer (cpp_reader *, size_t);\n static void push_replacement_text (cpp_reader *, cpp_hashnode *);\n-static bool scan_parameters (cpp_reader *, cpp_macro *);\n+static bool scan_parameters (cpp_reader *, unsigned *);\n static bool recursive_macro (cpp_reader *, cpp_hashnode *);\n static void save_replacement_text (cpp_reader *, cpp_macro *, unsigned int);\n static void maybe_start_funlike (cpp_reader *, cpp_hashnode *, const uchar *,\n@@ -1082,11 +1082,12 @@ replace_args_and_push (cpp_reader *pfile, struct fun_macro *fmacro)\n    duplicate parameter).  On success, CUR (pfile->context) is just\n    past the closing parenthesis.  */\n static bool\n-scan_parameters (cpp_reader *pfile, cpp_macro *macro)\n+scan_parameters (cpp_reader *pfile, unsigned *n_ptr)\n {\n   const uchar *cur = CUR (pfile->context) + 1;\n   bool ok;\n \n+  unsigned nparms = 0;\n   for (;;)\n     {\n       cur = skip_whitespace (pfile, cur, true /* skip_comments */);\n@@ -1095,8 +1096,9 @@ scan_parameters (cpp_reader *pfile, cpp_macro *macro)\n \t{\n \t  struct cpp_hashnode *id = lex_identifier (pfile, cur);\n \t  ok = false;\n-\t  if (_cpp_save_parameter (pfile, macro, id, id))\n+\t  if (!_cpp_save_parameter (pfile, nparms, id, id))\n \t    break;\n+\t  nparms++;\n \t  cur = skip_whitespace (pfile, CUR (pfile->context),\n \t\t\t\t true /* skip_comments */);\n \t  if (*cur == ',')\n@@ -1108,10 +1110,12 @@ scan_parameters (cpp_reader *pfile, cpp_macro *macro)\n \t  break;\n \t}\n \n-      ok = (*cur == ')' && macro->paramc == 0);\n+      ok = (*cur == ')' && !nparms);\n       break;\n     }\n \n+  *n_ptr = nparms;\n+\n   if (!ok)\n     cpp_error (pfile, CPP_DL_ERROR, \"syntax error in macro parameter list\");\n \n@@ -1181,6 +1185,7 @@ _cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n   const uchar *cur;\n   uchar *limit;\n   cpp_context *context = pfile->context;\n+  unsigned nparms = 0;\n \n   /* The context has not been set up for command line defines, and CUR\n      has not been updated for the macro name for in-file defines.  */\n@@ -1192,7 +1197,8 @@ _cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n   /* Is this a function-like macro?  */\n   if (* CUR (context) == '(')\n     {\n-      bool ok = scan_parameters (pfile, macro);\n+      bool ok = scan_parameters (pfile, &nparms);\n+      macro->paramc = nparms;\n \n       /* Remember the params so we can clear NODE_MACRO_ARG flags.  */\n       macro->params = (cpp_hashnode **) BUFF_FRONT (pfile->a_buff);\n@@ -1217,6 +1223,8 @@ _cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n   _cpp_scan_out_logical_line (pfile, macro, false);\n   pfile->state.prevent_expansion--;\n \n+  _cpp_unsave_parameters (pfile, nparms);\n+\n   if (!macro)\n     return false;\n "}]}