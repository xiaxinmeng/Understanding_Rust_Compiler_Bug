{"sha": "b846c948f29c4b56d6c14a509df4164049dabbd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg0NmM5NDhmMjljNGI1NmQ2YzE0YTUwOWRmNDE2NDA0OWRhYmJkMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-01-24T01:56:48Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-01-24T01:56:48Z"}, "message": "re PR target/59909 (Quad memory bootstrap issues on little endian powerpc64 power8 systems)\n\n[gcc]\n2014-01-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/59909\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document\n\t-mquad-memory-atomic.  Update -mquad-memory documentation to say\n\tit is only used for non-atomic loads/stores.\n\n\t* config/rs6000/predicates.md (quad_int_reg_operand): Allow either\n\t-mquad-memory or -mquad-memory-atomic switches.\n\n\t* config/rs6000/rs6000-cpus.def (ISA_2_7_MASKS_SERVER): Add\n\t-mquad-memory-atomic to ISA 2.07 support.\n\n\t* config/rs6000/rs6000.opt (-mquad-memory-atomic): Add new switch\n\tto separate support of normal quad word memory operations (ldq,\n\tstq) from the atomic quad word memory operations.\n\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Add\n\tsupport to separate non-atomic quad word operations from atomic\n\tquad word operations.  Disable non-atomic quad word operations in\n\tlittle endian mode so that we don't have to swap words after the\n\tload and before the store.\n\t(quad_load_store_p): Add comment about atomic quad word support.\n\t(rs6000_opt_masks): Add -mquad-memory-atomic to the list of\n\toptions printed with -mdebug=reg.\n\n\t* config/rs6000/rs6000.h (TARGET_SYNC_TI): Use\n\t-mquad-memory-atomic as the test for whether we have quad word\n\tatomic instructions.\n\t(TARGET_SYNC_HI_QI): If either -mquad-memory-atomic,\n\t-mquad-memory, or -mp8-vector are used, allow byte/half-word\n\tatomic operations.\n\n\t* config/rs6000/sync.md (load_lockedti): Insure that the address\n\tis a proper indexed or indirect address for the lqarx instruction.\n\tOn little endian systems, swap the hi/lo registers after the lqarx\n\tinstruction.\n\t(load_lockedpti): Use indexed_or_indirect_operand predicate to\n\tinsure the address is valid for the lqarx instruction.\n\t(store_conditionalti): Insure that the address is a proper indexed\n\tor indirect address for the stqcrx. instruction.  On little endian\n\tsystems, swap the hi/lo registers before doing the stqcrx.\n\tinstruction.\n\t(store_conditionalpti): Use indexed_or_indirect_operand predicate to\n\tinsure the address is valid for the stqcrx. instruction.\n\n\t* gcc/config/rs6000/rs6000-c.c (rs6000_target_modify_macros):\n\tDefine __QUAD_MEMORY__ and __QUAD_MEMORY_ATOMIC__ based on what\n\ttype of quad memory support is available.\n\n[gcc/testsuite]\n2014-01-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/59909\n\t* gcc.target/powerpc/quad-atomic.c: New file to test power8 quad\n\tword atomic functions at runtime.\n\nFrom-SVN: r207020", "tree": {"sha": "0db8047bb3fba3f07c9e23a6a12f99413bbfbd80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0db8047bb3fba3f07c9e23a6a12f99413bbfbd80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b846c948f29c4b56d6c14a509df4164049dabbd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b846c948f29c4b56d6c14a509df4164049dabbd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b846c948f29c4b56d6c14a509df4164049dabbd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b846c948f29c4b56d6c14a509df4164049dabbd3/comments", "author": null, "committer": null, "parents": [{"sha": "9eb3a1d30b85f2ec0e94b5ea4e1539be82ac51c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb3a1d30b85f2ec0e94b5ea4e1539be82ac51c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb3a1d30b85f2ec0e94b5ea4e1539be82ac51c2"}], "stats": {"total": 265, "additions": 240, "deletions": 25}, "files": [{"sha": "cd0e03d8647e116be30c9f78d5fdc9a8bad61de0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -1,3 +1,53 @@\n+2014-01-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/59909\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document\n+\t-mquad-memory-atomic.  Update -mquad-memory documentation to say\n+\tit is only used for non-atomic loads/stores.\n+\n+\t* config/rs6000/predicates.md (quad_int_reg_operand): Allow either\n+\t-mquad-memory or -mquad-memory-atomic switches.\n+\n+\t* config/rs6000/rs6000-cpus.def (ISA_2_7_MASKS_SERVER): Add\n+\t-mquad-memory-atomic to ISA 2.07 support.\n+\n+\t* config/rs6000/rs6000.opt (-mquad-memory-atomic): Add new switch\n+\tto separate support of normal quad word memory operations (ldq,\n+\tstq) from the atomic quad word memory operations.\n+\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Add\n+\tsupport to separate non-atomic quad word operations from atomic\n+\tquad word operations.  Disable non-atomic quad word operations in\n+\tlittle endian mode so that we don't have to swap words after the\n+\tload and before the store.\n+\t(quad_load_store_p): Add comment about atomic quad word support.\n+\t(rs6000_opt_masks): Add -mquad-memory-atomic to the list of\n+\toptions printed with -mdebug=reg.\n+\n+\t* config/rs6000/rs6000.h (TARGET_SYNC_TI): Use\n+\t-mquad-memory-atomic as the test for whether we have quad word\n+\tatomic instructions.\n+\t(TARGET_SYNC_HI_QI): If either -mquad-memory-atomic,\n+\t-mquad-memory, or -mp8-vector are used, allow byte/half-word\n+\tatomic operations.\n+\n+\t* config/rs6000/sync.md (load_lockedti): Insure that the address\n+\tis a proper indexed or indirect address for the lqarx instruction.\n+\tOn little endian systems, swap the hi/lo registers after the lqarx\n+\tinstruction.\n+\t(load_lockedpti): Use indexed_or_indirect_operand predicate to\n+\tinsure the address is valid for the lqarx instruction.\n+\t(store_conditionalti): Insure that the address is a proper indexed\n+\tor indirect address for the stqcrx. instruction.  On little endian\n+\tsystems, swap the hi/lo registers before doing the stqcrx.\n+\tinstruction.\n+\t(store_conditionalpti): Use indexed_or_indirect_operand predicate to\n+\tinsure the address is valid for the stqcrx. instruction.\n+\n+\t* gcc/config/rs6000/rs6000-c.c (rs6000_target_modify_macros):\n+\tDefine __QUAD_MEMORY__ and __QUAD_MEMORY_ATOMIC__ based on what\n+\ttype of quad memory support is available.\n+\n 2014-01-23  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR regression/59915"}, {"sha": "7b1121ddb7662364942a1a54c4c83554169a0c86", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -270,7 +270,7 @@\n {\n   HOST_WIDE_INT r;\n \n-  if (!TARGET_QUAD_MEMORY)\n+  if (!TARGET_QUAD_MEMORY && !TARGET_QUAD_MEMORY_ATOMIC)\n     return 0;\n \n   if (GET_CODE (op) == SUBREG)\n@@ -624,6 +624,7 @@\n        (match_test \"offsettable_nonstrict_memref_p (op)\")))\n \n ;; Return 1 if the operand is suitable for load/store quad memory.\n+;; This predicate only checks for non-atomic loads/stores.\n (define_predicate \"quad_memory_operand\"\n   (match_code \"mem\")\n {"}, {"sha": "acdd4b497771cc9e10caa02d49e3852e1871a73a", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -339,6 +339,10 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n     rs6000_define_or_undefine_macro (define_p, \"__HTM__\");\n   if ((flags & OPTION_MASK_P8_VECTOR) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"__POWER8_VECTOR__\");\n+  if ((flags & OPTION_MASK_QUAD_MEMORY) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"__QUAD_MEMORY__\");\n+  if ((flags & OPTION_MASK_QUAD_MEMORY_ATOMIC) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"__QUAD_MEMORY_ATOMIC__\");\n   if ((flags & OPTION_MASK_CRYPTO) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"__CRYPTO__\");\n "}, {"sha": "b17fd0d720705af1e1a4c14223d0c934208d95d7", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -53,7 +53,8 @@\n \t\t\t\t | OPTION_MASK_CRYPTO\t\t\t\\\n \t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n-\t\t\t\t | OPTION_MASK_QUAD_MEMORY)\n+\t\t\t\t | OPTION_MASK_QUAD_MEMORY\t\t\\\n+  \t\t\t\t | OPTION_MASK_QUAD_MEMORY_ATOMIC)\n \n #define POWERPC_7400_MASK\t(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)\n "}, {"sha": "867b8e86927491799ff93c3b2f015d1167382ea5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -3357,14 +3357,37 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* The quad memory instructions only works in 64-bit mode. In 32-bit mode,\n      silently turn off quad memory mode.  */\n-  if (TARGET_QUAD_MEMORY && !TARGET_POWERPC64)\n+  if ((TARGET_QUAD_MEMORY || TARGET_QUAD_MEMORY_ATOMIC) && !TARGET_POWERPC64)\n     {\n       if ((rs6000_isa_flags_explicit & OPTION_MASK_QUAD_MEMORY) != 0)\n \twarning (0, N_(\"-mquad-memory requires 64-bit mode\"));\n \n+      if ((rs6000_isa_flags_explicit & OPTION_MASK_QUAD_MEMORY_ATOMIC) != 0)\n+\twarning (0, N_(\"-mquad-memory-atomic requires 64-bit mode\"));\n+\n+      rs6000_isa_flags &= ~(OPTION_MASK_QUAD_MEMORY\n+\t\t\t    | OPTION_MASK_QUAD_MEMORY_ATOMIC);\n+    }\n+\n+  /* Non-atomic quad memory load/store are disabled for little endian, since\n+     the words are reversed, but atomic operations can still be done by\n+     swapping the words.  */\n+  if (TARGET_QUAD_MEMORY && !WORDS_BIG_ENDIAN)\n+    {\n+      if ((rs6000_isa_flags_explicit & OPTION_MASK_QUAD_MEMORY) != 0)\n+\twarning (0, N_(\"-mquad-memory is not available in little endian mode\"));\n+\n       rs6000_isa_flags &= ~OPTION_MASK_QUAD_MEMORY;\n     }\n \n+  /* Assume if the user asked for normal quad memory instructions, they want\n+     the atomic versions as well, unless they explicity told us not to use quad\n+     word atomic instructions.  */\n+  if (TARGET_QUAD_MEMORY\n+      && !TARGET_QUAD_MEMORY_ATOMIC\n+      && ((rs6000_isa_flags_explicit & OPTION_MASK_QUAD_MEMORY_ATOMIC) == 0))\n+    rs6000_isa_flags |= OPTION_MASK_QUAD_MEMORY_ATOMIC;\n+\n   /* Enable power8 fusion if we are tuning for power8, even if we aren't\n      generating power8 instructions.  */\n   if (!(rs6000_isa_flags_explicit & OPTION_MASK_P8_FUSION))\n@@ -5940,7 +5963,8 @@ direct_move_p (rtx op0, rtx op1)\n   return false;\n }\n \n-/* Return true if this is a load or store quad operation.  */\n+/* Return true if this is a load or store quad operation.  This function does\n+   not handle the atomic quad memory instructions.  */\n \n bool\n quad_load_store_p (rtx op0, rtx op1)\n@@ -30754,6 +30778,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"powerpc-gfxopt\",\t\tOPTION_MASK_PPC_GFXOPT,\t\tfalse, true  },\n   { \"powerpc-gpopt\",\t\tOPTION_MASK_PPC_GPOPT,\t\tfalse, true  },\n   { \"quad-memory\",\t\tOPTION_MASK_QUAD_MEMORY,\tfalse, true  },\n+  { \"quad-memory-atomic\",\tOPTION_MASK_QUAD_MEMORY_ATOMIC,\tfalse, true  },\n   { \"recip-precision\",\t\tOPTION_MASK_RECIP_PRECISION,\tfalse, true  },\n   { \"string\",\t\t\tOPTION_MASK_STRING,\t\tfalse, true  },\n   { \"update\",\t\t\tOPTION_MASK_NO_UPDATE,\t\ttrue , true  },"}, {"sha": "5e30879a0659693bfdb9972e2c5bafac6c9c5d77", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -533,8 +533,11 @@ extern int rs6000_vector_align[];\n /* Byte/char syncs were added as phased in for ISA 2.06B, but are not present\n    in power7, so conditionalize them on p8 features.  TImode syncs need quad\n    memory support.  */\n-#define TARGET_SYNC_HI_QI\t(TARGET_QUAD_MEMORY || TARGET_DIRECT_MOVE)\n-#define TARGET_SYNC_TI\t\tTARGET_QUAD_MEMORY\n+#define TARGET_SYNC_HI_QI\t(TARGET_QUAD_MEMORY\t\t\t\\\n+\t\t\t\t || TARGET_QUAD_MEMORY_ATOMIC\t\t\\\n+\t\t\t\t || TARGET_DIRECT_MOVE)\n+\n+#define TARGET_SYNC_TI\t\tTARGET_QUAD_MEMORY_ATOMIC\n \n /* Power7 has both 32-bit load and store integer for the FPRs, so we don't need\n    to allocate the SDmode stack slot to get the value into the proper location"}, {"sha": "4c1a02a524ad56c6feaa768c6eea2673d943e72b", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -571,7 +571,11 @@ Use ISA 2.07 transactional memory (HTM) instructions\n \n mquad-memory\n Target Report Mask(QUAD_MEMORY) Var(rs6000_isa_flags)\n-Generate the quad word memory instructions (lq/stq/lqarx/stqcx).\n+Generate the quad word memory instructions (lq/stq).\n+\n+mquad-memory-atomic\n+Target Report Mask(QUAD_MEMORY_ATOMIC) Var(rs6000_isa_flags)\n+Generate the quad word memory atomic instructions (lqarx/stqcx).\n \n mcompat-align-parm\n Target Report Var(rs6000_compat_align_parm) Init(0) Save"}, {"sha": "7db439074cd0cba75e7dcb658a3aefd155f5a9db", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 60, "deletions": 16, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -204,25 +204,46 @@\n   \"<QHI:larx> %0,%y1\"\n   [(set_attr \"type\" \"load_l\")])\n \n-;; Use PTImode to get even/odd register pairs\n+;; Use PTImode to get even/odd register pairs.\n+;; Use a temporary register to force getting an even register for the\n+;; lqarx/stqcrx. instructions.  Normal optimizations will eliminate this extra\n+;; copy on big endian systems.\n+\n+;; On little endian systems where non-atomic quad word load/store instructions\n+;; are not used, the address can be register+offset, so make sure the address\n+;; is indexed or indirect before register allocation.\n+\n (define_expand \"load_lockedti\"\n   [(use (match_operand:TI 0 \"quad_int_reg_operand\" \"\"))\n    (use (match_operand:TI 1 \"memory_operand\" \"\"))]\n   \"TARGET_SYNC_TI\"\n {\n-  /* Use a temporary register to force getting an even register for the\n-     lqarx/stqcrx. instructions.  Normal optimizations will eliminate this\n-     extra copy.  */\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n   rtx pti = gen_reg_rtx (PTImode);\n-  emit_insn (gen_load_lockedpti (pti, operands[1]));\n-  emit_move_insn (operands[0], gen_lowpart (TImode, pti));\n+\n+  if (!indexed_or_indirect_operand (op1, TImode))\n+    {\n+      rtx old_addr = XEXP (op1, 0);\n+      rtx new_addr = force_reg (Pmode, old_addr);\n+      operands[1] = op1 = change_address (op1, TImode, new_addr);\n+    }\n+\n+  emit_insn (gen_load_lockedpti (pti, op1));\n+  if (WORDS_BIG_ENDIAN)\n+    emit_move_insn (op0, gen_lowpart (TImode, pti));\n+  else\n+    {\n+      emit_move_insn (gen_lowpart (DImode, op0), gen_highpart (DImode, pti));\n+      emit_move_insn (gen_highpart (DImode, op0), gen_lowpart (DImode, pti));\n+    }\n   DONE;\n })\n \n (define_insn \"load_lockedpti\"\n   [(set (match_operand:PTI 0 \"quad_int_reg_operand\" \"=&r\")\n \t(unspec_volatile:PTI\n-         [(match_operand:TI 1 \"memory_operand\" \"Z\")] UNSPECV_LL))]\n+         [(match_operand:TI 1 \"indexed_or_indirect_operand\" \"Z\")] UNSPECV_LL))]\n   \"TARGET_SYNC_TI\n    && !reg_mentioned_p (operands[0], operands[1])\n    && quad_int_reg_operand (operands[0], PTImode)\"\n@@ -238,6 +259,14 @@\n   \"<stcx> %2,%y1\"\n   [(set_attr \"type\" \"store_c\")])\n \n+;; Use a temporary register to force getting an even register for the\n+;; lqarx/stqcrx. instructions.  Normal optimizations will eliminate this extra\n+;; copy on big endian systems.\n+\n+;; On little endian systems where non-atomic quad word load/store instructions\n+;; are not used, the address can be register+offset, so make sure the address\n+;; is indexed or indirect before register allocation.\n+\n (define_expand \"store_conditionalti\"\n   [(use (match_operand:CC 0 \"cc_reg_operand\" \"\"))\n    (use (match_operand:TI 1 \"memory_operand\" \"\"))\n@@ -247,21 +276,36 @@\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n   rtx op2 = operands[2];\n-  rtx pti_op1 = change_address (op1, PTImode, XEXP (op1, 0));\n-  rtx pti_op2 = gen_reg_rtx (PTImode);\n-\n-  /* Use a temporary register to force getting an even register for the\n-     lqarx/stqcrx. instructions.  Normal optimizations will eliminate this\n-     extra copy.  */\n-  emit_move_insn (pti_op2, gen_lowpart (PTImode, op2));\n-  emit_insn (gen_store_conditionalpti (op0, pti_op1, pti_op2));\n+  rtx addr = XEXP (op1, 0);\n+  rtx pti_mem;\n+  rtx pti_reg;\n+\n+  if (!indexed_or_indirect_operand (op1, TImode))\n+    {\n+      rtx new_addr = force_reg (Pmode, addr);\n+      operands[1] = op1 = change_address (op1, TImode, new_addr);\n+      addr = new_addr;\n+    }\n+\n+  pti_mem = change_address (op1, PTImode, addr);\n+  pti_reg = gen_reg_rtx (PTImode);\n+\n+  if (WORDS_BIG_ENDIAN)\n+    emit_move_insn (pti_reg, gen_lowpart (PTImode, op2));\n+  else\n+    {\n+      emit_move_insn (gen_lowpart (DImode, pti_reg), gen_highpart (DImode, op2));\n+      emit_move_insn (gen_highpart (DImode, pti_reg), gen_lowpart (DImode, op2));\n+    }\n+\n+  emit_insn (gen_store_conditionalpti (op0, pti_mem, pti_reg));\n   DONE;\n })\n \n (define_insn \"store_conditionalpti\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(unspec_volatile:CC [(const_int 0)] UNSPECV_SC))\n-   (set (match_operand:PTI 1 \"memory_operand\" \"=Z\")\n+   (set (match_operand:PTI 1 \"indexed_or_indirect_operand\" \"=Z\")\n \t(match_operand:PTI 2 \"quad_int_reg_operand\" \"r\"))]\n   \"TARGET_SYNC_TI && quad_int_reg_operand (operands[2], PTImode)\"\n   \"stqcx. %2,%y1\""}, {"sha": "8c620a523c8083f6457f617752c5224d8bbbb1a4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -919,6 +919,7 @@ See RS/6000 and PowerPC Options.\n -mpower8-fusion -mno-mpower8-fusion -mpower8-vector -mno-power8-vector @gol\n -mcrypto -mno-crypto -mdirect-move -mno-direct-move @gol\n -mquad-memory -mno-quad-memory @gol\n+-mquad-memory-atomic -mno-quad-memory-atomic @gol\n -mcompat-align-parm -mno-compat-align-parm}\n \n @emph{RX Options}\n@@ -18853,7 +18854,8 @@ following options:\n -mpopcntb -mpopcntd  -mpowerpc64 @gol\n -mpowerpc-gpopt  -mpowerpc-gfxopt  -msingle-float -mdouble-float @gol\n -msimple-fpu -mstring  -mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol\n--mcrypto -mdirect-move -mpower8-fusion -mpower8-vector -mquad-memory}\n+-mcrypto -mdirect-move -mpower8-fusion -mpower8-vector @gol\n+-mquad-memory -mquad-memory-atomic}\n \n The particular options set for any particular CPU varies between\n compiler versions, depending on what setting seems to produce optimal\n@@ -19040,10 +19042,18 @@ the vector instructions.\n @itemx -mno-quad-memory\n @opindex mquad-memory\n @opindex mno-quad-memory\n-Generate code that uses (does not use) the quad word memory\n+Generate code that uses (does not use) the non-atomic quad word memory\n instructions.  The @option{-mquad-memory} option requires use of\n 64-bit mode.\n \n+@item -mquad-memory-atomic\n+@itemx -mno-quad-memory-atomic\n+@opindex mquad-memory-atomic\n+@opindex mno-quad-memory-atomic\n+Generate code that uses (does not use) the atomic quad word memory\n+instructions.  The @option{-mquad-memory-atomic} option requires use of\n+64-bit mode.\n+\n @item -mfloat-gprs=@var{yes/single/double/no}\n @itemx -mfloat-gprs\n @opindex mfloat-gprs"}, {"sha": "1240250b7b816c74aee0ffb89790559466c445f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -1,3 +1,9 @@\n+2014-01-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/59909\n+\t* gcc.target/powerpc/quad-atomic.c: New file to test power8 quad\n+\tword atomic functions at runtime.\n+\n 2014-01-23  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/59846"}, {"sha": "6cf278852d74d309cddaea7fedb7af63eff6a8b9", "filename": "gcc/testsuite/gcc.target/powerpc/quad-atomic.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fquad-atomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b846c948f29c4b56d6c14a509df4164049dabbd3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fquad-atomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fquad-atomic.c?ref=b846c948f29c4b56d6c14a509df4164049dabbd3", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Test whether we get the right bits for quad word atomic instructions.  */\n+#include <stdlib.h>\n+\n+static __int128_t quad_fetch_and (__int128_t *, __int128_t value) __attribute__((__noinline__));\n+static __int128_t quad_fetch_or  (__int128_t *, __int128_t value) __attribute__((__noinline__));\n+static __int128_t quad_fetch_add (__int128_t *, __int128_t value) __attribute__((__noinline__));\n+\n+static __int128_t\n+quad_fetch_and (__int128_t *ptr, __int128_t value)\n+{\n+  return __atomic_fetch_and (ptr, value, __ATOMIC_ACQUIRE);\n+}\n+\n+static __int128_t\n+quad_fetch_or (__int128_t *ptr, __int128_t value)\n+{\n+  return __atomic_fetch_or (ptr, value, __ATOMIC_ACQUIRE);\n+}\n+\n+static __int128_t\n+quad_fetch_add (__int128_t *ptr, __int128_t value)\n+{\n+  return __atomic_fetch_add (ptr, value, __ATOMIC_ACQUIRE);\n+}\n+\n+int\n+main (void)\n+{\n+  __int128_t result;\n+  __int128_t value;\n+  __int128_t and_input\t= ((((__int128_t) 0x1234567890abcdefULL) << 64) | ((__int128_t) 0xfedcba0987654321ULL));\n+  __int128_t and_value\t= ((((__int128_t) 0xfffffffffffffff0ULL) << 64) | ((__int128_t) 0xfffffffffffffff0ULL));\n+  __int128_t and_exp\t= ((((__int128_t) 0x1234567890abcde0ULL) << 64) | ((__int128_t) 0xfedcba0987654320ULL));\n+\n+  __int128_t or_input\t= ((((__int128_t) 0x1234567890abcdefULL) << 64) | ((__int128_t) 0xfedcba0987654321ULL));\n+  __int128_t or_value\t= ((((__int128_t) 0x0000000000000010ULL) << 64) | ((__int128_t) 0x000000000000000eULL));\n+  __int128_t or_exp\t= ((((__int128_t) 0x1234567890abcdffULL) << 64) | ((__int128_t) 0xfedcba098765432fULL));\n+\n+  __int128_t add_input\t= ((((__int128_t) 0x1234567890abcdefULL) << 64) | ((__int128_t) 0xfedcba0987654321ULL));\n+  __int128_t add_value\t= ((((__int128_t) 0x0000000001000000ULL) << 64) | ((__int128_t) 0x0000001000000000ULL));\n+  __int128_t add_exp\t= ((((__int128_t) 0x1234567891abcdefULL) << 64) | ((__int128_t) 0xfedcba1987654321ULL));\n+\n+\n+  value = and_input;\n+  result = quad_fetch_and (&value, and_value);\n+  if (result != and_input || value != and_exp)\n+    abort ();\n+\n+  value = or_input;\n+  result = quad_fetch_or (&value, or_value);\n+  if (result != or_input || value != or_exp)\n+    abort ();\n+\n+  value = add_input;\n+  result = quad_fetch_add (&value, add_value);\n+  if (result != add_input || value != add_exp)\n+    abort ();\n+\n+  return 0;\n+}\n+"}]}