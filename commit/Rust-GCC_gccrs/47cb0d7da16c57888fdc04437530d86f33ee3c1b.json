{"sha": "47cb0d7da16c57888fdc04437530d86f33ee3c1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdjYjBkN2RhMTZjNTc4ODhmZGMwNDQzNzUzMGQ4NmYzM2VlM2MxYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-12-10T20:50:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-12-10T20:50:47Z"}, "message": "re PR middle-end/42228 (verify_cgraph_node failed:node has wrong clone_of)\n\n\n\tPR middle-end/42228\n\tPR middle-end/42110\n\t* cgraph.c (cgraph_create_edge_including_clones): Add old_stmt parameter;\n\tupdate edge if it already exists.\n\t(cgraph_remove_node): Handle correctly cases where we are removing node having\n\tclones.\n\t* cgraph.h (cgraph_create_edge_including_clones): Declare.\n\t(verify_cgraph_node): Add missing error_found = true code.\n\t(cgraph_materialize_all_clones): Remove call edges of dead nodes.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Correctly look for master\n\tclone; fix double linked list removal.\n\t* tree-inline.c (copy_bb): Update cgraph_create_edge_including_clones call;\n\tfix frequency of newly created edge.\n\n\t* g++.dg/torture/pr42110.C: new file.\n\nFrom-SVN: r155140", "tree": {"sha": "4b7897c70e32ed3a7ade0ed23cc48ffbcd023f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b7897c70e32ed3a7ade0ed23cc48ffbcd023f09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47cb0d7da16c57888fdc04437530d86f33ee3c1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47cb0d7da16c57888fdc04437530d86f33ee3c1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47cb0d7da16c57888fdc04437530d86f33ee3c1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47cb0d7da16c57888fdc04437530d86f33ee3c1b/comments", "author": null, "committer": null, "parents": [{"sha": "604df1167c464da3710e28270e6561d427df0444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604df1167c464da3710e28270e6561d427df0444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/604df1167c464da3710e28270e6561d427df0444"}], "stats": {"total": 138, "additions": 118, "deletions": 20}, "files": [{"sha": "b027bc9f162ebfd0b1d146d9f50afc5de6c663dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -1,3 +1,19 @@\n+2009-12-10  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/42228\n+\tPR middle-end/42110\n+\t* cgraph.c (cgraph_create_edge_including_clones): Add old_stmt parameter;\n+\tupdate edge if it already exists.\n+\t(cgraph_remove_node): Handle correctly cases where we are removing node having\n+\tclones.\n+\t* cgraph.h (cgraph_create_edge_including_clones): Declare.\n+\t(verify_cgraph_node): Add missing error_found = true code.\n+\t(cgraph_materialize_all_clones): Remove call edges of dead nodes.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Correctly look for master\n+\tclone; fix double linked list removal.\n+\t* tree-inline.c (copy_bb): Update cgraph_create_edge_including_clones call;\n+\tfix frequency of newly created edge.\n+\n 2009-12-10  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \tPR rtl-opt/42216"}, {"sha": "a3efdfc0ce10da76ff71b6e74535476f498c286e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -829,14 +829,16 @@ cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n }\n \n /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n-   same function body.\n+   same function body.  If clones already have edge for OLD_STMT; only\n+   update the edge same way as cgraph_set_call_stmt_including_clones does.\n \n    TODO: COUNT and LOOP_DEPTH should be properly distributed based on relative\n    frequencies of the clones.  */\n \n void\n cgraph_create_edge_including_clones (struct cgraph_node *orig,\n \t\t\t\t     struct cgraph_node *callee,\n+\t\t\t\t     gimple old_stmt,\n \t\t\t\t     gimple stmt, gcov_type count,\n \t\t\t\t     int freq, int loop_depth,\n \t\t\t\t     cgraph_inline_failed_t reason)\n@@ -854,9 +856,15 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n   if (node)\n     while (node != orig)\n       {\n-        /* It is possible that we already constant propagated into the clone\n-\t   and turned indirect call into dirrect call.  */\n-        if (!cgraph_edge (node, stmt))\n+\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n+\n+        /* It is possible that clones already contain the edge while\n+\t   master didn't.  Either we promoted indirect call into direct\n+\t   call in the clone or we are processing clones of unreachable\n+\t   master where edges has been rmeoved.  */\n+\tif (edge)\n+\t  cgraph_set_call_stmt (edge, stmt);\n+\telse if (!cgraph_edge (node, stmt))\n \t  {\n \t    edge = cgraph_create_edge (node, callee, stmt, count,\n \t\t\t\t       freq, loop_depth);\n@@ -1337,11 +1345,15 @@ cgraph_remove_node (struct cgraph_node *node)\n \t      = next_inline_clone->prev_sibling_clone;\n \t  if (next_inline_clone->prev_sibling_clone)\n \t    {\n+\t      gcc_assert (node->clones != next_inline_clone);\n \t      next_inline_clone->prev_sibling_clone->next_sibling_clone\n \t        = next_inline_clone->next_sibling_clone;\n \t    }\n \t  else\n-\t   node->clones = next_inline_clone->next_sibling_clone;\n+\t    {\n+\t      gcc_assert (node->clones == next_inline_clone);\n+\t      node->clones = next_inline_clone->next_sibling_clone;\n+\t    }\n \n \t  new_clones = node->clones;\n \t  node->clones = NULL;\n@@ -1355,6 +1367,8 @@ cgraph_remove_node (struct cgraph_node *node)\n \t  next_inline_clone->next_sibling_clone = NULL;\n \t  if (node->clone_of)\n \t    {\n+\t      if (node->clone_of->clones)\n+\t        node->clone_of->clones->prev_sibling_clone = next_inline_clone;\n \t      next_inline_clone->next_sibling_clone = node->clone_of->clones;\n \t      node->clone_of->clones = next_inline_clone;\n \t    }\n@@ -1389,8 +1403,6 @@ cgraph_remove_node (struct cgraph_node *node)\n \t}\n \n     }\n-  else\n-    gcc_assert (node->clone_of);\n   if (node->prev_sibling_clone)\n     node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n   else if (node->clone_of)\n@@ -1399,15 +1411,33 @@ cgraph_remove_node (struct cgraph_node *node)\n     node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n   if (node->clones)\n     {\n-      struct cgraph_node *n;\n+      struct cgraph_node *n, *next;\n \n-      for (n = node->clones; n->next_sibling_clone; n = n->next_sibling_clone)\n-\tn->clone_of = node->clone_of;\n-      n->clone_of = node->clone_of;\n-      n->next_sibling_clone = node->clone_of->clones;\n-      if (node->clone_of->clones)\n-\tnode->clone_of->clones->prev_sibling_clone = n;\n-      node->clone_of->clones = node->clones;\n+      if (node->clone_of)\n+        {\n+\t  for (n = node->clones; n->next_sibling_clone; n = n->next_sibling_clone)\n+\t    n->clone_of = node->clone_of;\n+\t  n->clone_of = node->clone_of;\n+\t  n->next_sibling_clone = node->clone_of->clones;\n+\t  if (node->clone_of->clones)\n+\t    node->clone_of->clones->prev_sibling_clone = n;\n+\t  node->clone_of->clones = node->clones;\n+\t}\n+      else\n+        {\n+\t  /* We are removing node with clones.  this makes clones inconsistent,\n+\t     but assume they will be removed subsequently and just keep clone\n+\t     tree intact.  This can happen in unreachable function removal since\n+\t     we remove unreachable functions in random order, not by bottom-up\n+\t     walk of clone trees.  */\n+\t  for (n = node->clones; n; n = next)\n+\t    {\n+\t       next = n->next_sibling_clone;\n+\t       n->next_sibling_clone = NULL;\n+\t       n->prev_sibling_clone = NULL;\n+\t       n->clone_of = NULL;\n+\t    }\n+\t}\n     }\n \n   while (node->same_body)"}, {"sha": "51426e60ab72b5762d909d58b76de5e8dc060688", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -445,7 +445,7 @@ void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple);\n void cgraph_create_edge_including_clones (struct cgraph_node *,\n \t\t\t\t\t  struct cgraph_node *,\n-\t\t\t\t\t  gimple, gcov_type, int, int,\n+\t\t\t\t\t  gimple, gimple, gcov_type, int, int,\n \t\t\t\t\t  cgraph_inline_failed_t);\n void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);"}, {"sha": "58bdd8512c2e0e50f7c57130314966a30446d8c4", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -749,6 +749,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t  {\n \t\t\t    error (\"edge points to same body alias:\");\n \t\t\t    debug_tree (e->callee->decl);\n+\t\t\t    error_found = true;\n \t\t\t  }\n \t\t\telse if (!clone_of_p (cgraph_node (decl), e->callee)\n \t\t\t         && !e->callee->global.inlined_to)\n@@ -757,6 +758,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t    debug_tree (e->callee->decl);\n \t\t\t    fprintf (stderr,\" Instead of:\");\n \t\t\t    debug_tree (decl);\n+\t\t\t    error_found = true;\n \t\t\t  }\n \t\t\te->aux = (void *)1;\n \t\t      }\n@@ -2248,6 +2250,9 @@ cgraph_materialize_all_clones (void)\n \t    }\n \t}\n     }\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (!node->analyzed && node->callees)\n+      cgraph_node_remove_callees (node);\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Updating call sites\\n\");\n   for (node = cgraph_nodes; node; node = node->next)"}, {"sha": "708b800a1a60c991b3dc437cab22b2a4379b4641", "filename": "gcc/ipa.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -179,11 +179,21 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t          first = e->callee;\n \t        }\n \t    }\n+\t\n+      /* We can freely remove inline clones even if they are cloned, however if\n+\t function is clone of real clone, we must keep it around in order to\n+\t make materialize_clones produce function body with the changes\n+\t applied.  */\n       while (node->clone_of && !node->clone_of->aux && !gimple_has_body_p (node->decl))\n         {\n+\t  bool noninline = node->clone_of->decl != node->decl;\n \t  node = node->clone_of;\n-\t  node->aux = first;\n-\t  first = node;\n+\t  if (noninline)\n+\t    {\n+\t      node->aux = first;\n+\t      first = node;\n+\t      break;\n+\t    }\n \t}\n     }\n \n@@ -244,6 +254,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t    node->clone_of->clones = node->next_sibling_clone;\n \t\t  if (node->next_sibling_clone)\n \t\t    node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n+\t\t  node->clone_of = NULL;\n+\t\t  node->next_sibling_clone = NULL;\n+\t\t  node->prev_sibling_clone = NULL;\n \t\t}\n \t      else\n \t\tcgraph_remove_node (node);"}, {"sha": "fd0628f5207a0bf3b56dbd07a90c9273148dc1e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -1,3 +1,8 @@\n+2009-12-10  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/42110\n+\t* g++.dg/torture/pr42110.C: new file.\n+\n 2009-12-10  Daniel Franke  <franke.daniel@gmail.com>\n \n         PR fortran/34402"}, {"sha": "c778b4f2fd73db3b7f85a527535c3655d8b36c69", "filename": "gcc/testsuite/g++.dg/torture/pr42110.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr42110.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr42110.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr42110.C?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+bool foo();\n+\n+struct A\n+{\n+  A* fooA() { if (foo()) foo(); return this; }\n+\n+  virtual void barA(char);\n+};\n+\n+template<int> struct B\n+{\n+  A *p, *q;\n+\n+  void fooB(char c) { p->fooA()->barA(c); }\n+};\n+\n+template<int N> inline void bar(B<N> b) { b.fooB(0); }\n+\n+extern template void bar(B<0>);\n+\n+void (*f)(B<0>) = bar;\n+\n+void baz()\n+{\n+  B<0>().fooB(0);\n+}"}, {"sha": "aacd903bac532cdcae8c11f2dfd2c860f170ddc9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47cb0d7da16c57888fdc04437530d86f33ee3c1b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=47cb0d7da16c57888fdc04437530d86f33ee3c1b", "patch": "@@ -1694,13 +1694,15 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  \t      || !id->src_node->analyzed);\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    cgraph_create_edge_including_clones\n-\t\t      (id->dst_node, dest, stmt, bb->count,\n+\t\t      (id->dst_node, dest, orig_stmt, stmt, bb->count,\n \t\t       compute_call_stmt_bb_frequency (id->dst_node->decl,\n \t\t       \t\t\t\t       copy_basic_block),\n \t\t       bb->loop_depth, CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n \t\t    cgraph_create_edge (id->dst_node, dest, stmt,\n-\t\t\t\t\tbb->count, CGRAPH_FREQ_BASE,\n+\t\t\t\t\tbb->count,\n+\t\t\t\t\tcompute_call_stmt_bb_frequency\n+\t\t\t\t\t  (id->dst_node->decl, copy_basic_block),\n \t\t\t\t\tbb->loop_depth)->inline_failed\n \t\t      = CIF_ORIGINALLY_INDIRECT_CALL;\n \t\t  if (dump_file)"}]}