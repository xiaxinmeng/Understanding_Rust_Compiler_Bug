{"sha": "d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0OGI1ZmYzY2IyYmY3YWVjMzIwMzEyZTc5YzkwZTQ5Y2Q5YjM5Yg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2017-05-14T00:38:59Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2017-05-14T00:38:59Z"}, "message": "use auto_bitmap more with alternate obstacks\n\ngcc/ChangeLog:\n\n2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* df-core.c (df_set_blocks): Start using auto_bitmap.\n\t(df_compact_blocks): Likewise.\n\t* df-problems.c (df_rd_confluence_n): Likewise.\n\t* df-scan.c (df_insn_rescan_all): Likewise.\n\t(df_process_deferred_rescans): Likewise.\n\t(df_update_entry_block_defs): Likewise.\n\t(df_update_exit_block_uses): Likewise.\n\t(df_entry_block_bitmap_verify): Likewise.\n\t(df_exit_block_bitmap_verify): Likewise.\n\t(df_scan_verify): Likewise.\n\t* lra-constraints.c (lra_constraints): Likewise.\n\t(undo_optional_reloads): Likewise.\n\t(lra_undo_inheritance): Likewise.\n\t* lra-remat.c (calculate_gen_cands): Likewise.\n\t(do_remat): Likewise.\n\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n\t(spill_pseudos): Likewise.\n\t* tree-ssa-pre.c (bitmap_set_and): Likewise.\n\t(bitmap_set_subtract_values): Likewise.\n\nFrom-SVN: r248023", "tree": {"sha": "dcf7daa4381cf183540db2795959f7f418fc0e5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf7daa4381cf183540db2795959f7f418fc0e5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/comments", "author": null, "committer": null, "parents": [{"sha": "8f9b31f7f161bd00d9c7847f117591ec85f9484d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9b31f7f161bd00d9c7847f117591ec85f9484d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f9b31f7f161bd00d9c7847f117591ec85f9484d"}], "stats": {"total": 265, "additions": 120, "deletions": 145}, "files": [{"sha": "aeb0a3908a2bffd42b9c0894d79bb6caaf8b9481", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "patch": "@@ -1,3 +1,25 @@\n+2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* df-core.c (df_set_blocks): Start using auto_bitmap.\n+\t(df_compact_blocks): Likewise.\n+\t* df-problems.c (df_rd_confluence_n): Likewise.\n+\t* df-scan.c (df_insn_rescan_all): Likewise.\n+\t(df_process_deferred_rescans): Likewise.\n+\t(df_update_entry_block_defs): Likewise.\n+\t(df_update_exit_block_uses): Likewise.\n+\t(df_entry_block_bitmap_verify): Likewise.\n+\t(df_exit_block_bitmap_verify): Likewise.\n+\t(df_scan_verify): Likewise.\n+\t* lra-constraints.c (lra_constraints): Likewise.\n+\t(undo_optional_reloads): Likewise.\n+\t(lra_undo_inheritance): Likewise.\n+\t* lra-remat.c (calculate_gen_cands): Likewise.\n+\t(do_remat): Likewise.\n+\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n+\t(spill_pseudos): Likewise.\n+\t* tree-ssa-pre.c (bitmap_set_and): Likewise.\n+\t(bitmap_set_subtract_values): Likewise.\n+\n 2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* haifa-sched.c (estimate_shadow_tick): Replace manual bitmap"}, {"sha": "1b270d417aa652988a199f5a9dacf62e422bb1e0", "filename": "gcc/df-core.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "patch": "@@ -497,9 +497,8 @@ df_set_blocks (bitmap blocks)\n \t  /* This block is called to change the focus from one subset\n \t     to another.  */\n \t  int p;\n-\t  bitmap_head diff;\n-\t  bitmap_initialize (&diff, &df_bitmap_obstack);\n-\t  bitmap_and_compl (&diff, df->blocks_to_analyze, blocks);\n+\t  auto_bitmap diff (&df_bitmap_obstack);\n+\t  bitmap_and_compl (diff, df->blocks_to_analyze, blocks);\n \t  for (p = 0; p < df->num_problems_defined; p++)\n \t    {\n \t      struct dataflow *dflow = df->problems_in_order[p];\n@@ -510,7 +509,7 @@ df_set_blocks (bitmap blocks)\n \t\t  bitmap_iterator bi;\n \t\t  unsigned int bb_index;\n \n-\t\t  EXECUTE_IF_SET_IN_BITMAP (&diff, 0, bb_index, bi)\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (diff, 0, bb_index, bi)\n \t\t    {\n \t\t      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n \t\t      if (bb)\n@@ -522,8 +521,6 @@ df_set_blocks (bitmap blocks)\n \t\t    }\n \t\t}\n \t    }\n-\n-\t   bitmap_clear (&diff);\n \t}\n       else\n \t{\n@@ -1652,9 +1649,8 @@ df_compact_blocks (void)\n   int i, p;\n   basic_block bb;\n   void *problem_temps;\n-  bitmap_head tmp;\n \n-  bitmap_initialize (&tmp, &df_bitmap_obstack);\n+  auto_bitmap tmp (&df_bitmap_obstack);\n   for (p = 0; p < df->num_problems_defined; p++)\n     {\n       struct dataflow *dflow = df->problems_in_order[p];\n@@ -1663,17 +1659,17 @@ df_compact_blocks (void)\n \t dflow problem.  */\n       if (dflow->out_of_date_transfer_functions)\n \t{\n-\t  bitmap_copy (&tmp, dflow->out_of_date_transfer_functions);\n+\t  bitmap_copy (tmp, dflow->out_of_date_transfer_functions);\n \t  bitmap_clear (dflow->out_of_date_transfer_functions);\n-\t  if (bitmap_bit_p (&tmp, ENTRY_BLOCK))\n+\t  if (bitmap_bit_p (tmp, ENTRY_BLOCK))\n \t    bitmap_set_bit (dflow->out_of_date_transfer_functions, ENTRY_BLOCK);\n-\t  if (bitmap_bit_p (&tmp, EXIT_BLOCK))\n+\t  if (bitmap_bit_p (tmp, EXIT_BLOCK))\n \t    bitmap_set_bit (dflow->out_of_date_transfer_functions, EXIT_BLOCK);\n \n \t  i = NUM_FIXED_BLOCKS;\n \t  FOR_EACH_BB_FN (bb, cfun)\n \t    {\n-\t      if (bitmap_bit_p (&tmp, bb->index))\n+\t      if (bitmap_bit_p (tmp, bb->index))\n \t\tbitmap_set_bit (dflow->out_of_date_transfer_functions, i);\n \t      i++;\n \t    }\n@@ -1711,23 +1707,21 @@ df_compact_blocks (void)\n \n   if (df->blocks_to_analyze)\n     {\n-      if (bitmap_bit_p (&tmp, ENTRY_BLOCK))\n+      if (bitmap_bit_p (tmp, ENTRY_BLOCK))\n \tbitmap_set_bit (df->blocks_to_analyze, ENTRY_BLOCK);\n-      if (bitmap_bit_p (&tmp, EXIT_BLOCK))\n+      if (bitmap_bit_p (tmp, EXIT_BLOCK))\n \tbitmap_set_bit (df->blocks_to_analyze, EXIT_BLOCK);\n-      bitmap_copy (&tmp, df->blocks_to_analyze);\n+      bitmap_copy (tmp, df->blocks_to_analyze);\n       bitmap_clear (df->blocks_to_analyze);\n       i = NUM_FIXED_BLOCKS;\n       FOR_EACH_BB_FN (bb, cfun)\n \t{\n-\t  if (bitmap_bit_p (&tmp, bb->index))\n+\t  if (bitmap_bit_p (tmp, bb->index))\n \t    bitmap_set_bit (df->blocks_to_analyze, i);\n \t  i++;\n \t}\n     }\n \n-  bitmap_clear (&tmp);\n-\n   i = NUM_FIXED_BLOCKS;\n   FOR_EACH_BB_FN (bb, cfun)\n     {"}, {"sha": "755aecf46df2a7ec82f91c27d5e2f648ddf315d0", "filename": "gcc/df-problems.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "patch": "@@ -461,19 +461,17 @@ df_rd_confluence_n (edge e)\n       bitmap dense_invalidated = &problem_data->dense_invalidated_by_call;\n       bitmap_iterator bi;\n       unsigned int regno;\n-      bitmap_head tmp;\n \n-      bitmap_initialize (&tmp, &df_bitmap_obstack);\n-      bitmap_and_compl (&tmp, op2, dense_invalidated);\n+      auto_bitmap tmp (&df_bitmap_obstack);\n+      bitmap_and_compl (tmp, op2, dense_invalidated);\n \n       EXECUTE_IF_SET_IN_BITMAP (sparse_invalidated, 0, regno, bi)\n  \t{\n- \t  bitmap_clear_range (&tmp,\n+\t  bitmap_clear_range (tmp,\n  \t\t\t      DF_DEFS_BEGIN (regno),\n  \t\t\t      DF_DEFS_COUNT (regno));\n \t}\n-      changed |= bitmap_ior_into (op1, &tmp);\n-      bitmap_clear (&tmp);\n+      changed |= bitmap_ior_into (op1, tmp);\n       return changed;\n     }\n   else"}, {"sha": "4884608b167d459ac13ee4d19915863fff503f33", "filename": "gcc/df-scan.c", "status": "modified", "additions": 36, "deletions": 57, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "patch": "@@ -1161,9 +1161,6 @@ df_insn_rescan_all (void)\n   basic_block bb;\n   bitmap_iterator bi;\n   unsigned int uid;\n-  bitmap_head tmp;\n-\n-  bitmap_initialize (&tmp, &df_bitmap_obstack);\n \n   if (df->changeable_flags & DF_NO_INSN_RESCAN)\n     {\n@@ -1177,15 +1174,15 @@ df_insn_rescan_all (void)\n       defer_insn_rescan = true;\n     }\n \n-  bitmap_copy (&tmp, &df->insns_to_delete);\n-  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n+  auto_bitmap tmp (&df_bitmap_obstack);\n+  bitmap_copy (tmp, &df->insns_to_delete);\n+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n \tdf_insn_info_delete (uid);\n     }\n \n-  bitmap_clear (&tmp);\n   bitmap_clear (&df->insns_to_delete);\n   bitmap_clear (&df->insns_to_rescan);\n   bitmap_clear (&df->insns_to_notes_rescan);\n@@ -1215,9 +1212,6 @@ df_process_deferred_rescans (void)\n   bool defer_insn_rescan = false;\n   bitmap_iterator bi;\n   unsigned int uid;\n-  bitmap_head tmp;\n-\n-  bitmap_initialize (&tmp, &df_bitmap_obstack);\n \n   if (df->changeable_flags & DF_NO_INSN_RESCAN)\n     {\n@@ -1234,24 +1228,25 @@ df_process_deferred_rescans (void)\n   if (dump_file)\n     fprintf (dump_file, \"starting the processing of deferred insns\\n\");\n \n-  bitmap_copy (&tmp, &df->insns_to_delete);\n-  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n+  auto_bitmap tmp (&df_bitmap_obstack);\n+  bitmap_copy (tmp, &df->insns_to_delete);\n+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n \tdf_insn_info_delete (uid);\n     }\n \n-  bitmap_copy (&tmp, &df->insns_to_rescan);\n-  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n+  bitmap_copy (tmp, &df->insns_to_rescan);\n+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n \tdf_insn_rescan (insn_info->insn);\n     }\n \n-  bitmap_copy (&tmp, &df->insns_to_notes_rescan);\n-  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n+  bitmap_copy (tmp, &df->insns_to_notes_rescan);\n+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n@@ -1261,7 +1256,6 @@ df_process_deferred_rescans (void)\n   if (dump_file)\n     fprintf (dump_file, \"ending the processing of deferred insns\\n\");\n \n-  bitmap_clear (&tmp);\n   bitmap_clear (&df->insns_to_delete);\n   bitmap_clear (&df->insns_to_rescan);\n   bitmap_clear (&df->insns_to_notes_rescan);\n@@ -3628,14 +3622,13 @@ df_record_entry_block_defs (bitmap entry_block_defs)\n void\n df_update_entry_block_defs (void)\n {\n-  bitmap_head refs;\n   bool changed = false;\n \n-  bitmap_initialize (&refs, &df_bitmap_obstack);\n-  df_get_entry_block_def_set (&refs);\n+  auto_bitmap refs (&df_bitmap_obstack);\n+  df_get_entry_block_def_set (refs);\n   if (df->entry_block_defs)\n     {\n-      if (!bitmap_equal_p (df->entry_block_defs, &refs))\n+      if (!bitmap_equal_p (df->entry_block_defs, refs))\n \t{\n \t  struct df_scan_bb_info *bb_info = df_scan_get_bb_info (ENTRY_BLOCK);\n \t  df_ref_chain_delete_du_chain (bb_info->artificial_defs);\n@@ -3655,11 +3648,10 @@ df_update_entry_block_defs (void)\n \n   if (changed)\n     {\n-      df_record_entry_block_defs (&refs);\n-      bitmap_copy (df->entry_block_defs, &refs);\n+      df_record_entry_block_defs (refs);\n+      bitmap_copy (df->entry_block_defs, refs);\n       df_set_bb_dirty (BASIC_BLOCK_FOR_FN (cfun, ENTRY_BLOCK));\n     }\n-  bitmap_clear (&refs);\n }\n \n \n@@ -3804,14 +3796,13 @@ df_record_exit_block_uses (bitmap exit_block_uses)\n void\n df_update_exit_block_uses (void)\n {\n-  bitmap_head refs;\n   bool changed = false;\n \n-  bitmap_initialize (&refs, &df_bitmap_obstack);\n-  df_get_exit_block_use_set (&refs);\n+  auto_bitmap refs (&df_bitmap_obstack);\n+  df_get_exit_block_use_set (refs);\n   if (df->exit_block_uses)\n     {\n-      if (!bitmap_equal_p (df->exit_block_uses, &refs))\n+      if (!bitmap_equal_p (df->exit_block_uses, refs))\n \t{\n \t  struct df_scan_bb_info *bb_info = df_scan_get_bb_info (EXIT_BLOCK);\n \t  df_ref_chain_delete_du_chain (bb_info->artificial_uses);\n@@ -3831,11 +3822,10 @@ df_update_exit_block_uses (void)\n \n   if (changed)\n     {\n-      df_record_exit_block_uses (&refs);\n-      bitmap_copy (df->exit_block_uses,& refs);\n+      df_record_exit_block_uses (refs);\n+      bitmap_copy (df->exit_block_uses, refs);\n       df_set_bb_dirty (BASIC_BLOCK_FOR_FN (cfun, EXIT_BLOCK));\n     }\n-  bitmap_clear (&refs);\n }\n \n static bool initialized = false;\n@@ -4171,25 +4161,22 @@ df_bb_verify (basic_block bb)\n static bool\n df_entry_block_bitmap_verify (bool abort_if_fail)\n {\n-  bitmap_head entry_block_defs;\n   bool is_eq;\n \n-  bitmap_initialize (&entry_block_defs, &df_bitmap_obstack);\n-  df_get_entry_block_def_set (&entry_block_defs);\n+  auto_bitmap entry_block_defs (&df_bitmap_obstack);\n+  df_get_entry_block_def_set (entry_block_defs);\n \n-  is_eq = bitmap_equal_p (&entry_block_defs, df->entry_block_defs);\n+  is_eq = bitmap_equal_p (entry_block_defs, df->entry_block_defs);\n \n   if (!is_eq && abort_if_fail)\n     {\n       fprintf (stderr, \"entry_block_defs = \");\n-      df_print_regset (stderr, &entry_block_defs);\n+      df_print_regset (stderr, entry_block_defs);\n       fprintf (stderr, \"df->entry_block_defs = \");\n       df_print_regset (stderr, df->entry_block_defs);\n       gcc_assert (0);\n     }\n \n-  bitmap_clear (&entry_block_defs);\n-\n   return is_eq;\n }\n \n@@ -4200,25 +4187,22 @@ df_entry_block_bitmap_verify (bool abort_if_fail)\n static bool\n df_exit_block_bitmap_verify (bool abort_if_fail)\n {\n-  bitmap_head exit_block_uses;\n   bool is_eq;\n \n-  bitmap_initialize (&exit_block_uses, &df_bitmap_obstack);\n-  df_get_exit_block_use_set (&exit_block_uses);\n+  auto_bitmap exit_block_uses (&df_bitmap_obstack);\n+  df_get_exit_block_use_set (exit_block_uses);\n \n-  is_eq = bitmap_equal_p (&exit_block_uses, df->exit_block_uses);\n+  is_eq = bitmap_equal_p (exit_block_uses, df->exit_block_uses);\n \n   if (!is_eq && abort_if_fail)\n     {\n       fprintf (stderr, \"exit_block_uses = \");\n-      df_print_regset (stderr, &exit_block_uses);\n+      df_print_regset (stderr, exit_block_uses);\n       fprintf (stderr, \"df->exit_block_uses = \");\n       df_print_regset (stderr, df->exit_block_uses);\n       gcc_assert (0);\n     }\n \n-  bitmap_clear (&exit_block_uses);\n-\n   return is_eq;\n }\n \n@@ -4231,8 +4215,6 @@ df_scan_verify (void)\n {\n   unsigned int i;\n   basic_block bb;\n-  bitmap_head regular_block_artificial_uses;\n-  bitmap_head eh_block_artificial_uses;\n \n   if (!df)\n     return;\n@@ -4253,24 +4235,21 @@ df_scan_verify (void)\n   /* (2) There are various bitmaps whose value may change over the\n      course of the compilation.  This step recomputes them to make\n      sure that they have not slipped out of date.  */\n-  bitmap_initialize (&regular_block_artificial_uses, &df_bitmap_obstack);\n-  bitmap_initialize (&eh_block_artificial_uses, &df_bitmap_obstack);\n+  auto_bitmap regular_block_artificial_uses (&df_bitmap_obstack);\n+  auto_bitmap eh_block_artificial_uses (&df_bitmap_obstack);\n \n-  df_get_regular_block_artificial_uses (&regular_block_artificial_uses);\n-  df_get_eh_block_artificial_uses (&eh_block_artificial_uses);\n+  df_get_regular_block_artificial_uses (regular_block_artificial_uses);\n+  df_get_eh_block_artificial_uses (eh_block_artificial_uses);\n \n-  bitmap_ior_into (&eh_block_artificial_uses,\n-\t\t   &regular_block_artificial_uses);\n+  bitmap_ior_into (eh_block_artificial_uses,\n+\t\t   regular_block_artificial_uses);\n \n   /* Check artificial_uses bitmaps didn't change. */\n-  gcc_assert (bitmap_equal_p (&regular_block_artificial_uses,\n+  gcc_assert (bitmap_equal_p (regular_block_artificial_uses,\n \t\t\t      &df->regular_block_artificial_uses));\n-  gcc_assert (bitmap_equal_p (&eh_block_artificial_uses,\n+  gcc_assert (bitmap_equal_p (eh_block_artificial_uses,\n \t\t\t      &df->eh_block_artificial_uses));\n \n-  bitmap_clear (&regular_block_artificial_uses);\n-  bitmap_clear (&eh_block_artificial_uses);\n-\n   /* Verify entry block and exit block. These only verify the bitmaps,\n      the refs are verified in df_bb_verify.  */\n   df_entry_block_bitmap_verify (true);"}, {"sha": "c6465c755235072947a8cc7c23f0f650bdd2ce06", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "patch": "@@ -4644,7 +4644,6 @@ lra_constraints (bool first_p)\n   unsigned int min_len, new_min_len, uid;\n   rtx set, x, reg, dest_reg;\n   basic_block last_bb;\n-  bitmap_head equiv_insn_bitmap;\n   bitmap_iterator bi;\n \n   lra_constraint_iter++;\n@@ -4676,7 +4675,7 @@ lra_constraints (bool first_p)\n   /* Do elimination before the equivalence processing as we can spill\n      some pseudos during elimination.  */\n   lra_eliminate (false, first_p);\n-  bitmap_initialize (&equiv_insn_bitmap, &reg_obstack);\n+  auto_bitmap equiv_insn_bitmap (&reg_obstack);\n   for (i = FIRST_PSEUDO_REGISTER; i < new_regno_start; i++)\n     if (lra_reg_info[i].nrefs != 0)\n       {\n@@ -4737,14 +4736,14 @@ lra_constraints (bool first_p)\n \t    if (contains_reg_p (x, false, true))\n \t      ira_reg_equiv[i].profitable_p = false;\n \t    if (get_equiv (reg) != reg)\n-\t      bitmap_ior_into (&equiv_insn_bitmap, &lra_reg_info[i].insn_bitmap);\n+\t      bitmap_ior_into (equiv_insn_bitmap, &lra_reg_info[i].insn_bitmap);\n \t  }\n       }\n   for (i = FIRST_PSEUDO_REGISTER; i < new_regno_start; i++)\n     update_equiv (i);\n   /* We should add all insns containing pseudos which should be\n      substituted by their equivalences.  */\n-  EXECUTE_IF_SET_IN_BITMAP (&equiv_insn_bitmap, 0, uid, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (equiv_insn_bitmap, 0, uid, bi)\n     lra_push_insn_by_uid (uid);\n   min_len = lra_insn_stack_length ();\n   new_insns_num = 0;\n@@ -4775,7 +4774,7 @@ lra_constraints (bool first_p)\n \t  /* We need to check equivalence in debug insn and change\n \t     pseudo to the equivalent value if necessary.  */\n \t  curr_id = lra_get_insn_recog_data (curr_insn);\n-\t  if (bitmap_bit_p (&equiv_insn_bitmap, INSN_UID (curr_insn)))\n+\t  if (bitmap_bit_p (equiv_insn_bitmap, INSN_UID (curr_insn)))\n \t    {\n \t      rtx old = *curr_id->operand_loc[0];\n \t      *curr_id->operand_loc[0]\n@@ -4849,15 +4848,15 @@ lra_constraints (bool first_p)\n \t  /* Check non-transformed insns too for equiv change as USE\n \t     or CLOBBER don't need reloads but can contain pseudos\n \t     being changed on their equivalences.  */\n-\t  else if (bitmap_bit_p (&equiv_insn_bitmap, INSN_UID (curr_insn))\n+\t  else if (bitmap_bit_p (equiv_insn_bitmap, INSN_UID (curr_insn))\n \t\t   && loc_equivalence_change_p (&PATTERN (curr_insn)))\n \t    {\n \t      lra_update_insn_regno_info (curr_insn);\n \t      changed_p = true;\n \t    }\n \t}\n     }\n-  bitmap_clear (&equiv_insn_bitmap);\n+\n   /* If we used a new hard regno, changed_p should be true because the\n      hard reg is assigned to a new pseudo.  */\n   if (flag_checking && !changed_p)\n@@ -6791,10 +6790,9 @@ undo_optional_reloads (void)\n   bitmap_iterator bi, bi2;\n   rtx_insn *insn;\n   rtx set, src, dest;\n-  bitmap_head removed_optional_reload_pseudos, insn_bitmap;\n+  auto_bitmap removed_optional_reload_pseudos (&reg_obstack);\n \n-  bitmap_initialize (&removed_optional_reload_pseudos, &reg_obstack);\n-  bitmap_copy (&removed_optional_reload_pseudos, &lra_optional_reload_pseudos);\n+  bitmap_copy (removed_optional_reload_pseudos, &lra_optional_reload_pseudos);\n   EXECUTE_IF_SET_IN_BITMAP (&lra_optional_reload_pseudos, 0, regno, bi)\n     {\n       keep_p = false;\n@@ -6829,19 +6827,19 @@ undo_optional_reloads (void)\n \t  }\n       if (keep_p)\n \t{\n-\t  bitmap_clear_bit (&removed_optional_reload_pseudos, regno);\n+\t  bitmap_clear_bit (removed_optional_reload_pseudos, regno);\n \t  if (lra_dump_file != NULL)\n \t    fprintf (lra_dump_file, \"Keep optional reload reg %d\\n\", regno);\n \t}\n     }\n-  change_p = ! bitmap_empty_p (&removed_optional_reload_pseudos);\n-  bitmap_initialize (&insn_bitmap, &reg_obstack);\n-  EXECUTE_IF_SET_IN_BITMAP (&removed_optional_reload_pseudos, 0, regno, bi)\n+  change_p = ! bitmap_empty_p (removed_optional_reload_pseudos);\n+  auto_bitmap insn_bitmap (&reg_obstack);\n+  EXECUTE_IF_SET_IN_BITMAP (removed_optional_reload_pseudos, 0, regno, bi)\n     {\n       if (lra_dump_file != NULL)\n \tfprintf (lra_dump_file, \"Remove optional reload reg %d\\n\", regno);\n-      bitmap_copy (&insn_bitmap, &lra_reg_info[regno].insn_bitmap);\n-      EXECUTE_IF_SET_IN_BITMAP (&insn_bitmap, 0, uid, bi2)\n+      bitmap_copy (insn_bitmap, &lra_reg_info[regno].insn_bitmap);\n+      EXECUTE_IF_SET_IN_BITMAP (insn_bitmap, 0, uid, bi2)\n \t{\n \t  insn = lra_insn_recog_data[uid]->insn;\n \t  if ((set = single_set (insn)) != NULL_RTX)\n@@ -6885,8 +6883,6 @@ undo_optional_reloads (void)\n   /* Clear restore_regnos.  */\n   EXECUTE_IF_SET_IN_BITMAP (&lra_optional_reload_pseudos, 0, regno, bi)\n     lra_reg_info[regno].restore_rtx = NULL_RTX;\n-  bitmap_clear (&insn_bitmap);\n-  bitmap_clear (&removed_optional_reload_pseudos);\n   return change_p;\n }\n \n@@ -6899,7 +6895,6 @@ lra_undo_inheritance (void)\n   int hard_regno;\n   int n_all_inherit, n_inherit, n_all_split, n_split;\n   rtx restore_rtx;\n-  bitmap_head remove_pseudos;\n   bitmap_iterator bi;\n   bool change_p;\n \n@@ -6910,7 +6905,7 @@ lra_undo_inheritance (void)\n     fprintf (lra_dump_file,\n \t     \"\\n********** Undoing inheritance #%d: **********\\n\\n\",\n \t     lra_undo_inheritance_iter);\n-  bitmap_initialize (&remove_pseudos, &reg_obstack);\n+  auto_bitmap remove_pseudos (&reg_obstack);\n   n_inherit = n_all_inherit = 0;\n   EXECUTE_IF_SET_IN_BITMAP (&lra_inheritance_pseudos, 0, regno, bi)\n     if (lra_reg_info[regno].restore_rtx != NULL_RTX)\n@@ -6922,7 +6917,7 @@ lra_undo_inheritance (void)\n \t       allocation we used shorter live-ranges.  */\n \t    && (! REG_P (lra_reg_info[regno].restore_rtx)\n \t\t|| reg_renumber[REGNO (lra_reg_info[regno].restore_rtx)] < 0))\n-\t  bitmap_set_bit (&remove_pseudos, regno);\n+\t  bitmap_set_bit (remove_pseudos, regno);\n \telse\n \t  n_inherit++;\n       }\n@@ -6940,7 +6935,7 @@ lra_undo_inheritance (void)\n \thard_regno = (restore_regno >= FIRST_PSEUDO_REGISTER\n \t\t      ? reg_renumber[restore_regno] : restore_regno);\n \tif (hard_regno < 0 || reg_renumber[regno] == hard_regno)\n-\t  bitmap_set_bit (&remove_pseudos, regno);\n+\t  bitmap_set_bit (remove_pseudos, regno);\n \telse\n \t  {\n \t    n_split++;\n@@ -6953,8 +6948,7 @@ lra_undo_inheritance (void)\n     fprintf (lra_dump_file, \"Split %d out of %d (%.2f%%)\\n\",\n \t     n_split, n_all_split,\n \t     (double) n_split / n_all_split * 100);\n-  change_p = remove_inheritance_pseudos (&remove_pseudos);\n-  bitmap_clear (&remove_pseudos);\n+  change_p = remove_inheritance_pseudos (remove_pseudos);\n   /* Clear restore_regnos.  */\n   EXECUTE_IF_SET_IN_BITMAP (&lra_inheritance_pseudos, 0, regno, bi)\n     lra_reg_info[regno].restore_rtx = NULL_RTX;"}, {"sha": "fb294edf368675636a3396f02c7100ffbce1e718", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "patch": "@@ -746,14 +746,12 @@ calculate_gen_cands (void)\n {\n   basic_block bb;\n   bitmap gen_cands;\n-  bitmap_head gen_insns;\n   rtx_insn *insn;\n \n-  bitmap_initialize (&gen_insns, &reg_obstack);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       gen_cands = &get_remat_bb_data (bb)->gen_cands;\n-      bitmap_clear (&gen_insns);\n+      auto_bitmap gen_insns (&reg_obstack);\n       FOR_BB_INSNS (bb, insn)\n \tif (INSN_P (insn))\n \t  {\n@@ -782,7 +780,7 @@ calculate_gen_cands (void)\n \t\t   reg = reg->next)\n \t\tif (reg->type != OP_IN\n \t\t    || find_regno_note (insn, REG_DEAD, reg->regno) != NULL)\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (&gen_insns, 0, uid, bi)\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (gen_insns, 0, uid, bi)\n \t\t    {\n \t\t      rtx_insn *insn2 = lra_insn_recog_data[uid]->insn;\n \t\t      \n@@ -801,7 +799,7 @@ calculate_gen_cands (void)\n \t\t    }\n \t    \n \t    if (CALL_P (insn))\n-\t      EXECUTE_IF_SET_IN_BITMAP (&gen_insns, 0, uid, bi)\n+\t      EXECUTE_IF_SET_IN_BITMAP (gen_insns, 0, uid, bi)\n \t\t{\n \t\t  rtx_insn *insn2 = lra_insn_recog_data[uid]->insn;\n \t\t  \n@@ -813,17 +811,16 @@ calculate_gen_cands (void)\n \t\t      bitmap_set_bit (&temp_bitmap, uid);\n \t\t    }\n \t\t}\n-\t    bitmap_and_compl_into (&gen_insns, &temp_bitmap);\n+\t    bitmap_and_compl_into (gen_insns, &temp_bitmap);\n \n \t    cand = insn_to_cand[INSN_UID (insn)];\n \t    if (cand != NULL)\n \t      {\n \t\tbitmap_set_bit (gen_cands, cand->index);\n-\t\tbitmap_set_bit (&gen_insns, INSN_UID (insn));\n+\t\tbitmap_set_bit (gen_insns, INSN_UID (insn));\n \t      }\n \t  }\n     }  \n-  bitmap_clear (&gen_insns);\n }\n \n \f\n@@ -1059,15 +1056,13 @@ do_remat (void)\n   unsigned regno;\n   rtx_insn *insn;\n   basic_block bb;\n-  bitmap_head avail_cands;\n-  bitmap_head active_cands;\n   bool changed_p = false;\n   /* Living hard regs and hard registers of living pseudos.  */\n   HARD_REG_SET live_hard_regs;\n   bitmap_iterator bi;\n \n-  bitmap_initialize (&avail_cands, &reg_obstack);\n-  bitmap_initialize (&active_cands, &reg_obstack);\n+  auto_bitmap avail_cands (&reg_obstack);\n+  auto_bitmap active_cands (&reg_obstack);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       CLEAR_HARD_REG_SET (live_hard_regs);\n@@ -1079,11 +1074,11 @@ do_remat (void)\n \t  if (hard_regno >= 0)\n \t    SET_HARD_REG_BIT (live_hard_regs, hard_regno);\n \t}\n-      bitmap_and (&avail_cands, &get_remat_bb_data (bb)->avin_cands,\n+      bitmap_and (avail_cands, &get_remat_bb_data (bb)->avin_cands,\n \t\t  &get_remat_bb_data (bb)->livein_cands);\n       /* Activating insns are always in the same block as their corresponding\n \t remat insn, so at the start of a block the two bitsets are equal.  */\n-      bitmap_copy (&active_cands, &avail_cands);\n+      bitmap_copy (active_cands, avail_cands);\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  if (!NONDEBUG_INSN_P (insn))\n@@ -1117,8 +1112,8 @@ do_remat (void)\n \t      for (cand = regno_cands[src_regno];\n \t\t   cand != NULL;\n \t\t   cand = cand->next_regno_cand)\n-\t\tif (bitmap_bit_p (&avail_cands, cand->index)\n-\t\t    && bitmap_bit_p (&active_cands, cand->index))\n+\t\tif (bitmap_bit_p (avail_cands, cand->index)\n+\t\t    && bitmap_bit_p (active_cands, cand->index))\n \t\t  break;\n \t    }\n \t  int i, hard_regno, nregs;\n@@ -1189,7 +1184,7 @@ do_remat (void)\n \t\t reg = reg->next)\n \t      if (reg->type != OP_IN\n \t\t  || find_regno_note (insn, REG_DEAD, reg->regno) != NULL)\n-\t\tEXECUTE_IF_SET_IN_BITMAP (&avail_cands, 0, cid, bi)\n+\t\tEXECUTE_IF_SET_IN_BITMAP (avail_cands, 0, cid, bi)\n \t\t  {\n \t\t    cand = all_cands[cid];\n \t\t    \n@@ -1203,30 +1198,30 @@ do_remat (void)\n \t\t  }\n \n \t  if (CALL_P (insn))\n-\t    EXECUTE_IF_SET_IN_BITMAP (&avail_cands, 0, cid, bi)\n+\t    EXECUTE_IF_SET_IN_BITMAP (avail_cands, 0, cid, bi)\n \t      {\n \t\tcand = all_cands[cid];\n \t\t\n \t\tif (call_used_input_regno_present_p (cand->insn))\n \t\t  bitmap_set_bit (&temp_bitmap, cand->index);\n \t      }\n \n-\t  bitmap_and_compl_into (&avail_cands, &temp_bitmap);\n+\t  bitmap_and_compl_into (avail_cands, &temp_bitmap);\n \n \t  /* Now see whether a candidate is made active or available\n \t     by this insn.  */\n \t  cand = insn_to_cand_activation[INSN_UID (insn)];\n \t  if (cand)\n-\t    bitmap_set_bit (&active_cands, cand->index);\n+\t    bitmap_set_bit (active_cands, cand->index);\n \n \t  cand = insn_to_cand[INSN_UID (insn)];\n \t  if (cand != NULL)\n \t    {\n-\t      bitmap_set_bit (&avail_cands, cand->index);\n+\t      bitmap_set_bit (avail_cands, cand->index);\n \t      if (cand->reload_regno == -1)\n-\t\tbitmap_set_bit (&active_cands, cand->index);\n+\t\tbitmap_set_bit (active_cands, cand->index);\n \t      else\n-\t\tbitmap_clear_bit (&active_cands, cand->index);\n+\t\tbitmap_clear_bit (active_cands, cand->index);\n \t    }\n \n \t  if (remat_insn != NULL)\n@@ -1274,8 +1269,6 @@ do_remat (void)\n \t      SET_HARD_REG_BIT (live_hard_regs, reg->regno);\n \t}\n     }\n-  bitmap_clear (&avail_cands);\n-  bitmap_clear (&active_cands);\n   return changed_p;\n }\n "}, {"sha": "3df6f6786a398a8532ee1f617b21d9865eb5c9f1", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d648b5ff3cb2bf7aec320312e79c90e49cd9b39b/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=d648b5ff3cb2bf7aec320312e79c90e49cd9b39b", "patch": "@@ -223,7 +223,6 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n   rtx set;\n   basic_block bb;\n   HARD_REG_SET conflict_hard_regs;\n-  bitmap_head ok_insn_bitmap;\n   bitmap setjump_crosses = regstat_get_setjmp_crosses ();\n   /* Hard registers which can not be used for any purpose at given\n      program point because they are unallocatable or already allocated\n@@ -243,13 +242,13 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n \tfor (p = r->start; p <= r->finish; p++)\n \t  add_to_hard_reg_set (&reserved_hard_regs[p],\n \t\t\t       lra_reg_info[i].biggest_mode, hard_regno);\n-  bitmap_initialize (&ok_insn_bitmap, &reg_obstack);\n+  auto_bitmap ok_insn_bitmap (&reg_obstack);\n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_BB_INSNS (bb, insn)\n       if (DEBUG_INSN_P (insn)\n \t  || ((set = single_set (insn)) != NULL_RTX\n \t      && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set))))\n-\tbitmap_set_bit (&ok_insn_bitmap, INSN_UID (insn));\n+\tbitmap_set_bit (ok_insn_bitmap, INSN_UID (insn));\n   for (res = i = 0; i < n; i++)\n     {\n       regno = pseudo_regnos[i];\n@@ -260,7 +259,7 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n \t\t targetm.spill_class ((reg_class_t) rclass,\n \t\t\t\t      PSEUDO_REGNO_MODE (regno)))) == NO_REGS\n \t  || bitmap_intersect_compl_p (&lra_reg_info[regno].insn_bitmap,\n-\t\t\t\t       &ok_insn_bitmap))\n+\t\t\t\t       ok_insn_bitmap))\n \t{\n \t  pseudo_regnos[res++] = regno;\n \t  continue;\n@@ -300,7 +299,6 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n \t/* Just loop.  */\n \tdf_set_regs_ever_live (hard_regno + nr, true);\n     }\n-  bitmap_clear (&ok_insn_bitmap);\n   free (reserved_hard_regs);\n   return res;\n }\n@@ -449,17 +447,16 @@ spill_pseudos (void)\n   basic_block bb;\n   rtx_insn *insn, *curr;\n   int i;\n-  bitmap_head spilled_pseudos, changed_insns;\n \n-  bitmap_initialize (&spilled_pseudos, &reg_obstack);\n-  bitmap_initialize (&changed_insns, &reg_obstack);\n+  auto_bitmap spilled_pseudos (&reg_obstack);\n+  auto_bitmap changed_insns (&reg_obstack);\n   for (i = FIRST_PSEUDO_REGISTER; i < regs_num; i++)\n     {\n       if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0\n \t  && ! lra_former_scratch_p (i))\n \t{\n-\t  bitmap_set_bit (&spilled_pseudos, i);\n-\t  bitmap_ior_into (&changed_insns, &lra_reg_info[i].insn_bitmap);\n+\t  bitmap_set_bit (spilled_pseudos, i);\n+\t  bitmap_ior_into (changed_insns, &lra_reg_info[i].insn_bitmap);\n \t}\n     }\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -468,7 +465,7 @@ spill_pseudos (void)\n \t{\n \t  bool removed_pseudo_p = false;\n \t  \n-\t  if (bitmap_bit_p (&changed_insns, INSN_UID (insn)))\n+\t  if (bitmap_bit_p (changed_insns, INSN_UID (insn)))\n \t    {\n \t      rtx *link_loc, link;\n \n@@ -526,12 +523,10 @@ spill_pseudos (void)\n \t\t\t \"Debug insn #%u is reset because it referenced \"\n \t\t\t \"removed pseudo\\n\", INSN_UID (insn));\n \t    }\n-\t  bitmap_and_compl_into (df_get_live_in (bb), &spilled_pseudos);\n-\t  bitmap_and_compl_into (df_get_live_out (bb), &spilled_pseudos);\n+\t  bitmap_and_compl_into (df_get_live_in (bb), spilled_pseudos);\n+\t  bitmap_and_compl_into (df_get_live_out (bb), spilled_pseudos);\n \t}\n     }\n-  bitmap_clear (&spilled_pseudos);\n-  bitmap_clear (&changed_insns);\n }\n \n /* Return true if we need to change some pseudos into memory.  */"}]}