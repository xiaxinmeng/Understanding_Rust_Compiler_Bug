{"sha": "de646917966153fb997aff63928c9f3bfcb613f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU2NDY5MTc5NjYxNTNmYjk5N2FmZjYzOTI4YzlmM2JmY2I2MTNmMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-02-22T18:14:04Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-02-22T18:14:04Z"}, "message": "re PR java/20056 ('verification failed: incompatible type on stack' with --indirect-dispatch)\n\n\tPR java/20056:\n\t* verify.cc (type::EITHER): New constant.\n\t(check_field_constant): Use it.\n\t(type::compatible): Handle it.\n\nFrom-SVN: r95403", "tree": {"sha": "37d6f1b819a2aa11dfd4d23abc1246ea6d550777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37d6f1b819a2aa11dfd4d23abc1246ea6d550777"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de646917966153fb997aff63928c9f3bfcb613f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de646917966153fb997aff63928c9f3bfcb613f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de646917966153fb997aff63928c9f3bfcb613f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de646917966153fb997aff63928c9f3bfcb613f3/comments", "author": null, "committer": null, "parents": [{"sha": "0947959a371305bff4a92fe250948ca684e130ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0947959a371305bff4a92fe250948ca684e130ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0947959a371305bff4a92fe250948ca684e130ed"}], "stats": {"total": 56, "additions": 42, "deletions": 14}, "files": [{"sha": "324a5b23b7d0d49d51726fdaeeef5f0397e46ac9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de646917966153fb997aff63928c9f3bfcb613f3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de646917966153fb997aff63928c9f3bfcb613f3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=de646917966153fb997aff63928c9f3bfcb613f3", "patch": "@@ -1,3 +1,10 @@\n+2005-02-22  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR java/20056:\n+\t* verify.cc (type::EITHER): New constant.\n+\t(check_field_constant): Use it.\n+\t(type::compatible): Handle it.\n+\n 2005-02-22  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/security/PolicyFile.java,"}, {"sha": "141f27af7970cd5c7f94e18f10e0e909e5d48179", "filename": "libjava/verify.cc", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de646917966153fb997aff63928c9f3bfcb613f3/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de646917966153fb997aff63928c9f3bfcb613f3/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=de646917966153fb997aff63928c9f3bfcb613f3", "patch": "@@ -578,16 +578,19 @@ class _Jv_BytecodeVerifier\n     //\n     // First, when constructing a new object, it is the PC of the\n     // `new' instruction which created the object.  We use the special\n-    // value UNINIT to mean that this is uninitialized, and the\n-    // special value SELF for the case where the current method is\n-    // itself the <init> method.\n+    // value UNINIT to mean that this is uninitialized.  The special\n+    // value SELF is used for the case where the current method is\n+    // itself the <init> method.  the special value EITHER is used\n+    // when we may optionally allow either an uninitialized or\n+    // initialized reference to match.\n     //\n     // Second, when the key is return_address_type, this holds the PC\n     // of the instruction following the `jsr'.\n     int pc;\n \n     static const int UNINIT = -2;\n     static const int SELF = -1;\n+    static const int EITHER = -3;\n \n     // Basic constructor.\n     type ()\n@@ -734,19 +737,33 @@ class _Jv_BytecodeVerifier\n       if (k.klass == NULL)\n \tverifier->verify_fail (\"programmer error in type::compatible\");\n \n-      // An initialized type and an uninitialized type are not\n-      // compatible.\n-      if (isinitialized () != k.isinitialized ())\n-\treturn false;\n-\n-      // Two uninitialized objects are compatible if either:\n-      // * The PCs are identical, or\n-      // * One PC is UNINIT.\n-      if (! isinitialized ())\n+      // Handle the special 'EITHER' case, which is only used in a\n+      // special case of 'putfield'.  Note that we only need to handle\n+      // this on the LHS of a check.\n+      if (! isinitialized () && pc == EITHER)\n \t{\n-\t  if (pc != k.pc && pc != UNINIT && k.pc != UNINIT)\n+\t  // If the RHS is uninitialized, it must be an uninitialized\n+\t  // 'this'.\n+\t  if (! k.isinitialized () && k.pc != SELF)\n \t    return false;\n \t}\n+      else if (isinitialized () != k.isinitialized ())\n+\t{\n+\t  // An initialized type and an uninitialized type are not\n+\t  // otherwise compatible.\n+\t  return false;\n+\t}\n+      else\n+\t{\n+\t  // Two uninitialized objects are compatible if either:\n+\t  // * The PCs are identical, or\n+\t  // * One PC is UNINIT.\n+\t  if (! isinitialized ())\n+\t    {\n+\t      if (pc != k.pc && pc != UNINIT && k.pc != UNINIT)\n+\t\treturn false;\n+\t    }\n+\t}\n \n       return klass->compatible(k.klass, verifier);\n     }\n@@ -2003,7 +2020,11 @@ class _Jv_BytecodeVerifier\n \t// We don't look at the signature, figuring that if it is\n \t// wrong we will fail during linking.  FIXME?\n \t&& _Jv_Linker::has_field_p (current_class, name))\n-      class_type->set_uninitialized (type::SELF, this);\n+      // Note that we don't actually know whether we're going to match\n+      // against 'this' or some other object of the same type.  So,\n+      // here we set things up so that it doesn't matter.  This relies\n+      // on knowing what our caller is up to.\n+      class_type->set_uninitialized (type::EITHER, this);\n \n     return result;\n   }"}]}