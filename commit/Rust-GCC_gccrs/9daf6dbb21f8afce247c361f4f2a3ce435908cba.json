{"sha": "9daf6dbb21f8afce247c361f4f2a3ce435908cba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRhZjZkYmIyMWY4YWZjZTI0N2MzNjFmNGYyYTNjZTQzNTkwOGNiYQ==", "commit": {"author": {"name": "Easwaran Raman", "email": "eraman@gcc.gnu.org", "date": "2013-05-28T17:27:54Z"}, "committer": {"name": "Easwaran Raman", "email": "eraman@gcc.gnu.org", "date": "2013-05-28T17:27:54Z"}, "message": "re PR tree-optimization/57337 (416.gamess ICE on x86 after r199048)\n\n2013-05-28  Easwaran Raman  <eraman@google.com>\n\n\tPR tree-optimization/57337\n\t* tree-ssa-reassoc.c (appears_later_in_bb): New function.\n\t(find_insert_point): Correctly identify the insertion point\n\twhen two statements with the same UID is compared.\n\nFrom-SVN: r199385", "tree": {"sha": "4b2ca021e859bc06db871b030b6e75d2200ef1c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b2ca021e859bc06db871b030b6e75d2200ef1c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9daf6dbb21f8afce247c361f4f2a3ce435908cba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9daf6dbb21f8afce247c361f4f2a3ce435908cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9daf6dbb21f8afce247c361f4f2a3ce435908cba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9daf6dbb21f8afce247c361f4f2a3ce435908cba/comments", "author": null, "committer": null, "parents": [{"sha": "4fb5478c936efb66fb417557182cb7cf7f4513b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb5478c936efb66fb417557182cb7cf7f4513b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb5478c936efb66fb417557182cb7cf7f4513b4"}], "stats": {"total": 43, "additions": 40, "deletions": 3}, "files": [{"sha": "015ccfb9005b1d7e452d3592e5b9482c6de5cbe7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9daf6dbb21f8afce247c361f4f2a3ce435908cba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9daf6dbb21f8afce247c361f4f2a3ce435908cba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9daf6dbb21f8afce247c361f4f2a3ce435908cba", "patch": "@@ -1,3 +1,10 @@\n+2013-05-28  Easwaran Raman  <eraman@google.com>\n+\n+\tPR tree-optimization/57337\n+\t* tree-ssa-reassoc.c (appears_later_in_bb): New function.\n+\t(find_insert_point): Correctly identify the insertion point\n+\twhen two statements with the same UID is compared.\n+\n 2013-05-28  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/56787\n@@ -464,6 +471,7 @@\n \t* config/rs6000/rs6000-opts.h (PROCESSOR_POWER8): Likewise.\n \t(enum rs6000_vector): Add power8 vector support.\n \n+>>>>>>> .r199383\n 2013-05-22  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/19599\n@@ -495,8 +503,8 @@\n 2013-05-21  Easwaran Raman  <eraman@google.com>\n \n \tPR tree-optimization/57322\n-\t* (build_and_add_sum): If a BB is empty, set the UID of the statement\n-\tadded to the BB to be 1.\n+\t* tree-ssa-reassoc.c (build_and_add_sum): If a BB is empty, set the\n+\tUID of the statement added to the BB to be 1.\n \n 2013-05-21  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "24ad390333c5bdd06c377e2e8aa4db285056b8e4", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9daf6dbb21f8afce247c361f4f2a3ce435908cba/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9daf6dbb21f8afce247c361f4f2a3ce435908cba/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=9daf6dbb21f8afce247c361f4f2a3ce435908cba", "patch": "@@ -2866,6 +2866,31 @@ not_dominated_by (gimple a, gimple b)\n \n }\n \n+/* Among STMT1 and STMT2, return the statement that appears later. Both\n+   statements are in same BB and have the same UID.  */\n+\n+static gimple\n+appears_later_in_bb (gimple stmt1, gimple stmt2)\n+{\n+  unsigned uid = gimple_uid (stmt1);\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt1);\n+  gsi_next (&gsi);\n+  if (gsi_end_p (gsi))\n+    return stmt1;\n+  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+\n+      /* If STMT has a different UID than STMT1 and we haven't seen\n+         STMT2 during traversal, we know STMT1 appears later.  */\n+      if (gimple_uid (stmt) != uid)\n+        return stmt1;\n+      else if (stmt == stmt2)\n+        return stmt2;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Find the statement after which STMT must be moved so that the\n    dependency from DEP_STMT to STMT is maintained.  */\n \n@@ -2875,7 +2900,11 @@ find_insert_point (gimple stmt, gimple dep_stmt)\n   gimple insert_stmt = stmt;\n   if (dep_stmt == NULL)\n     return stmt;\n-  if (not_dominated_by (insert_stmt, dep_stmt))\n+  if (gimple_uid (insert_stmt) == gimple_uid (dep_stmt)\n+      && gimple_bb (insert_stmt) == gimple_bb (dep_stmt)\n+      && insert_stmt != dep_stmt)\n+    insert_stmt = appears_later_in_bb (insert_stmt, dep_stmt);\n+  else if (not_dominated_by (insert_stmt, dep_stmt))\n     insert_stmt = dep_stmt;\n   return insert_stmt;\n }"}]}