{"sha": "7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4M2Y0ZjUzNjJiYjE3YWEzYjUzZGI2MGJlZDZkYmI1Y2QzOGU3Mw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-04-22T08:19:54Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-04-22T08:19:54Z"}, "message": "alpha.c: Use REG_P...\n\n\t* config/alpha/alpha.c: Use REG_P, MEM_P, CONST_INT_P, JUMP_P,\n\tNONJUMP_INSN_P, CALL_P, LABEL_P and NOTE_P predicates instead of\n\tGET_CODE macro.  Use IN_RANGE macro where appropriate.\n\t* config/alpha/alpha.h: Ditto.\n\t* config/alpha/alpha.md: Ditto.\n\t* config/alpha/constraints.md: Ditto.\n\t* config/alpha/predicates.md: Ditto.\n\nFrom-SVN: r146550", "tree": {"sha": "66228e392e26f91512cf9bd0b5dfa0217a301e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66228e392e26f91512cf9bd0b5dfa0217a301e87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/comments", "author": null, "committer": null, "parents": [{"sha": "a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e05f922a087f545fb94f16687ec59b7d3dcdf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e05f922a087f545fb94f16687ec59b7d3dcdf5"}], "stats": {"total": 258, "additions": 133, "deletions": 125}, "files": [{"sha": "a9daf8f175285b0f86ea2c61278d1a2337f8d35a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "patch": "@@ -1,3 +1,13 @@\n+2009-04-22  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/alpha/alpha.c: Use REG_P, MEM_P, CONST_INT_P, JUMP_P,\n+\tNONJUMP_INSN_P, CALL_P, LABEL_P and NOTE_P predicates instead of\n+\tGET_CODE macro.  Use IN_RANGE macro where appropriate.\n+\t* config/alpha/alpha.h: Ditto.\n+\t* config/alpha/alpha.md: Ditto.\n+\t* config/alpha/constraints.md: Ditto.\n+\t* config/alpha/predicates.md: Ditto.\n+\t\n 2009-04-22  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* defaults.h (GO_IF_MODE_DEPENDENT_ADDRESS): Provide empty default.\n@@ -40,8 +50,7 @@\n \t(find_basic_blocks_1): Delete.\n \t(find_basic_blocks): Delete.\n \t* except.c (finish_eh_generation): Make static.  Move comment from\n-\texcept.h here.  Remove find_basic_blocks references from\n-\tcomments.\n+\texcept.h here.  Remove find_basic_blocks references from comments.\n \t* except.h (finish_eh_generation): Delete.\n \t* basic-block.h (find_basic_blocks): Delete.\n \t* config/sh/sh.c (sh_output_mi_thunk): Delete a \"#if 0\" block.\n@@ -222,8 +231,8 @@\n \n \t* tree-switch-conversion.c (build_constructors): Split a long line.\n \t(constructor_contains_same_values_p): New function.\n-\t(build_one_array): Create assigns of constants if possible, do not call\n-\tmark_sym_for_renaming, call update_stmt.\n+\t(build_one_array): Create assigns of constants if possible, do not\n+\tcall mark_sym_for_renaming, call update_stmt.\n \t(build_arrays): Call make_ssa_name (create_tmp_var ()) instead of\n \tmake_rename_temp.  Do not call mark_symbols_for_renaming, call\n \tupdate_stmt.\n@@ -237,8 +246,7 @@\n 2009-04-21  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/39827\n-\t* tree-ssa-phiprop.c (propagate_with_phi): Check SSA_NAME\n-\tis in range.\n+\t* tree-ssa-phiprop.c (propagate_with_phi): Check SSA_NAME is in range.\n \t(tree_ssa_phiprop): Pass the correct array size.\n \n 2009-04-21  Uros Bizjak  <ubizjak@gmail.com>"}, {"sha": "da4dc08a13a3866ff146645a09ca57a3d9791b9e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "patch": "@@ -584,7 +584,7 @@ resolve_reload_operand (rtx op)\n       rtx tmp = op;\n       if (GET_CODE (tmp) == SUBREG)\n \ttmp = SUBREG_REG (tmp);\n-      if (GET_CODE (tmp) == REG\n+      if (REG_P (tmp)\n \t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n \t{\n \t  op = reg_equiv_memory_loc[REGNO (tmp)];\n@@ -661,7 +661,7 @@ alpha_tablejump_addr_vec (rtx insn)\n   tmp = NEXT_INSN (tmp);\n   if (!tmp)\n     return NULL_RTX;\n-  if (GET_CODE (tmp) == JUMP_INSN\n+  if (JUMP_P (tmp)\n       && GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC)\n     return PATTERN (tmp);\n   return NULL_RTX;\n@@ -812,7 +812,7 @@ alpha_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n   /* If this is an ldq_u type address, discard the outer AND.  */\n   if (mode == DImode\n       && GET_CODE (x) == AND\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (x, 1))\n       && INTVAL (XEXP (x, 1)) == -8)\n     x = XEXP (x, 0);\n \n@@ -854,7 +854,7 @@ alpha_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n \t{\n \t  if (! strict\n \t      && NONSTRICT_REG_OK_FP_BASE_P (x)\n-\t      && GET_CODE (ofs) == CONST_INT)\n+\t      && CONST_INT_P (ofs))\n \t    return true;\n \t  if ((strict\n \t       ? STRICT_REG_OK_FOR_BASE_P (x)\n@@ -926,8 +926,8 @@ alpha_legitimize_address (rtx x, rtx scratch, enum machine_mode mode)\n      valid offset, compute the high part of the constant and add it to\n      the register.  Then our address is (plus temp low-part-const).  */\n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && REG_P (XEXP (x, 0))\n+      && CONST_INT_P (XEXP (x, 1))\n       && ! CONSTANT_ADDRESS_P (XEXP (x, 1)))\n     {\n       addend = INTVAL (XEXP (x, 1));\n@@ -942,7 +942,7 @@ alpha_legitimize_address (rtx x, rtx scratch, enum machine_mode mode)\n   if (can_create_pseudo_p ()\n       && GET_CODE (x) == CONST\n       && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n     {\n       addend = INTVAL (XEXP (XEXP (x, 0), 1));\n       x = force_reg (Pmode, XEXP (XEXP (x, 0), 0));\n@@ -954,10 +954,10 @@ alpha_legitimize_address (rtx x, rtx scratch, enum machine_mode mode)\n      our address.  */\n   if (can_create_pseudo_p ()\n       && GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n+      && REG_P (XEXP (x, 0))\n       && GET_CODE (XEXP (x, 1)) == CONST\n       && GET_CODE (XEXP (XEXP (x, 1), 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (XEXP (x, 1), 0), 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (XEXP (XEXP (x, 1), 0), 1)))\n     {\n       addend = INTVAL (XEXP (XEXP (XEXP (x, 1), 0), 1));\n       x = expand_simple_binop (Pmode, PLUS, XEXP (x, 0),\n@@ -1217,9 +1217,9 @@ alpha_legitimize_reload_address (rtx x,\n   /* We must recognize output that we have already generated ourselves.  */\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && REG_P (XEXP (XEXP (x, 0), 0))\n+      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n+      && CONST_INT_P (XEXP (x, 1)))\n     {\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n@@ -1231,7 +1231,7 @@ alpha_legitimize_reload_address (rtx x,\n      splitting the addend across an ldah and the mem insn.  This\n      cuts number of extra insns needed from 3 to 1.  */\n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n+      && REG_P (XEXP (x, 0))\n       && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n       && REGNO_OK_FOR_BASE_P (REGNO (XEXP (x, 0)))\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n@@ -1349,7 +1349,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total,\n       return false;\n \n     case ASHIFT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) <= 3)\n \t{\n \t  *total = COSTS_N_INSNS (1);\n@@ -1410,7 +1410,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total,\n       return false;\n \n     case FLOAT_EXTEND:\n-      if (GET_CODE (XEXP (x, 0)) == MEM)\n+      if (MEM_P (XEXP (x, 0)))\n \t*total = 0;\n       else\n \t*total = cost_data->fp_add;\n@@ -1432,7 +1432,7 @@ get_aligned_mem (rtx ref, rtx *paligned_mem, rtx *pbitnum)\n   rtx base;\n   HOST_WIDE_INT disp, offset;\n \n-  gcc_assert (GET_CODE (ref) == MEM);\n+  gcc_assert (MEM_P (ref));\n \n   if (reload_in_progress\n       && ! memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n@@ -1477,7 +1477,7 @@ get_unaligned_address (rtx ref)\n   rtx base;\n   HOST_WIDE_INT offset = 0;\n \n-  gcc_assert (GET_CODE (ref) == MEM);\n+  gcc_assert (MEM_P (ref));\n \n   if (reload_in_progress\n       && ! memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n@@ -1524,7 +1524,7 @@ alpha_preferred_reload_class(rtx x, enum reg_class rclass)\n     return rclass;\n \n   /* These sorts of constants we can easily drop to memory.  */\n-  if (GET_CODE (x) == CONST_INT\n+  if (CONST_INT_P (x)\n       || GET_CODE (x) == CONST_DOUBLE\n       || GET_CODE (x) == CONST_VECTOR)\n     {\n@@ -1591,7 +1591,7 @@ alpha_set_memflags_1 (rtx *xp, void *data)\n {\n   rtx x = *xp, orig = (rtx) data;\n \n-  if (GET_CODE (x) != MEM)\n+  if (!MEM_P (x))\n     return 0;\n \n   MEM_VOLATILE_P (x) = MEM_VOLATILE_P (orig);\n@@ -1906,7 +1906,7 @@ alpha_emit_set_const (rtx target, enum machine_mode mode,\n   /* If we can't make any pseudos, TARGET is an SImode hard register, we\n      can't load this constant in one insn, do this in DImode.  */\n   if (!can_create_pseudo_p () && mode == SImode\n-      && GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER)\n+      && REG_P (target) && REGNO (target) < FIRST_PSEUDO_REGISTER)\n     {\n       result = alpha_emit_set_const_1 (target, mode, c, 1, no_output);\n       if (result)\n@@ -2019,7 +2019,7 @@ alpha_extract_integer (rtx x, HOST_WIDE_INT *p0, HOST_WIDE_INT *p1)\n     x = simplify_subreg (DImode, x, GET_MODE (x), 0);\n \n \n-  if (GET_CODE (x) == CONST_INT)\n+  if (CONST_INT_P (x))\n     {\n       i0 = INTVAL (x);\n       i1 = -(i0 < 0);\n@@ -2127,7 +2127,7 @@ alpha_expand_mov (enum machine_mode mode, rtx *operands)\n   rtx tmp;\n \n   /* If the output is not a register, the input must be.  */\n-  if (GET_CODE (operands[0]) == MEM\n+  if (MEM_P (operands[0])\n       && ! reg_or_0_operand (operands[1], mode))\n     operands[1] = force_reg (mode, operands[1]);\n \n@@ -2149,7 +2149,7 @@ alpha_expand_mov (enum machine_mode mode, rtx *operands)\n     return false;\n \n   /* Split large integers.  */\n-  if (GET_CODE (operands[1]) == CONST_INT\n+  if (CONST_INT_P (operands[1])\n       || GET_CODE (operands[1]) == CONST_DOUBLE\n       || GET_CODE (operands[1]) == CONST_VECTOR)\n     {\n@@ -2211,7 +2211,7 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n \t      subtarget = operands[0];\n-\t      if (GET_CODE (subtarget) == REG)\n+\t      if (REG_P (subtarget))\n \t\tsubtarget = gen_lowpart (DImode, subtarget), copyout = false;\n \t      else\n \t\tsubtarget = gen_reg_rtx (DImode), copyout = true;\n@@ -2241,7 +2241,7 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t  temp2 = gen_reg_rtx (DImode);\n \n \t  subtarget = operands[0];\n-\t  if (GET_CODE (subtarget) == REG)\n+\t  if (REG_P (subtarget))\n \t    subtarget = gen_lowpart (DImode, subtarget), copyout = false;\n \t  else\n \t    subtarget = gen_reg_rtx (DImode), copyout = true;\n@@ -2501,10 +2501,10 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \t  /* ??? Don't do this when comparing against symbols, otherwise\n \t     we'll reduce (&x == 0x1234) to (&x-0x1234 == 0), which will\n \t     be declared false out of hand (at least for non-weak).  */\n-\t  else if (GET_CODE (op1) == CONST_INT\n+\t  else if (CONST_INT_P (op1)\n \t\t   && (code == EQ || code == NE)\n \t\t   && !(symbolic_operand (op0, VOIDmode)\n-\t\t\t|| (GET_CODE (op0) == REG && REG_POINTER (op0))))\n+\t\t\t|| (REG_P (op0) && REG_POINTER (op0))))\n \t    {\n \t      rtx n_op1 = GEN_INT (-INTVAL (op1));\n \n@@ -2989,7 +2989,7 @@ alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n \t  break;\n \n \tcase VOIDmode:\n-\t  gcc_assert (GET_CODE (operands[i]) == CONST_INT);\n+\t  gcc_assert (CONST_INT_P (operands[i]));\n \t  /* FALLTHRU */\n \tcase DImode:\n \t  reg = gen_rtx_REG (DImode, regno);\n@@ -3815,11 +3815,11 @@ alpha_expand_block_move (rtx operands[])\n   /* Look for additional alignment information from recorded register info.  */\n \n   tmp = XEXP (orig_src, 0);\n-  if (GET_CODE (tmp) == REG)\n+  if (REG_P (tmp))\n     src_align = MAX (src_align, REGNO_POINTER_ALIGN (REGNO (tmp)));\n   else if (GET_CODE (tmp) == PLUS\n-\t   && GET_CODE (XEXP (tmp, 0)) == REG\n-\t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n+\t   && REG_P (XEXP (tmp, 0))\n+\t   && CONST_INT_P (XEXP (tmp, 1)))\n     {\n       unsigned HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n       unsigned int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n@@ -3836,11 +3836,11 @@ alpha_expand_block_move (rtx operands[])\n     }\n \n   tmp = XEXP (orig_dst, 0);\n-  if (GET_CODE (tmp) == REG)\n+  if (REG_P (tmp))\n     dst_align = MAX (dst_align, REGNO_POINTER_ALIGN (REGNO (tmp)));\n   else if (GET_CODE (tmp) == PLUS\n-\t   && GET_CODE (XEXP (tmp, 0)) == REG\n-\t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n+\t   && REG_P (XEXP (tmp, 0))\n+\t   && CONST_INT_P (XEXP (tmp, 1)))\n     {\n       unsigned HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n       unsigned int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n@@ -4059,11 +4059,11 @@ alpha_expand_block_clear (rtx operands[])\n \n   /* Look for stricter alignment.  */\n   tmp = XEXP (orig_dst, 0);\n-  if (GET_CODE (tmp) == REG)\n+  if (REG_P (tmp))\n     align = MAX (align, REGNO_POINTER_ALIGN (REGNO (tmp)));\n   else if (GET_CODE (tmp) == PLUS\n-\t   && GET_CODE (XEXP (tmp, 0)) == REG\n-\t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n+\t   && REG_P (XEXP (tmp, 0))\n+\t   && CONST_INT_P (XEXP (tmp, 1)))\n     {\n       HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n       int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n@@ -5053,7 +5053,7 @@ print_operand (FILE *file, rtx x, int code)\n \t    x = XVECEXP (x, 0, 0);\n \t    lituse = \"lituse_tlsldm\";\n \t  }\n-\telse if (GET_CODE (x) == CONST_INT)\n+\telse if (CONST_INT_P (x))\n \t  lituse = \"lituse_jsr\";\n \telse\n \t  {\n@@ -5082,7 +5082,7 @@ print_operand (FILE *file, rtx x, int code)\n       break;\n     case 'r':\n       /* If this operand is the constant zero, write it as \"$31\".  */\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n       else if (x == CONST0_RTX (GET_MODE (x)))\n \tfprintf (file, \"$31\");\n@@ -5092,7 +5092,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'R':\n       /* Similar, but for floating-point.  */\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n       else if (x == CONST0_RTX (GET_MODE (x)))\n \tfprintf (file, \"$f31\");\n@@ -5102,31 +5102,31 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'N':\n       /* Write the 1's complement of a constant.  */\n-      if (GET_CODE (x) != CONST_INT)\n+      if (!CONST_INT_P (x))\n \toutput_operand_lossage (\"invalid %%N value\");\n \n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, ~ INTVAL (x));\n       break;\n \n     case 'P':\n       /* Write 1 << C, for a constant C.  */\n-      if (GET_CODE (x) != CONST_INT)\n+      if (!CONST_INT_P (x))\n \toutput_operand_lossage (\"invalid %%P value\");\n \n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT) 1 << INTVAL (x));\n       break;\n \n     case 'h':\n       /* Write the high-order 16 bits of a constant, sign-extended.  */\n-      if (GET_CODE (x) != CONST_INT)\n+      if (!CONST_INT_P (x))\n \toutput_operand_lossage (\"invalid %%h value\");\n \n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) >> 16);\n       break;\n \n     case 'L':\n       /* Write the low-order 16 bits of a constant, sign-extended.  */\n-      if (GET_CODE (x) != CONST_INT)\n+      if (!CONST_INT_P (x))\n \toutput_operand_lossage (\"invalid %%L value\");\n \n       fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n@@ -5155,7 +5155,7 @@ print_operand (FILE *file, rtx x, int code)\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, mask & 0xff);\n \t}\n \n-      else if (GET_CODE (x) == CONST_INT)\n+      else if (CONST_INT_P (x))\n \t{\n \t  HOST_WIDE_INT mask = 0, value = INTVAL (x);\n \n@@ -5171,7 +5171,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'M':\n       /* 'b', 'w', 'l', or 'q' as the value of the constant.  */\n-      if (GET_CODE (x) != CONST_INT\n+      if (!CONST_INT_P (x)\n \t  || (INTVAL (x) != 8 && INTVAL (x) != 16\n \t      && INTVAL (x) != 32 && INTVAL (x) != 64))\n \toutput_operand_lossage (\"invalid %%M value\");\n@@ -5185,7 +5185,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'U':\n       /* Similar, except do it from the mask.  */\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \t{\n \t  HOST_WIDE_INT value = INTVAL (x);\n \n@@ -5225,7 +5225,7 @@ print_operand (FILE *file, rtx x, int code)\n       /* Write the constant value divided by 8 for little-endian mode or\n \t (56 - value) / 8 for big-endian mode.  */\n \n-      if (GET_CODE (x) != CONST_INT\n+      if (!CONST_INT_P (x)\n \t  || (unsigned HOST_WIDE_INT) INTVAL (x) >= (WORDS_BIG_ENDIAN\n \t\t\t\t\t\t     ? 56\n \t\t\t\t\t\t     : 64)\n@@ -5241,7 +5241,7 @@ print_operand (FILE *file, rtx x, int code)\n     case 'S':\n       /* Same, except compute (64 - c) / 8 */\n \n-      if (GET_CODE (x) != CONST_INT\n+      if (!CONST_INT_P (x)\n \t  && (unsigned HOST_WIDE_INT) INTVAL (x) >= 64\n \t  && (INTVAL (x) & 7) != 8)\n \toutput_operand_lossage (\"invalid %%s value\");\n@@ -5311,14 +5311,14 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'A':\n       /* Write \"_u\" for unaligned access.  */\n-      if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == AND)\n+      if (MEM_P (x) && GET_CODE (XEXP (x, 0)) == AND)\n \tfprintf (file, \"_u\");\n       break;\n \n     case 0:\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n-      else if (GET_CODE (x) == MEM)\n+      else if (MEM_P (x))\n \toutput_address (XEXP (x, 0));\n       else if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == UNSPEC)\n \t{\n@@ -5352,7 +5352,7 @@ print_operand_address (FILE *file, rtx addr)\n     addr = XEXP (addr, 0);\n \n   if (GET_CODE (addr) == PLUS\n-      && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (addr, 1)))\n     {\n       offset = INTVAL (XEXP (addr, 1));\n       addr = XEXP (addr, 0);\n@@ -8279,7 +8279,7 @@ alpha_end_function (FILE *file, const char *fnname, tree decl ATTRIBUTE_UNUSED)\n   insn = get_last_insn ();\n   if (!INSN_P (insn))\n     insn = prev_active_insn (insn);\n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     output_asm_insn (get_insn_template (CODE_FOR_nop, NULL), NULL);\n \n #if TARGET_ABI_OSF\n@@ -8655,7 +8655,7 @@ alpha_handle_trap_shadows (void)\n \n   for (i = get_insns (); i ; i = NEXT_INSN (i))\n     {\n-      if (GET_CODE (i) == NOTE)\n+      if (NOTE_P (i))\n \t{\n \t  switch (NOTE_KIND (i))\n \t    {\n@@ -8681,7 +8681,7 @@ alpha_handle_trap_shadows (void)\n \t{\n \t  if (alpha_tp == ALPHA_TP_FUNC)\n \t    {\n-\t      if (GET_CODE (i) == JUMP_INSN\n+\t      if (JUMP_P (i)\n \t\t  && GET_CODE (PATTERN (i)) == RETURN)\n \t\tgoto close_shadow;\n \t    }\n@@ -8759,7 +8759,7 @@ alpha_handle_trap_shadows (void)\n \t}\n \n       if ((exception_nesting > 0 || alpha_tp >= ALPHA_TP_FUNC)\n-\t  && GET_CODE (i) == INSN\n+\t  && NONJUMP_INSN_P (i)\n \t  && GET_CODE (PATTERN (i)) != USE\n \t  && GET_CODE (PATTERN (i)) != CLOBBER\n \t  && get_attr_trap (i) == TRAP_YES)\n@@ -8973,7 +8973,7 @@ alphaev4_next_group (rtx insn, int *pin_use, int *plen)\n       len += 4;\n \n       /* Haifa doesn't do well scheduling branches.  */\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \tgoto next_and_done;\n \n     next:\n@@ -9104,7 +9104,7 @@ alphaev5_next_group (rtx insn, int *pin_use, int *plen)\n       /* Haifa doesn't do well scheduling branches.  */\n       /* ??? If this is predicted not-taken, slotting continues, except\n \t that no more IBR, FBR, or JSR insns may be slotted.  */\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \tgoto next_and_done;\n \n     next:\n@@ -9212,7 +9212,7 @@ alpha_align_insns (unsigned int max_align,\n \n   ofs = prev_in_use = 0;\n   i = get_insns ();\n-  if (GET_CODE (i) == NOTE)\n+  if (NOTE_P (i))\n     i = next_nonnote_insn (i);\n \n   ldgp = alpha_function_needs_gp ? 8 : 0;\n@@ -9222,7 +9222,7 @@ alpha_align_insns (unsigned int max_align,\n       next = (*next_group) (i, &in_use, &len);\n \n       /* When we see a label, resync alignment etc.  */\n-      if (GET_CODE (i) == CODE_LABEL)\n+      if (LABEL_P (i))\n \t{\n \t  unsigned int new_align = 1 << label_to_alignment (i);\n \n@@ -9259,12 +9259,12 @@ alpha_align_insns (unsigned int max_align,\n \t  rtx prev, where;\n \n \t  where = prev = prev_nonnote_insn (i);\n-\t  if (!where || GET_CODE (where) != CODE_LABEL)\n+\t  if (!where || !LABEL_P (where))\n \t    where = i;\n \n \t  /* Can't realign between a call and its gp reload.  */\n \t  if (! (TARGET_EXPLICIT_RELOCS\n-\t\t && prev && GET_CODE (prev) == CALL_INSN))\n+\t\t && prev && CALL_P (prev)))\n \t    {\n \t      emit_insn_before (gen_realign (GEN_INT (new_log_align)), where);\n \t      align = 1 << new_log_align;\n@@ -9292,13 +9292,13 @@ alpha_align_insns (unsigned int max_align,\n \t  where = prev_nonnote_insn (i);\n \t  if (where)\n \t    {\n-\t      if (GET_CODE (where) == CODE_LABEL)\n+\t      if (LABEL_P (where))\n \t\t{\n \t\t  rtx where2 = prev_nonnote_insn (where);\n-\t\t  if (where2 && GET_CODE (where2) == JUMP_INSN)\n+\t\t  if (where2 && JUMP_P (where2))\n \t\t    where = where2;\n \t\t}\n-\t      else if (GET_CODE (where) == INSN)\n+\t      else if (NONJUMP_INSN_P (where))\n \t\twhere = i;\n \t    }\n \t  else\n@@ -10176,7 +10176,7 @@ unicosmk_ssib_name (void)\n   int len;\n \n   x = DECL_RTL (cfun->decl);\n-  gcc_assert (GET_CODE (x) == MEM);\n+  gcc_assert (MEM_P (x));\n   x = XEXP (x, 0);\n   gcc_assert (GET_CODE (x) == SYMBOL_REF);\n   fnname = XSTR (x, 0);"}, {"sha": "4df364071ba8a59dd7460f9981ed16f3c77bfc89", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "patch": "@@ -447,7 +447,7 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n    registers can hold 64-bit integers as well, but not smaller values.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\t\\\n-  ((REGNO) >= 32 && (REGNO) <= 62 \t\t\t\t\t\\\n+  (IN_RANGE ((REGNO), 32, 62)\t\t\t\t\t\t\\\n    ? (MODE) == SFmode || (MODE) == DFmode || (MODE) == DImode\t\t\\\n      || (MODE) == SCmode || (MODE) == DCmode\t\t\t\t\\\n    : 1)\n@@ -576,7 +576,7 @@ enum reg_class {\n   : (REGNO) == 24 ? R24_REG\t\t\t\\\n   : (REGNO) == 25 ? R25_REG\t\t\t\\\n   : (REGNO) == 27 ? R27_REG\t\t\t\\\n-  : (REGNO) >= 32 && (REGNO) <= 62 ? FLOAT_REGS\t\\\n+  : IN_RANGE ((REGNO), 32, 62) ? FLOAT_REGS\t\\\n   : GENERAL_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -752,7 +752,7 @@ extern int alpha_memory_latency;\n    On Alpha, these are $16-$21 and $f16-$f21.  */\n \n #define FUNCTION_ARG_REGNO_P(N) \\\n-  (((N) >= 16 && (N) <= 21) || ((N) >= 16 + 32 && (N) <= 21 + 32))\n+  (IN_RANGE ((N), 16, 21) || ((N) >= 16 + 32 && (N) <= 21 + 32))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -949,7 +949,7 @@ do {\t\t\t\t\t\t\\\n    symbolic addresses into registers.  */\n \n #define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == CONST_INT\t\\\n+  (CONST_INT_P (X)\t\t\\\n    && (unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n \n /* Include all constant integers and constant doubles, but not\n@@ -1125,15 +1125,15 @@ do {\t\t\t\t\t\t\t\t\t     \\\n #define CANONICALIZE_COMPARISON(CODE,OP0,OP1) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (((CODE) == GE || (CODE) == GT || (CODE) == GEU || (CODE) == GTU) \\\n-\t&& (GET_CODE (OP1) == REG || (OP1) == const0_rtx))\t\t\\\n+\t&& (REG_P (OP1) || (OP1) == const0_rtx))\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \trtx tem = (OP0);\t\t\t\t\t\t\\\n \t(OP0) = (OP1);\t\t\t\t\t\t\t\\\n \t(OP1) = tem;\t\t\t\t\t\t\t\\\n \t(CODE) = swap_condition (CODE);\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     if (((CODE) == LT || (CODE) == LTU)\t\t\t\t\t\\\n-\t&& GET_CODE (OP1) == CONST_INT && INTVAL (OP1) == 256)\t\t\\\n+\t&& CONST_INT_P (OP1) && INTVAL (OP1) == 256)\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \t(CODE) = (CODE) == LT ? LE : LEU;\t\t\t\t\\\n \t(OP1) = GEN_INT (255);\t\t\t\t\t\t\\"}, {"sha": "c4b3e13c82889d8ff298414ace8a4ddfbb09bf77", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "patch": "@@ -2155,7 +2155,7 @@\n \t\t   \t   (match_operand:DI 2 \"mul8_operand\" \"I\"))\n \t\t(match_operand:DI 3 \"immediate_operand\" \"i\")))]\n   \"HOST_BITS_PER_WIDE_INT == 64\n-   && GET_CODE (operands[3]) == CONST_INT\n+   && CONST_INT_P (operands[3])\n    && (((unsigned HOST_WIDE_INT) 0xff << INTVAL (operands[2])\n         == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n        || ((unsigned HOST_WIDE_INT) 0xffff << INTVAL (operands[2])\n@@ -4249,19 +4249,19 @@\n      register since that is more likely to match (and to produce better code\n      if both would).  */\n \n-  if (code == EQ && GET_CODE (operands[3]) == CONST_INT\n+  if (code == EQ && CONST_INT_P (operands[3])\n       && rtx_equal_p (operands[4], operands[3]))\n     operands[4] = operands[2];\n \n-  else if (code == NE && GET_CODE (operands[3]) == CONST_INT\n+  else if (code == NE && CONST_INT_P (operands[3])\n \t   && rtx_equal_p (operands[5], operands[3]))\n     operands[5] = operands[2];\n \n   if (code == NE || code == EQ\n       || (extended_count (operands[2], DImode, unsignedp) >= 1\n \t  && extended_count (operands[3], DImode, unsignedp) >= 1))\n     {\n-      if (GET_CODE (operands[3]) == CONST_INT)\n+      if (CONST_INT_P (operands[3]))\n \toperands[7] = gen_rtx_PLUS (DImode, operands[2],\n \t\t\t\t    GEN_INT (- INTVAL (operands[3])));\n       else\n@@ -4308,7 +4308,7 @@\n \t     && extended_count (operands[3], DImode, unsignedp) >= 1)))\n     FAIL;\n \n-  if (GET_CODE (operands[3]) == CONST_INT)\n+  if (CONST_INT_P (operands[3]))\n     tem = gen_rtx_PLUS (SImode, operands[2],\n \t\t\tGEN_INT (- INTVAL (operands[3])));\n   else\n@@ -4547,7 +4547,7 @@\n \t      (unspec [(reg:DI 29)] UNSPEC_SIBCALL)])]\n   \"TARGET_ABI_OSF\"\n {\n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (MEM_P (operands[0]));\n   operands[0] = XEXP (operands[0], 0);\n })\n \n@@ -4558,7 +4558,7 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (MEM_P (operands[0]));\n \n   operands[0] = XEXP (operands[0], 0);\n   if (! call_operand (operands[0], Pmode))\n@@ -4571,10 +4571,10 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (MEM_P (operands[0]));\n \n   operands[0] = XEXP (operands[0], 0);\n-  if (GET_CODE (operands[0]) != SYMBOL_REF && GET_CODE (operands[0]) != REG)\n+  if (GET_CODE (operands[0]) != SYMBOL_REF && !REG_P (operands[0]))\n     operands[0] = force_reg (DImode, operands[0]);\n })\n \n@@ -4589,13 +4589,13 @@\n \t       (clobber (reg:DI 26))])]\n    \"\"\n {\n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (MEM_P (operands[0]));\n \n   /* Always load the address of the called function into a register;\n      load the CIW in $25.  */\n \n   operands[0] = XEXP (operands[0], 0);\n-  if (GET_CODE (operands[0]) != REG)\n+  if (!REG_P (operands[0]))\n     operands[0] = force_reg (DImode, operands[0]);\n \n   emit_move_insn (gen_rtx_REG (DImode, 25), operands[1]);\n@@ -4615,7 +4615,7 @@\n \t      (clobber (reg:DI 27))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (MEM_P (operands[0]));\n \n   operands[0] = XEXP (operands[0], 0);\n \n@@ -4668,7 +4668,7 @@\n \t      (unspec [(reg:DI 29)] UNSPEC_SIBCALL)])]\n   \"TARGET_ABI_OSF\"\n {\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n   operands[1] = XEXP (operands[1], 0);\n })\n \n@@ -4680,7 +4680,7 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n \n   operands[1] = XEXP (operands[1], 0);\n   if (! call_operand (operands[1], Pmode))\n@@ -4694,10 +4694,10 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n \n   operands[1] = XEXP (operands[1], 0);\n-  if (GET_CODE (operands[1]) != SYMBOL_REF && GET_CODE (operands[1]) != REG)\n+  if (GET_CODE (operands[1]) != SYMBOL_REF && !REG_P (operands[1]))\n     operands[1] = force_reg (DImode, operands[1]);\n })\n \n@@ -4711,7 +4711,7 @@\n \t      (clobber (reg:DI 27))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n \n   operands[1] = XEXP (operands[1], 0);\n \n@@ -4742,10 +4742,10 @@\n \t      (clobber (reg:DI 26))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n \n   operands[1] = XEXP (operands[1], 0);\n-  if (GET_CODE (operands[1]) != REG)\n+  if (!REG_P (operands[1]))\n     operands[1] = force_reg (DImode, operands[1]);\n \n   emit_move_insn (gen_rtx_REG (DImode, 25), operands[2]);\n@@ -5243,7 +5243,7 @@\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) == MEM\n+  if (MEM_P (operands[0])\n       && ! reg_or_0_operand (operands[1], SFmode))\n     operands[1] = force_reg (SFmode, operands[1]);\n })\n@@ -5253,7 +5253,7 @@\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) == MEM\n+  if (MEM_P (operands[0])\n       && ! reg_or_0_operand (operands[1], DFmode))\n     operands[1] = force_reg (DFmode, operands[1]);\n })\n@@ -5263,7 +5263,7 @@\n \t(match_operand:TF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) == MEM\n+  if (MEM_P (operands[0])\n       && ! reg_or_0_operand (operands[1], TFmode))\n     operands[1] = force_reg (TFmode, operands[1]);\n })\n@@ -5746,7 +5746,7 @@\n         (match_operand:TI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) == MEM\n+  if (MEM_P (operands[0])\n       && ! reg_or_0_operand (operands[1], TImode))\n     operands[1] = force_reg (TImode, operands[1]);\n \n@@ -5755,7 +5755,7 @@\n   /* We must put 64-bit constants in memory.  We could keep the\n      32-bit constants in TImode and rely on the splitter, but\n      this doesn't seem to be worth the pain.  */\n-  else if (GET_CODE (operands[1]) == CONST_INT\n+  else if (CONST_INT_P (operands[1])\n \t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n     {\n       rtx in[2], out[2], target;\n@@ -5780,7 +5780,7 @@\n \t  emit_insn (gen_movdi (out[1], in[1]));\n \t}\n \n-      if (GET_CODE (operands[0]) != REG)\n+      if (!REG_P (operands[0]))\n \ttarget = gen_reg_rtx (TImode);\n       else\n \ttarget = operands[0];\n@@ -6204,7 +6204,7 @@\n       rtx scratch3 = scratch1;\n       rtx seq;\n \n-      if (GET_CODE (addr) == REG)\n+      if (REG_P (addr))\n \tscratch1 = addr;\n \n       seq = gen_unaligned_store<reloadmode> (addr, operands[1], scratch1,\n@@ -6480,7 +6480,7 @@\n \n   /* From mips.md: extract_bit_field doesn't verify that our source\n      matches the predicate, so we force it to be a MEM here.  */\n-  if (GET_CODE (operands[1]) != MEM)\n+  if (!MEM_P (operands[1]))\n     FAIL;\n \n   /* The bit number is relative to the mode of operand 1 which is\n@@ -6516,7 +6516,7 @@\n \t  && INTVAL (operands[2]) != 64))\n     FAIL;\n \n-  if (GET_CODE (operands[1]) == MEM)\n+  if (MEM_P (operands[1]))\n     {\n       int ofs;\n \n@@ -6561,7 +6561,7 @@\n \n   /* From mips.md: store_bit_field doesn't verify that our source\n      matches the predicate, so we force it to be a MEM here.  */\n-  if (GET_CODE (operands[0]) != MEM)\n+  if (!MEM_P (operands[0]))\n     FAIL;\n \n   /* The bit number is relative to the mode of operand 1 which is\n@@ -6742,7 +6742,7 @@\n \t(match_dup 2))]\n   \"\"\n {\n-  if (GET_CODE (operands[1]) == CONST_INT\n+  if (CONST_INT_P (operands[1])\n       && INTVAL (operands[1]) < 32768)\n     {\n       if (INTVAL (operands[1]) >= 4096)\n@@ -6775,7 +6775,7 @@\n \t\t\t     force_reg (Pmode, operands[1])));\n       emit_insn (gen_adddi3 (tmp, stack_pointer_rtx, GEN_INT (-4096)));\n \n-      if (GET_CODE (operands[1]) != CONST_INT)\n+      if (!CONST_INT_P (operands[1]))\n \t{\n \t  out_label = gen_label_rtx ();\n \t  emit_insn (gen_cmpdi (want, tmp));\n@@ -7533,7 +7533,7 @@\n \t\t(match_operand:DI 1 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (CONST_INT_P (operands[2]))\n     {\n       rtx mask = alpha_expand_zap_mask (INTVAL (operands[2]));\n \n@@ -7581,7 +7581,7 @@\n   [(const_int 0)]\n {\n   rtx mask = alpha_expand_zap_mask (INTVAL (operands[2]));\n-  if (HOST_BITS_PER_WIDE_INT >= 64 || GET_CODE (mask) == CONST_INT)\n+  if (HOST_BITS_PER_WIDE_INT >= 64 || CONST_INT_P (mask))\n     operands[1] = gen_int_mode (INTVAL (operands[1]) & INTVAL (mask), DImode);\n   else\n     {\n@@ -7626,7 +7626,7 @@\n \t\t(match_operand:DI 1 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (CONST_INT_P (operands[2]))\n     {\n       rtx mask = alpha_expand_zap_mask (~ INTVAL (operands[2]));\n "}, {"sha": "3e9a88776e08515c56a4e53aa29853ad24f05e54", "filename": "gcc/config/alpha/constraints.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fconstraints.md?ref=7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "patch": "@@ -42,7 +42,7 @@\n (define_constraint \"I\"\n   \"An unsigned 8 bit constant\"\n   (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 255\")))\n+       (match_test \"IN_RANGE (ival, 0, 255)\")))\n \n (define_constraint \"J\"\n   \"The constant zero\"\n@@ -52,7 +52,7 @@\n (define_constraint \"K\"\n   \"Signed 16-bit integer constant\"\n   (and (match_code \"const_int\")\n-       (match_test \"ival >= -32768 && ival < 32768 \")))\n+       (match_test \"IN_RANGE (ival, -32768, 32767)\")))\n \n (define_constraint \"L\"\n   \"A shifted signed 16-bit constant appropriate for LDAH\"\n@@ -68,12 +68,12 @@\n (define_constraint \"N\"\n   \"A complemented unsigned 8-bit constant\"\n   (and (match_code \"const_int\")\n-       (match_test \"~ival >= 0 && ~ival <= 255\")))\n+       (match_test \"IN_RANGE (~ival, 0, 255)\")))\n \n (define_constraint \"O\"\n   \"A negated unsigned 8-bit constant\"\n   (and (match_code \"const_int\")\n-       (match_test \"-ival >= 0 && -ival <= 255\")))\n+       (match_test \"IN_RANGE (-ival, 0, 255)\")))\n \n (define_constraint \"P\"\n   \"The constant 1, 2 or 3\"\n@@ -104,7 +104,7 @@\n (define_constraint \"S\"\n   \"An unsigned 6-bit constant\"\n   (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 63\")))\n+       (match_test \"IN_RANGE (ival, 0, 63)\")))\n \n (define_constraint \"T\"\n   \"@internal A high-part symbol\""}, {"sha": "425134ac820a1fd5018cea9ab9e569a94bf488db", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=7d83f4f5362bb17aa3b53db60bed6dbb5cd38e73", "patch": "@@ -112,7 +112,7 @@\n (define_predicate \"mode_mask_operand\"\n   (match_code \"const_int,const_double\")\n {\n-  if (GET_CODE (op) == CONST_INT)\n+  if (CONST_INT_P (op))\n     {\n       HOST_WIDE_INT value = INTVAL (op);\n \n@@ -326,7 +326,7 @@\n {\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (XEXP (op, 0), 1)))\n     op = XEXP (XEXP (op, 0), 0);\n \n   if (GET_CODE (op) == LABEL_REF)\n@@ -350,7 +350,7 @@\n \n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (XEXP (op, 0), 1)))\n     op = XEXP (XEXP (op, 0), 0);\n \n   if (GET_CODE (op) != SYMBOL_REF)\n@@ -374,7 +374,7 @@\n {\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (XEXP (op, 0), 1)))\n     op = XEXP (XEXP (op, 0), 0);\n \n   if (GET_CODE (op) != SYMBOL_REF)\n@@ -392,7 +392,7 @@\n \t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n \t\t\t && (GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n \t\t\t     || GET_CODE (XEXP (XEXP (op,0), 0)) == LABEL_REF)\n-\t\t\t && GET_CODE (XEXP (XEXP (op,0), 1)) == CONST_INT\"))))\n+\t\t\t && CONST_INT_P (XEXP (XEXP (op,0), 1))\"))))\n \n ;; Return true if OP is valid for 16-bit DTP relative relocations.\n (define_predicate \"dtp16_symbolic_operand\"\n@@ -457,7 +457,7 @@\n       base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n     }\n \n-  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) >= 32);\n+  return (REG_P (base) && REGNO_POINTER_ALIGN (REGNO (base)) >= 32);\n })\n \n ;; Similar, but return 1 if OP is a MEM which is not alignable.\n@@ -485,7 +485,7 @@\n       base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n     }\n \n-  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) < 32);\n+  return (REG_P (base) && REGNO_POINTER_ALIGN (REGNO (base)) < 32);\n })\n \n ;; Return 1 if OP is any memory location.  During reload a pseudo matches."}]}