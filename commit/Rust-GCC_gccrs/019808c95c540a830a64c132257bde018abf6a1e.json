{"sha": "019808c95c540a830a64c132257bde018abf6a1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE5ODA4Yzk1YzU0MGE4MzBhNjRjMTMyMjU3YmRlMDE4YWJmNmExZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-05-02T21:53:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-05-02T21:53:30Z"}, "message": "libgo: break dependence on libgcc unwind-pe.h\n    \n    The C portion of the Go runtime includes the header \"unwind-pe.h\" from\n    libgcc, which contains some constants and a few small routines for\n    decoding pointer values within unwind info. This patch gets rid of\n    that include and instead adds a re-implementation of that\n    functionality in the single file that uses it. The intent is to allow\n    the C runtime portion of libgo to be built without a companion GCC\n    installation.\n    \n    Reviewed-on: https://go-review.googlesource.com/90235\n\nFrom-SVN: r259861", "tree": {"sha": "b635fa4c3ee82a3c372d5ef01531c276fd59559f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b635fa4c3ee82a3c372d5ef01531c276fd59559f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/019808c95c540a830a64c132257bde018abf6a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019808c95c540a830a64c132257bde018abf6a1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/019808c95c540a830a64c132257bde018abf6a1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019808c95c540a830a64c132257bde018abf6a1e/comments", "author": null, "committer": null, "parents": [{"sha": "27db01d8039a1a1664bcd1ebd1f66cedcfe72398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27db01d8039a1a1664bcd1ebd1f66cedcfe72398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27db01d8039a1a1664bcd1ebd1f66cedcfe72398"}], "stats": {"total": 167, "additions": 165, "deletions": 2}, "files": [{"sha": "536a619d2987fc08d80fc54a93b21d78cf493915", "filename": "libgo/runtime/go-unwind.c", "status": "modified", "additions": 165, "deletions": 2, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019808c95c540a830a64c132257bde018abf6a1e/libgo%2Fruntime%2Fgo-unwind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019808c95c540a830a64c132257bde018abf6a1e/libgo%2Fruntime%2Fgo-unwind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unwind.c?ref=019808c95c540a830a64c132257bde018abf6a1e", "patch": "@@ -10,11 +10,30 @@\n #include <unistd.h>\n \n #include \"unwind.h\"\n-#define NO_SIZE_OF_ENCODED_VALUE\n-#include \"unwind-pe.h\"\n \n #include \"runtime.h\"\n \n+/* These constants are documented here:\n+   https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/dwarfext.html\n+ */\n+\n+#define DW_EH_PE_omit     0xff\n+#define DW_EH_PE_absptr   0x00\n+#define DW_EH_PE_uleb128  0x01\n+#define DW_EH_PE_udata2   0x02\n+#define DW_EH_PE_udata4   0x03\n+#define DW_EH_PE_udata8   0x04\n+#define DW_EH_PE_sleb128  0x09\n+#define DW_EH_PE_sdata2   0x0A\n+#define DW_EH_PE_sdata4   0x0B\n+#define DW_EH_PE_sdata8   0x0C\n+#define DW_EH_PE_pcrel    0x10\n+#define DW_EH_PE_textrel  0x20\n+#define DW_EH_PE_datarel  0x30\n+#define DW_EH_PE_funcrel  0x40\n+#define DW_EH_PE_aligned  0x50\n+#define DW_EH_PE_indirect 0x80\n+\n /* The code for a Go exception.  */\n \n #ifdef __ARM_EABI_UNWINDER__\n@@ -109,6 +128,150 @@ throwException ()\n   abort ();\n }\n \n+static inline _Unwind_Ptr\n+encoded_value_base (uint8_t encoding, struct _Unwind_Context *context)\n+{\n+  if (encoding == DW_EH_PE_omit)\n+    return 0;\n+  switch (encoding & 0x70)\n+    {\n+      case DW_EH_PE_absptr:\n+      case DW_EH_PE_pcrel:\n+      case DW_EH_PE_aligned:\n+        return 0;\n+      case DW_EH_PE_textrel:\n+        return _Unwind_GetTextRelBase(context);\n+      case DW_EH_PE_datarel:\n+        return _Unwind_GetDataRelBase(context);\n+      case DW_EH_PE_funcrel:\n+        return _Unwind_GetRegionStart(context);\n+    }\n+  abort ();\n+}\n+\n+/* Read an unsigned leb128 value.  */\n+\n+static inline const uint8_t *\n+read_uleb128 (const uint8_t *p, _uleb128_t *val)\n+{\n+  unsigned int shift = 0;\n+  _uleb128_t result = 0;\n+  uint8_t byte;\n+\n+  do\n+    {\n+      byte = *p++;\n+      result |= ((_uleb128_t)byte & 0x7f) << shift;\n+      shift += 7;\n+    }\n+  while (byte & 0x80);\n+\n+  *val = result;\n+  return p;\n+}\n+\n+/* Similar, but read a signed leb128 value.  */\n+\n+static inline const uint8_t *\n+read_sleb128 (const uint8_t *p, _sleb128_t *val)\n+{\n+  unsigned int shift = 0;\n+  _uleb128_t result = 0;\n+  uint8_t byte;\n+\n+  do\n+    {\n+      byte = *p++;\n+      result |= ((_uleb128_t)byte & 0x7f) << shift;\n+      shift += 7;\n+    }\n+  while (byte & 0x80);\n+\n+  /* sign extension */\n+  if (shift < (8 * sizeof(result)) && (byte & 0x40) != 0)\n+    result |= (((_uleb128_t)~0) << shift);\n+\n+  *val = (_sleb128_t)result;\n+  return p;\n+}\n+\n+#define ROUND_UP_TO_PVB(x) (x + sizeof(void *) - 1) &- sizeof(void *)\n+\n+#define COPY_AND_ADVANCE(dst, ptr, typ) \\\n+  (dst = *((const typ*)ptr),            \\\n+   ptr += sizeof(typ))\n+\n+static inline const uint8_t *\n+read_encoded_value (struct _Unwind_Context *context, uint8_t encoding,\n+                    const uint8_t *p, _Unwind_Ptr *val)\n+{\n+  _Unwind_Ptr base = encoded_value_base (encoding, context);\n+  _Unwind_Internal_Ptr decoded = 0;\n+  const uint8_t *origp = p;\n+\n+  if (encoding == DW_EH_PE_aligned)\n+    {\n+      _Unwind_Internal_Ptr uip = (_Unwind_Internal_Ptr)p;\n+      uip = ROUND_UP_TO_PVB (uip);\n+      decoded = *(_Unwind_Internal_Ptr *)uip;\n+      p = (const uint8_t *)(uip + sizeof(void *));\n+    }\n+  else\n+    {\n+      switch (encoding & 0x0f)\n+        {\n+          case DW_EH_PE_sdata2:\n+          case DW_EH_PE_udata2:\n+            COPY_AND_ADVANCE (decoded, p, uint16_t);\n+            break;\n+          case DW_EH_PE_sdata4:\n+          case DW_EH_PE_udata4:\n+            COPY_AND_ADVANCE (decoded, p, uint32_t);\n+            break;\n+          case DW_EH_PE_sdata8:\n+          case DW_EH_PE_udata8:\n+            COPY_AND_ADVANCE (decoded, p, uint64_t);\n+            break;\n+          case DW_EH_PE_uleb128:\n+            {\n+              _uleb128_t value;\n+              p = read_uleb128 (p, &value);\n+              decoded = (_Unwind_Internal_Ptr)value;\n+              break;\n+            }\n+          case DW_EH_PE_sleb128:\n+            {\n+              _sleb128_t value;\n+              p = read_sleb128 (p, &value);\n+              decoded = (_Unwind_Internal_Ptr)value;\n+              break;\n+            }\n+          case DW_EH_PE_absptr:\n+            decoded = (_Unwind_Internal_Ptr)(*(const void *const *)p);\n+            p += sizeof(void *);\n+            break;\n+          default:\n+            abort ();\n+        }\n+\n+      if (decoded == 0)\n+        {\n+          *val = decoded;\n+          return p;\n+        }\n+\n+      if ((encoding & 0x70) == DW_EH_PE_pcrel)\n+        decoded += ((_Unwind_Internal_Ptr)origp);\n+      else\n+        decoded += base;\n+\n+      if ((encoding & DW_EH_PE_indirect) != 0)\n+        decoded = *(_Unwind_Internal_Ptr *)decoded;\n+    }\n+  *val = decoded;\n+  return p;\n+}\n+\n /* The rest of this code is really similar to gcc/unwind-c.c and\n    libjava/exception.cc.  */\n "}]}