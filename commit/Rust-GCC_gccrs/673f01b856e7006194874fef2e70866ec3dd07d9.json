{"sha": "673f01b856e7006194874fef2e70866ec3dd07d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjczZjAxYjg1NmU3MDA2MTk0ODc0ZmVmMmU3MDg2NmVjM2RkMDdkOQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2019-06-25T09:52:04Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2019-06-25T09:52:04Z"}, "message": "[ARC] Fix for PR89838\n\ngcc/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.c (arc_symbol_binds_local_p): New function.\n\t(arc_legitimize_pic_address): Simplify and cleanup the function.\n\t(SYMBOLIC_CONST): Remove.\n\t(prepare_pic_move): Likewise.\n\t(prepare_move_operands): Handle complex mov cases here.\n\t(arc_legitimize_address_0): Remove call to\n\tarc_legitimize_pic_address.\n\t(arc_legitimize_address): Remove call to\n\tarc_legitimize_tls_address.\n\t* config/arc/arc.md (movqi_insn): Allow Cm3 match.\n\t(movhi_insn): Likewise.\n\n/gcc/testsuite\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* gcc.target/arc/pr89838.c: New file.\n\nFrom-SVN: r272643", "tree": {"sha": "5c10b964c92873ffc153830a70290b2583d9e8dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c10b964c92873ffc153830a70290b2583d9e8dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/673f01b856e7006194874fef2e70866ec3dd07d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673f01b856e7006194874fef2e70866ec3dd07d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673f01b856e7006194874fef2e70866ec3dd07d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673f01b856e7006194874fef2e70866ec3dd07d9/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e5803060c3d6db3ff73195db798ffd8e5588e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5803060c3d6db3ff73195db798ffd8e5588e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e5803060c3d6db3ff73195db798ffd8e5588e78"}], "stats": {"total": 257, "additions": 95, "deletions": 162}, "files": [{"sha": "d9f3c219121c7d263fa63dea27fc81769a697326", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=673f01b856e7006194874fef2e70866ec3dd07d9", "patch": "@@ -1,3 +1,17 @@\n+2019-06-25  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.c (arc_symbol_binds_local_p): New function.\n+\t(arc_legitimize_pic_address): Simplify and cleanup the function.\n+\t(SYMBOLIC_CONST): Remove.\n+\t(prepare_pic_move): Likewise.\n+\t(prepare_move_operands): Handle complex mov cases here.\n+\t(arc_legitimize_address_0): Remove call to\n+\tarc_legitimize_pic_address.\n+\t(arc_legitimize_address): Remove call to\n+\tarc_legitimize_tls_address.\n+\t* config/arc/arc.md (movqi_insn): Allow Cm3 match.\n+\t(movhi_insn): Likewise.\n+\n 2019-06-25  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* gcc/c-family/c-common.c (c_common_nodes_and_builtins): Define"}, {"sha": "0f80e2ad86d7cdeaf41c58e72fea9ca0e06a67b0", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 55, "deletions": 160, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=673f01b856e7006194874fef2e70866ec3dd07d9", "patch": "@@ -5975,130 +5975,47 @@ arc_legitimize_tls_address (rtx addr, enum tls_model model)\n     }\n }\n \n-/* Legitimize a pic address reference in ORIG.\n-   The return value is the legitimated address.\n-   If OLDX is non-zero, it is the target to assign the address to first.  */\n+/* Return true if SYMBOL_REF X binds locally.  */\n \n-static rtx\n-arc_legitimize_pic_address (rtx orig, rtx oldx)\n+static bool\n+arc_symbol_binds_local_p (const_rtx x)\n {\n-  rtx addr = orig;\n-  rtx pat = orig;\n-  rtx base;\n+  return (SYMBOL_REF_DECL (x)\n+\t  ? targetm.binds_local_p (SYMBOL_REF_DECL (x))\n+\t  : SYMBOL_REF_LOCAL_P (x));\n+}\n+\n+/* Legitimize a pic address reference in ADDR.  The return value is\n+   the legitimated address.  */\n \n-  if (oldx == orig)\n-    oldx = NULL;\n+static rtx\n+arc_legitimize_pic_address (rtx addr)\n+{\n+  if (!flag_pic)\n+    return addr;\n \n-  if (GET_CODE (addr) == LABEL_REF)\n-    ; /* Do nothing.  */\n-  else if (GET_CODE (addr) == SYMBOL_REF)\n+  switch (GET_CODE (addr))\n     {\n-      enum tls_model model = SYMBOL_REF_TLS_MODEL (addr);\n-      if (model != 0)\n-\treturn arc_legitimize_tls_address (addr, model);\n-      else if (!flag_pic)\n-\treturn orig;\n-      else if (CONSTANT_POOL_ADDRESS_P (addr) || SYMBOL_REF_LOCAL_P (addr))\n-\treturn arc_unspec_offset (addr, ARC_UNSPEC_GOTOFFPC);\n+    case SYMBOL_REF:\n+      /* TLS symbols are handled in different place.  */\n+      if (SYMBOL_REF_TLS_MODEL (addr))\n+\treturn addr;\n \n       /* This symbol must be referenced via a load from the Global\n \t Offset Table (@GOTPC).  */\n-      pat = arc_unspec_offset (addr, ARC_UNSPEC_GOT);\n-      pat = gen_const_mem (Pmode, pat);\n-\n-      if (oldx == NULL)\n-\toldx = gen_reg_rtx (Pmode);\n-\n-      emit_move_insn (oldx, pat);\n-      pat = oldx;\n-    }\n-  else\n-    {\n-      if (GET_CODE (addr) == CONST)\n-\t{\n-\t  addr = XEXP (addr, 0);\n-\t  if (GET_CODE (addr) == UNSPEC)\n-\t    {\n-\t      /* Check that the unspec is one of the ones we generate?  */\n-\t      return orig;\n-\t    }\n-\t  /* fwprop is placing in the REG_EQUIV notes constant pic\n-\t     unspecs expressions.  Then, loop may use these notes for\n-\t     optimizations resulting in complex patterns that are not\n-\t     supported by the current implementation. The following\n-\t     two if-cases are simplifying the complex patters to\n-\t     simpler ones.  */\n-\t  else if (GET_CODE (addr) == MINUS)\n-\t    {\n-\t      rtx op0 = XEXP (addr, 0);\n-\t      rtx op1 = XEXP (addr, 1);\n-\t      gcc_assert (oldx);\n-\t      gcc_assert (GET_CODE (op1) == UNSPEC);\n-\n-\t      emit_move_insn (oldx,\n-\t\t\t      gen_rtx_CONST (SImode,\n-\t\t\t\t\t     arc_legitimize_pic_address (op1,\n-\t\t\t\t\t\t\t\t\t NULL_RTX)));\n-\t      emit_insn (gen_rtx_SET (oldx, gen_rtx_MINUS (SImode, op0, oldx)));\n-\t      return oldx;\n-\n-\t    }\n-\t  else if (GET_CODE (addr) != PLUS)\n-\t    {\n-\t      rtx tmp = XEXP (addr, 0);\n-\t      enum rtx_code code = GET_CODE (addr);\n-\n-\t      /* It only works for UNARY operations.  */\n-\t      gcc_assert (UNARY_P (addr));\n-\t      gcc_assert (GET_CODE (tmp) == UNSPEC);\n-\t      gcc_assert (oldx);\n-\n-\t      emit_move_insn\n-\t\t(oldx,\n-\t\t gen_rtx_CONST (SImode,\n-\t\t\t\tarc_legitimize_pic_address (tmp,\n-\t\t\t\t\t\t\t    NULL_RTX)));\n-\n-\t      emit_insn (gen_rtx_SET (oldx,\n-\t\t\t\t      gen_rtx_fmt_ee (code, SImode,\n-\t\t\t\t\t\t      oldx, const0_rtx)));\n-\n-\t      return oldx;\n-\t    }\n-\t  else\n-\t    {\n-\t      gcc_assert (GET_CODE (addr) == PLUS);\n-\t      if (GET_CODE (XEXP (addr, 0)) == UNSPEC)\n-\t\treturn orig;\n-\t    }\n-\t}\n-\n-      if (GET_CODE (addr) == PLUS)\n-\t{\n-\t  rtx op0 = XEXP (addr, 0), op1 = XEXP (addr, 1);\n-\n-\t  base = arc_legitimize_pic_address (op0, oldx);\n-\t  pat  = arc_legitimize_pic_address (op1,\n-\t\t\t\t\t     base == oldx ? NULL_RTX : oldx);\n+      if (!arc_symbol_binds_local_p (addr))\n+\treturn gen_const_mem (Pmode, arc_unspec_offset (addr, ARC_UNSPEC_GOT));\n \n-\t  if (base == op0 && pat == op1)\n-\t    return orig;\n+      /* Local symb: use @pcl to access it.  */\n+      /* Fall through.  */\n+    case LABEL_REF:\n+      return arc_unspec_offset (addr, ARC_UNSPEC_GOTOFFPC);\n \n-\t  if (GET_CODE (pat) == CONST_INT)\n-\t    pat = plus_constant (Pmode, base, INTVAL (pat));\n-\t  else\n-\t    {\n-\t      if (GET_CODE (pat) == PLUS && CONSTANT_P (XEXP (pat, 1)))\n-\t\t{\n-\t\t  base = gen_rtx_PLUS (Pmode, base, XEXP (pat, 0));\n-\t\t  pat = XEXP (pat, 1);\n-\t\t}\n-\t      pat = gen_rtx_PLUS (Pmode, base, pat);\n-\t    }\n-\t}\n+    default:\n+      break;\n     }\n \n- return pat;\n+ return addr;\n }\n \n /* Output address constant X to FILE, taking PIC into account.  */\n@@ -6260,28 +6177,6 @@ arc_output_pic_addr_const (FILE * file, rtx x, int code)\n     }\n }\n \n-#define SYMBOLIC_CONST(X)\t\\\n-(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n- || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n- || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n-\n-/* Emit insns to move operands[1] into operands[0].  */\n-\n-static void\n-prepare_pic_move (rtx *operands, machine_mode)\n-{\n-  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1])\n-      && flag_pic)\n-    operands[1] = force_reg (Pmode, operands[1]);\n-  else\n-    {\n-      rtx temp = (reload_in_progress ? operands[0]\n-\t\t  : flag_pic? gen_reg_rtx (Pmode) : NULL_RTX);\n-      operands[1] = arc_legitimize_pic_address (operands[1], temp);\n-    }\n-}\n-\n-\n /* The function returning the number of words, at the beginning of an\n    argument, must be put in registers.  The returned value must be\n    zero for arguments that are passed entirely in registers or that\n@@ -9061,30 +8956,38 @@ prepare_move_operands (rtx *operands, machine_mode mode)\n \t}\n     }\n \n-  if (mode == SImode && SYMBOLIC_CONST (operands[1]))\n+  if (GET_CODE (operands[1]) == SYMBOL_REF)\n     {\n-      prepare_pic_move (operands, SImode);\n-\n-      /* Disable any REG_EQUALs associated with the symref\n-\t otherwise the optimization pass undoes the work done\n-\t here and references the variable directly.  */\n+      enum tls_model model = SYMBOL_REF_TLS_MODEL (operands[1]);\n+      if (MEM_P (operands[0]) && flag_pic)\n+\toperands[1] = force_reg (mode, operands[1]);\n+      else if (model)\n+\toperands[1] = arc_legitimize_tls_address (operands[1], model);\n     }\n \n+  operands[1] = arc_legitimize_pic_address (operands[1]);\n+\n+  /* Store instructions are limited, they only accept as address an\n+     immediate, a register or a register plus a small immediate.  */\n   if (MEM_P (operands[0])\n-      && !(reload_in_progress || reload_completed))\n+      && !move_dest_operand (operands[0], mode))\n     {\n-      operands[1] = force_reg (mode, operands[1]);\n-      if (!move_dest_operand (operands[0], mode))\n-\t{\n-\t  rtx addr = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-\t  /* This is like change_address_1 (operands[0], mode, 0, 1) ,\n-\t     except that we can't use that function because it is static.  */\n-\t  rtx pat = change_address (operands[0], mode, addr);\n-\t  MEM_COPY_ATTRIBUTES (pat, operands[0]);\n-\t  operands[0] = pat;\n-\t}\n+      rtx tmp0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+      rtx tmp1 = change_address (operands[0], mode, tmp0);\n+      MEM_COPY_ATTRIBUTES (tmp1, operands[0]);\n+      operands[0] = tmp1;\n     }\n \n+  /* Check if it is constant but it is not legitimized.  */\n+  if (CONSTANT_P (operands[1])\n+      && !arc_legitimate_constant_p (mode, operands[1]))\n+    operands[1] = force_reg (mode, XEXP (operands[1], 0));\n+  else if (MEM_P (operands[0])\n+\t   && ((CONSTANT_P (operands[1])\n+\t\t&& !satisfies_constraint_Cm3 (operands[1]))\n+\t       || MEM_P (operands[1])))\n+    operands[1] = force_reg (mode, operands[1]);\n+\n   return false;\n }\n \n@@ -9555,11 +9458,10 @@ arc_legitimize_address_0 (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n {\n   rtx addr, inner;\n \n-  if (flag_pic && SYMBOLIC_CONST (x))\n-     (x) =  arc_legitimize_pic_address (x, 0);\n   addr = x;\n   if (GET_CODE (addr) == CONST)\n     addr = XEXP (addr, 0);\n+\n   if (GET_CODE (addr) == PLUS\n       && CONST_INT_P (XEXP (addr, 1))\n       && ((GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n@@ -9590,13 +9492,6 @@ arc_legitimize_address_0 (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n static rtx\n arc_legitimize_address (rtx orig_x, rtx oldx, machine_mode mode)\n {\n-  if (GET_CODE (orig_x) == SYMBOL_REF)\n-    {\n-      enum tls_model model = SYMBOL_REF_TLS_MODEL (orig_x);\n-      if (model != 0)\n-\treturn arc_legitimize_tls_address (orig_x, model);\n-    }\n-\n   rtx new_x = arc_legitimize_address_0 (orig_x, oldx, mode);\n \n   if (new_x)"}, {"sha": "99a0e337884325216400750412b448b067b32d17", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=673f01b856e7006194874fef2e70866ec3dd07d9", "patch": "@@ -671,7 +671,9 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w, w,???w,h, w,Rcq,  S,!*x,  r,r, Ucm,m,???m,  m,Usc\")\n \t(match_operand:QI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1,cL, I,?Rac,i,?i,  T,Rcq,Usd,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n   \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\"\n+   || register_operand (operands[1], QImode)\n+   || (satisfies_constraint_Cm3 (operands[1])\n+       && memory_operand (operands[0], QImode))\"\n   \"@\n    mov%? %0,%1%&\n    mov%? %0,%1%&\n@@ -713,7 +715,9 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n        /* Don't use a LIMM that we could load with a single insn - we loose\n \t  delay-slot filling opportunities.  */\n        && !satisfies_constraint_I (operands[1])\n-       && satisfies_constraint_Usc (operands[0]))\"\n+       && satisfies_constraint_Usc (operands[0]))\n+   || (satisfies_constraint_Cm3 (operands[1])\n+       && memory_operand (operands[0], HImode))\"\n   \"@\n    mov%? %0,%1%&\n    mov%? %0,%1%&"}, {"sha": "b29a9c2f2cdfd95768db9a81d6133e9e1b5c6761", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=673f01b856e7006194874fef2e70866ec3dd07d9", "patch": "@@ -1,3 +1,7 @@\n+2019-06-25  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/pr89838.c: New file.\n+\n 2019-06-25  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* gcc.target/msp430/mlarge-pedwarns.c: New test."}, {"sha": "559434ac87e6ec90468b279f748a198941c879f2", "filename": "gcc/testsuite/gcc.target/arc/pr89838.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fpr89838.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673f01b856e7006194874fef2e70866ec3dd07d9/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fpr89838.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fpr89838.c?ref=673f01b856e7006194874fef2e70866ec3dd07d9", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void foo (void);\n+extern void bar (void *);\n+\n+struct {\n+  int __attribute__(()) a;\n+  int __attribute__(()) b;\n+} __thread c __attribute__((tls_model(\"initial-exec\")));\n+\n+void foo (void)\n+{\n+  bar (&c.b);\n+}"}]}