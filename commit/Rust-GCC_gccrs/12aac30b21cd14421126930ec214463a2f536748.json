{"sha": "12aac30b21cd14421126930ec214463a2f536748", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJhYWMzMGIyMWNkMTQ0MjExMjY5MzBlYzIxNDQ2M2EyZjUzNjc0OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2007-05-04T19:19:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2007-05-04T19:19:10Z"}, "message": "* config/linux/proc.c: New file.\n\nFrom-SVN: r124443", "tree": {"sha": "6e4794558a31c698d742d9756757f0d44affe185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e4794558a31c698d742d9756757f0d44affe185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12aac30b21cd14421126930ec214463a2f536748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12aac30b21cd14421126930ec214463a2f536748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12aac30b21cd14421126930ec214463a2f536748", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12aac30b21cd14421126930ec214463a2f536748/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52d53754d17c934708e5d32044bddb6510b40bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d53754d17c934708e5d32044bddb6510b40bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52d53754d17c934708e5d32044bddb6510b40bec"}], "stats": {"total": 183, "additions": 183, "deletions": 0}, "files": [{"sha": "d6f08fd9089373b416fc83cf50b38732be1fc656", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12aac30b21cd14421126930ec214463a2f536748/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12aac30b21cd14421126930ec214463a2f536748/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=12aac30b21cd14421126930ec214463a2f536748", "patch": "@@ -1,3 +1,7 @@\n+2007-05-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/linux/proc.c: New file.\n+\n 2007-04-19  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* libgomp.texi (GOMP_CPU_AFFINITY): Updated."}, {"sha": "2267cfbd2d1b2c5f7a13da80355e191ae2c89658", "filename": "libgomp/config/linux/proc.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12aac30b21cd14421126930ec214463a2f536748/libgomp%2Fconfig%2Flinux%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12aac30b21cd14421126930ec214463a2f536748/libgomp%2Fconfig%2Flinux%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fproc.c?ref=12aac30b21cd14421126930ec214463a2f536748", "patch": "@@ -0,0 +1,179 @@\n+/* Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains system specific routines related to counting\n+   online processors and dynamic load balancing.  */\n+\n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE 1\n+#endif\n+#include \"libgomp.h\"\n+#include <sched.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#ifdef HAVE_GETLOADAVG\n+# ifdef HAVE_SYS_LOADAVG_H\n+#  include <sys/loadavg.h>\n+# endif\n+#endif\n+\n+#ifdef HAVE_PTHREAD_AFFINITY_NP\n+static unsigned long\n+cpuset_popcount (cpu_set_t *cpusetp)\n+{\n+#ifdef CPU_COUNT\n+  /* glibc 2.6 and above provide a macro for this.  */\n+  return CPU_COUNT (cpusetp);\n+#else\n+  size_t i;\n+  unsigned long ret = 0;\n+  extern int check[sizeof (cpusetp->__bits[0]) == sizeof (unsigned long int)];\n+\n+  (void) check;\n+  for (i = 0; i < sizeof (*cpusetp) / sizeof (cpusetp->__bits[0]); i++)\n+    {\n+      unsigned long int mask = cpusetp->__bits[i];\n+      if (mask == 0)\n+\tcontinue;\n+      ret += __builtin_popcountl (mask);\n+    }\n+  return ret;\n+#endif\n+}\n+#endif\n+\n+/* At startup, determine the default number of threads.  It would seem\n+   this should be related to the number of cpus online.  */\n+\n+void\n+gomp_init_num_threads (void)\n+{\n+#ifdef HAVE_PTHREAD_AFFINITY_NP\n+  cpu_set_t cpuset;\n+\n+  if (pthread_getaffinity_np (pthread_self (), sizeof (cpuset), &cpuset) == 0)\n+    {\n+      /* Count only the CPUs this process can use.  */\n+      gomp_nthreads_var = cpuset_popcount (&cpuset);\n+      if (gomp_nthreads_var == 0)\n+\tgomp_nthreads_var = 1;\n+      return;\n+    }\n+#endif\n+#ifdef _SC_NPROCESSORS_ONLN\n+  gomp_nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n+#endif\n+}\n+\n+static int\n+get_num_procs (void)\n+{\n+#ifdef HAVE_PTHREAD_AFFINITY_NP\n+  cpu_set_t cpuset;\n+\n+  if (gomp_cpu_affinity == NULL)\n+    {\n+      /* Count only the CPUs this process can use.  */\n+      if (pthread_getaffinity_np (pthread_self (), sizeof (cpuset),\n+\t\t\t\t  &cpuset) == 0)\n+\t{\n+\t  int ret = cpuset_popcount (&cpuset);\n+\t  return ret != 0 ? ret : 1;\n+\t}\n+    }\n+  else\n+    {\n+      size_t idx;\n+      static int affinity_cpus;\n+\n+      /* We can't use pthread_getaffinity_np in this case\n+\t (we have changed it ourselves, it binds to just one CPU).\n+\t Count instead the number of different CPUs we are\n+\t using.  */\n+      CPU_ZERO (&cpuset);\n+      if (affinity_cpus == 0)\n+\t{\n+\t  int cpus = 0;\n+\t  for (idx = 0; idx < gomp_cpu_affinity_len; idx++)\n+\t    if (! CPU_ISSET (gomp_cpu_affinity[idx], &cpuset))\n+\t      {\n+\t\tcpus++;\n+\t\tCPU_SET (gomp_cpu_affinity[idx], &cpuset);\n+\t      }\n+\t  affinity_cpus = cpus;\n+\t}\n+      return affinity_cpus;\n+    }\n+#endif\n+#ifdef _SC_NPROCESSORS_ONLN\n+  return sysconf (_SC_NPROCESSORS_ONLN);\n+#else\n+  return gomp_nthreads_var;\n+#endif\n+}\n+\n+/* When OMP_DYNAMIC is set, at thread launch determine the number of\n+   threads we should spawn for this team.  */\n+/* ??? I have no idea what best practice for this is.  Surely some\n+   function of the number of processors that are *still* online and\n+   the load average.  Here I use the number of processors online\n+   minus the 15 minute load average.  */\n+\n+unsigned\n+gomp_dynamic_max_threads (void)\n+{\n+  unsigned n_onln, loadavg;\n+\n+  n_onln = get_num_procs ();\n+  if (n_onln > gomp_nthreads_var)\n+    n_onln = gomp_nthreads_var;\n+\n+  loadavg = 0;\n+#ifdef HAVE_GETLOADAVG\n+  {\n+    double dloadavg[3];\n+    if (getloadavg (dloadavg, 3) == 3)\n+      {\n+\t/* Add 0.1 to get a kind of biased rounding.  */\n+\tloadavg = dloadavg[2] + 0.1;\n+      }\n+  }\n+#endif\n+\n+  if (loadavg >= n_onln)\n+    return 1;\n+  else\n+    return n_onln - loadavg;\n+}\n+\n+int\n+omp_get_num_procs (void)\n+{\n+  return get_num_procs ();\n+}\n+\n+ialias (omp_get_num_procs)"}]}