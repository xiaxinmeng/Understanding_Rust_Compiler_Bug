{"sha": "198781144f33b0ef17dd2094580b5c77ad97d6e8", "node_id": "C_kwDOANBUbNoAKDE5ODc4MTE0NGYzM2IwZWYxN2RkMjA5NDU4MGI1Yzc3YWQ5N2Q2ZTg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-06-27T13:43:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-06-28T11:09:20Z"}, "message": "libstdc++: Improve directory iterator abstractions for openat\n\nCurrently the _Dir::open_subdir function decides whether to construct a\n_Dir_base with just a pathname, or a file descriptor and pathname. But\nthat means it is tiughtly coupled to the implementation of\n_Dir_base::openat, which is what actually decides whether to use a file\ndescriptor or not. If the derived class passes a file descriptor and\nfilename, but the base class expects a full path and ignores the file\ndescriptor, then recursive_directory_iterator cannot recurse.\n\nThis change introduces a new type that provides the union of all the\ninformation available to the derived class (the full pathname, as well\nas a file descriptor for a directory and another pathname relative to\nthat directory). This allows the derived class to be agnostic to how the\nbase class will use that information.\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/fs_dir.cc (_Dir::dir_and_pathname):: Replace with\n\tcurrent() returning _At_path.\n\t(_Dir::_Dir, _Dir::open_subdir, _Dir::do_unlink): Adjust.\n\t* src/filesystem/dir-common.h (_Dir_base::_At_path): New class.\n\t(_Dir_base::_Dir_Base, _Dir_base::openat): Use _At_path.\n\t* src/filesystem/dir.cc (_Dir::dir_and_pathname): Replace with\n\tcurrent() returning _At_path.\n\t(_Dir::_Dir, _Dir::open_subdir): Adjust.", "tree": {"sha": "ea71d88cfa12271bebe5437f606e0981dc0cdaa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea71d88cfa12271bebe5437f606e0981dc0cdaa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/198781144f33b0ef17dd2094580b5c77ad97d6e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198781144f33b0ef17dd2094580b5c77ad97d6e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/198781144f33b0ef17dd2094580b5c77ad97d6e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198781144f33b0ef17dd2094580b5c77ad97d6e8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "835b19936bf30d693783bfa39145a4ce243bbd7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/835b19936bf30d693783bfa39145a4ce243bbd7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/835b19936bf30d693783bfa39145a4ce243bbd7c"}], "stats": {"total": 116, "additions": 73, "deletions": 43}, "files": [{"sha": "2258399da258772913db0fb68d485e95c744837c", "filename": "libstdc++-v3/src/c++17/fs_dir.cc", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/198781144f33b0ef17dd2094580b5c77ad97d6e8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/198781144f33b0ef17dd2094580b5c77ad97d6e8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc?ref=198781144f33b0ef17dd2094580b5c77ad97d6e8", "patch": "@@ -46,7 +46,7 @@ struct fs::_Dir : _Dir_base\n {\n   _Dir(const fs::path& p, bool skip_permission_denied, bool nofollow,\n        [[maybe_unused]] bool filename_only, error_code& ec)\n-  : _Dir_base(fdcwd(), p.c_str(), skip_permission_denied, nofollow, ec)\n+  : _Dir_base(p.c_str(), skip_permission_denied, nofollow, ec)\n   {\n #if _GLIBCXX_HAVE_DIRFD && _GLIBCXX_HAVE_OPENAT && _GLIBCXX_HAVE_UNLINKAT\n     if (filename_only)\n@@ -117,27 +117,27 @@ struct fs::_Dir : _Dir_base\n     return false;\n   }\n \n-  // Return a file descriptor for the directory and current entry's path.\n-  // If dirfd is available, use it and return only the filename.\n-  // Otherwise, return AT_FDCWD and return the full path.\n-  pair<int, const posix::char_type*>\n-  dir_and_pathname() const noexcept\n+  // Return a pathname for the current directory entry, as an _At_path.\n+  _Dir_base::_At_path\n+  current() const noexcept\n   {\n     const fs::path& p = entry.path();\n-#if _GLIBCXX_HAVE_DIRFD && _GLIBCXX_HAVE_OPENAT\n-    if (!p.empty())\n-      return {::dirfd(this->dirp), std::prev(p.end())->c_str()};\n+#if _GLIBCXX_HAVE_DIRFD\n+    if (!p.empty()) [[__likely__]]\n+      {\n+\tauto len = std::prev(p.end())->native().size();\n+\treturn {::dirfd(this->dirp), p.c_str(), p.native().size() - len};\n+      }\n #endif\n-    return {this->fdcwd(), p.c_str()};\n+    return p.c_str();\n   }\n \n   // Create a new _Dir for the directory this->entry.path().\n   _Dir\n   open_subdir(bool skip_permission_denied, bool nofollow,\n \t      error_code& ec) const noexcept\n   {\n-    auto [dirfd, pathname] = dir_and_pathname();\n-    _Dir_base d(dirfd, pathname, skip_permission_denied, nofollow, ec);\n+    _Dir_base d(current(), skip_permission_denied, nofollow, ec);\n     // If this->path is empty, the new _Dir should have an empty path too.\n     const fs::path& p = this->path.empty() ? this->path : this->entry.path();\n     return _Dir(std::move(d), p);\n@@ -147,8 +147,9 @@ struct fs::_Dir : _Dir_base\n   do_unlink(bool is_directory, error_code& ec) const noexcept\n   {\n #if _GLIBCXX_HAVE_UNLINKAT\n-    auto [dirfd, pathname] = dir_and_pathname();\n-    if (::unlinkat(dirfd, pathname, is_directory ? AT_REMOVEDIR : 0) == -1)\n+    const auto atp = current();\n+    if (::unlinkat(atp.dir(), atp.path_at_dir(),\n+\t\t   is_directory ? AT_REMOVEDIR : 0) == -1)\n       {\n \tec.assign(errno, std::generic_category());\n \treturn false;"}, {"sha": "4844b1ac4532667fd1a360e23435164e277c2d4c", "filename": "libstdc++-v3/src/filesystem/dir-common.h", "status": "modified", "additions": 48, "deletions": 18, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/198781144f33b0ef17dd2094580b5c77ad97d6e8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/198781144f33b0ef17dd2094580b5c77ad97d6e8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h?ref=198781144f33b0ef17dd2094580b5c77ad97d6e8", "patch": "@@ -25,6 +25,7 @@\n #ifndef _GLIBCXX_DIR_COMMON_H\n #define _GLIBCXX_DIR_COMMON_H 1\n \n+#include <stdint.h>  // uint32_t\n #include <string.h>  // strcmp\n #include <errno.h>\n #if _GLIBCXX_FILESYSTEM_IS_WINDOWS\n@@ -91,12 +92,50 @@ is_permission_denied_error(int e)\n \n struct _Dir_base\n {\n+  // As well as the full pathname (including the directory iterator's path)\n+  // this type contains a file descriptor for a directory and a second pathname\n+  // relative to that directory. The file descriptor and relative pathname\n+  // can be used with POSIX openat and unlinkat.\n+  struct _At_path\n+  {\n+    // No file descriptor given, so interpret the pathname relative to the CWD.\n+    _At_path(const char* p) noexcept\n+    : pathname(p), dir_fd(fdcwd()), offset(0)\n+    { }\n+\n+    _At_path(int fd, const char* p, size_t offset) noexcept\n+    : pathname(p), dir_fd(fd), offset(offset)\n+    { }\n+\n+    const char* path() const noexcept { return pathname; }\n+\n+    int dir() const noexcept { return dir_fd; }\n+    const char* path_at_dir() const noexcept { return pathname + offset; }\n+\n+  private:\n+    const posix::char_type* pathname; // Full path relative to CWD.\n+    int dir_fd; // A directory descriptor (either the parent dir, or AT_FDCWD).\n+    uint32_t offset; // Offset into pathname for the part relative to dir_fd.\n+\n+    // Special value representing the current working directory.\n+    // Not a valid file descriptor for an open directory stream.\n+    static constexpr int\n+    fdcwd() noexcept\n+    {\n+#ifdef AT_FDCWD\n+      return AT_FDCWD;\n+#else\n+      return -1; // Use invalid fd if AT_FDCWD isn't supported.\n+#endif\n+    }\n+  };\n+\n   // If no error occurs then dirp is non-null,\n   // otherwise null (even if a permission denied error is ignored).\n-  _Dir_base(int fd, const posix::char_type* pathname,\n+  _Dir_base(const _At_path& atp,\n \t    bool skip_permission_denied, bool nofollow,\n \t    error_code& ec) noexcept\n-  : dirp(_Dir_base::openat(fd, pathname, nofollow))\n+  : dirp(_Dir_base::openat(atp, nofollow))\n   {\n     if (dirp)\n       ec.clear();\n@@ -143,16 +182,6 @@ struct _Dir_base\n       }\n   }\n \n-  static constexpr int\n-  fdcwd() noexcept\n-  {\n-#ifdef AT_FDCWD\n-    return AT_FDCWD;\n-#else\n-    return -1; // Use invalid fd if AT_FDCWD isn't supported.\n-#endif\n-  }\n-\n   static bool is_dot_or_dotdot(const char* s) noexcept\n   { return !strcmp(s, \".\") || !strcmp(s, \"..\"); }\n \n@@ -174,7 +203,7 @@ struct _Dir_base\n   }\n \n   static posix::DIR*\n-  openat(int fd, const posix::char_type* pathname, bool nofollow)\n+  openat(const _At_path& atp, bool nofollow)\n   {\n #if _GLIBCXX_HAVE_FDOPENDIR && defined O_RDONLY && defined O_DIRECTORY \\\n     && ! _GLIBCXX_FILESYSTEM_IS_WINDOWS\n@@ -198,16 +227,17 @@ struct _Dir_base\n     nofollow = false;\n #endif\n \n+    int fd;\n \n-#if _GLIBCXX_HAVE_OPENAT && defined AT_FDCWD\n-    fd = ::openat(fd, pathname, flags);\n+#if _GLIBCXX_HAVE_OPENAT\n+    fd = ::openat(atp.dir(), atp.path_at_dir(), flags);\n #else\n     // If we cannot use openat, there's no benefit to using posix::open unless\n     // we will use O_NOFOLLOW, so just use the simpler posix::opendir.\n     if (!nofollow)\n-      return posix::opendir(pathname);\n+      return posix::opendir(atp.path());\n \n-    fd = ::open(pathname, flags);\n+    fd = ::open(atp.path(), flags);\n #endif\n \n     if (fd == -1)\n@@ -220,7 +250,7 @@ struct _Dir_base\n     errno = err;\n     return nullptr;\n #else\n-    return posix::opendir(pathname);\n+    return posix::opendir(atp.path());\n #endif\n   }\n "}, {"sha": "a66a6773580d82178f65e743971371ca519cb598", "filename": "libstdc++-v3/src/filesystem/dir.cc", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/198781144f33b0ef17dd2094580b5c77ad97d6e8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/198781144f33b0ef17dd2094580b5c77ad97d6e8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc?ref=198781144f33b0ef17dd2094580b5c77ad97d6e8", "patch": "@@ -53,7 +53,7 @@ struct fs::_Dir : std::filesystem::_Dir_base\n {\n   _Dir(const fs::path& p, bool skip_permission_denied, bool nofollow,\n        error_code& ec)\n-  : _Dir_base(this->fdcwd(), p.c_str(), skip_permission_denied, nofollow, ec)\n+  : _Dir_base(p.c_str(), skip_permission_denied, nofollow, ec)\n   {\n     if (!ec)\n       path = p;\n@@ -113,26 +113,25 @@ struct fs::_Dir : std::filesystem::_Dir_base\n     return false;\n   }\n \n-  // Return a file descriptor for the directory and current entry's path.\n-  // If dirfd is available, use it and return only the filename.\n-  // Otherwise, return AT_FDCWD and return the full path.\n-  pair<int, const posix::char_type*>\n-  dir_and_pathname() const noexcept\n+  // Return a pathname for the current directory entry, as an _At_path.\n+  _Dir_base::_At_path\n+  current() const noexcept\n   {\n     const fs::path& p = entry.path();\n-#if _GLIBCXX_HAVE_DIRFD && _GLIBCXX_HAVE_OPENAT\n-    return {::dirfd(this->dirp), std::prev(p.end())->c_str()};\n+#if _GLIBCXX_HAVE_DIRFD\n+    auto len = std::prev(p.end())->native().size();\n+    return {::dirfd(this->dirp), p.c_str(), p.native().size() - len};\n+#else\n+    return p.c_str();\n #endif\n-    return {this->fdcwd(), p.c_str()};\n   }\n \n   // Create a new _Dir for the directory this->entry.path().\n   _Dir\n   open_subdir(bool skip_permission_denied, bool nofollow,\n \t      error_code& ec) noexcept\n   {\n-    auto [dirfd, pathname] = dir_and_pathname();\n-    _Dir_base d(dirfd, pathname, skip_permission_denied, nofollow, ec);\n+    _Dir_base d(current(), skip_permission_denied, nofollow, ec);\n     return _Dir(std::move(d), entry.path());\n   }\n "}]}