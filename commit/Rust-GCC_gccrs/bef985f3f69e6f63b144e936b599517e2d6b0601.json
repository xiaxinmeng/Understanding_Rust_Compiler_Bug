{"sha": "bef985f3f69e6f63b144e936b599517e2d6b0601", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVmOTg1ZjNmNjllNmY2M2IxNDRlOTM2YjU5OTUxN2UyZDZiMDYwMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-11T12:37:19Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-11T12:37:19Z"}, "message": "cpphash.c (_cpp_destroy_hashtable): Use ht_destroy.\n\n\t* cpphash.c (_cpp_destroy_hashtable): Use ht_destroy.\n\t* cpphash.h (CPP_IN_SYSTEM_HEADER): Fix.\n\t(struct cpp_pool): New member first.\n\t* cppinit.c (append_include_chain): Plug memory leaks.\n\t* cpplib.c (cpp_register_pragma, cpp_register_pragma_space):\n\tAllocate pragma structures from the (aligned) macro pool to\n\tavoid leaking memory.\n\t* cpplex.c (_cpp_init_pool, _cpp_free_pool): Use pool->first\n\tso we don't leak memory.\n\t* hashtable.c (ht_destroy): New.\n\t* hashtable.h (ht_destroy): New.\n\nFrom-SVN: r44794", "tree": {"sha": "fcbebbbfda56236b89a255fb6864d9fcde8b6022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcbebbbfda56236b89a255fb6864d9fcde8b6022"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bef985f3f69e6f63b144e936b599517e2d6b0601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef985f3f69e6f63b144e936b599517e2d6b0601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef985f3f69e6f63b144e936b599517e2d6b0601", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef985f3f69e6f63b144e936b599517e2d6b0601/comments", "author": null, "committer": null, "parents": [{"sha": "4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429"}], "stats": {"total": 63, "additions": 51, "deletions": 12}, "files": [{"sha": "6214570295151abec0375ad4f82079687eea96d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -1,3 +1,17 @@\n+2001-08-11  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.c (_cpp_destroy_hashtable): Use ht_destroy.\n+\t* cpphash.h (CPP_IN_SYSTEM_HEADER): Fix.\n+\t(struct cpp_pool): New member first.\n+\t* cppinit.c (append_include_chain): Plug memory leaks.\n+\t* cpplib.c (cpp_register_pragma, cpp_register_pragma_space):\n+\tAllocate pragma structures from the (aligned) macro pool to\n+\tavoid leaking memory.\n+\t* cpplex.c (_cpp_init_pool, _cpp_free_pool): Use pool->first\n+\tso we don't leak memory.\n+\t* hashtable.c (ht_destroy): New.\n+\t* hashtable.h (ht_destroy): New.\n+\n 2001-08-11  Neil Booth  <neil@daikokuya.demon.co.uk>\n \t    Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n "}, {"sha": "def51715f43a0abadc5eb27c02686f5b864cc834", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -73,7 +73,7 @@ _cpp_destroy_hashtable (pfile)\n {\n   if (pfile->our_hashtable)\n     {\n-      free (pfile->hash_table);\n+      ht_destroy (pfile->hash_table);\n       obstack_free (&pfile->hash_ob, 0);\n     }\n }"}, {"sha": "27e221c6b58879786c29181b9f3a13c0f5c31fce", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -66,7 +66,7 @@ struct cpp_chunk\n typedef struct cpp_pool cpp_pool;\n struct cpp_pool\n {\n-  struct cpp_chunk *cur, *locked;\n+  struct cpp_chunk *cur, *locked, *first;\n   unsigned char *pos;\t\t/* Current position.  */\n   unsigned int align;\n   unsigned int locks;\n@@ -368,7 +368,7 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n /* Macros.  */\n \n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n-#define CPP_IN_SYSTEM_HEADER(PFILE) (pfile->map && pfile->map->sysp)\n+#define CPP_IN_SYSTEM_HEADER(PFILE) ((PFILE)->map && (PFILE)->map->sysp)\n #define CPP_PEDANTIC(PF) CPP_OPTION (PF, pedantic)\n #define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n "}, {"sha": "63bcfdd3735b5feb9a8c26611a81679c751321e2", "filename": "gcc/cppinit.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -197,8 +197,8 @@ path_include (pfile, list, path)\n   while (1);\n }\n \n-/* Append DIR to include path PATH.  DIR must be permanently allocated\n-   and writable.  */\n+/* Append DIR to include path PATH.  DIR must be allocated on the\n+   heap; this routine takes responsibility for freeing it.  */\n static void\n append_include_chain (pfile, dir, path, cxx_aware)\n      cpp_reader *pfile;\n@@ -212,21 +212,27 @@ append_include_chain (pfile, dir, path, cxx_aware)\n   unsigned int len;\n \n   if (*dir == '\\0')\n-    dir = xstrdup (\".\");\n+    {\n+      free (dir);\n+      dir = xstrdup (\".\");\n+    }\n   _cpp_simplify_pathname (dir);\n+\n   if (stat (dir, &st))\n     {\n       /* Dirs that don't exist are silently ignored.  */\n       if (errno != ENOENT)\n \tcpp_notice_from_errno (pfile, dir);\n       else if (CPP_OPTION (pfile, verbose))\n \tfprintf (stderr, _(\"ignoring nonexistent directory \\\"%s\\\"\\n\"), dir);\n+      free (dir);\n       return;\n     }\n \n   if (!S_ISDIR (st.st_mode))\n     {\n       cpp_notice (pfile, \"%s: Not a directory\", dir);\n+      free (dir);\n       return;\n     }\n \n@@ -375,7 +381,7 @@ merge_include_chains (pfile)\n \tbrack = remove_dup_dir (pfile, qtail);\n     }\n   else\n-      quote = brack;\n+    quote = brack;\n \n   CPP_OPTION (pfile, quote_include) = quote;\n   CPP_OPTION (pfile, bracket_include) = brack;"}, {"sha": "9446aae592e1f2f46f68e78cbd147e2154f6b535", "filename": "gcc/cpplex.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -2109,7 +2109,8 @@ _cpp_init_pool (pool, size, align, temp)\n   if (align & (align - 1))\n     abort ();\n   pool->align = align;\n-  pool->cur = new_chunk (size);\n+  pool->first = new_chunk (size);\n+  pool->cur = pool->first;\n   pool->locked = 0;\n   pool->locks = 0;\n   if (temp)\n@@ -2136,15 +2137,15 @@ void\n _cpp_free_pool (pool)\n      cpp_pool *pool;\n {\n-  cpp_chunk *chunk = pool->cur, *next;\n+  cpp_chunk *chunk = pool->first, *next;\n \n   do\n     {\n       next = chunk->next;\n       free (chunk->base);\n       chunk = next;\n     }\n-  while (chunk && chunk != pool->cur);\n+  while (chunk && chunk != pool->first);\n }\n \n /* Reserve LEN bytes from a memory pool.  */"}, {"sha": "9404a00ea8e8668c173ec3919b4338625c2551cc", "filename": "gcc/cpplib.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -901,7 +901,8 @@ cpp_register_pragma (pfile, space, name, handler)\n     }\n \n  found:\n-  new = xnew (struct pragma_entry);\n+  new = (struct pragma_entry *)\n+    _cpp_pool_alloc (&pfile->macro_pool, sizeof (struct pragma_entry));\n   new->name = name;\n   new->len = strlen (name);\n   new->isnspace = 0;\n@@ -929,7 +930,8 @@ cpp_register_pragma_space (pfile, space)\n       p = p->next;\n     }\n \n-  new = xnew (struct pragma_entry);\n+  new = (struct pragma_entry *)\n+    _cpp_pool_alloc (&pfile->macro_pool, sizeof (struct pragma_entry));\n   new->name = space;\n   new->len = len;\n   new->isnspace = 1;"}, {"sha": "7d0359a2c613b5e3636962bdc38a7be293858192", "filename": "gcc/hashtable.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fhashtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fhashtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.c?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -94,6 +94,17 @@ ht_create (order)\n   return table;\n }\n \n+/* Frees all memory associated with a hash table.  */\n+\n+void\n+ht_destroy (table)\n+     hash_table *table;\n+{\n+  obstack_free (&table->stack, NULL);\n+  free (table->entries);\n+  free (table);\n+}\n+\n /* Returns the hash entry for the a STR of length LEN.  If that string\n    already exists in the table, returns the existing entry, and, if\n    INSERT is CPP_ALLOCED, frees the last obstack object.  If the"}, {"sha": "cd6c7f0be06284832a9e4b097f60b4feeec3d304", "filename": "gcc/hashtable.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef985f3f69e6f63b144e936b599517e2d6b0601/gcc%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.h?ref=bef985f3f69e6f63b144e936b599517e2d6b0601", "patch": "@@ -64,8 +64,13 @@ struct ht\n };\n \n extern void gcc_obstack_init PARAMS ((struct obstack *));\n+\n /* Initialise the hashtable with 2 ^ order entries.  */\n extern hash_table *ht_create PARAMS ((unsigned int order));\n+\n+/* Frees all memory associated with a hash table.  */\n+extern void ht_destroy PARAMS ((hash_table *));\n+\n extern hashnode ht_lookup PARAMS ((hash_table *, const unsigned char *,\n \t\t\t\t   unsigned int, enum ht_lookup_option));\n "}]}