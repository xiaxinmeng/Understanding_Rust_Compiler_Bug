{"sha": "ae04227b3a167158edfdd67ffd0a80fd2ca23453", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUwNDIyN2IzYTE2NzE1OGVkZmRkNjdmZmQwYTgwZmQyY2EyMzQ1Mw==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-08T03:40:47Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-08T03:40:47Z"}, "message": "entered into RCS\n\nFrom-SVN: r1511", "tree": {"sha": "e01b20fcc854a4fd4ab5758989e8cb6bed66bf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e01b20fcc854a4fd4ab5758989e8cb6bed66bf36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae04227b3a167158edfdd67ffd0a80fd2ca23453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae04227b3a167158edfdd67ffd0a80fd2ca23453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae04227b3a167158edfdd67ffd0a80fd2ca23453", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae04227b3a167158edfdd67ffd0a80fd2ca23453/comments", "author": null, "committer": null, "parents": [{"sha": "eaec9d17fd6a19c0a3d4f328cbe94e8092e42bdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec9d17fd6a19c0a3d4f328cbe94e8092e42bdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaec9d17fd6a19c0a3d4f328cbe94e8092e42bdd"}], "stats": {"total": 58, "additions": 54, "deletions": 4}, "files": [{"sha": "020d95658d3756d9f8cc2c3418091633b6d86630", "filename": "gcc/gcc.c", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae04227b3a167158edfdd67ffd0a80fd2ca23453/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae04227b3a167158edfdd67ffd0a80fd2ca23453/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=ae04227b3a167158edfdd67ffd0a80fd2ca23453", "patch": "@@ -813,6 +813,7 @@ struct prefix_list\n   char *prefix;               /* String to prepend to the path. */\n   struct prefix_list *next;   /* Next in linked list. */\n   int require_machine_suffix; /* Don't use without machine_suffix.  */\n+  /* 2 means try both machine_suffix and just_machine_suffix.  */\n   int *used_flag_ptr;\t      /* 1 if a file was found with this prefix.  */\n };\n \n@@ -835,10 +836,16 @@ static struct path_prefix startfile_prefix = { 0, 0, \"startfile\" };\n \n static struct path_prefix library_prefix = { 0, 0, \"libraryfile\" };\n \n-/* Suffix to attach to directories searched for commands.  */\n+/* Suffix to attach to directories searched for commands.\n+   This looks like `MACHINE/VERSION/'.  */\n \n static char *machine_suffix = 0;\n \n+/* Suffix to attach to directories searched for commands.\n+   This is just `MACHINE/'.  */\n+\n+static char *just_machine_suffix = 0;\n+\n /* Adjusted value of GCC_EXEC_PREFIX envvar.  */\n \n static char *gcc_exec_prefix;\n@@ -1164,6 +1171,16 @@ putenv_from_prefixes (paths, env_var)\n \t  obstack_grow (&collect_obstack, machine_suffix, suffix_len);\n \t}\n \n+      if (just_machine_suffix && pprefix->require_machine_suffix == 2)\n+\t{\n+\t  if (!first_time)\n+\t    obstack_grow (&collect_obstack, \":\", 1);\n+\t    \n+\t  first_time = FALSE;\n+\t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n+\t  obstack_grow (&collect_obstack, machine_suffix, suffix_len);\n+\t}\n+\n       if (!pprefix->require_machine_suffix)\n \t{\n \t  if (!first_time)\n@@ -1235,6 +1252,32 @@ find_a_file (pprefix, name, mode)\n \t\t  }\n \t      }\n \t  }\n+\t/* Certain prefixes are tried with just the machine type,\n+\t   not the version.  This is used for finding as, ld, etc.  */\n+\tif (just_machine_suffix && pl->require_machine_suffix == 2)\n+\t  {\n+\t    strcpy (temp, pl->prefix);\n+\t    strcat (temp, just_machine_suffix);\n+\t    strcat (temp, name);\n+\t    if (access (temp, mode) == 0)\n+\t      {\n+\t\tif (pl->used_flag_ptr != 0)\n+\t\t  *pl->used_flag_ptr = 1;\n+\t\treturn temp;\n+\t      }\n+\t    /* Some systems have a suffix for executable files.\n+\t       So try appending that.  */\n+\t    if (file_suffix[0] != 0)\n+\t      {\n+\t\tstrcat (temp, file_suffix);\n+\t\tif (access (temp, mode) == 0)\n+\t\t  {\n+\t\t    if (pl->used_flag_ptr != 0)\n+\t\t      *pl->used_flag_ptr = 1;\n+\t\t    return temp;\n+\t\t  }\n+\t      }\n+\t  }\n \t/* Certain prefixes can't be used without the machine suffix\n \t   when the machine or version is explicitly specified.  */\n \tif (!pl->require_machine_suffix)\n@@ -1271,7 +1314,11 @@ find_a_file (pprefix, name, mode)\n \n    If WARN is nonzero, we will warn if no file is found\n    through this prefix.  WARN should point to an int\n-   which will be set to 1 if this entry is used.  */\n+   which will be set to 1 if this entry is used.\n+\n+   REQUIRE_MACHINE_SUFFIX is 1 if this prefix can't be used without\n+   the complete value of machine_suffix.\n+   2 means try both machine_suffix and just_machine_suffix.  */\n \n static void\n add_prefix (pprefix, prefix, first, require_machine_suffix, warn)\n@@ -1955,8 +2002,10 @@ process_command (argc, argv)\n \n   /* These come before the md prefixes so that we will find gcc's subcommands\n      (such as cpp) rather than those of the host system.  */\n-  add_prefix (&exec_prefix, standard_exec_prefix, 0, 1, NULL_PTR);\n-  add_prefix (&exec_prefix, standard_exec_prefix_1, 0, 1, NULL_PTR);\n+  /* Use 2 as fourth arg meaning try just the machine as a suffix,\n+     as well as trying the machine and the version.  */\n+  add_prefix (&exec_prefix, standard_exec_prefix, 0, 2, NULL_PTR);\n+  add_prefix (&exec_prefix, standard_exec_prefix_1, 0, 2, NULL_PTR);\n \n   add_prefix (&startfile_prefix, standard_exec_prefix, 0, 1, NULL_PTR);\n   add_prefix (&startfile_prefix, standard_exec_prefix_1, 0, 1, NULL_PTR);\n@@ -3067,6 +3116,7 @@ main (argc, argv)\n   /* Read specs from a file if there is one.  */\n \n   machine_suffix = concat (spec_machine, \"/\", concat (spec_version, \"/\", \"\"));\n+  just_machine_suffix = concat (spec_machine, \"/\", \"\");\n \n   specs_file = find_a_file (&startfile_prefix, \"specs\", R_OK);\n   /* Read the specs file unless it is a default one.  */"}]}