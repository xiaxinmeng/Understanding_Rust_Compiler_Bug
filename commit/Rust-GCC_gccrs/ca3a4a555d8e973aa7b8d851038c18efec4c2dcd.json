{"sha": "ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzYTRhNTU1ZDhlOTczYWE3YjhkODUxMDM4YzE4ZWZlYzRjMmRjZA==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2018-04-07T10:52:19Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-04-07T10:52:19Z"}, "message": "[NDS32] Support dwarf exception handling.\n\ngcc/\n\t* config/nds32/constants.md (unspec_volatile_element): Add\n\tUNSPEC_VOLATILE_EH_RETURN.\n\t* config/nds32/nds32-md-auxiliary.c (nds32_output_stack_push,\n\tnds32_output_stack_pop): Support dwarf exception handling process.\n\t* config/nds32/nds32-protos.h (nds32_dynamic_chain_address): Declare.\n\t* config/nds32/nds32.c (nds32_init_machine_status): Support dwarf\n\texception handling process.\n\t(nds32_compute_stack_frame): Likewise.\n\t(nds32_return_addr_rtx): Likewise.\n\t(nds32_initial_elimination_offset): Likewise.\n\t(nds32_expand_prologue): Likewise.\n\t(nds32_expand_epilogue): Likewise.\n\t(nds32_dynamic_chain_address): New function.\n\t* config/nds32/nds32.h (machine_function): Add fields for dwarf\n\texception handling.\n\t(DYNAMIC_CHAIN_ADDRESS): Define.\n\t(EH_RETURN_DATA_REGNO): Define.\n\t(EH_RETURN_STACKADJ_RTX): Define.\n\t* config/nds32/nds32.md (eh_return, nds32_eh_return): Implement\n\tpatterns for dwarf exception handling.\n\nFrom-SVN: r259210", "tree": {"sha": "4dcb66b834f503e2bd784139d1850f1ce6fc3c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dcb66b834f503e2bd784139d1850f1ce6fc3c40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30044989cc76c1cca7a7967f29bed07d909faf9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30044989cc76c1cca7a7967f29bed07d909faf9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30044989cc76c1cca7a7967f29bed07d909faf9e"}], "stats": {"total": 289, "additions": 280, "deletions": 9}, "files": [{"sha": "2c44527ad1d35a58f41166dadcde53642941fcc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "patch": "@@ -1,3 +1,26 @@\n+2018-04-07  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/constants.md (unspec_volatile_element): Add\n+\tUNSPEC_VOLATILE_EH_RETURN.\n+\t* config/nds32/nds32-md-auxiliary.c (nds32_output_stack_push,\n+\tnds32_output_stack_pop): Support dwarf exception handling process.\n+\t* config/nds32/nds32-protos.h (nds32_dynamic_chain_address): Declare.\n+\t* config/nds32/nds32.c (nds32_init_machine_status): Support dwarf\n+\texception handling process.\n+\t(nds32_compute_stack_frame): Likewise.\n+\t(nds32_return_addr_rtx): Likewise.\n+\t(nds32_initial_elimination_offset): Likewise.\n+\t(nds32_expand_prologue): Likewise.\n+\t(nds32_expand_epilogue): Likewise.\n+\t(nds32_dynamic_chain_address): New function.\n+\t* config/nds32/nds32.h (machine_function): Add fields for dwarf\n+\texception handling.\n+\t(DYNAMIC_CHAIN_ADDRESS): Define.\n+\t(EH_RETURN_DATA_REGNO): Define.\n+\t(EH_RETURN_STACKADJ_RTX): Define.\n+\t* config/nds32/nds32.md (eh_return, nds32_eh_return): Implement\n+\tpatterns for dwarf exception handling.\n+\n 2018-04-07  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32.h: Clean up obsolete macros."}, {"sha": "a9593f7894c7e49fd614c2e66a78be1756eab79b", "filename": "gcc/config/nds32/constants.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fconstants.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fconstants.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstants.md?ref=ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "patch": "@@ -66,6 +66,7 @@\n \n ;; The unspec_volatile operation index.\n (define_c_enum \"unspec_volatile_element\" [\n+  UNSPEC_VOLATILE_EH_RETURN\n   UNSPEC_VOLATILE_ISYNC\n   UNSPEC_VOLATILE_ISB\n   UNSPEC_VOLATILE_DSB"}, {"sha": "95bd82969abb860fe7b19aa3dad4fa37fe6929ed", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "patch": "@@ -1712,6 +1712,10 @@ nds32_output_stack_push (rtx par_rtx)\n   int last_argument_regno = NDS32_FIRST_GPR_REGNUM\n \t\t\t    + NDS32_MAX_GPR_REGS_FOR_ARGS\n \t\t\t    - 1;\n+  /* Pick up first and last eh data regno for further use.  */\n+  int rb_eh_data = cfun->machine->eh_return_data_first_regno;\n+  int re_eh_data = cfun->machine->eh_return_data_last_regno;\n+  int first_eh_data_regno = EH_RETURN_DATA_REGNO (0);\n   /* Pick up callee-saved first regno and last regno for further use.  */\n   int rb_callee_saved = cfun->machine->callee_saved_first_gpr_regno;\n   int re_callee_saved = cfun->machine->callee_saved_last_gpr_regno;\n@@ -1731,6 +1735,22 @@ nds32_output_stack_push (rtx par_rtx)\n       return \"\";\n     }\n \n+  /* If last_argument_regno is not mentioned in par_rtx, we can confirm that\n+     we do not need to push argument registers for variadic function.\n+     But we still need to check if we need to push exception handling\n+     data registers.  */\n+  if (reg_mentioned_p (gen_rtx_REG (SImode, first_eh_data_regno), par_rtx))\n+    {\n+      /* Set operands[0] and operands[1].  */\n+      operands[0] = gen_rtx_REG (SImode, rb_eh_data);\n+      operands[1] = gen_rtx_REG (SImode, re_eh_data);\n+      /* Create assembly code pattern: \"Rb, Re, { }\".  */\n+      snprintf (pattern, sizeof (pattern), \"push.s\\t%s\", \"%0, %1, { }\");\n+      /* We use output_asm_insn() to output assembly code by ourself.  */\n+      output_asm_insn (pattern, operands);\n+      return \"\";\n+    }\n+\n   /* If we step here, we are going to do v3push or multiple push operation.  */\n \n   /* The v3push/v3pop instruction should only be applied on\n@@ -1833,10 +1853,28 @@ nds32_output_stack_pop (rtx par_rtx ATTRIBUTE_UNUSED)\n   char pattern[100];\n   /* The operands array which will be used in output_asm_insn().  */\n   rtx operands[3];\n+  /* Pick up first and last eh data regno for further use.  */\n+  int rb_eh_data = cfun->machine->eh_return_data_first_regno;\n+  int re_eh_data = cfun->machine->eh_return_data_last_regno;\n+  int first_eh_data_regno = EH_RETURN_DATA_REGNO (0);\n   /* Pick up callee-saved first regno and last regno for further use.  */\n   int rb_callee_saved = cfun->machine->callee_saved_first_gpr_regno;\n   int re_callee_saved = cfun->machine->callee_saved_last_gpr_regno;\n \n+  /* We need to check if we need to push exception handling\n+     data registers.  */\n+  if (reg_mentioned_p (gen_rtx_REG (SImode, first_eh_data_regno), par_rtx))\n+    {\n+      /* Set operands[0] and operands[1].  */\n+      operands[0] = gen_rtx_REG (SImode, rb_eh_data);\n+      operands[1] = gen_rtx_REG (SImode, re_eh_data);\n+      /* Create assembly code pattern: \"Rb, Re, { }\".  */\n+      snprintf (pattern, sizeof (pattern), \"pop.s\\t%s\", \"%0, %1, { }\");\n+      /* We use output_asm_insn() to output assembly code by ourself.  */\n+      output_asm_insn (pattern, operands);\n+      return \"\";\n+    }\n+\n   /* If we step here, we are going to do v3pop or multiple pop operation.  */\n \n   /* The v3push/v3pop instruction should only be applied on"}, {"sha": "2f077005b067827edb9c673e03cbbe542eea50cc", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "patch": "@@ -40,6 +40,7 @@ extern enum reg_class nds32_regno_reg_class (int);\n \n /* -- Basic Stack Layout.  */\n \n+extern rtx nds32_dynamic_chain_address (rtx);\n extern rtx nds32_return_addr_rtx (int, rtx);\n \n /* -- Eliminating Frame Pointer and Arg Pointer.  */"}, {"sha": "0ad0e85887697b12d395949d4b1c48482a273ce8", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 131, "deletions": 9, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "patch": "@@ -323,6 +323,9 @@ nds32_init_machine_status (void)\n   struct machine_function *machine;\n   machine = ggc_cleared_alloc<machine_function> ();\n \n+  /* Initially assume this function does not use __builtin_eh_return.  */\n+  machine->use_eh_return_p = 0;\n+\n   /* Initially assume this function needs prologue/epilogue.  */\n   machine->naked_p = 0;\n \n@@ -346,6 +349,36 @@ nds32_compute_stack_frame (void)\n      needs prologue/epilogue.  */\n   cfun->machine->naked_p = 0;\n \n+\n+  /* If __builtin_eh_return is used, we better have frame pointer needed\n+     so that we can easily locate the stack slot of return address.  */\n+  if (crtl->calls_eh_return)\n+    {\n+      frame_pointer_needed = 1;\n+\n+      /* We need to mark eh data registers that need to be saved\n+\t in the stack.  */\n+      cfun->machine->eh_return_data_first_regno = EH_RETURN_DATA_REGNO (0);\n+      for (r = 0; EH_RETURN_DATA_REGNO (r) != INVALID_REGNUM; r++)\n+\tcfun->machine->eh_return_data_last_regno = r;\n+\n+      cfun->machine->eh_return_data_regs_size\n+\t= 4 * (cfun->machine->eh_return_data_last_regno\n+\t       - cfun->machine->eh_return_data_first_regno\n+\t       + 1);\n+      cfun->machine->use_eh_return_p = 1;\n+    }\n+  else\n+    {\n+      /* Assigning SP_REGNUM to eh_first_regno and eh_last_regno means we\n+\t do not need to handle __builtin_eh_return case in this function.  */\n+      cfun->machine->eh_return_data_first_regno = SP_REGNUM;\n+      cfun->machine->eh_return_data_last_regno  = SP_REGNUM;\n+\n+      cfun->machine->eh_return_data_regs_size = 0;\n+      cfun->machine->use_eh_return_p = 0;\n+    }\n+\n   /* Get variadic arguments size to prepare pretend arguments and\n      we will push them into stack at prologue by ourself.  */\n   cfun->machine->va_args_size = crtl->args.pretend_args_size;\n@@ -3816,15 +3849,40 @@ nds32_regno_reg_class (int regno)\n \n /* -- Basic Stack Layout.  */\n \n+rtx\n+nds32_dynamic_chain_address (rtx frameaddr)\n+{\n+  if (TARGET_V3PUSH)\n+    {\n+      /* If -mv3push is specified, we push $fp, $gp, and $lp into stack.\n+         We can access dynamic chain address from stack by [$fp - 12].  */\n+      return plus_constant (Pmode, frameaddr, -12);\n+    }\n+  else\n+    {\n+      /* For general case we push $fp and $lp into stack at prologue.\n+         We can access dynamic chain address from stack by [$fp - 8].  */\n+      return plus_constant (Pmode, frameaddr, -8);\n+    }\n+}\n+\n rtx\n nds32_return_addr_rtx (int count,\n-\t\t       rtx frameaddr ATTRIBUTE_UNUSED)\n+\t\t       rtx frameaddr)\n {\n-  /* There is no way to determine the return address\n-     if frameaddr is the frame that has 'count' steps\n-     up from current frame.  */\n+  int offset;\n+  rtx addr;\n+\n   if (count != 0)\n-    return NULL_RTX;\n+    {\n+      /* In nds32 ABI design, we can expect that $lp is always available\n+         from stack by [$fp - 4] location.  */\n+      offset = -4;\n+      addr = plus_constant (Pmode, frameaddr, offset);\n+      addr = memory_address (Pmode, addr);\n+\n+      return gen_rtx_MEM (Pmode, addr);\n+    }\n \n   /* If count == 0, it means we are at current frame,\n      the return address is $r30 ($lp).  */\n@@ -3843,7 +3901,8 @@ nds32_initial_elimination_offset (unsigned int from_reg, unsigned int to_reg)\n   nds32_compute_stack_frame ();\n \n   /* Remember to consider\n-     cfun->machine->callee_saved_area_gpr_padding_bytes\n+     cfun->machine->callee_saved_area_gpr_padding_bytes and\n+     cfun->machine->eh_return_data_regs_size\n      when calculating offset.  */\n   if (from_reg == ARG_POINTER_REGNUM && to_reg == STACK_POINTER_REGNUM)\n     {\n@@ -3853,6 +3912,7 @@ nds32_initial_elimination_offset (unsigned int from_reg, unsigned int to_reg)\n \t\t+ cfun->machine->callee_saved_gpr_regs_size\n \t\t+ cfun->machine->callee_saved_area_gpr_padding_bytes\n \t\t+ cfun->machine->callee_saved_fpr_regs_size\n+\t\t+ cfun->machine->eh_return_data_regs_size\n \t\t+ cfun->machine->local_size\n \t\t+ cfun->machine->out_args_size);\n     }\n@@ -3874,7 +3934,8 @@ nds32_initial_elimination_offset (unsigned int from_reg, unsigned int to_reg)\n \t\t       + cfun->machine->lp_size\n \t\t       + cfun->machine->callee_saved_gpr_regs_size\n \t\t       + cfun->machine->callee_saved_area_gpr_padding_bytes\n-\t\t       + cfun->machine->callee_saved_fpr_regs_size);\n+\t\t       + cfun->machine->callee_saved_fpr_regs_size\n+\t\t       + cfun->machine->eh_return_data_regs_size);\n     }\n   else\n     {\n@@ -3960,20 +4021,33 @@ nds32_expand_prologue (void)\n \tfalse);\n     }\n \n+  /* Save eh data registers.  */\n+  if (cfun->machine->use_eh_return_p)\n+    {\n+      Rb = cfun->machine->eh_return_data_first_regno;\n+      Re = cfun->machine->eh_return_data_last_regno;\n+\n+      /* No need to push $fp, $gp, or $lp.\n+\t Also, this is not variadic arguments push.  */\n+      nds32_emit_stack_push_multiple (Rb, Re, false, false, false, false);\n+    }\n+\n   /* Check frame_pointer_needed to see\n      if we shall emit fp adjustment instruction.  */\n   if (frame_pointer_needed)\n     {\n       /* adjust $fp = $sp + ($fp size) + ($gp size) + ($lp size)\n \t\t\t  + (4 * callee-saved-registers)\n+\t\t\t  + (4 * exception-handling-data-registers)\n \t Note: No need to adjust\n \t       cfun->machine->callee_saved_area_gpr_padding_bytes,\n \t       because, at this point, stack pointer is just\n \t       at the position after push instruction.  */\n       fp_adjust = cfun->machine->fp_size\n \t\t  + cfun->machine->gp_size\n \t\t  + cfun->machine->lp_size\n-\t\t  + cfun->machine->callee_saved_gpr_regs_size;\n+\t\t  + cfun->machine->callee_saved_gpr_regs_size\n+\t\t  + cfun->machine->eh_return_data_regs_size;\n \n       nds32_emit_adjust_frame (hard_frame_pointer_rtx,\n \t\t\t       stack_pointer_rtx,\n@@ -4122,6 +4196,7 @@ nds32_expand_epilogue (bool sibcall_p)\n \t\t      + cfun->machine->gp_size\n \t\t      + cfun->machine->lp_size\n \t\t      + cfun->machine->callee_saved_gpr_regs_size\n+\t\t      + cfun->machine->eh_return_data_regs_size\n \t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes\n \t\t      + cfun->machine->callee_saved_fpr_regs_size;\n \n@@ -4145,7 +4220,8 @@ nds32_expand_epilogue (bool sibcall_p)\n \t  sp_adjust = cfun->machine->fp_size\n \t\t      + cfun->machine->gp_size\n \t\t      + cfun->machine->lp_size\n-\t\t      + cfun->machine->callee_saved_gpr_regs_size;\n+\t\t      + cfun->machine->callee_saved_gpr_regs_size\n+\t\t      + cfun->machine->eh_return_data_regs_size;\n \n \t  nds32_emit_adjust_frame (stack_pointer_rtx,\n \t\t\t\t   hard_frame_pointer_rtx,\n@@ -4193,6 +4269,16 @@ nds32_expand_epilogue (bool sibcall_p)\n \t}\n     }\n \n+  /* Restore eh data registers.  */\n+  if (cfun->machine->use_eh_return_p)\n+    {\n+      Rb = cfun->machine->eh_return_data_first_regno;\n+      Re = cfun->machine->eh_return_data_last_regno;\n+\n+      /* No need to pop $fp, $gp, or $lp.  */\n+      nds32_emit_stack_pop_multiple (Rb, Re, false, false, false);\n+    }\n+\n   /* Get callee_first_regno and callee_last_regno.  */\n   Rb = cfun->machine->callee_saved_first_gpr_regno;\n   Re = cfun->machine->callee_saved_last_gpr_regno;\n@@ -4226,6 +4312,42 @@ nds32_expand_epilogue (bool sibcall_p)\n \t\t\t       sp_adjust);\n     }\n \n+  /* If this function uses __builtin_eh_return, make stack adjustment\n+     for exception handler.  */\n+  if (cfun->machine->use_eh_return_p)\n+    {\n+      /* We need to unwind the stack by the offset computed by\n+\t EH_RETURN_STACKADJ_RTX.  However, at this point the CFA is\n+\t based on SP.  Ideally we would update the SP and define the\n+\t CFA along the lines of:\n+\n+\t SP = SP + EH_RETURN_STACKADJ_RTX\n+\t (regnote CFA = SP - EH_RETURN_STACKADJ_RTX)\n+\n+\t However the dwarf emitter only understands a constant\n+\t register offset.\n+\n+\t The solution chosen here is to use the otherwise $ta ($r15)\n+\t as a temporary register to hold the current SP value.  The\n+\t CFA is described using $ta then SP is modified.  */\n+\n+      rtx ta_reg;\n+      rtx insn;\n+\n+      ta_reg = gen_rtx_REG (SImode, TA_REGNUM);\n+\n+      insn = emit_move_insn (ta_reg, stack_pointer_rtx);\n+      add_reg_note (insn, REG_CFA_DEF_CFA, ta_reg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t     stack_pointer_rtx,\n+\t\t\t     EH_RETURN_STACKADJ_RTX));\n+\n+      /* Ensure the assignment to $ta does not get optimized away.  */\n+      emit_use (ta_reg);\n+    }\n+\n   /* Generate return instruction.  */\n   if (!sibcall_p)\n     emit_jump_insn (gen_return_internal ());"}, {"sha": "3bb5a72089601d13d9c2fcdfc20b68b8d54760e7", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "patch": "@@ -274,6 +274,17 @@ struct GTY(()) machine_function\n   /* The last required register that should be saved on stack for va_args.  */\n   int va_args_last_regno;\n \n+  /* Number of bytes on the stack for saving exception handling registers.  */\n+  int eh_return_data_regs_size;\n+  /* The first register of passing exception handling information.  */\n+  int eh_return_data_first_regno;\n+  /* The last register of passing exception handling information.  */\n+  int eh_return_data_last_regno;\n+\n+  /* Indicate that whether this function\n+     calls __builtin_eh_return.  */\n+  int use_eh_return_p;\n+\n   /* Indicate that whether this function needs\n      prologue/epilogue code generation.  */\n   int naked_p;\n@@ -888,6 +899,11 @@ enum reg_class\n #define FIRST_PARM_OFFSET(fundecl) \\\n   (NDS32_DOUBLE_WORD_ALIGN_P (crtl->args.pretend_args_size) ? 0 : 4)\n \n+/* A C expression whose value is RTL representing the address in a stack frame\n+   where the pointer to the caller's frame is stored.  */\n+#define DYNAMIC_CHAIN_ADDRESS(frameaddr) \\\n+  nds32_dynamic_chain_address (frameaddr)\n+\n #define RETURN_ADDR_RTX(count, frameaddr) \\\n   nds32_return_addr_rtx (count, frameaddr)\n \n@@ -899,6 +915,13 @@ enum reg_class\n #define INCOMING_RETURN_ADDR_RTX    gen_rtx_REG (Pmode, LP_REGNUM)\n #define DWARF_FRAME_RETURN_COLUMN   DWARF_FRAME_REGNUM (LP_REGNUM)\n \n+/* Use $r0 $r1 to pass exception handling information.  */\n+#define EH_RETURN_DATA_REGNO(N) (((N) < 2) ? (N) : INVALID_REGNUM)\n+/* The register $r2 that represents a location in which to store a stack\n+   adjustment to be applied before function return.\n+   This is used to unwind the stack to an exception handler's call frame.  */\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, 2)\n+\n #define DBX_REGISTER_NUMBER(REGNO) nds32_dbx_register_number (REGNO)\n \n #define STACK_POINTER_REGNUM SP_REGNUM"}, {"sha": "9e3e20a52fa1b0aa0030efe00278d921994a14ee", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a4a555d8e973aa7b8d851038c18efec4c2dcd/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=ca3a4a555d8e973aa7b8d851038c18efec4c2dcd", "patch": "@@ -1967,3 +1967,66 @@\n )\n \n ;; ----------------------------------------------------------------------------\n+\n+;; Patterns for exception handling\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\"))]\n+  \"\"\n+{\n+  emit_insn (gen_nds32_eh_return (operands[0]));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"nds32_eh_return\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")] UNSPEC_VOLATILE_EH_RETURN)]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx place;\n+  rtx addr;\n+\n+  /* The operands[0] is the handler address.  We need to assign it\n+     to return address rtx so that we can jump to exception handler\n+     when returning from current function.  */\n+\n+  if (cfun->machine->lp_size == 0)\n+    {\n+      /* If $lp is not saved in the stack frame, we can take $lp directly.  */\n+      place = gen_rtx_REG (SImode, LP_REGNUM);\n+    }\n+  else\n+    {\n+      /* Otherwise, we need to locate the stack slot of return address.\n+\t The return address is generally saved in [$fp-4] location.\n+\t However, DSE (dead store elimination) does not detect an alias\n+\t between [$fp-x] and [$sp+y].  This can result in a store to save\n+\t $lp introduced by builtin_eh_return() being incorrectly deleted\n+\t if it is based on $fp.  The solution we take here is to compute\n+\t the offset relative to stack pointer and then use $sp to access\n+\t location so that the alias can be detected.\n+\t FIXME: What if the immediate value \"offset\" is too large to be\n+\t        fit in a single addi instruction?  */\n+      HOST_WIDE_INT offset;\n+\n+      offset = (cfun->machine->fp_size\n+\t\t+ cfun->machine->gp_size\n+\t\t+ cfun->machine->lp_size\n+\t\t+ cfun->machine->callee_saved_gpr_regs_size\n+\t\t+ cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t+ cfun->machine->callee_saved_fpr_regs_size\n+\t\t+ cfun->machine->eh_return_data_regs_size\n+\t\t+ cfun->machine->local_size\n+\t\t+ cfun->machine->out_args_size);\n+\n+      addr = plus_constant (Pmode, stack_pointer_rtx, offset - 4);\n+      place = gen_frame_mem (SImode, addr);\n+    }\n+\n+  emit_move_insn (place, operands[0]);\n+  DONE;\n+})\n+\n+;; ----------------------------------------------------------------------------"}]}