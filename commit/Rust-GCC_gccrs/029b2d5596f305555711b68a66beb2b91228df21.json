{"sha": "029b2d5596f305555711b68a66beb2b91228df21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5YjJkNTU5NmYzMDU1NTU3MTFiNjhhNjZiZWIyYjkxMjI4ZGYyMQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-01-17T20:44:07Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-01-17T20:44:07Z"}, "message": "re PR fortran/64578 ([OOP] Seg-fault and ICE with unlimited polymorphic array pointer function)\n\n2015-01-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/64578\n\t* trans-expr.c (gfc_trans_pointer_assignment): Make sure that\n\tbefore reinitializing rse, to add the rse.pre to block before\n\tcreating 'ptrtemp'.\n\t* trans-intrinsic.c (gfc_conv_associated): Deal with the class\n\tdata being a descriptor.\n\n2015-01-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/64578\n\t* gfortran.dg/unlimited_polymorphic_21.f90: New test\n\nFrom-SVN: r219802", "tree": {"sha": "5980d86dc9e67a2048bc38f55fd9197b63dfe896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5980d86dc9e67a2048bc38f55fd9197b63dfe896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/029b2d5596f305555711b68a66beb2b91228df21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029b2d5596f305555711b68a66beb2b91228df21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029b2d5596f305555711b68a66beb2b91228df21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029b2d5596f305555711b68a66beb2b91228df21/comments", "author": null, "committer": null, "parents": [{"sha": "9b5485174b808986614d6d1d1f0ec319831c9ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b5485174b808986614d6d1d1f0ec319831c9ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b5485174b808986614d6d1d1f0ec319831c9ec4"}], "stats": {"total": 118, "additions": 69, "deletions": 49}, "files": [{"sha": "d9e0fea8a1afaf0c0deef3aef4d6c9c928467319", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=029b2d5596f305555711b68a66beb2b91228df21", "patch": "@@ -1,3 +1,12 @@\n+2015-01-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/64578\n+\t* trans-expr.c (gfc_trans_pointer_assignment): Make sure that\n+\tbefore reinitializing rse, to add the rse.pre to block before\n+\tcreating 'ptrtemp'.\n+\t* trans-intrinsic.c (gfc_conv_associated): Deal with the class\n+\tdata being a descriptor.\n+\n 2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/60357"}, {"sha": "79eed1e2489b3b85e19edde9d893aacd304938ea", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=029b2d5596f305555711b68a66beb2b91228df21", "patch": "@@ -7075,6 +7075,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\trse.expr = gfc_class_data_get (rse.expr);\n \t      else\n \t\t{\n+\t\t  gfc_add_block_to_block (&block, &rse.pre);\n \t\t  tmp = gfc_create_var (TREE_TYPE (rse.expr), \"ptrtemp\");\n \t\t  gfc_add_modify (&lse.pre, tmp, rse.expr);\n \n@@ -7146,6 +7147,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t    }\n \t  else\n \t    {\n+\t      gfc_add_block_to_block (&block, &rse.pre);\n \t      tmp = gfc_create_var (TREE_TYPE (rse.expr), \"ptrtemp\");\n \t      gfc_add_modify (&lse.pre, tmp, rse.expr);\n "}, {"sha": "9ca46ef83417cee537c7f60233735fd75be3b6d7", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=029b2d5596f305555711b68a66beb2b91228df21", "patch": "@@ -186,7 +186,7 @@ gfc_builtin_decl_for_float_kind (enum built_in_function double_built_in,\n     {\n       /* For __float128, the story is a bit different, because we return\n \t a decl to a library function rather than a built-in.  */\n-      gfc_intrinsic_map_t *m; \n+      gfc_intrinsic_map_t *m;\n       for (m = gfc_intrinsic_map; m->double_built_in != double_built_in ; m++)\n \t;\n \n@@ -294,8 +294,8 @@ gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n   nargs = gfc_intrinsic_argument_list_length (expr);\n   args = XALLOCAVEC (tree, nargs);\n \n-  /* Evaluate all the arguments passed. Whilst we're only interested in the \n-     first one here, there are other parts of the front-end that assume this \n+  /* Evaluate all the arguments passed. Whilst we're only interested in the\n+     first one here, there are other parts of the front-end that assume this\n      and will trigger an ICE if it's not the case.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n   gcc_assert (expr->value.function.actual->expr);\n@@ -540,7 +540,7 @@ gfc_conv_intrinsic_int (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   nargs = gfc_intrinsic_argument_list_length (expr);\n   args = XALLOCAVEC (tree, nargs);\n \n-  /* Evaluate the argument, we process all arguments even though we only \n+  /* Evaluate the argument, we process all arguments even though we only\n      use the first one for code generation purposes.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n   gcc_assert (expr->value.function.actual->expr);\n@@ -1237,7 +1237,7 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \n \n /* Send data to a remove coarray.  */\n- \n+\n static tree\n conv_caf_send (gfc_code *code) {\n   gfc_expr *lhs_expr, *rhs_expr;\n@@ -1520,7 +1520,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \t extent = gfc_extent(i)\n \t ml = m\n \t m  = m/extent\n-\t if (i >= min_var) \n+\t if (i >= min_var)\n \t   goto exit_label\n \t i++\n        }\n@@ -1547,10 +1547,10 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n       return;\n     }\n \n-  m = gfc_create_var (type, NULL); \n-  ml = gfc_create_var (type, NULL); \n-  loop_var = gfc_create_var (integer_type_node, NULL); \n-  min_var = gfc_create_var (integer_type_node, NULL); \n+  m = gfc_create_var (type, NULL);\n+  ml = gfc_create_var (type, NULL);\n+  loop_var = gfc_create_var (integer_type_node, NULL);\n+  min_var = gfc_create_var (integer_type_node, NULL);\n \n   /* m = this_image () - 1.  */\n   gfc_add_modify (&se->pre, m, tmp);\n@@ -1584,7 +1584,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n   extent = fold_convert (type, extent);\n \n   /* m = m/extent.  */\n-  gfc_add_modify (&loop, m, \n+  gfc_add_modify (&loop, m,\n \t\t  fold_build2_loc (input_location, TRUNC_DIV_EXPR, type,\n \t\t\t  m, extent));\n \n@@ -1907,7 +1907,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n   ubound = gfc_conv_descriptor_ubound_get (desc, bound);\n   lbound = gfc_conv_descriptor_lbound_get (desc, bound);\n-  \n+\n   /* 13.14.53: Result value for LBOUND\n \n      Case (i): For an array section or for an array expression other than a\n@@ -2257,7 +2257,7 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n \n \n /* Remainder function MOD(A, P) = A - INT(A / P) * P\n-                      MODULO(A, P) = A - FLOOR (A / P) * P  \n+                      MODULO(A, P) = A - FLOOR (A / P) * P\n \n    The obvious algorithms above are numerically instable for large\n    arguments, hence these intrinsics are instead implemented via calls\n@@ -2316,7 +2316,7 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \n \t In order to calculate the result accurately, we use the fmod\n \t function as follows.\n-\t \n+\n \t res = fmod (arg, arg2);\n \t if (res)\n \t   {\n@@ -2328,7 +2328,7 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \n \t => As two nested ternary exprs:\n \n-\t res = res ? (((arg < 0) xor (arg2 < 0)) ? res + arg2 : res) \n+\t res = res ? (((arg < 0) xor (arg2 < 0)) ? res + arg2 : res)\n \t       : copysign (0., arg2);\n \n       */\n@@ -2349,15 +2349,15 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t\t\t\t  boolean_type_node, test, test2);\n \t  test = gfc_evaluate_now (test, &se->pre);\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, test,\n-\t\t\t\t      fold_build2_loc (input_location, \n+\t\t\t\t      fold_build2_loc (input_location,\n \t\t\t\t\t\t       PLUS_EXPR,\n-\t\t\t\t\t\t       type, tmp, args[1]), \n+\t\t\t\t\t\t       type, tmp, args[1]),\n \t\t\t\t      tmp);\n \t}\n       else\n \t{\n \t  tree expr1, copysign, cscall;\n-\t  copysign = gfc_builtin_decl_for_float_kind (BUILT_IN_COPYSIGN, \n+\t  copysign = gfc_builtin_decl_for_float_kind (BUILT_IN_COPYSIGN,\n \t\t\t\t\t\t      expr->ts.kind);\n \t  test = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n \t\t\t\t  args[0], zero);\n@@ -2366,13 +2366,13 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t  test2 = fold_build2_loc (input_location, TRUTH_XOR_EXPR,\n \t\t\t\t   boolean_type_node, test, test2);\n \t  expr1 = fold_build3_loc (input_location, COND_EXPR, type, test2,\n-\t\t\t\t   fold_build2_loc (input_location, \n+\t\t\t\t   fold_build2_loc (input_location,\n \t\t\t\t\t\t    PLUS_EXPR,\n-\t\t\t\t\t\t    type, tmp, args[1]), \n+\t\t\t\t\t\t    type, tmp, args[1]),\n \t\t\t\t   tmp);\n \t  test = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t\t  tmp, zero);\n-\t  cscall = build_call_expr_loc (input_location, copysign, 2, zero, \n+\t  cscall = build_call_expr_loc (input_location, copysign, 2, zero,\n \t\t\t\t\targs[1]);\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, test,\n \t\t\t\t      expr1, cscall);\n@@ -2839,15 +2839,15 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n     {\n       tree cond, isnan;\n \n-      val = args[i]; \n+      val = args[i];\n \n       /* Handle absent optional arguments by ignoring the comparison.  */\n       if (argexpr->expr->expr_type == EXPR_VARIABLE\n \t  && argexpr->expr->symtree->n.sym->attr.optional\n \t  && TREE_CODE (val) == INDIRECT_REF)\n \tcond = fold_build2_loc (input_location,\n \t\t\t\tNE_EXPR, boolean_type_node,\n-\t\t\t\tTREE_OPERAND (val, 0), \n+\t\t\t\tTREE_OPERAND (val, 0),\n \t\t\tbuild_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n       else\n       {\n@@ -3387,35 +3387,35 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n       gfc_add_modify (&ifblock2, val,\n \t\t      fold_build2_loc (input_location, RDIV_EXPR, type, scale,\n \t\t\t\t       absX));\n-      res1 = fold_build2_loc (input_location, MULT_EXPR, type, val, val); \n+      res1 = fold_build2_loc (input_location, MULT_EXPR, type, val, val);\n       res1 = fold_build2_loc (input_location, MULT_EXPR, type, resvar, res1);\n       res1 = fold_build2_loc (input_location, PLUS_EXPR, type, res1,\n \t\t\t      gfc_build_const (type, integer_one_node));\n       gfc_add_modify (&ifblock2, resvar, res1);\n       gfc_add_modify (&ifblock2, scale, absX);\n-      res1 = gfc_finish_block (&ifblock2); \n+      res1 = gfc_finish_block (&ifblock2);\n \n       gfc_init_block (&ifblock3);\n       gfc_add_modify (&ifblock3, val,\n \t\t      fold_build2_loc (input_location, RDIV_EXPR, type, absX,\n \t\t\t\t       scale));\n-      res2 = fold_build2_loc (input_location, MULT_EXPR, type, val, val); \n+      res2 = fold_build2_loc (input_location, MULT_EXPR, type, val, val);\n       res2 = fold_build2_loc (input_location, PLUS_EXPR, type, resvar, res2);\n       gfc_add_modify (&ifblock3, resvar, res2);\n       res2 = gfc_finish_block (&ifblock3);\n \n       cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n \t\t\t      absX, scale);\n       tmp = build3_v (COND_EXPR, cond, res1, res2);\n-      gfc_add_expr_to_block (&ifblock1, tmp);  \n+      gfc_add_expr_to_block (&ifblock1, tmp);\n       tmp = gfc_finish_block (&ifblock1);\n \n       cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t      arrayse.expr,\n \t\t\t      gfc_build_const (type, integer_zero_node));\n \n       tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n-      gfc_add_expr_to_block (&block, tmp);  \n+      gfc_add_expr_to_block (&block, tmp);\n     }\n   else\n     {\n@@ -4786,7 +4786,7 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \n    For INTEGER kinds smaller than the C 'int' type, we have to subtract the\n    difference in bit size between the argument of LEADZ and the C int.  */\n- \n+\n static void\n gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n {\n@@ -4848,7 +4848,7 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n     {\n       /* We end up here if the argument type is larger than 'long long'.\n \t We generate this code:\n-  \n+\n \t    if (x & (ULL_MAX << ULL_SIZE) != 0)\n \t      return clzll ((unsigned long long) (x >> ULLSIZE));\n \t    else\n@@ -4904,7 +4904,7 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n    The conditional expression is necessary because the result of TRAILZ(0)\n    is defined, but the result of __builtin_ctz(0) is undefined for most\n    targets.  */\n- \n+\n static void\n gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n {\n@@ -4959,7 +4959,7 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n     {\n       /* We end up here if the argument type is larger than 'long long'.\n \t We generate this code:\n-  \n+\n \t    if ((x & ULL_MAX) == 0)\n \t      return ULL_SIZE + ctzll ((unsigned long long) (x >> ULLSIZE));\n \t    else\n@@ -5010,7 +5010,7 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n /* Using __builtin_popcount for POPCNT and __builtin_parity for POPPAR;\n    for types larger than \"long long\", we call the long long built-in for\n    the lower and higher bits and combine the result.  */\n- \n+\n static void\n gfc_conv_intrinsic_popcnt_poppar (gfc_se * se, gfc_expr *expr, int parity)\n {\n@@ -5076,7 +5076,7 @@ gfc_conv_intrinsic_popcnt_poppar (gfc_se * se, gfc_expr *expr, int parity)\n       call2 = build_call_expr_loc (input_location, func, 1,\n \t\t\t\t   fold_convert (long_long_unsigned_type_node,\n \t\t\t\t\t\t arg2));\n-\t\t\t  \n+\n       /* Combine the results.  */\n       if (parity)\n \tse->expr = fold_build2_loc (input_location, BIT_XOR_EXPR, result_type,\n@@ -5411,7 +5411,7 @@ gfc_conv_intrinsic_mask (gfc_se * se, gfc_expr * expr, int left)\n {\n   tree arg, allones, type, utype, res, cond, bitsize;\n   int i;\n- \n+\n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   arg = gfc_evaluate_now (arg, &se->pre);\n \n@@ -5743,7 +5743,7 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n \n       /* Unusually, for an intrinsic, size does not exclude\n-\t an optional arg2, so we must test for it.  */  \n+\t an optional arg2, so we must test for it.  */\n       if (actual->expr->expr_type == EXPR_VARIABLE\n \t    && actual->expr->symtree->n.sym->attr.dummy\n \t    && actual->expr->symtree->n.sym->attr.optional)\n@@ -5813,7 +5813,7 @@ size_of_string_in_bytes (int kind, tree string_length)\n {\n   tree bytesize;\n   int i = gfc_validate_kind (BT_CHARACTER, kind, false);\n- \n+\n   bytesize = build_int_cst (gfc_array_index_type,\n \t\t\t    gfc_character_kinds[i].bit_size / 8);\n \n@@ -5970,7 +5970,7 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n   tree type, result_type, tmp;\n \n   arg = expr->value.function.actual->expr;\n-  \n+\n   gfc_init_se (&argse, NULL);\n   result_type = gfc_get_int_type (expr->ts.kind);\n \n@@ -5986,7 +5986,7 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n \t}\n \n       gfc_conv_expr_reference (&argse, arg);\n-      type = TREE_TYPE (build_fold_indirect_ref_loc (input_location, \n+      type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t     argse.expr));\n     }\n   else\n@@ -6001,12 +6001,12 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n \t}\n       type = gfc_get_element_type (TREE_TYPE (argse.expr));\n     }\n-    \n+\n   /* Obtain the argument's word length.  */\n   if (arg->ts.type == BT_CHARACTER)\n     tmp = size_of_string_in_bytes (arg->ts.kind, argse.string_length);\n   else\n-    tmp = size_in_bytes (type); \n+    tmp = size_in_bytes (type);\n   tmp = fold_convert (result_type, tmp);\n \n done:\n@@ -6195,7 +6195,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t\t\t\t       argse.string_length);\n       else\n \ttmp = fold_convert (gfc_array_index_type,\n-\t\t\t    size_in_bytes (source_type)); \n+\t\t\t    size_in_bytes (source_type));\n \n       /* Obtain the size of the array in bytes.  */\n       extent = gfc_create_var (gfc_array_index_type, NULL);\n@@ -6553,8 +6553,12 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t      && arg1->expr->symtree->n.sym->attr.dummy)\n \t    arg1se.expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t       arg1se.expr);\n-\t  if (arg1->expr->ts.type == BT_CLASS)\n+  \t  if (arg1->expr->ts.type == BT_CLASS)\n+\t    {\n \t      tmp2 = gfc_class_data_get (arg1se.expr);\n+\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp2)))\n+\t\ttmp2 = gfc_conv_descriptor_data_get (tmp2);\n+\t    }\n \t  else\n \t    tmp2 = arg1se.expr;\n         }\n@@ -6749,7 +6753,7 @@ gfc_conv_intrinsic_si_kind (gfc_se *se, gfc_expr *expr)\n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   /* The argument to SELECTED_INT_KIND is INTEGER(4).  */\n-  type = gfc_get_int_type (4); \n+  type = gfc_get_int_type (4);\n   arg = gfc_build_addr_expr (NULL_TREE, fold_convert (type, arg));\n \n   /* Convert it to the required type.  */\n@@ -6790,7 +6794,7 @@ gfc_conv_intrinsic_sr_kind (gfc_se *se, gfc_expr *expr)\n \t      gfc_convert_type (actual->expr, &ts, 2);\n \t    }\n \t  gfc_conv_expr_reference (&argse, actual->expr);\n-\t} \n+\t}\n \n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);\n@@ -7022,8 +7026,8 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n   else\n     gfc_conv_array_parameter (se, arg_expr, true, NULL, NULL, NULL);\n   se->expr = convert (gfc_get_int_type (gfc_index_integer_kind), se->expr);\n-   \n-  /* Create a temporary variable for loc return value.  Without this, \n+\n+  /* Create a temporary variable for loc return value.  Without this,\n      we get an error an ICE in gcc/expr.c(expand_expr_addr_expr_1).  */\n   temp_var = gfc_create_var (gfc_get_int_type (gfc_index_integer_kind), NULL);\n   gfc_add_modify (&se->pre, temp_var, se->expr);\n@@ -8698,7 +8702,7 @@ conv_co_collective (gfc_code *code)\n     case GFC_ISYM_CO_SUM:\n       fndecl = gfor_fndecl_co_sum;\n       break;\n-    default: \n+    default:\n       gcc_unreachable ();\n     }\n \n@@ -9174,7 +9178,7 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n \t\t\t     build_int_cst (NULL, MEMMODEL_RELAXED),\n \t\t\t     build_int_cst (NULL, MEMMODEL_RELAXED));\n   gfc_add_expr_to_block (&block, tmp);\n-  \n+\n   if (stat != NULL_TREE)\n     gfc_add_modify (&block, stat, build_int_cst (TREE_TYPE (stat), 0));\n   gfc_add_block_to_block (&block, &post_block);"}, {"sha": "3c986b2b6565a749d7b7eb9e9763bd0351c70d5f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b2d5596f305555711b68a66beb2b91228df21/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=029b2d5596f305555711b68a66beb2b91228df21", "patch": "@@ -1,3 +1,8 @@\n+2015-01-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/64578\n+\t* gfortran.dg/unlimited_polymorphic_21.f90: New test\n+\n 2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/60357"}]}