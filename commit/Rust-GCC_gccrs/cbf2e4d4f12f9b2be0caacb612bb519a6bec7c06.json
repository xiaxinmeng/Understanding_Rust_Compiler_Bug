{"sha": "cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JmMmU0ZDRmMTJmOWIyYmUwY2FhY2I2MTJiYjUxOWE2YmVjN2MwNg==", "commit": {"author": {"name": "Harsha Jagasia", "email": "harsha.jagasia@amd.com", "date": "2009-09-30T00:00:45Z"}, "committer": {"name": "Harsha Jagasia", "email": "hjagasia@gcc.gnu.org", "date": "2009-09-30T00:00:45Z"}, "message": "config.gcc (i[34567]86-*-*): Include fma4intrin.h.\n\n2009-09-29  Harsha Jagasia  <harsha.jagasia@amd.com>\n\n\t* config.gcc (i[34567]86-*-*): Include fma4intrin.h.\n\t(x86_64-*-*): Ditto.\t\n\n\t* config/i386/fma4intrin.h: New file, provide common x86 compiler\n\tintrinisics for FMA4.\n\t* config/i386/cpuid.h (bit_FMA4): Define FMA4 bit.\n\t* config/i386/x86intrin.h: Fix typo to SSE4A instead of SSE4a.\n\tAdd FMA4 check and fma4intrin.h.\n\t* config/i386/i386-c.c(ix86_target_macros_internal): Check\n\tISA_FLAG for FMA4. \n\t* config/i386/i386.h(TARGET_FMA4): New macro for FMA4.\n\t* config/i386/i386.md (UNSPEC_FMA4_INTRINSIC): Add new UNSPEC\n\tconstant for FMA4 support.\n\t(UNSPEC_FMA4_FMADDSUB): Ditto.\n\t(UNSPEC_FMA4_FMSUBADD): Ditto.\n\t* config/i386/i386.opt (-mfma4): New switch for FMA4 support.\n\t* config/i386/i386-protos.h (ix86_fma4_valid_op_p): Add\n\tdeclaration.\n\t(ix86_expand_fma4_multiple_memory): Ditto.\n\t* config/i386/i386.c (OPTION_MASK_ISA_FMA4_SET): New.\n\t(OPTION_MASK_ISA_FMA4_UNSET): New.\t\n\t(OPTION_MASK_ISA_SSE4A_UNSET): Change definition to\n\tdepend on FMA4.\n\t(OPTION_MASK_ISA_AVX_UNSET): Change definition to\n\tdepend on FMA4.\n\t(ix86_handle_option): Handle -mfma4.\n\t(isa_opts): Handle -mfma4.\n\t(enum pta_flags): Add PTA_FMA4.\n\t(override_options): Add FMA4 support.\t\n\t(IX86_BUILTIN_VFMADDSS): New for FMA4 intrinsic.\n\t(IX86_BUILTIN_VFMADDSD): Ditto.\n\t(IX86_BUILTIN_VFMADDPS): Ditto.\n\t(IX86_BUILTIN_VFMADDPD): Ditto.\n\t(IX86_BUILTIN_VFMSUBSS): Ditto.\n\t(IX86_BUILTIN_VFMSUBSD): Ditto.\n\t(IX86_BUILTIN_VFMSUBPS): Ditto.\n\t(IX86_BUILTIN_VFMSUBPD): Ditto.\n\t(IX86_BUILTIN_VFMADDSUBPS): Ditto.\n\t(IX86_BUILTIN_VFMADDSUBPD): Ditto.\n\t(IX86_BUILTIN_VFMSUBADDPS): Ditto.\n\t(IX86_BUILTIN_VFMSUBADDPD): Ditto.\n\t(IX86_BUILTIN_VFNMADDSS): Ditto.\n\t(IX86_BUILTIN_VFNMADDSD): Ditto.\n\t(IX86_BUILTIN_VFNMADDPS): Ditto.\n\t(IX86_BUILTIN_VFNMADDPD): Ditto.\n\t(IX86_BUILTIN_VFNMSUBSS): Ditto.\n\t(IX86_BUILTIN_VFNMSUBSD): Ditto.\n\t(IX86_BUILTIN_VFNMSUBPS): Ditto.\n\t(IX86_BUILTIN_VFNMSUBPD): Ditto.\n\t(IX86_BUILTIN_VFMADDPS256): Ditto.\n\t(IX86_BUILTIN_VFMADDPD256): Ditto.\n\t(IX86_BUILTIN_VFMSUBPS256): Ditto.\n\t(IX86_BUILTIN_VFMSUBPD256): Ditto.\n\t(IX86_BUILTIN_VFMADDSUBPS256): Ditto.\n\t(IX86_BUILTIN_VFMADDSUBPD256): Ditto.\n\t(IX86_BUILTIN_VFMSUBADDPS256): Ditto.\n\t(IX86_BUILTIN_VFMSUBADDPD256): Ditto.\n\t(IX86_BUILTIN_VFNMADDPS256): Ditto.\n\t(IX86_BUILTIN_VFNMADDPD256): Ditto.\n\t(IX86_BUILTIN_VFNMSUBPS256): Ditto.\n\t(IX86_BUILTIN_VFNMSUBPD256): Ditto.\n\t(enum multi_arg_type): New enum for describing the various FMA4\n\tintrinsic argument types.\n\t(bdesc_multi_arg): New table for FMA4 intrinsics.\n\t(ix86_init_mmx_sse_builtins): Add FMA4 intrinsic support.\n\t(ix86_expand_multi_arg_builtin): New function for creating FMA4\n\tintrinsics.\n\t(ix86_expand_builtin): Add FMA4 intrinsic support.\n\t(ix86_fma4_valid_op_p): New function to validate FMA4 3 and 4\n\toperand instructions.\n\t(ix86_expand_fma4_multiple_memory): New function to split the\n\tsecond memory reference from FMA4 instructions.\n\t* config/i386/sse.md (ssemodesuffixf4): New mode attribute for FMA4.\n\t(ssemodesuffixf2s): Ditto.\n\t(fma4_fmadd<mode>4): Add FMA4 floating point multiply/add\n\tinstructions.\n\t(fma4_fmsub<mode>4): Ditto.\n\t(fma4_fnmadd<mode>4): Ditto.\n\t(fma4_fnmsub<mode>4): Ditto.\n\t(fma4_vmfmadd<mode>4): Ditto.\n\t(fma4_vmfmsub<mode>4): Ditto.\n\t(fma4_vmfnmadd<mode>4): Ditto.\n\t(fma4_vmfnmsub<mode>4): Ditto.\n\t(fma4_fmadd<mode>4256): Ditto.\n\t(fma4_fmsub<mode>4256): Ditto.\n\t(fma4_fnmadd<mode>4256): Ditto.\n\t(fma4_fnmsub<mode>4256): Ditto.\n\t(fma4_fmaddsubv8sf4): Ditto.\n\t(fma4_fmaddsubv4sf4): Ditto.\n\t(fma4_fmaddsubv4df4): Ditto.\n\t(fma4_fmaddsubv2df4): Ditto.\n\t(fma4_fmsubaddv8sf4): Ditto.\n\t(fma4_fmsubaddv4sf4): Ditto.\n\t(fma4_fmsubaddv4df4): Ditto.\n\t(fma4_fmsubaddv2df4): Ditto.\n\t(fma4i_fmadd<mode>4): Add FMA4 floating point multiply/add\n\tinstructions for intrinsics.\n\t(fma4i_fmsub<mode>4): Ditto.\n\t(fma4i_fnmadd<mode>4): Ditto.\n\t(fma4i_fnmsub<mode>4): Ditto.\n\t(fma4i_vmfmadd<mode>4): Ditto.\n\t(fma4i_vmfmsub<mode>4): Ditto.\n\t(fma4i_vmfnmadd<mode>4): Ditto.\n\t(fma4i_vmfnmsub<mode>4): Ditto.\n\t(fma4i_fmadd<mode>4256): Ditto.\n\t(fma4i_fmsub<mode>4256): Ditto.\n\t(fma4i_fnmadd<mode>4256): Ditto.\n\t(fma4i_fnmsub<mode>4256): Ditto.\n\t(fma4i_fmaddsubv8sf4): Ditto.\n\t(fma4i_fmaddsubv4sf4): Ditto.\n\t(fma4i_fmaddsubv4df4): Ditto.\n\t(fma4i_fmaddsubv2df4): Ditto.\n\t(fma4i_fmsubaddv8sf4): Ditto.\n\t(fma4i_fmsubaddv4sf4): Ditto.\n\t(fma4i_fmsubaddv4df4): Ditto.\n\t(fma4i_fmsubaddv2df4): Ditto.\n\n\t* doc/invoke.texi (-mfma4): Add documentation.\n\t* doc/extend.texi (x86 intrinsics): Add FMA4 intrinsics.\n\n\t* gcc.target/i386/fma4-check.h\n\t* gcc.target/i386/fma4-fma.c\n\t* gcc.target/i386/fma4-maccXX.c\n\t* gcc.target/i386/fma4-msubXX.c\n\t* gcc.target/i386/fma4-nmaccXX.c\n\t* gcc.target/i386/fma4-nmsubXX.c\n\t* gcc.target/i386/fma4-vector.c\n\t* gcc.target/i386/fma4-256-maccXX.c\n\t* gcc.target/i386/fma4-256-msubXX.c\n\t* gcc.target/i386/fma4-256-nmaccXX.c\n\t* gcc.target/i386/fma4-256-nmsubXX.c\n\t* gcc.target/i386/fma4-256-vector.c\n\t* gcc.target/i386/funcspec-2.c: New file.\n\t* gcc.target/i386/funcspec-4.c: Test error conditions\n\trelated to FMA4.\n\t* gcc.target/i386/funcspec-5.c\n\t* gcc.target/i386/funcspec-6.c\n\t* gcc.target/i386/funcspec-8.c: Add FMA4.\n\t* gcc.target/i386/funcspec-9.c: New file.\n\t* gcc.target/i386/i386.exp: Add check_effective_target_fma4.\n\t* gcc.target/i386/isa-10.c\n\t* gcc.target/i386/isa-11.c\n\t* gcc.target/i386/isa-12.c\n\t* gcc.target/i386/isa-13.c\n\t* gcc.target/i386/isa-2.c\n\t* gcc.target/i386/isa-3.c\n\t* gcc.target/i386/isa-4.c\n\t* gcc.target/i386/isa-7.c\n\t* gcc.target/i386/isa-8.c\n\t* gcc.target/i386/isa-9.c: New file.\n\t* gcc.target/i386/isa-14.c\n\t* gcc.target/i386/isa-1.c\n\t* gcc.target/i386/isa-5.c\n\t* gcc.target/i386/isa-6.c: Add FMA4.\n\t* gcc.target/i386/sse-12.c\n\t* gcc.target/i386/sse-13.c\n\t* gcc.target/i386/sse-14.c\n\t* gcc.target/i386/sse-22.c: New file.\n\t* g++.dg/other/i386-2.C\n\t* g++.dg/other/i386-3.C\n\t* g++.dg/other/i386-5.C\n\t* g++.dg/other/i386-6.C: Add -mfma4 in dg-options.\n\nFrom-SVN: r152311", "tree": {"sha": "a6738f5a8818475b5816bfd870277e6deb35e967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6738f5a8818475b5816bfd870277e6deb35e967"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/comments", "author": null, "committer": null, "parents": [{"sha": "f8fd49b54950059ad08d6a8cc291ec07fed15108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fd49b54950059ad08d6a8cc291ec07fed15108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8fd49b54950059ad08d6a8cc291ec07fed15108"}], "stats": {"total": 4144, "additions": 4119, "deletions": 25}, "files": [{"sha": "2fce0d5a0e4850b35f2fd63af1c41d3aa8df70fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,3 +1,125 @@\n+2009-09-29  Harsha Jagasia  <harsha.jagasia@amd.com>\n+\n+\t* config.gcc (i[34567]86-*-*): Include fma4intrin.h.\n+\t(x86_64-*-*): Ditto.\n+\t\n+\t* config/i386/fma4intrin.h: New file, provide common x86 compiler\n+\tintrinisics for FMA4.\n+\t* config/i386/cpuid.h (bit_FMA4): Define FMA4 bit.\n+\t* config/i386/x86intrin.h: Fix typo to SSE4A instead of SSE4a.\n+\tAdd FMA4 check and fma4intrin.h.\n+\t* config/i386/i386-c.c(ix86_target_macros_internal): Check\n+\tISA_FLAG for FMA4. \n+\t* config/i386/i386.h(TARGET_FMA4): New macro for FMA4.\n+\t* config/i386/i386.md (UNSPEC_FMA4_INTRINSIC): Add new UNSPEC\n+\tconstant for FMA4 support.\n+\t(UNSPEC_FMA4_FMADDSUB): Ditto.\n+\t(UNSPEC_FMA4_FMSUBADD): Ditto.\n+\t* config/i386/i386.opt (-mfma4): New switch for FMA4 support.\n+\t* config/i386/i386-protos.h (ix86_fma4_valid_op_p): Add\n+\tdeclaration.\n+\t(ix86_expand_fma4_multiple_memory): Ditto.\n+\t* config/i386/i386.c (OPTION_MASK_ISA_FMA4_SET): New.\n+\t(OPTION_MASK_ISA_FMA4_UNSET): New.\t\n+\t(OPTION_MASK_ISA_SSE4A_UNSET): Change definition to\n+\tdepend on FMA4.\n+\t(OPTION_MASK_ISA_AVX_UNSET): Change definition to\n+\tdepend on FMA4.\n+\t(ix86_handle_option): Handle -mfma4.\n+\t(isa_opts): Handle -mfma4.\n+\t(enum pta_flags): Add PTA_FMA4.\n+\t(override_options): Add FMA4 support.\t\n+\t(IX86_BUILTIN_VFMADDSS): New for FMA4 intrinsic.\n+\t(IX86_BUILTIN_VFMADDSD): Ditto.\n+\t(IX86_BUILTIN_VFMADDPS): Ditto.\n+\t(IX86_BUILTIN_VFMADDPD): Ditto.\n+\t(IX86_BUILTIN_VFMSUBSS): Ditto.\n+\t(IX86_BUILTIN_VFMSUBSD): Ditto.\n+\t(IX86_BUILTIN_VFMSUBPS): Ditto.\n+\t(IX86_BUILTIN_VFMSUBPD): Ditto.\n+\t(IX86_BUILTIN_VFMADDSUBPS): Ditto.\n+\t(IX86_BUILTIN_VFMADDSUBPD): Ditto.\n+\t(IX86_BUILTIN_VFMSUBADDPS): Ditto.\n+\t(IX86_BUILTIN_VFMSUBADDPD): Ditto.\n+\t(IX86_BUILTIN_VFNMADDSS): Ditto.\n+\t(IX86_BUILTIN_VFNMADDSD): Ditto.\n+\t(IX86_BUILTIN_VFNMADDPS): Ditto.\n+\t(IX86_BUILTIN_VFNMADDPD): Ditto.\n+\t(IX86_BUILTIN_VFNMSUBSS): Ditto.\n+\t(IX86_BUILTIN_VFNMSUBSD): Ditto.\n+\t(IX86_BUILTIN_VFNMSUBPS): Ditto.\n+\t(IX86_BUILTIN_VFNMSUBPD): Ditto.\n+\t(IX86_BUILTIN_VFMADDPS256): Ditto.\n+\t(IX86_BUILTIN_VFMADDPD256): Ditto.\n+\t(IX86_BUILTIN_VFMSUBPS256): Ditto.\n+\t(IX86_BUILTIN_VFMSUBPD256): Ditto.\n+\t(IX86_BUILTIN_VFMADDSUBPS256): Ditto.\n+\t(IX86_BUILTIN_VFMADDSUBPD256): Ditto.\n+\t(IX86_BUILTIN_VFMSUBADDPS256): Ditto.\n+\t(IX86_BUILTIN_VFMSUBADDPD256): Ditto.\n+\t(IX86_BUILTIN_VFNMADDPS256): Ditto.\n+\t(IX86_BUILTIN_VFNMADDPD256): Ditto.\n+\t(IX86_BUILTIN_VFNMSUBPS256): Ditto.\n+\t(IX86_BUILTIN_VFNMSUBPD256): Ditto.\n+\t(enum multi_arg_type): New enum for describing the various FMA4\n+\tintrinsic argument types.\n+\t(bdesc_multi_arg): New table for FMA4 intrinsics.\n+\t(ix86_init_mmx_sse_builtins): Add FMA4 intrinsic support.\n+\t(ix86_expand_multi_arg_builtin): New function for creating FMA4\n+\tintrinsics.\n+\t(ix86_expand_builtin): Add FMA4 intrinsic support.\n+\t(ix86_fma4_valid_op_p): New function to validate FMA4 3 and 4\n+\toperand instructions.\n+\t(ix86_expand_fma4_multiple_memory): New function to split the\n+\tsecond memory reference from FMA4 instructions.\n+\t* config/i386/sse.md (ssemodesuffixf4): New mode attribute for FMA4.\n+\t(ssemodesuffixf2s): Ditto.\n+\t(fma4_fmadd<mode>4): Add FMA4 floating point multiply/add\n+\tinstructions.\n+\t(fma4_fmsub<mode>4): Ditto.\n+\t(fma4_fnmadd<mode>4): Ditto.\n+\t(fma4_fnmsub<mode>4): Ditto.\n+\t(fma4_vmfmadd<mode>4): Ditto.\n+\t(fma4_vmfmsub<mode>4): Ditto.\n+\t(fma4_vmfnmadd<mode>4): Ditto.\n+\t(fma4_vmfnmsub<mode>4): Ditto.\n+\t(fma4_fmadd<mode>4256): Ditto.\n+\t(fma4_fmsub<mode>4256): Ditto.\n+\t(fma4_fnmadd<mode>4256): Ditto.\n+\t(fma4_fnmsub<mode>4256): Ditto.\n+\t(fma4_fmaddsubv8sf4): Ditto.\n+\t(fma4_fmaddsubv4sf4): Ditto.\n+\t(fma4_fmaddsubv4df4): Ditto.\n+\t(fma4_fmaddsubv2df4): Ditto.\n+\t(fma4_fmsubaddv8sf4): Ditto.\n+\t(fma4_fmsubaddv4sf4): Ditto.\n+\t(fma4_fmsubaddv4df4): Ditto.\n+\t(fma4_fmsubaddv2df4): Ditto.\n+\t(fma4i_fmadd<mode>4): Add FMA4 floating point multiply/add\n+\tinstructions for intrinsics.\n+\t(fma4i_fmsub<mode>4): Ditto.\n+\t(fma4i_fnmadd<mode>4): Ditto.\n+\t(fma4i_fnmsub<mode>4): Ditto.\n+\t(fma4i_vmfmadd<mode>4): Ditto.\n+\t(fma4i_vmfmsub<mode>4): Ditto.\n+\t(fma4i_vmfnmadd<mode>4): Ditto.\n+\t(fma4i_vmfnmsub<mode>4): Ditto.\n+\t(fma4i_fmadd<mode>4256): Ditto.\n+\t(fma4i_fmsub<mode>4256): Ditto.\n+\t(fma4i_fnmadd<mode>4256): Ditto.\n+\t(fma4i_fnmsub<mode>4256): Ditto.\n+\t(fma4i_fmaddsubv8sf4): Ditto.\n+\t(fma4i_fmaddsubv4sf4): Ditto.\n+\t(fma4i_fmaddsubv4df4): Ditto.\n+\t(fma4i_fmaddsubv2df4): Ditto.\n+\t(fma4i_fmsubaddv8sf4): Ditto.\n+\t(fma4i_fmsubaddv4sf4): Ditto.\n+\t(fma4i_fmsubaddv4df4): Ditto.\n+\t(fma4i_fmsubaddv2df4): Ditto.\n+\n+\t* doc/invoke.texi (-mfma4): Add documentation.\n+\t* doc/extend.texi (x86 intrinsics): Add FMA4 intrinsics.\n+\n 2009-09-29  Richard Henderson  <rth@redhat.com>\n \n \t* tree-eh.c (unsplit_eh): Do not unsplit if there's already"}, {"sha": "6351aa5895a99e208cfbc98793d500b243472619", "filename": "gcc/config.gcc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -286,17 +286,19 @@ i[34567]86-*-*)\n \tcxx_target_objs=\"i386-c.o\"\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n-\t\t       nmmintrin.h bmmintrin.h wmmintrin.h immintrin.h\n-\t\t       x86intrin.h avxintrin.h ia32intrin.h cross-stdarg.h\"\n+\t\t       nmmintrin.h bmmintrin.h fma4intrin.h wmmintrin.h\n+\t\t       immintrin.h x86intrin.h avxintrin.h \n+\t\t       ia32intrin.h cross-stdarg.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n \tc_target_objs=\"i386-c.o\"\n \tcxx_target_objs=\"i386-c.o\"\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n-\t\t       nmmintrin.h bmmintrin.h wmmintrin.h immintrin.h\n-\t\t       x86intrin.h avxintrin.h ia32intrin.h cross-stdarg.h\"\n+\t\t       nmmintrin.h bmmintrin.h fma4intrin.h wmmintrin.h\n+\t\t       immintrin.h x86intrin.h avxintrin.h \n+\t\t       ia32intrin.h cross-stdarg.h\"\n \tneed_64bit_hwint=yes\n \t;;\n ia64-*-*)"}, {"sha": "49acfa780e4c6bb23d56f5ea037199abb9c95792", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -48,6 +48,7 @@\n /* %ecx */\n #define bit_LAHF_LM\t(1 << 0)\n #define bit_SSE4a\t(1 << 6)\n+#define bit_FMA4\t(1 << 16)\n \n /* %edx */\n #define bit_LM\t\t(1 << 29)"}, {"sha": "42782ade0ed3c049a358c66605936f874fa18c92", "filename": "gcc/config/i386/fma4intrin.h", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Ffma4intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Ffma4intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffma4intrin.h?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,245 @@\n+/* Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _X86INTRIN_H_INCLUDED\n+# error \"Never use <fma4intrin.h> directly; include <x86intrin.h> instead.\"\n+#endif\n+\n+#ifndef _FMA4INTRIN_H_INCLUDED\n+#define _FMA4INTRIN_H_INCLUDED\n+\n+#ifndef __FMA4__\n+# error \"FMA4 instruction set not enabled\"\n+#else\n+\n+/* We need definitions from the SSE4A, SSE3, SSE2 and SSE header files.  */\n+#include <ammintrin.h>\n+\n+/* Internal data types for implementing the intrinsics.  */\n+typedef float __v8sf __attribute__ ((__vector_size__ (32)));\n+typedef double __v4df __attribute__ ((__vector_size__ (32)));\n+\n+typedef float __m256 __attribute__ ((__vector_size__ (32),\n+\t\t\t\t     __may_alias__));\n+typedef double __m256d __attribute__ ((__vector_size__ (32),\n+\t\t\t\t       __may_alias__));\n+\n+/* 128b Floating point multiply/add type instructions.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macc_ps (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfmaddps ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macc_pd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfmaddpd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macc_ss (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfmaddss ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macc_sd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfmaddsd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_msub_ps (__m128 __A, __m128 __B, __m128 __C)\n+\n+{\n+  return (__m128) __builtin_ia32_vfmsubps ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_msub_pd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfmsubpd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_msub_ss (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfmsubss ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_msub_sd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfmsubsd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmacc_ps (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfnmaddps ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmacc_pd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfnmaddpd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmacc_ss (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfnmaddss ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmacc_sd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfnmaddsd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmsub_ps (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfnmsubps ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmsub_pd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfnmsubpd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmsub_ss (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfnmsubss ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_nmsub_sd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfnmsubsd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maddsub_ps (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfmaddsubps ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maddsub_pd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfmaddsubpd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_msubadd_ps (__m128 __A, __m128 __B, __m128 __C)\n+{\n+  return (__m128) __builtin_ia32_vfmsubaddps ((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_msubadd_pd (__m128d __A, __m128d __B, __m128d __C)\n+{\n+  return (__m128d) __builtin_ia32_vfmsubaddpd ((__v2df)__A, (__v2df)__B, (__v2df)__C);\n+}\n+\n+/* 256b Floating point multiply/add type instructions.  */\n+extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_macc_ps (__m256 __A, __m256 __B, __m256 __C)\n+{\n+  return (__m256) __builtin_ia32_vfmaddps256 ((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);\n+}\n+\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_macc_pd (__m256d __A, __m256d __B, __m256d __C)\n+{\n+  return (__m256d) __builtin_ia32_vfmaddpd256 ((__v4df)__A, (__v4df)__B, (__v4df)__C);\n+}\n+\n+extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_msub_ps (__m256 __A, __m256 __B, __m256 __C)\n+\n+{\n+  return (__m256) __builtin_ia32_vfmsubps256 ((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);\n+}\n+\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_msub_pd (__m256d __A, __m256d __B, __m256d __C)\n+{\n+  return (__m256d) __builtin_ia32_vfmsubpd256 ((__v4df)__A, (__v4df)__B, (__v4df)__C);\n+}\n+\n+extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_nmacc_ps (__m256 __A, __m256 __B, __m256 __C)\n+{\n+  return (__m256) __builtin_ia32_vfnmaddps256 ((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);\n+}\n+\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_nmacc_pd (__m256d __A, __m256d __B, __m256d __C)\n+{\n+  return (__m256d) __builtin_ia32_vfnmaddpd256 ((__v4df)__A, (__v4df)__B, (__v4df)__C);\n+}\n+\n+extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_nmsub_ps (__m256 __A, __m256 __B, __m256 __C)\n+{\n+  return (__m256) __builtin_ia32_vfnmsubps256 ((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);\n+}\n+\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_nmsub_pd (__m256d __A, __m256d __B, __m256d __C)\n+{\n+  return (__m256d) __builtin_ia32_vfnmsubpd256 ((__v4df)__A, (__v4df)__B, (__v4df)__C);\n+}\n+\n+extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_maddsub_ps (__m256 __A, __m256 __B, __m256 __C)\n+{\n+  return (__m256) __builtin_ia32_vfmaddsubps256 ((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);\n+}\n+\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_maddsub_pd (__m256d __A, __m256d __B, __m256d __C)\n+{\n+  return (__m256d) __builtin_ia32_vfmaddsubpd256 ((__v4df)__A, (__v4df)__B, (__v4df)__C);\n+}\n+\n+extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_msubadd_ps (__m256 __A, __m256 __B, __m256 __C)\n+{\n+  return (__m256) __builtin_ia32_vfmsubaddps256 ((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);\n+}\n+\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_msubadd_pd (__m256d __A, __m256d __B, __m256d __C)\n+{\n+  return (__m256d) __builtin_ia32_vfmsubaddpd256 ((__v4df)__A, (__v4df)__B, (__v4df)__C);\n+}\n+\n+#endif\n+\n+#endif"}, {"sha": "12a3f1759a8cc92824a882d9a1b2a1d6280fdd43", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -230,6 +230,8 @@ ix86_target_macros_internal (int isa_flag,\n     def_or_undef (parse_in, \"__FMA__\");\n   if (isa_flag & OPTION_MASK_ISA_SSE4A)\n     def_or_undef (parse_in, \"__SSE4A__\");\n+  if (isa_flag & OPTION_MASK_ISA_FMA4)\n+    def_or_undef (parse_in, \"__FMA4__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE))\n     def_or_undef (parse_in, \"__SSE_MATH__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))"}, {"sha": "58da13168dec934404406751eb5f7d228d9607e2", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -214,6 +214,9 @@ extern void ix86_expand_vector_set (bool, rtx, rtx, int);\n extern void ix86_expand_vector_extract (bool, rtx, rtx, int);\n extern void ix86_expand_reduc_v4sf (rtx (*)(rtx, rtx, rtx), rtx, rtx);\n \n+extern bool ix86_fma4_valid_op_p (rtx [], rtx, int, bool, int, bool);\n+extern void ix86_expand_fma4_multiple_memory (rtx [], int, enum machine_mode);\n+\n /* In i386-c.c  */\n extern void ix86_target_macros (void);\n extern void ix86_register_pragmas (void);"}, {"sha": "9df01ba23dcce0595c298d9ab4f5f9cdcb5dad2c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 451, "deletions": 3, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1955,6 +1955,9 @@ static int ix86_isa_flags_explicit;\n \n #define OPTION_MASK_ISA_SSE4A_SET \\\n   (OPTION_MASK_ISA_SSE4A | OPTION_MASK_ISA_SSE3_SET)\n+#define OPTION_MASK_ISA_FMA4_SET \\\n+  (OPTION_MASK_ISA_FMA4 | OPTION_MASK_ISA_SSE4A_SET \\\n+   | OPTION_MASK_ISA_AVX_SET)\n \n /* AES and PCLMUL need SSE2 because they use xmm registers */\n #define OPTION_MASK_ISA_AES_SET \\\n@@ -1995,15 +1998,19 @@ static int ix86_isa_flags_explicit;\n #define OPTION_MASK_ISA_SSE4_2_UNSET \\\n   (OPTION_MASK_ISA_SSE4_2 | OPTION_MASK_ISA_AVX_UNSET )\n #define OPTION_MASK_ISA_AVX_UNSET \\\n-  (OPTION_MASK_ISA_AVX | OPTION_MASK_ISA_FMA_UNSET)\n+  (OPTION_MASK_ISA_AVX | OPTION_MASK_ISA_FMA_UNSET \\\n+   | OPTION_MASK_ISA_FMA4_UNSET)\n #define OPTION_MASK_ISA_FMA_UNSET OPTION_MASK_ISA_FMA\n \n /* SSE4 includes both SSE4.1 and SSE4.2.  -mno-sse4 should the same\n    as -mno-sse4.1. */\n #define OPTION_MASK_ISA_SSE4_UNSET OPTION_MASK_ISA_SSE4_1_UNSET\n \n #define OPTION_MASK_ISA_SSE4A_UNSET \\\n-  (OPTION_MASK_ISA_SSE4A)\n+  (OPTION_MASK_ISA_SSE4A | OPTION_MASK_ISA_FMA4_UNSET)\n+\n+#define OPTION_MASK_ISA_FMA4_UNSET OPTION_MASK_ISA_FMA4\n+\n #define OPTION_MASK_ISA_AES_UNSET OPTION_MASK_ISA_AES\n #define OPTION_MASK_ISA_PCLMUL_UNSET OPTION_MASK_ISA_PCLMUL\n #define OPTION_MASK_ISA_ABM_UNSET OPTION_MASK_ISA_ABM\n@@ -2237,6 +2244,19 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n \t}\n       return true;\n \n+    case OPT_mfma4:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_FMA4_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_FMA4_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_FMA4_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_FMA4_UNSET;\n+\t}\n+      return true;\n+\n     case OPT_mabm:\n       if (value)\n \t{\n@@ -2364,6 +2384,7 @@ ix86_target_string (int isa, int flags, const char *arch, const char *tune,\n   static struct ix86_target_opts isa_opts[] =\n   {\n     { \"-m64\",\t\tOPTION_MASK_ISA_64BIT },\n+    { \"-mfma4\",\t\tOPTION_MASK_ISA_FMA4 },\n     { \"-msse4a\",\tOPTION_MASK_ISA_SSE4A },\n     { \"-msse4.2\",\tOPTION_MASK_ISA_SSE4_2 },\n     { \"-msse4.1\",\tOPTION_MASK_ISA_SSE4_1 },\n@@ -2593,7 +2614,8 @@ override_options (bool main_args_p)\n       PTA_PCLMUL = 1 << 17,\n       PTA_AVX = 1 << 18,\n       PTA_FMA = 1 << 19,\n-      PTA_MOVBE = 1 << 20\n+      PTA_MOVBE = 1 << 20,\n+      PTA_FMA4 = 1 << 21\n     };\n \n   static struct pta\n@@ -2936,6 +2958,9 @@ override_options (bool main_args_p)\n \tif (processor_alias_table[i].flags & PTA_SSE4A\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4A))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_SSE4A;\n+\tif (processor_alias_table[i].flags & PTA_FMA4\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_FMA4))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_FMA4;\n \tif (processor_alias_table[i].flags & PTA_ABM\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_ABM))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_ABM;\n@@ -3619,6 +3644,7 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[])\n     IX86_ATTR_ISA (\"sse4.2\",\tOPT_msse4_2),\n     IX86_ATTR_ISA (\"sse4a\",\tOPT_msse4a),\n     IX86_ATTR_ISA (\"ssse3\",\tOPT_mssse3),\n+    IX86_ATTR_ISA (\"fma4\",\tOPT_mfma4),\n \n     /* string options */\n     IX86_ATTR_STR (\"arch=\",\tIX86_FUNCTION_SPECIFIC_ARCH),\n@@ -20686,6 +20712,39 @@ enum ix86_builtins\n \n   IX86_BUILTIN_CVTUDQ2PS,\n \n+  /* FMA4 instructions.  */\n+  IX86_BUILTIN_VFMADDSS,\n+  IX86_BUILTIN_VFMADDSD,\n+  IX86_BUILTIN_VFMADDPS,\n+  IX86_BUILTIN_VFMADDPD,\n+  IX86_BUILTIN_VFMSUBSS,\n+  IX86_BUILTIN_VFMSUBSD,\n+  IX86_BUILTIN_VFMSUBPS,\n+  IX86_BUILTIN_VFMSUBPD,\n+  IX86_BUILTIN_VFMADDSUBPS,\n+  IX86_BUILTIN_VFMADDSUBPD,\n+  IX86_BUILTIN_VFMSUBADDPS,\n+  IX86_BUILTIN_VFMSUBADDPD,\n+  IX86_BUILTIN_VFNMADDSS,\n+  IX86_BUILTIN_VFNMADDSD,\n+  IX86_BUILTIN_VFNMADDPS,\n+  IX86_BUILTIN_VFNMADDPD,\n+  IX86_BUILTIN_VFNMSUBSS,\n+  IX86_BUILTIN_VFNMSUBSD,\n+  IX86_BUILTIN_VFNMSUBPS,\n+  IX86_BUILTIN_VFNMSUBPD,\n+  IX86_BUILTIN_VFMADDPS256,\n+  IX86_BUILTIN_VFMADDPD256,\n+  IX86_BUILTIN_VFMSUBPS256,\n+  IX86_BUILTIN_VFMSUBPD256,\n+  IX86_BUILTIN_VFMADDSUBPS256,\n+  IX86_BUILTIN_VFMADDSUBPD256,\n+  IX86_BUILTIN_VFMSUBADDPS256,\n+  IX86_BUILTIN_VFMSUBADDPD256,\n+  IX86_BUILTIN_VFNMADDPS256,\n+  IX86_BUILTIN_VFNMADDPD256,\n+  IX86_BUILTIN_VFNMSUBPS256,\n+  IX86_BUILTIN_VFNMSUBPD256,\n   IX86_BUILTIN_MAX\n };\n \n@@ -21759,6 +21818,56 @@ static const struct builtin_description bdesc_args[] =\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movmskps256, \"__builtin_ia32_movmskps256\", IX86_BUILTIN_MOVMSKPS256, UNKNOWN, (int) INT_FTYPE_V8SF },\n };\n \n+/* FMA4.  */\n+enum multi_arg_type {\n+  MULTI_ARG_UNKNOWN,\n+  MULTI_ARG_3_SF,\n+  MULTI_ARG_3_DF,\n+  MULTI_ARG_3_SF2,\n+  MULTI_ARG_3_DF2\n+};\n+\n+static const struct builtin_description bdesc_multi_arg[] =\n+{\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfmaddv4sf4,     \"__builtin_ia32_vfmaddss\",    IX86_BUILTIN_VFMADDSS,    UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfmaddv2df4,     \"__builtin_ia32_vfmaddsd\",    IX86_BUILTIN_VFMADDSD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddv4sf4,       \"__builtin_ia32_vfmaddps\",    IX86_BUILTIN_VFMADDPS,    UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddv2df4,       \"__builtin_ia32_vfmaddpd\",    IX86_BUILTIN_VFMADDPD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfmsubv4sf4,     \"__builtin_ia32_vfmsubss\",    IX86_BUILTIN_VFMSUBSS,    UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfmsubv2df4,     \"__builtin_ia32_vfmsubsd\",    IX86_BUILTIN_VFMSUBSD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv4sf4,       \"__builtin_ia32_vfmsubps\",    IX86_BUILTIN_VFMSUBPS,    UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv2df4,       \"__builtin_ia32_vfmsubpd\",    IX86_BUILTIN_VFMSUBPD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n+    \n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfnmaddv4sf4,    \"__builtin_ia32_vfnmaddss\",   IX86_BUILTIN_VFNMADDSS,   UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfnmaddv2df4,    \"__builtin_ia32_vfnmaddsd\",   IX86_BUILTIN_VFNMADDSD,   UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmaddv4sf4,      \"__builtin_ia32_vfnmaddps\",   IX86_BUILTIN_VFNMADDPS,   UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmaddv2df4,      \"__builtin_ia32_vfnmaddpd\",   IX86_BUILTIN_VFNMADDPD,   UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfnmsubv4sf4,    \"__builtin_ia32_vfnmsubss\",   IX86_BUILTIN_VFNMSUBSS,   UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfnmsubv2df4,    \"__builtin_ia32_vfnmsubsd\",   IX86_BUILTIN_VFNMSUBSD,   UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmsubv4sf4,      \"__builtin_ia32_vfnmsubps\",   IX86_BUILTIN_VFNMSUBPS,   UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmsubv2df4,      \"__builtin_ia32_vfnmsubpd\",   IX86_BUILTIN_VFNMSUBPD,   UNKNOWN,      (int)MULTI_ARG_3_DF },\n+\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddsubv4sf4,\t   \"__builtin_ia32_vfmaddsubps\", IX86_BUILTIN_VFMADDSUBPS,    UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddsubv2df4,\t   \"__builtin_ia32_vfmaddsubpd\", IX86_BUILTIN_VFMADDSUBPD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubaddv4sf4,\t   \"__builtin_ia32_vfmsubaddps\", IX86_BUILTIN_VFMSUBADDPS,    UNKNOWN,      (int)MULTI_ARG_3_SF },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubaddv2df4,\t   \"__builtin_ia32_vfmsubaddpd\", IX86_BUILTIN_VFMSUBADDPD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n+\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddv8sf4256,       \"__builtin_ia32_vfmaddps256\",    IX86_BUILTIN_VFMADDPS256,    UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddv4df4256,       \"__builtin_ia32_vfmaddpd256\",    IX86_BUILTIN_VFMADDPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv8sf4256,       \"__builtin_ia32_vfmsubps256\",    IX86_BUILTIN_VFMSUBPS256,    UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv4df4256,       \"__builtin_ia32_vfmsubpd256\",    IX86_BUILTIN_VFMSUBPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n+  \n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmaddv8sf4256,      \"__builtin_ia32_vfnmaddps256\",   IX86_BUILTIN_VFNMADDPS256,   UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmaddv4df4256,      \"__builtin_ia32_vfnmaddpd256\",   IX86_BUILTIN_VFNMADDPD256,   UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmsubv8sf4256,      \"__builtin_ia32_vfnmsubps256\",   IX86_BUILTIN_VFNMSUBPS256,   UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmsubv4df4256,      \"__builtin_ia32_vfnmsubpd256\",   IX86_BUILTIN_VFNMSUBPD256,   UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n+\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddsubv8sf4,\t   \"__builtin_ia32_vfmaddsubps256\", IX86_BUILTIN_VFMADDSUBPS256,    UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddsubv4df4,\t   \"__builtin_ia32_vfmaddsubpd256\", IX86_BUILTIN_VFMADDSUBPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubaddv8sf4,\t   \"__builtin_ia32_vfmsubaddps256\", IX86_BUILTIN_VFMSUBADDPS256,    UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubaddv4df4,\t   \"__builtin_ia32_vfmsubaddpd256\", IX86_BUILTIN_VFMSUBADDPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 }\n+\n+};\n \n /* Set up all the MMX/SSE builtins, even builtins for instructions that are not\n    in the current target ISA to allow the user to compile particular modules\n@@ -23192,6 +23301,29 @@ ix86_init_mmx_sse_builtins (void)\n \t\t\t\t    intQI_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n   def_builtin_const (OPTION_MASK_ISA_SSE4_1, \"__builtin_ia32_vec_set_v16qi\", ftype, IX86_BUILTIN_VEC_SET_V16QI);\n+  /* Add FMA4 multi-arg argument instructions */\n+  for (i = 0, d = bdesc_multi_arg; i < ARRAY_SIZE (bdesc_multi_arg); i++, d++)\n+    {\n+      tree mtype = NULL_TREE;\n+\n+      if (d->name == 0)\n+\tcontinue;\n+\n+      switch ((enum multi_arg_type)d->flag)\n+\t{\n+\tcase MULTI_ARG_3_SF:     mtype = v4sf_ftype_v4sf_v4sf_v4sf; \tbreak;\n+\tcase MULTI_ARG_3_DF:     mtype = v2df_ftype_v2df_v2df_v2df; \tbreak;\n+\tcase MULTI_ARG_3_SF2:    mtype = v8sf_ftype_v8sf_v8sf_v8sf; \tbreak;\n+\tcase MULTI_ARG_3_DF2:    mtype = v4df_ftype_v4df_v4df_v4df; \tbreak;\n+\n+\tcase MULTI_ARG_UNKNOWN:\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (mtype)\n+\tdef_builtin_const (d->mask, d->name, mtype, d->code);\n+    }\n }\n \n /* Internal method for ix86_init_builtins.  */\n@@ -23364,6 +23496,122 @@ ix86_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n   return target;\n }\n \n+/* Subroutine of ix86_expand_builtin to take care of 2-4 argument insns.  */\n+\n+static rtx\n+ix86_expand_multi_arg_builtin (enum insn_code icode, tree exp, rtx target,\n+\t\t\t       enum multi_arg_type m_type,\n+\t\t\t       enum rtx_code sub_code)\n+{\n+  rtx pat;\n+  int i;\n+  int nargs;\n+  bool comparison_p = false;\n+  bool tf_p = false;\n+  bool last_arg_constant = false;\n+  int num_memory = 0;\n+  struct {\n+    rtx op;\n+    enum machine_mode mode;\n+  } args[4];\n+\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+\n+  switch (m_type)\n+    {\n+    case MULTI_ARG_3_SF:\n+    case MULTI_ARG_3_DF:\n+    case MULTI_ARG_3_SF2:\n+    case MULTI_ARG_3_DF2:\n+      nargs = 3;\n+      break;\n+\n+    case MULTI_ARG_UNKNOWN:\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (optimize || !target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  gcc_assert (nargs <= 4);\n+\n+  for (i = 0; i < nargs; i++)\n+    {\n+      tree arg = CALL_EXPR_ARG (exp, i);\n+      rtx op = expand_normal (arg);\n+      int adjust = (comparison_p) ? 1 : 0;\n+      enum machine_mode mode = insn_data[icode].operand[i+adjust+1].mode;\n+\n+      if (last_arg_constant && i == nargs-1)\n+\t{\n+\t  if (!CONST_INT_P (op))\n+\t    {\n+\t      error (\"last argument must be an immediate\");\n+\t      return gen_reg_rtx (tmode);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (VECTOR_MODE_P (mode))\n+\t    op = safe_vector_operand (op, mode);\n+\n+\t  /* If we aren't optimizing, only allow one memory operand to be\n+\t     generated.  */\n+\t  if (memory_operand (op, mode))\n+\t    num_memory++;\n+\n+\t  gcc_assert (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode);\n+\n+\t  if (optimize\n+\t      || ! (*insn_data[icode].operand[i+adjust+1].predicate) (op, mode)\n+\t      || num_memory > 1)\n+\t    op = force_reg (mode, op);\n+\t}\n+\n+      args[i].op = op;\n+      args[i].mode = mode;\n+    }\n+\n+  switch (nargs)\n+    {\n+    case 1:\n+      pat = GEN_FCN (icode) (target, args[0].op);\n+      break;\n+\n+    case 2:\n+      if (tf_p)\n+\tpat = GEN_FCN (icode) (target, args[0].op, args[1].op,\n+\t\t\t       GEN_INT ((int)sub_code));\n+      else if (! comparison_p)\n+\tpat = GEN_FCN (icode) (target, args[0].op, args[1].op);\n+      else\n+\t{\n+\t  rtx cmp_op = gen_rtx_fmt_ee (sub_code, GET_MODE (target),\n+\t\t\t\t       args[0].op,\n+\t\t\t\t       args[1].op);\n+\n+\t  pat = GEN_FCN (icode) (target, cmp_op, args[0].op, args[1].op);\n+\t}\n+      break;\n+\n+    case 3:\n+      pat = GEN_FCN (icode) (target, args[0].op, args[1].op, args[2].op);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (! pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+  return target;\n+}\n+\n /* Subroutine of ix86_expand_args_builtin to take care of scalar unop\n    insns with vec_merge.  */\n \n@@ -24633,6 +24881,12 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     if (d->code == fcode)\n       return ix86_expand_sse_pcmpistr (d, exp, target);\n \n+  for (i = 0, d = bdesc_multi_arg; i < ARRAY_SIZE (bdesc_multi_arg); i++, d++)\n+    if (d->code == fcode)\n+      return ix86_expand_multi_arg_builtin (d->icode, exp, target,\n+\t\t\t\t\t    (enum multi_arg_type)d->flag,\n+\t\t\t\t\t    d->comparison);\n+\n   gcc_unreachable ();\n }\n \n@@ -29015,6 +29269,200 @@ ix86_expand_round (rtx operand0, rtx operand1)\n   emit_move_insn (operand0, res);\n }\n \f\n+/* Validate whether a FMA4 instruction is valid or not.\n+   OPERANDS is the array of operands.\n+   NUM is the number of operands.\n+   USES_OC0 is true if the instruction uses OC0 and provides 4 variants.\n+   NUM_MEMORY is the maximum number of memory operands to accept.\n+   NUM_MEMORY less than zero is a special case to allow an operand\n+   of an instruction to be memory operation.\n+   when COMMUTATIVE is set, operand 1 and 2 can be swapped.  */\n+\n+bool\n+ix86_fma4_valid_op_p (rtx operands[], rtx insn ATTRIBUTE_UNUSED, int num,\n+\t\t      bool uses_oc0, int num_memory, bool commutative)\n+{\n+  int mem_mask;\n+  int mem_count;\n+  int i;\n+\n+  /* Count the number of memory arguments */\n+  mem_mask = 0;\n+  mem_count = 0;\n+  for (i = 0; i < num; i++)\n+    {\n+      enum machine_mode mode = GET_MODE (operands[i]);\n+      if (register_operand (operands[i], mode))\n+\t;\n+\n+      else if (memory_operand (operands[i], mode))\n+\t{\n+\t  mem_mask |= (1 << i);\n+\t  mem_count++;\n+\t}\n+\n+      else\n+\t{\n+\t  rtx pattern = PATTERN (insn);\n+\n+\t  /* allow 0 for pcmov */\n+\t  if (GET_CODE (pattern) != SET\n+\t      || GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE\n+\t      || i < 2\n+\t      || operands[i] != CONST0_RTX (mode))\n+\t    return false;\n+\t}\n+    }\n+\n+  /* Special case pmacsdq{l,h} where we allow the 3rd argument to be\n+     a memory operation.  */\n+  if (num_memory < 0)\n+    {\n+      num_memory = -num_memory;\n+      if ((mem_mask & (1 << (num-1))) != 0)\n+\t{\n+\t  mem_mask &= ~(1 << (num-1));\n+\t  mem_count--;\n+\t}\n+    }\n+\n+  /* If there were no memory operations, allow the insn */\n+  if (mem_mask == 0)\n+    return true;\n+\n+  /* Do not allow the destination register to be a memory operand.  */\n+  else if (mem_mask & (1 << 0))\n+    return false;\n+\n+  /* If there are too many memory operations, disallow the instruction.  While\n+     the hardware only allows 1 memory reference, before register allocation\n+     for some insns, we allow two memory operations sometimes in order to allow\n+     code like the following to be optimized:\n+\n+\tfloat fmadd (float *a, float *b, float *c) { return (*a * *b) + *c; }\n+\n+    or similar cases that are vectorized into using the vfmaddss\n+    instruction.  */\n+  else if (mem_count > num_memory)\n+    return false;\n+\n+  /* Don't allow more than one memory operation if not optimizing.  */\n+  else if (mem_count > 1 && !optimize)\n+    return false;\n+\n+  else if (num == 4 && mem_count == 1)\n+    {\n+      /* formats (destination is the first argument), example vfmaddss:\n+\t xmm1, xmm1, xmm2, xmm3/mem\n+\t xmm1, xmm1, xmm2/mem, xmm3\n+\t xmm1, xmm2, xmm3/mem, xmm1\n+\t xmm1, xmm2/mem, xmm3, xmm1 */\n+      if (uses_oc0)\n+\treturn ((mem_mask == (1 << 1))\n+\t\t|| (mem_mask == (1 << 2))\n+\t\t|| (mem_mask == (1 << 3)));\n+\n+      /* format, example vpmacsdd:\n+\t xmm1, xmm2, xmm3/mem, xmm1 */\n+      if (commutative)\n+\treturn (mem_mask == (1 << 2) || mem_mask == (1 << 1));\n+      else\n+\treturn (mem_mask == (1 << 2));\n+    }\n+\n+  else if (num == 4 && num_memory == 2)\n+    {\n+      /* If there are two memory operations, we can load one of the memory ops\n+\t into the destination register.  This is for optimizing the\n+\t multiply/add ops, which the combiner has optimized both the multiply\n+\t and the add insns to have a memory operation.  We have to be careful\n+\t that the destination doesn't overlap with the inputs.  */\n+      rtx op0 = operands[0];\n+\n+      if (reg_mentioned_p (op0, operands[1])\n+\t  || reg_mentioned_p (op0, operands[2])\n+\t  || reg_mentioned_p (op0, operands[3]))\n+\treturn false;\n+\n+      /* formats (destination is the first argument), example vfmaddss:\n+\t xmm1, xmm1, xmm2, xmm3/mem\n+\t xmm1, xmm1, xmm2/mem, xmm3\n+\t xmm1, xmm2, xmm3/mem, xmm1\n+\t xmm1, xmm2/mem, xmm3, xmm1\n+\n+         For the oc0 case, we will load either operands[1] or operands[3] into\n+         operands[0], so any combination of 2 memory operands is ok.  */\n+      if (uses_oc0)\n+\treturn true;\n+\n+      /* format, example vpmacsdd:\n+\t xmm1, xmm2, xmm3/mem, xmm1\n+\n+         For the integer multiply/add instructions be more restrictive and\n+         require operands[2] and operands[3] to be the memory operands.  */\n+      if (commutative)\n+\treturn (mem_mask == ((1 << 1) | (1 << 3)) || ((1 << 2) | (1 << 3)));\n+      else\n+\treturn (mem_mask == ((1 << 2) | (1 << 3)));\n+    }\n+\n+  else if (num == 3 && num_memory == 1)\n+    {\n+      /* formats, example vprotb:\n+\t xmm1, xmm2, xmm3/mem\n+\t xmm1, xmm2/mem, xmm3 */\n+      if (uses_oc0)\n+\treturn ((mem_mask == (1 << 1)) || (mem_mask == (1 << 2)));\n+\n+      /* format, example vpcomeq:\n+\t xmm1, xmm2, xmm3/mem */\n+      else\n+\treturn (mem_mask == (1 << 2));\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  return false;\n+}\n+\n+\n+/* Fixup an FMA4 instruction that has 2 memory input references into a form the\n+   hardware will allow by using the destination register to load one of the\n+   memory operations.  Presently this is used by the multiply/add routines to\n+   allow 2 memory references.  */\n+\n+void\n+ix86_expand_fma4_multiple_memory (rtx operands[],\n+\t\t\t\t  int num,\n+\t\t\t\t  enum machine_mode mode)\n+{\n+  rtx op0 = operands[0];\n+  if (num != 4\n+      || memory_operand (op0, mode)\n+      || reg_mentioned_p (op0, operands[1])\n+      || reg_mentioned_p (op0, operands[2])\n+      || reg_mentioned_p (op0, operands[3]))\n+    gcc_unreachable ();\n+\n+  /* For 2 memory operands, pick either operands[1] or operands[3] to move into\n+     the destination register.  */\n+  if (memory_operand (operands[1], mode))\n+    {\n+      emit_move_insn (op0, operands[1]);\n+      operands[1] = op0;\n+    }\n+  else if (memory_operand (operands[3], mode))\n+    {\n+      emit_move_insn (op0, operands[3]);\n+      operands[3] = op0;\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return;\n+}\n+\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ix86_attribute_table[] =\n {"}, {"sha": "8d525727eec4a2a7cb4f9122afda20667be85967", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -54,6 +54,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_AVX\tOPTION_ISA_AVX\n #define TARGET_FMA\tOPTION_ISA_FMA\n #define TARGET_SSE4A\tOPTION_ISA_SSE4A\n+#define TARGET_FMA4\tOPTION_ISA_FMA4\n #define TARGET_ROUND\tOPTION_ISA_ROUND\n #define TARGET_ABM\tOPTION_ISA_ABM\n #define TARGET_POPCNT\tOPTION_ISA_POPCNT\n@@ -65,8 +66,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_CMPXCHG16B OPTION_ISA_CX16\n \n \n-/* SSE4.1 define round instructions */\n-#define\tOPTION_MASK_ISA_ROUND\t(OPTION_MASK_ISA_SSE4_1)\n+/* SSE4.1 defines round instructions */\n+#define\tOPTION_MASK_ISA_ROUND\tOPTION_MASK_ISA_SSE4_1\n #define\tOPTION_ISA_ROUND\t((ix86_isa_flags & OPTION_MASK_ISA_ROUND) != 0)\n \n #include \"config/vxworks-dummy.h\"\n@@ -1351,6 +1352,10 @@ enum reg_class\n   (TARGET_AVX && ((MODE) == V4SFmode || (MODE) == V2DFmode \\\n \t\t  || (MODE) == V8SFmode || (MODE) == V4DFmode))\n \n+#define FMA4_VEC_FLOAT_MODE_P(MODE) \\\n+  (TARGET_FMA4 && ((MODE) == V4SFmode || (MODE) == V2DFmode \\\n+\t\t  || (MODE) == V8SFmode || (MODE) == V4DFmode))\n+\n #define MMX_REG_P(XOP) (REG_P (XOP) && MMX_REGNO_P (REGNO (XOP)))\n #define MMX_REGNO_P(N) IN_RANGE ((N), FIRST_MMX_REG, LAST_MMX_REG)\n "}, {"sha": "5c2564e273428e36dbcd7ba3265cb983101f3006", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -195,6 +195,10 @@\n    (UNSPEC_PCMPESTR\t\t144)\n    (UNSPEC_PCMPISTR\t\t145)\n \n+   ; For FMA4 support\n+   (UNSPEC_FMA4_INTRINSIC\t150)\n+   (UNSPEC_FMA4_FMADDSUB\t151)\n+   (UNSPEC_FMA4_FMSUBADD\t152)\n    ; For AES support\n    (UNSPEC_AESENC\t\t159)\n    (UNSPEC_AESENCLAST\t\t160)"}, {"sha": "9668ff6504d64600e56717cae29db67cc8174355", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -310,6 +310,10 @@ msse4a\n Target Report Mask(ISA_SSE4A) Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE, SSE2, SSE3 and SSE4A built-in functions and code generation\n \n+mfma4\n+Target Report Mask(ISA_FMA4) Var(ix86_isa_flags) VarExists Save\n+Support FMA4 built-in functions and code generation \n+\n mabm\n Target Report Mask(ISA_ABM) Var(ix86_isa_flags) VarExists Save\n Support code generation of Advanced Bit Manipulation (ABM) instructions."}, {"sha": "e90296512adac9346955cd2eab4f6890b578ca0e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 936, "deletions": 0, "changes": 936, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -49,6 +49,7 @@\n (define_mode_iterator SSEMODE248 [V8HI V4SI V2DI])\n (define_mode_iterator SSEMODE1248 [V16QI V8HI V4SI V2DI])\n (define_mode_iterator SSEMODEF4 [SF DF V4SF V2DF])\n+(define_mode_iterator FMA4MODEF4 [V8SF V4DF])\n (define_mode_iterator SSEMODEF2P [V4SF V2DF])\n \n (define_mode_iterator AVX256MODEF2P [V8SF V4DF])\n@@ -74,6 +75,11 @@\n ;; Mapping from integer vector mode to mnemonic suffix\n (define_mode_attr ssevecsize [(V16QI \"b\") (V8HI \"w\") (V4SI \"d\") (V2DI \"q\")])\n \n+;; Mapping of the fma4 suffix\n+(define_mode_attr fma4modesuffixf4 [(V8SF \"ps\") (V4DF \"pd\")])\n+(define_mode_attr ssemodesuffixf2s [(SF \"ss\") (DF \"sd\")\n+\t\t\t\t    (V4SF \"ss\") (V2DF \"sd\")])\n+\n ;; Mapping of the avx suffix\n (define_mode_attr ssemodesuffixf4 [(SF \"ss\") (DF \"sd\")\n \t\t\t\t   (V4SF \"ps\") (V2DF \"pd\")])\n@@ -1659,6 +1665,936 @@\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"<ssevecmode>\")])\n \n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; FMA4 floating point multiply/accumulate instructions This includes the\n+;; scalar version of the instructions as well as the vector\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; In order to match (*a * *b) + *c, particularly when vectorizing, allow\n+;; combine to generate a multiply/add with two memory references.  We then\n+;; split this insn, into loading up the destination register with one of the\n+;; memory operations.  If we don't manage to split the insn, reload will\n+;; generate the appropriate moves.  The reason this is needed, is that combine\n+;; has already folded one of the memory references into both the multiply and\n+;; add insns, and it can't generate a new pseudo.  I.e.:\n+;;\t(set (reg1) (mem (addr1)))\n+;;\t(set (reg2) (mult (reg1) (mem (addr2))))\n+;;\t(set (reg3) (plus (reg2) (mem (addr3))))\n+\n+(define_insn \"fma4_fmadd<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x,x\")\n+\t(plus:FMA4MODEF4\n+\t (mult:FMA4MODEF4\n+\t  (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm,x\"))\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x,x\")))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmadd<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fmadd with two memory operands into a load and the fmadd.\n+(define_split\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"\")\n+\t(plus:FMA4MODEF4\n+\t (mult:FMA4MODEF4\n+\t  (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fmadd<mode>4256 (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;; Floating multiply and subtract\n+;; Allow two memory operands the same as fmadd\n+(define_insn \"fma4_fmsub<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x,x\")\n+\t(minus:FMA4MODEF4\n+\t (mult:FMA4MODEF4\n+\t  (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm,x\"))\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x,x\")))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsub<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fmsub with two memory operands into a load and the fmsub.\n+(define_split\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"\")\n+\t(minus:FMA4MODEF4\n+\t (mult:FMA4MODEF4\n+\t  (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fmsub<mode>4256 (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;; Floating point negative multiply and add\n+;; Rewrite (- (a * b) + c) into the canonical form: c - (a * b)\n+;; Note operands are out of order to simplify call to ix86_fma4_valid_p\n+;; Allow two memory operands to help in optimizing.\n+(define_insn \"fma4_fnmadd<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x,x\")\n+\t(minus:FMA4MODEF4\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x,x\")\n+\t (mult:FMA4MODEF4\n+\t  (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm,x\"))))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfnmadd<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fnmadd with two memory operands into a load and the fnmadd.\n+(define_split\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"\")\n+\t(minus:FMA4MODEF4\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"\")\n+\t (mult:FMA4MODEF4\n+\t  (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"\"))))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fnmadd<mode>4256 (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;; Floating point negative multiply and subtract\n+;; Rewrite (- (a * b) - c) into the canonical form: ((-a) * b) - c\n+;; Allow 2 memory operands to help with optimization\n+(define_insn \"fma4_fnmsub<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x\")\n+\t(minus:FMA4MODEF4\n+\t (mult:FMA4MODEF4\n+\t  (neg:FMA4MODEF4\n+\t   (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x\"))\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x\")))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, false)\"\n+  \"vfnmsub<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fnmsub with two memory operands into a load and the fmsub.\n+(define_split\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"\")\n+\t(minus:FMA4MODEF4\n+\t (mult:FMA4MODEF4\n+\t  (neg:FMA4MODEF4\n+\t   (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"\"))\n+\t  (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, false)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fnmsub<mode>4256 (operands[0], operands[1],\n+\t\t\t\t        operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+(define_insn \"fma4_fmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"=x,x,x\")\n+\t(plus:SSEMODEF4\n+\t (mult:SSEMODEF4\n+\t  (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"x,xm,x\"))\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"xm,x,x\")))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmadd<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fmadd with two memory operands into a load and the fmadd.\n+(define_split\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"\")\n+\t(plus:SSEMODEF4\n+\t (mult:SSEMODEF4\n+\t  (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fmadd<mode>4 (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;; For the scalar operations, use operand1 for the upper words that aren't\n+;; modified, so restrict the forms that are generated.\n+;; Scalar version of fmadd\n+(define_insn \"fma4_vmfmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:SSEMODEF2P\n+\t (plus:SSEMODEF2P\n+\t  (mult:SSEMODEF2P\n+\t   (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\")\n+\t   (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t  (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t (match_dup 0)\n+\t (const_int 1)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfmadd<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Floating multiply and subtract\n+;; Allow two memory operands the same as fmadd\n+(define_insn \"fma4_fmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"=x,x,x\")\n+\t(minus:SSEMODEF4\n+\t (mult:SSEMODEF4\n+\t  (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"x,xm,x\"))\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"xm,x,x\")))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsub<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fmsub with two memory operands into a load and the fmsub.\n+(define_split\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"\")\n+\t(minus:SSEMODEF4\n+\t (mult:SSEMODEF4\n+\t  (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fmsub<mode>4 (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;; For the scalar operations, use operand1 for the upper words that aren't\n+;; modified, so restrict the forms that are generated.\n+;; Scalar version of fmsub\n+(define_insn \"fma4_vmfmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:SSEMODEF2P\n+\t (minus:SSEMODEF2P\n+\t  (mult:SSEMODEF2P\n+\t   (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\")\n+\t   (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t  (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t (match_dup 0)\n+\t (const_int 1)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vfmsub<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Floating point negative multiply and add\n+;; Rewrite (- (a * b) + c) into the canonical form: c - (a * b)\n+;; Note operands are out of order to simplify call to ix86_fma4_valid_p\n+;; Allow two memory operands to help in optimizing.\n+(define_insn \"fma4_fnmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"=x,x,x\")\n+\t(minus:SSEMODEF4\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"xm,x,x\")\n+\t (mult:SSEMODEF4\n+\t  (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"x,xm,x\"))))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfnmadd<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fnmadd with two memory operands into a load and the fnmadd.\n+(define_split\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"\")\n+\t(minus:SSEMODEF4\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"\")\n+\t (mult:SSEMODEF4\n+\t  (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"\"))))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fnmadd<mode>4 (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;; For the scalar operations, use operand1 for the upper words that aren't\n+;; modified, so restrict the forms that are generated.\n+;; Scalar version of fnmadd\n+(define_insn \"fma4_vmfnmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:SSEMODEF2P\n+\t (minus:SSEMODEF2P\n+\t  (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\")\n+\t  (mult:SSEMODEF2P\n+\t   (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\")\n+\t   (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\")))\n+\t (match_dup 0)\n+\t (const_int 1)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfnmadd<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Floating point negative multiply and subtract\n+;; Rewrite (- (a * b) - c) into the canonical form: ((-a) * b) - c\n+;; Allow 2 memory operands to help with optimization\n+(define_insn \"fma4_fnmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"=x,x\")\n+\t(minus:SSEMODEF4\n+\t (mult:SSEMODEF4\n+\t  (neg:SSEMODEF4\n+\t   (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"x,x\"))\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"xm,x\")))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, false)\"\n+  \"vfnmsub<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Split fnmsub with two memory operands into a load and the fmsub.\n+(define_split\n+  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"\")\n+\t(minus:SSEMODEF4\n+\t (mult:SSEMODEF4\n+\t  (neg:SSEMODEF4\n+\t   (match_operand:SSEMODEF4 1 \"nonimmediate_operand\" \"\"))\n+\t  (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:SSEMODEF4 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_FMA4\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, false)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, <MODE>mode);\n+  emit_insn (gen_fma4_fnmsub<mode>4 (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+  DONE;\n+})\n+\n+;; For the scalar operations, use operand1 for the upper words that aren't\n+;; modified, so restrict the forms that are generated.\n+;; Scalar version of fnmsub\n+(define_insn \"fma4_vmfnmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:SSEMODEF2P\n+\t (minus:SSEMODEF2P\n+\t  (mult:SSEMODEF2P\n+\t   (neg:SSEMODEF2P\n+\t    (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\"))\n+\t   (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t  (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t (match_dup 0)\n+\t (const_int 1)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, false)\"\n+  \"vfnmsub<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn \"fma4i_fmadd<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x\")\n+\t(unspec:FMA4MODEF4\n+\t [(plus:FMA4MODEF4\n+\t   (mult:FMA4MODEF4\n+\t    (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x\")\n+\t    (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t   (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x\"))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfmadd<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fma4i_fmsub<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x\")\n+\t(unspec:FMA4MODEF4\n+\t [(minus:FMA4MODEF4\n+\t   (mult:FMA4MODEF4\n+\t    (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x\")\n+\t    (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t   (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x\"))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfmsub<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fma4i_fnmadd<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x\")\n+\t(unspec:FMA4MODEF4\n+\t [(minus:FMA4MODEF4\n+\t   (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x\")\n+\t   (mult:FMA4MODEF4\n+\t    (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x\")\n+\t    (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm\")))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfnmadd<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fma4i_fnmsub<mode>4256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x,x\")\n+\t(unspec:FMA4MODEF4\n+\t [(minus:FMA4MODEF4\n+\t   (mult:FMA4MODEF4\n+\t    (neg:FMA4MODEF4\n+\t     (match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"x,x\"))\n+\t    (match_operand:FMA4MODEF4 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t   (match_operand:FMA4MODEF4 3 \"nonimmediate_operand\" \"xm,x\"))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vfnmsub<fma4modesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn \"fma4i_fmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(plus:SSEMODEF2P\n+\t   (mult:SSEMODEF2P\n+\t    (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\")\n+\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t   (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfmadd<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fma4i_fmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(minus:SSEMODEF2P\n+\t   (mult:SSEMODEF2P\n+\t    (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\")\n+\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t   (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfmsub<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fma4i_fnmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(minus:SSEMODEF2P\n+\t   (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\")\n+\t   (mult:SSEMODEF2P\n+\t    (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\")\n+\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\")))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfnmadd<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fma4i_fnmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(minus:SSEMODEF2P\n+\t   (mult:SSEMODEF2P\n+\t    (neg:SSEMODEF2P\n+\t     (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\"))\n+\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t   (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vfnmsub<ssemodesuffixf4>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; For the scalar operations, use operand1 for the upper words that aren't\n+;; modified, so restrict the forms that are accepted.\n+(define_insn \"fma4i_vmfmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(vec_merge:SSEMODEF2P\n+\t   (plus:SSEMODEF2P\n+\t    (mult:SSEMODEF2P\n+\t     (match_operand:SSEMODEF2P 1 \"register_operand\" \"x,x\")\n+\t     (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (match_dup 0)\n+\t   (const_int 1))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vfmadd<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<ssescalarmode>\")])\n+\n+(define_insn \"fma4i_vmfmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(vec_merge:SSEMODEF2P\n+\t   (minus:SSEMODEF2P\n+\t    (mult:SSEMODEF2P\n+\t     (match_operand:SSEMODEF2P 1 \"register_operand\" \"x,x\")\n+\t     (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (match_dup 0)\n+\t   (const_int 1))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vfmsub<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<ssescalarmode>\")])\n+\n+(define_insn \"fma4i_vmfnmadd<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(vec_merge:SSEMODEF2P\n+\t   (minus:SSEMODEF2P\n+\t    (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\")\n+\t    (mult:SSEMODEF2P\n+\t     (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"x,x\")\n+\t     (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\")))\n+\t   (match_dup 0)\n+\t   (const_int 1))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, true)\"\n+  \"vfnmadd<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<ssescalarmode>\")])\n+\n+(define_insn \"fma4i_vmfnmsub<mode>4\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n+\t(unspec:SSEMODEF2P\n+\t [(vec_merge:SSEMODEF2P\n+\t   (minus:SSEMODEF2P\n+\t    (mult:SSEMODEF2P\n+\t     (neg:SSEMODEF2P\n+\t      (match_operand:SSEMODEF2P 1 \"register_operand\" \"x,x\"))\n+\t     (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:SSEMODEF2P 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (match_dup 0)\n+\t   (const_int 1))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4 && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vfnmsub<ssemodesuffixf2s>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"<ssescalarmode>\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; FMA4 Parallel floating point multiply addsub and subadd operations\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn \"fma4_fmaddsubv8sf4\"\n+  [(set (match_operand:V8SF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V8SF\n+\t  (plus:V8SF\n+\t    (mult:V8SF\n+\t      (match_operand:V8SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V8SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V8SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V8SF\n+\t    (mult:V8SF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 170)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V8SF\")])\n+\n+(define_insn \"fma4_fmaddsubv4df4\"\n+  [(set (match_operand:V4DF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V4DF\n+\t  (plus:V4DF\n+\t    (mult:V4DF\n+\t      (match_operand:V4DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V4DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V4DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V4DF\n+\t    (mult:V4DF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 10)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4DF\")])\n+\n+(define_insn \"fma4_fmaddsubv4sf4\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V4SF\n+\t  (plus:V4SF\n+\t    (mult:V4SF\n+\t      (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V4SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V4SF\n+\t    (mult:V4SF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 10)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"fma4_fmaddsubv2df4\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V2DF\n+\t  (plus:V2DF\n+\t    (mult:V2DF\n+\t      (match_operand:V2DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V2DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V2DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V2DF\n+\t    (mult:V2DF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 2)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"fma4_fmsubaddv8sf4\"\n+  [(set (match_operand:V8SF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V8SF\n+\t  (plus:V8SF\n+\t    (mult:V8SF\n+\t      (match_operand:V8SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V8SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V8SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V8SF\n+\t    (mult:V8SF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 85)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V8SF\")])\n+\n+(define_insn \"fma4_fmsubaddv4df4\"\n+  [(set (match_operand:V4DF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V4DF\n+\t  (plus:V4DF\n+\t    (mult:V4DF\n+\t      (match_operand:V4DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V4DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V4DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V4DF\n+\t    (mult:V4DF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 5)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4DF\")])\n+\n+(define_insn \"fma4_fmsubaddv4sf4\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V4SF\n+\t  (plus:V4SF\n+\t    (mult:V4SF\n+\t      (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V4SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V4SF\n+\t    (mult:V4SF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 5)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"fma4_fmsubaddv2df4\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V2DF\n+\t  (plus:V2DF\n+\t    (mult:V2DF\n+\t      (match_operand:V2DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t      (match_operand:V2DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t    (match_operand:V2DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t  (minus:V2DF\n+\t    (mult:V2DF\n+\t      (match_dup 1)\n+\t      (match_dup 2))\n+\t    (match_dup 3))\n+\t  (const_int 1)))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn \"fma4i_fmaddsubv8sf4\"\n+  [(set (match_operand:V8SF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V8SF\n+\t [(vec_merge:V8SF\n+\t   (plus:V8SF\n+\t     (mult:V8SF\n+\t       (match_operand:V8SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V8SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V8SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V8SF\n+\t     (mult:V8SF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 170))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V8SF\")])\n+\n+(define_insn \"fma4i_fmaddsubv4df4\"\n+  [(set (match_operand:V4DF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V4DF\n+\t [(vec_merge:V4DF\n+\t   (plus:V4DF\n+\t     (mult:V4DF\n+\t       (match_operand:V4DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V4DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V4DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V4DF\n+\t     (mult:V4DF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 10))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4DF\")])\n+\n+(define_insn \"fma4i_fmaddsubv4sf4\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V4SF\n+\t [(vec_merge:V4SF\n+\t   (plus:V4SF\n+\t     (mult:V4SF\n+\t       (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V4SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V4SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V4SF\n+\t     (mult:V4SF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 10))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"fma4i_fmaddsubv2df4\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V2DF\n+\t [(vec_merge:V2DF\n+\t   (plus:V2DF\n+\t     (mult:V2DF\n+\t       (match_operand:V2DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V2DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V2DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V2DF\n+\t     (mult:V2DF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 2))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmaddsubpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"fma4i_fmsubaddv8sf4\"\n+  [(set (match_operand:V8SF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V8SF\n+\t [(vec_merge:V8SF\n+\t   (plus:V8SF\n+\t     (mult:V8SF\n+\t       (match_operand:V8SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V8SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V8SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V8SF\n+\t     (mult:V8SF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 85))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V8SF\")])\n+\n+(define_insn \"fma4i_fmsubaddv4df4\"\n+  [(set (match_operand:V4DF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V4DF\n+\t [(vec_merge:V4DF\n+\t   (plus:V4DF\n+\t     (mult:V4DF\n+\t       (match_operand:V4DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V4DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V4DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V4DF\n+\t     (mult:V4DF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 5))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4DF\")])\n+\n+(define_insn \"fma4i_fmsubaddv4sf4\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V4SF\n+\t [(vec_merge:V4SF\n+\t   (plus:V4SF\n+\t     (mult:V4SF\n+\t       (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V4SF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V4SF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V4SF\n+\t     (mult:V4SF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 5))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddps\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"fma4i_fmsubaddv2df4\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:V2DF\n+\t [(vec_merge:V2DF\n+\t   (plus:V2DF\n+\t     (mult:V2DF\n+\t       (match_operand:V2DF 1 \"nonimmediate_operand\" \"x,x\")\n+\t       (match_operand:V2DF 2 \"nonimmediate_operand\" \"x,xm\"))\n+\t     (match_operand:V2DF 3 \"nonimmediate_operand\" \"xm,x\"))\n+\t   (minus:V2DF\n+\t     (mult:V2DF\n+\t       (match_dup 1)\n+\t       (match_dup 2))\n+\t     (match_dup 3))\n+\t   (const_int 1))]\n+\t UNSPEC_FMA4_INTRINSIC))]\n+  \"TARGET_FMA4\n+   && ix86_fma4_valid_op_p (operands, insn, 4, true, 2, true)\"\n+  \"vfmsubaddpd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel single-precision floating point conversion operations"}, {"sha": "7bc47f8f15d9f1eaa2ac4777bc20312afc430ee8", "filename": "gcc/config/i386/x86intrin.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fx86intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fconfig%2Fi386%2Fx86intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86intrin.h?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -46,14 +46,18 @@\n #include <tmmintrin.h>\n #endif\n \n-#ifdef __SSE4a__\n+#ifdef __SSE4A__\n #include <ammintrin.h>\n #endif\n \n #if defined (__SSE4_2__) || defined (__SSE4_1__)\n #include <smmintrin.h>\n #endif\n \n+#ifdef __FMA4__\n+#include <fma4intrin.h>\n+#endif\n+\n #if defined (__AES__) || defined (__PCLMUL__)\n #include <wmmintrin.h>\n #endif"}, {"sha": "6f0955577c3c97d446219eaa95f4fc946a05074b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -3168,6 +3168,11 @@ Enable/disable the generation of the sse4.2 instructions.\n @cindex @code{target(\"sse4a\")} attribute\n Enable/disable the generation of the SSE4A instructions.\n \n+@item fma4\n+@itemx no-fma4\n+@cindex @code{target(\"fma4\")} attribute\n+Enable/disable the generation of the FMA4 instructions.\n+\n @item ssse3\n @itemx no-ssse3\n @cindex @code{target(\"ssse3\")} attribute\n@@ -8888,6 +8893,46 @@ v2di __builtin_ia32_insertq (v2di, v2di)\n v2di __builtin_ia32_insertqi (v2di, v2di, const unsigned int, const unsigned int)\n @end smallexample\n \n+The following built-in functions are available when @option{-mfma4} is used.\n+All of them generate the machine instruction that is part of the name\n+with MMX registers.\n+\n+@smallexample\n+v2df __builtin_ia32_fmaddpd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fmaddps (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fmaddsd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fmaddss (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fmsubpd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fmsubps (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fmsubsd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fmsubss (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fnmaddpd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fnmaddps (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fnmaddsd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fnmaddss (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fnmsubpd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fnmsubps (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fnmsubsd (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fnmsubss (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fmaddsubpd  (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fmaddsubps  (v4sf, v4sf, v4sf)\n+v2df __builtin_ia32_fmsubaddpd  (v2df, v2df, v2df)\n+v4sf __builtin_ia32_fmsubaddps  (v4sf, v4sf, v4sf)\n+v4df __builtin_ia32_fmaddpd256 (v4df, v4df, v4df)\n+v8sf __builtin_ia32_fmaddps256 (v8sf, v8sf, v8sf)\n+v4df __builtin_ia32_fmsubpd256 (v4df, v4df, v4df)\n+v8sf __builtin_ia32_fmsubps256 (v8sf, v8sf, v8sf)\n+v4df __builtin_ia32_fnmaddpd256 (v4df, v4df, v4df)\n+v8sf __builtin_ia32_fnmaddps256 (v8sf, v8sf, v8sf)\n+v4df __builtin_ia32_fnmsubpd256 (v4df, v4df, v4df)\n+v8sf __builtin_ia32_fnmsubps256 (v8sf, v8sf, v8sf)\n+v4df __builtin_ia32_fmaddsubpd256 (v4df, v4df, v4df)\n+v8sf __builtin_ia32_fmaddsubps256 (v8sf, v8sf, v8sf)\n+v4df __builtin_ia32_fmsubaddpd256 (v4df, v4df, v4df)\n+v8sf __builtin_ia32_fmsubaddps256 (v8sf, v8sf, v8sf)\n+\n+@end smallexample\n+\n The following built-in functions are available when @option{-m3dnow} is used.\n All of them generate the machine instruction that is part of the name.\n "}, {"sha": "e12241c97c1af782d421fa39b511097087d452f6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -592,7 +592,7 @@ Objective-C and Objective-C++ Dialects}.\n -mcld -mcx16 -msahf -mmovbe -mcrc32 -mrecip @gol\n -mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 -mavx @gol\n -maes -mpclmul @gol\n--msse4a -m3dnow -mpopcnt -mabm @gol\n+-msse4a -m3dnow -mpopcnt -mabm -mfma4 @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n@@ -11727,6 +11727,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mno-pclmul\n @itemx -msse4a\n @itemx -mno-sse4a\n+@itemx -mfma4\n+@itemx -mno-fma4\n @itemx -m3dnow\n @itemx -mno-3dnow\n @itemx -mpopcnt\n@@ -11740,7 +11742,7 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @opindex m3dnow\n @opindex mno-3dnow\n These switches enable or disable the use of instructions in the MMX,\n-SSE, SSE2, SSE3, SSSE3, SSE4.1, AVX, AES, PCLMUL, SSE4A, ABM or\n+SSE, SSE2, SSE3, SSSE3, SSE4.1, AVX, AES, PCLMUL, SSE4A, FMA4, ABM or\n 3DNow!@: extended instruction sets.\n These extensions are also available as built-in functions: see\n @ref{X86 Built-in Functions}, for details of the functions enabled and"}, {"sha": "8128a9092ceac3f1426f9885d38286da613309e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,3 +1,56 @@\n+2009-09-29  Harsha Jagasia  <harsha.jagasia@amd.com>\n+\n+\t* gcc.target/i386/fma4-check.h\n+\t* gcc.target/i386/fma4-fma.c\n+\t* gcc.target/i386/fma4-maccXX.c\n+\t* gcc.target/i386/fma4-msubXX.c\n+\t* gcc.target/i386/fma4-nmaccXX.c\n+\t* gcc.target/i386/fma4-nmsubXX.c\n+\t* gcc.target/i386/fma4-vector.c\n+\t* gcc.target/i386/fma4-256-maccXX.c\n+\t* gcc.target/i386/fma4-256-msubXX.c\n+\t* gcc.target/i386/fma4-256-nmaccXX.c\n+\t* gcc.target/i386/fma4-256-nmsubXX.c\n+\t* gcc.target/i386/fma4-256-vector.c\n+\t* gcc.target/i386/funcspec-2.c: New file.\n+\n+\t* gcc.target/i386/funcspec-4.c: Test error conditions\n+\trelated to FMA4.\n+\n+\t* gcc.target/i386/funcspec-5.c\n+\t* gcc.target/i386/funcspec-6.c\n+\t* gcc.target/i386/funcspec-8.c: Add FMA4.\n+\n+\t* gcc.target/i386/funcspec-9.c: New file.\n+\n+\t* gcc.target/i386/i386.exp: Add check_effective_target_fma4.\n+\n+\t* gcc.target/i386/isa-10.c\n+\t* gcc.target/i386/isa-11.c\n+\t* gcc.target/i386/isa-12.c\n+\t* gcc.target/i386/isa-13.c\n+\t* gcc.target/i386/isa-2.c\n+\t* gcc.target/i386/isa-3.c\n+\t* gcc.target/i386/isa-4.c\n+\t* gcc.target/i386/isa-7.c\n+\t* gcc.target/i386/isa-8.c\n+\t* gcc.target/i386/isa-9.c: New file.\n+\n+\t* gcc.target/i386/isa-14.c\n+\t* gcc.target/i386/isa-1.c\n+\t* gcc.target/i386/isa-5.c\n+\t* gcc.target/i386/isa-6.c: Add FMA4.\n+\n+\t* gcc.target/i386/sse-12.c\n+\t* gcc.target/i386/sse-13.c\n+\t* gcc.target/i386/sse-14.c\n+\t* gcc.target/i386/sse-22.c: New file.\n+\n+\t* g++.dg/other/i386-2.C\n+\t* g++.dg/other/i386-3.C\n+\t* g++.dg/other/i386-5.C\n+\t* g++.dg/other/i386-6.C: Add -mfma4 in dg-options.\n+\n 2009-09-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR testsuite/41496"}, {"sha": "4c9579d07cdd151b1405318c80627fc14e1eb6d0", "filename": "gcc/testsuite/g++.dg/other/i386-2.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,7 +1,7 @@\n-/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h and mm_malloc.h are\n-   usable with -O -pedantic-errors.  */\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+   mm_malloc.h are usable with -O -pedantic-errors.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -maes -mpclmul\" } */\n+/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n \n #include <x86intrin.h>\n "}, {"sha": "b9e89169ccb2391996bc1b9cbb21d37399c84339", "filename": "gcc/testsuite/g++.dg/other/i386-3.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,6 +1,6 @@\n-/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h and mm_malloc.h are\n-   usable with -O -fkeep-inline-functions.  */\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+    mm_malloc.h are usable with -O -fkeep-inline-functions.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -maes -mpclmul\" } */\n+/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n \n #include <x86intrin.h>"}, {"sha": "6dcb2d3b0d0f0fc7217a8dd0986225416298c82d", "filename": "gcc/testsuite/g++.dg/other/i386-5.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-5.C?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,6 +1,6 @@\n-/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h and mm_malloc.h are\n-   usable with -O -fkeep-inline-functions.  */\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+   mm_malloc.h are usable with -O -fkeep-inline-functions.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -maes -mpclmul\" } */\n+/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n \n #include <x86intrin.h>"}, {"sha": "4c9579d07cdd151b1405318c80627fc14e1eb6d0", "filename": "gcc/testsuite/g++.dg/other/i386-6.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-6.C?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,7 +1,7 @@\n-/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h and mm_malloc.h are\n-   usable with -O -pedantic-errors.  */\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+   mm_malloc.h are usable with -O -pedantic-errors.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -maes -mpclmul\" } */\n+/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n \n #include <x86intrin.h>\n "}, {"sha": "134200af72a904c7124fc65e58cb495280aabbba", "filename": "gcc/testsuite/gcc.target/i386/fma4-256-maccXX.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-maccXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-maccXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-maccXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O2 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m256 x[NUM];\n+  float f[NUM * 8];\n+  __m256d y[NUM];\n+  double d[NUM * 4];\n+} dst, res, src1, src2, src3;\n+\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_maccps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 8; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_maccpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_maccps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 8; i = i + 8)\n+    for (j = 0; j < 8; j++)\n+      {\n+\tres.f[i + j] = (src1.f[i + j] * src2.f[i + j]) + src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_maccpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.d[i + j] = (src1.d[i + j] * src2.d[i + j]) + src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_maccps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm256_macc_ps (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_maccps ()) \n+    abort ();\n+\n+  init_maccpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm256_macc_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_maccpd ()) \n+    abort ();  \n+}"}, {"sha": "d6cafb4d542e4bcb395b7cfc61250d6a0e248a43", "filename": "gcc/testsuite/gcc.target/i386/fma4-256-msubXX.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-msubXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-msubXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-msubXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O2 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m256 x[NUM];\n+  float f[NUM * 8];\n+  __m256d y[NUM];\n+  double d[NUM * 4];\n+} dst, res, src1, src2, src3;\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_msubps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 8; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_msubpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_msubps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 8; i = i + 8)\n+    for (j = 0; j < 8; j++)\n+      {\n+\tres.f[i + j] = (src1.f[i + j] * src2.f[i + j]) - src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_msubpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.d[i + j] = (src1.d[i + j] * src2.d[i + j]) - src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_msubps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm256_msub_ps (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_msubps ()) \n+    abort ();\n+\n+  init_msubpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm256_msub_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_msubpd ()) \n+    abort ();\n+  \n+}"}, {"sha": "261f302f2f705d545f3263d0982d1d4f63b31de0", "filename": "gcc/testsuite/gcc.target/i386/fma4-256-nmaccXX.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-nmaccXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-nmaccXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-nmaccXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O2 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m256 x[NUM];\n+  float f[NUM * 8];\n+  __m256d y[NUM];\n+  double d[NUM * 4];\n+} dst, res, src1, src2, src3;\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_nmaccps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 8; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_nmaccpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_nmaccps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 8; i = i + 8)\n+    for (j = 0; j < 8; j++)\n+      {\n+\tres.f[i + j] = - (src1.f[i + j] * src2.f[i + j]) + src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_nmaccpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.d[i + j] = - (src1.d[i + j] * src2.d[i + j]) + src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_nmaccps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm256_nmacc_ps (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_nmaccps ()) \n+    abort ();\n+  \n+  init_nmaccpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm256_nmacc_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_nmaccpd ()) \n+    abort ();\n+\n+}"}, {"sha": "3205715efec908230a0c3e33b80c908596b00f1f", "filename": "gcc/testsuite/gcc.target/i386/fma4-256-nmsubXX.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-nmsubXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-nmsubXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-nmsubXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O2 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m256 x[NUM];\n+  float f[NUM * 8];\n+  __m256d y[NUM];\n+  double d[NUM * 4];\n+} dst, res, src1, src2, src3;\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_nmsubps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 8; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_nmsubpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_nmsubps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 8; i = i + 8)\n+    for (j = 0; j < 8; j++)\n+      {\n+\tres.f[i + j] = - (src1.f[i + j] * src2.f[i + j]) - src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_nmsubpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.d[i + j] = - (src1.d[i + j] * src2.d[i + j]) - src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_nmsubps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm256_nmsub_ps (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_nmsubps (&dst.x[i], &src1.f[i * 4], &src2.f[i * 4], &src3.f[i * 4])) \n+    abort ();\n+\n+  init_nmsubpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm256_nmsub_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_nmsubpd (&dst.y[i], &src1.d[i * 2], &src2.d[i * 2], &src3.d[i * 2])) \n+    abort ();\n+\n+}"}, {"sha": "714b743186d77e766e0b1fc674c7cfba5a6293cc", "filename": "gcc/testsuite/gcc.target/i386/fma4-256-vector.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-256-vector.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,93 @@\n+/* Test that the compiler properly optimizes floating point multiply and add\n+   instructions vector into vfmaddps on FMA4 systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mfma4 -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef float     __m256  __attribute__ ((__vector_size__ (32), __may_alias__));\n+typedef double    __m256d __attribute__ ((__vector_size__ (32), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m256 f_align;\n+  __m256d d_align;\n+  float f[SIZE];\n+  double d[SIZE];\n+} a, b, c, d;\n+\n+void\n+flt_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.f[i] = (b.f[i] * c.f[i]) + d.f[i];\n+}\n+\n+void\n+dbl_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.d[i] = (b.d[i] * c.d[i]) + d.d[i];\n+}\n+\n+void\n+flt_mul_sub (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.f[i] = (b.f[i] * c.f[i]) - d.f[i];\n+}\n+\n+void\n+dbl_mul_sub (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.d[i] = (b.d[i] * c.d[i]) - d.d[i];\n+}\n+\n+void\n+flt_neg_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.f[i] = (-(b.f[i] * c.f[i])) + d.f[i];\n+}\n+\n+void\n+dbl_neg_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.d[i] = (-(b.d[i] * c.d[i])) + d.d[i];\n+}\n+\n+int main ()\n+{\n+  flt_mul_add ();\n+  flt_mul_sub ();\n+  flt_neg_mul_add ();\n+\n+  dbl_mul_add ();\n+  dbl_mul_sub ();\n+  dbl_neg_mul_add ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vfmaddps\" } } */\n+/* { dg-final { scan-assembler \"vfmaddpd\" } } */\n+/* { dg-final { scan-assembler \"vfmsubps\" } } */\n+/* { dg-final { scan-assembler \"vfmsubpd\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddps\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddpd\" } } */"}, {"sha": "76fcdef99b6e837dc2e33699fff16ea62e677b4d", "filename": "gcc/testsuite/gcc.target/i386/fma4-check.h", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-check.h?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,20 @@\n+#include <stdlib.h>\n+\n+#include \"cpuid.h\"\n+\n+static void fma4_test (void);\n+\n+int\n+main ()\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+ \n+  if (!__get_cpuid (0x80000001, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  /* Run FMA4 test only if host has FMA4 support.  */\n+  if (ecx & bit_FMA4)\n+    fma4_test ();\n+\n+  exit (0);\n+}"}, {"sha": "cb906916117ba1d580234b2c47e5ec1975a734af", "filename": "gcc/testsuite/gcc.target/i386/fma4-fma.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-fma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-fma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-fma.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,83 @@\n+/* Test that the compiler properly optimizes floating point multiply\n+   and add instructions into vfmaddss, vfmsubss, vfnmaddss,\n+   vfnmsubss on FMA4 systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mfma4\" } */\n+\n+extern void exit (int);\n+\n+float\n+flt_mul_add (float a, float b, float c)\n+{\n+  return (a * b) + c;\n+}\n+\n+double\n+dbl_mul_add (double a, double b, double c)\n+{\n+  return (a * b) + c;\n+}\n+\n+float\n+flt_mul_sub (float a, float b, float c)\n+{\n+  return (a * b) - c;\n+}\n+\n+double\n+dbl_mul_sub (double a, double b, double c)\n+{\n+  return (a * b) - c;\n+}\n+\n+float\n+flt_neg_mul_add (float a, float b, float c)\n+{\n+  return (-(a * b)) + c;\n+}\n+\n+double\n+dbl_neg_mul_add (double a, double b, double c)\n+{\n+  return (-(a * b)) + c;\n+}\n+\n+float\n+flt_neg_mul_sub (float a, float b, float c)\n+{\n+  return (-(a * b)) - c;\n+}\n+\n+double\n+dbl_neg_mul_sub (double a, double b, double c)\n+{\n+  return (-(a * b)) - c;\n+}\n+\n+float  f[10] = { 2, 3, 4 };\n+double d[10] = { 2, 3, 4 };\n+\n+int main ()\n+{\n+  f[3] = flt_mul_add (f[0], f[1], f[2]);\n+  f[4] = flt_mul_sub (f[0], f[1], f[2]);\n+  f[5] = flt_neg_mul_add (f[0], f[1], f[2]);\n+  f[6] = flt_neg_mul_sub (f[0], f[1], f[2]);\n+\n+  d[3] = dbl_mul_add (d[0], d[1], d[2]);\n+  d[4] = dbl_mul_sub (d[0], d[1], d[2]);\n+  d[5] = dbl_neg_mul_add (d[0], d[1], d[2]);\n+  d[6] = dbl_neg_mul_sub (d[0], d[1], d[2]);\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vfmaddss\" } } */\n+/* { dg-final { scan-assembler \"vfmaddsd\" } } */\n+/* { dg-final { scan-assembler \"vfmsubss\" } } */\n+/* { dg-final { scan-assembler \"vfmsubsd\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddss\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddsd\" } } */\n+/* { dg-final { scan-assembler \"vfnmsubss\" } } */\n+/* { dg-final { scan-assembler \"vfnmsubsd\" } } */"}, {"sha": "4b4c00596a795db10bb53f61705ce055c070975e", "filename": "gcc/testsuite/gcc.target/i386/fma4-maccXX.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-maccXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-maccXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-maccXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,136 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O0 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m128 x[NUM];\n+  float f[NUM * 4];\n+  __m128d y[NUM];\n+  double d[NUM * 2];\n+} dst, res, src1, src2, src3;\n+\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_maccps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_maccpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_maccps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.f[i + j] = (src1.f[i + j] * src2.f[i + j]) + src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_maccpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    for (j = 0; j < 2; j++)\n+      {\n+\tres.d[i + j] = (src1.d[i + j] * src2.d[i + j]) + src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+\n+static int\n+check_maccss ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i= i + 4)\n+    {\n+      res.f[i] = (src1.f[i] * src2.f[i]) + src3.f[i];\n+      if (dst.f[i] != res.f[i]) \n+\tcheck_fails++;\n+    }\t\n+  return check_fails++;\n+}\n+\n+static int\n+check_maccsd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    {\n+      res.d[i] = (src1.d[i] * src2.d[i]) + src3.d[i];\n+      if (dst.d[i] != res.d[i]) \n+\tcheck_fails++;\n+    }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_maccps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_macc_ps (src1.x[i], src2.x[i], src3.x[i]);\n+\n+  if (check_maccps ()) \n+    abort ();\n+\n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_macc_ss (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_maccss ()) \n+    abort ();\n+\n+  init_maccpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_macc_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_maccpd ()) \n+    abort ();\n+\n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_macc_sd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_maccsd ()) \n+    abort ();\n+\n+}"}, {"sha": "eed75580e8d32e198749a9f4b856afa6bb743437", "filename": "gcc/testsuite/gcc.target/i386/fma4-msubXX.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-msubXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-msubXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-msubXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,134 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O0 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m128 x[NUM];\n+  float f[NUM * 4];\n+  __m128d y[NUM];\n+  double d[NUM * 2];\n+} dst, res, src1, src2, src3;\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_msubps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_msubpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_msubps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.f[i + j] = (src1.f[i + j] * src2.f[i + j]) - src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_msubpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    for (j = 0; j < 2; j++)\n+      {\n+\tres.d[i + j] = (src1.d[i + j] * src2.d[i + j]) - src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+\n+static int\n+check_msubss ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    {\n+      res.f[i] = (src1.f[i] * src2.f[i]) - src3.f[i];\n+      if (dst.f[i] != res.f[i]) \n+\tcheck_fails++;\n+    }\t\n+  return check_fails++;\n+}\n+\n+static int\n+check_msubsd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    {\n+      res.d[i] = (src1.d[i] * src2.d[i]) - src3.d[i];\n+      if (dst.d[i] != res.d[i]) \n+\tcheck_fails++;\n+    }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_msubps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_msub_ps (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_msubps ()) \n+    abort ();\n+\n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_msub_ss (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_msubss ()) \n+    abort ();\n+\n+  init_msubpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_msub_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_msubpd ()) \n+    abort ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_msub_sd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_msubsd ()) \n+    abort ();\n+}"}, {"sha": "9abf74604777f03ed53a41b679915fbd57c0daa2", "filename": "gcc/testsuite/gcc.target/i386/fma4-nmaccXX.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-nmaccXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-nmaccXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-nmaccXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,137 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O0 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m128 x[NUM];\n+  float f[NUM * 4];\n+  __m128d y[NUM];\n+  double d[NUM * 2];\n+} dst, res, src1, src2, src3;\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_nmaccps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_nmaccpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_nmaccps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.f[i + j] = - (src1.f[i + j] * src2.f[i + j]) + src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_nmaccpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    for (j = 0; j < 2; j++)\n+      {\n+\tres.d[i + j] = - (src1.d[i + j] * src2.d[i + j]) + src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+\n+static int\n+check_nmaccss ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    {\n+      res.f[i] = - (src1.f[i] * src2.f[i]) + src3.f[i];\n+      if (dst.f[i] != res.f[i]) \n+\tcheck_fails++;\n+    }\t\n+  return check_fails++;\n+}\n+\n+static int\n+check_nmaccsd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    {\n+      res.d[i] = - (src1.d[i] * src2.d[i]) + src3.d[i];\n+      if (dst.d[i] != res.d[i]) \n+\tcheck_fails++;\n+    }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_nmaccps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_nmacc_ps (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_nmaccps ()) \n+    abort ();\n+  \n+\n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_nmacc_ss (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_nmaccss ()) \n+    abort ();\n+\n+  init_nmaccpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_nmacc_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_nmaccpd ()) \n+    abort ();\n+  \n+\n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_nmacc_sd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_nmaccsd ()) \n+    abort ();\n+\n+}"}, {"sha": "85fbecddb3daa71e4af83df649c9ebf4886b74b0", "filename": "gcc/testsuite/gcc.target/i386/fma4-nmsubXX.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-nmsubXX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-nmsubXX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-nmsubXX.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,137 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fma4 } */\n+/* { dg-options \"-O0 -mfma4\" } */\n+\n+#include \"fma4-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 20\n+\n+union\n+{\n+  __m128 x[NUM];\n+  float f[NUM * 4];\n+  __m128d y[NUM];\n+  double d[NUM * 2];\n+} dst, res, src1, src2, src3;\n+\n+/* Note that in macc*,msub*,mnmacc* and mnsub* instructions, the intermdediate \n+   product is not rounded, only the addition is rounded. */\n+\n+static void\n+init_nmsubps ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.f[i] = i;\n+      src2.f[i] = i + 10;\n+      src3.f[i] = i + 20;\n+    }\n+}\n+\n+static void\n+init_nmsubpd ()\n+{\n+  int i;\n+  for (i = 0; i < NUM * 4; i++)\n+    {\n+      src1.d[i] = i;\n+      src2.d[i] = i + 10;\n+      src3.d[i] = i + 20;\n+    }\n+}\n+\n+static int\n+check_nmsubps ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    for (j = 0; j < 4; j++)\n+      {\n+\tres.f[i + j] = - (src1.f[i + j] * src2.f[i + j]) - src3.f[i + j];\n+\tif (dst.f[i + j] != res.f[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+static int\n+check_nmsubpd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    for (j = 0; j < 2; j++)\n+      {\n+\tres.d[i + j] = - (src1.d[i + j] * src2.d[i + j]) - src3.d[i + j];\n+\tif (dst.d[i + j] != res.d[i + j]) \n+\t  check_fails++;\n+      }\n+  return check_fails++;\n+}\n+\n+\n+static int\n+check_nmsubss ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 4; i = i + 4)\n+    {\n+      res.f[i] = - (src1.f[i] * src2.f[i]) - src3.f[i];\n+      if (dst.f[i] != res.f[i]) \n+\tcheck_fails++;\n+    }\t\n+  return check_fails++;\n+}\n+\n+static int\n+check_nmsubsd ()\n+{\n+  int i, j, check_fails = 0;\n+  for (i = 0; i < NUM * 2; i = i + 2)\n+    {\n+      res.d[i] = - (src1.d[i] * src2.d[i]) - src3.d[i];\n+      if (dst.d[i] != res.d[i]) \n+\tcheck_fails++;\n+    }\n+  return check_fails++;\n+}\n+\n+static void\n+fma4_test (void)\n+{\n+  int i;\n+\n+  init_nmsubps ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_nmsub_ps (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_nmsubps (&dst.x[i], &src1.f[i * 4], &src2.f[i * 4], &src3.f[i * 4])) \n+    abort ();\n+  \n+\n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_nmsub_ss (src1.x[i], src2.x[i], src3.x[i]);\n+  \n+  if (check_nmsubss (&dst.x[i], &src1.f[i * 4], &src2.f[i * 4], &src3.f[i * 4])) \n+    abort ();\n+\n+  init_nmsubpd ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_nmsub_pd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_nmsubpd (&dst.y[i], &src1.d[i * 2], &src2.d[i * 2], &src3.d[i * 2])) \n+    abort ();\n+  \n+\n+  for (i = 0; i < NUM; i++)\n+    dst.y[i] = _mm_nmsub_sd (src1.y[i], src2.y[i], src3.y[i]);\n+  \n+  if (check_nmsubsd (&dst.y[i], &src1.d[i * 2], &src2.d[i * 2], &src3.d[i * 2])) \n+    abort ();\n+\n+}"}, {"sha": "df8463ea32a9434d8fa25a11119ebcadb728bb3c", "filename": "gcc/testsuite/gcc.target/i386/fma4-vector.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-vector.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,93 @@\n+/* Test that the compiler properly optimizes floating point multiply and add\n+   instructions vector into vfmaddps on FMA4 systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mfma4 -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef float     __m128  __attribute__ ((__vector_size__ (16), __may_alias__));\n+typedef double    __m128d __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128 f_align;\n+  __m128d d_align;\n+  float f[SIZE];\n+  double d[SIZE];\n+} a, b, c, d;\n+\n+void\n+flt_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.f[i] = (b.f[i] * c.f[i]) + d.f[i];\n+}\n+\n+void\n+dbl_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.d[i] = (b.d[i] * c.d[i]) + d.d[i];\n+}\n+\n+void\n+flt_mul_sub (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.f[i] = (b.f[i] * c.f[i]) - d.f[i];\n+}\n+\n+void\n+dbl_mul_sub (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.d[i] = (b.d[i] * c.d[i]) - d.d[i];\n+}\n+\n+void\n+flt_neg_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.f[i] = (-(b.f[i] * c.f[i])) + d.f[i];\n+}\n+\n+void\n+dbl_neg_mul_add (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.d[i] = (-(b.d[i] * c.d[i])) + d.d[i];\n+}\n+\n+int main ()\n+{\n+  flt_mul_add ();\n+  flt_mul_sub ();\n+  flt_neg_mul_add ();\n+\n+  dbl_mul_add ();\n+  dbl_mul_sub ();\n+  dbl_neg_mul_add ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vfmaddps\" } } */\n+/* { dg-final { scan-assembler \"vfmaddpd\" } } */\n+/* { dg-final { scan-assembler \"vfmsubps\" } } */\n+/* { dg-final { scan-assembler \"vfmsubpd\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddps\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddpd\" } } */"}, {"sha": "c132fc9a965154bb14bfbee96c35c90e9d6d720d", "filename": "gcc/testsuite/gcc.target/i386/funcspec-2.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-2.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,99 @@\n+/* Test whether using target specific options, we can generate FMA4 code.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -march=k8\" } */\n+\n+extern void exit (int);\n+\n+#define FMA4_ATTR __attribute__((__target__(\"fma4\")))\n+extern float  flt_mul_add     (float a, float b, float c) FMA4_ATTR;\n+extern float  flt_mul_sub     (float a, float b, float c) FMA4_ATTR;\n+extern float  flt_neg_mul_add (float a, float b, float c) FMA4_ATTR;\n+extern float  flt_neg_mul_sub (float a, float b, float c) FMA4_ATTR;\n+\n+extern double dbl_mul_add     (double a, double b, double c) FMA4_ATTR;\n+extern double dbl_mul_sub     (double a, double b, double c) FMA4_ATTR;\n+extern double dbl_neg_mul_add (double a, double b, double c) FMA4_ATTR;\n+extern double dbl_neg_mul_sub (double a, double b, double c) FMA4_ATTR;\n+\n+float\n+flt_mul_add (float a, float b, float c)\n+{\n+  return (a * b) + c;\n+}\n+\n+double\n+dbl_mul_add (double a, double b, double c)\n+{\n+  return (a * b) + c;\n+}\n+\n+float\n+flt_mul_sub (float a, float b, float c)\n+{\n+  return (a * b) - c;\n+}\n+\n+double\n+dbl_mul_sub (double a, double b, double c)\n+{\n+  return (a * b) - c;\n+}\n+\n+float\n+flt_neg_mul_add (float a, float b, float c)\n+{\n+  return (-(a * b)) + c;\n+}\n+\n+double\n+dbl_neg_mul_add (double a, double b, double c)\n+{\n+  return (-(a * b)) + c;\n+}\n+\n+float\n+flt_neg_mul_sub (float a, float b, float c)\n+{\n+  return (-(a * b)) - c;\n+}\n+\n+double\n+dbl_neg_mul_sub (double a, double b, double c)\n+{\n+  return (-(a * b)) - c;\n+}\n+\n+float  f[10] = { 2, 3, 4 };\n+double d[10] = { 2, 3, 4 };\n+\n+int main ()\n+{\n+  f[3] = flt_mul_add (f[0], f[1], f[2]);\n+  f[4] = flt_mul_sub (f[0], f[1], f[2]);\n+  f[5] = flt_neg_mul_add (f[0], f[1], f[2]);\n+  f[6] = flt_neg_mul_sub (f[0], f[1], f[2]);\n+\n+  d[3] = dbl_mul_add (d[0], d[1], d[2]);\n+  d[4] = dbl_mul_sub (d[0], d[1], d[2]);\n+  d[5] = dbl_neg_mul_add (d[0], d[1], d[2]);\n+  d[6] = dbl_neg_mul_sub (d[0], d[1], d[2]);\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vfmaddss\" } } */\n+/* { dg-final { scan-assembler \"vfmaddsd\" } } */\n+/* { dg-final { scan-assembler \"vfmsubss\" } } */\n+/* { dg-final { scan-assembler \"vfmsubsd\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddss\" } } */\n+/* { dg-final { scan-assembler \"vfnmaddsd\" } } */\n+/* { dg-final { scan-assembler \"vfnmsubss\" } } */\n+/* { dg-final { scan-assembler \"vfnmsubsd\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_mul_sub\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_neg_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_neg_mul_sub\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_mul_sub\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_neg_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_neg_mul_sub\" } } */"}, {"sha": "025b97dff8e1cee72641647537f4baf174e5a21f", "filename": "gcc/testsuite/gcc.target/i386/funcspec-4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-4.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,6 +1,9 @@\n /* Test some error conditions with function specific options.  */\n /* { dg-do compile } */\n \n+/* no fma400 switch */\n+extern void error1 (void) __attribute__((__target__(\"fma400\"))); /* { dg-error \"unknown\" } */\n+\n /* Multiple arch switches */\n extern void error2 (void) __attribute__((__target__(\"arch=core2,arch=k8\"))); /* { dg-error \"already specified\" } */\n "}, {"sha": "34da51ceb9f1afba280d6024d5386356d6d3f24f", "filename": "gcc/testsuite/gcc.target/i386/funcspec-5.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-5.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -16,6 +16,7 @@ extern void test_sse4 (void)\t\t\t__attribute__((__target__(\"sse4\")));\n extern void test_sse4_1 (void)\t\t\t__attribute__((__target__(\"sse4.1\")));\n extern void test_sse4_2 (void)\t\t\t__attribute__((__target__(\"sse4.2\")));\n extern void test_sse4a (void)\t\t\t__attribute__((__target__(\"sse4a\")));\n+extern void test_fma4 (void)\t\t\t__attribute__((__target__(\"fma4\")));\n extern void test_ssse3 (void)\t\t\t__attribute__((__target__(\"ssse3\")));\n \n extern void test_no_abm (void)\t\t\t__attribute__((__target__(\"no-abm\")));\n@@ -31,6 +32,7 @@ extern void test_no_sse4 (void)\t\t\t__attribute__((__target__(\"no-sse4\")));\n extern void test_no_sse4_1 (void)\t\t__attribute__((__target__(\"no-sse4.1\")));\n extern void test_no_sse4_2 (void)\t\t__attribute__((__target__(\"no-sse4.2\")));\n extern void test_no_sse4a (void)\t\t__attribute__((__target__(\"no-sse4a\")));\n+extern void test_no_fma4 (void)\t\t\t__attribute__((__target__(\"no-fma4\")));\n extern void test_no_ssse3 (void)\t\t__attribute__((__target__(\"no-ssse3\")));\n \n extern void test_arch_i386 (void)\t\t__attribute__((__target__(\"arch=i386\")));"}, {"sha": "575be9bbbddce85b98db6b8fddfb0bdac22ca2f4", "filename": "gcc/testsuite/gcc.target/i386/funcspec-6.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-6.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -16,6 +16,7 @@ extern void test_sse4 (void)\t\t\t__attribute__((__target__(\"sse4\")));\n extern void test_sse4_1 (void)\t\t\t__attribute__((__target__(\"sse4.1\")));\n extern void test_sse4_2 (void)\t\t\t__attribute__((__target__(\"sse4.2\")));\n extern void test_sse4a (void)\t\t\t__attribute__((__target__(\"sse4a\")));\n+extern void test_fma4 (void)\t\t\t__attribute__((__target__(\"fma4\")));\n extern void test_ssse3 (void)\t\t\t__attribute__((__target__(\"ssse3\")));\n \n extern void test_no_abm (void)\t\t\t__attribute__((__target__(\"no-abm\")));\n@@ -31,6 +32,7 @@ extern void test_no_sse4 (void)\t\t\t__attribute__((__target__(\"no-sse4\")));\n extern void test_no_sse4_1 (void)\t\t__attribute__((__target__(\"no-sse4.1\")));\n extern void test_no_sse4_2 (void)\t\t__attribute__((__target__(\"no-sse4.2\")));\n extern void test_no_sse4a (void)\t\t__attribute__((__target__(\"no-sse4a\")));\n+extern void test_no_fma4 (void)\t\t\t__attribute__((__target__(\"no-fma4\")));\n extern void test_no_ssse3 (void)\t\t__attribute__((__target__(\"no-ssse3\")));\n \n extern void test_arch_nocona (void)\t\t__attribute__((__target__(\"arch=nocona\")));"}, {"sha": "ba4b7f22743fe3070d3e86682248d538f304ec63", "filename": "gcc/testsuite/gcc.target/i386/funcspec-8.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-8.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -104,6 +104,25 @@ generic_insertq (__m128i a, __m128i b)\n   return __builtin_ia32_insertq (a, b);\t\t\t/* { dg-error \"needs isa option\" } */\n }\n \n+#ifdef __FMA4__\n+#error \"-mfma4 should not be set for this test\"\n+#endif\n+\n+__m128d fma4_fmaddpd (__m128d a, __m128d b, __m128d c) __attribute__((__target__(\"fma4\")));\n+__m128d generic_fmaddpd (__m128d a, __m128d b, __m128d c);\n+\n+__m128d\n+fma4_fmaddpd  (__m128d a, __m128d b, __m128d c)\n+{\n+  return __builtin_ia32_vfmaddpd (a, b, c);\n+}\n+\n+__m128d\n+generic_fmaddpd  (__m128d a, __m128d b, __m128d c)\n+{\n+  return __builtin_ia32_vfmaddpd (a, b, c);\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n #ifdef __AES__\n #error \"-maes should not be set for this test\"\n #endif"}, {"sha": "78714e12417c987bd7225a17ac4a53927a23fe10", "filename": "gcc/testsuite/gcc.target/i386/funcspec-9.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-9.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,36 @@\n+/* Test whether using target specific options, we can generate FMA4 code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=k8 -mfpmath=sse -msse2\" } */\n+\n+extern void exit (int);\n+\n+#ifdef __FMA4__\n+#warning \"__FMA4__ should not be defined before #pragma GCC target.\"\n+#endif\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"fma4\")\n+\n+#ifndef __FMA4__\n+#warning \"__FMA4__ should have be defined after #pragma GCC target.\"\n+#endif\n+\n+float\n+flt_mul_add (float a, float b, float c)\n+{\n+  return (a * b) + c;\n+}\n+\n+#pragma GCC pop_options\n+#ifdef __FMA4__\n+#warning \"__FMA4__ should not be defined after #pragma GCC pop target.\"\n+#endif\n+\n+double\n+dbl_mul_add (double a, double b, double c)\n+{\n+  return (a * b) + c;\n+}\n+\n+/* { dg-final { scan-assembler \"vfmaddss\" } } */\n+/* { dg-final { scan-assembler \"addsd\" } } */"}, {"sha": "c7c6e12d1f4c40f2f4adf80b539a1978a4f21b0f", "filename": "gcc/testsuite/gcc.target/i386/i386.exp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -120,6 +120,20 @@ proc check_effective_target_sse4a { } {\n     } \"-O2 -msse4a\" ]\n }\n \n+# Return 1 if fma4 instructions can be compiled.\n+proc check_effective_target_fma4 { } {\n+    return [check_no_compiler_messages fma4 object {\n+        typedef float __m128 __attribute__ ((__vector_size__ (16)));\n+\ttypedef float __v4sf __attribute__ ((__vector_size__ (16)));\n+\t__m128 _mm_macc_ps(__m128 __A, __m128 __B, __m128 __C)\n+\t{\n+\t    return (__m128) __builtin_ia32_vfmaddps ((__v4sf)__A,\n+\t\t\t\t\t\t     (__v4sf)__B,\n+\t\t\t\t\t\t     (__v4sf)__C);\n+\t}\n+    } \"-O2 -mfma4\" ]\n+}\n+\n # If a testcase doesn't have special options, use these.\n global DEFAULT_CFLAGS\n if ![info exists DEFAULT_CFLAGS] then {"}, {"sha": "d98c14ffb19005dcbdbf061b9d6214331400966f", "filename": "gcc/testsuite/gcc.target/i386/isa-1.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-1.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -26,6 +26,12 @@ main ()\n #endif\n #if defined __SSE4A__\n   abort ();\n+#endif\n+#if defined __AVX__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n #endif\n   return 0;\n }"}, {"sha": "5f57be91390d045a1f893ebe555e2f9162666f6c", "filename": "gcc/testsuite/gcc.target/i386/isa-10.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-10.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=x86-64 -mfma4 -mno-sse4\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if !defined __SSSE3__\n+  abort ();\n+#endif\n+#if defined __SSE4_1__\n+  abort ();\n+#endif\n+#if defined __SSE4_2__\n+  abort ();\n+#endif\n+#if !defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "64755b099ccc731360e06d0dabc383a7efe82faa", "filename": "gcc/testsuite/gcc.target/i386/isa-11.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-11.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=x86-64 -mfma4 -mno-ssse3\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if defined __SSSE3__\n+  abort ();\n+#endif\n+#if defined __SSE4_1__\n+  abort ();\n+#endif\n+#if defined __SSE4_2__\n+  abort ();\n+#endif\n+#if !defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "fde84a21aef54f0805c3ad5ca87466fe57518eec", "filename": "gcc/testsuite/gcc.target/i386/isa-12.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-12.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=x86-64 -mfma4 -mno-sse3\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if defined __SSE3__\n+  abort ();\n+#endif\n+#if defined __SSSE3__\n+  abort ();\n+#endif\n+#if defined __SSE4_1__\n+  abort ();\n+#endif\n+#if defined __SSE4_2__\n+  abort ();\n+#endif\n+#if defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "74e37d92d127319a4d38bb3e932633341a7679cf", "filename": "gcc/testsuite/gcc.target/i386/isa-13.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-13.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=x86-64 -mfma4 -mno-sse2\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if defined __SSE2__\n+  abort ();\n+#endif\n+#if defined __SSE3__\n+  abort ();\n+#endif\n+#if defined __SSSE3__\n+  abort ();\n+#endif\n+#if defined __SSE4_1__\n+  abort ();\n+#endif\n+#if defined __SSE4_2__\n+  abort ();\n+#endif\n+#if defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "5d49e6e77fec2190e9603c8384d3e656ba9ddad1", "filename": "gcc/testsuite/gcc.target/i386/isa-14.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-14.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-march=x86-64 -msse4a -mno-sse\" } */\n+/* { dg-options \"-march=x86-64 -msse4a -mfma4 -mno-sse\" } */\n \n extern void abort (void);\n \n@@ -26,6 +26,9 @@ main ()\n #endif\n #if defined __SSE4A__\n   abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n #endif\n   return 0;\n }"}, {"sha": "aa8958c93643b7d3505e0ec720694496a3b885a7", "filename": "gcc/testsuite/gcc.target/i386/isa-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-2.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=x86-64 -msse4 -mfma4\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if !defined __SSSE3__\n+  abort ();\n+#endif\n+#if !defined __SSE4_1__\n+  abort ();\n+#endif\n+#if !defined __SSE4_2__\n+  abort ();\n+#endif\n+#if !defined __SSE4A__\n+  abort ();\n+#endif\n+#if !defined __AVX__\n+  abort ();\n+#endif\n+#if !defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "a4d93f4bd99732658cdac8c40f49c9b55db92f18", "filename": "gcc/testsuite/gcc.target/i386/isa-3.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-3.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=x86-64 -msse4 -mfma4 -msse4a\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if !defined __SSSE3__\n+  abort ();\n+#endif\n+#if !defined __SSE4_1__\n+  abort ();\n+#endif\n+#if !defined __SSE4_2__\n+  abort ();\n+#endif\n+#if !defined __SSE4A__\n+  abort ();\n+#endif\n+#if !defined __AVX__\n+  abort ();\n+#endif\n+#if !defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "0137257c8d179f7f9b865ac1cf6f2b7d70e89be9", "filename": "gcc/testsuite/gcc.target/i386/isa-4.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-4.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=core2 -mfma4 -mno-sse4\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if !defined __SSSE3__\n+  abort ();\n+#endif\n+#if defined __SSE4_1__\n+  abort ();\n+#endif\n+#if defined __SSE4_2__\n+  abort ();\n+#endif\n+#if !defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __AVX__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "39d065e68ee66a5beba9e7af70b49e42c6125140", "filename": "gcc/testsuite/gcc.target/i386/isa-5.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-5.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -26,6 +26,12 @@ main ()\n #endif\n #if !defined __SSE4A__\n   abort ();\n+#endif\n+#if defined __AVX__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n #endif\n   return 0;\n }"}, {"sha": "a9a0ddb14c170aafa442ee248cc5ca701b58f04e", "filename": "gcc/testsuite/gcc.target/i386/isa-6.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-6.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -27,6 +27,12 @@ main ()\n #endif\n #if !defined __SSE4A__\n   abort ();\n+#endif\n+#if defined __AVX__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n #endif\n   return 0;\n }"}, {"sha": "8dd628e924172ef2c33665668469c082808991e1", "filename": "gcc/testsuite/gcc.target/i386/isa-7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-7.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=amdfam10 -mfma4 -mno-sse4\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if !defined __SSSE3__\n+  abort ();\n+#endif\n+#if defined __SSE4_1__\n+  abort ();\n+#endif\n+#if defined __SSE4_2__\n+  abort ();\n+#endif\n+#if !defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __AVX__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "2ffd80fbad22e850a1e83f675071dc52dbfa5554", "filename": "gcc/testsuite/gcc.target/i386/isa-8.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-8.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=amdfam10 -mfma4 -mno-sse4a\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if !defined __SSSE3__\n+  abort ();\n+#endif\n+#if !defined __SSE4_1__\n+  abort ();\n+#endif\n+#if !defined __SSE4_2__\n+  abort ();\n+#endif\n+#if defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "64cbdbd6654f876534e76670e376a720d2a1ca27", "filename": "gcc/testsuite/gcc.target/i386/isa-9.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-9.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=amdfam10 -mno-fma4\" } */\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+#if !defined __SSE__\n+  abort ();\n+#endif\n+#if !defined __SSE2__\n+  abort ();\n+#endif\n+#if !defined __SSE3__\n+  abort ();\n+#endif\n+#if defined __SSSE3__\n+  abort ();\n+#endif\n+#if defined __SSE4_1__\n+  abort ();\n+#endif\n+#if defined __SSE4_2__\n+  abort ();\n+#endif\n+#if !defined __SSE4A__\n+  abort ();\n+#endif\n+#if defined __FMA4__\n+  abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "85c36c8be31e9623f6b6a3a67c46527d71c08e78", "filename": "gcc/testsuite/gcc.target/i386/sse-12.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,8 @@\n+/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h and mm_malloc.h are\n+   usable with -O -std=c89 -pedantic-errors.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -std=c89 -pedantic-errors -march=k8 -m3dnow -mavx -mfma4 -maes -mpclmul\" } */\n+\n+#include <x86intrin.h>\n+\n+int dummy;"}, {"sha": "1ce9d960884eb7bb23bd028147db161210db9969", "filename": "gcc/testsuite/gcc.target/i386/sse-13.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,128 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Werror-implicit-function-declaration -march=k8 -m3dnow -mavx -maes -mpclmul\" } */\n+\n+#include <mm_malloc.h>\n+\n+/* Test that the intrinsics compile with optimization.  All of them are\n+   defined as inline functions in {,x,e,p,t,s,w,a,b,i}mmintrin.h and mm3dnow.h\n+   that reference the proper builtin functions.  Defining away \"extern\" and\n+   \"__inline\" results in all of them being compiled as proper functions.  */\n+\n+#define extern\n+#define __inline\n+\n+/* Following intrinsics require immediate arguments. */\n+\n+/* ammintrin.h */\n+#define __builtin_ia32_extrqi(X, I, L)  __builtin_ia32_extrqi(X, 1, 1)\n+#define __builtin_ia32_insertqi(X, Y, I, L) __builtin_ia32_insertqi(X, Y, 1, 1)\n+\n+/* immintrin.h */\n+#define __builtin_ia32_blendpd256(X, Y, M) __builtin_ia32_blendpd256(X, Y, 1)\n+#define __builtin_ia32_blendps256(X, Y, M) __builtin_ia32_blendps256(X, Y, 1)\n+#define __builtin_ia32_dpps256(X, Y, M) __builtin_ia32_dpps256(X, Y, 1)\n+#define __builtin_ia32_shufpd256(X, Y, M) __builtin_ia32_shufpd256(X, Y, 1)\n+#define __builtin_ia32_shufps256(X, Y, M) __builtin_ia32_shufps256(X, Y, 1)\n+#define __builtin_ia32_cmpsd(X, Y, O) __builtin_ia32_cmpsd(X, Y, 1)\n+#define __builtin_ia32_cmpss(X, Y, O) __builtin_ia32_cmpss(X, Y, 1)\n+#define __builtin_ia32_cmppd(X, Y, O) __builtin_ia32_cmppd(X, Y, 1)\n+#define __builtin_ia32_cmpps(X, Y, O) __builtin_ia32_cmpps(X, Y, 1)\n+#define __builtin_ia32_cmppd256(X, Y, O) __builtin_ia32_cmppd256(X, Y, 1)\n+#define __builtin_ia32_cmpps256(X, Y, O) __builtin_ia32_cmpps256(X, Y, 1)\n+#define __builtin_ia32_vextractf128_pd256(X, N) __builtin_ia32_vextractf128_pd256(X, 1)\n+#define __builtin_ia32_vextractf128_ps256(X, N) __builtin_ia32_vextractf128_ps256(X, 1)\n+#define __builtin_ia32_vextractf128_si256(X, N) __builtin_ia32_vextractf128_si256(X, 1)\n+#define __builtin_ia32_vpermilpd(X, N) __builtin_ia32_vpermilpd(X, 1)\n+#define __builtin_ia32_vpermilpd256(X, N) __builtin_ia32_vpermilpd256(X, 1)\n+#define __builtin_ia32_vpermilps(X, N) __builtin_ia32_vpermilps(X, 1)\n+#define __builtin_ia32_vpermilps256(X, N) __builtin_ia32_vpermilps256(X, 1)\n+#define __builtin_ia32_vpermil2pd(X, Y, C, I) __builtin_ia32_vpermil2pd(X, Y, C, 1)\n+#define __builtin_ia32_vpermil2pd256(X, Y, C, I) __builtin_ia32_vpermil2pd256(X, Y, C, 1)\n+#define __builtin_ia32_vpermil2ps(X, Y, C, I) __builtin_ia32_vpermil2ps(X, Y, C, 1)\n+#define __builtin_ia32_vpermil2ps256(X, Y, C, I) __builtin_ia32_vpermil2ps256(X, Y, C, 1)\n+#define __builtin_ia32_vperm2f128_pd256(X, Y, C) __builtin_ia32_vperm2f128_pd256(X, Y, 1)\n+#define __builtin_ia32_vperm2f128_ps256(X, Y, C) __builtin_ia32_vperm2f128_ps256(X, Y, 1)\n+#define __builtin_ia32_vperm2f128_si256(X, Y, C) __builtin_ia32_vperm2f128_si256(X, Y, 1)\n+#define __builtin_ia32_vinsertf128_pd256(X, Y, C) __builtin_ia32_vinsertf128_pd256(X, Y, 1)\n+#define __builtin_ia32_vinsertf128_ps256(X, Y, C) __builtin_ia32_vinsertf128_ps256(X, Y, 1)\n+#define __builtin_ia32_vinsertf128_si256(X, Y, C) __builtin_ia32_vinsertf128_si256(X, Y, 1)\n+#define __builtin_ia32_roundpd256(V, M) __builtin_ia32_roundpd256(V, 1)\n+#define __builtin_ia32_roundps256(V, M) __builtin_ia32_roundps256(V, 1)\n+\n+/* wmmintrin.h */\n+#define __builtin_ia32_aeskeygenassist128(X, C) __builtin_ia32_aeskeygenassist128(X, 1)\n+#define __builtin_ia32_pclmulqdq128(X, Y, I) __builtin_ia32_pclmulqdq128(X, Y, 1)\n+\n+/* smmintrin.h */\n+#define __builtin_ia32_roundpd(V, M) __builtin_ia32_roundpd(V, 1)\n+#define __builtin_ia32_roundsd(D, V, M) __builtin_ia32_roundsd(D, V, 1)\n+#define __builtin_ia32_roundps(V, M) __builtin_ia32_roundps(V, 1)\n+#define __builtin_ia32_roundss(D, V, M) __builtin_ia32_roundss(D, V, 1)\n+\n+#define __builtin_ia32_pblendw128(X, Y, M) __builtin_ia32_pblendw128 (X, Y, 1)\n+#define __builtin_ia32_blendps(X, Y, M) __builtin_ia32_blendps(X, Y, 1)\n+#define __builtin_ia32_blendpd(X, Y, M) __builtin_ia32_blendpd(X, Y, 1)\n+#define __builtin_ia32_dpps(X, Y, M) __builtin_ia32_dpps(X, Y, 1)\n+#define __builtin_ia32_dppd(X, Y, M) __builtin_ia32_dppd(X, Y, 1)\n+#define __builtin_ia32_insertps128(D, S, N) __builtin_ia32_insertps128(D, S, 1)\n+#define __builtin_ia32_vec_ext_v4sf(X, N) __builtin_ia32_vec_ext_v4sf(X, 1)\n+#define __builtin_ia32_vec_set_v16qi(D, S, N) __builtin_ia32_vec_set_v16qi(D, S, 1)\n+#define __builtin_ia32_vec_set_v4si(D, S, N) __builtin_ia32_vec_set_v4si(D, S, 1)\n+#define __builtin_ia32_vec_set_v2di(D, S, N) __builtin_ia32_vec_set_v2di(D, S, 1)\n+#define __builtin_ia32_vec_ext_v16qi(X, N) __builtin_ia32_vec_ext_v16qi(X, 1)\n+#define __builtin_ia32_vec_ext_v4si(X, N) __builtin_ia32_vec_ext_v4si(X, 1)\n+#define __builtin_ia32_vec_ext_v2di(X, N) __builtin_ia32_vec_ext_v2di(X, 1)\n+#define __builtin_ia32_mpsadbw128(X, Y, M) __builtin_ia32_mpsadbw128(X, Y, 1)\n+#define __builtin_ia32_pcmpistrm128(X, Y, M) \\\n+  __builtin_ia32_pcmpistrm128(X, Y, 1)\n+#define __builtin_ia32_pcmpistri128(X, Y, M) \\\n+  __builtin_ia32_pcmpistri128(X, Y, 1)\n+#define __builtin_ia32_pcmpestrm128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestrm128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestri128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestri128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpistria128(X, Y, M) \\\n+  __builtin_ia32_pcmpistria128(X, Y, 1)\n+#define __builtin_ia32_pcmpistric128(X, Y, M) \\\n+  __builtin_ia32_pcmpistric128(X, Y, 1)\n+#define __builtin_ia32_pcmpistrio128(X, Y, M) \\\n+  __builtin_ia32_pcmpistrio128(X, Y, 1)\n+#define __builtin_ia32_pcmpistris128(X, Y, M) \\\n+  __builtin_ia32_pcmpistris128(X, Y, 1)\n+#define __builtin_ia32_pcmpistriz128(X, Y, M) \\\n+  __builtin_ia32_pcmpistriz128(X, Y, 1)\n+#define __builtin_ia32_pcmpestria128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestria128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestric128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestric128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestrio128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestrio128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestris128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestris128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestriz128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestriz128(X, LX, Y, LY, 1)\n+\n+/* tmmintrin.h */\n+#define __builtin_ia32_palignr128(X, Y, N) __builtin_ia32_palignr128(X, Y, 8)\n+#define __builtin_ia32_palignr(X, Y, N) __builtin_ia32_palignr(X, Y, 8)\n+\n+/* emmintrin.h */\n+#define __builtin_ia32_psrldqi128(A, B) __builtin_ia32_psrldqi128(A, 8)\n+#define __builtin_ia32_pslldqi128(A, B) __builtin_ia32_pslldqi128(A, 8)\n+#define __builtin_ia32_pshufhw(A, N) __builtin_ia32_pshufhw(A, 0)\n+#define __builtin_ia32_pshuflw(A, N) __builtin_ia32_pshuflw(A, 0)\n+#define __builtin_ia32_pshufd(A, N) __builtin_ia32_pshufd(A, 0)\n+#define __builtin_ia32_vec_set_v8hi(A, D, N) \\\n+  __builtin_ia32_vec_set_v8hi(A, D, 0)\n+#define __builtin_ia32_vec_ext_v8hi(A, N) __builtin_ia32_vec_ext_v8hi(A, 0)\n+#define __builtin_ia32_shufpd(A, B, N) __builtin_ia32_shufpd(A, B, 0)\n+\n+/* xmmintrin.h */\n+#define __builtin_prefetch(P, A, I) __builtin_prefetch(P, A, _MM_HINT_NTA)\n+#define __builtin_ia32_pshufw(A, N) __builtin_ia32_pshufw(A, 0)\n+#define __builtin_ia32_vec_set_v4hi(A, D, N) \\\n+  __builtin_ia32_vec_set_v4hi(A, D, 0)\n+#define __builtin_ia32_vec_ext_v4hi(A, N) __builtin_ia32_vec_ext_v4hi(A, 0)\n+#define __builtin_ia32_shufps(A, B, N) __builtin_ia32_shufps(A, B, 0)\n+\n+#include <x86intrin.h>"}, {"sha": "c1ddb96e5c3a0bb2e2b2b9dc5a6e93f32e103031", "filename": "gcc/testsuite/gcc.target/i386/sse-14.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-14.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,157 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -Werror-implicit-function-declaration -march=k8 -m3dnow -mavx -msse4a -maes -mpclmul\" } */\n+\n+#include <mm_malloc.h>\n+\n+/* Test that the intrinsics compile without optimization.  All of them are\n+   defined as inline functions in {,x,e,p,t,s,w,a}mmintrin.h  and mm3dnow.h\n+   that reference the proper builtin functions.  Defining away \"extern\" and\n+   \"__inline\" results in all of them being compiled as proper functions.  */\n+\n+#define extern\n+#define __inline\n+\n+#include <x86intrin.h>\n+\n+#define _CONCAT(x,y) x ## y\n+\n+#define test_1(func, type, op1_type, imm)\t\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, int const I)\t\t\t\\\n+  { return func (A, imm); }\n+\n+#define test_1x(func, type, op1_type, imm1, imm2)\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, int const I, int const L)\t\t\\\n+  { return func (A, imm1, imm2); }\n+\n+#define test_2(func, type, op1_type, op2_type, imm)\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B, int const I)\t\t\\\n+  { return func (A, B, imm); }\n+\n+#define test_2x(func, type, op1_type, op2_type, imm1, imm2)\t\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B, int const I, int const L) \\\n+  { return func (A, B, imm1, imm2); }\n+\n+#define test_3(func, type, op1_type, op2_type, op3_type, imm)\t\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B,\t\t\t\t\\\n+\t\t\top3_type C, int const I)\t\t\t\\\n+  { return func (A, B, C, imm); }\n+\n+#define test_4(func, type, op1_type, op2_type, op3_type, op4_type, imm)\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B,\t\t\t\t\\\n+\t\t\top3_type C, op4_type D, int const I)\t\t\\\n+  { return func (A, B, C, D, imm); }\n+\n+\n+/* Following intrinsics require immediate arguments.  They\n+   are defined as macros for non-optimized compilations. */\n+\n+/* ammintrin.h */\n+test_1x (_mm_extracti_si64, __m128i, __m128i, 1, 1)\n+test_2x (_mm_inserti_si64, __m128i, __m128i, __m128i, 1, 1)\n+\n+/* immintrin.h */\n+test_2 (_mm256_blend_pd, __m256d, __m256d, __m256d, 1)\n+test_2 (_mm256_blend_ps, __m256, __m256, __m256, 1)\n+test_2 (_mm256_dp_ps, __m256, __m256, __m256, 1)\n+test_2 (_mm256_shuffle_pd, __m256d, __m256d, __m256d, 1)\n+test_2 (_mm256_shuffle_ps, __m256, __m256, __m256, 1)\n+test_2 (_mm_cmp_sd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_cmp_ss, __m128, __m128, __m128, 1)\n+test_2 (_mm_cmp_pd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_cmp_ps, __m128, __m128, __m128, 1)\n+test_2 (_mm256_cmp_pd, __m256d, __m256d, __m256d, 1)\n+test_2 (_mm256_cmp_ps, __m256, __m256, __m256, 1)\n+test_1 (_mm256_extractf128_pd, __m128d, __m256d, 1)\n+test_1 (_mm256_extractf128_ps, __m128, __m256, 1)\n+test_1 (_mm256_extractf128_si256, __m128i, __m256i, 1)\n+test_1 (_mm256_extract_epi8, int, __m256i, 20)\n+test_1 (_mm256_extract_epi16, int, __m256i, 13)\n+test_1 (_mm256_extract_epi32, int, __m256i, 6)\n+#ifdef __x86_64__\n+test_1 (_mm256_extract_epi64, long long, __m256i, 2)\n+#endif\n+test_1 (_mm_permute_pd, __m128d, __m128d, 1)\n+test_1 (_mm256_permute_pd, __m256d, __m256d, 1)\n+test_1 (_mm_permute_ps, __m128, __m128, 1)\n+test_1 (_mm256_permute_ps, __m256, __m256, 1)\n+test_2 (_mm256_permute2f128_pd, __m256d, __m256d, __m256d, 1)\n+test_2 (_mm256_permute2f128_ps, __m256, __m256, __m256, 1)\n+test_2 (_mm256_permute2f128_si256, __m256i, __m256i, __m256i, 1)\n+test_2 (_mm256_insertf128_pd, __m256d, __m256d, __m128d, 1)\n+test_2 (_mm256_insertf128_ps, __m256, __m256, __m128, 1)\n+test_2 (_mm256_insertf128_si256, __m256i, __m256i, __m128i, 1)\n+test_2 (_mm256_insert_epi8, __m256i, __m256i, int, 30)\n+test_2 (_mm256_insert_epi16, __m256i, __m256i, int, 7)\n+test_2 (_mm256_insert_epi32, __m256i, __m256i, int, 3)\n+#ifdef __x86_64__\n+test_2 (_mm256_insert_epi64, __m256i, __m256i, long long, 1)\n+#endif\n+test_1 (_mm256_round_pd, __m256d, __m256d, 1)\n+test_1 (_mm256_round_ps, __m256, __m256, 1)\n+\n+/* wmmintrin.h */\n+test_1 (_mm_aeskeygenassist_si128, __m128i, __m128i, 1)\n+test_2 (_mm_clmulepi64_si128, __m128i, __m128i, __m128i, 1)\n+\n+/* smmintrin.h */\n+test_1 (_mm_round_pd, __m128d, __m128d, 1)\n+test_1 (_mm_round_ps, __m128, __m128, 1)\n+test_2 (_mm_round_sd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_round_ss, __m128, __m128, __m128, 1)\n+\n+test_2 (_mm_blend_epi16, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_blend_ps, __m128, __m128, __m128, 1)\n+test_2 (_mm_blend_pd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_dp_ps, __m128, __m128, __m128, 1)\n+test_2 (_mm_dp_pd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_insert_ps, __m128, __m128, __m128, 1)\n+test_1 (_mm_extract_ps, int, __m128, 1)\n+test_2 (_mm_insert_epi8, __m128i, __m128i, int, 1)\n+test_2 (_mm_insert_epi32, __m128i, __m128i, int, 1)\n+#ifdef __x86_64__\n+test_2 (_mm_insert_epi64, __m128i, __m128i, long long, 1)\n+#endif\n+test_1 (_mm_extract_epi8, int, __m128i, 1)\n+test_1 (_mm_extract_epi32, int, __m128i, 1)\n+#ifdef __x86_64__\n+test_1 (_mm_extract_epi64, long long, __m128i, 1)\n+#endif\n+test_2 (_mm_mpsadbw_epu8, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrm, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistri, int, __m128i, __m128i, 1)\n+test_4 (_mm_cmpestrm, __m128i, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestri, int, __m128i, int, __m128i, int, 1)\n+test_2 (_mm_cmpistra, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrc, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistro, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrs, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrz, int, __m128i, __m128i, 1)\n+test_4 (_mm_cmpestra, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrc, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestro, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrs, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrz, int, __m128i, int, __m128i, int, 1)\n+\n+/* tmmintrin.h */\n+test_2 (_mm_alignr_epi8, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_alignr_pi8, __m64, __m64, __m64, 1)\n+\n+/* emmintrin.h */\n+test_2 (_mm_shuffle_pd, __m128d, __m128d, __m128d, 1)\n+test_1 (_mm_srli_si128, __m128i, __m128i, 1)\n+test_1 (_mm_slli_si128, __m128i, __m128i, 1)\n+test_1 (_mm_extract_epi16, int, __m128i, 1)\n+test_2 (_mm_insert_epi16, __m128i, __m128i, int, 1)\n+test_1 (_mm_shufflehi_epi16, __m128i, __m128i, 1)\n+test_1 (_mm_shufflelo_epi16, __m128i, __m128i, 1)\n+test_1 (_mm_shuffle_epi32, __m128i, __m128i, 1)\n+\n+/* xmmintrin.h */\n+test_2 (_mm_shuffle_ps, __m128, __m128, __m128, 1)\n+test_1 (_mm_extract_pi16, int, __m64, 1)\n+test_1 (_m_pextrw, int, __m64, 1)\n+test_2 (_mm_insert_pi16, __m64, __m64, int, 1)\n+test_2 (_m_pinsrw, __m64, __m64, int, 1)\n+test_1 (_mm_shuffle_pi16, __m64, __m64, 1)\n+test_1 (_m_pshufw, __m64, __m64, 1)\n+test_1 (_mm_prefetch, void, void *, _MM_HINT_NTA)"}, {"sha": "eeae0fcab7568838286882e27def142f0a54deda", "filename": "gcc/testsuite/gcc.target/i386/sse-22.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c?ref=cbf2e4d4f12f9b2be0caacb612bb519a6bec7c06", "patch": "@@ -0,0 +1,161 @@\n+/* Same as sse-14, except converted to use #pragma GCC option.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -Werror-implicit-function-declaration\" } */\n+\n+#include <mm_malloc.h>\n+\n+/* Test that the intrinsics compile without optimization.  All of them are\n+   defined as inline functions in {,x,e,p,t,s,w,a}mmintrin.h  and mm3dnow.h\n+   that reference the proper builtin functions.  Defining away \"extern\" and\n+   \"__inline\" results in all of them being compiled as proper functions.  */\n+\n+#define extern\n+#define __inline\n+\n+#define _CONCAT(x,y) x ## y\n+\n+#define test_1(func, type, op1_type, imm)\t\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, int const I)\t\t\t\\\n+  { return func (A, imm); }\n+\n+#define test_1x(func, type, op1_type, imm1, imm2)\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, int const I, int const L)\t\t\\\n+  { return func (A, imm1, imm2); }\n+\n+#define test_2(func, type, op1_type, op2_type, imm)\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B, int const I)\t\t\\\n+  { return func (A, B, imm); }\n+\n+#define test_2x(func, type, op1_type, op2_type, imm1, imm2)\t\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B, int const I, int const L) \\\n+  { return func (A, B, imm1, imm2); }\n+\n+#define test_4(func, type, op1_type, op2_type, op3_type, op4_type, imm)\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B,\t\t\t\t\\\n+\t\t\top3_type C, op4_type D, int const I)\t\t\\\n+  { return func (A, B, C, D, imm); }\n+\n+\n+#ifndef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"mmx,3dnow,sse,sse2,sse3,ssse3,sse4.1,sse4.2,sse4a,aes,pclmul\")\n+#endif\n+\n+/* Following intrinsics require immediate arguments.  They\n+   are defined as macros for non-optimized compilations. */\n+\n+/* mmintrin.h (MMX).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"mmx\")\n+#endif\n+#include <mmintrin.h>\n+\n+/* mm3dnow.h (3DNOW).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"3dnow\")\n+#endif\n+#include <mm3dnow.h>\n+\n+/* xmmintrin.h (SSE).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"sse\")\n+#endif\n+#include <xmmintrin.h>\n+test_2 (_mm_shuffle_ps, __m128, __m128, __m128, 1)\n+test_1 (_mm_extract_pi16, int, __m64, 1)\n+test_1 (_m_pextrw, int, __m64, 1)\n+test_2 (_mm_insert_pi16, __m64, __m64, int, 1)\n+test_2 (_m_pinsrw, __m64, __m64, int, 1)\n+test_1 (_mm_shuffle_pi16, __m64, __m64, 1)\n+test_1 (_m_pshufw, __m64, __m64, 1)\n+test_1 (_mm_prefetch, void, void *, _MM_HINT_NTA)\n+\n+/* emmintrin.h (SSE2).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"sse2\")\n+#endif\n+#include <emmintrin.h>\n+test_2 (_mm_shuffle_pd, __m128d, __m128d, __m128d, 1)\n+test_1 (_mm_srli_si128, __m128i, __m128i, 1)\n+test_1 (_mm_slli_si128, __m128i, __m128i, 1)\n+test_1 (_mm_extract_epi16, int, __m128i, 1)\n+test_2 (_mm_insert_epi16, __m128i, __m128i, int, 1)\n+test_1 (_mm_shufflehi_epi16, __m128i, __m128i, 1)\n+test_1 (_mm_shufflelo_epi16, __m128i, __m128i, 1)\n+test_1 (_mm_shuffle_epi32, __m128i, __m128i, 1)\n+\n+/* pmmintrin.h (SSE3).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"sse3\")\n+#endif\n+#include <pmmintrin.h>\n+\n+/* tmmintrin.h (SSSE3).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"ssse3\")\n+#endif\n+#include <tmmintrin.h>\n+test_2 (_mm_alignr_epi8, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_alignr_pi8, __m64, __m64, __m64, 1)\n+\n+/* ammintrin.h (SSE4A).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"sse4a\")\n+#endif\n+#include <ammintrin.h>\n+test_1x (_mm_extracti_si64, __m128i, __m128i, 1, 1)\n+test_2x (_mm_inserti_si64, __m128i, __m128i, __m128i, 1, 1)\n+\n+/* smmintrin.h (SSE4.1).  */\n+/* nmmintrin.h (SSE4.2).  */\n+/* Note, nmmintrin.h includes smmintrin.h, and smmintrin.h checks for the\n+   #ifdef.  So just set the option to SSE4.2.  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"sse4.2\")\n+#endif\n+#include <nmmintrin.h>\n+test_2 (_mm_blend_epi16, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_blend_ps, __m128, __m128, __m128, 1)\n+test_2 (_mm_blend_pd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_dp_ps, __m128, __m128, __m128, 1)\n+test_2 (_mm_dp_pd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_insert_ps, __m128, __m128, __m128, 1)\n+test_1 (_mm_extract_ps, int, __m128, 1)\n+test_2 (_mm_insert_epi8, __m128i, __m128i, int, 1)\n+test_2 (_mm_insert_epi32, __m128i, __m128i, int, 1)\n+#ifdef __x86_64__\n+test_2 (_mm_insert_epi64, __m128i, __m128i, long long, 1)\n+#endif\n+test_1 (_mm_extract_epi8, int, __m128i, 1)\n+test_1 (_mm_extract_epi32, int, __m128i, 1)\n+#ifdef __x86_64__\n+test_1 (_mm_extract_epi64, long long, __m128i, 1)\n+#endif\n+test_2 (_mm_mpsadbw_epu8, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrm, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistri, int, __m128i, __m128i, 1)\n+test_4 (_mm_cmpestrm, __m128i, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestri, int, __m128i, int, __m128i, int, 1)\n+test_2 (_mm_cmpistra, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrc, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistro, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrs, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrz, int, __m128i, __m128i, 1)\n+test_4 (_mm_cmpestra, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrc, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestro, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrs, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrz, int, __m128i, int, __m128i, int, 1)\n+\n+/* wmmintrin.h (AES/PCLMUL).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"aes,pclmul\")\n+#endif\n+#include <wmmintrin.h>\n+test_1 (_mm_aeskeygenassist_si128, __m128i, __m128i, 1)\n+test_2 (_mm_clmulepi64_si128, __m128i, __m128i, __m128i, 1)\n+\n+/* smmintrin.h (SSE4.1).  */\n+test_1 (_mm_round_pd, __m128d, __m128d, 1)\n+test_1 (_mm_round_ps, __m128, __m128, 1)\n+test_2 (_mm_round_sd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_round_ss, __m128, __m128, __m128, 1)"}]}