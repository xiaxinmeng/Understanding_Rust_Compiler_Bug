{"sha": "1e128c5f7b58721f49ba367788e518355747dc04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUxMjhjNWY3YjU4NzIxZjQ5YmEzNjc3ODhlNTE4MzU1NzQ3ZGMwNA==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-09-09T07:54:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T07:54:12Z"}, "message": "targhooks.c (default_unwind_emit, [...]): Use gcc_assert, gcc_unreachable & internal_error instead of abort.\n\n\t* targhooks.c (default_unwind_emit, default_scalar_mode_supported_p):\n\tUse gcc_assert, gcc_unreachable & internal_error instead of abort.\n\t* timevar.c (timevar_push, timevar_pop, timevar_start,\n\ttimevar_stop): Likewise.\n\t* toplev.c (default_pch_valid_p): Likewise.\n\t* tracer.c (tail_duplicate): Likewise.\n\t* tree-alias-common.c (get_alias_var_decl,\n\tget_values_from_constructor, create_alias_var, delete_alias_vars,\n\tempty_points_to_set, same_points_to_set, ptr_may_alias_var):\n\tLikewise.\n\t* tree.c (tree_size, make_node_stat, copy_node_stat,\n\tbuild_int_cst_wide, integer_all_onesp, list_length, chainon,\n\ttree_node_structure, type_contains_placeholder_p, substitute_in_expr,\n\tsubstitute_placeholder_in_expr, tabilize_reference_1, build0_stat,\n\tbuild1_stat, build2_stat, build3_stat, build4_stat, is_attribute_p,\n\tlookup_attribute, type_hash_canon, host_integerp, iterative_hash_expr,\n\tbuild_method_type_directly, decl_type_context, get_callee_fndecl,\n\tget_set_constructor_bits, build_vector_type_for_mode, int_cst_value,\n\ttree_fold_gcd): Likewise.\n\t* tree-cfg.c (create_bb, make_ctrl_stmt_edges, make_exit_edges,\n\tmake_cond_expr_edges, group_case_labels, tree_merge_blocks,\n\tcleanup_control_expr_graph, find_taken_edge,\n\tfind_taken_edge_switch_expr, phi_alternatives_equal,\n\tis_ctrl_altering_stmt, disband_implicit_edges, set_bb_for_stmt,\n\tstmt_for_bsi, tree_find_edge_insert_loc, bsi_insert_on_edge_immediate,\n\ttree_split_edge, tree_verify_flow_info, thread_jumps,\n\ttree_redirect_edge_and_branch, tree_flow_call_edges_add): Likewise.\n\t* tree-chrec.c (chrec_fold_poly_cst, chrec_fold_plus_poly_poly,\n\tchrec_fold_multiply_poly_poly): Likewise.\n\t* tree-complex.c (extract_component, expand_complex_division,\n\texpand_complex_comparison, expand_complex_operations_1,\n\tbuild_replicated_const, expand_vector_operations_1): Likewise.\n\t* tree-data-ref.c (tree_fold_bezout, build_classic_dist_vector,\n\tbuild_classic_dir_vector): Likewise.\n\t* tree-dfa.c (compute_immediate_uses_for_phi,\n\tcompute_immediate_uses_for_stmt, create_var_ann, create_stmt_ann,\n\tcreate_tree_ann, collect_dfa_stats, get_virtual_var): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t* tree-eh.c (record_stmt_eh_region, add_stmt_to_eh_region,\n\trecord_in_finally_tree, replace_goto_queue_1,\n\tmaybe_record_in_goto_queue, verify_norecord_switch_expr,\n\tdo_return_redirection): Likewise.\n\t* tree-if-conv.c (tree_if_convert_stmt, tree_if_convert_cond_expr,\n\tadd_to_dst_predicate_list, find_phi_replacement_condition,\n\treplace_phi_with_cond_modify_expr, get_loop_body_in_if_conv_order):\n\tLikewise.\n\t* tree-inline.c (remap_decl, remap_type, remap_decls, copy_body_r,\n\tinitialize_inlined_parameters, declare_return_variable,\n\testimate_num_insns_1, expand_call_inline, expand_calls_inline,\n\toptimize_inline_calls, copy_tree_r): Likewise.\n\t* tree-into-ssa.c (rewrite_initialize_block_local_data, rewrite_stmt,\n\tssa_rewrite_stmt, rewrite_into_ssa): Likewise.\n\t* tree-iterator.c (alloc_stmt_list, tsi_link_before, tsi_link_after,\n\ttsi_split_statement_list_after, tsi_split_statement_list_before):\n\tLikewise.\n\t* tree-mudflap.c (mf_varname_tree): Likewise.\n\t* tree-nested.c (create_tmp_var_for, lookup_field_for_decl,\n\tlookup_tramp_for_decl, convert_all_function_calls): Likewise.\n\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n\t* tree-outof-ssa.c (create_temp, eliminate_build, eliminate_phi,\n\tcoalesce_abnormal_edges, coalesce_ssa_name, eliminate_virtual_phis,\n\tfree_temp_expr_table, add_dependance, finish_expr, rewrite_trees):\n\tLikewise.\n\t* tree-phinodes.c (resize_phi_node, add_phi_arg,\n\tremove_all_phi_nodes_for): Likewise.\n\t* tree-pretty-print.c (op_prio, print_call_name): Likewise.\n\t* tree-profile.c (tree_gen_interval_profiler, tree_gen_pow2_profiler,\n\ttree_gen_one_value_profiler, tree_gen_const_delta_profiler): Likewise.\n\t* tree-sra.c (type_can_instantiate_all_elements, sra_hash_tree,\n\tsra_elt_eq, sra_walk_expr, instantiate_missing_elements,\n\tgenerate_one_element_ref, generate_element_copy,\n\tgenerate_element_zero, scalarize_copy, scalarize_init,\n\tscalarize_ldst): Likewise.\n\t* tree-ssa-alias.c (delete_alias_info, group_aliases, may_alias_p,\n\tadd_may_alias, add_pointed_to_expr, add_pointed_to_var,\n\tcollect_points_to_info_r, get_tmt_for, get_ptr_info): Likewise.\n\t* tree-ssa.c (walk_use_def_chains, check_phi_redundancy): Likewise.\n\t* tree-ssa-ccp.c (dump_lattice_value, get_default_value, get_value,\n\tset_lattice_value, likely_value, ccp_visit_phi_node, visit_assignment,\n\twiden_bitfield, ccp_fold_builtin): Likewise.\n\t* tree-ssa-copy.c (may_propagate_copy, merge_alias_info,\n\treplace_exp_1, propagate_tree_value): Likewise.\n\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Likewise.\n\t* tree-ssa-dce.c (set_control_dependence_map_bit,\n\tfind_control_dependence, find_pdom, mark_operand_necessary,\n\tmark_stmt_if_obviously_necessary,\n\tmark_control_dependent_edges_necessary, remove_dead_stmt): Likewise.\n\t* tree-ssa-dom.c (dom_opt_initialize_block_local_data,\n\tsimplify_switch_and_lookup_avail_expr, cprop_into_successor_phis,\n\teliminate_redundant_computations, avail_expr_eq): Likewise.\n\t* tree-ssa-dse.c (fix_stmt_v_may_defs): Likewise.\n\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p,\n\tduplicate_blocks): Likewise.\n\t* tree-ssa-loop-im.c (for_each_index, set_level,\n\tis_call_clobbered_ref): Likewise.\n\t* tree-ssa-loop-ivopts.c (dump_use, divide, stmt_after_ip_normal_pos,\n\tstmt_after_increment, set_iv, contains_abnormal_ssa_name_p,\n\tfind_interesting_uses_outer_or_nonlin, add_derived_ivs_candidates,\n\tpeel_address, ptr_difference_cost, may_replace_final_value,\n\tdetermine_use_iv_cost, rewrite_use_nonlinear_expr, rewrite_use_outer,\n\trewrite_use, rewrite_uses): Likewise.\n\t* tree-ssa-loop-manip.c (rewrite_into_loop_closed_ssa,\n\tcheck_loop_closed_ssa_use): Likewise.\n\t* tree-ssanames.c (make_ssa_name): Likewise.\n\t* tree-ssa-operands.c (finalize_ssa_defs, finalize_ssa_uses,\n\tfinalize_ssa_v_must_defs, finalize_ssa_stmt_operands,\n\tget_stmt_operands, get_expr_operands, get_asm_expr_operands,\n\tget_indirect_ref_operands, add_stmt_operand): Likewise.\n\t* tree-ssa-pre.c (value_exists_in_set_bitmap,\n\tvalue_remove_from_set_bitmap, bitmap_insert_into_set, insert_into_set,\n\tphi_translate, valid_in_set, compute_antic,\n\tfind_or_generate_expression, create_expression_by_pieces, insert_aux,\n\tcreate_value_expr_from, eliminate): Likewise.\n\t* tree-ssa-propagate.c (cfg_blocks_get): Likewise.\n\t* tree-ssa-threadupdate.c (remove_last_stmt_and_useless_edges):\n\tLikewise.\n\t* tree-tailcall.c (independent_of_stmt_p, adjust_return_value,\n\teliminate_tail_call): Likewise.\n\t* tree-vectorizer.c (vect_create_index_for_array_ref,\n\tvect_align_data_ref, vect_create_data_ref,\n\tvect_create_destination_var, vect_get_vec_def_for_operand,\n\tvect_finish_stmt_generation, vect_transform_stmt,\n\tvect_transform_loop_bound, vect_transform_loop,\n\tvect_analyze_operations): Likewise.\n\t* tree-vn.c (vn_compute, set_value_handle, get_value_handle):\n\tLikewise.\n\t* tree-flow-inline.h (var_ann, get_var_ann, get_def_from_ptr,\n\tget_use_op_ptr, immediate_use, phi_ssa_name_p, bsi_start,\n\tbsi_after_labels, bsi_last): Likewise.\n\t* tree-ssa-live.c (var_union, change_partition_var,\n\tcreate_ssa_var_map, calculate_live_on_entry, root_var_init,\n\ttype_var_init, add_coalesce, sort_coalesce_list, pop_best_coalesce):\n\tLikewise.\n\t* tree-ssa-live.h (partition_is_global, live_entry_blocks,\n\ttpa_find_tree): Likewise.\n\t(register_ssa_partition_check): Declare.\n\t(register_ssa_partition): use it.\n\t* tree-ssa-live.c: Include errors.h.\n\t(register_ssa_partition_check): New.\n\t* tree-ssa-operands.c: Include errors.h.\n\t* Makefile.in (tree-ssa-operands.o): Depend on errors.h.\n\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com>\n\nFrom-SVN: r87223", "tree": {"sha": "55c4658394013a7e952ce866d97d939e911a7ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55c4658394013a7e952ce866d97d939e911a7ce4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e128c5f7b58721f49ba367788e518355747dc04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e128c5f7b58721f49ba367788e518355747dc04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e128c5f7b58721f49ba367788e518355747dc04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e128c5f7b58721f49ba367788e518355747dc04/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c557edf447d02a1bace4e84cb4515e1de06be4d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c557edf447d02a1bace4e84cb4515e1de06be4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c557edf447d02a1bace4e84cb4515e1de06be4d9"}], "stats": {"total": 2179, "additions": 920, "deletions": 1259}, "files": [{"sha": "b6050b30373dab007995801a739306174a4112b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -1,3 +1,148 @@\n+2004-09-09  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* targhooks.c (default_unwind_emit, default_scalar_mode_supported_p):\n+\tUse gcc_assert, gcc_unreachable & internal_error instead of abort.\n+\t* timevar.c (timevar_push, timevar_pop, timevar_start,\n+\ttimevar_stop): Likewise.\n+\t* toplev.c (default_pch_valid_p): Likewise.\n+\t* tracer.c (tail_duplicate): Likewise.\n+\t* tree-alias-common.c (get_alias_var_decl,\n+\tget_values_from_constructor, create_alias_var, delete_alias_vars,\n+\tempty_points_to_set, same_points_to_set, ptr_may_alias_var):\n+\tLikewise.\n+\t* tree.c (tree_size, make_node_stat, copy_node_stat,\n+\tbuild_int_cst_wide, integer_all_onesp, list_length, chainon,\n+\ttree_node_structure, type_contains_placeholder_p, substitute_in_expr,\n+\tsubstitute_placeholder_in_expr, tabilize_reference_1, build0_stat,\n+\tbuild1_stat, build2_stat, build3_stat, build4_stat, is_attribute_p,\n+\tlookup_attribute, type_hash_canon, host_integerp, iterative_hash_expr,\n+\tbuild_method_type_directly, decl_type_context, get_callee_fndecl,\n+\tget_set_constructor_bits, build_vector_type_for_mode, int_cst_value,\n+\ttree_fold_gcd): Likewise.\n+\t* tree-cfg.c (create_bb, make_ctrl_stmt_edges, make_exit_edges,\n+\tmake_cond_expr_edges, group_case_labels, tree_merge_blocks,\n+\tcleanup_control_expr_graph, find_taken_edge,\n+\tfind_taken_edge_switch_expr, phi_alternatives_equal,\n+\tis_ctrl_altering_stmt, disband_implicit_edges, set_bb_for_stmt,\n+\tstmt_for_bsi, tree_find_edge_insert_loc, bsi_insert_on_edge_immediate,\n+\ttree_split_edge, tree_verify_flow_info, thread_jumps,\n+\ttree_redirect_edge_and_branch, tree_flow_call_edges_add): Likewise.\n+\t* tree-chrec.c (chrec_fold_poly_cst, chrec_fold_plus_poly_poly,\n+\tchrec_fold_multiply_poly_poly): Likewise.\n+\t* tree-complex.c (extract_component, expand_complex_division,\n+\texpand_complex_comparison, expand_complex_operations_1,\n+\tbuild_replicated_const, expand_vector_operations_1): Likewise.\n+\t* tree-data-ref.c (tree_fold_bezout, build_classic_dist_vector,\n+\tbuild_classic_dir_vector): Likewise.\n+\t* tree-dfa.c (compute_immediate_uses_for_phi,\n+\tcompute_immediate_uses_for_stmt, create_var_ann, create_stmt_ann,\n+\tcreate_tree_ann, collect_dfa_stats, get_virtual_var): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* tree-eh.c (record_stmt_eh_region, add_stmt_to_eh_region,\n+\trecord_in_finally_tree, replace_goto_queue_1,\n+\tmaybe_record_in_goto_queue, verify_norecord_switch_expr,\n+\tdo_return_redirection): Likewise.\n+\t* tree-if-conv.c (tree_if_convert_stmt, tree_if_convert_cond_expr,\n+\tadd_to_dst_predicate_list, find_phi_replacement_condition,\n+\treplace_phi_with_cond_modify_expr, get_loop_body_in_if_conv_order):\n+\tLikewise.\n+\t* tree-inline.c (remap_decl, remap_type, remap_decls, copy_body_r,\n+\tinitialize_inlined_parameters, declare_return_variable,\n+\testimate_num_insns_1, expand_call_inline, expand_calls_inline,\n+\toptimize_inline_calls, copy_tree_r): Likewise.\n+\t* tree-into-ssa.c (rewrite_initialize_block_local_data, rewrite_stmt,\n+\tssa_rewrite_stmt, rewrite_into_ssa): Likewise.\n+\t* tree-iterator.c (alloc_stmt_list, tsi_link_before, tsi_link_after,\n+\ttsi_split_statement_list_after, tsi_split_statement_list_before):\n+\tLikewise.\n+\t* tree-mudflap.c (mf_varname_tree): Likewise.\n+\t* tree-nested.c (create_tmp_var_for, lookup_field_for_decl,\n+\tlookup_tramp_for_decl, convert_all_function_calls): Likewise.\n+\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n+\t* tree-outof-ssa.c (create_temp, eliminate_build, eliminate_phi,\n+\tcoalesce_abnormal_edges, coalesce_ssa_name, eliminate_virtual_phis,\n+\tfree_temp_expr_table, add_dependance, finish_expr, rewrite_trees):\n+\tLikewise.\n+\t* tree-phinodes.c (resize_phi_node, add_phi_arg,\n+\tremove_all_phi_nodes_for): Likewise.\n+\t* tree-pretty-print.c (op_prio, print_call_name): Likewise.\n+\t* tree-profile.c (tree_gen_interval_profiler, tree_gen_pow2_profiler,\n+\ttree_gen_one_value_profiler, tree_gen_const_delta_profiler): Likewise.\n+\t* tree-sra.c (type_can_instantiate_all_elements, sra_hash_tree,\n+\tsra_elt_eq, sra_walk_expr, instantiate_missing_elements,\n+\tgenerate_one_element_ref, generate_element_copy,\n+\tgenerate_element_zero, scalarize_copy, scalarize_init,\n+\tscalarize_ldst): Likewise.\n+\t* tree-ssa-alias.c (delete_alias_info, group_aliases, may_alias_p,\n+\tadd_may_alias, add_pointed_to_expr, add_pointed_to_var,\n+\tcollect_points_to_info_r, get_tmt_for, get_ptr_info): Likewise.\n+\t* tree-ssa.c (walk_use_def_chains, check_phi_redundancy): Likewise.\n+\t* tree-ssa-ccp.c (dump_lattice_value, get_default_value, get_value,\n+\tset_lattice_value, likely_value, ccp_visit_phi_node, visit_assignment,\n+\twiden_bitfield, ccp_fold_builtin): Likewise.\n+\t* tree-ssa-copy.c (may_propagate_copy, merge_alias_info,\n+\treplace_exp_1, propagate_tree_value): Likewise.\n+\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Likewise.\n+\t* tree-ssa-dce.c (set_control_dependence_map_bit,\n+\tfind_control_dependence, find_pdom, mark_operand_necessary,\n+\tmark_stmt_if_obviously_necessary,\n+\tmark_control_dependent_edges_necessary, remove_dead_stmt): Likewise.\n+\t* tree-ssa-dom.c (dom_opt_initialize_block_local_data,\n+\tsimplify_switch_and_lookup_avail_expr, cprop_into_successor_phis,\n+\teliminate_redundant_computations, avail_expr_eq): Likewise.\n+\t* tree-ssa-dse.c (fix_stmt_v_may_defs): Likewise.\n+\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p,\n+\tduplicate_blocks): Likewise.\n+\t* tree-ssa-loop-im.c (for_each_index, set_level,\n+\tis_call_clobbered_ref): Likewise.\n+\t* tree-ssa-loop-ivopts.c (dump_use, divide, stmt_after_ip_normal_pos,\n+\tstmt_after_increment, set_iv, contains_abnormal_ssa_name_p,\n+\tfind_interesting_uses_outer_or_nonlin, add_derived_ivs_candidates,\n+\tpeel_address, ptr_difference_cost, may_replace_final_value,\n+\tdetermine_use_iv_cost, rewrite_use_nonlinear_expr, rewrite_use_outer,\n+\trewrite_use, rewrite_uses): Likewise.\n+\t* tree-ssa-loop-manip.c (rewrite_into_loop_closed_ssa,\n+\tcheck_loop_closed_ssa_use): Likewise.\n+\t* tree-ssanames.c (make_ssa_name): Likewise.\n+\t* tree-ssa-operands.c (finalize_ssa_defs, finalize_ssa_uses,\n+\tfinalize_ssa_v_must_defs, finalize_ssa_stmt_operands,\n+\tget_stmt_operands, get_expr_operands, get_asm_expr_operands,\n+\tget_indirect_ref_operands, add_stmt_operand): Likewise.\n+\t* tree-ssa-pre.c (value_exists_in_set_bitmap,\n+\tvalue_remove_from_set_bitmap, bitmap_insert_into_set, insert_into_set,\n+\tphi_translate, valid_in_set, compute_antic,\n+\tfind_or_generate_expression, create_expression_by_pieces, insert_aux,\n+\tcreate_value_expr_from, eliminate): Likewise.\n+\t* tree-ssa-propagate.c (cfg_blocks_get): Likewise.\n+\t* tree-ssa-threadupdate.c (remove_last_stmt_and_useless_edges):\n+\tLikewise.\n+\t* tree-tailcall.c (independent_of_stmt_p, adjust_return_value,\n+\teliminate_tail_call): Likewise.\n+\t* tree-vectorizer.c (vect_create_index_for_array_ref,\n+\tvect_align_data_ref, vect_create_data_ref,\n+\tvect_create_destination_var, vect_get_vec_def_for_operand,\n+\tvect_finish_stmt_generation, vect_transform_stmt,\n+\tvect_transform_loop_bound, vect_transform_loop,\n+\tvect_analyze_operations): Likewise.\n+\t* tree-vn.c (vn_compute, set_value_handle, get_value_handle):\n+\tLikewise.\n+\t* tree-flow-inline.h (var_ann, get_var_ann, get_def_from_ptr,\n+\tget_use_op_ptr, immediate_use, phi_ssa_name_p, bsi_start,\n+\tbsi_after_labels, bsi_last): Likewise.\n+\t* tree-ssa-live.c (var_union, change_partition_var,\n+\tcreate_ssa_var_map, calculate_live_on_entry, root_var_init,\n+\ttype_var_init, add_coalesce, sort_coalesce_list, pop_best_coalesce):\n+\tLikewise.\n+\t* tree-ssa-live.h (partition_is_global, live_entry_blocks,\n+\ttpa_find_tree): Likewise.\n+\t(register_ssa_partition_check): Declare.\n+\t(register_ssa_partition): use it.\n+\t* tree-ssa-live.c: Include errors.h.\n+\t(register_ssa_partition_check): New.\n+\t* tree-ssa-operands.c: Include errors.h.\n+\t* Makefile.in (tree-ssa-operands.o): Depend on errors.h.\n+\n 2004-09-09  Richard Sandiford  <rsandifo@redhat.com>\n \t    Catherine Moore  <clm@redhat.com>\n "}, {"sha": "995952ade9611c344b8daef5818c1fcc75010e9a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -1700,7 +1700,7 @@ tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    tree-alias-common.h convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) tree-pass.h params.h\n tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(GGC_H) diagnostic.h \\\n+   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(GGC_H) diagnostic.h errors.h \\\n    tree-inline.h $(FLAGS_H) function.h $(TM_H) $(TIMEVAR_H) tree-pass.h\n tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_H) $(FLAGS_H) function.h except.h langhooks.h \\"}, {"sha": "95a4909d43b3b7cda51b43b712b70973fbfd64c1", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -213,7 +213,7 @@ default_unwind_emit (FILE * stream ATTRIBUTE_UNUSED,\n \t\t     rtx insn ATTRIBUTE_UNUSED)\n {\n   /* Should never happen.  */\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* True if MODE is valid for the target.  By \"valid\", we mean able to\n@@ -258,7 +258,7 @@ default_scalar_mode_supported_p (enum machine_mode mode)\n       return false;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n "}, {"sha": "65323eb4e66a79e618865f0e19b7fac46cb6d18b", "filename": "gcc/timevar.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -263,8 +263,7 @@ timevar_push (timevar_id_t timevar)\n   tv->used = 1;\n \n   /* Can't push a standalone timer.  */\n-  if (tv->standalone)\n-    abort ();\n+  gcc_assert (!tv->standalone);\n \n   /* What time is it?  */\n   get_time (&now);\n@@ -309,13 +308,8 @@ timevar_pop (timevar_id_t timevar)\n   if (!timevar_enable)\n     return;\n \n-  if (&timevars[timevar] != stack->timevar)\n-    {\n-      sorry (\"cannot timevar_pop '%s' when top of timevars stack is '%s'\",\n-             timevars[timevar].name, stack->timevar->name);\n-      abort ();\n-    }\n-\n+  gcc_assert (&timevars[timevar] == stack->timevar);\n+  \n   /* What time is it?  */\n   get_time (&now);\n \n@@ -352,8 +346,7 @@ timevar_start (timevar_id_t timevar)\n \n   /* Don't allow the same timing variable to be started more than\n      once.  */\n-  if (tv->standalone)\n-    abort ();\n+  gcc_assert (!tv->standalone);\n   tv->standalone = 1;\n \n   get_time (&tv->start_time);\n@@ -372,8 +365,7 @@ timevar_stop (timevar_id_t timevar)\n     return;\n \n   /* TIMEVAR must have been started via timevar_start.  */\n-  if (!tv->standalone)\n-    abort ();\n+  gcc_assert (tv->standalone);\n \n   get_time (&now);\n   timevar_accumulate (&tv->elapsed, &tv->start_time, &now);"}, {"sha": "b0a297b991fee21570e1ac2db843454742d678d7", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -1502,7 +1502,7 @@ default_pch_valid_p (const void *data_p, size_t len)\n \t      goto make_message;\n \t    }\n \t}\n-      abort ();\n+      gcc_unreachable ();\n     }\n   data += sizeof (target_flags);\n   len -= sizeof (target_flags);"}, {"sha": "4fcedca153a6521831563d6d1fcf55f30368b4f1", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -247,8 +247,7 @@ tail_duplicate (void)\n \n       if (ignore_bb_p (bb))\n \tcontinue;\n-      if (seen (bb))\n-\tabort ();\n+      gcc_assert (!seen (bb));\n \n       n = find_trace (bb, trace);\n "}, {"sha": "21b8b497039e04a185fb14ebfa010a2e8e4f1c55", "filename": "gcc/tree-alias-common.c", "status": "modified", "additions": 27, "deletions": 54, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-alias-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-alias-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-common.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -139,8 +139,7 @@ static alias_var\n get_alias_var_decl (tree decl)\n {\n   alias_var newvar;\n-  if (TREE_CODE (decl) == FIELD_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) != FIELD_DECL);\n   if (DECL_P (decl))\n     {\n       if (DECL_PTA_ALIASVAR (decl))\n@@ -361,7 +360,7 @@ get_values_from_constructor (tree constructor, varray_type *vals,\n \t}\n       break;\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -944,14 +943,10 @@ create_alias_var (tree decl)\n {\n   alias_var avar;\n \n-  if (!DECL_P (decl))\n-    abort ();\n+  gcc_assert (DECL_P (decl));\n   \n-  if (DECL_P (decl))\n-    {\n-      if (DECL_PTA_ALIASVAR (decl))\n-\treturn DECL_PTA_ALIASVAR (decl);\n-    }\n+  if (DECL_PTA_ALIASVAR (decl))\n+    return DECL_PTA_ALIASVAR (decl);\n \n   if (POINTER_TYPE_P (TREE_TYPE (decl))\n       && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == FUNCTION_TYPE)\n@@ -1067,10 +1062,8 @@ delete_alias_vars (void)\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (local_alias_vars); i++)\n     {\n       tree key = VARRAY_TREE (local_alias_vars, i);\n-      if (DECL_P (key))\n-\tDECL_PTA_ALIASVAR (key) = NULL;\n-      else\n-\tabort ();\n+      gcc_assert (DECL_P (key));\n+      DECL_PTA_ALIASVAR (key) = NULL;\n     }\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (local_alias_varnums); i ++)\n@@ -1130,14 +1123,10 @@ empty_points_to_set (tree ptr)\n     ptr = TREE_OPERAND (ptr, 1);\n #endif\n \n-  if (DECL_P (ptr))\n-    {\n-      ptrtv = DECL_PTA_ALIASVAR (ptr);\n-      if (!ptrtv)\n-\treturn true;\n-    }\n-  else\n-    abort ();\n+  gcc_assert (DECL_P (ptr));\n+  ptrtv = DECL_PTA_ALIASVAR (ptr);\n+  if (!ptrtv)\n+    return true;\n \n   return current_alias_ops->empty_points_to_set (current_alias_ops, ptrtv);\n }\n@@ -1160,23 +1149,15 @@ same_points_to_set (tree ptr, tree var)\n   if (ptr == var)\n     return true;\n \n-  if (DECL_P (ptr))\n-    {\n-      ptrtv = DECL_PTA_ALIASVAR (ptr);\n-      if (!ptrtv)\n-\treturn false;\n-    }\n-  else\n-    abort ();\n+  gcc_assert (DECL_P (ptr));\n+  ptrtv = DECL_PTA_ALIASVAR (ptr);\n+  if (!ptrtv)\n+    return false;\n \n-  if (DECL_P (var))\n-    {\n-      vartv = DECL_PTA_ALIASVAR (var);\n-      if (!vartv)\n-\treturn false;\n-    }\n-  else\n-    abort ();\n+  gcc_assert (DECL_P (var));\n+  vartv = DECL_PTA_ALIASVAR (var);\n+  if (!vartv)\n+    return false;\n \n   return current_alias_ops->same_points_to_set (current_alias_ops, vartv, ptrtv);\n }\n@@ -1200,23 +1181,15 @@ ptr_may_alias_var (tree ptr, tree var)\n   if (ptr == var)\n     return true;\n \n-  if (DECL_P (ptr))\n-    {\n-      ptrtv = DECL_PTA_ALIASVAR (ptr);\n-      if (!ptrtv)\n-\treturn false;\n-    }\n-  else\n-    abort ();\n+  gcc_assert (DECL_P (ptr));\n+  ptrtv = DECL_PTA_ALIASVAR (ptr);\n+  if (!ptrtv)\n+    return false;\n \n-  if (DECL_P (var))\n-    {\n-      vartv = DECL_PTA_ALIASVAR (var);\n-      if (!vartv)\n-\treturn false;\n-    }\n-  else\n-    abort ();\n+  gcc_assert (DECL_P (var));\n+  vartv = DECL_PTA_ALIASVAR (var);\n+  if (!vartv)\n+    return false;\n \n   return current_alias_ops->may_alias (current_alias_ops, ptrtv, vartv);\n }"}, {"sha": "9452dff2cbfb3cf6c0347e97882f869f1200df87", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 39, "deletions": 82, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -294,8 +294,7 @@ static void\n create_block_annotation (basic_block bb)\n {\n   /* Verify that the tree_annotations field is clear.  */\n-  if (bb->tree_annotations)\n-    abort ();\n+  gcc_assert (!bb->tree_annotations);\n   bb->tree_annotations = ggc_alloc_cleared (sizeof (struct bb_ann_d));\n }\n \n@@ -374,8 +373,7 @@ create_bb (void *h, void *e, basic_block after)\n {\n   basic_block bb;\n \n-  if (e)\n-    abort ();\n+  gcc_assert (!e);\n \n   /* Create and initialize a new basic block.  */\n   bb = alloc_block ();\n@@ -462,11 +460,7 @@ make_ctrl_stmt_edges (basic_block bb)\n {\n   tree last = last_stmt (bb);\n \n-#if defined ENABLE_CHECKING\n-  if (last == NULL_TREE)\n-    abort();\n-#endif\n-\n+  gcc_assert (last);\n   switch (TREE_CODE (last))\n     {\n     case GOTO_EXPR:\n@@ -493,7 +487,7 @@ make_ctrl_stmt_edges (basic_block bb)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -507,9 +501,7 @@ make_exit_edges (basic_block bb)\n {\n   tree last = last_stmt (bb), op;\n \n-  if (last == NULL_TREE)\n-    abort ();\n-\n+  gcc_assert (last);\n   switch (TREE_CODE (last))\n     {\n     case CALL_EXPR:\n@@ -555,7 +547,7 @@ make_exit_edges (basic_block bb)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -570,10 +562,8 @@ make_cond_expr_edges (basic_block bb)\n   basic_block then_bb, else_bb;\n   tree then_label, else_label;\n \n-#if defined ENABLE_CHECKING\n-  if (entry == NULL_TREE || TREE_CODE (entry) != COND_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (entry);\n+  gcc_assert (TREE_CODE (entry) == COND_EXPR);\n \n   /* Entry basic blocks for each component.  */\n   then_label = GOTO_DESTINATION (COND_EXPR_THEN (entry));\n@@ -955,9 +945,7 @@ group_case_labels (void)\n \t      tree base_case, base_label, base_high, type;\n \t      base_case = TREE_VEC_ELT (labels, i);\n \n-\t      if (! base_case)\n-\t\tabort ();\n-\n+\t      gcc_assert (base_case);\n \t      base_label = CASE_LABEL (base_case);\n \n \t      /* Discard cases that have the same destination as the\n@@ -1080,12 +1068,8 @@ tree_merge_blocks (basic_block a, basic_block b)\n   /* Ensure that B follows A.  */\n   move_block_after (b, a);\n \n-  if (!(a->succ->flags & EDGE_FALLTHRU))\n-    abort ();\n-\n-  if (last_stmt (a)\n-      && stmt_ends_bb_p (last_stmt (a)))\n-    abort ();\n+  gcc_assert (a->succ->flags & EDGE_FALLTHRU);\n+  gcc_assert (!last_stmt (a) || !stmt_ends_bb_p (last_stmt (a)));\n \n   /* Remove labels from B and set bb_for_stmt to A for other statements.  */\n   for (bsi = bsi_start (b); !bsi_end_p (bsi);)\n@@ -1964,7 +1948,7 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       taken_edge = find_taken_edge (bb, val);\n@@ -2011,10 +1995,8 @@ find_taken_edge (basic_block bb, tree val)\n \n   stmt = last_stmt (bb);\n \n-#if defined ENABLE_CHECKING\n-  if (stmt == NULL_TREE || !is_ctrl_stmt (stmt))\n-    abort ();\n-#endif\n+  gcc_assert (stmt);\n+  gcc_assert (is_ctrl_stmt (stmt));\n \n   /* If VAL is a predicate of the form N RELOP N, where N is an\n      SSA_NAME, we can always determine its truth value (except when\n@@ -2097,8 +2079,7 @@ find_taken_edge_switch_expr (basic_block bb, tree val)\n   dest_bb = label_to_block (CASE_LABEL (taken_case));\n \n   e = find_edge (bb, dest_bb);\n-  if (!e)\n-    abort ();\n+  gcc_assert (e);\n   return e;\n }\n \n@@ -2161,10 +2142,8 @@ phi_alternatives_equal (basic_block dest, edge e1, edge e2)\n       n1 = phi_arg_from_edge (phi, e1);\n       n2 = phi_arg_from_edge (phi, e2);\n \n-#ifdef ENABLE_CHECKING\n-      if (n1 < 0 || n2 < 0)\n-\tabort ();\n-#endif\n+      gcc_assert (n1 >= 0);\n+      gcc_assert (n2 >= 0);\n \n       val1 = PHI_ARG_DEF (phi, n1);\n       val2 = PHI_ARG_DEF (phi, n2);\n@@ -2430,11 +2409,7 @@ is_ctrl_altering_stmt (tree t)\n {\n   tree call;\n \n-#if defined ENABLE_CHECKING\n-  if (t == NULL)\n-    abort ();\n-#endif\n-\n+  gcc_assert (t);\n   call = get_call_expr_in (t);\n   if (call)\n     {\n@@ -2556,7 +2531,7 @@ disband_implicit_edges (void)\n \t      else if (e->flags & EDGE_FALSE_VALUE)\n \t\tCOND_EXPR_ELSE (stmt) = build_empty_stmt ();\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      e->flags |= EDGE_FALLTHRU;\n \t    }\n \n@@ -2567,10 +2542,9 @@ disband_implicit_edges (void)\n \t{\n \t  /* Remove the RETURN_EXPR if we may fall though to the exit\n \t     instead.  */\n-\t  if (!bb->succ\n-\t      || bb->succ->succ_next\n-\t      || bb->succ->dest != EXIT_BLOCK_PTR)\n-\t    abort ();\n+\t  gcc_assert (bb->succ);\n+\t  gcc_assert (!bb->succ->succ_next);\n+\t  gcc_assert (bb->succ->dest == EXIT_BLOCK_PTR);\n \n \t  if (bb->next_bb == EXIT_BLOCK_PTR\n \t      && !TREE_OPERAND (stmt, 0))\n@@ -2594,9 +2568,7 @@ disband_implicit_edges (void)\n       if (!e || e->dest == bb->next_bb)\n \tcontinue;\n \n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tabort ();\n-\n+      gcc_assert (e->dest != EXIT_BLOCK_PTR);\n       label = tree_block_label (e->dest);\n \n       stmt = build1 (GOTO_EXPR, void_type_node, label);\n@@ -2720,14 +2692,9 @@ set_bb_for_stmt (tree t, basic_block bb)\n \t\tVARRAY_GROW (label_to_block_map, 3 * uid / 2);\n \t    }\n \t  else\n-\t    {\n-#ifdef ENABLE_CHECKING\n-\t      /* We're moving an existing label.  Make sure that we've\n-\t\t removed it from the old block.  */\n-\t      if (bb && VARRAY_BB (label_to_block_map, uid))\n-\t\tabort ();\n-#endif\n-\t    }\n+\t    /* We're moving an existing label.  Make sure that we've\n+\t\tremoved it from the old block.  */\n+\t    gcc_assert (!bb || !VARRAY_BB (label_to_block_map, uid));\n \t  VARRAY_BB (label_to_block_map, uid) = bb;\n \t}\n     }\n@@ -2744,7 +2711,7 @@ stmt_for_bsi (tree stmt)\n     if (bsi_stmt (bsi) == stmt)\n       return bsi;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Insert statement (or statement list) T before the statement\n@@ -2926,8 +2893,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n \t  tree op = TREE_OPERAND (tmp, 0);\n \t  if (!is_gimple_val (op))\n \t    {\n-\t      if (TREE_CODE (op) != MODIFY_EXPR)\n-\t\tabort ();\n+\t      gcc_assert (TREE_CODE (op) == MODIFY_EXPR);\n \t      bsi_insert_before (bsi, op, BSI_NEW_STMT);\n \t      TREE_OPERAND (tmp, 0) = TREE_OPERAND (op, 0);\n \t    }\n@@ -3009,8 +2975,7 @@ bsi_insert_on_edge_immediate (edge e, tree stmt)\n   block_stmt_iterator bsi;\n   basic_block new_bb = NULL;\n \n-  if (PENDING_STMT (e))\n-    abort ();\n+  gcc_assert (!PENDING_STMT (e));\n \n   if (tree_find_edge_insert_loc (e, &bsi, &new_bb))\n     bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n@@ -3036,8 +3001,7 @@ tree_split_edge (edge edge_in)\n   int i, num_elem;\n \n   /* Abnormal edges cannot be split.  */\n-  if (edge_in->flags & EDGE_ABNORMAL)\n-    abort ();\n+  gcc_assert (!(edge_in->flags & EDGE_ABNORMAL));\n \n   src = edge_in->src;\n   dest = edge_in->dest;\n@@ -3070,11 +3034,9 @@ tree_split_edge (edge edge_in)\n \t  }\n     }\n \n-  if (!redirect_edge_and_branch (edge_in, new_bb))\n-    abort ();\n-\n-  if (PENDING_STMT (edge_in))\n-    abort ();\n+  e = redirect_edge_and_branch (edge_in, new_bb);\n+  gcc_assert (e);\n+  gcc_assert (!PENDING_STMT (edge_in));\n \n   return new_bb;\n }\n@@ -3655,8 +3617,7 @@ tree_verify_flow_info (void)\n \t\ttree lab = CASE_LABEL (TREE_VEC_ELT (vec, i));\n \t\tbasic_block label_bb = label_to_block (lab);\n \n-\t\tif (label_bb->aux && label_bb->aux != (void *)1)\n-\t\t  abort ();\n+\t\tgcc_assert (!label_bb->aux || label_bb->aux == (void *)1);\n \t\tlabel_bb->aux = (void *)1;\n \t      }\n \n@@ -3962,8 +3923,7 @@ thread_jumps (void)\n \t      for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n \t\t{\n \t\t  arg = phi_arg_from_edge (phi, last);\n-\t\t  if (arg < 0)\n-\t\t    abort ();\n+\t\t  gcc_assert (arg >= 0);\n \t\t  add_phi_arg (&phi, PHI_ARG_DEF (phi, arg), e);\n \t\t}\n \t    }\n@@ -4130,7 +4090,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n     case GOTO_EXPR:\n       /* No non-abnormal edges should lead from a non-simple goto, and\n \t simple ones should be represented implicitly.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case SWITCH_EXPR:\n       {\n@@ -4154,8 +4114,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n     default:\n       /* Otherwise it must be a fallthru edge, and we don't need to\n \t do anything besides redirecting it.  */\n-      if (!(e->flags & EDGE_FALLTHRU))\n-\tabort ();\n+      gcc_assert (e->flags & EDGE_FALLTHRU);\n       break;\n     }\n \n@@ -4174,8 +4133,7 @@ static basic_block\n tree_redirect_edge_and_branch_force (edge e, basic_block dest)\n {\n   e = tree_redirect_edge_and_branch (e, dest);\n-  if (!e)\n-    abort ();\n+  gcc_assert (e);\n \n   return NULL;\n }\n@@ -4650,8 +4608,7 @@ tree_flow_call_edges_add (sbitmap blocks)\n #ifdef ENABLE_CHECKING\n \t\t  if (stmt == last_stmt)\n \t\t    for (e = bb->succ; e; e = e->succ_next)\n-\t\t      if (e->dest == EXIT_BLOCK_PTR)\n-\t\t\tabort ();\n+\t\t      gcc_assert (e->dest != EXIT_BLOCK_PTR);\n #endif\n \n \t\t  /* Note that the following may create a new basic block"}, {"sha": "0929f69d6df46314edb15adfdf52593ae6be3d26", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -56,13 +56,10 @@ chrec_fold_poly_cst (enum tree_code code,\n \t\t     tree poly, \n \t\t     tree cst)\n {\n-#if defined ENABLE_CHECKING\n-  if (poly == NULL_TREE\n-      || cst == NULL_TREE\n-      || TREE_CODE (poly) != POLYNOMIAL_CHREC\n-      || is_not_constant_evolution (cst))\n-    abort ();\n-#endif\n+  gcc_assert (poly);\n+  gcc_assert (cst);\n+  gcc_assert (TREE_CODE (poly) == POLYNOMIAL_CHREC);\n+  gcc_assert (!is_not_constant_evolution (cst));\n   \n   switch (code)\n     {\n@@ -98,14 +95,11 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n \t\t\t   tree poly1)\n {\n   tree left, right;\n-  \n-#if defined ENABLE_CHECKING\n-  if (poly0 == NULL_TREE\n-      || poly1 == NULL_TREE\n-      || TREE_CODE (poly0) != POLYNOMIAL_CHREC\n-      || TREE_CODE (poly1) != POLYNOMIAL_CHREC)\n-    abort ();\n-#endif\n+\n+  gcc_assert (poly0);\n+  gcc_assert (poly1);\n+  gcc_assert (TREE_CODE (poly0) == POLYNOMIAL_CHREC);\n+  gcc_assert (TREE_CODE (poly1) == POLYNOMIAL_CHREC);\n   \n   /*\n     {a, +, b}_1 + {c, +, d}_2  ->  {{a, +, b}_1 + c, +, d}_2,\n@@ -171,13 +165,10 @@ chrec_fold_multiply_poly_poly (tree type,\n \t\t\t       tree poly0, \n \t\t\t       tree poly1)\n {\n-#if defined ENABLE_CHECKING\n-  if (poly0 == NULL_TREE\n-      || poly1 == NULL_TREE\n-      || TREE_CODE (poly0) != POLYNOMIAL_CHREC\n-      || TREE_CODE (poly1) != POLYNOMIAL_CHREC)\n-    abort ();\n-#endif\n+  gcc_assert (poly0);\n+  gcc_assert (poly1);\n+  gcc_assert (TREE_CODE (poly0) == POLYNOMIAL_CHREC);\n+  gcc_assert (TREE_CODE (poly1) == POLYNOMIAL_CHREC);\n   \n   /* {a, +, b}_1 * {c, +, d}_2  ->  {c*{a, +, b}_1, +, d}_2,\n      {a, +, b}_2 * {c, +, d}_1  ->  {a*{c, +, d}_1, +, b}_2,"}, {"sha": "363e3a2d578e6137d11b77b6081d916147b5d021", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -64,7 +64,7 @@ extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return gimplify_val (bsi, inner_type, ret);\n@@ -285,7 +285,7 @@ expand_complex_division (block_stmt_iterator *bsi, tree inner_type,\n       break;\n     default:\n       /* C99-like requirements for complex divide (not yet implemented).  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -349,7 +349,7 @@ expand_complex_comparison (block_stmt_iterator *bsi, tree ar, tree ai,\n       TREE_OPERAND (stmt, 0) = cc;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   modify_stmt (stmt);\n@@ -472,7 +472,7 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -486,8 +486,7 @@ build_replicated_const (tree type, tree inner_type, HOST_WIDE_INT value)\n   unsigned HOST_WIDE_INT low, high, mask;\n   tree ret;\n \n-  if (n == 0)\n-    abort ();\n+  gcc_assert (n);\n \n   if (width == HOST_BITS_PER_WIDE_INT)\n     low = value;\n@@ -504,7 +503,7 @@ build_replicated_const (tree type, tree inner_type, HOST_WIDE_INT value)\n   else if (TYPE_PRECISION (type) == 2 * HOST_BITS_PER_WIDE_INT)\n     high = low;\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   ret = build_int_cst_wide (type, low, high);\n   return ret;\n@@ -783,10 +782,8 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n \n   if (code == NOP_EXPR || code == VIEW_CONVERT_EXPR)\n     return;\n-\n-  if (code == CONVERT_EXPR)\n-    abort ();\n-\n+  \n+  gcc_assert (code != CONVERT_EXPR);\n   op = optab_for_tree_code (code, type);\n \n   /* Optabs will try converting a negation into a subtraction, so"}, {"sha": "db5dea62829610220d4bde02c04e0733933af250", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -270,21 +270,19 @@ tree_fold_bezout (tree a1,\n       zs2 = fold (build (MULT_EXPR, integer_type_node, z, s2));\n       \n       /* row1 -= z * row2.  */\n+      gcc_assert (sign != 0);\n       if (sign < 0)\n \t{\n \t  *u11 = fold (build (PLUS_EXPR, integer_type_node, *u11, zu21));\n \t  *u12 = fold (build (PLUS_EXPR, integer_type_node, *u12, zu22));\n \t  s1 = fold (build (PLUS_EXPR, integer_type_node, s1, zs2));\n \t}\n-      else if (sign > 0)\n+      else\n \t{\n \t  *u11 = fold (build (MINUS_EXPR, integer_type_node, *u11, zu21));\n \t  *u12 = fold (build (MINUS_EXPR, integer_type_node, *u12, zu22));\n \t  s1 = fold (build (MINUS_EXPR, integer_type_node, s1, zs2));\n \t}\n-      else\n-\t/* Should not happen.  */\n-\tabort ();\n       \n       /* Interchange row1 and row2.  */\n       {\n@@ -1466,8 +1464,8 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t  /* If the loop number is still greater than the number of\n \t     loops we've been asked to analyze, or negative,\n \t     something is borked.  */\n-\t  if (loop_nb < 0 || loop_nb >= nb_loops)\n-\t    abort ();\n+\t  gcc_assert (loop_nb >= 0);\n+\t  gcc_assert (loop_nb < nb_loops);\n \t  dist = int_cst_value (SUB_DISTANCE (subscript));\n \n \t  /* This is the subscript coupling test.  \n@@ -1508,8 +1506,8 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n     \n     lca_nb = lca->num;\n     lca_nb -= first_loop;\n-    if (lca_nb < 0 || lca_nb >= nb_loops)\n-      abort ();\n+    gcc_assert (lca_nb >= 0);\n+    gcc_assert (lca_nb < nb_loops);\n     /* For each outer loop where init_v is not set, the accesses are\n        in dependence of distance 1 in the loop.  */\n     if (lca != loop_a\n@@ -1524,8 +1522,8 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \tlca_nb = lca->num - first_loop;\n \twhile (lca->depth != 0)\n \t  {\n-\t    if (lca_nb < 0 || lca_nb >= nb_loops)\n-\t      abort ();\n+\t    gcc_assert (lca_nb >= 0);\n+\t    gcc_assert (lca_nb < nb_loops);\n \t    if (init_v[lca_nb] == 0)\n \t      dist_v[lca_nb] = 1;\n \t    lca = lca->outer;\n@@ -1575,13 +1573,9 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \t  /* If the loop number is still greater than the number of\n \t     loops we've been asked to analyze, or negative,\n \t     something is borked.  */\n-\t  if (loop_nb < 0 || loop_nb >= nb_loops)\n-\t    abort ();\t  \n-\t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n-\t    {\n-\t      \n-\t    }\n-\t  else\n+\t  gcc_assert (loop_nb >= 0);\n+\t  gcc_assert (loop_nb < nb_loops);\n+\t  if (!chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t    {\n \t      int dist = int_cst_value (SUB_DISTANCE (subscript));\n \t      \n@@ -1632,8 +1626,8 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n     lca = find_common_loop (loop_a, loop_b); \n     lca_nb = lca->num - first_loop;\n \n-    if (lca_nb < 0 || lca_nb >= nb_loops)\n-      abort ();\n+    gcc_assert (lca_nb >= 0);\n+    gcc_assert (lca_nb < nb_loops);\n     /* For each outer loop where init_v is not set, the accesses are\n        in dependence of distance 1 in the loop.  */\n     if (lca != loop_a\n@@ -1647,8 +1641,8 @@ build_classic_dir_vector (struct data_dependence_relation *ddr,\n \tlca_nb = lca->num - first_loop;\n \twhile (lca->depth != 0)\n \t  {\n-\t    if (lca_nb < 0 || lca_nb >= nb_loops)\n-\t      abort ();\n+\t    gcc_assert (lca_nb >= 0);\n+\t    gcc_assert (lca_nb < nb_loops);\n \t    if (init_v[lca_nb] == 0)\n \t      dir_v[lca_nb] = dir_positive;\n \t    lca = lca->outer;"}, {"sha": "ad14e12bc7adcb93e275749148f38e0119a01859", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -244,10 +244,7 @@ compute_immediate_uses_for_phi (tree phi, bool (*calc_for)(tree))\n {\n   int i;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (phi) != PHI_NODE)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (phi) == PHI_NODE);\n \n   for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n     {\n@@ -274,11 +271,8 @@ compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n   tree use;\n   ssa_op_iter iter;\n \n-#ifdef ENABLE_CHECKING\n   /* PHI nodes are handled elsewhere.  */\n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n \n   /* Look at USE_OPS or VUSE_OPS according to FLAGS.  */\n   if (flags & TDFA_USE_OPS)\n@@ -382,13 +376,9 @@ create_var_ann (tree t)\n {\n   var_ann_t ann;\n \n-#if defined ENABLE_CHECKING\n-  if (t == NULL_TREE\n-      || !DECL_P (t)\n-      || (t->common.ann\n-\t  && t->common.ann->common.type != VAR_ANN))\n-    abort ();\n-#endif\n+  gcc_assert (t);\n+  gcc_assert (DECL_P (t));\n+  gcc_assert (!t->common.ann || t->common.ann->common.type == VAR_ANN);\n \n   ann = ggc_alloc (sizeof (*ann));\n   memset ((void *) ann, 0, sizeof (*ann));\n@@ -408,12 +398,8 @@ create_stmt_ann (tree t)\n {\n   stmt_ann_t ann;\n \n-#if defined ENABLE_CHECKING\n-  if ((!is_gimple_stmt (t))\n-      || (t->common.ann\n-\t  && t->common.ann->common.type != STMT_ANN))\n-    abort ();\n-#endif\n+  gcc_assert (is_gimple_stmt (t));\n+  gcc_assert (!t->common.ann || t->common.ann->common.type == STMT_ANN);\n \n   ann = ggc_alloc (sizeof (*ann));\n   memset ((void *) ann, 0, sizeof (*ann));\n@@ -436,12 +422,8 @@ create_tree_ann (tree t)\n {\n   tree_ann_t ann;\n \n-#if defined ENABLE_CHECKING\n-  if (t == NULL_TREE\n-      || (t->common.ann\n-\t  && t->common.ann->common.type != TREE_ANN_COMMON))\n-    abort ();\n-#endif\n+  gcc_assert (t);\n+  gcc_assert (!t->common.ann || t->common.ann->common.type == TREE_ANN_COMMON);\n \n   ann = ggc_alloc (sizeof (*ann));\n   memset ((void *) ann, 0, sizeof (*ann));\n@@ -750,8 +732,7 @@ collect_dfa_stats (struct dfa_stats_d *dfa_stats_p)\n   basic_block bb;\n   block_stmt_iterator i;\n \n-  if (dfa_stats_p == NULL)\n-    abort ();\n+  gcc_assert (dfa_stats_p);\n \n   memset ((void *)dfa_stats_p, 0, sizeof (struct dfa_stats_d));\n \n@@ -906,14 +887,11 @@ get_virtual_var (tree var)\n \t || handled_component_p (var))\n     var = TREE_OPERAND (var, 0);\n \n-#ifdef ENABLE_CHECKING\n   /* Treating GIMPLE registers as virtual variables makes no sense.\n      Also complain if we couldn't extract a _DECL out of the original\n      expression.  */\n-  if (!SSA_VAR_P (var)\n-      || is_gimple_reg (var))\n-    abort ();\n-#endif\n+  gcc_assert (SSA_VAR_P (var));\n+  gcc_assert (!is_gimple_reg (var));\n \n   return var;\n }"}, {"sha": "c09fc531a5526d2477ba3b7e060523c7ebd5781a", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -274,7 +274,7 @@ dequeue_and_dump (dump_info_p di)\n \t  else if (access == access_private_node)\n \t    string = \"priv\";\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \n \t  dump_string (di, string);\n \t  queue_and_dump_index (di, \"binf\", base, DUMP_BINFO);\n@@ -309,7 +309,7 @@ dequeue_and_dump (dump_info_p di)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else if (DECL_P (t))"}, {"sha": "008632de728c50d7115acc24c10b8f13a45f7771", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -103,8 +103,7 @@ record_stmt_eh_region (struct eh_region *region, tree t)\n   n->region_nr = get_eh_region_number (region);\n \n   slot = htab_find_slot (throw_stmt_table, n, INSERT);\n-  if (*slot)\n-    abort ();\n+  gcc_assert (!*slot);\n   *slot = n;\n }\n \n@@ -114,16 +113,14 @@ add_stmt_to_eh_region (tree t, int num)\n   struct throw_stmt_node *n;\n   void **slot;\n \n-  if (num < 0)\n-    abort ();\n+  gcc_assert (num >= 0);\n \n   n = ggc_alloc (sizeof (*n));\n   n->stmt = t;\n   n->region_nr = num;\n \n   slot = htab_find_slot (throw_stmt_table, n, INSERT);\n-  if (*slot)\n-    abort ();\n+  gcc_assert (!*slot);\n   *slot = n;\n }\n \n@@ -186,8 +183,7 @@ record_in_finally_tree (tree child, tree parent)\n   n->parent = parent;\n \n   slot = htab_find_slot (finally_tree, n, INSERT);\n-  if (*slot)\n-    abort ();\n+  gcc_assert (!*slot);\n   *slot = n;\n }\n \n@@ -422,7 +418,7 @@ replace_goto_queue_1 (tree t, struct leh_tf_state *tf, tree_stmt_iterator *tsi)\n       break;\n \n     case STATEMENT_LIST:\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n       /* These won't have gotos in them.  */\n@@ -505,7 +501,7 @@ maybe_record_in_goto_queue (struct leh_state *state, tree stmt)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   active = tf->goto_queue_active;\n@@ -547,8 +543,7 @@ verify_norecord_switch_expr (struct leh_state *state, tree switch_expr)\n   for (i = 0; i < n; ++i)\n     {\n       tree lab = CASE_LABEL (TREE_VEC_ELT (vec, i));\n-      if (outside_finally_tree (lab, tf->try_finally_expr))\n-\tabort ();\n+      gcc_assert (!outside_finally_tree (lab, tf->try_finally_expr));\n     }\n }\n #else\n@@ -591,47 +586,51 @@ do_return_redirection (struct goto_queue_node *q, tree finlab, tree mod,\n \t  depends, I guess, but it does make generation of the switch in\n \t  lower_try_finally_switch easier.  */\n \n-      if (TREE_CODE (ret_expr) == RESULT_DECL)\n+      switch (TREE_CODE (ret_expr))\n \t{\n+\tcase RESULT_DECL:\n \t  if (!*return_value_p)\n \t    *return_value_p = ret_expr;\n-\t  else if (*return_value_p != ret_expr)\n-\t    abort ();\n-          q->cont_stmt = q->stmt;\n-\t}\n-      else if (TREE_CODE (ret_expr) == MODIFY_EXPR)\n-\t{\n-\t  tree result = TREE_OPERAND (ret_expr, 0);\n-\t  tree new, old = TREE_OPERAND (ret_expr, 1);\n-\n-\t  if (!*return_value_p)\n-\t    {\n-\t      if (aggregate_value_p (TREE_TYPE (result),\n-\t\t\t\t     TREE_TYPE (current_function_decl)))\n-\t\t/* If this function returns in memory, copy the argument\n-\t\t   into the return slot now.  Otherwise, we might need to\n-\t\t   worry about magic return semantics, so we need to use a\n-\t\t   temporary to hold the value until we're actually ready\n-\t\t   to return.  */\n-\t\tnew = result;\n-\t      else\n-\t\tnew = create_tmp_var (TREE_TYPE (old), \"rettmp\");\n-\t      *return_value_p = new;\n-\t    }\n \t  else\n-\t    new = *return_value_p;\n+\t    gcc_assert (*return_value_p == ret_expr);\n+\t  q->cont_stmt = q->stmt;\n+\t  break;\n \n-\t  x = build (MODIFY_EXPR, TREE_TYPE (new), new, old);\n-\t  append_to_statement_list (x, &q->repl_stmt);\n+\tcase MODIFY_EXPR:\n+\t  {\n+\t    tree result = TREE_OPERAND (ret_expr, 0);\n+\t    tree new, old = TREE_OPERAND (ret_expr, 1);\n+\n+\t    if (!*return_value_p)\n+\t      {\n+\t\tif (aggregate_value_p (TREE_TYPE (result),\n+\t\t\t\t      TREE_TYPE (current_function_decl)))\n+\t\t  /* If this function returns in memory, copy the argument\n+\t\t    into the return slot now.  Otherwise, we might need to\n+\t\t    worry about magic return semantics, so we need to use a\n+\t\t    temporary to hold the value until we're actually ready\n+\t\t    to return.  */\n+\t\t  new = result;\n+\t\telse\n+\t\t  new = create_tmp_var (TREE_TYPE (old), \"rettmp\");\n+\t\t*return_value_p = new;\n+\t      }\n+\t    else\n+\t      new = *return_value_p;\n+\n+\t    x = build (MODIFY_EXPR, TREE_TYPE (new), new, old);\n+\t    append_to_statement_list (x, &q->repl_stmt);\n+\n+\t    if (new == result)\n+\t      x = result;\n+\t    else\n+\t      x = build (MODIFY_EXPR, TREE_TYPE (result), result, new);\n+\t    q->cont_stmt = build1 (RETURN_EXPR, void_type_node, x);\n+\t  }\n \n-\t  if (new == result)\n-\t    x = result;\n-\t  else\n-\t    x = build (MODIFY_EXPR, TREE_TYPE (result), result, new);\n-\t  q->cont_stmt = build1 (RETURN_EXPR, void_type_node, x);\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n     }\n   else\n     {"}, {"sha": "cd2bf9ec082ee0c4091f275fdeac9a600338112d", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 19, "deletions": 57, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -30,13 +30,9 @@ Boston, MA 02111-1307, USA.  */\n static inline var_ann_t\n var_ann (tree t)\n {\n-#if defined ENABLE_CHECKING\n-  if (t == NULL_TREE\n-      || !DECL_P (t)\n-      || (t->common.ann\n-\t  && t->common.ann->common.type != VAR_ANN))\n-    abort ();\n-#endif\n+  gcc_assert (t);\n+  gcc_assert (DECL_P (t));\n+  gcc_assert (!t->common.ann || t->common.ann->common.type == VAR_ANN);\n \n   return (var_ann_t) t->common.ann;\n }\n@@ -55,11 +51,9 @@ get_var_ann (tree var)\n static inline stmt_ann_t\n stmt_ann (tree t)\n {\n-#if defined ENABLE_CHECKING\n-  if (!is_gimple_stmt (t))\n-    abort ();\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (is_gimple_stmt (t));\n #endif\n-\n   return (stmt_ann_t) t->common.ann;\n }\n \n@@ -223,21 +217,15 @@ get_def_from_ptr (def_operand_p def)\n static inline use_operand_p\n get_use_op_ptr (use_optype uses, unsigned int index)\n {\n-#ifdef ENABLE_CHECKING\n-  if (index >= uses->num_uses)\n-    abort();\n-#endif\n+  gcc_assert (index < uses->num_uses);\n   return uses->uses[index];\n }\n \n /* Return a def_operand_p pointer for element INDEX of DEFS.  */\n static inline def_operand_p\n get_def_op_ptr (def_optype defs, unsigned int index)\n {\n-#ifdef ENABLE_CHECKING\n-  if (index >= defs->num_defs)\n-    abort();\n-#endif\n+  gcc_assert (index < defs->num_defs);\n   return defs->defs[index];\n }\n \n@@ -248,10 +236,7 @@ static inline def_operand_p\n get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n   def_operand_p op;\n-#ifdef ENABLE_CHECKING\n-  if (index >= v_may_defs->num_v_may_defs)\n-    abort();\n-#endif\n+  gcc_assert (index < v_may_defs->num_v_may_defs);\n   op.def = &(v_may_defs->v_may_defs[index].def);\n   return op;\n }\n@@ -262,10 +247,7 @@ static inline use_operand_p\n get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n   use_operand_p op;\n-#ifdef ENABLE_CHECKING\n-  if (index >= v_may_defs->num_v_may_defs)\n-    abort();\n-#endif\n+  gcc_assert (index < v_may_defs->num_v_may_defs);\n   op.use = &(v_may_defs->v_may_defs[index].use);\n   return op;\n }\n@@ -275,10 +257,7 @@ static inline use_operand_p\n get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n {\n   use_operand_p op;\n-#ifdef ENABLE_CHECKING\n-  if (index >= vuses->num_vuses)\n-    abort();\n-#endif\n+  gcc_assert (index < vuses->num_vuses);\n   op.use = &(vuses->vuses[index]);\n   return op;\n }\n@@ -289,10 +268,7 @@ static inline def_operand_p\n get_v_must_def_op_ptr (v_must_def_optype v_must_defs, unsigned int index)\n {\n   def_operand_p op;\n-#ifdef ENABLE_CHECKING\n-  if (index >= v_must_defs->num_v_must_defs)\n-    abort();\n-#endif\n+  gcc_assert (index < v_must_defs->num_v_must_defs);\n   op.def = &(v_must_defs->v_must_defs[index]);\n   return op;\n }\n@@ -358,8 +334,7 @@ immediate_use (dataflow_t df, int num)\n     return NULL_TREE;\n \n #ifdef ENABLE_CHECKING\n-  if (num >= num_immediate_uses (df))\n-    abort ();\n+  gcc_assert (num < num_immediate_uses (df));\n #endif\n   if (num < 2)\n     return df->uses[num];\n@@ -400,10 +375,8 @@ static inline int\n phi_arg_from_edge (tree phi, edge e)\n {\n   int i;\n-#if defined ENABLE_CHECKING\n-  if (!phi || TREE_CODE (phi) != PHI_NODE)\n-    abort();\n-#endif\n+  gcc_assert (phi);\n+  gcc_assert (TREE_CODE (phi) == PHI_NODE);\n \n   for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n     if (PHI_ARG_EDGE (phi, i) == e)\n@@ -477,8 +450,7 @@ phi_ssa_name_p (tree t)\n   if (TREE_CODE (t) == SSA_NAME)\n     return true;\n #ifdef ENABLE_CHECKING\n-  if (!is_gimple_min_invariant (t))\n-    abort ();\n+  gcc_assert (is_gimple_min_invariant (t));\n #endif\n   return false;\n }\n@@ -495,10 +467,7 @@ bsi_start (basic_block bb)\n     bsi.tsi = tsi_start (bb->stmt_list);\n   else\n     {\n-#ifdef ENABLE_CHECKING\n-      if (bb->index >= 0)\n-\tabort ();\n-#endif\n+      gcc_assert (bb->index < 0);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n     }\n@@ -519,10 +488,7 @@ bsi_after_labels (basic_block bb)\n \n   if (!bb->stmt_list)\n     {\n-#ifdef ENABLE_CHECKING\n-      if (bb->index >= 0)\n-\tabort ();\n-#endif\n+      gcc_assert (bb->index < 0);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n       return bsi;\n@@ -537,8 +503,7 @@ bsi_after_labels (basic_block bb)\n      be placed at the start of the basic block.  This would not work if the\n      first statement was not label; rather fail here than enable the user\n      proceed in wrong way.  */\n-  if (TREE_CODE (tsi_stmt (bsi.tsi)) != LABEL_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (tsi_stmt (bsi.tsi)) == LABEL_EXPR);\n \n   next = bsi.tsi;\n   tsi_next (&next);\n@@ -563,10 +528,7 @@ bsi_last (basic_block bb)\n     bsi.tsi = tsi_last (bb->stmt_list);\n   else\n     {\n-#ifdef ENABLE_CHECKING\n-      if (bb->index >= 0)\n-\tabort ();\n-#endif\n+      gcc_assert (bb->index < 0);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n     }"}, {"sha": "0c9a4b6487f89b170708917e7a8dcccdfc152820", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -257,8 +257,7 @@ tree_if_convert_stmt (struct loop *  loop, tree t, tree cond,\n       break;\n \n     default:\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n     }\n   return cond;\n }\n@@ -275,10 +274,7 @@ tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,\n   tree then_clause, else_clause, c, new_cond;\n   new_cond = NULL_TREE;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (stmt) != COND_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (stmt) == COND_EXPR);\n \n   c = TREE_OPERAND (stmt, 0);\n   then_clause = TREE_OPERAND (stmt, 1);\n@@ -634,10 +630,7 @@ add_to_dst_predicate_list (struct loop * loop, tree dst,\n   basic_block bb;\n   tree new_cond = NULL_TREE;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (dst) != GOTO_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (dst) == GOTO_EXPR);\n   bb = label_to_block (TREE_OPERAND (dst, 0));\n   if (!flow_bb_inside_loop_p (loop, bb))\n     return NULL_TREE;\n@@ -688,11 +681,11 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n     {\n       if (p1 == NULL)\n \t  p1 = e->src;\n-      else if (p2 == NULL)\n-\tp2 = e->src;\n-      else\n-\t/* More than two predecessors. This is not expected.  */\n-\tabort ();\n+      else \n+\t{\n+\t  gcc_assert (!p2);\n+\t  p2 = e->src;\n+\t}\n     }\n \n   /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n@@ -722,10 +715,7 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n       *cond = TREE_OPERAND (new_stmt, 0);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  if (*cond == NULL_TREE)\n-    abort ();\n-#endif\n+  gcc_assert (*cond);\n \n   return true_bb;\n }\n@@ -749,15 +739,11 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, basic_block true_bb,\n   basic_block bb;\n   tree rhs;\n   tree arg_0, arg_1;\n-  \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (phi) != PHI_NODE)\n-    abort ();\n \n+  gcc_assert (TREE_CODE (phi) == PHI_NODE);\n+  \n   /* If this is not filtered earlier, then now it is too late.  */\n-  if (PHI_NUM_ARGS (phi) != 2)\n-     abort ();\n-#endif\n+  gcc_assert (PHI_NUM_ARGS (phi) == 2);\n \n   /* Find basic block and initialize iterator.  */\n   bb = bb_for_stmt (phi);\n@@ -991,11 +977,8 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n   unsigned int index = 0;\n   unsigned int visited_count = 0;\n \n-  if (!loop->num_nodes)\n-    abort ();\n-\n-  if (loop->latch == EXIT_BLOCK_PTR)\n-    abort ();\n+  gcc_assert (loop->num_nodes);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n   blocks = xcalloc (loop->num_nodes, sizeof (basic_block));\n   visited = BITMAP_XMALLOC ();"}, {"sha": "7a80528ecfcbde8db1ec377a59cf9a693e79f536", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 22, "deletions": 44, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -206,8 +206,7 @@ remap_decl (tree decl, inline_data *id)\n \t    {\n \t      tree member = remap_decl (TREE_VALUE (src), id);\n \n-\t      if (TREE_PURPOSE (src))\n-\t\tabort ();\n+\t      gcc_assert (!TREE_PURPOSE (src));\n \t      members = tree_cons (NULL, member, members);\n \t    }\n \t  DECL_ANON_UNION_ELEMS (t) = nreverse (members);\n@@ -326,7 +325,7 @@ remap_type (tree type, inline_data *id)\n     case OFFSET_TYPE:\n     default:\n       /* Shouldn't have been thought variable sized.  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   walk_tree (&TYPE_SIZE (new), copy_body_r, id, NULL);\n@@ -354,12 +353,9 @@ remap_decls (tree decls, inline_data *id)\n \t already declared somewhere else, so don't declare it here.  */\n       if (!new_var || new_var == id->retvar)\n \t;\n-#ifdef ENABLE_CHECKING\n-      else if (!DECL_P (new_var))\n-\tabort ();\n-#endif\n       else\n \t{\n+\t  gcc_assert (DECL_P (new_var));\n \t  TREE_CHAIN (new_var) = new_decls;\n \t  new_decls = new_var;\n \t}\n@@ -461,8 +457,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n      what function they come from.  */\n   if ((TREE_CODE (*tp) == VAR_DECL || TREE_CODE (*tp) == LABEL_DECL)\n       && DECL_NAMESPACE_SCOPE_P (*tp))\n-    if (! DECL_EXTERNAL (*tp) && ! TREE_STATIC (*tp))\n-      abort ();\n+    gcc_assert (DECL_EXTERNAL (*tp) || TREE_STATIC (*tp));\n #endif\n \n   /* If this is a RETURN_EXPR, change it into a MODIFY_EXPR and a\n@@ -504,17 +499,11 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \n       /* Remap the declaration.  */\n       new_decl = remap_decl (*tp, id);\n-      if (! new_decl)\n-\tabort ();\n+      gcc_assert (new_decl);\n       /* Replace this variable with the copy.  */\n       STRIP_TYPE_NOPS (new_decl);\n       *tp = new_decl;\n     }\n-#if 0\n-  else if (nonstatic_local_decl_p (*tp)\n-\t   && DECL_CONTEXT (*tp) != VARRAY_TREE (id->fns, 0))\n-    abort ();\n-#endif\n   else if (TREE_CODE (*tp) == STATEMENT_LIST)\n     copy_statement_list (tp);\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n@@ -536,8 +525,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t= splay_tree_lookup (id->decl_map,\n \t\t\t     (splay_tree_key) TREE_OPERAND (*tp, 0));\n       /* We _must_ have seen the enclosing LABELED_BLOCK_EXPR.  */\n-      if (! n)\n-\tabort ();\n+      gcc_assert (n);\n       *tp = copy_node (*tp);\n       TREE_OPERAND (*tp, 0) = (tree) n->value;\n     }\n@@ -608,10 +596,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t      for (node = id->node->next_clone; node; node = node->next_clone)\n \t\t{\n \t\t  edge = cgraph_edge (node, old_node);\n-\t\t  if (edge)\n-\t\t    edge->call_expr = *tp;\n-\t\t  else\n-\t\t    abort ();\n+\t\t  gcc_assert (edge);\n+\t\t  edge->call_expr = *tp;\n \t\t}\n \t    }\n \t  else\n@@ -793,11 +779,10 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n   if (p)\n     {\n       /* No static chain?  Seems like a bug in tree-nested.c.  */\n-      if (!static_chain)\n-\tabort ();\n+      gcc_assert (static_chain);\n \n-       setup_one_parameter (id, p, static_chain, fn, &init_stmts, &vars,\n-\t\t\t    &gimplify_init_stmts_p);\n+      setup_one_parameter (id, p, static_chain, fn, &init_stmts, &vars,\n+\t\t\t   &gimplify_init_stmts_p);\n     }\n \n   if (gimplify_init_stmts_p)\n@@ -841,8 +826,7 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n     {\n       /* The front end shouldn't have used both return_slot_addr and\n \t a modify expression.  */\n-      if (modify_dest)\n-\tabort ();\n+      gcc_assert (!modify_dest);\n       if (DECL_BY_REFERENCE (result))\n \tvar = return_slot_addr;\n       else\n@@ -852,8 +836,7 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n     }\n \n   /* All types requiring non-trivial constructors should have been handled.  */\n-  if (TREE_ADDRESSABLE (callee_type))\n-    abort ();\n+  gcc_assert (!TREE_ADDRESSABLE (callee_type));\n \n   /* Attempt to avoid creating a new temporary variable.  */\n   if (modify_dest)\n@@ -886,8 +869,7 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n \t}\n     }\n \n-  if (TREE_CODE (TYPE_SIZE_UNIT (callee_type)) != INTEGER_CST)\n-    abort ();\n+  gcc_assert (TREE_CODE (TYPE_SIZE_UNIT (callee_type)) == INTEGER_CST);\n \n   var = copy_decl_for_inlining (result, callee, caller);\n   DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n@@ -1359,7 +1341,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n       }\n     default:\n       /* Abort here se we know we don't miss any nodes.  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return NULL;\n }\n@@ -1481,8 +1463,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n          where previous inlining turned indirect call into direct call by\n          constant propagating arguments.  In all other cases we hit a bug\n          (incorrect node sharing is most common reason for missing edges.  */\n-      if (!dest->needed)\n-\tabort ();\n+      gcc_assert (dest->needed);\n       cgraph_create_edge (id->node, dest, t)->inline_failed\n \t= N_(\"originally indirect function call not considered for inlining\");\n       goto egress;\n@@ -1585,9 +1566,8 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   DECL_CONTEXT (id->ret_label) = VARRAY_TREE (id->fns, 0);\n   insert_decl_map (id, id->ret_label, id->ret_label);\n \n-  if (! DECL_INITIAL (fn)\n-      || TREE_CODE (DECL_INITIAL (fn)) != BLOCK)\n-    abort ();\n+  gcc_assert (DECL_INITIAL (fn));\n+  gcc_assert (TREE_CODE (DECL_INITIAL (fn)) == BLOCK);\n \n   /* Find the lhs to which the result of this call is assigned.  */\n   modify_dest = tsi_stmt (id->tsi);\n@@ -1725,7 +1705,7 @@ expand_calls_inline (tree *stmt_p, inline_data *id)\n \n     case COMPOUND_EXPR:\n       /* We're gimple.  We should have gotten rid of all these.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case RETURN_EXPR:\n       stmt_p = &TREE_OPERAND (stmt, 0);\n@@ -1817,8 +1797,7 @@ optimize_inline_calls (tree fn)\n \n       /* Double check that we inlined everything we are supposed to inline.  */\n       for (e = id.node->callees; e; e = e->next_callee)\n-\tif (!e->inline_failed)\n-\t  abort ();\n+\tgcc_assert (e->inline_failed);\n     }\n #endif\n }\n@@ -2303,9 +2282,8 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     *walk_subtrees = 0;\n   else if (TREE_CODE_CLASS (code) == 'd')\n     *walk_subtrees = 0;\n- else if (code == STATEMENT_LIST)\n-    abort ();\n-\n+  else\n+    gcc_assert (code != STATEMENT_LIST);\n   return NULL_TREE;\n }\n "}, {"sha": "bbec1b2d726d585cd550538a4771b6da8f1ff34a", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -649,17 +649,14 @@ rewrite_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_U\n \t\t\t\t     basic_block bb ATTRIBUTE_UNUSED,\n \t\t\t\t     bool recycled ATTRIBUTE_UNUSED)\n {\n-#ifdef ENABLE_CHECKING\n   struct rewrite_block_data *bd\n     = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n                                                                                 \n   /* We get cleared memory from the allocator, so if the memory is\n      not cleared, then we are re-using a previously allocated entry.  In\n      that case, we can also re-use the underlying virtual arrays.  Just\n      make sure we clear them before using them!  */\n-  if (recycled && bd->block_defs && VARRAY_ACTIVE_SIZE (bd->block_defs) > 0)\n-    abort ();\n-#endif\n+  gcc_assert (!recycled || !bd->block_defs || !(VARRAY_ACTIVE_SIZE (bd->block_defs) > 0));\n }\n \n \n@@ -1064,12 +1061,9 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-#if defined ENABLE_CHECKING\n   /* We have just scanned the code for operands.  No statement should\n      be modified.  */\n-  if (ann->modified)\n-    abort ();\n-#endif\n+  gcc_assert (!ann->modified);\n \n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n@@ -1114,12 +1108,9 @@ ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-#if defined ENABLE_CHECKING\n   /* We have just scanned the code for operands.  No statement should\n      be modified.  */\n-  if (ann->modified)\n-    abort ();\n-#endif\n+  gcc_assert (!ann->modified);\n \n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n@@ -1421,9 +1412,7 @@ rewrite_into_ssa (bool all)\n   else\n     {\n       /* Initialize the array of variables to rename.  */\n- \n-      if (vars_to_rename == NULL)\n-\tabort ();\n+      gcc_assert (vars_to_rename);\n \n       if (bitmap_first_set_bit (vars_to_rename) < 0)\n \t{"}, {"sha": "1b781609ee284e4b9a181740254a25d56ca086d9", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -52,10 +52,8 @@ alloc_stmt_list (void)\n void\n free_stmt_list (tree t)\n {\n-#ifdef ENABLE_CHECKING\n-  if (STATEMENT_LIST_HEAD (t) || STATEMENT_LIST_TAIL (t))\n-    abort ();\n-#endif\n+  gcc_assert (!STATEMENT_LIST_HEAD (t));\n+  gcc_assert (!STATEMENT_LIST_TAIL (t));\n   TREE_CHAIN (t) = stmt_list_cache;\n   stmt_list_cache = t;\n }\n@@ -68,8 +66,7 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n   struct tree_statement_list_node *head, *tail, *cur;\n \n   /* Die on looping.  */\n-  if (t == i->container)\n-    abort ();\n+  gcc_assert (t != i->container);\n \n   if (TREE_CODE (t) == STATEMENT_LIST)\n     {\n@@ -83,8 +80,7 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       /* Empty statement lists need no work.  */\n       if (!head || !tail)\n \t{\n-\t  if (head != tail)\n-\t    abort ();\n+\t  gcc_assert (head == tail);\n \t  return;\n \t}\n     }\n@@ -114,8 +110,7 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n     }\n   else\n     {\n-      if (STATEMENT_LIST_TAIL (i->container))\n-\tabort ();\n+      gcc_assert (!STATEMENT_LIST_TAIL (i->container));\n       STATEMENT_LIST_HEAD (i->container) = head;\n       STATEMENT_LIST_TAIL (i->container) = tail;\n     }\n@@ -132,8 +127,7 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       i->ptr = tail;\n       break;\n     case TSI_SAME_STMT:\n-      if (!cur)\n-\tabort ();\n+      gcc_assert (cur);\n       break;\n     }\n }\n@@ -146,8 +140,7 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n   struct tree_statement_list_node *head, *tail, *cur;\n \n   /* Die on looping.  */\n-  if (t == i->container)\n-    abort ();\n+  gcc_assert (t != i->container);\n \n   if (TREE_CODE (t) == STATEMENT_LIST)\n     {\n@@ -161,8 +154,7 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       /* Empty statement lists need no work.  */\n       if (!head || !tail)\n \t{\n-\t  if (head != tail)\n-\t    abort ();\n+\t  gcc_assert (head == tail);\n \t  return;\n \t}\n     }\n@@ -192,8 +184,7 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n     }\n   else\n     {\n-      if (STATEMENT_LIST_TAIL (i->container))\n-\tabort ();\n+      gcc_assert (!STATEMENT_LIST_TAIL (i->container));\n       STATEMENT_LIST_HEAD (i->container) = head;\n       STATEMENT_LIST_TAIL (i->container) = tail;\n     }\n@@ -210,8 +201,7 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       i->ptr = tail;\n       break;\n     case TSI_SAME_STMT:\n-      if (!cur)\n-        abort ();\n+      gcc_assert (cur);\n       break;\n     }\n }\n@@ -254,8 +244,7 @@ tsi_split_statement_list_after (const tree_stmt_iterator *i)\n \n   cur = i->ptr;\n   /* How can we possibly split after the end, or before the beginning?  */\n-  if (cur == NULL)\n-    abort ();\n+  gcc_assert (cur);\n   next = cur->next;\n \n   old_sl = i->container;\n@@ -282,8 +271,7 @@ tsi_split_statement_list_before (tree_stmt_iterator *i)\n \n   cur = i->ptr;\n   /* How can we possibly split after the end, or before the beginning?  */\n-  if (cur == NULL)\n-    abort ();\n+  gcc_assert (cur);\n   prev = cur->prev;\n \n   old_sl = i->container;"}, {"sha": "ba589f9f0507e8290cf96c6859fca414979f0956", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -102,8 +102,7 @@ mf_varname_tree (tree decl)\n   const char *buf_contents;\n   tree result;\n \n-  if (decl == NULL_TREE)\n-    abort ();\n+  gcc_assert (decl);\n \n   if (!initialized)\n     {"}, {"sha": "3b7e3c5d7ac736b5e83d3add03058fe3de58147d", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -132,15 +132,12 @@ create_tmp_var_for (struct nesting_info *info, tree type, const char *prefix)\n {\n   tree tmp_var;\n \n-#if defined ENABLE_CHECKING\n   /* If the type is of variable size or a type which must be created by the\n      frontend, something is wrong.  Note that we explicitly allow\n      incomplete types here, since we create them ourselves here.  */\n-  if (TREE_ADDRESSABLE (type)\n-      || (TYPE_SIZE_UNIT (type)\n-\t  && TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST))\n-    abort ();\n-#endif\n+  gcc_assert (TREE_ADDRESSABLE (type));\n+  gcc_assert (!TYPE_SIZE_UNIT (type)\n+\t      || TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST);\n \n   tmp_var = create_tmp_var_raw (type, prefix);\n   DECL_CONTEXT (tmp_var) = info->context;\n@@ -249,8 +246,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n   slot = htab_find_slot (info->var_map, &dummy, insert);\n   if (!slot)\n     {\n-      if (insert == INSERT)\n-\tabort ();\n+      gcc_assert (insert != INSERT);\n       return NULL;\n     }\n   elt = *slot;\n@@ -434,8 +430,7 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n   slot = htab_find_slot (info->var_map, &dummy, insert);\n   if (!slot)\n     {\n-      if (insert == INSERT)\n-\tabort ();\n+      gcc_assert (insert != INSERT);\n       return NULL;\n     }\n   elt = *slot;\n@@ -1194,12 +1189,7 @@ convert_all_function_calls (struct nesting_info *root)\n       if (root->outer && !root->chain_decl && !root->chain_field)\n \tDECL_NO_STATIC_CHAIN (root->context) = 1;\n       else\n-\t{\n-#ifdef ENABLE_CHECKING\n-\t  if (DECL_NO_STATIC_CHAIN (root->context))\n-\t    abort ();\n-#endif\n-\t}\n+\tgcc_assert (!DECL_NO_STATIC_CHAIN (root->context));\n \n       root = root->next;\n     }"}, {"sha": "e1687af4fc0c73eabdb755f14e6c4c539f0dd59b", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -555,8 +555,7 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n \n   timevar_push (TV_EXPAND);\n \n-  if (flag_unit_at_a_time && !cgraph_global_info_ready)\n-    abort ();\n+  gcc_assert (!flag_unit_at_a_time || cgraph_global_info_ready);\n \n   /* Initialize the RTL code for the function.  */\n   current_function_decl = fndecl;"}, {"sha": "3910501f1ea2d912a5bdb346a3564ee9083efe2c", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 56, "deletions": 66, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -146,10 +146,8 @@ create_temp (tree t)\n \n   if (TREE_CODE (t) == SSA_NAME)\n     t = SSA_NAME_VAR (t);\n- \n-  if (TREE_CODE (t) != VAR_DECL \n-      && TREE_CODE (t) != PARM_DECL)\n-    abort ();\n+\n+  gcc_assert (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL);\n \n   type = TREE_TYPE (t);\n   tmp = DECL_NAME (t);\n@@ -368,8 +366,7 @@ eliminate_build (elim_graph g, basic_block B, int i)\n \t     in the same order as all of the other PHI nodes. If they don't \n \t     match, find the appropriate index here.  */\n \t  pi = phi_arg_from_edge (phi, g->e);\n-\t  if (pi == -1)\n-\t    abort();\n+\t  gcc_assert (pi != -1);\n \t  Ti = PHI_ARG_DEF (phi, pi);\n \t}\n \n@@ -496,12 +493,8 @@ eliminate_phi (edge e, int i, elim_graph g)\n   int x;\n   basic_block B = e->dest;\n \n-#if defined ENABLE_CHECKING\n-  if (i == -1)\n-    abort ();\n-  if (VARRAY_ACTIVE_SIZE (g->const_copies) != 0)\n-    abort ();\n-#endif\n+  gcc_assert (i != -1);\n+  gcc_assert (VARRAY_ACTIVE_SIZE (g->const_copies) == 0);\n \n   /* Abnormal edges already have everything coalesced, or the coalescer\n      would have aborted.  */\n@@ -609,59 +602,71 @@ coalesce_abnormal_edges (var_map map, conflict_graph graph, root_var_p rv)\n \t      continue;\n \n \t    y = phi_arg_from_edge (phi, e);\n-\t    if (y == -1)\n-\t      abort ();\n+\t    gcc_assert (y != -1);\n \n \t    tmp = PHI_ARG_DEF (phi, y);\n+#ifdef ENABLE_CHECKING\n \t    if (!phi_ssa_name_p (tmp))\n \t      {\n \t        print_exprs_edge (stderr, e,\n \t\t\t\t  \"\\nConstant argument in PHI. Can't insert :\",\n \t\t\t\t  var, \" = \", tmp);\n-\t\tabort ();\n+\t\tinternal_error (\"SSA corruption\");\n \t      }\n+#else\n+\t    gcc_assert (phi_ssa_name (tmp));\n+#endif\n \t    y = var_to_partition (map, tmp);\n-\t    if (x == NO_PARTITION || y == NO_PARTITION)\n-\t      abort ();\n+\t    gcc_assert (x != NO_PARTITION);\n+\t    gcc_assert (y != NO_PARTITION);\n+#ifdef ENABLE_CHECKING\n \t    if (root_var_find (rv, x) != root_var_find (rv, y))\n \t      {\n \t\tprint_exprs_edge (stderr, e, \"\\nDifferent root vars: \",\n \t\t\t\t  root_var (rv, root_var_find (rv, x)), \n \t\t\t\t  \" and \", \n \t\t\t\t  root_var (rv, root_var_find (rv, y)));\n-\t\tabort ();\n+\t\tinternal_error (\"SSA corruption\");\n \t      }\n+#else\n+\t    gcc_assert (root_var_find (rv, x) == root_var_find (rv, y));\n+#endif\n \n \t    if (x != y)\n \t      {\n-\t\tif (!conflict_graph_conflict_p (graph, x, y))\n-\t\t  {\n-\t\t    /* Now map the partitions back to their real variables.  */\n-\t\t    var = partition_to_var (map, x);\n-\t\t    tmp = partition_to_var (map, y);\n-\t\t    if (dump_file \n-\t\t\t&& (dump_flags & TDF_DETAILS))\n-\t\t      {\n-\t\t\tprint_exprs_edge (dump_file, e, \n-\t\t\t\t\t  \"ABNORMAL: Coalescing \",\n-\t\t\t\t\t  var, \" and \", tmp);\n-\t\t      }\n-\t\t    if (var_union (map, var, tmp) == NO_PARTITION)\n-\t\t      {\n-\t\t\tprint_exprs_edge (stderr, e, \"\\nUnable to coalesce\", \n-\t\t\t\t\t  partition_to_var (map, x), \" and \", \n-\t\t\t\t\t  partition_to_var (map, y));\n-\t\t\tabort ();\n-\t\t      }\n-\t\t    conflict_graph_merge_regs (graph, x, y);\n-\t\t  }\n-\t\telse\n+#ifdef ENABLE_CHECKING\n+\t\tif (conflict_graph_conflict_p (graph, x, y))\n \t\t  {\n \t\t    print_exprs_edge (stderr, e, \"\\n Conflict \", \n \t\t\t\t      partition_to_var (map, x),\n \t\t\t\t      \" and \", partition_to_var (map, y));\n-\t\t    abort ();\n+\t\t    internal_error (\"SSA corruption\");\n \t\t  }\n+#else\n+\t\tgcc_assert (!conflict_graph_conflict_p (graph, x, y));\n+#endif\n+\t\t\n+\t\t/* Now map the partitions back to their real variables.  */\n+\t\tvar = partition_to_var (map, x);\n+\t\ttmp = partition_to_var (map, y);\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t  {\n+\t\t    print_exprs_edge (dump_file, e, \n+\t\t\t\t      \"ABNORMAL: Coalescing \",\n+\t\t\t\t      var, \" and \", tmp);\n+\t\t  }\n+#ifdef ENABLE_CHECKING\n+\t\tif (var_union (map, var, tmp) == NO_PARTITION)\n+\t\t  {\n+\t\t    print_exprs_edge (stderr, e, \"\\nUnable to coalesce\", \n+\t\t\t\t      partition_to_var (map, x), \" and \", \n+\t\t\t\t      partition_to_var (map, y));\n+\t\t    internal_error (\"SSA corruption\");\n+\t\t  }\n+#else\n+\t\tgcc_assert (var_union (map, var, tmp) != NO_PARTITION);\n+#endif\n+\t\tconflict_graph_merge_regs (graph, x, y);\n \t      }\n \t  }\n }\n@@ -801,12 +806,9 @@ coalesce_ssa_name (var_map map, int flags)\n       /* If these aren't already coalesced...  */\n       if (partition_to_var (map, x) != var)\n \t{\n-\t  if (ann->out_of_ssa_tag)\n-\t    {\n-\t      /* This root variable has already been assigned to another\n-\t\t partition which is not coalesced with this one.  */\n-\t      abort ();\n-\t    }\n+\t  /* This root variable should have not already been assigned\n+\t     to another partition which is not coalesced with this one.  */\n+\t  gcc_assert (!ann->out_of_ssa_tag);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -1032,7 +1034,7 @@ eliminate_virtual_phis (void)\n \t\t      print_generic_expr (stderr, arg, TDF_SLIM);\n \t\t      fprintf (stderr, \"), but the result is :\");\n \t\t      print_generic_stmt (stderr, phi, TDF_SLIM);\n-\t\t      abort();\n+\t\t      internal_error (\"SSA corruption\");\n \t\t    }\n \t\t}\n #endif\n@@ -1279,7 +1281,7 @@ free_temp_expr_table (temp_expr_table_p t)\n   int x;\n   for (x = 0; x <= num_var_partitions (t->map); x++)\n     if (t->partition_dep_list[x] != NULL)\n-      abort();\n+      gcc_unreachable ();\n #endif\n \n   while ((p = t->free_list))\n@@ -1438,10 +1440,7 @@ add_dependance (temp_expr_table_p tab, int version, tree var)\n   else\n     {\n       i = var_to_partition (tab->map, var);\n-#ifdef ENABLE_CHECKING\n-      if (i== NO_PARTITION)\n-\tabort ();\n-#endif\n+      gcc_assert (i != NO_PARTITION);\n       add_value_to_list (tab, &(tab->partition_dep_list[i]), version);\n       add_value_to_list (tab, \n \t\t\t (value_expr_p *)&(tab->version_info[version]), i);\n@@ -1548,16 +1547,10 @@ finish_expr (temp_expr_table_p tab, int version, bool replace)\n   for (info = (value_expr_p) tab->version_info[version]; info; info = tmp)\n     {\n       partition = info->value;\n-#ifdef ENABLE_CHECKING\n-      if (tab->partition_dep_list[partition] == NULL)\n-        abort ();\n-#endif\n+      gcc_assert (tab->partition_dep_list[partition]);\n       tmp = remove_value_from_list (&(tab->partition_dep_list[partition]), \n \t\t\t\t    version);\n-#ifdef ENABLE_CHECKING\n-      if (!tmp)\n-        abort ();\n-#endif\n+      gcc_assert (tmp);\n       free_value_expr (tab, tmp);\n       /* Only clear the bit when the dependency list is emptied via \n          a replacement. Otherwise kill_expr will take care of it.  */\n@@ -1575,10 +1568,7 @@ finish_expr (temp_expr_table_p tab, int version, bool replace)\n     }\n   else\n     {\n-#ifdef ENABLE_CHECKING\n-      if (bitmap_bit_p (tab->replaceable, version))\n-\tabort ();\n-#endif\n+      gcc_assert (!bitmap_bit_p (tab->replaceable, version));\n       tab->version_info[version] = NULL;\n     }\n }\n@@ -1858,7 +1848,7 @@ rewrite_trees (var_map map, tree *values)\n \t\t      print_generic_expr (stderr, arg, TDF_SLIM);\n \t\t      fprintf (stderr, \"), but the result is not :\");\n \t\t      print_generic_stmt (stderr, phi, TDF_SLIM);\n-\t\t      abort();\n+\t\t      internal_error (\"SSA corruption\");\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "712e3f91c7aecd7c993438f607ec01bcc5e5a255", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -235,12 +235,9 @@ resize_phi_node (tree *phi, int len)\n   int size, old_size;\n   tree new_phi;\n   int i, old_len, bucket = NUM_BUCKETS - 2;\n-                                                                                \n-#ifdef ENABLE_CHECKING\n-  if (len < PHI_ARG_CAPACITY (*phi))\n-    abort ();\n-#endif\n-                                                                                \n+\n+  gcc_assert (len >= PHI_ARG_CAPACITY (*phi));\n+\n   /* Note that OLD_SIZE is guaranteed to be smaller than SIZE.  */\n   old_size = (sizeof (struct tree_phi_node)\n \t     + (PHI_ARG_CAPACITY (*phi) - 1) * sizeof (struct phi_arg_d));\n@@ -357,9 +354,7 @@ add_phi_arg (tree *phi, tree def, edge e)\n \t\t   p = PHI_CHAIN (p))\n \t\t;\n \n-\t      if (!p)\n-\t\tabort ();\n-\n+\t      gcc_assert (p);\n \t      PHI_CHAIN (p) = *phi;\n \t    }\n \t}\n@@ -524,8 +519,7 @@ remove_all_phi_nodes_for (bitmap vars)\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  tree var = SSA_NAME_VAR (PHI_RESULT (phi));\n-\t  if (bitmap_bit_p (vars, var_ann (var)->uid))\n-\t    abort ();\n+\t  gcc_assert (!bitmap_bit_p (vars, var_ann (var)->uid));\n \t}\n #endif\n     }"}, {"sha": "af3a0294626c3695b0a4813ee9f9380cc3e29745", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -1744,8 +1744,7 @@ op_prio (tree op)\n static const char *\n op_symbol (tree op)\n {\n-  if (op == NULL)\n-    abort ();\n+  gcc_assert (op);\n \n   switch (TREE_CODE (op))\n     {\n@@ -1882,8 +1881,7 @@ print_call_name (pretty_printer *buffer, tree node)\n {\n   tree op0;\n \n-  if (TREE_CODE (node) != CALL_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (node) == CALL_EXPR);\n \n   op0 = TREE_OPERAND (node, 0);\n "}, {"sha": "29299e53ccacf03bd78d7453470dcb523590b3b2", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -99,7 +99,10 @@ tree_gen_interval_profiler (histogram_value value ATTRIBUTE_UNUSED,\n \t\t\t    unsigned base ATTRIBUTE_UNUSED)\n {\n   /* FIXME implement this.  */\n-  abort ();\n+#ifdef ENABLE_CHECKING\n+  internal_error (\"unimplemented functionality\");\n+#endif\n+  gcc_unreachable ();\n }\n \n /* Output instructions as GIMPLE trees to increment the power of two histogram \n@@ -112,7 +115,10 @@ tree_gen_pow2_profiler (histogram_value value ATTRIBUTE_UNUSED,\n \t\t\tunsigned base ATTRIBUTE_UNUSED)\n {\n   /* FIXME implement this.  */\n-  abort ();\n+#ifdef ENABLE_CHECKING\n+  internal_error (\"unimplemented functionality\");\n+#endif\n+  gcc_unreachable ();\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value.\n@@ -125,7 +131,10 @@ tree_gen_one_value_profiler (histogram_value value ATTRIBUTE_UNUSED,\n \t\t\t    unsigned base ATTRIBUTE_UNUSED)\n {\n   /* FIXME implement this.  */\n-  abort ();\n+#ifdef ENABLE_CHECKING\n+  internal_error (\"unimplemented functionality\");\n+#endif\n+  gcc_unreachable ();\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value \n@@ -139,7 +148,10 @@ tree_gen_const_delta_profiler (histogram_value value ATTRIBUTE_UNUSED,\n \t\t\t\tunsigned base ATTRIBUTE_UNUSED)\n {\n   /* FIXME implement this.  */\n-  abort ();\n+#ifdef ENABLE_CHECKING\n+  internal_error (\"unimplemented functionality\");\n+#endif\n+  gcc_unreachable ();\n }\n \n /* Return 1 if tree-based profiling is in effect, else 0."}, {"sha": "b8ec2e1ff89178a31475b7c1bdc6e7c878160350", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -329,7 +329,7 @@ type_can_instantiate_all_elements (tree type)\n       return true;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -379,7 +379,7 @@ sra_hash_tree (tree t)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return h;\n@@ -446,7 +446,7 @@ sra_elt_eq (const void *x, const void *y)\n       return fields_compatible_p (ae, be);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -744,8 +744,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n       default:\n #ifdef ENABLE_CHECKING\n \t/* Validate that we're not missing any references.  */\n-\tif (walk_tree (&inner, sra_find_candidate_decl, NULL, NULL))\n-\t  abort ();\n+\tgcc_assert (!walk_tree (&inner, sra_find_candidate_decl, NULL, NULL));\n #endif\n \treturn;\n       }\n@@ -1246,7 +1245,7 @@ instantiate_missing_elements (struct sra_elt *elt)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1438,7 +1437,7 @@ generate_one_element_ref (struct sra_elt *elt, tree base)\n \treturn build (IMAGPART_EXPR, elt->type, base);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1495,17 +1494,15 @@ generate_element_copy (struct sra_elt *dst, struct sra_elt *src, tree *list_p)\n   for (dc = dst->children; dc ; dc = dc->sibling)\n     {\n       sc = lookup_element (src, dc->element, NULL, NO_INSERT);\n-      if (sc == NULL)\n-\tabort ();\n+      gcc_assert (sc);\n       generate_element_copy (dc, sc, list_p);\n     }\n \n   if (dst->replacement)\n     {\n       tree t;\n \n-      if (src->replacement == NULL)\n-\tabort ();\n+      gcc_assert (src->replacement);\n \n       t = build (MODIFY_EXPR, void_type_node, dst->replacement,\n \t\t src->replacement);\n@@ -1536,11 +1533,8 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n     {\n       tree t;\n \n-      if (elt->is_scalar)\n-\tt = build_int_cst (elt->type, 0);\n-      else\n-\t/* We generated a replacement for a non-scalar?  */\n-\tabort ();\n+      gcc_assert (elt->is_scalar);\n+      t = build_int_cst (elt->type, 0);\n \n       t = build (MODIFY_EXPR, void_type_node, elt->replacement, t);\n       append_to_statement_list (t, list_p);\n@@ -1788,12 +1782,9 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n       /* If we have two scalar operands, modify the existing statement.  */\n       stmt = bsi_stmt (*bsi);\n \n-#ifdef ENABLE_CHECKING\n       /* See the commentary in sra_walk_function concerning\n \t RETURN_EXPR, and why we should never see one here.  */\n-      if (TREE_CODE (stmt) != MODIFY_EXPR)\n-\tabort ();\n-#endif\n+      gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n \n       TREE_OPERAND (stmt, 0) = lhs_elt->replacement;\n       TREE_OPERAND (stmt, 1) = rhs_elt->replacement;\n@@ -1835,8 +1826,7 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n \n       list = NULL;\n       generate_element_copy (lhs_elt, rhs_elt, &list);\n-      if (list == NULL)\n-\tabort ();\n+      gcc_assert (list);\n       sra_replace (bsi, list);\n     }\n }\n@@ -1894,8 +1884,7 @@ scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n     {\n       /* The LHS is fully instantiated.  The list of initializations\n \t replaces the original structure assignment.  */\n-      if (!list)\n-\tabort ();\n+      gcc_assert (list);\n       mark_all_v_defs (bsi_stmt (*bsi));\n       sra_replace (bsi, list);\n     }\n@@ -1929,8 +1918,7 @@ scalarize_ldst (struct sra_elt *elt, tree other,\n \t\tblock_stmt_iterator *bsi, bool is_output)\n {\n   /* Shouldn't have gotten called for a scalar.  */\n-  if (elt->replacement)\n-    abort ();\n+  gcc_assert (!elt->replacement);\n \n   if (elt->use_block_copy)\n     {\n@@ -1948,8 +1936,7 @@ scalarize_ldst (struct sra_elt *elt, tree other,\n \n       mark_all_v_defs (stmt);\n       generate_copy_inout (elt, is_output, other, &list);\n-      if (list == NULL)\n-\tabort ();\n+      gcc_assert (list);\n \n       /* Preserve EH semantics.  */\n       if (stmt_ends_bb_p (stmt))"}, {"sha": "70a452570668f1725f1fd0155b391882aea5a4e9", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 104, "deletions": 114, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -486,10 +486,7 @@ delete_alias_info (struct alias_info *ai)\n static void\n collect_points_to_info_for (struct alias_info *ai, tree ptr)\n {\n-#if defined ENABLE_CHECKING\n-  if (!POINTER_TYPE_P (TREE_TYPE (ptr)))\n-    abort ();\n-#endif\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (ptr)));\n \n   if (!bitmap_bit_p (ai->ssa_names_visited, SSA_NAME_VERSION (ptr)))\n     {\n@@ -1207,10 +1204,8 @@ group_aliases (struct alias_info *ai)\n \t    {\n \t      tree new_alias;\n \n-#if defined ENABLE_CHECKING\n-\t      if (VARRAY_ACTIVE_SIZE (ann->may_aliases) != 1)\n-\t\tabort ();\n-#endif\n+\t      gcc_assert (VARRAY_ACTIVE_SIZE (ann->may_aliases) == 1);\n+\n \t      new_alias = VARRAY_TREE (ann->may_aliases, 0);\n \t      replace_may_alias (name_tag, j, new_alias);\n \t    }\n@@ -1546,10 +1541,7 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n   v_ann = var_ann (var);\n   m_ann = var_ann (mem);\n \n-#if defined ENABLE_CHECKING\n-  if (m_ann->mem_tag_kind != TYPE_TAG)\n-    abort ();\n-#endif\n+  gcc_assert (m_ann->mem_tag_kind == TYPE_TAG);\n \n   alias_stats.tbaa_queries++;\n \n@@ -1652,10 +1644,7 @@ add_may_alias (tree var, tree alias)\n   var_ann_t v_ann = get_var_ann (var);\n   var_ann_t a_ann = get_var_ann (alias);\n \n-#if defined ENABLE_CHECKING\n-  if (var == alias)\n-    abort ();\n-#endif\n+  gcc_assert (var != alias);\n \n   if (v_ann->may_aliases == NULL)\n     VARRAY_TREE_INIT (v_ann->may_aliases, 2, \"aliases\");\n@@ -1790,12 +1779,9 @@ add_pointed_to_expr (tree ptr, tree value)\n   if (TREE_CODE (value) == WITH_SIZE_EXPR)\n     value = TREE_OPERAND (value, 0);\n \n-#if defined ENABLE_CHECKING\n   /* Pointer variables should have been handled by merge_pointed_to_info.  */\n-  if (TREE_CODE (value) == SSA_NAME\n-      && POINTER_TYPE_P (TREE_TYPE (value)))\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (value) != SSA_NAME\n+\t      || !POINTER_TYPE_P (TREE_TYPE (value)));\n \n   get_ptr_info (ptr);\n \n@@ -1835,10 +1821,7 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n   tree pt_var;\n   size_t uid;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (value) != ADDR_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (value) == ADDR_EXPR);\n \n   pt_var = TREE_OPERAND (value, 0);\n   if (TREE_CODE_CLASS (TREE_CODE (pt_var)) == 'r')\n@@ -1883,95 +1866,109 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  switch (TREE_CODE (stmt))\n     {\n-      tree rhs = TREE_OPERAND (stmt, 1);\n-      STRIP_NOPS (rhs);\n-\n-      /* Found P_i = ADDR_EXPR  */\n-      if (TREE_CODE (rhs) == ADDR_EXPR)\n-\tadd_pointed_to_var (ai, var, rhs);\n-\n-      /* Found P_i = Q_j.  */\n-      else if (TREE_CODE (rhs) == SSA_NAME\n-\t       && POINTER_TYPE_P (TREE_TYPE (rhs)))\n-\tmerge_pointed_to_info (ai, var, rhs);\n+    case MODIFY_EXPR:\n+      {\n+\ttree rhs = TREE_OPERAND (stmt, 1);\n+\tSTRIP_NOPS (rhs);\n \n-      /* Found P_i = PLUS_EXPR or P_i = MINUS_EXPR  */\n-      else if (TREE_CODE (rhs) == PLUS_EXPR\n-\t       || TREE_CODE (rhs) == MINUS_EXPR)\n-\t{\n-\t  tree op0 = TREE_OPERAND (rhs, 0);\n-\t  tree op1 = TREE_OPERAND (rhs, 1);\n+\t/* Found P_i = ADDR_EXPR  */\n+\tif (TREE_CODE (rhs) == ADDR_EXPR)\n+\t  add_pointed_to_var (ai, var, rhs);\n \n-\t  /* Both operands may be of pointer type.  FIXME: Shouldn't\n-\t     we just expect PTR + OFFSET always?  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (op0)))\n-\t    {\n-\t      if (TREE_CODE (op0) == SSA_NAME)\n-\t\tmerge_pointed_to_info (ai, var, op0);\n-\t      else if (TREE_CODE (op0) == ADDR_EXPR)\n-\t\tadd_pointed_to_var (ai, var, op0);\n-\t      else\n-\t\tadd_pointed_to_expr (var, op0);\n-\t    }\n-\n-\t  if (POINTER_TYPE_P (TREE_TYPE (op1)))\n-\t    {\n-\t      if (TREE_CODE (op1) == SSA_NAME)\n-\t\tmerge_pointed_to_info (ai, var, op1);\n-\t      else if (TREE_CODE (op1) == ADDR_EXPR)\n-\t\tadd_pointed_to_var (ai, var, op1);\n-\t      else\n-\t\tadd_pointed_to_expr (var, op1);\n-\t    }\n+\t/* Found P_i = Q_j.  */\n+\telse if (TREE_CODE (rhs) == SSA_NAME\n+\t\t && POINTER_TYPE_P (TREE_TYPE (rhs)))\n+\t  merge_pointed_to_info (ai, var, rhs);\n \n-\t  /* Neither operand is a pointer?  VAR can be pointing\n-\t     anywhere.   FIXME: Is this right?  If we get here, we\n-\t     found PTR = INT_CST + INT_CST.  */\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (op0))\n-\t      && !POINTER_TYPE_P (TREE_TYPE (op1)))\n-\t    add_pointed_to_expr (var, rhs);\n-\t}\n+\t/* Found P_i = PLUS_EXPR or P_i = MINUS_EXPR  */\n+\telse if (TREE_CODE (rhs) == PLUS_EXPR\n+\t\t || TREE_CODE (rhs) == MINUS_EXPR)\n+\t  {\n+\t    tree op0 = TREE_OPERAND (rhs, 0);\n+\t    tree op1 = TREE_OPERAND (rhs, 1);\n+\t    \n+\t    /* Both operands may be of pointer type.  FIXME: Shouldn't\n+\t       we just expect PTR + OFFSET always?  */\n+\t    if (POINTER_TYPE_P (TREE_TYPE (op0)))\n+\t      {\n+\t\tif (TREE_CODE (op0) == SSA_NAME)\n+\t\t  merge_pointed_to_info (ai, var, op0);\n+\t\telse if (TREE_CODE (op0) == ADDR_EXPR)\n+\t\t  add_pointed_to_var (ai, var, op0);\n+\t\telse\n+\t\t  add_pointed_to_expr (var, op0);\n+\t      }\n+\n+\t    if (POINTER_TYPE_P (TREE_TYPE (op1)))\n+\t      {\n+\t\tif (TREE_CODE (op1) == SSA_NAME)\n+\t\t  merge_pointed_to_info (ai, var, op1);\n+\t\telse if (TREE_CODE (op1) == ADDR_EXPR)\n+\t\t  add_pointed_to_var (ai, var, op1);\n+\t\telse\n+\t\t  add_pointed_to_expr (var, op1);\n+\t      }\n+\n+\t    /* Neither operand is a pointer?  VAR can be pointing\n+\t       anywhere.  FIXME: Is this right?  If we get here, we\n+\t       found PTR = INT_CST + INT_CST.  */\n+\t    if (!POINTER_TYPE_P (TREE_TYPE (op0))\n+\t\t&& !POINTER_TYPE_P (TREE_TYPE (op1)))\n+\t      add_pointed_to_expr (var, rhs);\n+\t  }\n \n-      /* Something else.  */\n-      else\n-\tadd_pointed_to_expr (var, rhs);\n-    }\n-  else if (TREE_CODE (stmt) == ASM_EXPR)\n-    {\n+\t/* Something else.  */\n+\telse\n+\t  add_pointed_to_expr (var, rhs);\n+\tbreak;\n+      }\n+    case ASM_EXPR:\n       /* Pointers defined by __asm__ statements can point anywhere.  */\n       set_pt_anything (var);\n-    }\n-  else if (IS_EMPTY_STMT (stmt))\n-    {\n-      tree decl = SSA_NAME_VAR (var);\n+      break;\n \n-      if (TREE_CODE (decl) == PARM_DECL)\n-\tadd_pointed_to_expr (var, decl);\n-      else if (DECL_INITIAL (decl))\n-\tadd_pointed_to_var (ai, var, DECL_INITIAL (decl));\n-      else\n-\tadd_pointed_to_expr (var, decl);\n-    }\n-  else if (TREE_CODE (stmt) == PHI_NODE)\n-    {\n-      /* It STMT is a PHI node, then VAR is one of its arguments.  The\n-\t variable that we are analyzing is the LHS of the PHI node.  */\n-      tree lhs = PHI_RESULT (stmt);\n-\n-      if (TREE_CODE (var) == ADDR_EXPR)\n-\tadd_pointed_to_var (ai, lhs, var);\n-      else if (TREE_CODE (var) == SSA_NAME)\n-\tmerge_pointed_to_info (ai, lhs, var);\n-      else if (is_gimple_min_invariant (var))\n-\tadd_pointed_to_expr (lhs, var);\n-      else\n-\tabort ();\n-    }\n-  else\n-    abort ();\n+    case NOP_EXPR:\n+      if (IS_EMPTY_STMT (stmt))\n+\t{\n+\t  tree decl = SSA_NAME_VAR (var);\n+\t  \n+\t  if (TREE_CODE (decl) == PARM_DECL)\n+\t    add_pointed_to_expr (var, decl);\n+\t  else if (DECL_INITIAL (decl))\n+\t    add_pointed_to_var (ai, var, DECL_INITIAL (decl));\n+\t  else\n+\t    add_pointed_to_expr (var, decl);\n+\t}\n+      break;\n+    case PHI_NODE:\n+      {\n+        /* It STMT is a PHI node, then VAR is one of its arguments.  The\n+\t   variable that we are analyzing is the LHS of the PHI node.  */\n+\ttree lhs = PHI_RESULT (stmt);\n \n+\tswitch (TREE_CODE (var))\n+\t  {\n+\t  case ADDR_EXPR:\n+\t    add_pointed_to_var (ai, lhs, var);\n+\t    break;\n+\t    \n+\t  case SSA_NAME:\n+\t    merge_pointed_to_info (ai, lhs, var);\n+\t    break;\n+\t    \n+\t  default:\n+\t    gcc_assert (is_gimple_min_invariant (var));\n+\t    add_pointed_to_expr (lhs, var);\n+\t    break;\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+  \n   return false;\n }\n \n@@ -2154,13 +2151,9 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n       ai->pointers[ai->num_pointers++] = alias_map;\n     }\n \n-#if defined ENABLE_CHECKING\n   /* Make sure that the type tag has the same alias set as the\n      pointed-to type.  */\n-  if (tag_set != get_alias_set (tag))\n-    abort ();\n-#endif\n-\n+  gcc_assert (tag_set == get_alias_set (tag));\n \n   return tag;\n }\n@@ -2297,10 +2290,7 @@ get_ptr_info (tree t)\n {\n   struct ptr_info_def *pi;\n \n-#if defined ENABLE_CHECKING\n-  if (!POINTER_TYPE_P (TREE_TYPE (t)))\n-    abort ();\n-#endif\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (t)));\n \n   pi = SSA_NAME_PTR_INFO (t);\n   if (pi == NULL)"}, {"sha": "ddde45ddc5e4d278ec7997a228b5bbdbfae032f8", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 19, "deletions": 42, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -99,7 +99,7 @@ dump_lattice_value (FILE *outf, const char *prefix, value val)\n       print_generic_expr (outf, val.const_val, dump_flags);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -128,10 +128,7 @@ get_default_value (tree var)\n     sym = SSA_NAME_VAR (var);\n   else\n     {\n-#ifdef ENABLE_CHECKING\n-      if (!DECL_P (var))\n-\tabort ();\n-#endif\n+      gcc_assert (DECL_P (var));\n       sym = var;\n     }\n \n@@ -188,10 +185,7 @@ get_value (tree var)\n {\n   value *val;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (var) != SSA_NAME)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (var) == SSA_NAME);\n \n   val = &value_vector[SSA_NAME_VERSION (var)];\n   if (val->lattice_val == UNINITIALIZED)\n@@ -209,32 +203,24 @@ set_lattice_value (tree var, value val)\n {\n   value *old = get_value (var);\n \n-#ifdef ENABLE_CHECKING\n   if (val.lattice_val == UNDEFINED)\n     {\n       /* CONSTANT->UNDEFINED is never a valid state transition.  */\n-      if (old->lattice_val == CONSTANT)\n-\tabort ();\n+      gcc_assert (old->lattice_val != CONSTANT);\n \t\n       /* UNKNOWN_VAL->UNDEFINED is never a valid state transition.  */\n-      if (old->lattice_val == UNKNOWN_VAL)\n-\tabort ();\n+      gcc_assert (old->lattice_val != UNKNOWN_VAL);\n \n       /* VARYING->UNDEFINED is generally not a valid state transition,\n \t except for values which are initialized to VARYING.  */\n-      if (old->lattice_val == VARYING\n-\t  && get_default_value (var).lattice_val != VARYING)\n-\tabort ();\n+      gcc_assert (old->lattice_val != VARYING\n+\t\t  || get_default_value (var).lattice_val == VARYING);\n     }\n   else if (val.lattice_val == CONSTANT)\n-    {\n-      /* VARYING -> CONSTANT is an invalid state transition, except\n-\t for objects which start off in a VARYING state.  */\n-      if (old->lattice_val == VARYING\n-\t  && get_default_value (var).lattice_val != VARYING)\n-\tabort ();\n-    }\n-#endif\n+    /* VARYING -> CONSTANT is an invalid state transition, except\n+\tfor objects which start off in a VARYING state.  */\n+    gcc_assert (old->lattice_val == VARYING\n+\t\t|| get_default_value (var).lattice_val != VARYING);\n \n   /* If the constant for VAR has changed, then this VAR is really varying.  */\n   if (old->lattice_val == CONSTANT\n@@ -326,11 +312,8 @@ likely_value (tree stmt)\n       if (val->lattice_val == UNKNOWN_VAL)\n         return UNKNOWN_VAL;\n \t\n-#ifdef ENABLE_CHECKING\n-  /* There should be no VUSE operands that are UNDEFINED.  */\n-  if (val->lattice_val == UNDEFINED)\n-    abort ();\n-#endif\n+      /* There should be no VUSE operands that are UNDEFINED.  */\n+      gcc_assert (val->lattice_val != UNDEFINED);\n \t\n       if (val->lattice_val == CONSTANT)\n \tfound_constant = 1;\n@@ -719,7 +702,7 @@ ccp_visit_phi_node (tree phi)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n@@ -1016,12 +999,9 @@ visit_assignment (tree stmt, tree *output_p)\n   vuses = STMT_VUSE_OPS (stmt);\n   v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n \n-#if defined ENABLE_CHECKING\n-  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0\n-      || (NUM_V_MUST_DEFS (v_must_defs) != 1\n-          && TREE_CODE (lhs) != SSA_NAME))\n-    abort ();\n-#endif\n+  gcc_assert (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0);\n+  gcc_assert (NUM_V_MUST_DEFS (v_must_defs) == 1\n+\t      || TREE_CODE (lhs) == SSA_NAME);\n \n   /* We require the SSA version number of the lhs for the value_vector.\n      Make sure we have it.  */\n@@ -1250,10 +1230,7 @@ widen_bitfield (tree val, tree field, tree var)\n   if (field_size > HOST_BITS_PER_WIDE_INT || var_size > HOST_BITS_PER_WIDE_INT)\n     return NULL_TREE;\n \n-#if defined ENABLE_CHECKING\n-  if (var_size < field_size)\n-    abort ();\n-#endif\n+  gcc_assert (var_size >= field_size);\n \n   /* If the sign bit of the value is not set or the field's type is unsigned,\n      just mask off the high order bits of the value.  */\n@@ -2000,7 +1977,7 @@ ccp_fold_builtin (tree stmt, tree fn)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (result && ignore)"}, {"sha": "7b27c68b1bd5c7a84c61627c691199efaa5d32f3", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -131,8 +131,7 @@ may_propagate_copy (tree dest, tree orig)\n #ifdef ENABLE_CHECKING\n \t  /* If we have one real and one virtual operand, then something has\n \t     gone terribly wrong.  */\n-\t  if (is_gimple_reg (orig))\n-\t    abort ();\n+\t  gcc_assert (!is_gimple_reg (orig));\n #endif\n \t}\n \n@@ -170,27 +169,26 @@ merge_alias_info (tree orig, tree new)\n   var_ann_t new_ann = var_ann (new_sym);\n   var_ann_t orig_ann = var_ann (orig_sym);\n \n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (orig)));\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (new)));\n #if defined ENABLE_CHECKING\n-  if (!POINTER_TYPE_P (TREE_TYPE (orig))\n-      || !POINTER_TYPE_P (TREE_TYPE (new))\n-      || !lang_hooks.types_compatible_p (TREE_TYPE (orig), TREE_TYPE (new)))\n-    abort ();\n+  gcc_assert (lang_hooks.types_compatible_p (TREE_TYPE (orig),\n+\t\t\t\t\t     TREE_TYPE (new)));\n \n   /* If the pointed-to alias sets are different, these two pointers\n      would never have the same memory tag.  In this case, NEW should\n      not have been propagated into ORIG.  */\n-  if (get_alias_set (TREE_TYPE (TREE_TYPE (new_sym)))\n-      != get_alias_set (TREE_TYPE (TREE_TYPE (orig_sym))))\n-    abort ();\n+  gcc_assert (get_alias_set (TREE_TYPE (TREE_TYPE (new_sym)))\n+\t      == get_alias_set (TREE_TYPE (TREE_TYPE (orig_sym))));\n #endif\n \n   /* Merge type-based alias info.  */\n   if (new_ann->type_mem_tag == NULL_TREE)\n     new_ann->type_mem_tag = orig_ann->type_mem_tag;\n   else if (orig_ann->type_mem_tag == NULL_TREE)\n     orig_ann->type_mem_tag = new_ann->type_mem_tag;\n-  else if (new_ann->type_mem_tag != orig_ann->type_mem_tag)\n-    abort ();\n+  else\n+    gcc_assert (new_ann->type_mem_tag == orig_ann->type_mem_tag);\n }\n \n \n@@ -206,11 +204,10 @@ replace_exp_1 (use_operand_p op_p, tree val,\n   tree op = USE_FROM_PTR (op_p);\n \n #if defined ENABLE_CHECKING\n-  if (for_propagation\n-      && TREE_CODE (op) == SSA_NAME\n-      && TREE_CODE (val) == SSA_NAME\n-      && !may_propagate_copy (op, val))\n-    abort ();\n+  gcc_assert (!(for_propagation\n+\t\t&& TREE_CODE (op) == SSA_NAME\n+\t\t&& TREE_CODE (val) == SSA_NAME\n+\t\t&& !may_propagate_copy (op, val)));\n #endif\n \n   if (TREE_CODE (val) == SSA_NAME)\n@@ -249,10 +246,9 @@ void\n propagate_tree_value (tree *op_p, tree val)\n {\n #if defined ENABLE_CHECKING\n-  if (TREE_CODE (val) == SSA_NAME\n-      && TREE_CODE (*op_p) == SSA_NAME\n-      && !may_propagate_copy (*op_p, val))\n-    abort ();\n+  gcc_assert (!(TREE_CODE (val) == SSA_NAME\n+\t\t&& TREE_CODE (*op_p) == SSA_NAME\n+\t\t&& !may_propagate_copy (*op_p, val)));\n #endif\n \n   if (TREE_CODE (val) == SSA_NAME)"}, {"sha": "e38b77ac4946068a4f4fd408c3c6859733190163", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -120,10 +120,8 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n   var_ann_t ann1, ann2, ann3;\n   bool ign1, ign2;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (var1) != SSA_NAME || TREE_CODE (var2) != SSA_NAME)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (var1) == SSA_NAME);\n+  gcc_assert (TREE_CODE (var2) == SSA_NAME);\n \n   register_ssa_partition (map, var1, false);\n   register_ssa_partition (map, var2, true);\n@@ -140,10 +138,8 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n       fprintf (debug, \"(P%d)\", p2);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  if (p1 == NO_PARTITION || p2 == NO_PARTITION)\n-    abort ();\n-#endif\n+  gcc_assert (p1 != NO_PARTITION);\n+  gcc_assert (p2 != NO_PARTITION);\n \n   root1 = SSA_NAME_VAR (partition_to_var (map, p1));\n   root2 = SSA_NAME_VAR (partition_to_var (map, p2));"}, {"sha": "ccfa0f5c324eb8b63dc6455f8b59c3ee09b14f57", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -127,8 +127,7 @@ set_control_dependence_map_bit (basic_block bb, int edge_index)\n {\n   if (bb == ENTRY_BLOCK_PTR)\n     return;\n-  if (bb == EXIT_BLOCK_PTR)\n-    abort ();\n+  gcc_assert (bb != EXIT_BLOCK_PTR);\n   bitmap_set_bit (control_dependence_map[bb->index], edge_index);\n }\n \n@@ -160,10 +159,7 @@ find_control_dependence (struct edge_list *el, int edge_index)\n   basic_block current_block;\n   basic_block ending_block;\n \n-#ifdef ENABLE_CHECKING\n-  if (INDEX_EDGE_PRED_BB (el, edge_index) == EXIT_BLOCK_PTR)\n-    abort ();\n-#endif\n+  gcc_assert (INDEX_EDGE_PRED_BB (el, edge_index) != EXIT_BLOCK_PTR);\n \n   if (INDEX_EDGE_PRED_BB (el, edge_index) == ENTRY_BLOCK_PTR)\n     ending_block = ENTRY_BLOCK_PTR->next_bb;\n@@ -192,9 +188,9 @@ find_control_dependence (struct edge_list *el, int edge_index)\n static inline basic_block\n find_pdom (basic_block block)\n {\n-  if (block == ENTRY_BLOCK_PTR)\n-    abort ();\n-  else if (block == EXIT_BLOCK_PTR)\n+  gcc_assert (block != ENTRY_BLOCK_PTR);\n+\n+  if (block == EXIT_BLOCK_PTR)\n     return EXIT_BLOCK_PTR;\n   else\n     {\n@@ -212,12 +208,9 @@ find_pdom (basic_block block)\n static inline void\n mark_stmt_necessary (tree stmt, bool add_to_worklist)\n {\n-#ifdef ENABLE_CHECKING\n-  if (stmt == NULL\n-      || stmt == error_mark_node\n-      || (stmt && DECL_P (stmt)))\n-    abort ();\n-#endif\n+  gcc_assert (stmt);\n+  gcc_assert (stmt != error_mark_node);\n+  gcc_assert (!DECL_P (stmt));\n \n   if (NECESSARY (stmt))\n     return;\n@@ -242,21 +235,15 @@ mark_operand_necessary (tree op)\n   tree stmt;\n   int ver;\n \n-#ifdef ENABLE_CHECKING\n-  if (op == NULL)\n-    abort ();\n-#endif\n+  gcc_assert (op);\n \n   ver = SSA_NAME_VERSION (op);\n   if (TEST_BIT (processed, ver))\n     return;\n   SET_BIT (processed, ver);\n \n   stmt = SSA_NAME_DEF_STMT (op);\n-#ifdef ENABLE_CHECKING\n-  if (stmt == NULL)\n-    abort ();\n-#endif\n+  gcc_assert (stmt);\n \n   if (NECESSARY (stmt)\n       || IS_EMPTY_STMT (stmt))\n@@ -387,10 +374,7 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n     {\n       tree lhs;\n \n-#if defined ENABLE_CHECKING\n-      if (TREE_CODE (stmt) != MODIFY_EXPR)\n-\tabort ();\n-#endif\n+      gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n \n       /* Note that we must not check the individual virtual operands\n \t here.  In particular, if this is an aliased store, we could\n@@ -451,7 +435,7 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n \t    }\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   return;\n@@ -526,10 +510,7 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n {\n   int edge_number;\n \n-#ifdef ENABLE_CHECKING\n-  if (bb == EXIT_BLOCK_PTR)\n-    abort ();\n-#endif\n+  gcc_assert (bb != EXIT_BLOCK_PTR);\n \n   if (bb == ENTRY_BLOCK_PTR)\n     return;\n@@ -742,11 +723,8 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n     {\n       basic_block post_dom_bb;\n       edge e;\n-#ifdef ENABLE_CHECKING\n       /* The post dominance info has to be up-to-date.  */\n-      if (dom_computed[CDI_POST_DOMINATORS] != DOM_OK)\n-\tabort ();\n-#endif\n+      gcc_assert (dom_computed[CDI_POST_DOMINATORS] == DOM_OK);\n       /* Get the immediate post dominator of bb.  */\n       post_dom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n       /* Some blocks don't have an immediate post dominator.  This can happen"}, {"sha": "7b1c3ac783fca60bf315446b449605d829fbcf17", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -715,7 +715,6 @@ dom_opt_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_U\n \t\t\t\t     basic_block bb ATTRIBUTE_UNUSED,\n \t\t\t\t     bool recycled ATTRIBUTE_UNUSED)\n {\n-#ifdef ENABLE_CHECKING\n   struct dom_walk_block_data *bd\n     = (struct dom_walk_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n@@ -725,20 +724,19 @@ dom_opt_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_U\n      make sure we clear them before using them!  */\n   if (recycled)\n     {\n-      if (bd->avail_exprs && VARRAY_ACTIVE_SIZE (bd->avail_exprs) > 0)\n-\tabort ();\n-      if (bd->const_and_copies && VARRAY_ACTIVE_SIZE (bd->const_and_copies) > 0)\n-\tabort ();\n-      if (bd->nonzero_vars && VARRAY_ACTIVE_SIZE (bd->nonzero_vars) > 0)\n-\tabort ();\n-      if (bd->stmts_to_rescan && VARRAY_ACTIVE_SIZE (bd->stmts_to_rescan) > 0)\n-\tabort ();\n-      if (bd->vrp_variables && VARRAY_ACTIVE_SIZE (bd->vrp_variables) > 0)\n-\tabort ();\n-      if (bd->block_defs && VARRAY_ACTIVE_SIZE (bd->block_defs) > 0)\n-\tabort ();\n+      gcc_assert (!bd->avail_exprs\n+\t\t  || VARRAY_ACTIVE_SIZE (bd->avail_exprs) == 0);\n+      gcc_assert (!bd->const_and_copies\n+\t\t  || VARRAY_ACTIVE_SIZE (bd->const_and_copies) == 0);\n+      gcc_assert (!bd->nonzero_vars\n+\t\t  || VARRAY_ACTIVE_SIZE (bd->nonzero_vars) == 0);\n+      gcc_assert (!bd->stmts_to_rescan\n+\t\t  || VARRAY_ACTIVE_SIZE (bd->stmts_to_rescan) == 0);\n+      gcc_assert (!bd->vrp_variables\n+\t\t  || VARRAY_ACTIVE_SIZE (bd->vrp_variables) == 0);\n+      gcc_assert (!bd->block_defs\n+\t\t  || VARRAY_ACTIVE_SIZE (bd->block_defs) == 0);\n     }\n-#endif\n }\n \n /* Initialize local stacks for this optimizer and record equivalences\n@@ -2216,8 +2214,7 @@ simplify_switch_and_lookup_avail_expr (tree stmt,\n \n #ifdef ENABLE_CHECKING\n \t      /* ??? Why was Jeff testing this?  We are gimple...  */\n-\t      if (!is_gimple_val (def))\n-\t\tabort ();\n+\t      gcc_assert (is_gimple_val (def));\n #endif\n \n \t      to = TREE_TYPE (cond);\n@@ -2316,12 +2313,9 @@ cprop_into_successor_phis (basic_block bb,\n \t      hint = i;\n \t    }\n \n-#ifdef ENABLE_CHECKING\n \t  /* If we did not find the proper alternative, then something is\n \t     horribly wrong.  */\n-\t  if (hint == phi_num_args)\n-\t    abort ();\n-#endif\n+\t  gcc_assert (hint != phi_num_args);\n \n \t  /* The alternative may be associated with a constant, so verify\n \t     it is an SSA_NAME before doing anything with it.  */\n@@ -2447,9 +2441,8 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n       opt_stats.num_re++;\n \n #if defined ENABLE_CHECKING\n-      if (TREE_CODE (cached_lhs) != SSA_NAME\n-\t  && !is_gimple_min_invariant (cached_lhs))\n-\tabort ();\n+      gcc_assert (TREE_CODE (cached_lhs) == SSA_NAME\n+\t\t  || is_gimple_min_invariant (cached_lhs));\n #endif\n \n       if (TREE_CODE (cached_lhs) == ADDR_EXPR\n@@ -3333,11 +3326,8 @@ avail_expr_eq (const void *p1, const void *p2)\n \tif (VUSE_OP (ops1, i) != VUSE_OP (ops2, i))\n \t  return false;\n \n-#ifdef ENABLE_CHECKING\n-      if (((struct expr_hash_elt *)p1)->hash\n-\t  != ((struct expr_hash_elt *)p2)->hash)\n-\tabort ();\n-#endif\n+      gcc_assert (((struct expr_hash_elt *)p1)->hash\n+\t\t  == ((struct expr_hash_elt *)p2)->hash);\n       return true;\n     }\n "}, {"sha": "820b2c6378cb0075992fd132e4e1c2481d997b74", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -169,13 +169,9 @@ fix_stmt_v_may_defs (tree stmt1, tree stmt2)\n \t    }\n \t}\n \n-#ifdef ENABLE_CHECKING\n       /* If we did not find a corresponding V_MAY_DEF_RESULT, then something\n \t has gone terribly wrong.  */\n-      if (j == NUM_V_MAY_DEFS (v_may_defs2))\n-\tabort ();\n-#endif\n-\n+      gcc_assert (j != NUM_V_MAY_DEFS (v_may_defs2));\n     }\n }\n "}, {"sha": "d65d6fb20d8fabc75ee33811471031ca6f29ef96", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\"\n+#include \"errors.h\"\n \n static void live_worklist (tree_live_info_p, varray_type, int);\n static tree_live_info_p new_tree_live_info (var_map);\n@@ -144,8 +145,8 @@ var_union (var_map map, tree var1, tree var2)\n \tother_var = var2;\n     }\n \n-  if (p1 == NO_PARTITION || p2 == NO_PARTITION)\n-    abort ();\n+  gcc_assert (p1 != NO_PARTITION);\n+  gcc_assert (p2 != NO_PARTITION);\n \n   if (p1 == p2)\n     p3 = p1;\n@@ -274,8 +275,7 @@ change_partition_var (var_map map, tree var, int part)\n {\n   var_ann_t ann;\n \n-  if (TREE_CODE (var) == SSA_NAME)\n-    abort();\n+  gcc_assert (TREE_CODE (var) != SSA_NAME);\n \n   ann = var_ann (var);\n   ann->out_of_ssa_tag = 1;\n@@ -415,7 +415,7 @@ create_ssa_var_map (int flags)\n \tEXECUTE_IF_SET_IN_SBITMAP (both, 0, i,\n \t  fprintf (stderr, \"Variable %s used in real and virtual operands\\n\",\n \t\t   get_name (referenced_var (i))));\n-\tabort ();\n+\tinternal_error (\"SSA corruption\");\n       }\n \n     sbitmap_free (used_in_real_ops);\n@@ -715,8 +715,7 @@ calculate_live_on_entry (var_map map)\n \t      }\n \t}\n     }\n-  if (num > 0)\n-    abort ();\n+  gcc_assert (num <= 0);\n #endif\n \n   BITMAP_XFREE (saw_def);\n@@ -943,10 +942,7 @@ root_var_init (var_map map)\n \n       p = var_to_partition (map, t);\n \n-#ifdef ENABLE_CHECKING\n-      if (p == NO_PARTITION)\n-        abort ();\n-#endif\n+      gcc_assert (p != NO_PARTITION);\n \n       /* Make sure we only put coalesced partitions into the list once.  */\n       if (TEST_BIT (seen, p))\n@@ -1019,10 +1015,7 @@ type_var_init (var_map map)\n \n       p = var_to_partition (map, t);\n \n-#ifdef ENABLE_CHECKING\n-      if (p == NO_PARTITION)\n-        abort ();\n-#endif\n+      gcc_assert (p != NO_PARTITION);\n \n       /* If partitions have been coalesced, only add the representative \n \t for the partition to the list once.  */\n@@ -1143,10 +1136,7 @@ add_coalesce (coalesce_list_p cl, int p1, int p2, int value)\n {\n   partition_pair_p node;\n \n-#ifdef ENABLE_CHECKING\n-  if (!cl->add_mode)\n-    abort();\n-#endif\n+  gcc_assert (cl->add_mode);\n \n   if (p1 == p2)\n     return;\n@@ -1177,8 +1167,7 @@ sort_coalesce_list (coalesce_list_p cl)\n   partition_pair_p chain, p;\n   partition_pair_p  *list;\n \n-  if (!cl->add_mode)\n-    abort();\n+  gcc_assert (cl->add_mode);\n \n   cl->add_mode = false;\n \n@@ -1204,10 +1193,7 @@ sort_coalesce_list (coalesce_list_p cl)\n       for (p = chain; p != NULL; p = p->next)\n \tlist[count++] = p;\n \n-#ifdef ENABLE_CHECKING\n-  if (count != num)\n-    abort ();\n-#endif\n+      gcc_assert (count == num);\n \t\n       qsort (list, count, sizeof (partition_pair_p), compare_pairs);\n \n@@ -1248,8 +1234,7 @@ pop_best_coalesce (coalesce_list_p cl, int *p1, int *p2)\n   partition_pair_p node;\n   int ret;\n \n-  if (cl->add_mode)\n-    abort();\n+  gcc_assert (!cl->add_mode);\n \n   node = cl->list[0];\n   if (!node)\n@@ -1793,3 +1778,18 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n \t}\n     }\n }\n+\n+#ifdef ENABLE_CHECKING\n+void\n+register_ssa_partition_check (tree ssa_var)\n+{\n+  gcc_assert (TREE_CODE (ssa_var) == SSA_NAME);\n+  if (!is_gimple_reg (SSA_NAME_VAR (ssa_var)))\n+    {\n+      fprintf (stderr, \"Illegally registering a virtual SSA name :\");\n+      print_generic_expr (stderr, ssa_var, TDF_SLIM);\n+      fprintf (stderr, \" in the SSA->Normal phase.\\n\");\n+      internal_error (\"SSA corruption\");\n+    }\n+}\n+#endif"}, {"sha": "eb93305ffd974ebb11f0ee021a0076d91f52ef85", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -65,6 +65,9 @@ extern int var_union (var_map, tree, tree);\n extern void change_partition_var (var_map, tree, int);\n extern void compact_var_map (var_map, int);\n extern tree make_ssa_temp (tree);\n+#ifdef ENABLE_CHECKING\n+extern void register_ssa_partition_check (tree ssa_var);\n+#endif\n \n static inline int num_var_partitions (var_map);\n static inline tree var_to_partition_to_var (var_map, tree);\n@@ -77,7 +80,6 @@ static inline void register_ssa_partition (var_map, tree, bool);\n #define SSA_VAR_MAP_REF_COUNT\t 0x01\n extern var_map create_ssa_var_map (int);\n \n-\n /* Number of partitions in MAP.  */\n \n static inline int \n@@ -93,10 +95,7 @@ static inline int\n version_ref_count (var_map map, tree ssa_var)\n {\n   int version = SSA_NAME_VERSION (ssa_var);\n-#ifdef ENABLE_CHECKING\n-  if (!map->ref_count)\n-    abort ();\n-#endif\n+  gcc_assert (map->ref_count);\n   return map->ref_count[version];\n }\n  \n@@ -182,16 +181,7 @@ register_ssa_partition (var_map map, tree ssa_var, bool is_use)\n   int version;\n \n #if defined ENABLE_CHECKING\n-  if (TREE_CODE (ssa_var) != SSA_NAME)\n-    abort ();\n-\n-  if (!is_gimple_reg (SSA_NAME_VAR (ssa_var)))\n-    {\n-      fprintf (stderr, \"Illegally registering a virtual SSA name :\");\n-      print_generic_expr (stderr, ssa_var, TDF_SLIM);\n-      fprintf (stderr, \" in the SSA->Normal phase.\\n\");\n-      abort();\n-    }\n+  register_ssa_partition_check (ssa_var);\n #endif\n \n   version = SSA_NAME_VERSION (ssa_var);\n@@ -274,9 +264,7 @@ static inline void make_live_on_entry (tree_live_info_p, basic_block, int);\n static inline int\n partition_is_global (tree_live_info_p live, int p)\n {\n-  if (!live->global)\n-    abort ();\n-\n+  gcc_assert (live->global);\n   return bitmap_bit_p (live->global, p);\n }\n \n@@ -287,9 +275,7 @@ partition_is_global (tree_live_info_p live, int p)\n static inline bitmap\n live_entry_blocks (tree_live_info_p live, int p)\n {\n-  if (!live->livein)\n-    abort ();\n-\n+  gcc_assert (live->livein);\n   return live->livein[p];\n }\n \n@@ -300,12 +286,10 @@ live_entry_blocks (tree_live_info_p live, int p)\n static inline bitmap\n live_on_exit (tree_live_info_p live, basic_block bb)\n {\n-  if (!live->liveout)\n-    abort();\n+  gcc_assert (live->liveout);\n+  gcc_assert (bb != ENTRY_BLOCK_PTR);\n+  gcc_assert (bb != EXIT_BLOCK_PTR);\n \n-  if (bb == ENTRY_BLOCK_PTR || bb == EXIT_BLOCK_PTR)\n-    abort ();\n-  \n   return live->liveout[bb->index];\n }\n \n@@ -428,10 +412,7 @@ tpa_find_tree (tpa_p tpa, int i)\n      a compressed element, so return TPA_NONE.  */\n   if (index != TPA_NONE && index >= tpa_num_trees (tpa))\n     {\n-#ifdef ENABLE_CHECKING\n-      if (tpa->uncompressed_num == -1)\n-        abort ();\n-#endif\n+      gcc_assert (tpa->uncompressed_num != -1);\n       index = TPA_NONE;\n     }\n \n@@ -444,10 +425,7 @@ tpa_find_tree (tpa_p tpa, int i)\n static inline void \n tpa_decompact(tpa_p tpa)\n {\n-#ifdef ENABLE_CHECKING\n-  if (tpa->uncompressed_num == -1)\n-    abort ();\n-#endif\n+  gcc_assert (tpa->uncompressed_num != -1);\n   tpa->num_trees = tpa->uncompressed_num;\n }\n "}, {"sha": "a03dabd1fd1dccc8aaa7d71bae0e14c8987e133f", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -59,8 +59,7 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n   if (header->aux)\n     return false;\n \n-  if (!header->succ)\n-    abort ();\n+  gcc_assert (header->succ);\n   if (!header->succ->succ_next)\n     return false;\n   if (header->succ->succ_next->succ_next)\n@@ -118,8 +117,7 @@ duplicate_blocks (varray_type bbs_to_duplicate)\n       preheader_edge = VARRAY_GENERIC_PTR_NOGC (bbs_to_duplicate, i);\n       header = preheader_edge->dest;\n \n-      if (!header->aux)\n-\tabort ();\n+      gcc_assert (header->aux);\n       header->aux = NULL;\n \n       new_header = duplicate_block (header, preheader_edge);"}, {"sha": "c0d2c00ad9ee0d08389ac95f04457dfe9731ffff", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -150,7 +150,7 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \t  return true;\n \n \tdefault:\n-    \t  abort ();\n+    \t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -438,12 +438,9 @@ set_level (tree stmt, struct loop *orig_loop, struct loop *level)\n   if (flow_loop_nested_p (stmt_loop, level))\n     return;\n \n-  if (!LIM_DATA (stmt))\n-    abort ();\n-\n-  if (level != LIM_DATA (stmt)->max_loop\n-      && !flow_loop_nested_p (LIM_DATA (stmt)->max_loop, level))\n-    abort ();\n+  gcc_assert (LIM_DATA (stmt));\n+  gcc_assert (level == LIM_DATA (stmt)->max_loop\n+\t      || flow_loop_nested_p (LIM_DATA (stmt)->max_loop, level));\n \n   LIM_DATA (stmt)->tgt_loop = level;\n   for (dep = LIM_DATA (stmt)->depends; dep; dep = dep->next)\n@@ -1106,7 +1103,7 @@ is_call_clobbered_ref (tree ref)\n       return false;\n     }\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Determine whether all memory references inside LOOP corresponding to the"}, {"sha": "fd0250bf77865d2a752ba5cb9350bc16caa0898d", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -355,7 +355,7 @@ dump_use (FILE *file, struct iv_use *use)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n    fprintf (file, \"  in statement \");\n@@ -513,8 +513,7 @@ divide (unsigned bits, unsigned HOST_WIDE_INT a, unsigned HOST_WIDE_INT b,\n \n   val = (a * inv) & mask;\n \n-  if (((val * b) & mask) != a)\n-    abort ();\n+  gcc_assert (((val * b) & mask) == a);\n \n   if ((val >> (bits - 1)) & 1)\n     val |= ~mask;\n@@ -532,8 +531,7 @@ stmt_after_ip_normal_pos (struct loop *loop, tree stmt)\n {\n   basic_block bb = ip_normal_pos (loop), sbb = bb_for_stmt (stmt);\n \n-  if (!bb)\n-    abort ();\n+  gcc_assert (bb);\n \n   if (sbb == loop->latch)\n     return true;\n@@ -589,7 +587,7 @@ stmt_after_increment (struct loop *loop, struct iv_cand *cand, tree stmt)\n       return stmt_after_ip_original_pos (cand, stmt);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -644,8 +642,7 @@ set_iv (struct ivopts_data *data, tree iv, tree base, tree step)\n {\n   struct version_info *info = name_info (data, iv);\n \n-  if (info->iv)\n-    abort ();\n+  gcc_assert (!info->iv);\n \n   bitmap_set_bit (data->relevant, SSA_NAME_VERSION (iv));\n   info->iv = alloc_iv (base, step);\n@@ -741,7 +738,7 @@ contains_abnormal_ssa_name_p (tree expr)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return false;\n@@ -1030,9 +1027,8 @@ find_interesting_uses_outer_or_nonlin (struct ivopts_data *data, tree op,\n     {\n       use = iv_use (data, iv->use_id);\n \n-      if (use->type != USE_NONLINEAR_EXPR\n-\t  && use->type != USE_OUTER)\n-\tabort ();\n+      gcc_assert (use->type == USE_NONLINEAR_EXPR\n+\t\t  || use->type == USE_OUTER);\n \n       if (type == USE_NONLINEAR_EXPR)\n \tuse->type = USE_NONLINEAR_EXPR;\n@@ -1050,9 +1046,8 @@ find_interesting_uses_outer_or_nonlin (struct ivopts_data *data, tree op,\n   *civ = *iv;\n \n   stmt = SSA_NAME_DEF_STMT (op);\n-  if (TREE_CODE (stmt) != PHI_NODE\n-      && TREE_CODE (stmt) != MODIFY_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (stmt) == PHI_NODE\n+\t      || TREE_CODE (stmt) == MODIFY_EXPR);\n \n   use = record_use (data, NULL, civ, stmt, type);\n   iv->use_id = use->id;\n@@ -1742,7 +1737,7 @@ add_derived_ivs_candidates (struct ivopts_data *data)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -2531,8 +2526,7 @@ peel_address (tree addr, unsigned HOST_WIDE_INT *diff)\n       off = DECL_FIELD_BIT_OFFSET (TREE_OPERAND (addr, 1));\n       bit_offset = TREE_INT_CST_LOW (off);\n \n-      if (bit_offset % BITS_PER_UNIT)\n-\tabort ();\n+      gcc_assert ((bit_offset % BITS_PER_UNIT) == 0);\n       \n       if (diff)\n \t*diff += bit_offset / BITS_PER_UNIT;\n@@ -2557,7 +2551,7 @@ peel_address (tree addr, unsigned HOST_WIDE_INT *diff)\n       return TREE_OPERAND (addr, 0);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2647,8 +2641,7 @@ ptr_difference_cost (struct ivopts_data *data,\n   unsigned HOST_WIDE_INT diff = 0;\n   unsigned cost;\n \n-  if (TREE_CODE (e1) != ADDR_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (e1) == ADDR_EXPR);\n \n   if (TREE_CODE (e2) == ADDR_EXPR\n       && ptr_difference_const (TREE_OPERAND (e1, 0),\n@@ -3041,9 +3034,8 @@ may_replace_final_value (struct loop *loop, struct iv_use *use, tree *value)\n   if (!exit)\n     return false;\n \n-  if (!dominated_by_p (CDI_DOMINATORS, exit->src,\n-\t\t       bb_for_stmt (use->stmt)))\n-    abort ();\n+  gcc_assert (dominated_by_p (CDI_DOMINATORS, exit->src,\n+\t\t\t      bb_for_stmt (use->stmt)));\n \n   niter = &loop_data (loop)->niter;\n   if (!niter->niter\n@@ -3129,7 +3121,7 @@ determine_use_iv_cost (struct ivopts_data *data,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3790,8 +3782,9 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n   tree op, stmts, tgt, ass;\n   block_stmt_iterator bsi, pbsi;\n  \n-  if (TREE_CODE (use->stmt) == PHI_NODE)\n+  switch (TREE_CODE (use->stmt))\n     {\n+    case PHI_NODE:\n       tgt = PHI_RESULT (use->stmt);\n \n       /* If we should keep the biv, do not replace it.  */\n@@ -3805,14 +3798,16 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t  bsi = pbsi;\n \t  bsi_next (&pbsi);\n \t}\n-    }\n-  else if (TREE_CODE (use->stmt) == MODIFY_EXPR)\n-    {\n+      break;\n+\n+    case MODIFY_EXPR:\n       tgt = TREE_OPERAND (use->stmt, 0);\n       bsi = stmt_for_bsi (use->stmt);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   op = force_gimple_operand (comp, &stmts, false, SSA_NAME_VAR (tgt));\n \n@@ -4102,20 +4097,26 @@ rewrite_use_outer (struct ivopts_data *data,\n   tree value, op, stmts, tgt;\n   tree phi;\n \n-  if (TREE_CODE (use->stmt) == PHI_NODE)\n-    tgt = PHI_RESULT (use->stmt);\n-  else if (TREE_CODE (use->stmt) == MODIFY_EXPR)\n-    tgt = TREE_OPERAND (use->stmt, 0);\n-  else\n-    abort ();\n+  switch (TREE_CODE (use->stmt))\n+    {\n+    case PHI_NODE:\n+      tgt = PHI_RESULT (use->stmt);\n+      break;\n+    case MODIFY_EXPR:\n+      tgt = TREE_OPERAND (use->stmt, 0);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n   exit = single_dom_exit (data->current_loop);\n \n   if (exit)\n     {\n       if (!cand->iv)\n \t{\n-\t  if (!may_replace_final_value (data->current_loop, use, &value))\n-\t    abort ();\n+\t  bool ok = may_replace_final_value (data->current_loop, use, &value);\n+\t  gcc_assert (ok);\n \t}\n       else\n \tvalue = get_computation_at (data->current_loop,\n@@ -4180,7 +4181,7 @@ rewrite_use (struct ivopts_data *data,\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   modify_stmt (use->stmt);\n }\n@@ -4198,8 +4199,7 @@ rewrite_uses (struct ivopts_data *data)\n     {\n       use = iv_use (data, i);\n       cand = use->selected;\n-      if (!cand)\n-\tabort ();\n+      gcc_assert (cand);\n \n       rewrite_use (data, use, cand);\n     }"}, {"sha": "cde3ce8fb4d80e4ca8d017f4943ebb57c2b9c7df", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -310,8 +310,7 @@ rewrite_into_loop_closed_ssa (void)\n   unsigned i;\n   bitmap names_to_rename;\n \n-  if (any_marked_for_rewrite_p ())\n-    abort ();\n+  gcc_assert (!any_marked_for_rewrite_p ());\n \n   use_blocks = xcalloc (num_ssa_names, sizeof (bitmap));\n \n@@ -346,9 +345,8 @@ check_loop_closed_ssa_use (basic_block bb, tree use)\n \n   def = SSA_NAME_DEF_STMT (use);\n   def_bb = bb_for_stmt (def);\n-  if (def_bb\n-      && !flow_bb_inside_loop_p (def_bb->loop_father, bb))\n-    abort ();\n+  gcc_assert (!def_bb\n+\t      || flow_bb_inside_loop_p (def_bb->loop_father, bb));\n }\n \n /* Checks invariants of loop closed ssa form in statement STMT in BB.  */"}, {"sha": "6b234c13f8973e0e5e19dcca603666820440d517", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -26,6 +26,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"function.h\"\n #include \"diagnostic.h\"\n+#include \"errors.h\"\n #include \"tree-flow.h\"\n #include \"tree-inline.h\"\n #include \"tree-pass.h\"\n@@ -322,11 +323,8 @@ finalize_ssa_defs (def_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n   if (num == 0)\n     return NULL;\n \n-#ifdef ENABLE_CHECKING\n   /* There should only be a single real definition per assignment.  */\n-  if (TREE_CODE (stmt) == MODIFY_EXPR && num > 1)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (stmt) != MODIFY_EXPR || num <= 1);\n \n   old_ops = *old_ops_p;\n \n@@ -382,8 +380,7 @@ finalize_ssa_uses (use_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n        initial call to get_stmt_operands does not pass a pointer to a \n        statement).  */\n     for (x = 0; x < num; x++)\n-      if (*(VARRAY_TREE_PTR (build_uses, x)) == stmt)\n-\tabort ();\n+      gcc_assert (*(VARRAY_TREE_PTR (build_uses, x)) != stmt);\n   }\n #endif\n   old_ops = *old_ops_p;\n@@ -639,11 +636,8 @@ finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p,\n   if (num == 0)\n     return NULL;\n \n-#ifdef ENABLE_CHECKING\n   /* There should only be a single V_MUST_DEF per assignment.  */\n-  if (TREE_CODE (stmt) == MODIFY_EXPR && num > 1)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (stmt) != MODIFY_EXPR || num <= 1);\n \n   old_ops = *old_ops_p;\n \n@@ -721,14 +715,11 @@ finalize_ssa_stmt_operands (tree stmt, stmt_operands_p old_ops,\n static inline void\n start_ssa_stmt_operands (void)\n {\n-#ifdef ENABLE_CHECKING\n-  if (VARRAY_ACTIVE_SIZE (build_defs) > 0 \n-      || VARRAY_ACTIVE_SIZE (build_uses) > 0\n-      || VARRAY_ACTIVE_SIZE (build_vuses) > 0\n-      || VARRAY_ACTIVE_SIZE (build_v_may_defs) > 0\n-      || VARRAY_ACTIVE_SIZE (build_v_must_defs) > 0)\n-    abort ();\n-#endif\n+  gcc_assert (VARRAY_ACTIVE_SIZE (build_defs) == 0);\n+  gcc_assert (VARRAY_ACTIVE_SIZE (build_uses) == 0);\n+  gcc_assert (VARRAY_ACTIVE_SIZE (build_vuses) == 0);\n+  gcc_assert (VARRAY_ACTIVE_SIZE (build_v_may_defs) == 0);\n+  gcc_assert (VARRAY_ACTIVE_SIZE (build_v_must_defs) == 0);\n }\n \n \n@@ -935,12 +926,9 @@ get_stmt_operands (tree stmt)\n   stmt_ann_t ann;\n   stmt_operands_t old_operands;\n \n-#if defined ENABLE_CHECKING\n   /* The optimizers cannot handle statements that are nothing but a\n      _DECL.  This indicates a bug in the gimplifier.  */\n-  if (SSA_VAR_P (stmt))\n-    abort ();\n-#endif\n+  gcc_assert (!SSA_VAR_P (stmt));\n \n   /* Ignore error statements.  */\n   if (TREE_CODE (stmt) == ERROR_MARK)\n@@ -1189,10 +1177,13 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     }\n \n   /* If we get here, something has gone wrong.  */\n+#ifdef ENABLE_CHECKING\n   fprintf (stderr, \"unhandled expression in get_expr_operands():\\n\");\n   debug_tree (expr);\n   fputs (\"\\n\", stderr);\n-  abort ();\n+  internal_error (\"internal error\");\n+#endif\n+  gcc_unreachable ();\n }\n \n \n@@ -1217,11 +1208,8 @@ get_asm_expr_operands (tree stmt)\n       parse_output_constraint (&constraint, i, 0, 0,\n \t  &allows_mem, &allows_reg, &is_inout);\n \n-#if defined ENABLE_CHECKING\n       /* This should have been split in gimplify_asm_expr.  */\n-      if (allows_reg && is_inout)\n-\tabort ();\n-#endif\n+      gcc_assert (!allows_reg || !is_inout);\n \n       /* Memory operands are addressable.  Note that STMT needs the\n \t address of this operand.  */\n@@ -1379,7 +1367,7 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n \n   /* Ok, this isn't even is_gimple_min_invariant.  Something's broke.  */\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   /* Add a USE operand for the base pointer.  */\n   get_expr_operands (stmt, pptr, opf_none);\n@@ -1489,12 +1477,9 @@ add_stmt_operand (tree *var_p, tree stmt, int flags)\n \t    {\n \t      if (flags & opf_kill_def)\n \t\t{\n-#if defined ENABLE_CHECKING\n \t\t  /* Only regular variables may get a V_MUST_DEF\n \t\t     operand.  */\n-\t\t  if (v_ann->mem_tag_kind != NOT_A_TAG)\n-\t\t    abort ();\n-#endif\n+\t\t  gcc_assert (v_ann->mem_tag_kind == NOT_A_TAG);\n \t\t  /* V_MUST_DEF for non-aliased, non-GIMPLE register \n \t\t    variable definitions.  */\n \t\t  append_v_must_def (var);\n@@ -1519,10 +1504,7 @@ add_stmt_operand (tree *var_p, tree stmt, int flags)\n \n \t  /* The variable is aliased.  Add its aliases to the virtual\n \t     operands.  */\n-#if defined ENABLE_CHECKING\n-\t  if (VARRAY_ACTIVE_SIZE (aliases) == 0)\n-\t    abort ();\n-#endif\n+\t  gcc_assert (VARRAY_ACTIVE_SIZE (aliases) != 0);\n \n \t  if (flags & opf_is_def)\n \t    {"}, {"sha": "b3227555f22cbb5a0630a745e9d5fc8f6486bb2d", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -444,10 +444,7 @@ value_exists_in_set_bitmap (value_set_t set, tree v)\n static void\n value_remove_from_set_bitmap (value_set_t set, tree v)\n {\n-#ifdef ENABLE_CHECKING\n-  if (!set->indexed)\n-    abort ();\n-#endif\n+  gcc_assert (set->indexed);\n \n   if (!set->values)\n     return;\n@@ -462,10 +459,7 @@ value_remove_from_set_bitmap (value_set_t set, tree v)\n static inline void\n value_insert_into_set_bitmap (value_set_t set, tree v)\n {\n-#ifdef ENABLE_CHECKING\n-  if (!set->indexed)\n-    abort ();\n-#endif\n+  gcc_assert (set->indexed);\n \n   if (set->values == NULL)\n     {\n@@ -511,12 +505,10 @@ bitmap_insert_into_set (bitmap_set_t set, tree expr)\n {\n   tree val;\n   /* XXX: For now, we only let SSA_NAMES into the bitmap sets.  */\n-  if (TREE_CODE (expr) != SSA_NAME)\n-    abort ();\n+  gcc_assert (TREE_CODE (expr) == SSA_NAME);\n   val = get_value_handle (expr);\n   \n-  if (val == NULL)\n-    abort ();\n+  gcc_assert (val);\n   if (!is_gimple_min_invariant (val))\n     bitmap_set_bit (set->values, VALUE_HANDLE_ID (val));\n   bitmap_set_bit (set->expressions, SSA_NAME_VERSION (expr));\n@@ -529,9 +521,7 @@ insert_into_set (value_set_t set, tree expr)\n {\n   value_set_node_t newnode = pool_alloc (value_set_node_pool);\n   tree val = get_value_handle (expr);\n-  \n-  if (val == NULL)\n-    abort ();\n+  gcc_assert (val);\n \n   /* For indexed sets, insert the value into the set value bitmap.\n      For all sets, add it to the linked list and increment the list\n@@ -923,13 +913,12 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n       }\n       break;\n     case 'd':\n-      abort ();\n+      gcc_unreachable ();\n     case 'x':\n       {\n \ttree phi = NULL;\n \tint i;\n-\tif (TREE_CODE (expr) != SSA_NAME)\n-\t  abort ();\n+\tgcc_assert (TREE_CODE (expr) == SSA_NAME);\n \tif (TREE_CODE (SSA_NAME_DEF_STMT (expr)) == PHI_NODE)\n \t  phi = SSA_NAME_DEF_STMT (expr);\n \telse\n@@ -1078,12 +1067,11 @@ valid_in_set (value_set_t set, tree expr)\n       }\n     case 'x':\n       {\n-\tif (TREE_CODE (expr) == SSA_NAME)\n-\t  return true;\n-\tabort ();\n+\tgcc_assert (TREE_CODE (expr) == SSA_NAME);\n+\treturn true;\n       }\n     case 'c':\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return false;\n }\n@@ -1258,8 +1246,7 @@ compute_antic (void)\n   FOR_ALL_BB (bb)\n     {\n       ANTIC_IN (bb) = set_new (true);\n-      if (bb->flags & BB_VISITED)\n-\tabort ();\n+      gcc_assert (!(bb->flags & BB_VISITED));\n     }\n \n   while (changed)\n@@ -1304,10 +1291,9 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   if (genop == NULL)\n     {\n       genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n-      if (TREE_CODE_CLASS (TREE_CODE (genop)) != '1'\n-\t  && TREE_CODE_CLASS (TREE_CODE (genop)) != '2'\n-\t  && TREE_CODE_CLASS (TREE_CODE (genop)) != 'r')\n-\tabort ();\n+      gcc_assert (TREE_CODE_CLASS (TREE_CODE (genop)) == '1'\n+\t\t  || TREE_CODE_CLASS (TREE_CODE (genop)) == '2'\n+\t\t  || TREE_CODE_CLASS (TREE_CODE (genop)) == 'r');\n       genop = create_expression_by_pieces (block, genop, stmts);\n     }\n   return genop;\n@@ -1381,7 +1367,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tbreak;\n       }\n     default:\n-      abort ();\n+      gcc_unreachable ();\n       \n     }\n   v = get_value_handle (expr);\n@@ -1497,8 +1483,7 @@ insert_aux (basic_block block)\n \t\t\t    }\n \n \t\t\t  vprime = get_value_handle (eprime);\n-\t\t\t  if (!vprime)\n-\t\t\t    abort ();\t\t\t  \n+\t\t\t  gcc_assert (vprime);\n \t\t\t  edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n \t\t\t\t\t\t\t     vprime);\n \t\t\t  if (edoubleprime == NULL)\n@@ -1514,9 +1499,9 @@ insert_aux (basic_block block)\n \t\t\t\tfirst_s = edoubleprime;\n \t\t\t      else if (first_s != edoubleprime)\n \t\t\t\tall_same = false;\n-\t\t\t      if (first_s != edoubleprime \n-\t\t\t\t  && operand_equal_p (first_s, edoubleprime, 0))\n-\t\t\t\tabort ();\n+\t\t\t      gcc_assert (first_s == edoubleprime \n+\t\t\t\t\t  || !operand_equal_p\n+\t\t\t\t\t      (first_s, edoubleprime, 0));\n \t\t\t    }\n \t\t\t}\n \t\t      /* If we can insert it, it's not the same value\n@@ -1683,12 +1668,9 @@ create_value_expr_from (tree expr, basic_block block, vuse_optype vuses)\n   enum tree_code code = TREE_CODE (expr);\n   tree vexpr;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE_CLASS (code) != '1'\n-      && TREE_CODE_CLASS (code) != '2'\n-      && TREE_CODE_CLASS (code) != 'r')\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE_CLASS (code) == '1'\n+\t      || TREE_CODE_CLASS (code) == '2'\n+\t      || TREE_CODE_CLASS (code) == 'r');\n \n   if (TREE_CODE_CLASS (code) == '1')\n     vexpr = pool_alloc (unary_node_pool);\n@@ -1887,8 +1869,7 @@ eliminate (void)\n \t\t  && (TREE_CODE (*rhs_p) != SSA_NAME\n \t\t      || may_propagate_copy (*rhs_p, sprime)))\n \t\t{\n-\t\t  if (sprime == *rhs_p)\n-\t\t    abort ();\n+\t\t  gcc_assert (sprime != *rhs_p);\n \n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    {"}, {"sha": "8e65f6444a4b5ae7be4c5f8f64ca6b8081337522", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -215,10 +215,8 @@ cfg_blocks_get (void)\n \n   bb = VARRAY_BB (cfg_blocks, cfg_blocks_head);\n \n-#ifdef ENABLE_CHECKING\n-  if (cfg_blocks_empty_p () || !bb)\n-    abort ();\n-#endif\n+  gcc_assert (!cfg_blocks_empty_p ());\n+  gcc_assert (bb);\n \n   cfg_blocks_head = (cfg_blocks_head + 1) % VARRAY_SIZE (cfg_blocks);\n   --cfg_blocks_num;"}, {"sha": "50c5b320da0f235ed65af4b71b30d32ea5a98cb9", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -145,11 +145,8 @@ remove_last_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n \n   bsi = bsi_last (bb);\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (bsi_stmt (bsi)) != COND_EXPR\n-      && TREE_CODE (bsi_stmt (bsi)) != SWITCH_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (bsi_stmt (bsi)) == COND_EXPR\n+\t      || TREE_CODE (bsi_stmt (bsi)) == SWITCH_EXPR);\n \n   bsi_remove (&bsi);\n "}, {"sha": "4d8096b22942befb5b7d83ff28700deb3d245d26", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -845,10 +845,7 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data,\n {\n   tree def_stmt;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (var) != SSA_NAME)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (var) == SSA_NAME);\n \n   def_stmt = SSA_NAME_DEF_STMT (var);\n \n@@ -1047,8 +1044,7 @@ check_phi_redundancy (tree phi, tree *eq_to)\n \n   /* At least one of the arguments should not be equal to the result, or\n      something strange is happening.  */\n-  if (!val)\n-    abort ();\n+  gcc_assert (val);\n \n   if (get_eq_name (eq_to, res) == val)\n     return;"}, {"sha": "d138a793ebfc43b003f04308daa74fbf465db124", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -181,14 +181,12 @@ make_ssa_name (tree var, tree stmt)\n {\n   tree t;\n \n-#if defined ENABLE_CHECKING\n-  if ((!DECL_P (var)\n-       && TREE_CODE (var) != INDIRECT_REF)\n-      || (stmt\n-\t  && !IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (stmt)))\n-\t  && TREE_CODE (stmt) != PHI_NODE))\n-    abort ();\n-#endif\n+  gcc_assert (DECL_P (var)\n+\t      || TREE_CODE (var) == INDIRECT_REF);\n+\n+  gcc_assert (!stmt\n+\t      || IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (stmt)))\n+\t      || TREE_CODE (stmt) == PHI_NODE);\n \n   /* If our free list has an element, then use it.  Also reuse the\n      SSA version number of the element on the free list which helps"}, {"sha": "e3f491e2be1cc8251d2cff188e09d97e641b0b30", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -233,8 +233,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n       for (e = bb->pred; e; e = e->pred_next)\n \tif (e->src->aux)\n \t  break;\n-      if (!e)\n-\tabort ();\n+      gcc_assert (e);\n \n       expr = PHI_ARG_DEF_FROM_EDGE (at, e);\n       if (TREE_CODE (expr) != SSA_NAME)\n@@ -592,8 +591,7 @@ adjust_return_value (basic_block bb, tree m, tree a)\n   tree ret_type = TREE_TYPE (DECL_RESULT (current_function_decl));\n   block_stmt_iterator bsi = bsi_last (bb);\n \n-  if (TREE_CODE (ret_stmt) != RETURN_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (ret_stmt) == RETURN_EXPR);\n \n   ret_var = TREE_OPERAND (ret_stmt, 0);\n   if (!ret_var)\n@@ -691,8 +689,7 @@ eliminate_tail_call (struct tailcall *t)\n \n   /* Replace the call by a jump to the start of function.  */\n   e = redirect_edge_and_branch (t->call_block->succ, first);\n-  if (!e)\n-    abort ();\n+  gcc_assert (e);\n   PENDING_STMT (e) = NULL_TREE;\n \n   /* Add phi node entries for arguments.  Not every PHI node corresponds to\n@@ -751,8 +748,7 @@ eliminate_tail_call (struct tailcall *t)\n \t  /* For all calls the same set of variables should be clobbered.  This\n \t     means that there always should be the appropriate phi node except\n \t     for the first time we eliminate the call.  */\n-\t  if (first->pred->pred_next->pred_next)\n-\t    abort ();\n+\t  gcc_assert (!first->pred->pred_next->pred_next);\n \t}\n \n       add_phi_arg (&phi, V_MAY_DEF_OP (v_may_defs, i), e);"}, {"sha": "65214cc7ebe3989897c38ed90bf0ec9bbb5a3fcd", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 39, "deletions": 83, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -540,25 +540,18 @@ vect_create_index_for_array_ref (tree stmt, block_stmt_iterator *bsi)\n   varray_type access_fns = DR_ACCESS_FNS (dr);\n \n   /* FORNOW: handling only one dimensional arrays.  */\n-  if (VARRAY_ACTIVE_SIZE (access_fns) != 1)\n-    abort ();\n-\n-  if (!vectorization_factor)\n-    abort ();\n+  gcc_assert (VARRAY_ACTIVE_SIZE (access_fns) == 1);\n+  gcc_assert (vectorization_factor);\n #endif\n \n   access_fn = DR_ACCESS_FN (dr, 0);\n   ok = vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step, true)\n        && vect_get_first_index (expr, &array_first_index);\n \n-#ifdef ENABLE_CHECKING\n-  if (!ok)\n-    abort ();\n+  gcc_assert (ok);\n \n   /* FORNOW: Handling only constant 'init'.  */\n-  if (TREE_CODE (init) != INTEGER_CST)\n-    abort ();\t\n-#endif\n+  gcc_assert (TREE_CODE (init) == INTEGER_CST);\n \n   vf = build_int_cst (unsigned_type_node, vectorization_factor);\n \n@@ -636,8 +629,7 @@ vect_align_data_ref (tree stmt)\n \n   /* FORNOW: can't handle misaligned accesses; \n              all accesses expected to be aligned.  */\n-  if (!aligned_access_p (dr))\n-    abort ();\n+  gcc_assert (aligned_access_p (dr));\n }\n \n \n@@ -706,12 +698,9 @@ vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n \t\tget_name (addr_ref));\n   add_referenced_tmp_var (vect_ptr);\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (addr_ref) != VAR_DECL\n-      && TREE_CODE (addr_ref) != COMPONENT_REF\n-      && TREE_CODE (addr_ref) != SSA_NAME)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (addr_ref) == VAR_DECL\n+\t      || TREE_CODE (addr_ref) == COMPONENT_REF\n+\t      || TREE_CODE (addr_ref) == SSA_NAME);\n \n   if (vect_debug_details (NULL))\n     {\n@@ -732,10 +721,7 @@ vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n \n   /* Handle aliasing:  */ \n   tag = STMT_VINFO_MEMTAG (stmt_info);\n-#ifdef ENABLE_CHECKING\n-  if (!tag)\n-    abort ();\n-#endif\n+  gcc_assert (tag);\n   get_var_ann (vect_ptr)->type_mem_tag = tag;\n   \n   /* Mark for renaming all aliased variables\n@@ -794,10 +780,7 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n   tree vec_dest;\n   const char *new_name;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (scalar_dest) != SSA_NAME)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (scalar_dest) == SSA_NAME);\n \n   new_name = get_name (scalar_dest);\n   if (!new_name)\n@@ -907,10 +890,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n       return vect_init_vector (stmt, vec_cst);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE (op) != SSA_NAME)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (op) == SSA_NAME);\n  \n   /** ===> Case 2: operand is an SSA_NAME - find the stmt that defines it.  **/\n \n@@ -931,10 +911,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n       /* Get the def from the vectorized stmt.  */\n \n       vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n-#ifdef ENABLE_CHECKING\n-      if (!vec_stmt)\n-        abort ();\n-#endif\n+      gcc_assert (vec_stmt);\n       vec_oprnd = TREE_OPERAND (vec_stmt, 0);\n       return vec_oprnd;\n     }\n@@ -948,7 +925,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n     {\n       if (vect_debug_details (NULL))\n \tfprintf (dump_file, \"reduction/induction - unsupported.\");\n-      abort (); /* FORNOW no support for reduction/induction.  */\n+      internal_error (\"no support for reduction/induction\"); /* FORNOW */\n     }\n \n \n@@ -965,10 +942,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n       break;\n     case NOP_EXPR:\n       def = TREE_OPERAND (def_stmt, 0);\n-#ifdef ENABLE_CHECKING\n-      if (!IS_EMPTY_STMT (def_stmt))\n-\tabort ();\n-#endif\n+      gcc_assert (IS_EMPTY_STMT (def_stmt));\n       def = op;\n       break;\n     default:\n@@ -977,7 +951,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n           fprintf (dump_file, \"unsupported defining stmt: \");\n \t  print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n \t}\n-      abort ();\n+      internal_error (\"unsupported defining stmt\");\n     }\n \n   /* Build a tree with vector elements. Create 'vec_inv = {inv,inv,..,inv}'  */\n@@ -1017,10 +991,7 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n \n   while (stmt != bsi_stmt (*bsi) && !bsi_end_p (*bsi))\n     bsi_next (bsi);\n-#ifdef ENABLE_CHECKING\n-  if (stmt != bsi_stmt (*bsi))\n-    abort ();\n-#endif\n+  gcc_assert (stmt == bsi_stmt (*bsi));\n }\n \n \n@@ -1352,33 +1323,34 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n   bool is_store = false;\n   tree vec_stmt = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  bool done;\n \n   switch (STMT_VINFO_TYPE (stmt_info))\n     {\n     case op_vec_info_type:\n-      if (!vectorizable_operation (stmt, bsi, &vec_stmt))\n-        abort ();\n+      done = vectorizable_operation (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n       break;\n \n     case assignment_vec_info_type:\n-      if (!vectorizable_assignment (stmt, bsi, &vec_stmt))\n-\tabort ();\n+      done = vectorizable_assignment (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n       break;\n \n     case load_vec_info_type:\n-      if (!vectorizable_load (stmt, bsi, &vec_stmt))\n-\tabort ();\n+      done = vectorizable_load (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n       break;\n \n     case store_vec_info_type:\n-      if (!vectorizable_store (stmt, bsi, &vec_stmt))\n-\tabort ();\n+      done = vectorizable_store (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n       is_store = true;\n       break;\n     default:\n       if (vect_debug_details (NULL))\n         fprintf (dump_file, \"stmt not supported.\");\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n@@ -1406,36 +1378,25 @@ vect_transform_loop_bound (loop_vec_info loop_vinfo)\n   tree cond;\n   tree lb_type;\n \n-#ifdef ENABLE_CHECKING\n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-    abort ();\n-#endif\n+  gcc_assert (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo));\n   old_N = LOOP_VINFO_NITERS (loop_vinfo);\n   vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n-#ifdef ENABLE_CHECKING\n   /* FORNOW: \n      assuming number-of-iterations divides by the vectorization factor.  */\n-  if (old_N % vf)\n-    abort ();\n-#endif\n+  gcc_assert (!(old_N % vf));\n \n   orig_cond_expr = LOOP_VINFO_EXIT_COND (loop_vinfo);\n-#ifdef ENABLE_CHECKING\n-  if (!orig_cond_expr)\n-    abort ();\n-#endif\n-  if (orig_cond_expr != bsi_stmt (loop_exit_bsi))\n-    abort ();\n+  gcc_assert (orig_cond_expr);\n+  gcc_assert (orig_cond_expr == bsi_stmt (loop_exit_bsi));\n \n   create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop, \n \t     &loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n \n   /* bsi_insert is using BSI_NEW_STMT. We need to bump it back \n      to point to the exit condition.  */\n   bsi_next (&loop_exit_bsi);\n-  if (bsi_stmt (loop_exit_bsi) != orig_cond_expr)\n-    abort ();\n+  gcc_assert (bsi_stmt (loop_exit_bsi) == orig_cond_expr);\n \n   /* new loop exit test:  */\n   lb_type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (orig_cond_expr, 0), 1));\n@@ -1484,9 +1445,8 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   /* 1) Make sure the loop header has exactly two entries\n      2) Make sure we have a preheader basic block.  */\n \n-  if (!loop->header->pred->pred_next\n-      || loop->header->pred->pred_next->pred_next)\n-    abort ();\n+  gcc_assert (loop->header->pred->pred_next);\n+  gcc_assert (!loop->header->pred->pred_next->pred_next);\n \n   loop_split_edge_with (loop_preheader_edge (loop), NULL);\n \n@@ -1515,10 +1475,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n \t    }\t\n \t  stmt_info = vinfo_for_stmt (stmt);\n-#ifdef ENABLE_CHECKING\n-\t  if (!stmt_info)\n-\t    abort ();\n-#endif\n+\t  gcc_assert (stmt_info);\n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n \t    {\n \t      bsi_next (&si);\n@@ -1528,8 +1485,8 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t  /* FORNOW: Verify that all stmts operate on the same number of\n \t             units and no inner unrolling is necessary.  */\n \t  vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t  if (GET_MODE_NUNITS (TYPE_MODE (vectype)) != vectorization_factor)\n-\t    abort ();\n+\t  gcc_assert (GET_MODE_NUNITS (TYPE_MODE (vectype))\n+\t\t      == vectorization_factor);\n #endif\n \t  /* -------- vectorize statement ------------ */\n \t  if (vect_debug_details (NULL))\n@@ -1668,10 +1625,9 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t      fprintf (dump_file, \"==> examining statement: \");\n \t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n \t    }\n-#ifdef ENABLE_CHECKING\n-\t  if (!stmt_info)\n-\t    abort ();\n-#endif\n+\n+\t  gcc_assert (stmt_info);\n+\n \t  /* skip stmts which do not need to be vectorized.\n \t     this is expected to include:\n \t     - the COND_EXPR which is the loop exit condition"}, {"sha": "0f65c8a26aa6bb5bb18509a0e046dfc198aa92a7", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -87,14 +87,11 @@ vn_compute (tree expr, hashval_t val, vuse_optype vuses)\n {\n   size_t i;\n \n-#if defined ENABLE_CHECKING\n   /* EXPR must not be a statement.  We are only interested in value\n      numbering expressions on the RHS of assignments.  */\n-  if (expr == NULL_TREE\n-      || (expr->common.ann\n-\t  && expr->common.ann->common.type == STMT_ANN))\n-    abort ();\n-#endif\n+  gcc_assert (expr);\n+  gcc_assert (!expr->common.ann\n+\t      || expr->common.ann->common.type != STMT_ANN);\n \n   val = iterative_hash_expr (expr, val);\n \n@@ -177,11 +174,9 @@ set_value_handle (tree e, tree v)\n     SSA_NAME_VALUE (e) = v;\n   else if (EXPR_P (e) || DECL_P (e))\n     get_tree_ann (e)->common.value_handle = v;\n-  else if (is_gimple_min_invariant (e))\n-    /* Do nothing.  Constants are their own value handles.  */\n-    ;\n   else\n-    abort ();\n+    /* Do nothing.  Constants are their own value handles.  */\n+    gcc_assert (is_gimple_min_invariant (e));\n }\n \n \n@@ -284,10 +279,11 @@ get_value_handle (tree expr)\n       tree_ann_t ann = tree_ann (expr);\n       return ((ann) ? ann->common.value_handle : NULL_TREE);\n     }\n-  else if (is_gimple_min_invariant (expr))\n-    return expr;\n-\n-  abort ();\n+  else\n+    {\n+      gcc_assert (is_gimple_min_invariant (expr));\n+      return expr;\n+    }\n }\n \n "}, {"sha": "7b9c53f31a7eb58123b5764cf774cc5aaa5f8050", "filename": "gcc/tree.c", "status": "modified", "additions": 58, "deletions": 85, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e128c5f7b58721f49ba367788e518355747dc04/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1e128c5f7b58721f49ba367788e518355747dc04", "patch": "@@ -205,7 +205,7 @@ tree_size (tree node)\n \t}\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -228,8 +228,8 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \n   /* We can't allocate a TREE_VEC, PHI_NODE, or STRING_CST\n      without knowing how many elements it will have.  */\n-  if (code == TREE_VEC || code == PHI_NODE)\n-    abort ();\n+  gcc_assert (code != TREE_VEC);\n+  gcc_assert (code != PHI_NODE);\n \n   TREE_SET_CODE ((tree)&ttmp, code);\n   length = tree_size ((tree)&ttmp);\n@@ -282,7 +282,7 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   tree_node_counts[(int) kind]++;\n@@ -366,10 +366,7 @@ copy_node_stat (tree node MEM_STAT_DECL)\n   enum tree_code code = TREE_CODE (node);\n   size_t length;\n \n-#ifdef ENABLE_CHECKING\n-  if (code == STATEMENT_LIST)\n-    abort ();\n-#endif\n+  gcc_assert (code != STATEMENT_LIST);\n \n   length = tree_size (node);\n   t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n@@ -547,10 +544,9 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n       if (t)\n \t{\n \t  /* Make sure no one is clobbering the shared constant.  */\n-\t  if (TREE_TYPE (t) != type)\n-\t    abort ();\n-\t  if (TREE_INT_CST_LOW (t) != low || TREE_INT_CST_HIGH (t) != hi)\n-\t    abort ();\n+\t  gcc_assert (TREE_TYPE (t) == type);\n+\t  gcc_assert (TREE_INT_CST_LOW (t) == low);\n+\t  gcc_assert (TREE_INT_CST_HIGH (t) == hi);\n \t  return t;\n \t}\n     }\n@@ -840,10 +836,9 @@ integer_all_onesp (tree expr)\n \n       shift_amount = prec - HOST_BITS_PER_WIDE_INT;\n \n-      if (shift_amount > HOST_BITS_PER_WIDE_INT)\n-\t/* Can not handle precisions greater than twice the host int size.  */\n-\tabort ();\n-      else if (shift_amount == HOST_BITS_PER_WIDE_INT)\n+      /* Can not handle precisions greater than twice the host int size.  */\n+      gcc_assert (shift_amount <= HOST_BITS_PER_WIDE_INT);\n+      if (shift_amount == HOST_BITS_PER_WIDE_INT)\n \t/* Shifting by the host word size is undefined according to the ANSI\n \t   standard, so we must handle this as a special case.  */\n \thigh_value = -1;\n@@ -1133,8 +1128,7 @@ list_length (tree t)\n #ifdef ENABLE_TREE_CHECKING\n       if (len % 2)\n \tq = TREE_CHAIN (q);\n-      if (p == q)\n-\tabort ();\n+      gcc_assert (p != q);\n #endif\n       len++;\n     }\n@@ -1179,8 +1173,7 @@ chainon (tree op1, tree op2)\n   {\n     tree t2;\n     for (t2 = op2; t2; t2 = TREE_CHAIN (t2))\n-      if (t2 == t1)\n-\tabort ();  /* Circularity created.  */\n+      gcc_assert (t2 != t1);\n   }\n #endif\n \n@@ -1632,7 +1625,7 @@ tree_node_structure (tree t)\n     case VALUE_HANDLE:\t\treturn TS_VALUE_HANDLE;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -1799,7 +1792,7 @@ type_contains_placeholder_p (tree type)\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1960,12 +1953,12 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   TREE_READONLY (new) = TREE_READONLY (exp);\n@@ -2090,12 +2083,12 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t      return fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n }\n \f\n@@ -2255,7 +2248,7 @@ stabilize_reference_1 (tree e)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   TREE_TYPE (result) = TREE_TYPE (e);\n@@ -2369,10 +2362,7 @@ build0_stat (enum tree_code code, tree tt MEM_STAT_DECL)\n {\n   tree t;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE_LENGTH (code) != 0)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE_LENGTH (code) == 0);\n \n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n@@ -2407,10 +2397,7 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n   tree_node_sizes[(int) kind] += length;\n #endif\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE_LENGTH (code) != 1)\n-    abort ();\n-#endif /* ENABLE_CHECKING */\n+  gcc_assert (TREE_CODE_LENGTH (code) == 1);\n \n   t = ggc_alloc_zone_stat (length, tree_zone PASS_MEM_STAT);\n \n@@ -2498,10 +2485,7 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n   tree t;\n   int fro;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE_LENGTH (code) != 2)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE_LENGTH (code) == 2);\n \n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n@@ -2541,10 +2525,7 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   tree t;\n   int fro;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE_LENGTH (code) != 3)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE_LENGTH (code) == 3);\n \n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n@@ -2592,10 +2573,7 @@ build4_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   tree t;\n   int fro;\n \n-#ifdef ENABLE_CHECKING\n-  if (TREE_CODE_LENGTH (code) != 4)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE_LENGTH (code) == 4);\n \n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n@@ -2654,7 +2632,7 @@ tree\n       t = build4 (code, tt, arg0, arg1, arg2, arg3);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   va_end (p);\n \n@@ -2973,10 +2951,10 @@ is_attribute_p (const char *attr, tree ident)\n   /* If ATTR is `__text__', IDENT must be `text'; and vice versa.  */\n   if (attr[0] == '_')\n     {\n-      if (attr[1] != '_'\n-\t  || attr[attr_len - 2] != '_'\n-\t  || attr[attr_len - 1] != '_')\n-\tabort ();\n+      gcc_assert (attr[1] == '_');\n+      gcc_assert (attr[attr_len - 2] == '_');\n+      gcc_assert (attr[attr_len - 1] == '_');\n+      gcc_assert (attr[1] == '_');\n       if (ident_len == attr_len - 4\n \t  && strncmp (attr + 2, p, attr_len - 4) == 0)\n \treturn 1;\n@@ -3006,8 +2984,7 @@ lookup_attribute (const char *attr_name, tree list)\n \n   for (l = list; l; l = TREE_CHAIN (l))\n     {\n-      if (TREE_CODE (TREE_PURPOSE (l)) != IDENTIFIER_NODE)\n-\tabort ();\n+      gcc_assert (TREE_CODE (TREE_PURPOSE (l)) == IDENTIFIER_NODE);\n       if (is_attribute_p (attr_name, TREE_PURPOSE (l)))\n \treturn l;\n     }\n@@ -3491,8 +3468,7 @@ type_hash_canon (unsigned int hashcode, tree type)\n \n   /* The hash table only contains main variants, so ensure that's what we're\n      being passed.  */\n-  if (TYPE_MAIN_VARIANT (type) != type)\n-    abort ();\n+  gcc_assert (TYPE_MAIN_VARIANT (type) == type);\n \n   if (!lang_hooks.types.hash_types)\n     return type;\n@@ -3743,10 +3719,8 @@ host_integerp (tree t, int pos)\n HOST_WIDE_INT\n tree_low_cst (tree t, int pos)\n {\n-  if (host_integerp (t, pos))\n-    return TREE_INT_CST_LOW (t);\n-  else\n-    abort ();\n+  gcc_assert (host_integerp (t, pos));\n+  return TREE_INT_CST_LOW (t);\n }\n \n /* Return the most significant bit of the integer constant T.  */\n@@ -4107,7 +4081,7 @@ iterative_hash_expr (tree t, hashval_t val)\n \t      val = iterative_hash_expr (TREE_OPERAND (t, i), val);\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n       return val;\n       break;\n     }\n@@ -4487,8 +4461,7 @@ build_method_type_directly (tree basetype,\n tree\n build_method_type (tree basetype, tree type)\n {\n-  if (TREE_CODE (type) != FUNCTION_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n \n   return build_method_type_directly (basetype,\n \t\t\t\t     TREE_TYPE (type),\n@@ -5047,7 +5020,7 @@ decl_type_context (tree decl)\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   return NULL_TREE;\n@@ -5064,8 +5037,7 @@ get_callee_fndecl (tree call)\n \n   /* It's invalid to call this function with anything but a\n      CALL_EXPR.  */\n-  if (TREE_CODE (call) != CALL_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR);\n \n   /* The first operand to the CALL is the address of the function\n      called.  */\n@@ -5265,9 +5237,10 @@ get_set_constructor_bits (tree init, char *buffer, int bit_size)\n \t  HOST_WIDE_INT hi_index\n \t    = tree_low_cst (TREE_VALUE (vals), 0) - domain_min;\n \n-\t  if (lo_index < 0 || lo_index >= bit_size\n-\t      || hi_index < 0 || hi_index >= bit_size)\n-\t    abort ();\n+\t  gcc_assert (lo_index >= 0);\n+\t  gcc_assert (lo_index < bit_size);\n+\t  gcc_assert (hi_index >= 0);\n+\t  gcc_assert (hi_index < bit_size);\n \t  for (; lo_index <= hi_index; lo_index++)\n \t    buffer[lo_index] = 1;\n \t}\n@@ -5703,21 +5676,25 @@ build_vector_type_for_mode (tree innertype, enum machine_mode mode)\n {\n   int nunits;\n \n-  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-      || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n-    nunits = GET_MODE_NUNITS (mode);\n-\n-  else if (GET_MODE_CLASS (mode) == MODE_INT)\n+  switch (GET_MODE_CLASS (mode))\n     {\n+    case MODE_VECTOR_INT:\n+    case MODE_VECTOR_FLOAT:\n+      nunits = GET_MODE_NUNITS (mode);\n+      break;\n+\n+    case MODE_INT:\n       /* Check that there are no leftover bits.  */\n-      if (GET_MODE_BITSIZE (mode) % TREE_INT_CST_LOW (TYPE_SIZE (innertype)))\n-\tabort ();\n+      gcc_assert (GET_MODE_BITSIZE (mode)\n+\t\t  % TREE_INT_CST_LOW (TYPE_SIZE (innertype)) == 0);\n \n       nunits = GET_MODE_BITSIZE (mode)\n \t       / TREE_INT_CST_LOW (TYPE_SIZE (innertype));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   return make_vector_type (innertype, nunits, mode);\n }\n@@ -5903,8 +5880,7 @@ int_cst_value (tree x)\n   unsigned HOST_WIDE_INT val = TREE_INT_CST_LOW (x);\n   bool negative = ((val >> (bits - 1)) & 1) != 0;\n \n-  if (bits > HOST_BITS_PER_WIDE_INT)\n-    abort ();\n+  gcc_assert (bits <= HOST_BITS_PER_WIDE_INT);\n \n   if (negative)\n     val |= (~(unsigned HOST_WIDE_INT) 0) << (bits - 1) << 1;\n@@ -5923,11 +5899,8 @@ tree_fold_gcd (tree a, tree b)\n   tree a_mod_b;\n   tree type = TREE_TYPE (a);\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (a) != INTEGER_CST\n-      || TREE_CODE (b) != INTEGER_CST)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (a) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (b) == INTEGER_CST);\n \n   if (integer_zerop (a))\n     return b;"}]}