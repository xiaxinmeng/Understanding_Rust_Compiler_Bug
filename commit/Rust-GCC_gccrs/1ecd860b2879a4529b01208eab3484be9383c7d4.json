{"sha": "1ecd860b2879a4529b01208eab3484be9383c7d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVjZDg2MGIyODc5YTQ1MjliMDEyMDhlYWIzNDg0YmU5MzgzYzdkNA==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-09-11T21:46:35Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-09-11T21:46:35Z"}, "message": "loop.h (LOOP_REGS): New macro.\n\n\t* loop.h (LOOP_REGS): New macro.\n\t(struct loop_regs): New.\n\t(struct loop_info): Add regs field.\n\t* loop.c (set_in_loop): Remove global array and store\n\tin loop_regs structure as part of loop_info structure.\n\t(n_times_set, may_not_optimize): Likewise.\n\t(reg_single_usage, moved_once): Likewise.\n\t(count_one_set): Add regs argument.\n\t(combine_movables, rtx_equal_for_loop_p, combine_givs): Likewise.\n\t(set_pseudo_multiple_uses): Pass regs pointer.\n\nFrom-SVN: r36335", "tree": {"sha": "15eef14322878903f4a9ad4465889d34fba1f1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15eef14322878903f4a9ad4465889d34fba1f1dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ecd860b2879a4529b01208eab3484be9383c7d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ecd860b2879a4529b01208eab3484be9383c7d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ecd860b2879a4529b01208eab3484be9383c7d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ecd860b2879a4529b01208eab3484be9383c7d4/comments", "author": null, "committer": null, "parents": [{"sha": "0a5b41f2563e140388e5d59fd81458d828034270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a5b41f2563e140388e5d59fd81458d828034270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a5b41f2563e140388e5d59fd81458d828034270"}], "stats": {"total": 394, "additions": 225, "deletions": 169}, "files": [{"sha": "ab40e4ea590696bb30ce10d44efd5611487b6532", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ecd860b2879a4529b01208eab3484be9383c7d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ecd860b2879a4529b01208eab3484be9383c7d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ecd860b2879a4529b01208eab3484be9383c7d4", "patch": "@@ -1,3 +1,16 @@\n+2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* loop.h (LOOP_REGS): New macro.\n+\t(struct loop_regs): New.\n+\t(struct loop_info): Add regs field.\n+\t* loop.c (set_in_loop): Remove global array and store \n+\tin loop_regs structure as part of loop_info structure.\n+\t(n_times_set, may_not_optimize): Likewise.\n+\t(reg_single_usage, moved_once): Likewise.\n+\t(count_one_set): Add regs argument.\n+\t(combine_movables, rtx_equal_for_loop_p, combine_givs): Likewise.\n+\t(set_pseudo_multiple_uses): Pass regs pointer.\n+\n 2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n \n \t* unroll.c (iteration_info): Subsume into loop_iterations."}, {"sha": "e718311f5e34ec5ce74ba2c068203277762d5d6d", "filename": "gcc/loop.c", "status": "modified", "additions": 167, "deletions": 167, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ecd860b2879a4529b01208eab3484be9383c7d4/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ecd860b2879a4529b01208eab3484be9383c7d4/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1ecd860b2879a4529b01208eab3484be9383c7d4", "patch": "@@ -78,41 +78,6 @@ static int max_luid;\n \n static int max_loop_num;\n \n-/* Indexed by register number, contains the number of times the reg\n-   is set during the loop being scanned.\n-   During code motion, a negative value indicates a reg that has been\n-   made a candidate; in particular -2 means that it is an candidate that\n-   we know is equal to a constant and -1 means that it is an candidate\n-   not known equal to a constant.\n-   After code motion, regs moved have 0 (which is accurate now)\n-   while the failed candidates have the original number of times set.\n-\n-   Therefore, at all times, == 0 indicates an invariant register;\n-   < 0 a conditionally invariant one.  */\n-\n-static varray_type set_in_loop;\n-\n-/* Original value of set_in_loop; same except that this value\n-   is not set negative for a reg whose sets have been made candidates\n-   and not set to 0 for a reg that is moved.  */\n-\n-static varray_type n_times_set;\n-\n-/* Index by register number, 1 indicates that the register\n-   cannot be moved or strength reduced.  */\n-\n-static varray_type may_not_optimize;\n-\n-/* Contains the insn in which a register was used if it was used\n-   exactly once; contains const0_rtx if it was used more than once.  */\n-\n-static varray_type reg_single_usage;\n-\n-/* Nonzero means reg N has already been moved out of one loop.\n-   This reduces the desire to move it out of another.  */\n-\n-static char *moved_once;\n-\n /* Bound on pseudo register number before loop optimization.\n    A pseudo has valid regscan info if its number is < max_reg_before_loop.  */\n unsigned int max_reg_before_loop;\n@@ -202,7 +167,8 @@ static int reg_in_basic_block_p PARAMS ((rtx, rtx));\n static int consec_sets_invariant_p PARAMS ((const struct loop *,\n \t\t\t\t\t    rtx, int, rtx));\n static int labels_in_range_p PARAMS ((rtx, int));\n-static void count_one_set PARAMS ((rtx, rtx, varray_type, rtx *));\n+static void count_one_set PARAMS ((struct loop_regs *, rtx, rtx,\n+\t\t\t\t   varray_type, rtx *));\n \n static void count_loop_regs_set PARAMS ((const struct loop*,\n \t\t\t\t\t varray_type, varray_type,\n@@ -218,9 +184,10 @@ static rtx skip_consec_insns PARAMS ((rtx, int));\n static int libcall_benefit PARAMS ((rtx));\n static void ignore_some_movables PARAMS ((struct movables *));\n static void force_movables PARAMS ((struct movables *));\n-static void combine_movables PARAMS ((struct movables *, int));\n+static void combine_movables PARAMS ((struct movables *, struct loop_regs *));\n static int regs_match_p PARAMS ((rtx, rtx, struct movables *));\n-static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movables *));\n+static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movables *, \n+\t\t\t\t\t struct loop_regs *));\n static void add_label_notes PARAMS ((rtx, rtx));\n static void move_movables PARAMS ((struct loop *loop, struct movables *,\n \t\t\t\t   int, int, int));\n@@ -251,7 +218,7 @@ static int consec_sets_giv PARAMS ((const struct loop *, int, rtx,\n static int check_dbra_loop PARAMS ((struct loop *, int));\n static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n-static void combine_givs PARAMS ((struct iv_class *));\n+static void combine_givs PARAMS ((struct loop_regs *, struct iv_class *));\n struct recombine_givs_stats;\n static int find_life_end PARAMS ((rtx, struct recombine_givs_stats *,\n \t\t\t\t  rtx, rtx));\n@@ -383,6 +350,7 @@ loop_optimize (f, dumpfile, flags)\n   struct loops loops_data;\n   struct loops *loops = &loops_data;\n   struct loop_info *loops_info;\n+  static char *moved_once;\n \n   loop_dump_stream = dumpfile;\n \n@@ -480,6 +448,9 @@ loop_optimize (f, dumpfile, flags)\n   for (i = max_loop_num - 1; i >= 0; i--)\n     {\n       struct loop *loop = &loops->array[i];\n+      struct loop_regs *regs = LOOP_REGS (loop);\n+\n+      regs->moved_once = moved_once;\n \n       if (! loop->invalid && loop->end)\n \tscan_loop (loop, flags);\n@@ -545,13 +516,11 @@ scan_loop (loop, flags)\n      struct loop *loop;\n      int flags;\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   register int i;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  /* Additional information about the current loop being processed\n-     that is used to compute the number of loop iterations for loop\n-     unrolling and doloop optimization.  */\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n   rtx p;\n   /* 1 if we are scanning insns that could be executed zero times.  */\n   int maybe_never = 0;\n@@ -656,40 +625,43 @@ scan_loop (loop, flags)\n       return;\n     }\n \n-  /* Count number of times each reg is set during this loop.\n-     Set VARRAY_CHAR (may_not_optimize, I) if it is not safe to move out\n-     the setting of register I.  Set VARRAY_RTX (reg_single_usage, I).  */\n+  /* Count number of times each reg is set during this loop.  Set\n+     VARRAY_CHAR (regs->may_not_optimize, I) if it is not safe to move\n+     out the setting of register I.  Set VARRAY_RTX\n+     (regs->single_usage, I).  */\n \n   /* Allocate extra space for REGS that might be created by\n      load_mems.  We allocate a little extra slop as well, in the hopes\n      that even after the moving of movables creates some new registers\n      we won't have to reallocate these arrays.  However, we do grow\n      the arrays, if necessary, in load_mems_recount_loop_regs_set.  */\n   nregs = max_reg_num () + loop_info->mems_idx + 16;\n-  VARRAY_INT_INIT (set_in_loop, nregs, \"set_in_loop\");\n-  VARRAY_INT_INIT (n_times_set, nregs, \"n_times_set\");\n-  VARRAY_CHAR_INIT (may_not_optimize, nregs, \"may_not_optimize\");\n-  VARRAY_RTX_INIT (reg_single_usage, nregs, \"reg_single_usage\");\n+  VARRAY_INT_INIT (regs->set_in_loop, nregs, \"set_in_loop\");\n+  VARRAY_INT_INIT (regs->n_times_set, nregs, \"n_times_set\");\n+  VARRAY_CHAR_INIT (regs->may_not_optimize, nregs, \"may_not_optimize\");\n+  VARRAY_RTX_INIT (regs->single_usage, nregs, \"single_usage\");\n \n-  count_loop_regs_set (loop, may_not_optimize, reg_single_usage, \n+  regs->num = nregs;\n+\n+  count_loop_regs_set (loop, regs->may_not_optimize, regs->single_usage, \n \t\t       &insn_count, nregs);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      VARRAY_CHAR (may_not_optimize, i) = 1;\n-      VARRAY_INT (set_in_loop, i) = 1;\n+      VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n+      VARRAY_INT (regs->set_in_loop, i) = 1;\n     }\n \n #ifdef AVOID_CCMODE_COPIES\n   /* Don't try to move insns which set CC registers if we should not\n      create CCmode register copies.  */\n   for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n     if (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-      VARRAY_CHAR (may_not_optimize, i) = 1;\n+      VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n #endif\n \n-  bcopy ((char *) &set_in_loop->data,\n-\t (char *) &n_times_set->data, nregs * sizeof (int));\n+  bcopy ((char *) &regs->set_in_loop->data,\n+\t (char *) &regs->n_times_set->data, nregs * sizeof (int));\n \n   if (loop_dump_stream)\n     {\n@@ -701,7 +673,7 @@ scan_loop (loop, flags)\n     }\n \n   /* Scan through the loop finding insns that are safe to move.\n-     Set set_in_loop negative for the reg being set, so that\n+     Set regs->set_in_loop negative for the reg being set, so that\n      this reg will be considered invariant for subsequent insns.\n      We consider whether subsequent insns use the reg\n      in deciding whether it is worth actually moving.\n@@ -720,7 +692,7 @@ scan_loop (loop, flags)\n       if (GET_CODE (p) == INSN\n \t  && (set = single_set (p))\n \t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && ! VARRAY_CHAR (may_not_optimize, REGNO (SET_DEST (set))))\n+\t  && ! VARRAY_CHAR (regs->may_not_optimize, REGNO (SET_DEST (set))))\n \t{\n \t  int tem1 = 0;\n \t  int tem2 = 0;\n@@ -784,12 +756,13 @@ scan_loop (loop, flags)\n \t  else if ((tem = loop_invariant_p (loop, src))\n \t\t   && (dependencies == 0\n \t\t       || (tem2 = loop_invariant_p (loop, dependencies)) != 0)\n-\t\t   && (VARRAY_INT (set_in_loop,\n+\t\t   && (VARRAY_INT (regs->set_in_loop,\n \t\t\t\t   REGNO (SET_DEST (set))) == 1\n \t\t       || (tem1\n \t\t\t   = consec_sets_invariant_p\n \t\t\t   (loop, SET_DEST (set),\n-\t\t\t    VARRAY_INT (set_in_loop, REGNO (SET_DEST (set))),\n+\t\t\t    VARRAY_INT (regs->set_in_loop,\n+\t\t\t\t\tREGNO (SET_DEST (set))),\n \t\t\t    p)))\n \t\t   /* If the insn can cause a trap (such as divide by zero),\n \t\t      can't move it unless it's guaranteed to be executed\n@@ -817,12 +790,12 @@ scan_loop (loop, flags)\n \t\t SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n \n \t      if (loop_info->has_call\n-\t\t  && VARRAY_RTX (reg_single_usage, regno) != 0\n-\t\t  && VARRAY_RTX (reg_single_usage, regno) != const0_rtx\n+\t\t  && VARRAY_RTX (regs->single_usage, regno) != 0\n+\t\t  && VARRAY_RTX (regs->single_usage, regno) != const0_rtx\n \t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n \t\t  && (REGNO_LAST_UID (regno)\n-\t\t      == INSN_UID (VARRAY_RTX (reg_single_usage, regno)))\n-\t\t  && VARRAY_INT (set_in_loop, regno) == 1\n+\t\t      == INSN_UID (VARRAY_RTX (regs->single_usage, regno)))\n+\t\t  && VARRAY_INT (regs->set_in_loop, regno) == 1\n \t\t  && ! side_effects_p (SET_SRC (set))\n \t\t  && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n \t\t  && (! SMALL_REGISTER_CLASSES\n@@ -833,24 +806,25 @@ scan_loop (loop, flags)\n \t\t     might span a call.  */\n \t\t  && ! modified_between_p (SET_SRC (set), p,\n \t\t\t\t\t   VARRAY_RTX\n-\t\t\t\t\t   (reg_single_usage, regno))\n-\t\t  && no_labels_between_p (p, VARRAY_RTX (reg_single_usage, regno))\n+\t\t\t\t\t   (regs->single_usage, regno))\n+\t\t  && no_labels_between_p (p, VARRAY_RTX (regs->single_usage,\n+\t\t\t\t\t\t\t regno))\n \t\t  && validate_replace_rtx (SET_DEST (set), SET_SRC (set),\n \t\t\t\t\t   VARRAY_RTX\n-\t\t\t\t\t   (reg_single_usage, regno)))\n+\t\t\t\t\t   (regs->single_usage, regno)))\n \t\t{\n \t\t  /* Replace any usage in a REG_EQUAL note.  Must copy the\n \t\t     new source, so that we don't get rtx sharing between the\n \t\t     SET_SOURCE and REG_NOTES of insn p.  */\n-\t\t  REG_NOTES (VARRAY_RTX (reg_single_usage, regno))\n+\t\t  REG_NOTES (VARRAY_RTX (regs->single_usage, regno))\n \t\t    = replace_rtx (REG_NOTES (VARRAY_RTX\n-\t\t\t\t\t      (reg_single_usage, regno)),\n+\t\t\t\t\t      (regs->single_usage, regno)),\n \t\t\t\t   SET_DEST (set), copy_rtx (SET_SRC (set)));\n \n \t\t  PUT_CODE (p, NOTE);\n \t\t  NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (p) = 0;\n-\t\t  VARRAY_INT (set_in_loop, regno) = 0;\n+\t\t  VARRAY_INT (regs->set_in_loop, regno) = 0;\n \t\t  continue;\n \t\t}\n \n@@ -861,7 +835,7 @@ scan_loop (loop, flags)\n \t      m->dependencies = dependencies;\n \t      m->set_dest = SET_DEST (set);\n \t      m->force = 0;\n-\t      m->consec = VARRAY_INT (set_in_loop,\n+\t      m->consec = VARRAY_INT (regs->set_in_loop,\n \t\t\t\t      REGNO (SET_DEST (set))) - 1;\n \t      m->done = 0;\n \t      m->forces = 0;\n@@ -881,10 +855,10 @@ scan_loop (loop, flags)\n \t      m->match = 0;\n \t      m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n \t\t\t     - uid_luid[REGNO_FIRST_UID (regno)]);\n-\t      m->savings = VARRAY_INT (n_times_set, regno);\n+\t      m->savings = VARRAY_INT (regs->n_times_set, regno);\n \t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n-\t      VARRAY_INT (set_in_loop, regno) = move_insn ? -2 : -1;\n+\t      VARRAY_INT (regs->set_in_loop, regno) = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n \t      if (movables->head == 0)\n \t\tmovables->head = m;\n@@ -943,7 +917,7 @@ scan_loop (loop, flags)\n \t\t   && !reg_mentioned_p (SET_DEST (set), SET_SRC (set1)))\n \t    {\n \t      register int regno = REGNO (SET_DEST (set));\n-\t      if (VARRAY_INT (set_in_loop, regno) == 2)\n+\t      if (VARRAY_INT (regs->set_in_loop, regno) == 2)\n \t\t{\n \t\t  register struct movable *m;\n \t\t  m = (struct movable *) alloca (sizeof (struct movable));\n@@ -993,7 +967,7 @@ scan_loop (loop, flags)\n \t\t  m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n \t\t\t\t - uid_luid[REGNO_FIRST_UID (regno)]);\n \t\t  m->savings = 1;\n-\t\t  VARRAY_INT (set_in_loop, regno) = -1;\n+\t\t  VARRAY_INT (regs->set_in_loop, regno) = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n \t\t  if (movables->head == 0)\n \t\t    movables->head = m;\n@@ -1054,10 +1028,10 @@ scan_loop (loop, flags)\n      through the `match' field, and add the priorities of them\n      all together as the priority of the first.  */\n \n-  combine_movables (movables, nregs);\n+  combine_movables (movables, regs);\n \n   /* Now consider each movable insn to decide whether it is worth moving.\n-     Store 0 in set_in_loop for each reg that is moved.\n+     Store 0 in regs->set_in_loop for each reg that is moved.\n \n      Generally this increases code size, so do not move moveables when\n      optimizing for code size.  */\n@@ -1066,10 +1040,11 @@ scan_loop (loop, flags)\n     move_movables (loop, movables, threshold, insn_count, nregs);\n \n   /* Now candidates that still are negative are those not moved.\n-     Change set_in_loop to indicate that those are not actually invariant.  */\n+     Change regs->set_in_loop to indicate that those are not actually\n+     invariant.  */\n   for (i = 0; i < nregs; i++)\n-    if (VARRAY_INT (set_in_loop, i) < 0)\n-      VARRAY_INT (set_in_loop, i) = VARRAY_INT (n_times_set, i);\n+    if (VARRAY_INT (regs->set_in_loop, i) < 0)\n+      VARRAY_INT (regs->set_in_loop, i) = VARRAY_INT (regs->n_times_set, i);\n \n   /* Now that we've moved some things out of the loop, we might be able to\n      hoist even more memory references.  */\n@@ -1101,10 +1076,10 @@ scan_loop (loop, flags)\n \tdelete_insn (update_end);\n     }\n \n-  VARRAY_FREE (reg_single_usage);\n-  VARRAY_FREE (set_in_loop);\n-  VARRAY_FREE (n_times_set);\n-  VARRAY_FREE (may_not_optimize);\n+  VARRAY_FREE (regs->single_usage);\n+  VARRAY_FREE (regs->set_in_loop);\n+  VARRAY_FREE (regs->n_times_set);\n+  VARRAY_FREE (regs->may_not_optimize);\n }\n \f\n /* Add elements to *OUTPUT to record all the pseudo-regs\n@@ -1370,10 +1345,11 @@ force_movables (movables)\n    one register.  */\n \n static void\n-combine_movables (movables, nregs)\n+combine_movables (movables, regs)\n      struct movables *movables;\n-     int nregs;\n+     struct loop_regs *regs;\n {\n+  int nregs = regs->num;\n   register struct movable *m;\n   char *matched_regs = (char *) xmalloc (nregs);\n   enum machine_mode mode;\n@@ -1383,7 +1359,7 @@ combine_movables (movables, nregs)\n   /* Perhaps testing m->consec_sets would be more appropriate here?  */\n \n   for (m = movables->head; m; m = m->next)\n-    if (m->match == 0 && VARRAY_INT (n_times_set, m->regno) == 1\n+    if (m->match == 0 && VARRAY_INT (regs->n_times_set, m->regno) == 1\n \t&& !m->partial)\n       {\n \tregister struct movable *m1;\n@@ -1395,7 +1371,8 @@ combine_movables (movables, nregs)\n \t/* We want later insns to match the first one.  Don't make the first\n \t   one match any later ones.  So start this loop at m->next.  */\n \tfor (m1 = m->next; m1; m1 = m1->next)\n-\t  if (m != m1 && m1->match == 0 && VARRAY_INT (n_times_set, m1->regno) == 1\n+\t  if (m != m1 && m1->match == 0 && VARRAY_INT (regs->n_times_set,\n+\t\t\t\t\t\t       m1->regno) == 1\n \t      /* A reg used outside the loop mustn't be eliminated.  */\n \t      && !m1->global\n \t      /* A reg used for zero-extending mustn't be eliminated.  */\n@@ -1419,7 +1396,7 @@ combine_movables (movables, nregs)\n \t\t   && ((GET_CODE (m1->set_src) == REG\n \t\t\t&& matched_regs[REGNO (m1->set_src)])\n \t\t       || rtx_equal_for_loop_p (m->set_src, m1->set_src,\n-\t\t\t\t\t\tmovables))))\n+\t\t\t\t\t\tmovables, regs))))\n \t      && ((m->dependencies == m1->dependencies)\n \t\t  || rtx_equal_p (m->dependencies, m1->dependencies)))\n \t    {\n@@ -1517,9 +1494,10 @@ regs_match_p (x, y, movables)\n    equivalent constant, consider them equal.  */\n \n static int\n-rtx_equal_for_loop_p (x, y, movables)\n+rtx_equal_for_loop_p (x, y, movables, regs)\n      rtx x, y;\n      struct movables *movables;\n+     struct loop_regs * regs;\n {\n   register int i;\n   register int j;\n@@ -1536,15 +1514,16 @@ rtx_equal_for_loop_p (x, y, movables)\n \n   /* If we have a register and a constant, they may sometimes be\n      equal.  */\n-  if (GET_CODE (x) == REG && VARRAY_INT (set_in_loop, REGNO (x)) == -2\n+  if (GET_CODE (x) == REG && VARRAY_INT (regs->set_in_loop, REGNO (x)) == -2\n       && CONSTANT_P (y))\n     {\n       for (m = movables->head; m; m = m->next)\n \tif (m->move_insn && m->regno == REGNO (x)\n \t    && rtx_equal_p (m->set_src, y))\n \t  return 1;\n     }\n-  else if (GET_CODE (y) == REG && VARRAY_INT (set_in_loop, REGNO (y)) == -2\n+  else if (GET_CODE (y) == REG && VARRAY_INT (regs->set_in_loop, \n+\t\t\t\t\t      REGNO (y)) == -2\n \t   && CONSTANT_P (x))\n     {\n       for (m = movables->head; m; m = m->next)\n@@ -1597,12 +1576,14 @@ rtx_equal_for_loop_p (x, y, movables)\n \n \t  /* And the corresponding elements must match.  */\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (rtx_equal_for_loop_p (XVECEXP (x, i, j), XVECEXP (y, i, j), movables) == 0)\n+\t    if (rtx_equal_for_loop_p (XVECEXP (x, i, j), XVECEXP (y, i, j),\n+\t\t\t\t      movables, regs) == 0)\n \t      return 0;\n \t  break;\n \n \tcase 'e':\n-\t  if (rtx_equal_for_loop_p (XEXP (x, i), XEXP (y, i), movables) == 0)\n+\t  if (rtx_equal_for_loop_p (XEXP (x, i), XEXP (y, i), \n+\t\t\t\t    movables, regs) == 0)\n \t    return 0;\n \t  break;\n \n@@ -1677,6 +1658,7 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n      int insn_count;\n      int nregs;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   rtx new_start = 0;\n   register struct movable *m;\n   register rtx p;\n@@ -1748,7 +1730,7 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"savings %d \", savings);\n \n-\t  if (moved_once[regno] && loop_dump_stream)\n+\t  if (regs->moved_once[regno] && loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"halved since already moved \");\n \n \t  /* An insn MUST be moved if we already moved something else\n@@ -1767,9 +1749,9 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n \t  if (already_moved[regno]\n \t      || flag_move_all_movables\n \t      || (threshold * savings * m->lifetime) >=\n-\t\t (moved_once[regno] ? insn_count * 2 : insn_count)\n+\t\t (regs->moved_once[regno] ? insn_count * 2 : insn_count)\n \t      || (m->forces && m->forces->done\n-\t\t  && VARRAY_INT (n_times_set, m->forces->regno) == 1))\n+\t\t  && VARRAY_INT (regs->n_times_set, m->forces->regno) == 1))\n \t    {\n \t      int count;\n \t      register struct movable *m1;\n@@ -2075,11 +2057,11 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n \t      already_moved[regno] = 1;\n \n \t      /* This reg has been moved out of one loop.  */\n-\t      moved_once[regno] = 1;\n+\t      regs->moved_once[regno] = 1;\n \n \t      /* The reg set here is now invariant.  */\n \t      if (! m->partial)\n-\t\tVARRAY_INT (set_in_loop, regno) = 0;\n+\t\tVARRAY_INT (regs->set_in_loop, regno) = 0;\n \n \t      m->done = 1;\n \n@@ -2143,7 +2125,7 @@ move_movables (loop, movables, threshold, insn_count, nregs)\n \t\t      /* The reg merged here is now invariant,\n \t\t\t if the reg it matches is invariant.  */\n \t\t      if (! m->partial)\n-\t\t\tVARRAY_INT (set_in_loop, m1->regno) = 0;\n+\t\t\tVARRAY_INT (regs->set_in_loop, m1->regno) = 0;\n \t\t    }\n \t    }\n \t  else if (loop_dump_stream)\n@@ -3092,6 +3074,8 @@ note_set_pseudo_multiple_uses (x, y, data)\n      rtx y ATTRIBUTE_UNUSED;\n      void *data;\n {\n+  struct loop_regs *regs = (struct loop_regs *) data;\n+\n   if (x == 0)\n     return;\n \n@@ -3107,8 +3091,8 @@ note_set_pseudo_multiple_uses (x, y, data)\n   /* If we do not have usage information, or if we know the register\n      is used more than once, note that fact for check_dbra_loop.  */\n   if (REGNO (x) >= max_reg_before_loop\n-      || ! VARRAY_RTX (reg_single_usage, REGNO (x))\n-      || VARRAY_RTX (reg_single_usage, REGNO (x)) == const0_rtx)\n+      || ! VARRAY_RTX (regs->single_usage, REGNO (x))\n+      || VARRAY_RTX (regs->single_usage, REGNO (x)) == const0_rtx)\n     *((int *) data) = 1;\n }\n \f\n@@ -3125,6 +3109,7 @@ loop_invariant_p (loop, x)\n      register rtx x;\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   register int i;\n   register enum rtx_code code;\n   register const char *fmt;\n@@ -3175,10 +3160,10 @@ loop_invariant_p (loop, x)\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n \n-      if (VARRAY_INT (set_in_loop, REGNO (x)) < 0)\n+      if (VARRAY_INT (regs->set_in_loop, REGNO (x)) < 0)\n \treturn 2;\n \n-      return VARRAY_INT (set_in_loop, REGNO (x)) == 0;\n+      return VARRAY_INT (regs->set_in_loop, REGNO (x)) == 0;\n \n     case MEM:\n       /* Volatile memory references must be rejected.  Do this before\n@@ -3257,20 +3242,21 @@ consec_sets_invariant_p (loop, reg, n_sets, insn)\n      int n_sets;\n      rtx reg, insn;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   rtx p = insn;\n   unsigned int regno = REGNO (reg);\n   rtx temp;\n   /* Number of sets we have to insist on finding after INSN.  */\n   int count = n_sets - 1;\n-  int old = VARRAY_INT (set_in_loop, regno);\n+  int old = VARRAY_INT (regs->set_in_loop, regno);\n   int value = 0;\n   int this;\n \n   /* If N_SETS hit the limit, we can't rely on its value.  */\n   if (n_sets == 127)\n     return 0;\n \n-  VARRAY_INT (set_in_loop, regno) = 0;\n+  VARRAY_INT (regs->set_in_loop, regno) = 0;\n \n   while (count > 0)\n     {\n@@ -3309,12 +3295,12 @@ consec_sets_invariant_p (loop, reg, n_sets, insn)\n \tcount--;\n       else if (code != NOTE)\n \t{\n-\t  VARRAY_INT (set_in_loop, regno) = old;\n+\t  VARRAY_INT (regs->set_in_loop, regno) = old;\n \t  return 0;\n \t}\n     }\n \n-  VARRAY_INT (set_in_loop, regno) = old;\n+  VARRAY_INT (regs->set_in_loop, regno) = old;\n   /* If loop_invariant_p ever returned 2, we return 2.  */\n   return 1 + (value & 2);\n }\n@@ -3397,7 +3383,8 @@ find_single_use_in_loop (insn, x, usage)\n    MAY_NOT_MOVE and LAST_SET for any register set in X.  */\n \n static void\n-count_one_set (insn, x, may_not_move, last_set)\n+count_one_set (regs, insn, x, may_not_move, last_set)\n+     struct loop_regs *regs;\n      rtx insn, x;\n      varray_type may_not_move;\n      rtx *last_set;\n@@ -3422,7 +3409,7 @@ count_one_set (insn, x, may_not_move, last_set)\n \t     in current basic block, and it was set before,\n \t     it must be set in two basic blocks, so it cannot\n \t     be moved out of the loop.  */\n-\t  if (VARRAY_INT (set_in_loop, regno) > 0\n+\t  if (VARRAY_INT (regs->set_in_loop, regno) > 0\n \t      && last_set[regno] == 0)\n \t    VARRAY_CHAR (may_not_move, regno) = 1;\n \t  /* If this is not first setting in current basic block,\n@@ -3431,16 +3418,16 @@ count_one_set (insn, x, may_not_move, last_set)\n \t  if (last_set[regno] != 0\n \t      && reg_used_between_p (dest, last_set[regno], insn))\n \t    VARRAY_CHAR (may_not_move, regno) = 1;\n-\t  if (VARRAY_INT (set_in_loop, regno) < 127)\n-\t    ++VARRAY_INT (set_in_loop, regno);\n+\t  if (VARRAY_INT (regs->set_in_loop, regno) < 127)\n+\t    ++VARRAY_INT (regs->set_in_loop, regno);\n \t  last_set[regno] = insn;\n \t}\n     }\n }\n \n-/* Increment SET_IN_LOOP at the index of each register\n+/* Increment REGS->SET_IN_LOOP at the index of each register\n    that is modified by an insn between FROM and TO.\n-   If the value of an element of SET_IN_LOOP becomes 127 or more,\n+   If the value of an element of REGS->SET_IN_LOOP becomes 127 or more,\n    stop incrementing it, to avoid overflow.\n \n    Store in SINGLE_USAGE[I] the single insn in which register I is\n@@ -3462,6 +3449,7 @@ count_loop_regs_set (loop, may_not_move, single_usage, count_ptr, nregs)\n      int *count_ptr;\n      int nregs;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   register rtx *last_set = (rtx *) xcalloc (nregs, sizeof (rtx));\n   register rtx insn;\n   register int count = 0;\n@@ -3482,12 +3470,12 @@ count_loop_regs_set (loop, may_not_move, single_usage, count_ptr, nregs)\n \n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    count_one_set (insn, PATTERN (insn), may_not_move, last_set);\n+\t    count_one_set (regs, insn, PATTERN (insn), may_not_move, last_set);\n \t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t    {\n \t      register int i;\n \t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t\tcount_one_set (insn, XVECEXP (PATTERN (insn), 0, i),\n+\t\tcount_one_set (regs, insn, XVECEXP (PATTERN (insn), 0, i),\n \t\t\t       may_not_move, last_set);\n \t    }\n \t}\n@@ -3758,22 +3746,24 @@ for_each_insn_in_loop (loop, fncall)\n \f\n /* Perform strength reduction and induction variable elimination.\n \n-   Pseudo registers created during this function will be beyond the last\n-   valid index in several tables including n_times_set and regno_last_uid.\n-   This does not cause a problem here, because the added registers cannot be\n-   givs outside of their loop, and hence will never be reconsidered.\n-   But scan_loop must check regnos to make sure they are in bounds.   */\n+   Pseudo registers created during this function will be beyond the\n+   last valid index in several tables including regs->n_times_set and\n+   regno_last_uid.  This does not cause a problem here, because the\n+   added registers cannot be givs outside of their loop, and hence\n+   will never be reconsidered.  But scan_loop must check regnos to\n+   make sure they are in bounds.  */\n \n static void\n strength_reduce (loop, insn_count, flags)\n      struct loop *loop;\n      int insn_count;\n      int flags;\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   rtx p;\n   /* Temporary list pointers for traversing loop_iv_list.  */\n   struct iv_class *bl, **backbl;\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n      since in that case saving an insn makes more difference\n@@ -3816,13 +3806,13 @@ strength_reduce (loop, insn_count, flags)\n   for_each_insn_in_loop (loop, check_insn_for_bivs);\n \n   /* Scan loop_iv_list to remove all regs that proved not to be bivs.\n-     Make a sanity check against n_times_set.  */\n+     Make a sanity check against regs->n_times_set.  */\n   for (backbl = &loop_iv_list, bl = *backbl; bl; bl = bl->next)\n     {\n       if (REG_IV_TYPE (bl->regno) != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n \t  /* Make sure it is not recognized as a basic induction var: */\n-\t  || VARRAY_INT (n_times_set, bl->regno) != bl->biv_count\n+\t  || VARRAY_INT (regs->n_times_set, bl->regno) != bl->biv_count\n \t  /* If never incremented, it is invariant that we decided not to\n \t     move.  So leave it alone.  */\n \t  || ! bl->incremented)\n@@ -4149,13 +4139,13 @@ strength_reduce (loop, insn_count, flags)\n \t\t have been allocated with some slop space, so we may not\n \t\t actually need to reallocate them.  If we do, the following\n \t\t if statement will be executed just once in this loop.  */\n-\t      if ((unsigned) max_reg_num () > n_times_set->num_elements)\n+\t      if ((unsigned) max_reg_num () > regs->n_times_set->num_elements)\n \t\t{\n \t\t  /* Grow all the remaining arrays.  */\n-\t\t  VARRAY_GROW (set_in_loop, nregs);\n-\t\t  VARRAY_GROW (n_times_set, nregs);\n-\t\t  VARRAY_GROW (may_not_optimize, nregs);\n-\t\t  VARRAY_GROW (reg_single_usage, nregs);\n+\t\t  VARRAY_GROW (regs->set_in_loop, nregs);\n+\t\t  VARRAY_GROW (regs->n_times_set, nregs);\n+\t\t  VARRAY_GROW (regs->may_not_optimize, nregs);\n+\t\t  VARRAY_GROW (regs->single_usage, nregs);\n \t\t}\n \n \t      /* Some bivs are incremented with a multi-insn sequence.\n@@ -4231,11 +4221,11 @@ strength_reduce (loop, insn_count, flags)\n \n \t      old_regno = REGNO (old_reg);\n \t      new_regno = REGNO (dest_reg);\n-\t      VARRAY_INT (set_in_loop, old_regno)--;\n-\t      VARRAY_INT (set_in_loop, new_regno) = 1;\n-\t      VARRAY_INT (n_times_set, old_regno)--;\n-\t      VARRAY_INT (n_times_set, new_regno) = 1;\n-\t      VARRAY_CHAR (may_not_optimize, new_regno) = 0;\n+\t      VARRAY_INT (regs->set_in_loop, old_regno)--;\n+\t      VARRAY_INT (regs->set_in_loop, new_regno) = 1;\n+\t      VARRAY_INT (regs->n_times_set, old_regno)--;\n+\t      VARRAY_INT (regs->n_times_set, new_regno) = 1;\n+\t      VARRAY_CHAR (regs->may_not_optimize, new_regno) = 0;\n \n \t      REG_IV_TYPE (new_regno) = GENERAL_INDUCT;\n \t      REG_IV_INFO (new_regno) = v;\n@@ -4395,7 +4385,7 @@ strength_reduce (loop, insn_count, flags)\n       check_ext_dependant_givs (bl, loop_info);\n \n       /* Combine all giv's for this iv_class.  */\n-      combine_givs (bl);\n+      combine_givs (regs, bl);\n \n       /* This will be true at the end, if all givs which depend on this\n \t biv have been strength reduced.\n@@ -5030,12 +5020,13 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n      int not_every_iteration;\n      int maybe_multiple;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   rtx set;\n   /* Look for a general induction variable in a register.  */\n   if (GET_CODE (p) == INSN\n       && (set = single_set (p))\n       && GET_CODE (SET_DEST (set)) == REG\n-      && ! VARRAY_CHAR (may_not_optimize, REGNO (SET_DEST (set))))\n+      && ! VARRAY_CHAR (regs->may_not_optimize, REGNO (SET_DEST (set))))\n     {\n       rtx src_reg;\n       rtx dest_reg;\n@@ -5064,7 +5055,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \t  /* Don't recognize a BASIC_INDUCT_VAR here.  */\n \t  && dest_reg != src_reg\n \t  /* This must be the only place where the register is set.  */\n-\t  && (VARRAY_INT (n_times_set, REGNO (dest_reg)) == 1\n+\t  && (VARRAY_INT (regs->n_times_set, REGNO (dest_reg)) == 1\n \t      /* or all sets must be consecutive and make a giv.  */\n \t      || (benefit = consec_sets_giv (loop, benefit, p,\n \t\t\t\t\t     src_reg, dest_reg,\n@@ -5079,7 +5070,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \t    benefit += libcall_benefit (p);\n \n \t  /* Skip the consecutive insns, if there are any.  */\n-\t  if (VARRAY_INT (n_times_set, REGNO (dest_reg)) != 1)\n+\t  if (VARRAY_INT (regs->n_times_set, REGNO (dest_reg)) != 1)\n \t    p = last_consec_insn;\n \n \t  record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,\n@@ -6193,6 +6184,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n      rtx *ext_val;\n      int *benefit;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   enum machine_mode mode = GET_MODE (x);\n   rtx arg0, arg1;\n   rtx tem;\n@@ -6480,7 +6472,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t       less harmful than reducing many givs that are not really\n \t       beneficial.  */\n \t    {\n-\t      rtx single_use = VARRAY_RTX (reg_single_usage, REGNO (x));\n+\t      rtx single_use = VARRAY_RTX (regs->single_usage, REGNO (x));\n \t      if (single_use && single_use != const0_rtx)\n \t\t*benefit += v->benefit;\n \t    }\n@@ -6687,6 +6679,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n      rtx *ext_val;\n      rtx *last_consec_insn;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   int count;\n   enum rtx_code code;\n   int benefit;\n@@ -6713,7 +6706,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n   REG_IV_TYPE (REGNO (dest_reg)) = GENERAL_INDUCT;\n   REG_IV_INFO (REGNO (dest_reg)) = v;\n \n-  count = VARRAY_INT (n_times_set, REGNO (dest_reg)) - 1;\n+  count = VARRAY_INT (regs->n_times_set, REGNO (dest_reg)) - 1;\n \n   while (count > 0)\n     {\n@@ -7227,7 +7220,8 @@ cmp_combine_givs_stats (xp, yp)\n    giv.  Also, update BENEFIT and related fields for cost/benefit analysis.  */\n \n static void\n-combine_givs (bl)\n+combine_givs (regs, bl)\n+     struct loop_regs *regs;\n      struct iv_class *bl;\n {\n   /* Additional benefit to add for being combined multiple times.  */\n@@ -7269,7 +7263,8 @@ combine_givs (bl)\n \t DEST_ADDR targets on hosts with reg+reg addressing, though it can\n \t be seen elsewhere as well.  */\n       if (g1->giv_type == DEST_REG\n-\t  && (single_use = VARRAY_RTX (reg_single_usage, REGNO (g1->dest_reg)))\n+\t  && (single_use = VARRAY_RTX (regs->single_usage, \n+\t\t\t\t       REGNO (g1->dest_reg)))\n \t  && single_use != const0_rtx)\n \tcontinue;\n \n@@ -7512,6 +7507,7 @@ recombine_givs (loop, bl, unroll_p)\n      struct iv_class *bl;\n      int unroll_p;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   struct induction *v, **giv_array, *last_giv;\n   struct recombine_givs_stats *stats;\n   int giv_count;\n@@ -7639,7 +7635,7 @@ recombine_givs (loop, bl, unroll_p)\n \t  else\n \t    {\n \t      int regno = REGNO (v->dest_reg);\n-\t      int count = VARRAY_INT (n_times_set, regno) - 1;\n+\t      int count = VARRAY_INT (regs->n_times_set, regno) - 1;\n \t      rtx p = v->insn;\n \n \t      /* Find the first insn that sets the giv, so that we can verify\n@@ -7995,6 +7991,8 @@ check_dbra_loop (loop, insn_count)\n      struct loop *loop;\n      int insn_count;\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   struct iv_class *bl;\n   rtx reg;\n   rtx jump_label;\n@@ -8009,7 +8007,6 @@ check_dbra_loop (loop, insn_count)\n   int compare_and_branch;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n \n   /* If last insn is a conditional branch, and the insn before tests a\n      register value, try to optimize it.  Otherwise, we can't do anything.  */\n@@ -8167,10 +8164,9 @@ check_dbra_loop (loop, insn_count)\n \t\t       that has more than one usage, then the biv has uses\n \t\t       other than counting since it's used to derive a value\n \t\t       that is used more than one time.  */\n-\t\t    int note_set_pseudo_multiple_uses_retval = 0;\n \t\t    note_stores (PATTERN (p), note_set_pseudo_multiple_uses,\n-\t\t\t\t &note_set_pseudo_multiple_uses_retval);\n-\t\t    if (note_set_pseudo_multiple_uses_retval)\n+\t\t\t\t regs);\n+\t\t    if (regs->multiple_uses)\n \t\t      {\n \t\t\tno_use_except_counting = 0;\n \t\t\tbreak;\n@@ -9581,20 +9577,21 @@ insert_loop_mem (mem, data)\n   return 0;\n }\n \n-/* Like load_mems, but also ensures that SET_IN_LOOP,\n-   MAY_NOT_OPTIMIZE, REG_SINGLE_USAGE, and INSN_COUNT have the correct\n+/* Like load_mems, but also ensures that REGS->SET_IN_LOOP,\n+   REGS->MAY_NOT_OPTIMIZE, REGS->SINGLE_USAGE, and INSN_COUNT have the correct\n    values after load_mems.  */\n \n static void\n load_mems_and_recount_loop_regs_set (loop, insn_count)\n      const struct loop *loop;\n      int *insn_count;\n {\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   int nregs = max_reg_num ();\n \n   load_mems (loop);\n \n-  /* Recalculate set_in_loop and friends since load_mems may have\n+  /* Recalculate regs->set_in_loop and friends since load_mems may have\n      created new registers.  */\n   if (max_reg_num () > nregs)\n     {\n@@ -9604,39 +9601,40 @@ load_mems_and_recount_loop_regs_set (loop, insn_count)\n       old_nregs = nregs;\n       nregs = max_reg_num ();\n \n-      if ((unsigned) nregs > set_in_loop->num_elements)\n+      if ((unsigned) nregs > regs->set_in_loop->num_elements)\n \t{\n \t  /* Grow all the arrays.  */\n-\t  VARRAY_GROW (set_in_loop, nregs);\n-\t  VARRAY_GROW (n_times_set, nregs);\n-\t  VARRAY_GROW (may_not_optimize, nregs);\n-\t  VARRAY_GROW (reg_single_usage, nregs);\n+\t  VARRAY_GROW (regs->set_in_loop, nregs);\n+\t  VARRAY_GROW (regs->n_times_set, nregs);\n+\t  VARRAY_GROW (regs->may_not_optimize, nregs);\n+\t  VARRAY_GROW (regs->single_usage, nregs);\n \t}\n       /* Clear the arrays */\n-      bzero ((char *) &set_in_loop->data, nregs * sizeof (int));\n-      bzero ((char *) &may_not_optimize->data, nregs * sizeof (char));\n-      bzero ((char *) &reg_single_usage->data, nregs * sizeof (rtx));\n+      bzero ((char *) &regs->set_in_loop->data, nregs * sizeof (int));\n+      bzero ((char *) &regs->may_not_optimize->data, nregs * sizeof (char));\n+      bzero ((char *) &regs->single_usage->data, nregs * sizeof (rtx));\n \n-      count_loop_regs_set (loop, may_not_optimize, reg_single_usage,\n+      count_loop_regs_set (loop, regs->may_not_optimize, \n+\t\t\t   regs->single_usage,\n \t\t\t   insn_count, nregs);\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t{\n-\t  VARRAY_CHAR (may_not_optimize, i) = 1;\n-\t  VARRAY_INT (set_in_loop, i) = 1;\n+\t  VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n+\t  VARRAY_INT (regs->set_in_loop, i) = 1;\n \t}\n \n #ifdef AVOID_CCMODE_COPIES\n       /* Don't try to move insns which set CC registers if we should not\n \t create CCmode register copies.  */\n       for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n \tif (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-\t  VARRAY_CHAR (may_not_optimize, i) = 1;\n+\t  VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n #endif\n \n-      /* Set n_times_set for the new registers.  */\n-      bcopy ((char *) (&set_in_loop->data.i[0] + old_nregs),\n-\t     (char *) (&n_times_set->data.i[0] + old_nregs),\n+      /* Set regs->n_times_set for the new registers.  */\n+      bcopy ((char *) (&regs->set_in_loop->data.i[0] + old_nregs),\n+\t     (char *) (&regs->n_times_set->data.i[0] + old_nregs),\n \t     (nregs - old_nregs) * sizeof (int));\n     }\n }\n@@ -9648,6 +9646,7 @@ load_mems (loop)\n      const struct loop *loop;\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_regs *regs = LOOP_REGS (loop);\n   int maybe_never = 0;\n   int i;\n   rtx p;\n@@ -9808,7 +9807,8 @@ load_mems (loop)\n \t\t  && GET_CODE (SET_DEST (set)) == REG\n \t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t\t  && REGNO (SET_DEST (set)) < last_max_reg\n-\t\t  && VARRAY_INT (n_times_set, REGNO (SET_DEST (set))) == 1\n+\t\t  && VARRAY_INT (regs->n_times_set, \n+\t\t\t\t REGNO (SET_DEST (set))) == 1\n \t\t  && rtx_equal_p (SET_SRC (set), mem))\n \t\tSET_REGNO_REG_SET (&load_copies, REGNO (SET_DEST (set)));\n \n@@ -9822,7 +9822,7 @@ load_mems (loop)\n  \t\t  && GET_CODE (SET_SRC (set)) == REG\n  \t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n  \t\t  && REGNO (SET_SRC (set)) < last_max_reg\n- \t\t  && VARRAY_INT (n_times_set, REGNO (SET_SRC (set))) == 1\n+ \t\t  && VARRAY_INT (regs->n_times_set, REGNO (SET_SRC (set))) == 1\n  \t\t  && rtx_equal_p (SET_DEST (set), mem))\n  \t\tSET_REGNO_REG_SET (&store_copies, REGNO (SET_SRC (set)));\n  \t      "}, {"sha": "f73e2257bb8066ce59c71812ca6d83e5d350703e", "filename": "gcc/loop.h", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ecd860b2879a4529b01208eab3484be9383c7d4/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ecd860b2879a4529b01208eab3484be9383c7d4/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=1ecd860b2879a4529b01208eab3484be9383c7d4", "patch": "@@ -29,6 +29,9 @@ Boston, MA 02111-1307, USA.  */\n /* Get the loop info pointer of a loop.  */\n #define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux) \n \n+/* Get a pointer to the loop registers structure.  */\n+#define LOOP_REGS(LOOP) (&LOOP_INFO (loop)->regs)\n+\n /* Get the luid of an insn.  Catch the error of trying to reference the LUID\n    of an insn added during loop, since these don't have LUIDs.  */\n \n@@ -173,8 +176,46 @@ typedef struct loop_mem_info\n } loop_mem_info;\n \n \n-/* Information required to calculate the number of loop iterations. \n-   This is set by loop_iterations.  */\n+\n+struct loop_regs\n+{\n+  int num;\n+\n+  /* Indexed by register number, contains the number of times the reg\n+     is set during the loop being scanned.\n+     During code motion, a negative value indicates a reg that has been\n+     made a candidate; in particular -2 means that it is an candidate that\n+     we know is equal to a constant and -1 means that it is an candidate\n+     not known equal to a constant.\n+     After code motion, regs moved have 0 (which is accurate now)\n+     while the failed candidates have the original number of times set.\n+     \n+     Therefore, at all times, == 0 indicates an invariant register;\n+     < 0 a conditionally invariant one.  */\n+  varray_type set_in_loop;\n+\n+  /* Original value of set_in_loop; same except that this value\n+     is not set negative for a reg whose sets have been made candidates\n+     and not set to 0 for a reg that is moved.  */\n+  varray_type n_times_set;\n+  \n+  /* Index by register number, 1 indicates that the register\n+     cannot be moved or strength reduced.  */\n+  varray_type may_not_optimize;\n+  \n+  /* Contains the insn in which a register was used if it was used\n+     exactly once; contains const0_rtx if it was used more than once.  */\n+  varray_type single_usage;\n+  \n+  /* Nonzero means reg N has already been moved out of one loop.\n+     This reduces the desire to move it out of another.  */\n+  char *moved_once;\n+\n+  int multiple_uses;\n+};\n+\n+\n+/* Information pertaining to a loop.  */\n \n struct loop_info\n {\n@@ -242,6 +283,8 @@ struct loop_info\n   int num_mem_sets;\n   /* The insn where the first of these was found.  */\n   rtx first_loop_store_insn;\n+  /* The registers used the in loop.  */\n+  struct loop_regs regs;\n };\n \n /* Definitions used by the basic induction variable discovery code.  */"}]}