{"sha": "5c4dc10837d7f66311a5da622e054ea168483a5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM0ZGMxMDgzN2Q3ZjY2MzExYTVkYTYyMmUwNTRlYTE2ODQ4M2E1Yw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-08-12T21:14:23Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-08-12T21:14:23Z"}, "message": "Initial revision\n\nFrom-SVN: r85897", "tree": {"sha": "22c381bc68a21b73cb62dd6a0157a354fcb699a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22c381bc68a21b73cb62dd6a0157a354fcb699a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c4dc10837d7f66311a5da622e054ea168483a5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c4dc10837d7f66311a5da622e054ea168483a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c4dc10837d7f66311a5da622e054ea168483a5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c4dc10837d7f66311a5da622e054ea168483a5c/comments", "author": null, "committer": null, "parents": [{"sha": "47bedfb079ef53e4d072174d704f99dc96e6404d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47bedfb079ef53e4d072174d704f99dc96e6404d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47bedfb079ef53e4d072174d704f99dc96e6404d"}], "stats": {"total": 287, "additions": 287, "deletions": 0}, "files": [{"sha": "a7582af620b821f7d7fca00e9c875a2a7e1c7a9b", "filename": "boehm-gc/NT_STATIC_THREADS_MAKEFILE", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c4dc10837d7f66311a5da622e054ea168483a5c/boehm-gc%2FNT_STATIC_THREADS_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c4dc10837d7f66311a5da622e054ea168483a5c/boehm-gc%2FNT_STATIC_THREADS_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_STATIC_THREADS_MAKEFILE?ref=5c4dc10837d7f66311a5da622e054ea168483a5c", "patch": "@@ -0,0 +1,60 @@\n+# Makefile for Windows NT.  Assumes Microsoft compiler.\n+# DLLs are included in the root set under NT, but not under win32S.\n+# Use \"nmake nodebug=1 all\" for optimized versions of library, gctest and editor.\n+\n+MY_CPU=X86\n+CPU=$(MY_CPU)\n+!include <ntwin32.mak>\n+\n+OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj typd_mlc.obj ptr_chck.obj gc_cpp.obj mallocx.obj win32_threads.obj\n+\n+all: gctest.exe cord\\de.exe test_cpp.exe\n+\n+.c.obj:\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ -DGC_NOT_DLL -DGC_WIN32_THREADS $*.c /Fo$*.obj\n+\n+.cpp.obj:\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -DGC_NOT_DLL $*.CPP -DGC_WIN32_THREADS /Fo$*.obj\n+\n+$(OBJS) tests\\test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h include\\private\\gc_locks.h include\\private\\gc_pmark.h include\\gc_mark.h\n+\n+gc.lib: $(OBJS)\n+\tlib /MACHINE:i386 /out:gc.lib $(OBJS)\n+# The original NT SDK used lib32 instead of lib\n+\n+gctest.exe: tests\\test.obj gc.lib\n+#\tThe following works for win32 debugging.  For win32s debugging use debugtype:coff\n+#\tand add mapsympe line.\n+#  This produces a \"GUI\" applications that opens no windows and writes to the log file\n+#  \"gc.log\".  This is done to make the result runnable under win32s.\n+\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:131072 -out:$*.exe tests\\test.obj $(guilibs) gc.lib\n+#\tmapsympe -n -o gctest.sym gctest.exe\n+\n+cord\\de_win.rbj: cord\\de_win.res\n+\tcvtres /MACHINE:$(MY_CPU) /OUT:cord\\de_win.rbj cord\\de_win.res\n+\n+cord\\de.obj cord\\de_win.obj: include\\cord.h include\\private\\cord_pos.h cord\\de_win.h cord\\de_cmds.h\n+\n+cord\\de_win.res: cord\\de_win.rc cord\\de_win.h cord\\de_cmds.h\n+\t$(rc) $(rcvars) -r -fo cord\\de_win.res $(cvars) cord\\de_win.rc\n+\n+# Cord/de is a real win32 gui application.\n+cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib\n+\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:cord\\de.exe  cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib $(guilibs)\n+\n+gc_cpp.obj: include\\gc_cpp.h include\\gc.h\n+\n+gc_cpp.cpp: gc_cpp.cc\n+\tcopy gc_cpp.cc gc_cpp.cpp\n+\n+test_cpp.cpp: tests\\test_cpp.cc\n+\tcopy tests\\test_cpp.cc test_cpp.cpp\n+\n+# This generates the C++ test executable.  The executable expects\n+# a single numeric argument, which is the number of iterations.\n+# The output appears in the file \"gc.log\".\n+test_cpp.exe: test_cpp.obj include\\gc_cpp.h include\\gc.h gc.lib\n+\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:test_cpp.exe test_cpp.obj gc.lib $(guilibs)\n+\n+\n+"}, {"sha": "0bc0953ef032d608cbaef5d0ac13f54313f1ddbc", "filename": "boehm-gc/doc/simple_example.html", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c4dc10837d7f66311a5da622e054ea168483a5c/boehm-gc%2Fdoc%2Fsimple_example.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c4dc10837d7f66311a5da622e054ea168483a5c/boehm-gc%2Fdoc%2Fsimple_example.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fsimple_example.html?ref=5c4dc10837d7f66311a5da622e054ea168483a5c", "patch": "@@ -0,0 +1,202 @@\n+<HTML>\n+<HEAD>\n+<TITLE>Using the Garbage Collector: A simple example</title>\n+</head>\n+<BODY>\n+<H1>Using the Garbage Collector: A simple example</h1>\n+The following consists of step-by-step instructions for building and\n+using the collector.  We'll assume a Linux/gcc platform and\n+a single-threaded application.  <FONT COLOR=green>The green\n+text contains information about other platforms or scenarios.\n+It can be skipped, especially on first reading</font>.\n+<H2>Building the collector</h2>\n+If you haven't already so, unpack the collector and enter\n+the newly created directory with\n+<PRE>\n+tar xvfz gc<version>.tar.gz\n+cd gc<version>\n+</pre>\n+<P>\n+You can configure, build, and install the collector in a private\n+directory, say /home/xyz/gc, with the following commands:\n+<PRE>\n+./configure --prefix=/home/xyz/gc --disable-threads\n+make\n+make check\n+make install\n+</pre>\n+Here the \"<TT>make check</tt>\" command is optional, but highly recommended.\n+It runs a basic correctness test which usually takes well under a minute.\n+<FONT COLOR=green>\n+<H3>Other platforms</h3>\n+On non-Unix, non-Linux platforms, the collector is usually built by copying\n+the appropriate makefile (see the platform-specific README in doc/README.xxx\n+in the distribution) to the file \"Makefile\" (overwriting the copy of\n+Makefile.direct that was originally there), and then typing \"make\"\n+(or \"nmake\" or ...).  This builds the library in the source tree.  You may\n+want to move it and the files in the include directory to a more convenient\n+place.\n+<P>\n+If you use a makefile that does not require running a configure script,\n+you should first look at the makefile, and adjust any options that are\n+documented there.\n+<P>\n+If your platform provides a \"make\" utility, that is generally preferred\n+to platform- and compiler- dependent \"project\" files.  (At least that is the\n+strong preference of the would-be maintainer of those project files.)\n+<H3>Threads</h3>\n+If you need thread support, configure the collector with\n+<PRE>\n+--enable-threads=posix --enable-thread-local-alloc --enable-parallel-mark\n+</pre>\n+instead of\n+<TT>--disable-threads</tt>\n+If your target is a real old-fashioned uniprocessor (no \"hyperthreading\",\n+etc.) you will want to omit <TT>--enable-parallel-mark</tt>.\n+<H3>C++</h3>\n+You will need to include the C++ support, which unfortunately tends to\n+be among the least portable parts of the collector, since it seems\n+to rely on some corner cases of the language.  On Linux, it\n+suffices to add <TT>--enable-cplusplus</tt> to the configure options.\n+</font>\n+<H2>Writing the program</h2>\n+You will need a\n+<PRE>\n+#include \"gc.h\"\n+</pre>\n+at the beginning of every file that allocates memory through the\n+garbage collector.  Call <TT>GC_MALLOC</tt> wherever you would\n+have call <TT>malloc</tt>.  This initializes memory to zero like\n+<TT>calloc</tt>; there is no need to explicitly clear the\n+result.\n+<P>\n+If you know that an object will not contain pointers to the\n+garbage-collected heap, and you don't need it to be initialized,\n+call <TT>GC_MALLOC_ATOMIC</tt> instead.\n+<P>\n+A function <TT>GC_FREE</tt> is provided but need not be called.\n+For very small objects, your program will probably perform better if\n+you do not call it, and let the collector do its job.\n+<P>\n+A <TT>GC_REALLOC</tt> function behaves like the C library <TT>realloc</tt>.\n+It allocates uninitialized pointer-free memory if the original\n+object was allocated that way.\n+<P>\n+The following program <TT>loop.c</tt> is a trivial example:\n+<PRE>\n+#include \"gc.h\"\n+#include &lt;assert.h&gt;\n+#include &lt;stdio.h&gt;\n+\n+int main()\n+{\n+  int i;\n+\n+  GC_INIT();\t/* Optional on Linux/X86; see below.  */\n+  for (i = 0; i < 10000000; ++i)\n+   {\n+     int **p = (int **) GC_MALLOC(sizeof(int *));\n+     int *q = (int *) GC_MALLOC_ATOMIC(sizeof(int));\n+     assert(*p == 0);\n+     *p = (int *) GC_REALLOC(q, 2 * sizeof(int));\n+     if (i % 100000 == 0)\n+       printf(\"Heap size = %d\\n\", GC_get_heap_size());\n+   }\n+  return 0;\n+}\n+</pre>\n+<FONT COLOR=green>\n+<H3>Interaction with the system malloc</h3>\n+It is usually best not to mix garbage-collected allocation with the system\n+<TT>malloc-free</tt>.  If you do, you need to be careful not to store\n+pointers to the garbage-collected heap in memory allocated with the system\n+<TT>malloc</tt>.\n+<H3>Other Platforms</h3>\n+On some other platforms it is necessary to call <TT>GC_INIT()</tt> from the main program,\n+which is presumed to be part of the main executable, not a dynamic library.\n+This can never hurt, and is thus generally good practice.\n+\n+<H3>Threads</h3>\n+For a multithreaded program some more rules apply:\n+<UL>\n+<LI>\n+Files that either allocate through the GC <I>or make thread-related calls</i>\n+should first define the macro <TT>GC_THREADS</tt>, and then\n+include <TT>\"gc.h\"</tt>.  On some platforms this will redefine some\n+threads primitives, e.g. to let the collector keep track of thread creation.\n+<LI>\n+To take advantage of fast thread-local allocation, use the following instead\n+of including <TT>gc.h</tt>:\n+<PRE>\n+#define GC_REDIRECT_TO_LOCAL\n+#include \"gc_local_alloc.h\"\n+</pre>\n+This will cause GC_MALLOC and GC_MALLOC_ATOMIC to keep per-thread allocation\n+caches, and greatly reduce the number of lock acquisitions during allocation.\n+</ul>\n+\n+<H3>C++</h3>\n+In the case of C++, you need to be especially careful not to store pointers\n+to the garbage-collected heap in areas that are not traced by the collector.\n+The collector includes some <A HREF=\"gcinterface.html\">alternate interfaces</a>\n+to make that easier.\n+\n+<H3>Debugging</h3>\n+Additional debug checks can be performed by defining <TT>GC_DEBUG</tt> before\n+including <TT>gc.h</tt>.  Additional options are available if the collector\n+is also built with <TT>--enable-full_debug</tt> and all allocations are\n+performed with <TT>GC_DEBUG</tt> defined.\n+\n+<H3>What if I can't rewrite/recompile my program?</h3>\n+You may be able to build the collector with <TT>--enable-redirect-malloc</tt>\n+and set the <TT>LD_PRELOAD</tt> environment variable to point to the resulting\n+library, thus replacing the standard <TT>malloc</tt> with its garbage-collected\n+counterpart.  This is rather platform dependent.  See the\n+<A HREF=\"leak.html\">leak detection documentation</a> for some more details.\n+\n+</font>\n+\n+<H2>Compiling and linking</h2>\n+\n+The above application <TT>loop.c</tt> test program can be compiled and linked\n+with\n+\n+<PRE>\n+cc -I/home/xyz/gc/include loop.c /home/xyz/gc/lib/libgc.a -o loop\n+</pre>\n+\n+The <TT>-I</tt> option directs the compiler to the right include\n+directory.  In this case, we list the static library\n+directly on the compile line; the dynamic library could have been\n+used instead, provided we arranged for the dynamic loader to find\n+it, e.g. by setting <TT>LD_LIBRARY_PATH</tt>.\n+\n+<FONT COLOR=green>\n+\n+<H3>Threads</h3>\n+\n+On pthread platforms, you will of course also have to link with\n+<TT>-lpthread</tt>,\n+and compile with any thread-safety options required by your compiler.\n+On some platforms, you may also need to link with <TT>-ldl</tt>\n+or <TT>-lrt</tt>.\n+Looking at threadlibs.c in the GC build directory\n+should give you the appropriate\n+list if a plain <TT>-lpthread</tt> doesn't work.\n+\n+</font>\n+\n+<H2>Running the executable</h2>\n+\n+The executable can of course be run normally, e.g. by typing\n+\n+<PRE>\n+./loop\n+</pre>\n+\n+The operation of the collector is affected by a number of environment variables.\n+For example, setting <TT>GC_PRINT_STATS</tt> produces some\n+GC statistics on stdout.\n+See <TT>README.environment</tt> in the distribution for details.\n+</body>\n+</html>"}, {"sha": "5d9360af521dfe1839667dc8c6dc748dec39b090", "filename": "boehm-gc/tests/middle.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c4dc10837d7f66311a5da622e054ea168483a5c/boehm-gc%2Ftests%2Fmiddle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c4dc10837d7f66311a5da622e054ea168483a5c/boehm-gc%2Ftests%2Fmiddle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Fmiddle.c?ref=5c4dc10837d7f66311a5da622e054ea168483a5c", "patch": "@@ -0,0 +1,25 @@\n+/*\n+ * Test at the boundary between small and large objects.\n+ * Inspired by a test case from Zoltan Varga.\n+ */\n+#include <gc.h>\n+#include <stdio.h>\n+\n+int main ()\n+{\n+        int i;\n+\n+        GC_all_interior_pointers = 0;\n+\n+        for (i = 0; i < 20000; ++i) {\n+                GC_malloc_atomic (4096);\n+                GC_malloc (4096);\n+\t}\n+        for (i = 0; i < 20000; ++i) {\n+                GC_malloc_atomic (2048);\n+                GC_malloc (2048);\n+\t}\n+\tprintf(\"Final heap size is %ld\\n\", GC_get_heap_size());\n+\treturn 0;\n+}\n+"}]}