{"sha": "e8408f251a70640dcc208877ef3122efd5b7e824", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0MDhmMjUxYTcwNjQwZGNjMjA4ODc3ZWYzMTIyZWZkNWI3ZTgyNA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-03T22:14:08Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-03T22:14:08Z"}, "message": "cpplex.c (_cpp_lex_token): Don't warn about directives in macro arguments when looking for the '('.\n\n\t* cpplex.c (_cpp_lex_token): Don't warn about directives in\n\tmacro arguments when looking for the '('.\n\t* cppmacro.c (funlike_invocation_p): Set parsing_args to\n\t2 when really parsing arguments; 1 when looking for '('.\n\tAlways restore the lexer position.\n\t* gcc.dg/cpp/cppmacro7.c: New test.\n\nFrom-SVN: r40223", "tree": {"sha": "7dc28de2225965477d01df8a6de99ec5755e2829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dc28de2225965477d01df8a6de99ec5755e2829"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8408f251a70640dcc208877ef3122efd5b7e824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8408f251a70640dcc208877ef3122efd5b7e824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8408f251a70640dcc208877ef3122efd5b7e824", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8408f251a70640dcc208877ef3122efd5b7e824/comments", "author": null, "committer": null, "parents": [{"sha": "20f9202d81c1a89a0cb65a6ef260101a8ee8822b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f9202d81c1a89a0cb65a6ef260101a8ee8822b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20f9202d81c1a89a0cb65a6ef260101a8ee8822b"}], "stats": {"total": 90, "additions": 56, "deletions": 34}, "files": [{"sha": "322d241051441e1122d3ad55c3caf25afcea0d25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8408f251a70640dcc208877ef3122efd5b7e824", "patch": "@@ -1,3 +1,11 @@\n+2001-03-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplex.c (_cpp_lex_token): Don't warn about directives in\n+\tmacro arguments when looking for the '('.\n+\t* cppmacro.c (funlike_invocation_p): Set parsing_args to\n+\t2 when really parsing arguments; 1 when looking for '('.\n+\tAlways restore the lexer position.\n+\n 2001-03-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* longlong.h (umul_ppmm): Don't use a multiline string."}, {"sha": "bd96303861328d523fa83af5693f274ab6cac332", "filename": "gcc/cpplex.c", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=e8408f251a70640dcc208877ef3122efd5b7e824", "patch": "@@ -1171,38 +1171,36 @@ _cpp_lex_token (pfile, result)\n \n       result->type = CPP_HASH;\n     do_hash:\n-      if (bol)\n+      if (!bol)\n+\tbreak;\n+      /* 6.10.3 paragraph 11: If there are sequences of preprocessing\n+\t tokens within the list of arguments that would otherwise act\n+\t as preprocessing directives, the behavior is undefined.\n+\n+\t This implementation will report a hard error, terminate the\n+\t macro invocation, and proceed to process the directive.  */\n+      if (pfile->state.parsing_args)\n \t{\n-\t  if (pfile->state.parsing_args)\n-\t    {\n-\t      /* 6.10.3 paragraph 11: If there are sequences of\n-\t\t preprocessing tokens within the list of arguments that\n-\t\t would otherwise act as preprocessing directives, the\n-\t\t behavior is undefined.\n-\n-\t\t This implementation will report a hard error, terminate\n-\t\t the macro invocation, and proceed to process the\n-\t\t directive.  */\n-\t      cpp_error (pfile,\n-\t\t\t \"directives may not be used inside a macro argument\");\n-\n-\t      /* Put a '#' in lookahead, return CPP_EOF for parse_arg.  */\n-\t      buffer->extra_char = buffer->read_ahead;\n-\t      buffer->read_ahead = '#';\n-\t      pfile->state.next_bol = 1;\n-\t      result->type = CPP_EOF;\n-\n-\t      /* Get whitespace right - newline_in_args sets it.  */\n-\t      if (pfile->lexer_pos.col == 1)\n-\t\tresult->flags &= ~(PREV_WHITE | AVOID_LPASTE);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* This is the hash introducing a directive.  */\n-\t      if (_cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n-\t\tgoto done_directive; /* bol still 1.  */\n-\t      /* This is in fact an assembler #.  */\n-\t    }\n+\t  if (pfile->state.parsing_args == 2)\n+\t    cpp_error (pfile,\n+\t\t       \"directives may not be used inside a macro argument\");\n+\n+\t  /* Put a '#' in lookahead, return CPP_EOF for parse_arg.  */\n+\t  buffer->extra_char = buffer->read_ahead;\n+\t  buffer->read_ahead = '#';\n+\t  pfile->state.next_bol = 1;\n+\t  result->type = CPP_EOF;\n+\n+\t  /* Get whitespace right - newline_in_args sets it.  */\n+\t  if (pfile->lexer_pos.col == 1)\n+\t    result->flags &= ~(PREV_WHITE | AVOID_LPASTE);\n+\t}\n+      else\n+\t{\n+\t  /* This is the hash introducing a directive.  */\n+\t  if (_cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n+\t    goto done_directive; /* bol still 1.  */\n+\t  /* This is in fact an assembler #.  */\n \t}\n       break;\n "}, {"sha": "2390ee43798f47eb2e8e02a76ea292d77771e52f", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=e8408f251a70640dcc208877ef3122efd5b7e824", "patch": "@@ -602,6 +602,7 @@ funlike_invocation_p (pfile, node, list)\n   cpp_start_lookahead (pfile);\n   cpp_get_token (pfile, &maybe_paren);\n   cpp_stop_lookahead (pfile, maybe_paren.type == CPP_OPEN_PAREN);\n+  pfile->state.parsing_args = 2;\n \n   if (maybe_paren.type == CPP_OPEN_PAREN)\n     args = parse_args (pfile, node);\n@@ -615,11 +616,12 @@ funlike_invocation_p (pfile, node, list)\n   pfile->state.prevent_expansion--;\n   pfile->state.parsing_args = 0;\n \n+  /* Reset the position in case of failure.  If success, the macro's\n+     expansion appears where the name would have.  */\n+  pfile->lexer_pos = macro_pos;\n+\n   if (args)\n     {\n-      /* The macro's expansion appears where the name would have.  */\n-      pfile->lexer_pos = macro_pos;\n-\n       if (node->value.macro->paramc > 0)\n \t{\n \t  /* Don't save tokens during pre-expansion.  */"}, {"sha": "8e2e7b0399c3708a6e2430eeec346419372ae079", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8408f251a70640dcc208877ef3122efd5b7e824", "patch": "@@ -1,3 +1,7 @@\n+2001-03-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/macro7.c: New test.\n+\n 2001-03-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* gcc.dg/cpp/multiline.c: Update."}, {"sha": "6f2c67c1080963c4ae5f37e8d86ffb513a161f75", "filename": "gcc/testsuite/gcc.dg/cpp/macro7.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8408f251a70640dcc208877ef3122efd5b7e824/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro7.c?ref=e8408f251a70640dcc208877ef3122efd5b7e824", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do preprocess } */\n+\n+/* Test we don't complain about directives in macro expansions when\n+   looking for the '(' of a function-like macro.\n+\n+   Submitter: Neil Booth. 3 Mar 2000.  */\n+\n+#define f(x) x\n+f\n+#define g"}]}