{"sha": "744730a48e53f6aaa03be4af43ff3dc4eb44d502", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ0NzMwYTQ4ZTUzZjZhYWEwM2JlNGFmNDNmZjNkYzRlYjQ0ZDUwMg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-10-02T15:29:35Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-02T15:29:35Z"}, "message": "tree-flow.h: Remove some prototypes.\n\n\n2013-10-02  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-flow.h: Remove some prototypes.\n\t* gimple-fold.h: Add prototypes from gimple.h and tree-flow.h.\n\t* tree-ssa-propagate.h: Relocate prototypes from tree-flow.h.\n\t* tree-ssa-copy.c (may_propagate*, propagate_value, replace_exp,\n\tpropagate_tree_value*): Move from here to...\n\t* tree-ssa-propagate.c (may_propagate*, propagate_value, replace_exp,\n\tpropagate_tree_value*): Relocate here.\n\t* tree-ssa-propagate.h: Relocate prototypes from tree-flow.h.\n\t* gimple.h: Include gimple-fold.h, move prototypes into gimple-fold.h.\n\t* gimple-fold.c: Remove gimple-fold.h from include list.\n\t* tree-vrp.c: Remove gimple-fold.h from include list.\n\t* tree-ssa-sccvn.c: Remove gimple-fold.h from include list.\n\t* tree-ssa-ccp.c: Remove gimple-fold.h from include list.\n\t* tree-scalar-evolution.c: Add tree-ssa-propagate.h to include list.\n\t* tree-ssa-pre.c: Add tree-ssa-propagate.h to include list.\n\t* sese.c: Add tree-ssa-propagate.h to include list.\n\nFrom-SVN: r203118", "tree": {"sha": "5c2214fabbf4c67fc675ef1f8b0c28a4e7685280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c2214fabbf4c67fc675ef1f8b0c28a4e7685280"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/744730a48e53f6aaa03be4af43ff3dc4eb44d502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744730a48e53f6aaa03be4af43ff3dc4eb44d502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/744730a48e53f6aaa03be4af43ff3dc4eb44d502", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744730a48e53f6aaa03be4af43ff3dc4eb44d502/comments", "author": null, "committer": null, "parents": [{"sha": "756aa0c30268da6b1de3bf6b9b427eefe8520d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756aa0c30268da6b1de3bf6b9b427eefe8520d57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/756aa0c30268da6b1de3bf6b9b427eefe8520d57"}], "stats": {"total": 531, "additions": 270, "deletions": 261}, "files": [{"sha": "d2e75736e3c7ad383032164d7e46d36ca233dab4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -1,3 +1,22 @@\n+2013-10-02  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-flow.h: Remove some prototypes.\n+\t* gimple-fold.h: Add prototypes from gimple.h and tree-flow.h.\n+\t* tree-ssa-propagate.h: Relocate prototypes from tree-flow.h.\n+\t* tree-ssa-copy.c (may_propagate*, propagate_value, replace_exp,\n+\tpropagate_tree_value*): Move from here to...\n+\t* tree-ssa-propagate.c (may_propagate*, propagate_value, replace_exp,\n+\tpropagate_tree_value*): Relocate here.\n+\t* tree-ssa-propagate.h: Relocate prototypes from tree-flow.h.\n+\t* gimple.h: Include gimple-fold.h, move prototypes into gimple-fold.h.\n+\t* gimple-fold.c: Remove gimple-fold.h from include list.\n+\t* tree-vrp.c: Remove gimple-fold.h from include list.\n+\t* tree-ssa-sccvn.c: Remove gimple-fold.h from include list.\n+\t* tree-ssa-ccp.c: Remove gimple-fold.h from include list.\n+\t* tree-scalar-evolution.c: Add tree-ssa-propagate.h to include list.\n+\t* tree-ssa-pre.c: Add tree-ssa-propagate.h to include list.\n+\t* sese.c: Add tree-ssa-propagate.h to include list.\n+\n 2013-10-02  Richard Biener  <rguenther@suse.de>\n \n \t* tree-loop-distribution.c: Include tree-vectorizer.h for"}, {"sha": "9892c8642ea32be650992a38b563ff2088f53f2d", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -29,7 +29,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"target.h\"\n-#include \"gimple-fold.h\"\n #include \"ipa-utils.h\"\n #include \"gimple-pretty-print.h\"\n "}, {"sha": "9b818fc519f77c9d4131c08c9b0f97f2a5e9accd", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -22,10 +22,22 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_FOLD_H\n #define GCC_GIMPLE_FOLD_H\n \n-tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n-tree fold_const_aggregate_ref (tree);\n-\n-tree gimple_fold_stmt_to_constant_1 (gimple, tree (*) (tree));\n-tree gimple_fold_stmt_to_constant (gimple, tree (*) (tree));\n+extern tree canonicalize_constructor_val (tree, tree);\n+extern tree get_symbol_constant_value (tree);\n+extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n+extern tree gimple_fold_builtin (gimple);\n+extern tree gimple_extract_devirt_binfo_from_cst (tree, tree);\n+extern bool fold_stmt (gimple_stmt_iterator *);\n+extern bool fold_stmt_inplace (gimple_stmt_iterator *);\n+extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree, \n+\t\t\t\t\tenum tree_code, tree, tree);\n+extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n+\t\t\t\t       enum tree_code, tree, tree);\n+extern tree gimple_fold_stmt_to_constant_1 (gimple, tree (*) (tree));\n+extern tree gimple_fold_stmt_to_constant (gimple, tree (*) (tree));\n+extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n+extern tree fold_const_aggregate_ref (tree);\n+extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree);\n+extern bool gimple_val_nonnegative_real_p (tree);\n \n #endif  /* GCC_GIMPLE_FOLD_H */"}, {"sha": "3ac59af9da9d476b8538b71f09bd48e00f6bd5e2", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n \n typedef gimple gimple_seq_node;\n \n@@ -833,8 +834,6 @@ unsigned get_gimple_rhs_num_ops (enum tree_code);\n #define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n const char *gimple_decl_printable_name (tree, int);\n-tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree);\n-tree gimple_extract_devirt_binfo_from_cst (tree, tree);\n \n /* Returns true iff T is a scalar register variable.  */\n extern bool is_gimple_reg (tree);\n@@ -5421,21 +5420,6 @@ gimple_alloc_kind (enum gimple_code code)\n \n extern void dump_gimple_statistics (void);\n \n-/* In gimple-fold.c.  */\n-void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n-tree gimple_fold_builtin (gimple);\n-bool fold_stmt (gimple_stmt_iterator *);\n-bool fold_stmt_inplace (gimple_stmt_iterator *);\n-tree get_symbol_constant_value (tree);\n-tree canonicalize_constructor_val (tree, tree);\n-extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree, \n-\t\t\t\t\tenum tree_code, tree, tree);\n-extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n-\t\t\t\t       enum tree_code, tree, tree);\n-\n-bool gimple_val_nonnegative_real_p (tree);\n-\n-\n /* Set the location of all statements in SEQ to LOC.  */\n \n static inline void"}, {"sha": "a78a7967772533fc99cc6c984b5dc9e125919b03", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"value-prof.h\"\n #include \"sese.h\"\n+#include \"tree-ssa-propagate.h\"\n \n /* Print to stderr the element ELT.  */\n "}, {"sha": "bbd1a15dd713a8cd631301fac93237ec858cc6da", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -244,26 +244,13 @@ extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n void remove_edge_and_dominated_blocks (edge);\n bool tree_node_can_be_shared (tree);\n \n-/* In tree-ssa-ccp.c  */\n-tree fold_const_aggregate_ref (tree);\n-tree gimple_fold_stmt_to_constant (gimple, tree (*)(tree));\n-\n /* In tree-ssa-dom.c  */\n extern void dump_dominator_optimization_stats (FILE *);\n extern void debug_dominator_optimization_stats (void);\n int loop_depth_of_name (tree);\n tree degenerate_phi_result (gimple);\n bool simple_iv_increment_p (gimple);\n \n-/* In tree-ssa-copy.c  */\n-extern void propagate_value (use_operand_p, tree);\n-extern void propagate_tree_value (tree *, tree);\n-extern void propagate_tree_value_into_stmt (gimple_stmt_iterator *, tree);\n-extern void replace_exp (use_operand_p, tree);\n-extern bool may_propagate_copy (tree, tree);\n-extern bool may_propagate_copy_into_stmt (gimple, tree);\n-extern bool may_propagate_copy_into_asm (tree);\n-\n /* In tree-ssa-loop-ch.c  */\n bool do_while_loop_p (struct loop *);\n "}, {"sha": "16d9d7d4b2307b7157a19ec8b1185b11aa7523df", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -265,6 +265,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"dumpfile.h\"\n #include \"params.h\"\n+#include \"tree-ssa-propagate.h\"\n \n static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);\n static tree analyze_scalar_evolution_for_address_of (struct loop *loop,"}, {"sha": "15df8da7a3f2b11c73dd93e57ad2622c5674685b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -127,7 +127,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"diagnostic-core.h\"\n #include \"dbgcnt.h\"\n-#include \"gimple-fold.h\"\n #include \"params.h\"\n #include \"hash-table.h\"\n "}, {"sha": "c85749d511dc72c6e9982e14178bbc424c778bad", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -50,220 +50,6 @@ along with GCC; see the file COPYING3.  If not see\n    replacements of one SSA_NAME with a different SSA_NAME to use the\n    APIs defined in this file.  */\n \n-/* Return true if we may propagate ORIG into DEST, false otherwise.  */\n-\n-bool\n-may_propagate_copy (tree dest, tree orig)\n-{\n-  tree type_d = TREE_TYPE (dest);\n-  tree type_o = TREE_TYPE (orig);\n-\n-  /* If ORIG flows in from an abnormal edge, it cannot be propagated.  */\n-  if (TREE_CODE (orig) == SSA_NAME\n-      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig)\n-      /* If it is the default definition and an automatic variable then\n-         we can though and it is important that we do to avoid\n-\t uninitialized regular copies.  */\n-      && !(SSA_NAME_IS_DEFAULT_DEF (orig)\n-\t   && (SSA_NAME_VAR (orig) == NULL_TREE\n-\t       || TREE_CODE (SSA_NAME_VAR (orig)) == VAR_DECL)))\n-    return false;\n-\n-  /* If DEST is an SSA_NAME that flows from an abnormal edge, then it\n-     cannot be replaced.  */\n-  if (TREE_CODE (dest) == SSA_NAME\n-      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (dest))\n-    return false;\n-\n-  /* Do not copy between types for which we *do* need a conversion.  */\n-  if (!useless_type_conversion_p (type_d, type_o))\n-    return false;\n-\n-  /* Generally propagating virtual operands is not ok as that may\n-     create overlapping life-ranges.  */\n-  if (TREE_CODE (dest) == SSA_NAME && virtual_operand_p (dest))\n-    return false;\n-\n-  /* Anything else is OK.  */\n-  return true;\n-}\n-\n-/* Like may_propagate_copy, but use as the destination expression\n-   the principal expression (typically, the RHS) contained in\n-   statement DEST.  This is more efficient when working with the\n-   gimple tuples representation.  */\n-\n-bool\n-may_propagate_copy_into_stmt (gimple dest, tree orig)\n-{\n-  tree type_d;\n-  tree type_o;\n-\n-  /* If the statement is a switch or a single-rhs assignment,\n-     then the expression to be replaced by the propagation may\n-     be an SSA_NAME.  Fortunately, there is an explicit tree\n-     for the expression, so we delegate to may_propagate_copy.  */\n-\n-  if (gimple_assign_single_p (dest))\n-    return may_propagate_copy (gimple_assign_rhs1 (dest), orig);\n-  else if (gimple_code (dest) == GIMPLE_SWITCH)\n-    return may_propagate_copy (gimple_switch_index (dest), orig);\n-\n-  /* In other cases, the expression is not materialized, so there\n-     is no destination to pass to may_propagate_copy.  On the other\n-     hand, the expression cannot be an SSA_NAME, so the analysis\n-     is much simpler.  */\n-\n-  if (TREE_CODE (orig) == SSA_NAME\n-      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig))\n-    return false;\n-\n-  if (is_gimple_assign (dest))\n-    type_d = TREE_TYPE (gimple_assign_lhs (dest));\n-  else if (gimple_code (dest) == GIMPLE_COND)\n-    type_d = boolean_type_node;\n-  else if (is_gimple_call (dest)\n-           && gimple_call_lhs (dest) != NULL_TREE)\n-    type_d = TREE_TYPE (gimple_call_lhs (dest));\n-  else\n-    gcc_unreachable ();\n-\n-  type_o = TREE_TYPE (orig);\n-\n-  if (!useless_type_conversion_p (type_d, type_o))\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Similarly, but we know that we're propagating into an ASM_EXPR.  */\n-\n-bool\n-may_propagate_copy_into_asm (tree dest ATTRIBUTE_UNUSED)\n-{\n-  return true;\n-}\n-\n-\n-/* Common code for propagate_value and replace_exp.\n-\n-   Replace use operand OP_P with VAL.  FOR_PROPAGATION indicates if the\n-   replacement is done to propagate a value or not.  */\n-\n-static void\n-replace_exp_1 (use_operand_p op_p, tree val,\n-    \t       bool for_propagation ATTRIBUTE_UNUSED)\n-{\n-#if defined ENABLE_CHECKING\n-  tree op = USE_FROM_PTR (op_p);\n-\n-  gcc_assert (!(for_propagation\n-\t\t&& TREE_CODE (op) == SSA_NAME\n-\t\t&& TREE_CODE (val) == SSA_NAME\n-\t\t&& !may_propagate_copy (op, val)));\n-#endif\n-\n-  if (TREE_CODE (val) == SSA_NAME)\n-    SET_USE (op_p, val);\n-  else\n-    SET_USE (op_p, unshare_expr (val));\n-}\n-\n-\n-/* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n-   into the operand pointed to by OP_P.\n-\n-   Use this version for const/copy propagation as it will perform additional\n-   checks to ensure validity of the const/copy propagation.  */\n-\n-void\n-propagate_value (use_operand_p op_p, tree val)\n-{\n-  replace_exp_1 (op_p, val, true);\n-}\n-\n-/* Replace *OP_P with value VAL (assumed to be a constant or another SSA_NAME).\n-\n-   Use this version when not const/copy propagating values.  For example,\n-   PRE uses this version when building expressions as they would appear\n-   in specific blocks taking into account actions of PHI nodes.\n-\n-   The statement in which an expression has been replaced should be\n-   folded using fold_stmt_inplace.  */\n-\n-void\n-replace_exp (use_operand_p op_p, tree val)\n-{\n-  replace_exp_1 (op_p, val, false);\n-}\n-\n-\n-/* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n-   into the tree pointed to by OP_P.\n-\n-   Use this version for const/copy propagation when SSA operands are not\n-   available.  It will perform the additional checks to ensure validity of\n-   the const/copy propagation, but will not update any operand information.\n-   Be sure to mark the stmt as modified.  */\n-\n-void\n-propagate_tree_value (tree *op_p, tree val)\n-{\n-  gcc_checking_assert (!(TREE_CODE (val) == SSA_NAME\n-\t\t\t && *op_p\n-\t\t\t && TREE_CODE (*op_p) == SSA_NAME\n-\t\t\t && !may_propagate_copy (*op_p, val)));\n-\n-  if (TREE_CODE (val) == SSA_NAME)\n-    *op_p = val;\n-  else\n-    *op_p = unshare_expr (val);\n-}\n-\n-\n-/* Like propagate_tree_value, but use as the operand to replace\n-   the principal expression (typically, the RHS) contained in the\n-   statement referenced by iterator GSI.  Note that it is not\n-   always possible to update the statement in-place, so a new\n-   statement may be created to replace the original.  */\n-\n-void\n-propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n-{\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  if (is_gimple_assign (stmt))\n-    {\n-      tree expr = NULL_TREE;\n-      if (gimple_assign_single_p (stmt))\n-        expr = gimple_assign_rhs1 (stmt);\n-      propagate_tree_value (&expr, val);\n-      gimple_assign_set_rhs_from_tree (gsi, expr);\n-    }\n-  else if (gimple_code (stmt) == GIMPLE_COND)\n-    {\n-      tree lhs = NULL_TREE;\n-      tree rhs = build_zero_cst (TREE_TYPE (val));\n-      propagate_tree_value (&lhs, val);\n-      gimple_cond_set_code (stmt, NE_EXPR);\n-      gimple_cond_set_lhs (stmt, lhs);\n-      gimple_cond_set_rhs (stmt, rhs);\n-    }\n-  else if (is_gimple_call (stmt)\n-           && gimple_call_lhs (stmt) != NULL_TREE)\n-    {\n-      tree expr = NULL_TREE;\n-      bool res;\n-      propagate_tree_value (&expr, val);\n-      res = update_call_from_tree (gsi, expr);\n-      gcc_assert (res);\n-    }\n-  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    propagate_tree_value (gimple_switch_index_ptr (stmt), val);\n-  else\n-    gcc_unreachable ();\n-}\n-\n /*---------------------------------------------------------------------------\n \t\t\t\tCopy propagation\n ---------------------------------------------------------------------------*/"}, {"sha": "50027ebffe8c0a053edd80bed115b2f2e060b6be", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"domwalk.h\"\n #include \"ipa-prop.h\"\n+#include \"tree-ssa-propagate.h\"\n \n /* TODO:\n "}, {"sha": "591f5508f6659585361da1eee40cecf4f86ff7c1", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -1226,4 +1226,219 @@ substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n   return something_changed;\n }\n \n+\n+/* Return true if we may propagate ORIG into DEST, false otherwise.  */\n+\n+bool\n+may_propagate_copy (tree dest, tree orig)\n+{\n+  tree type_d = TREE_TYPE (dest);\n+  tree type_o = TREE_TYPE (orig);\n+\n+  /* If ORIG flows in from an abnormal edge, it cannot be propagated.  */\n+  if (TREE_CODE (orig) == SSA_NAME\n+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig)\n+      /* If it is the default definition and an automatic variable then\n+         we can though and it is important that we do to avoid\n+\t uninitialized regular copies.  */\n+      && !(SSA_NAME_IS_DEFAULT_DEF (orig)\n+\t   && (SSA_NAME_VAR (orig) == NULL_TREE\n+\t       || TREE_CODE (SSA_NAME_VAR (orig)) == VAR_DECL)))\n+    return false;\n+\n+  /* If DEST is an SSA_NAME that flows from an abnormal edge, then it\n+     cannot be replaced.  */\n+  if (TREE_CODE (dest) == SSA_NAME\n+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (dest))\n+    return false;\n+\n+  /* Do not copy between types for which we *do* need a conversion.  */\n+  if (!useless_type_conversion_p (type_d, type_o))\n+    return false;\n+\n+  /* Generally propagating virtual operands is not ok as that may\n+     create overlapping life-ranges.  */\n+  if (TREE_CODE (dest) == SSA_NAME && virtual_operand_p (dest))\n+    return false;\n+\n+  /* Anything else is OK.  */\n+  return true;\n+}\n+\n+/* Like may_propagate_copy, but use as the destination expression\n+   the principal expression (typically, the RHS) contained in\n+   statement DEST.  This is more efficient when working with the\n+   gimple tuples representation.  */\n+\n+bool\n+may_propagate_copy_into_stmt (gimple dest, tree orig)\n+{\n+  tree type_d;\n+  tree type_o;\n+\n+  /* If the statement is a switch or a single-rhs assignment,\n+     then the expression to be replaced by the propagation may\n+     be an SSA_NAME.  Fortunately, there is an explicit tree\n+     for the expression, so we delegate to may_propagate_copy.  */\n+\n+  if (gimple_assign_single_p (dest))\n+    return may_propagate_copy (gimple_assign_rhs1 (dest), orig);\n+  else if (gimple_code (dest) == GIMPLE_SWITCH)\n+    return may_propagate_copy (gimple_switch_index (dest), orig);\n+\n+  /* In other cases, the expression is not materialized, so there\n+     is no destination to pass to may_propagate_copy.  On the other\n+     hand, the expression cannot be an SSA_NAME, so the analysis\n+     is much simpler.  */\n+\n+  if (TREE_CODE (orig) == SSA_NAME\n+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig))\n+    return false;\n+\n+  if (is_gimple_assign (dest))\n+    type_d = TREE_TYPE (gimple_assign_lhs (dest));\n+  else if (gimple_code (dest) == GIMPLE_COND)\n+    type_d = boolean_type_node;\n+  else if (is_gimple_call (dest)\n+           && gimple_call_lhs (dest) != NULL_TREE)\n+    type_d = TREE_TYPE (gimple_call_lhs (dest));\n+  else\n+    gcc_unreachable ();\n+\n+  type_o = TREE_TYPE (orig);\n+\n+  if (!useless_type_conversion_p (type_d, type_o))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Similarly, but we know that we're propagating into an ASM_EXPR.  */\n+\n+bool\n+may_propagate_copy_into_asm (tree dest ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+\n+/* Common code for propagate_value and replace_exp.\n+\n+   Replace use operand OP_P with VAL.  FOR_PROPAGATION indicates if the\n+   replacement is done to propagate a value or not.  */\n+\n+static void\n+replace_exp_1 (use_operand_p op_p, tree val,\n+    \t       bool for_propagation ATTRIBUTE_UNUSED)\n+{\n+#if defined ENABLE_CHECKING\n+  tree op = USE_FROM_PTR (op_p);\n+\n+  gcc_assert (!(for_propagation\n+\t\t&& TREE_CODE (op) == SSA_NAME\n+\t\t&& TREE_CODE (val) == SSA_NAME\n+\t\t&& !may_propagate_copy (op, val)));\n+#endif\n+\n+  if (TREE_CODE (val) == SSA_NAME)\n+    SET_USE (op_p, val);\n+  else\n+    SET_USE (op_p, unshare_expr (val));\n+}\n+\n+\n+/* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n+   into the operand pointed to by OP_P.\n+\n+   Use this version for const/copy propagation as it will perform additional\n+   checks to ensure validity of the const/copy propagation.  */\n+\n+void\n+propagate_value (use_operand_p op_p, tree val)\n+{\n+  replace_exp_1 (op_p, val, true);\n+}\n+\n+/* Replace *OP_P with value VAL (assumed to be a constant or another SSA_NAME).\n+\n+   Use this version when not const/copy propagating values.  For example,\n+   PRE uses this version when building expressions as they would appear\n+   in specific blocks taking into account actions of PHI nodes.\n+\n+   The statement in which an expression has been replaced should be\n+   folded using fold_stmt_inplace.  */\n+\n+void\n+replace_exp (use_operand_p op_p, tree val)\n+{\n+  replace_exp_1 (op_p, val, false);\n+}\n+\n+\n+/* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n+   into the tree pointed to by OP_P.\n+\n+   Use this version for const/copy propagation when SSA operands are not\n+   available.  It will perform the additional checks to ensure validity of\n+   the const/copy propagation, but will not update any operand information.\n+   Be sure to mark the stmt as modified.  */\n+\n+void\n+propagate_tree_value (tree *op_p, tree val)\n+{\n+  gcc_checking_assert (!(TREE_CODE (val) == SSA_NAME\n+\t\t\t && *op_p\n+\t\t\t && TREE_CODE (*op_p) == SSA_NAME\n+\t\t\t && !may_propagate_copy (*op_p, val)));\n+\n+  if (TREE_CODE (val) == SSA_NAME)\n+    *op_p = val;\n+  else\n+    *op_p = unshare_expr (val);\n+}\n+\n+\n+/* Like propagate_tree_value, but use as the operand to replace\n+   the principal expression (typically, the RHS) contained in the\n+   statement referenced by iterator GSI.  Note that it is not\n+   always possible to update the statement in-place, so a new\n+   statement may be created to replace the original.  */\n+\n+void\n+propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+\n+  if (is_gimple_assign (stmt))\n+    {\n+      tree expr = NULL_TREE;\n+      if (gimple_assign_single_p (stmt))\n+        expr = gimple_assign_rhs1 (stmt);\n+      propagate_tree_value (&expr, val);\n+      gimple_assign_set_rhs_from_tree (gsi, expr);\n+    }\n+  else if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      tree lhs = NULL_TREE;\n+      tree rhs = build_zero_cst (TREE_TYPE (val));\n+      propagate_tree_value (&lhs, val);\n+      gimple_cond_set_code (stmt, NE_EXPR);\n+      gimple_cond_set_lhs (stmt, lhs);\n+      gimple_cond_set_rhs (stmt, rhs);\n+    }\n+  else if (is_gimple_call (stmt)\n+           && gimple_call_lhs (stmt) != NULL_TREE)\n+    {\n+      tree expr = NULL_TREE;\n+      bool res;\n+      propagate_tree_value (&expr, val);\n+      res = update_call_from_tree (gsi, expr);\n+      gcc_assert (res);\n+    }\n+  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n+    propagate_tree_value (gimple_switch_index_ptr (stmt), val);\n+  else\n+    gcc_unreachable ();\n+}\n+\n #include \"gt-tree-ssa-propagate.h\""}, {"sha": "1b8bf9042e591c65b1856099ddb3b352ef0efce7", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -68,13 +68,20 @@ typedef bool (*ssa_prop_fold_stmt_fn) (gimple_stmt_iterator *gsi);\n typedef tree (*ssa_prop_get_value_fn) (tree);\n \n \n-/* In tree-ssa-propagate.c  */\n-void ssa_propagate (ssa_prop_visit_stmt_fn, ssa_prop_visit_phi_fn);\n-bool valid_gimple_rhs_p (tree);\n-void move_ssa_defining_stmt_for_defs (gimple, gimple);\n-bool update_gimple_call (gimple_stmt_iterator *, tree, int, ...);\n-bool update_call_from_tree (gimple_stmt_iterator *, tree);\n-bool stmt_makes_single_store (gimple);\n-bool substitute_and_fold (ssa_prop_get_value_fn, ssa_prop_fold_stmt_fn, bool);\n+extern bool valid_gimple_rhs_p (tree);\n+extern void move_ssa_defining_stmt_for_defs (gimple, gimple);\n+extern bool update_gimple_call (gimple_stmt_iterator *, tree, int, ...);\n+extern bool update_call_from_tree (gimple_stmt_iterator *, tree);\n+extern void ssa_propagate (ssa_prop_visit_stmt_fn, ssa_prop_visit_phi_fn);\n+extern bool stmt_makes_single_store (gimple);\n+extern bool substitute_and_fold (ssa_prop_get_value_fn, ssa_prop_fold_stmt_fn,\n+\t\t\t\t bool);\n+extern bool may_propagate_copy (tree, tree);\n+extern bool may_propagate_copy_into_stmt (gimple, tree);\n+extern bool may_propagate_copy_into_asm (tree);\n+extern void propagate_value (use_operand_p, tree);\n+extern void replace_exp (use_operand_p, tree);\n+extern void propagate_tree_value (tree *, tree);\n+extern void propagate_tree_value_into_stmt (gimple_stmt_iterator *, tree);\n \n #endif /* _TREE_SSA_PROPAGATE_H  */"}, {"sha": "91604e2a54e272b137e131b175310284325108b1", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -37,7 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"tree-ssa-sccvn.h\"\n-#include \"gimple-fold.h\"\n \n /* This algorithm is based on the SCC algorithm presented by Keith\n    Cooper and L. Taylor Simpson in \"SCC-Based Value numbering\""}, {"sha": "3464529ca8569476523c611220669c1ba1ec548c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744730a48e53f6aaa03be4af43ff3dc4eb44d502/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=744730a48e53f6aaa03be4af43ff3dc4eb44d502", "patch": "@@ -37,7 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"tree-chrec.h\"\n #include \"tree-ssa-threadupdate.h\"\n-#include \"gimple-fold.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n "}]}