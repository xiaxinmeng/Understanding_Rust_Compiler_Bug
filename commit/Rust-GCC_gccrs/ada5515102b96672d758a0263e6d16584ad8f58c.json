{"sha": "ada5515102b96672d758a0263e6d16584ad8f58c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRhNTUxNTEwMmI5NjY3MmQ3NThhMDI2M2U2ZDE2NTg0YWQ4ZjU4Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-06-28T10:30:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-06-28T10:30:21Z"}, "message": "vec.h, vec.c: New, type safe vector API.\n\n\t* vec.h, vec.c: New, type safe vector API.\n\t* Makefile.in (OBJS-common): Add vec.o.\n\t(vec.o): New target.\n\t(gengtype-lex.o): Depend on vec.h.\n\nFrom-SVN: r83769", "tree": {"sha": "6b9f076ff5e810f86303640cbdffadcc0718e12c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b9f076ff5e810f86303640cbdffadcc0718e12c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ada5515102b96672d758a0263e6d16584ad8f58c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada5515102b96672d758a0263e6d16584ad8f58c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ada5515102b96672d758a0263e6d16584ad8f58c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada5515102b96672d758a0263e6d16584ad8f58c/comments", "author": null, "committer": null, "parents": [{"sha": "2851dd684b26170d5ac940428e775edb8b093a69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2851dd684b26170d5ac940428e775edb8b093a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2851dd684b26170d5ac940428e775edb8b093a69"}], "stats": {"total": 827, "additions": 824, "deletions": 3}, "files": [{"sha": "133389b1060b8adac291fa47c9a0b6342dfadfec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ada5515102b96672d758a0263e6d16584ad8f58c", "patch": "@@ -1,3 +1,10 @@\n+2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.h, vec.c: New, type safe vector API.\n+\t* Makefile.in (OBJS-common): Add vec.o.\n+\t(vec.o): New target.\n+\t(gengtype-lex.o): Depend on vec.h.\n+\n 2004-06-28  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* fold-const.c (fold_cond_expr_with_comparison): Add ARG1"}, {"sha": "62a5aa1d970e32f0d2ed389bb0b4e3e5e0975e0f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ada5515102b96672d758a0263e6d16584ad8f58c", "patch": "@@ -914,7 +914,7 @@ OBJS-common = \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n  simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o \t \t  \\\n  targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n- varasm.o varray.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n+ varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o\n \n@@ -1990,6 +1990,7 @@ global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS\n    toplev.h $(TM_P_H)\n varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h $(GGC_H) errors.h \\\n    $(HASHTAB_H)\n+vec.o : vec.c $(CONFIG_H) coretypes.h vec.h ggc.h errors.h\n ra.o : ra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TM_P_H) insn-config.h \\\n    $(RECOG_H) $(INTEGRATE_H) function.h $(REGS_H) $(OBSTACK_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(DF_H) $(EXPR_H) output.h toplev.h $(FLAGS_H) reload.h $(RA_H)\n@@ -2515,7 +2516,7 @@ gengtype.o : gengtype.c gengtype.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)\n   real.h $(RTL_BASE_H) gtyp-gen.h\n \n gengtype-lex.o : gengtype-lex.c gengtype.h gengtype-yacc.h \\\n-  $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\n+  $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) vec.h\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \\\n \t $< $(OUTPUT_OPTION)\n "}, {"sha": "ed9100829ee8e65329a509e79643123f1366b4db", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 143, "deletions": 1, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=ada5515102b96672d758a0263e6d16584ad8f58c", "patch": "@@ -30,6 +30,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"gengtype.h\"\n #include \"gengtype-yacc.h\"\n \n+#define YY_INPUT(BUF,RESULT,SIZE) ((RESULT) = macro_input (BUF,SIZE))\n+\n+static unsigned macro_input (char *buffer, unsigned);\n+static void push_macro_expansion (const char *, unsigned,\n+\t\t\t\t  const char *, unsigned);\n static void update_lineno (const char *l, size_t len);\n \n struct fileloc lexer_line;\n@@ -218,6 +223,35 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   return ENT_YACCUNION;\n }\n \n+^\"DEF_VEC_\"[[:alnum:]_]*{WS}?\"(\"{WS}?{ID}{WS}?\")\" {\n+  char *macro, *arg;\n+  unsigned macro_len, arg_len;\n+  char *ptr = yytext;\n+  type_p t;\n+\n+  /* Locate the macro and argument strings.  */\n+  macro = ptr;\n+  while (*ptr != '(' && !ISSPACE (*ptr))\n+    ptr++;\n+  macro_len = ptr - macro;\n+  while (*ptr == '(' || ISSPACE (*ptr))\n+    ptr++;\n+  arg = ptr;\n+  while (*ptr != ')' && !ISSPACE (*ptr))\n+    ptr++;\n+  arg_len = ptr - arg;\n+\n+  /* Push the macro for later expansion.  */\n+  push_macro_expansion (macro, macro_len, arg, arg_len);\n+\n+  /* Create the struct and typedef.  */\n+  ptr = xmemdup (\"VEC_\", 4, 4 + arg_len + 1);\n+  memcpy (&ptr[4], arg, arg_len);\n+  ptr[4 + arg_len] = 0;\n+  t = find_structure (ptr, 0);\n+  do_typedef (ptr, t, &lexer_line);\n+}\n+\n <in_struct>{\n \n \"/*\"\t\t\t\t{ BEGIN(in_struct_comment); }\n@@ -229,7 +263,6 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n {WS}\t\t\t\t{ update_lineno (yytext, yyleng); }\n \n \"const\"/[^[:alnum:]_]\t\t/* don't care */\n-\n \"GTY\"/[^[:alnum:]_]\t\t{ return GTY_TOKEN; }\n \"union\"/[^[:alnum:]_]\t\t{ return UNION; }\n \"struct\"/[^[:alnum:]_]\t\t{ return STRUCT; }\n@@ -254,6 +287,28 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   return SCALAR;\n }\n \n+\"VEC\"{WS}?\"(\"{WS}?{ID}{WS}?\")\" {\n+  char *macro, *arg;\n+  unsigned macro_len, arg_len;\n+  char *ptr = yytext;\n+\n+  macro = ptr;\n+  while (*ptr != '(' && !ISSPACE (*ptr))\n+    ptr++;\n+  macro_len = ptr - macro;\n+  while (*ptr == '(' || ISSPACE (*ptr))\n+    ptr++;\n+  arg = ptr;\n+  while (*ptr != ')' && !ISSPACE (*ptr))\n+    ptr++;\n+  arg_len = ptr - arg;\n+  ptr = xmemdup (macro, macro_len, macro_len + arg_len + 2);\n+  ptr[macro_len] = '_';\n+  memcpy (&ptr[macro_len+1], arg, arg_len);\n+  yylval.s = ptr;\n+  return ID;\n+}\n+\n {ID}/[^[:alnum:]_]\t\t{\n   yylval.s = xmemdup (yytext, yyleng, yyleng+1);\n   return ID;\n@@ -340,6 +395,93 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n \n %%\n \n+/* Deal with the expansion caused by the DEF_VEC_x macros.  */\n+\n+typedef struct macro\n+{\n+  const char *name;\n+  const char *expansion;\n+  struct macro *next;\n+} macro_t;\n+\n+static const macro_t macro_defs[] = \n+{\n+#define IN_GENGTYPE 1\n+#include \"vec.h\"\n+  {NULL, NULL, NULL}\n+};\n+\n+/* Chain of macro expansions to do at end of scanning.  */\n+static macro_t *macro_expns;\n+\n+/* Push macro NAME (NAME_LEN) with argument ARG (ARG_LEN) onto the\n+   expansion queue.  We ensure NAME is known at this point.  */\n+\n+static void\n+push_macro_expansion (const char *name, unsigned name_len,\n+\t\t      const char *arg, unsigned arg_len)\n+{\n+  unsigned ix;\n+\n+  for (ix = 0; macro_defs[ix].name; ix++)\n+    if (strlen (macro_defs[ix].name) == name_len\n+        && !memcmp (name, macro_defs[ix].name, name_len))\n+      {\n+        macro_t *expansion = xmalloc (sizeof (*expansion));\n+\n+\texpansion->next = macro_expns;\n+\texpansion->name = xmemdup (arg, arg_len, arg_len+1);\n+\texpansion->expansion = macro_defs[ix].expansion;\n+\tmacro_expns = expansion;\n+\treturn;\n+      }\n+  error_at_line (&lexer_line, \"unrecognized macro `%.*s(%.*s)'\",\n+\t\t name_len, name, arg_len, arg);\n+}\n+\n+/* Attempt to read some input.  Use fread until we're at the end of\n+   file.  At end of file expand the next queued macro.  We presume the\n+   buffer is large enough for the entire expansion.  */\n+\n+static unsigned\n+macro_input (char *buffer, unsigned size)\n+{\n+  unsigned result;\n+\n+  result = fread (buffer, 1, size, yyin);\n+  if (result)\n+    /*NOP*/;\n+  else if (ferror (yyin))\n+    YY_FATAL_ERROR (\"read of source file failed\");\n+  else if (macro_expns)\n+    {\n+      const char *expn;\n+      unsigned len;\n+\n+      for (expn = macro_expns->expansion; *expn; expn++)\n+        {\n+\t  if (*expn == '#')\n+\t    {\n+\t      if (buffer[result-1] == ' ' && buffer[result-2] == '_')\n+\t        result--;\n+\t      len = strlen (macro_expns->name);\n+\t      memcpy (&buffer[result], macro_expns->name, len);\n+\t      result += len;\n+\t    }\n+\t  else\n+\t    {\n+\t      buffer[result++] = *expn;\n+\t      if (*expn == ';' || *expn == '{')\n+\t        buffer[result++] = '\\n';\n+\t    }\n+        }\n+      if (result > size)\n+        YY_FATAL_ERROR (\"buffer too small to expand macro\");\n+      macro_expns = macro_expns->next;\n+    }\n+  return result;\n+}\n+\n void\n yyerror (const char *s)\n {"}, {"sha": "b8c5a32af0e0626fb1f94390dc7343ad9d4d88d8", "filename": "gcc/vec.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=ada5515102b96672d758a0263e6d16584ad8f58c", "patch": "@@ -0,0 +1,104 @@\n+/* Vector API for GNU compiler.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Nathan Sidwell <nathan@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ggc.h\"\n+#include \"vec.h\"\n+#include \"errors.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+\n+struct vec_prefix \n+{\n+  size_t num;\n+  size_t alloc;\n+  void *vec[1];\n+};\n+\n+/* Ensure there are at least RESERVE free slots in VEC, if RESERVE !=\n+   ~0u. If RESERVE == ~0u increase the current allocation\n+   exponentially.  VEC can be NULL, to create a new vector.  */\n+\n+void *\n+vec_p_reserve (void *vec, size_t reserve)\n+{\n+  return vec_o_reserve (vec, reserve,\n+\t\t\toffsetof (struct vec_prefix, vec), sizeof (void *));\n+}\n+\n+/* Ensure there are at least RESERVE free slots in VEC, if RESERVE !=\n+   ~0u.  If RESERVE == ~0u, increase the current allocation\n+   exponentially.  VEC can be NULL, in which case a new vector is\n+   created.  The vector's trailing array is at VEC_OFFSET offset and\n+   consistes of ELT_SIZE sized elements.  */\n+\n+void *\n+vec_o_reserve (void *vec, size_t reserve, size_t vec_offset, size_t elt_size)\n+{\n+  struct vec_prefix *pfx = vec;\n+  size_t alloc;\n+\n+  if (reserve + 1)\n+    alloc = (pfx ? pfx->num : 0) + reserve;\n+  else\n+    alloc = pfx ? pfx->alloc * 2 : 4;\n+  \n+  if (!pfx || pfx->alloc < alloc)\n+    {\n+      vec = ggc_realloc (vec, vec_offset + alloc * elt_size);\n+      ((struct vec_prefix *)vec)->alloc = alloc;\n+      if (!pfx)\n+\t((struct vec_prefix *)vec)->num = 0;\n+    }\n+  \n+  return vec;\n+}\n+\n+/* Allocate a structure which contains a vector as a trailing element.\n+   The vector is at STRUCT_OFFSET offset within the struct and the\n+   vector's array is at VEC_OFFSET offset within the vector.  */\n+\n+void *\n+vec_embedded_alloc (size_t struct_offset, size_t vec_offset,\n+\t\t    size_t elt_size, size_t reserve)\n+{\n+  void *ptr = ggc_alloc (struct_offset + vec_offset + elt_size * reserve);\n+  struct vec_prefix *pfx = (struct vec_prefix *)((char *)ptr + struct_offset);\n+\n+  pfx->num = 0;\n+  pfx->alloc = reserve;\n+\n+  return ptr;\n+}\n+\n+#if ENABLE_CHECKING\n+/* Issue a vector domain error, and then fall over.  */\n+\n+void\n+vec_assert_fail (const char *op, const char *struct_name,\n+\t\t const char *file, size_t line, const char *function)\n+{\n+  internal_error (\"vector %s %s domain error, in %s at %s:%u\",\n+\t\t  struct_name, op, function, function,\n+\t\t  trim_filename (file), line);\n+}\n+#endif"}, {"sha": "42d1c1f631006522b9a4a3856f7df235e5a3b818", "filename": "gcc/vec.h", "status": "added", "additions": 567, "deletions": 0, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada5515102b96672d758a0263e6d16584ad8f58c/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=ada5515102b96672d758a0263e6d16584ad8f58c", "patch": "@@ -0,0 +1,567 @@\n+/* Vector API for GNU compiler.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Nathan Sidwell <nathan@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_VEC_H\n+#define GCC_VEC_H\n+\n+/* The macros here implement a set of templated vector types and\n+   associated interfaces.  These templates are implemented with\n+   macros, as we're not in C++ land.  The interface functions are\n+   typesafe and use static inline functions, sometimes backed by\n+   out-of-line generic functions.  The vectors are designed to\n+   interoperate with the GTY machinery.\n+\n+   Because of the different behaviour of objects and of pointers to\n+   objects, there are two flavours.  One to deal with a vector of\n+   pointers to objects, and one to deal with a vector of objects\n+   themselves.  Both of these pass pointers to objects around -- in\n+   the former case the pointers are stored into the vector and in the\n+   latter case the pointers are dereferenced and the objects copied\n+   into the vector.  Therefore, when using a vector of pointers, the\n+   objects pointed to must be long lived, but when dealing with a\n+   vector of objects, the source objects need not be.\n+\n+   The vectors are implemented using the trailing array idiom, thus\n+   they are not resizeable without changing the address of the vector\n+   object itself.  This means you cannot have variables or fields of\n+   vector type -- always use a pointer to a vector.  The one exception\n+   is the final field of a structure, which could be a vector type.\n+   You will have to use the embedded_alloc call to create such\n+   objects, and they will probably not be resizeable (so don't use the\n+   'safe' allocation variants).  The trailing array idiom is used\n+   (rather than a pointer to an array of data), because, if we allow\n+   NULL to also represent an empty vector, empty vectors occupy\n+   minimal space in the structure containing them.\n+\n+   Each operation that increases the number of active elements is\n+   available in 'quick' and 'safe' variants.  The former presumes that\n+   there is sufficient allocated space for the operation to succeed\n+   (it aborts if there is not).  The latter will reallocate the\n+   vector, if needed.  Reallocation causes an exponential increase in\n+   vector size.  If you know you will be adding N elements, it would\n+   be more efficient to use the reserve operation before adding the\n+   elements with the 'quick' operation.\n+\n+   You should prefer the push and pop operations, as they append and\n+   remove from the end of the vector.  The insert and remove\n+   operations allow you to change elements in the middle of the\n+   vector.  There are two remove operations, one which preserves the\n+   element ordering 'ordered_remove', and one which does not\n+   'unordered_remove'.  The latter function copies the end element\n+   into the removed slot, rather than invoke a memmove operation.\n+   \n+   Vector types are defined using a DEF_VEC_x(TYPEDEF) macro, and\n+   variables of vector type are declared using a VEC(TYPEDEF)\n+   macro. The 'x' letter indicates whether TYPEDEF is a pointer (P) or\n+   object (O) type.\n+\n+   An example of their use would be,\n+\n+   DEF_VEC_P(tree);\t// define a vector of tree pointers.  This must\n+   \t\t\t// appear at file scope.\n+\n+   struct my_struct {\n+     VEC(tree) *v;      // A (pointer to) a vector of tree pointers.\n+   };\n+\n+   struct my_struct *s;\n+\n+   if (VEC_length(tree,s)) { we have some contents }\n+   VEC_safe_push(tree,s,decl); // append some decl onto the end\n+   for (ix = 0; (t = VEC_iterate(tree,s,ix)); ix++)\n+     { do something with t }\n+\n+*/\n+\n+/* Macros to invoke API calls.  A single macro works for both pointer\n+   and object vectors, but the argument and return types might well be\n+   different.  In each macro, TDEF is the typedef of the vector\n+   elements.  Some of these macros pass the vector, V, by reference\n+   (by taking its address), this is noted in the descriptions.  */\n+\n+/* Length of vector\n+   size_t VEC_T_length(const VEC(T) *v);\n+\n+   Return the number of active elements in V.  V can be NULL, in which\n+   case zero is returned.  */\n+#define VEC_length(TDEF,V)\t\t(VEC_OP(TDEF,length)(V))\n+\n+/* Get the final element of the vector.\n+   T VEC_T_last(VEC(T) *v); // Pointer\n+   T *VEC_T_last(VEC(T) *v); // Object\n+\n+   Return the final element.  If V is empty,  abort.  */\n+#define VEC_last(TDEF,V)\t\t(VEC_OP(TDEF,last)(V))\n+\n+/* Index into vector\n+   T VEC_T_index(VEC(T) *v, size_t ix); // Pointer\n+   T *VEC_T_index(VEC(T) *v, size_t ix); // Object\n+\n+   Return the IX'th element.  If IX is outside the domain of V,\n+   abort.  */\n+#define VEC_index(TDEF,V,I)\t\t(VEC_OP(TDEF,index)(V,I))\n+\n+/* Iterate over vector\n+   T VEC_T_index(VEC(T) *v, size_t ix); // Pointer\n+   T *VEC_T_index(VEC(T) *v, size_t ix); // Object\n+\n+   Return the IX'th element or NULL. Use this to iterate over the\n+   elements of a vector as follows,\n+\n+     for (ix = 0; (ptr = VEC_iterate(T,v,ix)); ix++)\n+       continue;  */\n+#define VEC_iterate(TDEF,V,I)\t\t(VEC_OP(TDEF,iterate)(V,I))\n+\n+/* Allocate new vector.\n+   VEC(T) *VEC_T_alloc(size_t reserve);\n+\n+   Allocate a new vector with space for RESERVE objects.  */\n+#define VEC_alloc(TDEF,A)\t\t(VEC_OP(TDEF,alloc)(A))\n+\n+/* Allocate new vector offset within a structure\n+   void *VEC_T_embedded_alloc(size_t offset, size_t reserve);\n+\n+   Allocate a new vector which is at offset OFFSET within a structure,\n+   and with space for RESERVE objects.  Return a pointer to the start\n+   of the structure containing the vector.  Naturally, the vector must\n+   be the last member of the structure.  */\n+#define VEC_embedded_alloc(TDEF,O,A)\t(VEC_OP(TDEF,embedded_alloc)(O,A))\n+\n+/* Reserve space.\n+   void VEC_T_reserve(VEC(T) *&v, size_t reserve);\n+\n+   Ensure that V has at least RESERVE slots available.  Note this can\n+   cause V to be reallocated.  */\n+#define VEC_reserve(TDEF,V,R)\t\t(VEC_OP(TDEF,reserve)(&(V),R))\n+\n+/* Push object with no reallocation\n+   T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n+   T *VEC_T_quick_push (VEC(T) *v, T *obj); // Object\n+   \n+   Push a new element onto the end, returns a pointer to the slot\n+   filled in. For object vectors, the new value can be NULL, in which\n+   case NO initialization is performed.  Aborts if there is\n+   insufficient space in the vector. */\n+#define VEC_quick_push(TDEF,V,O)\t(VEC_OP(TDEF,quick_push)(V,O))\n+\n+/* Push object with reallocation\n+   T *VEC_T_safe_push (VEC(T) *&v, T obj); // Pointer\n+   T *VEC_T_safe_push (VEC(T) *&v, T *obj); // Object\n+   \n+   Push a new element onto the end, returns a pointer to the slot\n+   filled in. For object vectors, the new value can be NULL, in which\n+   case NO initialization is performed.  Reallocates V, if needed.  */\n+#define VEC_safe_push(TDEF,V,O)\t\t(VEC_OP(TDEF,safe_push)(&(V),O))\n+\n+/* Pop element off end\n+   T VEC_T_pop (VEC(T) *v);\t\t// Pointer\n+   void VEC_T_pop (VEC(T) *v);\t\t// Object\n+\n+   Pop the last element off the end. Returns the element popped, for\n+   pointer vectors.  */\n+#define VEC_pop(TDEF,V)\t\t\t(VEC_OP(TDEF,pop)(V))\n+\n+/* Replace element\n+   T VEC_T_replace (VEC(T) *v, size_t ix, T val); // Pointer\n+   T *VEC_T_replace (VEC(T) *v, size_t ix, T *val);  // Object\n+   \n+   Replace the IXth element of V with a new value, VAL.  For pointer\n+   vectors returns the original value. For object vectors returns a\n+   pointer to the new value.  For object vectors the new value can be\n+   NULL, in which case no overwriting of the slot is actually\n+   performed.  */\n+#define VEC_replace(TDEF,V,I,O)\t\t(VEC_OP(TDEF,replace)(V,I,O))\n+\n+/* Insert object with no reallocation\n+   T *VEC_T_quick_insert (VEC(T) *v, size_t ix, T val); // Pointer\n+   T *VEC_T_quick_insert (VEC(T) *v, size_t ix, T *val); // Object\n+   \n+   Insert an element, VAL, at the IXth position of V. Return a pointer\n+   to the slot created.  For vectors of object, the new value can be\n+   NULL, in which case no initialization of the inserted slot takes\n+   place. Aborts if there is insufficient space.  */\n+#define VEC_quick_insert(TDEF,V,I,O)\t(VEC_OP(TDEF,quick_insert)(V,I,O))\n+\n+/* Insert object with reallocation\n+   T *VEC_T_safe_insert (VEC(T) *&v, size_t ix, T val); // Pointer\n+   T *VEC_T_safe_insert (VEC(T) *&v, size_t ix, T *val); // Object\n+   \n+   Insert an element, VAL, at the IXth position of V. Return a pointer\n+   to the slot created.  For vectors of object, the new value can be\n+   NULL, in which case no initialization of the inserted slot takes\n+   place. Reallocate V, if necessary.  */\n+#define VEC_safe_insert(TDEF,V,I,O)\t(VEC_OP(TDEF,safe_insert)(&(V),I,O))\n+     \n+/* Remove element retaining order\n+   T VEC_T_ordered_remove (VEC(T) *v, size_t ix); // Pointer\n+   void VEC_T_ordered_remove (VEC(T) *v, size_t ix); // Object\n+   \n+   Remove an element from the IXth position of V. Ordering of\n+   remaining elements is preserverd.  For pointer vectors returns the\n+   removed object.  This is an O(N) operation due to a memmove.  */\n+#define VEC_ordered_remove(TDEF,V,I)\t(VEC_OP(TDEF,ordered_remove)(V,I))\n+\n+/* Remove element destroying order\n+   T VEC_T_unordered_remove (VEC(T) *v, size_t ix); // Pointer\n+   void VEC_T_unordered_remove (VEC(T) *v, size_t ix); // Object\n+   \n+   Remove an element from the IXth position of V. Ordering of\n+   remaining elements is destroyed.  For pointer vectors returns the\n+   removed object.  This is an O(1) operation.  */\n+#define VEC_unordered_remove(TDEF,V,I)\t(VEC_OP(TDEF,unordered_remove)(V,I))\n+\n+#if !IN_GENGTYPE\n+#include \"auto-host.h\"\n+\n+/* Reallocate an array of elements with prefix.  */\n+extern void *vec_p_reserve (void *, size_t);\n+extern void *vec_o_reserve (void *, size_t, size_t, size_t);\n+extern void *vec_embedded_alloc (size_t, size_t, size_t, size_t);\n+\n+#if ENABLE_CHECKING\n+extern void vec_assert_fail (const char *, const char *,\n+\t\t\t    const char *, size_t, const char *)\n+     ATTRIBUTE_NORETURN;\n+#define VEC_ASSERT_FAIL(OP,VEC) \\\n+  vec_assert_fail (OP,#VEC,__FILE__,__LINE__,__FUNCTION__)\n+     \n+#define VEC_ASSERT(EXPR,OP,TDEF) \\\n+  (void)((EXPR) ? 0 : (VEC_ASSERT_FAIL(OP,VEC(TDEF)), 0))\n+#else\n+#define VEC_ASSERT(EXPR,OP,TYPE) (void)(EXPR)\n+#endif\n+\n+#define VEC(TDEF) VEC_##TDEF\n+#define VEC_OP(TDEF,OP) VEC_OP_(VEC(TDEF),OP)\n+#define VEC_OP_(VEC,OP) VEC_OP__(VEC,OP)\n+#define VEC_OP__(VEC,OP) VEC ## _ ## OP\n+#else  /* IN_GENGTYPE */\n+#define VEC(TDEF) VEC_ TDEF\n+#define VEC_STRINGIFY(X) VEC_STRINGIFY_(X)\n+#define VEC_STRINGIFY_(X) #X\n+#undef GTY\n+#endif /* IN_GENGTYPE */\n+\n+#define VEC_TDEF(TDEF)\t\t\t\t\t\t\t  \\\n+typedef struct VEC (TDEF) GTY(())\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  size_t num;\t\t\t\t\t\t\t\t  \\\n+  size_t alloc;\t\t\t\t\t\t\t\t  \\\n+  TDEF GTY ((length (\"%h.num\"))) vec[1];\t\t\t\t  \\\n+} VEC (TDEF)\n+\n+/* Vector of pointer to object.  */\n+#if IN_GENGTYPE\n+{\"DEF_VEC_P\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n+#else\n+  \n+#define DEF_VEC_P(TDEF)\t\t\t\t\t\t\t  \\\n+VEC_TDEF (TDEF);\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline size_t VEC_OP (TDEF,length)\t\t\t\t  \\\n+     (const VEC (TDEF) *vec_) \t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF VEC_OP (TDEF,last)\t\t\t\t\t  \\\n+     (const VEC (TDEF) *vec_)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_ && vec_->num, \"last\", TDEF);\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return vec_->vec[vec->num - 1];\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF VEC_OP (TDEF,index)\t\t\t\t\t  \\\n+     (const VEC (TDEF) *vec_, size_t ix_)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", TDEF);\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return vec_->vec[ix_];\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF VEC_OP (TDEF,iterate)\t\t  \t     \t  \\\n+     (const VEC (TDEF) *vec_, size_t ix_)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ && ix_ < vec_->num ? vec_->vec[ix_] : NULL;\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline VEC (TDEF) *VEC_OP (TDEF,alloc)\t\t       \t\t  \\\n+     (size_t alloc_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_p_reserve (NULL, alloc_ - !alloc_);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void *VEC_OP (TDEF,embedded_alloc)\t\t\t  \\\n+     (size_t offset_, size_t alloc_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_embedded_alloc (offset_, offsetof (VEC(TDEF),vec),\t\t  \\\n+\t\t\t     sizeof (TDEF), alloc_);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,reserve)\t       \t\t\t  \\\n+     (VEC (TDEF) **vec_, size_t alloc_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  *vec_ = vec_p_reserve (*vec_, alloc_);\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, TDEF obj_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", TDEF);\t\t\t  \\\n+  slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n+  *slot_ = obj_;\t\t\t\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return slot_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n+     (VEC (TDEF) **vec_, TDEF obj_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~0u);\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_)\t\t\t       \t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF obj_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num, \"pop\", TDEF);\t\t\t\t\t  \\\n+  obj_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return obj_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF VEC_OP (TDEF,replace)\t\t  \t     \t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, TDEF obj_)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF old_obj_;\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"replace\", TDEF);\t\t\t  \\\n+  old_obj_ = vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  vec_->vec[ix_] = obj_;\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return old_obj_;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t     \t  \t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, TDEF obj_)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (ix_ <= vec_->num, \"insert\", TDEF);\t\t\t  \\\n+  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  memmove (slot_ + 1, slot_, vec_->num++ - ix_);\t\t\t  \\\n+  *slot_ = obj_;\t\t\t\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return slot_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n+     (VEC (TDEF) **vec_, size_t ix_, TDEF obj_)       \t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~0u);\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  TDEF obj_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n+  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  obj_ = *slot_;\t\t\t\t\t\t\t  \\\n+  memmove (slot_, slot_ + 1, --vec_->num - ix_);       \t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return obj_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  TDEF obj_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n+  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  obj_ = *slot_;\t\t\t\t\t\t\t  \\\n+  *slot_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return obj_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#endif\n+\n+/* Vector of object.  */\n+#if IN_GENGTYPE\n+{\"DEF_VEC_O\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n+#else\n+  \n+#define DEF_VEC_O(TDEF)\t\t\t\t\t\t\t  \\\n+VEC_TDEF (TDEF);\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline size_t VEC_OP (TDEF,length)\t\t\t\t  \\\n+     (const VEC (TDEF) *vec_) \t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,last)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_ && vec_->num, \"last\", TDEF);\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return &vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,index)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", TDEF);\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,iterate)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ && ix_ < vec_->num ? &vec_->vec[ix_] : NULL;\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline VEC (TDEF) *VEC_OP (TDEF,alloc)      \t\t\t  \\\n+     (size_t alloc_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_o_reserve (NULL, alloc_ - !alloc_,\t\t\t\t  \\\n+\t\t\toffsetof (VEC(TDEF),vec), sizeof (TDEF));\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void *VEC_OP (TDEF,embedded_alloc)\t\t\t  \\\n+     (size_t offset_, size_t alloc_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_embedded_alloc (offset_, offsetof (VEC(TDEF),vec),\t\t  \\\n+\t\t\t     sizeof (TDEF), alloc_);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,reserve)\t       \t\t\t  \\\n+     (VEC (TDEF) **vec_, size_t alloc_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  *vec_ = vec_o_reserve (*vec_, alloc_,\t\t\t\t\t  \\\n+\t\t\t offsetof (VEC(TDEF),vec), sizeof (TDEF));\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, const TDEF *obj_)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", TDEF);\t\t\t  \\\n+  slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n+  if (obj_)\t\t\t\t\t\t\t\t  \\\n+    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return slot_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n+     (VEC (TDEF) **vec_, const TDEF *obj_)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~0u);\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num, \"pop\", TDEF);\t\t\t\t\t  \\\n+  vec_->vec[--vec_->num];\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,replace)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, const TDEF *obj_)\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"replace\", TDEF);\t\t\t  \\\n+  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  if (obj_)\t\t\t\t\t\t\t\t  \\\n+    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return slot_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, const TDEF *obj_)\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", TDEF);\t\t\t  \\\n+  VEC_ASSERT (ix_ <= vec_->num, \"insert\", TDEF);\t\t\t  \\\n+  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  memmove (slot_ + 1, slot_, vec_->num++ - ix_);\t\t\t  \\\n+  if (obj_)\t\t\t\t\t\t\t\t  \\\n+    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n+  \t\t\t\t\t\t\t\t\t  \\\n+  return slot_;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n+     (VEC (TDEF) **vec_, size_t ix_, const TDEF *obj_)\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~0u);\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n+  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+  memmove (slot_, slot_ + 1, --vec_->num - ix_);       \t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n+  vec_->vec[ix_] = vec_->vec[--vec_->num];\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#endif\n+\n+#endif /* GCC_VEC_H */"}]}