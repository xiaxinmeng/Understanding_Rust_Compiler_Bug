{"sha": "59075bc80894016c6f7fbf4b52bcd678601fce14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwNzViYzgwODk0MDE2YzZmN2ZiZjRiNTJiY2Q2Nzg2MDFmY2UxNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-05-30T07:16:31Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-05-30T07:16:31Z"}, "message": "Compare predictor values with these defined in predict.def.\n\n2017-05-30  Martin Liska  <mliska@suse.cz>\n\n\t* analyze_brprob.py: Add new argument to parse and modify\n\tpredict.def file.\n\t* analyze_brprob_spec.py: Likewise.\n\nFrom-SVN: r248600", "tree": {"sha": "ecd603e749dd6ccba367799fb55aada072d1af15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd603e749dd6ccba367799fb55aada072d1af15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59075bc80894016c6f7fbf4b52bcd678601fce14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59075bc80894016c6f7fbf4b52bcd678601fce14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59075bc80894016c6f7fbf4b52bcd678601fce14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59075bc80894016c6f7fbf4b52bcd678601fce14/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a582436140d3d79d43a5af27ba1601d16e3a51f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a582436140d3d79d43a5af27ba1601d16e3a51f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a582436140d3d79d43a5af27ba1601d16e3a51f8"}], "stats": {"total": 90, "additions": 80, "deletions": 10}, "files": [{"sha": "409f236df8050706848b761258ff1e50e2d7ba16", "filename": "contrib/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59075bc80894016c6f7fbf4b52bcd678601fce14/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59075bc80894016c6f7fbf4b52bcd678601fce14/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=59075bc80894016c6f7fbf4b52bcd678601fce14", "patch": "@@ -1,3 +1,9 @@\n+2017-05-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* analyze_brprob.py: Add new argument to parse and modify\n+\tpredict.def file.\n+\t* analyze_brprob_spec.py: Likewise.\n+\n 2017-05-29  Tom de Vries  <tom@codesourcery.com>\n \n \t* check_GNU_style_lib.py (TrailingWhitespaceCheck.check): Assert no"}, {"sha": "8f83b5a022108e10107744359771766d2f4dda54", "filename": "contrib/analyze_brprob.py", "status": "modified", "additions": 70, "deletions": 10, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59075bc80894016c6f7fbf4b52bcd678601fce14/contrib%2Fanalyze_brprob.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59075bc80894016c6f7fbf4b52bcd678601fce14/contrib%2Fanalyze_brprob.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fanalyze_brprob.py?ref=59075bc80894016c6f7fbf4b52bcd678601fce14", "patch": "@@ -90,6 +90,48 @@ def median(values):\n     values.sort()\n     return values[int(len(values) / 2)]\n \n+class PredictDefFile:\n+    def __init__(self, path):\n+        self.path = path\n+        self.predictors = {}\n+\n+    def parse_and_modify(self, heuristics, write_def_file):\n+        lines = [x.rstrip() for x in open(self.path).readlines()]\n+\n+        p = None\n+        modified_lines = []\n+        for l in lines:\n+            if l.startswith('DEF_PREDICTOR'):\n+                m = re.match('.*\"(.*)\".*', l)\n+                p = m.group(1)\n+            elif l == '':\n+                p = None\n+\n+            if p != None:\n+                heuristic = [x for x in heuristics if x.name == p]\n+                heuristic = heuristic[0] if len(heuristic) == 1 else None\n+\n+                m = re.match('.*HITRATE \\(([^)]*)\\).*', l)\n+                if (m != None):\n+                    self.predictors[p] = int(m.group(1))\n+\n+                    # modify the line\n+                    if heuristic != None:\n+                        new_line = (l[:m.start(1)]\n+                            + str(round(heuristic.get_hitrate()))\n+                            + l[m.end(1):])\n+                        l = new_line\n+                    p = None\n+                elif 'PROB_VERY_LIKELY' in l:\n+                    self.predictors[p] = 100\n+            modified_lines.append(l)\n+\n+        # save the file\n+        if write_def_file:\n+            with open(self.path, 'w+') as f:\n+                for l in modified_lines:\n+                    f.write(l + '\\n')\n+\n class Summary:\n     def __init__(self, name):\n         self.name = name\n@@ -113,15 +155,24 @@ def count_formatted(self):\n             v /= 1000.0\n         return \"%.1f%s\" % (v, 'Y')\n \n-    def print(self, branches_max, count_max):\n+    def print(self, branches_max, count_max, predict_def):\n+        predicted_as = None\n+        if predict_def != None and self.name in predict_def.predictors:\n+            predicted_as = predict_def.predictors[self.name]\n+\n         print('%-40s %8i %5.1f%% %11.2f%% %7.2f%% / %6.2f%% %14i %8s %5.1f%%' %\n             (self.name, self.branches,\n                 percentage(self.branches, branches_max),\n                 self.get_branch_hitrate(),\n                 self.get_hitrate(),\n                 percentage(self.fits, self.count),\n                 self.count, self.count_formatted(),\n-                percentage(self.count, count_max)))\n+                percentage(self.count, count_max)), end = '')\n+\n+        if predicted_as != None:\n+            print('%12i%% %5.1f%%' % (predicted_as,\n+                self.get_hitrate() - predicted_as), end = '')\n+        print()\n \n class Profile:\n     def __init__(self, filename):\n@@ -156,7 +207,7 @@ def branches_max(self):\n     def count_max(self):\n         return max([v.count for k, v in self.heuristics.items()])\n \n-    def print_group(self, sorting, group_name, heuristics):\n+    def print_group(self, sorting, group_name, heuristics, predict_def):\n         count_max = self.count_max()\n         branches_max = self.branches_max()\n \n@@ -170,26 +221,32 @@ def print_group(self, sorting, group_name, heuristics):\n         elif sorting == 'name':\n             sorter = lambda x: x.name.lower()\n \n-        print('%-40s %8s %6s %12s %18s %14s %8s %6s' %\n+        print('%-40s %8s %6s %12s %18s %14s %8s %6s %12s %6s' %\n             ('HEURISTICS', 'BRANCHES', '(REL)',\n-            'BR. HITRATE', 'HITRATE', 'COVERAGE', 'COVERAGE', '(REL)'))\n+            'BR. HITRATE', 'HITRATE', 'COVERAGE', 'COVERAGE', '(REL)',\n+            'predict.def', '(REL)'))\n         for h in sorted(heuristics, key = sorter):\n-            h.print(branches_max, count_max)\n+            h.print(branches_max, count_max, predict_def)\n \n     def dump(self, sorting):\n         heuristics = self.heuristics.values()\n         if len(heuristics) == 0:\n             print('No heuristics available')\n             return\n \n+        predict_def = None\n+        if args.def_file != None:\n+            predict_def = PredictDefFile(args.def_file)\n+            predict_def.parse_and_modify(heuristics, args.write_def_file)\n+\n         special = list(filter(lambda x: x.name in counter_aggregates,\n             heuristics))\n         normal = list(filter(lambda x: x.name not in counter_aggregates,\n             heuristics))\n \n-        self.print_group(sorting, 'HEURISTICS', normal)\n+        self.print_group(sorting, 'HEURISTICS', normal, predict_def)\n         print()\n-        self.print_group(sorting, 'HEURISTIC AGGREGATES', special)\n+        self.print_group(sorting, 'HEURISTIC AGGREGATES', special, predict_def)\n \n         if len(self.niter_vector) > 0:\n             print ('\\nLoop count: %d' % len(self.niter_vector)),\n@@ -206,13 +263,16 @@ def dump(self, sorting):\n parser.add_argument('-s', '--sorting', dest = 'sorting',\n     choices = ['branches', 'branch-hitrate', 'hitrate', 'coverage', 'name'],\n     default = 'branches')\n+parser.add_argument('-d', '--def-file', help = 'path to predict.def')\n+parser.add_argument('-w', '--write-def-file', action = 'store_true',\n+    help = 'Modify predict.def file in order to set new numbers')\n \n args = parser.parse_args()\n \n-profile = Profile(sys.argv[1])\n+profile = Profile(args.dump_file)\n r = re.compile('  (.*) heuristics( of edge [0-9]*->[0-9]*)?( \\\\(.*\\\\))?: (.*)%.*exec ([0-9]*) hit ([0-9]*)')\n loop_niter_str = ';;  profile-based iteration count: '\n-for l in open(args.dump_file).readlines():\n+for l in open(args.dump_file):\n     m = r.match(l)\n     if m != None and m.group(3) == None:\n         name = m.group(1)"}, {"sha": "e621853ba4e24c04582fb54333a24cdae7e3ed76", "filename": "contrib/analyze_brprob_spec.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59075bc80894016c6f7fbf4b52bcd678601fce14/contrib%2Fanalyze_brprob_spec.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59075bc80894016c6f7fbf4b52bcd678601fce14/contrib%2Fanalyze_brprob_spec.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fanalyze_brprob_spec.py?ref=59075bc80894016c6f7fbf4b52bcd678601fce14", "patch": "@@ -30,6 +30,7 @@\n parser.add_argument('-s', '--sorting', dest = 'sorting',\n     choices = ['branches', 'branch-hitrate', 'hitrate', 'coverage', 'name'],\n     default = 'branches')\n+parser.add_argument('-d', '--def-file', help = 'path to predict.def')\n \n args = parser.parse_args()\n \n@@ -56,6 +57,9 @@\n     sys.stdout.flush()\n     p = [os.path.join(os.path.dirname(script_location), 'analyze_brprob.py'),\n         temp.name, '--sorting', args.sorting]\n+    if args.def_file != None:\n+        p += ['-d', args.def_file]\n+\n     p = subprocess.check_call(p)\n     sys.stdout.flush()\n "}]}