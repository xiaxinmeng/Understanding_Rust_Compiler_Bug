{"sha": "174eceea4095a5c49ddae331f80dc79d072702e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0ZWNlZWE0MDk1YTVjNDlkZGFlMzMxZjgwZGM3OWQwNzI3MDJlNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mitchell@dumbledore.codesourcery.com", "date": "2000-01-11T01:55:37Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-11T01:55:37Z"}, "message": "cp-tree.h (BINFO_PRIMARY_MARKED_P): Change definition.\n\n\t* cp-tree.h (BINFO_PRIMARY_MARKED_P): Change definition.\n\t(BINFO_VBASE_PRIMARY_P): New macro.\n\t(BINFO_VIRTUALS): Add to documentation.\n\t(SET_BINFO_PRIMARY_MARKED_P): Remove.\n\t(CLEAR_BINFO_PRIMARY_MARKED_P): Likewise.\n\t(dfs_mark_primary_bases_queue_p): Likewise.\n\t(dfs_unmarked_real_bases_queue_p): New function.\n\t(dfs_marked_real_bases_queue_p): Likewise.\n\t* search.c (dfs_mark_primary_bases): Adjust.\n\t(mark_primary_bases): Likewise.\n\t(get_shared_vbase_if_not_primary): New function.\n\t(dfs_unmarked_real_bases_queue_p): Likewise.\n\t(dfs_marked_real_bases_queue_p): Likewise.\n\t(dfs_get_pure_virtuals): Simplify.\n\t(get_pure_virtuals): Likewise.\n\nFrom-SVN: r31312", "tree": {"sha": "6f301b18ec0563953b27c08351bbf11c47a54fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f301b18ec0563953b27c08351bbf11c47a54fa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174eceea4095a5c49ddae331f80dc79d072702e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174eceea4095a5c49ddae331f80dc79d072702e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174eceea4095a5c49ddae331f80dc79d072702e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174eceea4095a5c49ddae331f80dc79d072702e7/comments", "author": null, "committer": null, "parents": [{"sha": "afc27297c7e3a2fc0a7bd96aef3f25c2b652172f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc27297c7e3a2fc0a7bd96aef3f25c2b652172f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc27297c7e3a2fc0a7bd96aef3f25c2b652172f"}], "stats": {"total": 277, "additions": 228, "deletions": 49}, "files": [{"sha": "c4566981e36dc6d5c8fcafe084bc109bbf531d40", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174eceea4095a5c49ddae331f80dc79d072702e7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174eceea4095a5c49ddae331f80dc79d072702e7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=174eceea4095a5c49ddae331f80dc79d072702e7", "patch": "@@ -1,3 +1,21 @@\n+2000-01-10  Mark Mitchell  <mitchell@dumbledore.codesourcery.com>\n+\n+\t* cp-tree.h (BINFO_PRIMARY_MARKED_P): Change definition.\n+\t(BINFO_VBASE_PRIMARY_P): New macro.\n+\t(BINFO_VIRTUALS): Add to documentation.\n+\t(SET_BINFO_PRIMARY_MARKED_P): Remove.\n+\t(CLEAR_BINFO_PRIMARY_MARKED_P): Likewise.\n+\t(dfs_mark_primary_bases_queue_p): Likewise.\n+\t(dfs_unmarked_real_bases_queue_p): New function.\n+\t(dfs_marked_real_bases_queue_p): Likewise.\n+\t* search.c (dfs_mark_primary_bases): Adjust.\n+\t(mark_primary_bases): Likewise.\n+\t(get_shared_vbase_if_not_primary): New function.\n+\t(dfs_unmarked_real_bases_queue_p): Likewise.\n+\t(dfs_marked_real_bases_queue_p): Likewise.\n+\t(dfs_get_pure_virtuals): Simplify.\n+\t(get_pure_virtuals): Likewise.\n+\t\n 2000-01-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* lex.c: Include tm_p.h."}, {"sha": "269c398166a130eec72ec1cece56915d80376faf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174eceea4095a5c49ddae331f80dc79d072702e7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174eceea4095a5c49ddae331f80dc79d072702e7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=174eceea4095a5c49ddae331f80dc79d072702e7", "patch": "@@ -72,8 +72,8 @@ Boston, MA 02111-1307, USA.  */\n           or FIELD_DECL).\n       NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)\n       SCOPE_PARTIAL_P (in SCOPE_STMT)\n-   5: Not used.\n-   6: Not used.\n+   5: BINFO_PRIMARY_MARKED_P (in BINFO)\n+   6: BINFO_VBASE_PRIMARY_P (in BINFO)\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: C_TYPE_FIELDS_READONLY (in RECORD_TYPE or UNION_TYPE).\n@@ -117,10 +117,13 @@ Boston, MA 02111-1307, USA.  */\n    BINFO_VIRTUALS\n      For a binfo, this is a TREE_LIST.  The TREE_PURPOSE of each node\n      gives the amount by which to adjust the `this' pointer when\n-     calling the function.  The TREE_VALUE is the declaration for the \n-     virtual function itself.  When CLASSTYPE_COM_INTERFACE_P does not\n-     hold, the first entry does not have a TREE_VALUE; it is just an\n-     offset.\n+     calling the function.  If the method is an overriden version of a\n+     base class method, then it is assumed that, prior to adjustment,\n+     the this pointer points to an object of the base class.\n+\n+     The TREE_VALUE is the declaration for the virtual function\n+     itself.  When CLASSTYPE_COM_INTERFACE_P does not hold, the first\n+     entry does not have a TREE_VALUE; it is just an offset.\n \n    DECL_ARGUMENTS\n      For a VAR_DECL this is DECL_ANON_UNION_ELEMS.  */\n@@ -1572,23 +1575,33 @@ struct lang_type\n #define SET_BINFO_PUSHDECLS_MARKED(NODE) SET_BINFO_VTABLE_PATH_MARKED (NODE)\n #define CLEAR_BINFO_PUSHDECLS_MARKED(NODE) CLEAR_BINFO_VTABLE_PATH_MARKED (NODE)\n \n-/* Nonzero if this BINFO has been marked as a primary base class.  */\n-#define BINFO_PRIMARY_MARKED_P(NODE)\t\t\\\n-  (TREE_VIA_VIRTUAL (NODE) \t\t\t\\\n-   ? CLASSTYPE_MARKED5 (BINFO_TYPE (NODE))\t\\\n-   : TREE_LANG_FLAG_5 (NODE))\n+/* Nonzero if this BINFO is a primary base class.\n+\n+   In the TYPE_BINFO hierarchy, this flag is never set for a base\n+   class of a non-primary virtual base because the copies of a\n+   non-primary virtual base that appear in the TYPE_BINFO hierarchy do\n+   not really exist.  Instead, it is the BINFOs in the\n+   CLASSTYPE_VBASECLASSES list that are used.  In other words, this\n+   flag is only valid for paths (given by BINFO_INHERITANCE_CHAIN)\n+   that really exist in the final object.  \n+\n+   For example, consider:\n+\n+      struct A {};\n+      struct B : public A { };\n+      struct C : virtual public B { void f(); };\n \n-/* Mark NODE as a primary base class.  */\n-#define SET_BINFO_PRIMARY_MARKED_P(NODE)\t\\\n-  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n-   ? SET_CLASSTYPE_MARKED5 (BINFO_TYPE (NODE))\t\\\n-   : (TREE_LANG_FLAG_5 (NODE) = 1))\n+   `A' is the primary base class for `B'.  But, `B' is not a primary\n+   base class for `C'.  So, in the copy of `A' that appears in the\n+   TYPE_BINFO hierarcy for `C' does not have BINFO_PRIMARY_MARKED_P\n+   set; the copy in the CLASSTYPE_VBASECLASSES list does have this\n+   set.  */\n+#define BINFO_PRIMARY_MARKED_P(NODE) TREE_LANG_FLAG_5 (NODE)\n \n-/* Clear the primary base class mark.  */\n-#define CLEAR_BINFO_PRIMARY_MARKED_P(NODE) \t\t\\\n-  (TREE_VIA_VIRTUAL (NODE)\t\t\t\t\\\n-   ? CLEAR_CLASSTYPE_MARKED5 (BINFO_TYPE (NODE))\t\\\n-   : (TREE_LANG_FLAG_5 (NODE) = 0))\n+/* Nonzero if the virtual baseclass with the type given by this BINFO\n+   is primary *somewhere* in the hierarchy.  This flag is only set on \n+   entries in the CLASSTYPE_VBASECLASSES list.  */\n+#define BINFO_VBASE_PRIMARY_P(NODE) TREE_LANG_FLAG_6 (NODE)\n \n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n@@ -3937,7 +3950,10 @@ extern tree dfs_unmark                          PROTO((tree, void *));\n extern tree dfs_vbase_unmark                    PROTO((tree, void *));\n extern tree markedp                             PROTO((tree, void *));\n extern tree unmarkedp                           PROTO((tree, void *));\n-extern tree dfs_mark_primary_bases_queue_p      PROTO((tree, void *));\n+extern tree dfs_skip_nonprimary_vbases_unmarkedp PROTO((tree, void *));\n+extern tree dfs_skip_nonprimary_vbases_markedp  PROTO((tree, void *));\n+extern tree dfs_unmarked_real_bases_queue_p     PROTO((tree, void *));\n+extern tree dfs_marked_real_bases_queue_p       PROTO((tree, void *));\n extern void mark_primary_bases                  PROTO((tree));\n \n /* in semantics.c */"}, {"sha": "0637376b28017f2ea5f9c95b5d24157b84e16fd1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 172, "deletions": 27, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174eceea4095a5c49ddae331f80dc79d072702e7/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174eceea4095a5c49ddae331f80dc79d072702e7/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=174eceea4095a5c49ddae331f80dc79d072702e7", "patch": "@@ -151,6 +151,7 @@ static void setup_class_bindings PROTO ((tree, int));\n static int template_self_reference_p PROTO ((tree, tree));\n static void fixup_all_virtual_upcast_offsets PROTO ((tree, tree));\n static tree dfs_mark_primary_bases PROTO((tree, void *));\n+static tree get_shared_vbase_if_not_primary PROTO((tree, tree));\n \n /* Allocate a level of searching.  */\n \n@@ -2111,22 +2112,71 @@ get_matching_virtual (binfo, fndecl, dtorp)\n     }\n }\n \n+/* A queue function for dfs_walk that skips any nonprimary virtual\n+   bases and any already marked bases.  */\n+\n+tree\n+dfs_skip_nonprimary_vbases_unmarkedp (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+    /* This is a non-primary virtual base.  SKip it.  */\n+    return NULL_TREE;\n+\n+  return unmarkedp (binfo, NULL);\n+}\n+\n+/* A queue function for dfs_walk that skips any nonprimary virtual\n+   bases and any unmarked bases.  */\n+\n+tree\n+dfs_skip_nonprimary_vbases_markedp (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+    /* This is a non-primary virtual base.  SKip it.  */\n+    return NULL_TREE;\n+\n+  return markedp (binfo, NULL);\n+}\n+\n /* Called via dfs_walk from mark_primary_bases.  */\n \n static tree\n dfs_mark_primary_bases (binfo, data)\n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n {\n-  if (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+  int i;\n+  tree base_binfo;\n+\n+  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+    return NULL_TREE;\n+\n+  i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+  base_binfo = BINFO_BASETYPE (binfo, i);\n+\n+  if (!TREE_VIA_VIRTUAL (base_binfo))\n+    /* Non-virtual base classes are easy.  */\n+    BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n+  else\n     {\n-      int i;\n+      tree shared_binfo;\n \n-      i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      SET_BINFO_PRIMARY_MARKED_P (BINFO_BASETYPE (binfo, i));\n-    }\n+      shared_binfo \n+\t= BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), (tree) data);\n \n-  SET_BINFO_MARKED (binfo);\n+      /* If this virtual base is not already primary somewhere else in\n+\t the hiearchy, then we'll be using this copy.  */\n+      if (!BINFO_VBASE_PRIMARY_P (shared_binfo)\n+\t  && !BINFO_VBASE_MARKED (shared_binfo))\n+\t{\n+\t  BINFO_VBASE_PRIMARY_P (shared_binfo) = 1;\n+\t  BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n+\t}\n+    }\n \n   return NULL_TREE;\n }\n@@ -2138,8 +2188,106 @@ void\n mark_primary_bases (type)\n      tree type;\n {\n-  dfs_walk (TYPE_BINFO (type), dfs_mark_primary_bases, unmarkedp, NULL);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, NULL);\n+  tree vbase;\n+\n+  /* Mark the TYPE_BINFO hierarchy.  */\n+  dfs_walk (TYPE_BINFO (type), dfs_mark_primary_bases, \n+\t    dfs_skip_nonprimary_vbases_unmarkedp, type);\n+\n+  /* Now go through the virtual base classes.  Any that are not\n+     already primary will need to be allocated in TYPE, and so we need\n+     to mark their primary bases.  */\n+  for (vbase = CLASSTYPE_VBASECLASSES (type); \n+       vbase; \n+       vbase = TREE_CHAIN (vbase))\n+    {\n+      if (BINFO_VBASE_PRIMARY_P (vbase))\n+\t/* This virtual base was already included in the hierarchy, so\n+\t   there's nothing to do here.  */\n+\tcontinue;\n+\n+      /* Temporarily pretend that VBASE is primary so that its bases\n+\t will be walked; this is the real copy of VBASE.  */\n+      BINFO_PRIMARY_MARKED_P (vbase) = 1;\n+\n+      /* Now, walk its bases.  */\n+      dfs_walk (vbase, dfs_mark_primary_bases,\n+\t\tdfs_skip_nonprimary_vbases_unmarkedp, type);\n+\n+      /* VBASE wasn't really primary.  */\n+      BINFO_PRIMARY_MARKED_P (vbase) = 0;\n+      /* And we don't want to allow it to *become* primary if it is a\n+\t base of some subsequent base class.  */\n+      SET_BINFO_VBASE_MARKED (vbase);\n+    }\n+\n+  /* Clear the VBASE_MARKED bits we set above.  */\n+  for (vbase = CLASSTYPE_VBASECLASSES (type); \n+       vbase; \n+       vbase = TREE_CHAIN (vbase))\n+    CLEAR_BINFO_VBASE_MARKED (vbase);\n+}\n+\n+/* If BINFO is a non-primary virtual baseclass (in the hierarchy\n+   dominated by TYPE), and no primary copy appears anywhere in the\n+   hierarchy, return the shared copy.  If a primary copy appears\n+   elsewhere, return NULL_TREE.  Otherwise, return BINFO itself; it is\n+   either a non-virtual base or a primary virtual base.  */\n+\n+static tree\n+get_shared_vbase_if_not_primary (binfo, type)\n+     tree binfo;\n+     tree type;\n+{\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+    {\n+      /* This is a non-primary virtual base.  If there is no primary\n+\t version, get the shared version.  */\n+      binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), type);\n+      if (BINFO_VBASE_PRIMARY_P (binfo))\n+\treturn NULL_TREE;\n+    }\n+\n+  return binfo;\n+}\n+\n+/* A queue function to use with dfs_walk that prevents travel into any\n+   nonprimary virtual base, or its baseclasses.  DATA should be the\n+   type of the complete object, or a TREE_LIST whose TREE_PURPOSE is\n+   the type of the complete object.  By using this function as a queue\n+   function, you will walk over exactly those BINFOs that actually\n+   exist in the complete object, including those for virtual base\n+   classes.  If you SET_BINFO_MARKED for each binfo you process, you\n+   are further guaranteed that you will walk into each virtual base\n+   class exactly once.  */\n+\n+tree\n+dfs_unmarked_real_bases_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree type = (tree) data;\n+\n+  if (TREE_CODE (type) == TREE_LIST)\n+    type = TREE_PURPOSE (type);\n+  binfo = get_shared_vbase_if_not_primary (binfo, type); \n+  return binfo ? unmarkedp (binfo, NULL) : NULL_TREE;\n+}\n+\n+/* Like dfs_unmarked_real_bases_queue_p but walks only into things\n+   that are marked, rather than unmarked.  */\n+\n+tree\n+dfs_marked_real_bases_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree type = (tree) data;\n+\n+  if (TREE_CODE (type) == TREE_LIST)\n+    type = TREE_PURPOSE (type);\n+  binfo = get_shared_vbase_if_not_primary (binfo, type);\n+  return binfo ? markedp (binfo, NULL) : NULL_TREE;\n }\n \n /* Called via dfs_walk from dfs_get_pure_virtuals.  */\n@@ -2149,25 +2297,17 @@ dfs_get_pure_virtuals (binfo, data)\n      tree binfo;\n      void *data;\n {\n+  tree type = (tree) data;\n+\n   /* We're not interested in primary base classes; the derived class\n      of which they are a primary base will contain the information we\n      need.  */\n   if (!BINFO_PRIMARY_MARKED_P (binfo))\n     {\n-      tree type = (tree) data;\n-      tree shared_binfo;\n       tree virtuals;\n       \n-      /* If this is a virtual base class, then use the shared binfo\n-\t since that is the only place where BINFO_VIRTUALS is valid;\n-\t the various copies in the main hierarchy are not updated when\n-\t vtables are created.  */\n-      shared_binfo = (TREE_VIA_VIRTUAL (binfo) \n-\t\t      ? BINFO_FOR_VBASE (BINFO_TYPE (binfo), type)\n-\t\t      : binfo);\n-\n-      for (virtuals = skip_rtti_stuff (shared_binfo, \n-\t\t\t\t       BINFO_TYPE (shared_binfo), \n+      for (virtuals = skip_rtti_stuff (binfo, \n+\t\t\t\t       BINFO_TYPE (binfo), \n \t\t\t\t       NULL);\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n@@ -2199,22 +2339,27 @@ get_pure_virtuals (type)\n      (A primary base is not interesting because the derived class of\n      which it is a primary base will contain vtable entries for the\n      pure virtuals in the base class.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, unmarkedp, type);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, 0);\n+  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, \n+\t    dfs_unmarked_real_bases_queue_p, type);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark, \n+\t    dfs_marked_real_bases_queue_p, type);\n \n   /* Put the pure virtuals in dfs order.  */\n   CLASSTYPE_PURE_VIRTUALS (type) = nreverse (CLASSTYPE_PURE_VIRTUALS (type));\n \n-  for (vbases = CLASSTYPE_VBASECLASSES (type); vbases; vbases = TREE_CHAIN (vbases))\n+  for (vbases = CLASSTYPE_VBASECLASSES (type); \n+       vbases; \n+       vbases = TREE_CHAIN (vbases))\n     {\n-      tree virtuals = skip_rtti_stuff (vbases, BINFO_TYPE (vbases), NULL);\n+      tree virtuals;\n \n-      while (virtuals)\n+      for (virtuals = skip_rtti_stuff (vbases, BINFO_TYPE (vbases), NULL);\n+\t   virtuals;\n+\t   virtuals = TREE_CHAIN (virtuals))\n \t{\n \t  tree base_fndecl = TREE_VALUE (virtuals);\n \t  if (DECL_NEEDS_FINAL_OVERRIDER_P (base_fndecl))\n \t    cp_error (\"`%#D' needs a final overrider\", base_fndecl);\n-\t  virtuals = TREE_CHAIN (virtuals);\n \t}\n     }\n }"}]}