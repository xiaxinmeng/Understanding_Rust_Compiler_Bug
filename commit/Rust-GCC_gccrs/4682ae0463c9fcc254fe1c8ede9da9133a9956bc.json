{"sha": "4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY4MmFlMDQ2M2M5ZmNjMjU0ZmUxYzhlZGU5ZGE5MTMzYTk5NTZiYw==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-15T13:43:32Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-15T13:43:32Z"}, "message": "alloc-pool.c: Convert to ISO C90 prototypes.\n\n\n\t* alloc-pool.c: Convert to ISO C90 prototypes.\n\t* alloc-pool.h: Likewise.\n\t* alias.c: Likewise.\n\t* attribs.c: Likewise.\n\t* bb-reorder.c: Likewise.\n\t* bitmap.h: Likewise.\n\t* bitmap.c: Likewise.\n\t* builtins.c: Likewise.\n\n\t* tree.h: Convert prototypes of attribs.c to ISO C90.\n\t* basic-block.h: Convert prototypes of bb-reorder.c to ISO C90.\n\t* rtl.h: Convert prototypes of alias.c and builtins.c to ISO C90.\n\t* expr.h: Convert prototypes of builtins.c to ISO C90.\n\nFrom-SVN: r67975", "tree": {"sha": "011c105664290fc65aee6e952c836e52aa84f722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/011c105664290fc65aee6e952c836e52aa84f722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbdb4ba2dcf013c9ee4b1f28182596ab9ae135c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbdb4ba2dcf013c9ee4b1f28182596ab9ae135c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbdb4ba2dcf013c9ee4b1f28182596ab9ae135c5"}], "stats": {"total": 1116, "additions": 404, "deletions": 712}, "files": [{"sha": "56d54267f61fa3f79dc0b848090bfee8fc7621b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -1,3 +1,19 @@\n+2003-06-15  Andreas Jaeger  <aj@suse.de>\n+\n+\t* alloc-pool.c: Convert to ISO C90 prototypes.\n+\t* alloc-pool.h: Likewise.\n+\t* alias.c: Likewise.\n+\t* attribs.c: Likewise.\n+\t* bb-reorder.c: Likewise.\n+\t* bitmap.h: Likewise.\n+\t* bitmap.c: Likewise.\n+\t* builtins.c: Likewise.\n+\n+\t* tree.h: Convert prototypes of attribs.c to ISO C90.\n+\t* basic-block.h: Convert prototypes of bb-reorder.c to ISO C90.\n+\t* rtl.h: Convert prototypes of alias.c and builtins.c to ISO C90.\n+\t* expr.h: Convert prototypes of builtins.c to ISO C90.\n+\n 2003-06-15  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.md (expsf2, expdf2, expxf2): New patterns to"}, {"sha": "a7a51188d09e9b5b79cc9576fbbb92da6d27e852", "filename": "gcc/alias.c", "status": "modified", "additions": 86, "deletions": 153, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -92,35 +92,34 @@ typedef struct alias_set_entry\n   int has_zero_child;\n } *alias_set_entry;\n \n-static int rtx_equal_for_memref_p\tPARAMS ((rtx, rtx));\n-static rtx find_symbolic_term\t\tPARAMS ((rtx));\n-rtx get_addr\t\t\t\tPARAMS ((rtx));\n-static int memrefs_conflict_p\t\tPARAMS ((int, rtx, int, rtx,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n-static void record_set\t\t\tPARAMS ((rtx, rtx, void *));\n-static int base_alias_check\t\tPARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx find_base_value\t\tPARAMS ((rtx));\n-static int mems_in_disjoint_alias_sets_p PARAMS ((rtx, rtx));\n-static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n-static tree find_base_decl\t\tPARAMS ((tree));\n-static alias_set_entry get_alias_set_entry PARAMS ((HOST_WIDE_INT));\n-static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t\t\t      int (*) (rtx, int)));\n-static int aliases_everything_p         PARAMS ((rtx));\n-static bool nonoverlapping_component_refs_p PARAMS ((tree, tree));\n-static tree decl_for_component_ref\tPARAMS ((tree));\n-static rtx adjust_offset_for_component_ref PARAMS ((tree, rtx));\n-static int nonoverlapping_memrefs_p\tPARAMS ((rtx, rtx));\n-static int write_dependence_p           PARAMS ((rtx, rtx, int));\n-\n-static int nonlocal_mentioned_p_1       PARAMS ((rtx *, void *));\n-static int nonlocal_mentioned_p         PARAMS ((rtx));\n-static int nonlocal_referenced_p_1      PARAMS ((rtx *, void *));\n-static int nonlocal_referenced_p        PARAMS ((rtx));\n-static int nonlocal_set_p_1             PARAMS ((rtx *, void *));\n-static int nonlocal_set_p               PARAMS ((rtx));\n-static void memory_modified_1\t\tPARAMS ((rtx, rtx, void *));\n+static int rtx_equal_for_memref_p (rtx, rtx);\n+static rtx find_symbolic_term (rtx);\n+rtx get_addr (rtx);\n+static int memrefs_conflict_p (int, rtx, int, rtx, HOST_WIDE_INT);\n+static void record_set (rtx, rtx, void *);\n+static int base_alias_check (rtx, rtx, enum machine_mode,\n+\t\t\t     enum machine_mode);\n+static rtx find_base_value (rtx);\n+static int mems_in_disjoint_alias_sets_p (rtx, rtx);\n+static int insert_subset_children (splay_tree_node, void*);\n+static tree find_base_decl (tree);\n+static alias_set_entry get_alias_set_entry (HOST_WIDE_INT);\n+static rtx fixed_scalar_and_varying_struct_p (rtx, rtx, rtx, rtx,\n+\t\t\t\t\t      int (*) (rtx, int));\n+static int aliases_everything_p (rtx);\n+static bool nonoverlapping_component_refs_p (tree, tree);\n+static tree decl_for_component_ref (tree);\n+static rtx adjust_offset_for_component_ref (tree, rtx);\n+static int nonoverlapping_memrefs_p (rtx, rtx);\n+static int write_dependence_p (rtx, rtx, int);\n+\n+static int nonlocal_mentioned_p_1 (rtx *, void *);\n+static int nonlocal_mentioned_p (rtx);\n+static int nonlocal_referenced_p_1 (rtx *, void *);\n+static int nonlocal_referenced_p (rtx);\n+static int nonlocal_set_p_1 (rtx *, void *);\n+static int nonlocal_set_p (rtx);\n+static void memory_modified_1 (rtx, rtx, void *);\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -213,8 +212,7 @@ static splay_tree alias_sets;\n    such an entry, or NULL otherwise.  */\n \n static alias_set_entry\n-get_alias_set_entry (alias_set)\n-     HOST_WIDE_INT alias_set;\n+get_alias_set_entry (HOST_WIDE_INT alias_set)\n {\n   splay_tree_node sn\n     = splay_tree_lookup (alias_sets, (splay_tree_key) alias_set);\n@@ -226,9 +224,7 @@ get_alias_set_entry (alias_set)\n    the two MEMs cannot alias each other.  */\n \n static int\n-mems_in_disjoint_alias_sets_p (mem1, mem2)\n-     rtx mem1;\n-     rtx mem2;\n+mems_in_disjoint_alias_sets_p (rtx mem1, rtx mem2)\n {\n #ifdef ENABLE_CHECKING\n /* Perform a basic sanity check.  Namely, that there are no alias sets\n@@ -250,9 +246,7 @@ mems_in_disjoint_alias_sets_p (mem1, mem2)\n    record_alias_subset via splay_tree_foreach.  */\n \n static int\n-insert_subset_children (node, data)\n-     splay_tree_node node;\n-     void *data;\n+insert_subset_children (splay_tree_node node, void *data)\n {\n   splay_tree_insert ((splay_tree) data, node->key, node->value);\n \n@@ -262,8 +256,7 @@ insert_subset_children (node, data)\n /* Return 1 if the two specified alias sets may conflict.  */\n \n int\n-alias_sets_conflict_p (set1, set2)\n-     HOST_WIDE_INT set1, set2;\n+alias_sets_conflict_p (HOST_WIDE_INT set1, HOST_WIDE_INT set2)\n {\n   alias_set_entry ase;\n \n@@ -300,8 +293,7 @@ alias_sets_conflict_p (set1, set2)\n    contain readonly fields, return true as well.  */\n \n int\n-readonly_fields_p (type)\n-     tree type;\n+readonly_fields_p (tree type)\n {\n   tree field;\n \n@@ -324,8 +316,7 @@ readonly_fields_p (type)\n    NULL_TREE, it means we know nothing about the storage.  */\n \n int\n-objects_must_conflict_p (t1, t2)\n-     tree t1, t2;\n+objects_must_conflict_p (tree t1, tree t2)\n {\n   /* If neither has a type specified, we don't know if they'll conflict\n      because we may be using them to store objects of various types, for\n@@ -364,8 +355,7 @@ objects_must_conflict_p (t1, t2)\n    NULL_TREE is returned.  */\n \n static tree\n-find_base_decl (t)\n-     tree t;\n+find_base_decl (tree t)\n {\n   tree d0, d1, d2;\n \n@@ -421,8 +411,7 @@ find_base_decl (t)\n    get_inner_reference in T are such that we can address the object in T.  */\n \n int\n-can_address_p (t)\n-     tree t;\n+can_address_p (tree t)\n {\n   /* If we're at the end, it is vacuously addressable.  */\n   if (! handled_component_p (t))\n@@ -454,8 +443,7 @@ can_address_p (t)\n    expression.  Call language-specific routine for help, if needed.  */\n \n HOST_WIDE_INT\n-get_alias_set (t)\n-     tree t;\n+get_alias_set (tree t)\n {\n   HOST_WIDE_INT set;\n \n@@ -605,7 +593,7 @@ get_alias_set (t)\n /* Return a brand-new alias set.  */\n \n HOST_WIDE_INT\n-new_alias_set ()\n+new_alias_set (void)\n {\n   static HOST_WIDE_INT last_alias_set;\n \n@@ -625,9 +613,7 @@ new_alias_set ()\n    subset of alias set zero.  */\n \n void\n-record_alias_subset (superset, subset)\n-     HOST_WIDE_INT superset;\n-     HOST_WIDE_INT subset;\n+record_alias_subset (HOST_WIDE_INT superset, HOST_WIDE_INT subset)\n {\n   alias_set_entry superset_entry;\n   alias_set_entry subset_entry;\n@@ -684,8 +670,7 @@ record_alias_subset (superset, subset)\n    function if the individual component aren't addressable.  */\n \n void\n-record_component_aliases (type)\n-     tree type;\n+record_component_aliases (tree type)\n {\n   HOST_WIDE_INT superset = get_alias_set (type);\n   tree field;\n@@ -732,7 +717,7 @@ record_component_aliases (type)\n    spill area.  */\n \n HOST_WIDE_INT\n-get_varargs_alias_set ()\n+get_varargs_alias_set (void)\n {\n   static HOST_WIDE_INT set = -1;\n \n@@ -746,7 +731,7 @@ get_varargs_alias_set ()\n    save areas.  */\n \n HOST_WIDE_INT\n-get_frame_alias_set ()\n+get_frame_alias_set (void)\n {\n   static HOST_WIDE_INT set = -1;\n \n@@ -759,8 +744,7 @@ get_frame_alias_set ()\n /* Inside SRC, the source of a SET, find a base address.  */\n \n static rtx\n-find_base_value (src)\n-     rtx src;\n+find_base_value (rtx src)\n {\n   unsigned int regno;\n \n@@ -930,9 +914,7 @@ static char *reg_seen;\n static int unique_id;\n \n static void\n-record_set (dest, set, data)\n-     rtx dest, set;\n-     void *data ATTRIBUTE_UNUSED;\n+record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned regno;\n   rtx src;\n@@ -1040,10 +1022,7 @@ record_set (dest, set, data)\n    are different.  */\n \n void\n-record_base_value (regno, val, invariant)\n-     unsigned int regno;\n-     rtx val;\n-     int invariant;\n+record_base_value (unsigned int regno, rtx val, int invariant)\n {\n   if (regno >= reg_base_value_size)\n     return;\n@@ -1068,8 +1047,7 @@ record_base_value (regno, val, invariant)\n    changes the offset.  */\n \n void\n-clear_reg_alias_info (reg)\n-     rtx reg;\n+clear_reg_alias_info (rtx reg)\n {\n   unsigned int regno = REGNO (reg);\n \n@@ -1083,8 +1061,7 @@ clear_reg_alias_info (reg)\n    whose address is the SYMBOL_REF is returned.)  */\n \n rtx\n-canon_rtx (x)\n-     rtx x;\n+canon_rtx (rtx x)\n {\n   /* Recursively look for equivalences.  */\n   if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n@@ -1123,8 +1100,7 @@ canon_rtx (x)\n    different numbers are, in fact, equivalent.  */\n \n static int\n-rtx_equal_for_memref_p (x, y)\n-     rtx x, y;\n+rtx_equal_for_memref_p (rtx x, rtx y)\n {\n   int i;\n   int j;\n@@ -1175,7 +1151,7 @@ rtx_equal_for_memref_p (x, y)\n     case ADDRESSOF:\n       return (XINT (x, 1) == XINT (y, 1)\n \t      && rtx_equal_for_memref_p (XEXP (x, 0),\n-\t\t      \t\t\t XEXP (y, 0)));\n+\t\t\t\t\t XEXP (y, 0)));\n \n     default:\n       break;\n@@ -1203,13 +1179,13 @@ rtx_equal_for_memref_p (x, y)\n   else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == '2')\n     {\n       return (rtx_equal_for_memref_p (canon_rtx (XEXP (x, 0)),\n-\t  \t\t\t      canon_rtx (XEXP (y, 0)))\n+\t\t\t\t      canon_rtx (XEXP (y, 0)))\n \t      && rtx_equal_for_memref_p (canon_rtx (XEXP (x, 1)),\n \t\t\t\t\t canon_rtx (XEXP (y, 1))));\n     }\n   else if (GET_RTX_CLASS (code) == '1')\n     return rtx_equal_for_memref_p (canon_rtx (XEXP (x, 0)),\n-      \t\t\t\t   canon_rtx (XEXP (y, 0)));\n+\t\t\t\t   canon_rtx (XEXP (y, 0)));\n \n   /* Compare the elements.  If any pair of corresponding elements\n      fail to match, return 0 for the whole things.\n@@ -1268,8 +1244,7 @@ rtx_equal_for_memref_p (x, y)\n    X and return it, or return 0 if none found.  */\n \n static rtx\n-find_symbolic_term (x)\n-     rtx x;\n+find_symbolic_term (rtx x)\n {\n   int i;\n   enum rtx_code code;\n@@ -1299,8 +1274,7 @@ find_symbolic_term (x)\n }\n \n rtx\n-find_base_term (x)\n-     rtx x;\n+find_base_term (rtx x)\n {\n   cselib_val *val;\n   struct elt_loc_list *l;\n@@ -1432,9 +1406,8 @@ find_base_term (x)\n    objects, 1 if they might be pointers to the same object.  */\n \n static int\n-base_alias_check (x, y, x_mode, y_mode)\n-     rtx x, y;\n-     enum machine_mode x_mode, y_mode;\n+base_alias_check (rtx x, rtx y, enum machine_mode x_mode,\n+\t\t  enum machine_mode y_mode)\n {\n   rtx x_base = find_base_term (x);\n   rtx y_base = find_base_term (y);\n@@ -1513,8 +1486,7 @@ base_alias_check (x, y, x_mode, y_mode)\n    a more useful rtx.  */\n \n rtx\n-get_addr (x)\n-     rtx x;\n+get_addr (rtx x)\n {\n   cselib_val *v;\n   struct elt_loc_list *l;\n@@ -1538,10 +1510,7 @@ get_addr (x)\n     is not modified by the memory reference then ADDR is returned.  */\n \n rtx\n-addr_side_effect_eval (addr, size, n_refs)\n-     rtx addr;\n-     int size;\n-     int n_refs;\n+addr_side_effect_eval (rtx addr, int size, int n_refs)\n {\n   int offset = 0;\n \n@@ -1593,10 +1562,7 @@ addr_side_effect_eval (addr, size, n_refs)\n    local variables had their addresses taken, but that's too hard now.  */\n \n static int\n-memrefs_conflict_p (xsize, x, ysize, y, c)\n-     rtx x, y;\n-     int xsize, ysize;\n-     HOST_WIDE_INT c;\n+memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n {\n   if (GET_CODE (x) == VALUE)\n     x = get_addr (x);\n@@ -1816,9 +1782,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n    only be a dependence here if both reads are volatile.  */\n \n int\n-read_dependence (mem, x)\n-     rtx mem;\n-     rtx x;\n+read_dependence (rtx mem, rtx x)\n {\n   return MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem);\n }\n@@ -1832,10 +1796,9 @@ read_dependence (mem, x)\n    MEM1_ADDR and MEM2_ADDR are the addresses of MEM1 and MEM2.  */\n \n static rtx\n-fixed_scalar_and_varying_struct_p (mem1, mem2, mem1_addr, mem2_addr, varies_p)\n-     rtx mem1, mem2;\n-     rtx mem1_addr, mem2_addr;\n-     int (*varies_p) PARAMS ((rtx, int));\n+fixed_scalar_and_varying_struct_p (rtx mem1, rtx mem2, rtx mem1_addr,\n+\t\t\t\t   rtx mem2_addr,\n+\t\t\t\t   int (*varies_p) (rtx, int))\n {\n   if (! flag_strict_aliasing)\n     return NULL_RTX;\n@@ -1859,8 +1822,7 @@ fixed_scalar_and_varying_struct_p (mem1, mem2, mem1_addr, mem2_addr, varies_p)\n    indicates that it might well alias *anything*.  */\n \n static int\n-aliases_everything_p (mem)\n-     rtx mem;\n+aliases_everything_p (rtx mem)\n {\n   if (GET_CODE (XEXP (mem, 0)) == AND)\n     /* If the address is an AND, its very hard to know at what it is\n@@ -1874,8 +1836,7 @@ aliases_everything_p (mem)\n    overlap for any pair of objects.  */\n \n static bool\n-nonoverlapping_component_refs_p (x, y)\n-     tree x, y;\n+nonoverlapping_component_refs_p (tree x, tree y)\n {\n   tree fieldx, fieldy, typex, typey, orig_y;\n \n@@ -1931,8 +1892,7 @@ nonoverlapping_component_refs_p (x, y)\n /* Look at the bottom of the COMPONENT_REF list for a DECL, and return it.  */\n \n static tree\n-decl_for_component_ref (x)\n-     tree x;\n+decl_for_component_ref (tree x)\n {\n   do\n     {\n@@ -1947,9 +1907,7 @@ decl_for_component_ref (x)\n    offset of the field reference.  */\n \n static rtx\n-adjust_offset_for_component_ref (x, offset)\n-     tree x;\n-     rtx offset;\n+adjust_offset_for_component_ref (tree x, rtx offset)\n {\n   HOST_WIDE_INT ioffset;\n \n@@ -1978,8 +1936,7 @@ adjust_offset_for_component_ref (x, offset)\n    X and Y and they do not overlap.  */\n \n static int\n-nonoverlapping_memrefs_p (x, y)\n-     rtx x, y;\n+nonoverlapping_memrefs_p (rtx x, rtx y)\n {\n   tree exprx = MEM_EXPR (x), expry = MEM_EXPR (y);\n   rtx rtlx, rtly;\n@@ -2105,11 +2062,8 @@ nonoverlapping_memrefs_p (x, y)\n /* True dependence: X is read after store in MEM takes place.  */\n \n int\n-true_dependence (mem, mem_mode, x, varies)\n-     rtx mem;\n-     enum machine_mode mem_mode;\n-     rtx x;\n-     int (*varies) PARAMS ((rtx, int));\n+true_dependence (rtx mem, enum machine_mode mem_mode, rtx x,\n+\t\t int (*varies) (rtx, int))\n {\n   rtx x_addr, mem_addr;\n   rtx base;\n@@ -2189,10 +2143,8 @@ true_dependence (mem, mem_mode, x, varies)\n    this value prior to canonicalizing.  */\n \n int\n-canon_true_dependence (mem, mem_mode, mem_addr, x, varies)\n-     rtx mem, mem_addr, x;\n-     enum machine_mode mem_mode;\n-     int (*varies) PARAMS ((rtx, int));\n+canon_true_dependence (rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n+\t\t       rtx x, int (*varies) (rtx, int))\n {\n   rtx x_addr;\n \n@@ -2253,10 +2205,7 @@ canon_true_dependence (mem, mem_mode, mem_addr, x, varies)\n    (or, if WRITEP is nonzero, a write to) MEM.  */\n \n static int\n-write_dependence_p (mem, x, writep)\n-     rtx mem;\n-     rtx x;\n-     int writep;\n+write_dependence_p (rtx mem, rtx x, int writep)\n {\n   rtx x_addr, mem_addr;\n   rtx fixed_scalar;\n@@ -2322,19 +2271,15 @@ write_dependence_p (mem, x, writep)\n /* Anti dependence: X is written after read in MEM takes place.  */\n \n int\n-anti_dependence (mem, x)\n-     rtx mem;\n-     rtx x;\n+anti_dependence (rtx mem, rtx x)\n {\n   return write_dependence_p (mem, x, /*writep=*/0);\n }\n \n /* Output dependence: X is written after store in MEM takes place.  */\n \n int\n-output_dependence (mem, x)\n-     rtx mem;\n-     rtx x;\n+output_dependence (rtx mem, rtx x)\n {\n   return write_dependence_p (mem, x, /*writep=*/1);\n }\n@@ -2343,9 +2288,7 @@ output_dependence (mem, x)\n    something which is not local to the function and is not constant.  */\n \n static int\n-nonlocal_mentioned_p_1 (loc, data)\n-     rtx *loc;\n-     void *data ATTRIBUTE_UNUSED;\n+nonlocal_mentioned_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *loc;\n   rtx base;\n@@ -2443,8 +2386,7 @@ nonlocal_mentioned_p_1 (loc, data)\n    local to the function and is not constant.  */\n \n static int\n-nonlocal_mentioned_p (x)\n-     rtx x;\n+nonlocal_mentioned_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n@@ -2467,9 +2409,7 @@ nonlocal_mentioned_p (x)\n    something which is not local to the function and is not constant.  */\n \n static int\n-nonlocal_referenced_p_1 (loc, data)\n-     rtx *loc;\n-     void *data ATTRIBUTE_UNUSED;\n+nonlocal_referenced_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *loc;\n \n@@ -2540,8 +2480,7 @@ nonlocal_referenced_p_1 (loc, data)\n    local to the function and is not constant.  */\n \n static int\n-nonlocal_referenced_p (x)\n-     rtx x;\n+nonlocal_referenced_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n@@ -2564,9 +2503,7 @@ nonlocal_referenced_p (x)\n    something which is not local to the function and is not constant.  */\n \n static int\n-nonlocal_set_p_1 (loc, data)\n-     rtx *loc;\n-     void *data ATTRIBUTE_UNUSED;\n+nonlocal_set_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *loc;\n \n@@ -2619,8 +2556,7 @@ nonlocal_set_p_1 (loc, data)\n    local to the function and is not constant.  */\n \n static int\n-nonlocal_set_p (x)\n-     rtx x;\n+nonlocal_set_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n@@ -2642,7 +2578,7 @@ nonlocal_set_p (x)\n /* Mark the function if it is pure or constant.  */\n \n void\n-mark_constant_function ()\n+mark_constant_function (void)\n {\n   rtx insn;\n   int nonlocal_memory_referenced;\n@@ -2697,7 +2633,7 @@ mark_constant_function ()\n \f\n \n void\n-init_alias_once ()\n+init_alias_once (void)\n {\n   int i;\n \n@@ -2731,9 +2667,7 @@ init_alias_once ()\n    to be memory reference.  */\n static bool memory_modified;\n static void\n-memory_modified_1 (x, pat, data)\n-\trtx x, pat ATTRIBUTE_UNUSED;\n-\tvoid *data;\n+memory_modified_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n {\n   if (GET_CODE (x) == MEM)\n     {\n@@ -2746,8 +2680,7 @@ memory_modified_1 (x, pat, data)\n /* Return true when INSN possibly modify memory contents of MEM\n    (ie address can be modified).  */\n bool\n-memory_modified_in_insn_p (mem, insn)\n-     rtx mem, insn;\n+memory_modified_in_insn_p (rtx mem, rtx insn)\n {\n   if (!INSN_P (insn))\n     return false;\n@@ -2760,7 +2693,7 @@ memory_modified_in_insn_p (mem, insn)\n    array.  */\n \n void\n-init_alias_analysis ()\n+init_alias_analysis (void)\n {\n   int maxreg = max_reg_num ();\n   int changed, pass;\n@@ -2979,7 +2912,7 @@ init_alias_analysis ()\n }\n \n void\n-end_alias_analysis ()\n+end_alias_analysis (void)\n {\n   free (reg_known_value + FIRST_PSEUDO_REGISTER);\n   reg_known_value = 0;"}, {"sha": "e247b141f76e360585e42c8ddef1da9a64ce7f9b", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -30,7 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    special abort includes one or both.  toplev.h gets too few files,\n    system.h gets too many.  */\n \n-extern void fancy_abort PARAMS ((const char *, int, const char *))\n+extern void fancy_abort (const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n #define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n \n@@ -80,10 +80,7 @@ static ALLOC_POOL_ID_TYPE last_id;\n    allocate.  */\n \n alloc_pool\n-create_alloc_pool (name, size, num)\n-     const char *name;\n-     size_t size;\n-     size_t num;\n+create_alloc_pool (const char *name, size_t size, size_t num)\n {\n   alloc_pool pool;\n   size_t pool_size, header_size;\n@@ -143,8 +140,7 @@ create_alloc_pool (name, size, num)\n \n /* Free all memory allocated for the given memory pool.  */\n void\n-free_alloc_pool (pool)\n-     alloc_pool pool;\n+free_alloc_pool (alloc_pool pool)\n {\n   alloc_pool_list block, next_block;\n \n@@ -166,8 +162,7 @@ free_alloc_pool (pool)\n \n /* Allocates one element from the pool specified.  */\n void *\n-pool_alloc (pool)\n-     alloc_pool pool;\n+pool_alloc (alloc_pool pool)\n {\n   alloc_pool_list header;\n   char *block;\n@@ -225,9 +220,7 @@ pool_alloc (pool)\n \n /* Puts PTR back on POOL's free list.  */\n void\n-pool_free (pool, ptr)\n-     alloc_pool pool;\n-     void *ptr;\n+pool_free (alloc_pool pool, void *ptr)\n {\n   alloc_pool_list header;\n "}, {"sha": "48d017217a9fe8cd7fdacde3683045f23927fda5", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -47,8 +47,8 @@ typedef struct alloc_pool_def\n }\n  *alloc_pool;\n \n-extern alloc_pool create_alloc_pool PARAMS ((const char *, size_t, size_t));\n-extern void free_alloc_pool PARAMS ((alloc_pool));\n-extern void *pool_alloc PARAMS ((alloc_pool));\n-extern void pool_free PARAMS ((alloc_pool, void *));\n+extern alloc_pool create_alloc_pool (const char *, size_t, size_t);\n+extern void free_alloc_pool (alloc_pool);\n+extern void *pool_alloc (alloc_pool);\n+extern void pool_free (alloc_pool, void *);\n #endif"}, {"sha": "6ddacb18348571010976ebaf2ac143b4d367b3e9", "filename": "gcc/attribs.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -1,6 +1,6 @@\n /* Functions dealing with attribute handling, used by most front ends.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002 Free Software Foundation, Inc.\n+   2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -35,7 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"langhooks.h\"\n \n-static void init_attributes\t\tPARAMS ((void));\n+static void init_attributes (void);\n \n /* Table of the tables of attributes (common, language, format, machine)\n    searched.  */\n@@ -53,7 +53,7 @@ static const struct attribute_spec empty_attribute_table[] =\n    if --enable-checking.  */\n \n static void\n-init_attributes ()\n+init_attributes (void)\n {\n   size_t i;\n \n@@ -141,9 +141,7 @@ init_attributes ()\n    and ATTR_FLAG_BUILT_IN set.  */\n \n tree\n-decl_attributes (node, attributes, flags)\n-     tree *node, attributes;\n-     int flags;\n+decl_attributes (tree *node, tree attributes, int flags)\n {\n   tree a;\n   tree returned_attrs = NULL_TREE;\n@@ -317,9 +315,7 @@ decl_attributes (node, attributes, flags)\n    resulting attributes together the way decl_attributes expects them.  */\n \n void\n-split_specs_attrs (specs_attrs, declspecs, prefix_attributes)\n-     tree specs_attrs;\n-     tree *declspecs, *prefix_attributes;\n+split_specs_attrs (tree specs_attrs, tree *declspecs, tree *prefix_attributes)\n {\n   tree t, s, a, next, specs, attrs;\n \n@@ -394,8 +390,7 @@ split_specs_attrs (specs_attrs, declspecs, prefix_attributes)\n    A warning is issued for every ignored attribute.  */\n \n tree\n-strip_attrs (specs_attrs)\n-     tree specs_attrs;\n+strip_attrs (tree specs_attrs)\n {\n   tree specs, attrs;\n \n@@ -410,4 +405,3 @@ strip_attrs (specs_attrs)\n \n   return specs;\n }\n-"}, {"sha": "9e57f1941c46599f87264a4e17813b83ce2c2258", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -542,7 +542,6 @@ extern bool probably_never_executed_bb_p PARAMS ((basic_block));\n \n /* In flow.c */\n extern void init_flow                   PARAMS ((void));\n-extern void reorder_basic_blocks\tPARAMS ((void));\n extern void dump_bb\t\t\tPARAMS ((basic_block, FILE *));\n extern void debug_bb\t\t\tPARAMS ((basic_block));\n extern basic_block debug_bb_n\t\tPARAMS ((int));\n@@ -619,6 +618,9 @@ extern rtx hoist_insn_to_edge\t\tPARAMS ((rtx, edge, rtx, rtx));\n extern bool inside_basic_block_p\tPARAMS ((rtx));\n extern bool control_flow_insn_p\t\tPARAMS ((rtx));\n \n+/* In bb-reorder.c */\n+extern void reorder_basic_blocks (void);\n+\n /* In dominance.c */\n \n enum cdi_direction"}, {"sha": "7d221c62030ccb244402f1aea678d5c547a9bd8d", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 26, "deletions": 56, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -141,29 +141,24 @@ int max_entry_frequency;\n gcov_type max_entry_count;\n \n /* Local function prototypes.  */\n-static void find_traces\t\t\tPARAMS ((int *, struct trace *));\n-static basic_block rotate_loop\t\tPARAMS ((edge, struct trace *, int));\n-static void mark_bb_visited\t\tPARAMS ((basic_block, int));\n-static void find_traces_1_round\t\tPARAMS ((int, int, gcov_type,\n-\t\t\t\t\t\t struct trace *, int *, int,\n-\t\t\t\t\t\t fibheap_t *));\n-static basic_block copy_bb\t\tPARAMS ((basic_block, edge,\n-\t\t\t\t\t\t basic_block, int));\n-static fibheapkey_t bb_to_key\t\tPARAMS ((basic_block));\n-static bool better_edge_p\t\tPARAMS ((basic_block, edge, int, int,\n-\t\t\t\t\t\t int, int));\n-static void connect_traces\t\tPARAMS ((int, struct trace *));\n-static bool copy_bb_p\t\t\tPARAMS ((basic_block, int));\n-static int get_uncond_jump_length\tPARAMS ((void));\n+static void find_traces (int *, struct trace *);\n+static basic_block rotate_loop (edge, struct trace *, int);\n+static void mark_bb_visited (basic_block, int);\n+static void find_traces_1_round (int, int, gcov_type, struct trace *, int *,\n+\t\t\t\t int, fibheap_t *);\n+static basic_block copy_bb (basic_block, edge, basic_block, int);\n+static fibheapkey_t bb_to_key (basic_block);\n+static bool better_edge_p (basic_block, edge, int, int, int, int);\n+static void connect_traces (int, struct trace *);\n+static bool copy_bb_p (basic_block, int);\n+static int get_uncond_jump_length (void);\n \f\n /* Find the traces for Software Trace Cache.  Chain each trace through\n    RBI()->next.  Store the number of traces to N_TRACES and description of\n    traces to TRACES.  */\n \n static void\n-find_traces (n_traces, traces)\n-     int *n_traces;\n-     struct trace *traces;\n+find_traces (int *n_traces, struct trace *traces)\n {\n   int i;\n   edge e;\n@@ -222,10 +217,7 @@ find_traces (n_traces, traces)\n    (with sequential number TRACE_N).  */\n \n static basic_block\n-rotate_loop (back_edge, trace, trace_n)\n-     edge back_edge;\n-     struct trace *trace;\n-     int trace_n;\n+rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n {\n   basic_block bb;\n \n@@ -339,9 +331,7 @@ rotate_loop (back_edge, trace, trace_n)\n /* This function marks BB that it was visited in trace number TRACE.  */\n \n static void\n-mark_bb_visited (bb, trace)\n-     basic_block bb;\n-     int trace;\n+mark_bb_visited (basic_block bb, int trace)\n {\n   RBI (bb)->visited = trace;\n   if (bbd[bb->index].heap)\n@@ -361,15 +351,9 @@ mark_bb_visited (bb, trace)\n    *HEAP and stores starting points for the next round into new *HEAP.  */\n \n static void\n-find_traces_1_round (branch_th, exec_th, count_th, traces, n_traces, round,\n-\t\t     heap)\n-     int branch_th;\n-     int exec_th;\n-     gcov_type count_th;\n-     struct trace *traces;\n-     int *n_traces;\n-     int round;\n-     fibheap_t *heap;\n+find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n+\t\t     struct trace *traces, int *n_traces, int round,\n+\t\t     fibheap_t *heap)\n {\n   /* Heap for discarded basic blocks which are possible starting points for\n      the next round.  */\n@@ -664,11 +648,7 @@ find_traces_1_round (branch_th, exec_th, count_th, traces, n_traces, round,\n    (TRACE is a number of trace which OLD_BB is duplicated to).  */\n \n static basic_block\n-copy_bb (old_bb, e, bb, trace)\n-     basic_block old_bb;\n-     edge e;\n-     basic_block bb;\n-     int trace;\n+copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n {\n   basic_block new_bb;\n \n@@ -716,8 +696,7 @@ copy_bb (old_bb, e, bb, trace)\n /* Compute and return the key (for the heap) of the basic block BB.  */\n \n static fibheapkey_t\n-bb_to_key (bb)\n-     basic_block bb;\n+bb_to_key (basic_block bb)\n {\n   edge e;\n \n@@ -755,13 +734,8 @@ bb_to_key (bb)\n    BEST_PROB; similarly for frequency.  */\n \n static bool\n-better_edge_p (bb, e, prob, freq, best_prob, best_freq)\n-     basic_block bb;\n-     edge e;\n-     int prob;\n-     int freq;\n-     int best_prob;\n-     int best_freq;\n+better_edge_p (basic_block bb, edge e, int prob, int freq, int best_prob,\n+\t       int best_freq)\n {\n   bool is_better_edge;\n \n@@ -798,9 +772,7 @@ better_edge_p (bb, e, prob, freq, best_prob, best_freq)\n /* Connect traces in array TRACES, N_TRACES is the count of traces.  */\n \n static void\n-connect_traces (n_traces, traces)\n-     int n_traces;\n-     struct trace *traces;\n+connect_traces (int n_traces, struct trace *traces)\n {\n   int i;\n   bool *connected;\n@@ -1022,9 +994,7 @@ connect_traces (n_traces, traces)\n    when code size is allowed to grow by duplication.  */\n \n static bool\n-copy_bb_p (bb, code_may_grow)\n-     basic_block bb;\n-     int code_may_grow;\n+copy_bb_p (basic_block bb, int code_may_grow)\n {\n   int size = 0;\n   int max_size = uncond_jump_length;\n@@ -1063,7 +1033,7 @@ copy_bb_p (bb, code_may_grow)\n /* Return the length of unconditional jump instruction.  */\n \n static int\n-get_uncond_jump_length ()\n+get_uncond_jump_length (void)\n {\n   rtx label, jump;\n   int length;\n@@ -1081,7 +1051,7 @@ get_uncond_jump_length ()\n /* Reorder basic blocks.  The main entry point to this file.  */\n \n void\n-reorder_basic_blocks ()\n+reorder_basic_blocks (void)\n {\n   int n_traces;\n   int i;\n@@ -1100,7 +1070,7 @@ reorder_basic_blocks ()\n \n   /* We are estimating the lenght of uncond jump insn only once since the code\n      for getting the insn lenght always returns the minimal length now.  */\n-  if (uncond_jump_length == 0) \n+  if (uncond_jump_length == 0)\n     uncond_jump_length = get_uncond_jump_length ();\n \n   /* We need to know some information for each basic block.  */"}, {"sha": "f03f3e2794932f463fe3ab2af540021561101400", "filename": "gcc/bitmap.c", "status": "modified", "additions": 31, "deletions": 73, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -46,18 +46,16 @@ bitmap_element bitmap_zero_bits;\t/* An element of all zero bits.  */\n static bitmap_element *bitmap_free;\t/* Freelist of bitmap elements.  */\n static GTY((deletable (\"\"))) bitmap_element *bitmap_ggc_free;\n \n-static void bitmap_elem_to_freelist\tPARAMS ((bitmap, bitmap_element *));\n-static void bitmap_element_free\t\tPARAMS ((bitmap, bitmap_element *));\n-static bitmap_element *bitmap_element_allocate PARAMS ((bitmap));\n-static int bitmap_element_zerop\t\tPARAMS ((bitmap_element *));\n-static void bitmap_element_link\t\tPARAMS ((bitmap, bitmap_element *));\n-static bitmap_element *bitmap_find_bit\tPARAMS ((bitmap, unsigned int));\n+static void bitmap_elem_to_freelist (bitmap, bitmap_element *);\n+static void bitmap_element_free (bitmap, bitmap_element *);\n+static bitmap_element *bitmap_element_allocate (bitmap);\n+static int bitmap_element_zerop (bitmap_element *);\n+static void bitmap_element_link (bitmap, bitmap_element *);\n+static bitmap_element *bitmap_find_bit (bitmap, unsigned int);\n \f\n /* Add ELEM to the appropriate freelist.  */\n static INLINE void\n-bitmap_elem_to_freelist (head, elt)\n-     bitmap head;\n-     bitmap_element *elt;\n+bitmap_elem_to_freelist (bitmap head, bitmap_element *elt)\n {\n   if (head->using_obstack)\n     {\n@@ -75,9 +73,7 @@ bitmap_elem_to_freelist (head, elt)\n    bitmap_obstack, \"free\" actually means \"put onto the freelist\".  */\n \n static INLINE void\n-bitmap_element_free (head, elt)\n-     bitmap head;\n-     bitmap_element *elt;\n+bitmap_element_free (bitmap head, bitmap_element *elt)\n {\n   bitmap_element *next = elt->next;\n   bitmap_element *prev = elt->prev;\n@@ -105,8 +101,7 @@ bitmap_element_free (head, elt)\n /* Allocate a bitmap element.  The bits are cleared, but nothing else is.  */\n \n static INLINE bitmap_element *\n-bitmap_element_allocate (head)\n-     bitmap head;\n+bitmap_element_allocate (bitmap head)\n {\n   bitmap_element *element;\n \n@@ -159,7 +154,7 @@ bitmap_element_allocate (head)\n /* Release any memory allocated by bitmaps.  */\n \n void\n-bitmap_release_memory ()\n+bitmap_release_memory (void)\n {\n   bitmap_free = 0;\n   if (bitmap_obstack_init)\n@@ -172,8 +167,7 @@ bitmap_release_memory ()\n /* Return nonzero if all bits in an element are zero.  */\n \n static INLINE int\n-bitmap_element_zerop (element)\n-     bitmap_element *element;\n+bitmap_element_zerop (bitmap_element *element)\n {\n #if BITMAP_ELEMENT_WORDS == 2\n   return (element->bits[0] | element->bits[1]) == 0;\n@@ -191,9 +185,7 @@ bitmap_element_zerop (element)\n /* Link the bitmap element into the current bitmap linked list.  */\n \n static INLINE void\n-bitmap_element_link (head, element)\n-     bitmap head;\n-     bitmap_element *element;\n+bitmap_element_link (bitmap head, bitmap_element *element)\n {\n   unsigned int indx = element->indx;\n   bitmap_element *ptr;\n@@ -248,8 +240,7 @@ bitmap_element_link (head, element)\n /* Clear a bitmap by freeing the linked list.  */\n \n INLINE void\n-bitmap_clear (head)\n-     bitmap head;\n+bitmap_clear (bitmap head)\n {\n   bitmap_element *element, *next;\n \n@@ -265,9 +256,7 @@ bitmap_clear (head)\n /* Copy a bitmap to another bitmap.  */\n \n void\n-bitmap_copy (to, from)\n-     bitmap to;\n-     bitmap from;\n+bitmap_copy (bitmap to, bitmap from)\n {\n   bitmap_element *from_ptr, *to_ptr = 0;\n #if BITMAP_ELEMENT_WORDS != 2\n@@ -316,9 +305,7 @@ bitmap_copy (to, from)\n    faster.  */\n \n static INLINE bitmap_element *\n-bitmap_find_bit (head, bit)\n-     bitmap head;\n-     unsigned int bit;\n+bitmap_find_bit (bitmap head, unsigned int bit)\n {\n   bitmap_element *element;\n   unsigned int indx = bit / BITMAP_ELEMENT_ALL_BITS;\n@@ -352,9 +339,7 @@ bitmap_find_bit (head, bit)\n /* Clear a single bit in a bitmap.  */\n \n void\n-bitmap_clear_bit (head, bit)\n-     bitmap head;\n-     int bit;\n+bitmap_clear_bit (bitmap head, int bit)\n {\n   bitmap_element *ptr = bitmap_find_bit (head, bit);\n \n@@ -373,9 +358,7 @@ bitmap_clear_bit (head, bit)\n /* Set a single bit in a bitmap.  */\n \n void\n-bitmap_set_bit (head, bit)\n-     bitmap head;\n-     int bit;\n+bitmap_set_bit (bitmap head, int bit)\n {\n   bitmap_element *ptr = bitmap_find_bit (head, bit);\n   unsigned word_num = bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n@@ -396,9 +379,7 @@ bitmap_set_bit (head, bit)\n /* Return whether a bit is set within a bitmap.  */\n \n int\n-bitmap_bit_p (head, bit)\n-     bitmap head;\n-     int bit;\n+bitmap_bit_p (bitmap head, int bit)\n {\n   bitmap_element *ptr;\n   unsigned bit_num;\n@@ -418,8 +399,7 @@ bitmap_bit_p (head, bit)\n    if the bitmap is empty.  */\n \n int\n-bitmap_first_set_bit (a)\n-     bitmap a;\n+bitmap_first_set_bit (bitmap a)\n {\n   bitmap_element *ptr = a->first;\n   BITMAP_WORD word;\n@@ -471,8 +451,7 @@ bitmap_first_set_bit (a)\n    if the bitmap is empty.  */\n \n int\n-bitmap_last_set_bit (a)\n-     bitmap a;\n+bitmap_last_set_bit (bitmap a)\n {\n   bitmap_element *ptr = a->first;\n   BITMAP_WORD word;\n@@ -524,11 +503,8 @@ bitmap_last_set_bit (a)\n    a specific bit manipulation.  Return true if TO changes.  */\n \n int\n-bitmap_operation (to, from1, from2, operation)\n-     bitmap to;\n-     bitmap from1;\n-     bitmap from2;\n-     enum bitmap_bits operation;\n+bitmap_operation (bitmap to, bitmap from1, bitmap from2,\n+\t\t  enum bitmap_bits operation)\n {\n #define HIGHEST_INDEX (unsigned int) ~0\n \n@@ -687,14 +663,12 @@ bitmap_operation (to, from1, from2, operation)\n /* Return true if two bitmaps are identical.  */\n \n int\n-bitmap_equal_p (a, b)\n-     bitmap a;\n-     bitmap b;\n+bitmap_equal_p (bitmap a, bitmap b)\n {\n   bitmap_head c;\n   int ret;\n \n-  memset (&c, 0, sizeof (c)); \n+  memset (&c, 0, sizeof (c));\n   ret = ! bitmap_operation (&c, a, b, BITMAP_XOR);\n   bitmap_clear (&c);\n \n@@ -705,10 +679,7 @@ bitmap_equal_p (a, b)\n    bitmap FROM2.  */\n \n void\n-bitmap_ior_and_compl (to, from1, from2)\n-     bitmap to;\n-     bitmap from1;\n-     bitmap from2;\n+bitmap_ior_and_compl (bitmap to, bitmap from1, bitmap from2)\n {\n   bitmap_head tmp;\n \n@@ -721,11 +692,7 @@ bitmap_ior_and_compl (to, from1, from2)\n }\n \n int\n-bitmap_union_of_diff (dst, a, b, c)\n-     bitmap dst;\n-     bitmap a;\n-     bitmap b;\n-     bitmap c;\n+bitmap_union_of_diff (bitmap dst, bitmap a, bitmap b, bitmap c)\n {\n   bitmap_head tmp;\n   int changed;\n@@ -743,13 +710,11 @@ bitmap_union_of_diff (dst, a, b, c)\n /* Initialize a bitmap header.  */\n \n bitmap\n-bitmap_initialize (head, using_obstack)\n-     bitmap head;\n-     int using_obstack;\n+bitmap_initialize (bitmap head, int using_obstack)\n {\n   if (head == NULL && ! using_obstack)\n     head = ggc_alloc (sizeof (*head));\n-  \n+\n   head->first = head->current = 0;\n   head->using_obstack = using_obstack;\n \n@@ -759,9 +724,7 @@ bitmap_initialize (head, using_obstack)\n /* Debugging function to print out the contents of a bitmap.  */\n \n void\n-debug_bitmap_file (file, head)\n-     FILE *file;\n-     bitmap head;\n+debug_bitmap_file (FILE *file, bitmap head)\n {\n   bitmap_element *ptr;\n \n@@ -806,8 +769,7 @@ debug_bitmap_file (file, head)\n    of a bitmap.  */\n \n void\n-debug_bitmap (head)\n-     bitmap head;\n+debug_bitmap (bitmap head)\n {\n   debug_bitmap_file (stdout, head);\n }\n@@ -816,11 +778,7 @@ debug_bitmap (head)\n    it does not print anything but the bits.  */\n \n void\n-bitmap_print (file, head, prefix, suffix)\n-     FILE *file;\n-     bitmap head;\n-     const char *prefix;\n-     const char *suffix;\n+bitmap_print (FILE *file, bitmap head, const char *prefix, const char *suffix)\n {\n   const char *comma = \"\";\n   int i;"}, {"sha": "7b85f45c470d6b8c239fff9362cc1f548a450512", "filename": "gcc/bitmap.h", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -79,53 +79,52 @@ enum bitmap_bits {\n extern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */\n \n /* Clear a bitmap by freeing up the linked list.  */\n-extern void bitmap_clear PARAMS ((bitmap));\n+extern void bitmap_clear (bitmap);\n \n /* Copy a bitmap to another bitmap.  */\n-extern void bitmap_copy PARAMS ((bitmap, bitmap));\n+extern void bitmap_copy (bitmap, bitmap);\n \n /* True if two bitmaps are identical.  */\n-extern int bitmap_equal_p PARAMS ((bitmap, bitmap));\n+extern int bitmap_equal_p (bitmap, bitmap);\n \n /* Perform an operation on two bitmaps, yielding a third.  */\n-extern int bitmap_operation PARAMS ((bitmap, bitmap, bitmap, enum bitmap_bits));\n+extern int bitmap_operation (bitmap, bitmap, bitmap, enum bitmap_bits);\n \n /* `or' into one bitmap the `and' of a second bitmap witih the complement\n    of a third.  */\n-extern void bitmap_ior_and_compl PARAMS ((bitmap, bitmap, bitmap));\n+extern void bitmap_ior_and_compl (bitmap, bitmap, bitmap);\n \n /* Clear a single register in a register set.  */\n-extern void bitmap_clear_bit PARAMS ((bitmap, int));\n+extern void bitmap_clear_bit (bitmap, int);\n \n /* Set a single register in a register set.  */\n-extern void bitmap_set_bit PARAMS ((bitmap, int));\n+extern void bitmap_set_bit (bitmap, int);\n \n /* Return true if a register is set in a register set.  */\n-extern int bitmap_bit_p PARAMS ((bitmap, int));\n+extern int bitmap_bit_p (bitmap, int);\n \n /* Debug functions to print a bitmap linked list.  */\n-extern void debug_bitmap PARAMS ((bitmap));\n-extern void debug_bitmap_file PARAMS ((FILE *, bitmap));\n+extern void debug_bitmap (bitmap);\n+extern void debug_bitmap_file (FILE *, bitmap);\n \n /* Print a bitmap */\n-extern void bitmap_print PARAMS ((FILE *, bitmap, const char *, const char *));\n+extern void bitmap_print (FILE *, bitmap, const char *, const char *);\n \n /* Initialize a bitmap header.  If HEAD is NULL, a new header will be\n    allocated.  USING_OBSTACK indicates how elements should be allocated.  */\n-extern bitmap bitmap_initialize PARAMS ((bitmap head, \n-\t\t\t\t\t int using_obstack));\n+extern bitmap bitmap_initialize (bitmap head, int using_obstack);\n \n /* Release all memory used by the bitmap obstack.  */\n-extern void bitmap_release_memory PARAMS ((void));\n+extern void bitmap_release_memory (void);\n \n /* A few compatibility/functions macros for compatibility with sbitmaps */\n #define dump_bitmap(file, bitmap) bitmap_print (file, bitmap, \"\", \"\\n\")\n #define bitmap_zero(a) bitmap_clear (a)\n #define bitmap_a_or_b(a,b,c) bitmap_operation (a, b, c, BITMAP_IOR)\n #define bitmap_a_and_b(a,b,c) bitmap_operation (a, b, c, BITMAP_AND)\n-extern int bitmap_union_of_diff PARAMS((bitmap, bitmap, bitmap, bitmap));\n-extern int bitmap_first_set_bit PARAMS((bitmap));\n-extern int bitmap_last_set_bit PARAMS((bitmap));\n+extern int bitmap_union_of_diff (bitmap, bitmap, bitmap, bitmap);\n+extern int bitmap_first_set_bit (bitmap);\n+extern int bitmap_last_set_bit (bitmap);\n \n /* Allocate a bitmap with oballoc.  */\n #define BITMAP_OBSTACK_ALLOC(OBSTACK)\t\t\t\t\\\n@@ -249,7 +248,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       tmp2_ = ((ptr2_ != 0 && ptr2_->indx == ptr1_->indx)\t\t\\\n-\t       ? ptr2_ : &bitmap_zero_bits); \t\t\t\t\\\n+\t       ? ptr2_ : &bitmap_zero_bits);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n \t{\t\t\t\t\t\t\t\t\\"}, {"sha": "83797491c5d47a67b18c86e40341cb57cf47569f", "filename": "gcc/builtins.c", "status": "modified", "additions": 170, "deletions": 340, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -84,106 +84,82 @@ static bool builtin_dconsts_init = 0;\n static REAL_VALUE_TYPE dconstpi;\n static REAL_VALUE_TYPE dconste;\n \n-static int get_pointer_alignment\tPARAMS ((tree, unsigned int));\n-static tree c_strlen\t\t\tPARAMS ((tree));\n-static const char *c_getstr\t\tPARAMS ((tree));\n-static rtx c_readstr\t\t\tPARAMS ((const char *,\n-\t\t\t\t\t\t enum machine_mode));\n-static int target_char_cast\t\tPARAMS ((tree, char *));\n-static rtx get_memory_rtx\t\tPARAMS ((tree));\n-static int apply_args_size\t\tPARAMS ((void));\n-static int apply_result_size\t\tPARAMS ((void));\n+static int get_pointer_alignment (tree, unsigned int);\n+static tree c_strlen (tree);\n+static const char *c_getstr (tree);\n+static rtx c_readstr (const char *, enum machine_mode);\n+static int target_char_cast (tree, char *);\n+static rtx get_memory_rtx (tree);\n+static int apply_args_size (void);\n+static int apply_result_size (void);\n #if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n-static rtx result_vector\t\tPARAMS ((int, rtx));\n+static rtx result_vector (int, rtx);\n #endif\n-static rtx expand_builtin_setjmp\tPARAMS ((tree, rtx));\n-static void expand_builtin_prefetch\tPARAMS ((tree));\n-static rtx expand_builtin_apply_args\tPARAMS ((void));\n-static rtx expand_builtin_apply_args_1\tPARAMS ((void));\n-static rtx expand_builtin_apply\t\tPARAMS ((rtx, rtx, rtx));\n-static void expand_builtin_return\tPARAMS ((rtx));\n-static enum type_class type_to_class\tPARAMS ((tree));\n-static rtx expand_builtin_classify_type\tPARAMS ((tree));\n-static void expand_errno_check\t\tPARAMS ((tree, rtx));\n-static rtx expand_builtin_mathfn\tPARAMS ((tree, rtx, rtx));\n-static rtx expand_builtin_mathfn_2\tPARAMS ((tree, rtx, rtx));\n-static rtx expand_builtin_constant_p\tPARAMS ((tree, enum machine_mode));\n-static rtx expand_builtin_args_info\tPARAMS ((tree));\n-static rtx expand_builtin_next_arg\tPARAMS ((tree));\n-static rtx expand_builtin_va_start\tPARAMS ((tree));\n-static rtx expand_builtin_va_end\tPARAMS ((tree));\n-static rtx expand_builtin_va_copy\tPARAMS ((tree));\n-static rtx expand_builtin_memcmp\tPARAMS ((tree, tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strcmp\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strncmp\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx builtin_memcpy_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strcat\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strncat\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strspn\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strcspn\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_memcpy\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_mempcpy\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode, int));\n-static rtx expand_builtin_memmove\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_bcopy\t\tPARAMS ((tree));\n-static rtx expand_builtin_strcpy\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_stpcpy\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx builtin_strncpy_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strncpy\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx builtin_memset_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx builtin_memset_gen_str\tPARAMS ((PTR, HOST_WIDE_INT,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_memset\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_bzero\t\tPARAMS ((tree));\n-static rtx expand_builtin_strlen\tPARAMS ((tree, rtx, enum machine_mode));\n-static rtx expand_builtin_strstr\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strpbrk\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strchr\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_strrchr\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_alloca\tPARAMS ((tree, rtx));\n-static rtx expand_builtin_unop\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t tree, rtx, rtx, optab));\n-static rtx expand_builtin_frame_address\tPARAMS ((tree, tree));\n-static rtx expand_builtin_fputs\t\tPARAMS ((tree, int, int));\n-static tree stabilize_va_list\t\tPARAMS ((tree, int));\n-static rtx expand_builtin_expect\tPARAMS ((tree, rtx));\n-static tree fold_builtin_constant_p\tPARAMS ((tree));\n-static tree fold_builtin_classify_type\tPARAMS ((tree));\n-static tree fold_builtin_inf\t\tPARAMS ((tree, int));\n-static tree fold_builtin_nan\t\tPARAMS ((tree, tree, int));\n-static int validate_arglist\t\tPARAMS ((tree, ...));\n-static tree fold_trunc_transparent_mathfn PARAMS ((tree));\n-static bool readonly_data_expr\t\tPARAMS ((tree));\n-static rtx expand_builtin_fabs\t\tPARAMS ((tree, rtx, rtx));\n-static rtx expand_builtin_cabs\t\tPARAMS ((tree, rtx));\n-static void init_builtin_dconsts\tPARAMS ((void));\n-static tree fold_builtin_cabs\t\tPARAMS ((tree, tree, tree));\n+static rtx expand_builtin_setjmp (tree, rtx);\n+static void expand_builtin_prefetch (tree);\n+static rtx expand_builtin_apply_args (void);\n+static rtx expand_builtin_apply_args_1 (void);\n+static rtx expand_builtin_apply (rtx, rtx, rtx);\n+static void expand_builtin_return (rtx);\n+static enum type_class type_to_class (tree);\n+static rtx expand_builtin_classify_type (tree);\n+static void expand_errno_check (tree, rtx);\n+static rtx expand_builtin_mathfn (tree, rtx, rtx);\n+static rtx expand_builtin_mathfn_2 (tree, rtx, rtx);\n+static rtx expand_builtin_constant_p (tree, enum machine_mode);\n+static rtx expand_builtin_args_info (tree);\n+static rtx expand_builtin_next_arg (tree);\n+static rtx expand_builtin_va_start (tree);\n+static rtx expand_builtin_va_end (tree);\n+static rtx expand_builtin_va_copy (tree);\n+static rtx expand_builtin_memcmp (tree, tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strcmp (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strncmp (tree, rtx, enum machine_mode);\n+static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n+static rtx expand_builtin_strcat (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strncat (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strspn (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strcspn (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_memcpy (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_mempcpy (tree, rtx, enum machine_mode, int);\n+static rtx expand_builtin_memmove (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_bcopy (tree);\n+static rtx expand_builtin_strcpy (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_stpcpy (tree, rtx, enum machine_mode);\n+static rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n+static rtx expand_builtin_strncpy (tree, rtx, enum machine_mode);\n+static rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n+static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, enum machine_mode);\n+static rtx expand_builtin_memset (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_bzero (tree);\n+static rtx expand_builtin_strlen (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strstr (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strpbrk (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strchr (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strrchr (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_alloca (tree, rtx);\n+static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);\n+static rtx expand_builtin_frame_address (tree, tree);\n+static rtx expand_builtin_fputs (tree, int, int);\n+static tree stabilize_va_list (tree, int);\n+static rtx expand_builtin_expect (tree, rtx);\n+static tree fold_builtin_constant_p (tree);\n+static tree fold_builtin_classify_type (tree);\n+static tree fold_builtin_inf (tree, int);\n+static tree fold_builtin_nan (tree, tree, int);\n+static int validate_arglist (tree, ...);\n+static tree fold_trunc_transparent_mathfn (tree);\n+static bool readonly_data_expr (tree);\n+static rtx expand_builtin_fabs (tree, rtx, rtx);\n+static rtx expand_builtin_cabs (tree, rtx);\n+static void init_builtin_dconsts (void);\n+static tree fold_builtin_cabs (tree, tree, tree);\n \n /* Initialize mathematical constants for constant folding builtins.\n    These constants need to be given to at least 160 bits precision.  */\n \n static void\n-init_builtin_dconsts ()\n+init_builtin_dconsts (void)\n {\n   real_from_string (&dconstpi,\n     \"3.1415926535897932384626433832795028841971693993751058209749445923078\");\n@@ -192,7 +168,7 @@ init_builtin_dconsts ()\n \n   builtin_dconsts_init = true;\n }\n-  \n+\n /* Return the alignment in bits of EXP, a pointer valued expression.\n    But don't return more than MAX_ALIGN no matter what.\n    The alignment returned is, by default, the alignment of the thing that\n@@ -202,9 +178,7 @@ init_builtin_dconsts ()\n    expression is actually pointing at an object whose alignment is tighter.  */\n \n static int\n-get_pointer_alignment (exp, max_align)\n-     tree exp;\n-     unsigned int max_align;\n+get_pointer_alignment (tree exp, unsigned int max_align)\n {\n   unsigned int align, inner;\n \n@@ -273,8 +247,7 @@ get_pointer_alignment (exp, max_align)\n    arrays with initializers, so neither can we do so here.  */\n \n static tree\n-c_strlen (src)\n-     tree src;\n+c_strlen (tree src)\n {\n   tree offset_node;\n   HOST_WIDE_INT offset;\n@@ -339,8 +312,7 @@ c_strlen (src)\n    or sum of string constant and integer constant.  */\n \n static const char *\n-c_getstr (src)\n-     tree src;\n+c_getstr (tree src)\n {\n   tree offset_node;\n \n@@ -361,9 +333,7 @@ c_getstr (src)\n    GET_MODE_BITSIZE (MODE) bits from string constant STR.  */\n \n static rtx\n-c_readstr (str, mode)\n-     const char *str;\n-     enum machine_mode mode;\n+c_readstr (const char *str, enum machine_mode mode)\n {\n   HOST_WIDE_INT c[2];\n   HOST_WIDE_INT ch;\n@@ -397,9 +367,7 @@ c_readstr (str, mode)\n    P.  */\n \n static int\n-target_char_cast (cst, p)\n-     tree cst;\n-     char *p;\n+target_char_cast (tree cst, char *p)\n {\n   unsigned HOST_WIDE_INT val, hostval;\n \n@@ -427,10 +395,8 @@ target_char_cast (cst, p)\n    address located within it (depending on FNDECL_CODE).  */\n \n rtx\n-expand_builtin_return_addr (fndecl_code, count, tem)\n-     enum built_in_function fndecl_code;\n-     int count;\n-     rtx tem;\n+expand_builtin_return_addr (enum built_in_function fndecl_code, int count,\n+\t\t\t    rtx tem)\n {\n   int i;\n \n@@ -490,9 +456,7 @@ static HOST_WIDE_INT setjmp_alias_set = -1;\n    handling code.  */\n \n void\n-expand_builtin_setjmp_setup (buf_addr, receiver_label)\n-     rtx buf_addr;\n-     rtx receiver_label;\n+expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n {\n   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n   rtx stack_save;\n@@ -553,8 +517,7 @@ expand_builtin_setjmp_setup (buf_addr, receiver_label)\n    This is used directly by sjlj exception handling code.  */\n \n void\n-expand_builtin_setjmp_receiver (receiver_label)\n-     rtx receiver_label ATTRIBUTE_UNUSED;\n+expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n {\n   /* Clobber the FP when we get here, so we have to make sure it's\n      marked as used by this function.  */\n@@ -626,9 +589,7 @@ expand_builtin_setjmp_receiver (receiver_label)\n    them.  */\n \n static rtx\n-expand_builtin_setjmp (arglist, target)\n-     tree arglist;\n-     rtx target;\n+expand_builtin_setjmp (tree arglist, rtx target)\n {\n   rtx buf_addr, next_lab, cont_lab;\n \n@@ -679,8 +640,7 @@ expand_builtin_setjmp (arglist, target)\n    them.  */\n \n void\n-expand_builtin_longjmp (buf_addr, value)\n-     rtx buf_addr, value;\n+expand_builtin_longjmp (rtx buf_addr, rtx value)\n {\n   rtx fp, lab, stack, insn, last;\n   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n@@ -769,8 +729,7 @@ expand_builtin_longjmp (buf_addr, value)\n    effects.  */\n \n static void\n-expand_builtin_prefetch (arglist)\n-     tree arglist;\n+expand_builtin_prefetch (tree arglist)\n {\n   tree arg0, arg1, arg2;\n   rtx op0, op1, op2;\n@@ -856,8 +815,7 @@ expand_builtin_prefetch (arglist)\n    to be used to be used in a string instruction (cmpstrsi, movstrsi, ..).  */\n \n static rtx\n-get_memory_rtx (exp)\n-     tree exp;\n+get_memory_rtx (tree exp)\n {\n   rtx addr = expand_expr (exp, NULL_RTX, ptr_mode, EXPAND_SUM);\n   rtx mem;\n@@ -919,8 +877,7 @@ static int apply_args_reg_offset[FIRST_PSEUDO_REGISTER];\n    needed in objc-act.c.  */\n \n int\n-apply_args_register_offset (regno)\n-     int regno;\n+apply_args_register_offset (int regno)\n {\n   apply_args_size ();\n \n@@ -936,7 +893,7 @@ apply_args_register_offset (regno)\n    and initialize apply_args_mode.  */\n \n static int\n-apply_args_size ()\n+apply_args_size (void)\n {\n   static int size = -1;\n   int align;\n@@ -1016,7 +973,7 @@ apply_args_size ()\n    and initialize apply_result_mode.  */\n \n static int\n-apply_result_size ()\n+apply_result_size (void)\n {\n   static int size = -1;\n   int align, regno;\n@@ -1092,9 +1049,7 @@ apply_result_size ()\n    restore the values.  */\n \n static rtx\n-result_vector (savep, result)\n-     int savep;\n-     rtx result;\n+result_vector (int savep, rtx result)\n {\n   int regno, size, align, nelts;\n   enum machine_mode mode;\n@@ -1123,7 +1078,7 @@ result_vector (savep, result)\n    arguments as were passed to the current function.  */\n \n static rtx\n-expand_builtin_apply_args_1 ()\n+expand_builtin_apply_args_1 (void)\n {\n   rtx registers;\n   int size, align, regno;\n@@ -1180,7 +1135,7 @@ expand_builtin_apply_args_1 ()\n    saved.  */\n \n static rtx\n-expand_builtin_apply_args ()\n+expand_builtin_apply_args (void)\n {\n   /* Don't do __builtin_apply_args more than once in a function.\n      Save the result of the first call and reuse it.  */\n@@ -1215,8 +1170,7 @@ expand_builtin_apply_args ()\n    untyped return of whatever value was returned by the given function.  */\n \n static rtx\n-expand_builtin_apply (function, arguments, argsize)\n-     rtx function, arguments, argsize;\n+expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n {\n   int size, align, regno;\n   enum machine_mode mode;\n@@ -1371,8 +1325,7 @@ expand_builtin_apply (function, arguments, argsize)\n /* Perform an untyped return.  */\n \n static void\n-expand_builtin_return (result)\n-     rtx result;\n+expand_builtin_return (rtx result)\n {\n   int size, align, regno;\n   enum machine_mode mode;\n@@ -1425,8 +1378,7 @@ expand_builtin_return (result)\n /* Used by expand_builtin_classify_type and fold_builtin_classify_type.  */\n \n static enum type_class\n-type_to_class (type)\n-     tree type;\n+type_to_class (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -1458,8 +1410,7 @@ type_to_class (type)\n    ARGLIST.  */\n \n static rtx\n-expand_builtin_classify_type (arglist)\n-     tree arglist;\n+expand_builtin_classify_type (tree arglist)\n {\n   if (arglist != 0)\n     return GEN_INT (type_to_class (TREE_TYPE (TREE_VALUE (arglist))));\n@@ -1469,9 +1420,7 @@ expand_builtin_classify_type (arglist)\n /* Expand expression EXP, which is a call to __builtin_constant_p.  */\n \n static rtx\n-expand_builtin_constant_p (arglist, target_mode)\n-     tree arglist;\n-     enum machine_mode target_mode;\n+expand_builtin_constant_p (tree arglist, enum machine_mode target_mode)\n {\n   rtx tmp;\n \n@@ -1493,9 +1442,7 @@ expand_builtin_constant_p (arglist, target_mode)\n /* Return mathematic function equivalent to FN but operating directly on TYPE,\n    if available.  */\n tree\n-mathfn_built_in (type, fn)\n-     tree type;\n-     enum built_in_function fn;\n+mathfn_built_in (tree type, enum built_in_function fn)\n {\n   enum built_in_function fcode = NOT_BUILT_IN;\n   if (TYPE_MODE (type) == TYPE_MODE (double_type_node))\n@@ -1704,9 +1651,7 @@ mathfn_built_in (type, fn)\n    errno to EDOM.  */\n \n static void\n-expand_errno_check (exp, target)\n-     tree exp;\n-     rtx target;\n+expand_errno_check (tree exp, rtx target)\n {\n   rtx lab;\n \n@@ -1750,9 +1695,7 @@ expand_errno_check (exp, target)\n    SUBTARGET may be used as the target for computing one of EXP's operands.  */\n \n static rtx\n-expand_builtin_mathfn (exp, target, subtarget)\n-     tree exp;\n-     rtx target, subtarget;\n+expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n {\n   optab builtin_optab;\n   rtx op0, insns;\n@@ -1867,9 +1810,7 @@ expand_builtin_mathfn (exp, target, subtarget)\n    operands.  */\n \n static rtx\n-expand_builtin_mathfn_2 (exp, target, subtarget)\n-     tree exp;\n-     rtx target, subtarget;\n+expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n {\n   optab builtin_optab;\n   rtx op0, op1, insns;\n@@ -1962,10 +1903,8 @@ expand_builtin_mathfn_2 (exp, target, subtarget)\n    try to get the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strlen (arglist, target, target_mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode target_mode;\n+expand_builtin_strlen (tree arglist, rtx target,\n+\t\t       enum machine_mode target_mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2061,10 +2000,7 @@ expand_builtin_strlen (arglist, target, target_mode)\n    in TARGET, if convenient (and in mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_strstr (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strstr (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2117,10 +2053,7 @@ expand_builtin_strstr (arglist, target, mode)\n    in TARGET, if convenient (and in mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_strchr (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strchr (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2163,10 +2096,7 @@ expand_builtin_strchr (arglist, target, mode)\n    in TARGET, if convenient (and in mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_strrchr (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strrchr (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2217,10 +2147,7 @@ expand_builtin_strrchr (arglist, target, mode)\n    in TARGET, if convenient (and in mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_strpbrk (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strpbrk (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2279,10 +2206,8 @@ expand_builtin_strpbrk (arglist, target, mode)\n    constant.  */\n \n static rtx\n-builtin_memcpy_read_str (data, offset, mode)\n-     PTR data;\n-     HOST_WIDE_INT offset;\n-     enum machine_mode mode;\n+builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n+\t\t\t enum machine_mode mode)\n {\n   const char *str = (const char *) data;\n \n@@ -2299,10 +2224,7 @@ builtin_memcpy_read_str (data, offset, mode)\n    otherwise try to get the result in TARGET, if convenient (and in\n    mode MODE if that's convenient).  */\n static rtx\n-expand_builtin_memcpy (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_memcpy (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -2388,11 +2310,8 @@ expand_builtin_memcpy (arglist, target, mode)\n    stpcpy.  */\n \n static rtx\n-expand_builtin_mempcpy (arglist, target, mode, endp)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n-     int endp;\n+expand_builtin_mempcpy (tree arglist, rtx target, enum machine_mode mode,\n+\t\t\tint endp)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -2488,10 +2407,7 @@ expand_builtin_mempcpy (arglist, target, mode, endp)\n    if we failed the caller should emit a normal call.  */\n \n static rtx\n-expand_builtin_memmove (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_memmove (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -2543,8 +2459,7 @@ expand_builtin_memmove (arglist, target, mode)\n    if we failed the caller should emit a normal call.  */\n \n static rtx\n-expand_builtin_bcopy (arglist)\n-     tree arglist;\n+expand_builtin_bcopy (tree arglist)\n {\n   tree src, dest, size, newarglist;\n \n@@ -2574,10 +2489,7 @@ expand_builtin_bcopy (arglist)\n    convenient).  */\n \n static rtx\n-expand_builtin_strcpy (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strcpy (tree arglist, rtx target, enum machine_mode mode)\n {\n   tree fn, len;\n \n@@ -2604,10 +2516,7 @@ expand_builtin_strcpy (arglist, target, mode)\n    mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_stpcpy (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_stpcpy (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2647,10 +2556,8 @@ expand_builtin_stpcpy (arglist, target, mode)\n    constant.  */\n \n static rtx\n-builtin_strncpy_read_str (data, offset, mode)\n-     PTR data;\n-     HOST_WIDE_INT offset;\n-     enum machine_mode mode;\n+builtin_strncpy_read_str (void *data, HOST_WIDE_INT offset,\n+\t\t\t  enum machine_mode mode)\n {\n   const char *str = (const char *) data;\n \n@@ -2664,10 +2571,7 @@ builtin_strncpy_read_str (data, offset, mode)\n    if we failed the caller should emit a normal call.  */\n \n static rtx\n-expand_builtin_strncpy (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strncpy (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -2743,10 +2647,8 @@ expand_builtin_strncpy (arglist, target, mode)\n    constant.  */\n \n static rtx\n-builtin_memset_read_str (data, offset, mode)\n-     PTR data;\n-     HOST_WIDE_INT offset ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+builtin_memset_read_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode)\n {\n   const char *c = (const char *) data;\n   char *p = alloca (GET_MODE_SIZE (mode));\n@@ -2762,10 +2664,8 @@ builtin_memset_read_str (data, offset, mode)\n    4 bytes wide, return the RTL for 0x01010101*data.  */\n \n static rtx\n-builtin_memset_gen_str (data, offset, mode)\n-     PTR data;\n-     HOST_WIDE_INT offset ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+builtin_memset_gen_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode)\n {\n   rtx target, coeff;\n   size_t size;\n@@ -2790,10 +2690,7 @@ builtin_memset_gen_str (data, offset, mode)\n    convenient).  */\n \n static rtx\n-expand_builtin_memset (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -2904,8 +2801,7 @@ expand_builtin_memset (arglist, target, mode)\n    if we failed the caller should emit a normal call.  */\n \n static rtx\n-expand_builtin_bzero (arglist)\n-     tree arglist;\n+expand_builtin_bzero (tree arglist)\n {\n   tree dest, size, newarglist;\n \n@@ -2933,11 +2829,8 @@ expand_builtin_bzero (arglist)\n    TARGET, if convenient (and in mode MODE, if that's convenient).  */\n \n static rtx\n-expand_builtin_memcmp (exp, arglist, target, mode)\n-     tree exp ATTRIBUTE_UNUSED;\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n+\t\t       enum machine_mode mode)\n {\n   tree arg1, arg2, len;\n   const char *p1, *p2;\n@@ -3058,10 +2951,7 @@ expand_builtin_memcmp (exp, arglist, target, mode)\n    the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strcmp (exp, target, mode)\n-     tree exp;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg1, arg2;\n@@ -3189,10 +3079,7 @@ expand_builtin_strcmp (exp, target, mode)\n    the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strncmp (exp, target, mode)\n-     tree exp;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg1, arg2, arg3;\n@@ -3342,10 +3229,7 @@ expand_builtin_strncmp (exp, target, mode)\n    otherwise try to get the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strcat (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strcat (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -3368,10 +3252,7 @@ expand_builtin_strcat (arglist, target, mode)\n    otherwise try to get the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strncat (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strncat (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -3420,10 +3301,7 @@ expand_builtin_strncat (arglist, target, mode)\n    otherwise try to get the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strspn (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strspn (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -3457,10 +3335,7 @@ expand_builtin_strspn (arglist, target, mode)\n    otherwise try to get the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strcspn (arglist, target, mode)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode mode;\n+expand_builtin_strcspn (tree arglist, rtx target, enum machine_mode mode)\n {\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n@@ -3507,7 +3382,7 @@ expand_builtin_strcspn (arglist, target, mode)\n    if that's convenient.  */\n \n rtx\n-expand_builtin_saveregs ()\n+expand_builtin_saveregs (void)\n {\n   rtx val, seq;\n \n@@ -3558,8 +3433,7 @@ expand_builtin_saveregs ()\n    is controlled by the definition of CUMULATIVE_ARGS.  */\n \n static rtx\n-expand_builtin_args_info (arglist)\n-     tree arglist;\n+expand_builtin_args_info (tree arglist)\n {\n   int nwords = sizeof (CUMULATIVE_ARGS) / sizeof (int);\n   int *word_ptr = (int *) &current_function_args_info;\n@@ -3590,8 +3464,7 @@ expand_builtin_args_info (arglist)\n /* Expand ARGLIST, from a call to __builtin_next_arg.  */\n \n static rtx\n-expand_builtin_next_arg (arglist)\n-     tree arglist;\n+expand_builtin_next_arg (tree arglist)\n {\n   tree fntype = TREE_TYPE (current_function_decl);\n \n@@ -3635,9 +3508,7 @@ expand_builtin_next_arg (arglist)\n    from multiple evaluations.  */\n \n static tree\n-stabilize_va_list (valist, needs_lvalue)\n-     tree valist;\n-     int needs_lvalue;\n+stabilize_va_list (tree valist, int needs_lvalue)\n {\n   if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n     {\n@@ -3684,9 +3555,7 @@ stabilize_va_list (valist, needs_lvalue)\n    the variable.  */\n \n void\n-std_expand_builtin_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+std_expand_builtin_va_start (tree valist, rtx nextarg)\n {\n   tree t;\n \n@@ -3700,8 +3569,7 @@ std_expand_builtin_va_start (valist, nextarg)\n /* Expand ARGLIST, from a call to __builtin_va_start.  */\n \n static rtx\n-expand_builtin_va_start (arglist)\n-     tree arglist;\n+expand_builtin_va_start (tree arglist)\n {\n   rtx nextarg;\n   tree chain, valist;\n@@ -3727,8 +3595,7 @@ expand_builtin_va_start (arglist)\n    current (padded) address and increment by the (padded) size.  */\n \n rtx\n-std_expand_builtin_va_arg (valist, type)\n-     tree valist, type;\n+std_expand_builtin_va_arg (tree valist, tree type)\n {\n   tree addr_tree, t, type_size = NULL;\n   tree align, alignm1;\n@@ -3786,8 +3653,7 @@ std_expand_builtin_va_arg (valist, type)\n    a very special sort of operator.  */\n \n rtx\n-expand_builtin_va_arg (valist, type)\n-     tree valist, type;\n+expand_builtin_va_arg (tree valist, tree type)\n {\n   rtx addr, result;\n   tree promoted_type, want_va_type, have_va_type;\n@@ -3887,8 +3753,7 @@ expand_builtin_va_arg (valist, type)\n /* Expand ARGLIST, from a call to __builtin_va_end.  */\n \n static rtx\n-expand_builtin_va_end (arglist)\n-     tree arglist;\n+expand_builtin_va_end (tree arglist)\n {\n   tree valist = TREE_VALUE (arglist);\n \n@@ -3910,8 +3775,7 @@ expand_builtin_va_end (arglist)\n    nastiness of array-type va_list types.  */\n \n static rtx\n-expand_builtin_va_copy (arglist)\n-     tree arglist;\n+expand_builtin_va_copy (tree arglist)\n {\n   tree dst, src, t;\n \n@@ -3964,8 +3828,7 @@ expand_builtin_va_copy (arglist)\n    __builtin_return_address.  */\n \n static rtx\n-expand_builtin_frame_address (fndecl, arglist)\n-     tree fndecl, arglist;\n+expand_builtin_frame_address (tree fndecl, tree arglist)\n {\n   /* The argument must be a nonnegative integer constant.\n      It counts the number of frames to scan up the stack.\n@@ -4014,9 +3877,7 @@ expand_builtin_frame_address (fndecl, arglist)\n    the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_alloca (arglist, target)\n-     tree arglist;\n-     rtx target;\n+expand_builtin_alloca (tree arglist, rtx target)\n {\n   rtx op0;\n   rtx result;\n@@ -4044,11 +3905,8 @@ expand_builtin_alloca (arglist, target)\n    SUBTARGET may be used as the target for computing one of EXP's operands.  */\n \n static rtx\n-expand_builtin_unop (target_mode, arglist, target, subtarget, op_optab)\n-     enum machine_mode target_mode;\n-     tree arglist;\n-     rtx target, subtarget;\n-     optab op_optab;\n+expand_builtin_unop (enum machine_mode target_mode, tree arglist, rtx target,\n+\t\t     rtx subtarget, optab op_optab)\n {\n   rtx op0;\n   if (!validate_arglist (arglist, INTEGER_TYPE, VOID_TYPE))\n@@ -4070,10 +3928,7 @@ expand_builtin_unop (target_mode, arglist, target, subtarget, op_optab)\n    long, we attempt to transform this call into __builtin_fputc().  */\n \n static rtx\n-expand_builtin_fputs (arglist, ignore, unlocked)\n-     tree arglist;\n-     int ignore;\n-     int unlocked;\n+expand_builtin_fputs (tree arglist, int ignore, int unlocked)\n {\n   tree len, fn;\n   tree fn_fputc = unlocked ? implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED]\n@@ -4154,9 +4009,7 @@ expand_builtin_fputs (arglist, ignore, unlocked)\n    a non-jump context.  */\n \n static rtx\n-expand_builtin_expect (arglist, target)\n-     tree arglist;\n-     rtx target;\n+expand_builtin_expect (tree arglist, rtx target)\n {\n   tree exp, c;\n   rtx note, rtx_c;\n@@ -4200,10 +4053,7 @@ expand_builtin_expect (arglist, target)\n    based on the test being 0/1.  */\n \n rtx\n-expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n-     tree exp;\n-     rtx if_false_label;\n-     rtx if_true_label;\n+expand_builtin_expect_jump (tree exp, rtx if_false_label, rtx if_true_label)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree arg0 = TREE_VALUE (arglist);\n@@ -4314,7 +4164,7 @@ expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n }\n \n void\n-expand_builtin_trap ()\n+expand_builtin_trap (void)\n {\n #ifdef HAVE_trap\n   if (HAVE_trap)\n@@ -4332,9 +4182,7 @@ expand_builtin_trap ()\n    the operand.  */\n \n static rtx\n-expand_builtin_fabs (arglist, target, subtarget)\n-     tree arglist;\n-     rtx target, subtarget;\n+expand_builtin_fabs (tree arglist, rtx target, rtx subtarget)\n {\n   enum machine_mode mode;\n   tree arg;\n@@ -4355,9 +4203,7 @@ expand_builtin_fabs (arglist, target, subtarget)\n    in target.  */\n \n static rtx\n-expand_builtin_cabs (arglist, target)\n-     tree arglist;\n-     rtx target;\n+expand_builtin_cabs (tree arglist, rtx target)\n {\n   enum machine_mode mode;\n   tree arg;\n@@ -4383,12 +4229,8 @@ expand_builtin_cabs (arglist, target)\n    IGNORE is nonzero if the value is to be ignored.  */\n \n rtx\n-expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget;\n-     enum machine_mode mode;\n-     int ignore;\n+expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n+\t\tint ignore)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -4963,10 +4805,9 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n    taking a single real argument, then the return value is the\n    DECL_FUNCTION_CODE of the call, e.g. BUILT_IN_SQRT.  Otherwise\n    the return value is END_BUILTINS.  */\n-   \n+\n enum built_in_function\n-builtin_mathfn_code (t)\n-     tree t;\n+builtin_mathfn_code (tree t)\n {\n   tree fndecl, arglist;\n \n@@ -5013,8 +4854,7 @@ builtin_mathfn_code (t)\n    constant.  ARGLIST is the argument list of the call.  */\n \n static tree\n-fold_builtin_constant_p (arglist)\n-     tree arglist;\n+fold_builtin_constant_p (tree arglist)\n {\n   if (arglist == 0)\n     return 0;\n@@ -5054,8 +4894,7 @@ fold_builtin_constant_p (arglist)\n /* Fold a call to __builtin_classify_type.  */\n \n static tree\n-fold_builtin_classify_type (arglist)\n-     tree arglist;\n+fold_builtin_classify_type (tree arglist)\n {\n   if (arglist == 0)\n     return build_int_2 (no_type_class, 0);\n@@ -5066,9 +4905,7 @@ fold_builtin_classify_type (arglist)\n /* Fold a call to __builtin_inf or __builtin_huge_val.  */\n \n static tree\n-fold_builtin_inf (type, warn)\n-     tree type;\n-     int warn;\n+fold_builtin_inf (tree type, int warn)\n {\n   REAL_VALUE_TYPE real;\n \n@@ -5082,9 +4919,7 @@ fold_builtin_inf (type, warn)\n /* Fold a call to __builtin_nan or __builtin_nans.  */\n \n static tree\n-fold_builtin_nan (arglist, type, quiet)\n-     tree arglist, type;\n-     int quiet;\n+fold_builtin_nan (tree arglist, tree type, int quiet)\n {\n   REAL_VALUE_TYPE real;\n   const char *str;\n@@ -5105,8 +4940,7 @@ fold_builtin_nan (arglist, type, quiet)\n    across (for instance floor((double)f) == (double)floorf (f).\n    Do the transformation.  */\n static tree\n-fold_trunc_transparent_mathfn (exp)\n-     tree exp;\n+fold_trunc_transparent_mathfn (tree exp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -5136,8 +4970,7 @@ fold_trunc_transparent_mathfn (exp)\n    type.  Return NULL_TREE if no simplification can be made.  */\n \n static tree\n-fold_builtin_cabs (fndecl, arglist, type)\n-     tree fndecl, arglist, type;\n+fold_builtin_cabs (tree fndecl, tree arglist, tree type)\n {\n   tree arg;\n \n@@ -5221,8 +5054,7 @@ fold_builtin_cabs (fndecl, arglist, type)\n    the CALL_EXPR of a call to a builtin function.  */\n \n tree\n-fold_builtin (exp)\n-     tree exp;\n+fold_builtin (tree exp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -5699,8 +5531,7 @@ fold_builtin (exp)\n /* Conveniently construct a function call expression.  */\n \n tree\n-build_function_call_expr (fn, arglist)\n-     tree fn, arglist;\n+build_function_call_expr (tree fn, tree arglist)\n {\n   tree call_expr;\n \n@@ -5722,7 +5553,7 @@ validate_arglist (tree arglist, ...)\n   enum tree_code code;\n   int res = 0;\n   va_list ap;\n-  \n+\n   va_start (ap, arglist);\n \n   do\n@@ -5763,27 +5594,26 @@ validate_arglist (tree arglist, ...)\n /* Default version of target-specific builtin setup that does nothing.  */\n \n void\n-default_init_builtins ()\n+default_init_builtins (void)\n {\n }\n \n /* Default target-specific builtin expander that does nothing.  */\n \n rtx\n-default_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp ATTRIBUTE_UNUSED;\n-     rtx target ATTRIBUTE_UNUSED;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore ATTRIBUTE_UNUSED;\n+default_expand_builtin (tree exp ATTRIBUTE_UNUSED,\n+\t\t\trtx target ATTRIBUTE_UNUSED,\n+\t\t\trtx subtarget ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\tint ignore ATTRIBUTE_UNUSED)\n {\n   return NULL_RTX;\n }\n \n /* Instantiate all remaining CONSTANT_P_RTX nodes.  */\n \n void\n-purge_builtin_constant_p ()\n+purge_builtin_constant_p (void)\n {\n   rtx insn, set, arg, new, note;\n "}, {"sha": "394d947f113233846153782ade6614f6c7802c1e", "filename": "gcc/expr.h", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -352,25 +352,23 @@ extern rtx get_condition PARAMS ((rtx, rtx *));\n extern rtx gen_cond_trap PARAMS ((enum rtx_code, rtx, rtx, rtx));\n \f\n /* Functions from builtins.c:  */\n-extern rtx expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n-extern void std_expand_builtin_va_start PARAMS ((tree, rtx));\n-extern rtx std_expand_builtin_va_arg PARAMS ((tree, tree));\n-extern rtx expand_builtin_va_arg PARAMS ((tree, tree));\n-extern void default_init_builtins PARAMS ((void));\n-extern rtx default_expand_builtin PARAMS ((tree, rtx, rtx,\n-\t\t\t\t\t   enum machine_mode, int));\n-extern void expand_builtin_setjmp_setup PARAMS ((rtx, rtx));\n-extern void expand_builtin_setjmp_receiver PARAMS ((rtx));\n-extern void expand_builtin_longjmp PARAMS ((rtx, rtx));\n-extern rtx expand_builtin_saveregs PARAMS ((void));\n-extern void expand_builtin_trap PARAMS ((void));\n-extern HOST_WIDE_INT get_varargs_alias_set PARAMS ((void));\n-extern HOST_WIDE_INT get_frame_alias_set PARAMS ((void));\n-extern void record_base_value\t\tPARAMS ((unsigned int, rtx, int));\n-extern void record_alias_subset         PARAMS ((HOST_WIDE_INT,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n-extern HOST_WIDE_INT new_alias_set\t\tPARAMS ((void));\n-extern int can_address_p\t\tPARAMS ((tree));\n+extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern void std_expand_builtin_va_start (tree, rtx);\n+extern rtx std_expand_builtin_va_arg (tree, tree);\n+extern rtx expand_builtin_va_arg (tree, tree);\n+extern void default_init_builtins (void);\n+extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern void expand_builtin_setjmp_setup (rtx, rtx);\n+extern void expand_builtin_setjmp_receiver (rtx);\n+extern void expand_builtin_longjmp (rtx, rtx);\n+extern rtx expand_builtin_saveregs (void);\n+extern void expand_builtin_trap (void);\n+extern HOST_WIDE_INT get_varargs_alias_set (void);\n+extern HOST_WIDE_INT get_frame_alias_set (void);\n+extern void record_base_value (unsigned int, rtx, int);\n+extern void record_alias_subset (HOST_WIDE_INT, HOST_WIDE_INT);\n+extern HOST_WIDE_INT new_alias_set (void);\n+extern int can_address_p (tree);\n \f\n /* Functions from expr.c:  */\n "}, {"sha": "b7d8745211f7cfed729a367b111ce19b2d5ef9db", "filename": "gcc/rtl.h", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -1406,8 +1406,8 @@ extern int ceil_log2\t\t\tPARAMS ((unsigned HOST_WIDE_INT));\n #define plus_constant(X, C) plus_constant_wide ((X), (HOST_WIDE_INT) (C))\n \n /* In builtins.c */\n-extern rtx expand_builtin_expect_jump\tPARAMS ((tree, rtx, rtx));\n-extern void purge_builtin_constant_p\tPARAMS ((void));\n+extern rtx expand_builtin_expect_jump (tree, rtx, rtx);\n+extern void purge_builtin_constant_p (void);\n \n /* In explow.c */\n extern void set_stack_check_libfunc PARAMS ((rtx));\n@@ -1558,8 +1558,8 @@ extern rtx prev_cc0_setter\t\tPARAMS ((rtx));\n \n /* In cfglayout.c  */\n extern tree choose_inner_scope\t\tPARAMS ((tree, tree));\n-extern int insn_line \t\t\tPARAMS ((rtx));\n-extern const char * insn_file \t\tPARAMS ((rtx));\n+extern int insn_line\t\t\tPARAMS ((rtx));\n+extern const char * insn_file\t\tPARAMS ((rtx));\n extern int prologue_locator, epilogue_locator;\n \n /* In jump.c */\n@@ -2320,23 +2320,22 @@ extern void fancy_abort PARAMS ((const char *, int, const char *))\n #define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n \n /* In alias.c */\n-extern void clear_reg_alias_info\tPARAMS ((rtx));\n-extern rtx canon_rtx                    PARAMS ((rtx));\n-extern int true_dependence\t\tPARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t\tint (*)(rtx, int)));\n-extern rtx get_addr                     PARAMS ((rtx));\n-extern int canon_true_dependence        PARAMS ((rtx, enum machine_mode, rtx,\n-                                                rtx, int (*)(rtx, int)));\n-extern int read_dependence\t\tPARAMS ((rtx, rtx));\n-extern int anti_dependence\t\tPARAMS ((rtx, rtx));\n-extern int output_dependence\t\tPARAMS ((rtx, rtx));\n-extern void mark_constant_function\tPARAMS ((void));\n-extern void init_alias_once\t\tPARAMS ((void));\n-extern void init_alias_analysis\t\tPARAMS ((void));\n-extern void end_alias_analysis\t\tPARAMS ((void));\n-extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n-extern bool memory_modified_in_insn_p\tPARAMS ((rtx, rtx));\n-extern rtx find_base_term\t\tPARAMS ((rtx));\n+extern void clear_reg_alias_info (rtx);\n+extern rtx canon_rtx (rtx);\n+extern int true_dependence (rtx, enum machine_mode, rtx, int (*)(rtx, int));\n+extern rtx get_addr (rtx);\n+extern int canon_true_dependence (rtx, enum machine_mode, rtx, rtx,\n+\t\t\t\t  int (*)(rtx, int));\n+extern int read_dependence (rtx, rtx);\n+extern int anti_dependence (rtx, rtx);\n+extern int output_dependence (rtx, rtx);\n+extern void mark_constant_function (void);\n+extern void init_alias_once (void);\n+extern void init_alias_analysis (void);\n+extern void end_alias_analysis (void);\n+extern rtx addr_side_effect_eval (rtx, int, int);\n+extern bool memory_modified_in_insn_p (rtx, rtx);\n+extern rtx find_base_term (rtx);\n \n /* In sibcall.c */\n typedef enum {"}, {"sha": "aeee9d9107f622545d25950828249ea4fd113d2b", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4682ae0463c9fcc254fe1c8ede9da9133a9956bc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4682ae0463c9fcc254fe1c8ede9da9133a9956bc", "patch": "@@ -2199,11 +2199,11 @@ extern void default_register_cpp_builtins PARAMS ((struct cpp_reader *));\n \n /* Split a list of declspecs and attributes into two.  */\n \n-extern void split_specs_attrs\t\tPARAMS ((tree, tree *, tree *));\n+extern void split_specs_attrs (tree, tree *, tree *);\n \n /* Strip attributes from a list of combined specs and attrs.  */\n \n-extern tree strip_attrs\t\t\tPARAMS ((tree));\n+extern tree strip_attrs (tree);\n \n /* Return 1 if an attribute and its arguments are valid for a decl or type.  */\n \n@@ -2892,7 +2892,7 @@ extern bool alloca_call_p\t\tPARAMS ((tree));\n    from tree.h.  Depending on these flags, some attributes may be\n    returned to be applied at a later stage (for example, to apply\n    a decl attribute to the declaration rather than to its type).  */\n-extern tree decl_attributes\t\tPARAMS ((tree *, tree, int));\n+extern tree decl_attributes (tree *, tree, int);\n \n /* In integrate.c */\n extern void save_for_inline\t\tPARAMS ((tree));"}]}