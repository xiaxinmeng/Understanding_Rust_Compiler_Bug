{"sha": "8cbb664efd48c0be633d1a63a87888da5b77f06d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNiYjY2NGVmZDQ4YzBiZTYzM2QxYTYzYTg3ODg4ZGE1Yjc3ZjA2ZA==", "commit": {"author": {"name": "Matthew Gingell", "email": "gingell@gcc.gnu.org", "date": "2002-03-28T15:33:09Z"}, "committer": {"name": "Matthew Gingell", "email": "gingell@gcc.gnu.org", "date": "2002-03-28T15:33:09Z"}, "message": "* checks.ads:\n\n\t(Remove_Checks): New procedure\n\n\t* checks.adb:\n\t(Remove_Checks): New procedure\n\n\t* exp_util.adb:\n\tUse new Duplicate_Subexpr functions\n\t(Duplicate_Subexpr_No_Checks): New procedure\n\t(Duplicate_Subexpr_No_Checks_Orig): New procedure\n\t(Duplicate_Subexpr): Restore original form (checks duplicated)\n\t(Duplicate_Subexpr): Call Remove_Checks\n\n\t* exp_util.ads:\n\t(Duplicate_Subexpr_No_Checks): New procedure\n\t(Duplicate_Subexpr_No_Checks_Orig): New procedure\n\tAdd 2002 to copyright notice\n\n\t* sem_util.adb: Use new Duplicate_Subexpr functions\n\n\t* sem_eval.adb:\n\t(Eval_Indexed_Component): This is the place to call\n\tConstant_Array_Ref and to replace the value. We simply merge\n\tthe code of this function in here, since it is now no longer\n\tused elsewhere. This fixes the problem of the back end not\n\trealizing we were clever enough to see that this was\n\tconstant.\n\t(Expr_Val): Remove call to Constant_Array_Ref\n\t(Expr_Rep_Val): Remove call to Constant_Array_Ref\n\tMinor reformatting\n\t(Constant_Array_Ref): Deal with string literals (patch\n\tsuggested by Zack Weinberg on the gcc list)\n\n\t* exp_util.adb: Duplicate_Subexpr_No_Checks_Orig =>\n\tDuplicate_Subexpr_Move_Checks.\n\n\t* exp_util.ads: Duplicate_Subexpr_No_Checks_Orig =>\n\tDuplicate_Subexpr_Move_Checks.\n\n\t* sem_eval.adb: (Constant_Array_Ref): Verify that constant\n\tvalue of array exists before retrieving it (it may a private\n\tprotected component in a function).\n\nFrom-SVN: r51513", "tree": {"sha": "de291fbe38321eee24920156c79d6252aa6b59ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de291fbe38321eee24920156c79d6252aa6b59ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cbb664efd48c0be633d1a63a87888da5b77f06d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cbb664efd48c0be633d1a63a87888da5b77f06d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cbb664efd48c0be633d1a63a87888da5b77f06d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cbb664efd48c0be633d1a63a87888da5b77f06d/comments", "author": null, "committer": null, "parents": [{"sha": "792c4e744099b705a889e0676b8f1f71fb467343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792c4e744099b705a889e0676b8f1f71fb467343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792c4e744099b705a889e0676b8f1f71fb467343"}], "stats": {"total": 403, "additions": 302, "deletions": 101}, "files": [{"sha": "5105950589c86218e459a5146ee3b84251fc1087", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8cbb664efd48c0be633d1a63a87888da5b77f06d", "patch": "@@ -1,3 +1,50 @@\n+2001-03-28  Robert Dewar <dewar@gnat.com>\n+\n+\t* checks.ads:\n+\t(Remove_Checks): New procedure\n+\n+\t* checks.adb:\n+\t(Remove_Checks): New procedure\n+\n+\t* exp_util.adb:\n+\tUse new Duplicate_Subexpr functions\n+\t(Duplicate_Subexpr_No_Checks): New procedure\n+\t(Duplicate_Subexpr_No_Checks_Orig): New procedure\n+\t(Duplicate_Subexpr): Restore original form (checks duplicated)\n+\t(Duplicate_Subexpr): Call Remove_Checks\n+\n+\t* exp_util.ads: \n+\t(Duplicate_Subexpr_No_Checks): New procedure\n+\t(Duplicate_Subexpr_No_Checks_Orig): New procedure\n+\tAdd 2002 to copyright notice\n+\n+\t* sem_util.adb: Use new Duplicate_Subexpr functions\n+\n+\t* sem_eval.adb: \t\n+\t(Eval_Indexed_Component): This is the place to call\n+\tConstant_Array_Ref and to replace the value. We simply merge\n+\tthe code of this function in here, since it is now no longer\n+\tused elsewhere. This fixes the problem of the back end not\n+\trealizing we were clever enough to see that this was\n+\tconstant.\n+\t(Expr_Val): Remove call to Constant_Array_Ref\n+\t(Expr_Rep_Val): Remove call to Constant_Array_Ref\n+\tMinor reformatting\n+\t(Constant_Array_Ref): Deal with string literals (patch\n+\tsuggested by Zack Weinberg on the gcc list)\n+\n+2001-03-28  Ed Schonberg <schonber@gnat.com>\n+\n+\t* exp_util.adb: Duplicate_Subexpr_No_Checks_Orig => \n+\tDuplicate_Subexpr_Move_Checks.\n+\n+\t* exp_util.ads: Duplicate_Subexpr_No_Checks_Orig => \n+\tDuplicate_Subexpr_Move_Checks.\n+\n+\t* sem_eval.adb: (Constant_Array_Ref): Verify that constant \n+\tvalue of array exists before retrieving it (it may a private \n+\tprotected component in a function).\n+\n 2002-03-28   Geert Bosch <bosch@gnat.com>\n \n \t* prj-pp.adb : New file."}, {"sha": "327f1cc751bca6c6cac53701378712cc7b979e1c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=8cbb664efd48c0be633d1a63a87888da5b77f06d", "patch": "@@ -2918,6 +2918,104 @@ package body Checks is\n         or else Vax_Float (E);\n    end Range_Checks_Suppressed;\n \n+   -------------------\n+   -- Remove_Checks --\n+   -------------------\n+\n+   procedure Remove_Checks (Expr : Node_Id) is\n+      Discard : Traverse_Result;\n+\n+      function Process (N : Node_Id) return Traverse_Result;\n+      --  Process a single node during the traversal\n+\n+      function Traverse is new Traverse_Func (Process);\n+      --  The traversal function itself\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      function Process (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) not in N_Subexpr then\n+            return Skip;\n+         end if;\n+\n+         Set_Do_Range_Check (N, False);\n+\n+         case Nkind (N) is\n+            when N_And_Then =>\n+               Discard := Traverse (Left_Opnd (N));\n+               return Skip;\n+\n+            when N_Attribute_Reference =>\n+               Set_Do_Access_Check (N, False);\n+               Set_Do_Overflow_Check (N, False);\n+\n+            when N_Explicit_Dereference =>\n+               Set_Do_Access_Check (N, False);\n+\n+            when N_Function_Call =>\n+               Set_Do_Tag_Check (N, False);\n+\n+            when N_Indexed_Component =>\n+               Set_Do_Access_Check (N, False);\n+\n+            when N_Op =>\n+               Set_Do_Overflow_Check (N, False);\n+\n+               case Nkind (N) is\n+                  when N_Op_Divide =>\n+                     Set_Do_Division_Check (N, False);\n+\n+                  when N_Op_And =>\n+                     Set_Do_Length_Check (N, False);\n+\n+                  when N_Op_Mod =>\n+                     Set_Do_Division_Check (N, False);\n+\n+                  when N_Op_Or =>\n+                     Set_Do_Length_Check (N, False);\n+\n+                  when N_Op_Rem =>\n+                     Set_Do_Division_Check (N, False);\n+\n+                  when N_Op_Xor =>\n+                     Set_Do_Length_Check (N, False);\n+\n+                  when others =>\n+                     null;\n+               end case;\n+\n+            when N_Or_Else =>\n+               Discard := Traverse (Left_Opnd (N));\n+               return Skip;\n+\n+            when N_Selected_Component =>\n+               Set_Do_Access_Check (N, False);\n+               Set_Do_Discriminant_Check (N, False);\n+\n+            when N_Slice =>\n+               Set_Do_Access_Check (N, False);\n+\n+            when N_Type_Conversion =>\n+               Set_Do_Length_Check (N, False);\n+               Set_Do_Overflow_Check (N, False);\n+               Set_Do_Tag_Check (N, False);\n+\n+            when others =>\n+               null;\n+         end case;\n+\n+         return OK;\n+      end Process;\n+\n+   --  Start of processing for Remove_Checks\n+\n+   begin\n+      Discard := Traverse (Expr);\n+   end Remove_Checks;\n+\n    ----------------------------\n    -- Selected_Length_Checks --\n    ----------------------------"}, {"sha": "e35e889e0bf0dde77f3c40ba5b046ebd72d96e08", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=8cbb664efd48c0be633d1a63a87888da5b77f06d", "patch": "@@ -496,6 +496,11 @@ package Checks is\n    --  the sense of the 'Valid attribute returning True. Constraint_Error\n    --  will be raised if the value is not valid.\n \n+   procedure Remove_Checks (Expr : Node_Id);\n+   --  Remove all checks from Expr except those that are only executed\n+   --  conditionally (on the right side of And Then/Or Else. This call\n+   --  removes only embedded checks (Do_Range_Check, Do_Overflow_Check).\n+\n private\n \n    type Check_Result is array (Positive range 1 .. 2) of Node_Id;"}, {"sha": "1acd0df0c2b328b317b9e01dd5654367728b8383", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=8cbb664efd48c0be633d1a63a87888da5b77f06d", "patch": "@@ -969,6 +969,42 @@ package body Exp_Util is\n       return New_Copy_Tree (Exp);\n    end Duplicate_Subexpr;\n \n+   ---------------------------------\n+   -- Duplicate_Subexpr_No_Checks --\n+   ---------------------------------\n+\n+   function Duplicate_Subexpr_No_Checks\n+     (Exp      : Node_Id;\n+      Name_Req : Boolean := False)\n+      return     Node_Id\n+   is\n+      New_Exp : Node_Id;\n+\n+   begin\n+      Remove_Side_Effects (Exp, Name_Req);\n+      New_Exp := New_Copy_Tree (Exp);\n+      Remove_Checks (New_Exp);\n+      return New_Exp;\n+   end Duplicate_Subexpr_No_Checks;\n+\n+   -----------------------------------\n+   -- Duplicate_Subexpr_Move_Checks --\n+   -----------------------------------\n+\n+   function Duplicate_Subexpr_Move_Checks\n+     (Exp      : Node_Id;\n+      Name_Req : Boolean := False)\n+      return     Node_Id\n+   is\n+      New_Exp : Node_Id;\n+\n+   begin\n+      Remove_Side_Effects (Exp, Name_Req);\n+      New_Exp := New_Copy_Tree (Exp);\n+      Remove_Checks (Exp);\n+      return New_Exp;\n+   end Duplicate_Subexpr_Move_Checks;\n+\n    --------------------\n    -- Ensure_Defined --\n    --------------------\n@@ -2310,7 +2346,8 @@ package body Exp_Util is\n         Make_Op_Subtract (Loc,\n           Left_Opnd =>\n             Make_Attribute_Reference (Loc,\n-              Prefix         => OK_Convert_To (T, Duplicate_Subexpr (E)),\n+              Prefix =>\n+                OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E)),\n               Attribute_Name => Name_Size),\n           Right_Opnd =>\n             Make_Attribute_Reference (Loc,\n@@ -2452,7 +2489,9 @@ package body Exp_Util is\n          Utyp        := Underlying_Type (Unc_Typ);\n          Full_Subtyp := Make_Defining_Identifier (Loc,\n                           New_Internal_Name ('C'));\n-         Full_Exp    := Unchecked_Convert_To (Utyp, Duplicate_Subexpr (E));\n+         Full_Exp    :=\n+           Unchecked_Convert_To\n+             (Utyp, Duplicate_Subexpr_No_Checks (E));\n          Set_Parent (Full_Exp, Parent (E));\n \n          Priv_Subtyp :=\n@@ -2490,13 +2529,14 @@ package body Exp_Util is\n               Make_Range (Loc,\n                 Low_Bound =>\n                   Make_Attribute_Reference (Loc,\n-                    Prefix => Duplicate_Subexpr (E),\n+                    Prefix => Duplicate_Subexpr_No_Checks (E),\n                     Attribute_Name => Name_First,\n                     Expressions => New_List (\n                       Make_Integer_Literal (Loc, J))),\n+\n                 High_Bound =>\n                   Make_Attribute_Reference (Loc,\n-                    Prefix         => Duplicate_Subexpr (E),\n+                    Prefix         => Duplicate_Subexpr_No_Checks (E),\n                     Attribute_Name => Name_Last,\n                     Expressions    => New_List (\n                       Make_Integer_Literal (Loc, J)))));\n@@ -2530,7 +2570,7 @@ package body Exp_Util is\n \n             Append_To (List_Constr,\n               Make_Selected_Component (Loc,\n-                Prefix        => Duplicate_Subexpr (E),\n+                Prefix        => Duplicate_Subexpr_No_Checks (E),\n                 Selector_Name => New_Reference_To (D, Loc)));\n \n             Next_Discriminant (D);"}, {"sha": "c83b97ef1e01a5f33e13db374debfc0d3c285b33", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=8cbb664efd48c0be633d1a63a87888da5b77f06d", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                                                                          --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -243,6 +243,32 @@ package Exp_Util is\n    --  copy after it is attached to the tree. The Name_Req flag is set to\n    --  ensure that the result is suitable for use in a context requiring a\n    --  name (e.g. the prefix of an attribute reference).\n+   --\n+   --  Note that if there are any run time checks in Exp, these same checks\n+   --  will be duplicated in the returned duplicated expression. The two\n+   --  following functions allow this behavior to be modified.\n+\n+   function Duplicate_Subexpr_No_Checks\n+     (Exp      : Node_Id;\n+      Name_Req : Boolean := False)\n+      return     Node_Id;\n+   --  Identical in effect to Duplicate_Subexpr, except that Remove_Checks\n+   --  is called on the result, so that the duplicated expression does not\n+   --  include checks. This is appropriate for use when Exp, the original\n+   --  expression is unconditionally elaborated before the duplicated\n+   --  expression, so that there is no need to repeat any checks.\n+\n+   function Duplicate_Subexpr_Move_Checks\n+     (Exp      : Node_Id;\n+      Name_Req : Boolean := False)\n+      return     Node_Id;\n+   --  Identical in effect to Duplicate_Subexpr, except that Remove_Checks\n+   --  is called on Exp after the duplication is complete, so that the\n+   --  original expression does not include checks. In this case the result\n+   --  returned (the duplicated expression) will retain the original checks.\n+   --  This is appropriate for use when the duplicated expression is sure\n+   --  to be elaborated before the original expression Exp, so that there\n+   --  is no need to repeat the checks.\n \n    procedure Ensure_Defined (Typ : Entity_Id; N : Node_Id);\n    --  This procedure ensures that type referenced by Typ is defined. For the"}, {"sha": "ba031b13f4c72d3119601b82fbe28a8e5805adea", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 73, "deletions": 91, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=8cbb664efd48c0be633d1a63a87888da5b77f06d", "patch": "@@ -32,6 +32,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Eval_Fat; use Eval_Fat;\n+with Exp_Util; use Exp_Util;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n@@ -127,14 +128,6 @@ package body Sem_Eval is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Constant_Array_Ref (Op : Node_Id) return Node_Id;\n-   --  The caller has checked that Op is an array reference (i.e. that its\n-   --  node kind is N_Indexed_Component). If the array reference is constant\n-   --  at compile time, and yields a constant value of a discrete type, then\n-   --  the expression node for the constant value is returned. otherwise Empty\n-   --  is returned. This is used by Compile_Time_Known_Value, as well as by\n-   --  Expr_Value and Expr_Rep_Value.\n-\n    function From_Bits (B : Bits; T : Entity_Id) return Uint;\n    --  Converts a bit string of length B'Length to a Uint value to be used\n    --  for a target of type T, which is a modular type. This procedure\n@@ -730,7 +723,6 @@ package body Sem_Eval is\n    function Compile_Time_Known_Value (Op : Node_Id) return Boolean is\n       K      : constant Node_Kind := Nkind (Op);\n       CV_Ent : CV_Entry renames CV_Cache (Nat (Op) mod CV_Cache_Size);\n-      Val    : Node_Id;\n \n    begin\n       --  Never known at compile time if bad type or raises constraint error\n@@ -800,17 +792,6 @@ package body Sem_Eval is\n \n          elsif K = N_Attribute_Reference then\n             return Attribute_Name (Op) = Name_Null_Parameter;\n-\n-         --  A reference to an element of a constant array may be constant.\n-\n-         elsif K = N_Indexed_Component then\n-            Val := Constant_Array_Ref (Op);\n-\n-            if Present (Val) then\n-               CV_Ent.N := Op;\n-               CV_Ent.V := Expr_Value (Val);\n-               return True;\n-            end if;\n          end if;\n       end if;\n \n@@ -908,58 +889,6 @@ package body Sem_Eval is\n       end if;\n    end Compile_Time_Known_Value_Or_Aggr;\n \n-   ------------------------\n-   -- Constant_Array_Ref --\n-   ------------------------\n-\n-   function Constant_Array_Ref (Op : Node_Id) return Node_Id is\n-   begin\n-      if List_Length (Expressions (Op)) = 1\n-        and then Is_Entity_Name (Prefix (Op))\n-        and then Ekind (Entity (Prefix (Op))) = E_Constant\n-      then\n-         declare\n-            Arr : constant Node_Id := Constant_Value (Entity (Prefix (Op)));\n-            Sub : constant Node_Id := First (Expressions (Op));\n-            Aty : constant Node_Id := Etype (Arr);\n-\n-            Lin : Nat;\n-            --  Linear one's origin subscript value for array reference\n-\n-            Lbd : Node_Id;\n-            --  Lower bound of the first array index\n-\n-            Elm : Node_Id;\n-            --  Value from constant array\n-\n-         begin\n-            if Ekind (Aty) = E_String_Literal_Subtype then\n-               Lbd := String_Literal_Low_Bound (Aty);\n-            else\n-               Lbd := Type_Low_Bound (Etype (First_Index (Aty)));\n-            end if;\n-\n-            if Compile_Time_Known_Value (Sub)\n-              and then Nkind (Arr) = N_Aggregate\n-              and then Compile_Time_Known_Value (Lbd)\n-              and then Is_Discrete_Type (Component_Type (Aty))\n-            then\n-               Lin := UI_To_Int (Expr_Value (Sub) - Expr_Value (Lbd)) + 1;\n-\n-               if List_Length (Expressions (Arr)) >= Lin then\n-                  Elm := Pick (Expressions (Arr), Lin);\n-\n-                  if Compile_Time_Known_Value (Elm) then\n-                     return Elm;\n-                  end if;\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-\n-      return Empty;\n-   end Constant_Array_Ref;\n-\n    -----------------\n    -- Eval_Actual --\n    -----------------\n@@ -1140,7 +1069,6 @@ package body Sem_Eval is\n       end if;\n \n       Set_Is_Static_Expression (N, Stat);\n-\n    end Eval_Arithmetic_Op;\n \n    ----------------------------\n@@ -1344,8 +1272,9 @@ package body Sem_Eval is\n    -- Eval_Indexed_Component --\n    ----------------------------\n \n-   --  Indexed components are never static, so the only required processing\n-   --  is to perform the check for non-static context on the index values.\n+   --  Indexed components are never static, so we need to perform the check\n+   --  for non-static context on the index values. Then, we check if the\n+   --  value can be obtained at compile time, even though it is non-static.\n \n    procedure Eval_Indexed_Component (N : Node_Id) is\n       Expr : Node_Id;\n@@ -1357,6 +1286,74 @@ package body Sem_Eval is\n          Next (Expr);\n       end loop;\n \n+      --  See if this is a constant array reference\n+\n+      if List_Length (Expressions (N)) = 1\n+        and then Is_Entity_Name (Prefix (N))\n+        and then Ekind (Entity (Prefix (N))) = E_Constant\n+        and then Present (Constant_Value (Entity (Prefix (N))))\n+      then\n+         declare\n+            Loc : constant Source_Ptr := Sloc (N);\n+            Arr : constant Node_Id    := Constant_Value (Entity (Prefix (N)));\n+            Sub : constant Node_Id    := First (Expressions (N));\n+\n+            Atyp : Entity_Id;\n+            --  Type of array\n+\n+            Lin : Nat;\n+            --  Linear one's origin subscript value for array reference\n+\n+            Lbd : Node_Id;\n+            --  Lower bound of the first array index\n+\n+            Elm : Node_Id;\n+            --  Value from constant array\n+\n+         begin\n+            Atyp := Etype (Arr);\n+\n+            if Is_Access_Type (Atyp) then\n+               Atyp := Designated_Type (Atyp);\n+            end if;\n+\n+            --  If we have an array type (we should have but perhaps there\n+            --  are error cases where this is not the case), then see if we\n+            --  can do a constant evaluation of the array reference.\n+\n+            if Is_Array_Type (Atyp) then\n+               if Ekind (Atyp) = E_String_Literal_Subtype then\n+                  Lbd := String_Literal_Low_Bound (Atyp);\n+               else\n+                  Lbd := Type_Low_Bound (Etype (First_Index (Atyp)));\n+               end if;\n+\n+               if Compile_Time_Known_Value (Sub)\n+                 and then Nkind (Arr) = N_Aggregate\n+                 and then Compile_Time_Known_Value (Lbd)\n+                 and then Is_Discrete_Type (Component_Type (Atyp))\n+               then\n+                  Lin := UI_To_Int (Expr_Value (Sub) - Expr_Value (Lbd)) + 1;\n+\n+                  if List_Length (Expressions (Arr)) >= Lin then\n+                     Elm := Pick (Expressions (Arr), Lin);\n+\n+                     --  If the resulting expression is compile time known,\n+                     --  then we can rewrite the indexed component with this\n+                     --  value, being sure to mark the result as non-static.\n+                     --  We also reset the Sloc, in case this generates an\n+                     --  error later on (e.g. 136'Access).\n+\n+                     if Compile_Time_Known_Value (Elm) then\n+                        Rewrite (N, Duplicate_Subexpr_No_Checks (Elm));\n+                        Set_Is_Static_Expression (N, False);\n+                        Set_Sloc (N, Loc);\n+                     end if;\n+                  end if;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n    end Eval_Indexed_Component;\n \n    --------------------------\n@@ -2465,7 +2462,6 @@ package body Sem_Eval is\n    function Expr_Rep_Value (N : Node_Id) return Uint is\n       Kind : constant Node_Kind := Nkind (N);\n       Ent  : Entity_Id;\n-      Vexp : Node_Id;\n \n    begin\n       if Is_Entity_Name (N) then\n@@ -2506,14 +2502,8 @@ package body Sem_Eval is\n       then\n          return Uint_0;\n \n-      --  Array reference case\n-\n-      elsif Kind = N_Indexed_Component then\n-         Vexp := Constant_Array_Ref (N);\n-         pragma Assert (Present (Vexp));\n-         return Expr_Rep_Value (Vexp);\n-\n       --  Otherwise must be character literal\n+\n       else\n          pragma Assert (Kind = N_Character_Literal);\n          Ent := Entity (N);\n@@ -2541,7 +2531,6 @@ package body Sem_Eval is\n       CV_Ent : CV_Entry renames CV_Cache (Nat (N) mod CV_Cache_Size);\n       Ent    : Entity_Id;\n       Val    : Uint;\n-      Vexp   : Node_Id;\n \n    begin\n       --  If already in cache, then we know it's compile time known and\n@@ -2593,13 +2582,6 @@ package body Sem_Eval is\n       then\n          Val := Uint_0;\n \n-      --  Array reference case\n-\n-      elsif Kind = N_Indexed_Component then\n-         Vexp := Constant_Array_Ref (N);\n-         pragma Assert (Present (Vexp));\n-         Val := Expr_Value (Vexp);\n-\n       --  Otherwise must be character literal\n \n       else"}, {"sha": "5c8c4a400bf6f8e3823be35ebe00f737e4ccba2f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cbb664efd48c0be633d1a63a87888da5b77f06d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8cbb664efd48c0be633d1a63a87888da5b77f06d", "patch": "@@ -187,14 +187,16 @@ package body Sem_Util is\n \n             Lo :=\n               Make_Attribute_Reference (Loc,\n-                Prefix         => Duplicate_Subexpr (Obj, Name_Req => True),\n+                Prefix         =>\n+                  Duplicate_Subexpr_No_Checks (Obj, Name_Req => True),\n                 Attribute_Name => Name_First,\n                 Expressions    => New_List (\n                   Make_Integer_Literal (Loc, J)));\n \n             Hi :=\n               Make_Attribute_Reference (Loc,\n-                Prefix         => Duplicate_Subexpr (Obj, Name_Req => True),\n+                Prefix         =>\n+                  Duplicate_Subexpr_No_Checks (Obj, Name_Req => True),\n                 Attribute_Name => Name_Last,\n                 Expressions    => New_List (\n                   Make_Integer_Literal (Loc, J)));\n@@ -226,7 +228,8 @@ package body Sem_Util is\n          while Present (Discr) loop\n             Append_To (Constraints,\n               Make_Selected_Component (Loc,\n-                Prefix => Duplicate_Subexpr (Obj),\n+                Prefix =>\n+                  Duplicate_Subexpr_No_Checks (Obj),\n                 Selector_Name => New_Occurrence_Of (Discr, Loc)));\n             Next_Discriminant (Discr);\n          end loop;\n@@ -2056,7 +2059,7 @@ package body Sem_Util is\n                           Make_Component_Association (Sloc (Typ),\n                             New_List\n                               (New_Occurrence_Of (D, Sloc (Typ))),\n-                            Duplicate_Subexpr (Node (C)));\n+                            Duplicate_Subexpr_No_Checks (Node (C)));\n                         exit Find_Constraint;\n                      end if;\n "}]}