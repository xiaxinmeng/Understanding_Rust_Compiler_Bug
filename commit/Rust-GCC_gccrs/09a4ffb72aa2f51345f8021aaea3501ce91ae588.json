{"sha": "09a4ffb72aa2f51345f8021aaea3501ce91ae588", "node_id": "C_kwDOANBUbNoAKDA5YTRmZmI3MmFhMmY1MTM0NWY4MDIxYWFlYTM1MDFjZTkxYWU1ODg", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-21T12:21:32Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-21T12:22:34Z"}, "message": "Refactor load/store/kill analysis in ipa-modref\n\nRefactor load/store/kill analysis in ipa-modref to a class\nmodref_access_analysis.  This is done in order to avoid some code duplication\nand early exits that has turned out to be hard to maintain and there were\nmultiple bugs we noticed recently.\n\ngcc/ChangeLog:\n\n2021-11-21  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (ignore_nondeterminism_p): Move earlier in source\n\tcode.\n\t(ignore_retval_p): Likewise.\n\t(ignore_stores_p): Likewise.\n\t(parm_map_for_arg): Likewise.\n\t(class modref_access_analysis): New class.\n\t(modref_access_analysis::set_side_effects): New member function.\n\t(modref_access_analysis::set_nondeterministic): New member function.\n\t(get_access): Turn to ...\n\t(modref_access_analysis::get_access): ... this one.\n\t(record_access): Turn to ...\n\t(modref_access_analysis::record_access): ... this one.\n\t(record_access_lto): Turn to ...\n\t(modref_access_analysis::record_access_lto): ... This one.\n\t(record_access_p): Turn to ...\n\t(modref_access_analysis::record_access_p): ... This one\n\t(modref_access_analysis::record_unknown_load): New member function.\n\t(modref_access_analysis::record_unknown_store): New member function.\n\t(get_access_for_fnspec): Turn to ...\n\t(modref_access_analysis::get_access_for_fnspec): ... this one.\n\t(merge_call_side_effects): Turn to ...\n\t(moderf_access_analysis::merge_call_side_effects): Turn to ...\n\t(collapse_loads): Move later in source code.\n\t(collapse_stores): Move later in source code.\n\t(process_fnspec): Turn to ...\n\t(modref_access_analysis::process_fnspec): ... this one.\n\t(analyze_call): Turn to ...\n\t(modref_access_analysis::analyze_call): ... this one.\n\t(struct summary_ptrs): Remove.\n\t(analyze_load): Turn to ...\n\t(modref_access_analysis::analyze_load): ... this one.\n\t(analyze_store): Turn to ...\n\t(modref_access_analysis::analyze_store): ... this one.\n\t(analyze_stmt): Turn to ...\n\t(modref_access_analysis::analyze_stmt): ... This one.\n\t(remove_summary): Remove.\n\t(modref_access_analysis::propagate): Break out from ...\n\t(modref_access_analysis::analyze): Break out from ...\n\t(analyze_function): ... here.", "tree": {"sha": "00a17c979c6db0c5949a33f501920301855a11fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00a17c979c6db0c5949a33f501920301855a11fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09a4ffb72aa2f51345f8021aaea3501ce91ae588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a4ffb72aa2f51345f8021aaea3501ce91ae588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09a4ffb72aa2f51345f8021aaea3501ce91ae588", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a4ffb72aa2f51345f8021aaea3501ce91ae588/comments", "author": null, "committer": null, "parents": [{"sha": "dc915b361bbc99da83fc53db7f7e0e28d0ce12c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc915b361bbc99da83fc53db7f7e0e28d0ce12c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc915b361bbc99da83fc53db7f7e0e28d0ce12c8"}], "stats": {"total": 946, "additions": 511, "deletions": 435}, "files": [{"sha": "a04e5855a9a337df254e295b236dca71e7bce090", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 511, "deletions": 435, "changes": 946, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a4ffb72aa2f51345f8021aaea3501ce91ae588/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a4ffb72aa2f51345f8021aaea3501ce91ae588/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=09a4ffb72aa2f51345f8021aaea3501ce91ae588", "patch": "@@ -775,9 +775,177 @@ get_modref_function_summary (gcall *call, bool *interposed)\n \n namespace {\n \n+/* Return true if ECF flags says that nondeterminsm can be ignored.  */\n+\n+static bool\n+ignore_nondeterminism_p (tree caller, int flags)\n+{\n+  if (flags & (ECF_CONST | ECF_PURE))\n+    return true;\n+  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n+      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n+    return true;\n+  return false;\n+}\n+\n+/* Return true if ECF flags says that return value can be ignored.  */\n+\n+static bool\n+ignore_retval_p (tree caller, int flags)\n+{\n+  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n+      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n+    return true;\n+  return false;\n+}\n+\n+/* Return true if ECF flags says that stores can be ignored.  */\n+\n+static bool\n+ignore_stores_p (tree caller, int flags)\n+{\n+  if (flags & (ECF_PURE | ECF_CONST | ECF_NOVOPS))\n+    return true;\n+  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n+      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n+    return true;\n+  return false;\n+}\n+\n+/* Determine parm_map for argument OP.  */\n+\n+modref_parm_map\n+parm_map_for_arg (tree op)\n+{\n+  bool offset_known;\n+  poly_int64 offset;\n+  struct modref_parm_map parm_map;\n+\n+  parm_map.parm_offset_known = false;\n+  parm_map.parm_offset = 0;\n+\n+  offset_known = unadjusted_ptr_and_unit_offset (op, &op, &offset);\n+  if (TREE_CODE (op) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (op)\n+      && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n+    {\n+      int index = 0;\n+      for (tree t = DECL_ARGUMENTS (current_function_decl);\n+\t   t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n+\t{\n+\t  if (!t)\n+\t    {\n+\t      index = MODREF_UNKNOWN_PARM;\n+\t      break;\n+\t    }\n+\t  index++;\n+\t}\n+      parm_map.parm_index = index;\n+      parm_map.parm_offset_known = offset_known;\n+      parm_map.parm_offset = offset;\n+    }\n+  else if (points_to_local_or_readonly_memory_p (op))\n+    parm_map.parm_index = MODREF_LOCAL_MEMORY_PARM;\n+  else\n+    parm_map.parm_index = MODREF_UNKNOWN_PARM;\n+  return parm_map;\n+}\n+\n+/* Analyze memory accesses (loads, stores and kills) performed\n+   by the function.  Set also side_effects, calls_interposable\n+   and nondeterminism flags.  */\n+\n+class modref_access_analysis\n+{\n+public:\n+  modref_access_analysis (bool ipa, modref_summary *summary,\n+\t\t\t  modref_summary_lto *summary_lto)\n+  : m_summary (summary), m_summary_lto (summary_lto), m_ipa (ipa)\n+  {\n+  }\n+  void analyze ();\n+private:\n+  bool set_side_effects ();\n+  bool set_nondeterministic ();\n+  static modref_access_node get_access (ao_ref *ref);\n+  static void record_access (modref_records *, ao_ref *, modref_access_node &);\n+  static void record_access_lto (modref_records_lto *, ao_ref *,\n+\t\t\t\t modref_access_node &a);\n+  bool record_access_p (tree);\n+  bool record_unknown_load ();\n+  bool record_unknown_store ();\n+  bool merge_call_side_effects (gimple *, modref_summary *,\n+\t\t\t\tcgraph_node *, bool);\n+  modref_access_node get_access_for_fnspec (gcall *, attr_fnspec &,\n+\t\t\t\t\t    unsigned int, modref_parm_map &);\n+  void process_fnspec (gcall *);\n+  void analyze_call (gcall *);\n+  static bool analyze_load (gimple *, tree, tree, void *);\n+  static bool analyze_store (gimple *, tree, tree, void *);\n+  void analyze_stmt (gimple *, bool);\n+  void propagate ();\n+\n+  /* Summary being computed.\n+     We work eitehr with m_summary or m_summary_lto.  Never on both.  */\n+  modref_summary *m_summary;\n+  modref_summary_lto *m_summary_lto;\n+  /* Recursive calls needs simplisitc dataflow after analysis finished.\n+     Collect all calls into this vector during analysis and later process\n+     them in propagate.  */\n+  auto_vec <gimple *, 32> m_recursive_calls;\n+  /* ECF flags of function being analysed.  */\n+  int m_ecf_flags;\n+  /* True if IPA propagation will be done later.  */\n+  bool m_ipa;\n+  /* Set true if statement currently analysed is known to be\n+     executed each time function is called.  */\n+  bool m_always_executed;\n+};\n+\n+/* Set side_effects flag and return if someting changed.  */\n+\n+bool\n+modref_access_analysis::set_side_effects ()\n+{\n+  bool changed = false;\n+\n+  if (m_summary && !m_summary->side_effects)\n+    {\n+      m_summary->side_effects = true;\n+      changed = true;\n+    }\n+  if (m_summary_lto && !m_summary_lto->side_effects)\n+    {\n+      m_summary_lto->side_effects = true;\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n+/* Set nondeterministic flag and return if someting changed.  */\n+\n+bool\n+modref_access_analysis::set_nondeterministic ()\n+{\n+  bool changed = false;\n+\n+  if (m_summary && !m_summary->nondeterministic)\n+    {\n+      m_summary->side_effects = m_summary->nondeterministic = true;\n+      changed = true;\n+    }\n+  if (m_summary_lto && !m_summary_lto->nondeterministic)\n+    {\n+      m_summary_lto->side_effects = m_summary_lto->nondeterministic = true;\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n /* Construct modref_access_node from REF.  */\n-static modref_access_node\n-get_access (ao_ref *ref)\n+\n+modref_access_node\n+modref_access_analysis::get_access (ao_ref *ref)\n {\n   tree base;\n \n@@ -822,8 +990,10 @@ get_access (ao_ref *ref)\n \n /* Record access into the modref_records data structure.  */\n \n-static void\n-record_access (modref_records *tt, ao_ref *ref, modref_access_node &a)\n+void\n+modref_access_analysis::record_access (modref_records *tt,\n+\t\t\t\t       ao_ref *ref,\n+\t\t\t\t       modref_access_node &a)\n {\n   alias_set_type base_set = !flag_strict_aliasing ? 0\n \t\t\t    : ao_ref_base_alias_set (ref);\n@@ -840,8 +1010,9 @@ record_access (modref_records *tt, ao_ref *ref, modref_access_node &a)\n \n /* IPA version of record_access_tree.  */\n \n-static void\n-record_access_lto (modref_records_lto *tt, ao_ref *ref, modref_access_node &a)\n+void\n+modref_access_analysis::record_access_lto (modref_records_lto *tt, ao_ref *ref,\n+\t\t\t\t\t   modref_access_node &a)\n {\n   /* get_alias_set sometimes use different type to compute the alias set\n      than TREE_TYPE (base).  Do same adjustments.  */\n@@ -906,9 +1077,23 @@ record_access_lto (modref_records_lto *tt, ao_ref *ref, modref_access_node &a)\n /* Returns true if and only if we should store the access to EXPR.\n    Some accesses, e.g. loads from automatic variables, are not interesting.  */\n \n-static bool\n-record_access_p (tree expr)\n+bool\n+modref_access_analysis::record_access_p (tree expr)\n {\n+  if (TREE_THIS_VOLATILE (expr))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" (volatile; marking nondeterministic) \");\n+      set_nondeterministic ();\n+    }\n+  if (cfun->can_throw_non_call_exceptions\n+      && tree_could_throw_p (expr))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" (can throw; marking side effects) \");\n+      set_side_effects ();\n+    }\n+\n   if (refs_local_or_readonly_memory_p (expr))\n     {\n       if (dump_file)\n@@ -918,154 +1103,120 @@ record_access_p (tree expr)\n   return true;\n }\n \n-/* Return true if ECF flags says that nondeterminsm can be ignored.  */\n-\n-static bool\n-ignore_nondeterminism_p (tree caller, int flags)\n-{\n-  if (flags & (ECF_CONST | ECF_PURE))\n-    return true;\n-  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n-      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n-    return true;\n-  return false;\n-}\n-\n-/* Return true if ECF flags says that return value can be ignored.  */\n+/* Collapse loads and return true if something changed.  */\n \n-static bool\n-ignore_retval_p (tree caller, int flags)\n+bool\n+modref_access_analysis::record_unknown_load ()\n {\n-  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n-      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n-    return true;\n-  return false;\n-}\n-\n-/* Return true if ECF flags says that stores can be ignored.  */\n+  bool changed = false;\n \n-static bool\n-ignore_stores_p (tree caller, int flags)\n-{\n-  if (flags & (ECF_PURE | ECF_CONST | ECF_NOVOPS))\n-    return true;\n-  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n-      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n-    return true;\n-  return false;\n+  if (m_summary && !m_summary->loads->every_base)\n+    {\n+      m_summary->loads->collapse ();\n+      changed = true;\n+    }\n+  if (m_summary_lto && !m_summary_lto->loads->every_base)\n+    {\n+      m_summary_lto->loads->collapse ();\n+      changed = true;\n+    }\n+  return changed;\n }\n \n-/* Determine parm_map for argument OP.  */\n+/* Collapse loads and return true if something changed.  */\n \n-modref_parm_map\n-parm_map_for_arg (tree op)\n+bool\n+modref_access_analysis::record_unknown_store ()\n {\n-  bool offset_known;\n-  poly_int64 offset;\n-  struct modref_parm_map parm_map;\n-\n-  parm_map.parm_offset_known = false;\n-  parm_map.parm_offset = 0;\n+  bool changed = false;\n \n-  offset_known = unadjusted_ptr_and_unit_offset (op, &op, &offset);\n-  if (TREE_CODE (op) == SSA_NAME\n-      && SSA_NAME_IS_DEFAULT_DEF (op)\n-      && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n+  if (m_summary && !m_summary->stores->every_base)\n     {\n-      int index = 0;\n-      for (tree t = DECL_ARGUMENTS (current_function_decl);\n-\t   t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n-\t{\n-\t  if (!t)\n-\t    {\n-\t      index = MODREF_UNKNOWN_PARM;\n-\t      break;\n-\t    }\n-\t  index++;\n-\t}\n-      parm_map.parm_index = index;\n-      parm_map.parm_offset_known = offset_known;\n-      parm_map.parm_offset = offset;\n+      m_summary->stores->collapse ();\n+      changed = true;\n     }\n-  else if (points_to_local_or_readonly_memory_p (op))\n-    parm_map.parm_index = MODREF_LOCAL_MEMORY_PARM;\n-  else\n-    parm_map.parm_index = MODREF_UNKNOWN_PARM;\n-  return parm_map;\n+  if (m_summary_lto && !m_summary_lto->stores->every_base)\n+    {\n+      m_summary_lto->stores->collapse ();\n+      changed = true;\n+    }\n+  return changed;\n }\n \n-/* Merge side effects of call STMT to function with CALLEE_SUMMARY\n-   int CUR_SUMMARY.  Return true if something changed.\n+/* Merge side effects of call STMT to function with CALLEE_SUMMARY.\n+   Return true if something changed.\n    If IGNORE_STORES is true, do not merge stores.\n    If RECORD_ADJUSTMENTS is true cap number of adjustments to\n    a given access to make dataflow finite.  */\n \n bool\n-merge_call_side_effects (modref_summary *cur_summary,\n-\t\t\t gimple *stmt, modref_summary *callee_summary,\n-\t\t\t bool ignore_stores, cgraph_node *callee_node,\n-\t\t\t bool record_adjustments, bool always_executed)\n+modref_access_analysis::merge_call_side_effects\n+\t (gimple *stmt, modref_summary *callee_summary,\n+\t  cgraph_node *callee_node, bool record_adjustments)\n {\n-  auto_vec <modref_parm_map, 32> parm_map;\n-  modref_parm_map chain_map;\n-  bool changed = false;\n   int flags = gimple_call_flags (stmt);\n \n+  /* Nothing to do for non-looping cont functions.  */\n   if ((flags & (ECF_CONST | ECF_NOVOPS))\n       && !(flags & ECF_LOOPING_CONST_OR_PURE))\n-    return changed;\n+    return false;\n+\n+  bool changed = false;\n \n   if (dump_file)\n     fprintf (dump_file, \" - Merging side effects of %s\\n\",\n \t     callee_node->dump_name ());\n \n+  /* Merge side effects and non-determinism.\n+     PURE/CONST flags makes functions deterministic and if there is\n+     no LOOPING_CONST_OR_PURE they also have no side effects.  */\n   if (!(flags & (ECF_CONST | ECF_NOVOPS | ECF_PURE))\n       || (flags & ECF_LOOPING_CONST_OR_PURE))\n     {\n-      if (!cur_summary->side_effects && callee_summary->side_effects)\n+      if (!m_summary->side_effects && callee_summary->side_effects)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \" - merging side effects.\\n\");\n-\t  cur_summary->side_effects = true;\n+\t  m_summary->side_effects = true;\n \t  changed = true;\n \t}\n-      if (!cur_summary->nondeterministic && callee_summary->nondeterministic\n+      if (!m_summary->nondeterministic && callee_summary->nondeterministic\n \t  && !ignore_nondeterminism_p (current_function_decl, flags))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \" - merging nondeterministic.\\n\");\n-\t  cur_summary->nondeterministic = true;\n+\t  m_summary->nondeterministic = true;\n \t  changed = true;\n \t}\n      }\n \n+  /* For const functions we are done.  */\n   if (flags & (ECF_CONST | ECF_NOVOPS))\n     return changed;\n \n-  if (!cur_summary->calls_interposable && callee_summary->calls_interposable)\n+  /* Merge calls_interposable flags.  */\n+  if (!m_summary->calls_interposable && callee_summary->calls_interposable)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \" - merging calls interposable.\\n\");\n-      cur_summary->calls_interposable = true;\n+      m_summary->calls_interposable = true;\n       changed = true;\n     }\n \n-  /* We can not safely optimize based on summary of callee if it does\n-     not always bind to current def: it is possible that memory load\n-     was optimized out earlier which may not happen in the interposed\n-     variant.  */\n-  if (!callee_node->binds_to_current_def_p ()\n-      && !cur_summary->calls_interposable)\n+  if (!callee_node->binds_to_current_def_p () && !m_summary->calls_interposable)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \" - May be interposed.\\n\");\n-      cur_summary->calls_interposable = true;\n+      m_summary->calls_interposable = true;\n       changed = true;\n     }\n \n+  /* Now merge the actual load, store and kill vectors.  For this we need\n+     to compute map translating new parameters to old.  */\n   if (dump_file)\n     fprintf (dump_file, \"   Parm map:\");\n \n+  auto_vec <modref_parm_map, 32> parm_map;\n   parm_map.safe_grow_cleared (gimple_call_num_args (stmt), true);\n   for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n@@ -1081,6 +1232,8 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t    }\n \t}\n     }\n+\n+  modref_parm_map chain_map;\n   if (gimple_call_chain (stmt))\n     {\n       chain_map = parm_map_for_arg (gimple_call_chain (stmt));\n@@ -1098,7 +1251,9 @@ merge_call_side_effects (modref_summary *cur_summary,\n   if (dump_file)\n     fprintf (dump_file, \"\\n\");\n \n-  if (always_executed\n+  /* Kills can me merged in only if we know the function is going to be\n+     always executed.  */\n+  if (m_always_executed\n       && callee_summary->kills.length ()\n       && (!cfun->can_throw_non_call_exceptions\n \t  || !stmt_could_throw_p (cfun, stmt)))\n@@ -1124,24 +1279,25 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t  modref_access_node n = kill;\n \t  n.parm_index = m.parm_index;\n \t  n.parm_offset += m.parm_offset;\n-\t  if (modref_access_node::insert_kill (cur_summary->kills, n,\n+\t  if (modref_access_node::insert_kill (m_summary->kills, n,\n \t\t\t\t\t       record_adjustments))\n \t    changed = true;\n \t}\n     }\n \n-  /* Merge with callee's summary.  */\n-  changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map,\n-\t\t\t\t\t&chain_map, record_adjustments);\n-  if (!ignore_stores)\n+  /* Merge in loads.  */\n+  changed |= m_summary->loads->merge (callee_summary->loads, &parm_map,\n+\t\t\t\t      &chain_map, record_adjustments);\n+  /* Merge in stores.  */\n+  if (!ignore_stores_p (current_function_decl, flags))\n     {\n-      changed |= cur_summary->stores->merge (callee_summary->stores,\n-\t\t\t\t\t     &parm_map, &chain_map,\n-\t\t\t\t\t     record_adjustments);\n-      if (!cur_summary->writes_errno\n+      changed |= m_summary->stores->merge (callee_summary->stores,\n+\t\t\t\t\t   &parm_map, &chain_map,\n+\t\t\t\t\t   record_adjustments);\n+      if (!m_summary->writes_errno\n \t  && callee_summary->writes_errno)\n \t{\n-\t  cur_summary->writes_errno = true;\n+\t  m_summary->writes_errno = true;\n \t  changed = true;\n \t}\n     }\n@@ -1150,9 +1306,10 @@ merge_call_side_effects (modref_summary *cur_summary,\n \n /* Return access mode for argument I of call STMT with FNSPEC.  */\n \n-static modref_access_node\n-get_access_for_fnspec (gcall *call, attr_fnspec &fnspec,\n-\t\t       unsigned int i, modref_parm_map &map)\n+modref_access_node\n+modref_access_analysis::get_access_for_fnspec (gcall *call, attr_fnspec &fnspec,\n+\t\t\t\t\t       unsigned int i,\n+\t\t\t\t\t       modref_parm_map &map)\n {\n   tree size = NULL_TREE;\n   unsigned int size_arg;\n@@ -1185,97 +1342,46 @@ get_access_for_fnspec (gcall *call, attr_fnspec &fnspec,\n   return a;\n }\n \n-/* Collapse loads and return true if something changed.  */\n-\n-static bool\n-collapse_loads (modref_summary *cur_summary,\n-\t\tmodref_summary_lto *cur_summary_lto)\n-{\n-  bool changed = false;\n-\n-  if (cur_summary && !cur_summary->loads->every_base)\n-    {\n-      cur_summary->loads->collapse ();\n-      changed = true;\n-    }\n-  if (cur_summary_lto\n-      && !cur_summary_lto->loads->every_base)\n-    {\n-      cur_summary_lto->loads->collapse ();\n-      changed = true;\n-    }\n-  return changed;\n-}\n-\n-/* Collapse loads and return true if something changed.  */\n-\n-static bool\n-collapse_stores (modref_summary *cur_summary,\n-\t\tmodref_summary_lto *cur_summary_lto)\n-{\n-  bool changed = false;\n-\n-  if (cur_summary && !cur_summary->stores->every_base)\n-    {\n-      cur_summary->stores->collapse ();\n-      changed = true;\n-    }\n-  if (cur_summary_lto\n-      && !cur_summary_lto->stores->every_base)\n-    {\n-      cur_summary_lto->stores->collapse ();\n-      changed = true;\n-    }\n-  return changed;\n-}\n-\n-\n /* Apply side effects of call STMT to CUR_SUMMARY using FNSPEC.\n    If IGNORE_STORES is true ignore them.\n    Return false if no useful summary can be produced.   */\n \n-static bool\n-process_fnspec (modref_summary *cur_summary,\n-\t\tmodref_summary_lto *cur_summary_lto,\n-\t\tgcall *call, bool ignore_stores)\n+void\n+modref_access_analysis::process_fnspec (gcall *call)\n {\n-  attr_fnspec fnspec = gimple_call_fnspec (call);\n   int flags = gimple_call_flags (call);\n \n+  /* PURE/CONST flags makes functions deterministic and if there is\n+     no LOOPING_CONST_OR_PURE they also have no side effects.  */\n   if (!(flags & (ECF_CONST | ECF_NOVOPS | ECF_PURE))\n       || (flags & ECF_LOOPING_CONST_OR_PURE)\n       || (cfun->can_throw_non_call_exceptions\n \t  && stmt_could_throw_p (cfun, call)))\n     {\n-      if (cur_summary)\n-\t{\n-\t  cur_summary->side_effects = true;\n-\t  if (!ignore_nondeterminism_p (current_function_decl, flags))\n-\t    cur_summary->nondeterministic = true;\n-\t}\n-      if (cur_summary_lto)\n-\t{\n-\t  cur_summary_lto->side_effects = true;\n-\t  if (!ignore_nondeterminism_p (current_function_decl, flags))\n-\t    cur_summary_lto->nondeterministic = true;\n-\t}\n+      set_side_effects ();\n+      if (!ignore_nondeterminism_p (current_function_decl, flags))\n+\tset_nondeterministic ();\n     }\n+\n+  /* For const functions we are done.  */\n   if (flags & (ECF_CONST | ECF_NOVOPS))\n-    return true;\n+    return;\n+\n+  attr_fnspec fnspec = gimple_call_fnspec (call);\n+  /* If there is no fnpec we know nothing about loads & stores.  */\n   if (!fnspec.known_p ())\n     {\n       if (dump_file && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n \tfprintf (dump_file, \"      Builtin with no fnspec: %s\\n\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl (call))));\n-      if (ignore_stores)\n-\t{\n-\t  collapse_loads (cur_summary, cur_summary_lto);\n-\t  return true;\n-\t}\n-      return false;\n+      record_unknown_load ();\n+      if (!ignore_stores_p (current_function_decl, flags))\n+\trecord_unknown_store ();\n+      return;\n     }\n+  /* Process fnspec.  */\n   if (fnspec.global_memory_read_p ())\n-    collapse_loads (cur_summary, cur_summary_lto);\n+    record_unknown_load ();\n   else\n     {\n       for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n@@ -1291,27 +1397,20 @@ process_fnspec (modref_summary *cur_summary,\n \t      continue;\n \t    if (map.parm_index == MODREF_UNKNOWN_PARM)\n \t      {\n-\t\tcollapse_loads (cur_summary, cur_summary_lto);\n+\t\trecord_unknown_load ();\n \t\tbreak;\n \t      }\n-\t    if (cur_summary)\n-\t      cur_summary->loads->insert (0, 0,\n-\t\t\t\t\t  get_access_for_fnspec (call,\n-\t\t\t\t\t\t\t\t fnspec, i,\n-\t\t\t\t\t\t\t\t map),\n-\t\t\t\t\t  false);\n-\t    if (cur_summary_lto)\n-\t      cur_summary_lto->loads->insert (0, 0,\n-\t\t\t\t\t      get_access_for_fnspec (call,\n-\t\t\t\t\t\t\t\t     fnspec, i,\n-\t\t\t\t\t\t\t\t     map),\n-\t\t\t\t\t      false);\n+\t    modref_access_node a = get_access_for_fnspec (call, fnspec, i, map);\n+\t    if (m_summary)\n+\t      m_summary->loads->insert (0, 0, a, false);\n+\t    if (m_summary_lto)\n+\t      m_summary_lto->loads->insert (0, 0, a, false);\n \t  }\n     }\n-  if (ignore_stores)\n-    return true;\n+  if (ignore_stores_p (current_function_decl, flags))\n+    return;\n   if (fnspec.global_memory_written_p ())\n-    collapse_stores (cur_summary, cur_summary_lto);\n+    record_unknown_store ();\n   else\n     {\n       for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n@@ -1327,58 +1426,45 @@ process_fnspec (modref_summary *cur_summary,\n \t      continue;\n \t    if (map.parm_index == MODREF_UNKNOWN_PARM)\n \t      {\n-\t\tcollapse_stores (cur_summary, cur_summary_lto);\n+\t\trecord_unknown_store ();\n \t\tbreak;\n \t      }\n-\t    if (cur_summary)\n-\t      cur_summary->stores->insert (0, 0,\n-\t\t\t\t\t   get_access_for_fnspec (call,\n-\t\t\t\t\t\t\t\t  fnspec, i,\n-\t\t\t\t\t\t\t\t  map),\n-\t\t\t\t\t   false);\n-\t    if (cur_summary_lto)\n-\t      cur_summary_lto->stores->insert (0, 0,\n-\t\t\t\t\t       get_access_for_fnspec (call,\n-\t\t\t\t\t\t\t\t      fnspec, i,\n-\t\t\t\t\t\t\t\t      map),\n-\t\t\t\t\t       false);\n+\t    modref_access_node a = get_access_for_fnspec (call, fnspec, i, map);\n+\t    if (m_summary)\n+\t      m_summary->stores->insert (0, 0, a, false);\n+\t    if (m_summary_lto)\n+\t      m_summary_lto->stores->insert (0, 0, a, false);\n \t  }\n       if (fnspec.errno_maybe_written_p () && flag_errno_math)\n \t{\n-\t  if (cur_summary)\n-\t    cur_summary->writes_errno = true;\n-\t  if (cur_summary_lto)\n-\t    cur_summary_lto->writes_errno = true;\n+\t  if (m_summary)\n+\t    m_summary->writes_errno = true;\n+\t  if (m_summary_lto)\n+\t    m_summary_lto->writes_errno = true;\n \t}\n     }\n-  return true;\n }\n \n /* Analyze function call STMT in function F.\n    Remember recursive calls in RECURSIVE_CALLS.  */\n \n-static bool\n-analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n-\t      gcall *stmt, vec <gimple *> *recursive_calls,\n-\t      bool always_executed)\n+void\n+modref_access_analysis::analyze_call (gcall *stmt)\n {\n   /* Check flags on the function call.  In certain cases, analysis can be\n      simplified.  */\n   int flags = gimple_call_flags (stmt);\n+\n   if ((flags & (ECF_CONST | ECF_NOVOPS))\n       && !(flags & ECF_LOOPING_CONST_OR_PURE))\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n \t\t \" - ECF_CONST | ECF_NOVOPS, ignoring all stores and all loads \"\n \t\t \"except for args.\\n\");\n-      return true;\n+      return;\n     }\n \n-  /* Pure functions do not affect global memory.  Stores by functions which are\n-     noreturn and do not throw can safely be ignored.  */\n-  bool ignore_stores = ignore_stores_p (current_function_decl, flags);\n-\n   /* Next, we try to get the callee's function declaration.  The goal is to\n      merge their summary with ours.  */\n   tree callee = gimple_call_fndecl (stmt);\n@@ -1389,25 +1475,23 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n       if (dump_file)\n \tfprintf (dump_file, gimple_call_internal_p (stmt)\n \t\t ? \" - Internal call\" : \" - Indirect call.\\n\");\n-      return process_fnspec (cur_summary, cur_summary_lto, stmt, ignore_stores);\n+      process_fnspec (stmt);\n+      return;\n     }\n   /* We only need to handle internal calls in IPA mode.  */\n-  gcc_checking_assert (!cur_summary_lto);\n+  gcc_checking_assert (!m_summary_lto && !m_ipa);\n \n   struct cgraph_node *callee_node = cgraph_node::get_create (callee);\n \n   /* If this is a recursive call, the target summary is the same as ours, so\n      there's nothing to do.  */\n   if (recursive_call_p (current_function_decl, callee))\n     {\n-      recursive_calls->safe_push (stmt);\n-      if (cur_summary)\n-\tcur_summary->side_effects = true;\n-      if (cur_summary_lto)\n-\tcur_summary_lto->side_effects = true;\n+      m_recursive_calls.safe_push (stmt);\n+      set_side_effects ();\n       if (dump_file)\n \tfprintf (dump_file, \" - Skipping recursive call.\\n\");\n-      return true;\n+      return;\n     }\n \n   gcc_assert (callee_node != NULL);\n@@ -1419,21 +1503,18 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n   if (builtin_safe_for_const_function_p (&looping, callee))\n     {\n       if (looping)\n-\t{\n-\t  if (cur_summary)\n-\t    cur_summary->side_effects = true;\n-\t  if (cur_summary_lto)\n-\t    cur_summary_lto->side_effects = true;\n-\t}\n+\tset_side_effects ();\n       if (dump_file)\n-\tfprintf (dump_file, \" - Bulitin is safe for const.\\n\");\n-      return true;\n+\tfprintf (dump_file, \" - Builtin is safe for const.\\n\");\n+      return;\n     }\n   if (avail <= AVAIL_INTERPOSABLE)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \" - Function availability <= AVAIL_INTERPOSABLE.\\n\");\n-      return process_fnspec (cur_summary, cur_summary_lto, stmt, ignore_stores);\n+\tfprintf (dump_file,\n+\t\t \" - Function availability <= AVAIL_INTERPOSABLE.\\n\");\n+      process_fnspec (stmt);\n+      return;\n     }\n \n   /* Get callee's modref summary.  As above, if there's no summary, we either\n@@ -1443,31 +1524,21 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n     {\n       if (dump_file)\n \tfprintf (dump_file, \" - No modref summary available for callee.\\n\");\n-      return process_fnspec (cur_summary, cur_summary_lto, stmt, ignore_stores);\n+      process_fnspec (stmt);\n+      return;\n     }\n \n-  merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores,\n-\t\t\t   callee_node, false, always_executed);\n+  merge_call_side_effects (stmt, callee_summary, callee_node, false);\n \n-  return true;\n+  return;\n }\n \n-/* Support analysis in non-lto and lto mode in parallel.  */\n-\n-struct summary_ptrs\n-{\n-  struct modref_summary *nolto;\n-  struct modref_summary_lto *lto;\n-  bool always_executed;\n-};\n-\n /* Helper for analyze_stmt.  */\n \n-static bool\n-analyze_load (gimple *, tree, tree op, void *data)\n+bool\n+modref_access_analysis::analyze_load (gimple *, tree, tree op, void *data)\n {\n-  modref_summary *summary = ((summary_ptrs *)data)->nolto;\n-  modref_summary_lto *summary_lto = ((summary_ptrs *)data)->lto;\n+  modref_access_analysis *t = (modref_access_analysis *)data;\n \n   if (dump_file)\n     {\n@@ -1476,39 +1547,26 @@ analyze_load (gimple *, tree, tree op, void *data)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (TREE_THIS_VOLATILE (op)\n-      || (cfun->can_throw_non_call_exceptions\n-\t  && tree_could_throw_p (op)))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \" (volatile or can throw; marking side effects) \");\n-      if (summary)\n-\tsummary->side_effects = summary->nondeterministic = true;\n-      if (summary_lto)\n-\tsummary_lto->side_effects = summary_lto->nondeterministic = true;\n-    }\n-\n-  if (!record_access_p (op))\n+  if (!t->record_access_p (op))\n     return false;\n \n   ao_ref r;\n   ao_ref_init (&r, op);\n   modref_access_node a = get_access (&r);\n \n-  if (summary)\n-    record_access (summary->loads, &r, a);\n-  if (summary_lto)\n-    record_access_lto (summary_lto->loads, &r, a);\n+  if (t->m_summary)\n+    t->record_access (t->m_summary->loads, &r, a);\n+  if (t->m_summary_lto)\n+    t->record_access_lto (t->m_summary_lto->loads, &r, a);\n   return false;\n }\n \n /* Helper for analyze_stmt.  */\n \n-static bool\n-analyze_store (gimple *stmt, tree, tree op, void *data)\n+bool\n+modref_access_analysis::analyze_store (gimple *stmt, tree, tree op, void *data)\n {\n-  modref_summary *summary = ((summary_ptrs *)data)->nolto;\n-  modref_summary_lto *summary_lto = ((summary_ptrs *)data)->lto;\n+  modref_access_analysis *t = (modref_access_analysis *)data;\n \n   if (dump_file)\n     {\n@@ -1517,57 +1575,44 @@ analyze_store (gimple *stmt, tree, tree op, void *data)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (TREE_THIS_VOLATILE (op)\n-      || (cfun->can_throw_non_call_exceptions\n-\t  && tree_could_throw_p (op)))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \" (volatile or can throw; marking side effects) \");\n-      if (summary)\n-\tsummary->side_effects = summary->nondeterministic = true;\n-      if (summary_lto)\n-\tsummary_lto->side_effects = summary_lto->nondeterministic = true;\n-    }\n-\n-  if (!record_access_p (op))\n+  if (!t->record_access_p (op))\n     return false;\n \n   ao_ref r;\n   ao_ref_init (&r, op);\n   modref_access_node a = get_access (&r);\n \n-  if (summary)\n-    record_access (summary->stores, &r, a);\n-  if (summary_lto)\n-    record_access_lto (summary_lto->stores, &r, a);\n-  if (((summary_ptrs *)data)->always_executed\n+  if (t->m_summary)\n+    t->record_access (t->m_summary->stores, &r, a);\n+  if (t->m_summary_lto)\n+    t->record_access_lto (t->m_summary_lto->stores, &r, a);\n+  if (t->m_always_executed\n       && a.useful_for_kill_p ()\n       && (!cfun->can_throw_non_call_exceptions\n \t  || !stmt_could_throw_p (cfun, stmt)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"   - Recording kill\\n\");\n-      if (summary)\n-\tmodref_access_node::insert_kill (summary->kills, a, false);\n-      if (summary_lto)\n-\tmodref_access_node::insert_kill (summary_lto->kills, a, false);\n+      if (t->m_summary)\n+\tmodref_access_node::insert_kill (t->m_summary->kills, a, false);\n+      if (t->m_summary_lto)\n+\tmodref_access_node::insert_kill (t->m_summary_lto->kills, a, false);\n     }\n   return false;\n }\n \n /* Analyze statement STMT of function F.\n    If IPA is true do not merge in side effects of calls.  */\n \n-static bool\n-analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n-\t      gimple *stmt, bool ipa, vec <gimple *> *recursive_calls,\n-\t      bool always_executed)\n+void\n+modref_access_analysis::analyze_stmt (gimple *stmt, bool always_executed)\n {\n+  m_always_executed = always_executed;\n   /* In general we can not ignore clobbers because they are barriers for code\n      motion, however after inlining it is safe to do because local optimization\n      passes do not consider clobbers from other functions.\n      Similar logic is in ipa-pure-const.c.  */\n-  if ((ipa || cfun->after_inlining) && gimple_clobber_p (stmt))\n+  if ((m_ipa || cfun->after_inlining) && gimple_clobber_p (stmt))\n     {\n       if (always_executed && record_access_p (gimple_assign_lhs (stmt)))\n \t{\n@@ -1578,104 +1623,145 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"   - Recording kill\\n\");\n-\t      if (summary)\n-\t\tmodref_access_node::insert_kill (summary->kills, a, false);\n-\t      if (summary_lto)\n-\t\tmodref_access_node::insert_kill (summary_lto->kills, a, false);\n+\t      if (m_summary)\n+\t\tmodref_access_node::insert_kill (m_summary->kills, a, false);\n+\t      if (m_summary_lto)\n+\t\tmodref_access_node::insert_kill (m_summary_lto->kills,\n+\t\t\t\t\t\t a, false);\n \t    }\n \t}\n-      return true;\n+      return;\n     }\n \n-  struct summary_ptrs sums = {summary, summary_lto, always_executed};\n-\n   /* Analyze all loads and stores in STMT.  */\n-  walk_stmt_load_store_ops (stmt, &sums,\n+  walk_stmt_load_store_ops (stmt, this,\n \t\t\t    analyze_load, analyze_store);\n \n   switch (gimple_code (stmt))\n    {\n    case GIMPLE_ASM:\n       if (gimple_asm_volatile_p (as_a <gasm *> (stmt)))\n-\t{\n-\t  if (summary)\n-\t    summary->side_effects = summary->nondeterministic = true;\n-\t  if (summary_lto)\n-\t    summary_lto->side_effects = summary_lto->nondeterministic = true;\n-\t}\n+\tset_nondeterministic ();\n       if (cfun->can_throw_non_call_exceptions\n \t  && stmt_could_throw_p (cfun, stmt))\n-\t{\n-\t  if (summary)\n-\t    summary->side_effects = true;\n-\t  if (summary_lto)\n-\t    summary_lto->side_effects = true;\n-\t}\n+\tset_side_effects ();\n      /* If the ASM statement does not read nor write memory, there's nothing\n \tto do.  Otherwise just give up.  */\n      if (!gimple_asm_clobbers_memory_p (as_a <gasm *> (stmt)))\n-       return true;\n+       return;\n      if (dump_file)\n        fprintf (dump_file, \" - Function contains GIMPLE_ASM statement \"\n \t       \"which clobbers memory.\\n\");\n-     return false;\n+     record_unknown_load ();\n+     record_unknown_store ();\n+     return;\n    case GIMPLE_CALL:\n-     if (!ipa || gimple_call_internal_p (stmt))\n-       return analyze_call (summary, summary_lto,\n-\t\t\t    as_a <gcall *> (stmt), recursive_calls,\n-\t\t\t    always_executed);\n+     if (!m_ipa || gimple_call_internal_p (stmt))\n+       analyze_call (as_a <gcall *> (stmt));\n      else\n-      {\n-\tattr_fnspec fnspec = gimple_call_fnspec (as_a <gcall *>(stmt));\n-\n-\tif (fnspec.known_p ()\n-\t    && (!fnspec.global_memory_read_p ()\n-\t\t|| !fnspec.global_memory_written_p ()))\n-\t  {\n-\t    cgraph_edge *e = cgraph_node::get (current_function_decl)->get_edge (stmt);\n-\t    if (e->callee)\n-\t      {\n-\t\tfnspec_summaries->get_create (e)->fnspec = xstrdup (fnspec.get_str ());\n-\t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"  Recorded fnspec %s\\n\", fnspec.get_str ());\n-\t      }\n-\t  }\n-      }\n-     return true;\n+       {\n+\t attr_fnspec fnspec = gimple_call_fnspec (as_a <gcall *>(stmt));\n+\n+\t if (fnspec.known_p ()\n+\t     && (!fnspec.global_memory_read_p ()\n+\t\t || !fnspec.global_memory_written_p ()))\n+\t   {\n+\t     cgraph_edge *e = cgraph_node::get\n+\t\t\t\t  (current_function_decl)->get_edge (stmt);\n+\t     if (e->callee)\n+\t       {\n+\t\t fnspec_summaries->get_create (e)->fnspec\n+\t\t\t  = xstrdup (fnspec.get_str ());\n+\t\t if (dump_file)\n+\t\t   fprintf (dump_file, \"  Recorded fnspec %s\\n\",\n+\t\t\t    fnspec.get_str ());\n+\t       }\n+\t   }\n+       }\n+     return;\n    default:\n      if (cfun->can_throw_non_call_exceptions\n \t && stmt_could_throw_p (cfun, stmt))\n-\t{\n-\t  if (summary)\n-\t    summary->side_effects = true;\n-\t  if (summary_lto)\n-\t    summary_lto->side_effects = true;\n-\t}\n-     return true;\n+\tset_side_effects ();\n+     return;\n    }\n }\n \n-/* Remove summary of current function because during the function body\n-   scan we determined it is not useful.  LTO, NOLTO and IPA determines the\n-   mode of scan.  */\n+/* Propagate load/stres acress recursive calls.  */\n \n-static void\n-remove_summary (bool lto, bool nolto, bool ipa)\n+void\n+modref_access_analysis::propagate ()\n {\n+  if (m_ipa && m_summary)\n+    return;\n+\n+  bool changed = true;\n+  bool first = true;\n   cgraph_node *fnode = cgraph_node::get (current_function_decl);\n-  if (!ipa)\n-    optimization_summaries->remove (fnode);\n-  else\n+\n+  m_always_executed = false;\n+  while (changed && m_summary->useful_p (m_ecf_flags, false))\n     {\n-      if (nolto)\n-\tsummaries->remove (fnode);\n-      if (lto)\n-\tsummaries_lto->remove (fnode);\n-      remove_modref_edge_summaries (fnode);\n+      changed = false;\n+      for (unsigned i = 0; i < m_recursive_calls.length (); i++)\n+\t{\n+\t  changed |= merge_call_side_effects (m_recursive_calls[i], m_summary,\n+\t\t\t\t\t      fnode, !first);\n+\t}\n+      first = false;\n+    }\n+}\n+\n+/* Analyze function.  */\n+\n+void\n+modref_access_analysis::analyze ()\n+{\n+  m_ecf_flags = flags_from_decl_or_type (current_function_decl);\n+  bool summary_useful = true;\n+\n+  /* Analyze each statement in each basic block of the function.  If the\n+     statement cannot be analyzed (for any reason), the entire function cannot\n+     be analyzed by modref.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      gimple_stmt_iterator si;\n+      bool always_executed\n+\t      = bb == single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->dest;\n+\n+      for (si = gsi_start_nondebug_after_labels_bb (bb);\n+\t   !gsi_end_p (si); gsi_next_nondebug (&si))\n+\t{\n+\t  analyze_stmt (gsi_stmt (si), always_executed);\n+\n+\t  /* Avoid doing useles work.  */\n+\t  if ((!m_summary || !m_summary->useful_p (m_ecf_flags, false))\n+\t      && (!m_summary_lto\n+\t\t  || !m_summary_lto->useful_p (m_ecf_flags, false)))\n+\t    {\n+\t      summary_useful = false;\n+\t      break;\n+\t    }\n+\t  if (always_executed\n+\t      && stmt_can_throw_external (cfun, gsi_stmt (si)))\n+\t    always_executed = false;\n+\t}\n+      if (!summary_useful)\n+\tbreak;\n+    }\n+  /* In non-IPA mode we need to perform iterative datafow on recursive calls.\n+     This needs to be done after all other side effects are computed.  */\n+  if (summary_useful)\n+    {\n+      if (!m_ipa)\n+\tpropagate ();\n+      if (m_summary && !m_summary->side_effects && !finite_function_p ())\n+\tm_summary->side_effects = true;\n+      if (m_summary_lto && !m_summary_lto->side_effects\n+\t  && !finite_function_p ())\n+\tm_summary_lto->side_effects = true;\n     }\n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \" - modref done with result: not tracked.\\n\");\n }\n \n /* Return true if OP accesses memory pointed to by SSA_NAME.  */\n@@ -1730,7 +1816,8 @@ deref_flags (int flags, bool ignore_stores)\n }\n \n \n-/* Description of an escape point.  */\n+/* Description of an escape point: a call which affects flags of a given\n+   SSA name.  */\n \n struct escape_point\n {\n@@ -1745,6 +1832,10 @@ struct escape_point\n   bool direct;\n };\n \n+/* Lattice used during the eaf flags analsysis dataflow.  For a given SSA name\n+   we aim to compute its flags and escape points.  We also use the lattice\n+   to dynamically build dataflow graph to propagate on.  */\n+\n class modref_lattice\n {\n public:\n@@ -2967,69 +3058,10 @@ analyze_function (function *f, bool ipa)\n   analyze_parms (summary, summary_lto, ipa,\n \t\t past_flags, past_retslot_flags, past_static_chain_flags);\n \n-  int ecf_flags = flags_from_decl_or_type (current_function_decl);\n-  auto_vec <gimple *, 32> recursive_calls;\n-\n-  /* Analyze each statement in each basic block of the function.  If the\n-     statement cannot be analyzed (for any reason), the entire function cannot\n-     be analyzed by modref.  */\n-  basic_block bb;\n-  FOR_EACH_BB_FN (bb, f)\n-    {\n-      gimple_stmt_iterator si;\n-      bool always_executed\n-\t      = bb == single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->dest;\n-\n-      for (si = gsi_start_nondebug_after_labels_bb (bb);\n-\t   !gsi_end_p (si); gsi_next_nondebug (&si))\n-\t{\n-\t  if (!analyze_stmt (summary, summary_lto,\n-\t\t\t     gsi_stmt (si), ipa, &recursive_calls,\n-\t\t\t     always_executed)\n-\t      || ((!summary || !summary->useful_p (ecf_flags, false))\n-\t\t  && (!summary_lto\n-\t\t      || !summary_lto->useful_p (ecf_flags, false))))\n-\t    {\n-\t      collapse_loads (summary, summary_lto);\n-\t      collapse_stores (summary, summary_lto);\n-\t      break;\n-\t    }\n-\t  if (always_executed\n-\t      && stmt_can_throw_external (cfun, gsi_stmt (si)))\n-\t    always_executed = false;\n-\t}\n-    }\n-\n-  /* In non-IPA mode we need to perform iterative datafow on recursive calls.\n-     This needs to be done after all other side effects are computed.  */\n-  if (!ipa)\n-    {\n-      bool changed = true;\n-      bool first = true;\n-      while (changed)\n-\t{\n-\t  changed = false;\n-\t  for (unsigned i = 0; i < recursive_calls.length (); i++)\n-\t    {\n-\t      changed |= merge_call_side_effects\n-\t\t\t  (summary, recursive_calls[i], summary,\n-\t\t\t   ignore_stores_p (current_function_decl,\n-\t\t\t\t\t    gimple_call_flags\n-\t\t\t\t\t\t (recursive_calls[i])),\n-\t\t\t   fnode, !first, false);\n-\t      if (!summary->useful_p (ecf_flags, false))\n-\t\t{\n-\t\t  remove_summary (lto, nolto, ipa);\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\t  first = false;\n-\t}\n-    }\n-  if (summary && !summary->side_effects && !finite_function_p ())\n-    summary->side_effects = true;\n-  if (summary_lto && !summary_lto->side_effects && !finite_function_p ())\n-    summary_lto->side_effects = true;\n+  {\n+    modref_access_analysis analyzer (ipa, summary, summary_lto);\n+    analyzer.analyze ();\n+  }\n \n   if (!ipa && flag_ipa_pure_const)\n     {\n@@ -3045,6 +3077,7 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t\t\tsummary->side_effects, true);\n \t}\n     }\n+  int ecf_flags = flags_from_decl_or_type (current_function_decl);\n   if (summary && !summary->useful_p (ecf_flags))\n     {\n       if (!ipa)\n@@ -4261,6 +4294,49 @@ get_access_for_fnspec (cgraph_edge *e, attr_fnspec &fnspec,\n   return a;\n }\n \n+ /* Collapse loads and return true if something changed.  */\n+static bool\n+collapse_loads (modref_summary *cur_summary,\n+\t\tmodref_summary_lto *cur_summary_lto)\n+{\n+  bool changed = false;\n+\n+  if (cur_summary && !cur_summary->loads->every_base)\n+    {\n+      cur_summary->loads->collapse ();\n+      changed = true;\n+    }\n+  if (cur_summary_lto\n+      && !cur_summary_lto->loads->every_base)\n+    {\n+      cur_summary_lto->loads->collapse ();\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n+/* Collapse loads and return true if something changed.  */\n+\n+static bool\n+collapse_stores (modref_summary *cur_summary,\n+\t\tmodref_summary_lto *cur_summary_lto)\n+{\n+  bool changed = false;\n+\n+  if (cur_summary && !cur_summary->stores->every_base)\n+    {\n+      cur_summary->stores->collapse ();\n+      changed = true;\n+    }\n+  if (cur_summary_lto\n+      && !cur_summary_lto->stores->every_base)\n+    {\n+      cur_summary_lto->stores->collapse ();\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n /* Call E in NODE with ECF_FLAGS has no summary; update MODREF_SUMMARY and\n    CUR_SUMMARY_LTO accordingly.  Return true if something changed.  */\n "}]}