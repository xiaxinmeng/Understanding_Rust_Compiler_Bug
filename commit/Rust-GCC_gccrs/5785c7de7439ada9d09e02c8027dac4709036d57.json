{"sha": "5785c7de7439ada9d09e02c8027dac4709036d57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc4NWM3ZGU3NDM5YWRhOWQwOWUwMmM4MDI3ZGFjNDcwOTAzNmQ1Nw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-03-14T01:07:16Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-03-14T01:07:16Z"}, "message": "fold-const.c (negate_expr, [...]): Replace calls via (*lang_hooks.foo) () with lang_hooks.foo ().\n\n\n\t* fold-const.c (negate_expr, operand_equal_for_comparison_p,\n\toptimize_bit_field_compare, decode_field_reference, all_ones_mask_p,\n\tmake_range, build_range_check, fold_range_test, unextend,\n\tconstant_boolean_node, fold_binary_op_with_conditional_arg,\n\tfold_truthop, fold_mathfn_compare, fold_inf_compare,\n\tfold_single_bit_test, fold): Replace calls via (*lang_hooks.foo) ()\n\twith lang_hooks.foo ().\n\nFrom-SVN: r79471", "tree": {"sha": "e1c60a87fbb54c2f172527c346c84e30370d2847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1c60a87fbb54c2f172527c346c84e30370d2847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5785c7de7439ada9d09e02c8027dac4709036d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5785c7de7439ada9d09e02c8027dac4709036d57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5785c7de7439ada9d09e02c8027dac4709036d57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5785c7de7439ada9d09e02c8027dac4709036d57/comments", "author": null, "committer": null, "parents": [{"sha": "edc621221a4021b68ef4ef3fdec6885277d4fe14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc621221a4021b68ef4ef3fdec6885277d4fe14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edc621221a4021b68ef4ef3fdec6885277d4fe14"}], "stats": {"total": 78, "additions": 44, "deletions": 34}, "files": [{"sha": "d5499d35263a2dce80ab3257c9038dccf79d4d1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5785c7de7439ada9d09e02c8027dac4709036d57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5785c7de7439ada9d09e02c8027dac4709036d57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5785c7de7439ada9d09e02c8027dac4709036d57", "patch": "@@ -1,3 +1,13 @@\n+2004-03-13  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (negate_expr, operand_equal_for_comparison_p,\n+\toptimize_bit_field_compare, decode_field_reference, all_ones_mask_p,\n+\tmake_range, build_range_check, fold_range_test, unextend,\n+\tconstant_boolean_node, fold_binary_op_with_conditional_arg,\n+\tfold_truthop, fold_mathfn_compare, fold_inf_compare,\n+\tfold_single_bit_test, fold): Replace calls via (*lang_hooks.foo) ()\n+\twith lang_hooks.foo ().\n+\n 2004-03-14  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.h (EXTRA_CONSTRAINT_STR_ARM): Update comment."}, {"sha": "5e899fddc28b6df1f4c7c45aa6ac553f7d1d1de3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5785c7de7439ada9d09e02c8027dac4709036d57/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5785c7de7439ada9d09e02c8027dac4709036d57/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5785c7de7439ada9d09e02c8027dac4709036d57", "patch": "@@ -1087,8 +1087,8 @@ negate_expr (tree t)\n \t\t == TREE_INT_CST_LOW (op1))\n \t    {\n \t      tree ntype = TREE_UNSIGNED (type)\n-\t\t\t   ? (*lang_hooks.types.signed_type) (type)\n-\t\t\t   : (*lang_hooks.types.unsigned_type) (type);\n+\t\t\t   ? lang_hooks.types.signed_type (type)\n+\t\t\t   : lang_hooks.types.unsigned_type (type);\n \t      tree temp = fold_convert (ntype, TREE_OPERAND (t, 0));\n \t      temp = fold (build2 (RSHIFT_EXPR, ntype, temp, op1));\n \t      return fold_convert (type, temp);\n@@ -2419,7 +2419,7 @@ operand_equal_for_comparison_p (tree arg0, tree arg1, tree other)\n \n       /* Make sure shorter operand is extended the right way\n \t to match the longer operand.  */\n-      primarg1 = fold_convert ((*lang_hooks.types.signed_or_unsigned_type)\n+      primarg1 = fold_convert (lang_hooks.types.signed_or_unsigned_type\n \t\t\t       (unsignedp1, TREE_TYPE (primarg1)), primarg1);\n \n       if (operand_equal_p (arg0, fold_convert (type, primarg1), 0))\n@@ -2900,8 +2900,8 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n \n   /* Set signed and unsigned types of the precision of this mode for the\n      shifts below.  */\n-  signed_type = (*lang_hooks.types.type_for_mode) (nmode, 0);\n-  unsigned_type = (*lang_hooks.types.type_for_mode) (nmode, 1);\n+  signed_type = lang_hooks.types.type_for_mode (nmode, 0);\n+  unsigned_type = lang_hooks.types.type_for_mode (nmode, 1);\n \n   /* Compute the bit position and size for the new reference and our offset\n      within it. If the new reference is the same size as the original, we\n@@ -3074,7 +3074,7 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n     *punsignedp = TREE_UNSIGNED (outer_type);\n \n   /* Compute the mask to access the bitfield.  */\n-  unsigned_type = (*lang_hooks.types.type_for_size) (*pbitsize, 1);\n+  unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);\n   precision = TYPE_PRECISION (unsigned_type);\n \n   mask = build_int_2 (~0, ~0);\n@@ -3104,7 +3104,7 @@ all_ones_mask_p (tree mask, int size)\n   tree tmask;\n \n   tmask = build_int_2 (~0, ~0);\n-  TREE_TYPE (tmask) = (*lang_hooks.types.signed_type) (type);\n+  TREE_TYPE (tmask) = lang_hooks.types.signed_type (type);\n   force_fit_type (tmask, 0);\n   return\n     tree_int_cst_equal (mask,\n@@ -3497,7 +3497,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t     be interpreted as positive.  */\n \t  if (TREE_UNSIGNED (type) && ! TREE_UNSIGNED (TREE_TYPE (exp)))\n \t    {\n-\t      tree equiv_type = (*lang_hooks.types.type_for_mode)\n+\t      tree equiv_type = lang_hooks.types.type_for_mode\n \t\t(TYPE_MODE (type), 1);\n \t      tree high_positive;\n \n@@ -3598,7 +3598,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n     {\n       if (! TREE_UNSIGNED (etype))\n \t{\n-\t  etype = (*lang_hooks.types.unsigned_type) (etype);\n+\t  etype = lang_hooks.types.unsigned_type (etype);\n \t  high = fold_convert (etype, high);\n \t  exp = fold_convert (etype, exp);\n \t}\n@@ -3628,7 +3628,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t{\n \t  if (TREE_UNSIGNED (etype))\n \t    {\n-\t      etype = (*lang_hooks.types.signed_type) (etype);\n+\t      etype = lang_hooks.types.signed_type (etype);\n \t      exp = fold_convert (etype, exp);\n \t    }\n \t  return fold (build (GT_EXPR, type, exp,\n@@ -3833,7 +3833,7 @@ fold_range_test (tree exp)\n \t\t      TREE_TYPE (exp), TREE_OPERAND (exp, 0),\n \t\t      TREE_OPERAND (exp, 1));\n \n-      else if ((*lang_hooks.decls.global_bindings_p) () == 0\n+      else if (lang_hooks.decls.global_bindings_p () == 0\n \t       && ! CONTAINS_PLACEHOLDER_P (lhs))\n \t{\n \t  tree common = save_expr (lhs);\n@@ -3881,7 +3881,7 @@ unextend (tree c, int p, int unsignedp, tree mask)\n      zero or one, and the conversion to a signed type can never overflow.\n      We could get an overflow if this conversion is done anywhere else.  */\n   if (TREE_UNSIGNED (type))\n-    temp = fold_convert ((*lang_hooks.types.signed_type) (type), temp);\n+    temp = fold_convert (lang_hooks.types.signed_type (type), temp);\n \n   temp = const_binop (LSHIFT_EXPR, temp, size_int (modesize - 1), 0);\n   temp = const_binop (RSHIFT_EXPR, temp, size_int (modesize - p - 1), 0);\n@@ -4127,7 +4127,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \n   /* After this point all optimizations will generate bit-field\n      references, which we might not want.  */\n-  if (! (*lang_hooks.can_use_bit_fields_p) ())\n+  if (! lang_hooks.can_use_bit_fields_p ())\n     return 0;\n \n   /* See if we can find a mode that contains both fields being compared on\n@@ -4143,7 +4143,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \n   lnbitsize = GET_MODE_BITSIZE (lnmode);\n   lnbitpos = first_bit & ~ (lnbitsize - 1);\n-  lntype = (*lang_hooks.types.type_for_size) (lnbitsize, 1);\n+  lntype = lang_hooks.types.type_for_size (lnbitsize, 1);\n   xll_bitpos = ll_bitpos - lnbitpos, xrl_bitpos = rl_bitpos - lnbitpos;\n \n   if (BYTES_BIG_ENDIAN)\n@@ -4214,7 +4214,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \n       rnbitsize = GET_MODE_BITSIZE (rnmode);\n       rnbitpos = first_bit & ~ (rnbitsize - 1);\n-      rntype = (*lang_hooks.types.type_for_size) (rnbitsize, 1);\n+      rntype = lang_hooks.types.type_for_size (rnbitsize, 1);\n       xlr_bitpos = lr_bitpos - rnbitpos, xrr_bitpos = rr_bitpos - rnbitpos;\n \n       if (BYTES_BIG_ENDIAN)\n@@ -4787,8 +4787,8 @@ constant_boolean_node (int value, tree type)\n   if (type == integer_type_node)\n     return value ? integer_one_node : integer_zero_node;\n   else if (TREE_CODE (type) == BOOLEAN_TYPE)\n-    return (*lang_hooks.truthvalue_conversion) (value ? integer_one_node :\n-\t\t\t\t\t\tinteger_zero_node);\n+    return lang_hooks.truthvalue_conversion (value ? integer_one_node\n+\t\t\t\t\t\t   : integer_zero_node);\n   else\n     {\n       tree t = build_int_2 (value, 0);\n@@ -4920,7 +4920,7 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n     save = 1;\n   else if (lhs == 0 && rhs == 0\n \t   && !TREE_CONSTANT (arg)\n-\t   && (*lang_hooks.decls.global_bindings_p) () == 0\n+\t   && lang_hooks.decls.global_bindings_p () == 0\n \t   && ((TREE_CODE (arg) != VAR_DECL && TREE_CODE (arg) != PARM_DECL)\n \t       || TREE_SIDE_EFFECTS (arg)))\n     {\n@@ -5095,7 +5095,7 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t\t\t\t    build_real (TREE_TYPE (arg), dconst0)));\n \n \t      /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n-\t      if ((*lang_hooks.decls.global_bindings_p) () != 0\n+\t      if (lang_hooks.decls.global_bindings_p () != 0\n \t\t  || CONTAINS_PLACEHOLDER_P (arg))\n \t\treturn NULL_TREE;\n \n@@ -5115,7 +5115,7 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t\t\t\tbuild_real (TREE_TYPE (arg), c2)));\n \n \t  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n-\t  if ((*lang_hooks.decls.global_bindings_p) () == 0\n+\t  if (lang_hooks.decls.global_bindings_p () == 0\n \t      && ! CONTAINS_PLACEHOLDER_P (arg))\n \t    {\n \t      arg = save_expr (arg);\n@@ -5176,7 +5176,7 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t\t arg0);\n \n       /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n-      if ((*lang_hooks.decls.global_bindings_p) () == 0\n+      if (lang_hooks.decls.global_bindings_p () == 0\n \t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n \t{\n \t  arg0 = save_expr (arg0);\n@@ -5257,7 +5257,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       arg00 = sign_bit_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n       if (arg00 != NULL_TREE)\n \t{\n-\t  tree stype = (*lang_hooks.types.signed_type) (TREE_TYPE (arg00));\n+\t  tree stype = lang_hooks.types.signed_type (TREE_TYPE (arg00));\n \t  return fold (build (code == EQ_EXPR ? GE_EXPR : LT_EXPR, result_type,\n \t\t\t      fold_convert (stype, arg00),\n \t\t\t      fold_convert (stype, integer_zero_node)));\n@@ -5293,8 +5293,8 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       ops_unsigned = 1;\n #endif\n \n-      signed_type = (*lang_hooks.types.type_for_mode) (operand_mode, 0);\n-      unsigned_type = (*lang_hooks.types.type_for_mode) (operand_mode, 1);\n+      signed_type = lang_hooks.types.type_for_mode (operand_mode, 0);\n+      unsigned_type = lang_hooks.types.type_for_mode (operand_mode, 1);\n       intermediate_type = ops_unsigned ? unsigned_type : signed_type;\n       inner = fold_convert (intermediate_type, inner);\n \n@@ -5609,7 +5609,7 @@ fold (tree expr)\n \t       && (TREE_CODE (arg0) != COND_EXPR\n \t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg0)\n-\t\t   || ((*lang_hooks.decls.global_bindings_p) () == 0\n+\t\t   || (lang_hooks.decls.global_bindings_p () == 0\n \t\t       && ! CONTAINS_PLACEHOLDER_P (arg0))))\n \treturn\n \t  fold_binary_op_with_conditional_arg (code, type, arg1, arg0,\n@@ -5623,7 +5623,7 @@ fold (tree expr)\n \t       && (TREE_CODE (arg1) != COND_EXPR\n \t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg1)\n-\t\t   || ((*lang_hooks.decls.global_bindings_p) () == 0\n+\t\t   || (lang_hooks.decls.global_bindings_p () == 0\n \t\t       && ! CONTAINS_PLACEHOLDER_P (arg1))))\n \treturn\n \t  fold_binary_op_with_conditional_arg (code, type, arg0, arg1,\n@@ -5784,7 +5784,7 @@ fold (tree expr)\n \t\t  && (LOAD_EXTEND_OP (TYPE_MODE (TREE_TYPE (and0)))\n \t\t      == ZERO_EXTEND))\n \t\t{\n-\t\t  tree uns = (*lang_hooks.types.unsigned_type) (TREE_TYPE (and0));\n+\t\t  tree uns = lang_hooks.types.unsigned_type (TREE_TYPE (and0));\n \t\t  and0 = fold_convert (uns, and0);\n \t\t  and1 = fold_convert (uns, and1);\n \t\t}\n@@ -7544,8 +7544,8 @@ fold (tree expr)\n \t\tif (code == LE_EXPR || code == GT_EXPR)\n \t\t  {\n \t\t    tree st0, st1;\n-\t\t    st0 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg0));\n-\t\t    st1 = (*lang_hooks.types.signed_type) (TREE_TYPE (arg1));\n+\t\t    st0 = lang_hooks.types.signed_type (TREE_TYPE (arg0));\n+\t\t    st1 = lang_hooks.types.signed_type (TREE_TYPE (arg1));\n \t\t    return fold\n \t\t      (build (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n \t\t\t      type, fold_convert (st0, arg0),\n@@ -7668,7 +7668,7 @@ fold (tree expr)\n \t      || TREE_CODE (arg0) == ROUND_MOD_EXPR)\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1)))\n \t{\n-\t  tree newtype = (*lang_hooks.types.unsigned_type) (TREE_TYPE (arg0));\n+\t  tree newtype = lang_hooks.types.unsigned_type (TREE_TYPE (arg0));\n \t  tree newmod = build (TREE_CODE (arg0), newtype,\n \t\t\t       fold_convert (newtype,\n \t\t\t\t\t     TREE_OPERAND (arg0, 0)),\n@@ -7895,7 +7895,7 @@ fold (tree expr)\n \n       /* If this is a comparison of a field, we may be able to simplify it.  */\n       if (((TREE_CODE (arg0) == COMPONENT_REF\n-\t    && (*lang_hooks.can_use_bit_fields_p) ())\n+\t    && lang_hooks.can_use_bit_fields_p ())\n \t   || TREE_CODE (arg0) == BIT_FIELD_REF)\n \t  && (code == EQ_EXPR || code == NE_EXPR)\n \t  /* Handle the constant case even without -O\n@@ -8045,7 +8045,7 @@ fold (tree expr)\n \n       TREE_TYPE (t1) = type;\n       if (TREE_CODE (type) == BOOLEAN_TYPE)\n-\treturn (*lang_hooks.truthvalue_conversion) (t1);\n+\treturn lang_hooks.truthvalue_conversion (t1);\n       return t1;\n \n     case COND_EXPR:\n@@ -8115,14 +8115,14 @@ fold (tree expr)\n \t      case GE_EXPR:\n \t      case GT_EXPR:\n \t\tif (TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  arg1 = fold_convert ((*lang_hooks.types.signed_type)\n+\t\t  arg1 = fold_convert (lang_hooks.types.signed_type\n \t\t\t\t       (TREE_TYPE (arg1)), arg1);\n \t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n \t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n \t      case LE_EXPR:\n \t      case LT_EXPR:\n \t\tif (TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  arg1 = fold_convert ((lang_hooks.types.signed_type)\n+\t\t  arg1 = fold_convert (lang_hooks.types.signed_type\n \t\t\t\t       (TREE_TYPE (arg1)), arg1);\n \t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n \t\targ1 = negate_expr (fold_convert (type, arg1));"}]}