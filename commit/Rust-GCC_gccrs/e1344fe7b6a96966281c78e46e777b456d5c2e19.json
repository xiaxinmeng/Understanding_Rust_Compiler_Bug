{"sha": "e1344fe7b6a96966281c78e46e777b456d5c2e19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEzNDRmZTdiNmE5Njk2NjI4MWM3OGU0NmU3NzdiNDU2ZDVjMmUxOQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-10-29T18:03:03Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-10-29T18:03:03Z"}, "message": "c++: Simplify constraint normalization routines\n\nMany of the high-level constraint normalization routines allow the\ncaller to supply the initial template arguments for normalization, but\nin practice all of the callers supply something equivalent to the\nidentity mapping(*).\n\nThis patch hard-codes this prevalent choice of initial template\narguments by making get_normalized_constraints always pass NULL_TREE as\nthe args to normalize_expression.  This admits some simplifications in\nthe high-level routines, such as removing their 'args' parameter and\nconsolidating the two versions of normalize_constraint_expression.\n\n(*): In particular, a set of generic template arguments or NULL_TREE.\nIn the case of the two-parm version of normalize_constraint_expression,\nwe were suspiciously using the template arguments of a concept-id when\nnormalizing the concept-id as a constraint-expression.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (get_normalized_constraints): Remove 'args'\n\tparameter.  Pass NULL_TREE as the initial template arguments to\n\tnormalize_expression.\n\t(get_normalized_constraints_from_info): Remove 'args' parameter\n\tand adjust the call to get_normalized_constraints.\n\t(get_normalized_constraints_from_decl): Remove 'args' local\n\tvariable and adjust call to get_normalized_constraints_from_info.\n\t(normalize_concept_definition): Remove 'args' local variable\n\tand adjust call to get_normalized_constraints.\n\t(normalize_constraint_expression): Remove the two-parameter\n\toverload.  Remove 'args' parameter from the three-parameter\n\toverload and update function comment accordingly.  Remove\n\tdefault argument from 'diag' parameter.  Adjust call to\n\tget_normalized_constraints.\n\t(finish_nested_requirement): Adjust call to\n\tnormalize_constraint_expression.\n\t(strictly_subsumes): Remove 'args' parameter.  Adjust call to\n\tget_normalized_constraints_from_info.\n\t(weakly_subsumes): Likewise.\n\t* cp-tree.h (strictly_subsumes): Remove 'args' parameter.\n\t(weakly_subsumes): Likewise.\n\t* pt.c (process_partial_specialization): Adjust call to\n\tstrictly_subsumes.\n\t(is_compatible_template_arg): Adjust call to weakly_subsumes.", "tree": {"sha": "d45435956b4ad7f23fd050b8ba375e61372f1990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d45435956b4ad7f23fd050b8ba375e61372f1990"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1344fe7b6a96966281c78e46e777b456d5c2e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1344fe7b6a96966281c78e46e777b456d5c2e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1344fe7b6a96966281c78e46e777b456d5c2e19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1344fe7b6a96966281c78e46e777b456d5c2e19/comments", "author": null, "committer": null, "parents": [{"sha": "5681668765e233735b4c5e6a305e73ae1f80a328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5681668765e233735b4c5e6a305e73ae1f80a328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5681668765e233735b4c5e6a305e73ae1f80a328"}], "stats": {"total": 78, "additions": 24, "deletions": 54}, "files": [{"sha": "d6354edbe6f04404925becce15a78d23796301aa", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1344fe7b6a96966281c78e46e777b456d5c2e19/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1344fe7b6a96966281c78e46e777b456d5c2e19/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=e1344fe7b6a96966281c78e46e777b456d5c2e19", "patch": "@@ -759,29 +759,26 @@ normalize_expression (tree t, tree args, norm_info info)\n static GTY((deletable)) hash_map<tree,tree> *normalized_map;\n \n static tree\n-get_normalized_constraints (tree t, tree args, norm_info info)\n+get_normalized_constraints (tree t, norm_info info)\n {\n   auto_timevar time (TV_CONSTRAINT_NORM);\n-  return normalize_expression (t, args, info);\n+  return normalize_expression (t, NULL_TREE, info);\n }\n \n /* Returns the normalized constraints from a constraint-info object\n-   or NULL_TREE if the constraints are null. ARGS provide the initial\n-   arguments for normalization and IN_DECL provides the declaration\n-   to which the constraints belong.  */\n+   or NULL_TREE if the constraints are null. IN_DECL provides the\n+   declaration to which the constraints belong.  */\n \n static tree\n-get_normalized_constraints_from_info (tree ci, tree args, tree in_decl,\n-\t\t\t\t      bool diag = false)\n+get_normalized_constraints_from_info (tree ci, tree in_decl, bool diag = false)\n {\n   if (ci == NULL_TREE)\n     return NULL_TREE;\n \n   /* Substitution errors during normalization are fatal.  */\n   ++processing_template_decl;\n   norm_info info (in_decl, diag ? tf_norm : tf_none);\n-  tree t = get_normalized_constraints (CI_ASSOCIATED_CONSTRAINTS (ci),\n-\t\t\t\t       args, info);\n+  tree t = get_normalized_constraints (CI_ASSOCIATED_CONSTRAINTS (ci), info);\n   --processing_template_decl;\n \n   return t;\n@@ -843,9 +840,8 @@ get_normalized_constraints_from_decl (tree d, bool diag = false)\n \n   push_nested_class_guard pncs (DECL_CONTEXT (d));\n \n-  tree args = generic_targs_for (tmpl);\n   tree ci = get_constraints (decl);\n-  tree norm = get_normalized_constraints_from_info (ci, args, tmpl, diag);\n+  tree norm = get_normalized_constraints_from_info (ci, tmpl, diag);\n \n   if (!diag)\n     hash_map_safe_put<hm_ggc> (normalized_map, tmpl, norm);\n@@ -866,11 +862,10 @@ normalize_concept_definition (tree tmpl, bool diag = false)\n   if (OVL_P (tmpl))\n     tmpl = OVL_FIRST (tmpl);\n   gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n-  tree args = generic_targs_for (tmpl);\n   tree def = get_concept_definition (DECL_TEMPLATE_RESULT (tmpl));\n   ++processing_template_decl;\n   norm_info info (tmpl, diag ? tf_norm : tf_none);\n-  tree norm = get_normalized_constraints (def, args, info);\n+  tree norm = get_normalized_constraints (def, info);\n   --processing_template_decl;\n \n   if (!diag)\n@@ -895,42 +890,20 @@ normalize_nontemplate_requirements (tree decl, bool diag = false)\n   return get_normalized_constraints_from_decl (decl, diag);\n }\n \n-/* Normalize an EXPR as a constraint using ARGS.  */\n+/* Normalize an EXPR as a constraint.  */\n \n static tree\n-normalize_constraint_expression (tree expr, tree args, bool diag = false)\n+normalize_constraint_expression (tree expr, bool diag)\n {\n   if (!expr || expr == error_mark_node)\n     return expr;\n   ++processing_template_decl;\n   norm_info info (diag ? tf_norm : tf_none);\n-  tree norm = get_normalized_constraints (expr, args, info);\n+  tree norm = get_normalized_constraints (expr, info);\n   --processing_template_decl;\n   return norm;\n }\n \n-/* Normalize an EXPR as a constraint.  */\n-\n-static tree\n-normalize_constraint_expression (tree expr, bool diag = false)\n-{\n-  if (!expr || expr == error_mark_node)\n-    return expr;\n-\n-  /* For concept checks, use the supplied template arguments as those used\n-     for normalization. Otherwise, there are no template arguments.  */\n-  tree args;\n-  if (concept_check_p (expr))\n-    {\n-      tree id = unpack_concept_check (expr);\n-      args = TREE_OPERAND (id, 1);\n-    }\n-  else\n-    args = NULL_TREE;\n-\n-  return normalize_constraint_expression (expr, args, diag);\n-}\n-\n /* 17.4.1.2p2. Two constraints are identical if they are formed\n    from the same expression and the targets of the parameter mapping\n    are equivalent.  */\n@@ -2998,9 +2971,7 @@ finish_compound_requirement (location_t loc, tree expr, tree type, bool noexcept\n tree\n finish_nested_requirement (location_t loc, tree expr)\n {\n-  /* Currently open template headers have dummy arg vectors, so don't\n-     pass into normalization.  */\n-  tree norm = normalize_constraint_expression (expr, NULL_TREE, false);\n+  tree norm = normalize_constraint_expression (expr, false);\n \n   /* Build the constraint, saving its normalization as its type.  */\n   tree r = build1 (NESTED_REQ, norm, expr);\n@@ -3105,25 +3076,25 @@ subsumes_constraints (tree a, tree b)\n   return subsumes (a, b);\n }\n \n-/* Returns true when the constraints in CI (with arguments\n-   ARGS) strictly subsume the associated constraints of TMPL.  */\n+/* Returns true when the constraints in CI strictly subsume\n+   the associated constraints of TMPL.  */\n \n bool\n-strictly_subsumes (tree ci, tree args, tree tmpl)\n+strictly_subsumes (tree ci, tree tmpl)\n {\n-  tree n1 = get_normalized_constraints_from_info (ci, args, NULL_TREE);\n+  tree n1 = get_normalized_constraints_from_info (ci, NULL_TREE);\n   tree n2 = get_normalized_constraints_from_decl (tmpl);\n \n   return subsumes (n1, n2) && !subsumes (n2, n1);\n }\n \n-/* REturns true when the constraints in CI (with arguments ARGS) subsume\n-   the associated constraints of TMPL.  */\n+/* Returns true when the constraints in CI subsume the\n+   associated constraints of TMPL.  */\n \n bool\n-weakly_subsumes (tree ci, tree args, tree tmpl)\n+weakly_subsumes (tree ci, tree tmpl)\n {\n-  tree n1 = get_normalized_constraints_from_info (ci, args, NULL_TREE);\n+  tree n1 = get_normalized_constraints_from_info (ci, NULL_TREE);\n   tree n2 = get_normalized_constraints_from_decl (tmpl);\n \n   return subsumes (n1, n2);"}, {"sha": "fdb8ee57f0bc89d53a45fe94edbb30095f215936", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1344fe7b6a96966281c78e46e777b456d5c2e19/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1344fe7b6a96966281c78e46e777b456d5c2e19/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e1344fe7b6a96966281c78e46e777b456d5c2e19", "patch": "@@ -7838,8 +7838,8 @@ extern tree find_template_parameters\t\t(tree, tree);\n extern bool equivalent_constraints              (tree, tree);\n extern bool equivalently_constrained            (tree, tree);\n extern bool subsumes_constraints                (tree, tree);\n-extern bool strictly_subsumes\t\t\t(tree, tree, tree);\n-extern bool weakly_subsumes\t\t\t(tree, tree, tree);\n+extern bool strictly_subsumes\t\t\t(tree, tree);\n+extern bool weakly_subsumes\t\t\t(tree, tree);\n extern int more_constrained                     (tree, tree);\n extern bool at_least_as_constrained             (tree, tree);\n extern bool constraints_equivalent_p            (tree, tree);"}, {"sha": "531554d702d59166334ee0712a580fded1a65888", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1344fe7b6a96966281c78e46e777b456d5c2e19/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1344fe7b6a96966281c78e46e777b456d5c2e19/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e1344fe7b6a96966281c78e46e777b456d5c2e19", "patch": "@@ -5089,8 +5089,7 @@ process_partial_specialization (tree decl)\n     = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (maintmpl)));\n   if (comp_template_args (inner_args, INNERMOST_TEMPLATE_ARGS (main_args))\n       && (!flag_concepts\n-\t  || !strictly_subsumes (current_template_constraints (),\n-\t\t\t\t main_args, maintmpl)))\n+\t  || !strictly_subsumes (current_template_constraints (), maintmpl)))\n     {\n       if (!flag_concepts)\n         error (\"partial specialization %q+D does not specialize \"\n@@ -8178,7 +8177,7 @@ is_compatible_template_arg (tree parm, tree arg)\n         return false;\n     }\n \n-  return weakly_subsumes (parm_cons, new_args, arg);\n+  return weakly_subsumes (parm_cons, arg);\n }\n \n // Convert a placeholder argument into a binding to the original"}]}