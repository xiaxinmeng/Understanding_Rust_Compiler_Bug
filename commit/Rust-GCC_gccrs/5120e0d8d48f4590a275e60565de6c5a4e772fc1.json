{"sha": "5120e0d8d48f4590a275e60565de6c5a4e772fc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyMGUwZDhkNDhmNDU5MGEyNzVlNjA1NjVkZTZjNWE0ZTc3MmZjMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-05-16T19:06:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-05-16T19:06:55Z"}, "message": "tree-affine.c (expr_to_aff_combination): New function split out from...\n\n2019-05-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-affine.c (expr_to_aff_combination): New function split\n\tout from...\n\t(tree_to_aff_combination): ... here.\n\t(aff_combination_expand): Avoid building a GENERIC tree.\n\nFrom-SVN: r271294", "tree": {"sha": "883655b71e4859622d8e097286f598e3bd0f7612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/883655b71e4859622d8e097286f598e3bd0f7612"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5120e0d8d48f4590a275e60565de6c5a4e772fc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5120e0d8d48f4590a275e60565de6c5a4e772fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5120e0d8d48f4590a275e60565de6c5a4e772fc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5120e0d8d48f4590a275e60565de6c5a4e772fc1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7430263c07b4a1bcf3deb708c8c691f233fcb40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7430263c07b4a1bcf3deb708c8c691f233fcb40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7430263c07b4a1bcf3deb708c8c691f233fcb40"}], "stats": {"total": 224, "additions": 148, "deletions": 76}, "files": [{"sha": "e618471b8d1ffd1f6bd777869d8207c31fd24aae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5120e0d8d48f4590a275e60565de6c5a4e772fc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5120e0d8d48f4590a275e60565de6c5a4e772fc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5120e0d8d48f4590a275e60565de6c5a4e772fc1", "patch": "@@ -1,3 +1,10 @@\n+2019-05-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-affine.c (expr_to_aff_combination): New function split\n+\tout from...\n+\t(tree_to_aff_combination): ... here.\n+\t(aff_combination_expand): Avoid building a GENERIC tree.\n+\n 2019-05-16  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* cgraphunit.c (cgraph_node::expand_thunk): Remove"}, {"sha": "b8a62a6aff12f946d0aba8d5ae427dd78600571d", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 141, "deletions": 76, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5120e0d8d48f4590a275e60565de6c5a4e772fc1/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5120e0d8d48f4590a275e60565de6c5a4e772fc1/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=5120e0d8d48f4590a275e60565de6c5a4e772fc1", "patch": "@@ -259,104 +259,66 @@ aff_combination_convert (aff_tree *comb, tree type)\n     }\n }\n \n-/* Splits EXPR into an affine combination of parts.  */\n+/* Tries to handle OP0 CODE OP1 as affine combination of parts.  Returns\n+   true when that was successful and returns the combination in COMB.  */\n \n-void\n-tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n+static bool\n+expr_to_aff_combination (aff_tree *comb, tree_code code, tree type,\n+\t\t\t tree op0, tree op1 = NULL_TREE)\n {\n   aff_tree tmp;\n-  enum tree_code code;\n-  tree cst, core, toffset;\n   poly_int64 bitpos, bitsize, bytepos;\n-  machine_mode mode;\n-  int unsignedp, reversep, volatilep;\n-\n-  STRIP_NOPS (expr);\n \n-  code = TREE_CODE (expr);\n   switch (code)\n     {\n     case POINTER_PLUS_EXPR:\n-      tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n-      tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n+      tree_to_aff_combination (op0, type, comb);\n+      tree_to_aff_combination (op1, sizetype, &tmp);\n       aff_combination_add (comb, &tmp);\n-      return;\n+      return true;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n-      tree_to_aff_combination (TREE_OPERAND (expr, 1), type, &tmp);\n+      tree_to_aff_combination (op0, type, comb);\n+      tree_to_aff_combination (op1, type, &tmp);\n       if (code == MINUS_EXPR)\n \taff_combination_scale (&tmp, -1);\n       aff_combination_add (comb, &tmp);\n-      return;\n+      return true;\n \n     case MULT_EXPR:\n-      cst = TREE_OPERAND (expr, 1);\n-      if (TREE_CODE (cst) != INTEGER_CST)\n+      if (TREE_CODE (op1) != INTEGER_CST)\n \tbreak;\n-      tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n-      aff_combination_scale (comb, wi::to_widest (cst));\n-      return;\n+      tree_to_aff_combination (op0, type, comb);\n+      aff_combination_scale (comb, wi::to_widest (op1));\n+      return true;\n \n     case NEGATE_EXPR:\n-      tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n+      tree_to_aff_combination (op0, type, comb);\n       aff_combination_scale (comb, -1);\n-      return;\n+      return true;\n \n     case BIT_NOT_EXPR:\n       /* ~x = -x - 1 */\n-      tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n+      tree_to_aff_combination (op0, type, comb);\n       aff_combination_scale (comb, -1);\n       aff_combination_add_cst (comb, -1);\n-      return;\n-\n-    case ADDR_EXPR:\n-      /* Handle &MEM[ptr + CST] which is equivalent to POINTER_PLUS_EXPR.  */\n-      if (TREE_CODE (TREE_OPERAND (expr, 0)) == MEM_REF)\n-\t{\n-\t  expr = TREE_OPERAND (expr, 0);\n-\t  tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n-\t  tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n-\t  aff_combination_add (comb, &tmp);\n-\t  return;\n-\t}\n-      core = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize, &bitpos,\n-\t\t\t\t  &toffset, &mode, &unsignedp, &reversep,\n-\t\t\t\t  &volatilep);\n-      if (!multiple_p (bitpos, BITS_PER_UNIT, &bytepos))\n-\tbreak;\n-      aff_combination_const (comb, type, bytepos);\n-      if (TREE_CODE (core) == MEM_REF)\n-\t{\n-\t  tree mem_offset = TREE_OPERAND (core, 1);\n-\t  aff_combination_add_cst (comb, wi::to_poly_widest (mem_offset));\n-\t  core = TREE_OPERAND (core, 0);\n-\t}\n-      else\n-\tcore = build_fold_addr_expr (core);\n-\n-      if (TREE_CODE (core) == ADDR_EXPR)\n-\taff_combination_add_elt (comb, core, 1);\n-      else\n-\t{\n-\t  tree_to_aff_combination (core, type, &tmp);\n-\t  aff_combination_add (comb, &tmp);\n-\t}\n-      if (toffset)\n-\t{\n-\t  tree_to_aff_combination (toffset, type, &tmp);\n-\t  aff_combination_add (comb, &tmp);\n-\t}\n-      return;\n+      return true;\n \n     CASE_CONVERT:\n       {\n-\ttree otype = TREE_TYPE (expr);\n-\ttree inner = TREE_OPERAND (expr, 0);\n+\ttree otype = type;\n+\ttree inner = op0;\n \ttree itype = TREE_TYPE (inner);\n \tenum tree_code icode = TREE_CODE (inner);\n \n+\t/* STRIP_NOPS  */\n+\tif (tree_nop_conversion_p (otype, itype))\n+\t  {\n+\t    tree_to_aff_combination (op0, type, comb);\n+\t    return true;\n+\t  }\n+\n \t/* In principle this is a valid folding, but it isn't necessarily\n \t   an optimization, so do it here and not in fold_unary.  */\n \tif ((icode == PLUS_EXPR || icode == MINUS_EXPR || icode == MULT_EXPR)\n@@ -376,9 +338,7 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n \t      {\n \t\top0 = fold_convert (otype, op0);\n \t\top1 = fold_convert (otype, op1);\n-\t\texpr = fold_build2 (icode, otype, op0, op1);\n-\t\ttree_to_aff_combination (expr, type, comb);\n-\t\treturn;\n+\t\treturn expr_to_aff_combination (comb, icode, otype, op0, op1);\n \t      }\n \t    wide_int minv, maxv;\n \t    /* If inner type has wrapping overflow behavior, fold conversion\n@@ -399,15 +359,102 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n \t\t  {\n \t\t    op0 = fold_convert (otype, op0);\n \t\t    op1 = fold_convert (otype, op1);\n-\t\t    expr = fold_build2 (MINUS_EXPR, otype, op0, op1);\n-\t\t    tree_to_aff_combination (expr, type, comb);\n-\t\t    return;\n+\t\t    return expr_to_aff_combination (comb, MINUS_EXPR, otype,\n+\t\t\t\t\t\t    op0, op1);\n \t\t  }\n \t      }\n \t  }\n       }\n       break;\n \n+    default:;\n+    }\n+\n+  return false;\n+}\n+\n+/* Splits EXPR into an affine combination of parts.  */\n+\n+void\n+tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n+{\n+  aff_tree tmp;\n+  enum tree_code code;\n+  tree core, toffset;\n+  poly_int64 bitpos, bitsize, bytepos;\n+  machine_mode mode;\n+  int unsignedp, reversep, volatilep;\n+\n+  STRIP_NOPS (expr);\n+\n+  code = TREE_CODE (expr);\n+  switch (code)\n+    {\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+      if (expr_to_aff_combination (comb, code, type, TREE_OPERAND (expr, 0),\n+\t\t\t\t   TREE_OPERAND (expr, 1)))\n+\treturn;\n+      break;\n+\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+      if (expr_to_aff_combination (comb, code, type, TREE_OPERAND (expr, 0)))\n+\treturn;\n+      break;\n+\n+    CASE_CONVERT:\n+      /* ???  TREE_TYPE (expr) should be equal to type here, but IVOPTS\n+\t calls this with not showing an outer widening cast.  */\n+      if (expr_to_aff_combination (comb, code,\n+\t\t\t\t   TREE_TYPE (expr), TREE_OPERAND (expr, 0)))\n+\t{\n+\t  aff_combination_convert (comb, type);\n+\t  return;\n+\t}\n+      break;\n+\n+    case ADDR_EXPR:\n+      /* Handle &MEM[ptr + CST] which is equivalent to POINTER_PLUS_EXPR.  */\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == MEM_REF)\n+\t{\n+\t  expr = TREE_OPERAND (expr, 0);\n+\t  tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n+\t  tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n+\t  aff_combination_add (comb, &tmp);\n+\t  return;\n+\t}\n+      core = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize, &bitpos,\n+\t\t\t\t  &toffset, &mode, &unsignedp, &reversep,\n+\t\t\t\t  &volatilep);\n+      if (!multiple_p (bitpos, BITS_PER_UNIT, &bytepos))\n+\tbreak;\n+      aff_combination_const (comb, type, bytepos);\n+      if (TREE_CODE (core) == MEM_REF)\n+\t{\n+\t  tree mem_offset = TREE_OPERAND (core, 1);\n+\t  aff_combination_add_cst (comb, wi::to_poly_widest (mem_offset));\n+\t  core = TREE_OPERAND (core, 0);\n+\t}\n+      else\n+\tcore = build_fold_addr_expr (core);\n+\n+      if (TREE_CODE (core) == ADDR_EXPR)\n+\taff_combination_add_elt (comb, core, 1);\n+      else\n+\t{\n+\t  tree_to_aff_combination (core, type, &tmp);\n+\t  aff_combination_add (comb, &tmp);\n+\t}\n+      if (toffset)\n+\t{\n+\t  tree_to_aff_combination (toffset, type, &tmp);\n+\t  aff_combination_add (comb, &tmp);\n+\t}\n+      return;\n+\n     default:\n       {\n \tif (poly_int_tree_p (expr))\n@@ -665,7 +712,7 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n {\n   unsigned i;\n   aff_tree to_add, current, curre;\n-  tree e, rhs;\n+  tree e;\n   gimple *def;\n   widest_int scale;\n   struct name_expansion *exp;\n@@ -715,20 +762,38 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n \t    case PLUS_EXPR:\n \t    case MINUS_EXPR:\n \t    case MULT_EXPR:\n+\t      if (!expr_to_aff_combination (&current, code, TREE_TYPE (name),\n+\t\t\t\t\t    gimple_assign_rhs1 (def),\n+\t\t\t\t\t    gimple_assign_rhs2 (def)))\n+\t\tcontinue;\n+\t      break;\n \t    case NEGATE_EXPR:\n \t    case BIT_NOT_EXPR:\n+\t      if (!expr_to_aff_combination (&current, code, TREE_TYPE (name),\n+\t\t\t\t\t    gimple_assign_rhs1 (def)))\n+\t\tcontinue;\n+\t      break;\n \t    CASE_CONVERT:\n-\t      rhs = gimple_assign_rhs_to_tree (def);\n+\t      if (!expr_to_aff_combination (&current, code, TREE_TYPE (name),\n+\t\t\t\t\t    gimple_assign_rhs1 (def)))\n+\t\t/* This makes us always expand conversions which we did\n+\t\t   in the past and makes gcc.dg/tree-ssa/ivopts-lt-2.c\n+\t\t   PASS, eliminating one induction variable in IVOPTs.\n+\t\t   ???  But it is really excessive and we should try\n+\t\t   harder to do without it.  */\n+\t\taff_combination_elt (&current, TREE_TYPE (name),\n+\t\t\t\t     fold_convert (TREE_TYPE (name),\n+\t\t\t\t\t\t   gimple_assign_rhs1 (def)));\n \t      break;\n \t    case ADDR_EXPR:\n \t    case INTEGER_CST:\n \t    case POLY_INT_CST:\n-\t      rhs = gimple_assign_rhs1 (def);\n+\t      tree_to_aff_combination (gimple_assign_rhs1 (def),\n+\t\t\t\t       TREE_TYPE (name), &current);\n \t      break;\n \t    default:\n \t      continue;\n \t    }\n-\t  tree_to_aff_combination (rhs, TREE_TYPE (name), &current);\n \t  exp = XNEW (struct name_expansion);\n \t  exp->in_progress = 1;\n \t  if (!*cache)"}]}