{"sha": "9da8a3ae97750a437a1197bdafdae642db7471fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRhOGEzYWU5Nzc1MGE0MzdhMTE5N2JkYWZkYWU2NDJkYjc0NzFmYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-06-27T02:39:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-06-27T02:39:42Z"}, "message": "* jump.c (jump_optimize_1): Validate the cmov copy to a temporary.\n\nFrom-SVN: r27788", "tree": {"sha": "8ef276fb052001318201c67c3e0a143259d26b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ef276fb052001318201c67c3e0a143259d26b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9da8a3ae97750a437a1197bdafdae642db7471fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9da8a3ae97750a437a1197bdafdae642db7471fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9da8a3ae97750a437a1197bdafdae642db7471fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9da8a3ae97750a437a1197bdafdae642db7471fb/comments", "author": null, "committer": null, "parents": [{"sha": "e2b2063128ae9c2302f5a63e6237c17f5b3e79aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2b2063128ae9c2302f5a63e6237c17f5b3e79aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2b2063128ae9c2302f5a63e6237c17f5b3e79aa"}], "stats": {"total": 61, "additions": 42, "deletions": 19}, "files": [{"sha": "0426f63c87a022b740e567aeda9935fa1cae948f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da8a3ae97750a437a1197bdafdae642db7471fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da8a3ae97750a437a1197bdafdae642db7471fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9da8a3ae97750a437a1197bdafdae642db7471fb", "patch": "@@ -1,3 +1,7 @@\n+Sun Jun 27 02:39:08 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* jump.c (jump_optimize_1): Validate the cmov copy to a temporary.\n+\n Sat Jun 26 17:18:18 1999  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.c (print_operand, case 'L'): Use plus_constant_for_output."}, {"sha": "295a6c117ba64fad8b18f85b07c13e6547b9a204", "filename": "gcc/jump.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9da8a3ae97750a437a1197bdafdae642db7471fb/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9da8a3ae97750a437a1197bdafdae642db7471fb/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=9da8a3ae97750a437a1197bdafdae642db7471fb", "patch": "@@ -970,7 +970,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n \t\tif (target)\n \t\t  {\n-\t\t    rtx seq1,seq2,last;\n+\t\t    rtx seq1, seq2, last;\n+\t\t    int copy_ok;\n \n \t\t    /* Save the conditional move sequence but don't emit it\n \t\t       yet.  On some machines, like the alpha, it is possible\n@@ -980,34 +981,52 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t    seq2 = get_insns ();\n \t\t    end_sequence ();\n \n-\t\t    /* Now that we can't fail, generate the copy insns that\n-\t\t       preserve the compared values.  */\n+\t\t    /* \"Now that we can't fail...\"  Famous last words.\n+\t\t       Generate the copy insns that preserve the compared\n+\t\t       values.  */\n \t\t    start_sequence ();\n \t\t    emit_move_insn (cond0, XEXP (temp4, 0));\n \t\t    if (cond1 != XEXP (temp4, 1))\n \t\t      emit_move_insn (cond1, XEXP (temp4, 1));\n \t\t    seq1 = get_insns ();\n \t\t    end_sequence ();\n \n-\t\t    emit_insns_before (seq1, temp5);\n-\t\t    /* Insert conditional move after insn, to be sure that\n-\t\t       the jump and a possible compare won't be separated */\n-\t\t    last = emit_insns_after (seq2, insn);\n-\n-\t\t    /* ??? We can also delete the insn that sets X to A.\n-\t\t       Flow will do it too though.  */\n-\t\t    delete_insn (temp);\n-\t\t    next = NEXT_INSN (insn);\n-\t\t    delete_jump (insn);\n+\t\t    /* Validate the sequence -- this may be some weird\n+\t\t       bit-extract-and-test instruction for which there\n+\t\t       exists no complimentary bit-extract insn.  */\n+\t\t    copy_ok = 1;\n+\t\t    for (last = seq1; last ; last = NEXT_INSN (last))\n+\t\t      if (recog_memoized (last) < 0)\n+\t\t\t{\n+\t\t\t  copy_ok = 0;\n+\t\t\t  break;\n+\t\t\t}\n \n-\t\t    if (after_regscan)\n+\t\t    if (copy_ok)\n \t\t      {\n-\t\t\treg_scan_update (seq1, NEXT_INSN (last), old_max_reg);\n-\t\t\told_max_reg = max_reg_num ();\n+\t\t        emit_insns_before (seq1, temp5);\n+\n+\t\t        /* Insert conditional move after insn, to be sure\n+\t\t\t   that the jump and a possible compare won't be\n+\t\t\t   separated.  */\n+\t\t        last = emit_insns_after (seq2, insn);\n+\n+\t\t        /* ??? We can also delete the insn that sets X to A.\n+\t\t           Flow will do it too though.  */\n+\t\t        delete_insn (temp);\n+\t\t        next = NEXT_INSN (insn);\n+\t\t        delete_jump (insn);\n+\n+\t\t        if (after_regscan)\n+\t\t          {\n+\t\t\t    reg_scan_update (seq1, NEXT_INSN (last),\n+\t\t\t\t\t     old_max_reg);\n+\t\t\t    old_max_reg = max_reg_num ();\n+\t\t          }\n+\n+\t\t        changed = 1;\n+\t\t        continue;\n \t\t      }\n-\n-\t\t    changed = 1;\n-\t\t    continue;\n \t\t  }\n \t\telse\n \t\t  end_sequence ();"}]}