{"sha": "1ece90ffa9ce63b416296bd662b8117d9b538913", "node_id": "C_kwDOANBUbNoAKDFlY2U5MGZmYTljZTYzYjQxNjI5NmJkNjYyYjgxMTdkOWI1Mzg5MTM", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-11-04T17:01:20Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-11-04T17:08:29Z"}, "message": "ipa-sra: Improve debug info for removed parameters (PR 93385)\n\nIn spring I added code eliminating any statements using parameters\nremoved by IPA passes (to fix PR 93385).  That patch fixed issues such\nas divisions by zero that such code could perform but it only reset\nall affected debug bind statements, this one updates them with\nexpressions which can allow the debugger to print the removed value -\nsee the added test-case for an example.\n\nEven though I originally did not want to create DEBUG_EXPR_DECLs for\nintermediate values, I ended up doing so, because otherwise the code\nstarted creating statements like\n\n   # DEBUG __aD.198693 => &MEM[(const struct _Alloc_nodeD.171110 *)D#195]._M_tD.184726->_M_implD.171154\n\nwhich not only is a bit scary but also gimple-fold ICEs on\nit. Therefore I decided they are probably quite necessary.\n\nThe patch simply notes each removed SSA name present in a debug\nstatement and then works from it backwards, looking if it can\nreconstruct the expression it represents (which can fail if a\nnon-degenerate PHI node is in the way).  If it can, it populates two\nhash maps with those expressions so that 1) removed assignments are\nreplaced with a debug bind defining a new intermediate debug_decl_expr\nand 2) existing debug binds that refer to SSA names that are bing\nremoved now refer to corresponding debug_decl_exprs.\n\nIf a removed parameter is passed to another function, the debugging\ninformation still cannot describe its value there - see the xfailed\ntest in the testcase.  I sort of know what needs to be done but that\nneeds a little bit more of IPA infrastructure on top of this patch and\nso I would like to get this patch reviewed first.\n\nBootstrapped and tested on x86_64-linux, i686-linux and (long time\nago) on aarch64-linux.  Also LTO-bootstrapped and on x86_64-linux.\n\nPerhaps it is good to go to trunk?\n\nThanks,\n\nMartin\n\ngcc/ChangeLog:\n\n2021-03-29  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* ipa-param-manipulation.h (class ipa_param_body_adjustments): New\n\tmembers remap_with_debug_expressions, m_dead_ssa_debug_equiv,\n\tm_dead_stmt_debug_equiv and prepare_debug_expressions.  Added\n\tparameter to mark_dead_statements.\n\t* ipa-param-manipulation.c: Include tree-phinodes.h and cfgexpand.h.\n\t(ipa_param_body_adjustments::mark_dead_statements): New parameter\n\tdebugstack, push into it all SSA names used in debug statements,\n\tproduce m_dead_ssa_debug_equiv mapping for the removed param.\n\t(replace_with_mapped_expr): New function.\n\t(ipa_param_body_adjustments::remap_with_debug_expressions): Likewise.\n\t(ipa_param_body_adjustments::prepare_debug_expressions): Likewise.\n\t(ipa_param_body_adjustments::common_initialization): Gather and\n\tprocecc SSA which will be removed but are in debug statements. Simplify.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Initialize\n\tnew members.\n\t* tree-inline.c (remap_gimple_stmt): Create a debug bind when possible\n\twhen avoiding a copy of an unnecessary statement.  Remap removed SSA\n\tnames in existing debug statements.\n\t(tree_function_versioning): Do not create DEBUG_EXPR_DECL for removed\n\tparameters if we have already done so.\n\ngcc/testsuite/ChangeLog:\n\n2021-03-29  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* gcc.dg/guality/ipa-sra-1.c: New test.", "tree": {"sha": "90f287c0c0ffa6d8397a3f151d8cdee39f05e05d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90f287c0c0ffa6d8397a3f151d8cdee39f05e05d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ece90ffa9ce63b416296bd662b8117d9b538913", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmGEE40ACgkQv2PBvD+k\nNUBCJQ//Xp3Wy4LFnwbqNZuGaQ7Xaew2fg29I7EprDnboZGTPuuqEOdvv1iBIW3N\nwq4370sOjD/MWoDtABf7tXyk/JxMnHnXOiVg15v2ozBW+1wnUZ5PzBflR/CL+6/d\nxkGPJd/88GNnof5d/Z8DL+2WUijeGgUnp0Y87VnwPuZhxdV+6N8QH9tg1CQ86oZ+\nwRMvyzDTW6Q0Qjr+KsZbjuINJRaaeUPoDnWZFwnEptcJRZo8hynN40gCuvDHWpyx\nCm6ScRMojRicE+A4EYlGYwJmSc4P6Wn1LI8VPe71Oh5bE9TZJxPYpceXkddX16VH\nBbUvZ9pfZf3z8S/d6Nx0zzY9gNuY47wHCqAsarrghk51pKAu+Pq5Yv5dc0d3oANv\nnSrUig9SWPyMDq39Ym3uUR6lsPpyJMy91WWTCQMQjSH7o2v7CvUp1UGAPgzuT1aB\nHN1za84wQG23qe7n0FgPTlEplLdtukj0NnC+5iaDIzborW/h0UyhthqSkfQzjawJ\nSJwN+gJ1xFjpw4KAhEy8SyT5FE94Z5y0INxEKwQfzvGGsu328yPLrUW+d02a3G7E\nFkOq1HIQN8zk32YO4RHdDNmFYyv2+OSM4w/RExmvruuplOirAaXvd1TaHQnO5H5z\nnZfnEnBuneDsa5yS8o/fvYBvQo9YktOXHfd+SVi7oo/myMjZewM=\n=2PTB\n-----END PGP SIGNATURE-----", "payload": "tree 90f287c0c0ffa6d8397a3f151d8cdee39f05e05d\nparent 7237c5b698b57dead425a215805a88b52d7823b0\nauthor Martin Jambor <mjambor@suse.cz> 1636045280 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1636045709 +0100\n\nipa-sra: Improve debug info for removed parameters (PR 93385)\n\nIn spring I added code eliminating any statements using parameters\nremoved by IPA passes (to fix PR 93385).  That patch fixed issues such\nas divisions by zero that such code could perform but it only reset\nall affected debug bind statements, this one updates them with\nexpressions which can allow the debugger to print the removed value -\nsee the added test-case for an example.\n\nEven though I originally did not want to create DEBUG_EXPR_DECLs for\nintermediate values, I ended up doing so, because otherwise the code\nstarted creating statements like\n\n   # DEBUG __aD.198693 => &MEM[(const struct _Alloc_nodeD.171110 *)D#195]._M_tD.184726->_M_implD.171154\n\nwhich not only is a bit scary but also gimple-fold ICEs on\nit. Therefore I decided they are probably quite necessary.\n\nThe patch simply notes each removed SSA name present in a debug\nstatement and then works from it backwards, looking if it can\nreconstruct the expression it represents (which can fail if a\nnon-degenerate PHI node is in the way).  If it can, it populates two\nhash maps with those expressions so that 1) removed assignments are\nreplaced with a debug bind defining a new intermediate debug_decl_expr\nand 2) existing debug binds that refer to SSA names that are bing\nremoved now refer to corresponding debug_decl_exprs.\n\nIf a removed parameter is passed to another function, the debugging\ninformation still cannot describe its value there - see the xfailed\ntest in the testcase.  I sort of know what needs to be done but that\nneeds a little bit more of IPA infrastructure on top of this patch and\nso I would like to get this patch reviewed first.\n\nBootstrapped and tested on x86_64-linux, i686-linux and (long time\nago) on aarch64-linux.  Also LTO-bootstrapped and on x86_64-linux.\n\nPerhaps it is good to go to trunk?\n\nThanks,\n\nMartin\n\ngcc/ChangeLog:\n\n2021-03-29  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* ipa-param-manipulation.h (class ipa_param_body_adjustments): New\n\tmembers remap_with_debug_expressions, m_dead_ssa_debug_equiv,\n\tm_dead_stmt_debug_equiv and prepare_debug_expressions.  Added\n\tparameter to mark_dead_statements.\n\t* ipa-param-manipulation.c: Include tree-phinodes.h and cfgexpand.h.\n\t(ipa_param_body_adjustments::mark_dead_statements): New parameter\n\tdebugstack, push into it all SSA names used in debug statements,\n\tproduce m_dead_ssa_debug_equiv mapping for the removed param.\n\t(replace_with_mapped_expr): New function.\n\t(ipa_param_body_adjustments::remap_with_debug_expressions): Likewise.\n\t(ipa_param_body_adjustments::prepare_debug_expressions): Likewise.\n\t(ipa_param_body_adjustments::common_initialization): Gather and\n\tprocecc SSA which will be removed but are in debug statements. Simplify.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Initialize\n\tnew members.\n\t* tree-inline.c (remap_gimple_stmt): Create a debug bind when possible\n\twhen avoiding a copy of an unnecessary statement.  Remap removed SSA\n\tnames in existing debug statements.\n\t(tree_function_versioning): Do not create DEBUG_EXPR_DECL for removed\n\tparameters if we have already done so.\n\ngcc/testsuite/ChangeLog:\n\n2021-03-29  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* gcc.dg/guality/ipa-sra-1.c: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ece90ffa9ce63b416296bd662b8117d9b538913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ece90ffa9ce63b416296bd662b8117d9b538913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ece90ffa9ce63b416296bd662b8117d9b538913/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7237c5b698b57dead425a215805a88b52d7823b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7237c5b698b57dead425a215805a88b52d7823b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7237c5b698b57dead425a215805a88b52d7823b0"}], "stats": {"total": 368, "additions": 298, "deletions": 70}, "files": [{"sha": "c84d669521c576070a44cf2e296ee797fae0a24c", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 210, "deletions": 56, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=1ece90ffa9ce63b416296bd662b8117d9b538913", "patch": "@@ -43,6 +43,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"symbol-summary.h\"\n #include \"symtab-clones.h\"\n+#include \"tree-phinodes.h\"\n+#include \"cfgexpand.h\"\n \n \n /* Actual prefixes of different newly synthetized parameters.  Keep in sync\n@@ -972,10 +974,12 @@ ipa_param_body_adjustments::carry_over_param (tree t)\n \n /* Populate m_dead_stmts given that DEAD_PARAM is going to be removed without\n    any replacement or splitting.  REPL is the replacement VAR_SECL to base any\n-   remaining uses of a removed parameter on.  */\n+   remaining uses of a removed parameter on.  Push all removed SSA names that\n+   are used within debug statements to DEBUGSTACK.  */\n \n void\n-ipa_param_body_adjustments::mark_dead_statements (tree dead_param)\n+ipa_param_body_adjustments::mark_dead_statements (tree dead_param,\n+\t\t\t\t\t\t  vec<tree> *debugstack)\n {\n   /* Current IPA analyses which remove unused parameters never remove a\n      non-gimple register ones which have any use except as parameters in other\n@@ -987,6 +991,7 @@ ipa_param_body_adjustments::mark_dead_statements (tree dead_param)\n     return;\n \n   auto_vec<tree, 4> stack;\n+  hash_set<tree> used_in_debug;\n   m_dead_ssas.add (parm_ddef);\n   stack.safe_push (parm_ddef);\n   while (!stack.is_empty ())\n@@ -1014,6 +1019,11 @@ ipa_param_body_adjustments::mark_dead_statements (tree dead_param)\n \t    {\n \t      m_dead_stmts.add (stmt);\n \t      gcc_assert (gimple_debug_bind_p (stmt));\n+\t      if (!used_in_debug.contains (t))\n+\t\t{\n+\t\t  used_in_debug.add (t);\n+\t\t  debugstack->safe_push (t);\n+\t\t}\n \t    }\n \t  else if (gimple_code (stmt) == GIMPLE_PHI)\n \t    {\n@@ -1046,6 +1056,149 @@ ipa_param_body_adjustments::mark_dead_statements (tree dead_param)\n \t    gcc_unreachable ();\n \t}\n     }\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    {\n+      gcc_assert (debugstack->is_empty ());\n+      return;\n+    }\n+\n+  tree dp_ddecl = make_node (DEBUG_EXPR_DECL);\n+  DECL_ARTIFICIAL (dp_ddecl) = 1;\n+  TREE_TYPE (dp_ddecl) = TREE_TYPE (dead_param);\n+  SET_DECL_MODE (dp_ddecl, DECL_MODE (dead_param));\n+  m_dead_ssa_debug_equiv.put (parm_ddef, dp_ddecl);\n+}\n+\n+/* Callback to walk_tree.  If REMAP is an SSA_NAME that is present in hash_map\n+   passed in DATA, replace it with unshared version of what it was mapped\n+   to.  */\n+\n+static tree\n+replace_with_mapped_expr (tree *remap, int *walk_subtrees, void *data)\n+{\n+  if (TYPE_P (*remap))\n+    {\n+      *walk_subtrees = 0;\n+      return 0;\n+    }\n+  if (TREE_CODE (*remap) != SSA_NAME)\n+    return 0;\n+\n+  *walk_subtrees = 0;\n+\n+  hash_map<tree, tree> *equivs = (hash_map<tree, tree> *) data;\n+  if (tree *p = equivs->get (*remap))\n+    *remap = unshare_expr (*p);\n+  return 0;\n+}\n+\n+/* Replace all occurances of SSAs in m_dead_ssa_debug_equiv in t with what they\n+   are mapped to.  */\n+\n+void\n+ipa_param_body_adjustments::remap_with_debug_expressions (tree *t)\n+{\n+  /* If *t is an SSA_NAME which should have its debug statements reset, it is\n+     mapped to NULL in the hash_map.  We need to handle that case separately or\n+     otherwise the walker would segfault.  No expression that is more\n+     complicated than that can have its operands mapped to NULL.  */\n+  if (TREE_CODE (*t) == SSA_NAME)\n+    {\n+      if (tree *p = m_dead_ssa_debug_equiv.get (*t))\n+\t*t = *p;\n+    }\n+  else\n+    walk_tree (t, replace_with_mapped_expr, &m_dead_ssa_debug_equiv, NULL);\n+}\n+\n+/* For an SSA_NAME DEAD_SSA which is about to be DCEd because it is based on a\n+   useless parameter, prepare an expression that should represent it in\n+   debug_binds in the cloned function and add a mapping from DEAD_SSA to\n+   m_dead_ssa_debug_equiv.  That mapping is to NULL when the associated\n+   debug_statement has to be reset instead.  In such case return false,\n+   ottherwise return true.  If DEAD_SSA comes from a basic block which is not\n+   about to be copied, ignore it and return true.  */\n+\n+bool\n+ipa_param_body_adjustments::prepare_debug_expressions (tree dead_ssa)\n+{\n+  gcc_checking_assert (m_dead_ssas.contains (dead_ssa));\n+  if (tree *d = m_dead_ssa_debug_equiv.get (dead_ssa))\n+    return (*d != NULL_TREE);\n+\n+  gcc_assert (!SSA_NAME_IS_DEFAULT_DEF (dead_ssa));\n+  gimple *def = SSA_NAME_DEF_STMT (dead_ssa);\n+  if (m_id->blocks_to_copy\n+      && !bitmap_bit_p (m_id->blocks_to_copy, gimple_bb (def)->index))\n+    return true;\n+\n+  if (gimple_code (def) == GIMPLE_PHI)\n+    {\n+      /* In theory, we could ignore all SSAs coming from BBs not in\n+\t m_id->blocks_to_copy but at the time of the writing this code that\n+\t should never really be the case because only fnsplit uses that bitmap,\n+\t so don't bother.  */\n+      tree value = degenerate_phi_result (as_a <gphi *> (def));\n+      if (!value\n+\t  || (m_dead_ssas.contains (value)\n+\t      && !prepare_debug_expressions (value)))\n+\t{\n+\t  m_dead_ssa_debug_equiv.put (dead_ssa, NULL_TREE);\n+\t  return false;\n+\t}\n+\n+      gcc_assert (TREE_CODE (value) == SSA_NAME);\n+      tree *d = m_dead_ssa_debug_equiv.get (value);\n+      m_dead_ssa_debug_equiv.put (dead_ssa, *d);\n+      return true;\n+    }\n+\n+  bool lost = false;\n+  use_operand_p use_p;\n+  ssa_op_iter oi;\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, def, oi, SSA_OP_USE)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      if (m_dead_ssas.contains (use)\n+\t  && !prepare_debug_expressions (use))\n+\t{\n+\t  lost = true;\n+\t  break;\n+\t}\n+    }\n+\n+  if (lost)\n+    {\n+      m_dead_ssa_debug_equiv.put (dead_ssa, NULL_TREE);\n+      return false;\n+    }\n+\n+  if (is_gimple_assign (def))\n+    {\n+      gcc_assert (!gimple_clobber_p (def));\n+      if (gimple_assign_copy_p (def)\n+\t  && TREE_CODE (gimple_assign_rhs1 (def)) == SSA_NAME)\n+\t{\n+\t  tree *d = m_dead_ssa_debug_equiv.get (gimple_assign_rhs1 (def));\n+\t  m_dead_ssa_debug_equiv.put (dead_ssa, *d);\n+\t  return (*d != NULL_TREE);\n+\t}\n+\n+      tree val = gimple_assign_rhs_to_tree (def);\n+      SET_EXPR_LOCATION (val, UNKNOWN_LOCATION);\n+      remap_with_debug_expressions (&val);\n+\n+      tree vexpr = make_node (DEBUG_EXPR_DECL);\n+      DECL_ARTIFICIAL (vexpr) = 1;\n+      TREE_TYPE (vexpr) = TREE_TYPE (val);\n+      SET_DECL_MODE (vexpr, TYPE_MODE (TREE_TYPE (val)));\n+      m_dead_stmt_debug_equiv.put (def, val);\n+      m_dead_ssa_debug_equiv.put (dead_ssa, vexpr);\n+      return true;\n+    }\n+  else\n+    gcc_unreachable ();\n }\n \n /* Common initialization performed by all ipa_param_body_adjustments\n@@ -1137,6 +1290,32 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \tgcc_unreachable ();\n     }\n \n+  if (tree_map)\n+    {\n+      /* Do not treat parameters which were replaced with a constant as\n+\t completely vanished.  */\n+      auto_vec <int, 16> index_mapping;\n+      bool need_remap = false;\n+\n+      if (m_id)\n+\t{\n+\t  clone_info *cinfo = clone_info::get (m_id->src_node);\n+\t  if (cinfo && cinfo->param_adjustments)\n+\t    {\n+\t      cinfo->param_adjustments->get_updated_indices (&index_mapping);\n+\t      need_remap = true;\n+\t    }\n+\t}\n+\n+      for (unsigned i = 0; i < tree_map->length (); i++)\n+\t{\n+\t  int parm_num = (*tree_map)[i]->parm_num;\n+\t  gcc_assert (parm_num >= 0);\n+\t  if (need_remap)\n+\t    parm_num = index_mapping[parm_num];\n+\t  kept[parm_num] = true;\n+\t}\n+    }\n \n   /* As part of body modifications, we will also have to replace remaining uses\n      of remaining uses of removed PARM_DECLs (which do not however use the\n@@ -1149,68 +1328,41 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n      replace_removed_params_ssa_names or perform_cfun_body_modifications when\n      you construct with ID not equal to NULL.  */\n \n+  auto_vec<tree, 8> ssas_to_process_debug;\n   unsigned op_len = m_oparms.length ();\n   for (unsigned i = 0; i < op_len; i++)\n     if (!kept[i])\n       {\n \tif (m_id)\n \t  {\n-\t    if (!m_id->decl_map->get (m_oparms[i]))\n-\t      {\n-\t\ttree var = copy_decl_to_var (m_oparms[i], m_id);\n-\t\tinsert_decl_map (m_id, m_oparms[i], var);\n-\t\t/* Declare this new variable.  */\n-\t\tDECL_CHAIN (var) = *vars;\n-\t\t*vars = var;\n-\n-\t\t/* If this is not a split but a real removal, init hash sets\n-\t\t   that will guide what not to copy to the new body.  */\n-\t\tif (!split[i])\n-\t\t  mark_dead_statements (m_oparms[i]);\n-\t      }\n+\t    gcc_assert (!m_id->decl_map->get (m_oparms[i]));\n+\t    tree var = copy_decl_to_var (m_oparms[i], m_id);\n+\t    insert_decl_map (m_id, m_oparms[i], var);\n+\t    /* Declare this new variable.  */\n+\t    DECL_CHAIN (var) = *vars;\n+\t    *vars = var;\n+\n+\t    /* If this is not a split but a real removal, init hash sets\n+\t       that will guide what not to copy to the new body.  */\n+\t    if (!split[i])\n+\t      mark_dead_statements (m_oparms[i], &ssas_to_process_debug);\n+\t    if (MAY_HAVE_DEBUG_STMTS\n+\t\t&& is_gimple_reg (m_oparms[i]))\n+\t      m_reset_debug_decls.safe_push (m_oparms[i]);\n \t  }\n \telse\n \t  {\n \t    m_removed_decls.safe_push (m_oparms[i]);\n \t    m_removed_map.put (m_oparms[i], m_removed_decls.length () - 1);\n+\t    if (MAY_HAVE_DEBUG_STMTS\n+\t\t&& !kept[i]\n+\t\t&& is_gimple_reg (m_oparms[i]))\n+\t      m_reset_debug_decls.safe_push (m_oparms[i]);\n \t  }\n       }\n \n-  if (!MAY_HAVE_DEBUG_STMTS)\n-    return;\n-\n-  /* Finally, when generating debug info, we fill vector m_reset_debug_decls\n-    with removed parameters declarations.  We do this in order to re-map their\n-    debug bind statements and create debug decls for them.  */\n-\n-  if (tree_map)\n-    {\n-      /* Do not output debuginfo for parameter declarations as if they vanished\n-\t when they were in fact replaced by a constant.  */\n-      auto_vec <int, 16> index_mapping;\n-      bool need_remap = false;\n-      clone_info *info = clone_info::get (m_id->src_node);\n-\n-      if (m_id && info && info->param_adjustments)\n-\t{\n-\t  ipa_param_adjustments *prev_adjustments = info->param_adjustments;\n-\t  prev_adjustments->get_updated_indices (&index_mapping);\n-\t  need_remap = true;\n-\t}\n-\n-      for (unsigned i = 0; i < tree_map->length (); i++)\n-\t{\n-\t  int parm_num = (*tree_map)[i]->parm_num;\n-\t  gcc_assert (parm_num >= 0);\n-\t  if (need_remap)\n-\t    parm_num = index_mapping[parm_num];\n-\t  kept[parm_num] = true;\n-\t}\n-    }\n-\n-  for (unsigned i = 0; i < op_len; i++)\n-    if (!kept[i] && is_gimple_reg (m_oparms[i]))\n-      m_reset_debug_decls.safe_push (m_oparms[i]);\n+  while (!ssas_to_process_debug.is_empty ())\n+    prepare_debug_expressions (ssas_to_process_debug.pop ());\n }\n \n /* Constructor of ipa_param_body_adjustments from a simple list of\n@@ -1224,9 +1376,9 @@ ::ipa_param_body_adjustments (vec<ipa_adjusted_param, va_gc> *adj_params,\n \t\t\t      tree fndecl)\n   : m_adj_params (adj_params), m_adjustments (NULL), m_reset_debug_decls (),\n     m_split_modifications_p (false), m_dead_stmts (), m_dead_ssas (),\n-    m_fndecl (fndecl), m_id (NULL), m_oparms (), m_new_decls (),\n-    m_new_types (), m_replacements (), m_removed_decls (), m_removed_map (),\n-    m_method2func (false)\n+    m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (), m_fndecl (fndecl),\n+    m_id (NULL), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n+    m_removed_decls (), m_removed_map (), m_method2func (false)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1241,7 +1393,8 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n \t\t\t      tree fndecl)\n   : m_adj_params (adjustments->m_adj_params), m_adjustments (adjustments),\n     m_reset_debug_decls (), m_split_modifications_p (false), m_dead_stmts (),\n-    m_dead_ssas (), m_fndecl (fndecl), m_id (NULL), m_oparms (), m_new_decls (),\n+    m_dead_ssas (), m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (),\n+    m_fndecl (fndecl), m_id (NULL), m_oparms (), m_new_decls (),\n     m_new_types (), m_replacements (), m_removed_decls (), m_removed_map (),\n     m_method2func (false)\n {\n@@ -1264,8 +1417,9 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n \t\t\t      vec<ipa_replace_map *, va_gc> *tree_map)\n   : m_adj_params (adjustments->m_adj_params), m_adjustments (adjustments),\n     m_reset_debug_decls (), m_split_modifications_p (false), m_dead_stmts (),\n-    m_dead_ssas (),m_fndecl (fndecl), m_id (id), m_oparms (), m_new_decls (),\n-    m_new_types (), m_replacements (), m_removed_decls (), m_removed_map (),\n+    m_dead_ssas (), m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (),\n+    m_fndecl (fndecl), m_id (id), m_oparms (), m_new_decls (), m_new_types (),\n+    m_replacements (), m_removed_decls (), m_removed_map (),\n     m_method2func (false)\n {\n   common_initialization (old_fndecl, vars, tree_map);"}, {"sha": "9440cbfc56ced02161432f973120bed5a2125966", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=1ece90ffa9ce63b416296bd662b8117d9b538913", "patch": "@@ -328,6 +328,9 @@ class ipa_param_body_adjustments\n \t\t\t   gimple *orig_stmt);\n   /* Return the new chain of parameters.  */\n   tree get_new_param_chain ();\n+  /* Replace all occurances of SSAs in m_dead_ssa_debug_equiv in t with what\n+     they are mapped to.  */\n+  void remap_with_debug_expressions (tree *t);\n \n   /* Pointers to data structures defining how the function should be\n      modified.  */\n@@ -348,6 +351,12 @@ class ipa_param_body_adjustments\n   hash_set<gimple *> m_dead_stmts;\n   hash_set<tree> m_dead_ssas;\n \n+  /* Mapping from DCEd SSAs to what their potential debug_binds should be.  */\n+  hash_map<tree, tree> m_dead_ssa_debug_equiv;\n+  /* Mapping from DCEd statements to debug expressions that will be placed on\n+     the RHS of debug statement that will replace this one.  */\n+  hash_map<gimple *, tree> m_dead_stmt_debug_equiv;\n+\n private:\n   void common_initialization (tree old_fndecl, tree *vars,\n \t\t\t      vec<ipa_replace_map *, va_gc> *tree_map);\n@@ -361,7 +370,8 @@ class ipa_param_body_adjustments\n   bool modify_call_stmt (gcall **stmt_p, gimple *orig_stmt);\n   bool modify_cfun_body ();\n   void reset_debug_stmts ();\n-  void mark_dead_statements (tree dead_param);\n+  void mark_dead_statements (tree dead_param, vec<tree> *debugstack);\n+  bool prepare_debug_expressions (tree dead_ssa);\n \n   /* Declaration of the function that is being transformed.  */\n "}, {"sha": "5434b3d7665acb1f883aeb7ef9788e179ad422e4", "filename": "gcc/testsuite/gcc.dg/guality/ipa-sra-1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fipa-sra-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fipa-sra-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fipa-sra-1.c?ref=1ece90ffa9ce63b416296bd662b8117d9b538913", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g -fno-ipa-icf\" } */\n+\n+\n+void __attribute__((noipa))\n+use (int x)\n+{\n+  asm volatile (\"\" : : \"r\" (x) : \"memory\");\n+}\n+\n+static int __attribute__((noinline))\n+bar (int i, int k)\n+{\n+  asm (\"\" : \"+r\" (i));\n+  use (i);\t\t/* { dg-final { gdb-test . \"k\" \"3\" { xfail *-*-* } } } */\n+  return 6;\n+}\n+\n+volatile int v;\n+\n+static int __attribute__((noinline))\n+foo (int i, int k)\n+{\n+  int r;\n+  v = 9;\n+  k = (k + 14)/k;\n+  r = bar (i, k);\t\t/* { dg-final { gdb-test . \"k\" \"3\" } } */\n+  return r;\n+}\n+\n+volatile int v;\n+\n+int __attribute__((noipa))\n+get_val1 (void)  {return 20;}\n+int __attribute__((noipa))\n+get_val2 (void)  {return 7;}\n+\n+int\n+main (void)\n+{\n+  int k = get_val2 ();\n+  int r = foo (get_val1 (), k);\n+  v = r + k;   /* k has to live accross the call or all is probably lost  */\n+  return 0;\n+}"}, {"sha": "d78e4392b6908530b8dd210f87f2e41ba4e2a583", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ece90ffa9ce63b416296bd662b8117d9b538913/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1ece90ffa9ce63b416296bd662b8117d9b538913", "patch": "@@ -1529,7 +1529,21 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n   if (!is_gimple_debug (stmt)\n       && id->param_body_adjs\n       && id->param_body_adjs->m_dead_stmts.contains (stmt))\n-    return NULL;\n+    {\n+      tree *dval = id->param_body_adjs->m_dead_stmt_debug_equiv.get (stmt);\n+      if (!dval)\n+\treturn NULL;\n+\n+      gcc_assert (is_gimple_assign (stmt));\n+      tree lhs = gimple_assign_lhs (stmt);\n+      tree *dvar = id->param_body_adjs->m_dead_ssa_debug_equiv.get (lhs);\n+      gdebug *bind = gimple_build_debug_bind (*dvar, *dval, stmt);\n+      if (id->reset_location)\n+\tgimple_set_location (bind, input_location);\n+      id->debug_stmts.safe_push (bind);\n+      gimple_seq_add_stmt (&stmts, bind);\n+      return stmts;\n+    }\n \n   /* Begin by recognizing trees that we'll completely rewrite for the\n      inlining context.  Our output for these trees is completely\n@@ -1807,15 +1821,13 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \n       if (gimple_debug_bind_p (stmt))\n \t{\n-\t  tree value;\n+\t  tree var = gimple_debug_bind_get_var (stmt);\n+\t  tree value = gimple_debug_bind_get_value (stmt);\n \t  if (id->param_body_adjs\n \t      && id->param_body_adjs->m_dead_stmts.contains (stmt))\n-\t    value = NULL_TREE;\n-\t  else\n-\t    value = gimple_debug_bind_get_value (stmt);\n-\t  gdebug *copy\n-\t    = gimple_build_debug_bind (gimple_debug_bind_get_var (stmt),\n-\t\t\t\t       value, stmt);\n+\t    id->param_body_adjs->remap_with_debug_expressions (&value);\n+\n+\t  gdebug *copy = gimple_build_debug_bind (var, value, stmt);\n \t  if (id->reset_location)\n \t    gimple_set_location (copy, input_location);\n \t  id->debug_stmts.safe_push (copy);\n@@ -6452,25 +6464,32 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t     in the debug info that var (whole DECL_ORIGIN is the parm\n \t     PARM_DECL) is optimized away, but could be looked up at the\n \t     call site as value of D#X there.  */\n-\t  tree vexpr;\n \t  gimple_stmt_iterator cgsi\n \t    = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \t  gimple *def_temp;\n \t  tree var = vars;\n \t  i = vec_safe_length (*debug_args);\n \t  do\n \t    {\n+\t      tree vexpr = NULL_TREE;\n \t      i -= 2;\n \t      while (var != NULL_TREE\n \t\t     && DECL_ABSTRACT_ORIGIN (var) != (**debug_args)[i])\n \t\tvar = TREE_CHAIN (var);\n \t      if (var == NULL_TREE)\n \t\tbreak;\n-\t      vexpr = make_node (DEBUG_EXPR_DECL);\n \t      tree parm = (**debug_args)[i];\n-\t      DECL_ARTIFICIAL (vexpr) = 1;\n-\t      TREE_TYPE (vexpr) = TREE_TYPE (parm);\n-\t      SET_DECL_MODE (vexpr, DECL_MODE (parm));\n+\t      if (tree parm_ddef = ssa_default_def (id.src_cfun, parm))\n+\t\tif (tree *d\n+\t\t    = param_body_adjs->m_dead_ssa_debug_equiv.get (parm_ddef))\n+\t\t  vexpr = *d;\n+\t      if (!vexpr)\n+\t\t{\n+\t\t  vexpr = make_node (DEBUG_EXPR_DECL);\n+\t\t  DECL_ARTIFICIAL (vexpr) = 1;\n+\t\t  TREE_TYPE (vexpr) = TREE_TYPE (parm);\n+\t\t  SET_DECL_MODE (vexpr, DECL_MODE (parm));\n+\t\t}\n \t      def_temp = gimple_build_debug_bind (var, vexpr, NULL);\n \t      gsi_insert_before (&cgsi, def_temp, GSI_NEW_STMT);\n \t      def_temp = gimple_build_debug_source_bind (vexpr, parm, NULL);"}]}