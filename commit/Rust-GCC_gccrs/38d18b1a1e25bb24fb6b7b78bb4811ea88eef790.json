{"sha": "38d18b1a1e25bb24fb6b7b78bb4811ea88eef790", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhkMThiMWExZTI1YmIyNGZiNmI3Yjc4YmI0ODExZWE4OGVlZjc5MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-08-12T09:23:43Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-08-12T09:23:43Z"}, "message": "re PR c++/21799 (Spurious ambiguity with pointers to members)\n\ncp:\n\tPR c++/21799\n\tPR c++/8271\n        * pt.c (unify) <METHOD_TYPE>: Check this-pointer cv-qualifiers\n\texplicitly.\n\n\tPR c++/21799\n\tRevert my 2005-07-08 patch\n\t* pt.c (type_unification_real): Remove is_method_argument and\n\tassoicated checks.\n\t(fn_type_unification, unify): Adjust type_unification_real calls.\n\nFrom-SVN: r103021", "tree": {"sha": "232c3b20f9f7a85b3ecd6d835294aefaee877502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/232c3b20f9f7a85b3ecd6d835294aefaee877502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790/comments", "author": null, "committer": null, "parents": [{"sha": "ec92bd4bd8dca3ce94c1cf2502b753c415210d01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec92bd4bd8dca3ce94c1cf2502b753c415210d01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec92bd4bd8dca3ce94c1cf2502b753c415210d01"}], "stats": {"total": 61, "additions": 32, "deletions": 29}, "files": [{"sha": "335d3132e4b647f84a75700a3178f172e8d8ab4c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=38d18b1a1e25bb24fb6b7b78bb4811ea88eef790", "patch": "@@ -1,3 +1,19 @@\n+2005-08-12  Giovanni Bajo  <giovannibajo@libero.it>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/21799\n+\tPR c++/8271\n+        * pt.c (unify) <METHOD_TYPE>: Check this-pointer cv-qualifiers\n+\texplicitly.\n+\t\n+2005-08-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/21799\n+\tRevert my 2005-07-08 patch\n+\t* pt.c (type_unification_real): Remove is_method_argument and\n+\tassoicated checks.\n+\t(fn_type_unification, unify): Adjust type_unification_real calls.\n+\n 2005-08-11  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/23266"}, {"sha": "a56dd047614251e3c193df03196c17774f6f856e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38d18b1a1e25bb24fb6b7b78bb4811ea88eef790/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=38d18b1a1e25bb24fb6b7b78bb4811ea88eef790", "patch": "@@ -109,7 +109,7 @@ static tree add_outermost_template_args (tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*);\n static int  type_unification_real (tree, tree, tree, tree,\n-\t\t\t\t   int, unification_kind_t, int);\n+\t\t\t\t   int, unification_kind_t);\n static void note_template_header (int);\n static tree convert_nontype_argument_function (tree, tree);\n static tree convert_nontype_argument (tree, tree);\n@@ -9197,7 +9197,7 @@ fn_type_unification (tree fn,\n      event.  */\n   result = type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n \t\t\t\t  targs, parms, args, /*subr=*/0,\n-\t\t\t\t  strict, 0);\n+\t\t\t\t  strict);\n \n   if (result == 0)\n     /* All is well so far.  Now, check:\n@@ -9305,18 +9305,15 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n \n    If SUBR is 1, we're being called recursively (to unify the\n    arguments of a function or method parameter of a function\n-   template).  If IS_METHOD is true, XPARMS are the parms of a\n-   member function, and special rules apply to cv qualification\n-   deduction on the this parameter.  */\n+   template). */\n \n static int\n type_unification_real (tree tparms,\n \t\t       tree targs,\n \t\t       tree xparms,\n \t\t       tree xargs,\n \t\t       int subr,\n-\t\t       unification_kind_t strict,\n-\t\t       int is_method)\n+\t\t       unification_kind_t strict)\n {\n   tree parm, arg;\n   int i;\n@@ -9368,26 +9365,6 @@ type_unification_real (tree tparms,\n \t   template args from other function args.  */\n \tcontinue;\n \n-      if (is_method)\n-\t{\n-\t  /* The cv qualifiers on the this pointer argument must match\n- \t     exactly.  We cannot deduce a T as const X against a const\n- \t     member function for instance.  */\n-\t  gcc_assert (TREE_CODE (parm) == POINTER_TYPE);\n-\t  gcc_assert (TREE_CODE (arg) == POINTER_TYPE);\n-\t  /* The restrict qualifier will be on the pointer.  */\n-\t  if (cp_type_quals (parm) != cp_type_quals (arg))\n-\t    return 1;\n-\t  parm = TREE_TYPE (parm);\n-\t  arg = TREE_TYPE (arg);\n-\t  if (cp_type_quals (parm) != cp_type_quals (arg))\n-\t    return 1;\n-\t  \n-\t  parm = TYPE_MAIN_VARIANT (parm);\n-\t  arg = TYPE_MAIN_VARIANT (arg);\n-\t  is_method = 0;\n-\t}\n-      \n       /* Conversions will be performed on a function argument that\n \t corresponds with a function parameter that contains only\n \t non-deducible template parameters and explicitly specified\n@@ -10288,12 +10265,22 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n \n+      /* CV qualifications for methods can never be deduced, they must\n+  \t match exactly.  We need to check them explicitly here,\n+  \t because type_unification_real treats them as any other\n+  \t cvqualified parameter.  */\n+      if (TREE_CODE (parm) == METHOD_TYPE\n+\t  && (!check_cv_quals_for_unify\n+\t      (UNIFY_ALLOW_NONE,\n+\t       TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (arg))),\n+\t       TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (parm))))))\n+\treturn 1;\n+\n       if (unify (tparms, targs, TREE_TYPE (parm),\n \t\t TREE_TYPE (arg), UNIFY_ALLOW_NONE))\n \treturn 1;\n       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n-\t\t\t\t    TYPE_ARG_TYPES (arg), 1, DEDUCE_EXACT,\n-\t\t\t\t    TREE_CODE (parm) == METHOD_TYPE);\n+\t\t\t\t    TYPE_ARG_TYPES (arg), 1, DEDUCE_EXACT);\n \n     case OFFSET_TYPE:\n       /* Unify a pointer to member with a pointer to member function, which"}]}