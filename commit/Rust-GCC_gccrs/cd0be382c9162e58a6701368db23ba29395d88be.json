{"sha": "cd0be382c9162e58a6701368db23ba29395d88be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwYmUzODJjOTE2MmU1OGE2NzAxMzY4ZGIyM2JhMjkzOTVkODhiZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-21T02:16:17Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-21T02:16:17Z"}, "message": "ChangeLog: Fix typos.\n\n\t* ChangeLog: Fix typos.\n\t* call.c: Fix comment typos.\n\t* class.c: Likewise.\n\t* cp-tree.h: Likewise.\n\t* cvt.c: Likewise.\n\t* cxx-pretty-print.c: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* init.c: Likewise.\n\t* mangle.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* parser.c: Likewise.\n\t* search.c: Likewise.\n\t* semantics.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise.\n\nFrom-SVN: r72737", "tree": {"sha": "0c02820a1869ab8cdb6e713dba2a47e4e3f4d194", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c02820a1869ab8cdb6e713dba2a47e4e3f4d194"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd0be382c9162e58a6701368db23ba29395d88be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0be382c9162e58a6701368db23ba29395d88be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0be382c9162e58a6701368db23ba29395d88be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0be382c9162e58a6701368db23ba29395d88be/comments", "author": null, "committer": null, "parents": [{"sha": "be03ccc9da81801953dca0e2a2061c9b8c753787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be03ccc9da81801953dca0e2a2061c9b8c753787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be03ccc9da81801953dca0e2a2061c9b8c753787"}], "stats": {"total": 91, "additions": 55, "deletions": 36}, "files": [{"sha": "076f539f971c71eab91bb0963b51f9a40f781c7e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -1,3 +1,22 @@\n+2003-10-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* ChangeLog: Fix typos.\n+\t* call.c: Fix comment typos.\n+\t* class.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\t* cxx-pretty-print.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* init.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\n 2003-10-20  Jan Hubicka  <jh@suse.cz>\n \n \t* decl.c (start_cleanup_fn):  Set DECL_DECLARED_INLINE_P to deffer\n@@ -1206,7 +1225,7 @@\n \t* typeck2.c (build_functional_cast): Do not perform name lookups.\n \n \tPR c++/10717\n-\t* decl.c (expand_static_init): Remove unncessary code.\n+\t* decl.c (expand_static_init): Remove unnecessary code.\n \n 2003-08-19  Andrew Pinski  <pinskia@physics.uc.edu>\n \n@@ -1694,7 +1713,7 @@\n \t(decay_conversion): Use convert_to_integer.\n \t(build_unary_op): Use build_nop.\n \t(get_delta_difference): Use convert_to_integer.\n-\t(build_ptrmemfunc): Avoid unncessary conversions.\n+\t(build_ptrmemfunc): Avoid unnecessary conversions.\n \n 2003-07-28  Jan Hubicka  <jh@suse.cz>\n \n@@ -4550,7 +4569,7 @@\n \t* decl2.c (is_namespace_ancestor): Rename to ...\n \t(namespace_anecestor): ... this.\n \t(set_decl_namespace): Adjust accordingly.\n-\t(handle_class_head): Remove unncessary parameters.\n+\t(handle_class_head): Remove unnecessary parameters.\n \t* parser.c (cp_parser_class_head): Check that\n \tnested-name-specifiers are used appropriately.\n \n@@ -8569,7 +8588,7 @@\n \t(instantiate_class_template): Adjust call to xref_basetypes.\n \t* semantics.c (begin_mem_initializers): New function.\n \t* tree.c (is_overloaded_fn): Use BASELINK_FUNCTIONS.\n-\t(really_overlaoded_fn): Likewise.\n+\t(really_overloaded_fn): Likewise.\n \t(get_overloaded_fn): New function.'\n \t(get_first_fn): USe BASELINK_FUNCTIONS.\n "}, {"sha": "508f760ad2ae4a61ad77f0e804e0feef75e7f89f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -3805,7 +3805,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n        the lookup selects a placement deallocation function, the\n        program is ill-formed.\n   \n-       Therefore, we ask lookup_fnfields to complain ambout ambiguity.  */\n+       Therefore, we ask lookup_fnfields to complain about ambiguity.  */\n     {\n       fns = lookup_fnfields (TYPE_BINFO (type), fnname, 1);\n       if (fns == error_mark_node)\n@@ -5262,7 +5262,7 @@ compare_ics (tree ics1, tree ics2)\n     {\n       /* XXX Isn't this an extension? */\n       /* Both ICS are bad.  We try to make a decision based on what\n-\t would have happenned if they'd been good.  */\n+\t would have happened if they'd been good.  */\n       if (ICS_USER_FLAG (ics1) > ICS_USER_FLAG (ics2)\n \t  || ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n \treturn -1;"}, {"sha": "d8b0e29e632c54f496a77697a812f74657924725", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -1939,7 +1939,7 @@ typedef struct find_final_overrider_data_s {\n   tree most_derived_type;\n   /* The candidate overriders.  */\n   tree candidates;\n-  /* Binfos which inherited virtually on the currrent path.  */\n+  /* Binfos which inherited virtually on the current path.  */\n   tree vpath;\n } find_final_overrider_data;\n \n@@ -2167,7 +2167,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       if (!virtual_offset)\n \t{\n \t  /* There was no existing virtual thunk (which takes\n-\t     precidence).  */\n+\t     precedence).  */\n \t  tree thunk_binfo;\n \t  base_kind kind;\n \t  "}, {"sha": "2812a90dff39d1042fc5ad5de413755f86e2561c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -362,7 +362,7 @@ typedef enum cp_id_kind\n   CP_ID_KIND_NONE,\n   /* An unqualified-id that is not a template-id.  */\n   CP_ID_KIND_UNQUALIFIED,\n-  /* An uqualified-id that is a dependent name.  */\n+  /* An unqualified-id that is a dependent name.  */\n   CP_ID_KIND_UNQUALIFIED_DEPENDENT,\n   /* An unqualified template-id.  */\n   CP_ID_KIND_TEMPLATE_ID,\n@@ -1474,7 +1474,7 @@ struct lang_type GTY(())\n #define BINFO_PUSHDECLS_MARKED(NODE) BINFO_VTABLE_PATH_MARKED (NODE)\n \n /* Nonzero if this BINFO is a primary base class.  Note, this can be\n-   set for non-canononical virtual bases. For a virtual primary base\n+   set for non-canonical virtual bases. For a virtual primary base\n    you might also need to check whether it is canonical.  */\n \n #define BINFO_PRIMARY_P(NODE) \\"}, {"sha": "cf69b95a333f00d0db580ebcdd6a6f9fef32d29e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -770,7 +770,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n    no lvalue-rvalue and similar conversions happen [expr.static.cast/4,\n    stmt.expr/1, expr.comma/1].  This permits dereferencing an incomplete type\n    in a void context. The C++ standard does not define what an `access' to an\n-   object is, but there is reason to beleive that it is the lvalue to rvalue\n+   object is, but there is reason to believe that it is the lvalue to rvalue\n    conversion -- if it were not, `*&*p = 1' would violate [expr]/4 in that it\n    accesses `*p' not to calculate the value to be stored. But, dcl.type.cv/8\n    indicates that volatile semantics should be the same between C and C++"}, {"sha": "e368e9a33f409746585a07e35be14d62af0edbae", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -261,7 +261,7 @@ pp_cxx_qualified_id (cxx_pretty_printer *pp, tree t)\n }\n \n /* id-expression:\n-      unaqualified-id\n+      unqualified-id\n       qualified-id   */\n static inline void\n pp_cxx_id_expression (cxx_pretty_printer *pp, tree t)\n@@ -986,7 +986,7 @@ pp_cxx_simple_type_specifier (cxx_pretty_printer *pp, tree t)\n       class-specifier\n       enum-specifier\n       elaborated-type-specifier\n-      cv-qualifer   */\n+      cv-qualifier   */\n \n static void\n pp_cxx_type_specifier_seq (cxx_pretty_printer *pp, tree t)\n@@ -1287,7 +1287,7 @@ pp_cxx_abstract_declarator (cxx_pretty_printer *pp, tree t)\n \n /* direct-abstract-declarator:\n       direct-abstract-declarator(opt) ( parameter-declaration-clause )\n-                           cv-quafilier-seq(opt) exception-specification(opt)\n+                           cv-qualifier-seq(opt) exception-specification(opt)\n       direct-abstract-declarator(opt) [ constant-expression(opt) ]\n       ( abstract-declarator )  */\n static void"}, {"sha": "32fe3982fc8acfae0d168182269f61894ddcf0d0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -3877,7 +3877,7 @@ start_decl_1 (tree decl)\n /* Handle initialization of references.  DECL, TYPE, and INIT have the\n    same meaning as in cp_finish_decl.  *CLEANUP must be NULL on entry,\n    but will be set to a new CLEANUP_STMT if a temporary is created\n-   that must be destroeyd subsequently.\n+   that must be destroyed subsequently.\n \n    Returns an initializer expression to use to initialize DECL, or\n    NULL if the initialization can be performed statically."}, {"sha": "7be1c1402c904f415ffef9843d6e0f334ade8ce2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -2084,7 +2084,7 @@ start_static_storage_duration_function (unsigned count)\n   /* Put the function in the global scope.  */\n   pushdecl (ssdf_decl);\n \n-  /* Start the function itself.  This is equivalent to declarating the\n+  /* Start the function itself.  This is equivalent to declaring the\n      function as:\n \n        static void __ssdf (int __initialize_p, init __priority_p);"}, {"sha": "68406965496736d167098ca276b9a5494db37afb", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -292,7 +292,7 @@ build_default_init (tree type, tree nelts)\n     return NULL_TREE;\n       \n   /* At this point, TYPE is either a POD class type, an array of POD\n-     classes, or something even more inoccuous.  */\n+     classes, or something even more innocuous.  */\n   return build_zero_init (type, nelts, /*static_storage_p=*/false);\n }\n "}, {"sha": "c8b3a84dddedb3e648ff1bb1c0c6ba5e0d0dee59", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -1028,7 +1028,7 @@ write_conversion_operator_name (const tree type)\n   write_type (type);\n }\n \n-/* Non-termial <source-name>.  IDENTIFIER is an IDENTIFIER_NODE.  \n+/* Non-terminal <source-name>.  IDENTIFIER is an IDENTIFIER_NODE.  \n \n      <source-name> ::= </length/ number> <identifier>  */\n \n@@ -1329,7 +1329,7 @@ discriminator_for_local_entity (tree entity)\n }\n \n /* Return the discriminator for STRING, a string literal used inside\n-   FUNCTION.  The disciminator is the lexical ordinal of STRING among\n+   FUNCTION.  The discriminator is the lexical ordinal of STRING among\n    string literals used in FUNCTION.  */\n \n static int"}, {"sha": "add0d55d40531e058b2f52bfcaa8a7d1bf94d219", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -1195,7 +1195,7 @@ cxx_scope_descriptor (cxx_scope *scope)\n   return scope_kind_names[kind];\n }\n \n-/* Output a debugging information about SCOPE when performning\n+/* Output a debugging information about SCOPE when performing\n    ACTION at LINE.  */\n static void\n cxx_scope_debug (cxx_scope *scope, int line, const char *action)\n@@ -1334,7 +1334,7 @@ leave_scope (void)\n \n   /* Namespace-scopes are left most probably temporarily, not completely;\n      they can be reopen later, e.g. in namespace-extension or any name\n-     binding acttivity that requires us to resume a namespace.  For other\n+     binding activity that requires us to resume a namespace.  For other\n      scopes, we just make the structure available for reuse.  */\n   if (scope->kind != sk_namespace)\n     {\n@@ -1814,7 +1814,7 @@ clear_anon_tags (void)\n   last_cnt = anon_cnt;\n }\n \f\n-/* Return (from the stack of) the BINDING, if any, establihsed at SCOPE.  */ \n+/* Return (from the stack of) the BINDING, if any, established at SCOPE.  */ \n \n static inline cxx_binding *\n find_binding (cxx_scope *scope, cxx_binding *binding)\n@@ -3694,7 +3694,7 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n   return error_mark_node;\n }\n \n-/* Subroutine of unualified_namespace_lookup:\n+/* Subroutine of unqualified_namespace_lookup:\n    Add the bindings of NAME in used namespaces to VAL.\n    We are currently looking for names in namespace SCOPE, so we\n    look through USINGS for using-directives of namespaces"}, {"sha": "b6416e81834d5d3de679c2a57cb5a07a066e5a32", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -1200,7 +1200,7 @@ typedef struct cp_parser GTY(())\n \n   /* TRUE if default arguments are allowed within a parameter list\n      that starts at this point. FALSE if only a gnu extension makes\n-     them permissable.  */\n+     them permissible.  */\n   bool default_arg_ok_p;\n   \n   /* TRUE if we are parsing an integral constant-expression.  See\n@@ -1790,7 +1790,7 @@ cp_parser_check_for_definition_in_return_type (tree declarator,\n     error (\"new types may not be defined in a return type\");\n }\n \n-/* Issue an eror message about the fact that THING appeared in a\n+/* Issue an error message about the fact that THING appeared in a\n    constant-expression.  Returns ERROR_MARK_NODE.  */\n \n static tree\n@@ -2502,7 +2502,7 @@ cp_parser_primary_expression (cp_parser *parser,\n    named is a template.  \n \n    If DECLARATOR_P is true, the id-expression is appearing as part of\n-   a declarator, rather than as part of an exprsesion.  */\n+   a declarator, rather than as part of an expression.  */\n \n static tree\n cp_parser_id_expression (cp_parser *parser,\n@@ -12088,7 +12088,7 @@ cp_parser_member_declaration (cp_parser* parser)\n      = 0\n \n    Returns INTEGER_ZERO_NODE if a pure specifier is found.\n-   Otherwiser, ERROR_MARK_NODE is returned.  */\n+   Otherwise, ERROR_MARK_NODE is returned.  */\n \n static tree\n cp_parser_pure_specifier (cp_parser* parser)\n@@ -12829,7 +12829,7 @@ cp_parser_attribute_list (cp_parser* parser)\n       if (token->type != CPP_COMMA)\n \tbreak;\n \n-      /* Consume the commma and keep going.  */\n+      /* Consume the comma and keep going.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n@@ -13885,7 +13885,7 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n     = TREE_CHAIN (parser->unparsed_functions_queues);\n }\n \n-/* If DECL contains any default args, remeber it on the unparsed\n+/* If DECL contains any default args, remember it on the unparsed\n    functions queue.  */\n \n static void\n@@ -14277,7 +14277,7 @@ cp_parser_check_class_key (enum tag_types class_key, tree type)\n \t     type);\n }\n \t\t\t   \n-/* Issue an error message if DECL is redeclared with differnt\n+/* Issue an error message if DECL is redeclared with different\n    access than its original declaration [class.access.spec/3].\n    This applies to nested classes and nested class templates.\n    [class.mem/1].  */"}, {"sha": "dc8ef9046ecf61f7426808a0fb24f4f814b65538", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -602,7 +602,7 @@ context_for_name_lookup (tree decl)\n }\n \n /* The accessibility routines use BINFO_ACCESS for scratch space\n-   during the computation of the accssibility of some declaration.  */\n+   during the computation of the accessibility of some declaration.  */\n \n #define BINFO_ACCESS(NODE) \\\n   ((access_kind) ((TREE_PUBLIC (NODE) << 1) | TREE_PRIVATE (NODE)))"}, {"sha": "dc8635ba309fd8799dbb9d095d7b5fd096ff5717", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -1439,7 +1439,7 @@ finish_stmt_expr_expr (tree expr)\n \n \t  /* Build a TARGET_EXPR for this aggregate.  finish_stmt_expr\n \t     will then pull it apart so the lifetime of the target is\n-\t     within the scope of the expresson containing this statement\n+\t     within the scope of the expression containing this statement\n \t     expression.  */\n \t  if (TREE_CODE (expr) == TARGET_EXPR)\n \t    ;\n@@ -2240,7 +2240,7 @@ finish_base_specifier (tree base, tree access, bool virtual_p)\n }\n \n /* Called when multiple declarators are processed.  If that is not\n-   premitted in this context, an error is issued.  */\n+   permitted in this context, an error is issued.  */\n \n void\n check_multiple_declarators (void)\n@@ -2452,7 +2452,7 @@ finish_id_expression (tree id_expression,\n \t    }\n \n \t  /* If there are no dependent template arguments, go through\n-\t     the overlaoded functions.  */\n+\t     the overloaded functions.  */\n \t  while (fns && !dependent_p)\n \t    {\n \t      tree fn = OVL_CURRENT (fns);"}, {"sha": "b9d37f53a8537638f17aefd5c20b5bd6144fc88f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -99,7 +99,7 @@ lvalue_p_1 (tree ref,\n \t  /* Clear the ordinary bit.  If this object was a class\n \t     rvalue we want to preserve that information.  */\n \t  op1_lvalue_kind &= ~clk_ordinary;\n-\t  /* The lvalue is for a btifield.  */\n+\t  /* The lvalue is for a bitfield.  */\n \t  op1_lvalue_kind |= clk_bitfield;\n \t}\n       else if (DECL_PACKED (TREE_OPERAND (ref, 1)))"}, {"sha": "f21115120661c9cdd65fa2f72017571909fcfd77", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be382c9162e58a6701368db23ba29395d88be/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cd0be382c9162e58a6701368db23ba29395d88be", "patch": "@@ -4361,7 +4361,7 @@ build_compound_expr (tree lhs, tree rhs)\n     {\n       /* If the rhs is a TARGET_EXPR, then build the compound\n          expression inside the target_expr's initializer. This\n-\t helps the compiler to eliminate unncessary temporaries.  */\n+\t helps the compiler to eliminate unnecessary temporaries.  */\n       tree init = TREE_OPERAND (rhs, 1);\n       \n       init = build (COMPOUND_EXPR, TREE_TYPE (init), lhs, init);"}]}