{"sha": "61332f77748bd6ea8cb59c15f08a48466940ac95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzMzJmNzc3NDhiZDZlYThjYjU5YzE1ZjA4YTQ4NDY2OTQwYWM5NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-12T14:04:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-12T14:04:29Z"}, "message": "gimple.c (gtc_visit): Compare TREE_ADDRESSABLE, handle NULLPTR_TYPE similar to VOID_TYPE.\n\n2011-05-12  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (gtc_visit): Compare TREE_ADDRESSABLE, handle\n\tNULLPTR_TYPE similar to VOID_TYPE.  Defer type-leader lookup\n\tuntil after simple checks.\n\t(gimple_types_compatible_p): Likewise.\n\t(iterative_hash_gimple_type): Always hash pointer targets\n\tand function return and argument types.\n\t(iterative_hash_canonical_type): Do not hash TYPE_QUALS,\n\thash TYPE_ALIGN.  Do not hash TYPE_MIN/MAX_VALUE.\n\t(gimple_canonical_types_compatible_p): Compare TREE_ADDRESSABLE,\n\thandle NULLPTR_TYPE similar to VOID_TYPE.  Handle non-aggregates\n\tcompletely in the simple compare section.\n\t(gimple_register_canonical_type): Query the cache again after\n\tregistering.\n\nFrom-SVN: r173704", "tree": {"sha": "d89587a55faefe1666ed384e83326f44e2600826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d89587a55faefe1666ed384e83326f44e2600826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61332f77748bd6ea8cb59c15f08a48466940ac95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61332f77748bd6ea8cb59c15f08a48466940ac95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61332f77748bd6ea8cb59c15f08a48466940ac95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61332f77748bd6ea8cb59c15f08a48466940ac95/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2a3a5f1add296430b85b6b6be24b7340a7bcc9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a3a5f1add296430b85b6b6be24b7340a7bcc9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a3a5f1add296430b85b6b6be24b7340a7bcc9e"}], "stats": {"total": 365, "additions": 128, "deletions": 237}, "files": [{"sha": "bb84bfd2b4170ab28583a591844fb157ec4f83b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61332f77748bd6ea8cb59c15f08a48466940ac95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61332f77748bd6ea8cb59c15f08a48466940ac95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61332f77748bd6ea8cb59c15f08a48466940ac95", "patch": "@@ -1,3 +1,19 @@\n+2011-05-12  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (gtc_visit): Compare TREE_ADDRESSABLE, handle\n+\tNULLPTR_TYPE similar to VOID_TYPE.  Defer type-leader lookup\n+\tuntil after simple checks.\n+\t(gimple_types_compatible_p): Likewise.\n+\t(iterative_hash_gimple_type): Always hash pointer targets\n+\tand function return and argument types.\n+\t(iterative_hash_canonical_type): Do not hash TYPE_QUALS,\n+\thash TYPE_ALIGN.  Do not hash TYPE_MIN/MAX_VALUE.\n+\t(gimple_canonical_types_compatible_p): Compare TREE_ADDRESSABLE,\n+\thandle NULLPTR_TYPE similar to VOID_TYPE.  Handle non-aggregates\n+\tcompletely in the simple compare section.\n+\t(gimple_register_canonical_type): Query the cache again after\n+\tregistering.\n+\n 2011-05-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/48172"}, {"sha": "c9ac991d3d039b3d5a213637f466b4e1d36c6072", "filename": "gcc/gimple.c", "status": "modified", "additions": 112, "deletions": 237, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61332f77748bd6ea8cb59c15f08a48466940ac95/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61332f77748bd6ea8cb59c15f08a48466940ac95/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=61332f77748bd6ea8cb59c15f08a48466940ac95", "patch": "@@ -3489,15 +3489,6 @@ gtc_visit (tree t1, tree t2,\n   if (t1 == NULL_TREE || t2 == NULL_TREE)\n     return false;\n \n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  leader1 = gimple_lookup_type_leader (t1);\n-  leader2 = gimple_lookup_type_leader (t2);\n-  if (leader1 == t2\n-      || t1 == leader2\n-      || (leader1 && leader1 == leader2))\n-    return true;\n-\n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return false;\n@@ -3506,23 +3497,30 @@ gtc_visit (tree t1, tree t2,\n   if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n     return false;\n \n-  /* Void types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE)\n+  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n+    return false;\n+\n+  /* Void types and nullptr types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE\n+      || TREE_CODE (t1) == NULLPTR_TYPE)\n     return true;\n \n+  /* Can't be the same type if they have different alignment or mode.  */\n+  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+      || TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return false;\n+\n   /* Do some simple checks before doing three hashtable queries.  */\n   if (INTEGRAL_TYPE_P (t1)\n       || SCALAR_FLOAT_TYPE_P (t1)\n       || FIXED_POINT_TYPE_P (t1)\n       || TREE_CODE (t1) == VECTOR_TYPE\n       || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE)\n+      || TREE_CODE (t1) == OFFSET_TYPE\n+      || POINTER_TYPE_P (t1))\n     {\n-      /* Can't be the same type if they have different alignment,\n-\t sign, precision or mode.  */\n-      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n+      /* Can't be the same type if they have different sign or precision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n \t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n \treturn false;\n \n@@ -3536,16 +3534,17 @@ gtc_visit (tree t1, tree t2,\n \t  || FIXED_POINT_TYPE_P (t1))\n \treturn true;\n \n-      /* For integral types fall thru to more complex checks.  */\n+      /* For other types fall thru to more complex checks.  */\n     }\n \n-  else if (AGGREGATE_TYPE_P (t1) || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different alignment or mode.  */\n-      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-\t  || TYPE_MODE (t1) != TYPE_MODE (t2))\n-\treturn false;\n-    }\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  leader1 = gimple_lookup_type_leader (t1);\n+  leader2 = gimple_lookup_type_leader (t2);\n+  if (leader1 == t2\n+      || t1 == leader2\n+      || (leader1 && leader1 == leader2))\n+    return true;\n \n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n@@ -3739,10 +3738,6 @@ gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n \tgoto different_types;\n       }\n \n-    case NULLPTR_TYPE:\n-      /* There is only one decltype(nullptr).  */\n-      goto same_types;\n-\n     case INTEGER_TYPE:\n     case BOOLEAN_TYPE:\n       {\n@@ -3906,15 +3901,6 @@ gimple_types_compatible_p (tree t1, tree t2)\n   if (t1 == NULL_TREE || t2 == NULL_TREE)\n     return false;\n \n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  leader1 = gimple_lookup_type_leader (t1);\n-  leader2 = gimple_lookup_type_leader (t2);\n-  if (leader1 == t2\n-      || t1 == leader2\n-      || (leader1 && leader1 == leader2))\n-    return true;\n-\n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return false;\n@@ -3923,23 +3909,30 @@ gimple_types_compatible_p (tree t1, tree t2)\n   if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n     return false;\n \n-  /* Void types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE)\n+  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n+    return false;\n+\n+  /* Void types and nullptr types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE\n+      || TREE_CODE (t1) == NULLPTR_TYPE)\n     return true;\n \n+  /* Can't be the same type if they have different alignment or mode.  */\n+  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+      || TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return false;\n+\n   /* Do some simple checks before doing three hashtable queries.  */\n   if (INTEGRAL_TYPE_P (t1)\n       || SCALAR_FLOAT_TYPE_P (t1)\n       || FIXED_POINT_TYPE_P (t1)\n       || TREE_CODE (t1) == VECTOR_TYPE\n       || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE)\n+      || TREE_CODE (t1) == OFFSET_TYPE\n+      || POINTER_TYPE_P (t1))\n     {\n-      /* Can't be the same type if they have different alignment,\n-\t sign, precision or mode.  */\n-      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n+      /* Can't be the same type if they have different sign or precision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n \t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n \treturn false;\n \n@@ -3953,16 +3946,17 @@ gimple_types_compatible_p (tree t1, tree t2)\n \t  || FIXED_POINT_TYPE_P (t1))\n \treturn true;\n \n-      /* For integral types fall thru to more complex checks.  */\n+      /* For other types fall thru to more complex checks.  */\n     }\n \n-  else if (AGGREGATE_TYPE_P (t1) || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different alignment or mode.  */\n-      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-\t  || TYPE_MODE (t1) != TYPE_MODE (t2))\n-\treturn false;\n-    }\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  leader1 = gimple_lookup_type_leader (t1);\n+  leader2 = gimple_lookup_type_leader (t2);\n+  if (leader1 == t2\n+      || t1 == leader2\n+      || (leader1 && leader1 == leader2))\n+    return true;\n \n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n@@ -4116,20 +4110,10 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n     }\n \n   /* For pointer and reference types, fold in information about the type\n-     pointed to but do not recurse into possibly incomplete types to\n-     avoid hash differences for complete vs. incomplete types.  */\n+     pointed to.  */\n   if (POINTER_TYPE_P (type))\n-    {\n-      if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n-\t{\n-\t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n-\t  v = iterative_hash_name\n-\t\t(TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n-\t}\n-      else\n-\tv = visit (TREE_TYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack);\n-    }\n+    v = visit (TREE_TYPE (type), state, v,\n+\t       sccstack, sccstate, sccstate_obstack);\n \n   /* For integer types hash the types min/max values and the string flag.  */\n   if (TREE_CODE (type) == INTEGER_TYPE)\n@@ -4170,29 +4154,13 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n \t\t   sccstack, sccstate, sccstate_obstack);\n \n-      /* For result types allow mismatch in completeness.  */\n-      if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n-\t{\n-\t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n-\t  v = iterative_hash_name\n-\t\t(TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n-\t}\n-      else\n-\tv = visit (TREE_TYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack);\n-\n+      /* Check result and argument types.  */\n+      v = visit (TREE_TYPE (type), state, v,\n+\t\t sccstack, sccstate, sccstate_obstack);\n       for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n \t{\n-\t  /* For argument types allow mismatch in completeness.  */\n-\t  if (RECORD_OR_UNION_TYPE_P (TREE_VALUE (p)))\n-\t    {\n-\t      v = iterative_hash_hashval_t (TREE_CODE (TREE_VALUE (p)), v);\n-\t      v = iterative_hash_name\n-\t\t    (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_VALUE (p))), v);\n-\t    }\n-\t  else\n-\t    v = visit (TREE_VALUE (p), state, v,\n-\t\t       sccstack, sccstate, sccstate_obstack);\n+\t  v = visit (TREE_VALUE (p), state, v,\n+\t\t     sccstack, sccstate, sccstate_obstack);\n \t  na++;\n \t}\n \n@@ -4311,19 +4279,20 @@ iterative_hash_canonical_type (tree type, hashval_t val)\n      only existing types having the same features as the new type will be\n      checked.  */\n   v = iterative_hash_hashval_t (TREE_CODE (type), 0);\n-  v = iterative_hash_hashval_t (TYPE_QUALS (type), v);\n   v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n-\n-  /* Do not hash the types size as this will cause differences in\n-     hash values for the complete vs. the incomplete type variant.  */\n+  v = iterative_hash_hashval_t (TYPE_ALIGN (type), v);\n+  v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n \n   /* Incorporate common features of numerical types.  */\n   if (INTEGRAL_TYPE_P (type)\n       || SCALAR_FLOAT_TYPE_P (type)\n-      || FIXED_POINT_TYPE_P (type))\n+      || FIXED_POINT_TYPE_P (type)\n+      || TREE_CODE (type) == VECTOR_TYPE\n+      || TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == OFFSET_TYPE\n+      || POINTER_TYPE_P (type))\n     {\n       v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n-      v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n       v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n     }\n \n@@ -4332,19 +4301,16 @@ iterative_hash_canonical_type (tree type, hashval_t val)\n   if (POINTER_TYPE_P (type))\n     {\n       v = iterative_hash_hashval_t (TYPE_REF_CAN_ALIAS_ALL (type), v);\n+      v = iterative_hash_hashval_t (TYPE_ADDR_SPACE (TREE_TYPE (type)), v);\n+      v = iterative_hash_hashval_t (TYPE_RESTRICT (type), v);\n       v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n     }\n \n   /* For integer types hash the types min/max values and the string flag.  */\n   if (TREE_CODE (type) == INTEGER_TYPE)\n     {\n-      /* OMP lowering can introduce error_mark_node in place of\n-\t random local decls in types.  */\n-      if (TYPE_MIN_VALUE (type) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MIN_VALUE (type), v);\n-      if (TYPE_MAX_VALUE (type) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MAX_VALUE (type), v);\n       v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+      v = iterative_hash_hashval_t (TYPE_IS_SIZETYPE (type), v);\n     }\n \n   /* For array types hash their domain and the string flag.  */\n@@ -4599,27 +4565,32 @@ gimple_canonical_types_compatible_p (tree t1, tree t2)\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return false;\n \n-  /* Can't be the same type if they have different CV qualifiers.  */\n-  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n     return false;\n \n-  /* Void types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE)\n+  /* Qualifiers do not matter for canonical type comparison purposes.  */\n+\n+  /* Void types and nullptr types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE\n+      || TREE_CODE (t1) == NULLPTR_TYPE)\n     return true;\n \n-  /* Do some simple checks before doing three hashtable queries.  */\n+  /* Can't be the same type if they have different alignment, or mode.  */\n+  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+      || TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return false;\n+\n+  /* Non-aggregate types can be handled cheaply.  */\n   if (INTEGRAL_TYPE_P (t1)\n       || SCALAR_FLOAT_TYPE_P (t1)\n       || FIXED_POINT_TYPE_P (t1)\n       || TREE_CODE (t1) == VECTOR_TYPE\n       || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE)\n+      || TREE_CODE (t1) == OFFSET_TYPE\n+      || POINTER_TYPE_P (t1))\n     {\n-      /* Can't be the same type if they have different alignment,\n-\t sign, precision or mode.  */\n-      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n+      /* Can't be the same type if they have different sign or precision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n \t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n \treturn false;\n \n@@ -4628,20 +4599,35 @@ gimple_canonical_types_compatible_p (tree t1, tree t2)\n \t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n \treturn false;\n \n-      /* That's all we need to check for float and fixed-point types.  */\n-      if (SCALAR_FLOAT_TYPE_P (t1)\n-\t  || FIXED_POINT_TYPE_P (t1))\n-\treturn true;\n+      /* For canonical type comparisons we do not want to build SCCs\n+\t so we cannot compare pointed-to types.  But we can, for now,\n+\t require the same pointed-to type kind and match what\n+\t useless_type_conversion_p would do.  */\n+      if (POINTER_TYPE_P (t1))\n+\t{\n+\t  /* If the two pointers have different ref-all attributes,\n+\t     they can't be the same type.  */\n+\t  if (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n+\t    return false;\n \n-      /* For integral types fall thru to more complex checks.  */\n-    }\n+\t  if (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n+\t      != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n+\t    return false;\n \n-  else if (AGGREGATE_TYPE_P (t1) || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different alignment or mode.  */\n-      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-\t  || TYPE_MODE (t1) != TYPE_MODE (t2))\n-\treturn false;\n+\t  if (TYPE_RESTRICT (t1) != TYPE_RESTRICT (t2))\n+\t    return false;\n+\n+\t  if (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n+\t    return false;\n+\t}\n+\n+      /* Tail-recurse to components.  */\n+      if (TREE_CODE (t1) == VECTOR_TYPE\n+\t  || TREE_CODE (t1) == COMPLEX_TYPE)\n+\treturn gimple_canonical_types_compatible_p (TREE_TYPE (t1),\n+\t\t\t\t\t\t    TREE_TYPE (t2));\n+\n+      return true;\n     }\n \n   /* If the hash values of t1 and t2 are different the types can't\n@@ -4669,12 +4655,6 @@ gimple_canonical_types_compatible_p (tree t1, tree t2)\n   /* Do type-specific comparisons.  */\n   switch (TREE_CODE (t1))\n     {\n-    case VECTOR_TYPE:\n-    case COMPLEX_TYPE:\n-      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\tgoto different_types;\n-      goto same_types;\n-\n     case ARRAY_TYPE:\n       /* Array types are the same if the element types are the same and\n \t the number of elements are the same.  */\n@@ -4767,114 +4747,6 @@ gimple_canonical_types_compatible_p (tree t1, tree t2)\n \t  goto same_types;\n \t}\n \n-    case OFFSET_TYPE:\n-      {\n-\tif (!gimple_canonical_types_compatible_p\n-\t       (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t    || !gimple_canonical_types_compatible_p\n-\t          (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2)))\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-      {\n-\t/* If the two pointers have different ref-all attributes,\n-\t   they can't be the same type.  */\n-\tif (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n-\t  goto different_types;\n-\n-\tif (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n-\t    != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n-\t  goto different_types;\n-\n-\tif (TYPE_RESTRICT (t1) != TYPE_RESTRICT (t2))\n-\t  goto different_types;\n-\n-\t/* For canonical type comparisons we do not want to build SCCs\n-\t   so we cannot compare pointed-to types.  But we can, for now,\n-\t   require the same pointed-to type kind.  */\n-\tif (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case NULLPTR_TYPE:\n-      /* There is only one decltype(nullptr).  */\n-      goto same_types;\n-\n-    case INTEGER_TYPE:\n-    case BOOLEAN_TYPE:\n-      {\n-\ttree min1 = TYPE_MIN_VALUE (t1);\n-\ttree max1 = TYPE_MAX_VALUE (t1);\n-\ttree min2 = TYPE_MIN_VALUE (t2);\n-\ttree max2 = TYPE_MAX_VALUE (t2);\n-\tbool min_equal_p = false;\n-\tbool max_equal_p = false;\n-\n-\t/* If either type has a minimum value, the other type must\n-\t   have the same.  */\n-\tif (min1 == NULL_TREE && min2 == NULL_TREE)\n-\t  min_equal_p = true;\n-\telse if (min1 && min2 && operand_equal_p (min1, min2, 0))\n-\t  min_equal_p = true;\n-\n-\t/* Likewise, if either type has a maximum value, the other\n-\t   type must have the same.  */\n-\tif (max1 == NULL_TREE && max2 == NULL_TREE)\n-\t  max_equal_p = true;\n-\telse if (max1 && max2 && operand_equal_p (max1, max2, 0))\n-\t  max_equal_p = true;\n-\n-\tif (!min_equal_p || !max_equal_p)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case ENUMERAL_TYPE:\n-      {\n-\t/* FIXME lto, we cannot check bounds on enumeral types because\n-\t   different front ends will produce different values.\n-\t   In C, enumeral types are integers, while in C++ each element\n-\t   will have its own symbolic value.  We should decide how enums\n-\t   are to be represented in GIMPLE and have each front end lower\n-\t   to that.  */\n-\ttree v1, v2;\n-\n-\t/* For enumeral types, all the values must be the same.  */\n-\tif (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n-\t  goto same_types;\n-\n-\tfor (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n-\t     v1 && v2;\n-\t     v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n-\t  {\n-\t    tree c1 = TREE_VALUE (v1);\n-\t    tree c2 = TREE_VALUE (v2);\n-\n-\t    if (TREE_CODE (c1) == CONST_DECL)\n-\t      c1 = DECL_INITIAL (c1);\n-\n-\t    if (TREE_CODE (c2) == CONST_DECL)\n-\t      c2 = DECL_INITIAL (c2);\n-\n-\t    if (tree_int_cst_equal (c1, c2) != 1)\n-\t      goto different_types;\n-\t  }\n-\n-\t/* If one enumeration has more values than the other, they\n-\t   are not the same.  */\n-\tif (v1 || v2)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n@@ -4949,6 +4821,9 @@ gimple_register_canonical_type (tree t)\n      to be the canonical type it will be the one we merge to as well.  */\n   t = gimple_register_type (t);\n \n+  if (TYPE_CANONICAL (t))\n+    return TYPE_CANONICAL (t);\n+\n   /* Always register the main variant first.  This is important so we\n      pick up the non-typedef variants as canonical, otherwise we'll end\n      up taking typedef ids for structure tags during comparison.  */"}]}