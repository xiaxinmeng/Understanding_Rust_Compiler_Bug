{"sha": "ba95698296f3733f461f9732b3be5c8dc20cee6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE5NTY5ODI5NmYzNzMzZjQ2MWY5NzMyYjNiZTVjOGRjMjBjZWU2YQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2001-09-29T22:56:14Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2001-09-29T22:56:14Z"}, "message": "s390.h (EXTRA_CC_MODES): Add CCLmode.\n\n* config/s390/s390.h (EXTRA_CC_MODES): Add CCLmode.\n(SELECT_CC_MODE): Use s390_select_ccmode.\n* config/s390/s390-protos.h (s390_select_ccmode): Add.\n* config/s390/s390.c (s390_select_ccmode): New.\n(s390_match_ccmode): Add CCLmode.\n(s390_branch_condition_mask, s390_branch_condition_mnemonic): New.\n(output_branch_condition, output_inverse_branch_condition): Removed.\n(print_operand): Use s390_branch_condition_mnemonic.\n* config/s390/s390.md (addsi3_cc, addsi3_cconly, addsi3_cconly2,\nsubsi3_cc, subsi3_cconly): Use logical instructions and CCLmode.\n(bunordered, bordered, buneq, bungt, bunlt, bnuge, bunle, bltgt): New.\n\n* config/s390/s390.c (check_and_change_labels): Preserve CC mode\nwhen converting conditional branches to far branches.\n* config/s390/s390.md (cmpstr_const, cmpstr_64, cmpstr_31, cmpint_si,\ncmpint_di): Use CCSmode instead of CCUmode.\n\n* config/s390/s390.c (legitimate_la_operand_p): New.\n* config/s390/s390-protos.h (legitimate_la_operand_p): Add.\n* config/s390/s390.md (movsi): Convert load address patterns to\narithmetic operations when necessary.\n(addaddr_picR, addaddr_picL, addaddr_picN): Removed.\n(do_la): Renamed to *do_la and use legitimate_la_operand_p.\n(*do_la_reg_0): Don't use before reload.\n\n* config/s390/s390.c (legitimize_address): Make more efficient\nuse of two-register addressing mode.\n\n* config/s390/s390.c (s390_function_prologue): Fix incorrect prolog\nwith -mno-backchain in some corner cases.\n\n* config/s390/s390.md (cmpsi_cct): Operands 0 and 1 do not commute.\n\nFrom-SVN: r45891", "tree": {"sha": "78a147c5f5a1ff5ea621fbfe6e1fbe64a319a2bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78a147c5f5a1ff5ea621fbfe6e1fbe64a319a2bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba95698296f3733f461f9732b3be5c8dc20cee6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba95698296f3733f461f9732b3be5c8dc20cee6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba95698296f3733f461f9732b3be5c8dc20cee6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba95698296f3733f461f9732b3be5c8dc20cee6a/comments", "author": null, "committer": null, "parents": [{"sha": "3d17d93d9fe5c1141c319158e756f6b9b6300f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d17d93d9fe5c1141c319158e756f6b9b6300f86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d17d93d9fe5c1141c319158e756f6b9b6300f86"}], "stats": {"total": 579, "additions": 412, "deletions": 167}, "files": [{"sha": "c89d7c81ec3ae4ec7d4b21ff89fda5556f72585e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba95698296f3733f461f9732b3be5c8dc20cee6a", "patch": "@@ -1,3 +1,38 @@\n+2001-09-30  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.h (EXTRA_CC_MODES): Add CCLmode.\n+\t(SELECT_CC_MODE): Use s390_select_ccmode.\n+\t* config/s390/s390-protos.h (s390_select_ccmode): Add.\n+\t* config/s390/s390.c (s390_select_ccmode): New.\n+\t(s390_match_ccmode): Add CCLmode.\n+\t(s390_branch_condition_mask, s390_branch_condition_mnemonic): New.\n+\t(output_branch_condition, output_inverse_branch_condition): Removed.\n+\t(print_operand): Use s390_branch_condition_mnemonic.\n+\t* config/s390/s390.md (addsi3_cc, addsi3_cconly, addsi3_cconly2,\n+\tsubsi3_cc, subsi3_cconly): Use logical instructions and CCLmode.\n+\t(bunordered, bordered, buneq, bungt, bunlt, bnuge, bunle, bltgt): New.\n+\n+\t* config/s390/s390.c (check_and_change_labels): Preserve CC mode\n+\twhen converting conditional branches to far branches.\n+\t* config/s390/s390.md (cmpstr_const, cmpstr_64, cmpstr_31, cmpint_si,\n+\tcmpint_di): Use CCSmode instead of CCUmode.\n+\n+\t* config/s390/s390.c (legitimate_la_operand_p): New.\n+\t* config/s390/s390-protos.h (legitimate_la_operand_p): Add.\n+\t* config/s390/s390.md (movsi): Convert load address patterns to\n+\tarithmetic operations when necessary.\n+\t(addaddr_picR, addaddr_picL, addaddr_picN): Removed.\n+\t(do_la): Renamed to *do_la and use legitimate_la_operand_p.\n+\t(*do_la_reg_0): Don't use before reload.\n+\n+\t* config/s390/s390.c (legitimize_address): Make more efficient\n+\tuse of two-register addressing mode.\n+\n+\t* config/s390/s390.c (s390_function_prologue): Fix incorrect prolog\n+\twith -mno-backchain in some corner cases.\n+\n+\t* config/s390/s390.md (cmpsi_cct): Operands 0 and 1 do not commute.\n+\n 2001-09-29  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* reload.c (find_reloads): Mark new USE insns with QImode."}, {"sha": "baee5a09ea05fcbda98e4979869a1974aaea4f5b", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=ba95698296f3733f461f9732b3be5c8dc20cee6a", "patch": "@@ -42,7 +42,9 @@ extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n \n extern int s390_match_ccmode PARAMS ((rtx, enum machine_mode));\n+extern enum machine_mode s390_select_ccmode PARAMS ((enum rtx_code, rtx, rtx));\n extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n+extern int legitimate_la_operand_p PARAMS ((rtx));\n extern int legitimate_pic_operand_p PARAMS ((rtx));\n extern int legitimate_constant_p PARAMS ((rtx));\n extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));"}, {"sha": "647a5fd5380f7bc993b9930c49e14c0fe35f4902", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 245, "deletions": 86, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ba95698296f3733f461f9732b3be5c8dc20cee6a", "patch": "@@ -94,11 +94,11 @@ struct s390_address\n };\n \n static int s390_match_ccmode_set PARAMS ((rtx, enum machine_mode));\n+static int s390_branch_condition_mask PARAMS ((rtx));\n+static const char *s390_branch_condition_mnemonic PARAMS ((rtx, int));\n static int base_n_index_p PARAMS ((rtx));\n static int check_mode PARAMS ((rtx, enum machine_mode *));\n static int s390_decompose_address PARAMS ((rtx, struct s390_address *, int));\n-static void output_branch_condition PARAMS ((FILE *, rtx));\n-static void output_inverse_branch_condition PARAMS ((FILE *, rtx));\n static int reg_used_in_mem_p PARAMS ((int, rtx));\n static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n static int other_chunk PARAMS ((int *, int, int));\n@@ -135,9 +135,6 @@ s390_match_ccmode_set (set, req_mode)\n   set_mode = GET_MODE (SET_DEST (set));\n   switch (set_mode)\n     {\n-    case CCmode:\n-      return 0;\n-\n     case CCSmode:\n       if (req_mode != CCSmode)\n         return 0;\n@@ -146,6 +143,10 @@ s390_match_ccmode_set (set, req_mode)\n       if (req_mode != CCUmode)\n         return 0;\n       break;\n+    case CCLmode:\n+      if (req_mode != CCLmode)\n+        return 0;\n+      break;\n     case CCZmode:\n       if (req_mode != CCSmode && req_mode != CCUmode && req_mode != CCTmode)\n         return 0;\n@@ -184,6 +185,161 @@ s390_match_ccmode (insn, req_mode)\n   return 1;\n }\n \n+/* Given a comparison code OP (EQ, NE, etc.) and the operands \n+   OP0 and OP1 of a COMPARE, return the mode to be used for the \n+   comparison.  */\n+\n+enum machine_mode\n+s390_select_ccmode (code, op0, op1) \n+     enum rtx_code code;\n+     rtx op0;\n+     rtx op1;\n+{\n+  switch (code)\n+    {\n+      case EQ:\n+      case NE:\n+\tif (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n+\t    || GET_CODE (op1) == NEG)\n+\t  return CCLmode;\n+\n+\treturn CCZmode;\n+\n+      case LE:\n+      case LT:\n+      case GE:\n+      case GT:\n+      case UNORDERED:\n+      case ORDERED:\n+      case UNEQ:\n+      case UNLE:\n+      case UNLT:\n+      case UNGE:\n+      case UNGT:\n+      case LTGT:\n+\treturn CCSmode;\n+\n+      case LEU:\n+      case LTU:\n+      case GEU:\n+      case GTU:\n+\treturn CCUmode;\n+\n+      default:\n+\tabort ();\n+    }\n+}\n+\n+/* Return branch condition mask to implement a branch \n+   specified by CODE.  */\n+\n+static int\n+s390_branch_condition_mask (code)\n+    rtx code;\n+{ \n+  const int CC0 = 1 << 3;\n+  const int CC1 = 1 << 2;\n+  const int CC2 = 1 << 1;\n+  const int CC3 = 1 << 0;\n+\n+  if (GET_CODE (XEXP (code, 0)) != REG\n+      || REGNO (XEXP (code, 0)) != CC_REGNUM\n+      || XEXP (code, 1) != const0_rtx)\n+    abort ();\n+\n+  switch (GET_MODE (XEXP (code, 0)))\n+    {\n+    case CCZmode:\n+      switch (GET_CODE (code))\n+        {\n+        case EQ:\treturn CC0;\n+\tcase NE:\treturn CC1 | CC2 | CC3;\n+\tdefault:\n+\t  abort ();\n+        }\n+      break;\n+\n+    case CCLmode:\n+      switch (GET_CODE (code))\n+        {\n+        case EQ:\treturn CC0 | CC2;\n+\tcase NE:\treturn CC1 | CC3;\n+\tcase UNORDERED:\treturn CC2 | CC3;  /* carry */\n+\tcase ORDERED:\treturn CC0 | CC1;  /* no carry */\n+\tdefault:\n+\t  abort ();\n+        }\n+      break;\n+\n+    case CCUmode:\n+      switch (GET_CODE (code))\n+        {\n+        case EQ:\treturn CC0;\n+        case NE:\treturn CC1 | CC2 | CC3;\n+        case LTU:\treturn CC1;\n+        case GTU:\treturn CC2;\n+        case LEU:\treturn CC0 | CC1;\n+        case GEU:\treturn CC0 | CC2;\n+\tdefault:\n+\t  abort ();\n+        }\n+      break;\n+\n+    case CCSmode:\n+      switch (GET_CODE (code))\n+        {\n+        case EQ:\treturn CC0;\n+        case NE:\treturn CC1 | CC2 | CC3;\n+        case LT:\treturn CC1;\n+        case GT:\treturn CC2;\n+        case LE:\treturn CC0 | CC1;\n+        case GE:\treturn CC0 | CC2;\n+\tcase UNORDERED:\treturn CC3;\n+\tcase ORDERED:\treturn CC0 | CC1 | CC2;\n+\tcase UNEQ:\treturn CC0 | CC3;\n+        case UNLT:\treturn CC1 | CC3;\n+        case UNGT:\treturn CC2 | CC3;\n+        case UNLE:\treturn CC0 | CC1 | CC3;\n+        case UNGE:\treturn CC0 | CC2 | CC3;\n+\tcase LTGT:\treturn CC1 | CC2;\n+\tdefault:\n+\t  abort ();\n+        }\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* If INV is false, return assembler mnemonic string to implement \n+   a branch specified by CODE.  If INV is true, return mnemonic \n+   for the corresponding inverted branch.  */\n+\n+static const char *\n+s390_branch_condition_mnemonic (code, inv)\n+     rtx code;\n+     int inv;\n+{\n+  static const char *mnemonic[16] =\n+    {\n+      NULL, \"o\", \"h\", \"nle\",\n+      \"l\", \"nhe\", \"lh\", \"ne\",\n+      \"e\", \"nlh\", \"he\", \"nl\",\n+      \"le\", \"nh\", \"no\", NULL\n+    };\n+\n+  int mask = s390_branch_condition_mask (code);\n+\n+  if (inv)\n+    mask ^= 15;\n+\n+  if (mask < 1 || mask > 14)\n+    abort ();\n+\n+  return mnemonic[mask];\n+}\n+\n+\n /* Change optimizations to be performed, depending on the \n    optimization level.\n \n@@ -887,6 +1043,40 @@ legitimate_address_p (mode, addr, strict)\n   return s390_decompose_address (addr, NULL, strict);\n }\n \n+/* Return 1 if OP is a valid operand for the LA instruction.\n+   In 31-bit, we need to prove that the result is used as an\n+   address, as LA performs only a 31-bit addition.  */\n+\n+int\n+legitimate_la_operand_p (op)\n+     register rtx op;\n+{\n+  struct s390_address addr;\n+  if (!s390_decompose_address (op, &addr, FALSE))\n+    return FALSE;\n+\n+  if (TARGET_64BIT)\n+    return TRUE;\n+\n+  /* Use of the base or stack pointer implies address.  */\n+\n+  if (addr.base && GET_CODE (addr.base) == REG)\n+    {\n+      if (REGNO (addr.base) == BASE_REGISTER\n+          || REGNO (addr.base) == STACK_POINTER_REGNUM)\n+        return TRUE;\n+    }\n+\n+  if (addr.indx && GET_CODE (addr.indx) == REG)\n+    {\n+      if (REGNO (addr.indx) == BASE_REGISTER\n+          || REGNO (addr.indx) == STACK_POINTER_REGNUM)\n+        return TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n /* Return a legitimate reference for ORIG (an address) using the\n    register REG.  If REG is 0, a new pseudo is generated.\n \n@@ -1199,87 +1389,52 @@ legitimize_address (x, oldx, mode)\n      register rtx oldx ATTRIBUTE_UNUSED;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  if (flag_pic && SYMBOLIC_CONST (x))\n-    return legitimize_pic_address (x, 0);\n-\n-  return x;\n-}\n+  rtx constant_term = const0_rtx;\n \n-\n-/* Output branch condition code of CODE in assembler\n-   syntax to stdio stream FILE.  */\n-\n-static void\n-output_branch_condition (file, code)\n-     FILE *file;\n-     rtx code;\n-{\n-  switch (GET_CODE (code)) \n+  if (flag_pic)\n     {\n-    case EQ:\n-      fprintf (file, \"e\");\n-      break;\n-    case NE:\n-      fprintf (file, \"ne\");\n-      break;\n-    case GT:\n-    case GTU:\n-      fprintf (file, \"h\");\n-      break;\n-    case LT:\n-    case LTU:\n-      fprintf (file, \"l\");\n-      break;\n-    case GE:\n-    case GEU:\n-      fprintf (file, \"he\");\n-      break;\n-    case LE:\n-    case LEU:\n-      fprintf (file, \"le\");\n-      break;\n-    default:\n-      fatal_insn (\"Unknown CC code\", code);\n+      if (SYMBOLIC_CONST (x)\n+          || (GET_CODE (x) == PLUS \n+              && (SYMBOLIC_CONST (XEXP (x, 0)) \n+                  || SYMBOLIC_CONST (XEXP (x, 1)))))\n+\t  x = legitimize_pic_address (x, 0);\n+\n+      if (legitimate_address_p (mode, x, FALSE))\n+\treturn x;\n     }\n-}\n \n-/* Output the inverse of the branch condition code of CODE \n-   in assembler syntax to stdio stream FILE.  */\n+  x = eliminate_constant_term (x, &constant_term);\n \n-static void\n-output_inverse_branch_condition (file, code)\n-     FILE *file;\n-     rtx code;\n-{\n-  switch (GET_CODE (code)) \n+  if (GET_CODE (x) == PLUS)\n     {\n-    case EQ:\n-      fprintf (file, \"ne\");\n-      break;\n-    case NE:\n-      fprintf (file, \"e\");\n-      break;\n-    case GT:\n-    case GTU:\n-      fprintf (file, \"nh\");\n-      break;\n-    case LT:\n-    case LTU:\n-      fprintf (file, \"nl\");\n-      break;\n-    case GE:\n-    case GEU:\n-      fprintf (file, \"nhe\");\n-      break;\n-    case LE:\n-    case LEU:\n-      fprintf (file, \"nle\");\n-      break;\n-    default:\n-      fatal_insn (\"Unknown CC code\", code);\n+      if (GET_CODE (XEXP (x, 0)) == REG)\n+\t{\n+\t  register rtx temp = gen_reg_rtx (Pmode);\n+\t  register rtx val  = force_operand (XEXP (x, 1), temp);\n+\t  if (val != temp)\n+\t    emit_move_insn (temp, val);\n+\n+\t  x = gen_rtx_PLUS (Pmode, XEXP (x, 0), temp);\n+\t}\n+\n+      else if (GET_CODE (XEXP (x, 1)) == REG)\n+\t{\n+\t  register rtx temp = gen_reg_rtx (Pmode);\n+\t  register rtx val  = force_operand (XEXP (x, 0), temp);\n+\t  if (val != temp)\n+\t    emit_move_insn (temp, val);\n+\n+\t  x = gen_rtx_PLUS (Pmode, temp, XEXP (x, 1));\n+\t}\n     }\n+\n+  if (constant_term != const0_rtx)\n+    x = gen_rtx_PLUS (Pmode, x, constant_term);\n+\n+  return x;\n }\n \n+\n /* Output symbolic constant X in assembler syntax to \n    stdio stream FILE.  */\n \n@@ -1417,11 +1572,11 @@ print_operand (file, x, code)\n   switch (code)\n     {\n     case 'C':\n-      output_branch_condition (file, x);\n+      fprintf (file, s390_branch_condition_mnemonic (x, FALSE));\n       return;\n \n     case 'D':\n-      output_inverse_branch_condition (file, x);\n+      fprintf (file, s390_branch_condition_mnemonic (x, TRUE));\n       return;\n \n     case 'Y':\n@@ -1806,7 +1961,7 @@ check_and_change_labels (insn, ltorg_uids)\n      int *ltorg_uids;\n {\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-  rtx target, jump;\n+  rtx target, jump, cjump;\n   rtx pattern, tmp, body, label1;\n   int addr0, addr1;\n \n@@ -1878,7 +2033,10 @@ check_and_change_labels (insn, ltorg_uids)\n \t\t    }\n \t\t  \n \t\t  label1 = gen_label_rtx ();\n-\t\t  emit_jump_insn_before (gen_icjump (label1, XEXP (body, 0)), insn);\n+\t\t  cjump = gen_rtx_LABEL_REF (VOIDmode, label1);\n+\t\t  cjump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (body, 0), pc_rtx, cjump);\n+\t\t  cjump = gen_rtx_SET (VOIDmode, pc_rtx, cjump);\n+\t\t  emit_jump_insn_before (cjump, insn);\n \t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n \t\t  tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n \t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n@@ -1912,7 +2070,10 @@ check_and_change_labels (insn, ltorg_uids)\n \t\t    }\n \t\t  \n \t\t  label1 = gen_label_rtx ();\n-\t\t  emit_jump_insn_before (gen_cjump (label1, XEXP (body, 0)), insn);\n+\t\t  cjump = gen_rtx_LABEL_REF (VOIDmode, label1);\n+\t\t  cjump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (body, 0), cjump, pc_rtx);\n+\t\t  cjump = gen_rtx_SET (VOIDmode, pc_rtx, cjump);\n+\t\t  emit_jump_insn_before (cjump, insn);\n \t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n \t\t  tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n \t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n@@ -2541,8 +2702,7 @@ s390_function_prologue (file, lsize)\n \n       /* Decrement stack.  */\n \n-      if (TARGET_BACKCHAIN || (STARTING_FRAME_OFFSET +\n-\t\t\t       lsize + STACK_POINTER_OFFSET > 4095\n+      if (TARGET_BACKCHAIN || (frame_size + STACK_POINTER_OFFSET > 4095\n \t\t\t       || frame_pointer_needed\n \t\t\t       || current_function_calls_alloca))\n \t{\n@@ -2582,8 +2742,7 @@ s390_function_prologue (file, lsize)\n \n       /* Generate backchain.  */\n \n-      if (TARGET_BACKCHAIN || (STARTING_FRAME_OFFSET + \n-\t\t\t       lsize + STACK_POINTER_OFFSET > 4095\n+      if (TARGET_BACKCHAIN || (frame_size + STACK_POINTER_OFFSET > 4095\n \t\t\t       || frame_pointer_needed\n \t\t\t       || current_function_calls_alloca))\n \t{"}, {"sha": "90ba647ed49d850f314e63e0714a759f098e3391", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=ba95698296f3733f461f9732b3be5c8dc20cee6a", "patch": "@@ -1687,20 +1687,15 @@ do {                                                                       \\\n #define EXTRA_CC_MODES \\\n \tCC (CCZmode, \"CCZ\") \\\n \tCC (CCAmode, \"CCA\") \\\n+\tCC (CCLmode, \"CCL\") \\\n \tCC (CCUmode, \"CCU\") \\\n \tCC (CCSmode, \"CCS\") \\\n \tCC (CCTmode, \"CCT\")\n  \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison. */\n  \n-#define SELECT_CC_MODE(OP, X, Y)            \\\n- (   (OP) == EQ  || (OP) == NE  ? CCZmode   \\\n-   : (OP) == LE  || (OP) == LT  ||          \\\n-     (OP) == GE  || (OP) == GT  ? CCSmode   \\\n-   : (OP) == LEU || (OP) == LTU ||          \\\n-     (OP) == GEU || (OP) == GTU ? CCUmode   \\\n-   : CCmode )\n+#define SELECT_CC_MODE(OP, X, Y) s390_select_ccmode ((OP), (X), (Y))\n  \n  \n /* Define the information needed to generate branch and scc insns.  This is"}, {"sha": "18e9c1c21c7832bf3cdf6e3880e5b40ca3ef4c72", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 128, "deletions": 74, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba95698296f3733f461f9732b3be5c8dc20cee6a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=ba95698296f3733f461f9732b3be5c8dc20cee6a", "patch": "@@ -369,7 +369,7 @@\n \n (define_insn \"*cmpsi_cct\"\n   [(set (reg 33)\n-        (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"%d\")\n+        (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n \t                  (match_operand:SI 1 \"const1_operand\" \"\")\n                           (match_operand:SI 2 \"immediate_operand\"  \"I\"))\n                  (const_int 0)))]\n@@ -856,6 +856,19 @@\n \n   if (flag_pic && SYMBOLIC_CONST (operands[1]))\n     emit_pic_move (operands, SImode);\n+\n+  /* expr.c tries to load an effective address using \n+     force_reg.  This fails because we don't have a \n+     generic load_address pattern.  Convert the move\n+     to a proper arithmetic operation instead, unless\n+     it is guaranteed to be OK.  */\n+  if (GET_CODE (operands[1]) == PLUS\n+      && !legitimate_la_operand_p (operands[1]))\n+    {\n+      operands[1] = force_operand (operands[1], operands[0]);\n+      if (operands[1] == operands[0])\n+        DONE;\n+    }\n }\")\n \n (define_insn \"*movsi\"\n@@ -1835,8 +1848,8 @@\n ; Compare a block that is less than 256 bytes in length.\n \n (define_insn \"cmpstr_const\"\n-  [(set (reg:CCU 33)\n-        (compare:CCU (match_operand:BLK 0 \"s_operand\" \"oQ\")\n+  [(set (reg:CCS 33)\n+        (compare:CCS (match_operand:BLK 0 \"s_operand\" \"oQ\")\n                      (match_operand:BLK 1 \"s_operand\" \"oQ\")))\n    (use (match_operand 2 \"immediate_operand\" \"I\"))]\n   \"(unsigned) INTVAL (operands[2]) < 256\"\n@@ -1848,8 +1861,8 @@\n ; Compare a block that is larger than 255 bytes in length.\n \n (define_insn \"cmpstr_64\"\n-  [(set (reg:CCU 33)\n-        (compare:CCU (mem:BLK (subreg:DI (match_operand:TI 0 \"register_operand\" \"d\") 0))\n+  [(set (reg:CCS 33)\n+        (compare:CCS (mem:BLK (subreg:DI (match_operand:TI 0 \"register_operand\" \"d\") 0))\n                      (mem:BLK (subreg:DI (match_operand:TI 1 \"register_operand\" \"d\") 0))))\n    (clobber (subreg:DI (match_dup 0) 0))\n    (clobber (subreg:DI (match_dup 0) 8))\n@@ -1862,8 +1875,8 @@\n    (set_attr \"type\"    \"other\")])\n \n (define_insn \"cmpstr_31\"\n-  [(set (reg:CCU 33)\n-        (compare:CCU (mem:BLK (subreg:SI (match_operand:DI 0 \"register_operand\" \"d\") 0))\n+  [(set (reg:CCS 33)\n+        (compare:CCS (mem:BLK (subreg:SI (match_operand:DI 0 \"register_operand\" \"d\") 0))\n                      (mem:BLK (subreg:SI (match_operand:DI 1 \"register_operand\" \"d\") 0))))\n    (clobber (subreg:SI (match_dup 0) 0))\n    (clobber (subreg:SI (match_dup 0) 4))\n@@ -1879,7 +1892,7 @@\n \n (define_insn \"cmpint_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (compare:SI (reg:CCU 33) (const_int 0)))]\n+        (compare:SI (reg:CCS 33) (const_int 0)))]\n   \"\"\n   \"*\n {\n@@ -1896,7 +1909,7 @@\n \n (define_insn \"cmpint_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (compare:DI (reg:CCU 33) (const_int 0)))]\n+        (compare:DI (reg:CCS 33) (const_int 0)))]\n   \"TARGET_64BIT\"\n   \"*\n {\n@@ -2907,76 +2920,44 @@\n    (set_attr \"atype\"    \"mem\")\n    (set_attr \"type\"     \"la\")])\n \n-(define_insn \"*addaddr_picR\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"a\")\n-                 (unspec:SI [(match_operand:SI 2 \"register_operand\" \"a\")] 101)))]\n-  \"\"\n-  \"la\\\\t%0,0(%1,%2)\"\n-  [(set_attr \"op_type\"  \"RX\")\n-   (set_attr \"atype\"    \"mem\")\n-   (set_attr \"type\"     \"la\")])\n-\n-(define_insn \"*addaddr_picL\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"a\")] 101)\n-                 (match_operand:SI 1 \"register_operand\" \"a\")))]\n-  \"\"\n-  \"la\\\\t%0,0(%1,%2)\"\n-  [(set_attr \"op_type\"  \"RX\")\n-   (set_attr \"atype\"    \"mem\")\n-   (set_attr \"type\"     \"la\")])\n-\n-(define_insn \"*addaddr_picN\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(match_operand:SI 1 \"register_operand\" \"a\")] 101))]\n-  \"\"\n-  \"la\\\\t%0,0(%1)\"\n-  [(set_attr \"op_type\"  \"RX\")\n-   (set_attr \"atype\"    \"mem\")\n-   (set_attr \"type\"     \"la\")])\n-\n (define_insn \"*addsi3_cc\"\n   [(set (reg 33) \n-        (compare (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0\")\n-                          (match_operand:SI 2 \"general_operand\" \"d,K,m\"))\n+        (compare (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+                          (match_operand:SI 2 \"nonimmediate_operand\" \"d,m\"))\n                  (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n         (plus:SI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode(insn, CCSmode)\"\n+  \"s390_match_ccmode(insn, CCLmode)\"\n   \"@\n-   ar\\\\t%0,%2\n-   ahi\\\\t%0,%h2\n-   a\\\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RI,RX\")\n-   (set_attr \"atype\"    \"reg,reg,mem\")])  \n+   alr\\\\t%0,%2\n+   al\\\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR,RX\")\n+   (set_attr \"atype\"    \"reg,mem\")])  \n \n (define_insn \"*addsi3_cconly\"\n   [(set (reg 33) \n-        (compare (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0\")\n-                          (match_operand:SI 2 \"general_operand\" \"d,K,m\"))\n+        (compare (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+                          (match_operand:SI 2 \"general_operand\" \"d,m\"))\n                  (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n-  \"s390_match_ccmode(insn, CCSmode)\"\n+   (clobber (match_scratch:SI 0 \"=d,d\"))]\n+  \"s390_match_ccmode(insn, CCLmode)\"\n   \"@\n-   ar\\\\t%0,%2\n-   ahi\\\\t%0,%h2\n-   a\\\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RI,RX\")\n-   (set_attr \"atype\"    \"reg,reg,mem\")])  \n+   alr\\\\t%0,%2\n+   al\\\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR,RX\")\n+   (set_attr \"atype\"    \"reg,mem\")])  \n \n (define_insn \"*addsi3_cconly2\"\n   [(set (reg 33) \n-        (compare (match_operand:SI 1 \"register_operand\" \"%0,0,0\")\n-                 (neg:SI (match_operand:SI 2 \"general_operand\" \"d,K,m\"))))\n-   (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n-  \"s390_match_ccmode(insn, CCSmode)\"\n+        (compare (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+                 (neg:SI (match_operand:SI 2 \"general_operand\" \"d,m\"))))\n+   (clobber (match_scratch:SI 0 \"=d,d\"))]\n+  \"s390_match_ccmode(insn, CCLmode)\"\n   \"@\n-   ar\\\\t%0,%2\n-   ahi\\\\t%0,%h2\n-   a\\\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RI,RX\")\n-   (set_attr \"atype\"    \"reg,reg,mem\")])  \n+   alr\\\\t%0,%2\n+   al\\\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR,RX\")\n+   (set_attr \"atype\"    \"reg,mem\")])  \n \n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n@@ -2991,10 +2972,11 @@\n   [(set_attr \"op_type\"  \"RR,RI,RX\")\n    (set_attr \"atype\"    \"reg,reg,mem\")])\n \n-(define_insn \"do_la\"\n+(define_insn \"*do_la\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n         (match_operand:QI 1 \"address_operand\" \"p\"))]\n-  \"volatile_ok\"\n+  \"reload_in_progress || reload_completed\n+   || legitimate_la_operand_p (operands[1])\"\n   \"la\\\\t%0,%a1\"\n   [(set_attr \"op_type\"  \"RX\")\n    (set_attr \"atype\"    \"mem\")\n@@ -3004,7 +2986,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n                  (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"\"\n+  \"reload_in_progress || reload_completed\"\n   \"brxle\\\\t%0,%2,.+4\"\n   [(set_attr \"op_type\" \"RSI\")\n    (set_attr \"atype\"   \"reg\")])\n@@ -3220,10 +3202,10 @@\n                  (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n         (minus:SI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode(insn, CCSmode)\"\n+  \"s390_match_ccmode(insn, CCLmode)\"\n   \"@\n-   sr\\\\t%0,%2\n-   s\\\\t%0,%2\"\n+   slr\\\\t%0,%2\n+   sl\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX\")\n    (set_attr \"atype\"    \"reg,mem\")])\n \n@@ -3233,10 +3215,10 @@\n                            (match_operand:SI 2 \"general_operand\" \"d,m\"))\n                  (const_int 0)))\n    (clobber (match_scratch:SI 0 \"=d,d\"))]\n-  \"s390_match_ccmode(insn, CCSmode)\"\n+  \"s390_match_ccmode(insn, CCLmode)\"\n   \"@\n-   sr\\\\t%0,%2\n-   s\\\\t%0,%2\"\n+   slr\\\\t%0,%2\n+   sl\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX\")\n    (set_attr \"atype\"    \"reg,mem\")])\n \n@@ -4945,6 +4927,78 @@\n   \"\"\n   \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n \n+(define_expand \"bunordered\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (unordered (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n+(define_expand \"bordered\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (ordered (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n+(define_expand \"buneq\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (uneq (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n+(define_expand \"bungt\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (ungt (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n+(define_expand \"bunlt\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (unlt (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n+(define_expand \"bunge\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (unge (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n+(define_expand \"bunle\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (unle (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n+(define_expand \"bltgt\"\n+  [(set (reg:CCS 33) (compare:CCS (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+        (if_then_else (ltgt (reg:CCS 33) (const_int 0))\n+                      (label_ref (match_operand 0 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"{ operands[1] = s390_compare_op0; operands[2] = s390_compare_op1; }\")\n+\n \n ;;\n ;;- Conditional jump instructions."}]}