{"sha": "fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM2NGI0NDgxZDYwODVjNGY0ZmQyNjBiNTgwMWQwNzg1YzhhN2EwMg==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@gmail.com", "date": "2011-05-27T20:19:13Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2011-05-27T20:19:13Z"}, "message": "re PR other/48981 (bootstrap-lto -O3 produces miscompiled, broken gcc)\n\n2011-05-27  Andrew Pinski  <pinskia@gmail.com>\n\n\tPR middle-end/48981\n\t* gengtype.c (vec_prefix_type): New function.\n\t(note_def_vec): Use vec_prefix_type and change the length\n\tattribute to be based on the prefix.\n\t* vec.c: Include coretypes.h before vec.h.\n\t(struct vec_prefix): Remove.\n\t(vec_gc_p_reserve): Change the offsetof to sizeof.\n\t(vec_gc_p_reserve_exact): Likewise.\n\t(vec_heap_p_reserve): Likewise.\n\t(vec_heap_p_reserve_exact): Likewise.\n\t(vec_stack_o_reserve_1): Copy from +1 instead of from vec.\n\t(vec_stack_p_reserve): Change the offsetof to sizeof.\n\t(vec_stack_p_reserve_exact): Likewise.\n\t* vec.h (struct vec_prefix): New struct definition.\n\t(VEC_T(T,B)): Use vec_prefix instead of having num/alloc fields.\n\t(VEC_T_GTY(T,B)): Likewise.\n\t(DEF_VEC_FUNC_P(T)): Use prefix field.\n\t(DEF_VEC_NONALLOC_FUNCS_O(T,A)): Likewise.\n\t(DEF_VEC_NONALLOC_FUNCS_I(T,A)): Likewise.\n\nFrom-SVN: r174359", "tree": {"sha": "58b5ea50a0a6ed81e3e2670399e5a95a8309deb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58b5ea50a0a6ed81e3e2670399e5a95a8309deb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/comments", "author": {"login": "pinskia", "id": 8496799, "node_id": "MDQ6VXNlcjg0OTY3OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8496799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pinskia", "html_url": "https://github.com/pinskia", "followers_url": "https://api.github.com/users/pinskia/followers", "following_url": "https://api.github.com/users/pinskia/following{/other_user}", "gists_url": "https://api.github.com/users/pinskia/gists{/gist_id}", "starred_url": "https://api.github.com/users/pinskia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pinskia/subscriptions", "organizations_url": "https://api.github.com/users/pinskia/orgs", "repos_url": "https://api.github.com/users/pinskia/repos", "events_url": "https://api.github.com/users/pinskia/events{/privacy}", "received_events_url": "https://api.github.com/users/pinskia/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "226855f0608af61a273c095fce991bd5fa9b32b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/226855f0608af61a273c095fce991bd5fa9b32b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/226855f0608af61a273c095fce991bd5fa9b32b3"}], "stats": {"total": 242, "additions": 140, "deletions": 102}, "files": [{"sha": "416d08fe04f5bd1f3765d12aae3c6fe14dbc4ad7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "patch": "@@ -1,3 +1,25 @@\n+2011-05-27  Andrew Pinski  <pinskia@gmail.com>\n+\n+\tPR middle-end/48981\n+\t* gengtype.c (vec_prefix_type): New function.\n+\t(note_def_vec): Use vec_prefix_type and change the length\n+\tattribute to be based on the prefix.\n+\t* vec.c: Include coretypes.h before vec.h.\n+\t(struct vec_prefix): Remove.\n+\t(vec_gc_p_reserve): Change the offsetof to sizeof.\n+\t(vec_gc_p_reserve_exact): Likewise.\n+\t(vec_heap_p_reserve): Likewise.\n+\t(vec_heap_p_reserve_exact): Likewise.\n+\t(vec_stack_o_reserve_1): Copy from +1 instead of from vec.\n+\t(vec_stack_p_reserve): Change the offsetof to sizeof.\n+\t(vec_stack_p_reserve_exact): Likewise.\n+\t* vec.h (struct vec_prefix): New struct definition.\n+\t(VEC_T(T,B)): Use vec_prefix instead of having num/alloc fields.\n+\t(VEC_T_GTY(T,B)): Likewise.\n+\t(DEF_VEC_FUNC_P(T)): Use prefix field.\n+\t(DEF_VEC_NONALLOC_FUNCS_O(T,A)): Likewise.\n+\t(DEF_VEC_NONALLOC_FUNCS_I(T,A)): Likewise.\n+\n 2011-05-27  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/46728"}, {"sha": "7cae3386120423fffb6c2a0cc31a8a8b14e421d7", "filename": "gcc/gengtype.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "patch": "@@ -4130,14 +4130,36 @@ write_roots (pair_p variables, bool emit_pch)\n   finish_root_table (flp, \"pch_rs\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_pch_scalar_rtab\");\n }\n+/* Record the definition of the vec_prefix structure, as defined in vec.h:\n+\n+   struct vec_prefix GTY(()) {\n+   unsigned num;\n+   unsigned alloc;\n+   };  */\n+static type_p\n+vec_prefix_type (void)\n+{\n+  static type_p prefix_type = NULL;\n+  if (prefix_type == NULL)\n+    {\n+      pair_p fields;\n+      static struct fileloc pos = { NULL, 0 };\n+      type_p len_ty = create_scalar_type (\"unsigned\");\n+      pos.file = input_file_by_name (__FILE__); pos.line = __LINE__;\n+      fields = create_field_at (0, len_ty, \"alloc\", 0, &pos);\n+      fields = create_field_at (fields, len_ty, \"num\", 0, &pos);\n+      prefix_type = new_structure (\"vec_prefix\", 0, &pos, fields, 0);\n+      prefix_type->u.s.bitmap = -1;\n+    }\n+  return prefix_type;\n+}\n \n /* Record the definition of a generic VEC structure, as if we had expanded\n    the macros in vec.h:\n \n    typedef struct VEC_<type>_base GTY(()) {\n-   unsigned num;\n-   unsigned alloc;\n-   <type> GTY((length (\"%h.num\"))) vec[1];\n+   struct vec_prefix prefix;\n+   <type> GTY((length (\"%h.prefix.num\"))) vec[1];\n    } VEC_<type>_base\n \n    where the GTY(()) tags are only present if is_scalar is _false_.  */\n@@ -4148,7 +4170,6 @@ note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n   pair_p fields;\n   type_p t;\n   options_p o;\n-  type_p len_ty = create_scalar_type (\"unsigned\");\n   const char *name = concat (\"VEC_\", type_name, \"_base\", (char *) 0);\n \n   if (is_scalar)\n@@ -4159,12 +4180,11 @@ note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n   else\n     {\n       t = resolve_typedef (type_name, pos);\n-      o = create_string_option (0, \"length\", \"%h.num\");\n+      o = create_string_option (0, \"length\", \"%h.prefix.num\");\n     }\n   /* We assemble the field list in reverse order.  */\n   fields = create_field_at (0, create_array (t, \"1\"), \"vec\", o, pos);\n-  fields = create_field_at (fields, len_ty, \"alloc\", 0, pos);\n-  fields = create_field_at (fields, len_ty, \"num\", 0, pos);\n+  fields = create_field_at (fields, vec_prefix_type (), \"prefix\", 0, pos);\n \n   do_typedef (name, new_structure (name, 0, pos, fields, 0), pos);\n }"}, {"sha": "c1d003492e3c2d802ba6713f7fdb3c463e8e8a87", "filename": "gcc/vec.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "patch": "@@ -28,20 +28,12 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n #include \"system.h\"\n+#include \"coretypes.h\"\n #include \"ggc.h\"\n #include \"vec.h\"\n-#include \"coretypes.h\"\n #include \"diagnostic-core.h\"\n #include \"hashtab.h\"\n \n-struct vec_prefix\n-{\n-  unsigned num;\n-  unsigned alloc;\n-  void *vec[1];\n-};\n-\n-\n #ifdef GATHER_STATISTICS\n \n /* Store information about each particular vector.  */\n@@ -254,7 +246,7 @@ void *\n vec_gc_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n {\n   return vec_gc_o_reserve_1 (vec, reserve,\n-\t\t\t     offsetof (struct vec_prefix, vec),\n+\t\t\t     sizeof (struct vec_prefix),\n \t\t\t     sizeof (void *), false\n \t\t\t     PASS_MEM_STAT);\n }\n@@ -268,7 +260,7 @@ void *\n vec_gc_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n {\n   return vec_gc_o_reserve_1 (vec, reserve,\n-\t\t\t     offsetof (struct vec_prefix, vec),\n+\t\t\t     sizeof (struct vec_prefix),\n \t\t\t     sizeof (void *), true\n \t\t\t     PASS_MEM_STAT);\n }\n@@ -337,7 +329,7 @@ void *\n vec_heap_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n {\n   return vec_heap_o_reserve_1 (vec, reserve,\n-\t\t\t       offsetof (struct vec_prefix, vec),\n+\t\t\t       sizeof (struct vec_prefix),\n \t\t\t       sizeof (void *), false\n \t\t\t       PASS_MEM_STAT);\n }\n@@ -348,7 +340,7 @@ void *\n vec_heap_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n {\n   return vec_heap_o_reserve_1 (vec, reserve,\n-\t\t\t       offsetof (struct vec_prefix, vec),\n+\t\t\t       sizeof (struct vec_prefix),\n \t\t\t       sizeof (void *), true\n \t\t\t       PASS_MEM_STAT);\n }\n@@ -443,8 +435,8 @@ vec_stack_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n   if (newvec && vec)\n     {\n       ((struct vec_prefix *) newvec)->num = ((struct vec_prefix *) vec)->num;\n-      memcpy (((struct vec_prefix *) newvec)->vec,\n-\t      ((struct vec_prefix *) vec)->vec,\n+      memcpy (((struct vec_prefix *) newvec)+1,\n+\t      ((struct vec_prefix *) vec)+1,\n \t      ((struct vec_prefix *) vec)->num * elt_size);\n     }\n   return newvec;\n@@ -456,7 +448,7 @@ void *\n vec_stack_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n {\n   return vec_stack_o_reserve_1 (vec, reserve,\n-\t\t\t\toffsetof (struct vec_prefix, vec),\n+\t\t\t\tsizeof (struct vec_prefix),\n \t\t\t\tsizeof (void *), false\n \t\t\t\tPASS_MEM_STAT);\n }\n@@ -467,7 +459,7 @@ void *\n vec_stack_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n {\n   return vec_stack_o_reserve_1 (vec, reserve,\n-\t\t\t\toffsetof (struct vec_prefix, vec),\n+\t\t\t\tsizeof (struct vec_prefix),\n \t\t\t\tsizeof (void *), true\n \t\t\t\tPASS_MEM_STAT);\n }"}, {"sha": "75fcdebf8e1c81f65a5a713993446c81c276efe8", "filename": "gcc/vec.h", "status": "modified", "additions": 82, "deletions": 78, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc64b4481d6085c4f4fd260b5801d0785c8a7a02/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=fc64b4481d6085c4f4fd260b5801d0785c8a7a02", "patch": "@@ -506,24 +506,28 @@ extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n    VEC, DEF_VEC_*, and DEF_VEC_ALLOC_* macros.  If you change the\n    expansions of these macros you may need to change gengtype too.  */\n \n+typedef struct GTY(()) vec_prefix\n+{\n+  unsigned num;\n+  unsigned alloc;\n+} vec_prefix;\n+\n #define VEC(T,A) VEC_##T##_##A\n #define VEC_OP(T,A,OP) VEC_##T##_##A##_##OP\n \n /* Base of vector type, not user visible.  */\n #define VEC_T(T,B)\t\t\t\t\t\t\t  \\\n typedef struct VEC(T,B) \t\t\t\t \t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  unsigned num;\t\t\t\t\t\t\t\t  \\\n-  unsigned alloc;\t\t\t\t\t\t\t  \\\n+  struct vec_prefix prefix;\t\t\t\t\t\t  \\\n   T vec[1];\t\t\t\t\t\t\t\t  \\\n } VEC(T,B)\n \n #define VEC_T_GTY(T,B)\t\t\t\t\t\t\t  \\\n typedef struct GTY(()) VEC(T,B)\t\t\t\t \t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  unsigned num;\t\t\t\t\t\t\t\t  \\\n-  unsigned alloc;\t\t\t\t\t\t\t  \\\n-  T GTY ((length (\"%h.num\"))) vec[1];\t\t\t\t\t  \\\n+  struct vec_prefix prefix;\t\t\t\t\t\t  \\\n+  T GTY ((length (\"%h.prefix.num\"))) vec[1];\t\t\t\t  \\\n } VEC(T,B)\n \n /* Derived vector type, user visible.  */\n@@ -579,29 +583,29 @@ struct vec_swallow_trailing_semi\n #define DEF_VEC_FUNC_P(T)\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)   \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n+  return vec_ ? vec_->prefix.num : 0;\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T VEC_OP (T,base,last)\t\t\t\t\t  \\\n      (const VEC(T,base) *vec_ VEC_CHECK_DECL)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && vec_->num, \"last\", T, base);\t\t\t  \\\n+  VEC_ASSERT (vec_ && vec_->prefix.num, \"last\", T, base);\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n-  return vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n+  return vec_->vec[vec_->prefix.num - 1];\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T VEC_OP (T,base,index)\t\t\t\t\t  \\\n      (const VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", T, base);\t\t  \\\n+  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return vec_->vec[ix_];\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline int VEC_OP (T,base,iterate)\t\t\t  \t  \\\n      (const VEC(T,base) *vec_, unsigned ix_, T *ptr)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n+  if (vec_ && ix_ < vec_->prefix.num)\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n       *ptr = vec_->vec[ix_];\t\t\t\t\t\t  \\\n       return 1;\t\t\t\t\t\t\t\t  \\\n@@ -622,27 +626,27 @@ static inline size_t VEC_OP (T,base,embedded_size)\t\t\t  \\\n static inline void VEC_OP (T,base,embedded_init)\t\t\t  \\\n      (VEC(T,base) *vec_, int alloc_)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  vec_->num = 0;\t\t\t\t\t\t\t  \\\n-  vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n+  vec_->prefix.num = 0;\t\t\t\t\t\t\t  \\\n+  vec_->prefix.alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n      (VEC(T,base) *vec_, int alloc_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\t\t\t\t  \\\n-  return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n+  return vec_ ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_ : !alloc_;\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP(T,base,splice)\t\t\t\t  \\\n      (VEC(T,base) *dst_, VEC(T,base) *src_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (src_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      unsigned len_ = src_->num;\t\t\t\t\t  \\\n-      VEC_ASSERT (dst_->num + len_ <= dst_->alloc, \"splice\", T, base);\t  \\\n+      unsigned len_ = src_->prefix.num;\t\t\t\t\t  \\\n+      VEC_ASSERT (dst_->prefix.num + len_ <= dst_->prefix.alloc, \"splice\", T, base);\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-      memcpy (&dst_->vec[dst_->num], &src_->vec[0], len_ * sizeof (T));\t  \\\n-      dst_->num += len_;\t\t\t\t\t\t  \\\n+      memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (T));\t  \\\n+      dst_->prefix.num += len_;\t\t\t\t\t\t  \\\n     }\t\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -651,8 +655,8 @@ static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", T, base);\t\t  \\\n-  slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\t\t  \\\n+  slot_ = &vec_->vec[vec_->prefix.num++];\t\t\t\t\t  \\\n   *slot_ = obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n@@ -662,26 +666,26 @@ static inline T VEC_OP (T,base,pop) (VEC(T,base) *vec_ VEC_CHECK_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num, \"pop\", T, base);\t\t\t\t  \\\n-  obj_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->prefix.num, \"pop\", T, base);\t\t\t\t  \\\n+  obj_ = vec_->vec[--vec_->prefix.num];\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,base,truncate)\t\t\t\t  \\\n      (VEC(T,base) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", T, base);\t  \\\n+  VEC_ASSERT (vec_ ? vec_->prefix.num >= size_ : !size_, \"truncate\", T, base);\t  \\\n   if (vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_->num = size_;\t\t\t\t\t\t\t  \\\n+    vec_->prefix.num = size_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T VEC_OP (T,base,replace)\t\t  \t     \t\t  \\\n      (VEC(T,base) *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T old_obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"replace\", T, base);\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"replace\", T, base);\t\t\t  \\\n   old_obj_ = vec_->vec[ix_];\t\t\t\t\t\t  \\\n   vec_->vec[ix_] = obj_;\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -693,10 +697,10 @@ static inline T *VEC_OP (T,base,quick_insert)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", T, base);\t\t  \\\n-  VEC_ASSERT (ix_ <= vec_->num, \"insert\", T, base);\t\t\t  \\\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\t\t  \\\n+  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (T));\t\t  \\\n+  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\t\t  \\\n   *slot_ = obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n@@ -708,10 +712,10 @@ static inline T VEC_OP (T,base,ordered_remove)\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n   T obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n   obj_ = *slot_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (T));     \t  \\\n+  memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (T));     \t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -722,10 +726,10 @@ static inline T VEC_OP (T,base,unordered_remove)\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n   T obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n   obj_ = *slot_;\t\t\t\t\t\t\t  \\\n-  *slot_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n+  *slot_ = vec_->vec[--vec_->prefix.num];\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -735,10 +739,10 @@ static inline void VEC_OP (T,base,block_remove)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ + len_ <= vec_->num, \"block_remove\", T, base);\t  \\\n+  VEC_ASSERT (ix_ + len_ <= vec_->prefix.num, \"block_remove\", T, base);\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->num -= len_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + len_, (vec_->num - ix_) * sizeof (T));\t  \\\n+  vec_->prefix.num -= len_;\t\t\t\t\t\t\t  \\\n+  memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (T));\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,base,address)\t\t\t\t  \\\n@@ -793,15 +797,15 @@ static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n+  size_t len_ = vec_ ? vec_->prefix.num : 0;\t\t\t\t\t  \\\n   VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (len_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n       new_vec_ = (VEC (T,A) *)(vec_##A##_p_reserve_exact\t\t  \\\n \t\t\t       (NULL, len_ PASS_MEM_STAT));\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->base.num = len_;\t\t\t\t\t  \\\n+      new_vec_->base.prefix.num = len_;\t\t\t\t\t  \\\n       memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n     }\t\t\t\t\t\t\t\t\t  \\\n   return new_vec_;\t\t\t\t\t\t\t  \\\n@@ -839,9 +843,9 @@ static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n \t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n \t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n   VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n-\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) \\\n+\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->prefix.num : 0) \\\n \t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+  VEC_BASE (*vec_)->prefix.num = size_;\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n@@ -858,7 +862,7 @@ static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (src_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,A,reserve_exact) (dst_, src_->num\t\t\t  \\\n+      VEC_OP (T,A,reserve_exact) (dst_, src_->prefix.num\t\t\t  \\\n \t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n       VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n@@ -898,28 +902,28 @@ struct vec_swallow_trailing_semi\n #define DEF_VEC_FUNC_O(T)\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n+  return vec_ ? vec_->prefix.num : 0;\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,base,last) (VEC(T,base) *vec_ VEC_CHECK_DECL)  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && vec_->num, \"last\", T, base);\t\t\t  \\\n+  VEC_ASSERT (vec_ && vec_->prefix.num, \"last\", T, base);\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n-  return &vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n+  return &vec_->vec[vec_->prefix.num - 1];\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,base,index)\t\t\t\t\t  \\\n      (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", T, base);\t\t  \\\n+  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return &vec_->vec[ix_];\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline int VEC_OP (T,base,iterate)\t\t\t     \t  \\\n      (VEC(T,base) *vec_, unsigned ix_, T **ptr)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n+  if (vec_ && ix_ < vec_->prefix.num)\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n       *ptr = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n       return 1;\t\t\t\t\t\t\t\t  \\\n@@ -940,27 +944,27 @@ static inline size_t VEC_OP (T,base,embedded_size)\t\t\t  \\\n static inline void VEC_OP (T,base,embedded_init)\t\t\t  \\\n      (VEC(T,base) *vec_, int alloc_)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  vec_->num = 0;\t\t\t\t\t\t\t  \\\n-  vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n+  vec_->prefix.num = 0;\t\t\t\t\t\t\t  \\\n+  vec_->prefix.alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n      (VEC(T,base) *vec_, int alloc_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\t\t\t\t  \\\n-  return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n+  return vec_ ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_ : !alloc_;\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP(T,base,splice)\t\t\t\t  \\\n      (VEC(T,base) *dst_, VEC(T,base) *src_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (src_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      unsigned len_ = src_->num;\t\t\t\t\t  \\\n-      VEC_ASSERT (dst_->num + len_ <= dst_->alloc, \"splice\", T, base);\t  \\\n+      unsigned len_ = src_->prefix.num;\t\t\t\t\t  \\\n+      VEC_ASSERT (dst_->prefix.num + len_ <= dst_->prefix.alloc, \"splice\", T, base);\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-      memcpy (&dst_->vec[dst_->num], &src_->vec[0], len_ * sizeof (T));\t  \\\n-      dst_->num += len_;\t\t\t\t\t\t  \\\n+      memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (T));\t  \\\n+      dst_->prefix.num += len_;\t\t\t\t\t\t  \\\n     }\t\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -969,8 +973,8 @@ static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"push\", T, base);\t\t  \\\n-  slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\t\t  \\\n+  slot_ = &vec_->vec[vec_->prefix.num++];\t\t\t\t\t  \\\n   if (obj_)\t\t\t\t\t\t\t\t  \\\n     *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n@@ -979,24 +983,24 @@ static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,base,pop) (VEC(T,base) *vec_ VEC_CHECK_DECL) \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num, \"pop\", T, base);\t\t\t\t  \\\n-  --vec_->num;\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->prefix.num, \"pop\", T, base);\t\t\t\t  \\\n+  --vec_->prefix.num;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,base,truncate)\t\t\t\t  \\\n      (VEC(T,base) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", T, base);\t  \\\n+  VEC_ASSERT (vec_ ? vec_->prefix.num >= size_ : !size_, \"truncate\", T, base);\t  \\\n   if (vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_->num = size_;\t\t\t\t\t\t\t  \\\n+    vec_->prefix.num = size_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,base,replace)\t\t\t\t  \\\n      (VEC(T,base) *vec_, unsigned ix_, const T *obj_ VEC_CHECK_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"replace\", T, base);\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"replace\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n   if (obj_)\t\t\t\t\t\t\t\t  \\\n     *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n@@ -1009,10 +1013,10 @@ static inline T *VEC_OP (T,base,quick_insert)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->num < vec_->alloc, \"insert\", T, base);\t\t  \\\n-  VEC_ASSERT (ix_ <= vec_->num, \"insert\", T, base);\t\t\t  \\\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\t\t  \\\n+  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (T));\t\t  \\\n+  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\t\t  \\\n   if (obj_)\t\t\t\t\t\t\t\t  \\\n     *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n@@ -1024,27 +1028,27 @@ static inline void VEC_OP (T,base,ordered_remove)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (T));\t\t  \\\n+  memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (T));\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,base,unordered_remove)\t\t\t  \\\n      (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->num, \"remove\", T, base);\t\t\t  \\\n-  vec_->vec[ix_] = vec_->vec[--vec_->num];\t\t\t\t  \\\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n+  vec_->vec[ix_] = vec_->vec[--vec_->prefix.num];\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,base,block_remove)\t\t\t\t  \\\n      (VEC(T,base) *vec_, unsigned ix_, unsigned len_ VEC_CHECK_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   T *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ + len_ <= vec_->num, \"block_remove\", T, base);\t  \\\n+  VEC_ASSERT (ix_ + len_ <= vec_->prefix.num, \"block_remove\", T, base);\t  \\\n   slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->num -= len_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + len_, (vec_->num - ix_) * sizeof (T));\t  \\\n+  vec_->prefix.num -= len_;\t\t\t\t\t\t\t  \\\n+  memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (T));\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline T *VEC_OP (T,base,address)\t\t\t\t  \\\n@@ -1092,7 +1096,7 @@ static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n #define DEF_VEC_NONALLOC_FUNCS_O(T,A)\t\t\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n+  size_t len_ = vec_ ? vec_->prefix.num : 0;\t\t\t\t\t  \\\n   VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (len_)\t\t\t\t\t\t\t\t  \\\n@@ -1102,7 +1106,7 @@ static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n \t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n \t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->base.num = len_;\t\t\t\t\t  \\\n+      new_vec_->base.prefix.num = len_;\t\t\t\t\t  \\\n       memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n     }\t\t\t\t\t\t\t\t\t  \\\n   return new_vec_;\t\t\t\t\t\t\t  \\\n@@ -1153,9 +1157,9 @@ static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n \t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n \t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n   VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n-\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) \\\n+\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->prefix.num : 0) \\\n \t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+  VEC_BASE (*vec_)->prefix.num = size_;\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n@@ -1172,7 +1176,7 @@ static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (src_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,A,reserve_exact) (dst_, src_->num\t\t\t  \\\n+      VEC_OP (T,A,reserve_exact) (dst_, src_->prefix.num\t\t\t  \\\n \t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n       VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n@@ -1210,7 +1214,7 @@ static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n #define DEF_VEC_NONALLOC_FUNCS_I(T,A)\t\t\t\t\t  \\\n static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n+  size_t len_ = vec_ ? vec_->prefix.num : 0;\t\t\t\t\t  \\\n   VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (len_)\t\t\t\t\t\t\t\t  \\\n@@ -1220,7 +1224,7 @@ static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n \t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n \t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->base.num = len_;\t\t\t\t\t  \\\n+      new_vec_->base.prefix.num = len_;\t\t\t\t\t  \\\n       memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n     }\t\t\t\t\t\t\t\t\t  \\\n   return new_vec_;\t\t\t\t\t\t\t  \\\n@@ -1270,9 +1274,9 @@ static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n \t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n \t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n   VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n-\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) \\\n+\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->prefix.num : 0) \\\n \t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+  VEC_BASE (*vec_)->prefix.num = size_;\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n@@ -1289,7 +1293,7 @@ static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (src_)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,A,reserve_exact) (dst_, src_->num\t\t\t  \\\n+      VEC_OP (T,A,reserve_exact) (dst_, src_->prefix.num\t\t\t  \\\n \t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n       VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\"}]}