{"sha": "8e4edce73fe0d2001ed264da7af150f3d15f08af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU0ZWRjZTczZmUwZDIwMDFlZDI2NGRhN2FmMTUwZjNkMTVmMDhhZg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2006-03-10T17:49:02Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-03-10T17:49:02Z"}, "message": "m32c.c (m32c_const_ok_for_constraint_p): Bit numbers start at zero.\n\n* config/m32c/m32c.c (m32c_const_ok_for_constraint_p): Bit numbers\nstart at zero.\n(m32c_expand_insv): Fix test for an AND mask.\n\nFrom-SVN: r111937", "tree": {"sha": "83cf7a3d9a11cd477ff1cc9d1b1fca7886840b63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83cf7a3d9a11cd477ff1cc9d1b1fca7886840b63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e4edce73fe0d2001ed264da7af150f3d15f08af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4edce73fe0d2001ed264da7af150f3d15f08af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e4edce73fe0d2001ed264da7af150f3d15f08af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4edce73fe0d2001ed264da7af150f3d15f08af/comments", "author": null, "committer": null, "parents": [{"sha": "891c0eeed7c8b2b087f908bd845ab0bea7663b00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891c0eeed7c8b2b087f908bd845ab0bea7663b00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/891c0eeed7c8b2b087f908bd845ab0bea7663b00"}], "stats": {"total": 20, "additions": 15, "deletions": 5}, "files": [{"sha": "f7f45d2f9cb16080b114cd762542c2a3970fe90b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4edce73fe0d2001ed264da7af150f3d15f08af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4edce73fe0d2001ed264da7af150f3d15f08af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e4edce73fe0d2001ed264da7af150f3d15f08af", "patch": "@@ -1,3 +1,9 @@\n+2006-03-10  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/m32c.c (m32c_const_ok_for_constraint_p): Bit numbers\n+\tstart at zero.\n+\t(m32c_expand_insv): Fix test for an AND mask.\n+\n 2006-03-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/26565"}, {"sha": "0f7269b094e6ca057b8a68dadbcf72465d66e201", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4edce73fe0d2001ed264da7af150f3d15f08af/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4edce73fe0d2001ed264da7af150f3d15f08af/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=8e4edce73fe0d2001ed264da7af150f3d15f08af", "patch": "@@ -923,22 +923,22 @@ m32c_const_ok_for_constraint_p (HOST_WIDE_INT value,\n   if (memcmp (str, \"Ilb\", 3) == 0)\n     {\n       int b = exact_log2 (value);\n-      return (b >= 1 && b <= 8);\n+      return (b >= 0 && b <= 7);\n     }\n   if (memcmp (str, \"Imb\", 3) == 0)\n     {\n       int b = exact_log2 ((value ^ 0xff) & 0xff);\n-      return (b >= 1 && b <= 8);\n+      return (b >= 0 && b <= 7);\n     }\n   if (memcmp (str, \"Ilw\", 3) == 0)\n     {\n       int b = exact_log2 (value);\n-      return (b >= 1 && b <= 16);\n+      return (b >= 0 && b <= 15);\n     }\n   if (memcmp (str, \"Imw\", 3) == 0)\n     {\n       int b = exact_log2 ((value ^ 0xffff) & 0xffff);\n-      return (b >= 1 && b <= 16);\n+      return (b >= 0 && b <= 15);\n     }\n   if (memcmp (str, \"I00\", 3) == 0)\n     {\n@@ -3455,13 +3455,17 @@ m32c_expand_insv (rtx *operands)\n       mask >>= 8;\n     }\n \n-  if (INTVAL (operands[3]))\n+  /* First, we generate a mask with the correct polarity.  If we are\n+     storing a zero, we want an AND mask, so invert it.  */\n+  if (INTVAL (operands[3]) == 0)\n     {\n       if (GET_MODE (op0) == HImode)\n \tmask ^= 0xffff;\n       else\n \tmask ^= 0xff;\n     }\n+  /* Now we need to properly sign-extend the mask in case we need to\n+     fall back to an AND or OR opcode.  */\n   if (GET_MODE (op0) == HImode)\n     {\n       if (mask & 0x8000)"}]}