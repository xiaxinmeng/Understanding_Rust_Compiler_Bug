{"sha": "86ff185365dbc40b64f907be9e2f35d756776e20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmZjE4NTM2NWRiYzQwYjY0ZjkwN2JlOWUyZjM1ZDc1Njc3NmUyMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-12T18:50:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-12T18:50:16Z"}, "message": "re PR go/84215 (Random results in go/libgo tests)\n\n\tPR go/84215\n    runtime, sync/atomic: use write barrier for atomic pointer functions\n    \n    This copies atomic_pointer.go from 1.10rc2.  It was omitted during the\n    transition of the runtime from C to Go, and I forgot about it.\n    \n    This may help with https://gcc.gnu.org/PR84215.\n    \n    Reviewed-on: https://go-review.googlesource.com/93197\n\nFrom-SVN: r257599", "tree": {"sha": "578d5adc5ed91aadca2a5f5059f17c7211a8d514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/578d5adc5ed91aadca2a5f5059f17c7211a8d514"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86ff185365dbc40b64f907be9e2f35d756776e20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ff185365dbc40b64f907be9e2f35d756776e20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ff185365dbc40b64f907be9e2f35d756776e20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ff185365dbc40b64f907be9e2f35d756776e20/comments", "author": null, "committer": null, "parents": [{"sha": "966a140df68bf3e2d378fb9b68a8afb7d80b34d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/966a140df68bf3e2d378fb9b68a8afb7d80b34d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/966a140df68bf3e2d378fb9b68a8afb7d80b34d6"}], "stats": {"total": 121, "additions": 70, "deletions": 51}, "files": [{"sha": "e8a036f504a6ba964ca873f46c4bf6d56bac92b9", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ff185365dbc40b64f907be9e2f35d756776e20/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ff185365dbc40b64f907be9e2f35d756776e20/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=86ff185365dbc40b64f907be9e2f35d756776e20", "patch": "@@ -1,4 +1,4 @@\n-89105404f94005ffa8e2b08df78015dc9ac91362\n+cebdbf3f293f5b0f3120c009c47da0ceadc113cb\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b66ef5896db3009b01ae70b33bb0ec448da47f44", "filename": "libgo/go/runtime/atomic_pointer.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ff185365dbc40b64f907be9e2f35d756776e20/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ff185365dbc40b64f907be9e2f35d756776e20/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go?ref=86ff185365dbc40b64f907be9e2f35d756776e20", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+// These functions cannot have go:noescape annotations,\n+// because while ptr does not escape, new does.\n+// If new is marked as not escaping, the compiler will make incorrect\n+// escape analysis decisions about the pointer value being stored.\n+// Instead, these are wrappers around the actual atomics (casp1 and so on)\n+// that use noescape to convey which arguments do not escape.\n+\n+// atomicstorep performs *ptr = new atomically and invokes a write barrier.\n+//\n+//go:nosplit\n+func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {\n+\twritebarrierptr_prewrite((*uintptr)(ptr), uintptr(new))\n+\tatomic.StorepNoWB(noescape(ptr), new)\n+}\n+\n+//go:nosplit\n+func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n+\t// The write barrier is only necessary if the CAS succeeds,\n+\t// but since it needs to happen before the write becomes\n+\t// public, we have to do it conservatively all the time.\n+\twritebarrierptr_prewrite((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))\n+\treturn atomic.Casp1((*unsafe.Pointer)(noescape(unsafe.Pointer(ptr))), noescape(old), new)\n+}\n+\n+// Like above, but implement in terms of sync/atomic's uintptr operations.\n+// We cannot just call the runtime routines, because the race detector expects\n+// to be able to intercept the sync/atomic forms but not the runtime forms.\n+\n+//go:linkname sync_atomic_StoreUintptr sync_atomic.StoreUintptr\n+func sync_atomic_StoreUintptr(ptr *uintptr, new uintptr)\n+\n+//go:linkname sync_atomic_StorePointer sync_atomic.StorePointer\n+//go:nosplit\n+func sync_atomic_StorePointer(ptr *unsafe.Pointer, new unsafe.Pointer) {\n+\twritebarrierptr_prewrite((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))\n+\tsync_atomic_StoreUintptr((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))\n+}\n+\n+//go:linkname sync_atomic_SwapUintptr sync_atomic.SwapUintptr\n+func sync_atomic_SwapUintptr(ptr *uintptr, new uintptr) uintptr\n+\n+//go:linkname sync_atomic_SwapPointer sync_atomic.SwapPointer\n+//go:nosplit\n+func sync_atomic_SwapPointer(ptr *unsafe.Pointer, new unsafe.Pointer) unsafe.Pointer {\n+\twritebarrierptr_prewrite((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))\n+\told := unsafe.Pointer(sync_atomic_SwapUintptr((*uintptr)(noescape(unsafe.Pointer(ptr))), uintptr(new)))\n+\treturn old\n+}\n+\n+//go:linkname sync_atomic_CompareAndSwapUintptr sync_atomic.CompareAndSwapUintptr\n+func sync_atomic_CompareAndSwapUintptr(ptr *uintptr, old, new uintptr) bool\n+\n+//go:linkname sync_atomic_CompareAndSwapPointer sync_atomic.CompareAndSwapPointer\n+//go:nosplit\n+func sync_atomic_CompareAndSwapPointer(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n+\twritebarrierptr_prewrite((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))\n+\treturn sync_atomic_CompareAndSwapUintptr((*uintptr)(noescape(unsafe.Pointer(ptr))), uintptr(old), uintptr(new))\n+}"}, {"sha": "efb037399bfc802665abb0e2b7b16f94428cafba", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ff185365dbc40b64f907be9e2f35d756776e20/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ff185365dbc40b64f907be9e2f35d756776e20/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=86ff185365dbc40b64f907be9e2f35d756776e20", "patch": "@@ -5,7 +5,6 @@\n package runtime\n \n import (\n-\t\"runtime/internal/atomic\"\n \t\"runtime/internal/sys\"\n \t\"unsafe\"\n )\n@@ -307,15 +306,6 @@ func setSupportAES(v bool) {\n \tsupport_aes = v\n }\n \n-// Here for gccgo until we port atomic_pointer.go and mgc.go.\n-//go:nosplit\n-func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n-\tif !atomic.Casp1((*unsafe.Pointer)(noescape(unsafe.Pointer(ptr))), noescape(old), new) {\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n // Here for gccgo until we port lock_*.go.\n func lock(l *mutex)\n func unlock(l *mutex)\n@@ -347,12 +337,6 @@ func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer\n // Temporary for gccgo until we port mheap.go\n func setprofilebucket(p unsafe.Pointer, b *bucket)\n \n-// Temporary for gccgo until we port atomic_pointer.go.\n-//go:nosplit\n-func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {\n-\tatomic.StorepNoWB(noescape(ptr), new)\n-}\n-\n // Get signal trampoline, written in C.\n func getSigtramp() uintptr\n "}, {"sha": "07a43063b7c56cdabc26ba2327011b633dad8012", "filename": "libgo/go/sync/atomic/atomic.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ff185365dbc40b64f907be9e2f35d756776e20/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ff185365dbc40b64f907be9e2f35d756776e20/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c?ref=86ff185365dbc40b64f907be9e2f35d756776e20", "patch": "@@ -62,16 +62,6 @@ SwapUintptr (uintptr_t *addr, uintptr_t new)\n   return __atomic_exchange_n (addr, new, __ATOMIC_SEQ_CST);\n }\n \n-void *SwapPointer (void **, void *)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.SwapPointer\")\n-  __attribute__ ((no_split_stack));\n-\n-void *\n-SwapPointer (void **addr, void *new)\n-{\n-  return __atomic_exchange_n (addr, new, __ATOMIC_SEQ_CST);\n-}\n-\n _Bool CompareAndSwapInt32 (int32_t *, int32_t, int32_t)\n   __asm__ (GOSYM_PREFIX \"sync_atomic.CompareAndSwapInt32\")\n   __attribute__ ((no_split_stack));\n@@ -126,16 +116,6 @@ CompareAndSwapUintptr (uintptr_t *val, uintptr_t old, uintptr_t new)\n   return __sync_bool_compare_and_swap (val, old, new);\n }\n \n-_Bool CompareAndSwapPointer (void **, void *, void *)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.CompareAndSwapPointer\")\n-  __attribute__ ((no_split_stack));\n-\n-_Bool\n-CompareAndSwapPointer (void **val, void *old, void *new)\n-{\n-  return __sync_bool_compare_and_swap (val, old, new);\n-}\n-\n int32_t AddInt32 (int32_t *, int32_t)\n   __asm__ (GOSYM_PREFIX \"sync_atomic.AddInt32\")\n   __attribute__ ((no_split_stack));\n@@ -357,17 +337,3 @@ StoreUintptr (uintptr_t *addr, uintptr_t val)\n   while (! __sync_bool_compare_and_swap (addr, v, val))\n     v = *addr;\n }\n-\n-void StorePointer (void **addr, void *val)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.StorePointer\")\n-  __attribute__ ((no_split_stack));\n-\n-void\n-StorePointer (void **addr, void *val)\n-{\n-  void *v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, val))\n-    v = *addr;\n-}"}]}