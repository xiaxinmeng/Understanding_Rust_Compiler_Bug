{"sha": "009da78551c8191873a18dd26f5cdedbe9ccb20e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA5ZGE3ODU1MWM4MTkxODczYTE4ZGQyNmY1Y2RlZGJlOWNjYjIwZQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2001-11-02T02:18:37Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2001-11-02T02:18:37Z"}, "message": "config.gcc: Revert part of earlier patch.\n\n2001-11-01  Eric Christopher  <echristo@redhat.com>\n\n        * config.gcc: Revert part of earlier patch.\n        * config/mips/linux.h: Ditto.\n\t* df.c: Include tm_p.h to avoid warnings.\n        * config/mips/mips.h (ABI_GAS_ASM_SPEC): Add defaults.  Adjust\n\t#if/#endif.\n\t* config/mips/mips.c: Define mips_abi regardless.\n\t(mips_output_function_prologues): Add long casts for .frame\n\toutput.\n\t(override_options): Allow use of ABI_32.\n\nFrom-SVN: r46707", "tree": {"sha": "dc794b5a02209a6162dbb85797dbfca82c221c59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc794b5a02209a6162dbb85797dbfca82c221c59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/009da78551c8191873a18dd26f5cdedbe9ccb20e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009da78551c8191873a18dd26f5cdedbe9ccb20e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009da78551c8191873a18dd26f5cdedbe9ccb20e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009da78551c8191873a18dd26f5cdedbe9ccb20e/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9caea35c411e440b55c20ff5caafa40deb9de99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caea35c411e440b55c20ff5caafa40deb9de99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9caea35c411e440b55c20ff5caafa40deb9de99f"}], "stats": {"total": 435, "additions": 217, "deletions": 218}, "files": [{"sha": "571df09262ef2c88f41d2cff78f9de7015faaf7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=009da78551c8191873a18dd26f5cdedbe9ccb20e", "patch": "@@ -1,3 +1,15 @@\n+2001-11-01  Eric Christopher  <echristo@redhat.com>\n+\n+        * config.gcc: Revert part of earlier patch.\n+        * config/mips/linux.h: Ditto.\n+\t* df.c: Include tm_p.h to avoid warnings.\n+        * config/mips/mips.h (ABI_GAS_ASM_SPEC): Add defaults.  Adjust\n+\t#if/#endif.\n+\t* config/mips/mips.c: Define mips_abi regardless.\n+\t(mips_output_function_prologues): Add long casts for .frame\n+\toutput.\n+\t(override_options): Allow use of ABI_32.\n+\n 2001-11-01  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/m68hc11/m68hc11.c: Fix comment formatting."}, {"sha": "41e2217381b71d6515d6d8ed926410be31b5bf72", "filename": "gcc/config.gcc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=009da78551c8191873a18dd26f5cdedbe9ccb20e", "patch": "@@ -2261,17 +2261,17 @@ mipsel-*-netbsd* | mips-dec-netbsd*)    # Decstation running NetBSD\n \t;;\n mips*-*-linux*)\t\t\t\t# Linux MIPS, either endian.\n \txmake_file=x-linux\n+        tm_file=\"linux.h mips/linux.h\"\n \tcase $machine in\n-\t\tmipsisa32el-*)\n-\t\t\ttm_file=\"elfos.h mips/elfl.h mips/linux.h mips/isa32-linux.h\"\n-\t\t\ttarget_cpu_default=\"MASK_SOFT_FLOAT\"\n-\t\t\t;;\n-                mipsisa32-*)\n-\t\t\ttm_file=\"elfos.h mips/elf.h mips/linux.h mips/isa32-linux.h\"\n-\t\t\ttarget_cpu_default=\"MASK_SOFT_FLOAT\"\n-\t\t\t;;\n-\t       \tmips*el-*)  tm_file=\"elfos.h mips/elfl.h mips/linux.h\" ;;\n-\t\t*) tm_file=\"elfos.h mips/elf.h mips/linux.h\"\n+        mipsisa32*-*)\n+                tm_file=\"$tm_file mips/isa32-linux.h\"\n+                target_cpu_default=\"MASK_SOFT_FLOAT\"\n+                ;;\n+        esac\n+        case $machine in\n+        mips*el-*)\n+                tm_file=\"mips/little.h $tm_file\"\n+                ;;\n \tesac\n \ttmake_file=\"t-slibgcc-elf-ver t-linux\"\n \textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\""}, {"sha": "6caaf760ecdded3a70e9825bc4ce8e4749a60476", "filename": "gcc/config/mips/linux.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig%2Fmips%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig%2Fmips%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux.h?ref=009da78551c8191873a18dd26f5cdedbe9ccb20e", "patch": "@@ -23,6 +23,8 @@ Boston, MA 02111-1307, USA.  */\n /* US Software GOFAST library support.  */\n #define INIT_SUBTARGET_OPTABS INIT_GOFAST_OPTABS\n \n+#include \"mips/mips.h\"\n+\n #undef WCHAR_TYPE\n #define WCHAR_TYPE \"int\"\n "}, {"sha": "8fac84cffc120565c47f7d8bffdc429b8e55df77", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=009da78551c8191873a18dd26f5cdedbe9ccb20e", "patch": "@@ -224,11 +224,8 @@ enum processor_type mips_tune;\n /* which instruction set architecture to use.  */\n int mips_isa;\n \n-#ifdef MIPS_ABI_DEFAULT\n-/* Which ABI to use.  This is defined to a constant in mips.h if the target\n-   doesn't support multiple ABIs.  */\n+/* which abi to use.  */\n int mips_abi;\n-#endif\n \n /* Strings to hold which cpu and instruction set architecture to use.  */\n const char *mips_cpu_string;\t/* for -mcpu=<xxx> */\n@@ -4886,10 +4883,6 @@ override_options ()\n \t  || mips_abi == ABI_64))\n     target_flags |= MASK_LONG64;\n \n-  /* ??? This doesn't work yet, so don't let people try to use it.  */\n-  if (mips_abi == ABI_32)\n-    error (\"The -mabi=32 support does not work yet.\");\n-\n #else\n   if (mips_abi_string)\n     error (\"This target does not support the -mabi switch.\");\n@@ -7001,9 +6994,9 @@ mips_output_function_prologue (file, size)\n \t       (reg_names[(frame_pointer_needed)\n \t\t\t  ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n \t       ((frame_pointer_needed && TARGET_MIPS16)\n-\t\t? (tsize - current_function_outgoing_args_size)\n-\t\t: tsize),\n-\t       reg_names[31 + GP_REG_FIRST],\n+\t\t? ((long) tsize - current_function_outgoing_args_size)\n+\t\t: (long) tsize),\n+\t       reg_names[GP_REG_FIRST + 31],\n \t       current_frame_info.var_size,\n \t       current_frame_info.num_gp,\n \t       current_frame_info.num_fp,"}, {"sha": "565e6b6be81fca76854f32fd977923f990b0e7e3", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=009da78551c8191873a18dd26f5cdedbe9ccb20e", "patch": "@@ -99,15 +99,6 @@ enum processor_type {\n    with different names.  */\n #define ABI_MEABI 5\n \n-\n-#ifndef MIPS_ABI_DEFAULT\n-/* We define this away so that there is no extra runtime cost if the target\n-   doesn't support multiple ABIs.  */\n-#define mips_abi ABI_32\n-#else\n-extern int mips_abi;\n-#endif\n-\n /* Whether to emit abicalls code sequences or not.  */\n \n enum mips_abicalls_type {\n@@ -873,51 +864,51 @@ while (0)\n /* GAS_ASM_SPEC is passed when using gas, rather than the MIPS\n    assembler.  */\n \n-#define GAS_ASM_SPEC \"%{march=*} %{mtune=*} %{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v} %{mgp32} %{mgp64} %(abi_gas_asm_spec) %{mabi=32:%{!mips*:-mips2}}\"\n+#define GAS_ASM_SPEC \"%{march=*} %{mtune=*} %{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v} %{mgp32} %{mgp64} %(abi_gas_asm_spec) %{mabi=32:%{!mips*:-mips1}}\"\n+\n+\n+/* We use the o32 abi as default for mips1 and mips2.  SGI uses n32/n64 for\n+   mips3 and mips4 by default, however, this is unsupported at this point in\n+   binutils so we use o64. This should change when n32/n64 is supported.  */\n+\n+extern int mips_abi;\n \n #ifndef MIPS_ABI_DEFAULT\n-#define ABI_GAS_ASM_SPEC \"\\\n-%{mabi=*} \\\n-%{!mabi=*:%{mips1|mips2|mips32:-mabi=32} %{!mips1:%{!mips2:%{!mips32:-mabi=64}}}}\"\n+#define MIPS_ABI_DEFAULT ABI_32\n+#endif\n \n-#else\n #if MIPS_ABI_DEFAULT == ABI_32\n-#define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=32}\"\n+#define ABI_GAS_ASM_SPEC \"%{mabi=*} \\\n+%{!mabi=*:%{mips3|mips4|mips5|mips64:-mabi=o64} %{!mips3:%{!mips4:%{!mips5:%{!mips64:-mabi=32}}}}}\"\n+#endif\n \n-#else\n #if MIPS_ABI_DEFAULT == ABI_N32\n #define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=n32}\"\n+#endif\n \n-#else\n #if MIPS_ABI_DEFAULT == ABI_64\n #define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=64}\"\n+#endif\n \n-#else\n #if MIPS_ABI_DEFAULT == ABI_EABI\n #define ABI_GAS_ASM_SPEC \"%{mabi=*} %{!mabi=*:-mabi=eabi}\"\n+#endif\n \n-#else\n #if MIPS_ABI_DEFAULT == ABI_O64\n #define ABI_GAS_ASM_SPEC \"\\\n %{mabi=*} \\\n-%{!mabi=*:%{mips1|mips2|mips32:-mabi=32} %{!mips1:%{!mips2:%{!mips32:-mabi=o64}}}}\"\n+%{!mabi=*:%{mips1|mips2|mips32:-mabi=32} %{!mips1:%{!mips2:%{!mips3:%{!mips32:-mabi=o64}}}}}\"\n+#endif\n \n-#else\n #if MIPS_ABI_DEFAULT == ABI_MEABI\n #define ABI_GAS_ASM_SPEC \"\\\n %{mabi=*} \\\n %{!mabi=*:-mabi=meabi }\"\n+#endif\n \n-#else\n+#ifndef ABI_GAS_ASM_SPEC\n  #error \"Unhandled MIPS_ABI_DEFAULT\"\n #endif\n-#endif\n-#endif\n-#endif\n-#endif\n-#endif\n-#endif\n-\n \n /* TARGET_ASM_SPEC is used to select either MIPS_AS_ASM_SPEC or\n    GAS_ASM_SPEC as the default, depending upon the value of"}, {"sha": "a51a220dacb554b56c04c67815b99cf096bd08f0", "filename": "gcc/df.c", "status": "modified", "additions": 169, "deletions": 168, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009da78551c8191873a18dd26f5cdedbe9ccb20e/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=009da78551c8191873a18dd26f5cdedbe9ccb20e", "patch": "@@ -86,7 +86,7 @@ marks all the modified insns to get processed the next time df_analyse\n \n Beware that tinkering with insns may invalidate the dataflow information.\n The philosophy behind these routines is that once the dataflow\n-information has been gathered, the user should store what they require \n+information has been gathered, the user should store what they require\n before they tinker with any insn.  Once a reg is replaced, for example,\n then the reg-def/reg-use chains will point to the wrong place.  Once a\n whole lot of changes have been made, df_analyse can be called again\n@@ -107,7 +107,7 @@ while the insn-use lists contain all the refs used by an insn.\n \n Note that the reg-def and reg-use chains are generally short (except for the\n hard registers) and thus it is much faster to search these chains\n-rather than searching the def or use bitmaps.  \n+rather than searching the def or use bitmaps.\n \n If the insns are in SSA form then the reg-def and use-def lists\n should only contain the single defining ref.\n@@ -140,11 +140,11 @@ tell which ones have been changed.  Alternatively, we could\n periodically squeeze the def and use tables and associated bitmaps and\n renumber the def and use ids.\n \n-4) Ordering of reg-def and reg-use lists. \n+4) Ordering of reg-def and reg-use lists.\n \n Should the first entry in the def list be the first def (within a BB)?\n Similarly, should the first entry in the use list be the last use\n-(within a BB)? \n+(within a BB)?\n \n 5) Working with a sub-CFG.\n \n@@ -157,12 +157,13 @@ Perhaps there should be a bitmap argument to df_analyse to specify\n \n #include \"config.h\"\n #include \"system.h\"\n-#include \"rtl.h\" \n-#include \"insn-config.h\" \n-#include \"recog.h\" \n-#include \"function.h\" \n-#include \"regs.h\" \n-#include \"obstack.h\" \n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"function.h\"\n+#include \"regs.h\"\n+#include \"obstack.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"bitmap.h\"\n@@ -212,7 +213,7 @@ static void df_alloc PARAMS((struct df *, int));\n static rtx df_reg_clobber_gen PARAMS((unsigned int));\n static rtx df_reg_use_gen PARAMS((unsigned int));\n \n-static inline struct df_link *df_link_create PARAMS((struct ref *, \n+static inline struct df_link *df_link_create PARAMS((struct ref *,\n \t\t\t\t\t\t     struct df_link *));\n static struct df_link *df_ref_unlink PARAMS((struct df_link **, struct ref *));\n static void df_def_unlink PARAMS((struct df *, struct ref *));\n@@ -223,12 +224,12 @@ static void df_bb_refs_unlink PARAMS ((struct df *, basic_block));\n static void df_refs_unlink PARAMS ((struct df *, bitmap));\n #endif\n \n-static struct ref *df_ref_create PARAMS((struct df *, \n+static struct ref *df_ref_create PARAMS((struct df *,\n \t\t\t\t\t rtx, rtx *, basic_block, rtx,\n \t\t\t\t\t enum df_ref_type));\n-static void df_ref_record_1 PARAMS((struct df *, rtx, rtx *, \n+static void df_ref_record_1 PARAMS((struct df *, rtx, rtx *,\n \t\t\t\t    basic_block, rtx, enum df_ref_type));\n-static void df_ref_record PARAMS((struct df *, rtx, rtx *, \n+static void df_ref_record PARAMS((struct df *, rtx, rtx *,\n \t\t\t\t  basic_block bb, rtx, enum df_ref_type));\n static void df_def_record_1 PARAMS((struct df *, rtx, basic_block, rtx));\n static void df_defs_record PARAMS((struct df *, rtx, basic_block, rtx));\n@@ -311,11 +312,11 @@ df_insn_table_realloc (df, size)\n     size = df->insn_size / 4;\n \n   size += df->insn_size;\n-  \n+\n   df->insns = (struct insn_info *)\n     xrealloc (df->insns, size * sizeof (struct insn_info));\n-  \n-  memset (df->insns + df->insn_size, 0, \n+\n+  memset (df->insns + df->insn_size, 0,\n \t  (size - df->insn_size) * sizeof (struct insn_info));\n \n   df->insn_size = size;\n@@ -344,7 +345,7 @@ df_reg_table_realloc (df, size)\n     xrealloc (df->regs, size * sizeof (struct reg_info));\n \n   /* Zero the new entries.  */\n-  memset (df->regs + df->reg_size, 0, \n+  memset (df->regs + df->reg_size, 0,\n \t  (size - df->reg_size) * sizeof (struct reg_info));\n \n   df->reg_size = size;\n@@ -366,14 +367,14 @@ df_def_table_realloc (df, size)\n     size = df->def_size / 4;\n \n   df->def_size += size;\n-  df->defs = xrealloc (df->defs, \n+  df->defs = xrealloc (df->defs,\n \t\t       df->def_size * sizeof (*df->defs));\n \n   /* Allocate a new block of memory and link into list of blocks\n      that will need to be freed later.  */\n \n   refs = xmalloc (size * sizeof (*refs));\n-  \n+\n   /* Link all the new refs together, overloading the chain field.  */\n   for (i = 0; i < size - 1; i++)\n       refs[i].chain = (struct df_link *)(refs + i + 1);\n@@ -410,7 +411,7 @@ df_bitmaps_alloc (df, flags)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-      \n+\n       if (flags & DF_RD && ! bb_info->rd_in)\n \t{\n \t  /* Allocate bitmaps for reaching definitions.  */\n@@ -618,7 +619,7 @@ static rtx df_reg_use_gen (regno)\n \n   reg = regno >= FIRST_PSEUDO_REGISTER\n     ? regno_reg_rtx[regno] : gen_rtx_REG (reg_raw_mode[regno], regno);\n- \n+\n   use = gen_rtx_USE (GET_MODE (reg), reg);\n   return use;\n }\n@@ -648,7 +649,7 @@ df_link_create (ref, next)\n {\n   struct df_link *link;\n \n-  link = (struct df_link *) obstack_alloc (&df_ref_obstack, \n+  link = (struct df_link *) obstack_alloc (&df_ref_obstack,\n \t\t\t\t\t   sizeof (*link));\n   link->next = next;\n   link->ref = ref;\n@@ -721,7 +722,7 @@ df_ref_remove (df, ref)\n \n \n /* Unlink DEF from use-def and reg-def chains.  */\n-static void \n+static void\n df_def_unlink (df, def)\n      struct df *df ATTRIBUTE_UNUSED;\n      struct ref *def;\n@@ -747,7 +748,7 @@ df_def_unlink (df, def)\n \n \n /* Unlink use from def-use and reg-use chains.  */\n-static void \n+static void\n df_use_unlink (df, use)\n      struct df *df ATTRIBUTE_UNUSED;\n      struct ref *use;\n@@ -778,7 +779,7 @@ df_use_unlink (df, use)\n    LOC within INSN of BB.  */\n static struct ref *\n df_ref_create (df, reg, loc, bb, insn, ref_type)\n-     struct df *df;     \n+     struct df *df;\n      rtx reg;\n      rtx *loc;\n      basic_block bb;\n@@ -787,8 +788,8 @@ df_ref_create (df, reg, loc, bb, insn, ref_type)\n {\n   struct ref *this_ref;\n   unsigned int uid;\n-  \n-  this_ref = (struct ref *) obstack_alloc (&df_ref_obstack, \n+\n+  this_ref = (struct ref *) obstack_alloc (&df_ref_obstack,\n \t\t\t\t\t   sizeof (*this_ref));\n   DF_REF_REG (this_ref) = reg;\n   DF_REF_LOC (this_ref) = loc;\n@@ -804,7 +805,7 @@ df_ref_create (df, reg, loc, bb, insn, ref_type)\n \t{\n \t  /* Make table 25 percent larger.  */\n \t  df->def_size += (df->def_size / 4);\n-\t  df->defs = xrealloc (df->defs, \n+\t  df->defs = xrealloc (df->defs,\n \t\t\t       df->def_size * sizeof (*df->defs));\n \t}\n       DF_REF_ID (this_ref) = df->def_id;\n@@ -816,7 +817,7 @@ df_ref_create (df, reg, loc, bb, insn, ref_type)\n \t{\n \t  /* Make table 25 percent larger.  */\n \t  df->use_size += (df->use_size / 4);\n-\t  df->uses = xrealloc (df->uses, \n+\t  df->uses = xrealloc (df->uses,\n \t\t\t       df->use_size * sizeof (*df->uses));\n \t}\n       DF_REF_ID (this_ref) = df->use_id;\n@@ -876,7 +877,7 @@ df_ref_record (df, reg, loc, bb, insn, ref_type)\n     {\n       int i;\n       int endregno;\n-      \n+\n       if (! (df->flags & DF_HARD_REGS))\n \treturn;\n \n@@ -1018,7 +1019,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n       /* If we are clobbering a MEM, mark any registers inside the address\n \t as being used.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n-\tdf_uses_record (df, &XEXP (XEXP (x, 0), 0), \n+\tdf_uses_record (df, &XEXP (XEXP (x, 0), 0),\n \t\t\tDF_REF_REG_MEM_STORE, bb, insn);\n \n       /* If we're clobbering a REG then we have a def so ignore.  */\n@@ -1065,13 +1066,13 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \t   show the address as being used.  */\n \tif (GET_CODE (dst) == MEM)\n \t  {\n-\t    df_uses_record (df, &XEXP (dst, 0), \n+\t    df_uses_record (df, &XEXP (dst, 0),\n \t\t\t    DF_REF_REG_MEM_STORE,\n \t\t\t    bb, insn);\n \t    df_uses_record (df, &SET_SRC (x), DF_REF_REG_USE, bb, insn);\n \t    return;\n \t  }\n-\t    \n+\n #if 1 && defined(HANDLE_SUBREG)\n \t/* Look for sets that perform a read-modify-write.  */\n \twhile (GET_CODE (dst) == STRICT_LOW_PART\n@@ -1148,7 +1149,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \n \t   Consider for instance a volatile asm that changes the fpu rounding\n \t   mode.  An insn should not be moved across this even if it only uses\n-\t   pseudo-regs because it might give an incorrectly rounded result. \n+\t   pseudo-regs because it might give an incorrectly rounded result.\n \n \t   For now, just mark any regs we can find in ASM_OPERANDS as\n \t   used.  */\n@@ -1162,7 +1163,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \t    int j;\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n-\t      df_uses_record (df, &ASM_OPERANDS_INPUT (x, j), \n+\t      df_uses_record (df, &ASM_OPERANDS_INPUT (x, j),\n \t\t\t      DF_REF_REG_USE, bb, insn);\n \t    return;\n \t  }\n@@ -1188,7 +1189,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n   {\n     const char *fmt = GET_RTX_FORMAT (code);\n     int i;\n-    \n+\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n@@ -1243,12 +1244,12 @@ df_insn_refs_record (df, bb, insn)\n \t\t  break;\n \t      }\n \t  }\n-      \n+\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx note;\n \t  rtx x;\n-\t  \n+\n \t  /* Record the registers used to pass arguments.  */\n \t  for (note = CALL_INSN_FUNCTION_USAGE (insn); note;\n \t       note = XEXP (note, 1))\n@@ -1261,7 +1262,7 @@ df_insn_refs_record (df, bb, insn)\n \t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n \t  x = df_reg_use_gen (STACK_POINTER_REGNUM);\n \t  df_uses_record (df, &SET_DEST (x), DF_REF_REG_USE, bb, insn);\n-\t  \n+\n \t  if (df->flags & DF_HARD_REGS)\n \t    {\n \t      /* Calls may also reference any of the global registers,\n@@ -1275,11 +1276,11 @@ df_insn_refs_record (df, bb, insn)\n \t\t  }\n \t    }\n \t}\n-      \n+\n       /* Record the register uses.  */\n-      df_uses_record (df, &PATTERN (insn), \n+      df_uses_record (df, &PATTERN (insn),\n \t\t      DF_REF_REG_USE, bb, insn);\n-      \n+\n \n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n@@ -1295,7 +1296,7 @@ df_insn_refs_record (df, bb, insn)\n \t\t    df_defs_record (df, reg_clob, bb, insn);\n \t\t  }\n \t    }\n-\t  \n+\n \t  /* There may be extra registers to be clobbered.  */\n \t  for (note = CALL_INSN_FUNCTION_USAGE (insn);\n \t       note;\n@@ -1354,12 +1355,12 @@ df_bb_reg_def_chain_create (df, bb)\n      basic_block bb;\n {\n   rtx insn;\n-  \n+\n   /* Perhaps the defs should be sorted using a depth first search\n      of the CFG (or possibly a breadth first search).  We currently\n      scan the basic blocks in reverse order so that the first defs\n      apprear at the start of the chain.  */\n-  \n+\n   for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n        insn = PREV_INSN (insn))\n     {\n@@ -1368,12 +1369,12 @@ df_bb_reg_def_chain_create (df, bb)\n \n       if (! INSN_P (insn))\n \tcontinue;\n-      \n+\n       for (link = df->insns[uid].defs; link; link = link->next)\n \t{\n \t  struct ref *def = link->ref;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  \n+\n \t  df->regs[dregno].defs\n \t    = df_link_create (def, df->regs[dregno].defs);\n \t}\n@@ -1405,10 +1406,10 @@ df_bb_reg_use_chain_create (df, bb)\n      basic_block bb;\n {\n   rtx insn;\n-  \n+\n   /* Scan in forward order so that the last uses appear at the\n \t start of the chain.  */\n-  \n+\n   for (insn = bb->head; insn && insn != NEXT_INSN (bb->end);\n        insn = NEXT_INSN (insn))\n     {\n@@ -1417,12 +1418,12 @@ df_bb_reg_use_chain_create (df, bb)\n \n       if (! INSN_P (insn))\n \tcontinue;\n-      \n+\n       for (link = df->insns[uid].uses; link; link = link->next)\n \t{\n \t  struct ref *use = link->ref;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n-\t  \n+\n \t  df->regs[uregno].uses\n \t    = df_link_create (use, df->regs[uregno].uses);\n \t}\n@@ -1455,9 +1456,9 @@ df_bb_du_chain_create (df, bb, ru)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n-  \n+\n   bitmap_copy (ru, bb_info->ru_out);\n-  \n+\n   /* For each def in BB create a linked list (chain) of uses\n      reached from the def.  */\n   for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n@@ -1469,28 +1470,28 @@ df_bb_du_chain_create (df, bb, ru)\n \n       if (! INSN_P (insn))\n \tcontinue;\n-      \n+\n       /* For each def in insn...  */\n       for (def_link = df->insns[uid].defs; def_link; def_link = def_link->next)\n \t{\n \t  struct ref *def = def_link->ref;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  \n+\n \t  DF_REF_CHAIN (def) = 0;\n \n \t  /* While the reg-use chains are not essential, it\n \t     is _much_ faster to search these short lists rather\n \t     than all the reaching uses, especially for large functions.  */\n-\t  for (use_link = df->regs[dregno].uses; use_link; \n+\t  for (use_link = df->regs[dregno].uses; use_link;\n \t       use_link = use_link->next)\n \t    {\n \t      struct ref *use = use_link->ref;\n-\t      \n+\n \t      if (bitmap_bit_p (ru, DF_REF_ID (use)))\n \t\t{\n-\t\t  DF_REF_CHAIN (def) \n+\t\t  DF_REF_CHAIN (def)\n \t\t    = df_link_create (use, DF_REF_CHAIN (def));\n-\t\t  \n+\n \t\t  bitmap_clear_bit (ru, DF_REF_ID (use));\n \t\t}\n \t    }\n@@ -1536,9 +1537,9 @@ df_bb_ud_chain_create (df, bb)\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   struct ref **reg_def_last = df->reg_def_last;\n   rtx insn;\n-  \n+\n   memset (reg_def_last, 0, df->n_regs * sizeof (struct ref *));\n-  \n+\n   /* For each use in BB create a linked list (chain) of defs\n      that reach the use.  */\n   for (insn = bb->head; insn && insn != NEXT_INSN (bb->end);\n@@ -1551,12 +1552,12 @@ df_bb_ud_chain_create (df, bb)\n       if (! INSN_P (insn))\n \tcontinue;\n \n-      /* For each use in insn...  */      \n+      /* For each use in insn...  */\n       for (use_link = df->insns[uid].uses; use_link; use_link = use_link->next)\n \t{\n \t  struct ref *use = use_link->ref;\n \t  unsigned int regno = DF_REF_REGNO (use);\n-\t  \n+\n \t  DF_REF_CHAIN (use) = 0;\n \n \t  /* Has regno been defined in this BB yet?  If so, use\n@@ -1566,7 +1567,7 @@ df_bb_ud_chain_create (df, bb)\n \t     this BB.  */\n \t  if (reg_def_last[regno])\n \t    {\n-\t      DF_REF_CHAIN (use) \n+\t      DF_REF_CHAIN (use)\n \t\t= df_link_create (reg_def_last[regno], 0);\n \t    }\n \t  else\n@@ -1575,27 +1576,27 @@ df_bb_ud_chain_create (df, bb)\n \t\t _much_ faster to search these short lists rather than\n \t\t all the reaching defs, especially for large\n \t\t functions.  */\n-\t      for (def_link = df->regs[regno].defs; def_link; \n+\t      for (def_link = df->regs[regno].defs; def_link;\n \t\t   def_link = def_link->next)\n \t\t{\n \t\t  struct ref *def = def_link->ref;\n-\t      \n+\n \t\t  if (bitmap_bit_p (bb_info->rd_in, DF_REF_ID (def)))\n \t\t    {\n-\t\t      DF_REF_CHAIN (use) \n+\t\t      DF_REF_CHAIN (use)\n \t\t\t= df_link_create (def, DF_REF_CHAIN (use));\n \t\t    }\n \t\t}\n \t    }\n \t}\n-      \n+\n \n       /* For each def in insn...record the last def of each reg.  */\n       for (def_link = df->insns[uid].defs; def_link; def_link = def_link->next)\n \t{\n \t  struct ref *def = def_link->ref;\n \t  int dregno = DF_REF_REGNO (def);\n-\t  \n+\n \t  reg_def_last[dregno] = def;\n \t}\n     }\n@@ -1659,25 +1660,25 @@ df_rd_global_compute (df, blocks)\n   int i;\n   basic_block bb;\n   sbitmap worklist;\n-  \n+\n   worklist = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (worklist);\n \n   /* Copy the blocklist to the worklist */\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, \n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n   {\n     SET_BIT (worklist, i);\n   });\n-  \n+\n   /* We assume that only the basic blocks in WORKLIST have been\n      modified.  */\n   FOR_EACH_BB_IN_SBITMAP (worklist, 0, bb,\n     {\n       struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-      \n+\n       bitmap_copy (bb_info->rd_out, bb_info->rd_gen);\n     });\n-  \n+\n   while ((i = df_visit_next_rc (df, worklist)) >= 0)\n     {\n       struct bb_info *bb_info;\n@@ -1686,24 +1687,24 @@ df_rd_global_compute (df, blocks)\n \n       /* Remove this block from the worklist.  */\n       RESET_BIT (worklist, i);\n-      \n \n-      bb = BASIC_BLOCK (i);  \n+\n+      bb = BASIC_BLOCK (i);\n       bb_info = DF_BB_INFO (df, bb);\n \n       /* Calculate union of predecessor outs.  */\n       bitmap_zero (bb_info->rd_in);\n       for (e = bb->pred; e != 0; e = e->pred_next)\n \t{\n \t  struct bb_info *pred_refs = DF_BB_INFO (df, e->src);\n-\t  \n+\n \t  if (e->src == ENTRY_BLOCK_PTR)\n \t    continue;\n \n-\t  bitmap_a_or_b (bb_info->rd_in, bb_info->rd_in, \n+\t  bitmap_a_or_b (bb_info->rd_in, bb_info->rd_in,\n \t\t\t  pred_refs->rd_out);\n \t}\n-      \n+\n       /* RD_OUT is the set of defs that are live at the end of the\n \t BB.  These are the defs that are either generated by defs\n \t (RD_GEN) within the BB or are live at the start (RD_IN)\n@@ -1718,7 +1719,7 @@ df_rd_global_compute (df, blocks)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n-\t      \n+\n \t      SET_BIT (worklist, e->dest->index);\n \t    }\n \t}\n@@ -1740,8 +1741,8 @@ df_ru_global_compute (df, blocks)\n \n   worklist = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (worklist);\n-  \n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, \n+\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n   {\n     SET_BIT (worklist, i);\n   });\n@@ -1761,23 +1762,23 @@ df_ru_global_compute (df, blocks)\n       struct bb_info *bb_info;\n       edge e;\n       int changed;\n-      \n+\n       /* Remove this block from the worklist.  */\n       RESET_BIT (worklist, i);\n-      \n-      bb = BASIC_BLOCK (i);  \n+\n+      bb = BASIC_BLOCK (i);\n       bb_info = DF_BB_INFO (df, bb);\n \n       /* Calculate union of successor ins.  */\n       bitmap_zero (bb_info->ru_out);\n       for (e = bb->succ; e != 0; e = e->succ_next)\n \t{\n \t  struct bb_info *succ_refs = DF_BB_INFO (df, e->dest);\n-\t  \n+\n \t  if (e->dest == EXIT_BLOCK_PTR)\n \t    continue;\n-\t  \n-\t  bitmap_a_or_b (bb_info->ru_out, bb_info->ru_out, \n+\n+\t  bitmap_a_or_b (bb_info->ru_out, bb_info->ru_out,\n \t\t\t  succ_refs->ru_in);\n \t}\n \n@@ -1796,7 +1797,7 @@ df_ru_global_compute (df, blocks)\n \t      if (e->src == ENTRY_BLOCK_PTR)\n \t\tcontinue;\n \n-\t      SET_BIT (worklist, e->src->index);\t      \n+\t      SET_BIT (worklist, e->src->index);\n \t    }\n \t}\n     }\n@@ -1832,23 +1833,23 @@ df_lr_global_compute (df, blocks)\n       struct bb_info *bb_info = DF_BB_INFO (df, bb);\n       edge e;\n       int changed;\n-      \n+\n       /* Remove this block from the worklist.  */\n       bitmap_clear_bit (worklist, i);\n \n-      bb = BASIC_BLOCK (i);  \n+      bb = BASIC_BLOCK (i);\n       bb_info = DF_BB_INFO (df, bb);\n \n       /* Calculate union of successor ins.  */\n       bitmap_zero (bb_info->lr_out);\n       for (e = bb->succ; e != 0; e = e->succ_next)\n \t{\n \t  struct bb_info *succ_refs = DF_BB_INFO (df, e->dest);\n-\t  \n+\n \t  if (e->dest == EXIT_BLOCK_PTR)\n \t    continue;\n-\t  \n-\t  bitmap_a_or_b (bb_info->lr_out, bb_info->lr_out, \n+\n+\t  bitmap_a_or_b (bb_info->lr_out, bb_info->lr_out,\n \t\t\t  succ_refs->lr_in);\n \t}\n \n@@ -1883,7 +1884,7 @@ df_bb_rd_local_compute (df, bb)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n-  \n+\n   for (insn = bb->head; insn && insn != NEXT_INSN (bb->end);\n        insn = NEXT_INSN (insn))\n     {\n@@ -1892,14 +1893,14 @@ df_bb_rd_local_compute (df, bb)\n \n       if (! INSN_P (insn))\n \tcontinue;\n-      \n+\n       for (def_link = df->insns[uid].defs; def_link; def_link = def_link->next)\n \t{\n \t  struct ref *def = def_link->ref;\n \t  unsigned int regno = DF_REF_REGNO (def);\n \t  struct df_link *def2_link;\n \n-\t  for (def2_link = df->regs[regno].defs; def2_link; \n+\t  for (def2_link = df->regs[regno].defs; def2_link;\n \t       def2_link = def2_link->next)\n \t    {\n \t      struct ref *def2 = def2_link->ref;\n@@ -1909,15 +1910,15 @@ df_bb_rd_local_compute (df, bb)\n \t\t be killed by this BB but it keeps things a lot\n \t\t simpler.  */\n \t      bitmap_set_bit (bb_info->rd_kill, DF_REF_ID (def2));\n-\t      \n+\n \t      /* Zap from the set of gens for this BB.  */\n \t      bitmap_clear_bit (bb_info->rd_gen, DF_REF_ID (def2));\n \t    }\n \n \t  bitmap_set_bit (bb_info->rd_gen, DF_REF_ID (def));\n \t}\n     }\n-  \n+\n   bb_info->rd_valid = 1;\n }\n \n@@ -1960,13 +1961,13 @@ df_bb_ru_local_compute (df, bb)\n \n       if (! INSN_P (insn))\n \tcontinue;\n-      \n+\n       for (def_link = df->insns[uid].defs; def_link; def_link = def_link->next)\n \t{\n \t  struct ref *def = def_link->ref;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n \n-\t  for (use_link = df->regs[dregno].uses; use_link; \n+\t  for (use_link = df->regs[dregno].uses; use_link;\n \t       use_link = use_link->next)\n \t    {\n \t      struct ref *use = use_link->ref;\n@@ -1976,12 +1977,12 @@ df_bb_ru_local_compute (df, bb)\n \t\t be killed by this BB but it keeps things a lot\n \t\t simpler.  */\n \t      bitmap_set_bit (bb_info->ru_kill, DF_REF_ID (use));\n-\t      \n+\n \t      /* Zap from the set of gens for this BB.  */\n \t      bitmap_clear_bit (bb_info->ru_gen, DF_REF_ID (use));\n \t    }\n \t}\n-      \n+\n       for (use_link = df->insns[uid].uses; use_link; use_link = use_link->next)\n \t{\n \t  struct ref *use = use_link->ref;\n@@ -2017,7 +2018,7 @@ df_bb_lr_local_compute (df, bb)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n-  \n+\n   for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n        insn = PREV_INSN (insn))\n     {\n@@ -2026,18 +2027,18 @@ df_bb_lr_local_compute (df, bb)\n \n       if (! INSN_P (insn))\n \tcontinue;\n-      \n+\n       for (link = df->insns[uid].defs; link; link = link->next)\n \t{\n \t  struct ref *def = link->ref;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  \n+\n \t  /* Add def to set of defs in this BB.  */\n \t  bitmap_set_bit (bb_info->lr_def, dregno);\n-\t  \n+\n \t  bitmap_clear_bit (bb_info->lr_use, dregno);\n \t}\n-      \n+\n       for (link = df->insns[uid].uses; link; link = link->next)\n \t{\n \t  struct ref *use = link->ref;\n@@ -2075,42 +2076,42 @@ df_bb_reg_info_compute (df, bb, live)\n   struct reg_info *reg_info = df->regs;\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n-  \n+\n   bitmap_copy (live, bb_info->lr_out);\n-  \n+\n   for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n        insn = PREV_INSN (insn))\n     {\n       unsigned int uid = INSN_UID (insn);\n       unsigned int regno;\n       struct df_link *link;\n-      \n+\n       if (! INSN_P (insn))\n \tcontinue;\n-      \n+\n       for (link = df->insns[uid].defs; link; link = link->next)\n \t{\n \t  struct ref *def = link->ref;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  \n+\n \t  /* Kill this register.  */\n \t  bitmap_clear_bit (live, dregno);\n \t  reg_info[dregno].n_defs++;\n \t}\n-      \n+\n       for (link = df->insns[uid].uses; link; link = link->next)\n \t{\n \t  struct ref *use = link->ref;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n-\t  \n+\n \t  /* This register is now live.  */\n \t  bitmap_set_bit (live, uregno);\n \t  reg_info[uregno].n_uses++;\n \t}\n-      \n+\n       /* Increment lifetimes of all live registers.  */\n       EXECUTE_IF_SET_IN_BITMAP (live, 0, regno,\n-      { \n+      {\n \treg_info[regno].lifetime++;\n       });\n     }\n@@ -2256,7 +2257,7 @@ df_analyse_1 (df, blocks, flags, update)\n   df->dfs_order = xmalloc (sizeof(int) * n_basic_blocks);\n   df->rc_order = xmalloc (sizeof(int) * n_basic_blocks);\n   df->rts_order = xmalloc (sizeof(int) * n_basic_blocks);\n-  \n+\n   flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n   flow_reverse_top_sort_order_compute (df->rts_order);\n   if (aflags & DF_RD)\n@@ -2276,13 +2277,13 @@ df_analyse_1 (df, blocks, flags, update)\n       if (! (flags & DF_RD))\n \tdflags |= DF_RD;\n     }\n-     \n+\n   if (aflags & DF_RU)\n     {\n       /* Compute the sets of gens and kills for the upwards exposed\n \t uses in each bb.  */\n       df_ru_local_compute (df, df->flags & DF_RU ? blocks : df->all_blocks);\n-      \n+\n       /* Compute the global reaching uses.  */\n       df_ru_global_compute (df, df->all_blocks);\n     }\n@@ -2304,15 +2305,15 @@ df_analyse_1 (df, blocks, flags, update)\n     {\n       /* Compute the sets of defs and uses of live variables.  */\n       df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);\n-      \n+\n       /* Compute the global live variables.  */\n       df_lr_global_compute (df, df->all_blocks);\n     }\n \n   if (aflags & DF_REG_INFO)\n     {\n       df_reg_info_compute (df, df->all_blocks);\n-    } \n+    }\n   free (df->dfs_order);\n   free (df->rc_order);\n   free (df->rts_order);\n@@ -2329,7 +2330,7 @@ df_init ()\n \n   /* Squirrel away a global for debugging.  */\n   ddf = df;\n-  \n+\n   return df;\n }\n \n@@ -2380,7 +2381,7 @@ df_refs_process (df)\n \n \n /* Update refs for basic block BB.  */\n-static int \n+static int\n df_bb_refs_update (df, bb)\n      struct df *df;\n      basic_block bb;\n@@ -2403,12 +2404,12 @@ df_bb_refs_update (df, bb)\n \t{\n \t  /* Delete any allocated refs of this insn.  MPH,  FIXME.  */\n \t  df_insn_refs_unlink (df, bb, insn);\n-\t  \n+\n \t  /* Scan the insn for refs.  */\n \t  df_insn_refs_record (df, bb, insn);\n-\t  \n \n-\t  bitmap_clear_bit (df->insns_modified, uid);\t  \n+\n+\t  bitmap_clear_bit (df->insns_modified, uid);\n \t  count++;\n \t}\n       if (insn == bb->end)\n@@ -2529,7 +2530,7 @@ df_insn_refs_unlink (df, bb, insn)\n {\n   struct df_link *link;\n   unsigned int uid;\n-  \n+\n   uid = INSN_UID (insn);\n \n   /* Unlink all refs defined by this insn.  */\n@@ -2899,7 +2900,7 @@ df_bb_def_use_swap (df, bb, def_insn, use_insn, regno)\n }\n \n \n-/* Record df between FIRST_INSN and LAST_INSN inclusive.  All new \n+/* Record df between FIRST_INSN and LAST_INSN inclusive.  All new\n    insns must be processed by this routine.  */\n static void\n df_insns_modify (df, bb, first_insn, last_insn)\n@@ -2952,7 +2953,7 @@ df_pattern_emit_before (df, pattern, bb, insn)\n   ret_insn = emit_insn_before (pattern, insn);\n   if (ret_insn == insn)\n     return ret_insn;\n-  \n+\n   df_insns_modify (df, bb, NEXT_INSN (prev_insn), ret_insn);\n   return ret_insn;\n }\n@@ -3018,9 +3019,9 @@ df_insn_move_before (df, bb, insn, before_bb, before_insn)\n   uid = INSN_UID (insn);\n \n   /* Change bb for all df defined and used by this insn.  */\n-  for (link = df->insns[uid].defs; link; link = link->next)  \n+  for (link = df->insns[uid].defs; link; link = link->next)\n     DF_REF_BB (link->ref) = before_bb;\n-  for (link = df->insns[uid].uses; link; link = link->next)  \n+  for (link = df->insns[uid].uses; link; link = link->next)\n     DF_REF_BB (link->ref) = before_bb;\n \n   /* The lifetimes of the registers used in this insn will be reduced\n@@ -3048,10 +3049,10 @@ df_insn_regno_def_p (df, bb, insn, regno)\n \n   uid = INSN_UID (insn);\n \n-  for (link = df->insns[uid].defs; link; link = link->next)  \n+  for (link = df->insns[uid].defs; link; link = link->next)\n     {\n       struct ref *def = link->ref;\n-      \n+\n       if (DF_REF_REGNO (def) == regno)\n \treturn 1;\n     }\n@@ -3072,7 +3073,7 @@ df_def_dominates_all_uses_p (df, def)\n     {\n       struct ref *use = du_link->ref;\n       struct df_link *ud_link;\n-      \n+\n       /* Follow use-def chain to check all the defs for this use.  */\n       for (ud_link = DF_REF_CHAIN (use); ud_link; ud_link = ud_link->next)\n \tif (ud_link->ref != def)\n@@ -3093,10 +3094,10 @@ df_insn_dominates_all_uses_p (df, bb, insn)\n \n   uid = INSN_UID (insn);\n \n-  for (link = df->insns[uid].defs; link; link = link->next)  \n+  for (link = df->insns[uid].defs; link; link = link->next)\n     {\n       struct ref *def = link->ref;\n-      \n+\n       if (! df_def_dominates_all_uses_p (df, def))\n \treturn 0;\n     }\n@@ -3150,7 +3151,7 @@ df_insn_dominates_uses_p (df, bb, insn, blocks)\n \n   uid = INSN_UID (insn);\n \n-  for (link = df->insns[uid].defs; link; link = link->next)  \n+  for (link = df->insns[uid].defs; link; link = link->next)\n     {\n       struct ref *def = link->ref;\n \n@@ -3216,7 +3217,7 @@ df_bb_reg_live_start_p (df, bb, reg)\n   if (! bb_info->lr_in)\n     abort ();\n #endif\n-  \n+\n   return bitmap_bit_p (bb_info->lr_in, REGNO (reg));\n }\n \n@@ -3229,7 +3230,7 @@ df_bb_reg_live_end_p (df, bb, reg)\n      rtx reg;\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-  \n+\n #ifdef ENABLE_CHECKING\n   if (! bb_info->lr_in)\n     abort ();\n@@ -3255,7 +3256,7 @@ df_bb_regs_lives_compare (df, bb, reg1, reg2)\n   struct ref *def2;\n   struct ref *use2;\n \n- \n+\n   /* The regs must be local to BB.  */\n   if (df_regno_bb (df, regno1) != bb\n       || df_regno_bb (df, regno2) != bb)\n@@ -3292,7 +3293,7 @@ df_bb_regno_last_use_find (df, bb, regno)\n      BB, the last use is found first.  However, since the BBs are not\n      ordered, the first use in the chain is not necessarily the last\n      use in the function.  */\n-  for (link = df->regs[regno].uses; link; link = link->next)  \n+  for (link = df->regs[regno].uses; link; link = link->next)\n     {\n       struct ref *use = link->ref;\n \n@@ -3316,7 +3317,7 @@ df_bb_regno_first_def_find (df, bb, regno)\n      BB, the first def is found first.  However, since the BBs are not\n      ordered, the first def in the chain is not necessarily the first\n      def in the function.  */\n-  for (link = df->regs[regno].defs; link; link = link->next)  \n+  for (link = df->regs[regno].defs; link; link = link->next)\n     {\n       struct ref *def = link->ref;\n \n@@ -3340,7 +3341,7 @@ df_bb_insn_regno_last_use_find (df, bb, insn, regno)\n \n   uid = INSN_UID (insn);\n \n-  for (link = df->insns[uid].uses; link; link = link->next)  \n+  for (link = df->insns[uid].uses; link; link = link->next)\n     {\n       struct ref *use = link->ref;\n \n@@ -3365,7 +3366,7 @@ df_bb_insn_regno_first_def_find (df, bb, insn, regno)\n \n   uid = INSN_UID (insn);\n \n-  for (link = df->insns[uid].defs; link; link = link->next)  \n+  for (link = df->insns[uid].defs; link; link = link->next)\n     {\n       struct ref *def = link->ref;\n \n@@ -3409,7 +3410,7 @@ df_bb_single_def_use_insn_find (df, bb, insn, reg)\n   /* Check for multiple uses.  */\n   if (du_link->next)\n     return NULL_RTX;\n-  \n+\n   return DF_REF_INSN (use);\n }\n \f\n@@ -3470,9 +3471,9 @@ df_dump (df, flags, file)\n       fprintf (file, \"Reaching defs:\\n\");\n       for (i = 0; i < df->n_bbs; i++)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);  \n-\t  struct bb_info *bb_info = DF_BB_INFO (df, bb);      \n-\t  \n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  struct bb_info *bb_info = DF_BB_INFO (df, bb);\n+\n \t  if (! bb_info->rd_in)\n \t    continue;\n \n@@ -3510,9 +3511,9 @@ df_dump (df, flags, file)\n       fprintf (file, \"Reaching uses:\\n\");\n       for (i = 0; i < df->n_bbs; i++)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);  \n-\t  struct bb_info *bb_info = DF_BB_INFO (df, bb);      \n-\t  \n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  struct bb_info *bb_info = DF_BB_INFO (df, bb);\n+\n \t  if (! bb_info->ru_in)\n \t    continue;\n \n@@ -3550,9 +3551,9 @@ df_dump (df, flags, file)\n       fprintf (file, \"Live regs:\\n\");\n       for (i = 0; i < df->n_bbs; i++)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);  \n-\t  struct bb_info *bb_info = DF_BB_INFO (df, bb);      \n-\t  \n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  struct bb_info *bb_info = DF_BB_INFO (df, bb);\n+\n \t  if (! bb_info->lr_in)\n \t    continue;\n \n@@ -3574,7 +3575,7 @@ df_dump (df, flags, file)\n       fprintf (file, \"Register info:\\n\");\n       for (j = 0; j < df->n_regs; j++)\n \t{\n-\t  if (((flags & DF_REG_INFO) \n+\t  if (((flags & DF_REG_INFO)\n \t       && (reg_info[j].n_uses || reg_info[j].n_defs))\n \t      || ((flags & DF_RD_CHAIN) && reg_info[j].defs)\n \t      || ((flags & DF_RU_CHAIN) && reg_info[j].uses))\n@@ -3583,7 +3584,7 @@ df_dump (df, flags, file)\n \t    if ((flags & DF_RD_CHAIN) && (flags & DF_RU_CHAIN))\n \t      {\n \t\tbasic_block bb = df_regno_bb (df, j);\n-\t\t\n+\n \t\tif (bb)\n \t\t  fprintf (file, \" bb %d\", bb->index);\n \t\telse\n@@ -3697,23 +3698,23 @@ df_regno_debug (df, regno, file)\n static void\n df_ref_debug (df, ref, file)\n      struct df *df;\n-     struct ref *ref; \n+     struct ref *ref;\n      FILE *file;\n {\n   fprintf (file, \"%c%d \",\n \t   DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n \t   DF_REF_ID (ref));\n-  fprintf (file, \"reg %d bb %d luid %d insn %d chain \", \n+  fprintf (file, \"reg %d bb %d luid %d insn %d chain \",\n \t   DF_REF_REGNO (ref),\n-\t   DF_REF_BBNO (ref), \n+\t   DF_REF_BBNO (ref),\n \t   DF_INSN_LUID (df, DF_REF_INSN (ref)),\n \t   INSN_UID (DF_REF_INSN (ref)));\n   df_chain_dump (DF_REF_CHAIN (ref), file);\n   fprintf (file, \"\\n\");\n }\n \n \n-void \n+void\n debug_df_insn (insn)\n      rtx insn;\n {\n@@ -3722,47 +3723,47 @@ debug_df_insn (insn)\n }\n \n \n-void \n+void\n debug_df_reg (reg)\n      rtx reg;\n {\n   df_regno_debug (ddf, REGNO (reg), stderr);\n }\n \n \n-void \n+void\n debug_df_regno (regno)\n      unsigned int regno;\n {\n   df_regno_debug (ddf, regno, stderr);\n }\n \n \n-void \n+void\n debug_df_ref (ref)\n      struct ref *ref;\n {\n   df_ref_debug (ddf, ref, stderr);\n }\n \n \n-void \n+void\n debug_df_defno (defno)\n      unsigned int defno;\n {\n   df_ref_debug (ddf, ddf->defs[defno], stderr);\n }\n \n \n-void \n+void\n debug_df_useno (defno)\n      unsigned int defno;\n {\n   df_ref_debug (ddf, ddf->uses[defno], stderr);\n }\n \n \n-void \n+void\n debug_df_chain (link)\n      struct df_link *link;\n {"}]}