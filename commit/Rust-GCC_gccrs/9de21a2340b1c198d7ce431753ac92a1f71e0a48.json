{"sha": "9de21a2340b1c198d7ce431753ac92a1f71e0a48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlMjFhMjM0MGIxYzE5OGQ3Y2U0MzE3NTNhYzkyYTFmNzFlMGE0OA==", "commit": {"author": {"name": "Josh Conner", "email": "jconner@apple.com", "date": "2005-07-28T17:14:57Z"}, "committer": {"name": "Josh Conner", "email": "jconner@gcc.gnu.org", "date": "2005-07-28T17:14:57Z"}, "message": "ipa-inline.c (cgraph_edge_badness): Update comments.\n\n        * ipa-inline.c (cgraph_edge_badness): Update comments.  Invert shift\n        direction of badness if negative.\n        (cgraph_default_inline_p): Add reason to parameters, and assign it\n        a value.\n        (cgraph_decide_inlining_of_small_functions): New parameter in call\n        to cgraph_default_inline_p.\n        (cgraph_decide_inlining_incrementally): Likewise.\n        * cgraphunit.c (decide_is_function_needed): Likewise.\n        * cgraph.h (cgraph_default_inline_p): Likewise.\n\nFrom-SVN: r102497", "tree": {"sha": "ad9d93c4161ef8e99642c7ab70a87f2ea9c7c3ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad9d93c4161ef8e99642c7ab70a87f2ea9c7c3ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9de21a2340b1c198d7ce431753ac92a1f71e0a48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de21a2340b1c198d7ce431753ac92a1f71e0a48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de21a2340b1c198d7ce431753ac92a1f71e0a48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de21a2340b1c198d7ce431753ac92a1f71e0a48/comments", "author": null, "committer": null, "parents": [{"sha": "206048bd415aa4a985b6a2929b91bb86962f468f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/206048bd415aa4a985b6a2929b91bb86962f468f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/206048bd415aa4a985b6a2929b91bb86962f468f"}], "stats": {"total": 84, "additions": 60, "deletions": 24}, "files": [{"sha": "5b081e1118bbf6c2c2a58e91e97bc3557a1f0157", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9de21a2340b1c198d7ce431753ac92a1f71e0a48", "patch": "@@ -1,3 +1,15 @@\n+2005-07-28  Josh Conner  <jconner@apple.com>\n+\n+\t* ipa-inline.c (cgraph_edge_badness): Update comments.  Invert shift\n+\tdirection of badness if negative.\n+\t(cgraph_default_inline_p): Add reason to parameters, and assign it\n+\ta value.\n+\t(cgraph_decide_inlining_of_small_functions): New parameter in call\n+\tto cgraph_default_inline_p.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\t* cgraphunit.c (decide_is_function_needed): Likewise.\n+\t* cgraph.h (cgraph_default_inline_p): Likewise.\n+\n 2005-07-28  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* builtins.c: Fix comment typo(s)."}, {"sha": "4e2a4c17d9d39bb9823430e078e0c94db621eb03", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9de21a2340b1c198d7ce431753ac92a1f71e0a48", "patch": "@@ -287,5 +287,5 @@ int cgraph_postorder (struct cgraph_node **);\n bool cgraph_decide_inlining_incrementally (struct cgraph_node *, bool);\n void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool);\n void cgraph_mark_inline_edge (struct cgraph_edge *);\n-bool cgraph_default_inline_p (struct cgraph_node *);\n+bool cgraph_default_inline_p (struct cgraph_node *, const char **);\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "f8f864c11f811352326964df50b4eb2c36f4b41b", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9de21a2340b1c198d7ce431753ac92a1f71e0a48", "patch": "@@ -248,7 +248,7 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n \t  /* When declared inline, defer even the uninlinable functions.\n \t     This allows them to be eliminated when unused.  */\n \t  && !DECL_DECLARED_INLINE_P (decl) \n-\t  && (!node->local.inlinable || !cgraph_default_inline_p (node))))\n+\t  && (!node->local.inlinable || !cgraph_default_inline_p (node, NULL))))\n     return true;\n \n   return false;"}, {"sha": "0797e773c2a87ca92e9da3c1dbafcc18c8697e16", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de21a2340b1c198d7ce431753ac92a1f71e0a48/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9de21a2340b1c198d7ce431753ac92a1f71e0a48", "patch": "@@ -277,14 +277,42 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n /* Return true when function N is small enough to be inlined.  */\n \n bool\n-cgraph_default_inline_p (struct cgraph_node *n)\n+cgraph_default_inline_p (struct cgraph_node *n, const char **reason)\n {\n-  if (!DECL_INLINE (n->decl) || !DECL_SAVED_TREE (n->decl))\n-    return false;\n+  if (!DECL_INLINE (n->decl))\n+    {\n+      if (reason)\n+\t*reason = N_(\"function not inlinable\");\n+      return false;\n+    }\n+\n+  if (!DECL_SAVED_TREE (n->decl))\n+    {\n+      if (reason)\n+\t*reason = N_(\"function body not available\");\n+      return false;\n+    }\n+\n   if (DECL_DECLARED_INLINE_P (n->decl))\n-    return n->global.insns < MAX_INLINE_INSNS_SINGLE;\n+    {\n+      if (n->global.insns >= MAX_INLINE_INSNS_SINGLE)\n+\t{\n+\t  if (reason)\n+\t    *reason = N_(\"--param max-inline-insns-single limit reached\");\n+\t  return false;\n+\t}\n+    }\n   else\n-    return n->global.insns < MAX_INLINE_INSNS_AUTO;\n+    {\n+      if (n->global.insns >= MAX_INLINE_INSNS_AUTO)\n+\t{\n+\t  if (reason)\n+\t    *reason = N_(\"--param max-inline-insns-auto limit reached\");\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n }\n \n /* Return true when inlining WHAT would create recursive inlining.\n@@ -326,15 +354,9 @@ cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n    metrics may accurately depend on values such as number of inlinable callers\n    of the function or function body size.\n \n-   For the moment we use estimated growth caused by inlining callee into all\n-   it's callers for driving the inlining but once we have loop depth or\n-   frequency information readily available we should do better.\n-\n    With profiling we use number of executions of each edge to drive the cost.\n    We also should distinguish hot and cold calls where the cold calls are\n    inlined into only when code size is overall improved.  \n-   \n-   Value INT_MAX can be returned to prevent function from being inlined.\n    */\n \n static int\n@@ -355,8 +377,12 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n   {\n     int nest = MIN (edge->loop_nest, 8);\n     int badness = cgraph_estimate_growth (edge->callee) * 256;\n-\t\t    \n-    badness >>= nest;\n+\n+    /* Decrease badness if call is nested.  */\n+    if (badness > 0)    \n+      badness >>= nest;\n+    else\n+      badness <<= nest;\n \n     /* Make recursive inlining happen always after other inlining is done.  */\n     if (cgraph_recursive_inlining_p (edge->caller, edge->callee, NULL))\n@@ -609,6 +635,7 @@ cgraph_decide_inlining_of_small_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n+  const char *failed_reason;\n   fibheap_t heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n \n@@ -626,10 +653,9 @@ cgraph_decide_inlining_of_small_functions (void)\n \tfprintf (dump_file, \"Considering inline candidate %s.\\n\", cgraph_node_name (node));\n \n       node->global.estimated_growth = INT_MIN;\n-      if (!cgraph_default_inline_p (node))\n+      if (!cgraph_default_inline_p (node, &failed_reason))\n \t{\n-\t  cgraph_set_inline_failed (node,\n-\t    N_(\"--param max-inline-insns-single limit reached\"));\n+\t  cgraph_set_inline_failed (node, failed_reason);\n \t  continue;\n \t}\n \n@@ -708,13 +734,11 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    }\n \t  continue;\n \t}\n-      if (!cgraph_default_inline_p (edge->callee))\n+      if (!cgraph_default_inline_p (edge->callee, &edge->inline_failed))\n \t{\n           if (!cgraph_recursive_inlining_p (edge->caller, edge->callee,\n \t\t\t\t            &edge->inline_failed))\n \t    {\n-\t      edge->inline_failed = \n-\t\tN_(\"--param max-inline-insns-single limit reached after inlining into the callee\");\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" inline_failed:%s.\\n\", edge->inline_failed);\n \t    }\n@@ -954,6 +978,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n {\n   struct cgraph_edge *e;\n   bool inlined = false;\n+  const char *failed_reason;\n \n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n@@ -984,7 +1009,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed)\n \t  && DECL_SAVED_TREE (e->callee->decl))\n \t{\n-\t  if (cgraph_default_inline_p (e->callee))\n+\t  if (cgraph_default_inline_p (e->callee, &failed_reason))\n \t    {\n \t      if (dump_file && early)\n                 fprintf (dump_file, \"  Early inlining %s into %s\\n\",\n@@ -993,8 +1018,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t      inlined = true;\n \t    }\n \t  else if (!early)\n-\t    e->inline_failed\n-\t      = N_(\"--param max-inline-insns-single limit reached\");\n+\t    e->inline_failed = failed_reason;\n \t}\n   if (early && inlined)\n     {"}]}