{"sha": "ceaaf873e9392ac3f196c400afbc91f70a9dbce2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhYWY4NzNlOTM5MmFjM2YxOTZjNDAwYWZiYzkxZjcwYTlkYmNlMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-08-17T18:42:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-08-17T18:42:04Z"}, "message": "re PR c++/67104 (Constant expression factory function initializes std::array with static storage duration strangely)\n\n\tPR c++/67104\n\t* constexpr.c (array_index_cmp, find_array_ctor_elt): New.\n\t(cxx_eval_array_reference, cxx_eval_store_expression): Use them.\n\nFrom-SVN: r226949", "tree": {"sha": "acaa7ee4f2eeb48404725e4f841c018fe9a2ec9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acaa7ee4f2eeb48404725e4f841c018fe9a2ec9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceaaf873e9392ac3f196c400afbc91f70a9dbce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceaaf873e9392ac3f196c400afbc91f70a9dbce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceaaf873e9392ac3f196c400afbc91f70a9dbce2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceaaf873e9392ac3f196c400afbc91f70a9dbce2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c75ce5301b616b22f1c24f216eed8e84f9074469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75ce5301b616b22f1c24f216eed8e84f9074469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75ce5301b616b22f1c24f216eed8e84f9074469"}], "stats": {"total": 175, "additions": 129, "deletions": 46}, "files": [{"sha": "078ee74f9f772d5f743f4c3899777908916eda0a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaf873e9392ac3f196c400afbc91f70a9dbce2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaf873e9392ac3f196c400afbc91f70a9dbce2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ceaaf873e9392ac3f196c400afbc91f70a9dbce2", "patch": "@@ -1,5 +1,9 @@\n 2015-08-17  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/67104\n+\t* constexpr.c (array_index_cmp, find_array_ctor_elt): New.\n+\t(cxx_eval_array_reference, cxx_eval_store_expression): Use them.\n+\n \t* constexpr.c (cxx_eval_store_expression): Don't set\n \tCONSTRUCTOR_NO_IMPLICIT_ZERO if we have an enclosing CONSTRUCTOR\n \twithout it."}, {"sha": "1eacb8be9a441151fc25499a1705b9ee2a0d2ccc", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 125, "deletions": 46, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaf873e9392ac3f196c400afbc91f70a9dbce2/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaf873e9392ac3f196c400afbc91f70a9dbce2/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=ceaaf873e9392ac3f196c400afbc91f70a9dbce2", "patch": "@@ -1654,6 +1654,90 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t       jump_target);\n }\n \n+/* Returns less than, equal to, or greater than zero if KEY is found to be\n+   less than, to match, or to be greater than the constructor_elt's INDEX.  */\n+\n+static int\n+array_index_cmp (tree key, tree index)\n+{\n+  gcc_assert (TREE_CODE (key) == INTEGER_CST);\n+\n+  switch (TREE_CODE (index))\n+    {\n+    case INTEGER_CST:\n+      return tree_int_cst_compare (key, index);\n+    case RANGE_EXPR:\n+      {\n+\ttree lo = TREE_OPERAND (index, 0);\n+\ttree hi = TREE_OPERAND (index, 1);\n+\tif (tree_int_cst_lt (key, lo))\n+\t  return -1;\n+\telse if (tree_int_cst_lt (hi, key))\n+\t  return 1;\n+\telse\n+\t  return 0;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Returns the index of the constructor_elt of ARY which matches DINDEX, or -1\n+   if none.  If INSERT is true, insert a matching element rather than fail.  */\n+\n+static HOST_WIDE_INT\n+find_array_ctor_elt (tree ary, tree dindex, bool insert = false)\n+{\n+  if (tree_int_cst_sgn (dindex) < 0)\n+    return -1;\n+\n+  unsigned HOST_WIDE_INT i = tree_to_uhwi (dindex);\n+  vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ary);\n+  unsigned HOST_WIDE_INT len = vec_safe_length (elts);\n+\n+  unsigned HOST_WIDE_INT end = len;\n+  unsigned HOST_WIDE_INT begin = 0;\n+\n+  /* If the last element of the CONSTRUCTOR has its own index, we can assume\n+     that the same is true of the other elements and index directly.  */\n+  if (end > 0)\n+    {\n+      tree cindex = (*elts)[end-1].index;\n+      if (TREE_CODE (cindex) == INTEGER_CST\n+\t  && compare_tree_int (cindex, end-1) == 0)\n+\t{\n+\t  if (i < end)\n+\t    return i;\n+\t  else\n+\t    begin = end;\n+\t}\n+    }\n+\n+  /* Otherwise, find a matching index by means of a binary search.  */\n+  while (begin != end)\n+    {\n+      unsigned HOST_WIDE_INT middle = (begin + end) / 2;\n+\n+      int cmp = array_index_cmp (dindex, (*elts)[middle].index);\n+      if (cmp < 0)\n+\tend = middle;\n+      else if (cmp > 0)\n+\tbegin = middle + 1;\n+      else\n+\treturn middle;\n+    }\n+\n+  if (insert)\n+    {\n+      constructor_elt e = { dindex, NULL_TREE };\n+      vec_safe_insert (CONSTRUCTOR_ELTS (ary), end, e);\n+      return end;\n+    }\n+\n+  return -1;\n+}\n+\n+\n /* Subroutine of cxx_eval_constant_expression.\n    Attempt to reduce a reference to an array slot.  */\n \n@@ -1699,36 +1783,26 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n     }\n \n   i = tree_to_shwi (index);\n-  bool found = true;\n-  if (TREE_CODE (ary) == CONSTRUCTOR && len\n-      && (TREE_CODE (CONSTRUCTOR_ELT (ary, len-1)->index) == RANGE_EXPR\n-\t  || compare_tree_int (CONSTRUCTOR_ELT (ary, len-1)->index, len-1)))\n+  if (i < 0)\n     {\n-      /* The last element doesn't match its position in the array; this must be\n-\t a sparse array from cxx_eval_store_expression.  So iterate.  */\n-      found = false;\n-      vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (ary);\n-      constructor_elt *e;\n-      for (unsigned ix = 0; vec_safe_iterate (v, ix, &e); ++ix)\n-\t{\n-\t  if (TREE_CODE (e->index) == RANGE_EXPR)\n-\t    {\n-\t      tree lo = TREE_OPERAND (e->index, 0);\n-\t      tree hi = TREE_OPERAND (e->index, 1);\n-\t      if (tree_int_cst_le (lo, index) && tree_int_cst_le (index, hi))\n-\t\tfound = true;\n-\t    }\n-\t  else if (tree_int_cst_equal (e->index, index))\n-\t    found = true;\n-\t  if (found)\n-\t    {\n-\t      i = ix;\n-\t      break;\n-\t    }\n-\t}\n+      if (!ctx->quiet)\n+\terror (\"negative array subscript\");\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  bool found;\n+  if (TREE_CODE (ary) == CONSTRUCTOR)\n+    {\n+      HOST_WIDE_INT ix = find_array_ctor_elt (ary, index);\n+      found = (ix >= 0);\n+      if (found)\n+\ti = ix;\n     }\n+  else\n+    found = (i < len);\n \n-  if (i >= len || !found)\n+  if (!found)\n     {\n       if (tree_int_cst_lt (index, array_type_nelts_top (TREE_TYPE (ary))))\n \t{\n@@ -1757,13 +1831,6 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n       *non_constant_p = true;\n       return t;\n     }\n-  else if (i < 0)\n-    {\n-      if (!ctx->quiet)\n-\terror (\"negative array subscript\");\n-      *non_constant_p = true;\n-      return t;\n-    }\n \n   if (TREE_CODE (ary) == CONSTRUCTOR)\n     return (*CONSTRUCTOR_ELTS (ary))[i].value;\n@@ -2698,21 +2765,33 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t subobjects will also be zero-initialized.  */\n       no_zero_init = CONSTRUCTOR_NO_IMPLICIT_ZERO (*valp);\n \n-      constructor_elt ce;\n+      enum tree_code code = TREE_CODE (type);\n       type = refs->pop();\n-      ce.index = refs->pop();\n-      ce.value = NULL_TREE;\n+      tree index = refs->pop();\n \n-      unsigned HOST_WIDE_INT idx = 0;\n       constructor_elt *cep = NULL;\n-      for (idx = 0;\n-\t   vec_safe_iterate (CONSTRUCTOR_ELTS (*valp), idx, &cep);\n-\t   idx++)\n-\t/* ??? slow */\n-\tif (cp_tree_equal (ce.index, cep->index))\n-\t  break;\n-      if (!cep)\n-\tcep = vec_safe_push (CONSTRUCTOR_ELTS (*valp), ce);\n+      if (code == ARRAY_TYPE)\n+\t{\n+\t  HOST_WIDE_INT i\n+\t    = find_array_ctor_elt (*valp, index, /*insert*/true);\n+\t  gcc_assert (i >= 0);\n+\t  cep = CONSTRUCTOR_ELT (*valp, i);\n+\t  gcc_assert (TREE_CODE (cep->index) != RANGE_EXPR);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (index) == FIELD_DECL);\n+\t  for (unsigned HOST_WIDE_INT idx = 0;\n+\t       vec_safe_iterate (CONSTRUCTOR_ELTS (*valp), idx, &cep);\n+\t       idx++)\n+\t    if (index == cep->index)\n+\t      break;\n+\t  if (!cep)\n+\t    {\n+\t      constructor_elt ce = { index, NULL_TREE };\n+\t      cep = vec_safe_push (CONSTRUCTOR_ELTS (*valp), ce);\n+\t    }\n+\t}\n       valp = &cep->value;\n     }\n   release_tree_vector (refs);"}]}