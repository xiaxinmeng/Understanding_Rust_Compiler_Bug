{"sha": "476ca5ade8522d566ffffeab0bece6a64aefeecd", "node_id": "C_kwDOANBUbNoAKDQ3NmNhNWFkZTg1MjJkNTY2ZmZmZmVhYjBiZWNlNmE2NGFlZmVlY2Q", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-19T09:36:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-19T10:29:33Z"}, "message": "Compute negative offset in get_load_store_type\n\nThis moves the computation of a negative offset that needs to be\napplied when we vectorize a negative stride access to\nget_load_store_type alongside where we compute the actual access\nmethod.\n\n2021-10-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-stmts.c (get_negative_load_store_type): Add\n\toffset output parameter and initialize it.\n\t(get_group_load_store_type): Likewise.\n\t(get_load_store_type): Likewise.\n\t(vectorizable_store): Use offset as computed by\n\tget_load_store_type.\n\t(vectorizable_load): Likewise.", "tree": {"sha": "b967cab924460f0c7b542a7af9c872e4f76a2fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b967cab924460f0c7b542a7af9c872e4f76a2fb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/476ca5ade8522d566ffffeab0bece6a64aefeecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476ca5ade8522d566ffffeab0bece6a64aefeecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476ca5ade8522d566ffffeab0bece6a64aefeecd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476ca5ade8522d566ffffeab0bece6a64aefeecd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d996799a507f9f4c379b55b004233be92fa63380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d996799a507f9f4c379b55b004233be92fa63380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d996799a507f9f4c379b55b004233be92fa63380"}], "stats": {"total": 33, "additions": 21, "deletions": 12}, "files": [{"sha": "09a97b44c914fcb5d9f1afcd9215a01067fbccc9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ca5ade8522d566ffffeab0bece6a64aefeecd/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ca5ade8522d566ffffeab0bece6a64aefeecd/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=476ca5ade8522d566ffffeab0bece6a64aefeecd", "patch": "@@ -1967,13 +1967,14 @@ perm_mask_for_reverse (tree vectype)\n \n /* A subroutine of get_load_store_type, with a subset of the same\n    arguments.  Handle the case where STMT_INFO is a load or store that\n-   accesses consecutive elements with a negative step.  */\n+   accesses consecutive elements with a negative step.  Sets *POFFSET\n+   to the offset to be applied to the DR for the first access.  */\n \n static vect_memory_access_type\n get_negative_load_store_type (vec_info *vinfo,\n \t\t\t      stmt_vec_info stmt_info, tree vectype,\n \t\t\t      vec_load_store_type vls_type,\n-\t\t\t      unsigned int ncopies)\n+\t\t\t      unsigned int ncopies, poly_int64 *poffset)\n {\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n   dr_alignment_support alignment_support_scheme;\n@@ -2003,6 +2004,7 @@ get_negative_load_store_type (vec_info *vinfo,\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"negative step with invariant source;\"\n \t\t\t \" no permute needed.\\n\");\n+      *poffset = -TYPE_VECTOR_SUBPARTS (vectype) + 1;\n       return VMAT_CONTIGUOUS_DOWN;\n     }\n \n@@ -2014,6 +2016,7 @@ get_negative_load_store_type (vec_info *vinfo,\n       return VMAT_ELEMENTWISE;\n     }\n \n+  *poffset = -TYPE_VECTOR_SUBPARTS (vectype) + 1;\n   return VMAT_CONTIGUOUS_REVERSE;\n }\n \n@@ -2108,6 +2111,7 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t\t   tree vectype, slp_tree slp_node,\n \t\t\t   bool masked_p, vec_load_store_type vls_type,\n \t\t\t   vect_memory_access_type *memory_access_type,\n+\t\t\t   poly_int64 *poffset,\n \t\t\t   dr_alignment_support *alignment_support_scheme,\n \t\t\t   int *misalignment,\n \t\t\t   gather_scatter_info *gs_info)\n@@ -2210,7 +2214,7 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t/* ???  The VMAT_CONTIGUOUS_REVERSE code generation is\n \t\t   only correct for single element \"interleaving\" SLP.  */\n \t\t*memory_access_type = get_negative_load_store_type\n-\t\t\t\t       (vinfo, stmt_info, vectype, vls_type, 1);\n+\t\t\t     (vinfo, stmt_info, vectype, vls_type, 1, poffset);\n \t      else\n \t\t{\n \t\t  /* Try to use consecutive accesses of DR_GROUP_SIZE elements,\n@@ -2359,13 +2363,15 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t\t     bool masked_p, vec_load_store_type vls_type,\n \t\t     unsigned int ncopies,\n \t\t     vect_memory_access_type *memory_access_type,\n+\t\t     poly_int64 *poffset,\n \t\t     dr_alignment_support *alignment_support_scheme,\n \t\t     int *misalignment,\n \t\t     gather_scatter_info *gs_info)\n {\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   *misalignment = DR_MISALIGNMENT_UNKNOWN;\n+  *poffset = 0;\n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       *memory_access_type = VMAT_GATHER_SCATTER;\n@@ -2412,7 +2418,7 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n     {\n       if (!get_group_load_store_type (vinfo, stmt_info, vectype, slp_node,\n \t\t\t\t      masked_p,\n-\t\t\t\t      vls_type, memory_access_type,\n+\t\t\t\t      vls_type, memory_access_type, poffset,\n \t\t\t\t      alignment_support_scheme,\n \t\t\t\t      misalignment, gs_info))\n \treturn false;\n@@ -2444,7 +2450,7 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t{\n \t  if (cmp < 0)\n \t    *memory_access_type = get_negative_load_store_type\n-\t       (vinfo, stmt_info, vectype, vls_type, ncopies);\n+\t       (vinfo, stmt_info, vectype, vls_type, ncopies, poffset);\n \t  else\n \t    *memory_access_type = VMAT_CONTIGUOUS;\n \t  *alignment_support_scheme\n@@ -7242,7 +7248,6 @@ vectorizable_store (vec_info *vinfo,\n   unsigned int group_size, i;\n   vec<tree> oprnds = vNULL;\n   vec<tree> result_chain = vNULL;\n-  tree offset = NULL_TREE;\n   vec<tree> vec_oprnds = vNULL;\n   bool slp = (slp_node != NULL);\n   unsigned int vec_num;\n@@ -7352,8 +7357,9 @@ vectorizable_store (vec_info *vinfo,\n   vect_memory_access_type memory_access_type;\n   enum dr_alignment_support alignment_support_scheme;\n   int misalignment;\n+  poly_int64 poffset;\n   if (!get_load_store_type (vinfo, stmt_info, vectype, slp_node, mask, vls_type,\n-\t\t\t    ncopies, &memory_access_type,\n+\t\t\t    ncopies, &memory_access_type, &poffset,\n \t\t\t    &alignment_support_scheme, &misalignment, &gs_info))\n     return false;\n \n@@ -7941,9 +7947,9 @@ vectorizable_store (vec_info *vinfo,\n \t      || alignment_support_scheme == dr_aligned\n \t      || alignment_support_scheme == dr_unaligned_supported);\n \n-  if (memory_access_type == VMAT_CONTIGUOUS_DOWN\n-      || memory_access_type == VMAT_CONTIGUOUS_REVERSE)\n-    offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n+  tree offset = NULL_TREE;\n+  if (!known_eq (poffset, 0))\n+    offset = size_int (poffset);\n \n   tree bump;\n   tree vec_offset = NULL_TREE;\n@@ -8498,7 +8504,6 @@ vectorizable_load (vec_info *vinfo,\n   unsigned int group_size;\n   poly_uint64 group_gap_adj;\n   tree msq = NULL_TREE, lsq;\n-  tree offset = NULL_TREE;\n   tree byte_offset = NULL_TREE;\n   tree realignment_token = NULL_TREE;\n   gphi *phi = NULL;\n@@ -8708,8 +8713,9 @@ vectorizable_load (vec_info *vinfo,\n   vect_memory_access_type memory_access_type;\n   enum dr_alignment_support alignment_support_scheme;\n   int misalignment;\n+  poly_int64 poffset;\n   if (!get_load_store_type (vinfo, stmt_info, vectype, slp_node, mask, VLS_LOAD,\n-\t\t\t    ncopies, &memory_access_type,\n+\t\t\t    ncopies, &memory_access_type, &poffset,\n \t\t\t    &alignment_support_scheme, &misalignment, &gs_info))\n     return false;\n \n@@ -9293,6 +9299,9 @@ vectorizable_load (vec_info *vinfo,\n   else\n     at_loop = loop;\n \n+  tree offset = NULL_TREE;\n+  if (!known_eq (poffset, 0))\n+    offset = size_int (poffset);\n   if (memory_access_type == VMAT_CONTIGUOUS_REVERSE)\n     offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n "}]}