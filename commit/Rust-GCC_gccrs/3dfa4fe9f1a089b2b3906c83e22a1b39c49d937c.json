{"sha": "3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RmYTRmZTlmMWEwODliMmIzOTA2YzgzZTIyYTFiMzljNDlkOTM3Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-08T13:10:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-17T07:52:07Z"}, "message": "Vectorization of BB reductions\n\nThis adds a simple reduction vectorization capability to the\nnon-loop vectorizer.  Simple meaning it lacks any of the fancy\nways to generate the reduction epilogue but only supports\nthose we can handle via a direct internal function reducing\na vector to a scalar.  One of the main reasons is to avoid\nmassive refactoring at this point but also that more complex\nepilogue operations are hardly profitable.\n\nMixed sign reductions are for now fend off and I'm not finally\nsettled with whether we want an explicit SLP node for the\nreduction epilogue operation.  Handling mixed signs could be\ndone by multiplying with a { 1, -1, .. } vector.  Fend off\nare also reductions with non-internal operands (constants\nor register parameters for example).\n\nCosting is done by accounting the original scalar participating\nstmts for the scalar cost and log2 permutes and operations for\nthe vectorized epilogue.\n\n--\n\nSPEC CPU 2017 FP with rate workload measurements show (picked\nfastest runs of three) regressions for 507.cactuBSSN_r (1.5%),\n508.namd_r (2.5%), 511.povray_r (2.5%), 526.blender_r (0.5) and\n527.cam4_r (2.5%) and improvements for 510.parest_r (5%) and\n538.imagick_r (1.5%).  This is with -Ofast -march=znver2 on a Zen2.\n\nStatistics on CPU 2017 shows that the overwhelming number of seeds\nwe find are reductions of two lanes (well - that's basically every\nassociative operation).  That means we put a quite high pressure\non the SLP discovery process this way.\n\nIn total we find 583218 seeds we put to SLP discovery out of which\n66205 pass that and only 6185 of those make it through\ncode generation checks. 796 of those are discarded because the reduction\nis part of a larger SLP instance.  4195 of the remaining\nare deemed not profitable to vectorize and 1194 are finally\nvectorized.  That's a poor 0.2% rate.\n\nOf the 583218 seeds 486826 (83%) have two lanes, 60912 have three (10%),\n28181 four (5%), 4808 five, 909 six and there are instances up to 120\nlanes.\n\nThere's a set of 54086 candidate seeds we reject because\nthey contain a constant or invariant (not implemented yet) but still\nhave two or more lanes that could be put to SLP discovery.\n\n2021-06-16  Richard Biener   <rguenther@suse.de>\n\n\tPR tree-optimization/54400\n\t* tree-vectorizer.h (enum slp_instance_kind): Add\n\tslp_inst_kind_bb_reduc.\n\t(reduction_fn_for_scalar_code): Declare.\n\t* tree-vect-data-refs.c (vect_slp_analyze_instance_dependence):\n\tCheck SLP_INSTANCE_KIND instead of looking at the\n\trepresentative.\n\t(vect_slp_analyze_instance_alignment): Likewise.\n\t* tree-vect-loop.c (reduction_fn_for_scalar_code): Export.\n\t* tree-vect-slp.c (vect_slp_linearize_chain): Split out\n\tchain linearization from vect_build_slp_tree_2 and generalize\n\tfor the use of BB reduction vectorization.\n\t(vect_build_slp_tree_2): Adjust accordingly.\n\t(vect_optimize_slp): Elide permutes at the root of BB reduction\n\tinstances.\n\t(vectorizable_bb_reduc_epilogue): New function.\n\t(vect_slp_prune_covered_roots): Likewise.\n\t(vect_slp_analyze_operations): Use them.\n\t(vect_slp_check_for_constructors): Recognize associatable\n\tchains for BB reduction vectorization.\n\t(vectorize_slp_instance_root_stmt): Generate code for the\n\tBB reduction epilogue.\n\n\t* gcc.dg/vect/bb-slp-pr54400.c: New testcase.", "tree": {"sha": "1621c34f9af6bee6b2a4cb47b03a30754e75b5f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1621c34f9af6bee6b2a4cb47b03a30754e75b5f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f12bd79c0bd162cdbfab528f2e8dac43fb53d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f12bd79c0bd162cdbfab528f2e8dac43fb53d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f12bd79c0bd162cdbfab528f2e8dac43fb53d68"}], "stats": {"total": 439, "additions": 367, "deletions": 72}, "files": [{"sha": "6b427aac774a0523c8ad85cf958f9c6b5c00aa9b", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr54400.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr54400.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr54400.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr54400.c?ref=3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_float} */\n+/* { dg-additional-options \"-w -Wno-psabi -ffast-math\" } */\n+\n+#include \"tree-vect.h\"\n+\n+typedef float v4sf __attribute__((vector_size(sizeof(float)*4)));\n+\n+float __attribute__((noipa))\n+f(v4sf v)\n+{\n+  return v[0]+v[1]+v[2]+v[3];\n+}\n+\n+float __attribute__((noipa))\n+g(float *v)\n+{\n+  return v[0]+v[1]+v[2]+v[3];\n+}\n+\n+float __attribute__((noipa))\n+h(float *v)\n+{\n+  return 2*v[0]+3*v[1]+4*v[2]+5*v[3];\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  v4sf v = (v4sf) { 1.f, 3.f, 4.f, 2.f };\n+  if (f (v) != 10.f)\n+    abort ();\n+  if (g (&v[0]) != 10.f)\n+    abort ();\n+  if (h (&v[0]) != 37.f)\n+    abort ();\n+  return 0;\n+}\n+\n+/* We are lacking an effective target for .REDUC_PLUS support.  */\n+/* { dg-final { scan-tree-dump-times \"basic block part vectorized\" 3 \"slp2\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump-not \" = VEC_PERM_EXPR\" \"slp2\" { target x86_64-*-* } } } */"}, {"sha": "bb086c6ac1c98d8bb3256bb579a3f97256abc00b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "patch": "@@ -843,9 +843,9 @@ vect_slp_analyze_instance_dependence (vec_info *vinfo, slp_instance instance)\n   DUMP_VECT_SCOPE (\"vect_slp_analyze_instance_dependence\");\n \n   /* The stores of this instance are at the root of the SLP tree.  */\n-  slp_tree store = SLP_INSTANCE_TREE (instance);\n-  if (! STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (store)))\n-    store = NULL;\n+  slp_tree store = NULL;\n+  if (SLP_INSTANCE_KIND (instance) == slp_inst_kind_store)\n+    store = SLP_INSTANCE_TREE (instance);\n \n   /* Verify we can sink stores to the vectorized stmt insert location.  */\n   stmt_vec_info last_store_info = NULL;\n@@ -2464,8 +2464,7 @@ vect_slp_analyze_instance_alignment (vec_info *vinfo,\n     if (! vect_slp_analyze_node_alignment (vinfo, node))\n       return false;\n \n-  node = SLP_INSTANCE_TREE (instance);\n-  if (STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (node))\n+  if (SLP_INSTANCE_KIND (instance) == slp_inst_kind_store\n       && ! vect_slp_analyze_node_alignment\n \t     (vinfo, SLP_INSTANCE_TREE (instance)))\n     return false;"}, {"sha": "51a46a6d852fb342278bb9513d013702cff4b868", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "patch": "@@ -3209,7 +3209,7 @@ fold_left_reduction_fn (tree_code code, internal_fn *reduc_fn)\n \n    Return FALSE if CODE currently cannot be vectorized as reduction.  */\n \n-static bool\n+bool\n reduction_fn_for_scalar_code (enum tree_code code, internal_fn *reduc_fn)\n {\n   switch (code)"}, {"sha": "0c1f85beeb2e9f3fb7c66c15d4d30594b2570f9e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 317, "deletions": 66, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "patch": "@@ -1442,6 +1442,84 @@ dt_sort_cmp (const void *op1_, const void *op2_, void *)\n   return (int)op1->code - (int)op2->code;\n }\n \n+/* Linearize the associatable expression chain at START with the\n+   associatable operation CODE (where PLUS_EXPR also allows MINUS_EXPR),\n+   filling CHAIN with the result and using WORKLIST as intermediate storage.\n+   CODE_STMT and ALT_CODE_STMT are filled with the first stmt using CODE\n+   or MINUS_EXPR.  *CHAIN_STMTS if not NULL is filled with all computation\n+   stmts, starting with START.  */\n+\n+static void\n+vect_slp_linearize_chain (vec_info *vinfo,\n+\t\t\t  vec<std::pair<tree_code, gimple *> > &worklist,\n+\t\t\t  vec<chain_op_t> &chain,\n+\t\t\t  enum tree_code code, gimple *start,\n+\t\t\t  gimple *&code_stmt, gimple *&alt_code_stmt,\n+\t\t\t  vec<gimple *> *chain_stmts)\n+{\n+  /* For each lane linearize the addition/subtraction (or other\n+     uniform associatable operation) expression tree.  */\n+  worklist.safe_push (std::make_pair (code, start));\n+  while (!worklist.is_empty ())\n+    {\n+      auto entry = worklist.pop ();\n+      gassign *stmt = as_a <gassign *> (entry.second);\n+      enum tree_code in_code = entry.first;\n+      enum tree_code this_code = gimple_assign_rhs_code (stmt);\n+      /* Pick some stmts suitable for SLP_TREE_REPRESENTATIVE.  */\n+      if (!code_stmt\n+\t  && gimple_assign_rhs_code (stmt) == code)\n+\tcode_stmt = stmt;\n+      else if (!alt_code_stmt\n+\t       && gimple_assign_rhs_code (stmt) == MINUS_EXPR)\n+\talt_code_stmt = stmt;\n+      if (chain_stmts)\n+\tchain_stmts->safe_push (stmt);\n+      for (unsigned opnum = 1; opnum <= 2; ++opnum)\n+\t{\n+\t  tree op = gimple_op (stmt, opnum);\n+\t  vect_def_type dt;\n+\t  stmt_vec_info def_stmt_info;\n+\t  bool res = vect_is_simple_use (op, vinfo, &dt, &def_stmt_info);\n+\t  gcc_assert (res);\n+\t  if (dt == vect_internal_def)\n+\t    {\n+\t      stmt_vec_info orig_def_stmt_info = def_stmt_info;\n+\t      def_stmt_info = vect_stmt_to_vectorize (def_stmt_info);\n+\t      if (def_stmt_info != orig_def_stmt_info)\n+\t\top = gimple_get_lhs (def_stmt_info->stmt);\n+\t    }\n+\t  gimple *use_stmt;\n+\t  use_operand_p use_p;\n+\t  if (dt == vect_internal_def\n+\t      && single_imm_use (op, &use_p, &use_stmt)\n+\t      && is_gimple_assign (def_stmt_info->stmt)\n+\t      && (gimple_assign_rhs_code (def_stmt_info->stmt) == code\n+\t\t  || (code == PLUS_EXPR\n+\t\t      && (gimple_assign_rhs_code (def_stmt_info->stmt)\n+\t\t\t  == MINUS_EXPR))))\n+\t    {\n+\t      tree_code op_def_code = this_code;\n+\t      if (op_def_code == MINUS_EXPR && opnum == 1)\n+\t\top_def_code = PLUS_EXPR;\n+\t      if (in_code == MINUS_EXPR)\n+\t\top_def_code = op_def_code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n+\t      worklist.safe_push (std::make_pair (op_def_code,\n+\t\t\t\t\t\t  def_stmt_info->stmt));\n+\t    }\n+\t  else\n+\t    {\n+\t      tree_code op_def_code = this_code;\n+\t      if (op_def_code == MINUS_EXPR && opnum == 1)\n+\t\top_def_code = PLUS_EXPR;\n+\t      if (in_code == MINUS_EXPR)\n+\t\top_def_code = op_def_code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n+\t      chain.safe_push (chain_op_t (op_def_code, dt, op));\n+\t    }\n+\t}\n+    }\n+}\n+\n typedef hash_map <vec <stmt_vec_info>, slp_tree,\n \t\t  simple_hashmap_traits <bst_traits, slp_tree> >\n   scalar_stmts_to_slp_tree_map_t;\n@@ -1784,63 +1862,14 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t{\n \t  /* For each lane linearize the addition/subtraction (or other\n \t     uniform associatable operation) expression tree.  */\n-\t  worklist.safe_push (std::make_pair (code, stmts[lane]->stmt));\n-\t  while (!worklist.is_empty ())\n-\t    {\n-\t      auto entry = worklist.pop ();\n-\t      gassign *stmt = as_a <gassign *> (entry.second);\n-\t      enum tree_code in_code = entry.first;\n-\t      enum tree_code this_code = gimple_assign_rhs_code (stmt);\n-\t      /* Pick some stmts suitable for SLP_TREE_REPRESENTATIVE.  */\n-\t      if (!op_stmt_info\n-\t\t  && gimple_assign_rhs_code (stmt) == code)\n-\t\top_stmt_info = vinfo->lookup_stmt (stmt);\n-\t      else if (!other_op_stmt_info\n-\t\t       && gimple_assign_rhs_code (stmt) == MINUS_EXPR)\n-\t\tother_op_stmt_info = vinfo->lookup_stmt (stmt);\n-\t      for (unsigned opnum = 1; opnum <= 2; ++opnum)\n-\t\t{\n-\t\t  tree op = gimple_op (stmt, opnum);\n-\t\t  vect_def_type dt;\n-\t\t  stmt_vec_info def_stmt_info;\n-\t\t  bool res = vect_is_simple_use (op, vinfo, &dt, &def_stmt_info);\n-\t\t  gcc_assert (res);\n-\t\t  if (dt == vect_internal_def)\n-\t\t    {\n-\t\t      def_stmt_info = vect_stmt_to_vectorize (def_stmt_info);\n-\t\t      op = gimple_get_lhs (def_stmt_info->stmt);\n-\t\t    }\n-\t\t  gimple *use_stmt;\n-\t\t  use_operand_p use_p;\n-\t\t  if (dt == vect_internal_def\n-\t\t      && single_imm_use (op, &use_p, &use_stmt)\n-\t\t      && is_gimple_assign (def_stmt_info->stmt)\n-\t\t      && (gimple_assign_rhs_code (def_stmt_info->stmt) == code\n-\t\t\t  || (code == PLUS_EXPR\n-\t\t\t      && (gimple_assign_rhs_code (def_stmt_info->stmt)\n-\t\t\t\t  == MINUS_EXPR))))\n-\t\t    {\n-\t\t      tree_code op_def_code = this_code;\n-\t\t      if (op_def_code == MINUS_EXPR && opnum == 1)\n-\t\t\top_def_code = PLUS_EXPR;\n-\t\t      if (in_code == MINUS_EXPR)\n-\t\t\top_def_code\n-\t\t\t  = op_def_code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n-\t\t      worklist.safe_push (std::make_pair (op_def_code,\n-\t\t\t\t\t\t\t  def_stmt_info->stmt));\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      tree_code op_def_code = this_code;\n-\t\t      if (op_def_code == MINUS_EXPR && opnum == 1)\n-\t\t\top_def_code = PLUS_EXPR;\n-\t\t      if (in_code == MINUS_EXPR)\n-\t\t\top_def_code\n-\t\t\t  = op_def_code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n-\t\t      chain.safe_push (chain_op_t (op_def_code, dt, op));\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  gimple *op_stmt = NULL, *other_op_stmt = NULL;\n+\t  vect_slp_linearize_chain (vinfo, worklist, chain, code,\n+\t\t\t\t    stmts[lane]->stmt, op_stmt, other_op_stmt,\n+\t\t\t\t    NULL);\n+\t  if (!op_stmt_info && op_stmt)\n+\t    op_stmt_info = vinfo->lookup_stmt (op_stmt);\n+\t  if (!other_op_stmt_info && other_op_stmt)\n+\t    other_op_stmt_info = vinfo->lookup_stmt (other_op_stmt);\n \t  if (chain.length () == 2)\n \t    {\n \t      /* In a chain of just two elements resort to the regular\n@@ -3915,6 +3944,48 @@ vect_optimize_slp (vec_info *vinfo)\n \t    }\n \t}\n     }\n+\n+  /* And any permutations of BB reductions.  */\n+  if (is_a <bb_vec_info> (vinfo))\n+    {\n+      for (slp_instance instance : vinfo->slp_instances)\n+\t{\n+\t  if (SLP_INSTANCE_KIND (instance) != slp_inst_kind_bb_reduc)\n+\t    continue;\n+\t  slp_tree old = SLP_INSTANCE_TREE (instance);\n+\t  if (SLP_TREE_CODE (old) == VEC_PERM_EXPR\n+\t      && SLP_TREE_CHILDREN (old).length () == 1)\n+\t    {\n+\t      slp_tree child = SLP_TREE_CHILDREN (old)[0];\n+\t      if (SLP_TREE_DEF_TYPE (child) == vect_external_def)\n+\t\t{\n+\t\t  /* Preserve the special VEC_PERM we use to shield existing\n+\t\t     vector defs from the rest.  But make it a no-op.  */\n+\t\t  unsigned i = 0;\n+\t\t  for (std::pair<unsigned, unsigned> &p\n+\t\t       : SLP_TREE_LANE_PERMUTATION (old))\n+\t\t    p.second = i++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  SLP_INSTANCE_TREE (instance) = child;\n+\t\t  SLP_TREE_REF_COUNT (child)++;\n+\t\t  vect_free_slp_tree (old);\n+\t\t}\n+\t    }\n+\t  else if (SLP_TREE_LOAD_PERMUTATION (old).exists ()\n+\t\t   && SLP_TREE_REF_COUNT (old) == 1)\n+\t    {\n+\t      /* ???  For loads the situation is more complex since\n+\t\t we can't modify the permute in place in case the\n+\t\t node is used multiple times.  In fact for loads this\n+\t\t should be somehow handled in the propagation engine.  */\n+\t      auto fn = [] (const void *a, const void *b)\n+\t\t\t      { return *(const int *)a - *(const int *)b; };\n+\t      SLP_TREE_LOAD_PERMUTATION (old).qsort (fn);\n+\t    }\n+\t}\n+    }\n }\n \n /* Gather loads reachable from the individual SLP graph entries.  */\n@@ -4492,7 +4563,6 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n   return res;\n }\n \n-\n /* Mark lanes of NODE that are live outside of the basic-block vectorized\n    region and that can be vectorized using vectorizable_live_operation\n    with STMT_VINFO_LIVE_P.  Not handled live operations will cause the\n@@ -4596,6 +4666,55 @@ vect_bb_slp_mark_live_stmts (bb_vec_info bb_vinfo, slp_tree node,\n \t\t\t\t   cost_vec, svisited, visited);\n }\n \n+/* Determine whether we can vectorize the reduction epilogue for INSTANCE.  */\n+\n+static bool\n+vectorizable_bb_reduc_epilogue (slp_instance instance,\n+\t\t\t\tstmt_vector_for_cost *cost_vec)\n+{\n+  enum tree_code reduc_code\n+    = gimple_assign_rhs_code (instance->root_stmts[0]->stmt);\n+  if (reduc_code == MINUS_EXPR)\n+    reduc_code = PLUS_EXPR;\n+  internal_fn reduc_fn;\n+  tree vectype = SLP_TREE_VECTYPE (SLP_INSTANCE_TREE (instance));\n+  if (!reduction_fn_for_scalar_code (reduc_code, &reduc_fn)\n+      || reduc_fn == IFN_LAST\n+      || !direct_internal_fn_supported_p (reduc_fn, vectype, OPTIMIZE_FOR_BOTH))\n+    return false;\n+\n+  /* There's no way to cost a horizontal vector reduction via REDUC_FN so\n+     cost log2 vector operations plus shuffles.  */\n+  unsigned steps = floor_log2 (vect_nunits_for_cost (vectype));\n+  record_stmt_cost (cost_vec, steps, vector_stmt, instance->root_stmts[0],\n+\t\t    vectype, 0, vect_body);\n+  record_stmt_cost (cost_vec, steps, vec_perm, instance->root_stmts[0],\n+\t\t    vectype, 0, vect_body);\n+  return true;\n+}\n+\n+/* Prune from ROOTS all stmts that are computed as part of lanes of NODE\n+   and recurse to children.  */\n+\n+static void\n+vect_slp_prune_covered_roots (slp_tree node, hash_set<stmt_vec_info> &roots,\n+\t\t\t      hash_set<slp_tree> &visited)\n+{\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def\n+      || visited.add (node))\n+    return;\n+\n+  stmt_vec_info stmt;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+    roots.remove (vect_orig_stmt (stmt));\n+\n+  slp_tree child;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (child)\n+      vect_slp_prune_covered_roots (child, roots, visited);\n+}\n+\n /* Analyze statements in SLP instances of VINFO.  Return true if the\n    operations are supported. */\n \n@@ -4619,15 +4738,20 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t\t\t\t\t     SLP_INSTANCE_TREE (instance),\n \t\t\t\t\t     instance, visited, visited_vec,\n \t\t\t\t\t     &cost_vec)\n-\t  /* Instances with a root stmt require vectorized defs for the\n-\t     SLP tree root.  */\n-\t  /* ???  Do inst->kind check instead.  */\n-\t  || (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ()\n+\t  /* CTOR instances require vectorized defs for the SLP tree root.  */\n+\t  || (SLP_INSTANCE_KIND (instance) == slp_inst_kind_ctor\n \t      && (SLP_TREE_DEF_TYPE (SLP_INSTANCE_TREE (instance))\n-\t\t  != vect_internal_def)))\n+\t\t  != vect_internal_def))\n+\t  /* Check we can vectorize the reduction.  */\n+\t  || (SLP_INSTANCE_KIND (instance) == slp_inst_kind_bb_reduc\n+\t      && !vectorizable_bb_reduc_epilogue (instance, &cost_vec)))\n         {\n \t  slp_tree node = SLP_INSTANCE_TREE (instance);\n-\t  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+\t  stmt_vec_info stmt_info;\n+\t  if (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ())\n+\t    stmt_info = SLP_INSTANCE_ROOT_STMTS (instance)[0];\n+\t  else\n+\t    stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"removing SLP instance operations starting from: %G\",\n@@ -4654,6 +4778,34 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t}\n     }\n \n+  /* Now look for SLP instances with a root that are covered by other\n+     instances and remove them.  */\n+  hash_set<stmt_vec_info> roots;\n+  for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n+    if (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ())\n+      roots.add (SLP_INSTANCE_ROOT_STMTS (instance)[0]);\n+  if (!roots.is_empty ())\n+    {\n+      visited.empty ();\n+      for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n+\tvect_slp_prune_covered_roots (SLP_INSTANCE_TREE (instance), roots,\n+\t\t\t\t      visited);\n+      for (i = 0; vinfo->slp_instances.iterate (i, &instance); )\n+\tif (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ()\n+\t    && !roots.contains (SLP_INSTANCE_ROOT_STMTS (instance)[0]))\n+\t  {\n+\t    stmt_vec_info root = SLP_INSTANCE_ROOT_STMTS (instance)[0];\n+\t    if (dump_enabled_p ())\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"removing SLP instance operations starting \"\n+\t\t\t       \"from: %G\", root->stmt);\n+\t    vect_free_slp_instance (instance);\n+\t    vinfo->slp_instances.ordered_remove (i);\n+\t  }\n+\telse\n+\t  ++i;\n+    }\n+\n   /* Compute vectorizable live stmts.  */\n   if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (vinfo))\n     {\n@@ -5115,7 +5267,10 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \tcontinue;\n \n       tree rhs = gimple_assign_rhs1 (assign);\n-      if (gimple_assign_rhs_code (assign) == CONSTRUCTOR)\n+      enum tree_code code = gimple_assign_rhs_code (assign);\n+      use_operand_p use_p;\n+      gimple *use_stmt;\n+      if (code == CONSTRUCTOR)\n \t{\n \t  if (!VECTOR_TYPE_P (TREE_TYPE (rhs))\n \t      || maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)),\n@@ -5136,7 +5291,7 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t  stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (assign);\n \t  BB_VINFO_GROUPED_STORES (bb_vinfo).safe_push (stmt_info);\n \t}\n-      else if (gimple_assign_rhs_code (assign) == BIT_INSERT_EXPR\n+      else if (code == BIT_INSERT_EXPR\n \t       && VECTOR_TYPE_P (TREE_TYPE (rhs))\n \t       && TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)).is_constant ()\n \t       && TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)).to_constant () > 1\n@@ -5230,6 +5385,69 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t  else\n \t    roots.release ();\n \t}\n+      else if (!VECTOR_TYPE_P (TREE_TYPE (rhs))\n+\t       && (associative_tree_code (code) || code == MINUS_EXPR)\n+\t       /* ???  The flag_associative_math and TYPE_OVERFLOW_WRAPS\n+\t\t  checks pessimize a two-element reduction.  PR54400.\n+\t\t  ???  In-order reduction could be handled if we only\n+\t\t  traverse one operand chain in vect_slp_linearize_chain.  */\n+\t       && ((FLOAT_TYPE_P (TREE_TYPE (rhs)) && flag_associative_math)\n+\t\t   || (INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n+\t\t       && TYPE_OVERFLOW_WRAPS (TREE_TYPE (rhs))))\n+\t       /* Ops with constants at the tail can be stripped here.  */\n+\t       && TREE_CODE (rhs) == SSA_NAME\n+\t       && TREE_CODE (gimple_assign_rhs2 (assign)) == SSA_NAME\n+\t       /* Should be the chain end.  */\n+\t       && (!single_imm_use (gimple_assign_lhs (assign),\n+\t\t\t\t    &use_p, &use_stmt)\n+\t\t   || !is_gimple_assign (use_stmt)\n+\t\t   || (gimple_assign_rhs_code (use_stmt) != code\n+\t\t       && ((code != PLUS_EXPR && code != MINUS_EXPR)\n+\t\t\t   || (gimple_assign_rhs_code (use_stmt)\n+\t\t\t       != (code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR))))))\n+\t{\n+\t  /* We start the match at the end of a possible association\n+\t     chain.  */\n+\t  auto_vec<chain_op_t> chain;\n+\t  auto_vec<std::pair<tree_code, gimple *> > worklist;\n+\t  auto_vec<gimple *> chain_stmts;\n+\t  gimple *code_stmt = NULL, *alt_code_stmt = NULL;\n+\t  if (code == MINUS_EXPR)\n+\t    code = PLUS_EXPR;\n+\t  internal_fn reduc_fn;\n+\t  if (!reduction_fn_for_scalar_code (code, &reduc_fn)\n+\t      || reduc_fn == IFN_LAST)\n+\t    continue;\n+\t  vect_slp_linearize_chain (bb_vinfo, worklist, chain, code, assign,\n+\t\t\t\t    /* ??? */\n+\t\t\t\t    code_stmt, alt_code_stmt, &chain_stmts);\n+\t  if (chain.length () > 1)\n+\t    {\n+\t      /* Sort the chain according to def_type and operation.  */\n+\t      chain.sort (dt_sort_cmp, bb_vinfo);\n+\t      /* ???  Now we'd want to strip externals and constants\n+\t\t but record those to be handled in the epilogue.  */\n+\t      /* ???  For now do not allow mixing ops or externs/constants.  */\n+\t      bool invalid = false;\n+\t      for (unsigned i = 0; i < chain.length (); ++i)\n+\t\tif (chain[i].dt != vect_internal_def\n+\t\t    || chain[i].code != code)\n+\t\t  invalid = true;\n+\t      if (!invalid)\n+\t\t{\n+\t\t  vec<stmt_vec_info> stmts;\n+\t\t  stmts.create (chain.length ());\n+\t\t  for (unsigned i = 0; i < chain.length (); ++i)\n+\t\t    stmts.quick_push (bb_vinfo->lookup_def (chain[i].op));\n+\t\t  vec<stmt_vec_info> roots;\n+\t\t  roots.create (chain_stmts.length ());\n+\t\t  for (unsigned i = 0; i < chain_stmts.length (); ++i)\n+\t\t    roots.quick_push (bb_vinfo->lookup_stmt (chain_stmts[i]));\n+\t\t  bb_vinfo->roots.safe_push (slp_root (slp_inst_kind_bb_reduc,\n+\t\t\t\t\t\t       stmts, roots));\n+\t\t}\n+\t    }\n+\t}\n     }\n }\n \n@@ -6861,6 +7079,39 @@ vectorize_slp_instance_root_stmt (slp_tree node, slp_instance instance)\n \t  rstmt = gimple_build_assign (lhs, r_constructor);\n \t}\n     }\n+  else if (instance->kind == slp_inst_kind_bb_reduc)\n+    {\n+      /* Largely inspired by reduction chain epilogue handling in\n+\t vect_create_epilog_for_reduction.  */\n+      vec<tree> vec_defs = vNULL;\n+      vect_get_slp_defs (node, &vec_defs);\n+      enum tree_code reduc_code\n+\t= gimple_assign_rhs_code (instance->root_stmts[0]->stmt);\n+      /* ???  We actually have to reflect signs somewhere.  */\n+      if (reduc_code == MINUS_EXPR)\n+\treduc_code = PLUS_EXPR;\n+      gimple_seq epilogue = NULL;\n+      /* We may end up with more than one vector result, reduce them\n+\t to one vector.  */\n+      tree vec_def = vec_defs[0];\n+      for (unsigned i = 1; i < vec_defs.length (); ++i)\n+\tvec_def = gimple_build (&epilogue, reduc_code, TREE_TYPE (vec_def),\n+\t\t\t\tvec_def, vec_defs[i]);\n+      vec_defs.release ();\n+      /* ???  Support other schemes than direct internal fn.  */\n+      internal_fn reduc_fn;\n+      if (!reduction_fn_for_scalar_code (reduc_code, &reduc_fn)\n+\t  || reduc_fn == IFN_LAST)\n+\tgcc_unreachable ();\n+      tree scalar_def = gimple_build (&epilogue, as_combined_fn (reduc_fn),\n+\t\t\t\t      TREE_TYPE (TREE_TYPE (vec_def)), vec_def);\n+\n+      gimple_stmt_iterator rgsi = gsi_for_stmt (instance->root_stmts[0]->stmt);\n+      gsi_insert_seq_before (&rgsi, epilogue, GSI_SAME_STMT);\n+      gimple_assign_set_rhs_from_tree (&rgsi, scalar_def);\n+      update_stmt (gsi_stmt (rgsi));\n+      return;\n+    }\n   else\n     gcc_unreachable ();\n "}, {"sha": "04c20f8bd0f3974e949f040f7512d66c70286d7f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=3dfa4fe9f1a089b2b3906c83e22a1b39c49d937c", "patch": "@@ -190,6 +190,7 @@ enum slp_instance_kind {\n     slp_inst_kind_store,\n     slp_inst_kind_reduc_group,\n     slp_inst_kind_reduc_chain,\n+    slp_inst_kind_bb_reduc,\n     slp_inst_kind_ctor\n };\n \n@@ -1971,6 +1972,7 @@ extern tree vect_get_loop_len (loop_vec_info, vec_loop_lens *, unsigned int,\n \t\t\t       unsigned int);\n extern gimple_seq vect_gen_len (tree, tree, tree, tree);\n extern stmt_vec_info info_for_reduction (vec_info *, stmt_vec_info);\n+extern bool reduction_fn_for_scalar_code (enum tree_code, internal_fn *);\n \n /* Drive for loop transformation stage.  */\n extern class loop *vect_transform_loop (loop_vec_info, gimple *);"}]}