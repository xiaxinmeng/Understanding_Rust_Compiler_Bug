{"sha": "a4015be50ac2c1769e744defdfdbbd45c9cc64ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQwMTViZTUwYWMyYzE3NjllNzQ0ZGVmZGZkYmJkNDVjOWNjNjRlZQ==", "commit": {"author": {"name": "Mike Stump", "email": "mikestump@comcast.net", "date": "2011-02-12T16:51:58Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2011-02-12T16:51:58Z"}, "message": "re PR target/47324 (r160124 caused g++.dg/torture/stackalign failures with -O3 -g at -m32 on darwin)\n\n\ngcc:\n\tPR target/47324\n\t* dwarf2out.c (output_cfa_loc): When required, apply the\n\tDWARF2_FRAME_REG_OUT macro to adjust register numbers.\n\t(output_loc_sequence): Likewise.\n\t(output_loc_operands_raw): Likewise.\n\t(output_loc_sequence_raw): Likewise.\n\t(output_cfa_loc): Likewise.\n\t(output_loc_list): Suppress register number adjustment when\n\tcalling output_loc_sequence()\n\t(output_die): Likewise.\n\n\nCo-Authored-By: Iain Sandoe <iains@gcc.gnu.org>\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r170077", "tree": {"sha": "de86376f4ccda2bbb1f1e38eb8fa60ba15d0750d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de86376f4ccda2bbb1f1e38eb8fa60ba15d0750d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4015be50ac2c1769e744defdfdbbd45c9cc64ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4015be50ac2c1769e744defdfdbbd45c9cc64ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4015be50ac2c1769e744defdfdbbd45c9cc64ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4015be50ac2c1769e744defdfdbbd45c9cc64ee/comments", "author": null, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03b2a04d63c7a320ef86ee4a077bbdcefd02a271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b2a04d63c7a320ef86ee4a077bbdcefd02a271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b2a04d63c7a320ef86ee4a077bbdcefd02a271"}], "stats": {"total": 139, "additions": 115, "deletions": 24}, "files": [{"sha": "ff2f60c4ce5fc1d5d4fa83a3c4ad36ad1ece3ea8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4015be50ac2c1769e744defdfdbbd45c9cc64ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4015be50ac2c1769e744defdfdbbd45c9cc64ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4015be50ac2c1769e744defdfdbbd45c9cc64ee", "patch": "@@ -1,3 +1,18 @@\n+2011-02-12  Mike Stump  <mikestump@comcast.net>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t    Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/47324\n+\t* dwarf2out.c (output_cfa_loc): When required, apply the\n+\tDWARF2_FRAME_REG_OUT macro to adjust register numbers.\n+\t(output_loc_sequence): Likewise.\n+\t(output_loc_operands_raw): Likewise.\n+\t(output_loc_sequence_raw): Likewise.\n+\t(output_cfa_loc): Likewise.\n+\t(output_loc_list): Suppress register number adjustment when\n+\tcalling output_loc_sequence()\n+\t(output_die): Likewise.\n+\n 2011-02-12  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/xtensa/xtensa.h (REGISTER_MOVE_COST, MEMORY_MOVE_COST):"}, {"sha": "fea820967f9ed1cec3dad4f6a3fa731661508b7c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 100, "deletions": 24, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4015be50ac2c1769e744defdfdbbd45c9cc64ee/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4015be50ac2c1769e744defdfdbbd45c9cc64ee/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a4015be50ac2c1769e744defdfdbbd45c9cc64ee", "patch": "@@ -474,7 +474,7 @@ static bool clobbers_queued_reg_save (const_rtx);\n static void dwarf2out_frame_debug_expr (rtx, const char *);\n \n /* Support for complex CFA locations.  */\n-static void output_cfa_loc (dw_cfi_ref);\n+static void output_cfa_loc (dw_cfi_ref, int);\n static void output_cfa_loc_raw (dw_cfi_ref);\n static void get_cfa_from_loc_descr (dw_cfa_location *,\n \t\t\t\t    struct dw_loc_descr_struct *);\n@@ -3317,7 +3317,7 @@ output_cfi (dw_cfi_ref cfi, dw_fde_ref fde, int for_eh)\n \n \tcase DW_CFA_def_cfa_expression:\n \tcase DW_CFA_expression:\n-\t  output_cfa_loc (cfi);\n+\t  output_cfa_loc (cfi, for_eh);\n \t  break;\n \n \tcase DW_CFA_GNU_negative_offset_extended:\n@@ -5053,10 +5053,15 @@ size_of_locs (dw_loc_descr_ref loc)\n static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n static void get_ref_die_offset_label (char *, dw_die_ref);\n \n-/* Output location description stack opcode's operands (if any).  */\n+/* Output location description stack opcode's operands (if any).\n+   The for_eh_or_skip parameter controls whether register numbers are\n+   converted using DWARF2_FRAME_REG_OUT, which is needed in the case that\n+   hard reg numbers have been processed via DWARF_FRAME_REGNUM (i.e. for unwind\n+   info).  This should be suppressed for the cases that have not been converted\n+   (i.e. symbolic debug info), by setting the parameter < 0.  See PR47324.  */\n \n static void\n-output_loc_operands (dw_loc_descr_ref loc)\n+output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n {\n   dw_val_ref val1 = &loc->dw_loc_oprnd1;\n   dw_val_ref val2 = &loc->dw_loc_oprnd2;\n@@ -5227,14 +5232,28 @@ output_loc_operands (dw_loc_descr_ref loc)\n       dw2_asm_output_data_sleb128 (val1->v.val_int, NULL);\n       break;\n     case DW_OP_regx:\n-      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n+      {\n+\tunsigned r = val1->v.val_unsigned;\n+\tif (for_eh_or_skip >= 0)\n+\t  r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);\n+\tgcc_assert (size_of_uleb128 (r) \n+\t\t    == size_of_uleb128 (val1->v.val_unsigned));\n+\tdw2_asm_output_data_uleb128 (r, NULL);\t\n+      }\n       break;\n     case DW_OP_fbreg:\n       dw2_asm_output_data_sleb128 (val1->v.val_int, NULL);\n       break;\n     case DW_OP_bregx:\n-      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n-      dw2_asm_output_data_sleb128 (val2->v.val_int, NULL);\n+      {\n+\tunsigned r = val1->v.val_unsigned;\n+\tif (for_eh_or_skip >= 0)\n+\t  r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);\n+\tgcc_assert (size_of_uleb128 (r) \n+\t\t    == size_of_uleb128 (val1->v.val_unsigned));\n+\tdw2_asm_output_data_uleb128 (r, NULL);\t\n+\tdw2_asm_output_data_sleb128 (val2->v.val_int, NULL);\n+      }\n       break;\n     case DW_OP_piece:\n       dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n@@ -5288,19 +5307,42 @@ output_loc_operands (dw_loc_descr_ref loc)\n     }\n }\n \n-/* Output a sequence of location operations.  */\n+/* Output a sequence of location operations.  \n+   The for_eh_or_skip parameter controls whether register numbers are\n+   converted using DWARF2_FRAME_REG_OUT, which is needed in the case that\n+   hard reg numbers have been processed via DWARF_FRAME_REGNUM (i.e. for unwind\n+   info).  This should be suppressed for the cases that have not been converted\n+   (i.e. symbolic debug info), by setting the parameter < 0.  See PR47324.  */\n \n static void\n-output_loc_sequence (dw_loc_descr_ref loc)\n+output_loc_sequence (dw_loc_descr_ref loc, int for_eh_or_skip)\n {\n   for (; loc != NULL; loc = loc->dw_loc_next)\n     {\n+      enum dwarf_location_atom opc = loc->dw_loc_opc;\n       /* Output the opcode.  */\n-      dw2_asm_output_data (1, loc->dw_loc_opc,\n-\t\t\t   \"%s\", dwarf_stack_op_name (loc->dw_loc_opc));\n+      if (for_eh_or_skip >= 0 \n+          && opc >= DW_OP_breg0 && opc <= DW_OP_breg31)\n+\t{\n+\t  unsigned r = (opc - DW_OP_breg0);\n+\t  r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);\n+\t  gcc_assert (r <= 31);\n+\t  opc = (enum dwarf_location_atom) (DW_OP_breg0 + r);\n+\t}\n+      else if (for_eh_or_skip >= 0 \n+\t       && opc >= DW_OP_reg0 && opc <= DW_OP_reg31)\n+\t{\n+\t  unsigned r = (opc - DW_OP_reg0);\n+\t  r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);\n+\t  gcc_assert (r <= 31);\n+\t  opc = (enum dwarf_location_atom) (DW_OP_reg0 + r);\n+\t}\n+\n+      dw2_asm_output_data (1, opc,\n+\t\t\t     \"%s\", dwarf_stack_op_name (opc));\n \n       /* Output the operand(s) (if any).  */\n-      output_loc_operands (loc);\n+      output_loc_operands (loc, for_eh_or_skip);\n     }\n }\n \n@@ -5361,9 +5403,18 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n       }\n       break;\n \n+    case DW_OP_regx:\n+      {\n+\tunsigned r = DWARF2_FRAME_REG_OUT (val1->v.val_unsigned, 1);\n+\tgcc_assert (size_of_uleb128 (r) \n+\t\t    == size_of_uleb128 (val1->v.val_unsigned));\n+\tfputc (',', asm_out_file);\n+\tdw2_asm_output_data_uleb128_raw (r);\n+      }\n+      break;\n+      \n     case DW_OP_constu:\n     case DW_OP_plus_uconst:\n-    case DW_OP_regx:\n     case DW_OP_piece:\n       fputc (',', asm_out_file);\n       dw2_asm_output_data_uleb128_raw (val1->v.val_unsigned);\n@@ -5414,10 +5465,15 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n       break;\n \n     case DW_OP_bregx:\n-      fputc (',', asm_out_file);\n-      dw2_asm_output_data_uleb128_raw (val1->v.val_unsigned);\n-      fputc (',', asm_out_file);\n-      dw2_asm_output_data_sleb128_raw (val2->v.val_int);\n+      {\n+\tunsigned r = DWARF2_FRAME_REG_OUT (val1->v.val_unsigned, 1);\n+\tgcc_assert (size_of_uleb128 (r) \n+\t\t    == size_of_uleb128 (val1->v.val_unsigned));\n+\tfputc (',', asm_out_file);\n+\tdw2_asm_output_data_uleb128_raw (r);\n+\tfputc (',', asm_out_file);\n+\tdw2_asm_output_data_sleb128_raw (val2->v.val_int);\n+      }\n       break;\n \n     case DW_OP_GNU_implicit_pointer:\n@@ -5435,8 +5491,24 @@ output_loc_sequence_raw (dw_loc_descr_ref loc)\n {\n   while (1)\n     {\n+      enum dwarf_location_atom opc = loc->dw_loc_opc;\n+      /* Output the opcode.  */\n+      if (opc >= DW_OP_breg0 && opc <= DW_OP_breg31)\n+\t{\n+\t  unsigned r = (opc - DW_OP_breg0);\n+\t  r = DWARF2_FRAME_REG_OUT (r, 1);\n+\t  gcc_assert (r <= 31);\n+\t  opc = (enum dwarf_location_atom) (DW_OP_breg0 + r);\n+\t}\n+      else if (opc >= DW_OP_reg0 && opc <= DW_OP_reg31)\n+\t{\n+\t  unsigned r = (opc - DW_OP_reg0);\n+\t  r = DWARF2_FRAME_REG_OUT (r, 1);\n+\t  gcc_assert (r <= 31);\n+\t  opc = (enum dwarf_location_atom) (DW_OP_reg0 + r);\n+\t}\n       /* Output the opcode.  */\n-      fprintf (asm_out_file, \"%#x\", loc->dw_loc_opc);\n+      fprintf (asm_out_file, \"%#x\", opc);\n       output_loc_operands_raw (loc);\n \n       if (!loc->dw_loc_next)\n@@ -5451,14 +5523,16 @@ output_loc_sequence_raw (dw_loc_descr_ref loc)\n    description based on a cfi entry with a complex address.  */\n \n static void\n-output_cfa_loc (dw_cfi_ref cfi)\n+output_cfa_loc (dw_cfi_ref cfi, int for_eh)\n {\n   dw_loc_descr_ref loc;\n   unsigned long size;\n \n   if (cfi->dw_cfi_opc == DW_CFA_expression)\n     {\n-      dw2_asm_output_data (1, cfi->dw_cfi_oprnd1.dw_cfi_reg_num, NULL);\n+      unsigned r = \n+\tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+      dw2_asm_output_data (1, r, NULL);\n       loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;\n     }\n   else\n@@ -5469,7 +5543,7 @@ output_cfa_loc (dw_cfi_ref cfi)\n   dw2_asm_output_data_uleb128 (size, NULL);\n \n   /* Now output the operations themselves.  */\n-  output_loc_sequence (loc);\n+  output_loc_sequence (loc, for_eh);\n }\n \n /* Similar, but used for .cfi_escape.  */\n@@ -5482,7 +5556,9 @@ output_cfa_loc_raw (dw_cfi_ref cfi)\n \n   if (cfi->dw_cfi_opc == DW_CFA_expression)\n     {\n-      fprintf (asm_out_file, \"%#x,\", cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n+      unsigned r = \n+\tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (asm_out_file, \"%#x,\", r);\n       loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;\n     }\n   else\n@@ -11075,7 +11151,7 @@ output_loc_list (dw_loc_list_ref list_head)\n       gcc_assert (size <= 0xffff);\n       dw2_asm_output_data (2, size, \"%s\", \"Location expression size\");\n \n-      output_loc_sequence (curr->expr);\n+      output_loc_sequence (curr->expr, -1);\n     }\n \n   dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n@@ -11153,7 +11229,7 @@ output_die (dw_die_ref die)\n \t  else\n \t    dw2_asm_output_data (constant_size (size), size, \"%s\", name);\n \n-\t  output_loc_sequence (AT_loc (a));\n+\t  output_loc_sequence (AT_loc (a), -1);\n \t  break;\n \n \tcase dw_val_class_const:"}]}