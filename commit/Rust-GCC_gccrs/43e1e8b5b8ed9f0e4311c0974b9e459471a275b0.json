{"sha": "43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlMWU4YjViOGVkOWYwZTQzMTFjMDk3NGI5ZTQ1OTQ3MWEyNzViMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-06-29T05:40:58Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-06-29T05:40:58Z"}, "message": "Remove trailing whitespace in C++ front end.\n\nFrom-SVN: r272809", "tree": {"sha": "6dddab969c3319d8d04f3f304677e25d823b3992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dddab969c3319d8d04f3f304677e25d823b3992"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/comments", "author": null, "committer": null, "parents": [{"sha": "ee62a32fb741a8029a8621de28170bd039f27ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee62a32fb741a8029a8621de28170bd039f27ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee62a32fb741a8029a8621de28170bd039f27ce2"}], "stats": {"total": 541, "additions": 270, "deletions": 271}, "files": [{"sha": "a1849f69836c56d47e4eb34793ac255d8e711ae5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "patch": "@@ -734,7 +734,7 @@ struct GTY(()) tree_overload {\n /* Iterator for a 1 dimensional overload.  Permits iterating over the\n    outer level of a 2-d overload when explicitly enabled.  */\n \n-class ovl_iterator \n+class ovl_iterator\n {\n   tree ovl;\n   const bool allow_inner; /* Only used when checking.  */\n@@ -1296,7 +1296,7 @@ enum cp_trait_kind\n struct GTY (()) tree_trait_expr {\n   struct tree_common common;\n   tree type1;\n-  tree type2;  \n+  tree type2;\n   enum cp_trait_kind kind;\n };\n \n@@ -1613,7 +1613,7 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n   struct tree_deferred_parse GTY ((tag (\"TS_CP_DEFERRED_PARSE\"))) deferred_parse;\n   struct tree_deferred_noexcept GTY ((tag (\"TS_CP_DEFERRED_NOEXCEPT\"))) deferred_noexcept;\n   struct lang_identifier GTY ((tag (\"TS_CP_IDENTIFIER\"))) identifier;\n-  struct tree_static_assert GTY ((tag (\"TS_CP_STATIC_ASSERT\"))) \n+  struct tree_static_assert GTY ((tag (\"TS_CP_STATIC_ASSERT\")))\n     static_assertion;\n   struct tree_argument_pack_select GTY ((tag (\"TS_CP_ARGUMENT_PACK_SELECT\")))\n     argument_pack_select;\n@@ -3680,7 +3680,7 @@ struct GTY(()) lang_decl {\n    select.  */\n #define ARGUMENT_PACK_SELECT_INDEX(NODE)\t\t\t\t\\\n   (((struct tree_argument_pack_select *)ARGUMENT_PACK_SELECT_CHECK (NODE))->index)\n-  \n+\n #define FOLD_EXPR_CHECK(NODE)\t\t\t\t\t\t\\\n   TREE_CHECK4 (NODE, UNARY_LEFT_FOLD_EXPR, UNARY_RIGHT_FOLD_EXPR,\t\\\n \t       BINARY_LEFT_FOLD_EXPR, BINARY_RIGHT_FOLD_EXPR)\n@@ -4080,7 +4080,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* [basic.fundamental]\n \n    Integral and floating types are collectively called arithmetic\n-   types.  \n+   types.\n \n    As a GNU extension, we also accept complex types.\n \n@@ -4098,7 +4098,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    Arithmetic types, enumeration types, pointer types,\n    pointer-to-member types, and std::nullptr_t are collectively called\n    scalar types.\n-   \n+\n    Keep these checks in ascending code order.  */\n #define SCALAR_TYPE_P(TYPE)\t\t\t\\\n   (TYPE_PTRDATAMEM_P (TYPE)\t\t\t\\\n@@ -4118,7 +4118,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n    Scoped enumeration types are different from normal (unscoped)\n    enumeration types in several ways:\n-   \n+\n      - The enumerators of a scoped enumeration type are only available\n        within the scope of the enumeration type and not in the\n        enclosing scope. For example, the Red color can be referred to\n@@ -4581,7 +4581,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    parameter).  The TREE_PURPOSE is the default value, if any.  The\n    TEMPLATE_PARM_INDEX for the parameter is available as the\n    DECL_INITIAL (for a PARM_DECL) or as the TREE_TYPE (for a\n-   TYPE_DECL). \n+   TYPE_DECL).\n \n    FIXME: CONST_CAST_TREE is a hack that hopefully will go away after\n    tree is converted to C++ class hiearchy.  */\n@@ -4733,18 +4733,18 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n         template <> int min<int> (int, int),\n \n      3=explicit instantiation, e.g.:\n-  \n+\n         template int min<int> (int, int);\n \n    Note that NODE will be marked as a specialization even if the\n    template it is instantiating is not a primary template.  For\n    example, given:\n \n-     template <typename T> struct O { \n+     template <typename T> struct O {\n        void f();\n-       struct I {}; \n+       struct I {};\n      };\n-    \n+\n    both O<int>::f and O<int>::I will be marked as instantiations.\n \n    If DECL_USE_TEMPLATE is nonzero, then DECL_TEMPLATE_INFO will also\n@@ -6747,7 +6747,7 @@ extern void append_type_to_template_for_access_check (tree, tree, tree,\n extern tree convert_generic_types_to_packs\t(tree, int, int);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n-extern tree process_template_parm\t\t(tree, location_t, tree, \n+extern tree process_template_parm\t\t(tree, location_t, tree,\n \t\t\t\t\t\t bool, bool);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_parm_list\t\t(void);\n@@ -7404,7 +7404,7 @@ extern tree cp_build_unary_op                   (enum tree_code, tree, bool,\n                                                  tsubst_flags_t);\n extern tree genericize_compound_lvalue\t\t(tree);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n-extern tree build_x_conditional_expr\t\t(location_t, tree, tree, tree, \n+extern tree build_x_conditional_expr\t\t(location_t, tree, tree, tree,\n                                                  tsubst_flags_t);\n extern tree build_x_compound_expr_from_list\t(tree, expr_list_kind,\n \t\t\t\t\t\t tsubst_flags_t);\n@@ -7449,7 +7449,7 @@ extern void expand_ptrmemfunc_cst\t\t(tree, tree *, tree *);\n extern tree type_after_usual_arithmetic_conversions (tree, tree);\n extern tree common_pointer_type                 (tree, tree);\n extern tree composite_pointer_type\t\t(tree, tree, tree, tree,\n-\t\t\t\t\t\t composite_pointer_operation, \n+\t\t\t\t\t\t composite_pointer_operation,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree merge_types\t\t\t\t(tree, tree);\n extern tree strip_array_domain\t\t\t(tree);"}, {"sha": "038f300903976e0ea7edba0cfdb140cf362f1b33", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "patch": "@@ -3023,7 +3023,6 @@ pp_cxx_constraint (cxx_pretty_printer *pp, tree t)\n     }\n }\n \n-\n \f\n typedef c_pretty_print_fn pp_fun;\n "}, {"sha": "128141024650e076a4ed9b884796adcca517bec3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "patch": "@@ -824,7 +824,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n             {\n               /* Warn about the C++0x keyword (but still treat it as\n                  an identifier).  */\n-              warning (OPT_Wc__11_compat, \n+              warning (OPT_Wc__11_compat,\n                        \"identifier %qE is a keyword in C++11\",\n                        token->u.value);\n \n@@ -969,7 +969,7 @@ cp_keyword_starts_decl_specifier_p (enum rid keyword)\n     case RID_FLOAT:\n     case RID_DOUBLE:\n     case RID_VOID:\n-      /* GNU extensions.  */ \n+      /* GNU extensions.  */\n     case RID_ATTRIBUTE:\n     case RID_TYPEOF:\n       /* C++0x extensions.  */\n@@ -1646,7 +1646,7 @@ make_array_declarator (cp_declarator *element, tree bounds)\n \n /* Determine whether the declarator we've seen so far can be a\n    parameter pack, when followed by an ellipsis.  */\n-static bool \n+static bool\n declarator_can_be_parameter_pack (cp_declarator *declarator)\n {\n   if (declarator && declarator->parameter_pack_p)\n@@ -1727,7 +1727,7 @@ function_declarator_p (const cp_declarator *declarator)\n     }\n   return false;\n }\n- \n+\n /* The parser.  */\n \n /* Overview\n@@ -2173,7 +2173,7 @@ static tree cp_parser_simple_type_specifier\n   (cp_parser *, cp_decl_specifier_seq *, cp_parser_flags);\n static tree cp_parser_type_name\n   (cp_parser *, bool);\n-static tree cp_parser_nonclass_name \n+static tree cp_parser_nonclass_name\n   (cp_parser* parser);\n static tree cp_parser_elaborated_type_specifier\n   (cp_parser *, bool, bool);\n@@ -2251,7 +2251,7 @@ static tree cp_parser_parameter_declaration_list\n   (cp_parser *, cp_parser_flags);\n static cp_parameter_declarator *cp_parser_parameter_declaration\n   (cp_parser *, cp_parser_flags, bool, bool *);\n-static tree cp_parser_default_argument \n+static tree cp_parser_default_argument\n   (cp_parser *, bool);\n static void cp_parser_function_body\n   (cp_parser *, bool);\n@@ -2491,9 +2491,9 @@ static tree cp_parser_objc_statement\n   (cp_parser *);\n static bool cp_parser_objc_valid_prefix_attributes\n   (cp_parser *, tree *);\n-static void cp_parser_objc_at_property_declaration \n+static void cp_parser_objc_at_property_declaration\n   (cp_parser *) ;\n-static void cp_parser_objc_at_synthesize_declaration \n+static void cp_parser_objc_at_synthesize_declaration\n   (cp_parser *) ;\n static void cp_parser_objc_at_dynamic_declaration\n   (cp_parser *) ;\n@@ -2997,7 +2997,7 @@ cp_parser_name_lookup_error (cp_parser* parser,\n \t    break;\n \t  default:\n \t    gcc_unreachable ();\n-\t    \n+\n \t}\n     }\n   else if (parser->scope == global_namespace)\n@@ -3096,7 +3096,7 @@ cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,\n     {\n       error_at (type_location,\n \t\t\"new types may not be defined in a return type\");\n-      inform (type_location, \n+      inform (type_location,\n \t      \"(perhaps a semicolon is missing after the definition of %qT)\",\n \t      type);\n     }\n@@ -3369,7 +3369,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n \t\t    if (TREE_CODE (field) == TYPE_DECL\n \t\t\t&& DECL_NAME (field) == id)\n \t\t      {\n-\t\t\tinform (location, \n+\t\t\tinform (location,\n \t\t\t\t\"(perhaps %<typename %T::%E%> was intended)\",\n \t\t\t\tBINFO_TYPE (b), id);\n \t\t\tbreak;\n@@ -4655,7 +4655,7 @@ static void\n cp_parser_translation_unit (cp_parser* parser)\n {\n   gcc_checking_assert (!cp_error_declarator);\n-  \n+\n   /* Create the declarator obstack.  */\n   gcc_obstack_init (&declarator_obstack);\n   /* Create the error declarator.  */\n@@ -4671,7 +4671,7 @@ cp_parser_translation_unit (cp_parser* parser)\n   for (;;)\n     {\n       cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      \n+\n       /* If we're entering or exiting a region that's implicitly\n \t extern \"C\", modify the lang context appropriately.  */\n       if (implicit_extern_c\n@@ -5121,14 +5121,14 @@ cp_parser_fold_expression (cp_parser *parser, tree expr1)\n      __builtin_offsetof ( type-id , offsetof-expression )\n \n    C++ Extensions:\n-     __has_nothrow_assign ( type-id )   \n+     __has_nothrow_assign ( type-id )\n      __has_nothrow_constructor ( type-id )\n      __has_nothrow_copy ( type-id )\n-     __has_trivial_assign ( type-id )   \n+     __has_trivial_assign ( type-id )\n      __has_trivial_constructor ( type-id )\n      __has_trivial_copy ( type-id )\n      __has_trivial_destructor ( type-id )\n-     __has_virtual_destructor ( type-id )     \n+     __has_virtual_destructor ( type-id )\n      __is_abstract ( type-id )\n      __is_base_of ( type-id , type-id )\n      __is_class ( type-id )\n@@ -5516,10 +5516,10 @@ cp_parser_primary_expression (cp_parser *parser,\n \n \tcase RID_HAS_NOTHROW_ASSIGN:\n \tcase RID_HAS_NOTHROW_CONSTRUCTOR:\n-\tcase RID_HAS_NOTHROW_COPY:\t  \n+\tcase RID_HAS_NOTHROW_COPY:\n \tcase RID_HAS_TRIVIAL_ASSIGN:\n \tcase RID_HAS_TRIVIAL_CONSTRUCTOR:\n-\tcase RID_HAS_TRIVIAL_COPY:\t  \n+\tcase RID_HAS_TRIVIAL_COPY:\n \tcase RID_HAS_TRIVIAL_DESTRUCTOR:\n \tcase RID_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n \tcase RID_HAS_VIRTUAL_DESTRUCTOR:\n@@ -6687,7 +6687,7 @@ cp_parser_qualifying_entity (cp_parser *parser,\n   saved_object_scope = parser->object_scope;\n   /* Try for a class-name first.  If the SAVED_SCOPE is a type, then\n      there is no need to look for a namespace-name.  */\n-  only_class_p = template_keyword_p \n+  only_class_p = template_keyword_p\n     || (saved_scope && TYPE_P (saved_scope) && cxx_dialect == cxx98);\n   if (!only_class_p)\n     cp_parser_parse_tentatively (parser);\n@@ -6734,7 +6734,7 @@ cp_parser_compound_literal_p (cp_parser *parser)\n     = (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n \t\t\t\t\t      /*consume_paren=*/true)\n        && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n-  \n+\n   /* Roll back the tokens we skipped.  */\n   cp_lexer_rollback_tokens (parser->lexer);\n \n@@ -6884,7 +6884,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    break;\n \t  case RID_REINTCAST:\n \t    postfix_expression\n-\t      = build_reinterpret_cast (type, expression, \n+\t      = build_reinterpret_cast (type, expression,\n                                         tf_warning_or_error);\n \t    break;\n \t  case RID_CONSTCAST:\n@@ -7766,7 +7766,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t      (name, parser->scope, scope);\n \t  postfix_expression\n \t    = finish_class_member_access_expr (postfix_expression, name,\n-\t\t\t\t\t       template_p, \n+\t\t\t\t\t       template_p,\n \t\t\t\t\t       tf_warning_or_error);\n \t  /* Build a location e.g.:\n \t       ptr->access_expr\n@@ -8687,7 +8687,7 @@ cp_parser_new_expression (cp_parser* parser)\n \t{\n \t  error_at (token->location,\n \t\t    \"array bound forbidden after parenthesized type-id\");\n-\t  inform (token->location, \n+\t  inform (token->location,\n \t\t  \"try removing the parentheses around the type-id\");\n \t  cp_parser_direct_new_declarator (parser);\n \t}\n@@ -8861,7 +8861,7 @@ cp_parser_new_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n   tree type, std_attributes = NULL_TREE;\n-  cp_cv_quals cv_quals;  \n+  cp_cv_quals cv_quals;\n \n   /* We don't know if there's a ptr-operator next, or not.  */\n   cp_parser_parse_tentatively (parser);\n@@ -9345,7 +9345,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t      return expr;\n \t    }\n \t}\n-      else \n+      else\n         cp_parser_abort_tentative_parse (parser);\n     }\n \n@@ -10316,7 +10316,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n   if (binary)\n     {\n       cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n- \n+\n       {\n \ttype_id_in_expr_sentinel s (parser);\n \ttype2 = cp_parser_type_id (parser);\n@@ -11227,7 +11227,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t    }\n \t  cp_parser_declaration_statement (parser);\n \t  return;\n-\t  \n+\n \tcase RID_TRANSACTION_ATOMIC:\n \tcase RID_TRANSACTION_RELAXED:\n \tcase RID_SYNCHRONIZED:\n@@ -11649,12 +11649,12 @@ cp_parser_statement_seq_opt (cp_parser* parser, tree in_statement_expr)\n \t  || token->type == CPP_PRAGMA_EOL\n \t  || (token->type == CPP_KEYWORD && token->keyword == RID_AT_END))\n \tbreak;\n-      \n+\n       /* If we are in a compound statement and find 'else' then\n \t something went wrong.  */\n       else if (token->type == CPP_KEYWORD && token->keyword == RID_ELSE)\n \t{\n-\t  if (parser->in_statement & IN_IF_STMT) \n+\t  if (parser->in_statement & IN_IF_STMT)\n \t    break;\n \t  else\n \t    {\n@@ -12092,7 +12092,7 @@ cp_parser_condition (cp_parser* parser)\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ)\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n \tcp_parser_simulate_error (parser);\n-\t\n+\n       /* If we did see an `=' or '{', then we are looking at a declaration\n \t for sure.  */\n       if (cp_parser_parse_definitely (parser))\n@@ -12857,7 +12857,7 @@ cp_parser_jump_statement (cp_parser* parser)\n   switch (keyword)\n     {\n     case RID_BREAK:\n-      in_statement = parser->in_statement & ~IN_IF_STMT;      \n+      in_statement = parser->in_statement & ~IN_IF_STMT;\n       switch (in_statement)\n \t{\n \tcase 0:\n@@ -14050,7 +14050,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t     GNU Extension:\n \t       thread  */\n \tcase RID_AUTO:\n-          if (cxx_dialect == cxx98) \n+          if (cxx_dialect == cxx98)\n             {\n \t      /* Consume the token.  */\n \t      cp_lexer_consume_token (parser->lexer);\n@@ -14421,12 +14421,12 @@ cp_parser_linkage_specification (cp_parser* parser)\n /* Parse a static_assert-declaration.\n \n    static_assert-declaration:\n-     static_assert ( constant-expression , string-literal ) ; \n+     static_assert ( constant-expression , string-literal ) ;\n      static_assert ( constant-expression ) ; (C++17)\n \n    If MEMBER_P, this static_assert is a class member.  */\n \n-static void \n+static void\n cp_parser_static_assert(cp_parser *parser, bool member_p)\n {\n   cp_expr condition;\n@@ -14439,7 +14439,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n   token_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   /* Look for the `static_assert' keyword.  */\n-  if (!cp_parser_require_keyword (parser, RID_STATIC_ASSERT, \n+  if (!cp_parser_require_keyword (parser, RID_STATIC_ASSERT,\n                                   RT_STATIC_ASSERT))\n     return;\n \n@@ -14454,7 +14454,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n \n   /* Parse the constant-expression.  Allow a non-constant expression\n      here in order to give better diagnostics in finish_static_assert.  */\n-  condition = \n+  condition =\n     cp_parser_constant_expression (parser,\n                                    /*allow_non_constant_p=*/true,\n                                    /*non_constant_p=*/&dummy);\n@@ -14477,14 +14477,14 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n       cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \n       /* Parse the string-literal message.  */\n-      message = cp_parser_string_literal (parser, \n+      message = cp_parser_string_literal (parser,\n                                 \t  /*translate=*/false,\n                                 \t  /*wide_ok=*/true);\n \n       /* A `)' completes the static assertion.  */\n       if (!parens.require_close (parser))\n-\tcp_parser_skip_to_closing_parenthesis (parser, \n-                                               /*recovering=*/true, \n+\tcp_parser_skip_to_closing_parenthesis (parser,\n+                                               /*recovering=*/true,\n                                                /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n     }\n@@ -14499,7 +14499,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n   if (assert_loc == UNKNOWN_LOCATION)\n     assert_loc = token_loc;\n \n-  /* Complete the static assertion, which may mean either processing \n+  /* Complete the static assertion, which may mean either processing\n      the static assert now or saving it for template instantiation.  */\n   finish_static_assert (condition, message, assert_loc, member_p);\n }\n@@ -14573,7 +14573,7 @@ cp_parser_decltype_expr (cp_parser *parser,\n             id_expression_or_member_access_p = true;\n         }\n \n-      if (expr \n+      if (expr\n           && expr != error_mark_node\n           && cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_PAREN)\n         /* We have an id-expression.  */\n@@ -14593,7 +14593,7 @@ cp_parser_decltype_expr (cp_parser *parser,\n                                            /*cast_p=*/false, /*decltype*/true,\n                                            /*member_access_only_p=*/true, NULL);\n \n-      if (expr \n+      if (expr\n           && expr != error_mark_node\n           && cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_PAREN)\n         /* We have an id-expression.  */\n@@ -14652,7 +14652,7 @@ cp_parser_decltype (cp_parser *parser)\n   push_deferring_access_checks (dk_deferred);\n \n   tree expr = NULL_TREE;\n-  \n+\n   if (cxx_dialect >= cxx14\n       && cp_lexer_next_token_is_keyword (parser->lexer, RID_AUTO))\n     /* decltype (auto) */\n@@ -14737,7 +14737,7 @@ cp_parser_decltype (cp_parser *parser)\n   cp_lexer_purge_tokens_after (parser->lexer, start_token);\n \n   pop_to_parent_deferring_access_checks ();\n-  \n+\n   return expr;\n }\n \n@@ -15109,7 +15109,7 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n   /* `typename' is not allowed in this context ([temp.res]).  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TYPENAME))\n     {\n-      error_at (token->location, \n+      error_at (token->location,\n \t\t\"keyword %<typename%> not allowed in this context (a qualified \"\n \t\t\"member initializer is implicitly a type)\");\n       cp_lexer_consume_token (parser->lexer);\n@@ -15639,7 +15639,7 @@ cp_parser_template_parameter_list (cp_parser* parser)\n \n       /* Parse the template-parameter.  */\n       parm_loc = cp_lexer_peek_token (parser->lexer)->location;\n-      parameter = cp_parser_template_parameter (parser, \n+      parameter = cp_parser_template_parameter (parser,\n                                                 &is_non_type,\n                                                 &is_parameter_pack);\n       /* Add it to the list.  */\n@@ -16916,7 +16916,7 @@ cp_parser_template_argument (cp_parser* parser)\n      Here 'X()' is a valid type-id of a function type, but the user just\n      wanted to write the expression \"X() >> 5\". Thus, we remember that we\n      found a valid type-id, but we still try to parse the argument as an\n-     expression to see what happens. \n+     expression to see what happens.\n \n      In C++0x, the '>>' will be considered two separate '>'\n      tokens.  */\n@@ -17542,7 +17542,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \n    simple-type-specifier:\n      auto\n-     decltype ( expression )   \n+     decltype ( expression )\n      char16_t\n      char32_t\n      __underlying_type ( type-id )\n@@ -18036,12 +18036,12 @@ cp_parser_type_name (cp_parser* parser, bool typename_keyword_p)\n \t\t\t\t\t /*is_declaration=*/false);\n       /* Note that this must be an instantiation of an alias template\n \t because [temp.names]/6 says:\n-\t \n+\n \t     A template-id that names an alias template specialization\n \t     is a type-name.\n \n \t Whereas [temp.names]/7 says:\n-\t \n+\n \t     A simple-template-id that names a class template\n \t     specialization is a class-name.\n \n@@ -18192,7 +18192,7 @@ cp_parser_nonclass_name (cp_parser* parser)\n   type_decl = cp_parser_lookup_name_simple (parser, identifier, token->location);\n \n   type_decl = strip_using_decl (type_decl);\n-  \n+\n   /* If we found an overload set, then it may refer to a concept-name. */\n   if (tree decl = cp_parser_maybe_concept_name (parser, type_decl))\n     type_decl = decl;\n@@ -18230,7 +18230,7 @@ cp_parser_nonclass_name (cp_parser* parser)\n   else if (type_decl != error_mark_node\n \t   && !parser->scope)\n     maybe_note_name_used_in_class (identifier, type_decl);\n-  \n+\n   return type_decl;\n }\n \n@@ -18395,7 +18395,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       /* If the `typename' keyword is in effect and DECL is not a type\n \t decl, then type is non existent.   */\n       else if (tag_type == typename_type && TREE_CODE (decl) != TYPE_DECL)\n-        ; \n+        ;\n       else if (TREE_CODE (decl) == TYPE_DECL)\n \t{\n \t  type = check_elaborated_type_specifier (tag_type, decl,\n@@ -18410,7 +18410,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t    check_unqualified_spec_or_inst (type, token->location);\n \t}\n       else if (decl == error_mark_node)\n-\ttype = error_mark_node; \n+\ttype = error_mark_node;\n     }\n \n   if (!type)\n@@ -18658,7 +18658,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n      enum-key identifier enum-base [opt] ;\n \n    GNU Extensions:\n-     enum-key attributes[opt] identifier [opt] enum-base [opt] \n+     enum-key attributes[opt] identifier [opt] enum-base [opt]\n        { enumerator-list [opt] }attributes[opt]\n      enum-key attributes[opt] identifier [opt] enum-base [opt]\n        { enumerator-list, }attributes[opt] [C++0x]\n@@ -19237,7 +19237,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n   for (;;)\n     {\n       identifier = NULL_TREE;\n-      \n+\n       bool nested_inline_p = cp_lexer_next_token_is_keyword (parser->lexer,\n \t\t\t\t\t\t\t     RID_INLINE);\n       if (nested_inline_p && nested_definition_count != 0)\n@@ -19271,7 +19271,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n \t  is_inline |= nested_inline_p;\n \t  break;\n \t}\n-  \n+\n       if (!nested_definition_count && cxx_dialect < cxx17)\n         pedwarn (input_location, OPT_Wpedantic,\n \t\t \"nested namespace definitions only available with \"\n@@ -19290,7 +19290,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n \n   if (nested_definition_count && !identifier)\n     cp_parser_error (parser, \"namespace name required\");\n-  \n+\n   if (nested_definition_count && attribs)\n     error_at (token->location,\n \t      \"a nested namespace definition cannot have attributes\");\n@@ -19356,7 +19356,7 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n     return;\n   /* Look for the `=' token.  */\n   if (!cp_parser_uncommitted_to_tentative_parse_p (parser)\n-      && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)) \n+      && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n       error_at (token->location, \"%<namespace%> definition is not allowed here\");\n       /* Skip the definition.  */\n@@ -19406,15 +19406,15 @@ cp_parser_qualified_namespace_specifier (cp_parser* parser)\n \n    using-declaration:\n      using typename [opt] :: [opt] nested-name-specifier unqualified-id ;\n-     using :: unqualified-id ;  \n+     using :: unqualified-id ;\n \n    access-declaration:\n-     qualified-id ;  \n+     qualified-id ;\n \n    */\n \n static bool\n-cp_parser_using_declaration (cp_parser* parser, \n+cp_parser_using_declaration (cp_parser* parser,\n \t\t\t     bool access_declaration_p)\n {\n   cp_token *token;\n@@ -19435,7 +19435,7 @@ cp_parser_using_declaration (cp_parser* parser,\n     {\n       /* Look for the `using' keyword.  */\n       cp_parser_require_keyword (parser, RID_USING, RT_USING);\n-      \n+\n  again:\n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -20530,7 +20530,7 @@ cp_parser_init_declarator (cp_parser* parser,\n     /* Core issue #226 (C++0x only): A default template-argument\n        shall not be specified in a friend class template\n        declaration. */\n-    check_default_tmpl_args (decl, current_template_parms, /*is_primary=*/true, \n+    check_default_tmpl_args (decl, current_template_parms, /*is_primary=*/true,\n                              /*is_partial=*/false, /*is_friend_decl=*/1);\n \n   if (!friend_p && pushed_scope)\n@@ -21870,7 +21870,7 @@ cp_parser_type_id_1 (cp_parser *parser, cp_parser_flags flags,\n \t    return error_mark_node;\n \t  }\n       }\n-  \n+\n   return groktypename (&type_specifier_seq, abstract_declarator,\n \t\t       is_template_arg);\n }\n@@ -22475,7 +22475,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t  /* Consume the `...'. */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  maybe_warn_variadic_templates ();\n-\t  \n+\n \t  /* Build a pack expansion type */\n \t  if (template_parm_p)\n \t    template_parameter_pack_p = true;\n@@ -22529,11 +22529,11 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t       || (decl_specifiers.type\n \t\t   && PACK_EXPANSION_P (decl_specifiers.type)))\n \t{\n-\t  /* Find the name of the parameter pack.  */     \n+\t  /* Find the name of the parameter pack.  */\n \t  cp_declarator *id_declarator = declarator;\n \t  while (id_declarator && id_declarator->kind != cdk_id)\n \t    id_declarator = id_declarator->declarator;\n-\t  \n+\n \t  if (id_declarator && id_declarator->kind == cdk_id)\n \t    error_at (declarator_token_start->location,\n \t\t      template_parm_p\n@@ -22824,7 +22824,7 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n    production is used).  The TREE_TYPE for the CONSTRUCTOR will be\n    NULL_TREE.  There is no way to detect whether or not the optional\n    trailing `,' was provided.  NON_CONSTANT_P is as for\n-   cp_parser_initializer.  */     \n+   cp_parser_initializer.  */\n \n static cp_expr\n cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n@@ -22925,7 +22925,7 @@ cp_parser_array_designator_p (cp_parser *parser)\n   bool array_designator_p\n     = (cp_parser_skip_to_closing_square_bracket (parser)\n        && cp_lexer_next_token_is (parser->lexer, CPP_EQ));\n-  \n+\n   /* Roll back the tokens we skipped.  */\n   cp_lexer_rollback_tokens (parser->lexer);\n \n@@ -23313,7 +23313,7 @@ cp_parser_class_name (cp_parser *parser,\n \t   /* In Objective-C 2.0, a classname followed by '.' starts a\n \t      dot-syntax expression, and it's not a type-name.  */\n \t   || (c_dialect_objc ()\n-\t       && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT \n+\t       && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT\n \t       && objc_is_class_name (decl)))\n     decl = error_mark_node;\n \n@@ -24296,7 +24296,7 @@ cp_parser_type_parameter_key (cp_parser* parser)\n       if (pedantic && tag_type == typename_type && cxx_dialect < cxx17)\n \t/* typename is not allowed in a template template parameter\n \t   by the standard until C++17.  */\n-\tpedwarn (token->location, OPT_Wpedantic, \n+\tpedwarn (token->location, OPT_Wpedantic,\n \t\t \"ISO C++ forbids typename key in template template parameter;\"\n \t\t \" use %<-std=c++17%> or %<-std=gnu++17%>\");\n     }\n@@ -24385,7 +24385,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n    member-declarator:\n      declarator attributes [opt] pure-specifier [opt]\n      declarator attributes [opt] constant-initializer [opt]\n-     identifier [opt] attributes [opt] : constant-expression  \n+     identifier [opt] attributes [opt] : constant-expression\n \n    C++0x Extensions:\n \n@@ -24696,7 +24696,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t    }\n \t\t}\n \t      else\n-\t\t{ \n+\t\t{\n \t\t  /* Look for attributes that apply to the bitfield after\n \t\t     the `:' token and width.  This is where GCC used to\n \t\t     parse attributes in the past, pedwarn if there is\n@@ -25882,8 +25882,8 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       /* Look for the `)'.  */\n       parens.require_close (parser);\n \n-      if (name == error_mark_node \n-\t  || string_literal == error_mark_node \n+      if (name == error_mark_node\n+\t  || string_literal == error_mark_node\n \t  || expression == error_mark_node)\n         invalid_operands = true;\n \n@@ -26166,7 +26166,7 @@ cp_parser_gnu_attribute_list (cp_parser* parser, bool exactly_one /* = false */)\n \n \t  /* Save away the identifier that indicates which attribute\n \t     this is.  */\n-\t  identifier = (token->type == CPP_KEYWORD) \n+\t  identifier = (token->type == CPP_KEYWORD)\n \t    /* For keywords, use the canonical spelling, not the\n \t       parsed identifier.  */\n \t    ? ridpointers[(int) token->keyword]\n@@ -26183,9 +26183,9 @@ cp_parser_gnu_attribute_list (cp_parser* parser, bool exactly_one /* = false */)\n \t      vec<tree, va_gc> *vec;\n \t      int attr_flag = (attribute_takes_identifier_p (identifier)\n \t\t\t       ? id_attr : normal_attr);\n-\t      vec = cp_parser_parenthesized_expression_list \n-\t\t    (parser, attr_flag, /*cast_p=*/false, \n-\t\t    /*allow_expansion_p=*/false, \n+\t      vec = cp_parser_parenthesized_expression_list\n+\t\t    (parser, attr_flag, /*cast_p=*/false,\n+\t\t    /*allow_expansion_p=*/false,\n \t\t    /*non_constant_p=*/NULL);\n \t      if (vec == NULL)\n \t\targuments = error_mark_node;\n@@ -27538,7 +27538,7 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n \t    template_id_p = true;\n \t  }\n \n-\treturn cp_parser_check_template_parameters \n+\treturn cp_parser_check_template_parameters\n \t  (parser, num_templates, template_id_p, declarator_location,\n \t   declarator);\n       }\n@@ -27590,14 +27590,14 @@ cp_parser_check_template_parameters (cp_parser* parser,\n     {\n       if (declarator && !current_function_decl)\n \terror_at (location, \"specializing member %<%T::%E%> \"\n-\t\t  \"requires %<template<>%> syntax\", \n+\t\t  \"requires %<template<>%> syntax\",\n \t\t  declarator->u.id.qualifying_scope,\n \t\t  declarator->u.id.unqualified_name);\n       else if (declarator)\n \terror_at (location, \"invalid declaration of %<%T::%E%>\",\n \t\t  declarator->u.id.qualifying_scope,\n \t\t  declarator->u.id.unqualified_name);\n-      else \n+      else\n \terror_at (location, \"too few template-parameter-lists\");\n       return false;\n     }\n@@ -29307,8 +29307,8 @@ cp_parser_set_storage_class (cp_parser *parser,\n   decl_specs->storage_class = storage_class;\n   set_and_check_decl_spec_loc (decl_specs, ds_storage_class, token);\n \n-  /* A storage class specifier cannot be applied alongside a typedef \n-     specifier. If there is a typedef specifier present then set \n+  /* A storage class specifier cannot be applied alongside a typedef\n+     specifier. If there is a typedef specifier present then set\n      conflicting_specifiers_p which will trigger an error later\n      on in grokdeclarator. */\n   if (decl_spec_seq_has_spec_p (decl_specs, ds_typedef))\n@@ -29415,7 +29415,7 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,\n \t    {\n \t      decl_specs->locations[ds_long_long] = location;\n \t      pedwarn_cxx98 (location,\n-\t\t\t     OPT_Wlong_long, \n+\t\t\t     OPT_Wlong_long,\n \t\t\t     \"ISO C++ 1998 does not support %<long long%>\");\n \t    }\n \t}\n@@ -29843,7 +29843,7 @@ cp_parser_next_token_ends_template_argument_p (cp_parser *parser)\n   cp_token *token;\n \n   token = cp_lexer_peek_token (parser->lexer);\n-  return (token->type == CPP_COMMA \n+  return (token->type == CPP_COMMA\n           || token->type == CPP_GREATER\n           || token->type == CPP_ELLIPSIS\n \t  || ((cxx_dialect != cxx98) && token->type == CPP_RSHIFT));\n@@ -30528,7 +30528,7 @@ cp_parser_objc_message_receiver (cp_parser* parser)\n \n   if (cp_parser_parse_definitely (parser))\n     return objc_get_class_reference (rcv);\n-  \n+\n   cp_parser_error (parser, \"objective-c++ message receiver expected\");\n   return error_mark_node;\n }\n@@ -30629,7 +30629,7 @@ cp_parser_objc_encode_expression (cp_parser* parser)\n \n   if (!type)\n     {\n-      error_at (token->location, \n+      error_at (token->location,\n \t\t\"%<@encode%> must specify a type as an argument\");\n       return error_mark_node;\n     }\n@@ -30811,7 +30811,7 @@ cp_parser_objc_identifier_list (cp_parser* parser)\n \n   identifier = cp_parser_identifier (parser);\n   if (identifier == error_mark_node)\n-    return error_mark_node;      \n+    return error_mark_node;\n \n   list = build_tree_list (NULL_TREE, identifier);\n   sep = cp_lexer_peek_token (parser->lexer);\n@@ -30827,7 +30827,7 @@ cp_parser_objc_identifier_list (cp_parser* parser)\n \t\t\t\t\t     identifier));\n       sep = cp_lexer_peek_token (parser->lexer);\n     }\n-  \n+\n   return list;\n }\n \n@@ -30866,11 +30866,11 @@ cp_parser_objc_class_declaration (cp_parser* parser)\n   while (true)\n     {\n       tree id;\n-      \n+\n       id = cp_parser_identifier (parser);\n       if (id == error_mark_node)\n \tbreak;\n-      \n+\n       objc_declare_class (id);\n \n       if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n@@ -30994,7 +30994,7 @@ cp_parser_objc_typename (cp_parser* parser)\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n \t{\n \t  cp_type = cp_parser_type_id (parser);\n-\t  \n+\n \t  /* If the type could not be parsed, an error has already\n \t     been produced.  For error recovery, behave as if it had\n \t     not been specified, which will use the default type\n@@ -31126,7 +31126,7 @@ cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)\n       if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n \t  || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n \treturn params;\n-      cp_parser_error (parser, \n+      cp_parser_error (parser,\n \t\t       \"method attributes must be specified at the end\");\n       return error_mark_node;\n     }\n@@ -31142,7 +31142,7 @@ cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)\n /* Parse the non-keyword Objective-C params.  */\n \n static tree\n-cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp, \n+cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp,\n \t\t\t\t       tree* attributes)\n {\n   tree params = make_node (TREE_LIST);\n@@ -31187,12 +31187,12 @@ cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp,\n \t      || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n \t    return params;\n \t}\n-      else        \n-\t/* We have an error, but parse the attributes, so that we can \n+      else\n+\t/* We have an error, but parse the attributes, so that we can\n \t   carry on.  */\n \t*attributes = cp_parser_attributes_opt (parser);\n \n-      cp_parser_error (parser, \n+      cp_parser_error (parser,\n \t\t       \"method attributes must be specified at the end\");\n       return error_mark_node;\n     }\n@@ -31269,11 +31269,11 @@ cp_parser_objc_method_signature (cp_parser* parser, tree* attributes)\n static bool\n cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)\n {\n-  tree tattr;  \n+  tree tattr;\n   cp_lexer_save_tokens (parser->lexer);\n   tattr = cp_parser_attributes_opt (parser);\n   gcc_assert (tattr) ;\n-  \n+\n   /* If the attributes are followed by a method introducer, this is not allowed.\n      Dump the attributes and flag the situation.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_PLUS)\n@@ -31283,7 +31283,7 @@ cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)\n   /* Otherwise, the attributes introduce some interstitial code, possibly so\n      rewind to allow that check.  */\n   cp_lexer_rollback_tokens (parser->lexer);\n-  return false;  \n+  return false;\n }\n \n /* Parse an Objective-C method prototype list.  */\n@@ -31315,10 +31315,10 @@ cp_parser_objc_method_prototype_list (cp_parser* parser)\n \t}\n       else if (token->keyword == RID_AT_PROPERTY)\n \tcp_parser_objc_at_property_declaration (parser);\n-      else if (token->keyword == RID_ATTRIBUTE \n+      else if (token->keyword == RID_ATTRIBUTE\n       \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n-\twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n-\t\t    OPT_Wattributes, \n+\twarning_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t    OPT_Wattributes,\n \t\t    \"prefix attributes are ignored for methods\");\n       else\n \t/* Allow for interspersed non-ObjC++ code.  */\n@@ -31371,7 +31371,7 @@ cp_parser_objc_method_definition_list (cp_parser* parser)\n \t    cp_lexer_consume_token (parser->lexer);\n \n \t  ptk = cp_lexer_peek_token (parser->lexer);\n-\t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS \n+\t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS\n \t\t|| ptk->type == CPP_EOF || ptk->keyword == RID_AT_END))\n \t    {\n \t      perform_deferred_access_checks (tf_warning_or_error);\n@@ -31390,7 +31390,7 @@ cp_parser_objc_method_definition_list (cp_parser* parser)\n \tcp_parser_objc_at_synthesize_declaration (parser);\n       else if (token->keyword == RID_AT_DYNAMIC)\n \tcp_parser_objc_at_dynamic_declaration (parser);\n-      else if (token->keyword == RID_ATTRIBUTE \n+      else if (token->keyword == RID_ATTRIBUTE\n       \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n \twarning_at (token->location, OPT_Wattributes,\n \t       \t    \"prefix attributes are ignored for methods\");\n@@ -31422,7 +31422,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n   cp_lexer_consume_token (parser->lexer);  /* Eat '{'.  */\n   token = cp_lexer_peek_token (parser->lexer);\n \n-  while (token->type != CPP_CLOSE_BRACE \n+  while (token->type != CPP_CLOSE_BRACE\n \t&& token->keyword != RID_AT_END && token->type != CPP_EOF)\n     {\n       cp_decl_specifier_seq declspecs;\n@@ -31442,7 +31442,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n       /* auto, register, static, extern, mutable.  */\n       if (declspecs.storage_class != sc_none)\n \t{\n-\t  cp_parser_error (parser, \"invalid type for instance variable\");\t  \n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\n \t  declspecs.storage_class = sc_none;\n \t}\n \n@@ -31452,7 +31452,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t  cp_parser_error (parser, \"invalid type for instance variable\");\n \t  declspecs.locations[ds_thread] = 0;\n \t}\n-      \n+\n       /* typedef.  */\n       if (decl_spec_seq_has_spec_p (&declspecs, ds_typedef))\n \t{\n@@ -31552,10 +31552,10 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n     cp_parser_error (parser, \"expected %<}%>\");\n \n   /* Do not consume the RID_AT_END, so it will be read again as terminating\n-     the @interface of @implementation.  */ \n+     the @interface of @implementation.  */\n   if (token->keyword != RID_AT_END && token->type != CPP_EOF)\n     cp_lexer_consume_token (parser->lexer);  /* Eat '}'.  */\n-    \n+\n   /* For historical reasons, we accept an optional semicolon.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n     cp_lexer_consume_token (parser->lexer);\n@@ -31587,13 +31587,13 @@ cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)\n       while (true)\n \t{\n \t  tree id;\n-\t  \n+\n \t  id = cp_parser_identifier (parser);\n \t  if (id == error_mark_node)\n \t    break;\n-\t  \n+\n \t  objc_declare_protocol (id, attributes);\n-\t  \n+\n \t  if(cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t    cp_lexer_consume_token (parser->lexer);\n \t  else\n@@ -31615,7 +31615,7 @@ cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)\n /* Parse an Objective-C superclass or category.  */\n \n static void\n-cp_parser_objc_superclass_or_category (cp_parser *parser, \n+cp_parser_objc_superclass_or_category (cp_parser *parser,\n \t\t\t\t       bool iface_p,\n \t\t\t\t       tree *super,\n \t\t\t\t       tree *categ, bool *is_class_extension)\n@@ -31810,7 +31810,7 @@ cp_parser_objc_declaration (cp_parser* parser, tree attributes)\n    Returns NULL_TREE.\n \n    PS: This function is identical to c_parser_objc_try_catch_finally_statement\n-   for C.  Keep them in sync.  */   \n+   for C.  Keep them in sync.  */\n \n static tree\n cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n@@ -31875,7 +31875,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n \t     going.  */\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n \t    cp_lexer_consume_token (parser->lexer);\n-\t  \n+\n \t  /* If these is no immediate closing parenthesis, the user\n \t     probably doesn't know that parenthesis are required at\n \t     all (ie, they typed \"@catch NSException *e\").  So, just\n@@ -31977,9 +31977,9 @@ cp_parser_objc_statement (cp_parser * parser)\n   return error_mark_node;\n }\n \n-/* If we are compiling ObjC++ and we see an __attribute__ we neeed to \n+/* If we are compiling ObjC++ and we see an __attribute__ we neeed to\n    look ahead to see if an objc keyword follows the attributes.  This\n-   is to detect the use of prefix attributes on ObjC @interface and \n+   is to detect the use of prefix attributes on ObjC @interface and\n    @protocol.  */\n \n static bool\n@@ -31994,7 +31994,7 @@ cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)\n       return true;\n     }\n   cp_lexer_rollback_tokens (parser->lexer);\n-  return false;  \n+  return false;\n }\n \n /* This routine is a minimal replacement for\n@@ -32031,14 +32031,14 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n       cp_parser_error (parser, \"invalid type for property\");\n       declspecs.storage_class = sc_none;\n     }\n-  \n+\n   /* thread_local.  */\n   if (decl_spec_seq_has_spec_p (&declspecs, ds_thread))\n     {\n       cp_parser_error (parser, \"invalid type for property\");\n       declspecs.locations[ds_thread] = 0;\n     }\n-  \n+\n   /* typedef.  */\n   if (decl_spec_seq_has_spec_p (&declspecs, ds_typedef))\n     {\n@@ -32075,7 +32075,7 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n \n       if (decl == error_mark_node || decl == NULL_TREE)\n \treturn error_mark_node;\n-      \n+\n       /* Reset PREFIX_ATTRIBUTES.  */\n       if (attributes != error_mark_node)\n \t{\n@@ -32130,7 +32130,7 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n \n    PS: This function is identical to\n    c_parser_objc_at_property_declaration for C.  Keep them in sync.  */\n-static void \n+static void\n cp_parser_objc_at_property_declaration (cp_parser *parser)\n {\n   /* The following variables hold the attributes of the properties as\n@@ -32281,15 +32281,15 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n       /* Comma-separated properties are chained together in\n \t reverse order; add them one by one.  */\n       properties = nreverse (properties);\n-      \n+\n       for (; properties; properties = TREE_CHAIN (properties))\n \tobjc_add_property_declaration (loc, copy_node (properties),\n \t\t\t\t       property_readonly, property_readwrite,\n \t\t\t\t       property_assign, property_retain,\n \t\t\t\t       property_copy, property_nonatomic,\n \t\t\t\t       property_getter_ident, property_setter_ident);\n     }\n-  \n+\n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n }\n \n@@ -32313,7 +32313,7 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n   PS: This function is identical to c_parser_objc_at_synthesize_declaration\n   for C.  Keep them in sync.\n */\n-static void \n+static void\n cp_parser_objc_at_synthesize_declaration (cp_parser *parser)\n {\n   tree list = NULL_TREE;\n@@ -32364,7 +32364,7 @@ cp_parser_objc_at_synthesize_declaration (cp_parser *parser)\n   PS: This function is identical to c_parser_objc_at_dynamic_declaration\n   for C.  Keep them in sync.\n */\n-static void \n+static void\n cp_parser_objc_at_dynamic_declaration (cp_parser *parser)\n {\n   tree list = NULL_TREE;\n@@ -33147,7 +33147,7 @@ cp_parser_oacc_clause_tile (cp_parser *parser, location_t clause_loc, tree list)\n     {\n       if (tile && !cp_parser_require (parser, CPP_COMMA, RT_COMMA))\n \treturn list;\n-      \n+\n       if (cp_lexer_next_token_is (parser->lexer, CPP_MULT)\n \t  && (cp_lexer_nth_token_is (parser->lexer, 2, CPP_COMMA)\n \t      || cp_lexer_nth_token_is (parser->lexer, 2, CPP_CLOSE_PAREN)))\n@@ -34472,7 +34472,7 @@ cp_parser_omp_clause_lastprivate (cp_parser *parser, tree list)\n    linear ( modifier ( variable-list ) : expression ) */\n \n static tree\n-cp_parser_omp_clause_linear (cp_parser *parser, tree list, \n+cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n \t\t\t     bool declare_simd)\n {\n   tree nlist, c, step = integer_one_node;\n@@ -36700,10 +36700,10 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n       attributes = cp_parser_attributes_opt (parser);\n       asm_specification = cp_parser_asm_specification_opt (parser);\n \n-      if (declarator == cp_error_declarator) \n+      if (declarator == cp_error_declarator)\n \tcp_parser_skip_to_end_of_statement (parser);\n \n-      else \n+      else\n \t{\n \t  tree pushed_scope, auto_node;\n \n@@ -36715,7 +36715,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t  auto_node = type_uses_auto (TREE_TYPE (decl));\n \t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n \t    {\n-\t      if (cp_lexer_next_token_is (parser->lexer, \n+\t      if (cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t  CPP_OPEN_PAREN))\n \t        error (\"parenthesized initialization is not allowed in \"\n \t\t       \"OpenMP %<for%> loop\");\n@@ -36746,7 +36746,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t\t      && !type_dependent_expression_p (decl))\n \t\t    goto non_class;\n \t\t}\n-\t\t      \n+\n \t      cp_finish_decl (decl, init, !is_non_constant_init,\n \t\t\t      asm_specification,\n \t\t\t      LOOKUP_ONLYCONVERTING);\n@@ -36806,7 +36806,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t    pop_scope (pushed_scope);\n \t}\n     }\n-  else \n+  else\n     {\n       cp_id_kind idk;\n       /* If parsing a type specifier sequence failed, then\n@@ -39855,7 +39855,7 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n   cp_token_cache *cp;\n   int errs;\n   void *p;\n-    \n+\n   /* Get the high-water mark for the DECLARATOR_OBSTACK.  */\n   p = obstack_alloc (&declarator_obstack, 0);\n \n@@ -41364,7 +41364,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n       break;\n \n     case PRAGMA_OMP_SECTION:\n-      error_at (pragma_tok->location, \n+      error_at (pragma_tok->location,\n \t\t\"%<#pragma omp section%> may only be used in \"\n \t\t\"%<#pragma omp sections%> construct\");\n       break;"}, {"sha": "c5161a7782f16b90dcb514e77a1a766a29b4e5c6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "patch": "@@ -2238,10 +2238,10 @@ determine_specialization (tree template_id,\n \t  /* Skip the \"this\" parameter and, for constructors of\n \t     classes with virtual bases, the VTT parameter.  A\n \t     full specialization of a constructor will have a VTT\n-\t     parameter, but a template never will.  */ \n-\t  decl_arg_types \n+\t     parameter, but a template never will.  */\n+\t  decl_arg_types\n \t    = skip_artificial_parms_for (decl, decl_arg_types);\n-\t  fn_arg_types \n+\t  fn_arg_types\n \t    = skip_artificial_parms_for (fn, fn_arg_types);\n \n \t  /* Function templates cannot be specializations; there are\n@@ -2913,7 +2913,7 @@ check_explicit_specialization (tree declarator,\n       for (; t; t = TREE_CHAIN (t))\n \tif (TREE_PURPOSE (t))\n \t  {\n-\t    permerror (input_location, \n+\t    permerror (input_location,\n \t\t       \"default argument specified in explicit specialization\");\n \t    break;\n \t  }\n@@ -3303,18 +3303,18 @@ comp_template_parms (const_tree parms1, const_tree parms2)\n \n /* Determine whether PARM is a parameter pack.  */\n \n-bool \n+bool\n template_parameter_pack_p (const_tree parm)\n {\n   /* Determine if we have a non-type template parameter pack.  */\n   if (TREE_CODE (parm) == PARM_DECL)\n-    return (DECL_TEMPLATE_PARM_P (parm) \n+    return (DECL_TEMPLATE_PARM_P (parm)\n             && TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)));\n   if (TREE_CODE (parm) == TEMPLATE_PARM_INDEX)\n     return TEMPLATE_PARM_PARAMETER_PACK (parm);\n \n   /* If this is a list of template parameters, we could get a\n-     TYPE_DECL or a TEMPLATE_DECL.  */ \n+     TYPE_DECL or a TEMPLATE_DECL.  */\n   if (TREE_CODE (parm) == TYPE_DECL || TREE_CODE (parm) == TEMPLATE_DECL)\n     parm = TREE_TYPE (parm);\n \n@@ -3366,7 +3366,7 @@ function_parameter_expanded_from_pack_p (tree param_decl, tree pack)\n /* Determine whether ARGS describes a variadic template args list,\n    i.e., one that is terminated by a template argument pack.  */\n \n-static bool \n+static bool\n template_args_variadic_p (tree args)\n {\n   int nargs;\n@@ -3640,7 +3640,7 @@ expand_builtin_pack_call (tree call, tree args, tsubst_flags_t complain,\n }\n \n /* Structure used to track the progress of find_parameter_packs_r.  */\n-struct find_parameter_pack_data \n+struct find_parameter_pack_data\n {\n   /* TREE_LIST that will contain all of the parameter packs found by\n      the traversal.  */\n@@ -3661,7 +3661,7 @@ static tree\n find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n {\n   tree t = *tp;\n-  struct find_parameter_pack_data* ppd = \n+  struct find_parameter_pack_data* ppd =\n     (struct find_parameter_pack_data*)data;\n   bool parameter_pack_p = false;\n \n@@ -3746,22 +3746,22 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n     }\n \n   if (TYPE_P (t))\n-    cp_walk_tree (&TYPE_CONTEXT (t), \n+    cp_walk_tree (&TYPE_CONTEXT (t),\n \t\t  &find_parameter_packs_r, ppd, ppd->visited);\n \n   /* This switch statement will return immediately if we don't find a\n      parameter pack.  */\n-  switch (TREE_CODE (t)) \n+  switch (TREE_CODE (t))\n     {\n     case TEMPLATE_PARM_INDEX:\n       return NULL_TREE;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       /* Check the template itself.  */\n-      cp_walk_tree (&TREE_TYPE (TYPE_TI_TEMPLATE (t)), \n+      cp_walk_tree (&TREE_TYPE (TYPE_TI_TEMPLATE (t)),\n \t\t    &find_parameter_packs_r, ppd, ppd->visited);\n       /* Check the template arguments.  */\n-      cp_walk_tree (&TYPE_TI_ARGS (t), &find_parameter_packs_r, ppd, \n+      cp_walk_tree (&TYPE_TI_ARGS (t), &find_parameter_packs_r, ppd,\n \t\t    ppd->visited);\n       *walk_subtrees = 0;\n       return NULL_TREE;\n@@ -3802,26 +3802,26 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n       cp_walk_tree (&TREE_TYPE (t),\n \t\t    &find_parameter_packs_r, ppd, ppd->visited);\n       return NULL_TREE;\n- \n+\n     case TYPENAME_TYPE:\n       cp_walk_tree (&TYPENAME_TYPE_FULLNAME (t), &find_parameter_packs_r,\n                    ppd, ppd->visited);\n       *walk_subtrees = 0;\n       return NULL_TREE;\n-      \n+\n     case TYPE_PACK_EXPANSION:\n     case EXPR_PACK_EXPANSION:\n       *walk_subtrees = 0;\n       return NULL_TREE;\n \n     case INTEGER_TYPE:\n-      cp_walk_tree (&TYPE_MAX_VALUE (t), &find_parameter_packs_r, \n+      cp_walk_tree (&TYPE_MAX_VALUE (t), &find_parameter_packs_r,\n \t\t    ppd, ppd->visited);\n       *walk_subtrees = 0;\n       return NULL_TREE;\n \n     case IDENTIFIER_NODE:\n-      cp_walk_tree (&TREE_TYPE (t), &find_parameter_packs_r, ppd, \n+      cp_walk_tree (&TREE_TYPE (t), &find_parameter_packs_r, ppd,\n \t\t    ppd->visited);\n       *walk_subtrees = 0;\n       return NULL_TREE;\n@@ -3894,7 +3894,7 @@ uses_parameter_packs (tree t)\n    expansion. If all goes well, the resulting node will be an\n    EXPR_PACK_EXPANSION, TYPE_PACK_EXPANSION, or TREE_LIST,\n    respectively.  */\n-tree \n+tree\n make_pack_expansion (tree arg, tsubst_flags_t complain)\n {\n   tree result;\n@@ -3936,7 +3936,7 @@ make_pack_expansion (tree arg, tsubst_flags_t complain)\n       ppd.parameter_packs = &parameter_packs;\n       ppd.type_pack_expansion_p = false;\n       gcc_assert (TYPE_P (TREE_PURPOSE (arg)));\n-      cp_walk_tree (&TREE_PURPOSE (arg), &find_parameter_packs_r, \n+      cp_walk_tree (&TREE_PURPOSE (arg), &find_parameter_packs_r,\n                     &ppd, ppd.visited);\n \n       if (parameter_packs == NULL_TREE)\n@@ -4033,11 +4033,11 @@ make_pack_expansion (tree arg, tsubst_flags_t complain)\n    where \"args\" is a parameter pack. check_for_bare_parameter_packs\n    should not be called for the subexpressions args, h(args),\n    g(h(args)), or f(g(h(args))), because we would produce erroneous\n-   error messages. \n+   error messages.\n \n    Returns TRUE and emits an error if there were bare parameter packs,\n    returns FALSE otherwise.  */\n-bool \n+bool\n check_for_bare_parameter_packs (tree t, location_t loc /* = UNKNOWN_LOCATION */)\n {\n   tree parameter_packs = NULL_TREE;\n@@ -4060,7 +4060,7 @@ check_for_bare_parameter_packs (tree t, location_t loc /* = UNKNOWN_LOCATION */)\n   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);\n   delete ppd.visited;\n \n-  if (parameter_packs) \n+  if (parameter_packs)\n     {\n       if (loc == UNKNOWN_LOCATION)\n \tloc = cp_expr_loc_or_loc (t, input_location);\n@@ -4298,7 +4298,7 @@ reduce_template_parm_level (tree index, tree type, int levels, tree args,\n \t\t\t\t     TEMPLATE_PARM_ORIG_LEVEL (index),\n \t\t\t\t     decl, type);\n       TEMPLATE_PARM_DESCENDANTS (index) = t;\n-      TEMPLATE_PARM_PARAMETER_PACK (t) \n+      TEMPLATE_PARM_PARAMETER_PACK (t)\n \t= TEMPLATE_PARM_PARAMETER_PACK (index);\n \n \t/* Template template parameters need this.  */\n@@ -4391,7 +4391,7 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n \t\t\t\t     processing_template_decl,\n \t\t\t\t     decl, TREE_TYPE (parm));\n \n-      TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)) \n+      TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm))\n \t= is_parameter_pack;\n     }\n   else\n@@ -4900,7 +4900,7 @@ process_partial_specialization (tree decl)\n \n      The type of a template parameter corresponding to a specialized\n      non-type argument shall not be dependent on a parameter of the\n-     specialization. \n+     specialization.\n \n      Also, we verify that pack expansions only occur at the\n      end of the argument list.  */\n@@ -5279,7 +5279,7 @@ check_default_tmpl_args (tree decl, tree parms, bool is_primary,\n \t\t  error (\"parameter pack %q+D must be at the end of the\"\n \t\t\t \" template parameter list\", TREE_VALUE (parm));\n \n-\t\t  TREE_VALUE (TREE_VEC_ELT (inner_parms, i)) \n+\t\t  TREE_VALUE (TREE_VEC_ELT (inner_parms, i))\n \t\t    = error_mark_node;\n \t\t  no_errors = false;\n \t\t}\n@@ -5288,7 +5288,7 @@ check_default_tmpl_args (tree decl, tree parms, bool is_primary,\n     }\n \n   if (((cxx_dialect == cxx98) && TREE_CODE (decl) != TYPE_DECL)\n-      || is_partial \n+      || is_partial\n       || !is_primary\n       || is_friend_decl)\n     /* For an ordinary class template, default template arguments are\n@@ -5497,7 +5497,7 @@ push_template_decl_real (tree decl, bool is_friend)\n   if (is_primary)\n     {\n       warning (OPT_Wtemplates, \"template %qD declared\", decl);\n-      \n+\n       if (DECL_CLASS_SCOPE_P (decl))\n \tmember_template_p = true;\n       if (TREE_CODE (decl) == TYPE_DECL\n@@ -6244,7 +6244,7 @@ convert_nontype_argument_function (tree type, tree expr,\n     fn_no_ptr = TREE_OPERAND (fn_no_ptr, 0);\n   if (BASELINK_P (fn_no_ptr))\n     fn_no_ptr = BASELINK_FUNCTIONS (fn_no_ptr);\n- \n+\n   /* [temp.arg.nontype]/1\n \n      A template-argument for a non-type, non-template template-parameter\n@@ -7228,10 +7228,10 @@ coerce_template_template_parm (tree parm,\n   if (arg == NULL_TREE || error_operand_p (arg)\n       || parm == NULL_TREE || error_operand_p (parm))\n     return 0;\n-  \n+\n   if (TREE_CODE (arg) != TREE_CODE (parm))\n     return 0;\n-  \n+\n   switch (TREE_CODE (parm))\n     {\n     case TEMPLATE_DECL:\n@@ -7241,23 +7241,23 @@ coerce_template_template_parm (tree parm,\n       {\n \ttree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n \ttree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n-\t\n+\n \tif (!coerce_template_template_parms\n \t    (parmparm, argparm, complain, in_decl, outer_args))\n \t  return 0;\n       }\n       /* Fall through.  */\n-      \n+\n     case TYPE_DECL:\n       if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (arg))\n \t  && !TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (parm)))\n \t/* Argument is a parameter pack but parameter is not.  */\n \treturn 0;\n       break;\n-      \n+\n     case PARM_DECL:\n       /* The tsubst call is used to handle cases such as\n-\t \n+\n            template <int> class C {};\n \t   template <class T, template <T> class TT> class D {};\n \t   D<int, C> d;\n@@ -7270,12 +7270,12 @@ coerce_template_template_parm (tree parm,\n \t      && !same_type_p (t, TREE_TYPE (arg)))\n \t    return 0;\n \t}\n-      \n+\n       if (TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (arg))\n \t  && !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))\n \t/* Argument is a parameter pack but parameter is not.  */\n \treturn 0;\n-      \n+\n       break;\n \n     default:\n@@ -7595,7 +7595,7 @@ coerce_template_template_parms (tree parm_parms,\n   if (TREE_VEC_ELT (parm_parms, nparms - 1) != error_mark_node)\n     {\n       parm = TREE_VALUE (TREE_VEC_ELT (parm_parms, nparms - 1));\n-      \n+\n       if (error_operand_p (parm))\n \treturn 0;\n \n@@ -7606,17 +7606,17 @@ coerce_template_template_parms (tree parm_parms,\n           if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (parm)))\n             variadic_p = 1;\n           break;\n-\t  \n+\n         case PARM_DECL:\n           if (TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))\n             variadic_p = 1;\n           break;\n-\t  \n+\n         default:\n           gcc_unreachable ();\n         }\n     }\n- \n+\n   if (nargs != nparms\n       && !(variadic_p && nargs >= nparms - 1))\n     return 0;\n@@ -7652,9 +7652,9 @@ coerce_template_template_parms (tree parm_parms,\n         {\n           if (TREE_VEC_ELT (arg_parms, i) == error_mark_node)\n             continue;\n- \n+\n           arg = TREE_VALUE (TREE_VEC_ELT (arg_parms, i));\n- \n+\n           if (!coerce_template_template_parm (parm, arg, complain, in_decl,\n                                               outer_args))\n             return 0;\n@@ -7672,7 +7672,7 @@ coerce_template_template_parms (tree parm_parms,\n    routine can only be called after all template arguments have been\n    deduced. It will return TRUE if all of the template template\n    parameter bindings are okay, FALSE otherwise.  */\n-bool \n+bool\n template_template_parm_bindings_ok_p (tree tparms, tree targs)\n {\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n@@ -7916,7 +7916,7 @@ convert_template_argument (tree parm,\n \t}\n     }\n \n-  is_tmpl_type = \n+  is_tmpl_type =\n     ((TREE_CODE (arg) == TEMPLATE_DECL\n       && TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n      || (requires_tmpl_type && TREE_CODE (arg) == TYPE_ARGUMENT_PACK)\n@@ -8270,7 +8270,7 @@ coerce_template_parameter_pack (tree parms,\n \t    error (\"template argument %d is invalid\", arg_idx + 1);\n \t}\n       else\n-\targ = convert_template_argument (actual_parm, \n+\targ = convert_template_argument (actual_parm,\n \t\t\t\t\t arg, new_args, complain, parm_idx,\n \t\t\t\t\t in_decl);\n       if (arg == error_mark_node)\n@@ -8474,7 +8474,7 @@ coerce_template_parms (tree parms,\n \n       /* Get the Ith template parameter.  */\n       parm = TREE_VEC_ELT (parms, parm_idx);\n- \n+\n       if (parm == error_mark_node)\n \t{\n \t  TREE_VEC_ELT (new_inner_args, arg_idx) = error_mark_node;\n@@ -8493,7 +8493,7 @@ coerce_template_parms (tree parms,\n         {\n \t  /* Some arguments will be placed in the\n \t     template parameter pack PARM.  */\n-\t  arg = coerce_template_parameter_pack (parms, parm_idx, args, \n+\t  arg = coerce_template_parameter_pack (parms, parm_idx, args,\n \t\t\t\t\t\tinner_args, arg_idx,\n \t\t\t\t\t\tnew_args, &lost,\n \t\t\t\t\t\tin_decl, complain);\n@@ -8527,7 +8527,7 @@ coerce_template_parms (tree parms,\n \t\t  fixed_pack_adjust += pack_adjust;\n \t\t}\n \t    }\n-          \n+\n           continue;\n         }\n       else if (arg)\n@@ -8597,7 +8597,7 @@ coerce_template_parms (tree parms,\n \t}\n       else\n \targ = convert_template_argument (TREE_VALUE (parm),\n-\t\t\t\t\t arg, new_args, complain, \n+\t\t\t\t\t arg, new_args, complain,\n                                          parm_idx, in_decl);\n \n       if (arg == error_mark_node)\n@@ -9963,7 +9963,7 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n     case UNDERLYING_TYPE:\n       if (pfd->include_nondeduced_p\n \t  && for_each_template_parm (TYPE_VALUES_RAW (t), fn, data,\n-\t\t\t\t     pfd->visited, \n+\t\t\t\t     pfd->visited,\n \t\t\t\t     pfd->include_nondeduced_p,\n \t\t\t\t     pfd->any_fn))\n \treturn error_mark_node;\n@@ -11246,10 +11246,10 @@ instantiate_class_template_1 (tree type)\n               if (TREE_CODE (t) == STATIC_ASSERT)\n                 {\n                   tree condition;\n- \n+\n \t\t  ++c_inhibit_evaluation_warnings;\n \t\t  condition =\n-\t\t    tsubst_expr (STATIC_ASSERT_CONDITION (t), args, \n+\t\t    tsubst_expr (STATIC_ASSERT_CONDITION (t), args,\n \t\t\t\t tf_warning_or_error, NULL_TREE,\n \t\t\t\t /*integral_constant_expression_p=*/true);\n \t\t  --c_inhibit_evaluation_warnings;\n@@ -12185,7 +12185,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n      packs used in the expansion expression. While we're at it,\n      compute the number of arguments to be expanded and make sure it\n      is consistent.  */\n-  for (pack = PACK_EXPANSION_PARAMETER_PACKS (t); pack; \n+  for (pack = PACK_EXPANSION_PARAMETER_PACKS (t); pack;\n        pack = TREE_CHAIN (pack))\n     {\n       tree parm_pack = TREE_VALUE (pack);\n@@ -12273,7 +12273,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       orig_arg = arg_pack;\n       if (arg_pack && TREE_CODE (arg_pack) == ARGUMENT_PACK_SELECT)\n \targ_pack = ARGUMENT_PACK_SELECT_FROM_PACK (arg_pack);\n-      \n+\n       if (arg_pack && !ARGUMENT_PACK_P (arg_pack))\n \t/* This can only happen if we forget to expand an argument\n \t   pack somewhere else. Just return an error, silently.  */\n@@ -12428,7 +12428,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t    continue;\n \n           template_parm_level_and_index (parm, &level, &idx);\n-          \n+\n           /* Update the corresponding argument.  */\n           if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n             TREE_VEC_ELT (TREE_VEC_ELT (args, level -1 ), idx) =\n@@ -12443,7 +12443,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       delete local_specializations;\n       local_specializations = saved_local_specializations;\n     }\n-  \n+\n   /* If the dependent pack arguments were such that we end up with only a\n      single pack expansion again, there's no need to keep it in a TREE_VEC.  */\n   if (len == 1 && TREE_CODE (result) == TREE_VEC\n@@ -13766,7 +13766,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    /* T is a static data member or namespace-scope entity.\n \t       We have to substitute into namespace-scope variables\n \t       (not just variable templates) because of cases like:\n-\t       \n+\n \t         template <class T> void f() { extern T t; }\n \n \t       where the entity referenced is not known until\n@@ -13827,7 +13827,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    spec = retrieve_local_specialization (t);\n \t  }\n \t/* If we already have the specialization we need, there is\n-\t   nothing more to do.  */ \n+\t   nothing more to do.  */\n \tif (spec)\n \t  {\n \t    r = spec;\n@@ -13883,7 +13883,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t   void g() { f x; }\n \n \t\t   declares a function, not a variable.  However:\n-      \n+\n \t\t   typedef void f();\n \t\t   template <typename T> void g() { T t; }\n \t\t   template void g<f>();\n@@ -14052,7 +14052,7 @@ tsubst_arg_types (tree arg_types,\n \n   while (i > 0) {\n     --i;\n-    \n+\n     if (expanded_args)\n       type = TREE_VEC_ELT (expanded_args, i);\n     else if (!type)\n@@ -14073,7 +14073,7 @@ tsubst_arg_types (tree arg_types,\n     /* DR 657. */\n     if (abstract_virtuals_error_sfinae (ACU_PARM, type, complain))\n       return error_mark_node;\n-    \n+\n     /* Do array-to-pointer, function-to-pointer conversion, and ignore\n        top-level qualifiers as required.  */\n     type = cv_unqualified (type_decays_to (type));\n@@ -14102,10 +14102,10 @@ tsubst_arg_types (tree arg_types,\n \t\t       remaining_arg_types);\n       }\n     else\n-      remaining_arg_types = \n+      remaining_arg_types =\n         hash_tree_cons (default_arg, type, remaining_arg_types);\n   }\n-\t\n+\n   return remaining_arg_types;\n }\n \n@@ -14326,7 +14326,7 @@ tsubst_exception_specification (tree fntype,\n \t\t    /* We're substituting into a member template, so\n \t\t       we got a TYPE_PACK_EXPANSION back.  Add that\n \t\t       expansion and move on.  */\n-\t\t    gcc_assert (TREE_CODE (expanded_specs) \n+\t\t    gcc_assert (TREE_CODE (expanded_specs)\n \t\t\t\t== TYPE_PACK_EXPANSION);\n \t\t    new_specs = add_exception_specifier (new_specs,\n \t\t\t\t\t\t\t expanded_specs,\n@@ -14535,7 +14535,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tr = NULL_TREE;\n \n \tgcc_assert (TREE_VEC_LENGTH (args) > 0);\n-\ttemplate_parm_level_and_index (t, &level, &idx); \n+\ttemplate_parm_level_and_index (t, &level, &idx);\n \n \tlevels = TMPL_ARGS_DEPTH (args);\n \tif (level <= levels\n@@ -14572,7 +14572,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\tgcc_assert (TYPE_P (arg));\n \n \t\tquals = cp_type_quals (arg) | cp_type_quals (t);\n-\t\t  \n+\n \t\treturn cp_build_qualified_type_real\n \t\t  (arg, quals, complain | tf_ignore_bad_quals);\n \t      }\n@@ -15567,7 +15567,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t     mangling.  */\n \t  DECL_CONTEXT (r) = DECL_CONTEXT (t);\n \t}\n-      \n+\n       if (TREE_CODE (r) == ARGUMENT_PACK_SELECT)\n \tr = argument_pack_select_arg (r);\n       if (!mark_used (r, complain) && !(complain & tf_error))\n@@ -16353,7 +16353,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n-\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, \n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain,\n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n@@ -18475,7 +18475,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t\tcomplain|decltype_flag));\n \n     case FIX_TRUNC_EXPR:\n-      gcc_unreachable ();    \n+      gcc_unreachable ();\n \n     case ADDR_EXPR:\n       op1 = TREE_OPERAND (t, 0);\n@@ -18569,7 +18569,7 @@ tsubst_copy_and_build (tree t,\n \t  || ARGUMENT_PACK_P (TREE_OPERAND (t, 0)))\n \tRETURN (tsubst_copy (t, args, complain, in_decl));\n       /* Fall through */\n-      \n+\n     case ALIGNOF_EXPR:\n       {\n \ttree r;\n@@ -19211,7 +19211,7 @@ tsubst_copy_and_build (tree t,\n \n                 RETURN (tree_cons (purposevec, valuevec, chain));\n               }\n-            \n+\n             /* Convert the argument vectors into a TREE_LIST */\n             i = len;\n             while (i > 0)\n@@ -19221,7 +19221,7 @@ tsubst_copy_and_build (tree t,\n                 purpose = purposevec ? TREE_VEC_ELT (purposevec, i) \n \t\t                     : NULL_TREE;\n                 value \n-\t\t  = valuevec ? convert_from_reference (TREE_VEC_ELT (valuevec, i)) \n+\t\t  = valuevec ? convert_from_reference (TREE_VEC_ELT (valuevec, i))\n                              : NULL_TREE;\n \n                 /* Build the list (backwards).  */\n@@ -19523,7 +19523,7 @@ tsubst_copy_and_build (tree t,\n \t  type2 = RECUR (type2);\n \telse if (type2)\n \t  type2 = tsubst (type2, args, complain, in_decl);\n-\t\n+\n \tRETURN (finish_trait_expr (TRAIT_EXPR_KIND (t), type1, type2));\n       }\n \n@@ -20901,15 +20901,15 @@ type_unification_real (tree tparms,\n \treturn 1;\n     }\n \n-  if (parms \n+  if (parms\n       && parms != void_list_node\n       && TREE_CODE (TREE_VALUE (parms)) == TYPE_PACK_EXPANSION)\n     {\n       /* Unify the remaining arguments with the pack expansion type.  */\n       tree argvec;\n       tree parmvec = make_tree_vec (1);\n \n-      /* Allocate a TREE_VEC and copy in all of the arguments */ \n+      /* Allocate a TREE_VEC and copy in all of the arguments */\n       argvec = make_tree_vec (nargs - ia);\n       for (i = 0; ia < nargs; ++ia, ++i)\n \tTREE_VEC_ELT (argvec, i) = args[ia];\n@@ -20998,7 +20998,7 @@ type_unification_real (tree tparms,\n \t  /* Core issue #226 (C++0x) [temp.deduct]:\n \n \t     If a template argument has not been deduced, its\n-\t     default template argument, if any, is used. \n+\t     default template argument, if any, is used.\n \n \t     When we are in C++98 mode, TREE_PURPOSE will either\n \t     be NULL_TREE or ERROR_MARK_NODE, so we do not need\n@@ -21667,7 +21667,7 @@ check_cv_quals_for_unify (int strict, tree arg, tree parm)\n }\n \n /* Determines the LEVEL and INDEX for the template parameter PARM.  */\n-void \n+void\n template_parm_level_and_index (tree parm, int* level, int* index)\n {\n   if (TREE_CODE (parm) == TEMPLATE_TYPE_PARM\n@@ -21700,11 +21700,11 @@ template_parm_level_and_index (tree parm, int* level, int* index)\n    lists. */\n \n static int\n-unify_pack_expansion (tree tparms, tree targs, tree packed_parms, \n+unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n                       tree packed_args, unification_kind_t strict,\n                       bool subr, bool explain_p)\n {\n-  tree parm \n+  tree parm\n     = TREE_VEC_ELT (packed_parms, TREE_VEC_LENGTH (packed_parms) - 1);\n   tree pattern = PACK_EXPANSION_PATTERN (parm);\n   tree pack, packs = NULL_TREE;\n@@ -21720,7 +21720,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n \n   /* Determine the parameter packs we will be deducing from the\n      pattern, and record their current deductions.  */\n-  for (pack = PACK_EXPANSION_PARAMETER_PACKS (parm); \n+  for (pack = PACK_EXPANSION_PARAMETER_PACKS (parm);\n        pack; pack = TREE_CHAIN (pack))\n     {\n       tree parm_pack = TREE_VALUE (pack);\n@@ -21741,7 +21741,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n       packs = tree_cons (parm_pack, TMPL_ARG (targs, level, idx), packs);\n       TREE_TYPE (packs) = make_tree_vec (len - start);\n     }\n-  \n+\n   /* Loop through all of the arguments that have not yet been\n      unified and unify each with the pattern.  */\n   for (i = start; i < len; i++)\n@@ -23310,7 +23310,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n   gcc_assert (decl != DECL_TEMPLATE_RESULT (fn));\n \n   /* Never do unification on the 'this' parameter.  */\n-  decl_arg_types = skip_artificial_parms_for (decl, \n+  decl_arg_types = skip_artificial_parms_for (decl,\n \t\t\t\t\t      TYPE_ARG_TYPES (decl_type));\n \n   nargs = list_length (decl_arg_types);\n@@ -23842,7 +23842,7 @@ do_decl_instantiation (tree decl, tree storage)\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     {\n       if (!in_system_header_at (input_location) && (cxx_dialect == cxx98))\n-\tpedwarn (input_location, OPT_Wpedantic, \n+\tpedwarn (input_location, OPT_Wpedantic,\n \t\t \"ISO C++ 1998 forbids the use of %<extern%> on explicit \"\n \t\t \"instantiations\");\n       extern_p = 1;\n@@ -23928,12 +23928,12 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t  if (storage == ridpointers[(int) RID_EXTERN])\n \t    {\n \t      if (cxx_dialect == cxx98)\n-\t\tpedwarn (input_location, OPT_Wpedantic, \n+\t\tpedwarn (input_location, OPT_Wpedantic,\n \t\t\t \"ISO C++ 1998 forbids the use of %<extern%> on \"\n \t\t\t \"explicit instantiations\");\n \t    }\n \t  else\n-\t    pedwarn (input_location, OPT_Wpedantic, \n+\t    pedwarn (input_location, OPT_Wpedantic,\n \t\t     \"ISO C++ forbids the use of %qE\"\n \t\t     \" on explicit instantiations\", storage);\n \t}\n@@ -24097,7 +24097,7 @@ regenerate_decl_from_template (tree decl, tree tmpl, tree args)\n \t{\n \t  tree parm_type;\n \t  tree attributes;\n-          \n+\n \t  if (DECL_NAME (decl_parm) != DECL_NAME (pattern_parm))\n \t    DECL_NAME (decl_parm) = DECL_NAME (pattern_parm);\n \t  parm_type = tsubst (TREE_TYPE (pattern_parm), args, tf_error,\n@@ -24129,7 +24129,7 @@ regenerate_decl_from_template (tree decl, tree tmpl, tree args)\n             {\n               tree parm_type;\n               tree attributes;\n-          \n+\n               if (DECL_NAME (decl_parm) != DECL_NAME (pattern_parm))\n                 /* Rename the parameter to include the index.  */\n                 DECL_NAME (decl_parm) = \n@@ -24958,7 +24958,7 @@ tsubst_initializer_list (tree t, tree argvec)\n                                                  NULL_TREE);\n           if (expanded_bases == error_mark_node)\n             continue;\n-          \n+\n           /* We'll be building separate TREE_LISTs of arguments for\n              each base.  */\n           len = TREE_VEC_LENGTH (expanded_bases);\n@@ -24991,7 +24991,7 @@ tsubst_initializer_list (tree t, tree argvec)\n \n \t\t  /* Expand the argument.  */\n \t\t  SET_PACK_EXPANSION_PATTERN (expr, TREE_VALUE (arg));\n-\t\t  expanded_exprs \n+\t\t  expanded_exprs\n \t\t    = tsubst_pack_expansion (expr, argvec,\n \t\t\t\t\t     tf_warning_or_error,\n \t\t\t\t\t     NULL_TREE);\n@@ -25002,8 +25002,8 @@ tsubst_initializer_list (tree t, tree argvec)\n \t\t     corresponding TREE_LIST in EXPANDED_ARGUMENTS.  */\n \t\t  for (i = 0; i < len; i++)\n \t\t    {\n-\t\t      TREE_VEC_ELT (expanded_arguments, i) = \n-\t\t\ttree_cons (NULL_TREE, \n+\t\t      TREE_VEC_ELT (expanded_arguments, i) =\n+\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t   TREE_VEC_ELT (expanded_exprs, i),\n \t\t\t\t   TREE_VEC_ELT (expanded_arguments, i));\n \t\t    }\n@@ -25014,7 +25014,7 @@ tsubst_initializer_list (tree t, tree argvec)\n \t\t since we built them backwards.  */\n \t      for (i = 0; i < len; i++)\n \t\t{\n-\t\t  TREE_VEC_ELT (expanded_arguments, i) = \n+\t\t  TREE_VEC_ELT (expanded_arguments, i) =\n \t\t    nreverse (TREE_VEC_ELT (expanded_arguments, i));\n \t\t}\n \t    }\n@@ -25626,11 +25626,11 @@ value_dependent_expression_p (tree expression)\n       {\n         tree values = ARGUMENT_PACK_ARGS (expression);\n         int i, len = TREE_VEC_LENGTH (values);\n-        \n+\n         for (i = 0; i < len; ++i)\n           if (value_dependent_expression_p (TREE_VEC_ELT (values, i)))\n             return true;\n-        \n+\n         return false;\n       }\n \n@@ -26562,7 +26562,7 @@ resolve_typename_type (tree type, bool only_current_p)\n \t\t\ttf_warning_or_error);\n \n   result = NULL_TREE;\n-  \n+\n   /* For a TYPENAME_TYPE like \"typename X::template Y<T>\", we want to\n      find a TEMPLATE_DECL.  Otherwise, we want to find a TYPE_DECL.  */\n   tree fullname = TYPENAME_TYPE_FULLNAME (type);\n@@ -26601,15 +26601,15 @@ resolve_typename_type (tree type, bool only_current_p)\n       if (result == error_mark_node)\n \tresult = NULL_TREE;\n     }\n-  \n+\n   /* Leave the SCOPE.  */\n   if (pushed_scope)\n     pop_scope (pushed_scope);\n \n   /* If we failed to resolve it, return the original typename.  */\n   if (!result)\n     return type;\n-  \n+\n   /* If lookup found a typename type, resolve that too.  */\n   if (TREE_CODE (result) == TYPENAME_TYPE && !TYPENAME_IS_RESOLVING_P (result))\n     {\n@@ -26619,7 +26619,7 @@ resolve_typename_type (tree type, bool only_current_p)\n       result = resolve_typename_type (result, only_current_p);\n       TYPENAME_IS_RESOLVING_P (result) = 0;\n     }\n-  \n+\n   /* Qualify the resulting type.  */\n   quals = cp_type_quals (type);\n   if (quals)\n@@ -26826,7 +26826,7 @@ listify (tree arg)\n   tree std_init_list = get_namespace_binding (std_node, init_list_identifier);\n \n   if (!std_init_list || !DECL_CLASS_TEMPLATE_P (std_init_list))\n-    {    \n+    {\n       gcc_rich_location richloc (input_location);\n       maybe_add_include_fixit (&richloc, \"<initializer_list>\", false);\n       error_at (&richloc,"}, {"sha": "4f71ac706e585c4153af981368f15c5cb283ed6b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "patch": "@@ -686,7 +686,7 @@ finish_expr_stmt (tree expr)\n \t  expr = convert_to_void (expr, ICV_STATEMENT, tf_warning_or_error);\n \t}\n       else if (!type_dependent_expression_p (expr))\n-\tconvert_to_void (build_non_dependent_expr (expr), ICV_STATEMENT, \n+\tconvert_to_void (build_non_dependent_expr (expr), ICV_STATEMENT,\n                          tf_warning_or_error);\n \n       if (check_for_bare_parameter_packs (expr))\n@@ -906,7 +906,7 @@ finish_return_stmt (tree expr)\n     {\n       if (warn_sequence_point)\n \tverify_sequence_points (expr);\n-      \n+\n       if (DECL_DESTRUCTOR_P (current_function_decl)\n \t  || (DECL_CONSTRUCTOR_P (current_function_decl)\n \t      && targetm.cxx.cdtor_returns_this ()))\n@@ -1570,7 +1570,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t{\n \t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n \t  bool constraint_parsed\n-\t    = parse_input_constraint (&constraint, i, ninputs, noutputs, 0,   \n+\t    = parse_input_constraint (&constraint, i, ninputs, noutputs, 0,\n \t\t\t\t      oconstraints, &allows_mem, &allows_reg);\n \t  /* If the operand is going to end up in memory, don't call\n \t     decay_conversion.  */\n@@ -2020,7 +2020,7 @@ check_accessibility_of_qualified_id (tree decl,\n        its bases.  */\n     qualifying_type = currently_open_derived_class (scope);\n \n-  if (qualifying_type \n+  if (qualifying_type\n       /* It is possible for qualifying type to be a TEMPLATE_TYPE_PARM\n \t or similar in a default argument value.  */\n       && CLASS_TYPE_P (qualifying_type)\n@@ -3004,7 +3004,7 @@ finish_template_template_parm (tree aggr, tree identifier)\n \n   gcc_assert (DECL_TEMPLATE_PARMS (tmpl));\n \n-  check_default_tmpl_args (decl, DECL_TEMPLATE_PARMS (tmpl), \n+  check_default_tmpl_args (decl, DECL_TEMPLATE_PARMS (tmpl),\n \t\t\t   /*is_primary=*/true, /*is_partial=*/false,\n \t\t\t   /*is_friend=*/0);\n \n@@ -3379,7 +3379,7 @@ baselink_for_fns (tree fns)\n   tree scope;\n   tree cl;\n \n-  if (BASELINK_P (fns) \n+  if (BASELINK_P (fns)\n       || error_operand_p (fns))\n     return fns;\n \n@@ -3868,7 +3868,7 @@ finish_id_expression_1 (tree id_expression,\n \t  if (DECL_P (decl) && DECL_NONLOCAL (decl)\n \t      && DECL_CLASS_SCOPE_P (decl))\n \t    {\n-\t      tree context = context_for_name_lookup (decl); \n+\t      tree context = context_for_name_lookup (decl);\n \t      if (context != current_class_type)\n \t\t{\n \t\t  tree path = currently_open_derived_class (context);\n@@ -8032,7 +8032,7 @@ restore_omp_privatization_clauses (vec<tree> &save)\n       save.release ();\n       return;\n     }\n-    \n+\n   omp_private_member_map = new hash_map <tree, tree>;\n   while (!save.is_empty ())\n     {\n@@ -9046,7 +9046,7 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n \t{\n \t  if (opcode == NOP_EXPR)\n \t    stmt = build2 (MODIFY_EXPR, void_type_node, orig_lhs, orig_rhs);\n-\t  else \n+\t  else\n \t    stmt = build2 (opcode, void_type_node, orig_lhs, orig_rhs);\n \t  if (orig_rhs1)\n \t    stmt = build_min_nt_loc (EXPR_LOCATION (orig_rhs1),\n@@ -9317,8 +9317,8 @@ init_cp_semantics (void)\n    CONDITION and the message text MESSAGE.  LOCATION is the location\n    of the static assertion in the source code.  When MEMBER_P, this\n    static assertion is a member of a class.  */\n-void \n-finish_static_assert (tree condition, tree message, location_t location, \n+void\n+finish_static_assert (tree condition, tree message, location_t location,\n                       bool member_p)\n {\n   tsubst_flags_t complain = tf_warning_or_error;\n@@ -9344,7 +9344,7 @@ finish_static_assert (tree condition, tree message, location_t location,\n       STATIC_ASSERT_SOURCE_LOCATION (assertion) = location;\n \n       if (member_p)\n-        maybe_add_class_template_decl_list (current_class_type, \n+        maybe_add_class_template_decl_list (current_class_type,\n                                             assertion,\n                                             /*friend_p=*/0);\n       else\n@@ -9362,12 +9362,12 @@ finish_static_assert (tree condition, tree message, location_t location,\n   if (TREE_CODE (condition) == INTEGER_CST && !integer_zerop (condition))\n     /* Do nothing; the condition is satisfied. */\n     ;\n-  else \n+  else\n     {\n       location_t saved_loc = input_location;\n \n       input_location = location;\n-      if (TREE_CODE (condition) == INTEGER_CST \n+      if (TREE_CODE (condition) == INTEGER_CST\n           && integer_zerop (condition))\n \t{\n \t  int sz = TREE_INT_CST_LOW (TYPE_SIZE_UNIT\n@@ -9582,7 +9582,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n   return type;\n }\n \n-/* Called from trait_expr_value to evaluate either __has_nothrow_assign or \n+/* Called from trait_expr_value to evaluate either __has_nothrow_assign or\n    __has_nothrow_copy, depending on assign_p.  Returns true iff all\n    the copy {ctor,assign} fns are nothrow.  */\n \n@@ -9643,7 +9643,7 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n \n     case CPTK_HAS_NOTHROW_CONSTRUCTOR:\n       type1 = strip_array_types (type1);\n-      return (trait_expr_value (CPTK_HAS_TRIVIAL_CONSTRUCTOR, type1, type2) \n+      return (trait_expr_value (CPTK_HAS_TRIVIAL_CONSTRUCTOR, type1, type2)\n \t      || (CLASS_TYPE_P (type1)\n \t\t  && (t = locate_ctor (type1))\n \t\t  && maybe_instantiate_noexcept (t)"}]}