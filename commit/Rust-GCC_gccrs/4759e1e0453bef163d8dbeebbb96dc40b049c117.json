{"sha": "4759e1e0453bef163d8dbeebbb96dc40b049c117", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc1OWUxZTA0NTNiZWYxNjNkOGRiZWViYmI5NmRjNDBiMDQ5YzExNw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-08-12T16:29:48Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-08-17T23:28:43Z"}, "message": "Add GORI tracing faciltiies.\n\nDebugging range-ops and gori unwinding needed some help.\n\n\t* gimple-range-gori.cc (gori_compute::gori_compute): Enable tracing.\n\t(gori_compute::compute_operand_range): Add tracing.\n\t(gori_compute::logical_combine): Ditto.\n\t(gori_compute::compute_logical_operands): Ditto.\n\t(gori_compute::compute_operand1_range): Ditto.\n\t(gori_compute::compute_operand2_range): Ditto.\n\t(gori_compute::outgoing_edge_range_p): Ditto.\n\t* gimple-range-gori.h (class gori_compute): Add range_tracer.", "tree": {"sha": "336ecedea0e4a773393ac1cdb93155913640251f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/336ecedea0e4a773393ac1cdb93155913640251f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4759e1e0453bef163d8dbeebbb96dc40b049c117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4759e1e0453bef163d8dbeebbb96dc40b049c117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4759e1e0453bef163d8dbeebbb96dc40b049c117", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4759e1e0453bef163d8dbeebbb96dc40b049c117/comments", "author": null, "committer": null, "parents": [{"sha": "0bb74a28e1318cbac9c895f1079b384a42513a9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb74a28e1318cbac9c895f1079b384a42513a9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bb74a28e1318cbac9c895f1079b384a42513a9c"}], "stats": {"total": 173, "additions": 149, "deletions": 24}, "files": [{"sha": "f78829595dcb3c1baf2181d7be0083e0495aa078", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 148, "deletions": 24, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4759e1e0453bef163d8dbeebbb96dc40b049c117/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4759e1e0453bef163d8dbeebbb96dc40b049c117/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=4759e1e0453bef163d8dbeebbb96dc40b049c117", "patch": "@@ -634,11 +634,13 @@ debug (gori_map &g)\n \n // Construct a gori_compute object.\n \n-gori_compute::gori_compute ()\n+gori_compute::gori_compute () : tracer (\"GORI \")\n {\n   // Create a boolean_type true and false range.\n   m_bool_zero = int_range<2> (boolean_false_node, boolean_false_node);\n   m_bool_one = int_range<2> (boolean_true_node, boolean_true_node);\n+  if (dump_file && (param_evrp_mode & EVRP_MODE_GORI))\n+    tracer.enable_trace ();\n }\n \n // Given the switch S, return an evaluation in R for NAME when the lhs\n@@ -712,29 +714,43 @@ gori_compute::compute_operand_range (irange &r, gimple *stmt,\n   if (!op1_in_chain && !op2_in_chain)\n     return false;\n \n+  bool res;\n   // Process logicals as they have special handling.\n   if (is_gimple_logical_p (stmt))\n     {\n+      unsigned idx;\n+      if ((idx = tracer.header (\"compute_operand \")))\n+\t{\n+\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t  fprintf (dump_file, \" with LHS = \");\n+\t  lhs.dump (dump_file);\n+\t  fprintf (dump_file, \" at stmt \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+\n       int_range_max op1_trange, op1_frange;\n       int_range_max op2_trange, op2_frange;\n       compute_logical_operands (op1_trange, op1_frange, stmt, lhs,\n \t\t\t\tname, src, op1, op1_in_chain);\n       compute_logical_operands (op2_trange, op2_frange, stmt, lhs,\n \t\t\t\tname, src, op2, op2_in_chain);\n-      return logical_combine (r, gimple_expr_code (stmt), lhs,\n-\t\t\t      op1_trange, op1_frange, op2_trange, op2_frange);\n+      res = logical_combine (r, gimple_expr_code (stmt), lhs,\n+\t\t\t     op1_trange, op1_frange, op2_trange, op2_frange);\n+      if (idx)\n+\ttracer.trailer (idx, \"compute_operand\", res, name, r);\n     }\n-\n   // Follow the appropriate operands now.\n-  if (op1_in_chain && op2_in_chain)\n-    return compute_operand1_and_operand2_range (r, stmt, lhs, name, src);\n-  if (op1_in_chain)\n-    return compute_operand1_range (r, stmt, lhs, name, src);\n-  if (op2_in_chain)\n-    return compute_operand2_range (r, stmt, lhs, name, src);\n+  else if (op1_in_chain && op2_in_chain)\n+    res = compute_operand1_and_operand2_range (r, stmt, lhs, name, src);\n+  else if (op1_in_chain)\n+    res = compute_operand1_range (r, stmt, lhs, name, src);\n+  else if (op2_in_chain)\n+    res = compute_operand2_range (r, stmt, lhs, name, src);\n+  else\n+    gcc_unreachable ();\n \n   // If neither operand is derived, this statement tells us nothing.\n-  return false;\n+  return res;\n }\n \n \n@@ -767,6 +783,38 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n       && op2_true.varying_p () && op2_false.varying_p ())\n     return false;\n \n+  unsigned idx;\n+  if ((idx = tracer.header (\"logical_combine\")))\n+    {\n+      switch (code)\n+        {\n+\t  case TRUTH_OR_EXPR:\n+\t  case BIT_IOR_EXPR:\n+\t    fprintf (dump_file, \" || \");\n+\t    break;\n+\t  case TRUTH_AND_EXPR:\n+\t  case BIT_AND_EXPR:\n+\t    fprintf (dump_file, \" && \");\n+\t    break;\n+\t  default:\n+\t    break;\n+\t}\n+      fprintf (dump_file, \" with LHS = \");\n+      lhs.dump (dump_file);\n+      fputc ('\\n', dump_file);\n+\n+      tracer.print (idx, \"op1_true = \");\n+      op1_true.dump (dump_file);\n+      fprintf (dump_file, \"  op1_false = \");\n+      op1_false.dump (dump_file);\n+      fputc ('\\n', dump_file);\n+      tracer.print (idx, \"op2_true = \");\n+      op2_true.dump (dump_file);\n+      fprintf (dump_file, \"  op2_false = \");\n+      op2_false.dump (dump_file);\n+      fputc ('\\n', dump_file);\n+    }\n+\n   // This is not a simple fold of a logical expression, rather it\n   // determines ranges which flow through the logical expression.\n   //\n@@ -804,16 +852,20 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n   // would be lost.\n   if (!range_is_either_true_or_false (lhs))\n     {\n+      bool res;\n       int_range_max r1;\n       if (logical_combine (r1, code, m_bool_zero, op1_true, op1_false,\n \t\t\t   op2_true, op2_false)\n \t  && logical_combine (r, code, m_bool_one, op1_true, op1_false,\n \t\t\t      op2_true, op2_false))\n \t{\n \t  r.union_ (r1);\n-\t  return true;\n+\t  res = true;\n \t}\n-      return false;\n+      else\n+\tres = false;\n+      if (idx)\n+\ttracer.trailer (idx, \"logical_combine\", res, NULL_TREE, r);\n     }\n \n   switch (code)\n@@ -873,6 +925,8 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n         gcc_unreachable ();\n     }\n \n+  if (idx)\n+    tracer.trailer (idx, \"logical_combine\", true, NULL_TREE, r);\n   return true;\n }\n \n@@ -895,6 +949,13 @@ gori_compute::compute_logical_operands (irange &true_range, irange &false_range,\n       // use its known value on entry to the block.\n       src.get_operand (true_range, name);\n       false_range = true_range;\n+      unsigned idx;\n+      if ((idx = tracer.header (\"logical_operand\")))\n+\t{\n+\t  print_generic_expr (dump_file, op, TDF_SLIM);\n+\t  fprintf (dump_file, \" not in computation chain. Queried.\\n\");\n+\t  tracer.trailer (idx, \"logical_operand\", true, NULL_TREE, true_range);\n+        }\n       return;\n     }\n \n@@ -958,15 +1019,43 @@ gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n \treturn false;\n     }\n \n+  unsigned idx;\n+  if ((idx = tracer.header (\"compute op 1 (\")))\n+    {\n+      print_generic_expr (dump_file, op1, TDF_SLIM);\n+      fprintf (dump_file, \") at \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+      tracer.print (idx, \"LHS =\");\n+      lhs.dump (dump_file);\n+      if (op2 && TREE_CODE (op2) == SSA_NAME)\n+\t{\n+\t  fprintf (dump_file, \", \");\n+\t  print_generic_expr (dump_file, op2, TDF_SLIM);\n+\t  fprintf (dump_file, \" = \");\n+\t  op2_range.dump (dump_file);\n+\t}\n+      fprintf (dump_file, \"\\n\");\n+      tracer.print (idx, \"Computes \");\n+      print_generic_expr (dump_file, op1, TDF_SLIM);\n+      fprintf (dump_file, \" = \");\n+      r.dump (dump_file);\n+      fprintf (dump_file, \" intersect Known range : \");\n+      op1_range.dump (dump_file);\n+      fputc ('\\n', dump_file);\n+    }\n   // Intersect the calculated result with the known result and return if done.\n   if (op1 == name)\n     {\n       r.intersect (op1_range);\n+      if (idx)\n+\ttracer.trailer (idx, \"produces \", true, name, r);\n       return true;\n     }\n   // If the calculation continues, we're using op1_range as the new LHS.\n   op1_range.intersect (r);\n \n+  if (idx)\n+    tracer.trailer (idx, \"produces \", true, op1, op1_range);\n   gimple *src_stmt = SSA_NAME_DEF_STMT (op1);\n   gcc_checking_assert (src_stmt);\n \n@@ -995,15 +1084,43 @@ gori_compute::compute_operand2_range (irange &r, gimple *stmt,\n   if (!gimple_range_calc_op2 (r, stmt, lhs, op1_range))\n     return false;\n \n+  unsigned idx;\n+  if ((idx = tracer.header (\"compute op 2 (\")))\n+    {\n+      print_generic_expr (dump_file, op2, TDF_SLIM);\n+      fprintf (dump_file, \") at \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+      tracer.print (idx, \"LHS = \");\n+      lhs.dump (dump_file);\n+      if (TREE_CODE (op1) == SSA_NAME)\n+\t{\n+\t  fprintf (dump_file, \", \");\n+\t  print_generic_expr (dump_file, op1, TDF_SLIM);\n+\t  fprintf (dump_file, \" = \");\n+\t  op1_range.dump (dump_file);\n+\t}\n+      fprintf (dump_file, \"\\n\");\n+      tracer.print (idx, \"Computes \");\n+      print_generic_expr (dump_file, op2, TDF_SLIM);\n+      fprintf (dump_file, \" = \");\n+      r.dump (dump_file);\n+      fprintf (dump_file, \" intersect Known range : \");\n+      op2_range.dump (dump_file);\n+      fputc ('\\n', dump_file);\n+    }\n   // Intersect the calculated result with the known result and return if done.\n   if (op2 == name)\n     {\n       r.intersect (op2_range);\n+      if (idx)\n+\ttracer.trailer (idx, \" produces \", true, NULL_TREE, r);\n       return true;\n     }\n   // If the calculation continues, we're using op2_range as the new LHS.\n   op2_range.intersect (r);\n \n+  if (idx)\n+    tracer.trailer (idx, \" produces \", true, op2, op2_range);\n   gimple *src_stmt = SSA_NAME_DEF_STMT (op2);\n   gcc_checking_assert (src_stmt);\n //  gcc_checking_assert (!is_import_p (op2, find.bb));\n@@ -1095,6 +1212,7 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n \t\t\t\t     range_query &q)\n {\n   int_range_max lhs;\n+  unsigned idx;\n \n   gcc_checking_assert (gimple_range_ssa_p (name));\n   // Determine if there is an outgoing edge.\n@@ -1122,7 +1240,15 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n   // If NAME can be calculated on the edge, use that.\n   if (is_export_p (name, e->src))\n     {\n-      if (compute_operand_range (r, stmt, lhs, name, src))\n+      bool res;\n+      if ((idx = tracer.header (\"outgoing_edge\")))\n+\t{\n+\t  fprintf (dump_file, \" for \");\n+\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t  fprintf (dump_file, \" on edge %d->%d\\n\",\n+\t\t   e->src->index, e->dest->index);\n+\t}\n+      if ((res = compute_operand_range (r, stmt, lhs, name, src)))\n \t{\n \t  // Sometimes compatible types get interchanged. See PR97360.\n \t  // Make sure we are returning the type of the thing we asked for.\n@@ -1132,28 +1258,26 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n \t\t\t\t\t\t       TREE_TYPE (name)));\n \t      range_cast (r, TREE_TYPE (name));\n \t    }\n-\t  return true;\n \t}\n+      if (idx)\n+\ttracer.trailer (idx, \"outgoing_edge\", res, name, r);\n+      return res;\n     }\n   // If NAME isn't exported, check if it can be recomputed.\n   else if (may_recompute_p (name, e))\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n \n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      if ((idx = tracer.header (\"recomputation\")))\n \t{\n-\t  fprintf (dump_file, \"recomputation attempt on edge %d->%d for \",\n+\t  fprintf (dump_file, \" attempt on edge %d->%d for \",\n \t\t   e->src->index, e->dest->index);\n-\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t  print_gimple_stmt (dump_file, def_stmt, 0, TDF_SLIM);\n \t}\n       // Simply calculate DEF_STMT on edge E using the range query Q.\n       fold_range (r, def_stmt, e, &q);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \" : Calculated :\");\n-\t  r.dump (dump_file);\n-\t  fputc ('\\n', dump_file);\n-\t}\n+      if (idx)\n+\ttracer.trailer (idx, \"recomputation\", true, name, r);\n       return true;\n     }\n   return false;"}, {"sha": "688468c879082b53bb305c1e523901d75a313e45", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4759e1e0453bef163d8dbeebbb96dc40b049c117/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4759e1e0453bef163d8dbeebbb96dc40b049c117/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=4759e1e0453bef163d8dbeebbb96dc40b049c117", "patch": "@@ -180,6 +180,7 @@ class gori_compute : public gori_map\n   int_range<2> m_bool_one;\t// Boolean true cached.\n \n   gimple_outgoing_range outgoing;\t// Edge values for COND_EXPR & SWITCH_EXPR.\n+  range_tracer tracer;\n };\n \n // These routines provide a GIMPLE interface to the range-ops code."}]}