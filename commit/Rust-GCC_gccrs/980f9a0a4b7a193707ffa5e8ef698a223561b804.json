{"sha": "980f9a0a4b7a193707ffa5e8ef698a223561b804", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgwZjlhMGE0YjdhMTkzNzA3ZmZhNWU4ZWY2OThhMjIzNTYxYjgwNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-10T22:53:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-10T22:53:23Z"}, "message": "runtime: copy signal code from Go 1.7 runtime\n    \n    Add a little shell script to auto-generate runtime.sigtable from the\n    known signal names.\n    \n    Force the main package to always import the runtime package.  Otherwise\n    some runtime package global variables may never be initialized.\n    \n    Set the syscallsp and syscallpc fields of g when entering a syscall, so\n    that the runtime package knows when a g is executing a syscall.\n    \n    Fix runtime.funcPC to avoid dead store elimination of the interface\n    value when the function is inlined.\n    \n    Reviewed-on: https://go-review.googlesource.com/33025\n\nFrom-SVN: r242060", "tree": {"sha": "5a870a796677b74bf81d7659534413ed868dad5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a870a796677b74bf81d7659534413ed868dad5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/980f9a0a4b7a193707ffa5e8ef698a223561b804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980f9a0a4b7a193707ffa5e8ef698a223561b804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980f9a0a4b7a193707ffa5e8ef698a223561b804", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980f9a0a4b7a193707ffa5e8ef698a223561b804/comments", "author": null, "committer": null, "parents": [{"sha": "071af74db674f3dc462ab8a25e091b74830fda2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/071af74db674f3dc462ab8a25e091b74830fda2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/071af74db674f3dc462ab8a25e091b74830fda2d"}], "stats": {"total": 2313, "additions": 1374, "deletions": 939}, "files": [{"sha": "c25c2e486429c3be2637ff60b6942b38f74d05d4", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -1,4 +1,4 @@\n-cac897bd27885c18a16dacfe27d5efd4526455c5\n+449e918b0f93d3e3339edcec21a5bc157f548e54\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1b0434ed0983fad09f760978103f7f5bb1ea77e7", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -3791,7 +3791,7 @@ Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n \tthis->escapes_ = false;\n \n       // When compiling the runtime, the address operator does not\n-      // cause local variables to escapes.  When escape analysis\n+      // cause local variables to escape.  When escape analysis\n       // becomes the default, this should be changed to make it an\n       // error if we have an address operator that escapes.\n       if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")"}, {"sha": "acfab188a80c313e9ddbaeb8f74d1750354032d4", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -394,6 +394,7 @@ void\n Gogo::import_package(const std::string& filename,\n \t\t     const std::string& local_name,\n \t\t     bool is_local_name_exported,\n+\t\t     bool must_exist,\n \t\t     Location location)\n {\n   if (filename.empty())\n@@ -497,7 +498,8 @@ Gogo::import_package(const std::string& filename,\n \t\t\t\t\t\tthis->relative_import_path_);\n   if (stream == NULL)\n     {\n-      go_error_at(location, \"import file %qs not found\", filename.c_str());\n+      if (must_exist)\n+\tgo_error_at(location, \"import file %qs not found\", filename.c_str());\n       return;\n     }\n \n@@ -2179,6 +2181,14 @@ Gogo::is_thunk(const Named_object* no)\n void\n Gogo::define_global_names()\n {\n+  if (this->is_main_package())\n+    {\n+      // Every Go program has to import the runtime package, so that\n+      // it is properly initialized.\n+      this->import_package(\"runtime\", \"_\", false, false,\n+\t\t\t   Linemap::predeclared_location());\n+    }\n+\n   for (Bindings::const_declarations_iterator p =\n \t this->globals_->begin_declarations();\n        p != this->globals_->end_declarations();"}, {"sha": "62bbf9e11ae3aa86883bb55c5712aa4a77d10bcf", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -301,7 +301,7 @@ class Gogo\n   // the declarations are added to the global scope.\n   void\n   import_package(const std::string& filename, const std::string& local_name,\n-\t\t bool is_local_name_exported, Location);\n+\t\t bool is_local_name_exported, bool must_exist, Location);\n \n   // Whether we are the global binding level.\n   bool"}, {"sha": "34a7765418db9e71a766450bb43a62c54258af77", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -5722,7 +5722,7 @@ Parse::import_spec(void*)\n     }\n \n   this->gogo_->import_package(token->string_value(), local_name,\n-\t\t\t      is_local_name_exported, location);\n+\t\t\t      is_local_name_exported, true, location);\n \n   this->advance_token();\n }"}, {"sha": "b29f6c4ff5793d863d726bcb387b33e29e520e90", "filename": "libgo/Makefile.am", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -480,14 +480,12 @@ runtime_files = \\\n \truntime/print.c \\\n \truntime/proc.c \\\n \truntime/runtime_c.c \\\n-\truntime/signal_unix.c \\\n \truntime/thread.c \\\n \t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \tmalloc.c \\\n \truntime1.c \\\n-\tsigqueue.c \\\n \t$(runtime_getncpu_file)\n \n goc2c.$(OBJEXT): runtime/goc2c.c\n@@ -504,10 +502,6 @@ runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c\n-\t./goc2c --go-pkgpath os_signal $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n %.c: $(srcdir)/runtime/%.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n@@ -572,6 +566,12 @@ s-runtime_sysinfo: $(srcdir)/mkrsysinfo.sh gen-sysinfo.go\n \t$(SHELL) $(srcdir)/mvifdiff.sh tmp-runtime_sysinfo.go runtime_sysinfo.go\n \t$(STAMP) $@\n \n+sigtab.go: s-sigtab; @true\n+s-sigtab: $(srcdir)/mksigtab.sh gen-sysinfo.go\n+\tGOOS=$(GOOS) $(SHELL) $(srcdir)/mksigtab.sh > tmp-sigtab.go\n+\t$(SHELL) $(srcdir)/mvifdiff.sh tmp-sigtab.go sigtab.go\n+\t$(STAMP) $@\n+\n runtime.inc: s-runtime-inc; @true\n s-runtime-inc: runtime.lo Makefile\n \trm -f runtime.inc.tmp2\n@@ -1038,7 +1038,7 @@ $(foreach package,$(PACKAGES),$(eval $(call PACKAGE_template,$(package))))\n math_lo_GOCFLAGS = $(MATH_FLAG)\n \n # Add the generated file runtime_sysinfo.go to the runtime package.\n-extra_go_files_runtime = runtime_sysinfo.go\n+extra_go_files_runtime = runtime_sysinfo.go sigtab.go\n runtime.lo.dep: $(extra_go_files_runtime)\n \n # Add generated files to the syscall package."}, {"sha": "44a6999c2064eca2d5bfc0c8f3600f0dc13cedcf", "filename": "libgo/Makefile.in", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -203,9 +203,8 @@ am__objects_5 = go-assert.lo go-breakpoint.lo go-caller.lo \\\n \tgo-unwind.lo go-varargs.lo env_posix.lo heapdump.lo mcache.lo \\\n \tmcentral.lo $(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo \\\n \tmsize.lo panic.lo parfor.lo print.lo proc.lo runtime_c.lo \\\n-\tsignal_unix.lo thread.lo $(am__objects_2) yield.lo \\\n-\t$(am__objects_3) malloc.lo runtime1.lo sigqueue.lo \\\n-\t$(am__objects_4)\n+\tthread.lo $(am__objects_2) yield.lo $(am__objects_3) malloc.lo \\\n+\truntime1.lo $(am__objects_4)\n am_libgo_llgo_la_OBJECTS = $(am__objects_5)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -828,14 +827,12 @@ runtime_files = \\\n \truntime/print.c \\\n \truntime/proc.c \\\n \truntime/runtime_c.c \\\n-\truntime/signal_unix.c \\\n \truntime/thread.c \\\n \t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \tmalloc.c \\\n \truntime1.c \\\n-\tsigqueue.c \\\n \t$(runtime_getncpu_file)\n \n noinst_DATA = zstdpkglist.go\n@@ -1141,7 +1138,7 @@ CHECK_DEPS = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n math_lo_GOCFLAGS = $(MATH_FLAG)\n \n # Add the generated file runtime_sysinfo.go to the runtime package.\n-extra_go_files_runtime = runtime_sysinfo.go\n+extra_go_files_runtime = runtime_sysinfo.go sigtab.go\n \n # Add generated files to the syscall package.\n extra_go_files_syscall = \\\n@@ -1525,8 +1522,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rtems-task-variable-add.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime_c.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/signal_unix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sigqueue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread.Plo@am__quote@\n@@ -1966,13 +1961,6 @@ runtime_c.lo: runtime/runtime_c.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o runtime_c.lo `test -f 'runtime/runtime_c.c' || echo '$(srcdir)/'`runtime/runtime_c.c\n \n-signal_unix.lo: runtime/signal_unix.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT signal_unix.lo -MD -MP -MF $(DEPDIR)/signal_unix.Tpo -c -o signal_unix.lo `test -f 'runtime/signal_unix.c' || echo '$(srcdir)/'`runtime/signal_unix.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/signal_unix.Tpo $(DEPDIR)/signal_unix.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/signal_unix.c' object='signal_unix.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o signal_unix.lo `test -f 'runtime/signal_unix.c' || echo '$(srcdir)/'`runtime/signal_unix.c\n-\n thread.lo: runtime/thread.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread.lo -MD -MP -MF $(DEPDIR)/thread.Tpo -c -o thread.lo `test -f 'runtime/thread.c' || echo '$(srcdir)/'`runtime/thread.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread.Tpo $(DEPDIR)/thread.Plo\n@@ -3177,10 +3165,6 @@ runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c\n-\t./goc2c --go-pkgpath os_signal $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n %.c: $(srcdir)/runtime/%.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n@@ -3245,6 +3229,12 @@ s-runtime_sysinfo: $(srcdir)/mkrsysinfo.sh gen-sysinfo.go\n \t$(SHELL) $(srcdir)/mvifdiff.sh tmp-runtime_sysinfo.go runtime_sysinfo.go\n \t$(STAMP) $@\n \n+sigtab.go: s-sigtab; @true\n+s-sigtab: $(srcdir)/mksigtab.sh gen-sysinfo.go\n+\tGOOS=$(GOOS) $(SHELL) $(srcdir)/mksigtab.sh > tmp-sigtab.go\n+\t$(SHELL) $(srcdir)/mvifdiff.sh tmp-sigtab.go sigtab.go\n+\t$(STAMP) $@\n+\n runtime.inc: s-runtime-inc; @true\n s-runtime-inc: runtime.lo Makefile\n \trm -f runtime.inc.tmp2"}, {"sha": "c39107be1b4aede481a1caf3a78b6c87ab840b93", "filename": "libgo/go/runtime/panic.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+// Calling panic with one of the errors below will call errorString.Error\n+// which will call mallocgc to concatenate strings. That will fail if\n+// malloc is locked, causing a confusing error message. Throw a better\n+// error message instead.\n+func panicCheckMalloc(err error) {\n+\tgp := getg()\n+\tif gp != nil && gp.m != nil && gp.m.mallocing != 0 {\n+\t\tthrow(string(err.(errorString)))\n+\t}\n+}\n+\n+var indexError = error(errorString(\"index out of range\"))\n+\n+func panicindex() {\n+\tpanicCheckMalloc(indexError)\n+\tpanic(indexError)\n+}\n+\n+var sliceError = error(errorString(\"slice bounds out of range\"))\n+\n+func panicslice() {\n+\tpanicCheckMalloc(sliceError)\n+\tpanic(sliceError)\n+}\n+\n+var divideError = error(errorString(\"integer divide by zero\"))\n+\n+func panicdivide() {\n+\tpanicCheckMalloc(divideError)\n+\tpanic(divideError)\n+}\n+\n+var overflowError = error(errorString(\"integer overflow\"))\n+\n+func panicoverflow() {\n+\tpanicCheckMalloc(overflowError)\n+\tpanic(overflowError)\n+}\n+\n+var floatError = error(errorString(\"floating point error\"))\n+\n+func panicfloat() {\n+\tpanicCheckMalloc(floatError)\n+\tpanic(floatError)\n+}\n+\n+var memoryError = error(errorString(\"invalid memory address or nil pointer dereference\"))\n+\n+func panicmem() {\n+\tpanicCheckMalloc(memoryError)\n+\tpanic(memoryError)\n+}\n+\n+func throwreturn() {\n+\tthrow(\"no return at end of a typed function - compiler is broken\")\n+}\n+\n+func throwinit() {\n+\tthrow(\"recursive call during initialization - linker skew\")\n+}\n+\n+//go:nosplit\n+func canpanic(gp *g) bool {\n+\t// Note that g is m->gsignal, different from gp.\n+\t// Note also that g->m can change at preemption, so m can go stale\n+\t// if this function ever makes a function call.\n+\t_g_ := getg()\n+\t_m_ := _g_.m\n+\n+\t// Is it okay for gp to panic instead of crashing the program?\n+\t// Yes, as long as it is running Go code, not runtime code,\n+\t// and not stuck in a system call.\n+\tif gp == nil || gp != _m_.curg {\n+\t\treturn false\n+\t}\n+\tif _m_.locks-_m_.softfloat != 0 || _m_.mallocing != 0 || _m_.throwing != 0 || _m_.preemptoff != \"\" || _m_.dying != 0 {\n+\t\treturn false\n+\t}\n+\tstatus := readgstatus(gp)\n+\tif status&^_Gscan != _Grunning || gp.syscallsp != 0 {\n+\t\treturn false\n+\t}\n+\treturn true\n+}"}, {"sha": "f3bbb589d1c986d03971f379aaba75e78a7b0e4d", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -326,8 +326,8 @@ type g struct {\n \tm      *m      // current m; offset known to arm liblink\n \t// Not for gccgo: stackAlloc     uintptr // stack allocation is [stack.lo,stack.lo+stackAlloc)\n \t// Not for gccgo: sched          gobuf\n-\t// Not for gccgo: syscallsp      uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc\n-\t// Not for gccgo: syscallpc      uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc\n+\tsyscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc\n+\tsyscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc\n \t// Not for gccgo: stkbar         []stkbar       // stack barriers, from low to high (see top of mstkbar.go)\n \t// Not for gccgo: stkbarPos      uintptr        // index of lowest stack barrier not hit\n \t// Not for gccgo: stktopsp       uintptr        // expected sp at top of stack, to check in traceback"}, {"sha": "f9327651911ad55ff2272f5f4016ceedb0e06c5a", "filename": "libgo/go/runtime/signal1_unix.go", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal1_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal1_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal1_unix.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,332 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package runtime\n+\n+import (\n+\t_ \"unsafe\" // For go:linkname.\n+)\n+\n+// Temporary for gccgo's C code to call:\n+//go:linkname initsig runtime.initsig\n+//go:linkname crash runtime.crash\n+//go:linkname resetcpuprofiler runtime.resetcpuprofiler\n+\n+//extern setitimer\n+func setitimer(which int32, new *_itimerval, old *_itimerval) int32\n+\n+type sigTabT struct {\n+\tflags int32\n+\tname  string\n+}\n+\n+const (\n+\t_SIG_DFL uintptr = 0\n+\t_SIG_IGN uintptr = 1\n+)\n+\n+// Stores the signal handlers registered before Go installed its own.\n+// These signal handlers will be invoked in cases where Go doesn't want to\n+// handle a particular signal (e.g., signal occurred on a non-Go thread).\n+// See sigfwdgo() for more information on when the signals are forwarded.\n+//\n+// Signal forwarding is currently available only on Darwin and Linux.\n+var fwdSig [_NSIG]uintptr\n+\n+// sigmask represents a general signal mask compatible with the GOOS\n+// specific sigset types: the signal numbered x is represented by bit x-1\n+// to match the representation expected by sigprocmask.\n+type sigmask [(_NSIG + 31) / 32]uint32\n+\n+// channels for synchronizing signal mask updates with the signal mask\n+// thread\n+var (\n+\tdisableSigChan  chan uint32\n+\tenableSigChan   chan uint32\n+\tmaskUpdatedChan chan struct{}\n+)\n+\n+func init() {\n+\t// _NSIG is the number of signals on this operating system.\n+\t// sigtable should describe what to do for all the possible signals.\n+\tif len(sigtable) != _NSIG {\n+\t\tprint(\"runtime: len(sigtable)=\", len(sigtable), \" _NSIG=\", _NSIG, \"\\n\")\n+\t\tthrow(\"bad sigtable len\")\n+\t}\n+}\n+\n+var signalsOK bool\n+\n+// Initialize signals.\n+// Called by libpreinit so runtime may not be initialized.\n+//go:nosplit\n+//go:nowritebarrierrec\n+func initsig(preinit bool) {\n+\tif !preinit {\n+\t\t// It's now OK for signal handlers to run.\n+\t\tsignalsOK = true\n+\t}\n+\n+\t// For c-archive/c-shared this is called by libpreinit with\n+\t// preinit == true.\n+\tif (isarchive || islibrary) && !preinit {\n+\t\treturn\n+\t}\n+\n+\tfor i := int32(0); i < _NSIG; i++ {\n+\t\tt := &sigtable[i]\n+\t\tif t.flags == 0 || t.flags&_SigDefault != 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfwdSig[i] = getsig(i)\n+\n+\t\tif !sigInstallGoHandler(i) {\n+\t\t\t// Even if we are not installing a signal handler,\n+\t\t\t// set SA_ONSTACK if necessary.\n+\t\t\tif fwdSig[i] != _SIG_DFL && fwdSig[i] != _SIG_IGN {\n+\t\t\t\tsetsigstack(i)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tt.flags |= _SigHandling\n+\t\tsetsig(i, funcPC(sigtramp), true)\n+\t}\n+}\n+\n+//go:nosplit\n+//go:nowritebarrierrec\n+func sigInstallGoHandler(sig int32) bool {\n+\t// For some signals, we respect an inherited SIG_IGN handler\n+\t// rather than insist on installing our own default handler.\n+\t// Even these signals can be fetched using the os/signal package.\n+\tswitch sig {\n+\tcase _SIGHUP, _SIGINT:\n+\t\tif fwdSig[sig] == _SIG_IGN {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tt := &sigtable[sig]\n+\tif t.flags&_SigSetStack != 0 {\n+\t\treturn false\n+\t}\n+\n+\t// When built using c-archive or c-shared, only install signal\n+\t// handlers for synchronous signals.\n+\tif (isarchive || islibrary) && t.flags&_SigPanic == 0 {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n+}\n+\n+func sigenable(sig uint32) {\n+\tif sig >= uint32(len(sigtable)) {\n+\t\treturn\n+\t}\n+\n+\tt := &sigtable[sig]\n+\tif t.flags&_SigNotify != 0 {\n+\t\tensureSigM()\n+\t\tenableSigChan <- sig\n+\t\t<-maskUpdatedChan\n+\t\tif t.flags&_SigHandling == 0 {\n+\t\t\tt.flags |= _SigHandling\n+\t\t\tfwdSig[sig] = getsig(int32(sig))\n+\t\t\tsetsig(int32(sig), funcPC(sigtramp), true)\n+\t\t}\n+\t}\n+}\n+\n+func sigdisable(sig uint32) {\n+\tif sig >= uint32(len(sigtable)) {\n+\t\treturn\n+\t}\n+\n+\tt := &sigtable[sig]\n+\tif t.flags&_SigNotify != 0 {\n+\t\tensureSigM()\n+\t\tdisableSigChan <- sig\n+\t\t<-maskUpdatedChan\n+\n+\t\t// If initsig does not install a signal handler for a\n+\t\t// signal, then to go back to the state before Notify\n+\t\t// we should remove the one we installed.\n+\t\tif !sigInstallGoHandler(int32(sig)) {\n+\t\t\tt.flags &^= _SigHandling\n+\t\t\tsetsig(int32(sig), fwdSig[sig], true)\n+\t\t}\n+\t}\n+}\n+\n+func sigignore(sig uint32) {\n+\tif sig >= uint32(len(sigtable)) {\n+\t\treturn\n+\t}\n+\n+\tt := &sigtable[sig]\n+\tif t.flags&_SigNotify != 0 {\n+\t\tt.flags &^= _SigHandling\n+\t\tsetsig(int32(sig), _SIG_IGN, true)\n+\t}\n+}\n+\n+func resetcpuprofiler(hz int32) {\n+\tvar it _itimerval\n+\tif hz == 0 {\n+\t\tsetitimer(_ITIMER_PROF, &it, nil)\n+\t} else {\n+\t\tit.it_interval.tv_sec = 0\n+\t\tit.it_interval.set_usec(1000000 / hz)\n+\t\tit.it_value = it.it_interval\n+\t\tsetitimer(_ITIMER_PROF, &it, nil)\n+\t}\n+\t_g_ := getg()\n+\t_g_.m.profilehz = hz\n+}\n+\n+func sigpipe() {\n+\tif sigsend(_SIGPIPE) {\n+\t\treturn\n+\t}\n+\tdieFromSignal(_SIGPIPE)\n+}\n+\n+// dieFromSignal kills the program with a signal.\n+// This provides the expected exit status for the shell.\n+// This is only called with fatal signals expected to kill the process.\n+//go:nosplit\n+//go:nowritebarrierrec\n+func dieFromSignal(sig int32) {\n+\tsetsig(sig, _SIG_DFL, false)\n+\tupdatesigmask(sigmask{})\n+\traise(sig)\n+\n+\t// That should have killed us. On some systems, though, raise\n+\t// sends the signal to the whole process rather than to just\n+\t// the current thread, which means that the signal may not yet\n+\t// have been delivered. Give other threads a chance to run and\n+\t// pick up the signal.\n+\tosyield()\n+\tosyield()\n+\tosyield()\n+\n+\t// If we are still somehow running, just exit with the wrong status.\n+\texit(2)\n+}\n+\n+// raisebadsignal is called when a signal is received on a non-Go\n+// thread, and the Go program does not want to handle it (that is, the\n+// program has not called os/signal.Notify for the signal).\n+func raisebadsignal(sig int32, c *sigctxt) {\n+\tif sig == _SIGPROF {\n+\t\t// Ignore profiling signals that arrive on non-Go threads.\n+\t\treturn\n+\t}\n+\n+\tvar handler uintptr\n+\tif sig >= _NSIG {\n+\t\thandler = _SIG_DFL\n+\t} else {\n+\t\thandler = fwdSig[sig]\n+\t}\n+\n+\t// Reset the signal handler and raise the signal.\n+\t// We are currently running inside a signal handler, so the\n+\t// signal is blocked. We need to unblock it before raising the\n+\t// signal, or the signal we raise will be ignored until we return\n+\t// from the signal handler. We know that the signal was unblocked\n+\t// before entering the handler, or else we would not have received\n+\t// it. That means that we don't have to worry about blocking it\n+\t// again.\n+\tunblocksig(sig)\n+\tsetsig(sig, handler, false)\n+\n+\t// If we're linked into a non-Go program we want to try to\n+\t// avoid modifying the original context in which the signal\n+\t// was raised. If the handler is the default, we know it\n+\t// is non-recoverable, so we don't have to worry about\n+\t// re-installing sighandler. At this point we can just\n+\t// return and the signal will be re-raised and caught by\n+\t// the default handler with the correct context.\n+\tif (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {\n+\t\treturn\n+\t}\n+\n+\traise(sig)\n+\n+\t// If the signal didn't cause the program to exit, restore the\n+\t// Go signal handler and carry on.\n+\t//\n+\t// We may receive another instance of the signal before we\n+\t// restore the Go handler, but that is not so bad: we know\n+\t// that the Go program has been ignoring the signal.\n+\tsetsig(sig, funcPC(sigtramp), true)\n+}\n+\n+func crash() {\n+\tdieFromSignal(_SIGABRT)\n+}\n+\n+// ensureSigM starts one global, sleeping thread to make sure at least one thread\n+// is available to catch signals enabled for os/signal.\n+func ensureSigM() {\n+\tif maskUpdatedChan != nil {\n+\t\treturn\n+\t}\n+\tmaskUpdatedChan = make(chan struct{})\n+\tdisableSigChan = make(chan uint32)\n+\tenableSigChan = make(chan uint32)\n+\tgo func() {\n+\t\t// Signal masks are per-thread, so make sure this goroutine stays on one\n+\t\t// thread.\n+\t\tLockOSThread()\n+\t\tdefer UnlockOSThread()\n+\t\t// The sigBlocked mask contains the signals not active for os/signal,\n+\t\t// initially all signals except the essential. When signal.Notify()/Stop is called,\n+\t\t// sigenable/sigdisable in turn notify this thread to update its signal\n+\t\t// mask accordingly.\n+\t\tvar sigBlocked sigmask\n+\t\tfor i := range sigBlocked {\n+\t\t\tsigBlocked[i] = ^uint32(0)\n+\t\t}\n+\t\tfor i := range sigtable {\n+\t\t\tif sigtable[i].flags&_SigUnblock != 0 {\n+\t\t\t\tsigBlocked[(i-1)/32] &^= 1 << ((uint32(i) - 1) & 31)\n+\t\t\t}\n+\t\t}\n+\t\tupdatesigmask(sigBlocked)\n+\t\tfor {\n+\t\t\tselect {\n+\t\t\tcase sig := <-enableSigChan:\n+\t\t\t\tif b := sig - 1; sig > 0 {\n+\t\t\t\t\tsigBlocked[b/32] &^= (1 << (b & 31))\n+\t\t\t\t}\n+\t\t\tcase sig := <-disableSigChan:\n+\t\t\t\tif b := sig - 1; sig > 0 {\n+\t\t\t\t\tsigBlocked[b/32] |= (1 << (b & 31))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tupdatesigmask(sigBlocked)\n+\t\t\tmaskUpdatedChan <- struct{}{}\n+\t\t}\n+\t}()\n+}\n+\n+// This runs on a foreign stack, without an m or a g. No stack split.\n+//go:nosplit\n+//go:norace\n+//go:nowritebarrierrec\n+func badsignal(sig uintptr, c *sigctxt) {\n+\tneedm()\n+\tif !sigsend(uint32(sig)) {\n+\t\t// A foreign thread received the signal sig, and the\n+\t\t// Go code does not want to handle it.\n+\t\traisebadsignal(int32(sig), c)\n+\t}\n+\tdropm()\n+}"}, {"sha": "2a39eac43fa23442830cc4c6fbe6c7e165424a10", "filename": "libgo/go/runtime/signal2_unix.go", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal2_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal2_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal2_unix.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -2,24 +2,19 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build ignore\n-\n-// +build darwin dragonfly freebsd linux netbsd openbsd\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n \n package runtime\n \n import \"unsafe\"\n \n-//go:noescape\n-func sigfwd(fn uintptr, sig uint32, info *siginfo, ctx unsafe.Pointer)\n-\n // Determines if the signal should be handled by Go and if not, forwards the\n // signal to the handler that was installed before Go's. Returns whether the\n // signal was forwarded.\n // This is called by the signal handler, and the world may be stopped.\n //go:nosplit\n //go:nowritebarrierrec\n-func sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool {\n+func sigfwdgo(sig uint32, info *_siginfo_t, ctx unsafe.Pointer) bool {\n \tif sig >= uint32(len(sigtable)) {\n \t\treturn false\n \t}\n@@ -52,7 +47,7 @@ func sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool {\n \t}\n \n \t// Only forward synchronous signals.\n-\tc := &sigctxt{info, ctx}\n+\tc := sigctxt{info, ctx}\n \tif c.sigcode() == _SI_USER || flags&_SigPanic == 0 {\n \t\treturn false\n \t}"}, {"sha": "0ecafccec4c946caeab4e6f935e0918e9c960945", "filename": "libgo/go/runtime/signal_gccgo.go", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// Functions for gccgo to support signal handling. In the gc runtime\n+// these are written in OS-specific files and in assembler.\n+\n+//extern sigaction\n+func sigaction(signum int32, act *_sigaction, oact *_sigaction) int32\n+\n+//extern sigprocmask\n+func sigprocmask(how int32, set *_sigset_t, oldset *_sigset_t) int32\n+\n+// The argument should be simply *_sigset_t, but that fails on GNU/Linux\n+// which sometimes uses _sigset_t and sometimes uses ___sigset_t.\n+//extern sigfillset\n+func sigfillset(set unsafe.Pointer) int32\n+\n+//extern sigemptyset\n+func sigemptyset(set *_sigset_t) int32\n+\n+//extern sigaddset\n+func sigaddset(set *_sigset_t, signum int32) int32\n+\n+//extern sigaltstack\n+func sigaltstack(ss *_stack_t, oss *_stack_t) int32\n+\n+//extern raise\n+func raise(sig int32) int32\n+\n+//extern getpid\n+func getpid() _pid_t\n+\n+//extern kill\n+func kill(pid _pid_t, sig int32) int32\n+\n+type sigctxt struct {\n+\tinfo *_siginfo_t\n+\tctxt unsafe.Pointer\n+}\n+\n+func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }\n+\n+//go:nosplit\n+func sigblock() {\n+\tvar set _sigset_t\n+\tsigfillset(unsafe.Pointer(&set))\n+\tsigprocmask(_SIG_SETMASK, &set, nil)\n+}\n+\n+//go:nosplit\n+//go:nowritebarrierrec\n+func setsig(i int32, fn uintptr, restart bool) {\n+\tvar sa _sigaction\n+\tsa.sa_flags = _SA_SIGINFO\n+\n+\t// For gccgo we do not set SA_ONSTACK for a signal that can\n+\t// cause a panic.  Instead, we trust that the split stack has\n+\t// enough room to start the signal handler.  This is because\n+\t// otherwise we have no good way to switch back to the\n+\t// original stack before panicing.\n+\tif sigtable[i].flags&_SigPanic == 0 {\n+\t\tsa.sa_flags |= _SA_ONSTACK\n+\t}\n+\n+\tif restart {\n+\t\tsa.sa_flags |= _SA_RESTART\n+\t}\n+\tsigfillset(unsafe.Pointer(&sa.sa_mask))\n+\tsetSigactionHandler(&sa, fn)\n+\tsigaction(i, &sa, nil)\n+}\n+\n+//go:nosplit\n+//go:nowritebarrierrec\n+func setsigstack(i int32) {\n+\tvar sa _sigaction\n+\tsigaction(i, nil, &sa)\n+\thandler := getSigactionHandler(&sa)\n+\tif handler == 0 || handler == _SIG_DFL || handler == _SIG_IGN || sa.sa_flags&_SA_ONSTACK != 0 {\n+\t\treturn\n+\t}\n+\tif sigtable[i].flags&_SigPanic != 0 {\n+\t\treturn\n+\t}\n+\tsa.sa_flags |= _SA_ONSTACK\n+\tsigaction(i, &sa, nil)\n+}\n+\n+//go:nosplit\n+//go:nowritebarrierrec\n+func getsig(i int32) uintptr {\n+\tvar sa _sigaction\n+\tif sigaction(i, nil, &sa) < 0 {\n+\t\t// On GNU/Linux glibc rejects attempts to call\n+\t\t// sigaction with signal 32 (SIGCANCEL) or 33 (SIGSETXID).\n+\t\tif GOOS == \"linux\" && (i == 32 || i == 33) {\n+\t\t\treturn _SIG_DFL\n+\t\t}\n+\t\tthrow(\"sigaction read failure\")\n+\t}\n+\treturn getSigactionHandler(&sa)\n+}\n+\n+//go:nosplit\n+//go:nowritebarrierrec\n+func updatesigmask(m sigmask) {\n+\tvar mask _sigset_t\n+\tsigemptyset(&mask)\n+\tfor i := int32(0); i < _NSIG; i++ {\n+\t\tif m[(i-1)/32]&(1<<((uint(i)-1)&31)) != 0 {\n+\t\t\tsigaddset(&mask, i)\n+\t\t}\n+\t}\n+\tsigprocmask(_SIG_SETMASK, &mask, nil)\n+}\n+\n+func unblocksig(sig int32) {\n+\tvar mask _sigset_t\n+\tsigemptyset(&mask)\n+\tsigaddset(&mask, sig)\n+\tsigprocmask(_SIG_UNBLOCK, &mask, nil)\n+}\n+\n+//go:nosplit\n+//go:nowritebarrierrec\n+func raiseproc(sig int32) {\n+\tkill(getpid(), sig)\n+}\n+\n+//go:nosplit\n+//go:nowritebarrierrec\n+func sigfwd(fn uintptr, sig uint32, info *_siginfo_t, ctx unsafe.Pointer) {\n+\tf1 := &[1]uintptr{fn}\n+\tf2 := *(*func(uint32, *_siginfo_t, unsafe.Pointer))(unsafe.Pointer(&f1))\n+\tf2(sig, info, ctx)\n+}"}, {"sha": "3cbec66236facf68274f6feca3070c38ddb80c95", "filename": "libgo/go/runtime/signal_sighandler.go", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// crashing is the number of m's we have waited for when implementing\n+// GOTRACEBACK=crash when a signal is received.\n+var crashing int32\n+\n+// sighandler is invoked when a signal occurs. The global g will be\n+// set to a gsignal goroutine and we will be running on the alternate\n+// signal stack. The parameter g will be the value of the global g\n+// when the signal occurred. The sig, info, and ctxt parameters are\n+// from the system signal handler: they are the parameters passed when\n+// the SA is passed to the sigaction system call.\n+//\n+// The garbage collector may have stopped the world, so write barriers\n+// are not allowed.\n+//\n+//go:nowritebarrierrec\n+func sighandler(sig uint32, info *_siginfo_t, ctxt unsafe.Pointer, gp *g) {\n+\t_g_ := getg()\n+\tc := sigctxt{info, ctxt}\n+\n+\tif sig == _SIGPROF {\n+\t\tsigprof()\n+\t\treturn\n+\t}\n+\n+\tsigfault, sigpc := getSiginfo(info, ctxt)\n+\n+\tflags := int32(_SigThrow)\n+\tif sig < uint32(len(sigtable)) {\n+\t\tflags = sigtable[sig].flags\n+\t}\n+\tif c.sigcode() != _SI_USER && flags&_SigPanic != 0 {\n+\t\t// Emulate gc by passing arguments out of band,\n+\t\t// although we don't really have to.\n+\t\tgp.sig = sig\n+\t\tgp.sigcode0 = uintptr(c.sigcode())\n+\t\tgp.sigcode1 = sigfault\n+\t\tgp.sigpc = sigpc\n+\n+\t\tsetg(gp)\n+\n+\t\t// All signals were blocked due to the sigaction mask;\n+\t\t// unblock them.\n+\t\tvar set _sigset_t\n+\t\tsigfillset(unsafe.Pointer(&set))\n+\t\tsigprocmask(_SIG_UNBLOCK, &set, nil)\n+\n+\t\tsigpanic()\n+\t\tthrow(\"sigpanic returned\")\n+\t}\n+\n+\tif c.sigcode() == _SI_USER || flags&_SigNotify != 0 {\n+\t\tif sigsend(sig) {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tif c.sigcode() == _SI_USER && signal_ignored(sig) {\n+\t\treturn\n+\t}\n+\n+\tif flags&_SigKill != 0 {\n+\t\tdieFromSignal(int32(sig))\n+\t}\n+\n+\tif flags&_SigThrow == 0 {\n+\t\treturn\n+\t}\n+\n+\t_g_.m.throwing = 1\n+\t_g_.m.caughtsig.set(gp)\n+\n+\tif crashing == 0 {\n+\t\tstartpanic()\n+\t}\n+\n+\tif sig < uint32(len(sigtable)) {\n+\t\tprint(sigtable[sig].name, \"\\n\")\n+\t} else {\n+\t\tprint(\"Signal \", sig, \"\\n\")\n+\t}\n+\n+\tif sigpc != 0 {\n+\t\tprint(\"PC=\", hex(sigpc), \" \")\n+\t}\n+\tprint(\"m=\", _g_.m.id, \" sigcode=\", c.sigcode(), \"\\n\")\n+\tif _g_.m.lockedg != nil && _g_.m.ncgo > 0 && gp == _g_.m.g0 {\n+\t\tprint(\"signal arrived during cgo execution\\n\")\n+\t\tgp = _g_.m.lockedg\n+\t}\n+\tprint(\"\\n\")\n+\n+\tlevel, _, docrash := gotraceback()\n+\tif level > 0 {\n+\t\tgoroutineheader(gp)\n+\t\ttraceback(0)\n+\t\tif crashing == 0 {\n+\t\t\ttracebackothers(gp)\n+\t\t\tprint(\"\\n\")\n+\t\t}\n+\t\tdumpregs(info, ctxt)\n+\t}\n+\n+\tif docrash {\n+\t\tcrashing++\n+\t\tif crashing < mcount() {\n+\t\t\t// There are other m's that need to dump their stacks.\n+\t\t\t// Relay SIGQUIT to the next m by sending it to the current process.\n+\t\t\t// All m's that have already received SIGQUIT have signal masks blocking\n+\t\t\t// receipt of any signals, so the SIGQUIT will go to an m that hasn't seen it yet.\n+\t\t\t// When the last m receives the SIGQUIT, it will fall through to the call to\n+\t\t\t// crash below. Just in case the relaying gets botched, each m involved in\n+\t\t\t// the relay sleeps for 5 seconds and then does the crash/exit itself.\n+\t\t\t// In expected operation, the last m has received the SIGQUIT and run\n+\t\t\t// crash/exit and the process is gone, all long before any of the\n+\t\t\t// 5-second sleeps have finished.\n+\t\t\tprint(\"\\n-----\\n\\n\")\n+\t\t\traiseproc(_SIGQUIT)\n+\t\t\tusleep(5 * 1000 * 1000)\n+\t\t}\n+\t\tcrash()\n+\t}\n+\n+\texit(2)\n+}"}, {"sha": "67b9e6704333df70d476a066921ffaa23ab46627", "filename": "libgo/go/runtime/signal_sigtramp.go", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -2,19 +2,20 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build ignore\n-\n-// +build dragonfly linux netbsd\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n \n package runtime\n \n import \"unsafe\"\n \n+// For gccgo, use go:linkname so the C signal handler can call this one.\n+//go:linkname sigtrampgo runtime.sigtrampgo\n+\n // Continuation of the (assembly) sigtramp() logic.\n // This may be called with the world stopped.\n //go:nosplit\n //go:nowritebarrierrec\n-func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {\n+func sigtrampgo(sig uint32, info *_siginfo_t, ctx unsafe.Pointer) {\n \tif sigfwdgo(sig, info, ctx) {\n \t\treturn\n \t}\n@@ -32,28 +33,6 @@ func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {\n \t\treturn\n \t}\n \n-\t// If some non-Go code called sigaltstack, adjust.\n-\tsp := uintptr(unsafe.Pointer(&sig))\n-\tif sp < g.m.gsignal.stack.lo || sp >= g.m.gsignal.stack.hi {\n-\t\tvar st sigaltstackt\n-\t\tsigaltstack(nil, &st)\n-\t\tif st.ss_flags&_SS_DISABLE != 0 {\n-\t\t\tsetg(nil)\n-\t\t\tcgocallback(unsafe.Pointer(funcPC(noSignalStack)), noescape(unsafe.Pointer(&sig)), unsafe.Sizeof(sig), 0)\n-\t\t}\n-\t\tstsp := uintptr(unsafe.Pointer(st.ss_sp))\n-\t\tif sp < stsp || sp >= stsp+st.ss_size {\n-\t\t\tsetg(nil)\n-\t\t\tcgocallback(unsafe.Pointer(funcPC(sigNotOnStack)), noescape(unsafe.Pointer(&sig)), unsafe.Sizeof(sig), 0)\n-\t\t}\n-\t\tg.m.gsignal.stack.lo = stsp\n-\t\tg.m.gsignal.stack.hi = stsp + st.ss_size\n-\t\tg.m.gsignal.stackguard0 = stsp + _StackGuard\n-\t\tg.m.gsignal.stackguard1 = stsp + _StackGuard\n-\t\tg.m.gsignal.stackAlloc = st.ss_size\n-\t\tg.m.gsignal.stktopsp = getcallersp(unsafe.Pointer(&sig))\n-\t}\n-\n \tsetg(g.m.gsignal)\n \tsighandler(sig, info, ctx, g)\n \tsetg(g)"}, {"sha": "f59c9b954975b4b0a7d5a6f769c9babf2d138feb", "filename": "libgo/go/runtime/signal_unix.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package runtime\n+\n+import _ \"unsafe\" // for go:linkname\n+\n+//go:linkname os_sigpipe os.sigpipe\n+func os_sigpipe() {\n+\tsystemstack(sigpipe)\n+}\n+\n+func signame(sig uint32) string {\n+\tif sig >= uint32(len(sigtable)) {\n+\t\treturn \"\"\n+\t}\n+\treturn sigtable[sig].name\n+}"}, {"sha": "00ad090f428d5326e8ba9f1b58e32d45865a5f08", "filename": "libgo/go/runtime/sigpanic_unix.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsigpanic_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsigpanic_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigpanic_unix.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package runtime\n+\n+import _ \"unsafe\" // For go:linkname.\n+\n+// For gccgo, C code has to call sigpanic, so we have to export it.\n+//go:linkname sigpanic runtime.sigpanic\n+\n+func sigpanic() {\n+\tg := getg()\n+\tif !canpanic(g) {\n+\t\tthrow(\"unexpected signal during runtime execution\")\n+\t}\n+\n+\tswitch g.sig {\n+\tcase _SIGBUS:\n+\t\tif g.sigcode0 == _BUS_ADRERR && g.sigcode1 < 0x1000 || g.paniconfault {\n+\t\t\tpanicmem()\n+\t\t}\n+\t\tprint(\"unexpected fault address \", hex(g.sigcode1), \"\\n\")\n+\t\tthrow(\"fault\")\n+\tcase _SIGSEGV:\n+\t\tif (g.sigcode0 == 0 || g.sigcode0 == _SEGV_MAPERR || g.sigcode0 == _SEGV_ACCERR) && g.sigcode1 < 0x1000 || g.paniconfault {\n+\t\t\tpanicmem()\n+\t\t}\n+\t\tprint(\"unexpected fault address \", hex(g.sigcode1), \"\\n\")\n+\t\tthrow(\"fault\")\n+\tcase _SIGFPE:\n+\t\tswitch g.sigcode0 {\n+\t\tcase _FPE_INTDIV:\n+\t\t\tpanicdivide()\n+\t\tcase _FPE_INTOVF:\n+\t\t\tpanicoverflow()\n+\t\t}\n+\t\tpanicfloat()\n+\t}\n+\n+\tif g.sig >= uint32(len(sigtable)) {\n+\t\t// can't happen: we looked up g.sig in sigtable to decide to call sigpanic\n+\t\tthrow(\"unexpected signal value\")\n+\t}\n+\tpanic(errorString(sigtable[g.sig].name))\n+}"}, {"sha": "a6d498f9b03cf3a3063f51c0d9057b7b66706e1d", "filename": "libgo/go/runtime/sigqueue.go", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements runtime support for signal handling.\n+//\n+// Most synchronization primitives are not available from\n+// the signal handler (it cannot block, allocate memory, or use locks)\n+// so the handler communicates with a processing goroutine\n+// via struct sig, below.\n+//\n+// sigsend is called by the signal handler to queue a new signal.\n+// signal_recv is called by the Go program to receive a newly queued signal.\n+// Synchronization between sigsend and signal_recv is based on the sig.state\n+// variable. It can be in 3 states: sigIdle, sigReceiving and sigSending.\n+// sigReceiving means that signal_recv is blocked on sig.Note and there are no\n+// new pending signals.\n+// sigSending means that sig.mask *may* contain new pending signals,\n+// signal_recv can't be blocked in this state.\n+// sigIdle means that there are no new pending signals and signal_recv is not blocked.\n+// Transitions between states are done atomically with CAS.\n+// When signal_recv is unblocked, it resets sig.Note and rechecks sig.mask.\n+// If several sigsends and signal_recv execute concurrently, it can lead to\n+// unnecessary rechecks of sig.mask, but it cannot lead to missed signals\n+// nor deadlocks.\n+\n+// +build !plan9\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t_ \"unsafe\" // for go:linkname\n+)\n+\n+var sig struct {\n+\tnote    note\n+\tmask    [(_NSIG + 31) / 32]uint32\n+\twanted  [(_NSIG + 31) / 32]uint32\n+\tignored [(_NSIG + 31) / 32]uint32\n+\trecv    [(_NSIG + 31) / 32]uint32\n+\tstate   uint32\n+\tinuse   bool\n+}\n+\n+const (\n+\tsigIdle = iota\n+\tsigReceiving\n+\tsigSending\n+)\n+\n+// Called from sighandler to send a signal back out of the signal handling thread.\n+// Reports whether the signal was sent. If not, the caller typically crashes the program.\n+func sigsend(s uint32) bool {\n+\tbit := uint32(1) << uint(s&31)\n+\tif !sig.inuse || s >= uint32(32*len(sig.wanted)) || sig.wanted[s/32]&bit == 0 {\n+\t\treturn false\n+\t}\n+\n+\t// Add signal to outgoing queue.\n+\tfor {\n+\t\tmask := sig.mask[s/32]\n+\t\tif mask&bit != 0 {\n+\t\t\treturn true // signal already in queue\n+\t\t}\n+\t\tif atomic.Cas(&sig.mask[s/32], mask, mask|bit) {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\t// Notify receiver that queue has new bit.\n+Send:\n+\tfor {\n+\t\tswitch atomic.Load(&sig.state) {\n+\t\tdefault:\n+\t\t\tthrow(\"sigsend: inconsistent state\")\n+\t\tcase sigIdle:\n+\t\t\tif atomic.Cas(&sig.state, sigIdle, sigSending) {\n+\t\t\t\tbreak Send\n+\t\t\t}\n+\t\tcase sigSending:\n+\t\t\t// notification already pending\n+\t\t\tbreak Send\n+\t\tcase sigReceiving:\n+\t\t\tif atomic.Cas(&sig.state, sigReceiving, sigIdle) {\n+\t\t\t\tnotewakeup(&sig.note)\n+\t\t\t\tbreak Send\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n+// Called to receive the next queued signal.\n+// Must only be called from a single goroutine at a time.\n+//go:linkname signal_recv os_signal.signal_recv\n+func signal_recv() uint32 {\n+\tfor {\n+\t\t// Serve any signals from local copy.\n+\t\tfor i := uint32(0); i < _NSIG; i++ {\n+\t\t\tif sig.recv[i/32]&(1<<(i&31)) != 0 {\n+\t\t\t\tsig.recv[i/32] &^= 1 << (i & 31)\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Wait for updates to be available from signal sender.\n+\tReceive:\n+\t\tfor {\n+\t\t\tswitch atomic.Load(&sig.state) {\n+\t\t\tdefault:\n+\t\t\t\tthrow(\"signal_recv: inconsistent state\")\n+\t\t\tcase sigIdle:\n+\t\t\t\tif atomic.Cas(&sig.state, sigIdle, sigReceiving) {\n+\t\t\t\t\tnotetsleepg(&sig.note, -1)\n+\t\t\t\t\tnoteclear(&sig.note)\n+\t\t\t\t\tbreak Receive\n+\t\t\t\t}\n+\t\t\tcase sigSending:\n+\t\t\t\tif atomic.Cas(&sig.state, sigSending, sigIdle) {\n+\t\t\t\t\tbreak Receive\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Incorporate updates from sender into local copy.\n+\t\tfor i := range sig.mask {\n+\t\t\tsig.recv[i] = atomic.Xchg(&sig.mask[i], 0)\n+\t\t}\n+\t}\n+}\n+\n+// Must only be called from a single goroutine at a time.\n+//go:linkname signal_enable os_signal.signal_enable\n+func signal_enable(s uint32) {\n+\tif !sig.inuse {\n+\t\t// The first call to signal_enable is for us\n+\t\t// to use for initialization. It does not pass\n+\t\t// signal information in m.\n+\t\tsig.inuse = true // enable reception of signals; cannot disable\n+\t\tnoteclear(&sig.note)\n+\t\treturn\n+\t}\n+\n+\tif s >= uint32(len(sig.wanted)*32) {\n+\t\treturn\n+\t}\n+\tsig.wanted[s/32] |= 1 << (s & 31)\n+\tsig.ignored[s/32] &^= 1 << (s & 31)\n+\tsigenable(s)\n+}\n+\n+// Must only be called from a single goroutine at a time.\n+//go:linkname signal_disable os_signal.signal_disable\n+func signal_disable(s uint32) {\n+\tif s >= uint32(len(sig.wanted)*32) {\n+\t\treturn\n+\t}\n+\tsig.wanted[s/32] &^= 1 << (s & 31)\n+\tsigdisable(s)\n+}\n+\n+// Must only be called from a single goroutine at a time.\n+//go:linkname signal_ignore os_signal.signal_ignore\n+func signal_ignore(s uint32) {\n+\tif s >= uint32(len(sig.wanted)*32) {\n+\t\treturn\n+\t}\n+\tsig.wanted[s/32] &^= 1 << (s & 31)\n+\tsig.ignored[s/32] |= 1 << (s & 31)\n+\tsigignore(s)\n+}\n+\n+// Checked by signal handlers.\n+func signal_ignored(s uint32) bool {\n+\treturn sig.ignored[s/32]&(1<<(s&31)) != 0\n+}"}, {"sha": "d0641ed71503eb432c892ec8bd694f83be2a6eac", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -241,9 +241,15 @@ func newarray(*_type, int) unsafe.Pointer\n // funcPC returns the entry PC of the function f.\n // It assumes that f is a func value. Otherwise the behavior is undefined.\n // For gccgo here unless and until we port proc.go.\n+// Note that this differs from the gc implementation; the gc implementation\n+// adds sys.PtrSize to the address of the interface value, but GCC's\n+// alias analysis decides that that can not be a reference to the second\n+// field of the interface, and in some cases it drops the initialization\n+// of the second field as a dead store.\n //go:nosplit\n func funcPC(f interface{}) uintptr {\n-\treturn **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))\n+\ti := (*iface)(unsafe.Pointer(&f))\n+\treturn **(**uintptr)(i.data)\n }\n \n // typedmemmove copies a typed value.\n@@ -489,3 +495,27 @@ var zerobase uintptr\n func getZerobase() *uintptr {\n \treturn &zerobase\n }\n+\n+// Temporary for gccgo until we port proc.go.\n+func needm()\n+func dropm()\n+func sigprof()\n+func mcount() int32\n+\n+// Signal trampoline, written in C.\n+func sigtramp()\n+\n+// The sa_handler field is generally hidden in a union, so use C accessors.\n+func getSigactionHandler(*_sigaction) uintptr\n+func setSigactionHandler(*_sigaction, uintptr)\n+\n+// Retrieve fields from the siginfo_t and ucontext_t pointers passed\n+// to a signal handler using C, as they are often hidden in a union.\n+// Returns  and, if available, PC where signal occurred.\n+func getSiginfo(*_siginfo_t, unsafe.Pointer) (sigaddr uintptr, sigpc uintptr)\n+\n+// Implemented in C for gccgo.\n+func dumpregs(*_siginfo_t, unsafe.Pointer)\n+\n+// Temporary for gccgo until we port panic.go.\n+func startpanic()"}, {"sha": "1ab4ea40f7154f967a1389253ca0b9da58086f7d", "filename": "libgo/mkrsysinfo.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fmkrsysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fmkrsysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmkrsysinfo.sh?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -41,6 +41,11 @@ echo $timeval | \\\n   sed -e 's/type _timeval /type timeval /' \\\n       -e 's/tv_sec *[a-zA-Z0-9_]*/tv_sec timeval_sec_t/' \\\n       -e 's/tv_usec *[a-zA-Z0-9_]*/tv_usec timeval_usec_t/' >> ${OUT}\n+echo >> ${OUT}\n+echo \"func (tv *timeval) set_usec(x int32) {\" >> ${OUT}\n+echo \"\ttv.tv_usec = timeval_usec_t(x)\" >> ${OUT}\n+echo \"}\" >> ${OUT}\n+\n timespec=`grep '^type _timespec ' gen-sysinfo.go || true`\n if test \"$timespec\" = \"\"; then\n   # IRIX 6.5 has __timespec instead."}, {"sha": "d33b7e2ff0b246e6a52e0fff7bd8d617cae2fffd", "filename": "libgo/mksigtab.sh", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fmksigtab.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fmksigtab.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksigtab.sh?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -0,0 +1,98 @@\n+#!/bin/sh\n+\n+# Copyright 2016 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# Create sigtab.go from gen-sysinfo.go.\n+\n+# This shell scripts creates the sigtab.go file, which maps signals to\n+# their dispositions.  We generate a file so that we can build a\n+# composite literal that only refers to signals that are defined on\n+# this system.\n+\n+# This script simply writes to standard output.\n+\n+set -e\n+\n+echo '// Generated by mksigtab.sh.  Do not edit.'\n+echo\n+echo 'package runtime'\n+echo\n+echo 'var sigtable = [...]sigTabT{'\n+\n+# Handle signals valid on all Unix systems.\n+\n+echo '\t0:          {0, \"SIGNONE: no trap\"},'\n+echo '\t_SIGHUP:    {_SigNotify + _SigKill, \"SIGHUP: terminal line hangup\"},'\n+echo '\t_SIGINT:    {_SigNotify + _SigKill, \"SIGINT: interrupt\"},'\n+echo '\t_SIGQUIT:   {_SigNotify + _SigThrow, \"SIGQUIT: quit\"},'\n+echo '\t_SIGILL:    {_SigThrow + _SigUnblock, \"SIGILL: illegal instruction\"},'\n+echo '\t_SIGTRAP:   {_SigThrow + _SigUnblock, \"SIGTRAP: trace trap\"},'\n+echo '\t_SIGABRT:   {_SigNotify + _SigThrow, \"SIGABRT: abort\"},'\n+echo '\t_SIGBUS:    {_SigPanic + _SigUnblock, \"SIGBUS: bus error\"},'\n+echo '\t_SIGFPE:    {_SigPanic + _SigUnblock, \"SIGFPE: floating-point exception\"},'\n+echo '\t_SIGKILL:   {0, \"SIGKILL: kill\"},'\n+echo '\t_SIGUSR1:   {_SigNotify, \"SIGUSR1: user-defined signal 1\"},'\n+echo '\t_SIGSEGV:   {_SigPanic + _SigUnblock, \"SIGSEGV: segmentation violation\"},'\n+echo '\t_SIGUSR2:   {_SigNotify, \"SIGUSR2: user-defined signal 2\"},'\n+echo '\t_SIGPIPE:   {_SigNotify, \"SIGPIPE: write to broken pipe\"},'\n+echo '\t_SIGALRM:   {_SigNotify, \"SIGALRM: alarm clock\"},'\n+echo '\t_SIGTERM:   {_SigNotify + _SigKill, \"SIGTERM: termination\"},'\n+echo '\t_SIGCHLD:   {_SigNotify + _SigUnblock, \"SIGCHLD: child status has changed\"},'\n+echo '\t_SIGCONT:   {_SigNotify + _SigDefault, \"SIGCONT: continue\"},'\n+echo '\t_SIGSTOP:   {0, \"SIGSTOP: stop\"},'\n+echo '\t_SIGTSTP:   {_SigNotify + _SigDefault, \"SIGTSTP: keyboard stop\"},'\n+echo '\t_SIGTTIN:   {_SigNotify + _SigDefault, \"SIGTTIN: background read from tty\"},'\n+echo '\t_SIGTTOU:   {_SigNotify + _SigDefault, \"SIGTTOU: background write to tty\"},'\n+echo '\t_SIGURG:    {_SigNotify, \"SIGURG: urgent condition on socket\"},'\n+echo '\t_SIGXCPU:   {_SigNotify, \"SIGXCPU: cpu limit exceeded\"},'\n+echo '\t_SIGXFSZ:   {_SigNotify, \"SIGXFSZ: file size limit exceeded\"},'\n+echo '\t_SIGVTALRM: {_SigNotify, \"SIGVTALRM: virtual alarm clock\"},'\n+echo '\t_SIGPROF:   {_SigNotify + _SigUnblock, \"SIGPROF: profiling alarm clock\"},'\n+echo '\t_SIGWINCH:  {_SigNotify, \"SIGWINCH: window size change\"},'\n+echo '\t_SIGSYS:    {_SigThrow, \"SIGSYS: bad system call\"},'\n+\n+# Handle signals that are not supported on all systems.\n+\n+checksig() {\n+    if grep 'const $1 = ' gen-sysinfo.go >/dev/null 2>&1; then\n+\techo \"\t$1: $2,\"\n+    fi\n+}\n+\n+checksig _SIGSTKFLT ' {_SigThrow + _SigUnblock, \"SIGSTKFLT: stack fault\"}'\n+checksig _SIGIO '     {_SigNotify, \"SIGIO: i/o now possible\"}'\n+checksig _SIGPWR '    {_SigNotify, \"SIGPWR: power failure restart\"}'\n+checksig _SIGEMT '    {_SigThrow, \"SIGEMT: emulate instruction executed\"}'\n+checksig _SIGINFO '   {_SigNotify, \"SIGINFO: status request from keyboard\"}'\n+checksig _SIGTHR '    {_SigNotify, \"SIGTHR: reserved\"}'\n+checksig _SIGPOLL '   {_SigNotify, \"SIGPOLL: pollable event occurred\"}'\n+checksig _SIGWAITING '{_SigNotify, \"SIGWAITING: reserved signal no longer used by\"}'\n+checksig _SIGLWP '    {_SigNotify, \"SIGLWP: reserved signal no longer used by\"}'\n+checksig _SIGFREEZE ' {_SigNotify, \"SIGFREEZE: special signal used by CPR\"}'\n+checksig _SIGTHAW '   {_SigNotify, \"SIGTHAW: special signal used by CPR\"}'\n+checksig _SIGCANCEL ' {_SigSetStack + _SigUnblock, \"SIGCANCEL: reserved signal for thread cancellation\"}'\n+checksig _SIGXRES '   {_SigNotify, \"SIGXRES: resource control exceeded\"}'\n+checksig _SIGJVM1 '   {_SigNotify, \"SIGJVM1: reserved signal for Java Virtual Machine\"}'\n+checksig _SIGJVM2 '   {_SigNotify, \"SIGJVM2: reserved signal for Java Virtual Machine\"}'\n+\n+# Special handling of signals 32 and 33 on GNU/Linux systems,\n+# because they are special to glibc.\n+if test \"${GOOS}\" = \"linux\"; then\n+    echo '\t32: {_SigSetStack + _SigUnblock, \"signal 32\"}, /* SIGCANCEL; see issue 6997 */'\n+    echo '\t33: {_SigSetStack + _SigUnblock, \"signal 33\"}, /* SIGSETXID; see issues 3871, 9400, 12498 */'\n+fi\n+\n+nsig=`grep 'const _*NSIG = [0-9]*$' gen-sysinfo.go | sed -e 's/.* = \\([0-9]*\\)/\\1/'`\n+i=1\n+while test \"$i\" -lt \"$nsig\"; do\n+    if ! grep \"const _SIG.* = $i\" gen-sysinfo.go >/dev/null 2>&1; then\n+\tif test \"${GOOS}\" != \"linux\" || test \"$i\" -ne 32 -a \"$i\" -ne 33; then\n+\t    echo \"\t$i: {_SigNotify, \\\"signal $i\\\"},\"\n+\tfi\n+    fi\n+    i=`expr \"$i\" + 1`\n+done\n+\n+echo '}'"}, {"sha": "9ee02a34f8fbeefdb425c69bbdb11aed8a0c7c19", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 207, "deletions": 480, "changes": 687, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -8,11 +8,11 @@\n #include <stdlib.h>\n #include <unistd.h>\n #include <sys/time.h>\n+#include <ucontext.h>\n \n #include \"runtime.h\"\n #include \"go-assert.h\"\n #include \"go-panic.h\"\n-#include \"signal_unix.h\"\n \n #ifndef SA_RESTART\n   #define SA_RESTART 0\n@@ -24,530 +24,257 @@ extern void __splitstack_getcontext(void *context[10]);\n \n extern void __splitstack_setcontext(void *context[10]);\n \n-#endif\n-\n-#define N _SigNotify\n-#define K _SigKill\n-#define T _SigThrow\n-#define P _SigPanic\n-#define D _SigDefault\n+extern void *__splitstack_find_context(void *context[10], size_t *,\n+\t\t\t\t       void **, void **, void **);\n \n-/* Signal actions.  This collects the sigtab tables for several\n-   different targets from the master library.  SIGKILL and SIGSTOP are\n-   not listed, as we don't want to set signal handlers for them.  */\n-\n-SigTab runtime_sigtab[] = {\n-#ifdef SIGHUP\n-  { SIGHUP,\tN + K, NULL },\n-#endif\n-#ifdef SIGINT\n-  { SIGINT, \tN + K, NULL  },\n-#endif\n-#ifdef SIGQUIT\n-  { SIGQUIT, \tN + T, NULL  },\n-#endif\n-#ifdef SIGILL\n-  { SIGILL, \tT, NULL  },\n-#endif\n-#ifdef SIGTRAP\n-  { SIGTRAP, \tT, NULL  },\n-#endif\n-#ifdef SIGABRT\n-  { SIGABRT, \tN + T, NULL  },\n-#endif\n-#ifdef SIGBUS\n-  { SIGBUS, \tP, NULL  },\n-#endif\n-#ifdef SIGFPE\n-  { SIGFPE, \tP, NULL  },\n-#endif\n-#ifdef SIGUSR1\n-  { SIGUSR1, \tN, NULL  },\n-#endif\n-#ifdef SIGSEGV\n-  { SIGSEGV, \tP, NULL  },\n-#endif\n-#ifdef SIGUSR2\n-  { SIGUSR2, \tN, NULL  },\n-#endif\n-#ifdef SIGPIPE\n-  { SIGPIPE, \tN, NULL  },\n-#endif\n-#ifdef SIGALRM\n-  { SIGALRM, \tN, NULL  },\n-#endif\n-#ifdef SIGTERM\n-  { SIGTERM, \tN + K, NULL  },\n-#endif\n-#ifdef SIGSTKFLT\n-  { SIGSTKFLT, \tT, NULL  },\n-#endif\n-#ifdef SIGCHLD\n-  { SIGCHLD, \tN, NULL  },\n-#endif\n-#ifdef SIGCONT\n-  { SIGCONT,\tN + D, NULL  },\n-#endif\n-#ifdef SIGTSTP\n-  { SIGTSTP, \tN + D, NULL  },\n-#endif\n-#ifdef SIGTTIN\n-  { SIGTTIN, \tN + D, NULL  },\n-#endif\n-#ifdef SIGTTOU\n-  { SIGTTOU, \tN + D, NULL  },\n-#endif\n-#ifdef SIGURG\n-  { SIGURG, \tN, NULL  },\n-#endif\n-#ifdef SIGXCPU\n-  { SIGXCPU, \tN, NULL  },\n-#endif\n-#ifdef SIGXFSZ\n-  { SIGXFSZ, \tN, NULL  },\n-#endif\n-#ifdef SIGVTALRM\n-  { SIGVTALRM, \tN, NULL  },\n-#endif\n-#ifdef SIGPROF\n-  { SIGPROF, \tN, NULL  },\n-#endif\n-#ifdef SIGWINCH\n-  { SIGWINCH, \tN, NULL  },\n-#endif\n-#ifdef SIGIO\n-  { SIGIO, \tN, NULL  },\n-#endif\n-#ifdef SIGPWR\n-  { SIGPWR, \tN, NULL  },\n-#endif\n-#ifdef SIGSYS\n-  { SIGSYS, \tN, NULL  },\n #endif\n-#ifdef SIGEMT\n-  { SIGEMT,\tT, NULL  },\n-#endif\n-#ifdef SIGINFO\n-  { SIGINFO,\tN, NULL  },\n-#endif\n-#ifdef SIGTHR\n-  { SIGTHR,\tN, NULL  },\n-#endif\n-  { -1,\t\t0, NULL  }\n-};\n-#undef N\n-#undef K\n-#undef T\n-#undef P\n-#undef D\n-\n-/* Handle a signal, for cases where we don't panic.  We can split the\n-   stack here.  */\n-\n-void\n-runtime_sighandler (int sig, Siginfo *info,\n-\t\t    void *context __attribute__ ((unused)), G *gp)\n-{\n-  M *m;\n-  int i;\n-\n-  m = runtime_m ();\n-\n-#ifdef SIGPROF\n-  if (sig == SIGPROF)\n-    {\n-      /* FIXME: Handle m == NULL by calling something like gc's\n-\t sigprofNonGo.  */\n-      if (m != NULL && gp != m->g0 && gp != m->gsignal)\n-\truntime_sigprof ();\n-      return;\n-    }\n-#endif\n-\n-  if (m == NULL)\n-    {\n-      runtime_badsignal (sig);\n-      return;\n-    }\n-\n-  for (i = 0; runtime_sigtab[i].sig != -1; ++i)\n-    {\n-      SigTab *t;\n-      bool notify, crash;\n-\n-      t = &runtime_sigtab[i];\n-\n-      if (t->sig != sig)\n-\tcontinue;\n-\n-      notify = false;\n-#ifdef SA_SIGINFO\n-      notify = info != NULL && info->si_code == SI_USER;\n-#endif\n-      if (notify || (t->flags & _SigNotify) != 0)\n-\t{\n-\t  if (__go_sigsend (sig))\n-\t    return;\n-\t}\n-      if ((t->flags & _SigKill) != 0)\n-\truntime_exit (2);\n-      if ((t->flags & _SigThrow) == 0)\n-\treturn;\n \n-      runtime_startpanic ();\n+// The rest of the signal handler, written in Go.\n \n-      {\n-\tconst char *name = NULL;\n-\n-#ifdef HAVE_STRSIGNAL\n-\tname = strsignal (sig);\n-#endif\n+extern void sigtrampgo(uint32, siginfo_t *, void *)\n+\t__asm__(GOSYM_PREFIX \"runtime.sigtrampgo\");\n \n-\tif (name == NULL)\n-\t  runtime_printf (\"Signal %d\\n\", sig);\n-\telse\n-\t  runtime_printf (\"%s\\n\", name);\n-      }\n+// The Go signal handler, written in C.  This should be running on the\n+// alternate signal stack.  This is responsible for setting up the\n+// split stack context so that stack guard checks will work as\n+// expected.\n \n-      if (m->lockedg != NULL && m->ncgo > 0 && gp == m->g0)\n-\t{\n-\t  runtime_printf(\"signal arrived during cgo execution\\n\");\n-\t  gp = m->lockedg;\n-\t}\n+void sigtramp(int, siginfo_t *, void *)\n+\t__attribute__ ((no_split_stack));\n \n-      runtime_printf (\"\\n\");\n+void sigtramp(int, siginfo_t *, void *)\n+\t__asm__ (GOSYM_PREFIX \"runtime.sigtramp\");\n \n-      if (runtime_gotraceback (&crash))\n-\t{\n-\t  G *g;\n+#ifndef USING_SPLIT_STACK\n \n-\t  g = runtime_g ();\n-\t  runtime_traceback (0);\n-\t  runtime_tracebackothers (g);\n+// When not using split stacks, there are no stack checks, and there\n+// is nothing special for this function to do.\n \n-\t  /* The gc library calls runtime_dumpregs here, and provides\n-\t     a function that prints the registers saved in context in\n-\t     a readable form.  */\n-\t}\n-\n-      if (crash)\n-\truntime_crash ();\n-\n-      runtime_exit (2);\n-    }\n-\n-  __builtin_unreachable ();\n-}\n-\n-/* The start of handling a signal which panics.  */\n-\n-static void\n-sig_panic_leadin (G *gp)\n+void\n+sigtramp(int sig, siginfo_t *info, void *context)\n {\n-  int i;\n-  sigset_t clear;\n-\n-  if (!runtime_canpanic (gp))\n-    runtime_throw (\"unexpected signal during runtime execution\");\n-\n-  /* The signal handler blocked signals; unblock them.  */\n-  i = sigfillset (&clear);\n-  __go_assert (i == 0);\n-  i = pthread_sigmask (SIG_UNBLOCK, &clear, NULL);\n-  __go_assert (i == 0);\n+\tsigtrampgo(sig, info, context);\n }\n \n-#ifdef SA_SIGINFO\n+#else // USING_SPLIT_STACK\n \n-/* Signal dispatch for signals which panic, on systems which support\n-   SA_SIGINFO.  This is called on the thread stack, and as such it is\n-   permitted to split the stack.  */\n-\n-static void\n-sig_panic_info_handler (int sig, Siginfo *info, void *context)\n+void\n+sigtramp(int sig, siginfo_t *info, void *context)\n {\n-  G *g;\n-\n-  g = runtime_g ();\n-  if (g == NULL || info->si_code == SI_USER)\n-    {\n-      runtime_sighandler (sig, info, context, g);\n-      return;\n-    }\n-\n-  g->sig = sig;\n-  g->sigcode0 = info->si_code;\n-  g->sigcode1 = (uintptr_t) info->si_addr;\n-\n-  /* It would be nice to set g->sigpc here as the gc library does, but\n-     I don't know how to get it portably.  */\n-\n-  sig_panic_leadin (g);\n-\n-  switch (sig)\n-    {\n-#ifdef SIGBUS\n-    case SIGBUS:\n-      if ((info->si_code == BUS_ADRERR && (uintptr_t) info->si_addr < 0x1000)\n-\t  || g->paniconfault)\n-\truntime_panicstring (\"invalid memory address or \"\n-\t\t\t     \"nil pointer dereference\");\n-      runtime_printf (\"unexpected fault address %p\\n\", info->si_addr);\n-      runtime_throw (\"fault\");\n-#endif\n-\n-#ifdef SIGSEGV\n-    case SIGSEGV:\n-      if (((info->si_code == 0\n-\t    || info->si_code == SEGV_MAPERR\n-\t    || info->si_code == SEGV_ACCERR)\n-\t   && (uintptr_t) info->si_addr < 0x1000)\n-\t  || g->paniconfault)\n-\truntime_panicstring (\"invalid memory address or \"\n-\t\t\t     \"nil pointer dereference\");\n-      runtime_printf (\"unexpected fault address %p\\n\", info->si_addr);\n-      runtime_throw (\"fault\");\n-#endif\n+\tG *gp;\n+\tvoid *stack_context[10];\n+\tvoid *stack;\n+\tsize_t stack_size;\n+\tvoid *next_segment;\n+\tvoid *next_sp;\n+\tvoid *initial_sp;\n+\tuintptr sp;\n+\tstack_t st;\n+\tuintptr stsp;\n+\n+\tgp = runtime_g();\n+\n+\tif (gp == nil) {\n+\t\t// Let the Go code handle this case.\n+\t\t// It should only call nosplit functions in this case.\n+\t\tsigtrampgo(sig, info, context);\n+\t\treturn;\n+\t}\n \n-#ifdef SIGFPE\n-    case SIGFPE:\n-      switch (info->si_code)\n-\t{\n-\tcase FPE_INTDIV:\n-\t  runtime_panicstring (\"integer divide by zero\");\n-\tcase FPE_INTOVF:\n-\t  runtime_panicstring (\"integer overflow\");\n+\t// If this signal is one for which we will panic, we are not\n+\t// on the alternate signal stack.  It's OK to call split-stack\n+\t// functions here.\n+\tif (sig == SIGBUS || sig == SIGFPE || sig == SIGSEGV) {\n+\t\tsigtrampgo(sig, info, context);\n+\t\treturn;\n \t}\n-      runtime_panicstring (\"floating point error\");\n-#endif\n-    }\n \n-  /* All signals with _SigPanic should be in cases above, and this\n-     handler should only be invoked for those signals.  */\n-  __builtin_unreachable ();\n-}\n+\t// We are running on the alternate signal stack.\n+\n+\t__splitstack_getcontext(&stack_context[0]);\n+\n+\tstack = __splitstack_find_context(&gp->m->gsignal->stackcontext[0],\n+\t\t\t\t\t  &stack_size, &next_segment,\n+\t\t\t\t\t  &next_sp, &initial_sp);\n+\n+\t// If some non-Go code called sigaltstack, adjust.\n+\tsp = (uintptr)(&stack_size);\n+\tif (sp < (uintptr)(stack) || sp >= (uintptr)(stack) + stack_size) {\n+\t\tsigaltstack(nil, &st);\n+\t\tif ((st.ss_flags & SS_DISABLE) != 0) {\n+\t\t\truntime_printf(\"signal %d received on thread with no signal stack\\n\", (int32)(sig));\n+\t\t\truntime_throw(\"non-Go code disabled sigaltstack\");\n+\t\t}\n+\n+\t\tstsp = (uintptr)(st.ss_sp);\n+\t\tif (sp < stsp || sp >= stsp + st.ss_size) {\n+\t\t\truntime_printf(\"signal %d received but handler not on signal stack\\n\", (int32)(sig));\n+\t\t\truntime_throw(\"non-Go code set up signal handler without SA_ONSTACK flag\");\n+\t\t}\n+\n+\t\t// Unfortunately __splitstack_find_context will return NULL\n+\t\t// when it is called on a context that has never been used.\n+\t\t// There isn't much we can do but assume all is well.\n+\t\tif (stack != NULL) {\n+\t\t\t// Here the gc runtime adjusts the gsignal\n+\t\t\t// stack guard to match the values returned by\n+\t\t\t// sigaltstack.  Unfortunately we have no way\n+\t\t\t// to do that.\n+\t\t\truntime_printf(\"signal %d received on unknown signal stack\\n\", (int32)(sig));\n+\t\t\truntime_throw(\"non-Go code changed signal stack\");\n+\t\t}\n+\t}\n \n-#else /* !defined (SA_SIGINFO) */\n+\t// Set the split stack context so that the stack guards are\n+\t// checked correctly.\n \n-static void\n-sig_panic_handler (int sig)\n-{\n-  G *g;\n-\n-  g = runtime_g ();\n-  if (g == NULL)\n-    {\n-      runtime_sighandler (sig, NULL, NULL, g);\n-      return;\n-    }\n-\n-  g->sig = sig;\n-  g->sigcode0 = 0;\n-  g->sigcode1 = 0;\n-\n-  sig_panic_leadin (g);\n-\n-  switch (sig)\n-    {\n-#ifdef SIGBUS\n-    case SIGBUS:\n-      runtime_panicstring (\"invalid memory address or \"\n-\t\t\t   \"nil pointer dereference\");\n-#endif\n+\t__splitstack_setcontext(&gp->m->gsignal->stackcontext[0]);\n \n-#ifdef SIGSEGV\n-    case SIGSEGV:\n-      runtime_panicstring (\"invalid memory address or \"\n-\t\t\t   \"nil pointer dereference\");\n-#endif\n+\tsigtrampgo(sig, info, context);\n \n-#ifdef SIGFPE\n-    case SIGFPE:\n-      runtime_panicstring (\"integer divide by zero or floating point error\");\n-#endif\n-    }\n+\t// We are going to return back to the signal trampoline and\n+\t// then to whatever we were doing before we got the signal.\n+\t// Restore the split stack context so that stack guards are\n+\t// checked correctly.\n \n-  /* All signals with _SigPanic should be in cases above, and this\n-     handler should only be invoked for those signals.  */\n-  __builtin_unreachable ();\n+\t__splitstack_setcontext(&stack_context[0]);\n }\n \n-#endif /* !defined (SA_SIGINFO) */\n-\n-/* A signal handler used for signals which are not going to panic.\n-   This is called on the alternate signal stack so it may not split\n-   the stack.  */\n-\n-static void\n-sig_tramp_info (int, Siginfo *, void *) __attribute__ ((no_split_stack));\n-\n-static void\n-sig_tramp_info (int sig, Siginfo *info, void *context)\n-{\n-  G *gp;\n-  M *mp;\n-#ifdef USING_SPLIT_STACK\n-  void *stack_context[10];\n-#endif\n-\n-  /* We are now running on the stack registered via sigaltstack.\n-     (Actually there is a small span of time between runtime_siginit\n-     and sigaltstack when the program starts.)  */\n-  gp = runtime_g ();\n-  mp = runtime_m ();\n-\n-  if (gp != NULL)\n-    {\n-#ifdef USING_SPLIT_STACK\n-      __splitstack_getcontext (&stack_context[0]);\n-#endif\n-    }\n-\n-  if (gp != NULL && mp->gsignal != NULL)\n-    {\n-      /* We are running on the signal stack.  Set the split stack\n-\t context so that the stack guards are checked correctly.  */\n-#ifdef USING_SPLIT_STACK\n-      __splitstack_setcontext (&mp->gsignal->stackcontext[0]);\n-#endif\n-    }\n-\n-  runtime_sighandler (sig, info, context, gp);\n+#endif // USING_SPLIT_STACK\n \n-  /* We are going to return back to the signal trampoline and then to\n-     whatever we were doing before we got the signal.  Restore the\n-     split stack context so that stack guards are checked\n-     correctly.  */\n+// C code to manage the sigaction sa_sigaction field, which is\n+// typically a union and so hard for mksysinfo.sh to handle.\n \n-  if (gp != NULL)\n-    {\n-#ifdef USING_SPLIT_STACK\n-      __splitstack_setcontext (&stack_context[0]);\n-#endif\n-    }\n-}\n-\n-#ifndef SA_SIGINFO\n+uintptr getSigactionHandler(struct sigaction*)\n+\t__attribute__ ((no_split_stack));\n \n-static void sig_tramp (int sig) __attribute__ ((no_split_stack));\n+uintptr getSigactionHandler(struct sigaction*)\n+\t__asm__ (GOSYM_PREFIX \"runtime.getSigactionHandler\");\n \n-static void\n-sig_tramp (int sig)\n+uintptr\n+getSigactionHandler(struct sigaction* sa)\n {\n-  sig_tramp_info (sig, NULL, NULL);\n+\treturn (uintptr)(sa->sa_sigaction);\n }\n \n-#endif\n+void setSigactionHandler(struct sigaction*, uintptr)\n+\t__attribute__ ((no_split_stack));\n+\n+void setSigactionHandler(struct sigaction*, uintptr)\n+\t__asm__ (GOSYM_PREFIX \"runtime.setSigactionHandler\");\n \n void\n-runtime_setsig (int32 i, GoSighandler *fn, bool restart)\n+setSigactionHandler(struct sigaction* sa, uintptr handler)\n {\n-  struct sigaction sa;\n-  int r;\n-  SigTab *t;\n-\n-  memset (&sa, 0, sizeof sa);\n-\n-  r = sigfillset (&sa.sa_mask);\n-  __go_assert (r == 0);\n-\n-  t = &runtime_sigtab[i];\n-\n-  if ((t->flags & _SigPanic) == 0)\n-    {\n-#ifdef SA_SIGINFO\n-      sa.sa_flags = SA_ONSTACK | SA_SIGINFO;\n-      if (fn == runtime_sighandler)\n-\tfn = (void *) sig_tramp_info;\n-      sa.sa_sigaction = (void *) fn;\n-#else\n-      sa.sa_flags = SA_ONSTACK;\n-      if (fn == runtime_sighandler)\n-\tfn = (void *) sig_tramp;\n-      sa.sa_handler = (void *) fn;\n-#endif\n-    }\n-  else\n-    {\n-#ifdef SA_SIGINFO\n-      sa.sa_flags = SA_SIGINFO;\n-      if (fn == runtime_sighandler)\n-\tfn = (void *) sig_panic_info_handler;\n-      sa.sa_sigaction = (void *) fn;\n-#else\n-      sa.sa_flags = 0;\n-      if (fn == runtime_sighandler)\n-\tfn = (void *) sig_panic_handler;\n-      sa.sa_handler = (void *) fn;\n-#endif\n-    }\n-\n-  if (restart)\n-    sa.sa_flags |= SA_RESTART;\n-\n-  if (sigaction (t->sig, &sa, NULL) != 0)\n-    __go_assert (0);\n+\tsa->sa_sigaction = (void*)(handler);\n }\n \n-GoSighandler*\n-runtime_getsig (int32 i)\n-{\n-  struct sigaction sa;\n-  int r;\n-  SigTab *t;\n-\n-  memset (&sa, 0, sizeof sa);\n-\n-  r = sigemptyset (&sa.sa_mask);\n-  __go_assert (r == 0);\n-\n-  t = &runtime_sigtab[i];\n-\n-  if (sigaction (t->sig, NULL, &sa) != 0)\n-    runtime_throw (\"sigaction read failure\");\n+// C code to fetch values from the siginfo_t and ucontext_t pointers\n+// passed to a signal handler.\n \n-  if ((void *) sa.sa_handler == sig_tramp_info)\n-    return runtime_sighandler;\n-#ifdef SA_SIGINFO\n-  if ((void *) sa.sa_handler == sig_panic_info_handler)\n-    return runtime_sighandler;\n-#else\n-  if ((void *) sa.sa_handler == sig_tramp\n-      || (void *) sa.sa_handler == sig_panic_handler)\n-    return runtime_sighandler;\n-#endif\n-\n-  return (void *) sa.sa_handler;\n-}\n-\n-/* Used by the os package to raise SIGPIPE.  */\n+struct getSiginfoRet {\n+\tuintptr sigaddr;\n+\tuintptr sigpc;\n+};\n \n-void os_sigpipe (void) __asm__ (GOSYM_PREFIX \"os.sigpipe\");\n+struct getSiginfoRet getSiginfo(siginfo_t *, void *)\n+\t__asm__(GOSYM_PREFIX \"runtime.getSiginfo\");\n \n-void\n-os_sigpipe (void)\n+struct getSiginfoRet\n+getSiginfo(siginfo_t *info, void *context __attribute__((unused)))\n {\n-  struct sigaction sa;\n-  int i;\n-\n-  if (__go_sigsend (SIGPIPE))\n-    return;\n-\n-  memset (&sa, 0, sizeof sa);\n-\n-  sa.sa_handler = SIG_DFL;\n+\tstruct getSiginfoRet ret;\n+\tLocation loc[1];\n+\tint32 n;\n+\n+\tret.sigaddr = (uintptr)(info->si_addr);\n+\tret.sigpc = 0;\n+\n+\t// There doesn't seem to be a portable way to get the PC.\n+\t// Use unportable code to pull it from context, and if that fails\n+\t// try a stack backtrace across the signal handler.\n+\n+#ifdef __x86_64__\n+ #ifdef __linux__\n+\tret.sigpc = ((ucontext_t*)(context))->uc_mcontext.gregs[REG_RIP];\n+ #endif\n+#endif\n+#ifdef __i386__\n+  #ifdef __linux__\n+\tret.sigpc = ((ucontext_t*)(context))->uc_mcontext.gregs[REG_EIP];\n+  #endif\n+#endif\n+\n+\tif (ret.sigpc == 0) {\n+\t\t// Skip getSiginfo/sighandler/sigtrampgo/sigtramp/handler.\n+\t\tn = runtime_callers(5, &loc[0], 1, false);\n+\t\tif (n > 0) {\n+\t\t\tret.sigpc = loc[0].pc;\n+\t\t}\n+\t}\n \n-  i = sigemptyset (&sa.sa_mask);\n-  __go_assert (i == 0);\n+\treturn ret;\n+}\n \n-  if (sigaction (SIGPIPE, &sa, NULL) != 0)\n-    abort ();\n+// Dump registers when crashing in a signal.\n+// There is no portable way to write this,\n+// so we just have some CPU/OS specific implementations.\n \n-  raise (SIGPIPE);\n-}\n+void dumpregs(siginfo_t *, void *)\n+\t__asm__(GOSYM_PREFIX \"runtime.dumpregs\");\n \n void\n-runtime_setprof(bool on)\n+dumpregs(siginfo_t *info __attribute__((unused)), void *context __attribute__((unused)))\n {\n-\tUSED(on);\n+#ifdef __x86_64__\n+ #ifdef __linux__\n+\t{\n+\t\tmcontext_t *m = &((ucontext_t*)(context))->uc_mcontext;\n+\n+\t\truntime_printf(\"rax    %X\\n\", m->gregs[REG_RAX]);\n+\t\truntime_printf(\"rbx    %X\\n\", m->gregs[REG_RBX]);\n+\t\truntime_printf(\"rcx    %X\\n\", m->gregs[REG_RCX]);\n+\t\truntime_printf(\"rdx    %X\\n\", m->gregs[REG_RDX]);\n+\t\truntime_printf(\"rdi    %X\\n\", m->gregs[REG_RDI]);\n+\t\truntime_printf(\"rsi    %X\\n\", m->gregs[REG_RSI]);\n+\t\truntime_printf(\"rbp    %X\\n\", m->gregs[REG_RBP]);\n+\t\truntime_printf(\"rsp    %X\\n\", m->gregs[REG_RSP]);\n+\t\truntime_printf(\"r8     %X\\n\", m->gregs[REG_R8]);\n+\t\truntime_printf(\"r9     %X\\n\", m->gregs[REG_R9]);\n+\t\truntime_printf(\"r10    %X\\n\", m->gregs[REG_R10]);\n+\t\truntime_printf(\"r11    %X\\n\", m->gregs[REG_R11]);\n+\t\truntime_printf(\"r12    %X\\n\", m->gregs[REG_R12]);\n+\t\truntime_printf(\"r13    %X\\n\", m->gregs[REG_R13]);\n+\t\truntime_printf(\"r14    %X\\n\", m->gregs[REG_R14]);\n+\t\truntime_printf(\"r15    %X\\n\", m->gregs[REG_R15]);\n+\t\truntime_printf(\"rip    %X\\n\", m->gregs[REG_RIP]);\n+\t\truntime_printf(\"rflags %X\\n\", m->gregs[REG_EFL]);\n+\t\truntime_printf(\"cs     %X\\n\", m->gregs[REG_CSGSFS] & 0xffff);\n+\t\truntime_printf(\"fs     %X\\n\", (m->gregs[REG_CSGSFS] >> 16) & 0xffff);\n+\t\truntime_printf(\"gs     %X\\n\", (m->gregs[REG_CSGSFS] >> 32) & 0xffff);\n+\t  }\n+ #endif\n+#endif\n+\n+#ifdef __i386__\n+ #ifdef __linux__\n+\t{\n+\t\tmcontext_t *m = &((ucontext_t*)(context))->uc_mcontext;\n+\n+\t\truntime_printf(\"eax    %X\\n\", m->gregs[REG_EAX]);\n+\t\truntime_printf(\"ebx    %X\\n\", m->gregs[REG_EBX]);\n+\t\truntime_printf(\"ecx    %X\\n\", m->gregs[REG_ECX]);\n+\t\truntime_printf(\"edx    %X\\n\", m->gregs[REG_EDX]);\n+\t\truntime_printf(\"edi    %X\\n\", m->gregs[REG_EDI]);\n+\t\truntime_printf(\"esi    %X\\n\", m->gregs[REG_ESI]);\n+\t\truntime_printf(\"ebp    %X\\n\", m->gregs[REG_EBP]);\n+\t\truntime_printf(\"esp    %X\\n\", m->gregs[REG_ESP]);\n+\t\truntime_printf(\"eip    %X\\n\", m->gregs[REG_EIP]);\n+\t\truntime_printf(\"eflags %X\\n\", m->gregs[REG_EFL]);\n+\t\truntime_printf(\"cs     %X\\n\", m->gregs[REG_CS]);\n+\t\truntime_printf(\"fs     %X\\n\", m->gregs[REG_FS]);\n+\t\truntime_printf(\"gs     %X\\n\", m->gregs[REG_GS]);\n+\t  }\n+ #endif\n+#endif\n }"}, {"sha": "78c8f5d4b5b2fe90d0ca678872ccbb686bab78b6", "filename": "libgo/runtime/panic.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fpanic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fpanic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fpanic.c?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -122,9 +122,13 @@ runtime_dopanic(int32 unused __attribute__ ((unused)))\n \tint32 t;\n \n \tg = runtime_g();\n-\tif(g->sig != 0)\n-\t\truntime_printf(\"[signal %x code=%p addr=%p]\\n\",\n+\tif(g->sig != 0) {\n+\t\truntime_printf(\"[signal %x code=%p addr=%p\",\n \t\t\t       g->sig, (void*)g->sigcode0, (void*)g->sigcode1);\n+\t\tif (g->sigpc != 0)\n+\t\t\truntime_printf(\" pc=%p\", g->sigpc);\n+\t\truntime_printf(\"]\\n\");\n+\t}\n \n \tif((t = runtime_gotraceback(&crash)) > 0){\n \t\tif(g != runtime_m()->g0) {"}, {"sha": "62abc9d238ba88697b97d7f052a693d777c63aea", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -2022,7 +2022,8 @@ goexit0(G *gp)\n // entersyscall is going to return immediately after.\n \n void runtime_entersyscall(int32) __attribute__ ((no_split_stack));\n-static void doentersyscall(void) __attribute__ ((no_split_stack, noinline));\n+static void doentersyscall(uintptr, uintptr)\n+  __attribute__ ((no_split_stack, noinline));\n \n void\n runtime_entersyscall(int32 dummy __attribute__ ((unused)))\n@@ -2040,11 +2041,12 @@ runtime_entersyscall(int32 dummy __attribute__ ((unused)))\n \t// callee-saved registers to access the TLS variable g.  We\n \t// don't want to put the ucontext_t on the stack because it is\n \t// large and we can not split the stack here.\n-\tdoentersyscall();\n+\tdoentersyscall((uintptr)runtime_getcallerpc(&dummy),\n+\t\t       (uintptr)runtime_getcallersp(&dummy));\n }\n \n static void\n-doentersyscall()\n+doentersyscall(uintptr pc, uintptr sp)\n {\n \t// Disable preemption because during this function g is in _Gsyscall status,\n \t// but can have inconsistent g->sched, do not let GC observe it.\n@@ -2067,6 +2069,9 @@ doentersyscall()\n \t}\n #endif\n \n+\tg->syscallsp = sp;\n+\tg->syscallpc = pc;\n+\n \tg->atomicstatus = _Gsyscall;\n \n \tif(runtime_atomicload(&runtime_sched.sysmonwait)) {  // TODO: fast atomic\n@@ -2118,6 +2123,9 @@ runtime_entersyscallblock(int32 dummy __attribute__ ((unused)))\n \t// held in registers will be seen by the garbage collector.\n \tgetcontext(ucontext_arg(&g->gcregs[0]));\n \n+\tg->syscallpc = (uintptr)runtime_getcallerpc(&dummy);\n+\tg->syscallsp = (uintptr)runtime_getcallersp(&dummy);\n+\n \tg->atomicstatus = _Gsyscall;\n \n \tp = releasep();\n@@ -2155,6 +2163,7 @@ runtime_exitsyscall(int32 dummy __attribute__ ((unused)))\n #endif\n \t\tgp->gcnextsp = nil;\n \t\truntime_memclr(&gp->gcregs[0], sizeof gp->gcregs);\n+\t\tgp->syscallsp = 0;\n \t\tgp->m->locks--;\n \t\treturn;\n \t}\n@@ -2176,6 +2185,8 @@ runtime_exitsyscall(int32 dummy __attribute__ ((unused)))\n \tgp->gcnextsp = nil;\n \truntime_memclr(&gp->gcregs[0], sizeof gp->gcregs);\n \n+\tgp->syscallsp = 0;\n+\n \t// Note that this gp->m might be different than the earlier\n \t// gp->m after returning from runtime_mcall.\n \t((P*)gp->m->p)->syscalltick++;"}, {"sha": "7d22631bddc802fc7943d9e64045fab463675e1a", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -282,10 +282,8 @@ void*\truntime_mal(uintptr);\n String\truntime_gostringnocopy(const byte*)\n   __asm__ (GOSYM_PREFIX \"runtime.gostringnocopy\");\n void\truntime_schedinit(void);\n-void\truntime_initsig(bool);\n-void\truntime_sigenable(uint32 sig);\n-void\truntime_sigdisable(uint32 sig);\n-void\truntime_sigignore(uint32 sig);\n+void\truntime_initsig(bool)\n+  __asm__ (GOSYM_PREFIX \"runtime.initsig\");\n int32\truntime_gotraceback(bool *crash);\n void\truntime_goroutineheader(G*)\n   __asm__ (GOSYM_PREFIX \"runtime.goroutineheader\");\n@@ -303,17 +301,20 @@ G*\truntime_malg(int32, byte**, uintptr*);\n void\truntime_mpreinit(M*);\n void\truntime_minit(void);\n void\truntime_unminit(void);\n-void\truntime_needm(void);\n-void\truntime_dropm(void);\n+void\truntime_needm(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.needm\");\n+void\truntime_dropm(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.dropm\");\n void\truntime_signalstack(byte*, int32);\n MCache*\truntime_allocmcache(void);\n void\truntime_freemcache(MCache*);\n void\truntime_mallocinit(void);\n void\truntime_mprofinit(void);\n #define runtime_malloc(s) __go_alloc(s)\n #define runtime_free(p) __go_free(p)\n-#define runtime_getcallersp(p) __builtin_frame_address(1)\n-int32\truntime_mcount(void);\n+#define runtime_getcallersp(p) __builtin_frame_address(0)\n+int32\truntime_mcount(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.mcount\");\n int32\truntime_gcount(void);\n void\truntime_mcall(void(*)(G*));\n uint32\truntime_fastrand1(void) __asm__ (GOSYM_PREFIX \"runtime.fastrand1\");\n@@ -339,7 +340,8 @@ int32\truntime_round2(int32 x); // round x up to a power of 2.\n #define runtime_atomicloadp(p) __atomic_load_n (p, __ATOMIC_SEQ_CST)\n #define runtime_atomicstorep(p, v) __atomic_store_n (p, v, __ATOMIC_SEQ_CST)\n \n-void runtime_setg(G*);\n+void runtime_setg(G*)\n+  __asm__ (GOSYM_PREFIX \"runtime.setg\");\n void runtime_newextram(void);\n #define runtime_exit(s) exit(s)\n #define runtime_breakpoint() __builtin_trap()\n@@ -358,19 +360,20 @@ void\truntime_entersyscallblock(int32)\n void\truntime_exitsyscall(int32)\n   __asm__ (GOSYM_PREFIX \"runtime.exitsyscall\");\n G*\t__go_go(void (*pfn)(void*), void*);\n-void\tsiginit(void);\n-bool\t__go_sigsend(int32 sig);\n int32\truntime_callers(int32, Location*, int32, bool keep_callers);\n int64\truntime_nanotime(void)\t// monotonic time\n   __asm__(GOSYM_PREFIX \"runtime.nanotime\");\n int64\truntime_unixnanotime(void) // real time, can skip\n   __asm__ (GOSYM_PREFIX \"runtime.unixnanotime\");\n void\truntime_dopanic(int32) __attribute__ ((noreturn));\n-void\truntime_startpanic(void);\n+void\truntime_startpanic(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.startpanic\");\n void\truntime_freezetheworld(void);\n void\truntime_unwindstack(G*, byte*);\n-void\truntime_sigprof();\n-void\truntime_resetcpuprofiler(int32);\n+void\truntime_sigprof()\n+  __asm__ (GOSYM_PREFIX \"runtime.sigprof\");\n+void\truntime_resetcpuprofiler(int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.resetcpuprofiler\");\n void\truntime_setcpuprofilerate_m(int32)\n      __asm__ (GOSYM_PREFIX \"runtime.setcpuprofilerate_m\");\n void\truntime_cpuprofAdd(Slice)\n@@ -385,7 +388,8 @@ void\truntime_blockevent(int64, int32);\n extern int64 runtime_blockprofilerate;\n G*\truntime_netpoll(bool)\n   __asm__ (GOSYM_PREFIX \"runtime.netpoll\");\n-void\truntime_crash(void);\n+void\truntime_crash(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.crash\");\n void\truntime_parsedebugvars(void)\n   __asm__(GOSYM_PREFIX \"runtime.parsedebugvars\");\n void\t_rt0_go(void);"}, {"sha": "2cca08cf47bed7fed9335b531d8a595f93f1683e", "filename": "libgo/runtime/signal_unix.c", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071af74db674f3dc462ab8a25e091b74830fda2d/libgo%2Fruntime%2Fsignal_unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071af74db674f3dc462ab8a25e091b74830fda2d/libgo%2Fruntime%2Fsignal_unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsignal_unix.c?ref=071af74db674f3dc462ab8a25e091b74830fda2d", "patch": "@@ -1,176 +0,0 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n-\n-#include <sys/time.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-#include \"signal_unix.h\"\n-\n-extern SigTab runtime_sigtab[];\n-\n-void\n-runtime_initsig(bool preinit)\n-{\n-\tint32 i;\n-\tSigTab *t;\n-\n-\t// For c-archive/c-shared this is called by go-libmain.c with\n-\t// preinit == true.\n-\tif(runtime_isarchive && !preinit)\n-\t\treturn;\n-\n-\t// First call: basic setup.\n-\tfor(i = 0; runtime_sigtab[i].sig != -1; i++) {\n-\t\tt = &runtime_sigtab[i];\n-\t\tif((t->flags == 0) || (t->flags & _SigDefault))\n-\t\t\tcontinue;\n-\n-\t\tt->fwdsig = runtime_getsig(i);\n-\n-\t\t// For some signals, we respect an inherited SIG_IGN handler\n-\t\t// rather than insist on installing our own default handler.\n-\t\t// Even these signals can be fetched using the os/signal package.\n-\t\tswitch(t->sig) {\n-\t\tcase SIGHUP:\n-\t\tcase SIGINT:\n-\t\t\tif(t->fwdsig == GO_SIG_IGN) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif(runtime_isarchive && (t->flags&_SigPanic) == 0)\n-\t\t\tcontinue;\n-\n-\t\tt->flags |= _SigHandling;\n-\t\truntime_setsig(i, runtime_sighandler, true);\n-\t}\n-}\n-\n-void\n-runtime_sigenable(uint32 sig)\n-{\n-\tint32 i;\n-\tSigTab *t;\n-\n-\tt = nil;\n-\tfor(i = 0; runtime_sigtab[i].sig != -1; i++) {\n-\t\tif(runtime_sigtab[i].sig == (int32)sig) {\n-\t\t\tt = &runtime_sigtab[i];\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\tif(t == nil)\n-\t\treturn;\n-\n-\tif((t->flags & _SigNotify) && !(t->flags & _SigHandling)) {\n-\t\tt->flags |= _SigHandling;\n-\t\tt->fwdsig = runtime_getsig(i);\n-\t\truntime_setsig(i, runtime_sighandler, true);\n-\t}\n-}\n-\n-void\n-runtime_sigdisable(uint32 sig)\n-{\n-\tint32 i;\n-\tSigTab *t;\n-\n-\tt = nil;\n-\tfor(i = 0; runtime_sigtab[i].sig != -1; i++) {\n-\t\tif(runtime_sigtab[i].sig == (int32)sig) {\n-\t\t\tt = &runtime_sigtab[i];\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\tif(t == nil)\n-\t\treturn;\n-\n-\tif((sig == SIGHUP || sig == SIGINT) && t->fwdsig == GO_SIG_IGN) {\n-\t\tt->flags &= ~_SigHandling;\n-\t\truntime_setsig(i, t->fwdsig, true);\n-\t}\n-}\n-\n-void\n-runtime_sigignore(uint32 sig)\n-{\n-\tint32 i;\n-\tSigTab *t;\n-\n-\tt = nil;\n-\tfor(i = 0; runtime_sigtab[i].sig != -1; i++) {\n-\t\tif(runtime_sigtab[i].sig == (int32)sig) {\n-\t\t\tt = &runtime_sigtab[i];\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\tif(t == nil)\n-\t\treturn;\n-\n-\tif((t->flags & _SigNotify) != 0) {\n-\t\tt->flags &= ~_SigHandling;\n-\t\truntime_setsig(i, GO_SIG_IGN, true);\n-\t}\n-}\n-\n-void\n-runtime_resetcpuprofiler(int32 hz)\n-{\n-\tstruct itimerval it;\n-\n-\truntime_memclr((byte*)&it, sizeof it);\n-\tif(hz == 0) {\n-\t\truntime_setitimer(ITIMER_PROF, &it, nil);\n-\t} else {\n-\t\tit.it_interval.tv_sec = 0;\n-\t\tit.it_interval.tv_usec = 1000000 / hz;\n-\t\tit.it_value = it.it_interval;\n-\t\truntime_setitimer(ITIMER_PROF, &it, nil);\n-\t}\n-\truntime_m()->profilehz = hz;\n-}\n-\n-void\n-runtime_unblocksignals(void)\n-{\n-\tsigset_t sigset_none;\n-\tsigemptyset(&sigset_none);\n-\tpthread_sigmask(SIG_SETMASK, &sigset_none, nil);\n-}\n-\n-void\n-runtime_crash(void)\n-{\n-\tint32 i;\n-\n-#ifdef GOOS_darwin\n-\t// OS X core dumps are linear dumps of the mapped memory,\n-\t// from the first virtual byte to the last, with zeros in the gaps.\n-\t// Because of the way we arrange the address space on 64-bit systems,\n-\t// this means the OS X core file will be >128 GB and even on a zippy\n-\t// workstation can take OS X well over an hour to write (uninterruptible).\n-\t// Save users from making that mistake.\n-\tif(sizeof(void*) == 8)\n-\t\treturn;\n-#endif\n-\n-\truntime_unblocksignals();\n-\tfor(i = 0; runtime_sigtab[i].sig != -1; i++)\n-\t\tif(runtime_sigtab[i].sig == SIGABRT)\n-\t\t\tbreak;\n-\truntime_setsig(i, GO_SIG_DFL, false);\n-\truntime_raise(SIGABRT);\n-}\n-\n-void\n-runtime_raise(int32 sig)\n-{\n-\traise(sig);\n-}"}, {"sha": "1c51740bf1dd132400d1c06ac64777518c177173", "filename": "libgo/runtime/signal_unix.h", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071af74db674f3dc462ab8a25e091b74830fda2d/libgo%2Fruntime%2Fsignal_unix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071af74db674f3dc462ab8a25e091b74830fda2d/libgo%2Fruntime%2Fsignal_unix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsignal_unix.h?ref=071af74db674f3dc462ab8a25e091b74830fda2d", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <signal.h>\n-\n-#define GO_SIG_DFL ((void*)SIG_DFL)\n-#define GO_SIG_IGN ((void*)SIG_IGN)\n-\n-#ifdef SA_SIGINFO\n-typedef siginfo_t Siginfo;\n-#else\n-typedef void *Siginfo;\n-#endif\n-\n-typedef void GoSighandler(int32, Siginfo*, void*, G*);\n-void\truntime_setsig(int32, GoSighandler*, bool);\n-GoSighandler* runtime_getsig(int32);\n-\n-void\truntime_sighandler(int32 sig, Siginfo *info, void *context, G *gp);\n-void\truntime_raise(int32);\n-"}, {"sha": "fba1c71e2cd84ce097c16c276b65c1ff787b116a", "filename": "libgo/runtime/sigqueue.goc", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071af74db674f3dc462ab8a25e091b74830fda2d/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071af74db674f3dc462ab8a25e091b74830fda2d/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=071af74db674f3dc462ab8a25e091b74830fda2d", "patch": "@@ -1,172 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements runtime support for signal handling.\n-//\n-// Most synchronization primitives are not available from\n-// the signal handler (it cannot block, allocate memory, or use locks)\n-// so the handler communicates with a processing goroutine\n-// via struct sig, below.\n-//\n-// sigsend() is called by the signal handler to queue a new signal.\n-// signal_recv() is called by the Go program to receive a newly queued signal.\n-// Synchronization between sigsend() and signal_recv() is based on the sig.state\n-// variable.  It can be in 3 states: 0, HASWAITER and HASSIGNAL.\n-// HASWAITER means that signal_recv() is blocked on sig.Note and there are no\n-// new pending signals.\n-// HASSIGNAL means that sig.mask *may* contain new pending signals,\n-// signal_recv() can't be blocked in this state.\n-// 0 means that there are no new pending signals and signal_recv() is not blocked.\n-// Transitions between states are done atomically with CAS.\n-// When signal_recv() is unblocked, it resets sig.Note and rechecks sig.mask.\n-// If several sigsend()'s and signal_recv() execute concurrently, it can lead to\n-// unnecessary rechecks of sig.mask, but must not lead to missed signals\n-// nor deadlocks.\n-\n-package signal\n-#include \"config.h\"\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-#include \"defs.h\"\n-\n-static struct {\n-\tNote;\n-\tuint32 mask[(NSIG+31)/32];\n-\tuint32 wanted[(NSIG+31)/32];\n-\tuint32 state;\n-\tbool inuse;\n-} sig;\n-\n-enum {\n-\tHASWAITER = 1,\n-\tHASSIGNAL = 2,\n-};\n-\n-// Called from sighandler to send a signal back out of the signal handling thread.\n-bool\n-__go_sigsend(int32 s)\n-{\n-\tuint32 bit, mask, old, new;\n-\n-\tif(!sig.inuse || s < 0 || (size_t)s >= 32*nelem(sig.wanted) || !(sig.wanted[s/32]&(1U<<(s&31))))\n-\t\treturn false;\n-\tbit = 1 << (s&31);\n-\tfor(;;) {\n-\t\tmask = sig.mask[s/32];\n-\t\tif(mask & bit)\n-\t\t\tbreak;\t\t// signal already in queue\n-\t\tif(runtime_cas(&sig.mask[s/32], mask, mask|bit)) {\n-\t\t\t// Added to queue.\n-\t\t\t// Only send a wakeup if the receiver needs a kick.\n-\t\t\tfor(;;) {\n-\t\t\t\told = runtime_atomicload(&sig.state);\n-\t\t\t\tif(old == HASSIGNAL)\n-\t\t\t\t\tbreak;\n-\t\t\t\tif(old == HASWAITER)\n-\t\t\t\t\tnew = 0;\n-\t\t\t\telse  // if(old == 0)\n-\t\t\t\t\tnew = HASSIGNAL;\n-\t\t\t\tif(runtime_cas(&sig.state, old, new)) {\n-\t\t\t\t\tif (old == HASWAITER)\n-\t\t\t\t\t\truntime_notewakeup(&sig);\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\treturn true;\n-}\n-\n-// Called to receive the next queued signal.\n-// Must only be called from a single goroutine at a time.\n-func signal_recv() (m uint32) {\n-\tstatic uint32 recv[nelem(sig.mask)];\n-\tuint32 i, old, new;\n-\t\n-\tfor(;;) {\n-\t\t// Serve from local copy if there are bits left.\n-\t\tfor(i=0; i<NSIG; i++) {\n-\t\t\tif(recv[i/32]&(1U<<(i&31))) {\n-\t\t\t\trecv[i/32] ^= 1U<<(i&31);\n-\t\t\t\tm = i;\n-\t\t\t\tgoto done;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Check and update sig.state.\n-\t\tfor(;;) {\n-\t\t\told = runtime_atomicload(&sig.state);\n-\t\t\tif(old == HASWAITER)\n-\t\t\t\truntime_throw(\"inconsistent state in signal_recv\");\n-\t\t\tif(old == HASSIGNAL)\n-\t\t\t\tnew = 0;\n-\t\t\telse  // if(old == 0)\n-\t\t\t\tnew = HASWAITER;\n-\t\t\tif(runtime_cas(&sig.state, old, new)) {\n-\t\t\t\tif (new == HASWAITER) {\n-\t\t\t\t\truntime_notetsleepg(&sig, -1);\n-\t\t\t\t\truntime_noteclear(&sig);\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Get a new local copy.\n-\t\tfor(i=0; (size_t)i<nelem(sig.mask); i++) {\n-\t\t\tfor(;;) {\n-\t\t\t\tm = sig.mask[i];\n-\t\t\t\tif(runtime_cas(&sig.mask[i], m, 0))\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\trecv[i] = m;\n-\t\t}\n-\t}\n-\n-done:;\n-\t// goc requires that we fall off the end of functions\n-\t// that return values instead of using our own return\n-\t// statements.\n-}\n-\n-// Must only be called from a single goroutine at a time.\n-func signal_enable(s uint32) {\n-\tif(!sig.inuse) {\n-\t\t// The first call to signal_enable is for us\n-\t\t// to use for initialization.  It does not pass\n-\t\t// signal information in m.\n-\t\tsig.inuse = true;\t// enable reception of signals; cannot disable\n-\t\truntime_noteclear(&sig);\n-\t\treturn;\n-\t}\n-\t\n-\tif(s >= nelem(sig.wanted)*32)\n-\t\treturn;\n-\tsig.wanted[s/32] |= 1U<<(s&31);\n-\truntime_sigenable(s);\n-}\n-\n-// Must only be called from a single goroutine at a time.\n-func signal_disable(s uint32) {\n-\tif(s >= nelem(sig.wanted)*32)\n-\t\treturn;\n-\tsig.wanted[s/32] &= ~(1U<<(s&31));\n-\truntime_sigdisable(s);\n-}\n-\n-// Must only be called from a single goroutine at a time.\n-func signal_ignore(s uint32) {\n-\tif (s >= nelem(sig.wanted)*32)\n-\t\treturn;\n-\tsig.wanted[s/32] &= ~(1U<<(s&31));\n-\truntime_sigignore(s);\n-}\n-\n-// This runs on a foreign stack, without an m or a g.  No stack split.\n-void\n-runtime_badsignal(int sig)\n-{\n-\t__go_sigsend(sig);\n-}"}, {"sha": "81ad0f9c9026024b7c5f21fb4c127976d54c109e", "filename": "libgo/runtime/thread-linux.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fthread-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fthread-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-linux.c?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -4,7 +4,6 @@\n \n #include \"runtime.h\"\n #include \"defs.h\"\n-#include \"signal_unix.h\"\n \n // Linux futex.\n "}, {"sha": "d0aed8d22ed432c0471430d9995c5954244165ad", "filename": "libgo/runtime/yield.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fyield.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f9a0a4b7a193707ffa5e8ef698a223561b804/libgo%2Fruntime%2Fyield.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fyield.c?ref=980f9a0a4b7a193707ffa5e8ef698a223561b804", "patch": "@@ -37,6 +37,9 @@ runtime_procyield (uint32 cnt)\n \n /* Ask the OS to reschedule this thread.  */\n \n+void runtime_osyield(void)\n+  __attribute__ ((no_split_stack));\n+\n void\n runtime_osyield (void)\n {"}]}