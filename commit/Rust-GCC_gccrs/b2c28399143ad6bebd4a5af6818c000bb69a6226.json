{"sha": "b2c28399143ad6bebd4a5af6818c000bb69a6226", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJjMjgzOTkxNDNhZDZiZWJkNGE1YWY2ODE4YzAwMGJiNjlhNjIyNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T07:52:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T07:52:49Z"}, "message": "[multiple changes]\n\n2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Create_Alternative): Removed.\n\t(Expand_N_If_Expression): Remove constant\n\tIn_Case_Or_If_Expression. Add local variable\n\tPtr_Typ. Inspect the \"then\" and \"else\" action lists\n\tfor transient controlled objects and generate code to\n\tfinalize them.\t(Is_Controlled_Function_Call): Removed.\n\t(Process_Action): Update the comment on usage. Update the call\n\tto Process_Transient_Object. There is no need to continue the\n\ttraversal of the object itself.\n\t(Process_Actions): New routine.\n\t(Process_Transient_Object): Moved to the top level of Exp_Ch4. Add\n\ta new formal and update the related comment on usage.\n\t* exp_util.adb (Within_Case_Or_If_Expression): Start the search\n\tfrom the parent of the node.\n\n2013-07-08  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cusyqu.ads, a-cbprqu.ads, s-interr.ads, a-cuprqu.ads,\n\ta-cbsyqu.ads: Minor reformatting (proper formatting of overriding).\n\nFrom-SVN: r200759", "tree": {"sha": "770aa0e2ec3731ba1eb6873e8e21ae8095a96301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/770aa0e2ec3731ba1eb6873e8e21ae8095a96301"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2c28399143ad6bebd4a5af6818c000bb69a6226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c28399143ad6bebd4a5af6818c000bb69a6226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c28399143ad6bebd4a5af6818c000bb69a6226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c28399143ad6bebd4a5af6818c000bb69a6226/comments", "author": null, "committer": null, "parents": [{"sha": "a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a530b8bb19dfadc48d8848259a8f91580ef0c9b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a530b8bb19dfadc48d8848259a8f91580ef0c9b3"}], "stats": {"total": 902, "additions": 435, "deletions": 467}, "files": [{"sha": "8d8c993ffbdb3321fa587c220dd2f98aecf4af80", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -1,3 +1,25 @@\n+2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Create_Alternative): Removed.\n+\t(Expand_N_If_Expression): Remove constant\n+\tIn_Case_Or_If_Expression. Add local variable\n+\tPtr_Typ. Inspect the \"then\" and \"else\" action lists\n+\tfor transient controlled objects and generate code to\n+\tfinalize them.\t(Is_Controlled_Function_Call): Removed.\n+\t(Process_Action): Update the comment on usage. Update the call\n+\tto Process_Transient_Object. There is no need to continue the\n+\ttraversal of the object itself.\n+\t(Process_Actions): New routine.\n+\t(Process_Transient_Object): Moved to the top level of Exp_Ch4. Add\n+\ta new formal and update the related comment on usage.\n+\t* exp_util.adb (Within_Case_Or_If_Expression): Start the search\n+\tfrom the parent of the node.\n+\n+2013-07-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cusyqu.ads, a-cbprqu.ads, s-interr.ads, a-cuprqu.ads,\n+\ta-cbsyqu.ads: Minor reformatting (proper formatting of overriding).\n+\n 2013-07-08  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch8.adb (Attribute_Renaming): Treat 'Img as an attribute"}, {"sha": "fb44d02c1dd1b477d1872af5977c5ffd00f8f103", "filename": "gcc/ada/a-cbprqu.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cbprqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cbprqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbprqu.ads?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -101,13 +101,13 @@ package Ada.Containers.Bounded_Priority_Queues is\n    protected type Queue\n      (Capacity : Count_Type := Default_Capacity;\n       Ceiling  : System.Any_Priority := Default_Ceiling)\n-     with Priority => Ceiling is new Queue_Interfaces.Queue with\n+   with\n+     Priority => Ceiling\n+   is new Queue_Interfaces.Queue with\n \n-      overriding\n-      entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+      overriding entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n \n-      overriding\n-      entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+      overriding entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n \n       --  The priority queue operation Dequeue_Only_High_Priority had been a\n       --  protected entry in early drafts of AI05-0159, but it was discovered\n@@ -116,22 +116,17 @@ package Ada.Containers.Bounded_Priority_Queues is\n       --  ARG meeting in Edinburgh (June 2011), with a different signature and\n       --  semantics.\n \n-      not overriding\n       procedure Dequeue_Only_High_Priority\n         (At_Least : Queue_Priority;\n          Element  : in out Queue_Interfaces.Element_Type;\n          Success  : out Boolean);\n \n-      overriding\n-      function Current_Use return Count_Type;\n+      overriding function Current_Use return Count_Type;\n \n-      overriding\n-      function Peak_Use return Count_Type;\n+      overriding function Peak_Use return Count_Type;\n \n    private\n-\n       List : Implementation.List_Type (Capacity);\n-\n    end Queue;\n \n end Ada.Containers.Bounded_Priority_Queues;"}, {"sha": "908463906ce678a96a1a2f0d8884ea5ef60c1e16", "filename": "gcc/ada/a-cbsyqu.ads", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cbsyqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cbsyqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbsyqu.ads?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -83,24 +83,20 @@ package Ada.Containers.Bounded_Synchronized_Queues is\n    protected type Queue\n      (Capacity : Count_Type := Default_Capacity;\n       Ceiling  : System.Any_Priority := Default_Ceiling)\n-     with Priority => Ceiling is new Queue_Interfaces.Queue with\n+   with\n+     Priority => Ceiling\n+   is new Queue_Interfaces.Queue with\n \n-      overriding\n-      entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+      overriding entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n \n-      overriding\n-      entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+      overriding entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n \n-      overriding\n-      function Current_Use return Count_Type;\n+      overriding function Current_Use return Count_Type;\n \n-      overriding\n-      function Peak_Use return Count_Type;\n+      overriding function Peak_Use return Count_Type;\n \n    private\n-\n       List : Implementation.List_Type (Capacity);\n-\n    end Queue;\n \n end Ada.Containers.Bounded_Synchronized_Queues;"}, {"sha": "4e11d6eef057c75180502f32240d02934b7827b2", "filename": "gcc/ada/a-cuprqu.ads", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cuprqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cuprqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.ads?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -94,19 +94,18 @@ package Ada.Containers.Unbounded_Priority_Queues is\n          Max_Length  : Count_Type := 0;\n       end record;\n \n-      overriding\n-      procedure Finalize (List : in out List_Type);\n+      overriding procedure Finalize (List : in out List_Type);\n \n    end Implementation;\n \n    protected type Queue (Ceiling : System.Any_Priority := Default_Ceiling)\n-     with Priority => Ceiling is new Queue_Interfaces.Queue with\n+   with\n+     Priority => Ceiling\n+   is new Queue_Interfaces.Queue with\n \n-      overriding\n-      entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+      overriding entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n \n-      overriding\n-      entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+      overriding entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n \n       --  The priority queue operation Dequeue_Only_High_Priority had been a\n       --  protected entry in early drafts of AI05-0159, but it was discovered\n@@ -115,22 +114,17 @@ package Ada.Containers.Unbounded_Priority_Queues is\n       --  ARG meeting in Edinburgh (June 2011), with a different signature and\n       --  semantics.\n \n-      not overriding\n       procedure Dequeue_Only_High_Priority\n         (At_Least : Queue_Priority;\n          Element  : in out Queue_Interfaces.Element_Type;\n          Success  : out Boolean);\n \n-      overriding\n-      function Current_Use return Count_Type;\n+      overriding function Current_Use return Count_Type;\n \n-      overriding\n-      function Peak_Use return Count_Type;\n+      overriding function Peak_Use return Count_Type;\n \n    private\n-\n       List : Implementation.List_Type;\n-\n    end Queue;\n \n end Ada.Containers.Unbounded_Priority_Queues;"}, {"sha": "c4f18020356696406db331f7d80e2a443080900e", "filename": "gcc/ada/a-cusyqu.ads", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cusyqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fa-cusyqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cusyqu.ads?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -80,30 +80,26 @@ package Ada.Containers.Unbounded_Synchronized_Queues is\n          Max_Length  : Count_Type := 0;\n       end record;\n \n-      overriding\n-      procedure Finalize (List : in out List_Type);\n+      overriding procedure Finalize (List : in out List_Type);\n \n    end Implementation;\n \n-   protected type Queue (Ceiling : System.Any_Priority := Default_Ceiling)\n-     with Priority => Ceiling is new Queue_Interfaces.Queue with\n+   protected type Queue\n+     (Ceiling : System.Any_Priority := Default_Ceiling)\n+   with\n+     Priority => Ceiling\n+   is new Queue_Interfaces.Queue with\n \n-      overriding\n-      entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+      overriding entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n \n-      overriding\n-      entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+      overriding entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n \n-      overriding\n-      function Current_Use return Count_Type;\n+      overriding function Current_Use return Count_Type;\n \n-      overriding\n-      function Peak_Use return Count_Type;\n+      overriding function Peak_Use return Count_Type;\n \n    private\n-\n       List : Implementation.List_Type;\n-\n    end Queue;\n \n end Ada.Containers.Unbounded_Synchronized_Queues;"}, {"sha": "26c517678f5de21c8d0ea3499f7f53ab494b58d4", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 371, "deletions": 405, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -233,6 +233,16 @@ package body Exp_Ch4 is\n    --  simple entity, and op is a comparison operator, optimizes it into a\n    --  comparison of First and Last.\n \n+   procedure Process_Transient_Object\n+     (Decl     : Node_Id;\n+      Rel_Node : Node_Id);\n+   --  Subsidiary routine to the expansion of expression_with_actions and if\n+   --  expressions. Generate all the necessary code to finalize a transient\n+   --  controlled object when the enclosing context is elaborated or evaluated.\n+   --  Decl denotes the declaration of the transient controlled object which is\n+   --  usually the result of a controlled function call. Rel_Node denotes the\n+   --  context, either an expression_with_actions or an if expression.\n+\n    procedure Rewrite_Comparison (N : Node_Id);\n    --  If N is the node for a comparison whose outcome can be determined at\n    --  compile time, then the node N can be rewritten with True or False. If\n@@ -5052,315 +5062,32 @@ package body Exp_Ch4 is\n    --------------------------------------\n \n    procedure Expand_N_Expression_With_Actions (N : Node_Id) is\n-      In_Case_Or_If_Expression : constant Boolean :=\n-                                   Within_Case_Or_If_Expression (N);\n-\n       function Process_Action (Act : Node_Id) return Traverse_Result;\n-      --  Inspect and process a single action of an expression_with_actions\n+      --  Inspect and process a single action of an expression_with_actions for\n+      --  transient controlled objects. If such objects are found, the routine\n+      --  generates code to clean them up when the context of the expression is\n+      --  evaluated or elaborated.\n \n       --------------------\n       -- Process_Action --\n       --------------------\n \n       function Process_Action (Act : Node_Id) return Traverse_Result is\n-         procedure Process_Transient_Object (Obj_Decl : Node_Id);\n-         --  Obj_Decl denotes the declaration of a transient controlled object.\n-         --  Generate all necessary types and hooks to properly finalize the\n-         --  result when the enclosing context is elaborated/evaluated.\n-\n-         ------------------------------\n-         -- Process_Transient_Object --\n-         ------------------------------\n-\n-         procedure Process_Transient_Object (Obj_Decl : Node_Id) is\n-            function Find_Enclosing_Context return Node_Id;\n-            --  Find the context where the expression_with_actions appears\n-\n-            ----------------------------\n-            -- Find_Enclosing_Context --\n-            ----------------------------\n-\n-            function Find_Enclosing_Context return Node_Id is\n-               Par : Node_Id;\n-               Top : Node_Id;\n-\n-            begin\n-               --  The expression_with_actions is in a case/if expression and\n-               --  the lifetime of any temporary controlled object is therefore\n-               --  extended. Find a suitable insertion node by locating the top\n-               --  most case or if expressions.\n-\n-               if In_Case_Or_If_Expression then\n-                  Par := N;\n-                  Top := N;\n-                  while Present (Par) loop\n-                     if Nkind_In (Original_Node (Par), N_Case_Expression,\n-                                                       N_If_Expression)\n-                     then\n-                        Top := Par;\n-\n-                     --  Prevent the search from going too far\n-\n-                     elsif Is_Body_Or_Package_Declaration (Par) then\n-                        exit;\n-                     end if;\n-\n-                     Par := Parent (Par);\n-                  end loop;\n-\n-                  --  The topmost case or if expression is now recovered, but\n-                  --  it may still not be the correct place to add all the\n-                  --  generated code. Climb to find a parent that is part of a\n-                  --  declarative or statement list.\n-\n-                  Par := Top;\n-                  while Present (Par) loop\n-                     if Is_List_Member (Par)\n-                       and then\n-                         not Nkind_In (Par, N_Component_Association,\n-                                            N_Discriminant_Association,\n-                                            N_Parameter_Association,\n-                                            N_Pragma_Argument_Association)\n-                     then\n-                        return Par;\n-\n-                     --  Prevent the search from going too far\n-\n-                     elsif Is_Body_Or_Package_Declaration (Par) then\n-                        exit;\n-                     end if;\n-\n-                     Par := Parent (Par);\n-                  end loop;\n-\n-                  return Par;\n-\n-               --  Short circuit operators in complex expressions are converted\n-               --  into expression_with_actions.\n-\n-               else\n-                  --  Take care of the case where the expression_with_actions\n-                  --  is buried deep inside an IF statement. The temporary\n-                  --  function result must be finalized before the then, elsif\n-                  --  or else statements are evaluated.\n-\n-                  --    if Something\n-                  --      and then Ctrl_Func_Call\n-                  --    then\n-                  --       <result must be finalized at this point>\n-                  --       <statements>\n-                  --    end if;\n-\n-                  --  To achieve this, find the topmost logical operator. The\n-                  --  generated actions are then inserted before/after it.\n-\n-                  Par := N;\n-                  while Present (Par) loop\n-\n-                     --  Keep climbing past various operators\n-\n-                     if Nkind (Parent (Par)) in N_Op\n-                       or else Nkind_In (Parent (Par), N_And_Then, N_Or_Else)\n-                     then\n-                        Par := Parent (Par);\n-                     else\n-                        exit;\n-                     end if;\n-                  end loop;\n-\n-                  Top := Par;\n-\n-                  --  The expression_with_actions might be located in a pragma\n-                  --  in which case locate the pragma itself:\n-\n-                  --    pragma Precondition (... and then Ctrl_Func_Call ...);\n-\n-                  --  Similar case occurs when the expression_with_actions is\n-                  --  related to an object declaration or assignment:\n-\n-                  --    Obj [: Some_Typ] := ... and then Ctrl_Func_Call ...;\n-\n-                  --  Another case to consider is an expression_with_actions as\n-                  --  part of a return statement:\n-\n-                  --    return ... and then Ctrl_Func_Call ...;\n-\n-                  --  Yet another case: a formal in a procedure call statement:\n-\n-                  --    Proc (... and then Ctrl_Func_Call ...);\n-\n-                  while Present (Par) loop\n-                     if Nkind_In (Par, N_Assignment_Statement,\n-                                       N_Object_Declaration,\n-                                       N_Pragma,\n-                                       N_Procedure_Call_Statement,\n-                                       N_Simple_Return_Statement)\n-                     then\n-                        return Par;\n-\n-                     --  Prevent the search from going too far\n-\n-                     elsif Is_Body_Or_Package_Declaration (Par) then\n-                        exit;\n-                     end if;\n-\n-                     Par := Parent (Par);\n-                  end loop;\n-\n-                  --  Return the topmost short circuit operator\n-\n-                  return Top;\n-               end if;\n-            end Find_Enclosing_Context;\n-\n-            --  Local variables\n-\n-            Context   : constant Node_Id    := Find_Enclosing_Context;\n-            Loc       : constant Source_Ptr := Sloc (Obj_Decl);\n-            Obj_Id    : constant Entity_Id  := Defining_Identifier (Obj_Decl);\n-            Obj_Typ   : constant Node_Id    := Etype (Obj_Id);\n-            Desig_Typ : Entity_Id;\n-            Expr      : Node_Id;\n-            Fin_Call  : Node_Id;\n-            Ptr_Id    : Entity_Id;\n-            Temp_Id   : Entity_Id;\n-\n-         --  Start of processing for Process_Transient_Object\n-\n-         begin\n-            --  Step 1: Create the access type which provides a reference to\n-            --  the transient object.\n-\n-            if Is_Access_Type (Obj_Typ) then\n-               Desig_Typ := Directly_Designated_Type (Obj_Typ);\n-            else\n-               Desig_Typ := Obj_Typ;\n-            end if;\n-\n-            Desig_Typ := Base_Type (Desig_Typ);\n-\n-            --  Generate:\n-            --    Ann : access [all] <Desig_Typ>;\n-\n-            Ptr_Id := Make_Temporary (Loc, 'A');\n-\n-            Insert_Action (Context,\n-              Make_Full_Type_Declaration (Loc,\n-                Defining_Identifier => Ptr_Id,\n-                Type_Definition     =>\n-                  Make_Access_To_Object_Definition (Loc,\n-                    All_Present        =>\n-                      Ekind (Obj_Typ) = E_General_Access_Type,\n-                    Subtype_Indication => New_Reference_To (Desig_Typ, Loc))));\n-\n-            --  Step 2: Create a temporary which acts as a hook to the\n-            --  transient object. Generate:\n-\n-            --    Temp : Ptr_Id := null;\n-\n-            Temp_Id := Make_Temporary (Loc, 'T');\n-\n-            Insert_Action (Context,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp_Id,\n-                Object_Definition   => New_Reference_To (Ptr_Id, Loc)));\n-\n-            --  Mark this temporary as created for the purposes of exporting\n-            --  the transient declaration out of the Actions list. This signals\n-            --  the machinery in Build_Finalizer to recognize this special\n-            --  case.\n-\n-            Set_Status_Flag_Or_Transient_Decl (Temp_Id, Obj_Decl);\n-\n-            --  Step 3: Hook the transient object to the temporary\n-\n-            --  The use of unchecked conversion / unrestricted access is needed\n-            --  to avoid an accessibility violation. Note that the finalization\n-            --  code is structured in such a way that the \"hook\" is processed\n-            --  only when it points to an existing object.\n-\n-            if Is_Access_Type (Obj_Typ) then\n-               Expr :=\n-                 Unchecked_Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n-            else\n-               Expr :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         => New_Reference_To (Obj_Id, Loc),\n-                   Attribute_Name => Name_Unrestricted_Access);\n-            end if;\n-\n-            --  Generate:\n-            --    Temp := Ptr_Id (Obj_Id);\n-            --      <or>\n-            --    Temp := Obj_Id'Unrestricted_Access;\n-\n-            Insert_After_And_Analyze (Obj_Decl,\n-              Make_Assignment_Statement (Loc,\n-                Name       => New_Reference_To (Temp_Id, Loc),\n-                Expression => Expr));\n-\n-            --  Step 4: Finalize the function result after the context has been\n-            --  evaluated/elaborated. Generate:\n-\n-            --    if Temp /= null then\n-            --       [Deep_]Finalize (Temp.all);\n-            --       Temp := null;\n-            --    end if;\n-\n-            --  When the expression_with_actions is part of a return statement,\n-            --  there is no need to insert a finalization call, as the general\n-            --  finalization mechanism (see Build_Finalizer) would take care of\n-            --  the temporary function result on subprogram exit. Note that it\n-            --  would also be impossible to insert the finalization code after\n-            --  the return statement as this would make it unreachable.\n-\n-            if Nkind (Context) /= N_Simple_Return_Statement then\n-               Fin_Call :=\n-                 Make_Implicit_If_Statement (Obj_Decl,\n-                   Condition =>\n-                     Make_Op_Ne (Loc,\n-                       Left_Opnd  => New_Reference_To (Temp_Id, Loc),\n-                       Right_Opnd => Make_Null (Loc)),\n-\n-                   Then_Statements => New_List (\n-                     Make_Final_Call\n-                       (Obj_Ref =>\n-                          Make_Explicit_Dereference (Loc,\n-                            Prefix => New_Reference_To (Temp_Id, Loc)),\n-                        Typ     => Desig_Typ),\n-\n-                     Make_Assignment_Statement (Loc,\n-                       Name       => New_Reference_To (Temp_Id, Loc),\n-                       Expression => Make_Null (Loc))));\n-\n-               --  Use the Actions list of logical operators when inserting the\n-               --  finalization call. This ensures that all transient objects\n-               --  are finalized after the operators are evaluated.\n-\n-               if Nkind_In (Context, N_And_Then, N_Or_Else) then\n-                  Insert_Action (Context, Fin_Call);\n-               else\n-                  Insert_Action_After (Context, Fin_Call);\n-               end if;\n-            end if;\n-         end Process_Transient_Object;\n-\n-      --  Start of processing for Process_Action\n-\n       begin\n          if Nkind (Act) = N_Object_Declaration\n            and then Is_Finalizable_Transient (Act, N)\n          then\n-            Process_Transient_Object (Act);\n+            Process_Transient_Object (Act, N);\n+            return Abandon;\n \n          --  Avoid processing temporary function results multiple times when\n          --  dealing with nested expression_with_actions.\n \n          elsif Nkind (Act) = N_Expression_With_Actions then\n             return Abandon;\n \n-         --  Do not process temporary function results in loops. This is\n-         --  done by Expand_N_Loop_Statement and Build_Finalizer.\n+         --  Do not process temporary function results in loops. This is done\n+         --  by Expand_N_Loop_Statement and Build_Finalizer.\n \n          elsif Nkind (Act) = N_Loop_Statement then\n             return Abandon;\n@@ -5393,67 +5120,31 @@ package body Exp_Ch4 is\n    --  Deal with limited types and condition actions\n \n    procedure Expand_N_If_Expression (N : Node_Id) is\n-      function Create_Alternative\n-        (Loc     : Source_Ptr;\n-         Temp_Id : Entity_Id;\n-         Flag_Id : Entity_Id;\n-         Expr    : Node_Id) return List_Id;\n-      --  Build the statements of a \"then\" or \"else\" dependent expression\n-      --  alternative. Temp_Id is the if expression result, Flag_Id is a\n-      --  finalization flag created to service expression Expr.\n-\n-      function Is_Controlled_Function_Call (Expr : Node_Id) return Boolean;\n-      --  Determine if expression Expr is a rewritten controlled function call\n+      procedure Process_Actions (Actions : List_Id);\n+      --  Inspect and process a single action list of an if expression for\n+      --  transient controlled objects. If such objects are found, the routine\n+      --  generates code to clean them up when the context of the expression is\n+      --  evaluated or elaborated.\n \n-      ------------------------\n-      -- Create_Alternative --\n-      ------------------------\n+      ---------------------\n+      -- Process_Actions --\n+      ---------------------\n \n-      function Create_Alternative\n-        (Loc     : Source_Ptr;\n-         Temp_Id : Entity_Id;\n-         Flag_Id : Entity_Id;\n-         Expr    : Node_Id) return List_Id\n-      is\n-         Result : constant List_Id := New_List;\n+      procedure Process_Actions (Actions : List_Id) is\n+         Act : Node_Id;\n \n       begin\n-         --  Generate:\n-         --    Fnn := True;\n-\n-         if Present (Flag_Id)\n-           and then not Is_Controlled_Function_Call (Expr)\n-         then\n-            Append_To (Result,\n-              Make_Assignment_Statement (Loc,\n-                Name       => New_Reference_To (Flag_Id, Loc),\n-                Expression => New_Reference_To (Standard_True, Loc)));\n-         end if;\n-\n-         --  Generate:\n-         --    Cnn := <expr>'Unrestricted_Access;\n-\n-         Append_To (Result,\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (Temp_Id, Loc),\n-             Expression =>\n-               Make_Attribute_Reference (Loc,\n-                 Prefix         => Relocate_Node (Expr),\n-                 Attribute_Name => Name_Unrestricted_Access)));\n-\n-         return Result;\n-      end Create_Alternative;\n-\n-      ---------------------------------\n-      -- Is_Controlled_Function_Call --\n-      ---------------------------------\n+         Act := First (Actions);\n+         while Present (Act) loop\n+            if Nkind (Act) = N_Object_Declaration\n+              and then Is_Finalizable_Transient (Act, N)\n+            then\n+               Process_Transient_Object (Act, N);\n+            end if;\n \n-      function Is_Controlled_Function_Call (Expr : Node_Id) return Boolean is\n-      begin\n-         return\n-           Nkind (Original_Node (Expr)) = N_Function_Call\n-             and then Needs_Finalization (Etype (Expr));\n-      end Is_Controlled_Function_Call;\n+            Next (Act);\n+         end loop;\n+      end Process_Actions;\n \n       --  Local variables\n \n@@ -5469,6 +5160,7 @@ package body Exp_Ch4 is\n       Expr    : Node_Id;\n       New_If  : Node_Id;\n       New_N   : Node_Id;\n+      Ptr_Typ : Entity_Id;\n \n    --  Start of processing for Expand_N_If_Expression\n \n@@ -5541,70 +5233,66 @@ package body Exp_Ch4 is\n       if Is_By_Reference_Type (Typ)\n         and then not Back_End_Handles_Limited_Types\n       then\n-         declare\n-            Flag_Id : Entity_Id;\n-            Ptr_Typ : Entity_Id;\n+         --  When the \"then\" or \"else\" expressions involve controlled function\n+         --  calls, generated temporaries are chained on the corresponding list\n+         --  of actions. These temporaries need to be finalized after the if\n+         --  expression is evaluated.\n \n-         begin\n-            Flag_Id := Empty;\n-\n-            --  At least one of the if expression dependent expressions uses a\n-            --  controlled function to provide the result. Create a status flag\n-            --  to signal the finalization machinery that Cnn needs special\n-            --  handling.\n+         Process_Actions (Then_Actions (N));\n+         Process_Actions (Else_Actions (N));\n \n-            if Is_Controlled_Function_Call (Thenx)\n-                 or else\n-               Is_Controlled_Function_Call (Elsex)\n-            then\n-               Flag_Id := Make_Temporary (Loc, 'F');\n+         --  Generate:\n+         --    type Ann is access all Typ;\n \n-               Insert_Action (N,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Flag_Id,\n-                   Object_Definition   =>\n-                     New_Reference_To (Standard_Boolean, Loc),\n-                   Expression          =>\n-                     New_Reference_To (Standard_False, Loc)));\n-            end if;\n+         Ptr_Typ := Make_Temporary (Loc, 'A');\n \n-            --  Generate:\n-            --    type Ann is access all Typ;\n+         Insert_Action (N,\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => Ptr_Typ,\n+             Type_Definition     =>\n+               Make_Access_To_Object_Definition (Loc,\n+                 All_Present        => True,\n+                 Subtype_Indication => New_Reference_To (Typ, Loc))));\n \n-            Ptr_Typ := Make_Temporary (Loc, 'A');\n+         --  Generate:\n+         --    Cnn : Ann;\n \n-            Insert_Action (N,\n-              Make_Full_Type_Declaration (Loc,\n-                Defining_Identifier => Ptr_Typ,\n-                Type_Definition     =>\n-                  Make_Access_To_Object_Definition (Loc,\n-                    All_Present        => True,\n-                    Subtype_Indication => New_Reference_To (Typ, Loc))));\n+         Cnn := Make_Temporary (Loc, 'C', N);\n \n-            --  Generate:\n-            --    Cnn : Ann;\n+         Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Cnn,\n+             Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc));\n \n-            Cnn := Make_Temporary (Loc, 'C', N);\n-            Set_Ekind (Cnn, E_Variable);\n-            Set_Status_Flag_Or_Transient_Decl (Cnn, Flag_Id);\n+         --  Generate:\n+         --    if Cond then\n+         --       Cnn := <Thenx>'Unrestricted_Access;\n+         --    else\n+         --       Cnn := <Elsex>'Unrestricted_Access;\n+         --    end if;\n \n-            Decl :=\n-               Make_Object_Declaration (Loc,\n-                 Defining_Identifier => Cnn,\n-                 Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc));\n+         New_If :=\n+           Make_Implicit_If_Statement (N,\n+             Condition       => Relocate_Node (Cond),\n+             Then_Statements => New_List (\n+               Make_Assignment_Statement (Sloc (Thenx),\n+                 Name       => New_Reference_To (Cnn, Sloc (Thenx)),\n+                 Expression =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         => Relocate_Node (Thenx),\n+                     Attribute_Name => Name_Unrestricted_Access))),\n \n-            New_If :=\n-              Make_Implicit_If_Statement (N,\n-                Condition       => Relocate_Node (Cond),\n-                Then_Statements =>\n-                  Create_Alternative (Sloc (Thenx), Cnn, Flag_Id, Thenx),\n-                Else_Statements =>\n-                  Create_Alternative (Sloc (Elsex), Cnn, Flag_Id, Elsex));\n+             Else_Statements => New_List (\n+               Make_Assignment_Statement (Sloc (Elsex),\n+                 Name       => New_Reference_To (Cnn, Sloc (Elsex)),\n+                 Expression =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         => Relocate_Node (Elsex),\n+                     Attribute_Name => Name_Unrestricted_Access))));\n \n             New_N :=\n               Make_Explicit_Dereference (Loc,\n                 Prefix => New_Occurrence_Of (Cnn, Loc));\n-         end;\n \n       --  For other types, we only need to expand if there are other actions\n       --  associated with either branch.\n@@ -5615,26 +5303,28 @@ package body Exp_Ch4 is\n \n          if Present (Then_Actions (N)) then\n             Rewrite (Thenx,\n-                     Make_Expression_With_Actions (Sloc (Thenx),\n-                       Actions    => Then_Actions (N),\n-                       Expression => Relocate_Node (Thenx)));\n+              Make_Expression_With_Actions (Sloc (Thenx),\n+                Actions    => Then_Actions (N),\n+                Expression => Relocate_Node (Thenx)));\n+\n             Set_Then_Actions (N, No_List);\n             Analyze_And_Resolve (Thenx, Typ);\n          end if;\n \n          if Present (Else_Actions (N)) then\n             Rewrite (Elsex,\n-                     Make_Expression_With_Actions (Sloc (Elsex),\n-                       Actions    => Else_Actions (N),\n-                       Expression => Relocate_Node (Elsex)));\n+              Make_Expression_With_Actions (Sloc (Elsex),\n+                Actions    => Else_Actions (N),\n+                Expression => Relocate_Node (Elsex)));\n+\n             Set_Else_Actions (N, No_List);\n             Analyze_And_Resolve (Elsex, Typ);\n          end if;\n \n          return;\n \n-         --  If no actions then no expansion needed, gigi will handle it using\n-         --  the same approach as a C conditional expression.\n+      --  If no actions then no expansion needed, gigi will handle it using the\n+      --  same approach as a C conditional expression.\n \n       else\n          return;\n@@ -12387,6 +12077,282 @@ package body Exp_Ch4 is\n       return;\n    end Optimize_Length_Comparison;\n \n+   ------------------------------\n+   -- Process_Transient_Object --\n+   ------------------------------\n+\n+   procedure Process_Transient_Object\n+     (Decl     : Node_Id;\n+      Rel_Node : Node_Id)\n+   is\n+      function Find_Enclosing_Context (N : Node_Id) return Node_Id;\n+      --  Find the logical context where N appears. The context is chosen such\n+      --  that it is possible to insert before and after it.\n+\n+      ----------------------------\n+      -- Find_Enclosing_Context --\n+      ----------------------------\n+\n+      function Find_Enclosing_Context (N : Node_Id) return Node_Id is\n+         Par : Node_Id;\n+         Top : Node_Id;\n+\n+      begin\n+         --  When the node is inside a case/if expression, the lifetime of any\n+         --  temporary controlled object is extended. Find a suitable insertion\n+         --  node by locating the topmost case or if expressions.\n+\n+         if Within_Case_Or_If_Expression (N) then\n+            Par := N;\n+            Top := N;\n+            while Present (Par) loop\n+               if Nkind_In (Original_Node (Par), N_Case_Expression,\n+                                                 N_If_Expression)\n+               then\n+                  Top := Par;\n+\n+               --  Prevent the search from going too far\n+\n+               elsif Is_Body_Or_Package_Declaration (Par) then\n+                  exit;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+\n+            --  The topmost case or if expression is now recovered, but it may\n+            --  still not be the correct place to add generated code. Climb to\n+            --  find a parent that is part of a declarative or statement list.\n+\n+            Par := Top;\n+            while Present (Par) loop\n+               if Is_List_Member (Par)\n+                 and then not Nkind_In (Par, N_Component_Association,\n+                                             N_Discriminant_Association,\n+                                             N_Parameter_Association,\n+                                             N_Pragma_Argument_Association)\n+               then\n+                  return Par;\n+\n+               --  Prevent the search from going too far\n+\n+               elsif Is_Body_Or_Package_Declaration (Par) then\n+                  exit;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+\n+            return Par;\n+\n+         --  Short circuit operators in complex expressions are converted into\n+         --  expression_with_actions.\n+\n+         else\n+            --  Handle the case where the node is buried deep inside an if\n+            --  statement. The temporary controlled object must be finalized\n+            --  before the then, elsif or else statements are evaluated.\n+\n+            --    if Something\n+            --      and then Ctrl_Func_Call\n+            --    then\n+            --       <result must be finalized at this point>\n+            --       <statements>\n+            --    end if;\n+\n+            --  To achieve this, find the topmost logical operator. Generated\n+            --  actions are then inserted before/after it.\n+\n+            Par := N;\n+            while Present (Par) loop\n+\n+               --  Keep climbing past various operators\n+\n+               if Nkind (Parent (Par)) in N_Op\n+                 or else Nkind_In (Parent (Par), N_And_Then, N_Or_Else)\n+               then\n+                  Par := Parent (Par);\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            Top := Par;\n+\n+            --  The node may be located in a pragma in which case return the\n+            --  pragma itself:\n+\n+            --    pragma Precondition (... and then Ctrl_Func_Call ...);\n+\n+            --  Similar case occurs when the node is related to an object\n+            --  declaration or assignment:\n+\n+            --    Obj [: Some_Typ] := ... and then Ctrl_Func_Call ...;\n+\n+            --  Another case to consider is when the node is part of a return\n+            --  statement:\n+\n+            --    return ... and then Ctrl_Func_Call ...;\n+\n+            --  Another case is when the node acts as a formal in a procedure\n+            --  call statement:\n+\n+            --    Proc (... and then Ctrl_Func_Call ...);\n+\n+            while Present (Par) loop\n+               if Nkind_In (Par, N_Assignment_Statement,\n+                                 N_Object_Declaration,\n+                                 N_Pragma,\n+                                 N_Procedure_Call_Statement,\n+                                 N_Simple_Return_Statement)\n+               then\n+                  return Par;\n+\n+               --  Prevent the search from going too far\n+\n+               elsif Is_Body_Or_Package_Declaration (Par) then\n+                  exit;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+\n+            --  Return the topmost short circuit operator\n+\n+            return Top;\n+         end if;\n+      end Find_Enclosing_Context;\n+\n+      --  Local variables\n+\n+      Context   : constant Node_Id    := Find_Enclosing_Context (Rel_Node);\n+      Loc       : constant Source_Ptr := Sloc (Decl);\n+      Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n+      Obj_Typ   : constant Node_Id    := Etype (Obj_Id);\n+      Desig_Typ : Entity_Id;\n+      Expr      : Node_Id;\n+      Fin_Call  : Node_Id;\n+      Ptr_Id    : Entity_Id;\n+      Temp_Id   : Entity_Id;\n+\n+   --  Start of processing for Process_Transient_Object\n+\n+   begin\n+      --  Step 1: Create the access type which provides a reference to the\n+      --  transient controlled object.\n+\n+      if Is_Access_Type (Obj_Typ) then\n+         Desig_Typ := Directly_Designated_Type (Obj_Typ);\n+      else\n+         Desig_Typ := Obj_Typ;\n+      end if;\n+\n+      Desig_Typ := Base_Type (Desig_Typ);\n+\n+      --  Generate:\n+      --    Ann : access [all] <Desig_Typ>;\n+\n+      Ptr_Id := Make_Temporary (Loc, 'A');\n+\n+      Insert_Action (Context,\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => Ptr_Id,\n+          Type_Definition     =>\n+            Make_Access_To_Object_Definition (Loc,\n+              All_Present        => Ekind (Obj_Typ) = E_General_Access_Type,\n+              Subtype_Indication => New_Reference_To (Desig_Typ, Loc))));\n+\n+      --  Step 2: Create a temporary which acts as a hook to the transient\n+      --  controlled object. Generate:\n+\n+      --    Temp : Ptr_Id := null;\n+\n+      Temp_Id := Make_Temporary (Loc, 'T');\n+\n+      Insert_Action (Context,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Temp_Id,\n+          Object_Definition   => New_Reference_To (Ptr_Id, Loc)));\n+\n+      --  Mark the temporary as created for the purposes of exporting the\n+      --  transient controlled object out of the expression_with_action or if\n+      --  expression. This signals the machinery in Build_Finalizer to treat\n+      --  this case specially.\n+\n+      Set_Status_Flag_Or_Transient_Decl (Temp_Id, Decl);\n+\n+      --  Step 3: Hook the transient object to the temporary\n+\n+      --  The use of unchecked conversion / unrestricted access is needed to\n+      --  avoid an accessibility violation. Note that the finalization code is\n+      --  structured in such a way that the \"hook\" is processed only when it\n+      --  points to an existing object.\n+\n+      if Is_Access_Type (Obj_Typ) then\n+         Expr := Unchecked_Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n+      else\n+         Expr :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Reference_To (Obj_Id, Loc),\n+             Attribute_Name => Name_Unrestricted_Access);\n+      end if;\n+\n+      --  Generate:\n+      --    Temp := Ptr_Id (Obj_Id);\n+      --      <or>\n+      --    Temp := Obj_Id'Unrestricted_Access;\n+\n+      Insert_After_And_Analyze (Decl,\n+        Make_Assignment_Statement (Loc,\n+          Name       => New_Reference_To (Temp_Id, Loc),\n+          Expression => Expr));\n+\n+      --  Step 4: Finalize the transient controlled object after the context\n+      --  has been evaluated/elaborated. Generate:\n+\n+      --    if Temp /= null then\n+      --       [Deep_]Finalize (Temp.all);\n+      --       Temp := null;\n+      --    end if;\n+\n+      --  When the node is part of a return statement, there is no need to\n+      --  insert a finalization call, as the general finalization mechanism\n+      --  (see Build_Finalizer) would take care of the transient controlled\n+      --  object on subprogram exit. Note that it would also be impossible to\n+      --  insert the finalization code after the return statement as this will\n+      --  render it unreachable.\n+\n+      if Nkind (Context) /= N_Simple_Return_Statement then\n+         Fin_Call :=\n+           Make_Implicit_If_Statement (Decl,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd  => New_Reference_To (Temp_Id, Loc),\n+                 Right_Opnd => Make_Null (Loc)),\n+\n+             Then_Statements => New_List (\n+               Make_Final_Call\n+                 (Obj_Ref =>\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix => New_Reference_To (Temp_Id, Loc)),\n+                  Typ     => Desig_Typ),\n+\n+               Make_Assignment_Statement (Loc,\n+                 Name       => New_Reference_To (Temp_Id, Loc),\n+                 Expression => Make_Null (Loc))));\n+\n+         --  Use the Actions list of logical operators when inserting the\n+         --  finalization call. This ensures that all transient controlled\n+         --  objects are finalized after the operators are evaluated.\n+\n+         if Nkind_In (Context, N_And_Then, N_Or_Else) then\n+            Insert_Action (Context, Fin_Call);\n+         else\n+            Insert_Action_After (Context, Fin_Call);\n+         end if;\n+      end if;\n+   end Process_Transient_Object;\n+\n    ------------------------\n    -- Rewrite_Comparison --\n    ------------------------"}, {"sha": "ca8bc9839ab4685b2dc374cbd18116711f0625cf", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -8040,11 +8040,11 @@ package body Exp_Util is\n       Par : Node_Id;\n \n    begin\n-      --  Locate an enclosing case or if expression. Note: these constructs can\n-      --  get expanded into Expression_With_Actions, hence the need to test\n-      --  using the original node.\n+      --  Locate an enclosing case or if expression. Note that these constructs\n+      --  can be expanded into Expression_With_Actions, hence the test of the\n+      --  original node.\n \n-      Par := N;\n+      Par := Parent (N);\n       while Present (Par) loop\n          if Nkind_In (Original_Node (Par), N_Case_Expression,\n                                            N_If_Expression)"}, {"sha": "a771db6f8a3a4444fb40bf980b149a9d8772e929", "filename": "gcc/ada/s-interr.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fs-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c28399143ad6bebd4a5af6818c000bb69a6226/gcc%2Fada%2Fs-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.ads?ref=b2c28399143ad6bebd4a5af6818c000bb69a6226", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -256,8 +256,7 @@ package System.Interrupts is\n      (Object : access Static_Interrupt_Protection) return Boolean;\n    --  Returns True\n \n-   overriding\n-   procedure Finalize (Object : in out Static_Interrupt_Protection);\n+   overriding procedure Finalize (Object : in out Static_Interrupt_Protection);\n    --  Restore previous handlers as required by C.3.1(12) then call\n    --  Finalize (Protection).\n "}]}