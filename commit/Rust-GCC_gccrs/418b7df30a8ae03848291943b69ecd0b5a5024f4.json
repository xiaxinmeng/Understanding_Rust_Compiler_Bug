{"sha": "418b7df30a8ae03848291943b69ecd0b5a5024f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE4YjdkZjMwYThhZTAzODQ4MjkxOTQzYjY5ZWNkMGI1YTUwMjRmNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-03-22T11:36:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-03-22T11:36:46Z"}, "message": "re PR tree-optimization/52638 (ice in build_vector_from_val)\n\n2012-03-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/52638\n\t* tree-vect-stmts.c (vect_init_vector_1): New function, split\n\tout from ...\n\t(vect_init_vector): ... here.  Handle scalar vector inits.\n\t(vect_get_vec_def_for_operand): Adjust.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r185687", "tree": {"sha": "9c60f1f9a573d38ac8a08a2f23cb739bcf2cf768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c60f1f9a573d38ac8a08a2f23cb739bcf2cf768"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/418b7df30a8ae03848291943b69ecd0b5a5024f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418b7df30a8ae03848291943b69ecd0b5a5024f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/418b7df30a8ae03848291943b69ecd0b5a5024f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418b7df30a8ae03848291943b69ecd0b5a5024f4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0d753d9b3b804fb4f36e90f3016cd01546d6972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d753d9b3b804fb4f36e90f3016cd01546d6972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d753d9b3b804fb4f36e90f3016cd01546d6972"}], "stats": {"total": 123, "additions": 71, "deletions": 52}, "files": [{"sha": "af9f8701ce658b93e3f5defc5010858c13840ede", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418b7df30a8ae03848291943b69ecd0b5a5024f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418b7df30a8ae03848291943b69ecd0b5a5024f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=418b7df30a8ae03848291943b69ecd0b5a5024f4", "patch": "@@ -1,3 +1,12 @@\n+2012-03-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/52638\n+\t* tree-vect-stmts.c (vect_init_vector_1): New function, split\n+\tout from ...\n+\t(vect_init_vector): ... here.  Handle scalar vector inits.\n+\t(vect_get_vec_def_for_operand): Adjust.\n+\t(vectorizable_load): Likewise.\n+\n 2012-03-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config.gcc (alpha*-*-linux*): Add elfos.h to tm_file."}, {"sha": "3a4d91aa081859fcb4165a5b73c1479338599526", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 62, "deletions": 52, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418b7df30a8ae03848291943b69ecd0b5a5024f4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418b7df30a8ae03848291943b69ecd0b5a5024f4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=418b7df30a8ae03848291943b69ecd0b5a5024f4", "patch": "@@ -1136,48 +1136,31 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n     }\n }\n \n+/* Insert the new stmt NEW_STMT at *GSI or at the appropriate place in\n+   the loop preheader for the vectorized stmt STMT.  */\n \n-/* Function vect_init_vector.\n-\n-   Insert a new stmt (INIT_STMT) that initializes a new vector variable with\n-   the vector elements of VECTOR_VAR.  Place the initialization at BSI if it\n-   is not NULL.  Otherwise, place the initialization at the loop preheader.\n-   Return the DEF of INIT_STMT.\n-   It will be used in the vectorization of STMT.  */\n-\n-tree\n-vect_init_vector (gimple stmt, tree vector_var, tree vector_type,\n-\t\t  gimple_stmt_iterator *gsi)\n+static void\n+vect_init_vector_1 (gimple stmt, gimple new_stmt, gimple_stmt_iterator *gsi)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  tree new_var;\n-  gimple init_stmt;\n-  tree vec_oprnd;\n-  edge pe;\n-  tree new_temp;\n-  basic_block new_bb;\n-\n-  new_var = vect_get_new_vect_var (vector_type, vect_simple_var, \"cst_\");\n-  add_referenced_var (new_var);\n-  init_stmt = gimple_build_assign  (new_var, vector_var);\n-  new_temp = make_ssa_name (new_var, init_stmt);\n-  gimple_assign_set_lhs (init_stmt, new_temp);\n \n   if (gsi)\n-    vect_finish_stmt_generation (stmt, init_stmt, gsi);\n+    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n   else\n     {\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n       loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n \n       if (loop_vinfo)\n         {\n           struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\t  basic_block new_bb;\n+\t  edge pe;\n \n           if (nested_in_vect_loop_p (loop, stmt))\n             loop = loop->inner;\n \n \t  pe = loop_preheader_edge (loop);\n-          new_bb = gsi_insert_on_edge_immediate (pe, init_stmt);\n+          new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);\n           gcc_assert (!new_bb);\n \t}\n       else\n@@ -1189,16 +1172,64 @@ vect_init_vector (gimple stmt, tree vector_var, tree vector_type,\n           gcc_assert (bb_vinfo);\n           bb = BB_VINFO_BB (bb_vinfo);\n           gsi_bb_start = gsi_after_labels (bb);\n-          gsi_insert_before (&gsi_bb_start, init_stmt, GSI_SAME_STMT);\n+          gsi_insert_before (&gsi_bb_start, new_stmt, GSI_SAME_STMT);\n        }\n     }\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"created new init_stmt: \");\n-      print_gimple_stmt (vect_dump, init_stmt, 0, TDF_SLIM);\n+      print_gimple_stmt (vect_dump, new_stmt, 0, TDF_SLIM);\n+    }\n+}\n+\n+/* Function vect_init_vector.\n+\n+   Insert a new stmt (INIT_STMT) that initializes a new vector variable with\n+   the vector elements of VECTOR_VAR.  Place the initialization at BSI if it\n+   is not NULL.  Otherwise, place the initialization at the loop preheader.\n+   Return the DEF of INIT_STMT.\n+   It will be used in the vectorization of STMT.  */\n+\n+tree\n+vect_init_vector (gimple stmt, tree vector_var, tree vector_type,\n+\t\t  gimple_stmt_iterator *gsi)\n+{\n+  tree new_var;\n+  gimple init_stmt;\n+  tree vec_oprnd;\n+  tree new_temp;\n+\n+  if (TREE_CODE (TREE_TYPE (vector_var)) != VECTOR_TYPE)\n+    {\n+      if (!types_compatible_p (TREE_TYPE (vector_type),\n+\t\t\t       TREE_TYPE (vector_var)))\n+\t{\n+\t  if (CONSTANT_CLASS_P (vector_var))\n+\t    vector_var = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (vector_type),\n+\t\t\t\t     vector_var);\n+\t  else\n+\t    {\n+\t      new_var = create_tmp_reg (TREE_TYPE (vector_type), NULL);\n+\t      add_referenced_var (new_var);\n+\t      init_stmt = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\t\t\tnew_var, vector_var,\n+\t\t\t\t\t\t\tNULL_TREE);\n+\t      new_temp = make_ssa_name (new_var, init_stmt);\n+\t      gimple_assign_set_lhs (init_stmt, new_temp);\n+\t      vect_init_vector_1 (stmt, init_stmt, gsi);\n+\t      vector_var = new_temp;\n+\t    }\n+\t}\n+      vector_var = build_vector_from_val (vector_type, vector_var);\n     }\n \n+  new_var = vect_get_new_vect_var (vector_type, vect_simple_var, \"cst_\");\n+  add_referenced_var (new_var);\n+  init_stmt = gimple_build_assign  (new_var, vector_var);\n+  new_temp = make_ssa_name (new_var, init_stmt);\n+  gimple_assign_set_lhs (init_stmt, new_temp);\n+  vect_init_vector_1 (stmt, init_stmt, gsi);\n   vec_oprnd = gimple_assign_lhs (init_stmt);\n   return vec_oprnd;\n }\n@@ -1225,8 +1256,6 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   unsigned int nunits;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  tree vec_inv;\n-  tree vec_cst;\n   tree def;\n   enum vect_def_type dt;\n   bool is_simple_use;\n@@ -1271,14 +1300,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n \n-\tif (!types_compatible_p (TREE_TYPE (vector_type), TREE_TYPE (op)))\n-\t  {\n-\t    op = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (vector_type), op);\n-\t    gcc_assert (op && CONSTANT_CLASS_P (op));\n-\t  }\n-\n-        vec_cst = build_vector_from_val (vector_type, op);\n-        return vect_init_vector (stmt, vec_cst, vector_type, NULL);\n+        return vect_init_vector (stmt, op, vector_type, NULL);\n       }\n \n     /* Case 2: operand is defined outside the loop - loop invariant.  */\n@@ -1294,8 +1316,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Create vector_inv.\");\n \n-\tvec_inv = build_vector_from_val (vector_type, def);\n-        return vect_init_vector (stmt, vec_inv, vector_type, NULL);\n+        return vect_init_vector (stmt, def, vector_type, NULL);\n       }\n \n     /* Case 3: operand is defined inside the loop.  */\n@@ -4875,21 +4896,10 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      /* 4. Handle invariant-load.  */\n \t      if (inv_p && !bb_vinfo)\n \t\t{\n-\t\t  tree tem, vec_inv;\n \t\t  gimple_stmt_iterator gsi2 = *gsi;\n \t\t  gcc_assert (!strided_load);\n \t\t  gsi_next (&gsi2);\n-\t\t  tem = scalar_dest;\n-\t\t  if (!useless_type_conversion_p (TREE_TYPE (vectype),\n-\t\t\t\t\t\t  TREE_TYPE (tem)))\n-\t\t    {\n-\t\t      tem = fold_convert (TREE_TYPE (vectype), tem);\n-\t\t      tem = force_gimple_operand_gsi (&gsi2, tem, true,\n-\t\t\t\t\t\t      NULL_TREE, true,\n-\t\t\t\t\t\t      GSI_SAME_STMT);\n-\t\t    }\n-\t\t  vec_inv = build_vector_from_val (vectype, tem);\n-\t\t  new_temp = vect_init_vector (stmt, vec_inv,\n+\t\t  new_temp = vect_init_vector (stmt, scalar_dest,\n \t\t\t\t\t       vectype, &gsi2);\n \t\t  new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t\t}"}]}