{"sha": "fec5f4e04195323a076ac92c9adc68e97dec738a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVjNWY0ZTA0MTk1MzIzYTA3NmFjOTJjOWFkYzY4ZTk3ZGVjNzM4YQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2017-01-04T17:06:33Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2017-01-04T17:06:33Z"}, "message": "Make MIPS soft-fp preserve NaN payloads for NAN2008.\n\nThe MIPS sfp-machine.h has an _FP_CHOOSENAN implementation which\nemulates hardware semantics of not preserving signaling NaN payloads\nfor an operation with two NaN arguments (although that doesn't suffice\nto avoid sNaN payload preservation in any case with just one NaN\nargument).\n\nHowever, those are only hardware semantics in the legacy NaN case; in\nthe NAN2008 case, the architecture documentation says hardware\npreserves payloads in such cases.  Furthermore, this implementation\nassumes legacy NaN semantics, so in the NAN2008 case the\nimplementation actually has the effect of preserving sNaN payloads but\nnot preserving qNaN payloads, when both should be preserved.\n\nThis patch fixes the code just to copy from the first argument (at the\nlevel of libgcc, it's not meaningful which argument is the first and\nwhich is the second).\n\nTested for mips64-linux-gnu (soft float, NAN2008) with the glibc math/\ntests.\n\n\t* config/mips/sfp-machine.h (_FP_CHOOSENAN): Always preserve NaN\n\tpayload if [__mips_nan2008].\n\nFrom-SVN: r244059", "tree": {"sha": "1f779d04a8a371cdb55a64c7a6a80b9043c4f1ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f779d04a8a371cdb55a64c7a6a80b9043c4f1ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fec5f4e04195323a076ac92c9adc68e97dec738a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec5f4e04195323a076ac92c9adc68e97dec738a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fec5f4e04195323a076ac92c9adc68e97dec738a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec5f4e04195323a076ac92c9adc68e97dec738a/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58adb11b3021a6495d990ba7840f09022e2a6dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58adb11b3021a6495d990ba7840f09022e2a6dfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58adb11b3021a6495d990ba7840f09022e2a6dfd"}], "stats": {"total": 19, "additions": 18, "deletions": 1}, "files": [{"sha": "f0eb567c591274e21734fc6de6b73b6856a1245b", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec5f4e04195323a076ac92c9adc68e97dec738a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec5f4e04195323a076ac92c9adc68e97dec738a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=fec5f4e04195323a076ac92c9adc68e97dec738a", "patch": "@@ -1,3 +1,8 @@\n+2017-01-04  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/mips/sfp-machine.h (_FP_CHOOSENAN): Always preserve NaN\n+\tpayload if [__mips_nan2008].\n+\n 2017-01-04  Alan Modra  <amodra@gmail.com>\n \n \t* Makefile.in (configure_deps): Update."}, {"sha": "07d11580ee682e95cecd25eb323745f8978688a7", "filename": "libgcc/config/mips/sfp-machine.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec5f4e04195323a076ac92c9adc68e97dec738a/libgcc%2Fconfig%2Fmips%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec5f4e04195323a076ac92c9adc68e97dec738a/libgcc%2Fconfig%2Fmips%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmips%2Fsfp-machine.h?ref=fec5f4e04195323a076ac92c9adc68e97dec738a", "patch": "@@ -96,10 +96,21 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n # define _FP_QNANNEGATEDP 1\n #endif\n \n+#ifdef __mips_nan2008\n+/* NaN payloads should be preserved for NAN2008.  */\n+# define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      R##_s = X##_s;\t\t\t\t\\\n+      _FP_FRAC_COPY_##wc (R, X);\t\t\\\n+      R##_c = FP_CLS_NAN;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+#else\n /* Comment from glibc: */\n /* From my experiments it seems X is chosen unless one of the\n    NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */\n-#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+# define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     if ((_FP_FRAC_HIGH_RAW_##fs(X) |\t\t\t\t\\\n \t _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)\t\t\\\n@@ -114,6 +125,7 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n       }\t\t\t\t\t\t\t\t\\\n     R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n   } while (0)\n+#endif\n \n #ifdef __mips_hard_float\n #define FP_EX_INVALID           0x40"}]}