{"sha": "3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4NmNmZWI0MmUyYTZiYmJlNmVjZGJkZGFjYmYxODJhN2RiODk5YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2011-06-29T14:18:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-06-29T14:18:48Z"}, "message": "unwind-arm.c (enum __cxa_type_match_result): New.\n\n\tgcc/\n\t* config/arm/unwind-arm.c (enum __cxa_type_match_result): New.\n\t(cxa_type_match): Correct declaration.\n\t(__gnu_unwind_pr_common): Reconstruct\n\tadditional indirection when __cxa_type_match returns\n\tsucceeded_with_ptr_to_base.\n\n\tlibstdc++/\n\t* libsupc++/eh_arm.c (__cxa_type_match): Construct address of\n\tthrown object here.  Return succeded_with_ptr_to_base for all\n\tpointer cases.\n\nFrom-SVN: r175641", "tree": {"sha": "8823824b74da8e60cbab15045913ea4c5340cfdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8823824b74da8e60cbab15045913ea4c5340cfdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/comments", "author": null, "committer": null, "parents": [{"sha": "7b37a0c548b633d91e07fbb2c941828aafd5cd3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b37a0c548b633d91e07fbb2c941828aafd5cd3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b37a0c548b633d91e07fbb2c941828aafd5cd3b"}], "stats": {"total": 115, "additions": 75, "deletions": 40}, "files": [{"sha": "bfd808119604e69302f1afc45af3860bb5661672", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "patch": "@@ -1,3 +1,11 @@\n+2011-06-29  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/arm/unwind-arm.c (enum __cxa_type_match_result): New.\n+\t(cxa_type_match): Correct declaration.\n+\t(__gnu_unwind_pr_common): Reconstruct\n+\tadditional indirection when __cxa_type_match returns\n+\tsucceeded_with_ptr_to_base.\n+\n 2011-06-29  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \tPR rtl-optimization/49114"}, {"sha": "90d258d3c807cd2738d4e18f5a45bf5943e49fe3", "filename": "gcc/config/arm/unwind-arm.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/gcc%2Fconfig%2Farm%2Funwind-arm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/gcc%2Fconfig%2Farm%2Funwind-arm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funwind-arm.c?ref=3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "patch": "@@ -32,13 +32,18 @@ extern void abort (void);\n typedef unsigned char bool;\n \n typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */\n+enum __cxa_type_match_result\n+  {\n+    ctm_failed = 0,\n+    ctm_succeeded = 1,\n+    ctm_succeeded_with_ptr_to_base = 2\n+  };\n \n void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);\n bool __attribute__((weak)) __cxa_begin_cleanup(_Unwind_Control_Block *ucbp);\n-bool __attribute__((weak)) __cxa_type_match(_Unwind_Control_Block *ucbp,\n-\t\t\t\t\t    const type_info *rttip,\n-\t\t\t\t\t    bool is_reference,\n-\t\t\t\t\t    void **matched_object);\n+enum __cxa_type_match_result __attribute__((weak)) __cxa_type_match\n+  (_Unwind_Control_Block *ucbp, const type_info *rttip,\n+   bool is_reference, void **matched_object);\n \n _Unwind_Ptr __attribute__((weak))\n __gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);\n@@ -1107,6 +1112,7 @@ __gnu_unwind_pr_common (_Unwind_State state,\n \t\t      _uw rtti;\n \t\t      bool is_reference = (data[0] & uint32_highbit) != 0;\n \t\t      void *matched;\n+\t\t      enum __cxa_type_match_result match_type;\n \n \t\t      /* Check for no-throw areas.  */\n \t\t      if (data[1] == (_uw) -2)\n@@ -1118,17 +1124,31 @@ __gnu_unwind_pr_common (_Unwind_State state,\n \t\t\t{\n \t\t\t  /* Match a catch specification.  */\n \t\t\t  rtti = _Unwind_decode_target2 ((_uw) &data[1]);\n-\t\t\t  if (!__cxa_type_match (ucbp, (type_info *) rtti,\n-\t\t\t\t\t\t is_reference,\n-\t\t\t\t\t\t &matched))\n-\t\t\t    matched = (void *)0;\n+\t\t\t  match_type = __cxa_type_match (ucbp,\n+\t\t\t\t\t\t\t (type_info *) rtti,\n+\t\t\t\t\t\t\t is_reference,\n+\t\t\t\t\t\t\t &matched);\n \t\t\t}\n+\t\t      else\n+\t\t\tmatch_type = ctm_succeeded;\n \n-\t\t      if (matched)\n+\t\t      if (match_type)\n \t\t\t{\n \t\t\t  ucbp->barrier_cache.sp =\n \t\t\t    _Unwind_GetGR (context, R_SP);\n-\t\t\t  ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n+\t\t\t  // ctm_succeeded_with_ptr_to_base really\n+\t\t\t  // means _c_t_m indirected the pointer\n+\t\t\t  // object.  We have to reconstruct the\n+\t\t\t  // additional pointer layer by using a temporary.\n+\t\t\t  if (match_type == ctm_succeeded_with_ptr_to_base)\n+\t\t\t    {\n+\t\t\t      ucbp->barrier_cache.bitpattern[2]\n+\t\t\t\t= (_uw) matched;\n+\t\t\t      ucbp->barrier_cache.bitpattern[0]\n+\t\t\t\t= (_uw) &ucbp->barrier_cache.bitpattern[2];\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n \t\t\t  ucbp->barrier_cache.bitpattern[1] = (_uw) data;\n \t\t\t  return _URC_HANDLER_FOUND;\n \t\t\t}"}, {"sha": "2d10efd3fde9598f8c274e022e90029d6db097de", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "patch": "@@ -1,3 +1,9 @@\n+2011-06-29  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* libsupc++/eh_arm.c (__cxa_type_match): Construct address of\n+\tthrown object here.  Return succeded_with_ptr_to_base for all\n+\tpointer cases.\n+\n 2011-06-23  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* testsuite/tr1/6_containers/tuple/creation_functions/tie2.cc: Fix for"}, {"sha": "e7ba2e54aa092c416cd09058de7121a4414d9db0", "filename": "libstdc++-v3/libsupc++/eh_arm.cc", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc?ref=3a86cfeb42e2a6bbbe6ecdbddacbf182a7db899a", "patch": "@@ -30,62 +30,63 @@\n using namespace __cxxabiv1;\n \n \n-// Given the thrown type THROW_TYPE, pointer to a variable containing a\n-// pointer to the exception object THROWN_PTR_P and a type CATCH_TYPE to\n-// compare against, return whether or not there is a match and if so,\n-// update *THROWN_PTR_P.\n+// Given the thrown type THROW_TYPE, exception object UE_HEADER and a\n+// type CATCH_TYPE to compare against, return whether or not there is\n+// a match and if so, update *THROWN_PTR_P to point to either the\n+// type-matched object, or in the case of a pointer type, the object\n+// pointed to by the pointer.\n \n extern \"C\" __cxa_type_match_result\n __cxa_type_match(_Unwind_Exception* ue_header,\n \t\t const std::type_info* catch_type,\n \t\t bool is_reference __attribute__((__unused__)),\n \t\t void** thrown_ptr_p)\n {\n-  bool forced_unwind = __is_gxx_forced_unwind_class(ue_header->exception_class);\n-  bool foreign_exception = !forced_unwind && !__is_gxx_exception_class(ue_header->exception_class);\n-  bool dependent_exception =\n-    __is_dependent_exception(ue_header->exception_class);\n+  bool forced_unwind\n+    = __is_gxx_forced_unwind_class(ue_header->exception_class);\n+  bool foreign_exception\n+    = !forced_unwind && !__is_gxx_exception_class(ue_header->exception_class);\n+  bool dependent_exception\n+    = __is_dependent_exception(ue_header->exception_class);\n   __cxa_exception* xh = __get_exception_header_from_ue(ue_header);\n   __cxa_dependent_exception *dx = __get_dependent_exception_from_ue(ue_header);\n   const std::type_info* throw_type;\n+  void *thrown_ptr = 0;\n \n   if (forced_unwind)\n     throw_type = &typeid(abi::__forced_unwind);\n   else if (foreign_exception)\n     throw_type = &typeid(abi::__foreign_exception);\n-  else if (dependent_exception)\n-    throw_type = __get_exception_header_from_obj\n-      (dx->primaryException)->exceptionType;\n   else\n-    throw_type = xh->exceptionType;\n-\n-  void* thrown_ptr = *thrown_ptr_p;\n+    {\n+      if (dependent_exception)\n+\txh = __get_exception_header_from_obj (dx->primaryException);\n+      throw_type = xh->exceptionType;\n+      // We used to require the caller set the target of thrown_ptr_p,\n+      // but that's incorrect -- the EHABI makes no such requirement\n+      // -- and not all callers will set it.  Fortunately callers that\n+      // do initialize will always pass us the value we calculate\n+      // here, so there's no backwards compatibility problem.\n+      thrown_ptr = __get_object_from_ue (ue_header);\n+    }\n+  \n+  __cxa_type_match_result result = ctm_succeeded;\n \n   // Pointer types need to adjust the actual pointer, not\n   // the pointer to pointer that is the exception object.\n   // This also has the effect of passing pointer types\n   // \"by value\" through the __cxa_begin_catch return value.\n   if (throw_type->__is_pointer_p())\n-    thrown_ptr = *(void**) thrown_ptr;\n+    {\n+      thrown_ptr = *(void**) thrown_ptr;\n+      // We need to indicate the indirection to our caller.\n+      result = ctm_succeeded_with_ptr_to_base;\n+    }\n \n   if (catch_type->__do_catch(throw_type, &thrown_ptr, 1))\n     {\n       *thrown_ptr_p = thrown_ptr;\n-\n-      if (typeid(*catch_type) == typeid (typeid(void*)))\n-\t{\n-\t  const __pointer_type_info *catch_pointer_type =\n-\t    static_cast<const __pointer_type_info *> (catch_type);\n-\t  const __pointer_type_info *throw_pointer_type =\n-\t    static_cast<const __pointer_type_info *> (throw_type);\n-\n-\t  if (typeid (*catch_pointer_type->__pointee) != typeid (void)\n-\t      && (*catch_pointer_type->__pointee != \n-\t\t  *throw_pointer_type->__pointee))\n-\t    return ctm_succeeded_with_ptr_to_base;\n-\t}\n-\n-      return ctm_succeeded;\n+      return result;\n     }\n \n   return ctm_failed;"}]}