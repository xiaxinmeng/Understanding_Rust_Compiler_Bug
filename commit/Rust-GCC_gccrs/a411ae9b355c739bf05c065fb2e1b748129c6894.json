{"sha": "a411ae9b355c739bf05c065fb2e1b748129c6894", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxMWFlOWIzNTVjNzM5YmYwNWMwNjVmYjJlMWI3NDgxMjljNjg5NA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-03-22T02:58:27Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-03-22T02:58:27Z"}, "message": "PR tree-optimization/89350 - Wrong -Wstringop-overflow= warning since r261518\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/89350\n\t* builtins.c (compute_objsize): Also ignore offsets whose upper\n\tbound is negative.\n\t* gimple-ssa-warn-restrict.c (builtin_memref): Add new member.\n\t(builtin_memref::builtin_memref): Initialize new member.\n\tAllow EXPR to be null.\n\t(builtin_memref::extend_offset_range): Replace local with a member.\n\tAvoid assuming pointer offsets are unsigned.\n\t(builtin_memref::set_base_and_offset): Determine base object\n\tbefore computing offset range.\n\t(builtin_access::builtin_access): Handle memset.\n\t(builtin_access::generic_overlap): Replace local with a member.\n\t(builtin_access::strcat_overlap): Same.\n\t(builtin_access::overlap): Same.\n\t(maybe_diag_overlap): Same.\n\t(maybe_diag_access_bounds): Same.\n\t(wrestrict_dom_walker::check_call): Handle memset.\n\t(check_bounds_or_overlap): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/89350\n\t* gcc.dg/Wstringop-overflow.c: Xfail overly ambitious tests.\n\t* gcc.dg/Wstringop-overflow-11.c: New test.\n\t* gcc.dg/Wstringop-overflow-12.c: New test.\n\t* gcc.dg/pr89350.c: New test.\n\t* gcc.dg/pr40340-1.c: Adjust expected warning.\n\t* gcc.dg/pr40340-2.c: Same.\n\t* gcc.dg/pr40340-4.c: Same.\n\t* gcc.dg/pr40340-5.c: Same.\n\nFrom-SVN: r269867", "tree": {"sha": "723e683acd41429480a4088f1a2c2804fe47ebd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/723e683acd41429480a4088f1a2c2804fe47ebd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a411ae9b355c739bf05c065fb2e1b748129c6894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a411ae9b355c739bf05c065fb2e1b748129c6894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a411ae9b355c739bf05c065fb2e1b748129c6894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a411ae9b355c739bf05c065fb2e1b748129c6894/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11bf9a075a2d6ba4ee668e785fd2c478fa32f421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11bf9a075a2d6ba4ee668e785fd2c478fa32f421", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11bf9a075a2d6ba4ee668e785fd2c478fa32f421"}], "stats": {"total": 652, "additions": 600, "deletions": 52}, "files": [{"sha": "10aa8e5cfd6705b1ff734bd93a6c17aff96cf2ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -1,3 +1,24 @@\n+2019-03-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/89350\n+\t* builtins.c (compute_objsize): Also ignore offsets whose upper\n+\tbound is negative.\n+\t* gimple-ssa-warn-restrict.c (builtin_memref): Add new member.\n+\t(builtin_memref::builtin_memref): Initialize new member.\n+\tAllow EXPR to be null.\n+\t(builtin_memref::extend_offset_range): Replace local with a member.\n+\tAvoid assuming pointer offsets are unsigned.\n+\t(builtin_memref::set_base_and_offset): Determine base object\n+\tbefore computing offset range.\n+\t(builtin_access::builtin_access): Handle memset.\n+\t(builtin_access::generic_overlap): Replace local with a member.\n+\t(builtin_access::strcat_overlap): Same.\n+\t(builtin_access::overlap): Same.\n+\t(maybe_diag_overlap): Same.\n+\t(maybe_diag_access_bounds): Same.\n+\t(wrestrict_dom_walker::check_call): Handle memset.\n+\t(check_bounds_or_overlap): Same.\n+\n 2019-03-21  Jan Hubicka  <hubicka@ucw.cz>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "daf5830011f85f38a131afd15e72aa0d30cc2d39", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -3650,7 +3650,8 @@ compute_objsize (tree dest, int ostype)\n \t\t      /* Ignore negative offsets for now.  For others,\n \t\t\t use the lower bound as the most optimistic\n \t\t\t estimate of the (remaining)size.  */\n-\t\t      if (wi::sign_mask (min))\n+\t\t      if (wi::sign_mask (min)\n+\t\t\t  || wi::sign_mask (max))\n \t\t\t;\n \t\t      else if (wi::ltu_p (min, wisiz))\n \t\t\treturn wide_int_to_tree (TREE_TYPE (size),"}, {"sha": "4ebe99fe7a225f66bea2baf865c893603364c973", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 94, "deletions": 40, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -147,6 +147,9 @@ struct builtin_memref\n   /* The size range of the access to this reference.  */\n   offset_int sizrange[2];\n \n+  /* Cached result of get_max_objsize().  */\n+  const offset_int maxobjsize;\n+\n   /* True for \"bounded\" string functions like strncat, and strncpy\n      and their variants that specify either an exact or upper bound\n      on the size of the accesses they perform.  For strncat both\n@@ -233,14 +236,16 @@ builtin_memref::builtin_memref (tree expr, tree size)\n   refoff (HOST_WIDE_INT_MIN),\n   offrange (),\n   sizrange (),\n+  maxobjsize (tree_to_shwi (max_object_size ())),\n   strbounded_p ()\n {\n   /* Unfortunately, wide_int default ctor is a no-op so array members\n      of the type must be set individually.  */\n   offrange[0] = offrange[1] = 0;\n   sizrange[0] = sizrange[1] = 0;\n \n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  if (!expr)\n+    return;\n \n   /* Find the BASE object or pointer referenced by EXPR and set\n      the offset range OFFRANGE in the process.  */\n@@ -292,13 +297,13 @@ builtin_memref::builtin_memref (tree expr, tree size)\n     }\n }\n \n-/* Ctor helper to set or extend OFFRANGE based on the OFFSET argument.  */\n+/* Ctor helper to set or extend OFFRANGE based on the OFFSET argument.\n+   Pointer offsets are represented as unsigned sizetype but must be\n+   treated as signed.  */\n \n void\n builtin_memref::extend_offset_range (tree offset)\n {\n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n-\n   if (TREE_CODE (offset) == INTEGER_CST)\n     {\n       offset_int off = int_cst_value (offset);\n@@ -312,36 +317,57 @@ builtin_memref::extend_offset_range (tree offset)\n \n   if (TREE_CODE (offset) == SSA_NAME)\n     {\n+      /* A pointer offset is represented as sizetype but treated\n+\t as signed.  */\n       wide_int min, max;\n       value_range_kind rng = get_range_info (offset, &min, &max);\n-      if (rng == VR_RANGE)\n+      if (rng == VR_ANTI_RANGE && wi::lts_p (max, min))\n+\t{\n+\t  /* Convert an anti-range whose upper bound is less than\n+\t     its lower bound to a signed range.  */\n+\t  offrange[0] += offset_int::from (max + 1, SIGNED);\n+\t  offrange[1] += offset_int::from (min - 1, SIGNED);\n+\t  return;\n+\t}\n+\n+      if (rng == VR_RANGE\n+\t  && (DECL_P (base) || wi::lts_p (min, max)))\n \t{\n+\t  /* Preserve the bounds of the range for an offset into\n+\t     a known object (it may be adjusted later relative to\n+\t     a constant offset from its beginning).  Otherwise use\n+\t     the bounds only when they are ascending when treated\n+\t     as signed.  */\n \t  offrange[0] += offset_int::from (min, SIGNED);\n \t  offrange[1] += offset_int::from (max, SIGNED);\n+\t  return;\n \t}\n-      else\n+\n+      /* Handle an anti-range the same as no range at all.  */\n+      gimple *stmt = SSA_NAME_DEF_STMT (offset);\n+      tree type;\n+      if (is_gimple_assign (stmt)\n+\t  && (type = TREE_TYPE (gimple_assign_rhs1 (stmt)))\n+\t  && INTEGRAL_TYPE_P (type))\n \t{\n-\t  /* Handle an anti-range the same as no range at all.  */\n-\t  gimple *stmt = SSA_NAME_DEF_STMT (offset);\n-\t  tree type;\n-\t  if (is_gimple_assign (stmt)\n-\t      && gimple_assign_rhs_code (stmt) == NOP_EXPR\n-\t      && (type = TREE_TYPE (gimple_assign_rhs1 (stmt)))\n-\t      && INTEGRAL_TYPE_P (type))\n+\t  tree_code code = gimple_assign_rhs_code (stmt);\n+\t  if (code == NOP_EXPR)\n \t    {\n \t      /* Use the bounds of the type of the NOP_EXPR operand\n \t\t even if it's signed.  The result doesn't trigger\n \t\t warnings but makes their output more readable.  */\n \t      offrange[0] += wi::to_offset (TYPE_MIN_VALUE (type));\n \t      offrange[1] += wi::to_offset (TYPE_MAX_VALUE (type));\n+\t      return;\n \t    }\n-\t  else\n-\t    offrange[1] += maxobjsize;\n \t}\n-      return;\n     }\n \n-  offrange[1] += maxobjsize;\n+  const offset_int maxoff = tree_to_shwi (max_object_size ()) >> 1;\n+  const offset_int minoff = -maxoff - 1;\n+\n+  offrange[0] += minoff;\n+  offrange[1] += maxoff;\n }\n \n /* Determines the base object or pointer of the reference EXPR\n@@ -350,7 +376,7 @@ builtin_memref::extend_offset_range (tree offset)\n void\n builtin_memref::set_base_and_offset (tree expr)\n {\n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  tree offset = NULL_TREE;\n \n   if (TREE_CODE (expr) == SSA_NAME)\n     {\n@@ -377,9 +403,7 @@ builtin_memref::set_base_and_offset (tree expr)\n \t  else if (code == POINTER_PLUS_EXPR)\n \t    {\n \t      expr = gimple_assign_rhs1 (stmt);\n-\n-\t      tree offset = gimple_assign_rhs2 (stmt);\n-\t      extend_offset_range (offset);\n+\t      offset = gimple_assign_rhs2 (stmt);\n \t    }\n \t  else\n \t    {\n@@ -389,6 +413,12 @@ builtin_memref::set_base_and_offset (tree expr)\n \t}\n       else\n \t{\n+\t  /* FIXME: Handle PHI nodes in case like:\n+\t     _12 = &MEM[(void *)&a + 2B] + _10;\n+\n+\t     <bb> [local count: 1073741824]:\n+\t     # prephitmp_13 = PHI <_12, &MEM[(void *)&a + 2B]>\n+\t     memcpy (prephitmp_13, p_7(D), 6);  */\n \t  base = expr;\n \t  return;\n \t}\n@@ -416,6 +446,9 @@ builtin_memref::set_base_and_offset (tree expr)\n   /* get_inner_reference is not expected to return null.  */\n   gcc_assert (base != NULL);\n \n+  if (offset)\n+    extend_offset_range (offset);\n+\n   poly_int64 bytepos = exact_div (bitpos, BITS_PER_UNIT);\n \n   /* Convert the poly_int64 offset to offset_int.  The offset\n@@ -471,7 +504,8 @@ builtin_memref::set_base_and_offset (tree expr)\n tree\n builtin_memref::offset_out_of_bounds (int strict, offset_int ooboff[2]) const\n {\n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  if (!ptr)\n+    return NULL_TREE;\n \n   /* A temporary, possibly adjusted, copy of the offset range.  */\n   offset_int offrng[2] = { offrange[0], offrange[1] };\n@@ -606,6 +640,14 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n       detect_overlap = &builtin_access::no_overlap;\n       break;\n \n+    case BUILT_IN_MEMSET:\n+    case BUILT_IN_MEMSET_CHK:\n+      /* For memset there is never any overlap to check for.  */\n+      ostype = 0;\n+      depends_p = false;\n+      detect_overlap = &builtin_access::no_overlap;\n+      break;\n+\n     case BUILT_IN_STPNCPY:\n     case BUILT_IN_STPNCPY_CHK:\n     case BUILT_IN_STRNCPY:\n@@ -640,7 +682,7 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n       return;\n     }\n \n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  const offset_int maxobjsize = dst.maxobjsize;\n \n   /* Try to determine the size of the base object.  compute_objsize\n      expects a pointer so create one if BASE is a non-pointer object.  */\n@@ -659,7 +701,7 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \tdst.basesize = maxobjsize;\n     }\n \n-  if (src.basesize < 0)\n+  if (src.base && src.basesize < 0)\n     {\n       addr = src.base;\n       if (!POINTER_TYPE_P (TREE_TYPE (addr)))\n@@ -845,7 +887,7 @@ builtin_access::generic_overlap ()\n \n   gcc_assert (dstref->base == srcref->base);\n \n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  const offset_int maxobjsize = acs.dstref->maxobjsize;\n \n   offset_int maxsize = dstref->basesize < 0 ? maxobjsize : dstref->basesize;\n   gcc_assert (maxsize <= maxobjsize);\n@@ -1054,7 +1096,7 @@ builtin_access::strcat_overlap ()\n \n   gcc_assert (dstref->base == srcref->base);\n \n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  const offset_int maxobjsize = acs.dstref->maxobjsize;\n \n   gcc_assert (dstref->base && dstref->base == srcref->base);\n \n@@ -1191,7 +1233,7 @@ builtin_access::overlap ()\n {\n   builtin_access &acs = *this;\n \n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  const offset_int maxobjsize = dstref->maxobjsize;\n \n   acs.sizrange[0] = wi::smax (dstref->sizrange[0],\n \t\t\t      srcref->sizrange[0]).to_shwi ();\n@@ -1372,7 +1414,7 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n \t     \"[\" HOST_WIDE_INT_PRINT_DEC \", \" HOST_WIDE_INT_PRINT_DEC \"]\",\n \t     ovloff[0], ovloff[1]);\n \n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  const offset_int maxobjsize = dstref.maxobjsize;\n   bool must_overlap = ovlsiz[0] > 0;\n \n   if (ovlsiz[1] == 0)\n@@ -1581,7 +1623,7 @@ static bool\n maybe_diag_access_bounds (location_t loc, gimple *call, tree func, int strict,\n \t\t\t  const builtin_memref &ref, bool do_warn)\n {\n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  const offset_int maxobjsize = ref.maxobjsize;\n \n   /* Check for excessive size first and regardless of warning options\n      since the result is used to make codegen decisions.  */\n@@ -1690,8 +1732,6 @@ maybe_diag_access_bounds (location_t loc, gimple *call, tree func, int strict,\n     }\n   else if (oobref == ref.base)\n     {\n-      const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n-\n       /* True when the offset formed by an access to the reference\n \t is out of bounds, rather than the initial offset wich is\n \t in bounds.  This implies access past the end.  */\n@@ -1814,6 +1854,12 @@ wrestrict_dom_walker::check_call (gimple *call)\n       bnd_idx = 2;\n       break;\n \n+    case BUILT_IN_MEMSET:\n+    case BUILT_IN_MEMSET_CHK:\n+      dst_idx = 0;\n+      bnd_idx = 2;\n+      break;\n+\n     case BUILT_IN_STPCPY:\n     case BUILT_IN_STPCPY_CHK:\n     case BUILT_IN_STRCPY:\n@@ -1844,14 +1890,14 @@ wrestrict_dom_walker::check_call (gimple *call)\n \n   /* DST and SRC can be null for a call with an insufficient number\n      of arguments to a built-in function declared without a protype.  */\n-  if (!dst || !src)\n+  if (!dst || (src_idx < nargs && !src))\n     return;\n \n   /* DST, SRC, or DSTWR can also have the wrong type in a call to\n      a function declared without a prototype.  Avoid checking such\n      invalid calls.  */\n   if (TREE_CODE (TREE_TYPE (dst)) != POINTER_TYPE\n-      || TREE_CODE (TREE_TYPE (src)) != POINTER_TYPE\n+      || (src && TREE_CODE (TREE_TYPE (src)) != POINTER_TYPE)\n       || (dstwr && !INTEGRAL_TYPE_P (TREE_TYPE (dstwr))))\n     return;\n \n@@ -1901,15 +1947,23 @@ check_bounds_or_overlap (gimple *call, tree dst, tree src, tree dstsize,\n       return OPT_Warray_bounds;\n     }\n \n-  bool check_overlap\n-    = (warn_restrict\n-       && (bounds_only\n-\t   || (DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE\n-\t       && DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE_CHK)));\n-\n-  if (!check_overlap)\n+  if (!warn_restrict || bounds_only || !src)\n     return 0;\n \n+  if (!bounds_only)\n+    {\n+      switch (DECL_FUNCTION_CODE (func))\n+\t{\n+\tcase BUILT_IN_MEMMOVE:\n+\tcase BUILT_IN_MEMMOVE_CHK:\n+\tcase BUILT_IN_MEMSET:\n+\tcase BUILT_IN_MEMSET_CHK:\n+\t  return 0;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n   if (operand_equal_p (dst, src, 0))\n     {\n       /* Issue -Wrestrict unless the pointers are null (those do"}, {"sha": "076f79537f5a01eefe2c6f7f195ae06375626630", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -1,3 +1,16 @@\n+2019-03-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/89350\n+\t* gcc.dg/Warray-bounds-40.c: Remove an xfail.\n+\t* gcc.dg/Wstringop-overflow.c: Xfail overly ambitious tests.\n+\t* gcc.dg/Wstringop-overflow-11.c: New test.\n+\t* gcc.dg/Wstringop-overflow-12.c: New test.\n+\t* gcc.dg/pr89350.c: New test.\n+\t* gcc.dg/pr40340-1.c: Adjust expected warning.\n+\t* gcc.dg/pr40340-2.c: Same.\n+\t* gcc.dg/pr40340-4.c: Same.\n+\t* gcc.dg/pr40340-5.c: Same.\n+\n 2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR lto/89692"}, {"sha": "aabc2832b3a456eb614b5008dc4eea5513e6014b", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-40.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-40.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -42,7 +42,7 @@ void test_memmove (void)\n \n void test_memset (void)\n {\n-  memset (d, 0, SIZE_MAX - 2);    /* { dg-warning \".memset. pointer overflow between offset 0 and size \\[0-9\\]+ \\\\\\[-Warray-bounds\" \"bug\" { xfail *-*-* } } */\n+  memset (d, 0, SIZE_MAX - 2);    /* { dg-warning \".memset. pointer overflow between offset 0 and size \\[0-9\\]+ \\\\\\[-Warray-bounds\" } */\n }\n \n "}, {"sha": "f5dac458d1ea616fc2e8668a59588cb6cdfa433a", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-11.c", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -0,0 +1,321 @@\n+/* PR tree-optimization/89350 - Wrong -Wstringop-overflow warning\n+   on a variable offset from the end of an array\n+   Test exercising -Wstringop-truncation with -Wall.\n+   -Wstringop-truncation is disabled to avoid warnings for strncpy\n+   calls whose bound matches the size of the destination getting\n+   in the way of -Wstringop-overflow.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-stringop-truncation -ftrack-macro-expansion=0\" }  */\n+\n+#include \"range.h\"\n+\n+extern void* memcpy (void*, const void*, size_t);\n+extern void* memset (void*, int, size_t);\n+extern char* strcpy (char*, const char*);\n+extern char* strncpy (char*, const char*, size_t);\n+\n+void sink (void*);\n+\n+#define CAT(pfx, line) pfx ## line\n+#define CONCAT(pfx, line) CAT (pfx, line)\n+#define UNIQ_NAME(pfx) CONCAT (pfx, __LINE__)\n+\n+/* Exercise a call to memset with a distinct destination object each\n+   time to prevent GCC from reusing the destination pointer in later\n+   tests.  */\n+#define T(off1, off2, n)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern char UNIQ_NAME (ga)[7];\t\t\\\n+    char *d = UNIQ_NAME (ga) + off1;\t\t\\\n+    d += off2;\t\t\t\t\t\\\n+    memset (d, 0, n);\t\t\t\t\\\n+    sink (d);\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* Exercise calls to memset with a destination pointer pointing to\n+   an array plus constant offset plus variable offset, in that order.  */\n+\n+void test_memset_array_cst_range_off (void)\n+{\n+  T (1, SR (-7, 7), 7);\n+  T (1, SR (-1, 1), 7);\n+  T (1, SR (-1, 1), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (1, SR ( 1, 2), 1);\n+  T (1, SR ( 1, 2), 5);\n+\n+  T (1, SR ( 0, 1), 6);\n+  T (1, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR (-7, 7), 7);\n+  T (2, SR (-2, 7), 7);\n+  T (2, SR (-1, 1), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR (-1, 1), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR ( 1, 2), 1);\n+  T (2, SR ( 1, 2), 3);\n+  T (2, SR ( 1, 2), 4);\n+  T (2, SR ( 1, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-7, 0), 7);\n+  T (7, UR (-7, 0), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-3, 2), 3);\n+  T (7, UR (-2, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+/* Exercise calls to memset with a destination pointer pointing to\n+   an array plus variable offset plus constant offset.  */\n+\n+void test_memset_array_range_cst_off (void)\n+{\n+  T (SR (-7, 7), 1, 7);\n+  T (SR (-1, 1), 1, 7);\n+  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR ( 1, 2), 1, 1);\n+  T (SR ( 1, 2), 1, 5);\n+\n+  T (SR ( 0, 1), 1, 6);\n+  T (UR ( 1, 2), 1, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR (-7, 7), 2, 7);\n+  T (SR (-1, 1), 2, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR (-1, 1), 2, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR ( 1, 2), 2, 1);\n+  T (SR ( 1, 2), 2, 3);\n+  T (SR ( 1, 2), 2, 4);\n+  T (SR ( 1, 2), 2, 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR ( 0, 1), 2, 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (UR ( 1, 2), 2, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_memset_array_range_range_off (void)\n+{\n+  T (UR (0, 1), UR (0, 1), 7);\n+  T (UR (3, 5), UR (2, 7), 1);\n+  T (UR (3, 7), UR (2, 9), 2);\n+  T (UR (3, 9), UR (2, 9), 3);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (UR (0, 1), UR (1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+#undef T\n+#define T(off1, off2, n)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern char UNIQ_NAME (ga)[7];\t\t\\\n+    char *d = UNIQ_NAME (ga) + off1;\t\t\\\n+    d += off2;\t\t\t\t\t\\\n+    memcpy (d, s, n);\t\t\t\t\\\n+    sink (d);\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+void test_memcpy_array_cst_range_off (const void *s)\n+{\n+  T (1, SR (-7, 7), 7);\n+  T (1, SR (-1, 1), 7);\n+  T (1, SR (-1, 1), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (1, SR ( 1, 2), 1);\n+  T (1, SR ( 1, 2), 5);\n+\n+  T (1, SR ( 0, 1), 6);\n+  T (1, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR (-7, 7), 7);\n+  T (2, SR (-2, 7), 7);\n+  T (2, SR (-1, 1), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR (-1, 1), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR ( 1, 2), 1);\n+  T (2, SR ( 1, 2), 3);\n+  T (2, SR ( 1, 2), 4);\n+  T (2, SR ( 1, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-7, 0), 7);\n+  T (7, UR (-7, 0), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-3, 2), 3);\n+  T (7, UR (-2, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_memcpy_array_range_cst_off (const void *s)\n+{\n+  T (SR (-7, 7), 1, 7);\n+  T (SR (-1, 1), 1, 7);\n+  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR ( 1, 2), 1, 1);\n+  T (SR ( 1, 2), 1, 5);\n+\n+  T (SR ( 0, 1), 1, 6);\n+  T (UR ( 1, 2), 1, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR (-7, 7), 2, 7);\n+  T (SR (-1, 1), 2, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR (-1, 1), 2, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR ( 1, 2), 2, 1);\n+  T (SR ( 1, 2), 2, 3);\n+  T (SR ( 1, 2), 2, 4);\n+  T (SR ( 1, 2), 2, 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR ( 0, 1), 2, 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (UR ( 1, 2), 2, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_memcpy_array_range_range_off (const void *s)\n+{\n+  T (UR (0, 1), UR (0, 1), 7);\n+  T (UR (3, 5), UR (2, 7), 1);\n+  T (UR (3, 7), UR (2, 9), 2);\n+  T (UR (3, 9), UR (2, 9), 3);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (UR (0, 1), UR (1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+#undef T\n+#define T(off1, off2, n)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern char UNIQ_NAME (ga)[7];\t\t\\\n+    char *d = UNIQ_NAME (ga) + off1;\t\t\\\n+    d += off2;\t\t\t\t\t\\\n+    const char str[] = \"0123456789\";\t\t\\\n+    const char *s = str + sizeof str - 1 - n;   \\\n+    strcpy (d, s);\t\t\t\t\\\n+    sink (d);\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+void test_strcpy_array_cst_range_off (void)\n+{\n+  T (1, SR (-7, 7), 6);\n+  T (1, SR (-1, 1), 6);\n+  T (1, SR (-1, 1), 8);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (1, SR ( 1, 2), 0);\n+  T (1, SR ( 1, 2), 4);\n+\n+  T (1, SR ( 0, 1), 5);\n+  T (1, UR ( 1, 2), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR (-7, 7), 6);\n+  T (2, SR (-2, 7), 6);\n+  T (2, SR (-1, 1), 6);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR (-1, 1), 8);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR ( 1, 2), 0);\n+  T (2, SR ( 1, 2), 2);\n+  T (2, SR ( 1, 2), 3);\n+  T (2, SR ( 1, 2), 4);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR ( 0, 1), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, UR ( 1, 2), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-7, 0), 6);\n+  T (7, UR (-7, 0), 8);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-3, 2), 2);\n+  T (7, UR (-2, 2), 4);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_strcpy_array_range_cst_off (const char *s)\n+{\n+  T (SR (-7, 7), 1, 6);\n+  T (SR (-1, 1), 1, 6);\n+  T (SR (-1, 1), 1, 8);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR ( 1, 2), 1, 0);\n+  T (SR ( 1, 2), 1, 1);\n+  T (SR ( 1, 2), 1, 4);\n+\n+  T (SR ( 0, 1), 1, 5);\n+  T (UR ( 1, 2), 1, 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR (-7, 7), 2, 6);\n+  T (SR (-1, 1), 2, 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR (-1, 1), 2, 8);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR ( 1, 2), 2, 0);\n+  T (SR ( 1, 2), 2, 1);\n+  T (SR ( 1, 2), 2, 2);\n+  T (SR ( 1, 2), 2, 3);\n+  T (SR ( 1, 2), 2, 4);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR ( 0, 1), 2, 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (UR ( 1, 2), 2, 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+#undef T\n+#define T(off1, off2, n)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern char UNIQ_NAME (ga)[7];\t\t\\\n+    char *d = UNIQ_NAME (ga) + off1;\t\t\\\n+    d += off2;\t\t\t\t\t\\\n+    strncpy (d, s, n);\t\t\t\t\\\n+    sink (d);\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+void test_strncpy_array_cst_range_off (const char *s)\n+{\n+  T (1, SR (-7, 7), 7);\n+  T (1, SR (-1, 1), 7);\n+  T (1, SR (-1, 1), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (1, SR ( 1, 2), 1);\n+  T (1, SR ( 1, 2), 5);\n+\n+  T (1, SR ( 0, 1), 6);\n+  T (1, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR ( -7, 7), 7);\n+  T (2, SR ( -1, 1), 7);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR ( -1, 1), 9);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (2, SR ( 1, 2), 1);\n+  T (2, SR ( 1, 2), 3);\n+  T (2, SR ( 1, 2), 4);\n+  T (2, SR ( 1, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-7, 0), 7);\n+  T (7, UR (-7, 0), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (7, UR (-3, 2), 3);\n+  T (7, UR (-2, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_strncpy_array_range_cst_off (const char *s)\n+{\n+  T (SR (-7, 7), 1, 7);\n+  T (SR (-1, 1), 1, 7);\n+  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR ( 1, 2), 1, 1);\n+  T (SR ( 1, 2), 1, 5);\n+\n+  T (SR ( 0, 1), 1, 6);\n+  T (UR ( 1, 2), 1, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR (-7, 7), 2, 7);\n+  T (SR (-1, 1), 2, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR (-1, 1), 2, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (SR ( 1, 2), 2, 1);\n+  T (SR ( 1, 2), 2, 3);\n+  T (SR ( 1, 2), 2, 4);\n+  T (SR ( 1, 2), 2, 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (SR ( 0, 1), 2, 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+\n+  T (UR ( 1, 2), 2, 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_strncpy_array_range_range_off (const char *s)\n+{\n+  T (UR (0, 1), UR (0, 1), 7);\n+  T (UR (3, 5), UR (2, 7), 1);\n+  T (UR (3, 7), UR (2, 9), 2);\n+  T (UR (3, 9), UR (2, 9), 3);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  T (UR (0, 1), UR (1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}"}, {"sha": "04fa114f48cbe625918fa9f0e271f5da74edf016", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-12.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -0,0 +1,120 @@\n+/* PR tree-optimization/89350 - Wrong -Wstringop-overflow warning\n+   on a variable offset from the end of an array\n+   Test exercising -Wstringop-truncation alone, with -Warray-bounds\n+   explicitly disabled.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wno-array-bounds -Wstringop-overflow -ftrack-macro-expansion=0\" }  */\n+\n+#include \"range.h\"\n+\n+extern void* memcpy (void*, const void*, size_t);\n+extern void* memset (void*, int, size_t);\n+\n+void sink (void*);\n+\n+extern char ga7[7];\n+\n+\n+#define T(d, n) (memcpy ((d), s, (n)), sink (d))\n+\n+void test_memcpy_array_cst_range_off (const void *s)\n+{\n+  char *d = ga7 + 1;\n+\n+  T (d + UR (1, 2), 1);\n+  T (d + UR (1, 2), 5);\n+\n+  T (d + UR (0, 1), 6);\n+  T (d + UR (0, 1), 7);       /* { dg-warning \".memcpy. writing 6 bytes into a region of size 5 overflows the destination\" \"pr89428\" { xfail *-*-* } } */\n+  T (d + UR (1, 2), 6);       /* { dg-warning \".memcpy. writing 6 bytes into a region of size 5 overflows the destination\" } */\n+  T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n+\n+  T (d + SR (-3, -2), 1);     /* { dg-warning \"writing 1 byte into a region of size 0 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 1);\n+  T (d + SR (-2, -1), 2);     /* { dg-warning \"writing 2 bytes into a region of size 7 \" \"pr89428\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 9);     /* { dg-warning \"writing 9 bytes into a region of size 7 \" \"pr85350\" { xfail *-*-* } } */\n+\n+  d = ga7 + 7;\n+  T (d + SR (-7, -6), 1);\n+  T (d + SR (-7, -1), 1);\n+  T (d + SR (-2, -1), 3);     /* { dg-warning \"writing 3 bytes into a region of size 2 \" \"pr85350\" { xfail *-*-* } } */\n+\n+  T (d + UR (1, 2), 1);       /* { dg-warning \"writing 1 byte into a region of size 0 \" \"pr89350\" { xfail *-*-* } } */\n+}\n+\n+\n+void test_memcpy_array_range_range_off (const void *s)\n+{\n+  char *d = ga7 + UR (0, 1);\n+  T (d + SR (-1, 0), 1);\n+  T (d + SR (-1, 0), 7);\n+  T (d + SR (-1, 0), 9);       /* { dg-warning \"writing 1 byte into a region of size 0 \" \"pr89350\" { xfail *-*-* } } */\n+}\n+\n+\n+#undef T\n+#define T(d, n) (memset ((d), 0, (n)), sink (d))\n+\n+void test_memset_array_unsigned_off (void)\n+{\n+  char *d = ga7 + 1;\n+\n+  T (d + UR (1, 2), 1);\n+  T (d + UR (1, 2), 5);\n+\n+  T (d + UR (0, 1), 6);\n+  T (d + UR (0, 1), 7);       /* { dg-warning \".memset. writing 6 bytes into a region of size 5 overflows the destination\" \"pr89428\" { xfail *-*-* } } */\n+  T (d + UR (1, 2), 6);       /* { dg-warning \".memset. writing 6 bytes into a region of size 5 overflows the destination\" } */\n+  T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n+\n+  T (d + SR (-3, -2), 1);     /* { dg-warning \"writing 1 byte into a region of size 0 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 1);\n+  T (d + SR (-2, -1), 2);     /* { dg-warning \"writing 2 bytes into a region of size 7 \" \"pr89428\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 9);     /* { dg-warning \"writing 9 bytes into a region of size 7 \" \"pr85350\" { xfail *-*-* } } */\n+\n+  d = ga7 + 7;\n+  T (d + SR (-7, -6), 1);\n+  T (d + SR (-7, -1), 1);\n+  T (d + SR (-2, -1), 3);     /* { dg-warning \"writing 3 bytes into a region of size 2 \" \"pr85350\" { xfail *-*-* } } */\n+\n+  T (d + UR (1, 2), 1);       /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n+}\n+\n+\n+\n+struct MemArray { char a7[7], a3[3], c; };\n+\n+extern struct MemArray gma;\n+\n+void test_memset_memarray (void)\n+{\n+  char *d = gma.a7 + 1;\n+\n+  T (d + UR (1, 2), 1);\n+  T (d + UR (1, 2), 5);\n+\n+  T (d + UR (0, 1), 6);\n+  T (d + UR (0, 1), 7);       /* { dg-warning \".memset. writing 6 bytes into a region of size 5 overflows the destination\" \"pr89428\" { xfail *-*-* } } */\n+  T (d + UR (1, 2), 6);       /* { dg-warning \".memset. writing 6 bytes into a region of size 5 overflows the destination\" \"pr89350\" { xfail *-*-* } } */\n+  T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" \"pr85350\" { xfail *-*-* } } */\n+\n+}\n+\n+\n+#undef T\n+#define T(d, n) (memcpy ((d), s, (n)), sink (d))\n+\n+void test_memcpy_array_signed_off (const void *s)\n+{\n+  char *d = ga7 + 1;\n+\n+  T (d + SR (-7, 7), 7);\n+  T (d + SR (-1, 1), 7);\n+  T (d + SR (-1, 1), 9);      /* { dg-warning \"writing 9 bytes into a region of size \" \"pr89428\" { xfail *-*-* } } */\n+  T (d + SR (-1, 2), 9);      /* { dg-warning \"writing 9 bytes into a region of size \" \"pr89428\" { xfail *-*-* } } */\n+  T (d + SR (1, 2), 1);\n+  T (d + SR (1, 2), 5);\n+\n+  T (d + SR (0, 1), 6);\n+  T (d + UR (1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+}"}, {"sha": "2c5f4f05254c1e602d7915699e2f7a617c5efd7f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -51,8 +51,8 @@ void test_memcpy_array (const void *s)\n   T (a7 + UR (8, 9), s, 7);   /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n \n   T (a7 + UR (9, 10), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n-  T (a7 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n-  T (a7 + UR (DIFF_MAX, SIZE_MAX), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" \"pr85350\" { xfail *-*-* } } */\n+  T (a7 + UR (DIFF_MAX, SIZE_MAX), s, 7);  /* { dg-warning \"writing 7 bytes into a region of size 0\" \"pr85350\" { xfail *-*-*} } */\n \n   /* This is valid.  */\n   char *d = a7 + 7;\n@@ -102,8 +102,8 @@ void test_strcpy_array (void)\n   T (a7 + UR (8, 9), \"012345\");   /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n \n   T (a7 + UR (9, 10), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n-  T (a7 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n-  T (a7 + UR (DIFF_MAX, SIZE_MAX), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" } */\n+  T (a7 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" \"pr85350\" { xfail *-*-* } } */\n+  T (a7 + UR (DIFF_MAX, SIZE_MAX), \"012345\");  /* { dg-warning \"writing 7 bytes into a region of size 0\" \"pr85350\" { xfail *-*-* } } */\n \n   char *d = a7 + 7;\n \n@@ -127,6 +127,6 @@ void test_strncpy_memarray (struct MemArray *p, const void *s)\n   T (p->a9 + UR (9, 10), s, 9);   /* { dg-warning \"writing 9 bytes into a region of size 0\" } */\n   T (p->a9 + UR (10, 11), s, 9);  /* { dg-warning \"writing 9 bytes into a region of size 0\" } */\n \n-  T (p->a9 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), s, 1);  /* { dg-warning \"writing 1 byte into a region of size 0\" } */\n-  T (p->a9 + UR (DIFF_MAX, SIZE_MAX), s, 3);  /* { dg-warning \"writing 3 bytes into a region of size 0\" } */\n+  T (p->a9 + UR (DIFF_MAX, DIFF_MAX + (size_t)1), s, 1);  /* { dg-warning \"writing 1 byte into a region of size 0\" \"pr85350\" { xfail *-*-* } } */\n+  T (p->a9 + UR (DIFF_MAX, SIZE_MAX), s, 3);  /* { dg-warning \"writing 3 bytes into a region of size 0\" \"pr85350\" { xfail *-*-* } } */\n }"}, {"sha": "8fbb206a21e251ec1da58467b20a343756efd5fa", "filename": "gcc/testsuite/gcc.dg/pr40340-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-1.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -20,5 +20,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-warning \"writing\" \"\" { target *-*-* } 10 } */\n+/* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"\" { target *-*-* } 10 } */\n /* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */"}, {"sha": "10083acd10273bf5121f50c12d3c2ec6d98e53f3", "filename": "gcc/testsuite/gcc.dg/pr40340-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-2.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -12,5 +12,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-warning \"writing\" \"\" { target *-*-* } 10 } */\n+/* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"\" { target *-*-* } 10 } */\n /* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */"}, {"sha": "46b34bf47cdf3a312b7bf8f6689a9a5c586b76ad", "filename": "gcc/testsuite/gcc.dg/pr40340-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-4.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -1,6 +1,6 @@\n /* PR middle-end/40340 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wall -Wno-system-headers -g\" } */\n+/* { dg-options \"-O2 -Wall -Wno-array-bounds -Wno-system-headers -g\" } */\n \n #define TEST3\n #include \"pr40340.h\""}, {"sha": "0e48a2ca943c53cf232150b6e679abf420876bf0", "filename": "gcc/testsuite/gcc.dg/pr40340-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr40340-5.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -13,5 +13,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-warning \"writing\" \"\" { target *-*-* } 10 } */\n+/* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"\" { target *-*-* } 10 } */\n /* { dg-message \"file included\" \"In file included\" { target *-*-* } 0 } */"}, {"sha": "172b2487fd1f4bcd7b53ffb2fb8d5a427516ee00", "filename": "gcc/testsuite/gcc.dg/pr89350.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89350.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a411ae9b355c739bf05c065fb2e1b748129c6894/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89350.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89350.c?ref=a411ae9b355c739bf05c065fb2e1b748129c6894", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/89350 - Wrong -Wstringop-overflow warning\n+   on a variable offset from the end of an array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+char buf[128];\n+char *src = \"HCSparta\";\n+\n+int main(int argc, char **argv)\n+{\n+    char *dst = buf + sizeof(buf);\n+\n+    if (argc)\n+    {\n+      dst -= argc;\n+      __builtin_memcpy(dst, src, argc + 0);   /* { dg-bogus \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+    }\n+}"}]}