{"sha": "b11040a8b1a6060414092b8b26ad449a42380d9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExMDQwYThiMWE2MDYwNDE0MDkyYjhiMjZhZDQ0OWE0MjM4MGQ5Zg==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-08-07T19:13:27Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-08-07T19:13:27Z"}, "message": "vect-28.c: Fix test to not expect peeling on !vector_alignment_reachable targets.\n\n        * gcc.dg/vect/vect-28.c: Fix test to not expect peeling on\n        !vector_alignment_reachable targets.\n        * gcc.dg/vect/vect-33.c: Likewise.\n        * gcc.dg/vect/vect-42.c: Likewise.\n        * gcc.dg/vect/vect-44.c: Likewise.\n        * gcc.dg/vect/vect-50.c: Likewise.\n        * gcc.dg/vect/vect-70.c: Likewise.\n        * gcc.dg/vect/vect-71.c: Likewise.\n        * gcc.dg/vect/vect-87.c: Likewise.\n        * gcc.dg/vect/vect-88.c: Likewise.\n        * gcc.dg/vect/vect-91.c: Likewise.\n        * gcc.dg/vect/vect-93.c: Likewise.\n        * gcc.dg/vect/vect-96.c: Likewise.\n        * gcc.dg/vect/no-section-anchors-69.c: Likewise.\n        * gcc.dg/vect/section-anchors-69.c: Likewise.\n        * gcc.dg/vect/pr25413.c: Likewise.\n        * gcc.dg/vect/costmodel/ppc/costmodel-33.c: Likewise.\n        * gcc.dg/vect/costmodel/ppc/costmodel-76b.c: Likewise.\n        * gfortran.dg/vect-2.f90: Likewise.\n        * gfortran.dg/vect-3.f90: Likewise.\n        * gfortran.dg/vect-4.f90: Likewise.\n        * gfortran.dg/vect-5.f90: Likewise.\n        * lib/target-supports.exp (check_effective_target_natural_alignment):\n        Return false for darwin.\n        (check_effective_target_vector_alignment_reachable_for_double): New.\n\nFrom-SVN: r127276", "tree": {"sha": "88836adc0945d988bbbb35289e0d9750ed526d74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88836adc0945d988bbbb35289e0d9750ed526d74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b11040a8b1a6060414092b8b26ad449a42380d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11040a8b1a6060414092b8b26ad449a42380d9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b11040a8b1a6060414092b8b26ad449a42380d9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11040a8b1a6060414092b8b26ad449a42380d9f/comments", "author": null, "committer": null, "parents": [{"sha": "dc60b7754db561a029e42eeb297493726f8b8b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc60b7754db561a029e42eeb297493726f8b8b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc60b7754db561a029e42eeb297493726f8b8b33"}], "stats": {"total": 169, "additions": 118, "deletions": 51}, "files": [{"sha": "48c2cf363d81ebb501f743cdd47797f714da9ea7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -1,3 +1,31 @@\n+2007-08-07  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-28.c: Fix test to not expect peeling on \n+\t!vector_alignment_reachable targets.\n+\t* gcc.dg/vect/vect-33.c: Likewise.\n+\t* gcc.dg/vect/vect-42.c: Likewise.\n+\t* gcc.dg/vect/vect-44.c: Likewise.\n+\t* gcc.dg/vect/vect-50.c: Likewise.\n+\t* gcc.dg/vect/vect-70.c: Likewise.\n+\t* gcc.dg/vect/vect-71.c: Likewise.\n+\t* gcc.dg/vect/vect-87.c: Likewise.\n+\t* gcc.dg/vect/vect-88.c: Likewise.\n+\t* gcc.dg/vect/vect-91.c: Likewise.\n+\t* gcc.dg/vect/vect-93.c: Likewise.\n+\t* gcc.dg/vect/vect-96.c: Likewise.\n+\t* gcc.dg/vect/no-section-anchors-69.c: Likewise.\n+\t* gcc.dg/vect/section-anchors-69.c: Likewise.\n+\t* gcc.dg/vect/pr25413.c: Likewise.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-33.c: Likewise.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-76b.c: Likewise.\n+\t* gfortran.dg/vect-2.f90: Likewise.\n+\t* gfortran.dg/vect-3.f90: Likewise.\n+\t* gfortran.dg/vect-4.f90: Likewise.\n+\t* gfortran.dg/vect-5.f90: Likewise.\n+\t* lib/target-supports.exp (check_effective_target_natural_alignment): \n+\tReturn false for darwin. \n+\t(check_effective_target_vector_alignment_reachable_for_double): New.\t\n+\n 2007-08-07  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* gcc.dg/multiword-1.c: New testcase."}, {"sha": "11036b0bced5b9050fbae6edf03c3481a72dd3d7", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-33.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-33.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -35,5 +35,9 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* Peeling to align the store is used. Overhead of peeling is too high.  */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { target vector_alignment_reachable } } } */\n+\n+/* Versioning to align the store is used. Overhead of versioning is not too high.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target {! vector_alignment_reachable} } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8723d266f9d8b71ee25a207d1bb7e508be4a59c9", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76b.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -42,6 +42,10 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* Peeling to align the store is used. Overhead of peeling is too high.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { target { vector_alignment_reachable && {! vect_no_align} } } } } */\n+\n+/* Versioning to align the store is used. Overhead of versioning is not too high.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_no_align || {! vector_alignment_reachable} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "fd518470d6df09f6c2492b890380c3428ed2ba9d", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -37,7 +37,7 @@ int main1 ()\n {  \n   int i,j;\n \n-  /* 1. unaligned */\n+  /* 1. unaligned (known misalignment) */\n   for (i = 0; i < N; i++)\n     {\n       tmp1[2].a.n[1][2][i] = 5;\n@@ -82,7 +82,7 @@ int main1 ()\n \t}\n     }\n \n-  /* 4. unaligned */\n+  /* 4. unaligned (unknown misalignment) */\n   for (i = 0; i < N-4; i++)\n     {\n       for (j = 0; j < N-4; j++)\n@@ -113,5 +113,7 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail {! vector_alignment_reachable} } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target {! vector_alignment_reachable} } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target {! vector_alignment_reachable} } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a4cb0b00317658ea7968a25c3158eb42f9e68d1c", "filename": "gcc/testsuite/gcc.dg/vect/pr25413.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -31,8 +31,8 @@ int main (void)\n   return 0;\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vector_alignment_reachable } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { ! vector_alignment_reachable } } } } */\n-/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vector_alignment_reachable_for_double } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { ! vector_alignment_reachable_for_double } } } } */\n+/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vector_alignment_reachable_for_double } } } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 1 \"vect\" { target { ! vector_alignment_reachable_for_double } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7b5ce734884fe253ca8b8246c0c7c9333a488af8", "filename": "gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fsection-anchors-vect-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fsection-anchors-vect-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fsection-anchors-vect-69.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -115,5 +115,6 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n /* Alignment forced using versioning until the pass that increases alignment\n   is extended to handle structs.  */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 4 \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 4 \"vect\" { target {vect_int && vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 4 \"vect\" { target {vect_int && {! vector_alignment_reachable} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "474950d676b59fe20f55d0e6f3280c327f76fb9c", "filename": "gcc/testsuite/gcc.dg/vect/vect-28.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -39,5 +39,6 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3fd54fa75f1a0b67184b649b41972497e9c6ad89", "filename": "gcc/testsuite/gcc.dg/vect/vect-33.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -38,5 +38,6 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "59fe7da5578b87a36e4d7f97d49f1baa448dd9e5", "filename": "gcc/testsuite/gcc.dg/vect/vect-42.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -55,7 +55,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/*  { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/*  { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { vect_no_align || { ! vector_alignment_reachable } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail {vect_no_align || { ! vector_alignment_reachable } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "029475f43734532a39317deceb6b9eae4ce4f3a3", "filename": "gcc/testsuite/gcc.dg/vect/vect-44.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -65,6 +65,7 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "39438caf2804d922e9b8669d5db8b47544073acb", "filename": "gcc/testsuite/gcc.dg/vect/vect-50.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -61,6 +61,7 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "226ec12d5b042725cdad22a463d7831579702371", "filename": "gcc/testsuite/gcc.dg/vect/vect-70.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -63,5 +63,6 @@ int main (void)\n           \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" {target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" {target {! vector_alignment_reachable} } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ac1b4d74be383fe20527a1616a5823f853a633d6", "filename": "gcc/testsuite/gcc.dg/vect/vect-71.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-71.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-71.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-71.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -5,7 +5,7 @@\n \n #define N 16\n \n-/* unaligned load.  */\n+/* indirect access.  */\n \n int main1 ()\n {"}, {"sha": "f98ff1aa698a23139b75adc9403f1681b98c8c65", "filename": "gcc/testsuite/gcc.dg/vect/vect-87.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -50,5 +50,6 @@ int main (void)\n /* Fails for targets that don't vectorize PLUS (e.g alpha).  */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" {target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" {target {! vector_alignment_reachable} } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "6c61c96c2cc425fb8dabe83c3c832782b9ccc1d5", "filename": "gcc/testsuite/gcc.dg/vect/vect-88.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-88.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-88.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-88.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -50,5 +50,6 @@ int main (void)\n /* Fails for targets that don't vectorize PLUS (e.g alpha).  */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" {target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" {target {! vector_alignment_reachable} } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0eecdb42a5aa359fab91d22fa9fffc79041096d6", "filename": "gcc/testsuite/gcc.dg/vect/vect-91.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -58,7 +58,7 @@ main3 ()\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { xfail vect_no_int_add } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 3 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" {target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" {target {! vector_alignment_reachable} } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3277a7abcc34cf70c679df2f7c1e7d68a601f8a8", "filename": "gcc/testsuite/gcc.dg/vect/vect-93.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -67,12 +67,12 @@ int main (void)\n \n /* 2 loops vectorized in main1, 2 loops vectorized in main:\n    the first loop in main requires vectorization of conversions,\n-   the second loop in main requires vectorization of misaliged load.  */\n+   the second loop in main requires vectorization of misaligned load.  */\n \n /* main && main1 together: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 2 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target { vect_no_align && {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n \n /* in main1: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target !powerpc*-*-* !i?86-*-* !x86_64-*-* } } } */"}, {"sha": "f186515af6801ee48672dece0c1673309004b625", "filename": "gcc/testsuite/gcc.dg/vect/vect-96.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -42,7 +42,7 @@ int main (void)\n    For targets that don't support unaligned loads, version for the store.  */\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { {! vect_no_align} && vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { vect_no_align || {! vector_alignment_reachable} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "53ee74ce461d22366e2b4b959eba6bec2be437e0", "filename": "gcc/testsuite/gfortran.dg/vect/vect-2.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -15,8 +15,8 @@ SUBROUTINE FOO(A, B, C)\n ! support unaligned loads).\n \n ! { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail vect_no_align } } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target { vect_no_align && {! vector_alignment_reachable} } } } }\n ! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" {target vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" {target { vect_no_align || {! vector_alignment_reachable} } } } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "223d2dc175dc859297bbfc0259564cc9b13a07bf", "filename": "gcc/testsuite/gfortran.dg/vect/vect-3.f90", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -6,6 +6,13 @@ SUBROUTINE SAXPY(X, Y, A, N)\n Y = Y + A * X\n END\n \n-! fail to vectorize due to failure to compute number of iterations (PR tree-optimization/18527)\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail *-*-* } } } \n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" { target vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { target vect_no_align } } } \n+\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { {! vect_no_align} && {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target { {! vect_no_align} && {! vector_alignment_reachable} } } } }\n+\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n+\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "5e514f6136c7b95ea32cb050fa2c40ff20c41fce", "filename": "gcc/testsuite/gfortran.dg/vect/vect-4.f90", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -10,7 +10,8 @@ SUBROUTINE SAXPY(X, Y, A)\n END\n \n ! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } \n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target {! vector_alignment_reachable} } } }\n ! { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "acd13de16f72edec8cde9ee7746f7751d3803628", "filename": "gcc/testsuite/gfortran.dg/vect/vect-5.f90", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -36,16 +36,8 @@ program main\n         end\n \n ! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n ! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align } } } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 2 \"vect\" { target { ilp32 && vect_no_align } } } }\n-\n-! We also expect to vectorize one loop for lp64 targets that support \n-! misaligned access:\n-!   scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { lp64 && !vect_no_align } }\n-!   scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { lp64 && !vect_no_align } }\n-!   scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { lp64 && !vect_no_align } }\n-! but we currently can't combine logical operators. (Could define \n-! a keyword for \"not_vect_no_align\" if desired). \n-\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 2 \"vect\" { target { vect_no_align } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target {! vector_alignment_reachable} } } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "373f4802785232cd6cdb615cde4e651d14286056", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11040a8b1a6060414092b8b26ad449a42380d9f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b11040a8b1a6060414092b8b26ad449a42380d9f", "patch": "@@ -2110,9 +2110,10 @@ proc check_effective_target_natural_alignment { } {\n     if [info exists et_natural_alignment_saved] {\n         verbose \"check_effective_target_natural_alignment: using cached result\" 2\n     } else {\n-        set et_natural_alignment_saved 0\n-        if { [istarget spu-*-*] } {\n-            set et_natural_alignment_saved 1\n+\t# FIXME: 32bit powerpc: guaranteed only if MASK_ALIGN_NATURAL/POWER.\n+        set et_natural_alignment_saved 1\n+        if { ([istarget *-*-darwin*] && [is-effective-target lp64]) } { \n+            set et_natural_alignment_saved 0\n         }\n     }\n     verbose \"check_effective_target_natural_alignment: returning $et_natural_alignment_saved\" 2\n@@ -2140,6 +2141,26 @@ proc check_effective_target_vector_alignment_reachable { } {\n     return $et_vector_alignment_reachable_saved\n }\n \n+# Return 1 if vector alignment for soubles  is reachable, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vector_alignment_reachable_for_double { } {\n+    global et_vector_alignment_reachable_for_double\n+\n+    if [info exists et_vector_alignment_reachable_for_double_saved] {\n+        verbose \"check_effective_target_vector_alignment_reachable_for_double: using cached result\" 2\n+    } else {\n+        if { [check_effective_target_vect_aligned_arrays] } {\n+            set et_vector_alignment_reachable_for_double_saved 1\n+        } else {\n+            set et_vector_alignment_reachable_for_double_saved 0\n+        }\n+    }\n+    verbose \"check_effective_target_vector_alignment_reachable_for_double: returning $et_vector_alignment_reachable_for_double_saved\" 2\n+    return $et_vector_alignment_reachable_for_double_saved\n+}\n+\n # Return 1 if the target supports vector conditional operations, 0 otherwise.\n \n proc check_effective_target_vect_condition { } {"}]}