{"sha": "acd17ae6c85a4c094f1360632732c7a5ae058ecc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNkMTdhZTZjODVhNGMwOTRmMTM2MDYzMjczMmM3YTVhZTA1OGVjYw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2013-06-07T04:56:46Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2013-06-07T04:56:46Z"}, "message": "rs6000.c (rs6000_option_override_internal): Don't override user -mfp-in-toc.\n\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Don't\n\toverride user -mfp-in-toc.\n\t(offsettable_ok_by_alignment): Consider just the current access\n\trather than the whole object, unless BLKmode.  Handle\n\tCONSTANT_POOL_ADDRESS_P constants that lack a decl too.\n\t(use_toc_relative_ref): Allow CONSTANT_POOL_ADDRESS_P constants\n\tfor -mcmodel=medium.\n\t* config/rs6000/linux64.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Don't\n\toverride user -mfp-in-toc or -msum-in-toc.  Default to\n\t-mno-fp-in-toc for -mcmodel=medium.\n\nFrom-SVN: r199781", "tree": {"sha": "48979d1bafcba8bed947a49c8c9403a0a25c6b6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48979d1bafcba8bed947a49c8c9403a0a25c6b6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acd17ae6c85a4c094f1360632732c7a5ae058ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd17ae6c85a4c094f1360632732c7a5ae058ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd17ae6c85a4c094f1360632732c7a5ae058ecc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd17ae6c85a4c094f1360632732c7a5ae058ecc/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a9429737bda029bc8e668e23986e2d75fcec255f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9429737bda029bc8e668e23986e2d75fcec255f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9429737bda029bc8e668e23986e2d75fcec255f"}], "stats": {"total": 127, "additions": 77, "deletions": 50}, "files": [{"sha": "99db65aee3fda79fd6d4b01394da06fa15fb998b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd17ae6c85a4c094f1360632732c7a5ae058ecc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd17ae6c85a4c094f1360632732c7a5ae058ecc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acd17ae6c85a4c094f1360632732c7a5ae058ecc", "patch": "@@ -1,3 +1,16 @@\n+2013-06-07  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Don't\n+\toverride user -mfp-in-toc.\n+\t(offsettable_ok_by_alignment): Consider just the current access\n+\trather than the whole object, unless BLKmode.  Handle\n+\tCONSTANT_POOL_ADDRESS_P constants that lack a decl too.\n+\t(use_toc_relative_ref): Allow CONSTANT_POOL_ADDRESS_P constants\n+\tfor -mcmodel=medium.\n+\t* config/rs6000/linux64.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Don't\n+\toverride user -mfp-in-toc or -msum-in-toc.  Default to\n+\t-mno-fp-in-toc for -mcmodel=medium.\n+\n 2013-06-06  DJ Delorie  <dj@redhat.com>\n \n \t* config/rl78/rl78.c (rl78_valid_pointer_mode): New, implements"}, {"sha": "79f0f0b5f000ed22c98a091d03eeeb869e5045fd", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd17ae6c85a4c094f1360632732c7a5ae058ecc/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd17ae6c85a4c094f1360632732c7a5ae058ecc/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=acd17ae6c85a4c094f1360632732c7a5ae058ecc", "patch": "@@ -136,8 +136,11 @@ extern int dot_symbols;\n \t\tSET_CMODEL (CMODEL_MEDIUM);\t\t\t\\\n \t      if (rs6000_current_cmodel != CMODEL_SMALL)\t\\\n \t\t{\t\t\t\t\t\t\\\n-\t\t  TARGET_NO_FP_IN_TOC = 0;\t\t\t\\\n-\t\t  TARGET_NO_SUM_IN_TOC = 0;\t\t\t\\\n+\t\t  if (!global_options_set.x_TARGET_NO_FP_IN_TOC) \\\n+\t\t    TARGET_NO_FP_IN_TOC\t\t\t\t\\\n+\t\t      = rs6000_current_cmodel == CMODEL_MEDIUM;\t\\\n+\t\t  if (!global_options_set.x_TARGET_NO_SUM_IN_TOC) \\\n+\t\t    TARGET_NO_SUM_IN_TOC = 0;\t\t\t\\\n \t\t}\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\"}, {"sha": "cc16e3fb8197655d58744a94d2ef4acb208ccc97", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 48, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd17ae6c85a4c094f1360632732c7a5ae058ecc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd17ae6c85a4c094f1360632732c7a5ae058ecc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=acd17ae6c85a4c094f1360632732c7a5ae058ecc", "patch": "@@ -3052,7 +3052,8 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* Place FP constants in the constant pool instead of TOC\n      if section anchors enabled.  */\n-  if (flag_section_anchors)\n+  if (flag_section_anchors\n+      && !global_options_set.x_TARGET_NO_FP_IN_TOC)\n     TARGET_NO_FP_IN_TOC = 1;\n \n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n@@ -5519,91 +5520,102 @@ virtual_stack_registers_memory_p (rtx op)\n \t  && regnum <= LAST_VIRTUAL_POINTER_REGISTER);\n }\n \n-/* Return true if memory accesses to OP are known to never straddle\n-   a 32k boundary.  */\n+/* Return true if a MODE sized memory accesses to OP plus OFFSET\n+   is known to not straddle a 32k boundary.  */\n \n static bool\n offsettable_ok_by_alignment (rtx op, HOST_WIDE_INT offset,\n \t\t\t     enum machine_mode mode)\n {\n   tree decl, type;\n-  unsigned HOST_WIDE_INT dsize, dalign;\n+  unsigned HOST_WIDE_INT dsize, dalign, lsb, mask;\n \n   if (GET_CODE (op) != SYMBOL_REF)\n     return false;\n \n+  dsize = GET_MODE_SIZE (mode);\n   decl = SYMBOL_REF_DECL (op);\n   if (!decl)\n     {\n-      if (GET_MODE_SIZE (mode) == 0)\n+      if (dsize == 0)\n \treturn false;\n \n       /* -fsection-anchors loses the original SYMBOL_REF_DECL when\n \t replacing memory addresses with an anchor plus offset.  We\n \t could find the decl by rummaging around in the block->objects\n \t VEC for the given offset but that seems like too much work.  */\n-      dalign = 1;\n+      dalign = BITS_PER_UNIT;\n       if (SYMBOL_REF_HAS_BLOCK_INFO_P (op)\n \t  && SYMBOL_REF_ANCHOR_P (op)\n \t  && SYMBOL_REF_BLOCK (op) != NULL)\n \t{\n \t  struct object_block *block = SYMBOL_REF_BLOCK (op);\n-\t  HOST_WIDE_INT lsb, mask;\n \n-\t  /* Given the alignment of the block..  */\n \t  dalign = block->alignment;\n-\t  mask = dalign / BITS_PER_UNIT - 1;\n-\n-\t  /* ..and the combined offset of the anchor and any offset\n-\t     to this block object..  */\n \t  offset += SYMBOL_REF_BLOCK_OFFSET (op);\n-\t  lsb = offset & -offset;\n+\t}\n+      else if (CONSTANT_POOL_ADDRESS_P (op))\n+\t{\n+\t  /* It would be nice to have get_pool_align()..  */\n+\t  enum machine_mode cmode = get_pool_mode (op);\n \n-\t  /* ..find how many bits of the alignment we know for the\n-\t     object.  */\n-\t  mask &= lsb - 1;\n-\t  dalign = mask + 1;\n+\t  dalign = GET_MODE_ALIGNMENT (cmode);\n \t}\n-      return dalign >= GET_MODE_SIZE (mode);\n     }\n-\n-  if (DECL_P (decl))\n+  else if (DECL_P (decl))\n     {\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\treturn true;\n+      dalign = DECL_ALIGN (decl);\n \n-      if (!DECL_SIZE_UNIT (decl))\n-\treturn false;\n+      if (dsize == 0)\n+\t{\n+\t  /* Allow BLKmode when the entire object is known to not\n+\t     cross a 32k boundary.  */\n+\t  if (!DECL_SIZE_UNIT (decl))\n+\t    return false;\n \n-      if (!host_integerp (DECL_SIZE_UNIT (decl), 1))\n-\treturn false;\n+\t  if (!host_integerp (DECL_SIZE_UNIT (decl), 1))\n+\t    return false;\n \n-      dsize = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n-      if (dsize > 32768)\n-\treturn false;\n+\t  dsize = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+\t  if (dsize > 32768)\n+\t    return false;\n \n-      dalign = DECL_ALIGN_UNIT (decl);\n-      return dalign >= dsize;\n+\t  return dalign / BITS_PER_UNIT >= dsize;\n+\t}\n     }\n+  else\n+    {\n+      type = TREE_TYPE (decl);\n \n-  type = TREE_TYPE (decl);\n+      dalign = TYPE_ALIGN (type);\n+      if (CONSTANT_CLASS_P (decl))\n+\tdalign = CONSTANT_ALIGNMENT (decl, dalign);\n+      else\n+\tdalign = DATA_ALIGNMENT (decl, dalign);\n \n-  if (TREE_CODE (decl) == STRING_CST)\n-    dsize = TREE_STRING_LENGTH (decl);\n-  else if (TYPE_SIZE_UNIT (type)\n-\t   && host_integerp (TYPE_SIZE_UNIT (type), 1))\n-    dsize = tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n-  else\n-    return false;\n-  if (dsize > 32768)\n-    return false;\n+      if (dsize == 0)\n+\t{\n+\t  /* BLKmode, check the entire object.  */\n+\t  if (TREE_CODE (decl) == STRING_CST)\n+\t    dsize = TREE_STRING_LENGTH (decl);\n+\t  else if (TYPE_SIZE_UNIT (type)\n+\t\t   && host_integerp (TYPE_SIZE_UNIT (type), 1))\n+\t    dsize = tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n+\t  else\n+\t    return false;\n+\t  if (dsize > 32768)\n+\t    return false;\n+\n+\t  return dalign / BITS_PER_UNIT >= dsize;\n+\t}\n+    }\n+\n+  /* Find how many bits of the alignment we know for this access.  */\n+  mask = dalign / BITS_PER_UNIT - 1;\n+  lsb = offset & -offset;\n+  mask &= lsb - 1;\n+  dalign = mask + 1;\n \n-  dalign = TYPE_ALIGN (type);\n-  if (CONSTANT_CLASS_P (decl))\n-    dalign = CONSTANT_ALIGNMENT (decl, dalign);\n-  else\n-    dalign = DATA_ALIGNMENT (decl, dalign);\n-  dalign /= BITS_PER_UNIT;\n   return dalign >= dsize;\n }\n \n@@ -6549,7 +6561,6 @@ use_toc_relative_ref (rtx sym)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (sym),\n \t\t\t\t\t       get_pool_mode (sym)))\n \t  || (TARGET_CMODEL == CMODEL_MEDIUM\n-\t      && !CONSTANT_POOL_ADDRESS_P (sym)\n \t      && SYMBOL_REF_LOCAL_P (sym)));\n }\n "}]}