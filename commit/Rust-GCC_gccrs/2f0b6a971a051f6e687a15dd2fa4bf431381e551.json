{"sha": "2f0b6a971a051f6e687a15dd2fa4bf431381e551", "node_id": "C_kwDOANBUbNoAKDJmMGI2YTk3MWEwNTFmNmU2ODdhMTVkZDJmYTRiZjQzMTM4MWU1NTE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-27T16:22:29Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-27T18:14:15Z"}, "message": "Reorder relation calculating code in the path solver.\n\nEnabling the fully resolving threader triggers various relation\nordering issues that have previously been dormant because the VRP\nhybrid threader (forward threader based) never gives us long enough\npaths for this to matter.  The new threader spares no punches in\nfinding non-obvious paths, so getting the relations right is\nparamount.\n\nThis patch fixes a couple oversights that have gone undetected.\n\nFirst, some background.  There are 3 types of relations along a path:\n\na) Relations inherent in a PHI.\nb) Relations as a side-effect of evaluating a statement.\nc) Outgoing relations between blocks in a path.\n\nWe must calculate these in their proper order, otherwise we can run\ninto ordering issues.  The current ordering is wrong, as we\nprecalculate PHIs for _all_ blocks before anything else, and then\nproceed to register the relations throughout the path.  Also, we fail\nto realize that a PHI whose argument is also defined in the PHIs block\ncannot be registered as an equivalence without causing more ordering\nissues.\n\nThis patch fixes all the problems described above.  With it we get a\nhandful more net threads, but most importantly, we disallow some\nthreads that were wrong.\n\nTested on x86-64 and ppc64le Linux on the usual regstrap, plus by\ncomparing the different thread counts before and after this patch.\n\ngcc/ChangeLog:\n\n\t* gimple-range-fold.cc (fold_using_range::range_of_range_op): Dump\n\toperands as well as relation.\n\t* gimple-range-path.cc\n\t(path_range_query::compute_ranges_in_block): Compute PHI relations\n\tfirst.  Compute outgoing relations at the end.\n\t(path_range_query::compute_ranges): Remove call to compute_relations.\n\t(path_range_query::compute_relations): Remove.\n\t(path_range_query::maybe_register_phi_relation): New.\n\t(path_range_query::compute_phi_relations): Abstract out\n\tregistering one PHI relation to...\n\t(path_range_query::compute_outgoing_relations): ...here.\n\t* gimple-range-path.h (class path_range_query): Remove\n\tcompute_relations.\n\tAdd maybe_register_phi_relation.", "tree": {"sha": "ff9f20c2ee36c0d5398bb95632b3f3296049de75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff9f20c2ee36c0d5398bb95632b3f3296049de75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f0b6a971a051f6e687a15dd2fa4bf431381e551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f0b6a971a051f6e687a15dd2fa4bf431381e551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f0b6a971a051f6e687a15dd2fa4bf431381e551", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f0b6a971a051f6e687a15dd2fa4bf431381e551/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f4edfc1fb80211f8663f978b7144e7e9d9df743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4edfc1fb80211f8663f978b7144e7e9d9df743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f4edfc1fb80211f8663f978b7144e7e9d9df743"}], "stats": {"total": 112, "additions": 58, "deletions": 54}, "files": [{"sha": "2fab904e6b099a64ed5dfe00c0137e940db69be2", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b6a971a051f6e687a15dd2fa4bf431381e551/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b6a971a051f6e687a15dd2fa4bf431381e551/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=2f0b6a971a051f6e687a15dd2fa4bf431381e551", "patch": "@@ -620,7 +620,9 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t  if (dump_file && (dump_flags & TDF_DETAILS) && rel != VREL_NONE)\n \t    {\n \t      fprintf (dump_file, \" folding with relation \");\n+\t      print_generic_expr (dump_file, op1, TDF_SLIM);\n \t      print_relation (dump_file, rel);\n+\t      print_generic_expr (dump_file, op2, TDF_SLIM);\n \t      fputc ('\\n', dump_file);\n \t    }\n \t  // Fold range, and register any dependency if available."}, {"sha": "2f570a13e057dfb30a77995da7e3944063bd4cf9", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b6a971a051f6e687a15dd2fa4bf431381e551/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b6a971a051f6e687a15dd2fa4bf431381e551/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=2f0b6a971a051f6e687a15dd2fa4bf431381e551", "patch": "@@ -316,6 +316,9 @@ path_range_query::compute_ranges_in_block (basic_block bb)\n   int_range_max r, cached_range;\n   unsigned i;\n \n+  if (m_resolve && !at_entry ())\n+    compute_phi_relations (bb, prev_bb ());\n+\n   // Force recalculation of any names in the cache that are defined in\n   // this block.  This can happen on interdependent SSA/phis in loops.\n   EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n@@ -341,7 +344,8 @@ path_range_query::compute_ranges_in_block (basic_block bb)\n     return;\n \n   // Solve imports that are exported to the next block.\n-  edge e = find_edge (bb, next_bb ());\n+  basic_block next = next_bb ();\n+  edge e = find_edge (bb, next);\n   EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n     {\n       tree name = ssa_name (i);\n@@ -369,6 +373,9 @@ path_range_query::compute_ranges_in_block (basic_block bb)\n \t    }\n \t}\n     }\n+\n+  if (m_resolve)\n+    compute_outgoing_relations (bb, next);\n }\n \n // Adjust all pointer imports in BB with non-null information.\n@@ -485,7 +492,6 @@ path_range_query::compute_ranges (const vec<basic_block> &path,\n     {\n       add_copies_to_imports ();\n       get_path_oracle ()->reset_path ();\n-      compute_relations (path);\n     }\n \n   if (DEBUG_SOLVER)\n@@ -527,7 +533,12 @@ path_range_query::compute_ranges (const vec<basic_block> &path,\n     }\n \n   if (DEBUG_SOLVER)\n-    dump (dump_file);\n+    {\n+      fprintf (dump_file, \"\\npath_oracle:\\n\");\n+      get_path_oracle ()->dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+      dump (dump_file);\n+    }\n }\n \n // A folding aid used to register and query relations along a path.\n@@ -624,49 +635,23 @@ path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n   return true;\n }\n \n-// Compute relations on a path.  This involves two parts: relations\n-// along the conditionals joining a path, and relations determined by\n-// examining PHIs.\n-\n void\n-path_range_query::compute_relations (const vec<basic_block> &path)\n+path_range_query::maybe_register_phi_relation (gphi *phi, tree arg)\n {\n-  if (!dom_info_available_p (CDI_DOMINATORS))\n-    return;\n+  basic_block bb = gimple_bb (phi);\n+  tree result = gimple_phi_result (phi);\n+  gimple *def = SSA_NAME_DEF_STMT (arg);\n \n-  jt_fur_source src (NULL, this, &m_ranger.gori (), path);\n-  basic_block prev = NULL;\n-  for (unsigned i = path.length (); i > 0; --i)\n-    {\n-      basic_block bb = path[i - 1];\n-      gimple *stmt = last_stmt (bb);\n+  // Avoid recording the equivalence if the arg is defined in this\n+  // block, as that would create an ordering problem.\n+  if (def && gimple_bb (def) == bb)\n+    return;\n \n-      compute_phi_relations (bb, prev);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  from bb%d:\", bb->index);\n \n-      // Compute relations in outgoing edges along the path.  Skip the\n-      // final conditional which we don't know yet.\n-      if (i > 1\n-\t  && stmt\n-\t  && gimple_code (stmt) == GIMPLE_COND\n-\t  && irange::supports_type_p (TREE_TYPE (gimple_cond_lhs (stmt))))\n-\t{\n-\t  basic_block next = path[i - 2];\n-\t  int_range<2> r;\n-\t  gcond *cond = as_a<gcond *> (stmt);\n-\t  edge e0 = EDGE_SUCC (bb, 0);\n-\t  edge e1 = EDGE_SUCC (bb, 1);\n-\n-\t  if (e0->dest == next)\n-\t    gcond_edge_range (r, e0);\n-\t  else if (e1->dest == next)\n-\t    gcond_edge_range (r, e1);\n-\t  else\n-\t    gcc_unreachable ();\n-\n-\t  src.register_outgoing_edges (cond, r, e0, e1);\n-\t}\n-      prev = bb;\n-    }\n+  get_path_oracle ()->killing_def (result);\n+  m_oracle->register_relation (entry_bb (), EQ_EXPR, arg, result);\n }\n \n // Compute relations for each PHI in BB.  For example:\n@@ -681,15 +666,12 @@ path_range_query::compute_phi_relations (basic_block bb, basic_block prev)\n   if (prev == NULL)\n     return;\n \n-  basic_block entry = entry_bb ();\n   edge e_in = find_edge (prev, bb);\n-  gcc_checking_assert (e_in);\n \n   for (gphi_iterator iter = gsi_start_phis (bb); !gsi_end_p (iter);\n        gsi_next (&iter))\n     {\n       gphi *phi = iter.phi ();\n-      tree result = gimple_phi_result (phi);\n       unsigned nargs = gimple_phi_num_args (phi);\n \n       for (size_t i = 0; i < nargs; ++i)\n@@ -698,17 +680,36 @@ path_range_query::compute_phi_relations (basic_block bb, basic_block prev)\n \t    tree arg = gimple_phi_arg_def (phi, i);\n \n \t    if (gimple_range_ssa_p (arg))\n-\t      {\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  fprintf (dump_file, \"  from bb%d:\", bb->index);\n+\t      maybe_register_phi_relation (phi, arg);\n+\t    break;\n+\t  }\n+    }\n+}\n \n-\t\t// Throw away any previous relation.\n-\t\tget_path_oracle ()->killing_def (result);\n+// Compute outgoing relations from BB to NEXT.\n \n-\t\tm_oracle->register_relation (entry, EQ_EXPR, arg, result);\n-\t      }\n+void\n+path_range_query::compute_outgoing_relations (basic_block bb, basic_block next)\n+{\n+  gimple *stmt = last_stmt (bb);\n \n-\t    break;\n-\t  }\n+  if (stmt\n+      && gimple_code (stmt) == GIMPLE_COND\n+      && irange::supports_type_p (TREE_TYPE (gimple_cond_lhs (stmt))))\n+    {\n+      int_range<2> r;\n+      gcond *cond = as_a<gcond *> (stmt);\n+      edge e0 = EDGE_SUCC (bb, 0);\n+      edge e1 = EDGE_SUCC (bb, 1);\n+\n+      if (e0->dest == next)\n+\tgcond_edge_range (r, e0);\n+      else if (e1->dest == next)\n+\tgcond_edge_range (r, e1);\n+      else\n+\tgcc_unreachable ();\n+\n+      jt_fur_source src (NULL, this, &m_ranger.gori (), *m_path);\n+      src.register_outgoing_edges (cond, r, e0, e1);\n     }\n }"}, {"sha": "541613956e119e69fd2cbd48b31a3f2ba7e63ce0", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b6a971a051f6e687a15dd2fa4bf431381e551/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b6a971a051f6e687a15dd2fa4bf431381e551/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=2f0b6a971a051f6e687a15dd2fa4bf431381e551", "patch": "@@ -57,8 +57,9 @@ class path_range_query : public range_query\n   void compute_ranges_in_block (basic_block bb);\n   void adjust_for_non_null_uses (basic_block bb);\n   void ssa_range_in_phi (irange &r, gphi *phi);\n-  void compute_relations (const vec<basic_block> &);\n+  void compute_outgoing_relations (basic_block bb, basic_block next);\n   void compute_phi_relations (basic_block bb, basic_block prev);\n+  void maybe_register_phi_relation (gphi *, tree arg);\n   void add_copies_to_imports ();\n   bool add_to_imports (tree name, bitmap imports);\n "}]}