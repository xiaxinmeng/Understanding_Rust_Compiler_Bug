{"sha": "ac1826887e12c3e8ea95414455f882838a518d11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMxODI2ODg3ZTEyYzNlOGVhOTU0MTQ0NTVmODgyODM4YTUxOGQxMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-06-07T12:01:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-06-07T12:01:47Z"}, "message": "tree-ssa-address.c: New file.\n\n\t* tree-ssa-address.c: New file.\n\t* Makefile.in (tree-ssa-address.o): Add.\n\t* expr.c (expand_expr_real_1): Do not handle REF_ORIGINAL on\n\tINDIRECT_REFs.  Handle TARGET_MEM_REFs.\n\t* tree-eh.c (tree_could_trap_p): Handle TARGET_MEM_REFs.\n\t* tree-flow.h (struct mem_address): New.\n\t(struct affine_tree_combination): Moved from tree-ssa-loop-ivopts.c.\n\t(create_mem_ref, addr_for_mem_ref, get_address_description,\n\tmaybe_fold_tmr, multiplier_allowed_in_address_p,\n\tmultiply_by_cost):  Declare.\n\t* tree-mudflap.c (mf_xform_derefs_1): Handle TARGET_MEM_REFs.\n\t* tree-pretty-print.c (dump_generic_node): Ditto.\n\t* tree-ssa-loop-im.c (for_each_index): Ditto.\n\t* tree-ssa-loop-ivopts.c (may_be_unaligned_p,\n\tfind_interesting_uses_address): Ditto.\n\t(rewrite_address_base, build_addr_strip_iref): Removed.\n\t(struct affine_tree_combination): Moved to tree-flow.h.\n\t(get_ref_tag, copy_ref_info): New functions.\n\t(rewrite_use_address): Produce TARGET_MEM_REFs.\n\t(tree_ssa_iv_optimize): Do not call update_ssa\n\tand rewrite_into_loop_closed_ssa.\n\t(tree_to_aff_combination): Use build_fold_addr_expr instead of\n\tbuild_addr_strip_iref.\n\t(unshare_aff_combination): New function.\n\t(fold_affine_sum): Removed.\n\t(get_computation_at): Use get_computation_aff.  Unshare the result.\n\t(get_computation_aff, multiplier_allowed_in_address_p): New function.\n\t(multiply_by_cost): Exported.\n\t(get_address_cost): Use multiplier_allowed_in_address_p.\n\t* tree-ssa-operands.c (get_tmr_operands): New function.\n\t(get_expr_operands): Handle TARGET_MEM_REFs.\n\t* tree.c (copy_node_stat): Copy annotations for TARGET_MEM_REFs.\n\t(build): Handle 7 arguments.\n\t(build7_stat): New function.\n\t* tree.def (TARGET_MEM_DEF): New.\n\t* tree.h (REF_ORIGINAL): Removed.\n\t(TMR_SYMBOL, TMR_BASE, TMR_INDEX, TMR_STEP, TMR_OFFSET, TMR_ORIGINAL,\n\tTMR_TAG, build7): New macros.\n\t(build7_stat, tree_mem_ref_addr, copy_mem_ref_info): Declare.\n\t* tree-ssa-ccp.c (fold_stmt_r): Call maybe_fold_tmr.\n\t* doc/c-tree.texi: Document TARGET_MEM_REF.\n\t* doc/tree-ssa.texi: Add TARGET_MEM_REF to gimple grammar.\n\n\t* gcc.dg/tree-ssa/loop-2.c: Update outcome.\n\t* gcc.dg/tree-ssa/loop-3.c: Update outcome.\n\t* gcc.dg/tree-ssa/loop-4.c: Update outcome.\n\t* gcc.dg/tree-ssa/loop-9.c: New test.\n\nFrom-SVN: r100708", "tree": {"sha": "378327f436c131f3eecc7128a199fdc378d9aa28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/378327f436c131f3eecc7128a199fdc378d9aa28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac1826887e12c3e8ea95414455f882838a518d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1826887e12c3e8ea95414455f882838a518d11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1826887e12c3e8ea95414455f882838a518d11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1826887e12c3e8ea95414455f882838a518d11/comments", "author": null, "committer": null, "parents": [{"sha": "01ea1ea8269ff36065e625b0b5e348568519bfa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ea1ea8269ff36065e625b0b5e348568519bfa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ea1ea8269ff36065e625b0b5e348568519bfa3"}], "stats": {"total": 1558, "additions": 1320, "deletions": 238}, "files": [{"sha": "b4fff9ae7ee7b976ff1747d1384001d5ecbfa3ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -1,3 +1,48 @@\n+2005-06-07  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-address.c: New file.\n+\t* Makefile.in (tree-ssa-address.o): Add.\n+\t* expr.c (expand_expr_real_1): Do not handle REF_ORIGINAL on\n+\tINDIRECT_REFs.  Handle TARGET_MEM_REFs.\n+\t* tree-eh.c (tree_could_trap_p): Handle TARGET_MEM_REFs.\n+\t* tree-flow.h (struct mem_address): New.\n+\t(struct affine_tree_combination): Moved from tree-ssa-loop-ivopts.c.\n+\t(create_mem_ref, addr_for_mem_ref, get_address_description,\n+\tmaybe_fold_tmr, multiplier_allowed_in_address_p,\n+\tmultiply_by_cost):  Declare.\n+\t* tree-mudflap.c (mf_xform_derefs_1): Handle TARGET_MEM_REFs.\n+\t* tree-pretty-print.c (dump_generic_node): Ditto.\n+\t* tree-ssa-loop-im.c (for_each_index): Ditto.\n+\t* tree-ssa-loop-ivopts.c (may_be_unaligned_p,\n+\tfind_interesting_uses_address): Ditto.\n+\t(rewrite_address_base, build_addr_strip_iref): Removed.\n+\t(struct affine_tree_combination): Moved to tree-flow.h.\n+\t(get_ref_tag, copy_ref_info): New functions.\n+\t(rewrite_use_address): Produce TARGET_MEM_REFs.\n+\t(tree_ssa_iv_optimize): Do not call update_ssa\n+\tand rewrite_into_loop_closed_ssa.\n+\t(tree_to_aff_combination): Use build_fold_addr_expr instead of\n+\tbuild_addr_strip_iref.\n+\t(unshare_aff_combination): New function.\n+\t(fold_affine_sum): Removed.\n+\t(get_computation_at): Use get_computation_aff.  Unshare the result.\n+\t(get_computation_aff, multiplier_allowed_in_address_p): New function.\n+\t(multiply_by_cost): Exported.\n+\t(get_address_cost): Use multiplier_allowed_in_address_p.\n+\t* tree-ssa-operands.c (get_tmr_operands): New function.\n+\t(get_expr_operands): Handle TARGET_MEM_REFs.\n+\t* tree.c (copy_node_stat): Copy annotations for TARGET_MEM_REFs.\n+\t(build): Handle 7 arguments.\n+\t(build7_stat): New function.\n+\t* tree.def (TARGET_MEM_DEF): New.\n+\t* tree.h (REF_ORIGINAL): Removed.\n+\t(TMR_SYMBOL, TMR_BASE, TMR_INDEX, TMR_STEP, TMR_OFFSET, TMR_ORIGINAL,\n+\tTMR_TAG, build7): New macros.\n+\t(build7_stat, tree_mem_ref_addr, copy_mem_ref_info): Declare.\n+\t* tree-ssa-ccp.c (fold_stmt_r): Call maybe_fold_tmr.\n+\t* doc/c-tree.texi: Document TARGET_MEM_REF.\n+\t* doc/tree-ssa.texi: Add TARGET_MEM_REF to gimple grammar.\n+\n 2005-06-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/21946"}, {"sha": "b9f0f1edf3d5faf1e6ddc44465838f20056c6d4c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -684,7 +684,7 @@ CONFIG_H  = config.h  $(host_xm_file_list)\n TCONFIG_H = tconfig.h $(xm_file_list)\n TM_P_H    = tm_p.h    $(tm_p_file_list)\n GTM_H     = tm.h      $(tm_file_list)\n-TM_H      = $(GTM_H) insn-constants.h insn-flags.h\n+TM_H      = $(GTM_H) insn-constants.h insn-flags.h options.h\n \n # Variables for version information.\n BASEVER     := $(srcdir)/BASE-VER  # 4.x.y\n@@ -935,7 +935,8 @@ OBJS-common = \\\n  tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o\t\t   \\\n  tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t\t\t\t   \\\n  tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o\t\t   \\\n- tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-math-opts.o\t   \\\n+ tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-address.o\t   \\\n+ tree-ssa-math-opts.o\t\t\t\t\t\t\t   \\\n  tree-ssa-loop-ivopts.o tree-if-conv.o tree-ssa-loop-unswitch.o\t\t   \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n@@ -1801,6 +1802,11 @@ tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) \\\n    $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    domwalk.h $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h $(TREE_DUMP_H) tree-pass.h $(BASIC_BLOCK_H) hard-reg-set.h\n+tree-ssa-address.o : tree-ssa-address.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \\\n+   output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h $(FLAGS_H) tree-inline.h $(RECOG_H) insn-config.h $(EXPR_H) \\\n+   gt-tree-ssa-address.h $(GGC_H)\n tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \\\n    tree-inline.h output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n@@ -2622,7 +2628,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(srcdir)/tree-mudflap.c $(srcdir)/tree-flow.h \\\n   $(srcdir)/c-objc-common.c $(srcdir)/c-common.c $(srcdir)/c-parser.c \\\n-  $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c \\\n+  $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \\\n   $(srcdir)/tree-phinodes.c $(srcdir)/tree-cfg.c \\\n   $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-propagate.c \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n@@ -2645,7 +2651,8 @@ gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \\\n gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parser.h \\\n gt-c-pragma.h gtype-c.h gt-cfglayout.h \\\n-gt-tree-mudflap.h gt-tree-vect-generic.h gt-tree-profile.h \\\n+gt-tree-mudflap.h gt-tree-vect-generic.h \\\n+gt-tree-profile.h gt-tree-ssa-address.h \\\n gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \\"}, {"sha": "196aa5644301f8c7202cae942f174271e98eda48", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -1712,6 +1712,7 @@ This macro returns the attributes on the type @var{type}.\n @tindex EXACT_DIV_EXPR\n @tindex ARRAY_REF\n @tindex ARRAY_RANGE_REF\n+@tindex TARGET_MEM_REF\n @tindex LT_EXPR\n @tindex LE_EXPR\n @tindex GT_EXPR\n@@ -2103,6 +2104,26 @@ meanings.  The type of these expressions must be an array whose component\n type is the same as that of the first operand.  The range of that array\n type determines the amount of data these expressions access.\n \n+@item TARGET_MEM_REF\n+These nodes represent memory accesses whose address directly map to\n+an addressing mode of the target architecture.  The first argument\n+is @code{TMR_SYMBOL} and must be a @code{VAR_DECL} of an object with\n+a fixed address.  The second argument is @code{TMR_BASE} and the\n+third one is @code{TMR_INDEX}.  The fourth argument is\n+@code{TMR_STEP} and must be an @code{INTEGER_CST}.  The fifth\n+argument is @code{TMR_OFFSET} and must be an @code{INTEGER_CST}.\n+Any of the arguments may be NULL if the appropriate component\n+does not appear in the address.  Address of the @code{TARGET_MEM_REF}\n+is determined in the following way.\n+\n+@smallexample\n+&TMR_SYMBOL + TMR_BASE + TMR_INDEX * TMR_STEP + TMR_OFFSET\n+@end smallexample\n+\n+The sixth argument is the reference to the original memory access, which\n+is preserved for the purposes of the RTL alias analysis.  The seventh\n+argument is a tag representing the results of tree level alias analysis.\n+\n @item LT_EXPR\n @itemx LE_EXPR\n @itemx GT_EXPR"}, {"sha": "7113c394dd55aff91baa66dbcfada1120c54d989", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -632,6 +632,12 @@ void f()\n                         op2 -> var\n \n    compref      : inner-compref\n+                | TARGET_MEM_REF\n+                        op0 -> ID\n+                        op1 -> val\n+                        op2 -> val\n+                        op3 -> CONST\n+                        op4 -> CONST\n                 | REALPART_EXPR\n                         op0 -> inner-compref\n                 | IMAGPART_EXPR"}, {"sha": "8b75ed7c605770ce69536508751443e95222049b", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -6862,7 +6862,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case INDIRECT_REF:\n       {\n \ttree exp1 = TREE_OPERAND (exp, 0);\n-\ttree orig;\n \n \tif (modifier != EXPAND_WRITE)\n \t  {\n@@ -6885,10 +6884,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \ttemp = gen_rtx_MEM (mode, op0);\n \n-\torig = REF_ORIGINAL (exp);\n-\tif (!orig)\n-\t  orig = exp;\n-\tset_mem_attributes (temp, orig, 0);\n+\tset_mem_attributes (temp, exp, 0);\n \n \t/* Resolve the misalignment now, so that we don't have to remember\n \t   to resolve it later.  Of course, this only works for reads.  */\n@@ -6920,6 +6916,18 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn temp;\n       }\n \n+    case TARGET_MEM_REF:\n+      {\n+\tstruct mem_address addr;\n+\n+\tget_address_description (exp, &addr);\n+\top0 = addr_for_mem_ref (&addr, true);\n+\top0 = memory_address (mode, op0);\n+\ttemp = gen_rtx_MEM (mode, op0);\n+\tset_mem_attributes (temp, TMR_ORIGINAL (exp), 0);\n+      }\n+      return temp;\n+\n     case ARRAY_REF:\n \n       {"}, {"sha": "d16e6f94b023948d9aa732e61cfe5f5497787246", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -1,3 +1,10 @@\n+2005-06-07  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-2.c: Update outcome.\n+\t* gcc.dg/tree-ssa/loop-3.c: Update outcome.\n+\t* gcc.dg/tree-ssa/loop-4.c: Update outcome.\n+\t* gcc.dg/tree-ssa/loop-9.c: New test.\n+\n 2005-06-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/parse/defarg10.C: New."}, {"sha": "e086499ca2727139e838616539d22a9bb61720c6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-2.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-2.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -21,9 +21,12 @@ void xxx(void)\n     arr_base[iter].y = 17 * iter;\n }\n \n-/* Access to arr_base[iter].y should be strength reduced.  */\n+/* Access to arr_base[iter].y should be strength reduced, i.e., there should\n+   be no multiplication.  */\n \n-/* { dg-final { scan-tree-dump-times \"arr_base\\[^\\\\n\\\\r\\]*=\" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* \\[^\\\\n\\\\r\\]*=\" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\[^\\\\n\\\\r\\]*= \\\\* \" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\" 1 \"vars\" } } */\n \n /* 17 * iter should be strength reduced.  */\n "}, {"sha": "63e582b6f43fcc1092f1c7c299e3fc9d9e4d6dd8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-3.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-3.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -20,7 +20,8 @@ void xxx(void)\n /* Access to arr_base[iter].y should not be strength reduced, since\n    we have a memory mode including multiplication by 4.  */\n \n-/* { dg-final { scan-tree-dump-times \"arr_base.*=\" 1 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\" 1 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"step:\" 1 \"vars\" } } */\n \n /* And original induction variable should be preserved.  */\n "}, {"sha": "49e5a41e0d54a5102f40ffa6bf447d856718fa4b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-4.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-4.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -32,9 +32,11 @@ void xxx(void)\n    -- induction variable with base 0, the memory access of form\n       *(iv + &arr_base[0].y) = ...\n \n-   In any case, we should not have 'arr_base[.*] ='  */\n+   In any case, we should not have any multiplication.  */\n \n-/* { dg-final { scan-tree-dump-times \"arr_base\\[.*\\]\\.y =\" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* \\[^\\\\n\\\\r\\]*=\" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\[^\\\\n\\\\r\\]*= \\\\* \" 0 \"vars\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\" 1 \"vars\" } } */\n \n /* And the original induction variable should be eliminated.  */\n "}, {"sha": "a03ce7214c8cf623f33a58a76fe111454c7aa419", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-9.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-9.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -0,0 +1,24 @@\n+/* Without TARGET_MEM_REFs, dom creates code like\n+   \n+   i1 = 4 * i;\n+   *(p + i1) = i;\n+   *(p + i1 + 4) = i\n+   \n+   causing us to have unnecessary multiplication by 4 in the\n+   result.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+void foo (int *p)\n+{\n+  int i;\n+\n+  for (i = 0; i < 100; i++)\n+    {\n+      p[i] = i;\n+      p[i + 1] = i;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times \"lea\" 0 { target i?86-*-* x86_64-*-* } } } */"}, {"sha": "4288c2c3c70483b8b00b6da69542f806d48b1764", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -185,7 +185,6 @@ create_stmt_ann (tree t)\n   return ann;\n }\n \n-\n /* Create a new annotation for a tree T.  */\n \n tree_ann_t"}, {"sha": "0820e6738e1f69299e9c88877056090610f47025", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -1869,6 +1869,13 @@ tree_could_trap_p (tree expr)\n  restart:\n   switch (code)\n     {\n+    case TARGET_MEM_REF:\n+      /* For TARGET_MEM_REFs use the information based on the original\n+\t reference.  */\n+      expr = TMR_ORIGINAL (expr);\n+      code = TREE_CODE (expr);\n+      goto restart;\n+\n     case COMPONENT_REF:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:"}, {"sha": "68f8562fc3a5807caefb0eb1b293cbda2606d007", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -66,7 +66,6 @@ get_stmt_ann (tree stmt)\n   return (ann) ? ann : create_stmt_ann (stmt);\n }\n \n-\n /* Return the annotation type for annotation ANN.  */\n static inline enum tree_ann_type\n ann_type (tree_ann_t ann)"}, {"sha": "7d7dc00a01be9450e9d7a576ec9e0577513e2024", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -736,7 +736,9 @@ void insert_edge_copies (tree, basic_block);\n extern void linear_transform_loops (struct loops *);\n \n /* In tree-ssa-loop-ivopts.c  */\n-extern bool expr_invariant_in_loop_p (struct loop *, tree);\n+bool expr_invariant_in_loop_p (struct loop *, tree);\n+bool multiplier_allowed_in_address_p (HOST_WIDE_INT);\n+unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode);\n \n /* In tree-ssa-threadupdate.c.  */\n extern bool thread_through_all_blocks (bitmap);\n@@ -745,6 +747,48 @@ extern bool thread_through_all_blocks (bitmap);\n tree force_gimple_operand (tree, tree *, bool, tree);\n tree force_gimple_operand_bsi (block_stmt_iterator *, tree, bool, tree);\n \n+/* In tree-ssa-address.c  */\n+\n+/* Affine combination of trees.  We keep track of at most MAX_AFF_ELTS elements\n+   to make things simpler; this is sufficient in most cases.  */\n+\n+#define MAX_AFF_ELTS 8\n+\n+struct affine_tree_combination\n+{\n+  /* Type of the result of the combination.  */\n+  tree type;\n+\n+  /* Mask modulo that the operations are performed.  */\n+  unsigned HOST_WIDE_INT mask;\n+\n+  /* Constant offset.  */\n+  unsigned HOST_WIDE_INT offset;\n+\n+  /* Number of elements of the combination.  */\n+  unsigned n;\n+\n+  /* Elements and their coefficients.  */\n+  tree elts[MAX_AFF_ELTS];\n+  unsigned HOST_WIDE_INT coefs[MAX_AFF_ELTS];\n+\n+  /* Remainder of the expression.  */\n+  tree rest;\n+};\n+\n+/* Description of a memory address.  */\n+\n+struct mem_address\n+{\n+  tree symbol, base, index, step, offset;\n+};\n+\n+tree create_mem_ref (block_stmt_iterator *, tree, \n+\t\t     struct affine_tree_combination *);\n+rtx addr_for_mem_ref (struct mem_address *, bool);\n+void get_address_description (tree, struct mem_address *);\n+tree maybe_fold_tmr (tree);\n+\n #include \"tree-flow-inline.h\"\n \n #endif /* _TREE_FLOW_H  */"}, {"sha": "401e6b15cdb7cfb221bbced119480f8b3a06e6e3", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -835,6 +835,14 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n                            integer_one_node));\n       break;\n \n+    case TARGET_MEM_REF:\n+      addr = tree_mem_ref_addr (ptr_type_node, t);\n+      base = addr;\n+      limit = fold_build2 (MINUS_EXPR, ptr_type_node,\n+\t\t\t   fold_build2 (PLUS_EXPR, ptr_type_node, base, size),\n+\t\t\t   build_int_cst_type (ptr_type_node, 1));\n+      break;\n+\n     case ARRAY_RANGE_REF:\n       warning (0, \"mudflap checking not yet implemented for ARRAY_RANGE_REF\");\n       return;"}, {"sha": "a079f3efb2ac8290f54b5df3024d655ade32d6e1", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -443,6 +443,64 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \"::\");\n       break;\n \n+    case TARGET_MEM_REF:\n+      {\n+\tconst char *sep = \"\";\n+\ttree tmp;\n+\n+\tpp_string (buffer, \"MEM[\");\n+\n+\ttmp = TMR_SYMBOL (node);\n+\tif (tmp)\n+\t  {\n+\t    pp_string (buffer, sep);\n+\t    sep = \", \";\n+\t    pp_string (buffer, \"symbol: \");\n+\t    dump_generic_node (buffer, tmp, spc, flags, false);\n+\t  }\n+\ttmp = TMR_BASE (node);\n+\tif (tmp)\n+\t  {\n+\t    pp_string (buffer, sep);\n+\t    sep = \", \";\n+\t    pp_string (buffer, \"base: \");\n+\t    dump_generic_node (buffer, tmp, spc, flags, false);\n+\t  }\n+\ttmp = TMR_INDEX (node);\n+\tif (tmp)\n+\t  {\n+\t    pp_string (buffer, sep);\n+\t    sep = \", \";\n+\t    pp_string (buffer, \"index: \");\n+\t    dump_generic_node (buffer, tmp, spc, flags, false);\n+\t  }\n+\ttmp = TMR_STEP (node);\n+\tif (tmp)\n+\t  {\n+\t    pp_string (buffer, sep);\n+\t    sep = \", \";\n+\t    pp_string (buffer, \"step: \");\n+\t    dump_generic_node (buffer, tmp, spc, flags, false);\n+\t  }\n+\ttmp = TMR_OFFSET (node);\n+\tif (tmp)\n+\t  {\n+\t    pp_string (buffer, sep);\n+\t    sep = \", \";\n+\t    pp_string (buffer, \"offset: \");\n+\t    dump_generic_node (buffer, tmp, spc, flags, false);\n+\t  }\n+\tpp_string (buffer, \"]\");\n+\tif (flags & TDF_DETAILS)\n+\t  {\n+\t    pp_string (buffer, \"{\");\n+\t    dump_generic_node (buffer, TMR_ORIGINAL (node), spc, flags,\n+\t\t\t       false);\n+\t    pp_string (buffer, \"}\");\n+\t  }\n+      }\n+      break;\n+\n     case ARRAY_TYPE:\n       {\n \ttree tmp;"}, {"sha": "0fdaba0702496a4bceb87f13f4547e4b2121c007", "filename": "gcc/tree-ssa-address.c", "status": "added", "additions": 707, "deletions": 0, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -0,0 +1,707 @@\n+/* Memory address lowering and addressing mode selection.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Utility functions for manipulation with TARGET_MEM_REFs -- tree expressions\n+   that directly map to addressing modes of the target.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n+#include \"flags.h\"\n+#include \"tree-inline.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"ggc.h\"\n+\n+/* TODO -- handling of symbols (according to Richard Hendersons\n+   comments, http://gcc.gnu.org/ml/gcc-patches/2005-04/msg00949.html):\n+   \n+   There are at least 5 different kinds of symbols that we can run up against:\n+\n+     (1) binds_local_p, small data area.\n+     (2) binds_local_p, eg local statics\n+     (3) !binds_local_p, eg global variables\n+     (4) thread local, local_exec\n+     (5) thread local, !local_exec\n+\n+   Now, (1) won't appear often in an array context, but it certainly can.\n+   All you have to do is set -GN high enough, or explicitly mark any\n+   random object __attribute__((section (\".sdata\"))).\n+\n+   All of these affect whether or not a symbol is in fact a valid address.\n+   The only one tested here is (3).  And that result may very well\n+   be incorrect for (4) or (5).\n+\n+   An incorrect result here does not cause incorrect results out the\n+   back end, because the expander in expr.c validizes the address.  However\n+   it would be nice to improve the handling here in order to produce more\n+   precise results.  */\n+\n+/* A \"template\" for memory address, used to determine whether the address is\n+   valid for mode.  */\n+\n+struct mem_addr_template GTY (())\n+{\n+  rtx ref;\t\t\t/* The template.  */\n+  rtx * GTY ((skip)) step_p;\t/* The point in template where the step should be\n+\t\t\t\t   filled in.  */\n+  rtx * GTY ((skip)) off_p;\t/* The point in template where the offset should\n+\t\t\t\t   be filled in.  */\n+};\n+\n+/* The templates.  Each of the five bits of the index corresponds to one\n+   component of TARGET_MEM_REF being present, see TEMPL_IDX.  */\n+\n+static GTY (()) struct mem_addr_template templates[32];\n+\n+#define TEMPL_IDX(SYMBOL, BASE, INDEX, STEP, OFFSET) \\\n+  (((SYMBOL != 0) << 4) \\\n+   | ((BASE != 0) << 3) \\\n+   | ((INDEX != 0) << 2) \\\n+   | ((STEP != 0) << 1) \\\n+   | (OFFSET != 0))\n+\n+/* Stores address for memory reference with parameters SYMBOL, BASE, INDEX,\n+   STEP and OFFSET to *ADDR.  Stores pointers to where step is placed to\n+   *STEP_P and offset to *OFFSET_P.  */\n+\n+static void\n+gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n+\t      rtx *addr, rtx **step_p, rtx **offset_p)\n+{\n+  rtx act_elem;\n+\n+  *addr = NULL_RTX;\n+  if (step_p)\n+    *step_p = NULL;\n+  if (offset_p)\n+    *offset_p = NULL;\n+\n+  if (index)\n+    {\n+      act_elem = index;\n+      if (step)\n+\t{\n+\t  act_elem = gen_rtx_MULT (Pmode, act_elem, step);\n+\n+\t  if (step_p)\n+\t    *step_p = &XEXP (act_elem, 1);\n+\t}\n+\n+      *addr = act_elem;\n+    }\n+\n+  if (base)\n+    {\n+      if (*addr)\n+\t*addr = gen_rtx_PLUS (Pmode, *addr, base);\n+      else\n+\t*addr = base;\n+    }\n+\n+  if (symbol)\n+    {\n+      act_elem = symbol;\n+      if (offset)\n+\t{\n+\t  act_elem = gen_rtx_CONST (Pmode,\n+\t\t\t\t    gen_rtx_PLUS (Pmode, act_elem, offset));\n+\t  if (offset_p)\n+\t    *offset_p = &XEXP (XEXP (act_elem, 0), 1);\n+\t}\n+\n+      if (*addr)\n+\t*addr = gen_rtx_PLUS (Pmode, *addr, act_elem);\n+      else\n+\t*addr = act_elem;\n+    }\n+  else if (offset)\n+    {\n+      if (*addr)\n+\t{\n+\t  *addr = gen_rtx_PLUS (Pmode, *addr, offset);\n+\t  if (offset_p)\n+\t    *offset_p = &XEXP (*addr, 1);\n+\t}\n+      else\n+\t{\n+\t  *addr = offset;\n+\t  if (offset_p)\n+\t    *offset_p = addr;\n+\t}\n+    }\n+\n+  if (!*addr)\n+    *addr = const0_rtx;\n+}\n+\n+/* Returns address for TARGET_MEM_REF with parameters given by ADDR.\n+   If REALLY_EXPAND is false, just make fake registers instead \n+   of really expanding the operands, and perform the expansion in-place\n+   by using one of the \"templates\".  */\n+\n+rtx\n+addr_for_mem_ref (struct mem_address *addr, bool really_expand)\n+{\n+  rtx address, sym, bse, idx, st, off;\n+  static bool templates_initialized = false;\n+  struct mem_addr_template *templ;\n+\n+  if (addr->step && !integer_onep (addr->step))\n+    st = immed_double_const (TREE_INT_CST_LOW (addr->step),\n+\t\t\t     TREE_INT_CST_HIGH (addr->step), Pmode);\n+  else\n+    st = NULL_RTX;\n+\n+  if (addr->offset && !integer_zerop (addr->offset))\n+    off = immed_double_const (TREE_INT_CST_LOW (addr->offset),\n+\t\t\t      TREE_INT_CST_HIGH (addr->offset), Pmode);\n+  else\n+    off = NULL_RTX;\n+\n+  if (!really_expand)\n+    {\n+      /* Reuse the templates for addresses, so that we do not waste memory.  */\n+      if (!templates_initialized)\n+\t{\n+\t  unsigned i;\n+\n+\t  templates_initialized = true;\n+\t  sym = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (\"test_symbol\"));\n+\t  bse = gen_raw_REG (Pmode, FIRST_PSEUDO_REGISTER);\n+\t  idx = gen_raw_REG (Pmode, FIRST_PSEUDO_REGISTER + 1);\n+\n+\t  for (i = 0; i < 32; i++)\n+\t    gen_addr_rtx ((i & 16 ? sym : NULL_RTX),\n+\t\t\t  (i & 8 ? bse : NULL_RTX),\n+\t\t\t  (i & 4 ? idx : NULL_RTX),\n+\t\t\t  (i & 2 ? const0_rtx : NULL_RTX),\n+\t\t\t  (i & 1 ? const0_rtx : NULL_RTX),\n+\t\t\t  &templates[i].ref,\n+\t\t\t  &templates[i].step_p,\n+\t\t\t  &templates[i].off_p);\n+\t}\n+\n+      templ = templates + TEMPL_IDX (addr->symbol, addr->base, addr->index,\n+\t\t\t\t     st, off);\n+      if (st)\n+\t*templ->step_p = st;\n+      if (off)\n+\t*templ->off_p = off;\n+\n+      return templ->ref;\n+    }\n+\n+  /* Otherwise really expand the expressions.  */\n+  sym = (addr->symbol\n+\t ? expand_expr (build_addr (addr->symbol, current_function_decl),\n+\t\t\tNULL_RTX, Pmode, EXPAND_NORMAL)\n+\t : NULL_RTX);\n+  bse = (addr->base\n+\t ? expand_expr (addr->base, NULL_RTX, Pmode, EXPAND_NORMAL)\n+\t : NULL_RTX);\n+  idx = (addr->index\n+\t ? expand_expr (addr->index, NULL_RTX, Pmode, EXPAND_NORMAL)\n+\t : NULL_RTX);\n+\n+  gen_addr_rtx (sym, bse, idx, st, off, &address, NULL, NULL);\n+  return address;\n+}\n+\n+/* Returns address of MEM_REF in TYPE.  */\n+\n+tree\n+tree_mem_ref_addr (tree type, tree mem_ref)\n+{\n+  tree addr = NULL_TREE;\n+  tree act_elem;\n+  tree step = TMR_STEP (mem_ref), offset = TMR_OFFSET (mem_ref);\n+\n+  act_elem = TMR_INDEX (mem_ref);\n+  if (act_elem)\n+    {\n+      act_elem = fold_convert (type, act_elem);\n+\n+      if (step)\n+\tact_elem = fold_build2 (MULT_EXPR, type, act_elem,\n+\t\t\t\tfold_convert (type, step));\n+      addr = act_elem;\n+    }\n+\n+  act_elem = TMR_BASE (mem_ref);\n+  if (act_elem)\n+    {\n+      act_elem = fold_convert (type, act_elem);\n+\n+      if (addr)\n+\taddr = fold_build2 (PLUS_EXPR, type, addr, act_elem);\n+      else\n+\taddr = act_elem;\n+    }\n+\n+  act_elem = TMR_SYMBOL (mem_ref);\n+  if (act_elem)\n+    {\n+      act_elem = fold_convert (type, build_addr (act_elem,\n+\t\t\t\t\t\t current_function_decl));\n+      if (addr)\n+\taddr = fold_build2 (PLUS_EXPR, type, addr, act_elem);\n+      else\n+\taddr = act_elem;\n+    }\n+\n+  if (!zero_p (offset))\n+    {\n+      act_elem = fold_convert (type, offset);\n+\n+      if (addr)\n+\taddr = fold_build2 (PLUS_EXPR, type, addr, act_elem);\n+      else\n+\taddr = act_elem;\n+    }\n+\n+  if (!addr)\n+    addr = build_int_cst (type, 0);\n+\n+  return addr;\n+}\n+\n+/* Returns true if a memory reference in MODE and with parameters given by\n+   ADDR is valid on the current target.  */\n+\n+static bool\n+valid_mem_ref_p (enum machine_mode mode, struct mem_address *addr)\n+{\n+  rtx address;\n+\n+  address = addr_for_mem_ref (addr, false);\n+  if (!address)\n+    return false;\n+\n+  return memory_address_p (mode, address);\n+}\n+\n+/* Checks whether a TARGET_MEM_REF with type TYPE and parameters given by ADDR\n+   is valid on the current target and if so, creates and returns the\n+   TARGET_MEM_REF.  */\n+\n+static tree\n+create_mem_ref_raw (tree type, struct mem_address *addr)\n+{\n+  if (!valid_mem_ref_p (TYPE_MODE (type), addr))\n+    return NULL_TREE;\n+\n+  if (addr->step && integer_onep (addr->step))\n+    addr->step = NULL_TREE;\n+\n+  if (addr->offset && zero_p (addr->offset))\n+    addr->offset = NULL_TREE;\n+\n+  return build7 (TARGET_MEM_REF, type,\n+\t\t addr->symbol, addr->base, addr->index,\n+\t\t addr->step, addr->offset, NULL, NULL);\n+}\n+\n+/* Returns true if OBJ is an object whose address is a link time constant.  */\n+\n+static bool\n+fixed_address_object_p (tree obj)\n+{\n+  return (TREE_CODE (obj) == VAR_DECL\n+\t  && (TREE_STATIC (obj)\n+\t      || DECL_EXTERNAL (obj)));\n+}\n+\n+/* Adds COEF * ELT to PARTS.  TYPE is the type of the address we\n+   construct.  */\n+\n+static void\n+add_to_parts (struct mem_address *parts, tree type, tree elt,\n+\t      unsigned HOST_WIDE_INT coef)\n+{\n+  /* Check if this is a symbol.  */\n+  if (!parts->symbol\n+      && coef == 1\n+      && TREE_CODE (elt) == ADDR_EXPR\n+      && fixed_address_object_p (TREE_OPERAND (elt, 0)))\n+    {\n+      parts->symbol = TREE_OPERAND (elt, 0);\n+      return;\n+    }\n+\n+  if (coef != 1)\n+    elt = fold_build2 (MULT_EXPR, type, fold_convert (type, elt),\n+\t\t       build_int_cst_type (type, coef));\n+  else\n+    elt = fold_convert (type, elt);\n+\n+  if (!parts->base)\n+    {\n+      parts->base = elt;\n+      return;\n+    }\n+\n+  if (!parts->index)\n+    {\n+      parts->index = elt;\n+      return;\n+    }\n+\n+  /* Add ELT to base.  */\n+  parts->base = fold_build2 (PLUS_EXPR, type, parts->base, elt);\n+}\n+\n+/* Finds the most expensive multiplication in ADDR that can be\n+   expressed in an addressing mode and move the corresponding\n+   element(s) to PARTS.  TYPE is the type of the address we\n+   construct.  */\n+\n+static void\n+most_expensive_mult_to_index (struct mem_address *parts, tree type,\n+\t\t\t      struct affine_tree_combination *addr)\n+{\n+  unsigned HOST_WIDE_INT best_mult = 0;\n+  unsigned best_mult_cost = 0, acost;\n+  tree mult_elt = NULL_TREE, elt;\n+  unsigned i, j;\n+\n+  for (i = 0; i < addr->n; i++)\n+    {\n+      if (addr->coefs[i] == 1\n+\t  || !multiplier_allowed_in_address_p (addr->coefs[i]))\n+\tcontinue;\n+      \n+      acost = multiply_by_cost (addr->coefs[i], Pmode);\n+\n+      if (acost > best_mult_cost)\n+\t{\n+\t  best_mult_cost = acost;\n+\t  best_mult = addr->coefs[i];\n+\t}\n+    }\n+\n+  if (!best_mult)\n+    return;\n+\n+  for (i = j = 0; i < addr->n; i++)\n+    {\n+      if (addr->coefs[i] != best_mult)\n+\t{\n+\t  addr->coefs[j] = addr->coefs[i];\n+\t  addr->elts[j] = addr->elts[i];\n+\t  j++;\n+\t  continue;\n+\t}\n+\n+      elt = fold_convert (type, addr->elts[i]);\n+      if (!mult_elt)\n+\tmult_elt = elt;\n+      else\n+\tmult_elt = fold_build2 (PLUS_EXPR, type, mult_elt, elt);\n+    }\n+  addr->n = j;\n+\n+  parts->index = mult_elt;\n+  parts->step = build_int_cst_type (type, best_mult);\n+}\n+\n+/* Splits address ADDR into PARTS.\n+   \n+   TODO -- be more clever about the distribution of the elements of ADDR\n+   to PARTS.  Some architectures do not support anything but single\n+   register in address, possibly with a small integer offset; while\n+   create_mem_ref will simplify the address to an acceptable shape\n+   later, it would be a small bit more efficient to know that asking\n+   for complicated addressing modes is useless.  */\n+\n+static void\n+addr_to_parts (struct affine_tree_combination *addr, tree type,\n+\t       struct mem_address *parts)\n+{\n+  unsigned i;\n+\n+  parts->symbol = NULL_TREE;\n+  parts->base = NULL_TREE;\n+  parts->index = NULL_TREE;\n+  parts->step = NULL_TREE;\n+\n+  if (addr->offset)\n+    parts->offset = build_int_cst_type (type, addr->offset);\n+  else\n+    parts->offset = NULL_TREE;\n+\n+  /* First move the most expensive feasible multiplication\n+     to index.  */\n+  most_expensive_mult_to_index (parts, type, addr);\n+\n+  /* Then try to process the remaining elements.  */\n+  for (i = 0; i < addr->n; i++)\n+    add_to_parts (parts, type, addr->elts[i], addr->coefs[i]);\n+  if (addr->rest)\n+    add_to_parts (parts, type, addr->rest, 1);\n+}\n+\n+/* Force the PARTS to register.  */\n+\n+static void\n+gimplify_mem_ref_parts (block_stmt_iterator *bsi, struct mem_address *parts)\n+{\n+  if (parts->base)\n+    parts->base = force_gimple_operand_bsi (bsi, parts->base,\n+\t\t\t\t\t    true, NULL_TREE);\n+  if (parts->index)\n+    parts->index = force_gimple_operand_bsi (bsi, parts->index,\n+\t\t\t\t\t     true, NULL_TREE);\n+}\n+\n+/* Creates and returns a TARGET_MEM_REF for address ADDR.  If necessary\n+   computations are emitted in front of BSI.  TYPE is the mode\n+   of created memory reference.  */\n+\n+tree\n+create_mem_ref (block_stmt_iterator *bsi, tree type,\n+\t\tstruct affine_tree_combination *addr)\n+{\n+  tree mem_ref, tmp;\n+  tree addr_type = build_pointer_type (type);\n+  struct mem_address parts;\n+\n+  addr_to_parts (addr, addr_type, &parts);\n+  gimplify_mem_ref_parts (bsi, &parts);\n+  mem_ref = create_mem_ref_raw (type, &parts);\n+  if (mem_ref)\n+    return mem_ref;\n+\n+  /* The expression is too complicated.  Try making it simpler.  */\n+\n+  if (parts.step && !integer_onep (parts.step))\n+    {\n+      /* Move the multiplication to index.  */\n+      gcc_assert (parts.index);\n+      parts.index = force_gimple_operand_bsi (bsi,\n+\t\t\t\t\t      build2 (MULT_EXPR, addr_type,\n+\t\t\t\t\t\t      parts.index, parts.step),\n+\t\t\t\t\t      true, NULL_TREE);\n+      parts.step = NULL_TREE;\n+  \n+      mem_ref = create_mem_ref_raw (type, &parts);\n+      if (mem_ref)\n+\treturn mem_ref;\n+    }\n+\n+  if (parts.symbol)\n+    {\n+      tmp = build_addr (parts.symbol, current_function_decl);\n+    \n+      /* Add the symbol to base, eventually forcing it to register.  */\n+      if (parts.base)\n+\tparts.base = force_gimple_operand_bsi (bsi,\n+\t\t\t\t\t       build2 (PLUS_EXPR, addr_type,\n+\t\t\t\t\t\t       parts.base, tmp),\n+\t\t\t\t\t       true, NULL_TREE);\n+      else\n+\tparts.base = tmp;\n+      parts.symbol = NULL_TREE;\n+\n+      mem_ref = create_mem_ref_raw (type, &parts);\n+      if (mem_ref)\n+\treturn mem_ref;\n+    }\n+\n+  if (parts.base)\n+    {\n+      /* Add base to index.  */\n+      if (parts.index)\n+\tparts.index = force_gimple_operand_bsi (bsi,\n+\t\t\t\t\t\tbuild2 (PLUS_EXPR, addr_type,\n+\t\t\t\t\t\t\tparts.base,\n+\t\t\t\t\t\t\tparts.index),\n+\t\t\t\t\t\ttrue, NULL_TREE);\n+      else\n+\tparts.index = parts.base;\n+      parts.base = NULL_TREE;\n+\n+      mem_ref = create_mem_ref_raw (type, &parts);\n+      if (mem_ref)\n+\treturn mem_ref;\n+    }\n+\n+  if (parts.offset && !integer_zerop (parts.offset))\n+    {\n+      /* Try adding offset to index.  */\n+      if (parts.index)\n+\tparts.index = force_gimple_operand_bsi (bsi, \n+\t\t\t\t\t\tbuild2 (PLUS_EXPR, addr_type,\n+\t\t\t\t\t\t\tparts.index,\n+\t\t\t\t\t\t\tparts.offset),\n+\t\t\t\t\t\ttrue, NULL_TREE);\n+      else\n+\tparts.index = parts.offset, bsi;\n+\n+      parts.offset = NULL_TREE;\n+\n+      mem_ref = create_mem_ref_raw (type, &parts);\n+      if (mem_ref)\n+\treturn mem_ref;\n+    }\n+\n+  /* Verify that the address is in the simplest possible shape\n+     (only a register).  If we cannot create such a memory reference,\n+     something is really wrong.  */\n+  gcc_assert (parts.symbol == NULL_TREE);\n+  gcc_assert (parts.base == NULL_TREE);\n+  gcc_assert (!parts.step || integer_onep (parts.step));\n+  gcc_assert (!parts.offset || integer_zerop (parts.offset));\n+  gcc_unreachable ();\n+}\n+\n+/* Copies components of the address from OP to ADDR.  */\n+\n+void\n+get_address_description (tree op, struct mem_address *addr)\n+{\n+  addr->symbol = TMR_SYMBOL (op);\n+  addr->base = TMR_BASE (op);\n+  addr->index = TMR_INDEX (op);\n+  addr->step = TMR_STEP (op);\n+  addr->offset = TMR_OFFSET (op);\n+}\n+\n+/* Copies the additional information attached to target_mem_ref FROM to TO.  */\n+\n+void\n+copy_mem_ref_info (tree to, tree from)\n+{\n+  /* Copy the annotation, to preserve the aliasing information.  */\n+  TMR_TAG (to) = TMR_TAG (from);\n+\n+  /* And the info about the original reference.  */\n+  TMR_ORIGINAL (to) = TMR_ORIGINAL (from);\n+}\n+\n+/* Move constants in target_mem_ref REF to offset.  Returns the new target\n+   mem ref if anything changes, NULL_TREE otherwise.  */\n+\n+tree\n+maybe_fold_tmr (tree ref)\n+{\n+  struct mem_address addr;\n+  bool changed = false;\n+  tree ret, off;\n+\n+  get_address_description (ref, &addr);\n+\n+  if (addr.base && TREE_CODE (addr.base) == INTEGER_CST)\n+    {\n+      if (addr.offset)\n+\taddr.offset = fold_binary_to_constant (PLUS_EXPR, ptr_type_node,\n+\t\t\t\t\t       addr.offset, addr.base);\n+      else\n+\taddr.offset = addr.base;\n+\n+      addr.base = NULL_TREE;\n+      changed = true;\n+    }\n+\n+  if (addr.index && TREE_CODE (addr.index) == INTEGER_CST)\n+    {\n+      off = addr.index;\n+      if (addr.step)\n+\t{\n+\t  off = fold_binary_to_constant (MULT_EXPR, ptr_type_node,\n+\t\t\t\t\t off, addr.step);\n+\t  addr.step = NULL_TREE;\n+\t}\n+\n+      if (addr.offset)\n+\t{\n+\t  addr.offset = fold_binary_to_constant (PLUS_EXPR, ptr_type_node,\n+\t\t\t\t\t\t addr.offset, off);\n+\t}\n+      else\n+\taddr.offset = off;\n+\n+      addr.index = NULL_TREE;\n+      changed = true;\n+    }\n+\n+  if (!changed)\n+    return NULL_TREE;\n+  \n+  ret = create_mem_ref_raw (TREE_TYPE (ref), &addr);\n+  if (!ret)\n+    return NULL_TREE;\n+\n+  copy_mem_ref_info (ret, ref);\n+  return ret;\n+}\n+\n+/* Dump PARTS to FILE.  */\n+\n+extern void dump_mem_address (FILE *, struct mem_address *);\n+void\n+dump_mem_address (FILE *file, struct mem_address *parts)\n+{\n+  if (parts->symbol)\n+    {\n+      fprintf (file, \"symbol: \");\n+      print_generic_expr (file, parts->symbol, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+  if (parts->base)\n+    {\n+      fprintf (file, \"base: \");\n+      print_generic_expr (file, parts->base, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+  if (parts->index)\n+    {\n+      fprintf (file, \"index: \");\n+      print_generic_expr (file, parts->index, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+  if (parts->step)\n+    {\n+      fprintf (file, \"step: \");\n+      print_generic_expr (file, parts->step, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+  if (parts->offset)\n+    {\n+      fprintf (file, \"offset: \");\n+      print_generic_expr (file, parts->offset, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+}\n+\n+#include \"gt-tree-ssa-address.h\""}, {"sha": "6816dafd6c1b24c9d0489bf701c218a95b35a839", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -1874,7 +1874,6 @@ maybe_fold_stmt_addition (tree expr)\n   return t;\n }\n \n-\n /* Subroutine of fold_stmt called via walk_tree.  We perform several\n    simplifications of EXPR_P, mostly having to do with pointer arithmetic.  */\n \n@@ -1948,6 +1947,10 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n       }\n       break;\n \n+    case TARGET_MEM_REF:\n+      t = maybe_fold_tmr (expr);\n+      break;\n+\n     default:\n       return NULL_TREE;\n     }"}, {"sha": "b7a57f61ede659c21bd85ff9566659635cc835b3", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -204,6 +204,17 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \tcase VECTOR_CST:\n \t  return true;\n \n+\tcase TARGET_MEM_REF:\n+\t  idx = &TMR_BASE (*addr_p);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\t  idx = &TMR_INDEX (*addr_p);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\t  return true;\n+\n \tdefault:\n     \t  gcc_unreachable ();\n \t}"}, {"sha": "716d113e75ecd7be15c2bb2ba4653177d0d5f27e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 244, "deletions": 215, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -1494,6 +1494,11 @@ may_be_unaligned_p (tree ref)\n   int unsignedp, volatilep;\n   unsigned base_align;\n \n+  /* TARGET_MEM_REFs are translated directly to valid MEMs on the target,\n+     thus they are not missaligned.  */\n+  if (TREE_CODE (ref) == TARGET_MEM_REF)\n+    return false;\n+\n   /* The test below is basically copy of what expr.c:normal_inner_ref\n      does to check whether the object must be loaded by parts when\n      STRICT_ALIGNMENT is true.  */\n@@ -1516,7 +1521,7 @@ may_be_unaligned_p (tree ref)\n static void\n find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n {\n-  tree base = unshare_expr (*op_p), step = NULL;\n+  tree base = *op_p, step = NULL;\n   struct iv *civ;\n   struct ifs_ivopts_data ifs_ivopts_data;\n \n@@ -1535,17 +1540,63 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n       && may_be_unaligned_p (base))\n     goto fail;\n \n-  ifs_ivopts_data.ivopts_data = data;\n-  ifs_ivopts_data.stmt = stmt;\n-  ifs_ivopts_data.step_p = &step;\n-  if (!for_each_index (&base, idx_find_step, &ifs_ivopts_data)\n-      || zero_p (step))\n-    goto fail;\n+  base = unshare_expr (base);\n+\n+  if (TREE_CODE (base) == TARGET_MEM_REF)\n+    {\n+      tree type = build_pointer_type (TREE_TYPE (base));\n+      tree astep;\n+\n+      if (TMR_BASE (base)\n+\t  && TREE_CODE (TMR_BASE (base)) == SSA_NAME)\n+\t{\n+\t  civ = get_iv (data, TMR_BASE (base));\n+\t  if (!civ)\n+\t    goto fail;\n+\n+\t  TMR_BASE (base) = civ->base;\n+\t  step = civ->step;\n+\t}\n+      if (TMR_INDEX (base)\n+\t  && TREE_CODE (TMR_INDEX (base)) == SSA_NAME)\n+\t{\n+\t  civ = get_iv (data, TMR_INDEX (base));\n+\t  if (!civ)\n+\t    goto fail;\n \n-  gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n-  gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n+\t  TMR_INDEX (base) = civ->base;\n+\t  astep = civ->step;\n \n-  base = build_fold_addr_expr (base);\n+\t  if (astep)\n+\t    {\n+\t      if (TMR_STEP (base))\n+\t\tastep = fold_build2 (MULT_EXPR, type, TMR_STEP (base), astep);\n+\n+\t      if (step)\n+\t\tstep = fold_build2 (PLUS_EXPR, type, step, astep);\n+\t      else\n+\t\tstep = astep;\n+\t    }\n+\t}\n+\n+      if (zero_p (step))\n+\tgoto fail;\n+      base = tree_mem_ref_addr (type, base);\n+    }\n+  else\n+    {\n+      ifs_ivopts_data.ivopts_data = data;\n+      ifs_ivopts_data.stmt = stmt;\n+      ifs_ivopts_data.step_p = &step;\n+      if (!for_each_index (&base, idx_find_step, &ifs_ivopts_data)\n+\t  || zero_p (step))\n+\tgoto fail;\n+\n+      gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n+      gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n+\n+      base = build_fold_addr_expr (base);\n+    }\n \n   civ = alloc_iv (base, step);\n   record_use (data, op_p, civ, stmt, USE_ADDRESS);\n@@ -2614,33 +2665,6 @@ constant_multiple_of (tree type, tree top, tree bot)\n     }\n }\n \n-/* Affine combination of trees.  We keep track of at most MAX_AFF_ELTS elements\n-   to make things simpler; this is sufficient in most cases.  */\n-\n-#define MAX_AFF_ELTS 8\n-\n-struct affine_tree_combination\n-{\n-  /* Type of the result of the combination.  */\n-  tree type;\n-\n-  /* Mask modulo that the operations are performed.  */\n-  unsigned HOST_WIDE_INT mask;\n-\n-  /* Constant offset.  */\n-  unsigned HOST_WIDE_INT offset;\n-\n-  /* Number of elements of the combination.  */\n-  unsigned n;\n-\n-  /* Elements and their coefficients.  */\n-  tree elts[MAX_AFF_ELTS];\n-  unsigned HOST_WIDE_INT coefs[MAX_AFF_ELTS];\n-\n-  /* Remainder of the expression.  */\n-  tree rest;\n-};\n-\n /* Sets COMB to CST.  */\n \n static void\n@@ -2893,6 +2917,19 @@ add_elt_to_tree (tree expr, tree type, tree elt, unsigned HOST_WIDE_INT scale,\n   return fold_build2 (code, type, expr, elt);\n }\n \n+/* Copies the tree elements of COMB to ensure that they are not shared.  */\n+\n+static void\n+unshare_aff_combination (struct affine_tree_combination *comb)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < comb->n; i++)\n+    comb->elts[i] = unshare_expr (comb->elts[i]);\n+  if (comb->rest)\n+    comb->rest = unshare_expr (comb->rest);\n+}\n+\n /* Makes tree from the affine combination COMB.  */\n \n static tree\n@@ -2903,6 +2940,11 @@ aff_combination_to_tree (struct affine_tree_combination *comb)\n   unsigned i;\n   unsigned HOST_WIDE_INT off, sgn;\n \n+  /* Handle the special case produced by get_computation_aff when\n+     the type does not fit in HOST_WIDE_INT.  */\n+  if (comb->n == 0 && comb->offset == 0)\n+    return fold_convert (type, expr);\n+\n   gcc_assert (comb->n == MAX_AFF_ELTS || comb->rest == NULL_TREE);\n \n   for (i = 0; i < comb->n; i++)\n@@ -2924,49 +2966,14 @@ aff_combination_to_tree (struct affine_tree_combination *comb)\n \t\t\t  comb->mask);\n }\n \n-/* Folds X + RATIO * Y in TYPE.  */\n-\n-static tree\n-fold_affine_sum (tree type, tree x, tree y, HOST_WIDE_INT ratio)\n-{\n-  enum tree_code code;\n-  tree cst;\n-  struct affine_tree_combination cx, cy;\n-\n-  if (TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT)\n-    {\n-      if (ratio == 1)\n-\treturn fold_build2 (PLUS_EXPR, type, x, y);\n-      if (ratio == -1)\n-\treturn fold_build2 (MINUS_EXPR, type, x, y);\n-\n-      if (ratio < 0)\n-\t{\n-\t  code = MINUS_EXPR;\n-\t  ratio = -ratio;\n-\t}\n-      else\n-\tcode = PLUS_EXPR;\n-\n-      cst = build_int_cst_type (type, ratio);\n-      y = fold_build2 (MULT_EXPR, type, y, cst);\n-      return fold_build2 (code, type, x, y);\n-    }\n-\n-  tree_to_aff_combination (x, type, &cx);\n-  tree_to_aff_combination (y, type, &cy);\n-  aff_combination_scale (&cy, ratio);\n-  aff_combination_add (&cx, &cy);\n-\n-  return aff_combination_to_tree (&cx);\n-}\n-\n /* Determines the expression by that USE is expressed from induction variable\n-   CAND at statement AT in LOOP.  */\n+   CAND at statement AT in LOOP.  The expression is stored in a decomposed\n+   form into AFF.  Returns false if USE cannot be expressed using CAND.  */\n \n-static tree\n-get_computation_at (struct loop *loop,\n-\t\t    struct iv_use *use, struct iv_cand *cand, tree at)\n+static bool\n+get_computation_aff (struct loop *loop,\n+\t\t     struct iv_use *use, struct iv_cand *cand, tree at,\n+\t\t     struct affine_tree_combination *aff)\n {\n   tree ubase = use->iv->base;\n   tree ustep = use->iv->step;\n@@ -2978,11 +2985,12 @@ get_computation_at (struct loop *loop,\n   tree ratio;\n   unsigned HOST_WIDE_INT ustepi, cstepi;\n   HOST_WIDE_INT ratioi;\n+  struct affine_tree_combination cbase_aff, expr_aff;\n \n   if (TYPE_PRECISION (utype) > TYPE_PRECISION (ctype))\n     {\n       /* We do not have a precision to express the values of use.  */\n-      return NULL_TREE;\n+      return false;\n     }\n \n   expr = var_at_stmt (loop, cand, at);\n@@ -3020,7 +3028,7 @@ get_computation_at (struct loop *loop,\n \t  /* TODO maybe consider case when ustep divides cstep and the ratio is\n \t     a power of 2 (so that the division is fast to execute)?  We would\n \t     need to be much more careful with overflows etc. then.  */\n-\t  return NULL_TREE;\n+\t  return false;\n \t}\n \n       ratio = build_int_cst_type (uutype, ratioi);\n@@ -3029,7 +3037,7 @@ get_computation_at (struct loop *loop,\n     {\n       ratio = constant_multiple_of (uutype, ustep, cstep);\n       if (!ratio)\n-\treturn NULL_TREE;\n+\treturn false;\n \n       /* Ratioi is only used to detect special cases when the multiplicative\n \t factor is 1 or -1, so if we cannot convert ratio to HOST_WIDE_INT,\n@@ -3058,34 +3066,71 @@ get_computation_at (struct loop *loop,\n      happen, fold is able to apply the distributive law to obtain this form\n      anyway.  */\n \n-  if (ratioi == 1)\n+  if (TYPE_PRECISION (uutype) > HOST_BITS_PER_WIDE_INT)\n     {\n-      delta = fold_affine_sum (uutype, ubase, cbase, -1);\n-      expr = fold_build2 (PLUS_EXPR, uutype, expr, delta);\n-    }\n-  else if (ratioi == -1)\n-    {\n-      delta = fold_affine_sum (uutype, ubase, cbase, 1);\n-      expr = fold_build2 (MINUS_EXPR, uutype, delta, expr);\n-    }\n-  else\n-    {\n-      if (ratioi)\n-\tdelta = fold_affine_sum (uutype, ubase, cbase, -ratioi);\n+      /* Let's compute in trees and just return the result in AFF.  This case\n+\t should not be very common, and fold itself is not that bad either,\n+\t so making the aff. functions more complicated to handle this case\n+\t is not that urgent.  */\n+      if (ratioi == 1)\n+\t{\n+\t  delta = fold_build2 (MINUS_EXPR, uutype, ubase, cbase);\n+\t  expr = fold_build2 (PLUS_EXPR, uutype, expr, delta);\n+\t}\n+      else if (ratioi == -1)\n+\t{\n+\t  delta = fold_build2 (PLUS_EXPR, uutype, ubase, cbase);\n+\t  expr = fold_build2 (MINUS_EXPR, uutype, delta, expr);\n+\t}\n       else\n \t{\n-\t  delta = fold_build2 (MULT_EXPR, uutype, ratio, cbase);\n-\t  delta = fold_affine_sum (uutype, ubase, delta, -1);\n+\t  delta = fold_build2 (MULT_EXPR, uutype, cbase, ratio);\n+\t  delta = fold_build2 (MINUS_EXPR, uutype, ubase, delta);\n+\t  expr = fold_build2 (MULT_EXPR, uutype, ratio, expr);\n+\t  expr = fold_build2 (PLUS_EXPR, uutype, delta, expr);\n \t}\n-      expr = fold_build2 (MULT_EXPR, uutype, ratio, expr);\n-      expr = fold_build2 (PLUS_EXPR, uutype, delta, expr);\n+\n+      aff->type = uutype;\n+      aff->n = 0;\n+      aff->offset = 0;\n+      aff->mask = 0;\n+      aff->rest = expr;\n+      return true;\n     }\n \n-  return fold_convert (utype, expr);\n+  /* If we got here, the types fits in HOST_WIDE_INT, thus it must be\n+     possible to compute ratioi.  */\n+  gcc_assert (ratioi);\n+\n+  tree_to_aff_combination (ubase, uutype, aff);\n+  tree_to_aff_combination (cbase, uutype, &cbase_aff);\n+  tree_to_aff_combination (expr, uutype, &expr_aff);\n+  aff_combination_scale (&cbase_aff, -ratioi);\n+  aff_combination_scale (&expr_aff, ratioi);\n+  aff_combination_add (aff, &cbase_aff);\n+  aff_combination_add (aff, &expr_aff);\n+\n+  return true;\n+}\n+\n+/* Determines the expression by that USE is expressed from induction variable\n+   CAND at statement AT in LOOP.  The computation is unshared.  */\n+\n+static tree\n+get_computation_at (struct loop *loop,\n+\t\t    struct iv_use *use, struct iv_cand *cand, tree at)\n+{\n+  struct affine_tree_combination aff;\n+  tree type = TREE_TYPE (use->iv->base);\n+\n+  if (!get_computation_aff (loop, use, cand, at, &aff))\n+    return NULL_TREE;\n+  unshare_aff_combination (&aff);\n+  return fold_convert (type, aff_combination_to_tree (&aff));\n }\n \n /* Determines the expression by that USE is expressed from induction variable\n-   CAND in LOOP.  */\n+   CAND in LOOP.  The computation is unshared.  */\n \n static tree\n get_computation (struct loop *loop, struct iv_use *use, struct iv_cand *cand)\n@@ -3157,7 +3202,7 @@ mbc_entry_eq (const void *entry1, const void *entry2)\n \n /* Returns cost of multiplication by constant CST in MODE.  */\n \n-static unsigned\n+unsigned\n multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode)\n {\n   static htab_t costs;\n@@ -3195,6 +3240,47 @@ multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode)\n   return cost;\n }\n \n+/* Returns true if multiplying by RATIO is allowed in address.  */\n+\n+bool\n+multiplier_allowed_in_address_p (HOST_WIDE_INT ratio)\n+{\n+#define MAX_RATIO 128\n+  static sbitmap valid_mult;\n+  \n+  if (!valid_mult)\n+    {\n+      rtx reg1 = gen_raw_REG (Pmode, FIRST_PSEUDO_REGISTER);\n+      rtx addr;\n+      HOST_WIDE_INT i;\n+\n+      valid_mult = sbitmap_alloc (2 * MAX_RATIO + 1);\n+      sbitmap_zero (valid_mult);\n+      addr = gen_rtx_fmt_ee (MULT, Pmode, reg1, NULL_RTX);\n+      for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n+\t{\n+\t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n+\t  if (memory_address_p (Pmode, addr))\n+\t    SET_BIT (valid_mult, i + MAX_RATIO);\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  allowed multipliers:\");\n+\t  for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n+\t    if (TEST_BIT (valid_mult, i + MAX_RATIO))\n+\t      fprintf (dump_file, \" %d\", (int) i);\n+\t  fprintf (dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+\n+  if (ratio > MAX_RATIO || ratio < -MAX_RATIO)\n+    return false;\n+\n+  return TEST_BIT (valid_mult, ratio + MAX_RATIO);\n+}\n+\n /* Returns cost of address in shape symbol + var + OFFSET + RATIO * index.\n    If SYMBOL_PRESENT is false, symbol is omitted.  If VAR_PRESENT is false,\n    variable is omitted.  The created memory accesses MODE.\n@@ -3205,8 +3291,7 @@ static unsigned\n get_address_cost (bool symbol_present, bool var_present,\n \t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio)\n {\n-#define MAX_RATIO 128\n-  static sbitmap valid_mult;\n+  static bool initialized = false;\n   static HOST_WIDE_INT rat, off;\n   static HOST_WIDE_INT min_offset, max_offset;\n   static unsigned costs[2][2][2][2];\n@@ -3218,9 +3303,10 @@ get_address_cost (bool symbol_present, bool var_present,\n   unsigned HOST_WIDE_INT mask;\n   unsigned bits;\n \n-  if (!valid_mult)\n+  if (!initialized)\n     {\n       HOST_WIDE_INT i;\n+      initialized = true;\n \n       reg1 = gen_raw_REG (Pmode, FIRST_PSEUDO_REGISTER);\n \n@@ -3249,29 +3335,13 @@ get_address_cost (bool symbol_present, bool var_present,\n \t  fprintf (dump_file, \"  max offset %d\\n\", (int) max_offset);\n \t}\n \n-      valid_mult = sbitmap_alloc (2 * MAX_RATIO + 1);\n-      sbitmap_zero (valid_mult);\n       rat = 1;\n-      addr = gen_rtx_fmt_ee (MULT, Pmode, reg1, NULL_RTX);\n-      for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n-\t{\n-\t  XEXP (addr, 1) = GEN_INT (i);\n-\t  if (memory_address_p (Pmode, addr))\n-\t    {\n-\t      SET_BIT (valid_mult, i + MAX_RATIO);\n-\t      rat = i;\n-\t    }\n-\t}\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"  allowed multipliers:\");\n-\t  for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n-\t    if (TEST_BIT (valid_mult, i + MAX_RATIO))\n-\t      fprintf (dump_file, \" %d\", (int) i);\n-\t  fprintf (dump_file, \"\\n\");\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n+      for (i = 2; i <= MAX_RATIO; i++)\n+\tif (multiplier_allowed_in_address_p (i))\n+\t  {\n+\t    rat = i;\n+\t    break;\n+\t  }\n     }\n \n   bits = GET_MODE_BITSIZE (Pmode);\n@@ -3285,8 +3355,7 @@ get_address_cost (bool symbol_present, bool var_present,\n   offset_p = (s_offset != 0\n \t      && min_offset <= s_offset && s_offset <= max_offset);\n   ratio_p = (ratio != 1\n-\t     && -MAX_RATIO <= ratio && ratio <= MAX_RATIO\n-\t     && TEST_BIT (valid_mult, ratio + MAX_RATIO));\n+\t     && multiplier_allowed_in_address_p (ratio));\n \n   if (ratio != 1 && !ratio_p)\n     cost += multiply_by_cost (ratio, Pmode);\n@@ -5262,8 +5331,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \treturn;\n     }\n \n-  comp = unshare_expr (get_computation (data->current_loop,\n-\t\t\t\t\tuse, cand));\n+  comp = get_computation (data->current_loop, use, cand);\n   switch (TREE_CODE (use->stmt))\n     {\n     case PHI_NODE:\n@@ -5348,78 +5416,60 @@ unshare_and_remove_ssa_names (tree ref)\n   return ref;\n }\n \n-/* Rewrites base of memory access OP with expression WITH in statement\n-   pointed to by BSI.  */\n+/* Extract the alias analysis info for the memory reference REF.  There are\n+   several ways how this information may be stored and what precisely is\n+   its semantics depending on the type of the reference, but there always is\n+   somewhere hidden one _DECL node that is used to determine the set of\n+   virtual operands for the reference.  The code below deciphers this jungle\n+   and extracts this single useful piece of information.  */\n \n-static void\n-rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n+static tree\n+get_ref_tag (tree ref)\n {\n-  tree bvar, var, new_name, copy, name;\n-  tree orig;\n-\n-  var = bvar = get_base_address (*op);\n+  tree var = get_base_address (ref);\n+  tree tag;\n \n-  if (!var || TREE_CODE (with) != SSA_NAME)\n-    goto do_rewrite;\n+  if (!var)\n+    return NULL_TREE;\n \n-  gcc_assert (TREE_CODE (var) != ALIGN_INDIRECT_REF);\n-  gcc_assert (TREE_CODE (var) != MISALIGNED_INDIRECT_REF);\n   if (TREE_CODE (var) == INDIRECT_REF)\n     var = TREE_OPERAND (var, 0);\n   if (TREE_CODE (var) == SSA_NAME)\n     {\n-      name = var;\n+      if (SSA_NAME_PTR_INFO (var))\n+\t{\n+\t  tag = SSA_NAME_PTR_INFO (var)->name_mem_tag;\n+\t  if (tag)\n+\t    return tag;\n+\t}\n+ \n       var = SSA_NAME_VAR (var);\n     }\n-  else if (DECL_P (var))\n-    name = NULL_TREE;\n-  else\n-    goto do_rewrite;\n-    \n-  /* We need to add a memory tag for the variable.  But we do not want\n-     to add it to the temporary used for the computations, since this leads\n-     to problems in redundancy elimination when there are common parts\n-     in two computations referring to the different arrays.  So we copy\n-     the variable to a new temporary.  */\n-  copy = build2 (MODIFY_EXPR, void_type_node, NULL_TREE, with);\n-\n-  if (name)\n-    new_name = duplicate_ssa_name (name, copy);\n-  else\n+ \n+  if (DECL_P (var))\n     {\n-      tree tag = var_ann (var)->type_mem_tag;\n-      tree new_ptr = create_tmp_var (TREE_TYPE (with), \"ruatmp\");\n-      add_referenced_tmp_var (new_ptr);\n+      tag = var_ann (var)->type_mem_tag;\n       if (tag)\n-\tvar_ann (new_ptr)->type_mem_tag = tag;\n-      else\n-\tadd_type_alias (new_ptr, var);\n-      new_name = make_ssa_name (new_ptr, copy);\n-    }\n-\n-  TREE_OPERAND (copy, 0) = new_name;\n-  bsi_insert_before (bsi, copy, BSI_SAME_STMT);\n-  with = new_name;\n+\treturn tag;\n \n-do_rewrite:\n-\n-  orig = NULL_TREE;\n-  gcc_assert (TREE_CODE (*op) != ALIGN_INDIRECT_REF);\n-  gcc_assert (TREE_CODE (*op) != MISALIGNED_INDIRECT_REF);\n-\n-  if (TREE_CODE (*op) == INDIRECT_REF)\n-    orig = REF_ORIGINAL (*op);\n-  if (!orig)\n-    orig = unshare_and_remove_ssa_names (*op);\n+      return var;\n+    }\n \n-  *op = build1 (INDIRECT_REF, TREE_TYPE (*op), with);\n+  return NULL_TREE;\n+}\n \n-  /* Record the original reference, for purposes of alias analysis.  */\n-  REF_ORIGINAL (*op) = orig;\n+/* Copies the reference information from OLD_REF to NEW_REF.  */\n \n-  /* Virtual operands in the original statement may have to be renamed\n-     because of the replacement.  */\n-  mark_new_vars_to_rename (bsi_stmt (*bsi));\n+static void\n+copy_ref_info (tree new_ref, tree old_ref)\n+{\n+  if (TREE_CODE (old_ref) == TARGET_MEM_REF)\n+    copy_mem_ref_info (new_ref, old_ref);\n+  else\n+    {\n+      TMR_TAG (new_ref) = get_ref_tag (old_ref);\n+      TMR_ORIGINAL (new_ref) = unshare_and_remove_ssa_names (old_ref);\n+    }\n }\n \n /* Rewrites USE (address that is an iv) using candidate CAND.  */\n@@ -5428,16 +5478,16 @@ static void\n rewrite_use_address (struct ivopts_data *data,\n \t\t     struct iv_use *use, struct iv_cand *cand)\n {\n-  tree comp = unshare_expr (get_computation (data->current_loop,\n-\t\t\t\t\t     use, cand));\n+  struct affine_tree_combination aff;\n   block_stmt_iterator bsi = bsi_for_stmt (use->stmt);\n-  tree stmts;\n-  tree op = force_gimple_operand (comp, &stmts, true, NULL_TREE);\n+  tree ref;\n \n-  if (stmts)\n-    bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+  get_computation_aff (data->current_loop, use, cand, use->stmt, &aff);\n+  unshare_aff_combination (&aff);\n \n-  rewrite_address_base (&bsi, use->op_p, op);\n+  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff);\n+  copy_ref_info (ref, *use->op_p);\n+  *use->op_p = ref;\n }\n \n /* Rewrites USE (the condition such that one of the arguments is an iv) using\n@@ -5474,7 +5524,7 @@ rewrite_use_compare (struct ivopts_data *data,\n \n   /* The induction variable elimination failed; just express the original\n      giv.  */\n-  comp = unshare_expr (get_computation (data->current_loop, use, cand));\n+  comp = get_computation (data->current_loop, use, cand);\n \n   cond = *use->op_p;\n   op_p = &TREE_OPERAND (cond, 0);\n@@ -5630,7 +5680,6 @@ rewrite_use_outer (struct ivopts_data *data,\n \tvalue = get_computation_at (data->current_loop,\n \t\t\t\t    use, cand, last_stmt (exit->src));\n \n-      value = unshare_expr (value);\n       op = force_gimple_operand (value, &stmts, true, SSA_NAME_VAR (tgt));\n \t  \n       /* If we will preserve the iv anyway and we would need to perform\n@@ -5935,25 +5984,5 @@ tree_ssa_iv_optimize (struct loops *loops)\n \tloop = loop->outer;\n     }\n \n-  /* FIXME.  IV opts introduces new aliases and call-clobbered\n-     variables, which need to be renamed.  However, when we call the\n-     renamer, not all statements will be scanned for operands.  In\n-     particular, the newly introduced aliases may appear in statements\n-     that are considered \"unmodified\", so the renamer will not get a\n-     chance to rename those operands.\n-\n-     Work around this problem by forcing an operand re-scan on every\n-     statement.  This will not be necessary once the new operand\n-     scanner is implemented.  */\n-  if (need_ssa_update_p ())\n-    {\n-      basic_block bb;\n-      block_stmt_iterator si;\n-      FOR_EACH_BB (bb)\n-\tfor (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-\t  update_stmt (bsi_stmt (si));\n-    }\n-\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   tree_ssa_iv_optimize_finalize (loops, &data);\n }"}, {"sha": "12bfc780bd32bd17db84c33447ce1319aabd980f", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -152,6 +152,7 @@ static void note_addressable (tree, stmt_ann_t);\n static void get_expr_operands (tree, tree *, int);\n static void get_asm_expr_operands (tree);\n static void get_indirect_ref_operands (tree, tree, int);\n+static void get_tmr_operands (tree, tree, int);\n static void get_call_expr_operands (tree, tree);\n static inline void append_def (tree *);\n static inline void append_use (tree *);\n@@ -1289,6 +1290,10 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       get_indirect_ref_operands (stmt, expr, flags);\n       return;\n \n+    case TARGET_MEM_REF:\n+      get_tmr_operands (stmt, expr, flags);\n+      return;\n+\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n       /* Treat array references as references to the virtual variable\n@@ -1672,6 +1677,30 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n   get_expr_operands (stmt, pptr, opf_none);\n }\n \n+/* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */\n+\n+static void\n+get_tmr_operands (tree stmt, tree expr, int flags)\n+{\n+  tree tag = TMR_TAG (expr);\n+\n+  /* First record the real operands.  */\n+  get_expr_operands (stmt, &TMR_BASE (expr), opf_none);\n+  get_expr_operands (stmt, &TMR_INDEX (expr), opf_none);\n+\n+  /* MEM_REFs should never be killing.  */\n+  flags &= ~opf_kill_def;\n+\n+  if (TMR_SYMBOL (expr))\n+    note_addressable (TMR_SYMBOL (expr), stmt_ann (stmt));\n+\n+  if (tag)\n+    add_stmt_operand (&tag, stmt_ann (stmt), flags);\n+  else\n+    /* Something weird, so ensure that we will be careful.  */\n+    stmt_ann (stmt)->has_volatile_ops = true;\n+}\n+\n /* A subroutine of get_expr_operands to handle CALL_EXPR.  */\n \n static void"}, {"sha": "15488fbc86085b01fe0f49962d69d1da51742f9b", "filename": "gcc/tree.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -2739,12 +2739,41 @@ build4_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   return t;\n }\n \n+tree\n+build7_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n+\t     tree arg2, tree arg3, tree arg4, tree arg5,\n+\t     tree arg6 MEM_STAT_DECL)\n+{\n+  bool constant, read_only, side_effects, invariant;\n+  tree t;\n+\n+  gcc_assert (code == TARGET_MEM_REF);\n+\n+  t = make_node_stat (code PASS_MEM_STAT);\n+  TREE_TYPE (t) = tt;\n+\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+\n+  PROCESS_ARG(0);\n+  PROCESS_ARG(1);\n+  PROCESS_ARG(2);\n+  PROCESS_ARG(3);\n+  PROCESS_ARG(4);\n+  PROCESS_ARG(5);\n+  PROCESS_ARG(6);\n+\n+  TREE_SIDE_EFFECTS (t) = side_effects;\n+  TREE_THIS_VOLATILE (t) = 0;\n+\n+  return t;\n+}\n+\n /* Backup definition for non-gcc build compilers.  */\n \n tree\n (build) (enum tree_code code, tree tt, ...)\n {\n-  tree t, arg0, arg1, arg2, arg3;\n+  tree t, arg0, arg1, arg2, arg3, arg4, arg5, arg6;\n   int length = TREE_CODE_LENGTH (code);\n   va_list p;\n \n@@ -2776,6 +2805,16 @@ tree\n       arg3 = va_arg (p, tree);\n       t = build4 (code, tt, arg0, arg1, arg2, arg3);\n       break;\n+    case 7:\n+      arg0 = va_arg (p, tree);\n+      arg1 = va_arg (p, tree);\n+      arg2 = va_arg (p, tree);\n+      arg3 = va_arg (p, tree);\n+      arg4 = va_arg (p, tree);\n+      arg5 = va_arg (p, tree);\n+      arg6 = va_arg (p, tree);\n+      t = build7 (code, tt, arg0, arg1, arg2, arg3, arg4, arg5, arg6);\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "b8d5a36daf743603a230f3b6abe268f6d1e7e5e7", "filename": "gcc/tree.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -935,6 +935,18 @@ DEFTREECODE (WITH_SIZE_EXPR, \"with_size_expr\", tcc_expression, 2)\n    generated by the builtin targetm.vectorize.mask_for_load_builtin_decl.  */\n DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n \n+/* Low-level memory addressing.  Operands are SYMBOL (static or global\n+   variable), BASE (register), INDEX (register), STEP (integer constant),\n+   OFFSET (integer constant).  Corresponding address is\n+   SYMBOL + BASE + STEP * INDEX + OFFSET.  Only variations and values valid on\n+   the target are allowed.\n+   \n+   The sixth argument is the reference to the original memory access, which\n+   is preserved for the purposes of the RTL alias analysis.  The seventh\n+   argument is a tag representing results of the tree level alias analysis.  */\n+\n+DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 7)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "0af98babc2dc3ebff6a3aab83d8661ca909f157e", "filename": "gcc/tree.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1826887e12c3e8ea95414455f882838a518d11/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ac1826887e12c3e8ea95414455f882838a518d11", "patch": "@@ -1171,10 +1171,6 @@ struct tree_vec GTY(())\n #define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)\n #define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n \n-/* In INDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF.  */\n-#define REF_ORIGINAL(NODE) TREE_CHAIN (TREE_CHECK3 (NODE, \t\\\n-\tINDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF))\n-\n /* In a LOOP_EXPR node.  */\n #define LOOP_EXPR_BODY(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_EXPR, 0)\n \n@@ -1240,6 +1236,15 @@ struct tree_vec GTY(())\n #define CASE_HIGH(NODE)         \tTREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 1)\n #define CASE_LABEL(NODE)\t\tTREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 2)\n \n+/* The operands of a TARGET_MEM_REF.  */\n+#define TMR_SYMBOL(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 0))\n+#define TMR_BASE(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 1))\n+#define TMR_INDEX(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 2))\n+#define TMR_STEP(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 3))\n+#define TMR_OFFSET(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 4))\n+#define TMR_ORIGINAL(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 5))\n+#define TMR_TAG(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 6))\n+\n /* The operands of a BIND_EXPR.  */\n #define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))\n #define BIND_EXPR_BODY(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 1))\n@@ -2897,6 +2902,10 @@ extern tree build3_stat (enum tree_code, tree, tree, tree, tree MEM_STAT_DECL);\n extern tree build4_stat (enum tree_code, tree, tree, tree, tree,\n \t\t\t tree MEM_STAT_DECL);\n #define build4(c,t1,t2,t3,t4,t5) build4_stat (c,t1,t2,t3,t4,t5 MEM_STAT_INFO)\n+extern tree build7_stat (enum tree_code, tree, tree, tree, tree, tree,\n+\t\t\t tree, tree, tree MEM_STAT_DECL);\n+#define build7(c,t1,t2,t3,t4,t5,t6,t7,t8) \\\n+  build7_stat (c,t1,t2,t3,t4,t5,t6,t7,t8 MEM_STAT_INFO)\n \n extern tree build_int_cst (tree, HOST_WIDE_INT);\n extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n@@ -3990,4 +3999,8 @@ extern tree get_base_address (tree t);\n /* In tree-vectorizer.c.  */\n extern void vect_set_verbosity_level (const char *);\n \n+/* In tree-ssa-address.c.  */\n+extern tree tree_mem_ref_addr (tree, tree);\n+extern void copy_mem_ref_info (tree, tree);\n+\n #endif  /* GCC_TREE_H  */"}]}