{"sha": "fabcaa8df3d6eb852b87821ef090d31d222870b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiY2FhOGRmM2Q2ZWI4NTJiODc4MjFlZjA5MGQzMWQyMjI4NzBiNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-11-21T07:03:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-11-21T07:03:38Z"}, "message": "libgo: Update to current version of master library.\n\nFrom-SVN: r193688", "tree": {"sha": "72455aea0286937aa08cc141e5efc800e4626577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72455aea0286937aa08cc141e5efc800e4626577"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fabcaa8df3d6eb852b87821ef090d31d222870b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabcaa8df3d6eb852b87821ef090d31d222870b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabcaa8df3d6eb852b87821ef090d31d222870b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabcaa8df3d6eb852b87821ef090d31d222870b7/comments", "author": null, "committer": null, "parents": [{"sha": "a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51fb17f48428e7cfc96a72a9f9f87901363bb6b"}], "stats": {"total": 81168, "additions": 62008, "deletions": 19160}, "files": [{"sha": "5ab9716a4eeeadab64d683a95d4f5c1c8fa329e7", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -1,4 +1,4 @@\n-291d9f1baf75\n+a070de932857\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "fc0d9917ebe03c1125ee347200942853e2fda54d", "filename": "libgo/Makefile.am", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -773,7 +773,6 @@ go_net_files = \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n-\tgo/net/net_posix.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n@@ -1117,6 +1116,7 @@ go_crypto_x509_files = \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/root.go \\\n \tgo/crypto/x509/root_unix.go \\\n+\tgo/crypto/x509/sec1.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n@@ -1245,10 +1245,17 @@ go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n go_exp_types_files = \\\n+\tgo/exp/types/builtins.go \\\n \tgo/exp/types/check.go \\\n \tgo/exp/types/const.go \\\n+\tgo/exp/types/conversions.go \\\n+\tgo/exp/types/errors.go \\\n \tgo/exp/types/exportdata.go \\\n+\tgo/exp/types/expr.go \\\n \tgo/exp/types/gcimporter.go \\\n+\tgo/exp/types/operand.go \\\n+\tgo/exp/types/predicates.go \\\n+\tgo/exp/types/stmt.go \\\n \tgo/exp/types/types.go \\\n \tgo/exp/types/universe.go\n go_exp_utf8string_files = \\\n@@ -1329,6 +1336,7 @@ go_image_jpeg_files = \\\n \tgo/image/jpeg/huffman.go \\\n \tgo/image/jpeg/idct.go \\\n \tgo/image/jpeg/reader.go \\\n+\tgo/image/jpeg/scan.go \\\n \tgo/image/jpeg/writer.go\n \n go_image_png_files = \\"}, {"sha": "147d9c8e6dca4ae93feb6820c8893f3ae306310e", "filename": "libgo/Makefile.in", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -1027,7 +1027,6 @@ go_net_files = \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n-\tgo/net/net_posix.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n@@ -1312,6 +1311,7 @@ go_crypto_x509_files = \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/root.go \\\n \tgo/crypto/x509/root_unix.go \\\n+\tgo/crypto/x509/sec1.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n@@ -1463,10 +1463,17 @@ go_exp_terminal_files = \\\n \tgo/exp/terminal/util.go\n \n go_exp_types_files = \\\n+\tgo/exp/types/builtins.go \\\n \tgo/exp/types/check.go \\\n \tgo/exp/types/const.go \\\n+\tgo/exp/types/conversions.go \\\n+\tgo/exp/types/errors.go \\\n \tgo/exp/types/exportdata.go \\\n+\tgo/exp/types/expr.go \\\n \tgo/exp/types/gcimporter.go \\\n+\tgo/exp/types/operand.go \\\n+\tgo/exp/types/predicates.go \\\n+\tgo/exp/types/stmt.go \\\n \tgo/exp/types/types.go \\\n \tgo/exp/types/universe.go\n \n@@ -1557,6 +1564,7 @@ go_image_jpeg_files = \\\n \tgo/image/jpeg/huffman.go \\\n \tgo/image/jpeg/idct.go \\\n \tgo/image/jpeg/reader.go \\\n+\tgo/image/jpeg/scan.go \\\n \tgo/image/jpeg/writer.go\n \n go_image_png_files = \\"}, {"sha": "ad825c6be0b83339d3da43e6c30324718ff9779f", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -72,6 +72,18 @@ func cString(b []byte) string {\n }\n \n func (tr *Reader) octal(b []byte) int64 {\n+\t// Check for binary format first.\n+\tif len(b) > 0 && b[0]&0x80 != 0 {\n+\t\tvar x int64\n+\t\tfor i, c := range b {\n+\t\t\tif i == 0 {\n+\t\t\t\tc &= 0x7f // ignore signal bit in first byte\n+\t\t\t}\n+\t\t\tx = x<<8 | int64(c)\n+\t\t}\n+\t\treturn x\n+\t}\n+\n \t// Removing leading spaces.\n \tfor len(b) > 0 && b[0] == ' ' {\n \t\tb = b[1:]"}, {"sha": "7b190b6a8b27196e1a5d009a82714064c10a12c8", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -5,7 +5,10 @@\n package tar\n \n import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n \t\"os\"\n+\t\"reflect\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -54,3 +57,44 @@ func (symlink) Mode() os.FileMode  { return os.ModeSymlink }\n func (symlink) ModTime() time.Time { return time.Time{} }\n func (symlink) IsDir() bool        { return false }\n func (symlink) Sys() interface{}   { return nil }\n+\n+func TestRoundTrip(t *testing.T) {\n+\tdata := []byte(\"some file contents\")\n+\n+\tvar b bytes.Buffer\n+\ttw := NewWriter(&b)\n+\thdr := &Header{\n+\t\tName:    \"file.txt\",\n+\t\tUid:     1 << 21, // too big for 8 octal digits\n+\t\tSize:    int64(len(data)),\n+\t\tModTime: time.Now(),\n+\t}\n+\t// tar only supports second precision.\n+\thdr.ModTime = hdr.ModTime.Add(-time.Duration(hdr.ModTime.Nanosecond()) * time.Nanosecond)\n+\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\tt.Fatalf(\"tw.WriteHeader: %v\", err)\n+\t}\n+\tif _, err := tw.Write(data); err != nil {\n+\t\tt.Fatalf(\"tw.Write: %v\", err)\n+\t}\n+\tif err := tw.Close(); err != nil {\n+\t\tt.Fatalf(\"tw.Close: %v\", err)\n+\t}\n+\n+\t// Read it back.\n+\ttr := NewReader(&b)\n+\trHdr, err := tr.Next()\n+\tif err != nil {\n+\t\tt.Fatalf(\"tr.Next: %v\", err)\n+\t}\n+\tif !reflect.DeepEqual(rHdr, hdr) {\n+\t\tt.Errorf(\"Header mismatch.\\n got %+v\\nwant %+v\", rHdr, hdr)\n+\t}\n+\trData, err := ioutil.ReadAll(tr)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Read: %v\", err)\n+\t}\n+\tif !bytes.Equal(rData, data) {\n+\t\tt.Errorf(\"Data mismatch.\\n got %q\\nwant %q\", rData, data)\n+\t}\n+}"}, {"sha": "5af504b437d0af0e94495911dd791ba048455174", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n var (\n@@ -110,6 +111,12 @@ func (tw *Writer) numeric(b []byte, x int64) {\n \tb[0] |= 0x80 // highest bit indicates binary format\n }\n \n+var (\n+\tminTime = time.Unix(0, 0)\n+\t// There is room for 11 octal digits (33 bits) of mtime.\n+\tmaxTime = minTime.Add((1<<33 - 1) * time.Second)\n+)\n+\n // WriteHeader writes hdr and prepares to accept the file's contents.\n // WriteHeader calls Flush if it is not the first header.\n // Calling after a Close will return ErrWriteAfterClose.\n@@ -133,19 +140,25 @@ func (tw *Writer) WriteHeader(hdr *Header) error {\n \t// TODO(dsymonds): handle names longer than 100 chars\n \tcopy(s.next(100), []byte(hdr.Name))\n \n-\ttw.octal(s.next(8), hdr.Mode)              // 100:108\n-\ttw.numeric(s.next(8), int64(hdr.Uid))      // 108:116\n-\ttw.numeric(s.next(8), int64(hdr.Gid))      // 116:124\n-\ttw.numeric(s.next(12), hdr.Size)           // 124:136\n-\ttw.numeric(s.next(12), hdr.ModTime.Unix()) // 136:148\n-\ts.next(8)                                  // chksum (148:156)\n-\ts.next(1)[0] = hdr.Typeflag                // 156:157\n-\ttw.cString(s.next(100), hdr.Linkname)      // linkname (157:257)\n-\tcopy(s.next(8), []byte(\"ustar\\x0000\"))     // 257:265\n-\ttw.cString(s.next(32), hdr.Uname)          // 265:297\n-\ttw.cString(s.next(32), hdr.Gname)          // 297:329\n-\ttw.numeric(s.next(8), hdr.Devmajor)        // 329:337\n-\ttw.numeric(s.next(8), hdr.Devminor)        // 337:345\n+\t// Handle out of range ModTime carefully.\n+\tvar modTime int64\n+\tif !hdr.ModTime.Before(minTime) && !hdr.ModTime.After(maxTime) {\n+\t\tmodTime = hdr.ModTime.Unix()\n+\t}\n+\n+\ttw.octal(s.next(8), hdr.Mode)          // 100:108\n+\ttw.numeric(s.next(8), int64(hdr.Uid))  // 108:116\n+\ttw.numeric(s.next(8), int64(hdr.Gid))  // 116:124\n+\ttw.numeric(s.next(12), hdr.Size)       // 124:136\n+\ttw.numeric(s.next(12), modTime)        // 136:148\n+\ts.next(8)                              // chksum (148:156)\n+\ts.next(1)[0] = hdr.Typeflag            // 156:157\n+\ttw.cString(s.next(100), hdr.Linkname)  // linkname (157:257)\n+\tcopy(s.next(8), []byte(\"ustar\\x0000\")) // 257:265\n+\ttw.cString(s.next(32), hdr.Uname)      // 265:297\n+\ttw.cString(s.next(32), hdr.Gname)      // 297:329\n+\ttw.numeric(s.next(8), hdr.Devmajor)    // 329:337\n+\ttw.numeric(s.next(8), hdr.Devminor)    // 337:345\n \n \t// Use the GNU magic instead of POSIX magic if we used any GNU extensions.\n \tif tw.usedBinary {"}, {"sha": "c10f29a8369ae0c1606d30e87c22459153050e45", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -238,9 +238,12 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \n \tif len(f.Extra) > 0 {\n \t\tb := readBuf(f.Extra)\n-\t\tfor len(b) > 0 {\n+\t\tfor len(b) >= 4 { // need at least tag and size\n \t\t\ttag := b.uint16()\n \t\t\tsize := b.uint16()\n+\t\t\tif int(size) > len(b) {\n+\t\t\t\treturn ErrFormat\n+\t\t\t}\n \t\t\tif tag == zip64ExtraId {\n \t\t\t\t// update directory values from the zip64 extra block\n \t\t\t\teb := readBuf(b)\n@@ -256,6 +259,10 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \t\t\t}\n \t\t\tb = b[size:]\n \t\t}\n+\t\t// Should have consumed the whole header.\n+\t\tif len(b) != 0 {\n+\t\t\treturn ErrFormat\n+\t\t}\n \t}\n \treturn nil\n }"}, {"sha": "4c696e1529e8d08cfe45c10a93c20c9903e19fba", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -174,7 +174,7 @@ func (w *Writer) Create(name string) (io.Writer, error) {\n }\n \n // CreateHeader adds a file to the zip file using the provided FileHeader\n-// for the file metadata. \n+// for the file metadata.\n // It returns a Writer to which the file contents should be written.\n // The file's contents must be written to the io.Writer before the next\n // call to Create, CreateHeader, or Close."}, {"sha": "0a18798a3f963d2cd15cbbc6995d1f157436607f", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -173,3 +173,85 @@ func TestZip64(t *testing.T) {\n \t\tt.Errorf(\"UncompressedSize64 %d, want %d\", got, want)\n \t}\n }\n+\n+func testInvalidHeader(h *FileHeader, t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tz := NewWriter(&buf)\n+\n+\tf, err := z.CreateHeader(h)\n+\tif err != nil {\n+\t\tt.Fatalf(\"error creating header: %v\", err)\n+\t}\n+\tif _, err := f.Write([]byte(\"hi\")); err != nil {\n+\t\tt.Fatalf(\"error writing content: %v\", err)\n+\t}\n+\tif err := z.Close(); err != nil {\n+\t\tt.Fatalf(\"error closing zip writer: %v\", err)\n+\t}\n+\n+\tb := buf.Bytes()\n+\tif _, err = NewReader(bytes.NewReader(b), int64(len(b))); err != ErrFormat {\n+\t\tt.Fatalf(\"got %v, expected ErrFormat\", err)\n+\t}\n+}\n+\n+func testValidHeader(h *FileHeader, t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tz := NewWriter(&buf)\n+\n+\tf, err := z.CreateHeader(h)\n+\tif err != nil {\n+\t\tt.Fatalf(\"error creating header: %v\", err)\n+\t}\n+\tif _, err := f.Write([]byte(\"hi\")); err != nil {\n+\t\tt.Fatalf(\"error writing content: %v\", err)\n+\t}\n+\tif err := z.Close(); err != nil {\n+\t\tt.Fatalf(\"error closing zip writer: %v\", err)\n+\t}\n+\n+\tb := buf.Bytes()\n+\tif _, err = NewReader(bytes.NewReader(b), int64(len(b))); err != nil {\n+\t\tt.Fatalf(\"got %v, expected nil\", err)\n+\t}\n+}\n+\n+// Issue 4302.\n+func TestHeaderInvalidTagAndSize(t *testing.T) {\n+\tconst timeFormat = \"20060102T150405.000.txt\"\n+\n+\tts := time.Now()\n+\tfilename := ts.Format(timeFormat)\n+\n+\th := FileHeader{\n+\t\tName:   filename,\n+\t\tMethod: Deflate,\n+\t\tExtra:  []byte(ts.Format(time.RFC3339Nano)), // missing tag and len\n+\t}\n+\th.SetModTime(ts)\n+\n+\ttestInvalidHeader(&h, t)\n+}\n+\n+func TestHeaderTooShort(t *testing.T) {\n+\th := FileHeader{\n+\t\tName:   \"foo.txt\",\n+\t\tMethod: Deflate,\n+\t\tExtra:  []byte{zip64ExtraId}, // missing size\n+\t}\n+\ttestInvalidHeader(&h, t)\n+}\n+\n+// Issue 4393. It is valid to have an extra data header\n+// which contains no body.\n+func TestZeroLengthHeader(t *testing.T) {\n+\th := FileHeader{\n+\t\tName:   \"extadata.txt\",\n+\t\tMethod: Deflate,\n+\t\tExtra: []byte{\n+\t\t\t85, 84, 5, 0, 3, 154, 144, 195, 77, // tag 21589 size 5\n+\t\t\t85, 120, 0, 0, // tag 30805 size 0\n+\t\t},\n+\t}\n+\ttestValidHeader(&h, t)\n+}"}, {"sha": "cd51585f847d5600baa0f985ab26356fd253f694", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -567,6 +567,36 @@ func (b *Writer) WriteString(s string) (int, error) {\n \treturn nn, nil\n }\n \n+// ReadFrom implements io.ReaderFrom.\n+func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n+\tif b.Buffered() == 0 {\n+\t\tif w, ok := b.wr.(io.ReaderFrom); ok {\n+\t\t\treturn w.ReadFrom(r)\n+\t\t}\n+\t}\n+\tvar m int\n+\tfor {\n+\t\tm, err = r.Read(b.buf[b.n:])\n+\t\tif m == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tb.n += m\n+\t\tn += int64(m)\n+\t\tif b.Available() == 0 {\n+\t\t\tif err1 := b.Flush(); err1 != nil {\n+\t\t\t\treturn n, err1\n+\t\t\t}\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif err == io.EOF {\n+\t\terr = nil\n+\t}\n+\treturn n, err\n+}\n+\n // buffered input and output\n \n // ReadWriter stores pointers to a Reader and a Writer."}, {"sha": "75d9edf8b1cfa350fa9cc2f84ced096ecd6e58b6", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 163, "deletions": 10, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -763,8 +763,8 @@ func testReadLineNewlines(t *testing.T, input string, expect []readLineResult) {\n \t}\n }\n \n-func TestReaderWriteTo(t *testing.T) {\n-\tinput := make([]byte, 8192)\n+func createTestInput(n int) []byte {\n+\tinput := make([]byte, n)\n \tfor i := range input {\n \t\t// 101 and 251 are arbitrary prime numbers.\n \t\t// The idea is to create an input sequence\n@@ -774,7 +774,12 @@ func TestReaderWriteTo(t *testing.T) {\n \t\t\tinput[i] ^= byte(i / 101)\n \t\t}\n \t}\n-\tr := NewReader(bytes.NewBuffer(input))\n+\treturn input\n+}\n+\n+func TestReaderWriteTo(t *testing.T) {\n+\tinput := createTestInput(8192)\n+\tr := NewReader(onlyReader{bytes.NewBuffer(input)})\n \tw := new(bytes.Buffer)\n \tif n, err := r.WriteTo(w); err != nil || n != int64(len(input)) {\n \t\tt.Fatalf(\"r.WriteTo(w) = %d, %v, want %d, nil\", n, err, len(input))\n@@ -817,12 +822,129 @@ func TestReaderWriteToErrors(t *testing.T) {\n \t}\n }\n \n+func TestWriterReadFrom(t *testing.T) {\n+\tws := []func(io.Writer) io.Writer{\n+\t\tfunc(w io.Writer) io.Writer { return onlyWriter{w} },\n+\t\tfunc(w io.Writer) io.Writer { return w },\n+\t}\n+\n+\trs := []func(io.Reader) io.Reader{\n+\t\tiotest.DataErrReader,\n+\t\tfunc(r io.Reader) io.Reader { return r },\n+\t}\n+\n+\tfor ri, rfunc := range rs {\n+\t\tfor wi, wfunc := range ws {\n+\t\t\tinput := createTestInput(8192)\n+\t\t\tb := new(bytes.Buffer)\n+\t\t\tw := NewWriter(wfunc(b))\n+\t\t\tr := rfunc(bytes.NewBuffer(input))\n+\t\t\tif n, err := w.ReadFrom(r); err != nil || n != int64(len(input)) {\n+\t\t\t\tt.Errorf(\"ws[%d],rs[%d]: w.ReadFrom(r) = %d, %v, want %d, nil\", wi, ri, n, err, len(input))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif got, want := b.String(), string(input); got != want {\n+\t\t\t\tt.Errorf(\"ws[%d], rs[%d]:\\ngot  %q\\nwant %q\\n\", wi, ri, got, want)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+type errorReaderFromTest struct {\n+\trn, wn     int\n+\trerr, werr error\n+\texpected   error\n+}\n+\n+func (r errorReaderFromTest) Read(p []byte) (int, error) {\n+\treturn len(p) * r.rn, r.rerr\n+}\n+\n+func (w errorReaderFromTest) Write(p []byte) (int, error) {\n+\treturn len(p) * w.wn, w.werr\n+}\n+\n+var errorReaderFromTests = []errorReaderFromTest{\n+\t{0, 1, io.EOF, nil, nil},\n+\t{1, 1, io.EOF, nil, nil},\n+\t{0, 1, io.ErrClosedPipe, nil, io.ErrClosedPipe},\n+\t{0, 0, io.ErrClosedPipe, io.ErrShortWrite, io.ErrClosedPipe},\n+\t{1, 0, nil, io.ErrShortWrite, io.ErrShortWrite},\n+}\n+\n+func TestWriterReadFromErrors(t *testing.T) {\n+\tfor i, rw := range errorReaderFromTests {\n+\t\tw := NewWriter(rw)\n+\t\tif _, err := w.ReadFrom(rw); err != rw.expected {\n+\t\t\tt.Errorf(\"w.ReadFrom(errorReaderFromTests[%d]) = _, %v, want _,%v\", i, err, rw.expected)\n+\t\t}\n+\t}\n+}\n+\n+// TestWriterReadFromCounts tests that using io.Copy to copy into a\n+// bufio.Writer does not prematurely flush the buffer. For example, when\n+// buffering writes to a network socket, excessive network writes should be\n+// avoided.\n+func TestWriterReadFromCounts(t *testing.T) {\n+\tvar w0 writeCountingDiscard\n+\tb0 := NewWriterSize(&w0, 1234)\n+\tb0.WriteString(strings.Repeat(\"x\", 1000))\n+\tif w0 != 0 {\n+\t\tt.Fatalf(\"write 1000 'x's: got %d writes, want 0\", w0)\n+\t}\n+\tb0.WriteString(strings.Repeat(\"x\", 200))\n+\tif w0 != 0 {\n+\t\tt.Fatalf(\"write 1200 'x's: got %d writes, want 0\", w0)\n+\t}\n+\tio.Copy(b0, onlyReader{strings.NewReader(strings.Repeat(\"x\", 30))})\n+\tif w0 != 0 {\n+\t\tt.Fatalf(\"write 1230 'x's: got %d writes, want 0\", w0)\n+\t}\n+\tio.Copy(b0, onlyReader{strings.NewReader(strings.Repeat(\"x\", 9))})\n+\tif w0 != 1 {\n+\t\tt.Fatalf(\"write 1239 'x's: got %d writes, want 1\", w0)\n+\t}\n+\n+\tvar w1 writeCountingDiscard\n+\tb1 := NewWriterSize(&w1, 1234)\n+\tb1.WriteString(strings.Repeat(\"x\", 1200))\n+\tb1.Flush()\n+\tif w1 != 1 {\n+\t\tt.Fatalf(\"flush 1200 'x's: got %d writes, want 1\", w1)\n+\t}\n+\tb1.WriteString(strings.Repeat(\"x\", 89))\n+\tif w1 != 1 {\n+\t\tt.Fatalf(\"write 1200 + 89 'x's: got %d writes, want 1\", w1)\n+\t}\n+\tio.Copy(b1, onlyReader{strings.NewReader(strings.Repeat(\"x\", 700))})\n+\tif w1 != 1 {\n+\t\tt.Fatalf(\"write 1200 + 789 'x's: got %d writes, want 1\", w1)\n+\t}\n+\tio.Copy(b1, onlyReader{strings.NewReader(strings.Repeat(\"x\", 600))})\n+\tif w1 != 2 {\n+\t\tt.Fatalf(\"write 1200 + 1389 'x's: got %d writes, want 2\", w1)\n+\t}\n+\tb1.Flush()\n+\tif w1 != 3 {\n+\t\tt.Fatalf(\"flush 1200 + 1389 'x's: got %d writes, want 3\", w1)\n+\t}\n+}\n+\n+// A writeCountingDiscard is like ioutil.Discard and counts the number of times\n+// Write is called on it.\n+type writeCountingDiscard int\n+\n+func (w *writeCountingDiscard) Write(p []byte) (int, error) {\n+\t*w++\n+\treturn len(p), nil\n+}\n+\n // An onlyReader only implements io.Reader, no matter what other methods the underlying implementation may have.\n type onlyReader struct {\n \tr io.Reader\n }\n \n-func (r *onlyReader) Read(b []byte) (int, error) {\n+func (r onlyReader) Read(b []byte) (int, error) {\n \treturn r.r.Read(b)\n }\n \n@@ -831,7 +953,7 @@ type onlyWriter struct {\n \tw io.Writer\n }\n \n-func (w *onlyWriter) Write(b []byte) (int, error) {\n+func (w onlyWriter) Write(b []byte) (int, error) {\n \treturn w.w.Write(b)\n }\n \n@@ -840,7 +962,7 @@ func BenchmarkReaderCopyOptimal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tb.StopTimer()\n \t\tsrc := NewReader(bytes.NewBuffer(make([]byte, 8192)))\n-\t\tdst := &onlyWriter{new(bytes.Buffer)}\n+\t\tdst := onlyWriter{new(bytes.Buffer)}\n \t\tb.StartTimer()\n \t\tio.Copy(dst, src)\n \t}\n@@ -850,8 +972,8 @@ func BenchmarkReaderCopyUnoptimal(b *testing.B) {\n \t// Unoptimal case is where the underlying reader doesn't implement io.WriterTo\n \tfor i := 0; i < b.N; i++ {\n \t\tb.StopTimer()\n-\t\tsrc := NewReader(&onlyReader{bytes.NewBuffer(make([]byte, 8192))})\n-\t\tdst := &onlyWriter{new(bytes.Buffer)}\n+\t\tsrc := NewReader(onlyReader{bytes.NewBuffer(make([]byte, 8192))})\n+\t\tdst := onlyWriter{new(bytes.Buffer)}\n \t\tb.StartTimer()\n \t\tio.Copy(dst, src)\n \t}\n@@ -860,8 +982,39 @@ func BenchmarkReaderCopyUnoptimal(b *testing.B) {\n func BenchmarkReaderCopyNoWriteTo(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tb.StopTimer()\n-\t\tsrc := &onlyReader{NewReader(bytes.NewBuffer(make([]byte, 8192)))}\n-\t\tdst := &onlyWriter{new(bytes.Buffer)}\n+\t\tsrc := onlyReader{NewReader(bytes.NewBuffer(make([]byte, 8192)))}\n+\t\tdst := onlyWriter{new(bytes.Buffer)}\n+\t\tb.StartTimer()\n+\t\tio.Copy(dst, src)\n+\t}\n+}\n+\n+func BenchmarkWriterCopyOptimal(b *testing.B) {\n+\t// Optimal case is where the underlying writer implements io.ReaderFrom\n+\tfor i := 0; i < b.N; i++ {\n+\t\tb.StopTimer()\n+\t\tsrc := onlyReader{bytes.NewBuffer(make([]byte, 8192))}\n+\t\tdst := NewWriter(new(bytes.Buffer))\n+\t\tb.StartTimer()\n+\t\tio.Copy(dst, src)\n+\t}\n+}\n+\n+func BenchmarkWriterCopyUnoptimal(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tb.StopTimer()\n+\t\tsrc := onlyReader{bytes.NewBuffer(make([]byte, 8192))}\n+\t\tdst := NewWriter(onlyWriter{new(bytes.Buffer)})\n+\t\tb.StartTimer()\n+\t\tio.Copy(dst, src)\n+\t}\n+}\n+\n+func BenchmarkWriterCopyNoReadFrom(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tb.StopTimer()\n+\t\tsrc := onlyReader{bytes.NewBuffer(make([]byte, 8192))}\n+\t\tdst := onlyWriter{NewWriter(new(bytes.Buffer))}\n \t\tb.StartTimer()\n \t\tio.Copy(dst, src)\n \t}"}, {"sha": "92e29146b32d5061d3e2ce4af69c7fb090ef3ba7", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -251,10 +251,10 @@ func TestReadFrom(t *testing.T) {\n func TestWriteTo(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n-\t\ts := fillBytes(t, \"TestReadFrom (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n+\t\ts := fillBytes(t, \"TestWriteTo (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n \t\tvar b Buffer\n \t\tbuf.WriteTo(&b)\n-\t\tempty(t, \"TestReadFrom (2)\", &b, s, make([]byte, len(data)))\n+\t\tempty(t, \"TestWriteTo (2)\", &b, s, make([]byte, len(data)))\n \t}\n }\n "}, {"sha": "2311329ad05dd1cbac45f3d6ea75184ba99b402f", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -1026,7 +1026,7 @@ func TestEqualFold(t *testing.T) {\n \n var makeFieldsInput = func() []byte {\n \tx := make([]byte, 1<<20)\n-\t// Input is ~10% space, ~10% 2-byte UTF-8, rest ASCII non-space. \n+\t// Input is ~10% space, ~10% 2-byte UTF-8, rest ASCII non-space.\n \tfor i := range x {\n \t\tswitch rand.Intn(10) {\n \t\tcase 0:"}, {"sha": "b34dfc11bffde916d5b963e4cff3626a2e9ddf32", "filename": "libgo/go/bytes/reader.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// A Reader implements the io.Reader, io.ReaderAt, io.Seeker,\n+// A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker,\n // io.ByteScanner, and io.RuneScanner interfaces by reading from\n // a byte slice.\n // Unlike a Buffer, a Reader is read-only and supports seeking.\n@@ -121,5 +121,24 @@ func (r *Reader) Seek(offset int64, whence int) (int64, error) {\n \treturn abs, nil\n }\n \n+// WriteTo implements the io.WriterTo interface.\n+func (r *Reader) WriteTo(w io.Writer) (n int64, err error) {\n+\tr.prevRune = -1\n+\tif r.i >= len(r.s) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tb := r.s[r.i:]\n+\tm, err := w.Write(b)\n+\tif m > len(b) {\n+\t\tpanic(\"bytes.Reader.WriteTo: invalid Write count\")\n+\t}\n+\tr.i += m\n+\tn = int64(m)\n+\tif m != len(b) && err == nil {\n+\t\terr = io.ErrShortWrite\n+\t}\n+\treturn\n+}\n+\n // NewReader returns a new Reader reading from b.\n func NewReader(b []byte) *Reader { return &Reader{b, 0, -1} }"}, {"sha": "666881886760ea8ca6a6f78d2c9032800a14c2a4", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -86,3 +86,24 @@ func TestReaderAt(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestReaderWriteTo(t *testing.T) {\n+\tfor i := 3; i < 30; i += 3 {\n+\t\ts := data[:len(data)/i]\n+\t\tr := NewReader(testBytes[:len(testBytes)/i])\n+\t\tvar b Buffer\n+\t\tn, err := r.WriteTo(&b)\n+\t\tif expect := int64(len(s)); n != expect {\n+\t\t\tt.Errorf(\"got %v; want %v\", n, expect)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"got error = %v; want nil\", err)\n+\t\t}\n+\t\tif b.String() != s {\n+\t\t\tt.Errorf(\"got string %q; want %q\", b.String(), s)\n+\t\t}\n+\t\tif r.Len() != 0 {\n+\t\t\tt.Errorf(\"reader contains %v bytes; want 0\", r.Len())\n+\t\t}\n+\t}\n+}"}, {"sha": "ab1d60651436bd5a0b8118b46d5bb7f58c24869a", "filename": "libgo/go/compress/bzip2/bit_reader.go", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -14,21 +14,16 @@ import (\n // because the error handling was verbose. Instead, any error is kept and can\n // be checked afterwards.\n type bitReader struct {\n-\tr    byteReader\n+\tr    io.ByteReader\n \tn    uint64\n \tbits uint\n \terr  error\n }\n \n-// bitReader needs to read bytes from an io.Reader. We attempt to convert the\n-// given io.Reader to this interface and, if it doesn't already fit, we wrap in\n-// a bufio.Reader.\n-type byteReader interface {\n-\tReadByte() (byte, error)\n-}\n-\n+// newBitReader returns a new bitReader reading from r. If r is not\n+// already an io.ByteReader, it will be converted via a bufio.Reader.\n func newBitReader(r io.Reader) bitReader {\n-\tbyter, ok := r.(byteReader)\n+\tbyter, ok := r.(io.ByteReader)\n \tif !ok {\n \t\tbyter = bufio.NewReader(r)\n \t}"}, {"sha": "c5a54b998fa7a948b658c46b63a39a66309fdc14", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -208,8 +208,8 @@ type decompressor struct {\n \th1, h2 huffmanDecoder\n \n \t// Length arrays used to define Huffman codes.\n-\tbits     [maxLit + maxDist]int\n-\tcodebits [numCodes]int\n+\tbits     *[maxLit + maxDist]int\n+\tcodebits *[numCodes]int\n \n \t// Output history, buffer.\n \thist  *[maxHist]byte\n@@ -692,6 +692,8 @@ func makeReader(r io.Reader) Reader {\n // finished reading.\n func NewReader(r io.Reader) io.ReadCloser {\n \tvar f decompressor\n+\tf.bits = new([maxLit + maxDist]int)\n+\tf.codebits = new([numCodes]int)\n \tf.r = makeReader(r)\n \tf.hist = new([maxHist]byte)\n \tf.step = (*decompressor).nextBlock\n@@ -707,6 +709,8 @@ func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser {\n \tvar f decompressor\n \tf.r = makeReader(r)\n \tf.hist = new([maxHist]byte)\n+\tf.bits = new([maxLit + maxDist]int)\n+\tf.codebits = new([numCodes]int)\n \tf.step = (*decompressor).nextBlock\n \tf.setDict(dict)\n \treturn &f"}, {"sha": "69818c3b75be3bb4397305813a65c7077d898d2d", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -176,7 +176,7 @@ func (l *List) MoveToBack(e *Element) {\n \tl.insert(l.remove(e), l.root.prev)\n }\n \n-// PuchBackList inserts a copy of an other list at the back of list l.\n+// PushBackList inserts a copy of an other list at the back of list l.\n // The lists l and other may be the same.\n func (l *List) PushBackList(other *List) {\n \tl.lazyInit()"}, {"sha": "6fab9b42131e364d2c0c2ab73614bfaedeeecc4a", "filename": "libgo/go/crypto/cipher/cbc.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -33,6 +33,9 @@ type cbcEncrypter cbc\n // mode, using the given Block. The length of iv must be the same as the\n // Block's block size.\n func NewCBCEncrypter(b Block, iv []byte) BlockMode {\n+\tif len(iv) != b.BlockSize() {\n+\t\tpanic(\"cipher.NewCBCEncrypter: IV length must equal block size\")\n+\t}\n \treturn (*cbcEncrypter)(newCBC(b, iv))\n }\n \n@@ -58,6 +61,9 @@ type cbcDecrypter cbc\n // mode, using the given Block. The length of iv must be the same as the\n // Block's block size and must match the iv used to encrypt the data.\n func NewCBCDecrypter(b Block, iv []byte) BlockMode {\n+\tif len(iv) != b.BlockSize() {\n+\t\tpanic(\"cipher.NewCBCDecrypter: IV length must equal block size\")\n+\t}\n \treturn (*cbcDecrypter)(newCBC(b, iv))\n }\n "}, {"sha": "99006b546d1463c04a911c8fa68b8764b8ba3250", "filename": "libgo/go/crypto/cipher/cfb.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -17,13 +17,19 @@ type cfb struct {\n // using the given Block. The iv must be the same length as the Block's block\n // size.\n func NewCFBEncrypter(block Block, iv []byte) Stream {\n+\tif len(iv) != block.BlockSize() {\n+\t\tpanic(\"cipher.NewCBFEncrypter: IV length must equal block size\")\n+\t}\n \treturn newCFB(block, iv, false)\n }\n \n // NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\n // using the given Block. The iv must be the same length as the Block's block\n // size.\n func NewCFBDecrypter(block Block, iv []byte) Stream {\n+\tif len(iv) != block.BlockSize() {\n+\t\tpanic(\"cipher.NewCBFEncrypter: IV length must equal block size\")\n+\t}\n \treturn newCFB(block, iv, true)\n }\n "}, {"sha": "d9ee9d82725f46280602e1bb252b9a8b5c36cdd1", "filename": "libgo/go/crypto/cipher/ctr.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -23,7 +23,7 @@ type ctr struct {\n // counter mode. The length of iv must be the same as the Block's block size.\n func NewCTR(block Block, iv []byte) Stream {\n \tif len(iv) != block.BlockSize() {\n-\t\tpanic(\"cipher.NewCTR: iv length must equal block size\")\n+\t\tpanic(\"cipher.NewCTR: IV length must equal block size\")\n \t}\n \n \treturn &ctr{"}, {"sha": "c888eb2c6a2f0bcdf49e5e2d802a9979fb4bf1b3", "filename": "libgo/go/crypto/cipher/example_test.go", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,283 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cipher_test\n+\n+import (\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n+\t\"crypto/rand\"\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+func ExampleNewCBCDecrypter() {\n+\tkey := []byte(\"example key 1234\")\n+\tciphertext, _ := hex.DecodeString(\"f363f3ccdcb12bb883abf484ba77d9cd7d32b5baecb3d4b1b3e0e4beffdb3ded\")\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// The IV needs to be unique, but not secure. Therefore it's common to\n+\t// include it at the beginning of the ciphertext.\n+\tif len(ciphertext) < aes.BlockSize {\n+\t\tpanic(\"ciphertext too short\")\n+\t}\n+\tiv := ciphertext[:aes.BlockSize]\n+\tciphertext = ciphertext[aes.BlockSize:]\n+\n+\t// CBC mode always works in whole blocks.\n+\tif len(ciphertext)%aes.BlockSize != 0 {\n+\t\tpanic(\"ciphertext is not a multiple of the block size\")\n+\t}\n+\n+\tmode := cipher.NewCBCDecrypter(block, iv)\n+\n+\t// CryptBlocks can work in-place if the two arguments are the same.\n+\tmode.CryptBlocks(ciphertext, ciphertext)\n+\n+\t// If the original plaintext lengths are not a multiple of the block\n+\t// size, padding would have to be added when encrypting, which would be\n+\t// removed at this point. For an example, see\n+\t// https://tools.ietf.org/html/rfc5246#section-6.2.3.2. However, it's\n+\t// critical to note that ciphertexts must be authenticated (i.e. by\n+\t// using crypto/hmac) before being decrypted in order to avoid creating\n+\t// a padding oracle.\n+\n+\tfmt.Printf(\"%s\\n\", ciphertext)\n+\t// Output: exampleplaintext\n+}\n+\n+func ExampleNewCBCEncrypter() {\n+\tkey := []byte(\"example key 1234\")\n+\tplaintext := []byte(\"exampleplaintext\")\n+\n+\t// CBC mode works on blocks so plaintexts may need to be padded to the\n+\t// next whole block. For an example of such padding, see\n+\t// https://tools.ietf.org/html/rfc5246#section-6.2.3.2. Here we'll\n+\t// assume that the plaintext is already of the correct length.\n+\tif len(plaintext)%aes.BlockSize != 0 {\n+\t\tpanic(\"plaintext is not a multiple of the block size\")\n+\t}\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// The IV needs to be unique, but not secure. Therefore it's common to\n+\t// include it at the beginning of the ciphertext.\n+\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n+\tiv := ciphertext[:aes.BlockSize]\n+\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tmode := cipher.NewCBCEncrypter(block, iv)\n+\tmode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)\n+\n+\t// It's important to remember that ciphertexts must be authenticated\n+\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n+\t// be secure.\n+\n+\tfmt.Printf(\"%x\\n\", ciphertext)\n+}\n+\n+func ExampleNewCFBDecrypter() {\n+\tkey := []byte(\"example key 1234\")\n+\tciphertext, _ := hex.DecodeString(\"22277966616d9bc47177bd02603d08c9a67d5380d0fe8cf3b44438dff7b9\")\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// The IV needs to be unique, but not secure. Therefore it's common to\n+\t// include it at the beginning of the ciphertext.\n+\tif len(ciphertext) < aes.BlockSize {\n+\t\tpanic(\"ciphertext too short\")\n+\t}\n+\tiv := ciphertext[:aes.BlockSize]\n+\tciphertext = ciphertext[aes.BlockSize:]\n+\n+\tstream := cipher.NewCFBDecrypter(block, iv)\n+\n+\t// XORKeyStream can work in-place if the two arguments are the same.\n+\tstream.XORKeyStream(ciphertext, ciphertext)\n+\tfmt.Printf(\"%s\", ciphertext)\n+\t// Output: some plaintext\n+}\n+\n+func ExampleNewCFBEncrypter() {\n+\tkey := []byte(\"example key 1234\")\n+\tplaintext := []byte(\"some plaintext\")\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// The IV needs to be unique, but not secure. Therefore it's common to\n+\t// include it at the beginning of the ciphertext.\n+\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n+\tiv := ciphertext[:aes.BlockSize]\n+\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tstream := cipher.NewCFBEncrypter(block, iv)\n+\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n+\n+\t// It's important to remember that ciphertexts must be authenticated\n+\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n+\t// be secure.\n+}\n+\n+func ExampleNewCTR() {\n+\tkey := []byte(\"example key 1234\")\n+\tplaintext := []byte(\"some plaintext\")\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// The IV needs to be unique, but not secure. Therefore it's common to\n+\t// include it at the beginning of the ciphertext.\n+\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n+\tiv := ciphertext[:aes.BlockSize]\n+\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tstream := cipher.NewCTR(block, iv)\n+\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n+\n+\t// It's important to remember that ciphertexts must be authenticated\n+\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n+\t// be secure.\n+\n+\t// CTR mode is the same for both encryption and decryption, so we can\n+\t// also decrypt that ciphertext with NewCTR.\n+\n+\tplaintext2 := make([]byte, len(plaintext))\n+\tstream = cipher.NewCTR(block, iv)\n+\tstream.XORKeyStream(plaintext2, ciphertext[aes.BlockSize:])\n+\n+\tfmt.Printf(\"%s\\n\", plaintext2)\n+\t// Output: some plaintext\n+}\n+\n+func ExampleNewOFB() {\n+\tkey := []byte(\"example key 1234\")\n+\tplaintext := []byte(\"some plaintext\")\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// The IV needs to be unique, but not secure. Therefore it's common to\n+\t// include it at the beginning of the ciphertext.\n+\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n+\tiv := ciphertext[:aes.BlockSize]\n+\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tstream := cipher.NewOFB(block, iv)\n+\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n+\n+\t// It's important to remember that ciphertexts must be authenticated\n+\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n+\t// be secure.\n+\n+\t// OFB mode is the same for both encryption and decryption, so we can\n+\t// also decrypt that ciphertext with NewOFB.\n+\n+\tplaintext2 := make([]byte, len(plaintext))\n+\tstream = cipher.NewOFB(block, iv)\n+\tstream.XORKeyStream(plaintext2, ciphertext[aes.BlockSize:])\n+\n+\tfmt.Printf(\"%s\\n\", plaintext2)\n+\t// Output: some plaintext\n+}\n+\n+func ExampleStreamReader() {\n+\tkey := []byte(\"example key 1234\")\n+\n+\tinFile, err := os.Open(\"encrypted-file\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tdefer inFile.Close()\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// If the key is unique for each ciphertext, then it's ok to use a zero\n+\t// IV.\n+\tvar iv [aes.BlockSize]byte\n+\tstream := cipher.NewOFB(block, iv[:])\n+\n+\toutFile, err := os.OpenFile(\"decrypted-file\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tdefer outFile.Close()\n+\n+\treader := &cipher.StreamReader{stream, inFile}\n+\t// Copy the input file to the output file, decrypting as we go.\n+\tif _, err := io.Copy(outFile, reader); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// Note that this example is simplistic in that it omits any\n+\t// authentication of the encrypted data. It you were actually to use\n+\t// StreamReader in this manner, an attacker could flip arbitary bits in\n+\t// the output.\n+}\n+\n+func ExampleStreamWriter() {\n+\tkey := []byte(\"example key 1234\")\n+\n+\tinFile, err := os.Open(\"plaintext-file\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tdefer inFile.Close()\n+\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// If the key is unique for each ciphertext, then it's ok to use a zero\n+\t// IV.\n+\tvar iv [aes.BlockSize]byte\n+\tstream := cipher.NewOFB(block, iv[:])\n+\n+\toutFile, err := os.OpenFile(\"encrypted-file\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tdefer outFile.Close()\n+\n+\twriter := &cipher.StreamWriter{stream, outFile, nil}\n+\t// Copy the input file to the output file, encrypting as we go.\n+\tif _, err := io.Copy(writer, inFile); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// Note that this example is simplistic in that it omits any\n+\t// authentication of the encrypted data. It you were actually to use\n+\t// StreamReader in this manner, an attacker could flip arbitary bits in\n+\t// the decrypted result.\n+}"}, {"sha": "b6f4919a7ce45e888d20fa3c77c1ca207ac3036c", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -2,13 +2,27 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as\n-// defined in U.S. Federal Information Processing Standards Publication 198.\n-// An HMAC is a cryptographic hash that uses a key to sign a message.\n-// The receiver verifies the hash by recomputing it using the same key.\n+/*\n+Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as\n+defined in U.S. Federal Information Processing Standards Publication 198.\n+An HMAC is a cryptographic hash that uses a key to sign a message.\n+The receiver verifies the hash by recomputing it using the same key.\n+\n+Receivers should be careful to use Equal to compare MACs in order to avoid\n+timing side-channels:\n+\n+\t// CheckMAC returns true if messageMAC is a valid HMAC tag for message.\n+\tfunc CheckMAC(message, messageMAC, key []byte) bool {\n+\t\tmac := hmac.New(sha256.New, key)\n+\t\tmac.Write(message)\n+\t\texpectedMAC := mac.Sum(nil)\n+\t\treturn hmac.Equal(messageMAC, expectedMAC)\n+\t}\n+*/\n package hmac\n \n import (\n+\t\"crypto/subtle\"\n \t\"hash\"\n )\n \n@@ -57,7 +71,7 @@ func (h *hmac) BlockSize() int { return h.blocksize }\n func (h *hmac) Reset() {\n \th.inner.Reset()\n \th.tmpPad(0x36)\n-\th.inner.Write(h.tmp[0:h.blocksize])\n+\th.inner.Write(h.tmp[:h.blocksize])\n }\n \n // New returns a new HMAC hash using the given hash.Hash type and key.\n@@ -78,3 +92,11 @@ func New(h func() hash.Hash, key []byte) hash.Hash {\n \thm.Reset()\n \treturn hm\n }\n+\n+// Equal compares two MACs for equality without leaking timing information.\n+func Equal(mac1, mac2 []byte) bool {\n+\t// We don't have to be constant time if the lengths of the MACs are\n+\t// different as that suggests that a completely different hash function\n+\t// was used.\n+\treturn len(mac1) == len(mac2) && subtle.ConstantTimeCompare(mac1, mac2) == 1\n+}"}, {"sha": "d4860424eb1df2583b0db00c15dfc971f337ef64", "filename": "libgo/go/crypto/hmac/hmac_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -491,3 +491,22 @@ func TestHMAC(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestEqual(t *testing.T) {\n+\ta := []byte(\"test\")\n+\tb := []byte(\"test1\")\n+\tc := []byte(\"test2\")\n+\n+\tif !Equal(b, b) {\n+\t\tt.Error(\"Equal failed with equal arguments\")\n+\t}\n+\tif Equal(a, b) {\n+\t\tt.Error(\"Equal accepted a prefix of the second argument\")\n+\t}\n+\tif Equal(b, a) {\n+\t\tt.Error(\"Equal accepted a prefix of the first argument\")\n+\t}\n+\tif Equal(b, c) {\n+\t\tt.Error(\"Equal accepted unequal slices\")\n+\t}\n+}"}, {"sha": "966bdae267b3a09b3b67c88c85fca77c498ccb8e", "filename": "libgo/go/crypto/md5/gen.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -203,6 +203,8 @@ func block(dig *digest, p []byte) {\n \t\t\t// less code and run 1.3x faster if we take advantage of that.\n \t\t\t// My apologies.\n \t\t\tX = (*[16]uint32)(unsafe.Pointer(&p[0]))\n+\t\t} else if uintptr(unsafe.Pointer(&p[0]))&(unsafe.Alignof(uint32(0))-1) == 0 {\n+\t\t\tX = (*[16]uint32)(unsafe.Pointer(&p[0]))\n \t\t} else {\n \t\t\tX = &xbuf\n \t\t\tj := 0"}, {"sha": "cac39ad054b6c9ce1bb73b8c28c9c499f9c42e83", "filename": "libgo/go/crypto/md5/md5_test.go", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"testing\"\n+\t\"unsafe\"\n )\n \n type md5Test struct {\n@@ -54,13 +55,19 @@ func TestGolden(t *testing.T) {\n \tfor i := 0; i < len(golden); i++ {\n \t\tg := golden[i]\n \t\tc := md5.New()\n-\t\tfor j := 0; j < 3; j++ {\n+\t\tbuf := make([]byte, len(g.in)+4)\n+\t\tfor j := 0; j < 3+4; j++ {\n \t\t\tif j < 2 {\n \t\t\t\tio.WriteString(c, g.in)\n-\t\t\t} else {\n+\t\t\t} else if j == 2 {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n \t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n+\t\t\t} else if j > 2 {\n+\t\t\t\t// test unaligned write\n+\t\t\t\tbuf = buf[1:]\n+\t\t\t\tcopy(buf, g.in)\n+\t\t\t\tc.Write(buf[:len(g.in)])\n \t\t\t}\n \t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n@@ -80,26 +87,45 @@ func ExampleNew() {\n }\n \n var bench = md5.New()\n-var buf = makeBuf()\n+var buf = make([]byte, 8192+1)\n+var sum = make([]byte, bench.Size())\n \n-func makeBuf() []byte {\n-\tb := make([]byte, 8<<10)\n-\tfor i := range b {\n-\t\tb[i] = byte(i)\n+func benchmarkSize(b *testing.B, size int, unaligned bool) {\n+\tb.SetBytes(int64(size))\n+\tbuf := buf\n+\tif unaligned {\n+\t\tif uintptr(unsafe.Pointer(&buf[0]))&(unsafe.Alignof(uint32(0))-1) == 0 {\n+\t\t\tbuf = buf[1:]\n+\t\t}\n+\t}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Reset()\n+\t\tbench.Write(buf[:size])\n+\t\tbench.Sum(sum[:0])\n \t}\n-\treturn b\n+}\n+\n+func BenchmarkHash8Bytes(b *testing.B) {\n+\tbenchmarkSize(b, 8, false)\n }\n \n func BenchmarkHash1K(b *testing.B) {\n-\tb.SetBytes(1024)\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf[:1024])\n-\t}\n+\tbenchmarkSize(b, 1024, false)\n }\n \n func BenchmarkHash8K(b *testing.B) {\n-\tb.SetBytes(int64(len(buf)))\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf)\n-\t}\n+\tbenchmarkSize(b, 8192, false)\n+}\n+\n+func BenchmarkHash8BytesUnaligned(b *testing.B) {\n+\tbenchmarkSize(b, 8, true)\n+}\n+\n+func BenchmarkHash1KUnaligned(b *testing.B) {\n+\tbenchmarkSize(b, 1024, true)\n+}\n+\n+func BenchmarkHash8KUnaligned(b *testing.B) {\n+\tbenchmarkSize(b, 8192, true)\n }"}, {"sha": "59f8f6f5afa42ce9c1fda4fec947465bb83807c0", "filename": "libgo/go/crypto/md5/md5block.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -22,6 +22,8 @@ func block(dig *digest, p []byte) {\n \t\t\t// less code and run 1.3x faster if we take advantage of that.\n \t\t\t// My apologies.\n \t\t\tX = (*[16]uint32)(unsafe.Pointer(&p[0]))\n+\t\t} else if uintptr(unsafe.Pointer(&p[0]))&(unsafe.Alignof(uint32(0))-1) == 0 {\n+\t\t\tX = (*[16]uint32)(unsafe.Pointer(&p[0]))\n \t\t} else {\n \t\t\tX = &xbuf\n \t\t\tj := 0"}, {"sha": "6addd04bce1e36dd4fd173ec4a1434d9877219f3", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -61,7 +61,7 @@ type PrivateKey struct {\n }\n \n type PrecomputedValues struct {\n-\tDp, Dq *big.Int // D mod (P-1) (or mod Q-1) \n+\tDp, Dq *big.Int // D mod (P-1) (or mod Q-1)\n \tQinv   *big.Int // Q^-1 mod Q\n \n \t// CRTValues is used for the 3rd and subsequent primes. Due to a"}, {"sha": "f9fa56efe72b557d6cb5f11f6bbf348fb57a0a79", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -116,7 +116,7 @@ func BenchmarkRSA2048Decrypt(b *testing.B) {\n \t}\n \tpriv.Precompute()\n \n-\tc := fromBase10(\"1000\")\n+\tc := fromBase10(\"8472002792838218989464636159316973636630013835787202418124758118372358261975764365740026024610403138425986214991379012696600761514742817632790916315594342398720903716529235119816755589383377471752116975374952783629225022962092351886861518911824745188989071172097120352727368980275252089141512321893536744324822590480751098257559766328893767334861211872318961900897793874075248286439689249972315699410830094164386544311554704755110361048571142336148077772023880664786019636334369759624917224888206329520528064315309519262325023881707530002540634660750469137117568199824615333883758410040459705787022909848740188613313\")\n \n \tb.StartTimer()\n \n@@ -141,7 +141,7 @@ func Benchmark3PrimeRSA2048Decrypt(b *testing.B) {\n \t}\n \tpriv.Precompute()\n \n-\tc := fromBase10(\"1000\")\n+\tc := fromBase10(\"8472002792838218989464636159316973636630013835787202418124758118372358261975764365740026024610403138425986214991379012696600761514742817632790916315594342398720903716529235119816755589383377471752116975374952783629225022962092351886861518911824745188989071172097120352727368980275252089141512321893536744324822590480751098257559766328893767334861211872318961900897793874075248286439689249972315699410830094164386544311554704755110361048571142336148077772023880664786019636334369759624917224888206329520528064315309519262325023881707530002540634660750469137117568199824615333883758410040459705787022909848740188613313\")\n \n \tb.StartTimer()\n "}, {"sha": "58541127784d14ffff77314dfb2ed15d3ad9b7db", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -81,26 +81,26 @@ func ExampleNew() {\n }\n \n var bench = sha1.New()\n-var buf = makeBuf()\n+var buf = make([]byte, 8192)\n \n-func makeBuf() []byte {\n-\tb := make([]byte, 8<<10)\n-\tfor i := range b {\n-\t\tb[i] = byte(i)\n+func benchmarkSize(b *testing.B, size int) {\n+\tb.SetBytes(int64(size))\n+\tsum := make([]byte, bench.Size())\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Reset()\n+\t\tbench.Write(buf[:size])\n+\t\tbench.Sum(sum[:0])\n \t}\n-\treturn b\n+}\n+\n+func BenchmarkHash8Bytes(b *testing.B) {\n+\tbenchmarkSize(b, 8)\n }\n \n func BenchmarkHash1K(b *testing.B) {\n-\tb.SetBytes(1024)\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf[:1024])\n-\t}\n+\tbenchmarkSize(b, 1024)\n }\n \n func BenchmarkHash8K(b *testing.B) {\n-\tb.SetBytes(int64(len(buf)))\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf)\n-\t}\n+\tbenchmarkSize(b, 8192)\n }"}, {"sha": "1c9507c68e523fa5461f28478de4012ec3f967fd", "filename": "libgo/go/crypto/sha1/sha1block.go", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -16,7 +16,7 @@ const (\n )\n \n func block(dig *digest, p []byte) {\n-\tvar w [80]uint32\n+\tvar w [16]uint32\n \n \th0, h1, h2, h3, h4 := dig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4]\n \tfor len(p) >= chunk {\n@@ -26,42 +26,56 @@ func block(dig *digest, p []byte) {\n \t\t\tj := i * 4\n \t\t\tw[i] = uint32(p[j])<<24 | uint32(p[j+1])<<16 | uint32(p[j+2])<<8 | uint32(p[j+3])\n \t\t}\n-\t\tfor i := 16; i < 80; i++ {\n-\t\t\ttmp := w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16]\n-\t\t\tw[i] = tmp<<1 | tmp>>(32-1)\n-\t\t}\n \n \t\ta, b, c, d, e := h0, h1, h2, h3, h4\n \n \t\t// Each of the four 20-iteration rounds\n \t\t// differs only in the computation of f and\n \t\t// the choice of K (_K0, _K1, etc).\n-\t\tfor i := 0; i < 20; i++ {\n+\t\ti := 0\n+\t\tfor ; i < 16; i++ {\n+\t\t\tf := b&c | (^b)&d\n+\t\t\ta5 := a<<5 | a>>(32-5)\n+\t\t\tb30 := b<<30 | b>>(32-30)\n+\t\t\tt := a5 + f + e + w[i&0xf] + _K0\n+\t\t\ta, b, c, d, e = t, a, b30, c, d\n+\t\t}\n+\t\tfor ; i < 20; i++ {\n+\t\t\ttmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]\n+\t\t\tw[i&0xf] = tmp<<1 | tmp>>(32-1)\n+\n \t\t\tf := b&c | (^b)&d\n \t\t\ta5 := a<<5 | a>>(32-5)\n \t\t\tb30 := b<<30 | b>>(32-30)\n-\t\t\tt := a5 + f + e + w[i] + _K0\n+\t\t\tt := a5 + f + e + w[i&0xf] + _K0\n \t\t\ta, b, c, d, e = t, a, b30, c, d\n \t\t}\n-\t\tfor i := 20; i < 40; i++ {\n+\t\tfor ; i < 40; i++ {\n+\t\t\ttmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]\n+\t\t\tw[i&0xf] = tmp<<1 | tmp>>(32-1)\n \t\t\tf := b ^ c ^ d\n \t\t\ta5 := a<<5 | a>>(32-5)\n \t\t\tb30 := b<<30 | b>>(32-30)\n-\t\t\tt := a5 + f + e + w[i] + _K1\n+\t\t\tt := a5 + f + e + w[i&0xf] + _K1\n \t\t\ta, b, c, d, e = t, a, b30, c, d\n \t\t}\n-\t\tfor i := 40; i < 60; i++ {\n-\t\t\tf := b&c | b&d | c&d\n+\t\tfor ; i < 60; i++ {\n+\t\t\ttmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]\n+\t\t\tw[i&0xf] = tmp<<1 | tmp>>(32-1)\n+\t\t\tf := ((b | c) & d) | (b & c)\n+\n \t\t\ta5 := a<<5 | a>>(32-5)\n \t\t\tb30 := b<<30 | b>>(32-30)\n-\t\t\tt := a5 + f + e + w[i] + _K2\n+\t\t\tt := a5 + f + e + w[i&0xf] + _K2\n \t\t\ta, b, c, d, e = t, a, b30, c, d\n \t\t}\n-\t\tfor i := 60; i < 80; i++ {\n+\t\tfor ; i < 80; i++ {\n+\t\t\ttmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]\n+\t\t\tw[i&0xf] = tmp<<1 | tmp>>(32-1)\n \t\t\tf := b ^ c ^ d\n \t\t\ta5 := a<<5 | a>>(32-5)\n \t\t\tb30 := b<<30 | b>>(32-30)\n-\t\t\tt := a5 + f + e + w[i] + _K3\n+\t\t\tt := a5 + f + e + w[i&0xf] + _K3\n \t\t\ta, b, c, d, e = t, a, b30, c, d\n \t\t}\n "}, {"sha": "29bf1619aeb81ade899f9eb1e75be705e23522cb", "filename": "libgo/go/crypto/sha256/sha256_test.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -125,26 +125,26 @@ func TestGolden(t *testing.T) {\n }\n \n var bench = New()\n-var buf = makeBuf()\n+var buf = make([]byte, 8192)\n \n-func makeBuf() []byte {\n-\tb := make([]byte, 8<<10)\n-\tfor i := range b {\n-\t\tb[i] = byte(i)\n+func benchmarkSize(b *testing.B, size int) {\n+\tb.SetBytes(int64(size))\n+\tsum := make([]byte, bench.Size())\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Reset()\n+\t\tbench.Write(buf[:size])\n+\t\tbench.Sum(sum[:0])\n \t}\n-\treturn b\n+}\n+\n+func BenchmarkHash8Bytes(b *testing.B) {\n+\tbenchmarkSize(b, 8)\n }\n \n func BenchmarkHash1K(b *testing.B) {\n-\tb.SetBytes(1024)\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf[:1024])\n-\t}\n+\tbenchmarkSize(b, 1024)\n }\n \n func BenchmarkHash8K(b *testing.B) {\n-\tb.SetBytes(int64(len(buf)))\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf)\n-\t}\n+\tbenchmarkSize(b, 8192)\n }"}, {"sha": "6eafb1b5fa9136cd7db51c3f3b3278f1e44f1506", "filename": "libgo/go/crypto/sha512/sha512_test.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -125,26 +125,26 @@ func TestGolden(t *testing.T) {\n }\n \n var bench = New()\n-var buf = makeBuf()\n+var buf = make([]byte, 8192)\n \n-func makeBuf() []byte {\n-\tb := make([]byte, 8<<10)\n-\tfor i := range b {\n-\t\tb[i] = byte(i)\n+func benchmarkSize(b *testing.B, size int) {\n+\tb.SetBytes(int64(size))\n+\tsum := make([]byte, bench.Size())\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbench.Reset()\n+\t\tbench.Write(buf[:size])\n+\t\tbench.Sum(sum[:0])\n \t}\n-\treturn b\n+}\n+\n+func BenchmarkHash8Bytes(b *testing.B) {\n+\tbenchmarkSize(b, 8)\n }\n \n func BenchmarkHash1K(b *testing.B) {\n-\tb.SetBytes(1024)\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf[:1024])\n-\t}\n+\tbenchmarkSize(b, 1024)\n }\n \n func BenchmarkHash8K(b *testing.B) {\n-\tb.SetBytes(int64(len(buf)))\n-\tfor i := 0; i < b.N; i++ {\n-\t\tbench.Write(buf)\n-\t}\n+\tbenchmarkSize(b, 8192)\n }"}, {"sha": "44f3e66daed42c8b9741511ef7dbbf1f29d2df9b", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -513,7 +513,7 @@ Again:\n \t\t// First message, be extra suspicious:\n \t\t// this might not be a TLS client.\n \t\t// Bail out before reading a full 'body', if possible.\n-\t\t// The current max version is 3.1. \n+\t\t// The current max version is 3.1.\n \t\t// If the version is >= 16.0, it's probably not real.\n \t\t// Similarly, a clientHello message encodes in\n \t\t// well under a kilobyte.  If the length is >= 12 kB,\n@@ -604,9 +604,11 @@ Again:\n // sendAlert sends a TLS alert message.\n // c.out.Mutex <= L.\n func (c *Conn) sendAlertLocked(err alert) error {\n-\tc.tmp[0] = alertLevelError\n-\tif err == alertNoRenegotiation {\n+\tswitch err {\n+\tcase alertNoRenegotiation, alertCloseNotify:\n \t\tc.tmp[0] = alertLevelWarning\n+\tdefault:\n+\t\tc.tmp[0] = alertLevelError\n \t}\n \tc.tmp[1] = byte(err)\n \tc.writeRecord(recordTypeAlert, c.tmp[0:2])"}, {"sha": "58ee6186a5040698bdc5c5a8e67750500ad28f0e", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -246,15 +246,15 @@ var ecdheAESClientScript = [][]byte{\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x02, 0x00, 0x00,\n-\t\t0x50, 0x03, 0x01, 0x4f, 0x7f, 0x24, 0x25, 0x10,\n-\t\t0xa8, 0x9d, 0xb1, 0x33, 0xd6, 0x53, 0x81, 0xce,\n-\t\t0xb0, 0x69, 0xed, 0x1b, 0x9c, 0x5e, 0x40, 0x3a,\n-\t\t0x4d, 0x06, 0xbc, 0xc7, 0x84, 0x51, 0x5a, 0x30,\n-\t\t0x40, 0x50, 0x48, 0x20, 0xcd, 0x91, 0x80, 0x08,\n-\t\t0xff, 0x82, 0x38, 0xc6, 0x03, 0x2d, 0x45, 0x4c,\n-\t\t0x91, 0xbb, 0xcc, 0x27, 0x3d, 0x58, 0xff, 0x0d,\n-\t\t0x26, 0x34, 0x7b, 0x48, 0x7a, 0xce, 0x25, 0x20,\n-\t\t0x90, 0x0f, 0x35, 0x9f, 0xc0, 0x13, 0x00, 0x00,\n+\t\t0x50, 0x03, 0x01, 0x50, 0x77, 0x31, 0xf7, 0x5b,\n+\t\t0xdb, 0x3d, 0x7a, 0x62, 0x76, 0x70, 0x95, 0x33,\n+\t\t0x73, 0x71, 0x13, 0xfe, 0xa3, 0xb1, 0xd8, 0xb3,\n+\t\t0x4d, 0x0d, 0xdc, 0xfe, 0x58, 0x6e, 0x6a, 0x3a,\n+\t\t0xf9, 0xde, 0xdc, 0x20, 0x8e, 0xfa, 0x3d, 0x60,\n+\t\t0xd0, 0xda, 0xa4, 0x0e, 0x36, 0xf0, 0xde, 0xb6,\n+\t\t0x81, 0xb4, 0x80, 0x5e, 0xf9, 0xd2, 0x4c, 0xec,\n+\t\t0xd1, 0x9c, 0x2a, 0x81, 0xc3, 0x36, 0x0b, 0x0f,\n+\t\t0x4a, 0x3d, 0xdf, 0x75, 0xc0, 0x13, 0x00, 0x00,\n \t\t0x08, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01,\n \t\t0x02, 0x16, 0x03, 0x01, 0x02, 0x39, 0x0b, 0x00,\n \t\t0x02, 0x35, 0x00, 0x02, 0x32, 0x00, 0x02, 0x2f,\n@@ -329,23 +329,23 @@ var ecdheAESClientScript = [][]byte{\n \t\t0xbb, 0x77, 0xba, 0xe4, 0x12, 0xbb, 0xf4, 0xc8,\n \t\t0x5e, 0x9c, 0x81, 0xa8, 0x97, 0x60, 0x4c, 0x16,\n \t\t0x03, 0x01, 0x00, 0x8b, 0x0c, 0x00, 0x00, 0x87,\n-\t\t0x03, 0x00, 0x17, 0x41, 0x04, 0x0b, 0xe5, 0x39,\n-\t\t0xde, 0x17, 0x7a, 0xaf, 0x96, 0xd5, 0x16, 0x01,\n-\t\t0xa8, 0x06, 0x80, 0x98, 0x75, 0x52, 0x56, 0x92,\n-\t\t0x15, 0xf9, 0x8d, 0xc0, 0x98, 0x62, 0xed, 0x54,\n-\t\t0xb7, 0xef, 0x03, 0x11, 0x34, 0x82, 0x65, 0xd1,\n-\t\t0xde, 0x25, 0x15, 0x4c, 0xf3, 0xdf, 0x4d, 0xbd,\n-\t\t0x6c, 0xed, 0x3d, 0xd6, 0x04, 0xcc, 0xd1, 0xf7,\n-\t\t0x6d, 0x32, 0xb1, 0x1c, 0x59, 0xca, 0xfb, 0xbc,\n-\t\t0x61, 0xeb, 0x4b, 0xe6, 0x00, 0x00, 0x40, 0x3e,\n-\t\t0xe6, 0x23, 0x54, 0x61, 0x3f, 0x63, 0x16, 0xeb,\n-\t\t0x5c, 0xc3, 0xba, 0x8a, 0x19, 0x13, 0x60, 0x9f,\n-\t\t0x23, 0xbf, 0x36, 0x1a, 0x32, 0x7a, 0xae, 0x34,\n-\t\t0x7f, 0x2f, 0x89, 0x85, 0xe1, 0x0e, 0x93, 0xd7,\n-\t\t0xf0, 0xab, 0xa1, 0x0d, 0x54, 0x95, 0x79, 0x0b,\n-\t\t0xb4, 0xf1, 0x1c, 0x1d, 0x0f, 0x8c, 0x16, 0xec,\n-\t\t0x82, 0x60, 0xee, 0xa3, 0x71, 0x2f, 0xaf, 0x3e,\n-\t\t0xf1, 0xbd, 0xb5, 0x1b, 0x7f, 0xe0, 0xd2, 0x16,\n+\t\t0x03, 0x00, 0x17, 0x41, 0x04, 0xec, 0x06, 0x1f,\n+\t\t0xa0, 0x5e, 0x29, 0x49, 0x71, 0x8b, 0x04, 0x9f,\n+\t\t0x47, 0x87, 0xb1, 0xcb, 0xae, 0x57, 0x8f, 0xd7,\n+\t\t0xf6, 0xf8, 0x59, 0x74, 0x64, 0x5d, 0x3a, 0x08,\n+\t\t0xaf, 0x20, 0xc6, 0xd9, 0xfc, 0x5e, 0x36, 0x8b,\n+\t\t0x62, 0x0e, 0xdb, 0xee, 0xd8, 0xcd, 0xef, 0x25,\n+\t\t0x8a, 0x38, 0x88, 0x2d, 0x5c, 0x71, 0x50, 0x22,\n+\t\t0xda, 0x3f, 0x94, 0x06, 0xc9, 0x68, 0x5b, 0x78,\n+\t\t0x3d, 0x95, 0xca, 0x54, 0x44, 0x00, 0x40, 0x36,\n+\t\t0xcf, 0x10, 0x81, 0xb4, 0x32, 0x45, 0x3c, 0xa5,\n+\t\t0x2d, 0x3e, 0xb0, 0xf8, 0xf4, 0x51, 0xf5, 0x28,\n+\t\t0x09, 0x85, 0x71, 0xa6, 0x79, 0x71, 0x4b, 0x4e,\n+\t\t0xda, 0x32, 0x5a, 0xc7, 0xb3, 0x57, 0xfd, 0xe8,\n+\t\t0x12, 0xab, 0xd8, 0x29, 0xfb, 0x8b, 0x43, 0x8f,\n+\t\t0x7e, 0x27, 0x63, 0x91, 0x84, 0x9c, 0x51, 0x0c,\n+\t\t0x26, 0x7e, 0x36, 0x3b, 0x37, 0x8d, 0x8f, 0x9e,\n+\t\t0xe2, 0x82, 0x62, 0xbb, 0xe5, 0xdf, 0xfc, 0x16,\n \t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n \t},\n \t{\n@@ -359,34 +359,34 @@ var ecdheAESClientScript = [][]byte{\n \t\t0xe2, 0x32, 0x42, 0xe9, 0x58, 0xb6, 0xd7, 0x49,\n \t\t0xa6, 0xb5, 0x68, 0x1a, 0x41, 0x03, 0x56, 0x6b,\n \t\t0xdc, 0x5a, 0x89, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x30, 0x09, 0xac,\n-\t\t0xbe, 0x94, 0x75, 0x4d, 0x73, 0x45, 0xbd, 0xa8,\n-\t\t0x0c, 0xe3, 0x5f, 0x72, 0x0b, 0x40, 0x4f, 0xd0,\n-\t\t0xd2, 0xcb, 0x16, 0x50, 0xfe, 0xdd, 0x1a, 0x33,\n-\t\t0x5c, 0x18, 0x37, 0x98, 0x42, 0xfc, 0x25, 0x42,\n-\t\t0x33, 0xce, 0x60, 0xcf, 0x8e, 0x95, 0x6e, 0x48,\n-\t\t0xed, 0x00, 0x35, 0x50, 0x26, 0x7f,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x30, 0x9a, 0xaa,\n+\t\t0xca, 0x5b, 0x57, 0xae, 0x34, 0x92, 0x80, 0x45,\n+\t\t0x7f, 0xe6, 0xf9, 0x09, 0x19, 0xd0, 0xf0, 0x1e,\n+\t\t0x4b, 0xc3, 0xda, 0x71, 0xce, 0x34, 0x33, 0x56,\n+\t\t0x9f, 0x20, 0x9f, 0xf9, 0xa8, 0x62, 0x6c, 0x38,\n+\t\t0x1b, 0x41, 0xf5, 0x54, 0xf2, 0x79, 0x42, 0x6c,\n+\t\t0xb5, 0x0e, 0xe7, 0xe1, 0xbc, 0x54,\n \t},\n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x30, 0xf6, 0x6a, 0xdb, 0x83, 0xd4,\n-\t\t0x3c, 0x77, 0x52, 0xad, 0xc0, 0x0f, 0x3a, 0x2c,\n-\t\t0x42, 0xb9, 0x60, 0x4b, 0xb2, 0xf6, 0x84, 0xfd,\n-\t\t0x4e, 0x96, 0xfc, 0x15, 0xe7, 0x94, 0x25, 0xb0,\n-\t\t0x59, 0x9f, 0xdd, 0xb6, 0x58, 0x03, 0x13, 0x8d,\n-\t\t0xeb, 0xb0, 0xad, 0x30, 0x31, 0x58, 0x6c, 0xa0,\n-\t\t0x8f, 0x57, 0x50,\n+\t\t0x01, 0x00, 0x30, 0x62, 0x82, 0x41, 0x75, 0x2b,\n+\t\t0xee, 0x0f, 0xdc, 0x6c, 0x48, 0x5a, 0x63, 0xd6,\n+\t\t0xcb, 0x0a, 0xfd, 0x0a, 0x0e, 0xde, 0x8b, 0x41,\n+\t\t0x19, 0x0c, 0x13, 0x6b, 0x12, 0xd1, 0xc2, 0x53,\n+\t\t0xeb, 0x1e, 0xf3, 0x7a, 0xbf, 0x23, 0xc5, 0xa6,\n+\t\t0x81, 0xa1, 0xdb, 0xab, 0x2f, 0x2c, 0xbc, 0x35,\n+\t\t0x96, 0x72, 0x83,\n \t},\n \t{\n-\t\t0x17, 0x03, 0x01, 0x00, 0x20, 0xab, 0x64, 0x3d,\n-\t\t0x79, 0x69, 0x3e, 0xba, 0xc4, 0x24, 0x7b, 0xe5,\n-\t\t0xe5, 0x23, 0x66, 0x6f, 0x32, 0xdf, 0x50, 0x7c,\n-\t\t0x06, 0x2a, 0x02, 0x82, 0x79, 0x40, 0xdb, 0xb1,\n-\t\t0x04, 0xc0, 0x2b, 0xdc, 0x3a, 0x15, 0x03, 0x01,\n-\t\t0x00, 0x20, 0xf8, 0xad, 0xca, 0xd7, 0x96, 0xf0,\n-\t\t0xd6, 0xa3, 0x62, 0xe1, 0x03, 0x44, 0xdb, 0xd0,\n-\t\t0xc9, 0x63, 0x3e, 0x1b, 0x70, 0x41, 0x57, 0x0c,\n-\t\t0xd8, 0x8e, 0x71, 0x49, 0x68, 0xe3, 0x04, 0x53,\n-\t\t0x5a, 0xbe,\n+\t\t0x17, 0x03, 0x01, 0x00, 0x20, 0xaf, 0x5d, 0x35,\n+\t\t0x57, 0x10, 0x60, 0xb3, 0x25, 0x7c, 0x26, 0x0f,\n+\t\t0xf3, 0x5e, 0xb3, 0x0d, 0xad, 0x14, 0x53, 0xcc,\n+\t\t0x0c, 0x08, 0xd9, 0xa2, 0x67, 0xab, 0xf4, 0x03,\n+\t\t0x17, 0x20, 0xf1, 0x7e, 0xca, 0x15, 0x03, 0x01,\n+\t\t0x00, 0x20, 0x30, 0xd0, 0xc1, 0xfb, 0x5f, 0xa6,\n+\t\t0x1b, 0xb4, 0x48, 0xc2, 0x0b, 0x98, 0xa8, 0x88,\n+\t\t0x7a, 0xba, 0xdf, 0x36, 0x06, 0xd8, 0xcc, 0xe9,\n+\t\t0x34, 0xdd, 0x64, 0xc8, 0x73, 0xc5, 0xa2, 0x34,\n+\t\t0x64, 0xb7,\n \t},\n }"}, {"sha": "2546f16e3cd20b82063e6b6c2e5a2f5677e748c2", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 701, "deletions": 965, "changes": 1666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -393,24 +393,19 @@ func loadPEMCert(in string) *x509.Certificate {\n // The recorded bytes are written to stdout.\n var rc4ServerScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n-\t\t0x76, 0x03, 0x02, 0x4e, 0xdd, 0xe6, 0xa5, 0xf7,\n-\t\t0x00, 0x36, 0xf7, 0x83, 0xec, 0x93, 0x7c, 0xd2,\n-\t\t0x4d, 0xe7, 0x7b, 0xf5, 0x4c, 0xf7, 0xe3, 0x86,\n-\t\t0xe8, 0xec, 0x3b, 0xbd, 0x2c, 0x9a, 0x3f, 0x57,\n-\t\t0xf0, 0xa4, 0xd4, 0x00, 0x00, 0x34, 0x00, 0x33,\n-\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n-\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n-\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n-\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n-\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n-\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n-\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n-\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n-\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n-\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x01, 0x00, 0x00,\n+\t\t0x50, 0x03, 0x01, 0x50, 0x77, 0x3d, 0xbd, 0x32,\n+\t\t0x13, 0xd7, 0xea, 0x33, 0x65, 0x02, 0xb8, 0x70,\n+\t\t0xb7, 0x84, 0xc4, 0x05, 0x1f, 0xa4, 0x24, 0xc4,\n+\t\t0x91, 0x69, 0x04, 0x32, 0x96, 0xfe, 0x5b, 0x49,\n+\t\t0x71, 0x60, 0x9a, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t0x00,\n \t},\n-\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n \t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n@@ -509,72 +504,65 @@ var rc4ServerScript = [][]byte{\n \t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n \t\t0x00, 0x00, 0x00,\n \t},\n-\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0x39, 0xe2, 0x0f, 0x49, 0xa0,\n-\t\t0xe6, 0xe4, 0x3b, 0x0c, 0x5f, 0xce, 0x39, 0x97,\n-\t\t0x6c, 0xb6, 0x41, 0xd9, 0xe1, 0x52, 0x8f, 0x43,\n-\t\t0xb3, 0xc6, 0x4f, 0x9a, 0xe2, 0x1e, 0xb9, 0x3b,\n-\t\t0xe3, 0x72, 0x17, 0x68, 0xb2, 0x0d, 0x7b, 0x71,\n-\t\t0x33, 0x96, 0x5c, 0xf9, 0xfe, 0x18, 0x8f, 0x2f,\n-\t\t0x2b, 0x82, 0xec, 0x03, 0xf2, 0x16, 0xa8, 0xf8,\n-\t\t0x39, 0xf9, 0xbb, 0x5a, 0xd3, 0x0c, 0xc1, 0x2a,\n-\t\t0x52, 0xa1, 0x90, 0x20, 0x6b, 0x24, 0xc9, 0x55,\n-\t\t0xee, 0x05, 0xd8, 0xb3, 0x43, 0x58, 0xf6, 0x7f,\n-\t\t0x68, 0x2d, 0xb3, 0xd1, 0x1b, 0x30, 0xaa, 0xdf,\n-\t\t0xfc, 0x85, 0xf1, 0xab, 0x14, 0x51, 0x91, 0x78,\n-\t\t0x29, 0x35, 0x65, 0xe0, 0x9c, 0xf6, 0xb7, 0x35,\n-\t\t0x33, 0xdb, 0x28, 0x93, 0x4d, 0x86, 0xbc, 0xfe,\n-\t\t0xaa, 0xd1, 0xc0, 0x2e, 0x4d, 0xec, 0xa2, 0x98,\n-\t\t0xca, 0x08, 0xb2, 0x91, 0x14, 0xde, 0x97, 0x3a,\n-\t\t0xc4, 0x6b, 0x49, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0x7a, 0xcb,\n-\t\t0x3b, 0x0e, 0xbb, 0x7a, 0x56, 0x39, 0xaf, 0x83,\n-\t\t0xae, 0xfd, 0x25, 0xfd, 0x64, 0xb4, 0x0c, 0x0c,\n-\t\t0x17, 0x46, 0x54, 0x2c, 0x6a, 0x07, 0x83, 0xc6,\n-\t\t0x46, 0x08, 0x0b, 0xcd, 0x15, 0x53, 0xef, 0x40,\n-\t\t0x4e, 0x56,\n+\t\t0x82, 0x00, 0x80, 0x2d, 0x09, 0x7c, 0x7f, 0xfc,\n+\t\t0x84, 0xce, 0xb3, 0x30, 0x9b, 0xf9, 0xb7, 0xc8,\n+\t\t0xc3, 0xff, 0xee, 0x6f, 0x20, 0x8a, 0xf4, 0xfb,\n+\t\t0x86, 0x55, 0x1f, 0x6a, 0xb4, 0x81, 0x50, 0x3a,\n+\t\t0x46, 0x1b, 0xd3, 0xca, 0x4b, 0x11, 0xff, 0xef,\n+\t\t0x02, 0xbc, 0x18, 0xb8, 0x4a, 0x7d, 0x43, 0x23,\n+\t\t0x96, 0x92, 0x27, 0x7c, 0xca, 0xcf, 0xe6, 0x91,\n+\t\t0xe8, 0x14, 0x97, 0x68, 0xb4, 0xe5, 0xc0, 0xc9,\n+\t\t0x23, 0xdd, 0x54, 0x07, 0xa6, 0x2e, 0x8c, 0x98,\n+\t\t0xfc, 0xc6, 0x8c, 0x04, 0x6b, 0x1b, 0x5f, 0xd5,\n+\t\t0x3d, 0x8b, 0x6c, 0x55, 0x4f, 0x7a, 0xe6, 0x6c,\n+\t\t0x74, 0x2c, 0x1e, 0x34, 0xdb, 0xfb, 0x00, 0xb1,\n+\t\t0x4e, 0x10, 0x21, 0x16, 0xe0, 0x3e, 0xc5, 0x64,\n+\t\t0x84, 0x28, 0x2b, 0x2b, 0x29, 0x47, 0x51, 0x34,\n+\t\t0x76, 0x15, 0x20, 0x71, 0x0b, 0x30, 0xa1, 0x85,\n+\t\t0xd5, 0x15, 0x18, 0x14, 0x64, 0x4b, 0x40, 0x7c,\n+\t\t0x4f, 0xb3, 0x7b, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xab, 0xee,\n+\t\t0xf5, 0x97, 0x5f, 0xc6, 0x78, 0xf3, 0xc6, 0x83,\n+\t\t0x5b, 0x55, 0x4f, 0xcb, 0x45, 0x3f, 0xfa, 0xf7,\n+\t\t0x05, 0x02, 0xc2, 0x63, 0x87, 0x18, 0xb5, 0x9a,\n+\t\t0x62, 0xe2, 0x3f, 0x88, 0x5a, 0x60, 0x61, 0x72,\n+\t\t0xfa, 0x9c,\n \t},\n-\n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x24, 0xd3, 0x72, 0xeb, 0x29, 0xb9,\n-\t\t0x15, 0x29, 0xb5, 0xe5, 0xb7, 0xef, 0x5c, 0xb2,\n-\t\t0x9d, 0xf6, 0xc8, 0x47, 0xd6, 0xa0, 0x84, 0xf0,\n-\t\t0x8c, 0xcb, 0xe6, 0xbe, 0xbc, 0xfb, 0x38, 0x90,\n-\t\t0x89, 0x60, 0xa2, 0xe8, 0xaa, 0xb3, 0x12, 0x17,\n-\t\t0x03, 0x01, 0x00, 0x21, 0x67, 0x4a, 0x3d, 0x31,\n-\t\t0x6c, 0x5a, 0x1c, 0xf9, 0x6e, 0xf1, 0xd8, 0x12,\n-\t\t0x0e, 0xb9, 0xfd, 0xfc, 0x66, 0x91, 0xd1, 0x1d,\n-\t\t0x6e, 0xe4, 0x55, 0xdd, 0x11, 0xb9, 0xb8, 0xa2,\n-\t\t0x65, 0xa1, 0x95, 0x64, 0x1c, 0x15, 0x03, 0x01,\n-\t\t0x00, 0x16, 0x9b, 0xa0, 0x24, 0xe3, 0xcb, 0xae,\n-\t\t0xad, 0x51, 0xb3, 0x63, 0x59, 0x78, 0x49, 0x24,\n-\t\t0x06, 0x6e, 0xee, 0x7a, 0xd7, 0x74, 0x53, 0x04,\n+\t\t0x01, 0x00, 0x24, 0x72, 0xa4, 0xe4, 0xaa, 0xd2,\n+\t\t0xc4, 0x39, 0x7e, 0x2a, 0xc1, 0x6f, 0x34, 0x42,\n+\t\t0x28, 0xcb, 0x9d, 0x7a, 0x09, 0xca, 0x96, 0xad,\n+\t\t0x0e, 0x11, 0x51, 0x8a, 0x06, 0xb0, 0xe9, 0xca,\n+\t\t0xeb, 0xce, 0xe2, 0xd5, 0x2e, 0xc1, 0x8d, 0x17,\n+\t\t0x03, 0x01, 0x00, 0x21, 0x2e, 0x61, 0x86, 0x17,\n+\t\t0xdb, 0xa6, 0x30, 0xe2, 0x62, 0x06, 0x2a, 0x8b,\n+\t\t0x75, 0x2c, 0x2d, 0xcf, 0xf5, 0x01, 0x11, 0x52,\n+\t\t0x81, 0x38, 0xcf, 0xd5, 0xf7, 0xdc, 0x52, 0x31,\n+\t\t0x1f, 0x97, 0x43, 0xc2, 0x71, 0x15, 0x03, 0x01,\n+\t\t0x00, 0x16, 0xe0, 0x21, 0xfe, 0x36, 0x2e, 0x68,\n+\t\t0x2c, 0xf1, 0xbe, 0x04, 0xec, 0xd4, 0xc6, 0xdd,\n+\t\t0xac, 0x6f, 0x4c, 0x85, 0x32, 0x3f, 0x87, 0x1b,\n \t},\n }\n \n var des3ServerScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n-\t\t0x76, 0x03, 0x02, 0x4e, 0x84, 0xf4, 0x3c, 0xe4,\n-\t\t0xb8, 0xc7, 0xa0, 0x30, 0x55, 0x2a, 0xbc, 0xb7,\n-\t\t0x04, 0x6b, 0x6f, 0x87, 0x93, 0x96, 0xbd, 0x1a,\n-\t\t0x7a, 0x1e, 0xce, 0xd2, 0x0d, 0xf3, 0x01, 0x03,\n-\t\t0xbe, 0x7b, 0x17, 0x00, 0x00, 0x34, 0x00, 0x33,\n-\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n-\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n-\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n-\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n-\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n-\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n-\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n-\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n-\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n-\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x01, 0x00, 0x00,\n+\t\t0x50, 0x03, 0x01, 0x50, 0x77, 0x3d, 0xe3, 0x8e,\n+\t\t0x48, 0xe6, 0xbd, 0x6d, 0x72, 0x8a, 0x1a, 0x11,\n+\t\t0xb0, 0x8a, 0x7e, 0xff, 0x29, 0x07, 0xa8, 0x91,\n+\t\t0xbc, 0xea, 0x1e, 0x3e, 0x62, 0xc9, 0x8e, 0x72,\n+\t\t0x26, 0xd3, 0xca, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t0x00,\n \t},\n-\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n \t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n@@ -673,58 +661,49 @@ var des3ServerScript = [][]byte{\n \t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n \t\t0x00, 0x00, 0x00,\n \t},\n-\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0xae, 0xcf, 0x4f, 0x70, 0x0e,\n-\t\t0xe5, 0xe7, 0xba, 0xef, 0x0c, 0x66, 0xe9, 0xae,\n-\t\t0x76, 0xf4, 0xe0, 0xbc, 0x1c, 0x22, 0x5b, 0x72,\n-\t\t0xc9, 0x68, 0x63, 0x44, 0xec, 0x72, 0xc2, 0xca,\n-\t\t0xac, 0xc2, 0xf5, 0x5c, 0x28, 0xa1, 0xaf, 0xd0,\n-\t\t0xc2, 0xf7, 0x79, 0x71, 0x32, 0x73, 0x86, 0xea,\n-\t\t0x39, 0xf6, 0x04, 0x26, 0x19, 0x84, 0x1d, 0x7d,\n-\t\t0xa1, 0x21, 0xa6, 0x88, 0xbf, 0x33, 0x5a, 0x64,\n-\t\t0xb0, 0xc2, 0xcc, 0x19, 0x7a, 0x8b, 0x6e, 0x94,\n-\t\t0x9e, 0x2e, 0x20, 0xbe, 0xdc, 0xe9, 0x8e, 0xae,\n-\t\t0x5c, 0x39, 0xc8, 0xcd, 0x0e, 0x19, 0x9a, 0xa2,\n-\t\t0xfc, 0x3f, 0x61, 0x9a, 0xca, 0x58, 0x69, 0x0d,\n-\t\t0xa8, 0x7b, 0xbe, 0x98, 0x8f, 0xb9, 0x9d, 0x8b,\n-\t\t0x68, 0x65, 0xa9, 0x74, 0xcc, 0x8d, 0x0c, 0xb2,\n-\t\t0xc4, 0x0f, 0xdc, 0x56, 0x3e, 0x44, 0x61, 0x0a,\n-\t\t0x26, 0x93, 0x99, 0xef, 0x67, 0xff, 0x6e, 0x73,\n-\t\t0x01, 0xa1, 0x90, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x60, 0x49, 0x36,\n-\t\t0xc8, 0x38, 0x95, 0xe4, 0x5d, 0x8e, 0x80, 0x10,\n-\t\t0x26, 0x9f, 0x87, 0x7d, 0xcd, 0xb9, 0x32, 0x6c,\n-\t\t0xff, 0xaa, 0xe0, 0x07, 0xec, 0x33, 0xe2, 0x36,\n-\t\t0x9d, 0xd5, 0x83, 0x2c, 0xf0, 0x0a, 0xa0, 0xa8,\n-\t\t0x12, 0x9f, 0xca, 0x72, 0xda, 0x70, 0x7d, 0x76,\n-\t\t0x80, 0x12, 0x88, 0x07, 0xaa, 0x27, 0x62, 0x33,\n-\t\t0xab, 0x55, 0xad, 0x3c, 0x2b, 0x54, 0xc4, 0x1c,\n-\t\t0x91, 0xfd, 0x8f, 0x9c, 0xa7, 0x8b, 0x75, 0x10,\n-\t\t0xa8, 0x6e, 0xfc, 0x30, 0x52, 0x8a, 0x61, 0x02,\n-\t\t0xdb, 0x9c, 0x6f, 0xc8, 0x19, 0x93, 0x5d, 0x41,\n-\t\t0x1d, 0x36, 0x68, 0x0b, 0xec, 0x30, 0xae, 0xfb,\n-\t\t0x90, 0xdb, 0x6d, 0x83, 0xb0, 0xf2,\n+\t\t0x82, 0x00, 0x80, 0x33, 0x52, 0xe2, 0xd6, 0x79,\n+\t\t0xf8, 0xe6, 0xd4, 0xe2, 0x08, 0xb0, 0x73, 0x36,\n+\t\t0xa7, 0x61, 0x72, 0x19, 0xfb, 0xd1, 0x1f, 0xf5,\n+\t\t0xbc, 0x7c, 0x84, 0xdd, 0xed, 0x99, 0xd7, 0x5e,\n+\t\t0x3d, 0x11, 0xc3, 0x19, 0xb0, 0x7f, 0x10, 0x94,\n+\t\t0x72, 0x64, 0xf3, 0x2c, 0x3f, 0x8d, 0x73, 0x39,\n+\t\t0x9e, 0xca, 0x2e, 0x09, 0xbd, 0xb7, 0x8d, 0x4c,\n+\t\t0x5b, 0x58, 0xff, 0x4f, 0x53, 0xa9, 0xd4, 0x7c,\n+\t\t0x34, 0xe0, 0xaa, 0xa8, 0x14, 0xc0, 0x14, 0x25,\n+\t\t0x0b, 0xaa, 0x55, 0xab, 0x10, 0x34, 0x45, 0x72,\n+\t\t0xe8, 0x26, 0x6f, 0xf5, 0xbb, 0x3a, 0xfa, 0xd8,\n+\t\t0x4f, 0x70, 0xe1, 0xc1, 0xb6, 0x11, 0x1e, 0xd1,\n+\t\t0xe0, 0x0b, 0xa1, 0x3a, 0xdc, 0x94, 0x89, 0x7f,\n+\t\t0x88, 0x5e, 0x5a, 0xf1, 0x0c, 0x98, 0xe2, 0xab,\n+\t\t0x0e, 0x3a, 0xa8, 0x2f, 0xbb, 0xc5, 0x02, 0x07,\n+\t\t0x15, 0x5e, 0x46, 0x82, 0x54, 0x9c, 0x09, 0xea,\n+\t\t0xb9, 0x56, 0xf7, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x28, 0xb9, 0xbf,\n+\t\t0x9a, 0xb8, 0xe4, 0x14, 0x6b, 0xc6, 0xf0, 0x27,\n+\t\t0xb7, 0xdb, 0xb2, 0xbc, 0x16, 0xd1, 0x3c, 0x0b,\n+\t\t0xc1, 0xe6, 0x1c, 0xa1, 0x29, 0xc7, 0x37, 0xe6,\n+\t\t0x56, 0x1d, 0x16, 0xb5, 0xa8, 0x0d, 0x4d, 0xdb,\n+\t\t0x9d, 0xf8, 0xb2, 0x6a, 0x90, 0x96,\n \t},\n-\n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x28, 0x07, 0xf3, 0x33, 0x84, 0xb1,\n-\t\t0x5d, 0x2b, 0x52, 0xa4, 0x63, 0x3c, 0x32, 0xe0,\n-\t\t0x0d, 0x22, 0xf5, 0x23, 0xec, 0xf9, 0xa6, 0xec,\n-\t\t0xc0, 0x12, 0x69, 0x88, 0xf6, 0x7d, 0x37, 0xcd,\n-\t\t0xc2, 0x74, 0x2f, 0xef, 0xf6, 0x49, 0x15, 0xea,\n-\t\t0x88, 0x3f, 0x55, 0x17, 0x03, 0x01, 0x00, 0x28,\n-\t\t0xaf, 0x00, 0x84, 0xff, 0x11, 0x01, 0x6d, 0xba,\n-\t\t0x39, 0x5e, 0x45, 0xe1, 0x52, 0x5e, 0xc1, 0xab,\n-\t\t0xde, 0x5b, 0x16, 0xdd, 0xd6, 0x61, 0x57, 0xb8,\n-\t\t0x66, 0x8b, 0x2d, 0xde, 0x51, 0x41, 0xc5, 0x09,\n-\t\t0xb3, 0x6a, 0x06, 0x43, 0xb4, 0x73, 0x5c, 0xf1,\n-\t\t0x15, 0x03, 0x01, 0x00, 0x18, 0xbd, 0x65, 0xb2,\n-\t\t0xce, 0x77, 0x2e, 0xf9, 0x11, 0xc4, 0x80, 0x43,\n-\t\t0x5a, 0x73, 0x8b, 0x73, 0xdd, 0xf0, 0x54, 0x44,\n-\t\t0x7c, 0x56, 0x19, 0x54, 0xda,\n+\t\t0x01, 0x00, 0x28, 0x5d, 0xc9, 0xad, 0xcf, 0xf8,\n+\t\t0x37, 0x05, 0xec, 0x5e, 0xb2, 0x77, 0xb3, 0x1a,\n+\t\t0x91, 0x75, 0x1d, 0x8d, 0xdd, 0x1a, 0xff, 0xb6,\n+\t\t0xca, 0xf7, 0x59, 0x04, 0xb2, 0x11, 0x0a, 0x25,\n+\t\t0x7e, 0xc5, 0x7d, 0xba, 0x8a, 0x50, 0xcc, 0xe9,\n+\t\t0x89, 0xa0, 0x91, 0x17, 0x03, 0x01, 0x00, 0x28,\n+\t\t0x30, 0x68, 0x28, 0x1e, 0x75, 0x82, 0x04, 0xe7,\n+\t\t0xd3, 0x3b, 0xb1, 0x17, 0x32, 0x10, 0x7f, 0xae,\n+\t\t0x77, 0xeb, 0xf1, 0x46, 0xcc, 0xe5, 0xe0, 0xbe,\n+\t\t0x07, 0x37, 0x0d, 0x84, 0x54, 0xa1, 0x88, 0xac,\n+\t\t0xe5, 0x06, 0x7b, 0xee, 0xe6, 0xa1, 0xee, 0xb0,\n+\t\t0x15, 0x03, 0x01, 0x00, 0x18, 0x73, 0xa9, 0xf8,\n+\t\t0x5a, 0xd4, 0xfc, 0xd9, 0xa9, 0x82, 0x97, 0x50,\n+\t\t0x14, 0x76, 0x6c, 0x27, 0x9f, 0xa2, 0xf1, 0x52,\n+\t\t0xa0, 0xe3, 0xbd, 0xcb, 0xd3,\n \t},\n }\n \n@@ -890,17 +869,19 @@ var aesServerScript = [][]byte{\n \n var sslv3ServerScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x00, 0x00, 0x41, 0x01, 0x00, 0x00,\n-\t\t0x3d, 0x03, 0x00, 0x4e, 0x70, 0xe2, 0x18, 0x86,\n-\t\t0xd6, 0xc6, 0x6f, 0xf3, 0xc8, 0xf4, 0x02, 0xd6,\n-\t\t0x4d, 0xee, 0x17, 0x32, 0x4b, 0xd2, 0x78, 0xd8,\n-\t\t0xa1, 0x03, 0x5d, 0x68, 0x82, 0x89, 0xbe, 0xfd,\n-\t\t0x12, 0xb9, 0x06, 0x00, 0x00, 0x16, 0x00, 0x33,\n-\t\t0x00, 0x39, 0x00, 0x16, 0x00, 0x32, 0x00, 0x38,\n-\t\t0x00, 0x13, 0x00, 0x2f, 0x00, 0x35, 0x00, 0x0a,\n-\t\t0x00, 0x05, 0x00, 0x04, 0x01, 0x00,\n+\t\t0x16, 0x03, 0x00, 0x00, 0x54, 0x01, 0x00, 0x00,\n+\t\t0x50, 0x03, 0x00, 0x50, 0x77, 0x3d, 0x42, 0xae,\n+\t\t0x84, 0xbd, 0xc5, 0x07, 0xa5, 0xc4, 0xd6, 0x16,\n+\t\t0x4e, 0xd5, 0xc5, 0xfa, 0x02, 0x7a, 0x0f, 0x1d,\n+\t\t0xc1, 0xe1, 0xaa, 0xe3, 0x3b, 0x4b, 0x6f, 0x11,\n+\t\t0xfa, 0x1a, 0xa4, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t0x00,\n \t},\n-\n \t{\n \t\t0x16, 0x03, 0x00, 0x00, 0x2a, 0x02, 0x00, 0x00,\n \t\t0x26, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n@@ -999,90 +980,71 @@ var sslv3ServerScript = [][]byte{\n \t\t0xbd, 0xd9, 0x16, 0x03, 0x00, 0x00, 0x04, 0x0e,\n \t\t0x00, 0x00, 0x00,\n \t},\n-\n \t{\n \t\t0x16, 0x03, 0x00, 0x00, 0x84, 0x10, 0x00, 0x00,\n-\t\t0x80, 0x74, 0x0e, 0x3a, 0xcf, 0xba, 0x9f, 0x1a,\n-\t\t0x9b, 0xb2, 0xa4, 0xc7, 0x5d, 0xf3, 0x0c, 0x80,\n-\t\t0x06, 0x80, 0xf3, 0x57, 0xb2, 0xd9, 0x36, 0x24,\n-\t\t0x6a, 0x06, 0x13, 0x40, 0xf9, 0x7c, 0xb9, 0x3e,\n-\t\t0x4b, 0x68, 0x4f, 0x21, 0x90, 0x2d, 0xbd, 0xca,\n-\t\t0xd4, 0x83, 0xf0, 0x7a, 0xeb, 0x7a, 0x74, 0x1b,\n-\t\t0xcd, 0xfe, 0x69, 0xef, 0xc0, 0x86, 0xa0, 0x24,\n-\t\t0x31, 0x65, 0x40, 0xd2, 0xdd, 0x6f, 0xb9, 0xd7,\n-\t\t0x8d, 0xc1, 0x69, 0x60, 0x44, 0x7a, 0x75, 0xfb,\n-\t\t0x42, 0x6a, 0x0f, 0x66, 0x45, 0x10, 0x73, 0xee,\n-\t\t0x87, 0x28, 0x37, 0x83, 0x86, 0xd8, 0x5a, 0xc8,\n-\t\t0x60, 0x87, 0xda, 0x33, 0x87, 0xaf, 0x34, 0x8b,\n-\t\t0xf5, 0x61, 0x63, 0x7a, 0x5c, 0x60, 0x26, 0xb9,\n-\t\t0xdb, 0xa1, 0xb7, 0xe3, 0x60, 0x38, 0x94, 0x5c,\n-\t\t0x83, 0x23, 0xd6, 0x8d, 0xc2, 0x14, 0x4a, 0x0f,\n-\t\t0x0e, 0x4f, 0xf9, 0x4e, 0x7b, 0x15, 0xcd, 0x18,\n-\t\t0x04, 0x14, 0x03, 0x00, 0x00, 0x01, 0x01, 0x16,\n-\t\t0x03, 0x00, 0x00, 0x3c, 0xbd, 0xbc, 0xec, 0xdc,\n-\t\t0x79, 0xb1, 0xae, 0x16, 0xc9, 0x26, 0x9a, 0xc0,\n-\t\t0xc0, 0x2c, 0x33, 0x36, 0x13, 0x91, 0x58, 0x5d,\n-\t\t0x7d, 0xee, 0x4e, 0xd8, 0x7e, 0xac, 0x88, 0x87,\n-\t\t0x0a, 0x75, 0x66, 0xb1, 0x44, 0x79, 0x2f, 0x42,\n-\t\t0xe8, 0x92, 0x74, 0x4c, 0xab, 0x36, 0xc8, 0x17,\n-\t\t0x5f, 0x02, 0x8a, 0x20, 0x53, 0xe9, 0x1d, 0xb4,\n-\t\t0xfe, 0x5c, 0x2b, 0xd9, 0x0a, 0xfb, 0xc6, 0x63,\n+\t\t0x80, 0x4a, 0x8d, 0xc4, 0x38, 0x7a, 0x9c, 0xd6,\n+\t\t0xe8, 0x72, 0x9e, 0xa3, 0xdf, 0x37, 0xb4, 0x6c,\n+\t\t0x58, 0x33, 0x59, 0xd9, 0xc9, 0x4b, 0x50, 0x33,\n+\t\t0x6c, 0xed, 0x73, 0x38, 0x2a, 0x46, 0x55, 0x31,\n+\t\t0xa9, 0x8e, 0x8e, 0xfc, 0x0b, 0x5d, 0x5f, 0x3c,\n+\t\t0x88, 0x28, 0x3f, 0x60, 0x51, 0x13, 0xf1, 0x59,\n+\t\t0x0c, 0xa3, 0x5e, 0xe0, 0xa3, 0x35, 0x06, 0xb1,\n+\t\t0x71, 0x59, 0x24, 0x4e, 0xed, 0x07, 0x15, 0x88,\n+\t\t0x50, 0xef, 0xc2, 0xb2, 0x2a, 0x52, 0x30, 0x6a,\n+\t\t0x7c, 0xbe, 0x2f, 0xc6, 0x8f, 0xa8, 0x83, 0xc5,\n+\t\t0x80, 0x14, 0x62, 0x74, 0x7f, 0x96, 0x9f, 0x41,\n+\t\t0x32, 0x74, 0xdd, 0x76, 0x2d, 0x7b, 0xeb, 0x7b,\n+\t\t0xea, 0xd0, 0x4f, 0x0c, 0xcf, 0x9a, 0x9c, 0xc5,\n+\t\t0x7a, 0xe4, 0xbc, 0xf8, 0xa6, 0xe1, 0x09, 0x8e,\n+\t\t0x7c, 0x53, 0x3a, 0xe3, 0x30, 0x8f, 0x76, 0xee,\n+\t\t0x58, 0xbb, 0xfd, 0x0b, 0x06, 0xb8, 0xdf, 0xb7,\n+\t\t0x31, 0x14, 0x03, 0x00, 0x00, 0x01, 0x01, 0x16,\n+\t\t0x03, 0x00, 0x00, 0x3c, 0x13, 0x91, 0xc6, 0x4a,\n+\t\t0x0c, 0x59, 0x25, 0xce, 0x54, 0xc0, 0x1d, 0xb9,\n+\t\t0x2a, 0xff, 0x4d, 0xca, 0x26, 0x0c, 0x8c, 0x04,\n+\t\t0x98, 0x7c, 0x7c, 0x38, 0xa3, 0xf5, 0xf9, 0x36,\n+\t\t0x1c, 0x04, 0x32, 0x47, 0x2d, 0x48, 0x0e, 0x96,\n+\t\t0xe8, 0x2b, 0x5e, 0x5a, 0xc6, 0x0a, 0x48, 0x41,\n+\t\t0x34, 0x5e, 0x62, 0xd5, 0x68, 0x4e, 0x44, 0x1d,\n+\t\t0xb2, 0xa1, 0x11, 0xad, 0x6e, 0x14, 0x85, 0x61,\n \t},\n-\n \t{\n \t\t0x14, 0x03, 0x00, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x00, 0x00, 0x3c, 0xaa, 0xa1, 0x98, 0xc4, 0x6b,\n-\t\t0x5a, 0x16, 0x3f, 0x5f, 0xa4, 0x96, 0x3e, 0x78,\n-\t\t0xe4, 0x6f, 0x49, 0x05, 0x47, 0xc4, 0x05, 0x60,\n-\t\t0xeb, 0x0b, 0x45, 0xe3, 0xbc, 0x50, 0x11, 0x24,\n-\t\t0x5f, 0x01, 0xd7, 0xb8, 0x8f, 0x60, 0x63, 0x66,\n-\t\t0xbd, 0x3e, 0xd9, 0xa8, 0x80, 0x43, 0x9f, 0x0b,\n-\t\t0x51, 0x61, 0xed, 0x13, 0xc6, 0x21, 0xd0, 0xfe,\n-\t\t0xbc, 0x17, 0x3c, 0x36, 0xb0, 0x82, 0x7f, 0x17,\n-\t\t0x03, 0x00, 0x00, 0x21, 0xee, 0x44, 0xf3, 0xa6,\n-\t\t0x88, 0x9d, 0x78, 0x44, 0xde, 0xdf, 0xeb, 0xc5,\n-\t\t0xad, 0xc4, 0xcc, 0x56, 0x5c, 0x54, 0x96, 0x52,\n-\t\t0x3f, 0xd9, 0x40, 0x6e, 0x79, 0xd8, 0x58, 0x78,\n-\t\t0x4f, 0x5a, 0xe9, 0x06, 0xef, 0x15, 0x03, 0x00,\n-\t\t0x00, 0x16, 0xd3, 0xc2, 0x52, 0x99, 0x2a, 0x84,\n-\t\t0xc4, 0x52, 0x5f, 0x3b, 0x19, 0xe7, 0xfc, 0x65,\n-\t\t0xaf, 0xd3, 0xb7, 0xa3, 0xcc, 0x4a, 0x1d, 0x2e,\n+\t\t0x00, 0x00, 0x3c, 0x88, 0xae, 0xa9, 0xd4, 0xa8,\n+\t\t0x10, 0x8d, 0x65, 0xa6, 0x3e, 0x1e, 0xed, 0xd2,\n+\t\t0xfc, 0xc4, 0x7c, 0xa8, 0x94, 0x4f, 0x11, 0xaf,\n+\t\t0xa6, 0x87, 0x09, 0x37, 0x54, 0xf7, 0x69, 0xd1,\n+\t\t0xb5, 0x25, 0x6b, 0xb5, 0xed, 0xcb, 0x25, 0x39,\n+\t\t0x73, 0xeb, 0x53, 0x6c, 0xc7, 0xb4, 0x29, 0x8f,\n+\t\t0xd6, 0x49, 0xd1, 0x95, 0x59, 0x80, 0x9a, 0x67,\n+\t\t0x5c, 0xb2, 0xe0, 0xbd, 0x1e, 0xff, 0xaa, 0x17,\n+\t\t0x03, 0x00, 0x00, 0x21, 0x65, 0x7b, 0x99, 0x09,\n+\t\t0x02, 0xc3, 0x9d, 0x54, 0xd6, 0xe7, 0x32, 0x62,\n+\t\t0xab, 0xc1, 0x09, 0x91, 0x30, 0x0a, 0xc9, 0xfa,\n+\t\t0x70, 0xec, 0x06, 0x7b, 0xa3, 0xe1, 0x5f, 0xb4,\n+\t\t0x63, 0xe6, 0x5c, 0xba, 0x1f, 0x15, 0x03, 0x00,\n+\t\t0x00, 0x16, 0x40, 0x70, 0xbe, 0xe6, 0xa6, 0xee,\n+\t\t0x8f, 0xd0, 0x87, 0xa0, 0x43, 0xa1, 0x92, 0xd7,\n+\t\t0xd0, 0x1a, 0x0c, 0x20, 0x7c, 0xbf, 0xa2, 0xb5,\n \t},\n }\n \n var selectCertificateBySNIScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0xed, 0x01, 0x00, 0x00,\n-\t\t0xe9, 0x03, 0x02, 0x50, 0x5a, 0x1c, 0x90, 0x2b,\n-\t\t0xc8, 0xf1, 0xd9, 0x4b, 0xd0, 0x18, 0x69, 0xed,\n-\t\t0x5a, 0xbd, 0x68, 0xf6, 0xf7, 0xe3, 0xf0, 0x6e,\n-\t\t0xd1, 0xcc, 0xf1, 0x2d, 0x94, 0xa4, 0x01, 0x63,\n-\t\t0x91, 0xbe, 0xd0, 0x00, 0x00, 0x66, 0xc0, 0x14,\n-\t\t0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21, 0x00, 0x39,\n-\t\t0x00, 0x38, 0x00, 0x88, 0x00, 0x87, 0xc0, 0x0f,\n-\t\t0xc0, 0x05, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x12,\n-\t\t0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b, 0x00, 0x16,\n-\t\t0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a,\n-\t\t0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x1e,\n-\t\t0x00, 0x33, 0x00, 0x32, 0x00, 0x9a, 0x00, 0x99,\n-\t\t0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e, 0xc0, 0x04,\n-\t\t0x00, 0x2f, 0x00, 0x96, 0x00, 0x41, 0xc0, 0x11,\n-\t\t0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02, 0x00, 0x05,\n-\t\t0x00, 0x04, 0x00, 0x15, 0x00, 0x12, 0x00, 0x09,\n-\t\t0x00, 0x14, 0x00, 0x11, 0x00, 0x08, 0x00, 0x06,\n-\t\t0x00, 0x03, 0x00, 0xff, 0x02, 0x01, 0x00, 0x00,\n-\t\t0x59, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0e, 0x00,\n-\t\t0x00, 0x0b, 0x73, 0x6e, 0x69, 0x74, 0x65, 0x73,\n-\t\t0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x00, 0x0b, 0x00,\n-\t\t0x04, 0x03, 0x00, 0x01, 0x02, 0x00, 0x0a, 0x00,\n-\t\t0x34, 0x00, 0x32, 0x00, 0x0e, 0x00, 0x0d, 0x00,\n-\t\t0x19, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x18, 0x00,\n-\t\t0x09, 0x00, 0x0a, 0x00, 0x16, 0x00, 0x17, 0x00,\n-\t\t0x08, 0x00, 0x06, 0x00, 0x07, 0x00, 0x14, 0x00,\n-\t\t0x15, 0x00, 0x04, 0x00, 0x05, 0x00, 0x12, 0x00,\n-\t\t0x13, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00,\n-\t\t0x0f, 0x00, 0x10, 0x00, 0x11, 0x00, 0x0f, 0x00,\n-\t\t0x01, 0x01,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x6a, 0x01, 0x00, 0x00,\n+\t\t0x66, 0x03, 0x01, 0x50, 0x77, 0x3d, 0xfe, 0xfb,\n+\t\t0x8d, 0xc2, 0x68, 0xeb, 0xf9, 0xfa, 0x54, 0x97,\n+\t\t0x86, 0x45, 0xa2, 0xa3, 0xed, 0xb1, 0x91, 0xb8,\n+\t\t0x28, 0xc0, 0x47, 0xaf, 0xfb, 0xcd, 0xdc, 0x0e,\n+\t\t0xb3, 0xea, 0xa5, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00,\n+\t\t0x0e, 0x00, 0x00, 0x0b, 0x73, 0x6e, 0x69, 0x74,\n+\t\t0x65, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d,\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n@@ -1160,79 +1122,62 @@ var selectCertificateBySNIScript = [][]byte{\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0x45, 0x6d, 0x68, 0x61, 0xb9,\n-\t\t0x1a, 0xe5, 0xeb, 0x67, 0x22, 0x3b, 0x87, 0x19,\n-\t\t0x52, 0x86, 0x31, 0x91, 0xee, 0xcd, 0x17, 0x75,\n-\t\t0xc6, 0x44, 0xaf, 0x23, 0xef, 0xd9, 0xfa, 0xd2,\n-\t\t0x0b, 0xa2, 0xbb, 0xbf, 0x8b, 0x4b, 0x34, 0x50,\n-\t\t0xf6, 0x2e, 0x05, 0x09, 0x7e, 0xbf, 0xb3, 0xa6,\n-\t\t0x10, 0xe3, 0xc3, 0x49, 0x55, 0xa8, 0xdf, 0x6c,\n-\t\t0xaa, 0xab, 0x11, 0x4c, 0x80, 0x0a, 0x45, 0xf8,\n-\t\t0x37, 0xbb, 0xd3, 0x18, 0x4e, 0xec, 0x51, 0xbf,\n-\t\t0x1a, 0xf6, 0x11, 0x1b, 0xcf, 0x2c, 0xaf, 0x5f,\n-\t\t0x0b, 0x52, 0x4e, 0x92, 0x0c, 0x7a, 0xb2, 0x5d,\n-\t\t0xe2, 0x1f, 0x83, 0xbe, 0xf5, 0xbf, 0x05, 0xbf,\n-\t\t0x99, 0xd6, 0x9c, 0x86, 0x47, 0x5e, 0xb4, 0xff,\n-\t\t0xe7, 0xac, 0xad, 0x1e, 0x3c, 0xaa, 0x91, 0x39,\n-\t\t0xca, 0xad, 0xc5, 0x54, 0x64, 0x7e, 0xc2, 0x8a,\n-\t\t0x48, 0xee, 0xb6, 0x4e, 0xf9, 0x33, 0x82, 0x52,\n-\t\t0xe8, 0xed, 0x48, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xc1, 0x2f,\n-\t\t0x34, 0x03, 0x2a, 0xf2, 0xfd, 0x83, 0x69, 0x23,\n-\t\t0x8c, 0x9e, 0x66, 0x3b, 0xbb, 0xd1, 0xab, 0xbb,\n-\t\t0x51, 0x89, 0x27, 0x88, 0x0f, 0x08, 0x3e, 0x00,\n-\t\t0xdc, 0xc7, 0x47, 0x82, 0x13, 0x34, 0xec, 0xca,\n-\t\t0x68, 0x6a,\n+\t\t0x82, 0x00, 0x80, 0x69, 0xc3, 0xd4, 0x0e, 0xcc,\n+\t\t0xdc, 0xbc, 0x5e, 0xc2, 0x64, 0xa6, 0xde, 0x3c,\n+\t\t0x0c, 0x7e, 0x0c, 0x6b, 0x80, 0x0f, 0xd4, 0x8f,\n+\t\t0x02, 0x4b, 0xb2, 0xba, 0x8d, 0x01, 0xeb, 0x6b,\n+\t\t0xa1, 0x2e, 0x79, 0x37, 0xba, 0xae, 0x24, 0xc2,\n+\t\t0x26, 0x72, 0x51, 0xe1, 0x82, 0x8e, 0x51, 0x41,\n+\t\t0x1c, 0x54, 0xa4, 0x26, 0xbe, 0x13, 0xcd, 0x1b,\n+\t\t0xc6, 0xed, 0x3d, 0x1f, 0xfd, 0x72, 0x80, 0x90,\n+\t\t0xdb, 0xbf, 0xd6, 0x39, 0x94, 0x5f, 0x48, 0xfb,\n+\t\t0x25, 0x5a, 0xc9, 0x60, 0x9b, 0xd7, 0xc6, 0x20,\n+\t\t0xa8, 0x66, 0x64, 0x13, 0xf3, 0x65, 0xc8, 0xb1,\n+\t\t0xd5, 0x33, 0x21, 0x0e, 0x73, 0x41, 0xc0, 0x18,\n+\t\t0x1a, 0x37, 0xfe, 0xcf, 0x28, 0x2a, 0xcd, 0xe4,\n+\t\t0x0b, 0xac, 0xdd, 0x25, 0x5e, 0xcb, 0x17, 0x51,\n+\t\t0x69, 0xd5, 0x8c, 0xf4, 0xb6, 0x21, 0x98, 0xef,\n+\t\t0x20, 0xdb, 0x14, 0x67, 0xf3, 0x7c, 0x95, 0x6a,\n+\t\t0x48, 0x2a, 0x6a, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0x36, 0x1b,\n+\t\t0x09, 0xe5, 0xb9, 0xb9, 0x4d, 0x7d, 0xae, 0x87,\n+\t\t0xb6, 0x0f, 0xaf, 0xec, 0x22, 0xba, 0x0d, 0xa5,\n+\t\t0x96, 0x5e, 0x64, 0x65, 0xe7, 0xfb, 0xe3, 0xf3,\n+\t\t0x6b, 0x72, 0xa8, 0xdb, 0xed, 0xd8, 0x69, 0x9c,\n+\t\t0x08, 0xd8,\n \t},\n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x24, 0xda, 0x61, 0x76, 0x9f, 0x7a,\n-\t\t0x8a, 0xd0, 0x5f, 0x9b, 0x3d, 0xa7, 0xd5, 0xdd,\n-\t\t0x95, 0x4b, 0xd4, 0x64, 0x2d, 0x2d, 0x6a, 0x98,\n-\t\t0x9e, 0xfe, 0x77, 0x76, 0xe3, 0x02, 0x05, 0x0c,\n-\t\t0xb2, 0xa6, 0x15, 0x82, 0x28, 0x25, 0xc5, 0x17,\n-\t\t0x03, 0x01, 0x00, 0x21, 0x4e, 0x66, 0x2d, 0x50,\n-\t\t0x00, 0xa2, 0x44, 0x4d, 0xee, 0x5f, 0x81, 0x67,\n-\t\t0x21, 0x5d, 0x94, 0xc0, 0xfb, 0xdc, 0xbd, 0xf6,\n-\t\t0xa8, 0x32, 0x8e, 0x2c, 0x22, 0x58, 0x37, 0xb6,\n-\t\t0xa3, 0x1e, 0xf8, 0xdd, 0x83, 0x15, 0x03, 0x01,\n-\t\t0x00, 0x16, 0x68, 0x3b, 0x3a, 0xd0, 0x1e, 0xc4,\n-\t\t0x5e, 0x97, 0x6a, 0x47, 0x38, 0xfe, 0x17, 0x8e,\n-\t\t0xc0, 0xb6, 0x4a, 0x94, 0x00, 0xb5, 0x91, 0xbf,\n+\t\t0x01, 0x00, 0x24, 0x60, 0xf7, 0x09, 0x5f, 0xd1,\n+\t\t0xcb, 0xc9, 0xe1, 0x22, 0xb5, 0x2a, 0xcc, 0xde,\n+\t\t0x7c, 0xa7, 0xb8, 0x85, 0x00, 0xbc, 0xfd, 0x85,\n+\t\t0xe1, 0x91, 0x36, 0xbb, 0x07, 0x42, 0xad, 0x3d,\n+\t\t0x29, 0x62, 0x69, 0xc1, 0x45, 0x92, 0x6f, 0x17,\n+\t\t0x03, 0x01, 0x00, 0x21, 0x0d, 0xf9, 0xd5, 0x87,\n+\t\t0xb9, 0x57, 0x3c, 0x50, 0x19, 0xe4, 0x3a, 0x50,\n+\t\t0x45, 0xcc, 0x86, 0x89, 0xd4, 0x32, 0x79, 0x45,\n+\t\t0x7c, 0x9f, 0x96, 0xd4, 0x54, 0x56, 0x0c, 0x63,\n+\t\t0x72, 0x81, 0xc3, 0xd3, 0xe3, 0x15, 0x03, 0x01,\n+\t\t0x00, 0x16, 0x84, 0xec, 0x2e, 0xf6, 0xaf, 0x4f,\n+\t\t0xee, 0x48, 0x0f, 0xbe, 0xcd, 0x82, 0x5c, 0x56,\n+\t\t0x16, 0xe4, 0xfb, 0x89, 0xc5, 0x57, 0x3e, 0x91,\n \t},\n }\n \n var issueSessionTicketTest = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0xdd, 0x01, 0x00, 0x00,\n-\t\t0xd9, 0x03, 0x02, 0x50, 0x5a, 0x32, 0xb6, 0x36,\n-\t\t0x0e, 0x94, 0x63, 0x57, 0x93, 0xd7, 0x1e, 0xb2,\n-\t\t0xa7, 0xd3, 0x20, 0x24, 0x30, 0x3f, 0x46, 0xf9,\n-\t\t0xfe, 0x22, 0x02, 0xa1, 0xff, 0x57, 0xf8, 0x8f,\n-\t\t0x95, 0x4c, 0xdd, 0x00, 0x00, 0x66, 0xc0, 0x14,\n-\t\t0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21, 0x00, 0x39,\n-\t\t0x00, 0x38, 0x00, 0x88, 0x00, 0x87, 0xc0, 0x0f,\n-\t\t0xc0, 0x05, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x12,\n-\t\t0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b, 0x00, 0x16,\n-\t\t0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a,\n-\t\t0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x1e,\n-\t\t0x00, 0x33, 0x00, 0x32, 0x00, 0x9a, 0x00, 0x99,\n-\t\t0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e, 0xc0, 0x04,\n-\t\t0x00, 0x2f, 0x00, 0x96, 0x00, 0x41, 0xc0, 0x11,\n-\t\t0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02, 0x00, 0x05,\n-\t\t0x00, 0x04, 0x00, 0x15, 0x00, 0x12, 0x00, 0x09,\n-\t\t0x00, 0x14, 0x00, 0x11, 0x00, 0x08, 0x00, 0x06,\n-\t\t0x00, 0x03, 0x00, 0xff, 0x02, 0x01, 0x00, 0x00,\n-\t\t0x49, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01,\n-\t\t0x02, 0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00,\n-\t\t0x0e, 0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00,\n-\t\t0x0c, 0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00,\n-\t\t0x16, 0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00,\n-\t\t0x07, 0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00,\n-\t\t0x05, 0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00,\n-\t\t0x02, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00,\n-\t\t0x11, 0x00, 0x23, 0x00, 0x00, 0x00, 0x0f, 0x00,\n-\t\t0x01, 0x01,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x5a, 0x01, 0x00, 0x00,\n+\t\t0x56, 0x03, 0x01, 0x50, 0x77, 0x3e, 0x49, 0x7a,\n+\t\t0xb7, 0x86, 0x5c, 0x27, 0xd2, 0x97, 0x61, 0xe3,\n+\t\t0x49, 0x41, 0x48, 0xe7, 0x0e, 0xaa, 0x7e, 0x4d,\n+\t\t0xb8, 0xdc, 0x01, 0x97, 0xfb, 0xab, 0x53, 0xb2,\n+\t\t0x5e, 0x36, 0xf6, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t0x00, 0x00, 0x04, 0x00, 0x23, 0x00, 0x00,\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x30, 0x02, 0x00, 0x00,\n@@ -1335,735 +1280,526 @@ var issueSessionTicketTest = [][]byte{\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0x92, 0x3f, 0xcc, 0x4d, 0x2f,\n-\t\t0xb2, 0x12, 0xc4, 0xf5, 0x72, 0xf3, 0x5a, 0x3c,\n-\t\t0x5a, 0xbb, 0x99, 0x89, 0xe6, 0x21, 0x0f, 0xdf,\n-\t\t0xf3, 0xa3, 0xd0, 0xce, 0x76, 0x55, 0xfd, 0xec,\n-\t\t0x38, 0x80, 0xf0, 0x46, 0x0b, 0xfa, 0x61, 0x7c,\n-\t\t0xc2, 0xb5, 0xe2, 0x89, 0x7b, 0xeb, 0xcf, 0x3e,\n-\t\t0x97, 0xab, 0x72, 0xf6, 0xfd, 0xcf, 0x10, 0x82,\n-\t\t0x3a, 0x05, 0x55, 0x7c, 0x2d, 0x7f, 0x44, 0x38,\n-\t\t0x9d, 0xeb, 0xa4, 0x7e, 0x53, 0x35, 0xda, 0xe0,\n-\t\t0x7c, 0x24, 0x66, 0x42, 0x5d, 0x85, 0xcf, 0xa6,\n-\t\t0x98, 0x81, 0xec, 0x42, 0x94, 0x4e, 0x25, 0xb1,\n-\t\t0x64, 0xac, 0x89, 0x98, 0x74, 0xd2, 0xeb, 0x51,\n-\t\t0x5a, 0xb3, 0xbd, 0x14, 0xf6, 0xc6, 0xec, 0x0b,\n-\t\t0xdd, 0x8b, 0x89, 0xdc, 0xde, 0xf3, 0xd6, 0x62,\n-\t\t0xee, 0xe3, 0xcf, 0xf5, 0x39, 0x23, 0x46, 0x4f,\n-\t\t0xb8, 0xef, 0x14, 0x39, 0x06, 0x36, 0xad, 0x84,\n-\t\t0x42, 0xb9, 0xd7, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xa1, 0xf0,\n-\t\t0x68, 0xf5, 0x29, 0x7e, 0x78, 0xaa, 0xbd, 0x59,\n-\t\t0xdc, 0x32, 0xab, 0x8e, 0x25, 0x54, 0x64, 0x9e,\n-\t\t0x2b, 0x08, 0xf9, 0xb8, 0xe3, 0x89, 0x09, 0xa4,\n-\t\t0xfd, 0x05, 0x78, 0x59, 0xcb, 0x33, 0xfc, 0x66,\n-\t\t0xb5, 0x73,\n+\t\t0x82, 0x00, 0x80, 0x68, 0x10, 0xdc, 0x80, 0xbc,\n+\t\t0xb3, 0x5a, 0x10, 0x75, 0x89, 0xcc, 0xe5, 0x9f,\n+\t\t0xbf, 0xe2, 0xce, 0xa4, 0x9f, 0x7f, 0x60, 0xc4,\n+\t\t0xfe, 0x5c, 0xb5, 0x02, 0x2d, 0xa5, 0xa9, 0x1e,\n+\t\t0x2c, 0x10, 0x79, 0x15, 0x0f, 0xed, 0x96, 0xb3,\n+\t\t0xa8, 0x5e, 0x21, 0xbc, 0x5b, 0xdc, 0x58, 0x04,\n+\t\t0x7d, 0x37, 0xdb, 0xa0, 0x31, 0xe8, 0x4f, 0x04,\n+\t\t0xbc, 0x46, 0x7c, 0xdb, 0x2e, 0x93, 0x07, 0xaf,\n+\t\t0xa6, 0x36, 0xd3, 0x39, 0x8d, 0x1d, 0x95, 0xa8,\n+\t\t0x50, 0x4b, 0xc4, 0x2b, 0xde, 0xd7, 0x04, 0x6d,\n+\t\t0x77, 0x6c, 0x4d, 0x70, 0x51, 0x88, 0x16, 0x31,\n+\t\t0x40, 0xb5, 0xba, 0x90, 0x47, 0x64, 0x0c, 0x87,\n+\t\t0xa5, 0x19, 0xf9, 0x89, 0x24, 0x3c, 0x5e, 0x4b,\n+\t\t0xaa, 0xe0, 0x60, 0x47, 0x0f, 0x2e, 0xcc, 0xc2,\n+\t\t0xd5, 0x21, 0xed, 0x72, 0xd0, 0xa9, 0xdd, 0x2a,\n+\t\t0x2b, 0xef, 0x08, 0x3a, 0x65, 0xea, 0x8b, 0x52,\n+\t\t0x77, 0x2d, 0xcc, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xe2, 0x95,\n+\t\t0x62, 0x3c, 0x18, 0xe5, 0xc7, 0x2c, 0xda, 0x16,\n+\t\t0x9b, 0x28, 0x0d, 0xf7, 0x88, 0x7b, 0x5d, 0x33,\n+\t\t0x55, 0x3b, 0x01, 0x73, 0xf2, 0xc6, 0x4e, 0x96,\n+\t\t0x01, 0x01, 0x83, 0x65, 0xd4, 0xef, 0x12, 0x13,\n+\t\t0x1d, 0x42,\n \t},\n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x72, 0x04, 0x00, 0x00,\n \t\t0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,\n-\t\t0xe8, 0x4b, 0xd1, 0xef, 0xba, 0xfc, 0x00, 0xd4,\n-\t\t0x2f, 0xf5, 0x6f, 0xba, 0xdc, 0xb7, 0xd7, 0x87,\n-\t\t0x59, 0x58, 0x05, 0x06, 0x36, 0x8f, 0x47, 0xc7,\n-\t\t0x9e, 0x4c, 0xf8, 0xb5, 0xd7, 0x55, 0x84, 0x64,\n-\t\t0x0b, 0x4c, 0x0b, 0xad, 0x8d, 0x9b, 0x79, 0x4d,\n-\t\t0xd7, 0x61, 0xf7, 0x2b, 0x89, 0x46, 0x2b, 0x52,\n-\t\t0x1a, 0x3f, 0x51, 0x58, 0xce, 0x59, 0x23, 0xef,\n-\t\t0x60, 0x55, 0x07, 0xc0, 0x46, 0x97, 0xad, 0x0a,\n-\t\t0xe3, 0x55, 0x10, 0x06, 0xff, 0x57, 0x0c, 0xb1,\n-\t\t0x49, 0xac, 0x80, 0xc6, 0xc3, 0x95, 0x5f, 0x12,\n-\t\t0xe2, 0xe5, 0xaa, 0x9f, 0x78, 0xc2, 0x20, 0x14,\n+\t\t0xe8, 0x4b, 0xd1, 0xef, 0xba, 0xfb, 0x41, 0x92,\n+\t\t0x6d, 0x37, 0x5f, 0xf8, 0x7d, 0x90, 0x0f, 0x01,\n+\t\t0xf8, 0x8c, 0xee, 0xbc, 0xd9, 0x0c, 0x97, 0x7e,\n+\t\t0x23, 0x46, 0xe2, 0x6b, 0x52, 0xc6, 0xc6, 0x97,\n+\t\t0x1d, 0xab, 0xde, 0xa0, 0x86, 0x94, 0xc8, 0x2e,\n+\t\t0x8b, 0x2e, 0x42, 0x5f, 0xc2, 0x70, 0x35, 0xc9,\n+\t\t0xee, 0x37, 0xeb, 0x70, 0xaa, 0x59, 0x23, 0x6c,\n+\t\t0xc8, 0xc1, 0x84, 0x89, 0x39, 0x87, 0x73, 0x0a,\n+\t\t0x7e, 0xba, 0xca, 0xed, 0x63, 0xba, 0x4e, 0x4f,\n+\t\t0xf3, 0x31, 0x4b, 0xf0, 0xee, 0x91, 0xa5, 0xb4,\n+\t\t0x62, 0x01, 0x9e, 0xbd, 0xbc, 0xb3, 0x35, 0x14,\n \t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n-\t\t0x00, 0x24, 0x47, 0x51, 0xf1, 0x13, 0xc8, 0xa6,\n-\t\t0xd2, 0x2c, 0xad, 0x35, 0xff, 0x53, 0xe2, 0x72,\n-\t\t0x01, 0xcb, 0x33, 0xcd, 0xf4, 0xa0, 0x9c, 0x03,\n-\t\t0x47, 0xfe, 0xcd, 0xc1, 0x46, 0x8d, 0x41, 0x5e,\n-\t\t0x54, 0xf7, 0xc3, 0x85, 0x2b, 0x2f, 0x17, 0x03,\n-\t\t0x01, 0x00, 0x21, 0xf4, 0xbf, 0x94, 0x3e, 0x93,\n-\t\t0x0b, 0x1b, 0x75, 0x3a, 0xd9, 0xd0, 0x57, 0x75,\n-\t\t0xf3, 0xa7, 0x82, 0xc9, 0x6b, 0x9e, 0x43, 0x98,\n-\t\t0x44, 0x9e, 0x9f, 0xad, 0x03, 0xa8, 0xb9, 0xa3,\n-\t\t0x0a, 0xd1, 0xc4, 0xb4, 0x15, 0x03, 0x01, 0x00,\n-\t\t0x16, 0xee, 0x57, 0xbd, 0xd3, 0xb7, 0x20, 0x29,\n-\t\t0xd1, 0x24, 0xe2, 0xdc, 0x24, 0xc3, 0x73, 0x86,\n-\t\t0x81, 0x8e, 0x40, 0xc3, 0x6e, 0x99, 0x9e,\n+\t\t0x00, 0x24, 0x3f, 0x66, 0xe4, 0x98, 0xc1, 0x3f,\n+\t\t0xc6, 0x2c, 0x81, 0xfb, 0xa9, 0x9f, 0x27, 0xe9,\n+\t\t0x63, 0x20, 0x1e, 0x0e, 0x4f, 0xfc, 0x5d, 0x12,\n+\t\t0xee, 0x77, 0x73, 0xc6, 0x96, 0x51, 0xf2, 0x26,\n+\t\t0x35, 0x3f, 0xce, 0x6a, 0xa9, 0xfd, 0x17, 0x03,\n+\t\t0x01, 0x00, 0x21, 0x8d, 0xd5, 0x67, 0x60, 0x5d,\n+\t\t0xa7, 0x93, 0xcc, 0x39, 0x78, 0x59, 0xab, 0xdb,\n+\t\t0x10, 0x96, 0xf2, 0xad, 0xa2, 0x85, 0xe2, 0x93,\n+\t\t0x43, 0x43, 0xcf, 0x82, 0xbd, 0x1f, 0xdc, 0x7a,\n+\t\t0x72, 0xd6, 0x83, 0x3b, 0x15, 0x03, 0x01, 0x00,\n+\t\t0x16, 0x89, 0x55, 0xf6, 0x42, 0x71, 0xa9, 0xe9,\n+\t\t0x05, 0x68, 0xe8, 0xce, 0x0d, 0x21, 0xe9, 0xec,\n+\t\t0xf2, 0x27, 0x67, 0xa7, 0x94, 0xf8, 0x34,\n \t},\n }\n-\n var serverResumeTest = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x01, 0x01, 0x65, 0x01, 0x00, 0x01,\n-\t\t0x61, 0x03, 0x01, 0x50, 0x5a, 0x32, 0xe2, 0xde,\n-\t\t0x19, 0x5c, 0xb6, 0x51, 0x87, 0xa4, 0x30, 0x2e,\n-\t\t0x95, 0x26, 0xd6, 0xed, 0xbf, 0xbf, 0x24, 0xbb,\n-\t\t0xd1, 0x1a, 0x29, 0x9f, 0x37, 0xfd, 0xfb, 0xae,\n-\t\t0xc2, 0xba, 0x2b, 0x20, 0xb5, 0x7a, 0x00, 0x96,\n-\t\t0x92, 0x51, 0xfc, 0x41, 0x16, 0x29, 0xc0, 0x54,\n-\t\t0x5e, 0xa7, 0xa9, 0x1f, 0xf8, 0xbf, 0x79, 0xfa,\n-\t\t0x49, 0x5a, 0x15, 0x28, 0x72, 0x9a, 0x59, 0xf9,\n-\t\t0x9b, 0xc4, 0x3a, 0xa8, 0x00, 0x66, 0xc0, 0x14,\n-\t\t0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21, 0x00, 0x39,\n-\t\t0x00, 0x38, 0x00, 0x88, 0x00, 0x87, 0xc0, 0x0f,\n-\t\t0xc0, 0x05, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x12,\n-\t\t0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b, 0x00, 0x16,\n-\t\t0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a,\n-\t\t0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x1e,\n-\t\t0x00, 0x33, 0x00, 0x32, 0x00, 0x9a, 0x00, 0x99,\n-\t\t0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e, 0xc0, 0x04,\n-\t\t0x00, 0x2f, 0x00, 0x96, 0x00, 0x41, 0xc0, 0x11,\n-\t\t0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02, 0x00, 0x05,\n-\t\t0x00, 0x04, 0x00, 0x15, 0x00, 0x12, 0x00, 0x09,\n-\t\t0x00, 0x14, 0x00, 0x11, 0x00, 0x08, 0x00, 0x06,\n-\t\t0x00, 0x03, 0x00, 0xff, 0x02, 0x01, 0x00, 0x00,\n-\t\t0xb1, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01,\n-\t\t0x02, 0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00,\n-\t\t0x0e, 0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00,\n-\t\t0x0c, 0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00,\n-\t\t0x16, 0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00,\n-\t\t0x07, 0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00,\n-\t\t0x05, 0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00,\n-\t\t0x02, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00,\n-\t\t0x11, 0x00, 0x23, 0x00, 0x68, 0x00, 0x00, 0x00,\n+\t\t0x16, 0x03, 0x01, 0x00, 0xc2, 0x01, 0x00, 0x00,\n+\t\t0xbe, 0x03, 0x01, 0x50, 0x77, 0x3e, 0x4f, 0x1f,\n+\t\t0x6f, 0xa5, 0x81, 0xeb, 0xb8, 0x80, 0x55, 0xa4,\n+\t\t0x76, 0xc2, 0x7f, 0x27, 0xf2, 0xe7, 0xc9, 0x7a,\n+\t\t0x01, 0x3c, 0xd8, 0xc1, 0xde, 0x99, 0x1f, 0x7c,\n+\t\t0xab, 0x35, 0x98, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t0x00, 0x00, 0x6c, 0x00, 0x23, 0x00, 0x68, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xe8, 0x4b,\n-\t\t0xd1, 0xef, 0xba, 0xfc, 0x00, 0xd4, 0x2f, 0xf5,\n-\t\t0x6f, 0xba, 0xdc, 0xb7, 0xd7, 0x87, 0x59, 0x58,\n-\t\t0x05, 0x06, 0x36, 0x8f, 0x47, 0xc7, 0x9e, 0x4c,\n-\t\t0xf8, 0xb5, 0xd7, 0x55, 0x84, 0x64, 0x0b, 0x4c,\n-\t\t0x0b, 0xad, 0x8d, 0x9b, 0x79, 0x4d, 0xd7, 0x61,\n-\t\t0xf7, 0x2b, 0x89, 0x46, 0x2b, 0x52, 0x1a, 0x3f,\n-\t\t0x51, 0x58, 0xce, 0x59, 0x23, 0xef, 0x60, 0x55,\n-\t\t0x07, 0xc0, 0x46, 0x97, 0xad, 0x0a, 0xe3, 0x55,\n-\t\t0x10, 0x06, 0xff, 0x57, 0x0c, 0xb1, 0x49, 0xac,\n-\t\t0x80, 0xc6, 0xc3, 0x95, 0x5f, 0x12, 0xe2, 0xe5,\n-\t\t0xaa, 0x9f, 0x78, 0xc2, 0x20, 0x00, 0x0f, 0x00,\n-\t\t0x01, 0x01,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,\n+\t\t0xe8, 0x4b, 0xd1, 0xef, 0xba, 0xfb, 0x41, 0x92,\n+\t\t0x6d, 0x37, 0x5f, 0xf8, 0x7d, 0x90, 0x0f, 0x01,\n+\t\t0xf8, 0x8c, 0xee, 0xbc, 0xd9, 0x0c, 0x97, 0x7e,\n+\t\t0x23, 0x46, 0xe2, 0x6b, 0x52, 0xc6, 0xc6, 0x97,\n+\t\t0x1d, 0xab, 0xde, 0xa0, 0x86, 0x94, 0xc8, 0x2e,\n+\t\t0x8b, 0x2e, 0x42, 0x5f, 0xc2, 0x70, 0x35, 0xc9,\n+\t\t0xee, 0x37, 0xeb, 0x70, 0xaa, 0x59, 0x23, 0x6c,\n+\t\t0xc8, 0xc1, 0x84, 0x89, 0x39, 0x87, 0x73, 0x0a,\n+\t\t0x7e, 0xba, 0xca, 0xed, 0x63, 0xba, 0x4e, 0x4f,\n+\t\t0xf3, 0x31, 0x4b, 0xf0, 0xee, 0x91, 0xa5, 0xb4,\n+\t\t0x62, 0x01, 0x9e, 0xbd, 0xbc, 0xb3, 0x35,\n \t},\n \t{\n-\t\t0x16, 0x03, 0x01, 0x00, 0x4a, 0x02, 0x00, 0x00,\n-\t\t0x46, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n \t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t0x00, 0x00, 0x00, 0x20, 0xb5, 0x7a, 0x00, 0x96,\n-\t\t0x92, 0x51, 0xfc, 0x41, 0x16, 0x29, 0xc0, 0x54,\n-\t\t0x5e, 0xa7, 0xa9, 0x1f, 0xf8, 0xbf, 0x79, 0xfa,\n-\t\t0x49, 0x5a, 0x15, 0x28, 0x72, 0x9a, 0x59, 0xf9,\n-\t\t0x9b, 0xc4, 0x3a, 0xa8, 0x00, 0x05, 0x00, 0x14,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x14,\n \t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n-\t\t0x00, 0x24, 0x2c, 0x86, 0xdd, 0x85, 0x21, 0xa7,\n-\t\t0xda, 0x25, 0xf5, 0x55, 0x62, 0x2d, 0x82, 0x6b,\n-\t\t0x9d, 0x67, 0x22, 0x28, 0xf4, 0x55, 0x33, 0xd0,\n-\t\t0x77, 0xc0, 0x9e, 0xb7, 0xf4, 0x96, 0x07, 0x8c,\n-\t\t0xf5, 0xea, 0x5b, 0x50, 0xa4, 0xb7,\n+\t\t0x00, 0x24, 0xc5, 0x35, 0x74, 0x19, 0x05, 0xc5,\n+\t\t0x85, 0x68, 0x48, 0xe8, 0xb5, 0xe9, 0xaf, 0x78,\n+\t\t0xbd, 0x35, 0x6f, 0xe9, 0x79, 0x34, 0x1b, 0xf0,\n+\t\t0x35, 0xd4, 0x4e, 0x55, 0x2e, 0x3c, 0xd5, 0xaf,\n+\t\t0xfc, 0xba, 0xf5, 0x1e, 0x83, 0x32,\n \t},\n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x24, 0x15, 0x14, 0x9c, 0x21, 0xdd,\n-\t\t0x47, 0x61, 0x52, 0xf9, 0x22, 0x15, 0x55, 0x3c,\n-\t\t0xbd, 0xd7, 0xff, 0xf9, 0xbd, 0x84, 0xec, 0x97,\n-\t\t0x2d, 0x4e, 0xa9, 0x6a, 0xb9, 0x9b, 0x96, 0xc6,\n-\t\t0x9e, 0x5c, 0x77, 0xa8, 0x5d, 0x7a, 0x08,\n+\t\t0x01, 0x00, 0x24, 0x27, 0x28, 0x88, 0xe1, 0x7e,\n+\t\t0x0d, 0x9c, 0x12, 0x50, 0xf6, 0x7a, 0xa7, 0x32,\n+\t\t0x21, 0x68, 0xba, 0xd8, 0x0a, 0xdc, 0x39, 0xef,\n+\t\t0x68, 0x95, 0x82, 0xae, 0xbd, 0x12, 0x79, 0xa1,\n+\t\t0x99, 0xfd, 0xd0, 0x10, 0x8e, 0x4b, 0xd8,\n \t},\n \t{\n-\t\t0x17, 0x03, 0x01, 0x00, 0x21, 0x04, 0xab, 0x0f,\n-\t\t0x7c, 0x54, 0x20, 0xab, 0x34, 0xa3, 0x73, 0x92,\n-\t\t0xc5, 0xaa, 0xdd, 0x5b, 0xf5, 0x0c, 0xe4, 0x4f,\n-\t\t0xf1, 0x93, 0x07, 0xe5, 0xe8, 0x72, 0xc2, 0x03,\n-\t\t0x60, 0xfa, 0x64, 0x01, 0x00, 0x25, 0x15, 0x03,\n-\t\t0x01, 0x00, 0x16, 0xc7, 0xd9, 0xff, 0x67, 0xfc,\n-\t\t0x7a, 0xac, 0x8a, 0xe6, 0x23, 0xfe, 0x32, 0xbf,\n-\t\t0x84, 0xe1, 0xe2, 0xf5, 0x6a, 0xc8, 0xda, 0x30,\n-\t\t0x8f,\n+\t\t0x17, 0x03, 0x01, 0x00, 0x21, 0xc5, 0x7e, 0x0a,\n+\t\t0x52, 0x6a, 0xb9, 0xaa, 0x1d, 0xae, 0x9e, 0x24,\n+\t\t0x9c, 0x34, 0x1e, 0xdb, 0x50, 0x95, 0xee, 0x76,\n+\t\t0xd7, 0x28, 0x88, 0x08, 0xe3, 0x2e, 0x58, 0xf7,\n+\t\t0xdb, 0x34, 0x75, 0xa5, 0x7f, 0x9d, 0x15, 0x03,\n+\t\t0x01, 0x00, 0x16, 0x2c, 0xc1, 0x29, 0x5f, 0x12,\n+\t\t0x1d, 0x19, 0xab, 0xb3, 0xf4, 0x35, 0x1c, 0x62,\n+\t\t0x6a, 0x80, 0x29, 0x0d, 0x0e, 0xef, 0x7d, 0x6e,\n+\t\t0x50,\n \t},\n }\n \n var clientauthTests = []clientauthTest{\n-\t// Server doesn't asks for cert\n-\t// go test -run \"TestRunServer\" -serve -clientauth 0\n-\t// gnutls-cli --insecure --debug 100 -p 10443 localhost 2>&1 |\n-\t//   python parse-gnutls-cli-debug-log.py\n-\t{\"NoClientCert\", NoClientCert, nil,\n-\t\t[][]byte{{\n-\t\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n-\t\t\t0x76, 0x03, 0x02, 0x4e, 0xe0, 0x92, 0x5d, 0xcd,\n-\t\t\t0xfe, 0x0c, 0x69, 0xd4, 0x7d, 0x8e, 0xa6, 0x88,\n-\t\t\t0xde, 0x72, 0x04, 0x29, 0x6a, 0x4a, 0x16, 0x23,\n-\t\t\t0xd7, 0x8f, 0xbc, 0xfa, 0x80, 0x73, 0x2e, 0x12,\n-\t\t\t0xb7, 0x0b, 0x39, 0x00, 0x00, 0x34, 0x00, 0x33,\n-\t\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n-\t\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n-\t\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n-\t\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n-\t\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n-\t\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n-\t\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n-\t\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n-\t\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n-\t\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n-\t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n-\t\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n-\t\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n-\t\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n-\t\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n-\t\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n-\t\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n-\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n-\t\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n-\t\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n-\t\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n-\t\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n-\t\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n-\t\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n-\t\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n-\t\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n-\t\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n-\t\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n-\t\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n-\t\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n-\t\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n-\t\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n-\t\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n-\t\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n-\t\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n-\t\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n-\t\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n-\t\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n-\t\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n-\t\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n-\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n-\t\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n-\t\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n-\t\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n-\t\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n-\t\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n-\t\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n-\t\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n-\t\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n-\t\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n-\t\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n-\t\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n-\t\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n-\t\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n-\t\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n-\t\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n-\t\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n-\t\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n-\t\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n-\t\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n-\t\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n-\t\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n-\t\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n-\t\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n-\t\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n-\t\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n-\t\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n-\t\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n-\t\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n-\t\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n-\t\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n-\t\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n-\t\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n-\t\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n-\t\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n-\t\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n-\t\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n-\t\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n-\t\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n-\t\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n-\t\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n-\t\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n-\t\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n-\t\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n-\t\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n-\t\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n-\t\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n-\t\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n-\t\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n-\t\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n-\t\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n-\t\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n-\t\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n-\t\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n-\t\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n-\t\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n-\t\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n-\t\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n-\t\t\t\t0x00, 0x00, 0x00,\n-\t\t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t\t\t0x82, 0x00, 0x80, 0x10, 0xe1, 0x00, 0x3d, 0x0a,\n-\t\t\t\t0x6b, 0x02, 0x7f, 0x97, 0xde, 0xfb, 0x65, 0x46,\n-\t\t\t\t0x1a, 0x50, 0x4e, 0x34, 0x9a, 0xae, 0x14, 0x7e,\n-\t\t\t\t0xec, 0xef, 0x85, 0x15, 0x3b, 0x39, 0xc2, 0x45,\n-\t\t\t\t0x04, 0x40, 0x92, 0x71, 0xd6, 0x7e, 0xf6, 0xfd,\n-\t\t\t\t0x4d, 0x84, 0xf7, 0xc4, 0x77, 0x99, 0x3d, 0xe2,\n-\t\t\t\t0xc3, 0x8d, 0xb0, 0x4c, 0x74, 0xc8, 0x51, 0xec,\n-\t\t\t\t0xb2, 0xe8, 0x6b, 0xa1, 0xd2, 0x4d, 0xd8, 0x61,\n-\t\t\t\t0x92, 0x7a, 0x24, 0x57, 0x44, 0x4f, 0xa2, 0x1e,\n-\t\t\t\t0x74, 0x0b, 0x06, 0x4b, 0x80, 0x34, 0x8b, 0xfe,\n-\t\t\t\t0xc2, 0x0e, 0xc1, 0xcd, 0xab, 0x0c, 0x3f, 0x54,\n-\t\t\t\t0xe2, 0x44, 0xe9, 0x6c, 0x2b, 0xba, 0x7b, 0x64,\n-\t\t\t\t0xf1, 0x93, 0x65, 0x75, 0xf2, 0x35, 0xff, 0x27,\n-\t\t\t\t0x03, 0xd5, 0x64, 0xe6, 0x8e, 0xe7, 0x7b, 0x56,\n-\t\t\t\t0xb6, 0x61, 0x73, 0xeb, 0xa2, 0xdc, 0xa4, 0x6e,\n-\t\t\t\t0x52, 0xac, 0xbc, 0xba, 0x11, 0xa3, 0xd2, 0x61,\n-\t\t\t\t0x4a, 0xe0, 0xbb, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xd2, 0x5a,\n-\t\t\t\t0x0c, 0x2a, 0x27, 0x96, 0xba, 0xa9, 0x67, 0xd2,\n-\t\t\t\t0x51, 0x68, 0x32, 0x68, 0x22, 0x1f, 0xb9, 0x27,\n-\t\t\t\t0x79, 0x59, 0x28, 0xdf, 0x38, 0x1f, 0x92, 0x21,\n-\t\t\t\t0x5d, 0x0f, 0xf4, 0xc0, 0xee, 0xb7, 0x10, 0x5a,\n-\t\t\t\t0xa9, 0x45,\n-\t\t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t\t\t0x01, 0x00, 0x24, 0x13, 0x6f, 0x6c, 0x71, 0x83,\n-\t\t\t\t0x59, 0xcf, 0x32, 0x72, 0xe9, 0xce, 0xcc, 0x7a,\n-\t\t\t\t0x6c, 0xf0, 0x72, 0x39, 0x16, 0xae, 0x40, 0x61,\n-\t\t\t\t0xfa, 0x92, 0x4c, 0xe7, 0xf2, 0x1a, 0xd7, 0x0c,\n-\t\t\t\t0x84, 0x76, 0x6c, 0xe9, 0x11, 0x43, 0x19, 0x17,\n-\t\t\t\t0x03, 0x01, 0x00, 0x21, 0xc0, 0xa2, 0x13, 0x28,\n-\t\t\t\t0x94, 0x8c, 0x5c, 0xd6, 0x79, 0xb9, 0xfe, 0xae,\n-\t\t\t\t0x45, 0x4b, 0xc0, 0x7c, 0xae, 0x2d, 0xb4, 0x0d,\n-\t\t\t\t0x31, 0xc4, 0xad, 0x22, 0xd7, 0x1e, 0x99, 0x1c,\n-\t\t\t\t0x4c, 0x69, 0xab, 0x42, 0x61, 0x15, 0x03, 0x01,\n-\t\t\t\t0x00, 0x16, 0xe1, 0x0c, 0x67, 0xf3, 0xf4, 0xb9,\n-\t\t\t\t0x8e, 0x81, 0x8e, 0x01, 0xb8, 0xa0, 0x69, 0x8c,\n-\t\t\t\t0x03, 0x11, 0x43, 0x3e, 0xee, 0xb7, 0x4d, 0x69,\n-\t\t\t}}},\n \t// Server asks for cert with empty CA list, client doesn't give it.\n \t// go test -run \"TestRunServer\" -serve -clientauth 1\n-\t// gnutls-cli --insecure --debug 100 -p 10443 localhost\n-\t{\"RequestClientCert, none given\", RequestClientCert, nil,\n-\t\t[][]byte{{\n-\t\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n-\t\t\t0x76, 0x03, 0x02, 0x4e, 0xe0, 0x93, 0xe2, 0x47,\n-\t\t\t0x06, 0xa0, 0x61, 0x0c, 0x51, 0xdd, 0xf0, 0xef,\n-\t\t\t0xf4, 0x30, 0x72, 0xe1, 0xa6, 0x50, 0x68, 0x82,\n-\t\t\t0x3c, 0xfb, 0xcb, 0x72, 0x5e, 0x73, 0x9d, 0xda,\n-\t\t\t0x27, 0x35, 0x72, 0x00, 0x00, 0x34, 0x00, 0x33,\n-\t\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n-\t\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n-\t\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n-\t\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n-\t\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n-\t\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n-\t\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n-\t\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n-\t\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n-\t\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t{\"RequestClientCert, none given\", RequestClientCert, nil, [][]byte{\n+\t\t{\n+\t\t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x01, 0x00, 0x00,\n+\t\t\t0x50, 0x03, 0x01, 0x50, 0x77, 0x43, 0x9e, 0x31,\n+\t\t\t0xe6, 0x36, 0x5e, 0x5e, 0x24, 0xe4, 0x0d, 0x26,\n+\t\t\t0x34, 0xa7, 0x1c, 0x2e, 0x59, 0x6d, 0xa5, 0x3e,\n+\t\t\t0x72, 0xf3, 0xa3, 0x1c, 0xbc, 0xb3, 0x27, 0xaf,\n+\t\t\t0x92, 0x5b, 0x7d, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t\t0x00,\n \t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n-\t\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n-\t\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n-\t\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n-\t\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n-\t\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n-\t\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n-\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n-\t\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n-\t\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n-\t\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n-\t\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n-\t\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n-\t\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n-\t\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n-\t\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n-\t\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n-\t\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n-\t\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n-\t\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n-\t\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n-\t\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n-\t\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n-\t\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n-\t\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n-\t\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n-\t\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n-\t\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n-\t\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n-\t\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n-\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n-\t\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n-\t\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n-\t\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n-\t\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n-\t\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n-\t\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n-\t\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n-\t\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n-\t\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n-\t\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n-\t\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n-\t\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n-\t\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n-\t\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n-\t\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n-\t\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n-\t\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n-\t\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n-\t\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n-\t\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n-\t\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n-\t\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n-\t\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n-\t\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n-\t\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n-\t\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n-\t\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n-\t\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n-\t\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n-\t\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n-\t\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n-\t\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n-\t\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n-\t\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n-\t\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n-\t\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n-\t\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n-\t\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n-\t\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n-\t\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n-\t\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n-\t\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n-\t\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n-\t\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n-\t\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n-\t\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n-\t\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n-\t\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n-\t\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n-\t\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n-\t\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n-\t\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n-\t\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n-\t\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n-\t\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n-\t\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n-\t\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x08, 0x0d,\n-\t\t\t\t0x00, 0x00, 0x04, 0x01, 0x01, 0x00, 0x00, 0x16,\n-\t\t\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n-\t\t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x07, 0x0b, 0x00, 0x00,\n-\t\t\t\t0x03, 0x00, 0x00, 0x00, 0x16, 0x03, 0x01, 0x00,\n-\t\t\t\t0x86, 0x10, 0x00, 0x00, 0x82, 0x00, 0x80, 0x64,\n-\t\t\t\t0x28, 0xb9, 0x3f, 0x48, 0xaf, 0x06, 0x22, 0x39,\n-\t\t\t\t0x56, 0xd8, 0x6f, 0x63, 0x5d, 0x03, 0x48, 0x63,\n-\t\t\t\t0x01, 0x13, 0xa2, 0xd6, 0x76, 0xc0, 0xab, 0xda,\n-\t\t\t\t0x25, 0x30, 0x75, 0x6c, 0xaa, 0xb4, 0xdc, 0x35,\n-\t\t\t\t0x72, 0xdc, 0xf2, 0x43, 0xe4, 0x1d, 0x82, 0xfb,\n-\t\t\t\t0x6c, 0x64, 0xe2, 0xa7, 0x8f, 0x32, 0x67, 0x6b,\n-\t\t\t\t0xcd, 0xd2, 0xb2, 0x36, 0x94, 0xbc, 0x6f, 0x46,\n-\t\t\t\t0x79, 0x29, 0x42, 0xe3, 0x1a, 0xbf, 0xfb, 0x41,\n-\t\t\t\t0xd5, 0xe3, 0xb4, 0x2a, 0xf6, 0x95, 0x6f, 0x0c,\n-\t\t\t\t0x87, 0xb9, 0x03, 0x18, 0xa1, 0xea, 0x4a, 0xe2,\n-\t\t\t\t0x2e, 0x0f, 0x50, 0x00, 0xc1, 0xe8, 0x8c, 0xc8,\n-\t\t\t\t0xa2, 0xf6, 0xa4, 0x05, 0xf4, 0x38, 0x3e, 0xd9,\n-\t\t\t\t0x6e, 0x63, 0x96, 0x0c, 0x34, 0x73, 0x90, 0x03,\n-\t\t\t\t0x55, 0xa6, 0x34, 0xb0, 0x5e, 0x8c, 0x48, 0x40,\n-\t\t\t\t0x25, 0x45, 0x84, 0xa6, 0x21, 0x3f, 0x81, 0x97,\n-\t\t\t\t0xa7, 0x11, 0x09, 0x14, 0x95, 0xa5, 0xe5, 0x14,\n-\t\t\t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n-\t\t\t\t0x00, 0x24, 0x16, 0xaa, 0x01, 0x2c, 0xa8, 0xc1,\n-\t\t\t\t0x28, 0xaf, 0x35, 0xc1, 0xc1, 0xf3, 0x0a, 0x25,\n-\t\t\t\t0x66, 0x6e, 0x27, 0x11, 0xa3, 0xa4, 0xd9, 0xe9,\n-\t\t\t\t0xea, 0x15, 0x09, 0x9d, 0x28, 0xe3, 0x5b, 0x2b,\n-\t\t\t\t0xa6, 0x25, 0xa7, 0x14, 0x24, 0x3a,\n-\t\t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t\t\t0x01, 0x00, 0x24, 0x9a, 0xa8, 0xd6, 0x77, 0x46,\n-\t\t\t\t0x45, 0x68, 0x9d, 0x5d, 0xa9, 0x68, 0x03, 0xe5,\n-\t\t\t\t0xaf, 0xe8, 0xc8, 0x21, 0xc5, 0xc6, 0xc1, 0x50,\n-\t\t\t\t0xe0, 0xd8, 0x52, 0xce, 0xa3, 0x4f, 0x2d, 0xf4,\n-\t\t\t\t0xe3, 0xa7, 0x7d, 0x35, 0x80, 0x84, 0x12, 0x17,\n-\t\t\t\t0x03, 0x01, 0x00, 0x21, 0x8a, 0x82, 0x0c, 0x54,\n-\t\t\t\t0x1b, 0xeb, 0x77, 0x90, 0x2c, 0x3e, 0xbc, 0xf0,\n-\t\t\t\t0x23, 0xcc, 0xa8, 0x9f, 0x25, 0x08, 0x12, 0xed,\n-\t\t\t\t0x43, 0xf1, 0xf9, 0x06, 0xad, 0xa9, 0x4b, 0x97,\n-\t\t\t\t0x82, 0xb7, 0xc4, 0x0b, 0x4c, 0x15, 0x03, 0x01,\n-\t\t\t\t0x00, 0x16, 0x05, 0x2d, 0x9d, 0x45, 0x03, 0xb7,\n-\t\t\t\t0xc2, 0xd1, 0xb5, 0x1a, 0x43, 0xcf, 0x1a, 0x37,\n-\t\t\t\t0xf4, 0x70, 0xcc, 0xb4, 0xed, 0x07, 0x76, 0x3a,\n-\t\t\t}}},\n+\t\t{\n+\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n+\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x08, 0x0d,\n+\t\t\t0x00, 0x00, 0x04, 0x01, 0x01, 0x00, 0x00, 0x16,\n+\t\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n+\t\t},\n+\t\t{\n+\t\t\t0x16, 0x03, 0x01, 0x00, 0x07, 0x0b, 0x00, 0x00,\n+\t\t\t0x03, 0x00, 0x00, 0x00, 0x16, 0x03, 0x01, 0x00,\n+\t\t\t0x86, 0x10, 0x00, 0x00, 0x82, 0x00, 0x80, 0x04,\n+\t\t\t0x58, 0x63, 0x26, 0x32, 0x1b, 0x34, 0xbe, 0x10,\n+\t\t\t0xe4, 0xe4, 0x3e, 0xcd, 0x36, 0x7f, 0xa8, 0xa8,\n+\t\t\t0xe0, 0x19, 0xe8, 0x94, 0x13, 0xd9, 0x35, 0xc4,\n+\t\t\t0x71, 0xb4, 0x91, 0xd4, 0xbc, 0x74, 0x57, 0x9f,\n+\t\t\t0x93, 0xb7, 0x5d, 0x3b, 0x9c, 0xff, 0x5d, 0x79,\n+\t\t\t0xdb, 0x86, 0xfc, 0xdc, 0x74, 0x1e, 0x0c, 0xc6,\n+\t\t\t0xe8, 0x93, 0xcf, 0xaf, 0xba, 0x1d, 0xfd, 0x8a,\n+\t\t\t0xeb, 0xef, 0xbf, 0xfa, 0xa6, 0xe7, 0x53, 0x98,\n+\t\t\t0x60, 0x4e, 0x0e, 0x60, 0x7d, 0xea, 0x40, 0x8d,\n+\t\t\t0x1d, 0x8f, 0xa3, 0xc6, 0x83, 0xbc, 0xef, 0xb7,\n+\t\t\t0x9a, 0x4a, 0xe7, 0x99, 0xee, 0x0b, 0xc7, 0x46,\n+\t\t\t0x75, 0x45, 0x66, 0xe8, 0x5f, 0x4b, 0x08, 0xa4,\n+\t\t\t0xc1, 0x36, 0xd0, 0x36, 0x2c, 0xf2, 0x9a, 0x44,\n+\t\t\t0x1e, 0x5f, 0x22, 0xf4, 0xbe, 0x66, 0x66, 0x17,\n+\t\t\t0xd8, 0xb6, 0x0a, 0x89, 0xed, 0x22, 0x80, 0xdb,\n+\t\t\t0xad, 0x05, 0xd1, 0xb5, 0x93, 0xa1, 0x1c, 0x14,\n+\t\t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n+\t\t\t0x00, 0x24, 0x62, 0x6f, 0x3d, 0x30, 0x56, 0x97,\n+\t\t\t0xde, 0x03, 0x67, 0xa9, 0x63, 0x21, 0xb6, 0xe6,\n+\t\t\t0x05, 0x69, 0x94, 0xfb, 0x50, 0xc1, 0x99, 0xdd,\n+\t\t\t0xf6, 0xe8, 0x60, 0xbd, 0xe6, 0xba, 0xe3, 0x50,\n+\t\t\t0x0a, 0xcd, 0xde, 0x14, 0x16, 0xc4,\n+\t\t},\n+\t\t{\n+\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t\t0x01, 0x00, 0x24, 0xf0, 0x21, 0xf6, 0x84, 0x6a,\n+\t\t\t0xe3, 0x6b, 0x8a, 0xc5, 0x46, 0x50, 0xca, 0x40,\n+\t\t\t0xea, 0x4e, 0x82, 0xc1, 0x70, 0x25, 0xd8, 0x7d,\n+\t\t\t0x60, 0xf5, 0x51, 0x7f, 0x64, 0x03, 0x9f, 0x53,\n+\t\t\t0xec, 0xfb, 0x57, 0xa9, 0xfc, 0x26, 0x15, 0x17,\n+\t\t\t0x03, 0x01, 0x00, 0x21, 0xa6, 0xc6, 0x94, 0x2b,\n+\t\t\t0xa9, 0xcb, 0x93, 0xff, 0xb6, 0xa6, 0xe7, 0xc5,\n+\t\t\t0x37, 0x86, 0x15, 0x37, 0x57, 0xce, 0xef, 0x54,\n+\t\t\t0x96, 0x5d, 0x50, 0xa0, 0x50, 0x69, 0x5e, 0x82,\n+\t\t\t0x61, 0x8d, 0x42, 0xfb, 0x78, 0x15, 0x03, 0x01,\n+\t\t\t0x00, 0x16, 0x45, 0xd1, 0x86, 0x68, 0x59, 0xc1,\n+\t\t\t0xaf, 0xac, 0x5c, 0x46, 0x8a, 0x68, 0x69, 0x0c,\n+\t\t\t0xd7, 0x67, 0xbf, 0xf0, 0x3e, 0xee, 0x45, 0x55,\n+\t\t},\n+\t}},\n \t// Server asks for cert with empty CA list, client gives one\n \t// go test -run \"TestRunServer\" -serve -clientauth 1\n-\t// gnutls-cli --insecure --debug 100 -p 10443 localhost\n-\t{\"RequestClientCert, client gives it\", RequestClientCert,\n-\t\t[]*x509.Certificate{clientCertificate},\n-\t\t[][]byte{{\n-\t\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n-\t\t\t0x76, 0x03, 0x02, 0x4e, 0xe7, 0x44, 0xda, 0x58,\n-\t\t\t0x7d, 0x46, 0x4a, 0x48, 0x97, 0x9f, 0xe5, 0x91,\n-\t\t\t0x11, 0x64, 0xa7, 0x1e, 0x4d, 0xb7, 0xfe, 0x9b,\n-\t\t\t0xc6, 0x63, 0xf8, 0xa4, 0xb5, 0x0b, 0x18, 0xb5,\n-\t\t\t0xbd, 0x19, 0xb3, 0x00, 0x00, 0x34, 0x00, 0x33,\n-\t\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n-\t\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n-\t\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n-\t\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n-\t\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n-\t\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n-\t\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n-\t\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n-\t\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n-\t\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t{\"RequestClientCert, client gives it\", RequestClientCert, []*x509.Certificate{clientCertificate}, [][]byte{\n+\t\t{\n+\t\t\t0x16, 0x03, 0x01, 0x00, 0x54, 0x01, 0x00, 0x00,\n+\t\t\t0x50, 0x03, 0x01, 0x50, 0x77, 0x43, 0x47, 0xfd,\n+\t\t\t0x1d, 0xb0, 0x60, 0x4c, 0x25, 0x86, 0x45, 0x4a,\n+\t\t\t0xe5, 0x3f, 0x80, 0x56, 0x18, 0x91, 0x5c, 0xe2,\n+\t\t\t0x62, 0xc5, 0x77, 0xc2, 0x92, 0xdd, 0xdc, 0x39,\n+\t\t\t0x23, 0x1d, 0xc5, 0x00, 0x00, 0x28, 0x00, 0x39,\n+\t\t\t0x00, 0x38, 0x00, 0x35, 0x00, 0x16, 0x00, 0x13,\n+\t\t\t0x00, 0x0a, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2f,\n+\t\t\t0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,\n+\t\t\t0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,\n+\t\t\t0x00, 0x06, 0x00, 0x03, 0x00, 0xff, 0x02, 0x01,\n+\t\t\t0x00,\n \t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n-\t\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n-\t\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n-\t\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n-\t\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n-\t\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n-\t\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n-\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n-\t\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n-\t\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n-\t\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n-\t\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n-\t\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n-\t\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n-\t\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n-\t\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n-\t\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n-\t\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n-\t\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n-\t\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n-\t\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n-\t\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n-\t\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n-\t\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n-\t\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n-\t\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n-\t\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n-\t\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n-\t\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n-\t\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n-\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n-\t\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n-\t\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n-\t\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n-\t\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n-\t\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n-\t\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n-\t\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n-\t\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n-\t\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n-\t\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n-\t\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n-\t\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n-\t\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n-\t\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n-\t\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n-\t\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n-\t\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n-\t\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n-\t\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n-\t\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n-\t\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n-\t\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n-\t\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n-\t\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n-\t\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n-\t\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n-\t\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n-\t\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n-\t\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n-\t\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n-\t\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n-\t\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n-\t\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n-\t\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n-\t\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n-\t\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n-\t\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n-\t\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n-\t\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n-\t\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n-\t\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n-\t\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n-\t\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n-\t\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n-\t\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n-\t\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n-\t\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n-\t\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n-\t\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n-\t\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n-\t\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n-\t\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n-\t\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n-\t\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n-\t\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n-\t\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n-\t\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n-\t\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x08, 0x0d,\n-\t\t\t\t0x00, 0x00, 0x04, 0x01, 0x01, 0x00, 0x00, 0x16,\n-\t\t\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n-\t\t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x16, 0x03, 0x01, 0x01, 0xfb, 0x0b, 0x00, 0x01,\n-\t\t\t\t0xf7, 0x00, 0x01, 0xf4, 0x00, 0x01, 0xf1, 0x30,\n-\t\t\t\t0x82, 0x01, 0xed, 0x30, 0x82, 0x01, 0x58, 0xa0,\n-\t\t\t\t0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00, 0x30,\n-\t\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x30, 0x26, 0x31, 0x10,\n-\t\t\t\t0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n-\t\t\t\t0x07, 0x41, 0x63, 0x6d, 0x65, 0x20, 0x43, 0x6f,\n-\t\t\t\t0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04,\n-\t\t\t\t0x03, 0x13, 0x09, 0x31, 0x32, 0x37, 0x2e, 0x30,\n-\t\t\t\t0x2e, 0x30, 0x2e, 0x31, 0x30, 0x1e, 0x17, 0x0d,\n-\t\t\t\t0x31, 0x31, 0x31, 0x32, 0x30, 0x38, 0x30, 0x37,\n-\t\t\t\t0x35, 0x35, 0x31, 0x32, 0x5a, 0x17, 0x0d, 0x31,\n-\t\t\t\t0x32, 0x31, 0x32, 0x30, 0x37, 0x30, 0x38, 0x30,\n-\t\t\t\t0x30, 0x31, 0x32, 0x5a, 0x30, 0x26, 0x31, 0x10,\n-\t\t\t\t0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n-\t\t\t\t0x07, 0x41, 0x63, 0x6d, 0x65, 0x20, 0x43, 0x6f,\n-\t\t\t\t0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04,\n-\t\t\t\t0x03, 0x13, 0x09, 0x31, 0x32, 0x37, 0x2e, 0x30,\n-\t\t\t\t0x2e, 0x30, 0x2e, 0x31, 0x30, 0x81, 0x9c, 0x30,\n-\t\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t\t\t0x0d, 0x01, 0x01, 0x01, 0x03, 0x81, 0x8c, 0x00,\n-\t\t\t\t0x30, 0x81, 0x88, 0x02, 0x81, 0x80, 0x4e, 0xd0,\n-\t\t\t\t0x7b, 0x31, 0xe3, 0x82, 0x64, 0xd9, 0x59, 0xc0,\n-\t\t\t\t0xc2, 0x87, 0xa4, 0x5e, 0x1e, 0x8b, 0x73, 0x33,\n-\t\t\t\t0xc7, 0x63, 0x53, 0xdf, 0x66, 0x92, 0x06, 0x84,\n-\t\t\t\t0xf6, 0x64, 0xd5, 0x8f, 0xe4, 0x36, 0xa7, 0x1d,\n-\t\t\t\t0x2b, 0xe8, 0xb3, 0x20, 0x36, 0x45, 0x23, 0xb5,\n-\t\t\t\t0xe3, 0x95, 0xae, 0xed, 0xe0, 0xf5, 0x20, 0x9c,\n-\t\t\t\t0x8d, 0x95, 0xdf, 0x7f, 0x5a, 0x12, 0xef, 0x87,\n-\t\t\t\t0xe4, 0x5b, 0x68, 0xe4, 0xe9, 0x0e, 0x74, 0xec,\n-\t\t\t\t0x04, 0x8a, 0x7f, 0xde, 0x93, 0x27, 0xc4, 0x01,\n-\t\t\t\t0x19, 0x7a, 0xbd, 0xf2, 0xdc, 0x3d, 0x14, 0xab,\n-\t\t\t\t0xd0, 0x54, 0xca, 0x21, 0x0c, 0xd0, 0x4d, 0x6e,\n-\t\t\t\t0x87, 0x2e, 0x5c, 0xc5, 0xd2, 0xbb, 0x4d, 0x4b,\n-\t\t\t\t0x4f, 0xce, 0xb6, 0x2c, 0xf7, 0x7e, 0x88, 0xec,\n-\t\t\t\t0x7c, 0xd7, 0x02, 0x91, 0x74, 0xa6, 0x1e, 0x0c,\n-\t\t\t\t0x1a, 0xda, 0xe3, 0x4a, 0x5a, 0x2e, 0xde, 0x13,\n-\t\t\t\t0x9c, 0x4c, 0x40, 0x88, 0x59, 0x93, 0x02, 0x03,\n-\t\t\t\t0x01, 0x00, 0x01, 0xa3, 0x32, 0x30, 0x30, 0x30,\n-\t\t\t\t0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01,\n-\t\t\t\t0xff, 0x04, 0x04, 0x03, 0x02, 0x00, 0xa0, 0x30,\n-\t\t\t\t0x0d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x06,\n-\t\t\t\t0x04, 0x04, 0x01, 0x02, 0x03, 0x04, 0x30, 0x0f,\n-\t\t\t\t0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x08, 0x30,\n-\t\t\t\t0x06, 0x80, 0x04, 0x01, 0x02, 0x03, 0x04, 0x30,\n-\t\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n-\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x03, 0x81, 0x81, 0x00,\n-\t\t\t\t0x36, 0x1f, 0xb3, 0x7a, 0x0c, 0x75, 0xc9, 0x6e,\n-\t\t\t\t0x37, 0x46, 0x61, 0x2b, 0xd5, 0xbd, 0xc0, 0xa7,\n-\t\t\t\t0x4b, 0xcc, 0x46, 0x9a, 0x81, 0x58, 0x7c, 0x85,\n-\t\t\t\t0x79, 0x29, 0xc8, 0xc8, 0xc6, 0x67, 0xdd, 0x32,\n-\t\t\t\t0x56, 0x45, 0x2b, 0x75, 0xb6, 0xe9, 0x24, 0xa9,\n-\t\t\t\t0x50, 0x9a, 0xbe, 0x1f, 0x5a, 0xfa, 0x1a, 0x15,\n-\t\t\t\t0xd9, 0xcc, 0x55, 0x95, 0x72, 0x16, 0x83, 0xb9,\n-\t\t\t\t0xc2, 0xb6, 0x8f, 0xfd, 0x88, 0x8c, 0x38, 0x84,\n-\t\t\t\t0x1d, 0xab, 0x5d, 0x92, 0x31, 0x13, 0x4f, 0xfd,\n-\t\t\t\t0x83, 0x3b, 0xc6, 0x9d, 0xf1, 0x11, 0x62, 0xb6,\n-\t\t\t\t0x8b, 0xec, 0xab, 0x67, 0xbe, 0xc8, 0x64, 0xb0,\n-\t\t\t\t0x11, 0x50, 0x46, 0x58, 0x17, 0x6b, 0x99, 0x1c,\n-\t\t\t\t0xd3, 0x1d, 0xfc, 0x06, 0xf1, 0x0e, 0xe5, 0x96,\n-\t\t\t\t0xa8, 0x0c, 0xf9, 0x78, 0x20, 0xb7, 0x44, 0x18,\n-\t\t\t\t0x51, 0x8d, 0x10, 0x7e, 0x4f, 0x94, 0x67, 0xdf,\n-\t\t\t\t0xa3, 0x4e, 0x70, 0x73, 0x8e, 0x90, 0x91, 0x85,\n-\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t\t\t0x82, 0x00, 0x80, 0xa7, 0x2f, 0xed, 0xfa, 0xc2,\n-\t\t\t\t0xbd, 0x46, 0xa1, 0xf2, 0x69, 0xc5, 0x1d, 0xa1,\n-\t\t\t\t0x34, 0xd6, 0xd0, 0x84, 0xf5, 0x5d, 0x8c, 0x82,\n-\t\t\t\t0x8d, 0x98, 0x82, 0x9c, 0xd9, 0x07, 0xe0, 0xf7,\n-\t\t\t\t0x55, 0x49, 0x4d, 0xa1, 0x48, 0x59, 0x02, 0xd3,\n-\t\t\t\t0x84, 0x37, 0xaf, 0x01, 0xb3, 0x3a, 0xf4, 0xed,\n-\t\t\t\t0x99, 0xbe, 0x67, 0x36, 0x19, 0x55, 0xf3, 0xf9,\n-\t\t\t\t0xcb, 0x94, 0xe5, 0x7b, 0x8b, 0x77, 0xf2, 0x5f,\n-\t\t\t\t0x4c, 0xfe, 0x01, 0x1f, 0x7b, 0xd7, 0x23, 0x49,\n-\t\t\t\t0x0c, 0xcb, 0x6c, 0xb0, 0xe7, 0x77, 0xd6, 0xcf,\n-\t\t\t\t0xa8, 0x7d, 0xdb, 0xa7, 0x14, 0xe2, 0xf5, 0xf3,\n-\t\t\t\t0xff, 0xba, 0x23, 0xd2, 0x9a, 0x36, 0x14, 0x60,\n-\t\t\t\t0x2a, 0x91, 0x5d, 0x2b, 0x35, 0x3b, 0xb6, 0xdd,\n-\t\t\t\t0xcb, 0x6b, 0xdc, 0x18, 0xdc, 0x33, 0xb8, 0xb3,\n-\t\t\t\t0xc7, 0x27, 0x7e, 0xfc, 0xd2, 0xf7, 0x97, 0x90,\n-\t\t\t\t0x5e, 0x17, 0xac, 0x14, 0x8e, 0x0f, 0xca, 0xb5,\n-\t\t\t\t0x6f, 0xc9, 0x2d, 0x16, 0x03, 0x01, 0x00, 0x86,\n-\t\t\t\t0x0f, 0x00, 0x00, 0x82, 0x00, 0x80, 0x44, 0x7f,\n-\t\t\t\t0xa2, 0x59, 0x60, 0x0b, 0x5a, 0xc4, 0xaf, 0x1e,\n-\t\t\t\t0x60, 0xa5, 0x24, 0xea, 0xc1, 0xc3, 0x22, 0x21,\n-\t\t\t\t0x6b, 0x22, 0x8b, 0x2a, 0x11, 0x82, 0x68, 0x7d,\n-\t\t\t\t0xb9, 0xdd, 0x9c, 0x27, 0x4c, 0xc2, 0xc8, 0xa2,\n-\t\t\t\t0x8b, 0x6b, 0x77, 0x8d, 0x3a, 0x2b, 0x8d, 0x2f,\n-\t\t\t\t0x6a, 0x2b, 0x43, 0xd2, 0xd1, 0xc6, 0x41, 0x79,\n-\t\t\t\t0xa2, 0x4f, 0x2b, 0xc2, 0xf7, 0xb2, 0x10, 0xad,\n-\t\t\t\t0xa6, 0x01, 0x51, 0x51, 0x25, 0xe7, 0x58, 0x7a,\n-\t\t\t\t0xcf, 0x3b, 0xc4, 0x29, 0xb5, 0xe5, 0xa7, 0x83,\n-\t\t\t\t0xe6, 0xcb, 0x1e, 0xf3, 0x02, 0x0f, 0x53, 0x3b,\n-\t\t\t\t0xb5, 0x39, 0xef, 0x9c, 0x42, 0xe0, 0xa6, 0x9b,\n-\t\t\t\t0x2b, 0xdd, 0x60, 0xae, 0x0a, 0x73, 0x35, 0xbe,\n-\t\t\t\t0x26, 0x10, 0x1b, 0xe9, 0xe9, 0x61, 0xab, 0x20,\n-\t\t\t\t0xa5, 0x48, 0xc6, 0x60, 0xa6, 0x50, 0x3c, 0xfb,\n-\t\t\t\t0xa7, 0xca, 0xb0, 0x80, 0x95, 0x1e, 0xce, 0xc7,\n-\t\t\t\t0xbb, 0x68, 0x44, 0xdc, 0x0e, 0x0e, 0x14, 0x03,\n-\t\t\t\t0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01, 0x00,\n-\t\t\t\t0x24, 0xb6, 0xcd, 0x0c, 0x78, 0xfd, 0xd6, 0xff,\n-\t\t\t\t0xbe, 0x97, 0xd5, 0x0a, 0x7d, 0x4f, 0xa1, 0x03,\n-\t\t\t\t0x78, 0xc8, 0x61, 0x6f, 0xf2, 0x4b, 0xa8, 0x56,\n-\t\t\t\t0x4f, 0x3c, 0xa2, 0xd9, 0xd0, 0x20, 0x13, 0x1b,\n-\t\t\t\t0x8b, 0x36, 0xb7, 0x33, 0x9c,\n-\t\t\t},\n-\n-\t\t\t{\n-\t\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t\t\t0x01, 0x00, 0x24, 0xa3, 0x43, 0x94, 0xe7, 0xdf,\n-\t\t\t\t0xb6, 0xc3, 0x03, 0x9f, 0xc1, 0x59, 0x0c, 0xc3,\n-\t\t\t\t0x13, 0xae, 0xed, 0xcf, 0xff, 0xf1, 0x80, 0xf3,\n-\t\t\t\t0x13, 0x63, 0x1c, 0xf0, 0xca, 0xad, 0x9e, 0x71,\n-\t\t\t\t0x46, 0x5f, 0x6b, 0xeb, 0x10, 0x3f, 0xe3, 0x17,\n-\t\t\t\t0x03, 0x01, 0x00, 0x21, 0xe9, 0x80, 0x95, 0x6e,\n-\t\t\t\t0x05, 0x55, 0x2f, 0xed, 0x4d, 0xde, 0x17, 0x3a,\n-\t\t\t\t0x32, 0x9b, 0x2a, 0x74, 0x30, 0x4f, 0xe0, 0x9f,\n-\t\t\t\t0x4e, 0xd3, 0x06, 0xbd, 0x3a, 0x43, 0x75, 0x8b,\n-\t\t\t\t0x5b, 0x9a, 0xd8, 0x2e, 0x56, 0x15, 0x03, 0x01,\n-\t\t\t\t0x00, 0x16, 0x53, 0xf5, 0xff, 0xe0, 0xa1, 0x6c,\n-\t\t\t\t0x33, 0xf4, 0x4e, 0x89, 0x68, 0xe1, 0xf7, 0x61,\n-\t\t\t\t0x13, 0xb3, 0x12, 0xa1, 0x8e, 0x5a, 0x7a, 0x02,\n-\t\t\t},\n+\t\t{\n+\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n+\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x08, 0x0d,\n+\t\t\t0x00, 0x00, 0x04, 0x01, 0x01, 0x00, 0x00, 0x16,\n+\t\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n \t\t},\n-\t},\n+\t\t{\n+\t\t\t0x16, 0x03, 0x01, 0x01, 0xfb, 0x0b, 0x00, 0x01,\n+\t\t\t0xf7, 0x00, 0x01, 0xf4, 0x00, 0x01, 0xf1, 0x30,\n+\t\t\t0x82, 0x01, 0xed, 0x30, 0x82, 0x01, 0x58, 0xa0,\n+\t\t\t0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00, 0x30,\n+\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t0x0d, 0x01, 0x01, 0x05, 0x30, 0x26, 0x31, 0x10,\n+\t\t\t0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n+\t\t\t0x07, 0x41, 0x63, 0x6d, 0x65, 0x20, 0x43, 0x6f,\n+\t\t\t0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t0x03, 0x13, 0x09, 0x31, 0x32, 0x37, 0x2e, 0x30,\n+\t\t\t0x2e, 0x30, 0x2e, 0x31, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t\t0x31, 0x31, 0x31, 0x32, 0x30, 0x38, 0x30, 0x37,\n+\t\t\t0x35, 0x35, 0x31, 0x32, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t\t0x32, 0x31, 0x32, 0x30, 0x37, 0x30, 0x38, 0x30,\n+\t\t\t0x30, 0x31, 0x32, 0x5a, 0x30, 0x26, 0x31, 0x10,\n+\t\t\t0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n+\t\t\t0x07, 0x41, 0x63, 0x6d, 0x65, 0x20, 0x43, 0x6f,\n+\t\t\t0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t0x03, 0x13, 0x09, 0x31, 0x32, 0x37, 0x2e, 0x30,\n+\t\t\t0x2e, 0x30, 0x2e, 0x31, 0x30, 0x81, 0x9c, 0x30,\n+\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t0x0d, 0x01, 0x01, 0x01, 0x03, 0x81, 0x8c, 0x00,\n+\t\t\t0x30, 0x81, 0x88, 0x02, 0x81, 0x80, 0x4e, 0xd0,\n+\t\t\t0x7b, 0x31, 0xe3, 0x82, 0x64, 0xd9, 0x59, 0xc0,\n+\t\t\t0xc2, 0x87, 0xa4, 0x5e, 0x1e, 0x8b, 0x73, 0x33,\n+\t\t\t0xc7, 0x63, 0x53, 0xdf, 0x66, 0x92, 0x06, 0x84,\n+\t\t\t0xf6, 0x64, 0xd5, 0x8f, 0xe4, 0x36, 0xa7, 0x1d,\n+\t\t\t0x2b, 0xe8, 0xb3, 0x20, 0x36, 0x45, 0x23, 0xb5,\n+\t\t\t0xe3, 0x95, 0xae, 0xed, 0xe0, 0xf5, 0x20, 0x9c,\n+\t\t\t0x8d, 0x95, 0xdf, 0x7f, 0x5a, 0x12, 0xef, 0x87,\n+\t\t\t0xe4, 0x5b, 0x68, 0xe4, 0xe9, 0x0e, 0x74, 0xec,\n+\t\t\t0x04, 0x8a, 0x7f, 0xde, 0x93, 0x27, 0xc4, 0x01,\n+\t\t\t0x19, 0x7a, 0xbd, 0xf2, 0xdc, 0x3d, 0x14, 0xab,\n+\t\t\t0xd0, 0x54, 0xca, 0x21, 0x0c, 0xd0, 0x4d, 0x6e,\n+\t\t\t0x87, 0x2e, 0x5c, 0xc5, 0xd2, 0xbb, 0x4d, 0x4b,\n+\t\t\t0x4f, 0xce, 0xb6, 0x2c, 0xf7, 0x7e, 0x88, 0xec,\n+\t\t\t0x7c, 0xd7, 0x02, 0x91, 0x74, 0xa6, 0x1e, 0x0c,\n+\t\t\t0x1a, 0xda, 0xe3, 0x4a, 0x5a, 0x2e, 0xde, 0x13,\n+\t\t\t0x9c, 0x4c, 0x40, 0x88, 0x59, 0x93, 0x02, 0x03,\n+\t\t\t0x01, 0x00, 0x01, 0xa3, 0x32, 0x30, 0x30, 0x30,\n+\t\t\t0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01,\n+\t\t\t0xff, 0x04, 0x04, 0x03, 0x02, 0x00, 0xa0, 0x30,\n+\t\t\t0x0d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x06,\n+\t\t\t0x04, 0x04, 0x01, 0x02, 0x03, 0x04, 0x30, 0x0f,\n+\t\t\t0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x08, 0x30,\n+\t\t\t0x06, 0x80, 0x04, 0x01, 0x02, 0x03, 0x04, 0x30,\n+\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t0x0d, 0x01, 0x01, 0x05, 0x03, 0x81, 0x81, 0x00,\n+\t\t\t0x36, 0x1f, 0xb3, 0x7a, 0x0c, 0x75, 0xc9, 0x6e,\n+\t\t\t0x37, 0x46, 0x61, 0x2b, 0xd5, 0xbd, 0xc0, 0xa7,\n+\t\t\t0x4b, 0xcc, 0x46, 0x9a, 0x81, 0x58, 0x7c, 0x85,\n+\t\t\t0x79, 0x29, 0xc8, 0xc8, 0xc6, 0x67, 0xdd, 0x32,\n+\t\t\t0x56, 0x45, 0x2b, 0x75, 0xb6, 0xe9, 0x24, 0xa9,\n+\t\t\t0x50, 0x9a, 0xbe, 0x1f, 0x5a, 0xfa, 0x1a, 0x15,\n+\t\t\t0xd9, 0xcc, 0x55, 0x95, 0x72, 0x16, 0x83, 0xb9,\n+\t\t\t0xc2, 0xb6, 0x8f, 0xfd, 0x88, 0x8c, 0x38, 0x84,\n+\t\t\t0x1d, 0xab, 0x5d, 0x92, 0x31, 0x13, 0x4f, 0xfd,\n+\t\t\t0x83, 0x3b, 0xc6, 0x9d, 0xf1, 0x11, 0x62, 0xb6,\n+\t\t\t0x8b, 0xec, 0xab, 0x67, 0xbe, 0xc8, 0x64, 0xb0,\n+\t\t\t0x11, 0x50, 0x46, 0x58, 0x17, 0x6b, 0x99, 0x1c,\n+\t\t\t0xd3, 0x1d, 0xfc, 0x06, 0xf1, 0x0e, 0xe5, 0x96,\n+\t\t\t0xa8, 0x0c, 0xf9, 0x78, 0x20, 0xb7, 0x44, 0x18,\n+\t\t\t0x51, 0x8d, 0x10, 0x7e, 0x4f, 0x94, 0x67, 0xdf,\n+\t\t\t0xa3, 0x4e, 0x70, 0x73, 0x8e, 0x90, 0x91, 0x85,\n+\t\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n+\t\t\t0x82, 0x00, 0x80, 0x81, 0x46, 0x43, 0xf9, 0xe7,\n+\t\t\t0xda, 0x8c, 0x92, 0x3a, 0x78, 0x1a, 0x86, 0xb3,\n+\t\t\t0xbe, 0x83, 0x22, 0xb6, 0xaa, 0x57, 0x37, 0x68,\n+\t\t\t0x9e, 0x54, 0x3f, 0xd3, 0xce, 0x4d, 0x5e, 0x2a,\n+\t\t\t0xdc, 0xb0, 0x49, 0x02, 0xbb, 0xc0, 0x45, 0x58,\n+\t\t\t0x79, 0x10, 0xc7, 0x94, 0x60, 0x9f, 0x1b, 0x5f,\n+\t\t\t0x18, 0x31, 0x37, 0x9c, 0xe0, 0xe6, 0xdf, 0x5e,\n+\t\t\t0x70, 0x44, 0xf6, 0x8b, 0xdf, 0xf1, 0xf6, 0x43,\n+\t\t\t0xc8, 0x2f, 0xd1, 0xce, 0xd0, 0xd6, 0x64, 0x4f,\n+\t\t\t0xe8, 0x2b, 0xfa, 0xd3, 0xd0, 0xd1, 0x2e, 0xaa,\n+\t\t\t0x9b, 0x1d, 0x13, 0x5c, 0xbe, 0x57, 0x41, 0x6c,\n+\t\t\t0x5e, 0x8d, 0xea, 0xa9, 0x3c, 0x58, 0xa0, 0x30,\n+\t\t\t0x92, 0x77, 0x7a, 0xed, 0x64, 0x58, 0xe5, 0x7f,\n+\t\t\t0x6a, 0x93, 0x89, 0x66, 0x3d, 0x13, 0x16, 0x56,\n+\t\t\t0xa0, 0xad, 0xdc, 0x68, 0x95, 0x87, 0x81, 0xd0,\n+\t\t\t0x90, 0x4d, 0x5f, 0xfe, 0x3e, 0x83, 0x15, 0x2e,\n+\t\t\t0x50, 0x3c, 0xdd, 0x16, 0x03, 0x01, 0x00, 0x86,\n+\t\t\t0x0f, 0x00, 0x00, 0x82, 0x00, 0x80, 0x2b, 0xf8,\n+\t\t\t0x56, 0x48, 0xbb, 0x02, 0x37, 0x15, 0x02, 0x74,\n+\t\t\t0x33, 0x53, 0x65, 0xa7, 0x7c, 0x2f, 0xc6, 0x5d,\n+\t\t\t0x80, 0x59, 0xc1, 0xc2, 0x3b, 0xa9, 0xde, 0x4e,\n+\t\t\t0x70, 0x51, 0xd2, 0xde, 0x58, 0x7f, 0xd8, 0xb9,\n+\t\t\t0xb6, 0x3b, 0xc8, 0xaa, 0xfc, 0x3d, 0x53, 0x2d,\n+\t\t\t0x61, 0x4d, 0xf5, 0x60, 0x12, 0xc2, 0xa5, 0x39,\n+\t\t\t0x0c, 0xa7, 0xc6, 0xac, 0x26, 0x4b, 0xf4, 0x5f,\n+\t\t\t0xe9, 0xf4, 0xf2, 0x73, 0x48, 0xe4, 0x3b, 0xee,\n+\t\t\t0xf2, 0xee, 0xc0, 0xee, 0xfb, 0x5b, 0x60, 0xc2,\n+\t\t\t0x74, 0xe6, 0xf6, 0x43, 0x3e, 0xa4, 0xf7, 0x97,\n+\t\t\t0x3d, 0xfc, 0xe9, 0x44, 0x21, 0x18, 0x46, 0x05,\n+\t\t\t0x33, 0xf8, 0xfe, 0x35, 0x5b, 0xe6, 0x8f, 0xef,\n+\t\t\t0x4d, 0x4c, 0x87, 0xf6, 0xb4, 0x6e, 0x6b, 0x39,\n+\t\t\t0xd8, 0xaa, 0x1b, 0x33, 0xc9, 0x1c, 0x66, 0x48,\n+\t\t\t0xbe, 0xfa, 0xb5, 0x92, 0x09, 0xfd, 0xb9, 0xb9,\n+\t\t\t0xca, 0xe6, 0x6d, 0x71, 0xc6, 0x89, 0x14, 0x03,\n+\t\t\t0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01, 0x00,\n+\t\t\t0x24, 0xe3, 0x2b, 0xef, 0x17, 0xd5, 0xa6, 0x4c,\n+\t\t\t0x2e, 0x10, 0xac, 0x9c, 0xfe, 0x0f, 0x18, 0x43,\n+\t\t\t0x95, 0x00, 0x81, 0xf7, 0x7c, 0x00, 0x5b, 0x89,\n+\t\t\t0x52, 0x41, 0xe4, 0x8a, 0x8a, 0x34, 0x31, 0x09,\n+\t\t\t0x48, 0x7c, 0xc5, 0xc3, 0x83,\n+\t\t},\n+\t\t{\n+\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t\t0x01, 0x00, 0x24, 0x24, 0xaa, 0xaa, 0x56, 0x8b,\n+\t\t\t0x41, 0x87, 0x01, 0xbe, 0x80, 0x05, 0x51, 0x36,\n+\t\t\t0x08, 0xfc, 0xaf, 0xff, 0x7f, 0xf4, 0x74, 0x84,\n+\t\t\t0x88, 0xdc, 0xb8, 0x8e, 0x70, 0x6c, 0x22, 0x04,\n+\t\t\t0xee, 0x45, 0x8d, 0xda, 0xed, 0xc6, 0x05, 0x17,\n+\t\t\t0x03, 0x01, 0x00, 0x21, 0x91, 0x49, 0x4b, 0xed,\n+\t\t\t0xa3, 0x41, 0xe9, 0x88, 0x3b, 0xa3, 0x01, 0xee,\n+\t\t\t0x77, 0x4e, 0x12, 0xb4, 0xcd, 0x5e, 0xcc, 0x45,\n+\t\t\t0x02, 0x5a, 0x20, 0xd6, 0xe8, 0xac, 0xcb, 0x60,\n+\t\t\t0xcb, 0x1b, 0xef, 0xf9, 0xc2, 0x15, 0x03, 0x01,\n+\t\t\t0x00, 0x16, 0xd4, 0xcd, 0x92, 0x3c, 0x10, 0x93,\n+\t\t\t0x68, 0xc3, 0xdd, 0xaf, 0xe9, 0xcb, 0x5d, 0x94,\n+\t\t\t0x1a, 0x06, 0x81, 0xa7, 0x78, 0x0f, 0xc3, 0x03,\n+\t\t},\n+\t}},\n }\n \n // cert.pem and key.pem were generated with generate_cert.go\n@@ -2088,7 +1824,7 @@ GFGNEH5PlGffo05wc46QkYU=\n \n /* corresponding key.pem for cert.pem is:\n -----BEGIN RSA PRIVATE KEY-----\n-MIICXAIBAAKBgE7QezHjgmTZWcDCh6ReHotzM8djU99mkgaE9mTVj+Q2px0r6LMg\n+MIICWgIBAAKBgE7QezHjgmTZWcDCh6ReHotzM8djU99mkgaE9mTVj+Q2px0r6LMg\n NkUjteOVru3g9SCcjZXff1oS74fkW2jk6Q507ASKf96TJ8QBGXq98tw9FKvQVMoh\n DNBNbocuXMXSu01LT862LPd+iOx81wKRdKYeDBra40paLt4TnExAiFmTAgMBAAEC\n gYBxvXd8yNteFTns8A/2yomEMC4yeosJJSpp1CsN3BJ7g8/qTnrVPxBy+RU+qr63\n@@ -2100,6 +1836,6 @@ RkKVpenBHyrGg0oeN5La7URILWKj7CPXAkBKo6F+d+phNjwIFoN1Xb/RA32w/D1I\n saG9sF+UEhRt9AxUfW/U/tIQ9V0ZHHcSg1XaCM5Nvp934brdKdvTOKnJAkBD5h/3\n Rybatlvg/fzBEaJFyq09zhngkxlZOUtBVTqzl17RVvY2orgH02U4HbCHy4phxOn7\n qTdQRYlHRftgnWK1AkANibn9PRYJ7mJyJ9Dyj2QeNcSkSTzrt0tPvUMf4+meJymN\n-1Ntu5+S1DLLzfxlaljWG6ylW6DNxujCyuXIV2rvAMAA=\n+1Ntu5+S1DLLzfxlaljWG6ylW6DNxujCyuXIV2rvA\n -----END RSA PRIVATE KEY-----\n */"}, {"sha": "773a2b2ffc82b8a944fab84053230a02e042ad98", "filename": "libgo/go/crypto/tls/prf_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -51,7 +51,7 @@ func TestKeysFromPreMasterSecret(t *testing.T) {\n \n \t\tmasterSecret := masterFromPreMasterSecret(test.version, in, clientRandom, serverRandom)\n \t\tif s := hex.EncodeToString(masterSecret); s != test.masterSecret {\n-\t\t\tt.Errorf(\"#%d: bad master secret %s, want %s\", s, test.masterSecret)\n+\t\t\tt.Errorf(\"#%d: bad master secret %s, want %s\", i, s, test.masterSecret)\n \t\t\tcontinue\n \t\t}\n "}, {"sha": "182506c59efd077d866fc62d24b6aeea61c3e475", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -6,6 +6,8 @@\n package tls\n \n import (\n+\t\"crypto\"\n+\t\"crypto/ecdsa\"\n \t\"crypto/rsa\"\n \t\"crypto/x509\"\n \t\"encoding/pem\"\n@@ -153,41 +155,71 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error)\n \t\t\terr = errors.New(\"crypto/tls: failed to parse key PEM data\")\n \t\t\treturn\n \t\t}\n-\t\tif keyDERBlock.Type != \"CERTIFICATE\" {\n+\t\tif strings.HasSuffix(keyDERBlock.Type, \" PRIVATE KEY\") {\n \t\t\tbreak\n \t\t}\n \t}\n \n-\t// OpenSSL 0.9.8 generates PKCS#1 private keys by default, while\n-\t// OpenSSL 1.0.0 generates PKCS#8 keys. We try both.\n-\tvar key *rsa.PrivateKey\n-\tif key, err = x509.ParsePKCS1PrivateKey(keyDERBlock.Bytes); err != nil {\n-\t\tvar privKey interface{}\n-\t\tif privKey, err = x509.ParsePKCS8PrivateKey(keyDERBlock.Bytes); err != nil {\n-\t\t\terr = errors.New(\"crypto/tls: failed to parse key: \" + err.Error())\n-\t\t\treturn\n-\t\t}\n-\n-\t\tvar ok bool\n-\t\tif key, ok = privKey.(*rsa.PrivateKey); !ok {\n-\t\t\terr = errors.New(\"crypto/tls: found non-RSA private key in PKCS#8 wrapping\")\n-\t\t\treturn\n-\t\t}\n+\tcert.PrivateKey, err = parsePrivateKey(keyDERBlock.Bytes)\n+\tif err != nil {\n+\t\treturn\n \t}\n \n-\tcert.PrivateKey = key\n-\n \t// We don't need to parse the public key for TLS, but we so do anyway\n \t// to check that it looks sane and matches the private key.\n \tx509Cert, err := x509.ParseCertificate(cert.Certificate[0])\n \tif err != nil {\n \t\treturn\n \t}\n \n-\tif x509Cert.PublicKeyAlgorithm != x509.RSA || x509Cert.PublicKey.(*rsa.PublicKey).N.Cmp(key.PublicKey.N) != 0 {\n-\t\terr = errors.New(\"crypto/tls: private key does not match public key\")\n+\tswitch pub := x509Cert.PublicKey.(type) {\n+\tcase *rsa.PublicKey:\n+\t\tpriv, ok := cert.PrivateKey.(*rsa.PrivateKey)\n+\t\tif !ok {\n+\t\t\terr = errors.New(\"crypto/tls: private key type does not match public key type\")\n+\t\t\treturn\n+\t\t}\n+\t\tif pub.N.Cmp(priv.N) != 0 {\n+\t\t\terr = errors.New(\"crypto/tls: private key does not match public key\")\n+\t\t\treturn\n+\t\t}\n+\tcase *ecdsa.PublicKey:\n+\t\tpriv, ok := cert.PrivateKey.(*ecdsa.PrivateKey)\n+\t\tif !ok {\n+\t\t\terr = errors.New(\"crypto/tls: private key type does not match public key type\")\n+\t\t\treturn\n+\n+\t\t}\n+\t\tif pub.X.Cmp(priv.X) != 0 || pub.Y.Cmp(priv.Y) != 0 {\n+\t\t\terr = errors.New(\"crypto/tls: private key does not match public key\")\n+\t\t\treturn\n+\t\t}\n+\tdefault:\n+\t\terr = errors.New(\"crypto/tls: unknown public key algorithm\")\n \t\treturn\n \t}\n \n \treturn\n }\n+\n+// Attempt to parse the given private key DER block. OpenSSL 0.9.8 generates\n+// PKCS#1 private keys by default, while OpenSSL 1.0.0 generates PKCS#8 keys.\n+// OpenSSL ecparam generates SEC1 EC private keys for ECDSA. We try all three.\n+func parsePrivateKey(der []byte) (crypto.PrivateKey, error) {\n+\tif key, err := x509.ParsePKCS1PrivateKey(der); err == nil {\n+\t\treturn key, nil\n+\t}\n+\tif key, err := x509.ParsePKCS8PrivateKey(der); err == nil {\n+\t\tswitch key := key.(type) {\n+\t\tcase *rsa.PrivateKey, *ecdsa.PrivateKey:\n+\t\t\treturn key, nil\n+\t\tdefault:\n+\t\t\treturn nil, errors.New(\"crypto/tls: found unknown private key type in PKCS#8 wrapping\")\n+\t\t}\n+\t}\n+\tif key, err := x509.ParseECPrivateKey(der); err == nil {\n+\t\treturn key, nil\n+\t}\n+\n+\treturn nil, errors.New(\"crypto/tls: failed to parse private key\")\n+}"}, {"sha": "31b858d83274d8f5ec67c90a8504ada54e3d70be", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -8,7 +8,7 @@ import (\n \t\"testing\"\n )\n \n-var certPEM = `-----BEGIN CERTIFICATE-----\n+var rsaCertPEM = `-----BEGIN CERTIFICATE-----\n MIIB0zCCAX2gAwIBAgIJAI/M7BYjwB+uMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n aWRnaXRzIFB0eSBMdGQwHhcNMTIwOTEyMjE1MjAyWhcNMTUwOTEyMjE1MjAyWjBF\n@@ -22,7 +22,7 @@ r5QuVbpQhH6u+0UgcW0jp9QwpxoPTLTWGXEWBBBurxFwiCBhkQ+V\n -----END CERTIFICATE-----\n `\n \n-var keyPEM = `-----BEGIN RSA PRIVATE KEY-----\n+var rsaKeyPEM = `-----BEGIN RSA PRIVATE KEY-----\n MIIBOwIBAAJBANLJhPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wo\n k/4xIA+ui35/MmNartNuC+BdZ1tMuVCPFZcCAwEAAQJAEJ2N+zsR0Xn8/Q6twa4G\n 6OB1M1WO+k+ztnX/1SvNeWu8D6GImtupLTYgjZcHufykj09jiHmjHx8u8ZZB/o1N\n@@ -33,15 +33,61 @@ D2lWusoe2/nEqfDVVWGWlyJ7yOmqaVm/iNUN9B2N2g==\n -----END RSA PRIVATE KEY-----\n `\n \n+var ecdsaCertPEM = `-----BEGIN CERTIFICATE-----\n+MIIB/jCCAWICCQDscdUxw16XFDAJBgcqhkjOPQQBMEUxCzAJBgNVBAYTAkFVMRMw\n+EQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBXaWRnaXRzIFB0\n+eSBMdGQwHhcNMTIxMTE0MTI0MDQ4WhcNMTUxMTE0MTI0MDQ4WjBFMQswCQYDVQQG\n+EwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lk\n+Z2l0cyBQdHkgTHRkMIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBY9+my9OoeSUR\n+lDQdV/x8LsOuLilthhiS1Tz4aGDHIPwC1mlvnf7fg5lecYpMCrLLhauAc1UJXcgl\n+01xoLuzgtAEAgv2P/jgytzRSpUYvgLBt1UA0leLYBy6mQQbrNEuqT3INapKIcUv8\n+XxYP0xMEUksLPq6Ca+CRSqTtrd/23uTnapkwCQYHKoZIzj0EAQOBigAwgYYCQXJo\n+A7Sl2nLVf+4Iu/tAX/IF4MavARKC4PPHK3zfuGfPR3oCCcsAoz3kAzOeijvd0iXb\n+H5jBImIxPL4WxQNiBTexAkF8D1EtpYuWdlVQ80/h/f4pBcGiXPqX5h2PQSQY7hP1\n++jwM1FGS4fREIOvlBYr/SzzQRtwrvrzGYxDEDbsC0ZGRnA==\n+-----END CERTIFICATE-----\n+`\n+\n+var ecdsaKeyPEM = `-----BEGIN EC PARAMETERS-----\n+BgUrgQQAIw==\n+-----END EC PARAMETERS-----\n+-----BEGIN EC PRIVATE KEY-----\n+MIHcAgEBBEIBrsoKp0oqcv6/JovJJDoDVSGWdirrkgCWxrprGlzB9o0X8fV675X0\n+NwuBenXFfeZvVcwluO7/Q9wkYoPd/t3jGImgBwYFK4EEACOhgYkDgYYABAFj36bL\n+06h5JRGUNB1X/Hwuw64uKW2GGJLVPPhoYMcg/ALWaW+d/t+DmV5xikwKssuFq4Bz\n+VQldyCXTXGgu7OC0AQCC/Y/+ODK3NFKlRi+AsG3VQDSV4tgHLqZBBus0S6pPcg1q\n+kohxS/xfFg/TEwRSSws+roJr4JFKpO2t3/be5OdqmQ==\n+-----END EC PRIVATE KEY-----\n+`\n+\n+var keyPairTests = []struct {\n+\talgo string\n+\tcert *string\n+\tkey  *string\n+}{\n+\t{\"ECDSA\", &ecdsaCertPEM, &ecdsaKeyPEM},\n+\t{\"RSA\", &rsaCertPEM, &rsaKeyPEM},\n+}\n+\n func TestX509KeyPair(t *testing.T) {\n-\t_, err := X509KeyPair([]byte(keyPEM+certPEM), []byte(keyPEM+certPEM))\n-\tif err != nil {\n-\t\tt.Errorf(\"Failed to load key followed by cert: %s\", err)\n+\tvar pem []byte\n+\tfor _, test := range keyPairTests {\n+\t\tpem = []byte(*test.cert + *test.key)\n+\t\tif _, err := X509KeyPair(pem, pem); err != nil {\n+\t\t\tt.Errorf(\"Failed to load %s cert followed by %s key: %s\", test.algo, test.algo, err)\n+\t\t}\n+\t\tpem = []byte(*test.key + *test.cert)\n+\t\tif _, err := X509KeyPair(pem, pem); err != nil {\n+\t\t\tt.Errorf(\"Failed to load %s key followed by %s cert: %s\", test.algo, test.algo, err)\n+\t\t}\n \t}\n+}\n \n-\t_, err = X509KeyPair([]byte(certPEM+keyPEM), []byte(certPEM+keyPEM))\n-\tif err != nil {\n-\t\tt.Errorf(\"Failed to load cert followed by key: %s\", err)\n-\t\tprintln(err.Error())\n+func TestX509MixedKeyPair(t *testing.T) {\n+\tif _, err := X509KeyPair([]byte(rsaCertPEM), []byte(ecdsaKeyPEM)); err == nil {\n+\t\tt.Error(\"Load of RSA certificate succeeded with ECDSA private key\")\n+\t}\n+\tif _, err := X509KeyPair([]byte(ecdsaCertPEM), []byte(rsaKeyPEM)); err == nil {\n+\t\tt.Error(\"Load of ECDSA certificate succeeded with RSA private key\")\n \t}\n }"}, {"sha": "505f4d4f7762a03b91b64412f3710928b2e8140b", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -103,7 +103,7 @@ func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool) {\n }\n \n // Subjects returns a list of the DER-encoded subjects of\n-// all of the certificates in the pool. \n+// all of the certificates in the pool.\n func (s *CertPool) Subjects() (res [][]byte) {\n \tres = make([][]byte, len(s.certs))\n \tfor i, c := range s.certs {"}, {"sha": "194c81bf688c8eb5be8ab03bb4878bf15d049f5d", "filename": "libgo/go/crypto/x509/pem_decrypt.go", "status": "modified", "additions": 128, "deletions": 28, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -16,13 +16,64 @@ import (\n \t\"encoding/hex\"\n \t\"encoding/pem\"\n \t\"errors\"\n+\t\"io\"\n \t\"strings\"\n )\n \n-// rfc1423Algos represents how to create a block cipher for a decryption mode.\n+type PEMCipher int\n+\n+// Possible values for the EncryptPEMBlock encryption algorithm.\n+const (\n+\t_ PEMCipher = iota\n+\tPEMCipherDES\n+\tPEMCipher3DES\n+\tPEMCipherAES128\n+\tPEMCipherAES192\n+\tPEMCipherAES256\n+)\n+\n+// rfc1423Algo holds a method for enciphering a PEM block.\n type rfc1423Algo struct {\n-\tcipherFunc func([]byte) (cipher.Block, error)\n+\tcipher     PEMCipher\n+\tname       string\n+\tcipherFunc func(key []byte) (cipher.Block, error)\n \tkeySize    int\n+\tblockSize  int\n+}\n+\n+// rfc1423Algos holds a slice of the possible ways to encrypt a PEM\n+// block.  The ivSize numbers were taken from the OpenSSL source.\n+var rfc1423Algos = []rfc1423Algo{{\n+\tcipher:     PEMCipherDES,\n+\tname:       \"DES-CBC\",\n+\tcipherFunc: des.NewCipher,\n+\tkeySize:    8,\n+\tblockSize:  des.BlockSize,\n+}, {\n+\tcipher:     PEMCipher3DES,\n+\tname:       \"DES-EDE3-CBC\",\n+\tcipherFunc: des.NewTripleDESCipher,\n+\tkeySize:    24,\n+\tblockSize:  des.BlockSize,\n+}, {\n+\tcipher:     PEMCipherAES128,\n+\tname:       \"AES-128-CBC\",\n+\tcipherFunc: aes.NewCipher,\n+\tkeySize:    16,\n+\tblockSize:  aes.BlockSize,\n+}, {\n+\tcipher:     PEMCipherAES192,\n+\tname:       \"AES-192-CBC\",\n+\tcipherFunc: aes.NewCipher,\n+\tkeySize:    24,\n+\tblockSize:  aes.BlockSize,\n+}, {\n+\tcipher:     PEMCipherAES256,\n+\tname:       \"AES-256-CBC\",\n+\tcipherFunc: aes.NewCipher,\n+\tkeySize:    32,\n+\tblockSize:  aes.BlockSize,\n+},\n }\n \n // deriveKey uses a key derivation function to stretch the password into a key\n@@ -41,20 +92,9 @@ func (c rfc1423Algo) deriveKey(password, salt []byte) []byte {\n \t\tdigest = hash.Sum(digest[:0])\n \t\tcopy(out[i:], digest)\n \t}\n-\n \treturn out\n }\n \n-// rfc1423Algos is a mapping of encryption algorithm to an rfc1423Algo that can\n-// create block ciphers for that mode.\n-var rfc1423Algos = map[string]rfc1423Algo{\n-\t\"DES-CBC\":      {des.NewCipher, 8},\n-\t\"DES-EDE3-CBC\": {des.NewTripleDESCipher, 24},\n-\t\"AES-128-CBC\":  {aes.NewCipher, 16},\n-\t\"AES-192-CBC\":  {aes.NewCipher, 24},\n-\t\"AES-256-CBC\":  {aes.NewCipher, 32},\n-}\n-\n // IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n func IsEncryptedPEMBlock(b *pem.Block) bool {\n \t_, ok := b.Headers[\"DEK-Info\"]\n@@ -81,17 +121,16 @@ func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error) {\n \t}\n \n \tmode, hexIV := dek[:idx], dek[idx+1:]\n+\tciph := cipherByName(mode)\n+\tif ciph == nil {\n+\t\treturn nil, errors.New(\"x509: unknown encryption mode\")\n+\t}\n \tiv, err := hex.DecodeString(hexIV)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tif len(iv) < 8 {\n-\t\treturn nil, errors.New(\"x509: not enough bytes in IV\")\n-\t}\n-\n-\tciph, ok := rfc1423Algos[mode]\n-\tif !ok {\n-\t\treturn nil, errors.New(\"x509: unknown encryption mode\")\n+\tif len(iv) != ciph.blockSize {\n+\t\treturn nil, errors.New(\"x509: incorrect IV size\")\n \t}\n \n \t// Based on the OpenSSL implementation. The salt is the first 8 bytes\n@@ -107,27 +146,88 @@ func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error) {\n \tdec.CryptBlocks(data, b.Bytes)\n \n \t// Blocks are padded using a scheme where the last n bytes of padding are all\n-\t// equal to n. It can pad from 1 to 8 bytes inclusive. See RFC 1423.\n+\t// equal to n. It can pad from 1 to blocksize bytes inclusive. See RFC 1423.\n \t// For example:\n \t//\t[x y z 2 2]\n \t//\t[x y 7 7 7 7 7 7 7]\n \t// If we detect a bad padding, we assume it is an invalid password.\n \tdlen := len(data)\n-\tif dlen == 0 {\n+\tif dlen == 0 || dlen%ciph.blockSize != 0 {\n \t\treturn nil, errors.New(\"x509: invalid padding\")\n \t}\n-\tlast := data[dlen-1]\n-\tif dlen < int(last) {\n+\tlast := int(data[dlen-1])\n+\tif dlen < last {\n \t\treturn nil, IncorrectPasswordError\n \t}\n-\tif last == 0 || last > 8 {\n+\tif last == 0 || last > ciph.blockSize {\n \t\treturn nil, IncorrectPasswordError\n \t}\n-\tfor _, val := range data[dlen-int(last):] {\n-\t\tif val != last {\n+\tfor _, val := range data[dlen-last:] {\n+\t\tif int(val) != last {\n \t\t\treturn nil, IncorrectPasswordError\n \t\t}\n \t}\n+\treturn data[:dlen-last], nil\n+}\n+\n+// EncryptPEMBlock returns a PEM block of the specified type holding the\n+// given DER-encoded data encrypted with the specified algorithm and\n+// password.\n+func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error) {\n+\tciph := cipherByKey(alg)\n+\tif ciph == nil {\n+\t\treturn nil, errors.New(\"x509: unknown encryption mode\")\n+\t}\n+\tiv := make([]byte, ciph.blockSize)\n+\tif _, err := io.ReadFull(rand, iv); err != nil {\n+\t\treturn nil, errors.New(\"x509: cannot generate IV: \" + err.Error())\n+\t}\n+\t// The salt is the first 8 bytes of the initialization vector,\n+\t// matching the key derivation in DecryptPEMBlock.\n+\tkey := ciph.deriveKey(password, iv[:8])\n+\tblock, err := ciph.cipherFunc(key)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tenc := cipher.NewCBCEncrypter(block, iv)\n+\tpad := ciph.blockSize - len(data)%ciph.blockSize\n+\tencrypted := make([]byte, len(data), len(data)+pad)\n+\t// We could save this copy by encrypting all the whole blocks in\n+\t// the data separately, but it doesn't seem worth the additional\n+\t// code.\n+\tcopy(encrypted, data)\n+\t// See RFC 1423, section 1.1\n+\tfor i := 0; i < pad; i++ {\n+\t\tencrypted = append(encrypted, byte(pad))\n+\t}\n+\tenc.CryptBlocks(encrypted, encrypted)\n+\n+\treturn &pem.Block{\n+\t\tType: blockType,\n+\t\tHeaders: map[string]string{\n+\t\t\t\"Proc-Type\": \"4,ENCRYPTED\",\n+\t\t\t\"DEK-Info\":  ciph.name + \",\" + hex.EncodeToString(iv),\n+\t\t},\n+\t\tBytes: encrypted,\n+\t}, nil\n+}\n+\n+func cipherByName(name string) *rfc1423Algo {\n+\tfor i := range rfc1423Algos {\n+\t\talg := &rfc1423Algos[i]\n+\t\tif alg.name == name {\n+\t\t\treturn alg\n+\t\t}\n+\t}\n+\treturn nil\n+}\n \n-\treturn data[:dlen-int(last)], nil\n+func cipherByKey(key PEMCipher) *rfc1423Algo {\n+\tfor i := range rfc1423Algos {\n+\t\talg := &rfc1423Algos[i]\n+\t\tif alg.cipher == key {\n+\t\t\treturn alg\n+\t\t}\n+\t}\n+\treturn nil\n }"}, {"sha": "59ba6f90019a2d58955b8416a91d82ae60bfe4dc", "filename": "libgo/go/crypto/x509/pem_decrypt_test.go", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -5,34 +5,79 @@\n package x509\n \n import (\n+\t\"bytes\"\n+\t\"crypto/rand\"\n+\t\"encoding/base64\"\n \t\"encoding/pem\"\n \t\"testing\"\n )\n \n func TestDecrypt(t *testing.T) {\n-\tfor _, data := range testData {\n+\tfor i, data := range testData {\n+\t\tt.Logf(\"test %d. %s\", i, data.kind)\n \t\tblock, rest := pem.Decode(data.pemData)\n \t\tif len(rest) > 0 {\n-\t\t\tt.Error(data.kind, \"extra data\")\n+\t\t\tt.Error(\"extra data\")\n \t\t}\n \t\tder, err := DecryptPEMBlock(block, data.password)\n \t\tif err != nil {\n-\t\t\tt.Error(data.kind, err)\n+\t\t\tt.Error(\"decrypt failed: \", err)\n \t\t\tcontinue\n \t\t}\n \t\tif _, err := ParsePKCS1PrivateKey(der); err != nil {\n-\t\t\tt.Error(data.kind, \"Invalid private key\")\n+\t\t\tt.Error(\"invalid private key: \", err)\n+\t\t}\n+\t\tplainDER, err := base64.StdEncoding.DecodeString(data.plainDER)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"cannot decode test DER data: \", err)\n+\t\t}\n+\t\tif !bytes.Equal(der, plainDER) {\n+\t\t\tt.Error(\"data mismatch\")\n+\t\t}\n+\t}\n+}\n+\n+func TestEncrypt(t *testing.T) {\n+\tfor i, data := range testData {\n+\t\tt.Logf(\"test %d. %s\", i, data.kind)\n+\t\tplainDER, err := base64.StdEncoding.DecodeString(data.plainDER)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"cannot decode test DER data: \", err)\n+\t\t}\n+\t\tpassword := []byte(\"kremvax1\")\n+\t\tblock, err := EncryptPEMBlock(rand.Reader, \"RSA PRIVATE KEY\", plainDER, password, data.kind)\n+\t\tif err != nil {\n+\t\t\tt.Error(\"encrypt: \", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !IsEncryptedPEMBlock(block) {\n+\t\t\tt.Error(\"PEM block does not appear to be encrypted\")\n+\t\t}\n+\t\tif block.Type != \"RSA PRIVATE KEY\" {\n+\t\t\tt.Errorf(\"unexpected block type; got %q want %q\", block.Type, \"RSA PRIVATE KEY\")\n+\t\t}\n+\t\tif block.Headers[\"Proc-Type\"] != \"4,ENCRYPTED\" {\n+\t\t\tt.Errorf(\"block does not have correct Proc-Type header\")\n+\t\t}\n+\t\tder, err := DecryptPEMBlock(block, password)\n+\t\tif err != nil {\n+\t\t\tt.Error(\"decrypt: \", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !bytes.Equal(der, plainDER) {\n+\t\t\tt.Errorf(\"data mismatch\")\n \t\t}\n \t}\n }\n \n var testData = []struct {\n-\tkind     string\n+\tkind     PEMCipher\n \tpassword []byte\n \tpemData  []byte\n+\tplainDER string\n }{\n \t{\n-\t\tkind:     \"DES-CBC\",\n+\t\tkind:     PEMCipherDES,\n \t\tpassword: []byte(\"asdf\"),\n \t\tpemData: []byte(`\n -----BEGIN RSA PRIVATE KEY-----\n@@ -47,9 +92,17 @@ XOH9VfTjb52q/I8Suozq9coVQwg4tXfIoYUdT//O+mB7zJb9HI9Ps77b9TxDE6Gm\n 4C9brwZ3zg2vqXcwwV6QRZMtyll9rOpxkbw6NPlpfBqkc3xS51bbxivbO/Nve4KD\n r12ymjFNF4stXCfJnNqKoZ50BHmEEUDu5Wb0fpVn82XrGw7CYc4iug==\n -----END RSA PRIVATE KEY-----`),\n+\t\tplainDER: `\n+MIIBPAIBAAJBAPASZe+tCPU6p80AjHhDkVsLYa51D35e/YGa8QcZyooeZM8EHozo\n+KD0fNiKI+53bHdy07N+81VQ8/ejPcRoXPlsCAwEAAQJBAMTxIuSq27VpR+zZ7WJf\n+c6fvv1OBvpMZ0/d1pxL/KnOAgq2rD5hDtk9b0LGhTPgQAmrrMTKuSeGoIuYE+gKQ\n+QvkCIQD+GC1m+/do+QRurr0uo46Kx1LzLeSCrjBk34wiOp2+dwIhAPHfTLRXS2fv\n+7rljm0bYa4+eDZpz+E8RcXEgzhhvcQQ9AiAI5eHZJGOyml3MXnQjiPi55WcDOw0w\n+glcRgT6QCEtz2wIhANSyqaFtosIkHKqrDUGfz/bb5tqMYTAnBruVPaf/WEOBAiEA\n+9xORWeRG1tRpso4+dYy4KdDkuLPIO01KY6neYGm3BCM=`,\n \t},\n \t{\n-\t\tkind:     \"DES-EDE3-CBC\",\n+\t\tkind:     PEMCipher3DES,\n \t\tpassword: []byte(\"asdf\"),\n \t\tpemData: []byte(`\n -----BEGIN RSA PRIVATE KEY-----\n@@ -64,9 +117,17 @@ ldw5w7WC7d13x2LsRkwo8ZrDKgIV+Y9GNvhuCCkTzNP0V3gNeJpd201HZHR+9n3w\n 3z0VjR/MGqsfcy1ziEWMNOO53At3zlG6zP05aHMnMcZoVXadEK6L1gz++inSSDCq\n gI0UJP4e3JVB7AkgYymYAwiYALAkoEIuanxoc50njJk=\n -----END RSA PRIVATE KEY-----`),\n+\t\tplainDER: `\n+MIIBOwIBAAJBANOCXKdoNS/iP/MAbl9cf1/SF3P+Ns7ZeNL27CfmDh0O6Zduaax5\n+NBiumd2PmjkaCu7lQ5JOibHfWn+xJsc3kw0CAwEAAQJANX/W8d1Q/sCqzkuAn4xl\n+B5a7qfJWaLHndu1QRLNTRJPn0Ee7OKJ4H0QKOhQM6vpjRrz+P2u9thn6wUxoPsef\n+QQIhAP/jCkfejFcy4v15beqKzwz08/tslVjF+Yq41eJGejmxAiEA05pMoqfkyjcx\n+fyvGhpoOyoCp71vSGUfR2I9CR65oKh0CIC1Msjs66LlfJtQctRq6bCEtFCxEcsP+\n+eEjYo/Sk6WphAiEAxpgWPMJeU/shFT28gS+tmhjPZLpEoT1qkVlC14u0b3ECIQDX\n+tZZZxCtPAm7shftEib0VU77Lk8MsXJcx2C4voRsjEw==`,\n \t},\n \t{\n-\t\tkind:     \"AES-128-CBC\",\n+\t\tkind:     PEMCipherAES128,\n \t\tpassword: []byte(\"asdf\"),\n \t\tpemData: []byte(`\n -----BEGIN RSA PRIVATE KEY-----\n@@ -81,9 +142,17 @@ GZbBpf1jDH/pr0iGonuAdl2PCCZUiy+8eLsD2tyviHUkFLOB+ykYoJ5t8ngZ/B6D\n 080LzLHPCrXKdlr/f50yhNWq08ZxMWQFkui+FDHPDUaEELKAXV8/5PDxw80Rtybo\n AVYoCVIbZXZCuCO81op8UcOgEpTtyU5Lgh3Mw5scQL0=\n -----END RSA PRIVATE KEY-----`),\n+\t\tplainDER: `\n+MIIBOgIBAAJBAMBlj5FxYtqbcy8wY89d/S7n0+r5MzD9F63BA/Lpl78vQKtdJ5dT\n+cDGh/rBt1ufRrNp0WihcmZi7Mpl/3jHjiWECAwEAAQJABNOHYnKhtDIqFYj1OAJ3\n+k3GlU0OlERmIOoeY/cL2V4lgwllPBEs7r134AY4wMmZSBUj8UR/O4SNO668ElKPE\n+cQIhAOuqY7/115x5KCdGDMWi+jNaMxIvI4ETGwV40ykGzqlzAiEA0P9oEC3m9tHB\n+kbpjSTxaNkrXxDgdEOZz8X0uOUUwHNsCIAwzcSCiGLyYJTULUmP1ESERfW1mlV78\n+XzzESaJpIM/zAiBQkSTcl9VhcJreQqvjn5BnPZLP4ZHS4gPwJAGdsj5J4QIhAOVR\n+B3WlRNTXR2WsJ5JdByezg9xzdXzULqmga0OE339a`,\n \t},\n \t{\n-\t\tkind:     \"AES-192-CBC\",\n+\t\tkind:     PEMCipherAES192,\n \t\tpassword: []byte(\"asdf\"),\n \t\tpemData: []byte(`\n -----BEGIN RSA PRIVATE KEY-----\n@@ -98,9 +167,17 @@ ReUtTw8exmKsY4gsSjhkg5uiw7/ZB1Ihto0qnfQJgjGc680qGkT1d6JfvOfeYAk6\n xn5RqS/h8rYAYm64KnepfC9vIujo4NqpaREDmaLdX5MJPQ+SlytITQvgUsUq3q/t\n Ss85xjQEZH3hzwjQqdJvmA4hYP6SUjxYpBM+02xZ1Xw=\n -----END RSA PRIVATE KEY-----`),\n+\t\tplainDER: `\n+MIIBOwIBAAJBAMGcRrZiNNmtF20zyS6MQ7pdGx17aFDl+lTl+qnLuJRUCMUG05xs\n+OmxmL/O1Qlf+bnqR8Bgg65SfKg21SYuLhiMCAwEAAQJBAL94uuHyO4wux2VC+qpj\n+IzPykjdU7XRcDHbbvksf4xokSeUFjjD3PB0Qa83M94y89ZfdILIqS9x5EgSB4/lX\n+qNkCIQD6cCIqLfzq/lYbZbQgAAjpBXeQVYsbvVtJrPrXJAlVVQIhAMXpDKMeFPMn\n+J0g2rbx1gngx0qOa5r5iMU5w/noN4W2XAiBjf+WzCG5yFvazD+dOx3TC0A8+4x3P\n+uZ3pWbaXf5PNuQIgAcdXarvhelH2w2piY1g3BPeFqhzBSCK/yLGxR82KIh8CIQDD\n++qGKsd09NhQ/G27y/DARzOYtml1NvdmCQAgsDIIOLA==`,\n \t},\n \t{\n-\t\tkind:     \"AES-256-CBC\",\n+\t\tkind:     PEMCipherAES256,\n \t\tpassword: []byte(\"asdf\"),\n \t\tpemData: []byte(`\n -----BEGIN RSA PRIVATE KEY-----\n@@ -115,5 +192,32 @@ Pz3RZScwIuubzTGJ1x8EzdffYOsdCa9Mtgpp3L136+23dOd6L/qK2EG2fzrJSHs/\n sv5Z/KwlX+3MDEpPQpUwGPlGGdLnjI3UZ+cjgqBcoMiNc6HfgbBgYJSU6aDSHuCk\n clCwByxWkBNgJ2GrkwNrF26v+bGJJJNR4SKouY1jQf0=\n -----END RSA PRIVATE KEY-----`),\n+\t\tplainDER: `\n+MIIBOgIBAAJBAKy3GFkstoCHIEeUU/qO8207m8WSrjksR+p9B4tf1w5k+2O1V/GY\n+AQ5WFCApItcOkQe/I0yZZJk/PmCqMzSxrc8CAwEAAQJAOCAz0F7AW9oNelVQSP8F\n+Sfzx7O1yom+qWyAQQJF/gFR11gpf9xpVnnyu1WxIRnDUh1LZwUsjwlDYb7MB74id\n+oQIhANPcOiLwOPT4sIUpRM5HG6BF1BI7L77VpyGVk8xNP7X/AiEA0LMHZtk4I+lJ\n+nClgYp4Yh2JZ1Znbu7IoQMCEJCjwKDECIGd8Dzm5tViTkUW6Hs3Tlf73nNs65duF\n+aRnSglss8I3pAiEAonEnKruawgD8RavDFR+fUgmQiPz4FnGGeVgfwpGG1JECIBYq\n+PXHYtPqxQIbD2pScR5qum7iGUh11lEUPkmt+2uqS`,\n+\t},\n+\t{\n+\t\t// generated with:\n+\t\t// openssl genrsa -aes128 -passout pass:asdf -out server.orig.key 128\n+\t\tkind:     PEMCipherAES128,\n+\t\tpassword: []byte(\"asdf\"),\n+\t\tpemData: []byte(`\n+-----BEGIN RSA PRIVATE KEY-----\n+Proc-Type: 4,ENCRYPTED\n+DEK-Info: AES-128-CBC,74611ABC2571AF11B1BF9B69E62C89E7\n+\n+6ei/MlytjE0FFgZOGQ+jrwomKfpl8kdefeE0NSt/DMRrw8OacHAzBNi3pPEa0eX3\n+eND9l7C9meCirWovjj9QWVHrXyugFuDIqgdhQ8iHTgCfF3lrmcttVrbIfMDw+smD\n+hTP8O1mS/MHl92NE0nhv0w==\n+-----END RSA PRIVATE KEY-----`),\n+\t\tplainDER: `\n+MGMCAQACEQC6ssxmYuauuHGOCDAI54RdAgMBAAECEQCWIn6Yv2O+kBcDF7STctKB\n+AgkA8SEfu/2i3g0CCQDGNlXbBHX7kQIIK3Ww5o0cYbECCQDCimPb0dYGsQIIeQ7A\n+jryIst8=`,\n \t},\n }"}, {"sha": "30caacb3c54df35c22cabdb26651354aa5a7d1a2", "filename": "libgo/go/crypto/x509/pkcs8.go", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -11,8 +11,9 @@ import (\n \t\"fmt\"\n )\n \n-// pkcs8 reflects an ASN.1, PKCS#8 PrivateKey. See \n-// ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-8/pkcs-8v1_2.asn.\n+// pkcs8 reflects an ASN.1, PKCS#8 PrivateKey. See\n+// ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-8/pkcs-8v1_2.asn\n+// and RFC5208.\n type pkcs8 struct {\n \tVersion    int\n \tAlgo       pkix.AlgorithmIdentifier\n@@ -21,7 +22,7 @@ type pkcs8 struct {\n }\n \n // ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. See\n-// http://www.rsa.com/rsalabs/node.asp?id=2130\n+// http://www.rsa.com/rsalabs/node.asp?id=2130 and RFC5208.\n func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error) {\n \tvar privKey pkcs8\n \tif _, err := asn1.Unmarshal(der, &privKey); err != nil {\n@@ -34,6 +35,19 @@ func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error) {\n \t\t\treturn nil, errors.New(\"crypto/x509: failed to parse RSA private key embedded in PKCS#8: \" + err.Error())\n \t\t}\n \t\treturn key, nil\n+\n+\tcase privKey.Algo.Algorithm.Equal(oidPublicKeyECDSA):\n+\t\tbytes := privKey.Algo.Parameters.FullBytes\n+\t\tnamedCurveOID := new(asn1.ObjectIdentifier)\n+\t\tif _, err := asn1.Unmarshal(bytes, namedCurveOID); err != nil {\n+\t\t\tnamedCurveOID = nil\n+\t\t}\n+\t\tkey, err = parseECPrivateKey(namedCurveOID, privKey.PrivateKey)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.New(\"crypto/x509: failed to parse EC private key embedded in PKCS#8: \" + err.Error())\n+\t\t}\n+\t\treturn key, nil\n+\n \tdefault:\n \t\treturn nil, fmt.Errorf(\"crypto/x509: PKCS#8 wrapping contained private key with unknown algorithm: %v\", privKey.Algo.Algorithm)\n \t}"}, {"sha": "4114efd0e0d1ad24c5d3aa736a37b92c3009d18c", "filename": "libgo/go/crypto/x509/pkcs8_test.go", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -9,12 +9,20 @@ import (\n \t\"testing\"\n )\n \n-var pkcs8PrivateKeyHex = `30820278020100300d06092a864886f70d0101010500048202623082025e02010002818100cfb1b5bf9685ffa97b4f99df4ff122b70e59ac9b992f3bc2b3dde17d53c1a34928719b02e8fd17839499bfbd515bd6ef99c7a1c47a239718fe36bfd824c0d96060084b5f67f0273443007a24dfaf5634f7772c9346e10eb294c2306671a5a5e719ae24b4de467291bc571014b0e02dec04534d66a9bb171d644b66b091780e8d020301000102818100b595778383c4afdbab95d2bfed12b3f93bb0a73a7ad952f44d7185fd9ec6c34de8f03a48770f2009c8580bcd275e9632714e9a5e3f32f29dc55474b2329ff0ebc08b3ffcb35bc96e6516b483df80a4a59cceb71918cbabf91564e64a39d7e35dce21cb3031824fdbc845dba6458852ec16af5dddf51a8397a8797ae0337b1439024100ea0eb1b914158c70db39031dd8904d6f18f408c85fbbc592d7d20dee7986969efbda081fdf8bc40e1b1336d6b638110c836bfdc3f314560d2e49cd4fbde1e20b024100e32a4e793b574c9c4a94c8803db5152141e72d03de64e54ef2c8ed104988ca780cd11397bc359630d01b97ebd87067c5451ba777cf045ca23f5912f1031308c702406dfcdbbd5a57c9f85abc4edf9e9e29153507b07ce0a7ef6f52e60dcfebe1b8341babd8b789a837485da6c8d55b29bbb142ace3c24a1f5b54b454d01b51e2ad03024100bd6a2b60dee01e1b3bfcef6a2f09ed027c273cdbbaf6ba55a80f6dcc64e4509ee560f84b4f3e076bd03b11e42fe71a3fdd2dffe7e0902c8584f8cad877cdc945024100aa512fa4ada69881f1d8bb8ad6614f192b83200aef5edf4811313d5ef30a86cbd0a90f7b025c71ea06ec6b34db6306c86b1040670fd8654ad7291d066d06d031`\n+var pkcs8RSAPrivateKeyHex = `30820278020100300d06092a864886f70d0101010500048202623082025e02010002818100cfb1b5bf9685ffa97b4f99df4ff122b70e59ac9b992f3bc2b3dde17d53c1a34928719b02e8fd17839499bfbd515bd6ef99c7a1c47a239718fe36bfd824c0d96060084b5f67f0273443007a24dfaf5634f7772c9346e10eb294c2306671a5a5e719ae24b4de467291bc571014b0e02dec04534d66a9bb171d644b66b091780e8d020301000102818100b595778383c4afdbab95d2bfed12b3f93bb0a73a7ad952f44d7185fd9ec6c34de8f03a48770f2009c8580bcd275e9632714e9a5e3f32f29dc55474b2329ff0ebc08b3ffcb35bc96e6516b483df80a4a59cceb71918cbabf91564e64a39d7e35dce21cb3031824fdbc845dba6458852ec16af5dddf51a8397a8797ae0337b1439024100ea0eb1b914158c70db39031dd8904d6f18f408c85fbbc592d7d20dee7986969efbda081fdf8bc40e1b1336d6b638110c836bfdc3f314560d2e49cd4fbde1e20b024100e32a4e793b574c9c4a94c8803db5152141e72d03de64e54ef2c8ed104988ca780cd11397bc359630d01b97ebd87067c5451ba777cf045ca23f5912f1031308c702406dfcdbbd5a57c9f85abc4edf9e9e29153507b07ce0a7ef6f52e60dcfebe1b8341babd8b789a837485da6c8d55b29bbb142ace3c24a1f5b54b454d01b51e2ad03024100bd6a2b60dee01e1b3bfcef6a2f09ed027c273cdbbaf6ba55a80f6dcc64e4509ee560f84b4f3e076bd03b11e42fe71a3fdd2dffe7e0902c8584f8cad877cdc945024100aa512fa4ada69881f1d8bb8ad6614f192b83200aef5edf4811313d5ef30a86cbd0a90f7b025c71ea06ec6b34db6306c86b1040670fd8654ad7291d066d06d031`\n+\n+// Generated using:\n+//   openssl ecparam -genkey -name secp521r1 | openssl pkcs8 -topk8 -nocrypt\n+var pkcs8ECPrivateKeyHex = `3081ed020100301006072a8648ce3d020106052b810400230481d53081d20201010441850d81618c5da1aec74c2eed608ba816038506975e6427237c2def150c96a3b13efbfa1f89f1be15cdf4d0ac26422e680e65a0ddd4ad3541ad76165fbf54d6e34ba18189038186000400da97bcedba1eb6d30aeb93c9f9a1454598fa47278df27d6f60ea73eb672d8dc528a9b67885b5b5dcef93c9824f7449ab512ee6a27e76142f56b94b474cfd697e810046c8ca70419365245c1d7d44d0db82c334073835d002232714548abbae6e5700f5ef315ee08b929d8581383dcf2d1c98c2f8a9fccbf79c9579f7b2fd8a90115ac2`\n \n func TestPKCS8(t *testing.T) {\n-\tderBytes, _ := hex.DecodeString(pkcs8PrivateKeyHex)\n-\t_, err := ParsePKCS8PrivateKey(derBytes)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to decode PKCS8 key: %s\", err)\n+\tderBytes, _ := hex.DecodeString(pkcs8RSAPrivateKeyHex)\n+\tif _, err := ParsePKCS8PrivateKey(derBytes); err != nil {\n+\t\tt.Errorf(\"failed to decode PKCS8 with RSA private key: %s\", err)\n+\t}\n+\n+\tderBytes, _ = hex.DecodeString(pkcs8ECPrivateKeyHex)\n+\tif _, err := ParsePKCS8PrivateKey(derBytes); err != nil {\n+\t\tt.Errorf(\"failed to decode PKCS8 with EC private key: %s\", err)\n \t}\n }"}, {"sha": "8a2840fbef57068c3f93500437d64da440878866", "filename": "libgo/go/crypto/x509/sec1.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"crypto/ecdsa\"\n+\t\"crypto/elliptic\"\n+\t\"encoding/asn1\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math/big\"\n+)\n+\n+const ecPrivKeyVersion = 1\n+\n+// ecPrivateKey reflects an ASN.1 Elliptic Curve Private Key Structure.\n+// References:\n+//   RFC5915\n+//   SEC1 - http://www.secg.org/download/aid-780/sec1-v2.pdf\n+// Per RFC5915 the NamedCurveOID is marked as ASN.1 OPTIONAL, however in\n+// most cases it is not.\n+type ecPrivateKey struct {\n+\tVersion       int\n+\tPrivateKey    []byte\n+\tNamedCurveOID asn1.ObjectIdentifier `asn1:\"optional,explicit,tag:0\"`\n+\tPublicKey     asn1.BitString        `asn1:\"optional,explicit,tag:1\"`\n+}\n+\n+// ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n+func ParseECPrivateKey(der []byte) (key *ecdsa.PrivateKey, err error) {\n+\treturn parseECPrivateKey(nil, der)\n+}\n+\n+// parseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n+// The OID for the named curve may be provided from another source (such as\n+// the PKCS8 container) - if it is provided then use this instead of the OID\n+// that may exist in the EC private key structure.\n+func parseECPrivateKey(namedCurveOID *asn1.ObjectIdentifier, der []byte) (key *ecdsa.PrivateKey, err error) {\n+\tvar privKey ecPrivateKey\n+\tif _, err := asn1.Unmarshal(der, &privKey); err != nil {\n+\t\treturn nil, errors.New(\"crypto/x509: failed to parse EC private key: \" + err.Error())\n+\t}\n+\tif privKey.Version != ecPrivKeyVersion {\n+\t\treturn nil, fmt.Errorf(\"crypto/x509: unknown EC private key version %d\", privKey.Version)\n+\t}\n+\n+\tvar curve elliptic.Curve\n+\tif namedCurveOID != nil {\n+\t\tcurve = namedCurveFromOID(*namedCurveOID)\n+\t} else {\n+\t\tcurve = namedCurveFromOID(privKey.NamedCurveOID)\n+\t}\n+\tif curve == nil {\n+\t\treturn nil, errors.New(\"crypto/x509: unknown elliptic curve\")\n+\t}\n+\n+\tk := new(big.Int).SetBytes(privKey.PrivateKey)\n+\tif k.Cmp(curve.Params().N) >= 0 {\n+\t\treturn nil, errors.New(\"crypto/x509: invalid elliptic curve private key value\")\n+\t}\n+\tpriv := new(ecdsa.PrivateKey)\n+\tpriv.Curve = curve\n+\tpriv.D = k\n+\tpriv.X, priv.Y = curve.ScalarBaseMult(privKey.PrivateKey)\n+\n+\treturn priv, nil\n+}"}, {"sha": "7135699d28325ff78187c57aad22ee6479957547", "filename": "libgo/go/crypto/x509/sec1_test.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"testing\"\n+)\n+\n+// Generated using:\n+//   openssl ecparam -genkey -name secp384r1 -outform PEM\n+var ecPrivateKeyHex = `3081a40201010430bdb9839c08ee793d1157886a7a758a3c8b2a17a4df48f17ace57c72c56b4723cf21dcda21d4e1ad57ff034f19fcfd98ea00706052b81040022a16403620004feea808b5ee2429cfcce13c32160e1c960990bd050bb0fdf7222f3decd0a55008e32a6aa3c9062051c4cba92a7a3b178b24567412d43cdd2f882fa5addddd726fe3e208d2c26d733a773a597abb749714df7256ead5105fa6e7b3650de236b50`\n+\n+func TestParseECPrivateKey(t *testing.T) {\n+\tderBytes, _ := hex.DecodeString(ecPrivateKeyHex)\n+\t_, err := ParseECPrivateKey(derBytes)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to decode EC private key: %s\", err)\n+\t}\n+}"}, {"sha": "7983217696e57cb2b09ba2449fe022c531f93275", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -156,28 +156,28 @@ const (\n //\n // pkcs-1 OBJECT IDENTIFIER ::= {\n //    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }\n-// \n-// \n+//\n+//\n // RFC 3279 2.2.1 RSA Signature Algorithms\n //\n // md2WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 2 }\n //\n // md5WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 4 }\n //\n // sha-1WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 5 }\n-// \n+//\n // dsaWithSha1 OBJECT IDENTIFIER ::= {\n-//    iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 3 } \n+//    iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 3 }\n //\n // RFC 3279 2.2.3 ECDSA Signature Algorithm\n-// \n+//\n // ecdsa-with-SHA1 OBJECT IDENTIFIER ::= {\n // \t  iso(1) member-body(2) us(840) ansi-x962(10045)\n //    signatures(4) ecdsa-with-SHA1(1)}\n //\n //\n // RFC 4055 5 PKCS #1 Version 1.5\n-// \n+//\n // sha256WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 11 }\n //\n // sha384WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 12 }\n@@ -1224,7 +1224,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interf\n \t\tSerialNumber:       template.SerialNumber,\n \t\tSignatureAlgorithm: signatureAlgorithm,\n \t\tIssuer:             asn1.RawValue{FullBytes: asn1Issuer},\n-\t\tValidity:           validity{template.NotBefore, template.NotAfter},\n+\t\tValidity:           validity{template.NotBefore.UTC(), template.NotAfter.UTC()},\n \t\tSubject:            asn1.RawValue{FullBytes: asn1Subject},\n \t\tPublicKey:          publicKeyInfo{nil, publicKeyAlgorithm, encodedPublicKey},\n \t\tExtensions:         extensions,\n@@ -1314,8 +1314,8 @@ func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts [\n \t\t\tAlgorithm: oidSignatureSHA1WithRSA,\n \t\t},\n \t\tIssuer:              c.Subject.ToRDNSequence(),\n-\t\tThisUpdate:          now,\n-\t\tNextUpdate:          expiry,\n+\t\tThisUpdate:          now.UTC(),\n+\t\tNextUpdate:          expiry.UTC(),\n \t\tRevokedCertificates: revokedCerts,\n \t}\n "}, {"sha": "f462375dc6415e5d7efa58b995989690300940e5", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -417,10 +417,6 @@ func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, error) {\n \t\treturn nil, nil, errors.New(\"cannot load string table section\")\n \t}\n \n-\t// The first entry is all zeros.\n-\tvar skip [Sym32Size]byte\n-\tsymtab.Read(skip[0:])\n-\n \tsymbols := make([]Symbol, symtab.Len()/Sym32Size)\n \n \ti := 0\n@@ -460,10 +456,6 @@ func (f *File) getSymbols64(typ SectionType) ([]Symbol, []byte, error) {\n \t\treturn nil, nil, errors.New(\"cannot load string table section\")\n \t}\n \n-\t// The first entry is all zeros.\n-\tvar skip [Sym64Size]byte\n-\tsymtab.Read(skip[0:])\n-\n \tsymbols := make([]Symbol, symtab.Len()/Sym64Size)\n \n \ti := 0\n@@ -708,8 +700,8 @@ func (f *File) gnuVersionInit(str []byte) {\n // gnuVersion adds Library and Version information to sym,\n // which came from offset i of the symbol table.\n func (f *File) gnuVersion(i int, sym *ImportedSymbol) {\n-\t// Each entry is two bytes; skip undef entry at beginning.\n-\ti = (i + 1) * 2\n+\t// Each entry is two bytes.\n+\ti = i * 2\n \tif i >= len(f.gnuVersym) {\n \t\treturn\n \t}"}, {"sha": "810a2f9b9a36d5f932f01d0a6c46143c4beaa80f", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -175,23 +175,41 @@ func TestOpen(t *testing.T) {\n \t}\n }\n \n+type relocationTestEntry struct {\n+\tentryNumber int\n+\tentry       *dwarf.Entry\n+}\n+\n type relocationTest struct {\n-\tfile       string\n-\tfirstEntry *dwarf.Entry\n+\tfile    string\n+\tentries []relocationTestEntry\n }\n \n var relocationTests = []relocationTest{\n \t{\n \t\t\"testdata/go-relocation-test-gcc441-x86-64.obj\",\n-\t\t&dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.4.1\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"go-relocation-test.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x6)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}},\n+\t\t[]relocationTestEntry{\n+\t\t\t{0, &dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.4.1\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"go-relocation-test.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x6)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}}},\n+\t\t},\n \t},\n \t{\n \t\t\"testdata/go-relocation-test-gcc441-x86.obj\",\n-\t\t&dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.4.1\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"t.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x5)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}},\n+\t\t[]relocationTestEntry{\n+\t\t\t{0, &dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.4.1\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"t.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x5)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}}},\n+\t\t},\n \t},\n \t{\n \t\t\"testdata/go-relocation-test-gcc424-x86-64.obj\",\n-\t\t&dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.2.4 (Ubuntu 4.2.4-1ubuntu4)\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"go-relocation-test-gcc424.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x6)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}},\n+\t\t[]relocationTestEntry{\n+\t\t\t{0, &dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.2.4 (Ubuntu 4.2.4-1ubuntu4)\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"go-relocation-test-gcc424.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: uint64(0x6)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}}},\n+\t\t},\n+\t},\n+\t{\n+\t\t\"testdata/gcc-amd64-openbsd-debug-with-rela.obj\",\n+\t\t[]relocationTestEntry{\n+\t\t\t{203, &dwarf.Entry{Offset: 0xc62, Tag: dwarf.TagMember, Children: false, Field: []dwarf.Field{{Attr: dwarf.AttrName, Val: \"it_interval\"}, {Attr: dwarf.AttrDeclFile, Val: int64(7)}, {Attr: dwarf.AttrDeclLine, Val: int64(236)}, {Attr: dwarf.AttrType, Val: dwarf.Offset(0xb7f)}, {Attr: dwarf.AttrDataMemberLoc, Val: []byte{0x23, 0x0}}}}},\n+\t\t\t{204, &dwarf.Entry{Offset: 0xc70, Tag: dwarf.TagMember, Children: false, Field: []dwarf.Field{{Attr: dwarf.AttrName, Val: \"it_value\"}, {Attr: dwarf.AttrDeclFile, Val: int64(7)}, {Attr: dwarf.AttrDeclLine, Val: int64(237)}, {Attr: dwarf.AttrType, Val: dwarf.Offset(0xb7f)}, {Attr: dwarf.AttrDataMemberLoc, Val: []byte{0x23, 0x10}}}}},\n+\t\t},\n \t},\n }\n \n@@ -207,20 +225,24 @@ func TestDWARFRelocations(t *testing.T) {\n \t\t\tt.Error(err)\n \t\t\tcontinue\n \t\t}\n-\t\treader := dwarf.Reader()\n-\t\t// Checking only the first entry is sufficient since it has\n-\t\t// many different strings. If the relocation had failed, all\n-\t\t// the string offsets would be zero and all the strings would\n-\t\t// end up being the same.\n-\t\tfirstEntry, err := reader.Next()\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif !reflect.DeepEqual(test.firstEntry, firstEntry) {\n-\t\t\tt.Errorf(\"#%d: mismatch: got:%#v want:%#v\", i, firstEntry, test.firstEntry)\n-\t\t\tcontinue\n+\t\tfor _, testEntry := range test.entries {\n+\t\t\treader := dwarf.Reader()\n+\t\t\tfor j := 0; j < testEntry.entryNumber; j++ {\n+\t\t\t\tentry, err := reader.Next()\n+\t\t\t\tif entry == nil || err != nil {\n+\t\t\t\t\tt.Errorf(\"Failed to skip to entry %d: %v\", testEntry.entryNumber, err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tentry, err := reader.Next()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(testEntry.entry, entry) {\n+\t\t\t\tt.Errorf(\"#%d/%d: mismatch: got:%#v want:%#v\", i, testEntry.entryNumber, entry, testEntry.entry)\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "f62b1ea1cada83530e45320cc58394933753dddb", "filename": "libgo/go/debug/elf/testdata/gcc-amd64-openbsd-debug-with-rela.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgcc-amd64-openbsd-debug-with-rela.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgcc-amd64-openbsd-debug-with-rela.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgcc-amd64-openbsd-debug-with-rela.obj?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "0c216fdb3cd8947120587ed6b8454dac066f9dde", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -296,8 +296,7 @@ func marshalTwoDigits(out *forkableWriter, v int) (err error) {\n }\n \n func marshalUTCTime(out *forkableWriter, t time.Time) (err error) {\n-\tutc := t.UTC()\n-\tyear, month, day := utc.Date()\n+\tyear, month, day := t.Date()\n \n \tswitch {\n \tcase 1950 <= year && year < 2000:\n@@ -321,7 +320,7 @@ func marshalUTCTime(out *forkableWriter, t time.Time) (err error) {\n \t\treturn\n \t}\n \n-\thour, min, sec := utc.Clock()\n+\thour, min, sec := t.Clock()\n \n \terr = marshalTwoDigits(out, hour)\n \tif err != nil {"}, {"sha": "55d34a709a486d239477722a1b97c421542138dd", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -82,7 +82,7 @@ var marshalTests = []marshalTest{\n \t{explicitTagTest{64}, \"3005a503020140\"},\n \t{time.Unix(0, 0).UTC(), \"170d3730303130313030303030305a\"},\n \t{time.Unix(1258325776, 0).UTC(), \"170d3039313131353232353631365a\"},\n-\t{time.Unix(1258325776, 0).In(PST), \"17113039313131353232353631362d30383030\"},\n+\t{time.Unix(1258325776, 0).In(PST), \"17113039313131353134353631362d30383030\"},\n \t{BitString{[]byte{0x80}, 1}, \"03020780\"},\n \t{BitString{[]byte{0x81, 0xf0}, 12}, \"03030481f0\"},\n \t{ObjectIdentifier([]int{1, 2, 3, 4}), \"06032a0304\"},"}, {"sha": "06670141e16ee828214e5b057508cb954d5f3df1", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -125,6 +125,9 @@ func (bigEndian) GoString() string { return \"binary.BigEndian\" }\n // of fixed-size values.\n // Bytes read from r are decoded using the specified byte order\n // and written to successive fields of the data.\n+// When reading into structs, the field data for fields with\n+// blank (_) field names is skipped; i.e., blank field names\n+// may be used for padding.\n func Read(r io.Reader, order ByteOrder, data interface{}) error {\n \t// Fast path for basic types.\n \tif n := intDestSize(data); n != 0 {\n@@ -154,7 +157,7 @@ func Read(r io.Reader, order ByteOrder, data interface{}) error {\n \t\treturn nil\n \t}\n \n-\t// Fallback to reflect-based.\n+\t// Fallback to reflect-based decoding.\n \tvar v reflect.Value\n \tswitch d := reflect.ValueOf(data); d.Kind() {\n \tcase reflect.Ptr:\n@@ -181,6 +184,8 @@ func Read(r io.Reader, order ByteOrder, data interface{}) error {\n // values, or a pointer to such data.\n // Bytes written to w are encoded using the specified byte order\n // and read from successive fields of the data.\n+// When writing structs, zero values are are written for fields\n+// with blank (_) field names.\n func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \t// Fast path for basic types.\n \tvar b [8]byte\n@@ -239,6 +244,8 @@ func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \t\t_, err := w.Write(bs)\n \t\treturn err\n \t}\n+\n+\t// Fallback to reflect-based encoding.\n \tv := reflect.Indirect(reflect.ValueOf(data))\n \tsize := dataSize(v)\n \tif size < 0 {\n@@ -300,15 +307,13 @@ func sizeof(t reflect.Type) int {\n \treturn -1\n }\n \n-type decoder struct {\n+type coder struct {\n \torder ByteOrder\n \tbuf   []byte\n }\n \n-type encoder struct {\n-\torder ByteOrder\n-\tbuf   []byte\n-}\n+type decoder coder\n+type encoder coder\n \n func (d *decoder) uint8() uint8 {\n \tx := d.buf[0]\n@@ -379,9 +384,19 @@ func (d *decoder) value(v reflect.Value) {\n \t\t}\n \n \tcase reflect.Struct:\n+\t\tt := v.Type()\n \t\tl := v.NumField()\n \t\tfor i := 0; i < l; i++ {\n-\t\t\td.value(v.Field(i))\n+\t\t\t// Note: Calling v.CanSet() below is an optimization.\n+\t\t\t// It would be sufficient to check the field name,\n+\t\t\t// but creating the StructField info for each field is\n+\t\t\t// costly (run \"go test -bench=ReadStruct\" and compare\n+\t\t\t// results when making changes to this code).\n+\t\t\tif v := v.Field(i); v.CanSet() || t.Field(i).Name != \"_\" {\n+\t\t\t\td.value(v)\n+\t\t\t} else {\n+\t\t\t\td.skip(v)\n+\t\t\t}\n \t\t}\n \n \tcase reflect.Slice:\n@@ -435,9 +450,15 @@ func (e *encoder) value(v reflect.Value) {\n \t\t}\n \n \tcase reflect.Struct:\n+\t\tt := v.Type()\n \t\tl := v.NumField()\n \t\tfor i := 0; i < l; i++ {\n-\t\t\te.value(v.Field(i))\n+\t\t\t// see comment for corresponding code in decoder.value()\n+\t\t\tif v := v.Field(i); v.CanSet() || t.Field(i).Name != \"_\" {\n+\t\t\t\te.value(v)\n+\t\t\t} else {\n+\t\t\t\te.skip(v)\n+\t\t\t}\n \t\t}\n \n \tcase reflect.Slice:\n@@ -492,6 +513,18 @@ func (e *encoder) value(v reflect.Value) {\n \t}\n }\n \n+func (d *decoder) skip(v reflect.Value) {\n+\td.buf = d.buf[dataSize(v):]\n+}\n+\n+func (e *encoder) skip(v reflect.Value) {\n+\tn := dataSize(v)\n+\tfor i := range e.buf[0:n] {\n+\t\te.buf[i] = 0\n+\t}\n+\te.buf = e.buf[n:]\n+}\n+\n // intDestSize returns the size of the integer that ptrType points to,\n // or 0 if the type is not supported.\n func intDestSize(ptrType interface{}) int {"}, {"sha": "7fe3f886f381d077dea53156164ab8a660e0f01a", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 66, "deletions": 15, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -121,18 +121,14 @@ func testWrite(t *testing.T, order ByteOrder, b []byte, s1 interface{}) {\n \tcheckResult(t, \"Write\", order, err, buf.Bytes(), b)\n }\n \n-func TestBigEndianRead(t *testing.T) { testRead(t, BigEndian, big, s) }\n-\n-func TestLittleEndianRead(t *testing.T) { testRead(t, LittleEndian, little, s) }\n-\n-func TestBigEndianWrite(t *testing.T) { testWrite(t, BigEndian, big, s) }\n-\n-func TestLittleEndianWrite(t *testing.T) { testWrite(t, LittleEndian, little, s) }\n+func TestLittleEndianRead(t *testing.T)     { testRead(t, LittleEndian, little, s) }\n+func TestLittleEndianWrite(t *testing.T)    { testWrite(t, LittleEndian, little, s) }\n+func TestLittleEndianPtrWrite(t *testing.T) { testWrite(t, LittleEndian, little, &s) }\n \n+func TestBigEndianRead(t *testing.T)     { testRead(t, BigEndian, big, s) }\n+func TestBigEndianWrite(t *testing.T)    { testWrite(t, BigEndian, big, s) }\n func TestBigEndianPtrWrite(t *testing.T) { testWrite(t, BigEndian, big, &s) }\n \n-func TestLittleEndianPtrWrite(t *testing.T) { testWrite(t, LittleEndian, little, &s) }\n-\n func TestReadSlice(t *testing.T) {\n \tslice := make([]int32, 2)\n \terr := Read(bytes.NewBuffer(src), BigEndian, slice)\n@@ -148,20 +144,75 @@ func TestWriteSlice(t *testing.T) {\n func TestWriteT(t *testing.T) {\n \tbuf := new(bytes.Buffer)\n \tts := T{}\n-\terr := Write(buf, BigEndian, ts)\n-\tif err == nil {\n-\t\tt.Errorf(\"WriteT: have nil, want non-nil\")\n+\tif err := Write(buf, BigEndian, ts); err == nil {\n+\t\tt.Errorf(\"WriteT: have err == nil, want non-nil\")\n \t}\n \n \ttv := reflect.Indirect(reflect.ValueOf(ts))\n \tfor i, n := 0, tv.NumField(); i < n; i++ {\n-\t\terr = Write(buf, BigEndian, tv.Field(i).Interface())\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"WriteT.%v: have nil, want non-nil\", tv.Field(i).Type())\n+\t\tif err := Write(buf, BigEndian, tv.Field(i).Interface()); err == nil {\n+\t\t\tt.Errorf(\"WriteT.%v: have err == nil, want non-nil\", tv.Field(i).Type())\n \t\t}\n \t}\n }\n \n+type BlankFields struct {\n+\tA uint32\n+\t_ int32\n+\tB float64\n+\t_ [4]int16\n+\tC byte\n+\t_ [7]byte\n+\t_ struct {\n+\t\tf [8]float32\n+\t}\n+}\n+\n+type BlankFieldsProbe struct {\n+\tA  uint32\n+\tP0 int32\n+\tB  float64\n+\tP1 [4]int16\n+\tC  byte\n+\tP2 [7]byte\n+\tP3 struct {\n+\t\tF [8]float32\n+\t}\n+}\n+\n+func TestBlankFields(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tb1 := BlankFields{A: 1234567890, B: 2.718281828, C: 42}\n+\tif err := Write(buf, LittleEndian, &b1); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\t// zero values must have been written for blank fields\n+\tvar p BlankFieldsProbe\n+\tif err := Read(buf, LittleEndian, &p); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\t// quick test: only check first value of slices\n+\tif p.P0 != 0 || p.P1[0] != 0 || p.P2[0] != 0 || p.P3.F[0] != 0 {\n+\t\tt.Errorf(\"non-zero values for originally blank fields: %#v\", p)\n+\t}\n+\n+\t// write p and see if we can probe only some fields\n+\tif err := Write(buf, LittleEndian, &p); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\t// read should ignore blank fields in b2\n+\tvar b2 BlankFields\n+\tif err := Read(buf, LittleEndian, &b2); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif b1.A != b2.A || b1.B != b2.B || b1.C != b2.C {\n+\t\tt.Errorf(\"%#v != %#v\", b1, b2)\n+\t}\n+}\n+\n type byteSliceReader struct {\n \tremain []byte\n }"}, {"sha": "7035529f2791a104b058d8a8c0124a7d6dd19785", "filename": "libgo/go/encoding/binary/varint.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -123,7 +123,7 @@ func ReadUvarint(r io.ByteReader) (uint64, error) {\n \tpanic(\"unreachable\")\n }\n \n-// ReadVarint reads an encoded unsigned integer from r and returns it as an int64.\n+// ReadVarint reads an encoded signed integer from r and returns it as an int64.\n func ReadVarint(r io.ByteReader) (int64, error) {\n \tux, err := ReadUvarint(r) // ok to continue in presence of error\n \tx := int64(ux >> 1)"}, {"sha": "284decedead5382a6360592110fc1713702778e1", "filename": "libgo/go/encoding/gob/encoder.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -132,7 +132,7 @@ func (enc *Encoder) sendActualType(w io.Writer, state *encoderState, ut *userTyp\n \treturn true\n }\n \n-// sendType sends the type info to the other side, if necessary. \n+// sendType sends the type info to the other side, if necessary.\n func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Type) (sent bool) {\n \tut := userType(origt)\n \tif ut.isGobEncoder {"}, {"sha": "1e0c8d4b6e62f55274b7e59cfef5a097c873bc2a", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -67,8 +67,8 @@ func Unmarshal(data []byte, v interface{}) error {\n \n // Unmarshaler is the interface implemented by objects\n // that can unmarshal a JSON description of themselves.\n-// The input can be assumed to be a valid JSON object\n-// encoding.  UnmarshalJSON must copy the JSON data\n+// The input can be assumed to be a valid encoding of\n+// a JSON value. UnmarshalJSON must copy the JSON data\n // if it wishes to retain the data after returning.\n type Unmarshaler interface {\n \tUnmarshalJSON([]byte) error\n@@ -617,12 +617,10 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \tswitch c := item[0]; c {\n \tcase 'n': // null\n \t\tswitch v.Kind() {\n-\t\tdefault:\n-\t\t\td.saveError(&UnmarshalTypeError{\"null\", v.Type()})\n \t\tcase reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:\n \t\t\tv.Set(reflect.Zero(v.Type()))\n+\t\t\t// otherwise, ignore null for primitives/string\n \t\t}\n-\n \tcase 't', 'f': // true, false\n \t\tvalue := c == 't'\n \t\tswitch v.Kind() {"}, {"sha": "b9fad0597a6d0d17727f240826d57d005b186951", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -953,3 +953,50 @@ func TestInterfaceSet(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// JSON null values should be ignored for primitives and string values instead of resulting in an error.\n+// Issue 2540\n+func TestUnmarshalNulls(t *testing.T) {\n+\tjsonData := []byte(`{\n+\t\t\"Bool\"    : null, \n+\t\t\"Int\"     : null, \n+\t\t\"Int8\"    : null,\n+\t\t\"Int16\"   : null,\n+\t\t\"Int32\"   : null,\n+\t\t\"Int64\"   : null,\n+\t\t\"Uint\"    : null,\n+\t\t\"Uint8\"   : null,\n+\t\t\"Uint16\"  : null,\n+\t\t\"Uint32\"  : null,\n+\t\t\"Uint64\"  : null,\n+\t\t\"Float32\" : null,\n+\t\t\"Float64\" : null,\n+\t\t\"String\"  : null}`)\n+\n+\tnulls := All{\n+\t\tBool:    true,\n+\t\tInt:     2,\n+\t\tInt8:    3,\n+\t\tInt16:   4,\n+\t\tInt32:   5,\n+\t\tInt64:   6,\n+\t\tUint:    7,\n+\t\tUint8:   8,\n+\t\tUint16:  9,\n+\t\tUint32:  10,\n+\t\tUint64:  11,\n+\t\tFloat32: 12.1,\n+\t\tFloat64: 13.1,\n+\t\tString:  \"14\"}\n+\n+\terr := Unmarshal(jsonData, &nulls)\n+\tif err != nil {\n+\t\tt.Errorf(\"Unmarshal of null values failed: %v\", err)\n+\t}\n+\tif !nulls.Bool || nulls.Int != 2 || nulls.Int8 != 3 || nulls.Int16 != 4 || nulls.Int32 != 5 || nulls.Int64 != 6 ||\n+\t\tnulls.Uint != 7 || nulls.Uint8 != 8 || nulls.Uint16 != 9 || nulls.Uint32 != 10 || nulls.Uint64 != 11 ||\n+\t\tnulls.Float32 != 12.1 || nulls.Float64 != 13.1 || nulls.String != \"14\" {\n+\n+\t\tt.Errorf(\"Unmarshal of null values affected primitives\")\n+\t}\n+}"}, {"sha": "a5803b4623d3c402b78e4ab9567bf6c6d7f0d825", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -86,7 +86,7 @@ import (\n //\n // Anonymous struct fields are usually marshaled as if their inner exported fields\n // were fields in the outer struct, subject to the usual Go visibility rules.\n-// An anonymous struct field with a name given in its JSON tag is treated as \n+// An anonymous struct field with a name given in its JSON tag is treated as\n // having that name instead of as anonymous.\n //\n // Handling of anonymous struct fields is new in Go 1.1."}, {"sha": "8ff7ee8c33ab4387b7f34f50280335efd0e8fd4e", "filename": "libgo/go/encoding/pem/pem.go", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"bytes\"\n \t\"encoding/base64\"\n \t\"io\"\n+\t\"sort\"\n )\n \n // A Block represents a PEM encoded structure.\n@@ -209,46 +210,64 @@ func (l *lineBreaker) Close() (err error) {\n \treturn\n }\n \n-func Encode(out io.Writer, b *Block) (err error) {\n-\t_, err = out.Write(pemStart[1:])\n-\tif err != nil {\n-\t\treturn\n+func writeHeader(out io.Writer, k, v string) error {\n+\t_, err := out.Write([]byte(k + \": \" + v + \"\\n\"))\n+\treturn err\n+}\n+\n+func Encode(out io.Writer, b *Block) error {\n+\tif _, err := out.Write(pemStart[1:]); err != nil {\n+\t\treturn err\n \t}\n-\t_, err = out.Write([]byte(b.Type + \"-----\\n\"))\n-\tif err != nil {\n-\t\treturn\n+\tif _, err := out.Write([]byte(b.Type + \"-----\\n\")); err != nil {\n+\t\treturn err\n \t}\n \n \tif len(b.Headers) > 0 {\n-\t\tfor k, v := range b.Headers {\n-\t\t\t_, err = out.Write([]byte(k + \": \" + v + \"\\n\"))\n-\t\t\tif err != nil {\n-\t\t\t\treturn\n+\t\tconst procType = \"Proc-Type\"\n+\t\th := make([]string, 0, len(b.Headers))\n+\t\thasProcType := false\n+\t\tfor k := range b.Headers {\n+\t\t\tif k == procType {\n+\t\t\t\thasProcType = true\n+\t\t\t\tcontinue\n \t\t\t}\n+\t\t\th = append(h, k)\n \t\t}\n-\t\t_, err = out.Write([]byte{'\\n'})\n-\t\tif err != nil {\n-\t\t\treturn\n+\t\t// The Proc-Type header must be written first.\n+\t\t// See RFC 1421, section 4.6.1.1\n+\t\tif hasProcType {\n+\t\t\tif err := writeHeader(out, procType, b.Headers[procType]); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t// For consistency of output, write other headers sorted by key.\n+\t\tsort.Strings(h)\n+\t\tfor _, k := range h {\n+\t\t\tif err := writeHeader(out, k, b.Headers[k]); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\tif _, err := out.Write([]byte{'\\n'}); err != nil {\n+\t\t\treturn err\n \t\t}\n \t}\n \n \tvar breaker lineBreaker\n \tbreaker.out = out\n \n \tb64 := base64.NewEncoder(base64.StdEncoding, &breaker)\n-\t_, err = b64.Write(b.Bytes)\n-\tif err != nil {\n-\t\treturn\n+\tif _, err := b64.Write(b.Bytes); err != nil {\n+\t\treturn err\n \t}\n \tb64.Close()\n \tbreaker.Close()\n \n-\t_, err = out.Write(pemEnd[1:])\n-\tif err != nil {\n-\t\treturn\n+\tif _, err := out.Write(pemEnd[1:]); err != nil {\n+\t\treturn err\n \t}\n-\t_, err = out.Write([]byte(b.Type + \"-----\\n\"))\n-\treturn\n+\t_, err := out.Write([]byte(b.Type + \"-----\\n\"))\n+\treturn err\n }\n \n func EncodeToMemory(b *Block) []byte {"}, {"sha": "ccce42cf1ffa538143b05712af00e5e19570eafc", "filename": "libgo/go/encoding/pem/pem_test.go", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -43,16 +43,16 @@ func TestDecode(t *testing.T) {\n \tif !reflect.DeepEqual(result, privateKey) {\n \t\tt.Errorf(\"#1 got:%#v want:%#v\", result, privateKey)\n \t}\n-\tresult, _ = Decode([]byte(pemPrivateKey))\n+\tresult, _ = Decode([]byte(pemPrivateKey2))\n \tif !reflect.DeepEqual(result, privateKey2) {\n \t\tt.Errorf(\"#2 got:%#v want:%#v\", result, privateKey2)\n \t}\n }\n \n func TestEncode(t *testing.T) {\n \tr := EncodeToMemory(privateKey2)\n-\tif string(r) != pemPrivateKey {\n-\t\tt.Errorf(\"got:%s want:%s\", r, pemPrivateKey)\n+\tif string(r) != pemPrivateKey2 {\n+\t\tt.Errorf(\"got:%s want:%s\", r, pemPrivateKey2)\n \t}\n }\n \n@@ -341,50 +341,64 @@ var privateKey = &Block{Type: \"RSA PRIVATE KEY\",\n \t},\n }\n \n-var privateKey2 = &Block{Type: \"RSA PRIVATE KEY\",\n-\tHeaders: map[string]string{},\n-\tBytes: []uint8{0x30, 0x82, 0x1, 0x3a, 0x2, 0x1, 0x0, 0x2,\n-\t\t0x41, 0x0, 0xb2, 0x99, 0xf, 0x49, 0xc4, 0x7d, 0xfa, 0x8c,\n-\t\t0xd4, 0x0, 0xae, 0x6a, 0x4d, 0x1b, 0x8a, 0x3b, 0x6a, 0x13,\n-\t\t0x64, 0x2b, 0x23, 0xf2, 0x8b, 0x0, 0x3b, 0xfb, 0x97, 0x79,\n-\t\t0xa, 0xde, 0x9a, 0x4c, 0xc8, 0x2b, 0x8b, 0x2a, 0x81, 0x74,\n-\t\t0x7d, 0xde, 0xc0, 0x8b, 0x62, 0x96, 0xe5, 0x3a, 0x8, 0xc3,\n-\t\t0x31, 0x68, 0x7e, 0xf2, 0x5c, 0x4b, 0xf4, 0x93, 0x6b, 0xa1,\n-\t\t0xc0, 0xe6, 0x4, 0x1e, 0x9d, 0x15, 0x2, 0x3, 0x1, 0x0, 0x1,\n-\t\t0x2, 0x41, 0x0, 0x8a, 0xbd, 0x6a, 0x69, 0xf4, 0xd1, 0xa4,\n-\t\t0xb4, 0x87, 0xf0, 0xab, 0x8d, 0x7a, 0xae, 0xfd, 0x38, 0x60,\n-\t\t0x94, 0x5, 0xc9, 0x99, 0x98, 0x4e, 0x30, 0xf5, 0x67, 0xe1,\n-\t\t0xe8, 0xae, 0xef, 0xf4, 0x4e, 0x8b, 0x18, 0xbd, 0xb1, 0xec,\n-\t\t0x78, 0xdf, 0xa3, 0x1a, 0x55, 0xe3, 0x2a, 0x48, 0xd7, 0xfb,\n-\t\t0x13, 0x1f, 0x5a, 0xf1, 0xf4, 0x4d, 0x7d, 0x6b, 0x2c, 0xed,\n-\t\t0x2a, 0x9d, 0xf5, 0xe5, 0xae, 0x45, 0x35, 0x2, 0x21, 0x0,\n-\t\t0xda, 0xb2, 0xf1, 0x80, 0x48, 0xba, 0xa6, 0x8d, 0xe7, 0xdf,\n-\t\t0x4, 0xd2, 0xd3, 0x5d, 0x5d, 0x80, 0xe6, 0xe, 0x2d, 0xfa,\n-\t\t0x42, 0xd5, 0xa, 0x9b, 0x4, 0x21, 0x90, 0x32, 0x71, 0x5e,\n-\t\t0x46, 0xb3, 0x2, 0x21, 0x0, 0xd1, 0xf, 0x2e, 0x66, 0xb1,\n-\t\t0xd0, 0xc1, 0x3f, 0x10, 0xef, 0x99, 0x27, 0xbf, 0x53, 0x24,\n-\t\t0xa3, 0x79, 0xca, 0x21, 0x81, 0x46, 0xcb, 0xf9, 0xca, 0xfc,\n-\t\t0x79, 0x52, 0x21, 0xf1, 0x6a, 0x31, 0x17, 0x2, 0x20, 0x21,\n-\t\t0x2, 0x89, 0x79, 0x37, 0x81, 0x14, 0xca, 0xae, 0x88, 0xf7,\n-\t\t0xd, 0x6b, 0x61, 0xd8, 0x4f, 0x30, 0x6a, 0x4b, 0x7e, 0x4e,\n-\t\t0xc0, 0x21, 0x4d, 0xac, 0x9d, 0xf4, 0x49, 0xe8, 0xda, 0xb6,\n-\t\t0x9, 0x2, 0x20, 0x16, 0xb3, 0xec, 0x59, 0x10, 0xa4, 0x57,\n-\t\t0xe8, 0xe, 0x61, 0xc6, 0xa3, 0xf, 0x5e, 0xeb, 0x12, 0xa9,\n-\t\t0xae, 0x2e, 0xb7, 0x48, 0x45, 0xec, 0x69, 0x83, 0xc3, 0x75,\n-\t\t0xc, 0xe4, 0x97, 0xa0, 0x9f, 0x2, 0x20, 0x69, 0x52, 0xb4,\n-\t\t0x6, 0xe8, 0x50, 0x60, 0x71, 0x4c, 0x3a, 0xb7, 0x66, 0xba,\n-\t\t0xd, 0x8a, 0xc9, 0xb7, 0xd, 0xa3, 0x8, 0x6c, 0xa3, 0xf2,\n-\t\t0x62, 0xb0, 0x2a, 0x84, 0xaa, 0x2f, 0xd6, 0x1e, 0x55,\n+var privateKey2 = &Block{\n+\tType: \"RSA PRIVATE KEY\",\n+\tHeaders: map[string]string{\n+\t\t\"Proc-Type\":      \"4,ENCRYPTED\",\n+\t\t\"DEK-Info\":       \"AES-128-CBC,BFCD243FEDBB40A4AA6DDAA1335473A4\",\n+\t\t\"Content-Domain\": \"RFC822\",\n+\t},\n+\tBytes: []uint8{\n+\t\t0xa8, 0x35, 0xcc, 0x2b, 0xb9, 0xcb, 0x21, 0xab, 0xc0,\n+\t\t0x9d, 0x76, 0x61, 0x0, 0xf4, 0x81, 0xad, 0x69, 0xd2,\n+\t\t0xc0, 0x42, 0x41, 0x3b, 0xe4, 0x3c, 0xaf, 0x59, 0x5e,\n+\t\t0x6d, 0x2a, 0x3c, 0x9c, 0xa1, 0xa4, 0x5e, 0x68, 0x37,\n+\t\t0xc4, 0x8c, 0x70, 0x1c, 0xa9, 0x18, 0xe6, 0xc2, 0x2b,\n+\t\t0x8a, 0x91, 0xdc, 0x2d, 0x1f, 0x8, 0x23, 0x39, 0xf1,\n+\t\t0x4b, 0x8b, 0x1b, 0x2f, 0x46, 0xb, 0xb2, 0x26, 0xba,\n+\t\t0x4f, 0x40, 0x80, 0x39, 0xc4, 0xb1, 0xcb, 0x3b, 0xb4,\n+\t\t0x65, 0x3f, 0x1b, 0xb2, 0xf7, 0x8, 0xd2, 0xc6, 0xd5,\n+\t\t0xa8, 0x9f, 0x23, 0x69, 0xb6, 0x3d, 0xf9, 0xac, 0x1c,\n+\t\t0xb3, 0x13, 0x87, 0x64, 0x4, 0x37, 0xdb, 0x40, 0xc8,\n+\t\t0x82, 0xc, 0xd0, 0xf8, 0x21, 0x7c, 0xdc, 0xbd, 0x9, 0x4,\n+\t\t0x20, 0x16, 0xb0, 0x97, 0xe2, 0x6d, 0x56, 0x1d, 0xe3,\n+\t\t0xec, 0xf0, 0xfc, 0xe2, 0x56, 0xad, 0xa4, 0x3, 0x70,\n+\t\t0x6d, 0x63, 0x3c, 0x1, 0xbe, 0x3e, 0x28, 0x38, 0x6f,\n+\t\t0xc0, 0xe6, 0xfd, 0x85, 0xd1, 0x53, 0xa8, 0x9b, 0xcb,\n+\t\t0xd4, 0x4, 0xb1, 0x73, 0xb9, 0x73, 0x32, 0xd6, 0x7a,\n+\t\t0xc6, 0x29, 0x25, 0xa5, 0xda, 0x17, 0x93, 0x7a, 0x10,\n+\t\t0xe8, 0x41, 0xfb, 0xa5, 0x17, 0x20, 0xf8, 0x4e, 0xe9,\n+\t\t0xe3, 0x8f, 0x51, 0x20, 0x13, 0xbb, 0xde, 0xb7, 0x93,\n+\t\t0xae, 0x13, 0x8a, 0xf6, 0x9, 0xf4, 0xa6, 0x41, 0xe0,\n+\t\t0x2b, 0x51, 0x1a, 0x30, 0x38, 0xd, 0xb1, 0x3b, 0x67,\n+\t\t0x87, 0x64, 0xf5, 0xca, 0x32, 0x67, 0xd1, 0xc8, 0xa5,\n+\t\t0x3d, 0x23, 0x72, 0xc4, 0x6, 0xaf, 0x8f, 0x7b, 0x26,\n+\t\t0xac, 0x3c, 0x75, 0x91, 0xa1, 0x0, 0x13, 0xc6, 0x5c,\n+\t\t0x49, 0xd5, 0x3c, 0xe7, 0xb2, 0xb2, 0x99, 0xe0, 0xd5,\n+\t\t0x25, 0xfa, 0xe2, 0x12, 0x80, 0x37, 0x85, 0xcf, 0x92,\n+\t\t0xca, 0x1b, 0x9f, 0xf3, 0x4e, 0xd8, 0x80, 0xef, 0x3c,\n+\t\t0xce, 0xcd, 0xf5, 0x90, 0x9e, 0xf9, 0xa7, 0xb2, 0xc,\n+\t\t0x49, 0x4, 0xf1, 0x9, 0x8f, 0xea, 0x63, 0xd2, 0x70,\n+\t\t0xbb, 0x86, 0xbf, 0x34, 0xab, 0xb2, 0x3, 0xb1, 0x59,\n+\t\t0x33, 0x16, 0x17, 0xb0, 0xdb, 0x77, 0x38, 0xf4, 0xb4,\n+\t\t0x94, 0xb, 0x25, 0x16, 0x7e, 0x22, 0xd4, 0xf9, 0x22,\n+\t\t0xb9, 0x78, 0xa3, 0x4, 0x84, 0x4, 0xd2, 0xda, 0x84,\n+\t\t0x2d, 0x63, 0xdd, 0xf8, 0x50, 0x6a, 0xf6, 0xe3, 0xf5,\n+\t\t0x65, 0x40, 0x7c, 0xa9,\n \t},\n }\n \n-var pemPrivateKey = `-----BEGIN RSA PRIVATE KEY-----\n-MIIBOgIBAAJBALKZD0nEffqM1ACuak0bijtqE2QrI/KLADv7l3kK3ppMyCuLKoF0\n-fd7Ai2KW5ToIwzFofvJcS/STa6HA5gQenRUCAwEAAQJBAIq9amn00aS0h/CrjXqu\n-/ThglAXJmZhOMPVn4eiu7/ROixi9sex436MaVeMqSNf7Ex9a8fRNfWss7Sqd9eWu\n-RTUCIQDasvGASLqmjeffBNLTXV2A5g4t+kLVCpsEIZAycV5GswIhANEPLmax0ME/\n-EO+ZJ79TJKN5yiGBRsv5yvx5UiHxajEXAiAhAol5N4EUyq6I9w1rYdhPMGpLfk7A\n-IU2snfRJ6Nq2CQIgFrPsWRCkV+gOYcajD17rEqmuLrdIRexpg8N1DOSXoJ8CIGlS\n-tAboUGBxTDq3ZroNism3DaMIbKPyYrAqhKov1h5V\n+var pemPrivateKey2 = `-----BEGIN RSA PRIVATE KEY-----\n+Proc-Type: 4,ENCRYPTED\n+Content-Domain: RFC822\n+DEK-Info: AES-128-CBC,BFCD243FEDBB40A4AA6DDAA1335473A4\n+\n+qDXMK7nLIavAnXZhAPSBrWnSwEJBO+Q8r1lebSo8nKGkXmg3xIxwHKkY5sIripHc\n+LR8IIznxS4sbL0YLsia6T0CAOcSxyzu0ZT8bsvcI0sbVqJ8jabY9+awcsxOHZAQ3\n+20DIggzQ+CF83L0JBCAWsJfibVYd4+zw/OJWraQDcG1jPAG+Pig4b8Dm/YXRU6ib\n+y9QEsXO5czLWesYpJaXaF5N6EOhB+6UXIPhO6eOPUSATu963k64TivYJ9KZB4CtR\n+GjA4DbE7Z4dk9coyZ9HIpT0jcsQGr497Jqw8dZGhABPGXEnVPOeyspng1SX64hKA\n+N4XPksobn/NO2IDvPM7N9ZCe+aeyDEkE8QmP6mPScLuGvzSrsgOxWTMWF7Dbdzj0\n+tJQLJRZ+ItT5Irl4owSEBNLahC1j3fhQavbj9WVAfKk=\n -----END RSA PRIVATE KEY-----\n `"}, {"sha": "668fea6f85e5e5877aa270755e68858cf376ca7b", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -687,6 +687,27 @@ var marshalTests = []struct {\n \t\tValue:         &IgnoreTest{},\n \t\tUnmarshalOnly: true,\n \t},\n+\n+\t// Test escaping.\n+\t{\n+\t\tExpectXML: `<a><nested><value>dquote: &#34;; squote: &#39;; ampersand: &amp;; less: &lt;; greater: &gt;;</value></nested></a>`,\n+\t\tValue: &AnyTest{\n+\t\t\tNested: `dquote: \"; squote: '; ampersand: &; less: <; greater: >;`,\n+\t\t},\n+\t},\n+\t{\n+\t\tExpectXML: `<a><nested><value>newline: &#xA;; cr: &#xD;; tab: &#x9;;</value></nested></a>`,\n+\t\tValue: &AnyTest{\n+\t\t\tNested: \"newline: \\n; cr: \\r; tab: \\t;\",\n+\t\t},\n+\t},\n+\t{\n+\t\tExpectXML: \"<a><nested><value>1\\r2\\r\\n3\\n\\r4\\n5</value></nested></a>\",\n+\t\tValue: &AnyTest{\n+\t\t\tNested: \"1\\n2\\n3\\n\\n4\\n5\",\n+\t\t},\n+\t\tUnmarshalOnly: true,\n+\t},\n }\n \n func TestMarshal(t *testing.T) {"}, {"sha": "decb2bec65047091bcafe7e47002c540e914766f", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 139, "deletions": 104, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -181,7 +181,6 @@ type Decoder struct {\n \tns        map[string]string\n \terr       error\n \tline      int\n-\ttmp       [32]byte\n }\n \n // NewDecoder creates a new XML parser reading from r.\n@@ -877,94 +876,103 @@ Input:\n \t\t\t// XML in all its glory allows a document to define and use\n \t\t\t// its own character names with <!ENTITY ...> directives.\n \t\t\t// Parsers are required to recognize lt, gt, amp, apos, and quot\n-\t\t\t// even if they have not been declared.  That's all we allow.\n-\t\t\tvar i int\n-\t\t\tvar semicolon bool\n-\t\t\tvar valid bool\n-\t\t\tfor i = 0; i < len(d.tmp); i++ {\n-\t\t\t\tvar ok bool\n-\t\t\t\td.tmp[i], ok = d.getc()\n-\t\t\t\tif !ok {\n-\t\t\t\t\tif d.err == io.EOF {\n-\t\t\t\t\t\td.err = d.syntaxError(\"unexpected EOF\")\n-\t\t\t\t\t}\n+\t\t\t// even if they have not been declared.\n+\t\t\tbefore := d.buf.Len()\n+\t\t\td.buf.WriteByte('&')\n+\t\t\tvar ok bool\n+\t\t\tvar text string\n+\t\t\tvar haveText bool\n+\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif b == '#' {\n+\t\t\t\td.buf.WriteByte(b)\n+\t\t\t\tif b, ok = d.mustgetc(); !ok {\n \t\t\t\t\treturn nil\n \t\t\t\t}\n-\t\t\t\tc := d.tmp[i]\n-\t\t\t\tif c == ';' {\n-\t\t\t\t\tsemicolon = true\n-\t\t\t\t\tvalid = i > 0\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tif 'a' <= c && c <= 'z' ||\n-\t\t\t\t\t'A' <= c && c <= 'Z' ||\n-\t\t\t\t\t'0' <= c && c <= '9' ||\n-\t\t\t\t\tc == '_' || c == '#' {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\td.ungetc(c)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\ts := string(d.tmp[0:i])\n-\t\t\tif !valid {\n-\t\t\t\tif !d.Strict {\n-\t\t\t\t\tb0, b1 = 0, 0\n-\t\t\t\t\td.buf.WriteByte('&')\n-\t\t\t\t\td.buf.Write(d.tmp[0:i])\n-\t\t\t\t\tif semicolon {\n-\t\t\t\t\t\td.buf.WriteByte(';')\n+\t\t\t\tbase := 10\n+\t\t\t\tif b == 'x' {\n+\t\t\t\t\tbase = 16\n+\t\t\t\t\td.buf.WriteByte(b)\n+\t\t\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\t\t\treturn nil\n \t\t\t\t\t}\n-\t\t\t\t\tcontinue Input\n \t\t\t\t}\n-\t\t\t\tsemi := \";\"\n-\t\t\t\tif !semicolon {\n-\t\t\t\t\tsemi = \" (no semicolon)\"\n-\t\t\t\t}\n-\t\t\t\tif i < len(d.tmp) {\n-\t\t\t\t\td.err = d.syntaxError(\"invalid character entity &\" + s + semi)\n-\t\t\t\t} else {\n-\t\t\t\t\td.err = d.syntaxError(\"invalid character entity &\" + s + \"... too long\")\n+\t\t\t\tstart := d.buf.Len()\n+\t\t\t\tfor '0' <= b && b <= '9' ||\n+\t\t\t\t\tbase == 16 && 'a' <= b && b <= 'f' ||\n+\t\t\t\t\tbase == 16 && 'A' <= b && b <= 'F' {\n+\t\t\t\t\td.buf.WriteByte(b)\n+\t\t\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\t\t\treturn nil\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tvar haveText bool\n-\t\t\tvar text string\n-\t\t\tif i >= 2 && s[0] == '#' {\n-\t\t\t\tvar n uint64\n-\t\t\t\tvar err error\n-\t\t\t\tif i >= 3 && s[1] == 'x' {\n-\t\t\t\t\tn, err = strconv.ParseUint(s[2:], 16, 64)\n+\t\t\t\tif b != ';' {\n+\t\t\t\t\td.ungetc(b)\n \t\t\t\t} else {\n-\t\t\t\t\tn, err = strconv.ParseUint(s[1:], 10, 64)\n-\t\t\t\t}\n-\t\t\t\tif err == nil && n <= unicode.MaxRune {\n-\t\t\t\t\ttext = string(n)\n-\t\t\t\t\thaveText = true\n+\t\t\t\t\ts := string(d.buf.Bytes()[start:])\n+\t\t\t\t\td.buf.WriteByte(';')\n+\t\t\t\t\tn, err := strconv.ParseUint(s, base, 64)\n+\t\t\t\t\tif err == nil && n <= unicode.MaxRune {\n+\t\t\t\t\t\ttext = string(n)\n+\t\t\t\t\t\thaveText = true\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tif r, ok := entity[s]; ok {\n-\t\t\t\t\ttext = string(r)\n-\t\t\t\t\thaveText = true\n-\t\t\t\t} else if d.Entity != nil {\n-\t\t\t\t\ttext, haveText = d.Entity[s]\n+\t\t\t\td.ungetc(b)\n+\t\t\t\tif !d.readName() {\n+\t\t\t\t\tif d.err != nil {\n+\t\t\t\t\t\treturn nil\n+\t\t\t\t\t}\n+\t\t\t\t\tok = false\n \t\t\t\t}\n-\t\t\t}\n-\t\t\tif !haveText {\n-\t\t\t\tif !d.Strict {\n-\t\t\t\t\tb0, b1 = 0, 0\n-\t\t\t\t\td.buf.WriteByte('&')\n-\t\t\t\t\td.buf.Write(d.tmp[0:i])\n+\t\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\tif b != ';' {\n+\t\t\t\t\td.ungetc(b)\n+\t\t\t\t} else {\n+\t\t\t\t\tname := d.buf.Bytes()[before+1:]\n \t\t\t\t\td.buf.WriteByte(';')\n-\t\t\t\t\tcontinue Input\n+\t\t\t\t\tif isName(name) {\n+\t\t\t\t\t\ts := string(name)\n+\t\t\t\t\t\tif r, ok := entity[s]; ok {\n+\t\t\t\t\t\t\ttext = string(r)\n+\t\t\t\t\t\t\thaveText = true\n+\t\t\t\t\t\t} else if d.Entity != nil {\n+\t\t\t\t\t\t\ttext, haveText = d.Entity[s]\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\td.err = d.syntaxError(\"invalid character entity &\" + s + \";\")\n-\t\t\t\treturn nil\n \t\t\t}\n-\t\t\td.buf.Write([]byte(text))\n-\t\t\tb0, b1 = 0, 0\n-\t\t\tcontinue Input\n+\n+\t\t\tif haveText {\n+\t\t\t\td.buf.Truncate(before)\n+\t\t\t\td.buf.Write([]byte(text))\n+\t\t\t\tb0, b1 = 0, 0\n+\t\t\t\tcontinue Input\n+\t\t\t}\n+\t\t\tif !d.Strict {\n+\t\t\t\tb0, b1 = 0, 0\n+\t\t\t\tcontinue Input\n+\t\t\t}\n+\t\t\tent := string(d.buf.Bytes()[before])\n+\t\t\tif ent[len(ent)-1] != ';' {\n+\t\t\t\tent += \" (no semicolon)\"\n+\t\t\t}\n+\t\t\td.err = d.syntaxError(\"invalid character entity \" + ent)\n+\t\t\treturn nil\n \t\t}\n-\t\td.buf.WriteByte(b)\n+\n+\t\t// We must rewrite unescaped \\r and \\r\\n into \\n.\n+\t\tif b == '\\r' {\n+\t\t\td.buf.WriteByte('\\n')\n+\t\t} else if b1 == '\\r' && b == '\\n' {\n+\t\t\t// Skip \\r\\n--we already wrote \\n.\n+\t\t} else {\n+\t\t\td.buf.WriteByte(b)\n+\t\t}\n+\n \t\tb0, b1 = b1, b\n \t}\n \tdata := d.buf.Bytes()\n@@ -985,20 +993,7 @@ Input:\n \t\t}\n \t}\n \n-\t// Must rewrite \\r and \\r\\n into \\n.\n-\tw := 0\n-\tfor r := 0; r < len(data); r++ {\n-\t\tb := data[r]\n-\t\tif b == '\\r' {\n-\t\t\tif r+1 < len(data) && data[r+1] == '\\n' {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tb = '\\n'\n-\t\t}\n-\t\tdata[w] = b\n-\t\tw++\n-\t}\n-\treturn data[0:w]\n+\treturn data\n }\n \n // Decide whether the given rune is in the XML Character Range, per\n@@ -1034,18 +1029,34 @@ func (d *Decoder) nsname() (name Name, ok bool) {\n // Do not set d.err if the name is missing (unless unexpected EOF is received):\n // let the caller provide better context.\n func (d *Decoder) name() (s string, ok bool) {\n+\td.buf.Reset()\n+\tif !d.readName() {\n+\t\treturn \"\", false\n+\t}\n+\n+\t// Now we check the characters.\n+\ts = d.buf.String()\n+\tif !isName([]byte(s)) {\n+\t\td.err = d.syntaxError(\"invalid XML name: \" + s)\n+\t\treturn \"\", false\n+\t}\n+\treturn s, true\n+}\n+\n+// Read a name and append its bytes to d.buf.\n+// The name is delimited by any single-byte character not valid in names.\n+// All multi-byte characters are accepted; the caller must check their validity.\n+func (d *Decoder) readName() (ok bool) {\n \tvar b byte\n \tif b, ok = d.mustgetc(); !ok {\n \t\treturn\n \t}\n-\n-\t// As a first approximation, we gather the bytes [A-Za-z_:.-\\x80-\\xFF]*\n \tif b < utf8.RuneSelf && !isNameByte(b) {\n \t\td.ungetc(b)\n-\t\treturn \"\", false\n+\t\treturn false\n \t}\n-\td.buf.Reset()\n \td.buf.WriteByte(b)\n+\n \tfor {\n \t\tif b, ok = d.mustgetc(); !ok {\n \t\t\treturn\n@@ -1056,16 +1067,7 @@ func (d *Decoder) name() (s string, ok bool) {\n \t\t}\n \t\td.buf.WriteByte(b)\n \t}\n-\n-\t// Then we check the characters.\n-\ts = d.buf.String()\n-\tfor i, c := range s {\n-\t\tif !unicode.Is(first, c) && (i == 0 || !unicode.Is(second, c)) {\n-\t\t\td.err = d.syntaxError(\"invalid XML name: \" + s)\n-\t\t\treturn \"\", false\n-\t\t}\n-\t}\n-\treturn s, true\n+\treturn true\n }\n \n func isNameByte(c byte) bool {\n@@ -1075,6 +1077,30 @@ func isNameByte(c byte) bool {\n \t\tc == '_' || c == ':' || c == '.' || c == '-'\n }\n \n+func isName(s []byte) bool {\n+\tif len(s) == 0 {\n+\t\treturn false\n+\t}\n+\tc, n := utf8.DecodeRune(s)\n+\tif c == utf8.RuneError && n == 1 {\n+\t\treturn false\n+\t}\n+\tif !unicode.Is(first, c) {\n+\t\treturn false\n+\t}\n+\tfor n < len(s) {\n+\t\ts = s[n:]\n+\t\tc, n = utf8.DecodeRune(s)\n+\t\tif c == utf8.RuneError && n == 1 {\n+\t\t\treturn false\n+\t\t}\n+\t\tif !unicode.Is(first, c) && !unicode.Is(second, c) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // These tables were generated by cut and paste from Appendix B of\n // the XML spec at http://www.xml.com/axml/testaxml.htm\n // and then reformatting.  First corresponds to (Letter | '_' | ':')\n@@ -1689,6 +1715,9 @@ var (\n \tesc_amp  = []byte(\"&amp;\")\n \tesc_lt   = []byte(\"&lt;\")\n \tesc_gt   = []byte(\"&gt;\")\n+\tesc_tab  = []byte(\"&#x9;\")\n+\tesc_nl   = []byte(\"&#xA;\")\n+\tesc_cr   = []byte(\"&#xD;\")\n )\n \n // Escape writes to w the properly escaped XML equivalent\n@@ -1708,6 +1737,12 @@ func Escape(w io.Writer, s []byte) {\n \t\t\tesc = esc_lt\n \t\tcase '>':\n \t\t\tesc = esc_gt\n+\t\tcase '\\t':\n+\t\t\tesc = esc_tab\n+\t\tcase '\\n':\n+\t\t\tesc = esc_nl\n+\t\tcase '\\r':\n+\t\t\tesc = esc_cr\n \t\tdefault:\n \t\t\tcontinue\n \t\t}"}, {"sha": "981d3520313d18b01b0e11476748630cdca66215", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -19,6 +19,7 @@ const testInput = `\n <body xmlns:foo=\"ns1\" xmlns=\"ns2\" xmlns:tag=\"ns3\" ` +\n \t\"\\r\\n\\t\" + `  >\n   <hello lang=\"en\">World &lt;&gt;&apos;&quot; &#x767d;&#40300;\u7fd4</hello>\n+  <query>&\u4f55; &is-it;</query>\n   <goodbye />\n   <outer foo:attr=\"value\" xmlns:tag=\"ns4\">\n     <inner/>\n@@ -28,6 +29,8 @@ const testInput = `\n   </tag:name>\n </body><!-- missing final newline -->`\n \n+var testEntity = map[string]string{\"\u4f55\": \"What\", \"is-it\": \"is it?\"}\n+\n var rawTokens = []Token{\n \tCharData(\"\\n\"),\n \tProcInst{\"xml\", []byte(`version=\"1.0\" encoding=\"UTF-8\"`)},\n@@ -41,6 +44,10 @@ var rawTokens = []Token{\n \tCharData(\"World <>'\\\" \u767d\u9d6c\u7fd4\"),\n \tEndElement{Name{\"\", \"hello\"}},\n \tCharData(\"\\n  \"),\n+\tStartElement{Name{\"\", \"query\"}, []Attr{}},\n+\tCharData(\"What is it?\"),\n+\tEndElement{Name{\"\", \"query\"}},\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"\", \"goodbye\"}, []Attr{}},\n \tEndElement{Name{\"\", \"goodbye\"}},\n \tCharData(\"\\n  \"),\n@@ -74,6 +81,10 @@ var cookedTokens = []Token{\n \tCharData(\"World <>'\\\" \u767d\u9d6c\u7fd4\"),\n \tEndElement{Name{\"ns2\", \"hello\"}},\n \tCharData(\"\\n  \"),\n+\tStartElement{Name{\"ns2\", \"query\"}, []Attr{}},\n+\tCharData(\"What is it?\"),\n+\tEndElement{Name{\"ns2\", \"query\"}},\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"ns2\", \"goodbye\"}, []Attr{}},\n \tEndElement{Name{\"ns2\", \"goodbye\"}},\n \tCharData(\"\\n  \"),\n@@ -156,6 +167,7 @@ var xmlInput = []string{\n \n func TestRawToken(t *testing.T) {\n \td := NewDecoder(strings.NewReader(testInput))\n+\td.Entity = testEntity\n \ttestRawToken(t, d, rawTokens)\n }\n \n@@ -164,8 +176,14 @@ const nonStrictInput = `\n <tag>&unknown;entity</tag>\n <tag>&#123</tag>\n <tag>&#zzz;</tag>\n+<tag>&\u306a\u307e\u30483;</tag>\n+<tag>&lt-gt;</tag>\n+<tag>&;</tag>\n+<tag>&0a;</tag>\n `\n \n+var nonStringEntity = map[string]string{\"\": \"oops!\", \"0a\": \"oops!\"}\n+\n var nonStrictTokens = []Token{\n \tCharData(\"\\n\"),\n \tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n@@ -184,6 +202,22 @@ var nonStrictTokens = []Token{\n \tCharData(\"&#zzz;\"),\n \tEndElement{Name{\"\", \"tag\"}},\n \tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"&\u306a\u307e\u30483;\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"&lt-gt;\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"&;\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n+\tCharData(\"&0a;\"),\n+\tEndElement{Name{\"\", \"tag\"}},\n+\tCharData(\"\\n\"),\n }\n \n func TestNonStrictRawToken(t *testing.T) {\n@@ -317,6 +351,7 @@ func TestNestedDirectives(t *testing.T) {\n \n func TestToken(t *testing.T) {\n \td := NewDecoder(strings.NewReader(testInput))\n+\td.Entity = testEntity\n \n \tfor i, want := range cookedTokens {\n \t\thave, err := d.Token()"}, {"sha": "fc0bdb44ed838535db174510ff8891c280d195d5", "filename": "libgo/go/exp/gotype/gotype.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -176,8 +176,7 @@ func processPackage(fset *token.FileSet, files map[string]*ast.File) {\n \t\treport(err)\n \t\treturn\n \t}\n-\t_, err = types.Check(fset, pkg)\n-\tif err != nil {\n+\tif err = types.Check(fset, pkg, nil, nil); err != nil {\n \t\treport(err)\n \t}\n }"}, {"sha": "42d716d81f97f864b7ebb8c591e0a9d64b8d82a4", "filename": "libgo/go/exp/gotype/gotype_test.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -35,10 +35,12 @@ var tests = []struct {\n \n \t// directories\n \t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/ast\"), \"ast\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/build\"), \"build\"},\n \t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/doc\"), \"doc\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/token\"), \"scanner\"},\n-\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/scanner\"), \"scanner\"},\n \t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/parser\"), \"parser\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/printer\"), \"printer\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/scanner\"), \"scanner\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/token\"), \"token\"},\n \t{filepath.Join(runtime.GOROOT(), \"src/pkg/exp/types\"), \"types\"},\n }\n "}, {"sha": "c484e5a94fbf0a38b9c1789356f9f152ccaec4d2", "filename": "libgo/go/exp/html/doctype.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Fdoctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Fdoctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fdoctype.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -9,7 +9,7 @@ import (\n )\n \n // parseDoctype parses the data from a DoctypeToken into a name,\n-// public identifier, and system identifier. It returns a Node whose Type \n+// public identifier, and system identifier. It returns a Node whose Type\n // is DoctypeNode, whose Data is the name, and which has attributes\n // named \"system\" and \"public\" for the two identifiers if they were present.\n // quirks is whether the document should be parsed in \"quirks mode\"."}, {"sha": "75bddff094f3cb70e1cc0c7936ebdd458612e422", "filename": "libgo/go/exp/html/escape.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// These replacements permit compatibility with old numeric entities that \n+// These replacements permit compatibility with old numeric entities that\n // assumed Windows-1252 encoding.\n // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#consume-a-character-reference\n var replacementTable = [...]rune{\n@@ -46,7 +46,7 @@ var replacementTable = [...]rune{\n \t'\\u009D',\n \t'\\u017E',\n \t'\\u0178', // Last entry is 0x9F.\n-\t// 0x00->'\\uFFFD' is handled programmatically. \n+\t// 0x00->'\\uFFFD' is handled programmatically.\n \t// 0x0D->'\\u000D' is a no-op.\n }\n "}, {"sha": "0ff15746f2189570df063ec8482e5837e356960d", "filename": "libgo/go/exp/html/parse.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -2027,7 +2027,7 @@ func Parse(r io.Reader) (*Node, error) {\n \treturn p.doc, nil\n }\n \n-// ParseFragment parses a fragment of HTML and returns the nodes that were \n+// ParseFragment parses a fragment of HTML and returns the nodes that were\n // found. If the fragment is the InnerHTML for an existing element, pass that\n // element in context.\n func ParseFragment(r io.Reader, context *Node) ([]*Node, error) {"}, {"sha": "285dbc926e4ae65ffb7e89e1a0d1d42d3a481cf0", "filename": "libgo/go/exp/html/render.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -35,7 +35,7 @@ type writer interface {\n // children; the <a> is reparented to the <table>'s parent. However, calling\n // Parse on \"<a><table><a>\" does not return an error, but the result has an <a>\n // element with an <a> child, and is therefore not 'well-formed'.\n-// \n+//\n // Programmatically constructed trees are typically also 'well-formed', but it\n // is possible to construct a tree that looks innocuous but, when rendered and\n // re-parsed, results in a different tree. A simple example is that a solitary\n@@ -53,7 +53,7 @@ func Render(w io.Writer, n *Node) error {\n \treturn buf.Flush()\n }\n \n-// plaintextAbort is returned from render1 when a <plaintext> element \n+// plaintextAbort is returned from render1 when a <plaintext> element\n // has been rendered. No more end tags should be rendered after that.\n var plaintextAbort = errors.New(\"html: internal error (plaintext abort)\")\n "}, {"sha": "f9a087b02d9e7e83b57412098bb8934b4b27ce09", "filename": "libgo/go/exp/html/token.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -320,7 +320,7 @@ loop:\n }\n \n // readRawEndTag attempts to read a tag like \"</foo>\", where \"foo\" is z.rawTag.\n-// If it succeeds, it backs up the input position to reconsume the tag and \n+// If it succeeds, it backs up the input position to reconsume the tag and\n // returns true. Otherwise it returns false. The opening \"</\" has already been\n // consumed.\n func (z *Tokenizer) readRawEndTag() bool {"}, {"sha": "85436cf6ec19f9dad40d5606731c946ec9e201f4", "filename": "libgo/go/exp/locale/collate/build/builder.go", "status": "modified", "additions": 162, "deletions": 15, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fbuilder.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -25,7 +25,7 @@ import (\n //   compacted.\n // - Compress secondary weights into 8 bits.\n // - Some LDML specs specify a context element. Currently we simply concatenate\n-//   those.  Context can be implemented using the contraction trie. If Builder \n+//   those.  Context can be implemented using the contraction trie. If Builder\n //   could analyze and detect when using a context makes sense, there is no\n //   need to expose this construct in the API.\n \n@@ -58,7 +58,9 @@ type Tailoring struct {\n \tid      string\n \tbuilder *Builder\n \tindex   *ordering\n-\t// TODO: implement.\n+\n+\tanchor *entry\n+\tbefore bool\n }\n \n // NewBuilder returns a new Builder.\n@@ -72,19 +74,20 @@ func NewBuilder() *Builder {\n \t}\n }\n \n-// Tailoring returns a Tailoring for the given locale.  One should \n+// Tailoring returns a Tailoring for the given locale.  One should\n // have completed all calls to Add before calling Tailoring.\n func (b *Builder) Tailoring(locale string) *Tailoring {\n \tt := &Tailoring{\n \t\tid:      locale,\n \t\tbuilder: b,\n \t\tindex:   b.root.clone(),\n \t}\n+\tt.index.id = t.id\n \tb.locale = append(b.locale, t)\n \treturn t\n }\n \n-// Add adds an entry to the collation element table, mapping \n+// Add adds an entry to the collation element table, mapping\n // a slice of runes to a sequence of collation elements.\n // A collation element is specified as list of weights: []int{primary, secondary, ...}.\n // The entries are typically obtained from a collation element table\n@@ -95,7 +98,6 @@ func (b *Builder) Tailoring(locale string) *Tailoring {\n // a value for each colelem that is a variable. (See the reference above.)\n func (b *Builder) Add(runes []rune, colelems [][]int, variables []int) error {\n \tstr := string(runes)\n-\n \telems := make([][]int, len(colelems))\n \tfor i, ce := range colelems {\n \t\telems[i] = append(elems[i], ce...)\n@@ -127,7 +129,7 @@ func (b *Builder) Add(runes []rune, colelems [][]int, variables []int) error {\n \t\t\tif ce[0] > b.varTop {\n \t\t\t\tb.varTop = ce[0]\n \t\t\t}\n-\t\t} else if ce[0] > 0 {\n+\t\t} else if ce[0] > 1 { // 1 is a special primary value reserved for FFFE\n \t\t\tif ce[0] <= b.varTop {\n \t\t\t\treturn fmt.Errorf(\"primary value %X of non-variable is smaller than the highest variable %X\", ce[0], b.varTop)\n \t\t\t}\n@@ -144,21 +146,42 @@ func (b *Builder) Add(runes []rune, colelems [][]int, variables []int) error {\n \treturn nil\n }\n \n+func (t *Tailoring) setAnchor(anchor string) error {\n+\tanchor = norm.NFD.String(anchor)\n+\ta := t.index.find(anchor)\n+\tif a == nil {\n+\t\ta = t.index.newEntry(anchor, nil)\n+\t\ta.implicit = true\n+\t\tfor _, r := range []rune(anchor) {\n+\t\t\te := t.index.find(string(r))\n+\t\t\te.lock = true\n+\t\t}\n+\t}\n+\tt.anchor = a\n+\treturn nil\n+}\n+\n // SetAnchor sets the point after which elements passed in subsequent calls to\n // Insert will be inserted.  It is equivalent to the reset directive in an LDML\n // specification.  See Insert for an example.\n // SetAnchor supports the following logical reset positions:\n // <first_tertiary_ignorable/>, <last_teriary_ignorable/>, <first_primary_ignorable/>,\n // and <last_non_ignorable/>.\n func (t *Tailoring) SetAnchor(anchor string) error {\n-\t// TODO: implement.\n+\tif err := t.setAnchor(anchor); err != nil {\n+\t\treturn err\n+\t}\n+\tt.before = false\n \treturn nil\n }\n \n // SetAnchorBefore is similar to SetAnchor, except that subsequent calls to\n // Insert will insert entries before the anchor.\n func (t *Tailoring) SetAnchorBefore(anchor string) error {\n-\t// TODO: implement.\n+\tif err := t.setAnchor(anchor); err != nil {\n+\t\treturn err\n+\t}\n+\tt.before = true\n \treturn nil\n }\n \n@@ -171,7 +194,7 @@ func (t *Tailoring) SetAnchorBefore(anchor string) error {\n // See http://www.unicode.org/reports/tr10/#Tailoring_Example for details\n // on parametric tailoring and http://unicode.org/reports/tr35/#Collation_Elements\n // for full details on LDML.\n-// \n+//\n // Examples: create a tailoring for Swedish, where \"\u00e4\" is ordered after \"z\"\n // at the primary sorting level:\n //      t := b.Tailoring(\"se\")\n@@ -195,7 +218,112 @@ func (t *Tailoring) SetAnchorBefore(anchor string) error {\n //      t.SetAnchor(\"<last_primary_ignorable/>\")\n //      t.Insert(collate.Primary, \"0\", \"\")\n func (t *Tailoring) Insert(level collate.Level, str, extend string) error {\n-\t// TODO: implement.\n+\tif t.anchor == nil {\n+\t\treturn fmt.Errorf(\"%s:Insert: no anchor point set for tailoring of %s\", t.id, str)\n+\t}\n+\tstr = norm.NFD.String(str)\n+\te := t.index.find(str)\n+\tif e == nil {\n+\t\te = t.index.newEntry(str, nil)\n+\t} else if e.logical != noAnchor {\n+\t\treturn fmt.Errorf(\"%s:Insert: cannot reinsert logical reset position %q\", t.id, e.str)\n+\t}\n+\tif e.lock {\n+\t\treturn fmt.Errorf(\"%s:Insert: cannot reinsert element %q\", t.id, e.str)\n+\t}\n+\ta := t.anchor\n+\t// Find the first element after the anchor which differs at a level smaller or\n+\t// equal to the given level.  Then insert at this position.\n+\t// See http://unicode.org/reports/tr35/#Collation_Elements, Section 5.14.5 for details.\n+\te.before = t.before\n+\tif t.before {\n+\t\tt.before = false\n+\t\tif a.prev == nil {\n+\t\t\ta.insertBefore(e)\n+\t\t} else {\n+\t\t\tfor a = a.prev; a.level > level; a = a.prev {\n+\t\t\t}\n+\t\t\ta.insertAfter(e)\n+\t\t}\n+\t\te.level = level\n+\t} else {\n+\t\tfor ; a.level > level; a = a.next {\n+\t\t}\n+\t\te.level = a.level\n+\t\tif a != e {\n+\t\t\ta.insertAfter(e)\n+\t\t\ta.level = level\n+\t\t} else {\n+\t\t\t// We don't set a to prev itself. This has the effect of the entry\n+\t\t\t// getting new collation elements that are an increment of itself.\n+\t\t\t// This is intentional.\n+\t\t\ta.prev.level = level\n+\t\t}\n+\t}\n+\te.extend = norm.NFD.String(extend)\n+\te.exclude = false\n+\te.elems = nil\n+\tt.anchor = e\n+\treturn nil\n+}\n+\n+func (o *ordering) getWeight(e *entry) [][]int {\n+\tif len(e.elems) == 0 && e.logical == noAnchor {\n+\t\tif e.implicit {\n+\t\t\tfor _, r := range e.runes {\n+\t\t\t\te.elems = append(e.elems, o.getWeight(o.find(string(r)))...)\n+\t\t\t}\n+\t\t} else if e.before {\n+\t\t\tcount := [collate.Identity + 1]int{}\n+\t\t\ta := e\n+\t\t\tfor ; a.elems == nil && !a.implicit; a = a.next {\n+\t\t\t\tcount[a.level]++\n+\t\t\t}\n+\t\t\te.elems = append([][]int(nil), make([]int, len(a.elems[0])))\n+\t\t\tcopy(e.elems[0], a.elems[0])\n+\t\t\tfor i := collate.Primary; i < collate.Quaternary; i++ {\n+\t\t\t\tif count[i] != 0 {\n+\t\t\t\t\te.elems[0][i] -= count[i]\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif e.prev != nil {\n+\t\t\t\to.verifyWeights(e.prev, e, e.prev.level)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tprev := e.prev\n+\t\t\te.elems = nextWeight(prev.level, o.getWeight(prev))\n+\t\t\to.verifyWeights(e, e.next, e.level)\n+\t\t}\n+\t}\n+\treturn e.elems\n+}\n+\n+func (o *ordering) addExtension(e *entry) {\n+\tif ex := o.find(e.extend); ex != nil {\n+\t\te.elems = append(e.elems, ex.elems...)\n+\t} else {\n+\t\tfor _, r := range []rune(e.extend) {\n+\t\t\te.elems = append(e.elems, o.find(string(r)).elems...)\n+\t\t}\n+\t}\n+\te.extend = \"\"\n+}\n+\n+func (o *ordering) verifyWeights(a, b *entry, level collate.Level) error {\n+\tif level == collate.Identity || b == nil || b.elems == nil || a.elems == nil {\n+\t\treturn nil\n+\t}\n+\tfor i := collate.Primary; i < level; i++ {\n+\t\tif a.elems[0][i] < b.elems[0][i] {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\tif a.elems[0][level] >= b.elems[0][level] {\n+\t\terr := fmt.Errorf(\"%s:overflow: collation elements of %q (%X) overflows those of %q (%X) at level %d (%X >= %X)\", o.id, a.str, a.runes, b.str, b.runes, level, a.elems, b.elems)\n+\t\tlog.Println(err)\n+\t\t// TODO: return the error instead, or better, fix the conflicting entry by making room.\n+\t}\n \treturn nil\n }\n \n@@ -205,7 +333,19 @@ func (b *Builder) error(e error) {\n \t}\n }\n \n+func (b *Builder) errorID(locale string, e error) {\n+\tif e != nil {\n+\t\tb.err = fmt.Errorf(\"%s:%v\", locale, e)\n+\t}\n+}\n+\n func (b *Builder) buildOrdering(o *ordering) {\n+\tfor _, e := range o.ordered {\n+\t\to.getWeight(e)\n+\t}\n+\tfor _, e := range o.ordered {\n+\t\to.addExtension(e)\n+\t}\n \to.sort()\n \tsimplify(o)\n \tb.processExpansions(o)   // requires simplify\n@@ -215,7 +355,7 @@ func (b *Builder) buildOrdering(o *ordering) {\n \tfor e := o.front(); e != nil; e, _ = e.nextIndexed() {\n \t\tif !e.skip() {\n \t\t\tce, err := e.encode()\n-\t\t\tb.error(err)\n+\t\t\tb.errorID(o.id, err)\n \t\t\tt.insert(e.runes[0], ce)\n \t\t}\n \t}\n@@ -252,7 +392,11 @@ func (b *Builder) Build() (*collate.Collator, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn collate.Init(t), nil\n+\tc := collate.Init(t)\n+\tif c == nil {\n+\t\tpanic(\"generated table of incompatible type\")\n+\t}\n+\treturn c, nil\n }\n \n // Build builds a Collator for Tailoring t.\n@@ -308,6 +452,10 @@ func reproducibleFromNFKD(e *entry, exp, nfkd [][]int) bool {\n \t\tif i >= 2 && ce[2] != maxTertiary {\n \t\t\treturn false\n \t\t}\n+\t\tif _, err := makeCE(ce); err != nil {\n+\t\t\t// Simply return false. The error will be caught elsewhere.\n+\t\t\treturn false\n+\t\t}\n \t}\n \treturn true\n }\n@@ -332,12 +480,11 @@ func simplify(o *ordering) {\n \t\t\te.remove()\n \t\t}\n \t}\n-\n \t// Tag entries for which the runes NFKD decompose to identical values.\n \tfor e := o.front(); e != nil; e, _ = e.nextIndexed() {\n \t\ts := e.str\n \t\tnfkd := norm.NFKD.String(s)\n-\t\tif len(e.runes) > 1 || keep[e.runes[0]] || nfkd == s {\n+\t\tif e.decompose || len(e.runes) > 1 || len(e.elems) == 1 || keep[e.runes[0]] || nfkd == s {\n \t\t\tcontinue\n \t\t}\n \t\tif reproducibleFromNFKD(e, e.elems, o.genColElems(nfkd)) {\n@@ -459,7 +606,7 @@ func (b *Builder) processContractions(o *ordering) {\n \t\telems := []uint32{}\n \t\tfor _, e := range es {\n \t\t\tce, err := e.encodeBase()\n-\t\t\tb.error(err)\n+\t\t\tb.errorID(o.id, err)\n \t\t\telems = append(elems, ce)\n \t\t}\n \t\tkey = fmt.Sprintf(\"%v\", elems)"}, {"sha": "bd4546f365cb50e9ba3d2a27a5a7182416936bec", "filename": "libgo/go/exp/locale/collate/build/colelem.go", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -26,7 +26,7 @@ const (\n // For normal collation elements, we assume that a collation element either has\n // a primary or non-default secondary value, not both.\n // Collation elements with a primary value are of the form\n-// 010ppppp pppppppp pppppppp ssssssss\n+// 01pppppp pppppppp ppppppp0 ssssssss\n //   - p* is primary collation value\n //   - s* is the secondary collation value\n // or\n@@ -67,10 +67,10 @@ func makeCE(weights []int) (uint32, error) {\n \t\t\tif weights[1] >= 1<<maxSecondaryCompactBits {\n \t\t\t\treturn 0, fmt.Errorf(\"makeCE: secondary weight with non-zero primary out of bounds: %x >= %x\", weights[1], 1<<maxSecondaryCompactBits)\n \t\t\t}\n-\t\t\tce = uint32(weights[0]<<maxSecondaryCompactBits + weights[1])\n+\t\t\tce = uint32(weights[0]<<(maxSecondaryCompactBits+1) + weights[1])\n \t\t\tce |= isPrimary\n \t\t} else {\n-\t\t\td := weights[1] - defaultSecondary\n+\t\t\td := weights[1] - defaultSecondary + 4\n \t\t\tif d >= 1<<maxSecondaryDiffBits || d < 0 {\n \t\t\t\treturn 0, fmt.Errorf(\"makeCE: secondary weight diff out of bounds: %x < 0 || %x > %x\", d, d, 1<<maxSecondaryDiffBits)\n \t\t\t}\n@@ -132,7 +132,7 @@ func makeExpandIndex(index int) (uint32, error) {\n \treturn expandID + uint32(index), nil\n }\n \n-// Each list of collation elements corresponding to an expansion starts with \n+// Each list of collation elements corresponding to an expansion starts with\n // a header indicating the length of the sequence.\n func makeExpansionHeader(n int) (uint32, error) {\n \treturn uint32(n), nil\n@@ -199,7 +199,7 @@ func implicitPrimary(r rune) int {\n \treturn int(r) + otherOffset\n }\n \n-// convertLargeWeights converts collation elements with large \n+// convertLargeWeights converts collation elements with large\n // primaries (either double primaries or for illegal runes)\n // to our own representation.\n // A CJK character C is represented in the DUCET as\n@@ -258,21 +258,31 @@ func convertLargeWeights(elems [][]int) (res [][]int, err error) {\n // nextWeight computes the first possible collation weights following elems\n // for the given level.\n func nextWeight(level collate.Level, elems [][]int) [][]int {\n-\tnce := make([][]int, len(elems))\n-\tcopy(nce, elems)\n-\n-\tif level != collate.Identity {\n-\t\tnce[0] = make([]int, len(elems[0]))\n-\t\tcopy(nce[0], elems[0])\n-\t\tnce[0][level]++\n-\t\tif level < collate.Secondary {\n-\t\t\tnce[0][collate.Secondary] = defaultSecondary\n+\tif level == collate.Identity {\n+\t\tnext := make([][]int, len(elems))\n+\t\tcopy(next, elems)\n+\t\treturn next\n+\t}\n+\tnext := [][]int{make([]int, len(elems[0]))}\n+\tcopy(next[0], elems[0])\n+\tnext[0][level]++\n+\tif level < collate.Secondary {\n+\t\tnext[0][collate.Secondary] = defaultSecondary\n+\t}\n+\tif level < collate.Tertiary {\n+\t\tnext[0][collate.Tertiary] = defaultTertiary\n+\t}\n+\t// Filter entries that cannot influence ordering.\n+\tfor _, ce := range elems[1:] {\n+\t\tskip := true\n+\t\tfor i := collate.Primary; i < level; i++ {\n+\t\t\tskip = skip && ce[i] == 0\n \t\t}\n-\t\tif level < collate.Tertiary {\n-\t\t\tnce[0][collate.Tertiary] = defaultTertiary\n+\t\tif !skip {\n+\t\t\tnext = append(next, ce)\n \t\t}\n \t}\n-\treturn nce\n+\treturn next\n }\n \n func nextVal(elems [][]int, i int, level collate.Level) (index, value int) {"}, {"sha": "75f9c160a2eb5e4910954225de72e79c88926c09", "filename": "libgo/go/exp/locale/collate/build/colelem_test.go", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcolelem_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -34,10 +34,10 @@ func decompCE(in []int) (ce uint32, err error) {\n var ceTests = []ceTest{\n \t{normalCE, []int{0, 0, 0}, 0x80000000},\n \t{normalCE, []int{0, 0x28, 3}, 0x80002803},\n-\t{normalCE, []int{100, defaultSecondary, 3}, 0x0000C803},\n+\t{normalCE, []int{100, defaultSecondary, 3}, 0x0000C883},\n \t// non-ignorable primary with non-default secondary\n-\t{normalCE, []int{100, 0x28, defaultTertiary}, 0x40006428},\n-\t{normalCE, []int{100, defaultSecondary + 8, 3}, 0x0000C903},\n+\t{normalCE, []int{100, 0x28, defaultTertiary}, 0x4000C828},\n+\t{normalCE, []int{100, defaultSecondary + 8, 3}, 0x0000C983},\n \t{normalCE, []int{100, 0, 3}, 0xFFFF}, // non-ignorable primary with non-supported secondary\n \t{normalCE, []int{100, 1, 3}, 0xFFFF},\n \t{normalCE, []int{1 << maxPrimaryBits, defaultSecondary, 0}, 0xFFFF},\n@@ -114,18 +114,24 @@ var nextWeightTests = []weightsTest{\n \t},\n }\n \n-var extra = []int{200, 32, 8, 0}\n+var extra = [][]int{{200, 32, 8, 0}, {0, 32, 8, 0}, {0, 0, 8, 0}, {0, 0, 0, 0}}\n \n func TestNextWeight(t *testing.T) {\n \tfor i, tt := range nextWeightTests {\n-\t\ttest := func(tt weightsTest, a, gold [][]int) {\n+\t\ttest := func(l collate.Level, tt weightsTest, a, gold [][]int) {\n \t\t\tres := nextWeight(tt.level, a)\n \t\t\tif !equalCEArrays(gold, res) {\n-\t\t\t\tt.Errorf(\"%d: expected weights %d; found %d\", i, tt.b, res)\n+\t\t\t\tt.Errorf(\"%d:%d: expected weights %d; found %d\", i, l, gold, res)\n+\t\t\t}\n+\t\t}\n+\t\ttest(-1, tt, tt.a, tt.b)\n+\t\tfor l := collate.Primary; l <= collate.Tertiary; l++ {\n+\t\t\tif tt.level <= l {\n+\t\t\t\ttest(l, tt, append(tt.a, extra[l]), tt.b)\n+\t\t\t} else {\n+\t\t\t\ttest(l, tt, append(tt.a, extra[l]), append(tt.b, extra[l]))\n \t\t\t}\n \t\t}\n-\t\ttest(tt, tt.a, tt.b)\n-\t\ttest(tt, append(tt.a, extra), append(tt.b, extra))\n \t}\n }\n \n@@ -137,7 +143,7 @@ var compareTests = []weightsTest{\n \t\t0,\n \t},\n \t{\n-\t\t[][]int{{100, 20, 5, 0}, extra},\n+\t\t[][]int{{100, 20, 5, 0}, extra[0]},\n \t\t[][]int{{100, 20, 5, 1}},\n \t\tcollate.Primary,\n \t\t1,\n@@ -192,6 +198,6 @@ func TestCompareWeights(t *testing.T) {\n \t\t\t}\n \t\t}\n \t\ttest(tt, tt.a, tt.b)\n-\t\ttest(tt, append(tt.a, extra), append(tt.b, extra))\n+\t\ttest(tt, append(tt.a, extra[0]), append(tt.b, extra[0]))\n \t}\n }"}, {"sha": "868665061e70ddcae2f4909072c9f6f359982920", "filename": "libgo/go/exp/locale/collate/build/contract.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Fcontract.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -15,7 +15,7 @@ import (\n // This file contains code for detecting contractions and generating\n // the necessary tables.\n // Any Unicode Collation Algorithm (UCA) table entry that has more than\n-// one rune one the left-hand side is called a contraction.  \n+// one rune one the left-hand side is called a contraction.\n // See http://www.unicode.org/reports/tr10/#Contractions for more details.\n //\n // We define the following terms:\n@@ -27,7 +27,7 @@ import (\n // A rune may be both a initial and a non-initial and may be so in\n // many contractions.  An initial may typically also appear by itself.\n // In case of ambiguities, the UCA requires we match the longest\n-// contraction.  \n+// contraction.\n //\n // Many contraction rules share the same set of possible suffixes.\n // We store sets of suffixes in a trie that associates an index with\n@@ -39,14 +39,14 @@ import (\n // is represented as a subsequence of ctEntries, where each entry corresponds to\n // a possible match of a next character in the search string.  An entry\n // also includes the length and offset to the next sequence of entries\n-// to check in case of a match. \n+// to check in case of a match.\n \n const (\n \tfinal   = 0\n \tnoIndex = 0xFF\n )\n \n-// ctEntry associates to a matching byte an offset and/or next sequence of \n+// ctEntry associates to a matching byte an offset and/or next sequence of\n // bytes to check. A ctEntry c is called final if a match means that the\n // longest suffix has been found.  An entry c is final if c.n == 0.\n // A single final entry can match a range of characters to an offset.\n@@ -58,7 +58,7 @@ const (\n //     {'a', 1, 1, noIndex},  // 'a' by itself does not match, so i is 0xFF.\n //     {'b', 'c', 0, 1},   // \"ab\" -> 1, \"ac\" -> 2\n // }\n-// \n+//\n // The suffix strings \"ab\", \"abc\", \"abd\", and \"abcd\" can be represented as:\n // []ctEntry{\n //     {'a', 1, 1, noIndex}, // 'a' must be followed by 'b'.\n@@ -72,7 +72,7 @@ type ctEntry struct {\n \tl uint8 // non-final: byte value to match; final: lowest match in range.\n \th uint8 // non-final: relative index to next block; final: highest match in range.\n \tn uint8 // non-final: length of next block; final: final\n-\ti uint8 // result offset. Will be noIndex if more bytes are needed to complete. \n+\ti uint8 // result offset. Will be noIndex if more bytes are needed to complete.\n }\n \n // contractTrieSet holds a set of contraction tries. The tries are stored"}, {"sha": "ef3e51fc5b02bbebaa57c121e5ae8fbcda7250fa", "filename": "libgo/go/exp/locale/collate/build/order.go", "status": "modified", "additions": 84, "deletions": 22, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -26,16 +26,21 @@ const (\n // Collation Element Table.\n // See http://www.unicode.org/Public/UCA/6.0.0/allkeys.txt.\n type entry struct {\n-\trunes []rune\n-\telems [][]int // the collation elements for runes\n-\tstr   string  // same as string(runes)\n+\tstr    string // same as string(runes)\n+\trunes  []rune\n+\telems  [][]int // the collation elements\n+\textend string  // weights of extend to be appended to elems\n+\tbefore bool    // weights relative to next instead of previous.\n+\tlock   bool    // entry is used in extension and can no longer be moved.\n \n \t// prev, next, and level are used to keep track of tailorings.\n \tprev, next *entry\n \tlevel      collate.Level // next differs at this level\n+\tskipRemove bool          // do not unlink when removed\n \n \tdecompose bool // can use NFKD decomposition to generate elems\n \texclude   bool // do not include in table\n+\timplicit  bool // derived, is not included in the list\n \tlogical   logicalAnchor\n \n \texpansionIndex    int // used to store index into expansion table\n@@ -44,8 +49,8 @@ type entry struct {\n }\n \n func (e *entry) String() string {\n-\treturn fmt.Sprintf(\"%X -> %X (ch:%x; ci:%d, ei:%d)\",\n-\t\te.runes, e.elems, e.contractionHandle, e.contractionIndex, e.expansionIndex)\n+\treturn fmt.Sprintf(\"%X (%q) -> %X (ch:%x; ci:%d, ei:%d)\",\n+\t\te.runes, e.str, e.elems, e.contractionHandle, e.contractionIndex, e.expansionIndex)\n }\n \n func (e *entry) skip() bool {\n@@ -71,7 +76,7 @@ func (e *entry) contractionStarter() bool {\n // examples of entries that will not be indexed.\n func (e *entry) nextIndexed() (*entry, collate.Level) {\n \tlevel := e.level\n-\tfor e = e.next; e != nil && e.exclude; e = e.next {\n+\tfor e = e.next; e != nil && (e.exclude || len(e.elems) == 0); e = e.next {\n \t\tif e.level < level {\n \t\t\tlevel = e.level\n \t\t}\n@@ -87,16 +92,20 @@ func (e *entry) remove() {\n \tif e.logical != noAnchor {\n \t\tlog.Fatalf(\"may not remove anchor %q\", e.str)\n \t}\n-\tif e.prev != nil {\n-\t\te.prev.next = e.next\n-\t}\n-\tif e.next != nil {\n-\t\te.next.prev = e.prev\n-\t}\n+\t// TODO: need to set e.prev.level to e.level if e.level is smaller?\n \te.elems = nil\n+\tif !e.skipRemove {\n+\t\tif e.prev != nil {\n+\t\t\te.prev.next = e.next\n+\t\t}\n+\t\tif e.next != nil {\n+\t\t\te.next.prev = e.prev\n+\t\t}\n+\t}\n+\te.skipRemove = false\n }\n \n-// insertAfter inserts t after e.\n+// insertAfter inserts n after e.\n func (e *entry) insertAfter(n *entry) {\n \tif e == n {\n \t\tpanic(\"e == anchor\")\n@@ -109,10 +118,31 @@ func (e *entry) insertAfter(n *entry) {\n \n \tn.next = e.next\n \tn.prev = e\n-\te.next.prev = n\n+\tif e.next != nil {\n+\t\te.next.prev = n\n+\t}\n \te.next = n\n }\n \n+// insertBefore inserts n before e.\n+func (e *entry) insertBefore(n *entry) {\n+\tif e == n {\n+\t\tpanic(\"e == anchor\")\n+\t}\n+\tif e == nil {\n+\t\tpanic(\"unexpected nil anchor\")\n+\t}\n+\tn.remove()\n+\tn.decompose = false // redo decomposition test\n+\n+\tn.prev = e.prev\n+\tn.next = e\n+\tif e.prev != nil {\n+\t\te.prev.next = n\n+\t}\n+\te.prev = n\n+}\n+\n func (e *entry) encodeBase() (ce uint32, err error) {\n \tswitch {\n \tcase e.expansion():\n@@ -178,6 +208,7 @@ func (s sortedEntries) Less(i, j int) bool {\n }\n \n type ordering struct {\n+\tid       string\n \tentryMap map[string]*entry\n \tordered  []*entry\n \thandle   *trieHandle\n@@ -187,7 +218,14 @@ type ordering struct {\n // Note that insert simply appends e to ordered.  To reattain a sorted\n // order, o.sort() should be called.\n func (o *ordering) insert(e *entry) {\n-\to.entryMap[e.str] = e\n+\tif e.logical == noAnchor {\n+\t\to.entryMap[e.str] = e\n+\t} else {\n+\t\t// Use key format as used in UCA rules.\n+\t\to.entryMap[fmt.Sprintf(\"[%s]\", e.str)] = e\n+\t\t// Also add index entry for XML format.\n+\t\to.entryMap[fmt.Sprintf(\"<%s/>\", strings.Replace(e.str, \" \", \"_\", -1))] = e\n+\t}\n \to.ordered = append(o.ordered, e)\n }\n \n@@ -236,13 +274,13 @@ func makeRootOrdering() ordering {\n \t\tentryMap: make(map[string]*entry),\n \t}\n \tinsert := func(typ logicalAnchor, s string, ce []int) {\n-\t\t// Use key format as used in UCA rules.\n-\t\te := o.newEntry(fmt.Sprintf(\"[%s]\", s), [][]int{ce})\n-\t\t// Also add index entry for XML format.\n-\t\to.entryMap[fmt.Sprintf(\"<%s/>\", strings.Replace(s, \" \", \"_\", -1))] = e\n-\t\te.runes = nil\n-\t\te.exclude = true\n-\t\te.logical = typ\n+\t\te := &entry{\n+\t\t\telems:   [][]int{ce},\n+\t\t\tstr:     s,\n+\t\t\texclude: true,\n+\t\t\tlogical: typ,\n+\t\t}\n+\t\to.insert(e)\n \t}\n \tinsert(firstAnchor, \"first tertiary ignorable\", []int{0, 0, 0, 0})\n \tinsert(lastAnchor, \"last tertiary ignorable\", []int{0, 0, 0, max})\n@@ -252,6 +290,29 @@ func makeRootOrdering() ordering {\n \treturn o\n }\n \n+// patchForInsert eleminates entries from the list with more than one collation element.\n+// The next and prev fields of the eliminated entries still point to appropriate\n+// values in the newly created list.\n+// It requires that sort has been called.\n+func (o *ordering) patchForInsert() {\n+\tfor i := 0; i < len(o.ordered)-1; {\n+\t\te := o.ordered[i]\n+\t\tlev := e.level\n+\t\tn := e.next\n+\t\tfor ; n != nil && len(n.elems) > 1; n = n.next {\n+\t\t\tif n.level < lev {\n+\t\t\t\tlev = n.level\n+\t\t\t}\n+\t\t\tn.skipRemove = true\n+\t\t}\n+\t\tfor ; o.ordered[i] != n; i++ {\n+\t\t\to.ordered[i].level = lev\n+\t\t\to.ordered[i].next = n\n+\t\t\to.ordered[i+1].prev = e\n+\t\t}\n+\t}\n+}\n+\n // clone copies all ordering of es into a new ordering value.\n func (o *ordering) clone() *ordering {\n \to.sort()\n@@ -270,6 +331,7 @@ func (o *ordering) clone() *ordering {\n \t\too.insert(ne)\n \t}\n \too.sort() // link all ordering.\n+\too.patchForInsert()\n \treturn &oo\n }\n "}, {"sha": "00ebd0a125a4b5ed4beae2183d14da64c275b209", "filename": "libgo/go/exp/locale/collate/build/order_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Forder_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -128,6 +128,9 @@ func TestInsertAfter(t *testing.T) {\n \t\t\tlast.insertAfter(es[i])\n \t\t\tlast = es[i]\n \t\t}\n+\t\tfor _, e := range es {\n+\t\t\te.elems = es[0].elems\n+\t\t}\n \t\te := es[0]\n \t\tfor _, i := range perm {\n \t\t\te, _ = e.nextIndexed()\n@@ -139,6 +142,34 @@ func TestInsertAfter(t *testing.T) {\n \t}\n }\n \n+func TestInsertBefore(t *testing.T) {\n+\tconst n = 5\n+\torig := makeList(n)\n+\tperm := make([]int, n)\n+\tfor i := range perm {\n+\t\tperm[i] = i + 1\n+\t}\n+\tfor ok := true; ok; ok = nextPerm(perm) {\n+\t\tes := makeList(n)\n+\t\tlast := es[len(es)-1]\n+\t\tfor _, i := range perm {\n+\t\t\tlast.insertBefore(es[i])\n+\t\t\tlast = es[i]\n+\t\t}\n+\t\tfor _, e := range es {\n+\t\t\te.elems = es[0].elems\n+\t\t}\n+\t\te := es[0]\n+\t\tfor i := n - 1; i >= 0; i-- {\n+\t\t\te, _ = e.nextIndexed()\n+\t\t\tif e.runes[0] != rune(perm[i]) {\n+\t\t\t\tt.Errorf(\"%d:%d: expected entry %X; found %X\", perm, i, orig[i].runes, e.runes)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n type entryLessTest struct {\n \ta, b *entry\n \tres  bool"}, {"sha": "f5214279e2853416d42943c1b78e0a7977415b52", "filename": "libgo/go/exp/locale/collate/build/trie.go", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -4,7 +4,7 @@\n \n // The trie in this file is used to associate the first full character\n // in a UTF-8 string to a collation element.\n-// All but the last byte in a UTF-8 byte sequence are \n+// All but the last byte in a UTF-8 byte sequence are\n // used to look up offsets in the index table to be used for the next byte.\n // The last byte is used to index into a table of collation elements.\n // This file contains the code for the generation of the trie.\n@@ -35,10 +35,11 @@ type trie struct {\n \n // trieNode is the intermediate trie structure used for generating a trie.\n type trieNode struct {\n-\tindex []*trieNode\n-\tvalue []uint32\n-\tb     byte\n-\tref   uint16\n+\tindex    []*trieNode\n+\tvalue    []uint32\n+\tb        byte\n+\trefValue uint16\n+\trefIndex uint16\n }\n \n func newNode() *trieNode {\n@@ -108,18 +109,20 @@ func (b *trieBuilder) computeOffsets(n *trieNode) *trieNode {\n \thasher := fnv.New32()\n \tif n.index != nil {\n \t\tfor i, nn := range n.index {\n-\t\t\tv := uint16(0)\n+\t\t\tvar vi, vv uint16\n \t\t\tif nn != nil {\n \t\t\t\tnn = b.computeOffsets(nn)\n \t\t\t\tn.index[i] = nn\n-\t\t\t\tv = nn.ref\n+\t\t\t\tvi = nn.refIndex\n+\t\t\t\tvv = nn.refValue\n \t\t\t}\n-\t\t\thasher.Write([]byte{byte(v >> 8), byte(v)})\n+\t\t\thasher.Write([]byte{byte(vi >> 8), byte(vi)})\n+\t\t\thasher.Write([]byte{byte(vv >> 8), byte(vv)})\n \t\t}\n \t\th := hasher.Sum32()\n \t\tnn, ok := b.lookupBlockIdx[h]\n \t\tif !ok {\n-\t\t\tn.ref = uint16(len(b.lookupBlocks)) - blockOffset\n+\t\t\tn.refIndex = uint16(len(b.lookupBlocks)) - blockOffset\n \t\t\tb.lookupBlocks = append(b.lookupBlocks, n)\n \t\t\tb.lookupBlockIdx[h] = n\n \t\t} else {\n@@ -132,7 +135,8 @@ func (b *trieBuilder) computeOffsets(n *trieNode) *trieNode {\n \t\th := hasher.Sum32()\n \t\tnn, ok := b.valueBlockIdx[h]\n \t\tif !ok {\n-\t\t\tn.ref = uint16(len(b.valueBlocks)) - blockOffset\n+\t\t\tn.refValue = uint16(len(b.valueBlocks)) - blockOffset\n+\t\t\tn.refIndex = n.refValue\n \t\t\tb.valueBlocks = append(b.valueBlocks, n)\n \t\t\tb.valueBlockIdx[h] = n\n \t\t} else {\n@@ -150,15 +154,16 @@ func (b *trieBuilder) addStartValueBlock(n *trieNode) uint16 {\n \th := hasher.Sum32()\n \tnn, ok := b.valueBlockIdx[h]\n \tif !ok {\n-\t\tn.ref = uint16(len(b.valueBlocks))\n+\t\tn.refValue = uint16(len(b.valueBlocks))\n+\t\tn.refIndex = n.refValue\n \t\tb.valueBlocks = append(b.valueBlocks, n)\n \t\t// Add a dummy block to accommodate the double block size.\n \t\tb.valueBlocks = append(b.valueBlocks, nil)\n \t\tb.valueBlockIdx[h] = n\n \t} else {\n \t\tn = nn\n \t}\n-\treturn n.ref\n+\treturn n.refValue\n }\n \n func genValueBlock(t *trie, n *trieNode) {\n@@ -173,7 +178,11 @@ func genLookupBlock(t *trie, n *trieNode) {\n \tfor _, nn := range n.index {\n \t\tv := uint16(0)\n \t\tif nn != nil {\n-\t\t\tv = nn.ref\n+\t\t\tif n.index != nil {\n+\t\t\t\tv = nn.refIndex\n+\t\t\t} else {\n+\t\t\t\tv = nn.refValue\n+\t\t\t}\n \t\t}\n \t\tt.index = append(t.index, v)\n \t}\n@@ -192,7 +201,7 @@ func (b *trieBuilder) addTrie(n *trieNode) *trieHandle {\n \t}\n \tn = b.computeOffsets(n)\n \t// Offset by one extra block as the first byte starts at 0xC0 instead of 0x80.\n-\th.lookupStart = n.ref - 1\n+\th.lookupStart = n.refIndex - 1\n \treturn h\n }\n "}, {"sha": "4d4f6e4d140108dda8efd99a112828f6e93ad5c9", "filename": "libgo/go/exp/locale/collate/build/trie_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"testing\"\n )\n \n-// We take the smallest, largest and an arbitrary value for each \n+// We take the smallest, largest and an arbitrary value for each\n // of the UTF-8 sequence lengths.\n var testRunes = []rune{\n \t0x01, 0x0C, 0x7F, // 1-byte sequences"}, {"sha": "0ff15aa7eb954f285e698f95c5f0e2d1c8f8cc8a", "filename": "libgo/go/exp/locale/collate/colelem.go", "status": "modified", "additions": 80, "deletions": 28, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -8,16 +8,6 @@ import (\n \t\"unicode\"\n )\n \n-// weights holds the decoded weights per collation level.\n-type weights struct {\n-\tprimary   uint32\n-\tsecondary uint16\n-\ttertiary  uint8\n-\t// TODO: compute quaternary on the fly or compress this value into 8 bits\n-\t// such that weights fit within 64bit.\n-\tquaternary uint32\n-}\n-\n const (\n \tdefaultSecondary = 0x20\n \tdefaultTertiary  = 0x2\n@@ -69,7 +59,7 @@ func (ce colElem) ctype() ceType {\n // For normal collation elements, we assume that a collation element either has\n // a primary or non-default secondary value, not both.\n // Collation elements with a primary value are of the form\n-// 010ppppp pppppppp pppppppp ssssssss\n+// 01pppppp pppppppp ppppppp0 ssssssss\n //   - p* is primary collation value\n //   - s* is the secondary collation value\n // or\n@@ -82,25 +72,87 @@ func (ce colElem) ctype() ceType {\n //   - 16 BMP implicit -> weight\n //   - 8 bit s\n //   - default tertiary\n-func splitCE(ce colElem) weights {\n-\tconst primaryMask = 0x40000000\n-\tconst secondaryMask = 0x80000000\n-\tw := weights{}\n-\tif ce&primaryMask != 0 {\n-\t\tw.tertiary = defaultTertiary\n-\t\tw.secondary = uint16(uint8(ce))\n-\t\tw.primary = uint32((ce >> 8) & 0x1FFFFF)\n-\t} else if ce&secondaryMask == 0 {\n-\t\tw.tertiary = uint8(ce & 0x1F)\n-\t\tce >>= 5\n-\t\tw.secondary = defaultSecondary + uint16(ce&0xF)\n-\t\tce >>= 4\n-\t\tw.primary = uint32(ce)\n+// 11qqqqqq qqqqqqqq qqqqqqq0 00000000\n+//   - q* quaternary value\n+const (\n+\tceTypeMask            = 0xC0000000\n+\tceType1               = 0x40000000\n+\tceType2               = 0x00000000\n+\tceType3               = 0x80000000\n+\tceTypeQ               = 0xC0000000\n+\tceIgnore              = ceType3\n+\tfirstNonPrimary       = 0x80000000\n+\tsecondaryMask         = 0x80000000\n+\thasTertiaryMask       = 0x40000000\n+\tprimaryValueMask      = 0x3FFFFE00\n+\tprimaryShift          = 9\n+\tcompactSecondaryShift = 5\n+\tminCompactSecondary   = defaultSecondary - 4\n+)\n+\n+func makeImplicitCE(primary int) colElem {\n+\treturn ceType1 | colElem(primary<<primaryShift) | defaultSecondary\n+}\n+\n+func makeQuaternary(primary int) colElem {\n+\treturn ceTypeQ | colElem(primary<<primaryShift)\n+}\n+\n+func (ce colElem) primary() int {\n+\tif ce >= firstNonPrimary {\n+\t\treturn 0\n+\t}\n+\treturn int(ce&primaryValueMask) >> primaryShift\n+}\n+\n+func (ce colElem) secondary() int {\n+\tswitch ce & ceTypeMask {\n+\tcase ceType1:\n+\t\treturn int(uint8(ce))\n+\tcase ceType2:\n+\t\treturn minCompactSecondary + int((ce>>compactSecondaryShift)&0xF)\n+\tcase ceType3:\n+\t\treturn int(uint16(ce >> 8))\n+\tcase ceTypeQ:\n+\t\treturn 0\n+\t}\n+\tpanic(\"should not reach here\")\n+}\n+\n+func (ce colElem) tertiary() uint8 {\n+\tif ce&hasTertiaryMask == 0 {\n+\t\tif ce&ceType3 == 0 {\n+\t\t\treturn uint8(ce & 0x1F)\n+\t\t}\n+\t\treturn uint8(ce)\n+\t} else if ce&ceTypeMask == ceType1 {\n+\t\treturn defaultTertiary\n+\t}\n+\t// ce is a quaternary value.\n+\treturn 0\n+}\n+\n+func (ce colElem) updateTertiary(t uint8) colElem {\n+\tif ce&ceTypeMask == ceType1 {\n+\t\tnce := ce & primaryValueMask\n+\t\tnce |= colElem(uint8(ce)-minCompactSecondary) << compactSecondaryShift\n+\t\tce = nce\n \t} else {\n-\t\tw.tertiary = uint8(ce)\n-\t\tw.secondary = uint16(ce >> 8)\n+\t\tce &= ^colElem(maxTertiary)\n+\t}\n+\treturn ce | colElem(t)\n+}\n+\n+// quaternary returns the quaternary value if explicitly specified,\n+// 0 if ce == ceIgnore, or maxQuaternary otherwise.\n+// Quaternary values are used only for shifted variants.\n+func (ce colElem) quaternary() int {\n+\tif ce&ceTypeMask == ceTypeQ {\n+\t\treturn int(ce&primaryValueMask) >> primaryShift\n+\t} else if ce == ceIgnore {\n+\t\treturn 0\n \t}\n-\treturn w\n+\treturn maxQuaternary\n }\n \n // For contractions, collation elements are of the form"}, {"sha": "62ef90d029de8022ad7236a8a89c0274ae706e1e", "filename": "libgo/go/exp/locale/collate/colelem_test.go", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcolelem_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -29,10 +29,10 @@ func makeCE(weights []int) colElem {\n \tvar ce colElem\n \tif weights[0] != 0 {\n \t\tif weights[2] == defaultTertiary {\n-\t\t\tce = colElem(weights[0]<<maxSecondaryCompactBits + weights[1])\n+\t\t\tce = colElem(weights[0]<<(maxSecondaryCompactBits+1) + weights[1])\n \t\t\tce |= isPrimary\n \t\t} else {\n-\t\t\td := weights[1] - defaultSecondary\n+\t\t\td := weights[1] - defaultSecondary + 4\n \t\t\tce = colElem(weights[0]<<maxSecondaryDiffBits + d)\n \t\t\tce = ce<<maxTertiaryCompactBits + colElem(weights[2])\n \t\t}\n@@ -68,10 +68,10 @@ func makeDecompose(t1, t2 int) colElem {\n }\n \n func normalCE(inout []int) (ce colElem, t ceType) {\n-\tw := splitCE(makeCE(inout))\n-\tinout[0] = int(w.primary)\n-\tinout[1] = int(w.secondary)\n-\tinout[2] = int(w.tertiary)\n+\tw := makeCE(inout)\n+\tinout[0] = w.primary()\n+\tinout[1] = w.secondary()\n+\tinout[2] = int(w.tertiary())\n \treturn ce, ceNormal\n }\n \n@@ -167,3 +167,20 @@ func TestImplicit(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestUpdateTertiary(t *testing.T) {\n+\ttests := []struct {\n+\t\tin, out colElem\n+\t\tt       uint8\n+\t}{\n+\t\t{0x4000FE20, 0x0000FE8A, 0x0A},\n+\t\t{0x4000FE21, 0x0000FEAA, 0x0A},\n+\t\t{0x0000FE8B, 0x0000FE83, 0x03},\n+\t\t{0x8000CC02, 0x8000CC1B, 0x1B},\n+\t}\n+\tfor i, tt := range tests {\n+\t\tif out := tt.in.updateTertiary(tt.t); out != tt.out {\n+\t\t\tt.Errorf(\"%d: was %X; want %X\", i, out, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "a08dcae0d5f84f3ae219eeafb324532bcf5ed212", "filename": "libgo/go/exp/locale/collate/collate.go", "status": "modified", "additions": 228, "deletions": 82, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fcollate.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -30,7 +30,7 @@ const (\n \n // AlternateHandling identifies the various ways in which variables are handled.\n // A rune with a primary weight lower than the variable top is considered a\n-// variable. \n+// variable.\n // See http://www.unicode.org/reports/tr10/#Variable_Weighting for details.\n type AlternateHandling int\n \n@@ -83,9 +83,17 @@ type Collator struct {\n \tf norm.Form\n \n \tt *table\n+\n+\t_iter [2]iter\n+}\n+\n+func (c *Collator) iter(i int) *iter {\n+\t// TODO: evaluate performance for making the second iterator optional.\n+\treturn &c._iter[i]\n }\n \n // Locales returns the list of locales for which collating differs from its parent locale.\n+// The returned value should not be modified.\n func Locales() []string {\n \treturn availableLocales\n }\n@@ -99,11 +107,18 @@ func New(loc string) *Collator {\n \t\t\tt = mainTable.indexedTable(idx)\n \t\t}\n \t}\n-\treturn &Collator{\n+\treturn newCollator(t)\n+}\n+\n+func newCollator(t *table) *Collator {\n+\tc := &Collator{\n \t\tStrength: Quaternary,\n \t\tf:        norm.NFD,\n \t\tt:        t,\n \t}\n+\tc._iter[0].init(c)\n+\tc._iter[1].init(c)\n+\treturn c\n }\n \n // SetVariableTop sets all runes with primary strength less than the primary\n@@ -112,76 +127,126 @@ func (c *Collator) SetVariableTop(r rune) {\n \t// TODO: implement\n }\n \n-// Buffer holds reusable buffers that can be used during collation.\n-// Reusing a Buffer for the various calls that accept it may avoid\n-// unnecessary memory allocations.\n+// Buffer holds keys generated by Key and KeyString.\n type Buffer struct {\n-\t// TODO: try various parameters and techniques, such as using\n-\t// a chan of buffers for a pool.\n-\tba  [4096]byte\n-\twa  [512]weights\n+\tbuf [4096]byte\n \tkey []byte\n-\tce  []weights\n }\n \n func (b *Buffer) init() {\n-\tif b.ce == nil {\n-\t\tb.ce = b.wa[:0]\n-\t\tb.key = b.ba[:0]\n-\t} else {\n-\t\tb.ce = b.ce[:0]\n+\tif b.key == nil {\n+\t\tb.key = b.buf[:0]\n \t}\n }\n \n-// ResetKeys clears the buffer used for generated keys. Calling ResetKeys\n-// invalidates keys previously obtained from Key or KeyFromString.\n-func (b *Buffer) ResetKeys() {\n-\tb.ce = b.ce[:0]\n+// Reset clears the buffer from previous results generated by Key and KeyString.\n+func (b *Buffer) Reset() {\n \tb.key = b.key[:0]\n }\n \n // Compare returns an integer comparing the two byte slices.\n // The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n-// Compare calls ResetKeys, thereby invalidating keys\n-// previously generated using Key or KeyFromString using buf.\n-func (c *Collator) Compare(buf *Buffer, a, b []byte) int {\n-\t// TODO: for now we simply compute keys and compare.  Once we\n-\t// have good benchmarks, move to an implementation that works\n-\t// incrementally for the majority of cases.\n-\t// - Benchmark with long strings that only vary in modifiers.\n-\tbuf.ResetKeys()\n-\tka := c.Key(buf, a)\n-\tkb := c.Key(buf, b)\n-\tdefer buf.ResetKeys()\n-\treturn bytes.Compare(ka, kb)\n+func (c *Collator) Compare(a, b []byte) int {\n+\t// TODO: skip identical prefixes once we have a fast way to detect if a rune is\n+\t// part of a contraction. This would lead to roughly a 10% speedup for the colcmp regtest.\n+\tc.iter(0).setInput(c, a)\n+\tc.iter(1).setInput(c, b)\n+\tif res := c.compare(); res != 0 {\n+\t\treturn res\n+\t}\n+\tif Identity == c.Strength {\n+\t\treturn bytes.Compare(a, b)\n+\t}\n+\treturn 0\n }\n \n // CompareString returns an integer comparing the two strings.\n // The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n-// CompareString calls ResetKeys, thereby invalidating keys\n-// previously generated using Key or KeyFromString using buf.\n-func (c *Collator) CompareString(buf *Buffer, a, b string) int {\n-\tbuf.ResetKeys()\n-\tka := c.KeyFromString(buf, a)\n-\tkb := c.KeyFromString(buf, b)\n-\tdefer buf.ResetKeys()\n-\treturn bytes.Compare(ka, kb)\n+func (c *Collator) CompareString(a, b string) int {\n+\t// TODO: skip identical prefixes once we have a fast way to detect if a rune is\n+\t// part of a contraction. This would lead to roughly a 10% speedup for the colcmp regtest.\n+\tc.iter(0).setInputString(c, a)\n+\tc.iter(1).setInputString(c, b)\n+\tif res := c.compare(); res != 0 {\n+\t\treturn res\n+\t}\n+\tif Identity == c.Strength {\n+\t\tif a < b {\n+\t\t\treturn -1\n+\t\t} else if a > b {\n+\t\t\treturn 1\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+func compareLevel(f func(i *iter) int, a, b *iter) int {\n+\ta.pce = 0\n+\tb.pce = 0\n+\tfor {\n+\t\tva := f(a)\n+\t\tvb := f(b)\n+\t\tif va != vb {\n+\t\t\tif va < vb {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\treturn 1\n+\t\t} else if va == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn 0\n }\n \n-func (c *Collator) Prefix(buf *Buffer, s, prefix []byte) int {\n+func (c *Collator) compare() int {\n+\tia, ib := c.iter(0), c.iter(1)\n+\t// Process primary level\n+\tif c.Alternate != AltShifted {\n+\t\t// TODO: implement script reordering\n+\t\t// TODO: special hiragana handling\n+\t\tif res := compareLevel((*iter).nextPrimary, ia, ib); res != 0 {\n+\t\t\treturn res\n+\t\t}\n+\t} else {\n+\t\t// TODO: handle shifted\n+\t}\n+\tif Secondary <= c.Strength {\n+\t\tf := (*iter).nextSecondary\n+\t\tif c.Backwards {\n+\t\t\tf = (*iter).prevSecondary\n+\t\t}\n+\t\tif res := compareLevel(f, ia, ib); res != 0 {\n+\t\t\treturn res\n+\t\t}\n+\t}\n+\t// TODO: special case handling (Danish?)\n+\tif Tertiary <= c.Strength || c.CaseLevel {\n+\t\tif res := compareLevel((*iter).nextTertiary, ia, ib); res != 0 {\n+\t\t\treturn res\n+\t\t}\n+\t\t// TODO: Not needed for the default value of AltNonIgnorable?\n+\t\tif Quaternary <= c.Strength {\n+\t\t\tif res := compareLevel((*iter).nextQuaternary, ia, ib); res != 0 {\n+\t\t\t\treturn res\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+func (c *Collator) Prefix(s, prefix []byte) int {\n \t// iterate over s, track bytes consumed.\n \treturn 0\n }\n \n // Key returns the collation key for str.\n // Passing the buffer buf may avoid memory allocations.\n // The returned slice will point to an allocation in Buffer and will remain\n-// valid until the next call to buf.ResetKeys().\n+// valid until the next call to buf.Reset().\n func (c *Collator) Key(buf *Buffer, str []byte) []byte {\n \t// See http://www.unicode.org/reports/tr10/#Main_Algorithm for more details.\n \tbuf.init()\n-\tc.getColElems(buf, str)\n-\treturn c.key(buf, buf.ce)\n+\treturn c.key(buf, c.getColElems(str))\n }\n \n // KeyFromString returns the collation key for str.\n@@ -191,54 +256,81 @@ func (c *Collator) Key(buf *Buffer, str []byte) []byte {\n func (c *Collator) KeyFromString(buf *Buffer, str string) []byte {\n \t// See http://www.unicode.org/reports/tr10/#Main_Algorithm for more details.\n \tbuf.init()\n-\tc.getColElemsString(buf, str)\n-\treturn c.key(buf, buf.ce)\n+\treturn c.key(buf, c.getColElemsString(str))\n }\n \n-func (c *Collator) key(buf *Buffer, w []weights) []byte {\n+func (c *Collator) key(buf *Buffer, w []colElem) []byte {\n \tprocessWeights(c.Alternate, c.t.variableTop, w)\n \tkn := len(buf.key)\n \tc.keyFromElems(buf, w)\n \treturn buf.key[kn:]\n }\n \n-func (c *Collator) getColElems(buf *Buffer, str []byte) {\n-\ti := c.iter()\n-\ti.src.SetInput(c.f, str)\n+func (c *Collator) getColElems(str []byte) []colElem {\n+\ti := c.iter(0)\n+\ti.setInput(c, str)\n \tfor !i.done() {\n-\t\tbuf.ce = i.next(buf.ce)\n+\t\ti.next()\n \t}\n+\treturn i.ce\n }\n \n-func (c *Collator) getColElemsString(buf *Buffer, str string) {\n-\ti := c.iter()\n-\ti.src.SetInputString(c.f, str)\n+func (c *Collator) getColElemsString(str string) []colElem {\n+\ti := c.iter(0)\n+\ti.setInputString(c, str)\n \tfor !i.done() {\n-\t\tbuf.ce = i.next(buf.ce)\n+\t\ti.next()\n \t}\n+\treturn i.ce\n }\n \n type iter struct {\n \tsrc        norm.Iter\n-\tba         [1024]byte\n+\tnorm       [1024]byte\n \tbuf        []byte\n-\tt          *table\n \tp          int\n \tminBufSize int\n+\n+\twa  [512]colElem\n+\tce  []colElem\n+\tpce int\n+\n+\tt          *table\n \t_done, eof bool\n }\n \n-func (c *Collator) iter() iter {\n-\ti := iter{t: c.t, minBufSize: c.t.maxContractLen}\n-\ti.buf = i.ba[:0]\n+func (i *iter) init(c *Collator) {\n+\ti.t = c.t\n+\ti.minBufSize = c.t.maxContractLen\n+\ti.ce = i.wa[:0]\n+\ti.buf = i.norm[:0]\n+}\n+\n+func (i *iter) reset() {\n+\ti.ce = i.ce[:0]\n+\ti.buf = i.buf[:0]\n+\ti.p = 0\n+\ti.eof = i.src.Done()\n+\ti._done = i.eof\n+}\n+\n+func (i *iter) setInput(c *Collator, s []byte) *iter {\n+\ti.src.SetInput(c.f, s)\n+\ti.reset()\n+\treturn i\n+}\n+\n+func (i *iter) setInputString(c *Collator, s string) *iter {\n+\ti.src.SetInputString(c.f, s)\n+\ti.reset()\n \treturn i\n }\n \n func (i *iter) done() bool {\n \treturn i._done\n }\n \n-func (i *iter) next(ce []weights) []weights {\n+func (i *iter) next() {\n \tif !i.eof && len(i.buf)-i.p < i.minBufSize {\n \t\t// replenish buffer\n \t\tn := copy(i.buf, i.buf[i.p:])\n@@ -249,14 +341,70 @@ func (i *iter) next(ce []weights) []weights {\n \t}\n \tif i.p == len(i.buf) {\n \t\ti._done = true\n-\t\treturn ce\n+\t\treturn\n \t}\n-\tce, sz := i.t.appendNext(ce, i.buf[i.p:])\n+\tsz := 0\n+\ti.ce, sz = i.t.appendNext(i.ce, i.buf[i.p:])\n \ti.p += sz\n-\treturn ce\n }\n \n-func appendPrimary(key []byte, p uint32) []byte {\n+func (i *iter) nextPrimary() int {\n+\tfor {\n+\t\tfor ; i.pce < len(i.ce); i.pce++ {\n+\t\t\tif v := i.ce[i.pce].primary(); v != 0 {\n+\t\t\t\ti.pce++\n+\t\t\t\treturn v\n+\t\t\t}\n+\t\t}\n+\t\tif i.done() {\n+\t\t\treturn 0\n+\t\t}\n+\t\ti.next()\n+\t}\n+\tpanic(\"should not reach here\")\n+}\n+\n+func (i *iter) nextSecondary() int {\n+\tfor ; i.pce < len(i.ce); i.pce++ {\n+\t\tif v := i.ce[i.pce].secondary(); v != 0 {\n+\t\t\ti.pce++\n+\t\t\treturn v\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+func (i *iter) prevSecondary() int {\n+\tfor ; i.pce < len(i.ce); i.pce++ {\n+\t\tif v := i.ce[len(i.ce)-i.pce-1].secondary(); v != 0 {\n+\t\t\ti.pce++\n+\t\t\treturn v\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+func (i *iter) nextTertiary() int {\n+\tfor ; i.pce < len(i.ce); i.pce++ {\n+\t\tif v := i.ce[i.pce].tertiary(); v != 0 {\n+\t\t\ti.pce++\n+\t\t\treturn int(v)\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+func (i *iter) nextQuaternary() int {\n+\tfor ; i.pce < len(i.ce); i.pce++ {\n+\t\tif v := i.ce[i.pce].quaternary(); v != 0 {\n+\t\t\ti.pce++\n+\t\t\treturn v\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+func appendPrimary(key []byte, p int) []byte {\n \t// Convert to variable length encoding; supports up to 23 bits.\n \tif p <= 0x7FFF {\n \t\tkey = append(key, uint8(p>>8), uint8(p))\n@@ -268,9 +416,9 @@ func appendPrimary(key []byte, p uint32) []byte {\n \n // keyFromElems converts the weights ws to a compact sequence of bytes.\n // The result will be appended to the byte buffer in buf.\n-func (c *Collator) keyFromElems(buf *Buffer, ws []weights) {\n+func (c *Collator) keyFromElems(buf *Buffer, ws []colElem) {\n \tfor _, v := range ws {\n-\t\tif w := v.primary; w > 0 {\n+\t\tif w := v.primary(); w > 0 {\n \t\t\tbuf.key = appendPrimary(buf.key, w)\n \t\t}\n \t}\n@@ -279,13 +427,13 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []weights) {\n \t\t// TODO: we can use one 0 if we can guarantee that all non-zero weights are > 0xFF.\n \t\tif !c.Backwards {\n \t\t\tfor _, v := range ws {\n-\t\t\t\tif w := v.secondary; w > 0 {\n+\t\t\t\tif w := v.secondary(); w > 0 {\n \t\t\t\t\tbuf.key = append(buf.key, uint8(w>>8), uint8(w))\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor i := len(ws) - 1; i >= 0; i-- {\n-\t\t\t\tif w := ws[i].secondary; w > 0 {\n+\t\t\t\tif w := ws[i].secondary(); w > 0 {\n \t\t\t\t\tbuf.key = append(buf.key, uint8(w>>8), uint8(w))\n \t\t\t\t}\n \t\t\t}\n@@ -296,20 +444,20 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []weights) {\n \tif Tertiary <= c.Strength || c.CaseLevel {\n \t\tbuf.key = append(buf.key, 0, 0)\n \t\tfor _, v := range ws {\n-\t\t\tif w := v.tertiary; w > 0 {\n-\t\t\t\tbuf.key = append(buf.key, w)\n+\t\t\tif w := v.tertiary(); w > 0 {\n+\t\t\t\tbuf.key = append(buf.key, uint8(w))\n \t\t\t}\n \t\t}\n \t\t// Derive the quaternary weights from the options and other levels.\n \t\t// Note that we represent maxQuaternary as 0xFF. The first byte of the\n \t\t// representation of a a primary weight is always smaller than 0xFF,\n \t\t// so using this single byte value will compare correctly.\n-\t\tif Quaternary <= c.Strength {\n+\t\tif Quaternary <= c.Strength && c.Alternate >= AltShifted {\n \t\t\tif c.Alternate == AltShiftTrimmed {\n \t\t\t\tlastNonFFFF := len(buf.key)\n \t\t\t\tbuf.key = append(buf.key, 0)\n \t\t\t\tfor _, v := range ws {\n-\t\t\t\t\tif w := v.quaternary; w == maxQuaternary {\n+\t\t\t\t\tif w := v.quaternary(); w == maxQuaternary {\n \t\t\t\t\t\tbuf.key = append(buf.key, 0xFF)\n \t\t\t\t\t} else if w > 0 {\n \t\t\t\t\t\tbuf.key = appendPrimary(buf.key, w)\n@@ -320,7 +468,7 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []weights) {\n \t\t\t} else {\n \t\t\t\tbuf.key = append(buf.key, 0)\n \t\t\t\tfor _, v := range ws {\n-\t\t\t\t\tif w := v.quaternary; w == maxQuaternary {\n+\t\t\t\t\tif w := v.quaternary(); w == maxQuaternary {\n \t\t\t\t\t\tbuf.key = append(buf.key, 0xFF)\n \t\t\t\t\t} else if w > 0 {\n \t\t\t\t\t\tbuf.key = appendPrimary(buf.key, w)\n@@ -331,29 +479,27 @@ func (c *Collator) keyFromElems(buf *Buffer, ws []weights) {\n \t}\n }\n \n-func processWeights(vw AlternateHandling, top uint32, wa []weights) {\n+func processWeights(vw AlternateHandling, top uint32, wa []colElem) {\n \tignore := false\n+\tvtop := int(top)\n \tswitch vw {\n \tcase AltShifted, AltShiftTrimmed:\n \t\tfor i := range wa {\n-\t\t\tif p := wa[i].primary; p <= top && p != 0 {\n-\t\t\t\twa[i] = weights{quaternary: p}\n+\t\t\tif p := wa[i].primary(); p <= vtop && p != 0 {\n+\t\t\t\twa[i] = makeQuaternary(p)\n \t\t\t\tignore = true\n \t\t\t} else if p == 0 {\n \t\t\t\tif ignore {\n-\t\t\t\t\twa[i] = weights{}\n-\t\t\t\t} else if wa[i].tertiary != 0 {\n-\t\t\t\t\twa[i].quaternary = maxQuaternary\n+\t\t\t\t\twa[i] = ceIgnore\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\twa[i].quaternary = maxQuaternary\n \t\t\t\tignore = false\n \t\t\t}\n \t\t}\n \tcase AltBlanked:\n \t\tfor i := range wa {\n-\t\t\tif p := wa[i].primary; p <= top && (ignore || p != 0) {\n-\t\t\t\twa[i] = weights{}\n+\t\t\tif p := wa[i].primary(); p <= vtop && (ignore || p != 0) {\n+\t\t\t\twa[i] = ceIgnore\n \t\t\t\tignore = true\n \t\t\t} else {\n \t\t\t\tignore = false"}, {"sha": "1915c93963be79b2031f1a3ce052247b1a72f76e", "filename": "libgo/go/exp/locale/collate/export.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -4,8 +4,6 @@\n \n package collate\n \n-import \"exp/norm\"\n-\n // Init is used by type Builder in exp/locale/collate/build/\n // to create Collator instances.  It is for internal use only.\n func Init(data interface{}) *Collator {\n@@ -24,11 +22,7 @@ func Init(data interface{}) *Collator {\n \tt.contractElem = init.ContractElems()\n \tt.maxContractLen = init.MaxContractLen()\n \tt.variableTop = init.VariableTop()\n-\treturn &Collator{\n-\t\tStrength: Quaternary,\n-\t\tf:        norm.NFD,\n-\t\tt:        t,\n-\t}\n+\treturn newCollator(t)\n }\n \n type tableInitializer interface {"}, {"sha": "3afe66457942ad624c9562226c8c70dd7c455fef", "filename": "libgo/go/exp/locale/collate/export_test.go", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fexport_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -24,6 +24,8 @@ func W(ce ...int) Weights {\n \t}\n \tif len(ce) > 3 {\n \t\tw.Quaternary = ce[3]\n+\t} else if w.Tertiary != 0 {\n+\t\tw.Quaternary = maxQuaternary\n \t}\n \treturn w\n }\n@@ -33,25 +35,27 @@ func (w Weights) String() string {\n \n type Table struct {\n \tt *table\n-\tw []weights\n }\n \n func GetTable(c *Collator) *Table {\n-\treturn &Table{c.t, nil}\n+\treturn &Table{c.t}\n }\n \n-func convertToWeights(ws []weights) []Weights {\n+func convertToWeights(ws []colElem) []Weights {\n \tout := make([]Weights, len(ws))\n \tfor i, w := range ws {\n-\t\tout[i] = Weights{int(w.primary), int(w.secondary), int(w.tertiary), int(w.quaternary)}\n+\t\tout[i] = Weights{int(w.primary()), int(w.secondary()), int(w.tertiary()), int(w.quaternary())}\n \t}\n \treturn out\n }\n \n-func convertFromWeights(ws []Weights) []weights {\n-\tout := make([]weights, len(ws))\n+func convertFromWeights(ws []Weights) []colElem {\n+\tout := make([]colElem, len(ws))\n \tfor i, w := range ws {\n-\t\tout[i] = weights{uint32(w.Primary), uint16(w.Secondary), uint8(w.Tertiary), uint32(w.Quaternary)}\n+\t\tout[i] = makeCE([]int{w.Primary, w.Secondary, w.Tertiary})\n+\t\tif out[i] == ceIgnore && w.Quaternary > 0 {\n+\t\t\tout[i] = makeQuaternary(w.Quaternary)\n+\t\t}\n \t}\n \treturn out\n }\n@@ -68,10 +72,9 @@ func SetTop(c *Collator, top int) {\n \tc.t.variableTop = uint32(top)\n }\n \n-func GetColElems(c *Collator, buf *Buffer, str []byte) []Weights {\n-\tbuf.ResetKeys()\n-\tc.getColElems(buf, str)\n-\treturn convertToWeights(buf.ce)\n+func GetColElems(c *Collator, str []byte) []Weights {\n+\tce := c.getColElems(str)\n+\treturn convertToWeights(ce)\n }\n \n func ProcessWeights(h AlternateHandling, top int, w []Weights) []Weights {"}, {"sha": "40bf10ab449d36f6f23c63c0c98bf9b153f2f969", "filename": "libgo/go/exp/locale/collate/maketables.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fmaketables.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -38,7 +38,7 @@ var (\n \t\t`URL of the Default Unicode Collation Element Table (DUCET). This can be a zip\n file containing the file allkeys_CLDR.txt or an allkeys.txt file.`)\n \tcldr = flag.String(\"cldr\",\n-\t\t\"http://www.unicode.org/Public/cldr/2.0.1/core.zip\",\n+\t\t\"http://www.unicode.org/Public/cldr/22/core.zip\",\n \t\t\"URL of CLDR archive.\")\n \ttest = flag.Bool(\"test\", false,\n \t\t\"test existing tables; can be used to compare web data with package data.\")\n@@ -180,7 +180,7 @@ func skipAlt(a string) bool {\n \n func failOnError(e error) {\n \tif e != nil {\n-\t\tlog.Fatal(e)\n+\t\tlog.Panic(e)\n \t}\n }\n \n@@ -607,7 +607,7 @@ func insertTailoring(t *build.Tailoring, r RuleElem, context, extend string) {\n \t\t\tif *test {\n \t\t\t\ttestInput.add(str)\n \t\t\t}\n-\t\t\terr := t.Insert(lmap[l[0]], str, extend)\n+\t\t\terr := t.Insert(lmap[l[0]], str, context+extend)\n \t\t\tfailOnError(err)\n \t\t}\n \tcase \"pc\", \"sc\", \"tc\", \"ic\":\n@@ -617,7 +617,7 @@ func insertTailoring(t *build.Tailoring, r RuleElem, context, extend string) {\n \t\t\tif *test {\n \t\t\t\ttestInput.add(str)\n \t\t\t}\n-\t\t\terr := t.Insert(level, str, extend)\n+\t\t\terr := t.Insert(level, str, context+extend)\n \t\t\tfailOnError(err)\n \t\t}\n \tdefault:\n@@ -677,7 +677,7 @@ func testCollator(c *collate.Collator) {\n \t\tif bytes.Compare(k0, k) != 0 {\n \t\t\tfailOnError(fmt.Errorf(\"test:%U: keys differ (%x vs %x)\", []rune(str), k0, k))\n \t\t}\n-\t\tbuf.ResetKeys()\n+\t\tbuf.Reset()\n \t}\n \tfmt.Println(\"PASS\")\n }"}, {"sha": "e30915ed894aba9268917673debab3b29d1bff79", "filename": "libgo/go/exp/locale/collate/regtest.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fregtest.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -236,9 +236,9 @@ func doTest(t Test) {\n \tif strings.Contains(t.name, \"NON_IGNOR\") {\n \t\tc.Alternate = collate.AltNonIgnorable\n \t}\n-\n \tprev := t.str[0]\n \tfor i := 1; i < len(t.str); i++ {\n+\t\tb.Reset()\n \t\ts := t.str[i]\n \t\tka := c.Key(b, prev)\n \t\tkb := c.Key(b, s)\n@@ -247,10 +247,10 @@ func doTest(t Test) {\n \t\t\tprev = s\n \t\t\tcontinue\n \t\t}\n-\t\tif r := c.Compare(b, prev, s); r == 1 {\n+\t\tif r := c.Compare(prev, s); r == 1 {\n \t\t\tfail(t, \"%d: Compare(%.4X, %.4X) == %d; want -1 or 0\", i, runes(prev), runes(s), r)\n \t\t}\n-\t\tif r := c.Compare(b, s, prev); r == -1 {\n+\t\tif r := c.Compare(s, prev); r == -1 {\n \t\t\tfail(t, \"%d: Compare(%.4X, %.4X) == %d; want 1 or 0\", i, runes(s), runes(prev), r)\n \t\t}\n \t\tprev = s"}, {"sha": "084308c72f8db2e6c98d20fcda4aaf569757ef4b", "filename": "libgo/go/exp/locale/collate/table.go", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftable.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -37,17 +37,21 @@ func (t *table) indexedTable(idx tableIndex) *table {\n \treturn &nt\n }\n \n-// appendNext appends the weights corresponding to the next rune or \n+// appendNext appends the weights corresponding to the next rune or\n // contraction in s.  If a contraction is matched to a discontinuous\n-// sequence of runes, the weights for the interstitial runes are \n+// sequence of runes, the weights for the interstitial runes are\n // appended as well.  It returns a new slice that includes the appended\n // weights and the number of bytes consumed from s.\n-func (t *table) appendNext(w []weights, s []byte) ([]weights, int) {\n+func (t *table) appendNext(w []colElem, s []byte) ([]colElem, int) {\n \tv, sz := t.index.lookup(s)\n \tce := colElem(v)\n \ttp := ce.ctype()\n \tif tp == ceNormal {\n-\t\tw = append(w, getWeights(ce, s))\n+\t\tif ce == 0 {\n+\t\t\tr, _ := utf8.DecodeRune(s)\n+\t\t\tce = makeImplicitCE(implicitPrimary(r))\n+\t\t}\n+\t\tw = append(w, ce)\n \t} else if tp == ceExpansionIndex {\n \t\tw = t.appendExpansion(w, ce)\n \t} else if tp == ceContractionIndex {\n@@ -62,40 +66,28 @@ func (t *table) appendNext(w []weights, s []byte) ([]weights, int) {\n \t\tfor p := 0; len(nfkd) > 0; nfkd = nfkd[p:] {\n \t\t\tw, p = t.appendNext(w, nfkd)\n \t\t}\n-\t\tw[i].tertiary = t1\n+\t\tw[i] = w[i].updateTertiary(t1)\n \t\tif i++; i < len(w) {\n-\t\t\tw[i].tertiary = t2\n+\t\t\tw[i] = w[i].updateTertiary(t2)\n \t\t\tfor i++; i < len(w); i++ {\n-\t\t\t\tw[i].tertiary = maxTertiary\n+\t\t\t\tw[i] = w[i].updateTertiary(maxTertiary)\n \t\t\t}\n \t\t}\n \t}\n \treturn w, sz\n }\n \n-func getWeights(ce colElem, s []byte) weights {\n-\tif ce == 0 { // implicit\n-\t\tr, _ := utf8.DecodeRune(s)\n-\t\treturn weights{\n-\t\t\tprimary:   uint32(implicitPrimary(r)),\n-\t\t\tsecondary: defaultSecondary,\n-\t\t\ttertiary:  defaultTertiary,\n-\t\t}\n-\t}\n-\treturn splitCE(ce)\n-}\n-\n-func (t *table) appendExpansion(w []weights, ce colElem) []weights {\n+func (t *table) appendExpansion(w []colElem, ce colElem) []colElem {\n \ti := splitExpandIndex(ce)\n \tn := int(t.expandElem[i])\n \ti++\n \tfor _, ce := range t.expandElem[i : i+n] {\n-\t\tw = append(w, splitCE(colElem(ce)))\n+\t\tw = append(w, colElem(ce))\n \t}\n \treturn w\n }\n \n-func (t *table) matchContraction(w []weights, ce colElem, suffix []byte) ([]weights, int) {\n+func (t *table) matchContraction(w []colElem, ce colElem, suffix []byte) ([]colElem, int) {\n \tindex, n, offset := splitContractIndex(ce)\n \n \tscan := t.contractTries.scanner(index, n, suffix)\n@@ -138,7 +130,7 @@ func (t *table) matchContraction(w []weights, ce colElem, suffix []byte) ([]weig\n \ti, n := scan.result()\n \tce = colElem(t.contractElem[i+offset])\n \tif ce.ctype() == ceNormal {\n-\t\tw = append(w, splitCE(ce))\n+\t\tw = append(w, ce)\n \t} else {\n \t\tw = t.appendExpansion(w, ce)\n \t}"}, {"sha": "15d33abad31d6f87885dacb1a0a4c8bd4f65fc05", "filename": "libgo/go/exp/locale/collate/tables.go", "status": "modified", "additions": 47052, "deletions": 6668, "changes": 53720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftables.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "3f8d7eed655835d5ff084dc538e17e17d4c8c233", "filename": "libgo/go/exp/locale/collate/tools/colcmp/col.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcol.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcol.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcol.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -91,5 +91,5 @@ func (c *goCollator) Key(b Input) []byte {\n }\n \n func (c *goCollator) Compare(a, b Input) int {\n-\treturn c.c.Compare(&c.buf, a.UTF8, b.UTF8)\n+\treturn c.c.Compare(a.UTF8, b.UTF8)\n }"}, {"sha": "66d12127bdfc33540ff6b1148eda458e8997931c", "filename": "libgo/go/exp/locale/collate/tools/colcmp/colcmp.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcolcmp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcolcmp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftools%2Fcolcmp%2Fcolcmp.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -399,7 +399,7 @@ var cmdRegress = &Command{\n }\n \n const failedKeyCompare = `\n-%d: incorrect comparison result for input:\n+%s:%d: incorrect comparison result for input:\n     a:   %q (%.4X)\n     key: %s\n     b:   %q (%.4X)\n@@ -412,7 +412,7 @@ const failedKeyCompare = `\n `\n \n const failedCompare = `\n-%d: incorrect comparison result for input:\n+%s:%d: incorrect comparison result for input:\n     a:   %q (%.4X)\n     b:   %q (%.4X)\n     Compare(a, b) = %d; want %d.\n@@ -453,12 +453,12 @@ func runRegress(ctxt *Context, args []string) {\n \t\t\t\tcount++\n \t\t\t\ta := string(ia.UTF8)\n \t\t\t\tb := string(ib.UTF8)\n-\t\t\t\tfmt.Printf(failedKeyCompare, i-1, a, []rune(a), keyStr(ia.key), b, []rune(b), keyStr(ib.key), cmp, goldCmp, keyStr(gold.Key(ia)), keyStr(gold.Key(ib)))\n+\t\t\t\tfmt.Printf(failedKeyCompare, t.Locale, i-1, a, []rune(a), keyStr(ia.key), b, []rune(b), keyStr(ib.key), cmp, goldCmp, keyStr(gold.Key(ia)), keyStr(gold.Key(ib)))\n \t\t\t} else if cmp := t.Col.Compare(ia, ib); cmp != goldCmp {\n \t\t\t\tcount++\n \t\t\t\ta := string(ia.UTF8)\n \t\t\t\tb := string(ib.UTF8)\n-\t\t\t\tfmt.Printf(failedKeyCompare, i-1, a, []rune(a), b, []rune(b), cmp, goldCmp)\n+\t\t\t\tfmt.Printf(failedCompare, t.Locale, i-1, a, []rune(a), b, []rune(b), cmp, goldCmp)\n \t\t\t}\n \t\t}\n \t\tif count > 0 {"}, {"sha": "f6259424d9256ce538fe1eaa8cad58b6fdefb3e0", "filename": "libgo/go/exp/locale/collate/trie.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -4,7 +4,7 @@\n \n // The trie in this file is used to associate the first full character\n // in an UTF-8 string to a collation element.\n-// All but the last byte in a UTF-8 byte sequence are \n+// All but the last byte in a UTF-8 byte sequence are\n // used to lookup offsets in the index table to be used for the next byte.\n // The last byte is used to index into a table of collation elements.\n // For a full description, see exp/locale/collate/build/trie.go."}, {"sha": "778e85614a3cb4195a90496a9babb2ea199ddb14", "filename": "libgo/go/exp/locale/collate/trie_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Ftrie_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -8,7 +8,7 @@ import (\n \t\"testing\"\n )\n \n-// We take the smallest, largest and an arbitrary value for each \n+// We take the smallest, largest and an arbitrary value for each\n // of the UTF-8 sequence lengths.\n var testRunes = []rune{\n \t0x01, 0x0C, 0x7F, // 1-byte sequences"}, {"sha": "c74efb56d9bccc37d4992289fb4e49faa4d61ecb", "filename": "libgo/go/exp/norm/forminfo.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -76,7 +76,7 @@ func init() {\n // We do not distinguish between boundaries for NFC, NFD, etc. to avoid\n // unexpected behavior for the user.  For example, in NFD, there is a boundary\n // after 'a'.  However, 'a' might combine with modifiers, so from the application's\n-// perspective it is not a good boundary. We will therefore always use the \n+// perspective it is not a good boundary. We will therefore always use the\n // boundaries for the combining variants.\n \n // BoundaryBefore returns true if this rune starts a new segment and\n@@ -101,7 +101,7 @@ func (p Properties) BoundaryAfter() bool {\n //   0:    NFD_QC Yes (0) or No (1). No also means there is a decomposition.\n //   1..2: NFC_QC Yes(00), No (10), or Maybe (11)\n //   3:    Combines forward  (0 == false, 1 == true)\n-// \n+//\n // When all 4 bits are zero, the character is inert, meaning it is never\n // influenced by normalization.\n type qcInfo uint8"}, {"sha": "c0ab25e5658679082d12a441d7851454904164d1", "filename": "libgo/go/exp/norm/iter.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -64,9 +64,9 @@ func (i *Iter) Done() bool {\n }\n \n // Next writes f(i.input[i.Pos():n]...) to buffer buf, where n is the\n-// largest boundary of i.input such that the result fits in buf.  \n+// largest boundary of i.input such that the result fits in buf.\n // It returns the number of bytes written to buf.\n-// len(buf) should be at least MaxSegmentSize. \n+// len(buf) should be at least MaxSegmentSize.\n // Done must be false before calling Next.\n func (i *Iter) Next(buf []byte) int {\n \treturn i.next(i, buf)"}, {"sha": "2ba67a5ab4b86db387b52a1b921cf7443345f891", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -86,7 +86,7 @@ const (\n // Quick Check properties of runes allow us to quickly\n // determine whether a rune may occur in a normal form.\n // For a given normal form, a rune may be guaranteed to occur\n-// verbatim (QC=Yes), may or may not combine with another \n+// verbatim (QC=Yes), may or may not combine with another\n // rune (QC=Maybe), or may not occur (QC=No).\n type QCResult int\n "}, {"sha": "6d11ec069cda59216f880add4a73cbd84e4001a4", "filename": "libgo/go/exp/norm/maketesttables.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -16,7 +16,7 @@ func main() {\n \tprintTestTables()\n }\n \n-// We take the smallest, largest and an arbitrary value for each \n+// We take the smallest, largest and an arbitrary value for each\n // of the UTF-8 sequence lengths.\n var testRunes = []rune{\n \t0x01, 0x0C, 0x7F, // 1-byte sequences"}, {"sha": "0dd25596123e64118a559fe540bf015292abe7d3", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -57,7 +57,7 @@ var logger = log.New(os.Stderr, \"\", log.Lshortfile)\n // 1E0A;1E0A;0044 0307;1E0A;0044 0307; # (\u1e0a; \u1e0a; D\u25cc\u0307; \u1e0a; D\u25cc\u0307; ) LATIN CAPITAL LETTER D WITH DOT ABOVE\n // 1E0C;1E0C;0044 0323;1E0C;0044 0323; # (\u1e0c; \u1e0c; D\u25cc\u0323; \u1e0c; D\u25cc\u0323; ) LATIN CAPITAL LETTER D WITH DOT BELOW\n //\n-// Each test has 5 columns (c1, c2, c3, c4, c5), where \n+// Each test has 5 columns (c1, c2, c3, c4, c5), where\n // (c1, c2, c3, c4, c5) == (c1, NFC(c1), NFD(c1), NFKC(c1), NFKD(c1))\n //\n // CONFORMANCE:"}, {"sha": "20174c6628597a9c14420dfa0152bb1ea858d82d", "filename": "libgo/go/exp/norm/tables.go", "status": "modified", "additions": 4350, "deletions": 4232, "changes": 8582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "88267042e4b271cbb24eab79f4c5acd7746d112b", "filename": "libgo/go/exp/types/builtins.go", "status": "renamed", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fbuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fbuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fbuiltins.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -44,7 +44,7 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tswitch id {\n \t\tcase _Make, _New:\n \t\t\t// argument must be a type\n-\t\t\ttyp0 = underlying(check.typ(arg0, false))\n+\t\t\ttyp0 = check.typ(arg0, false)\n \t\t\tif typ0 == Typ[Invalid] {\n \t\t\t\tgoto Error\n \t\t\t}\n@@ -191,7 +191,7 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \n \tcase _Make:\n \t\tvar min int // minimum number of arguments\n-\t\tswitch typ0.(type) {\n+\t\tswitch underlying(typ0).(type) {\n \t\tcase *Slice:\n \t\t\tmin = 2\n \t\tcase *Map, *Chan:\n@@ -204,13 +204,27 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\t\tcheck.errorf(call.Pos(), \"%s expects %d or %d arguments; found %d\", call, min, min+1, n)\n \t\t\tgoto Error\n \t\t}\n+\t\tvar sizes []interface{} // constant integer arguments, if any\n \t\tfor _, arg := range args[1:] {\n \t\t\tcheck.expr(x, arg, nil, iota)\n-\t\t\tif !x.isInteger() {\n+\t\t\tif x.isInteger() {\n+\t\t\t\tif x.mode == constant {\n+\t\t\t\t\tif isNegConst(x.val) {\n+\t\t\t\t\t\tcheck.invalidArg(x.pos(), \"%s must not be negative\", x)\n+\t\t\t\t\t\t// safe to continue\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsizes = append(sizes, x.val) // x.val >= 0\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n \t\t\t\tcheck.invalidArg(x.pos(), \"%s must be an integer\", x)\n \t\t\t\t// safe to continue\n \t\t\t}\n \t\t}\n+\t\tif len(sizes) == 2 && compareConst(sizes[0], sizes[1], token.GTR) {\n+\t\t\tcheck.invalidArg(args[1].Pos(), \"length and capacity swapped\")\n+\t\t\t// safe to continue\n+\t\t}\n \t\tx.mode = variable\n \t\tx.typ = typ0\n \n@@ -287,7 +301,7 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tvar t operand\n \t\tx1 := x\n \t\tfor _, arg := range args {\n-\t\t\tcheck.exprOrType(x1, arg, nil, iota, true) // permit trace for types, e.g.: new(trace(T))\n+\t\t\tcheck.rawExpr(x1, arg, nil, iota, true) // permit trace for types, e.g.: new(trace(T))\n \t\t\tcheck.dump(\"%s: %s\", x1.pos(), x1)\n \t\t\tx1 = &t // use incoming x only for first argument\n \t\t}", "previous_filename": "libgo/go/exp/types/staging/builtins.go"}, {"sha": "1300d0a6dd812afc4c131c8476ddcfda61cf0eb7", "filename": "libgo/go/exp/types/check.go", "status": "modified", "additions": 320, "deletions": 198, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -9,244 +9,366 @@ package types\n import (\n \t\"fmt\"\n \t\"go/ast\"\n-\t\"go/scanner\"\n \t\"go/token\"\n-\t\"strconv\"\n+\t\"sort\"\n )\n \n-const debug = false\n+// enable for debugging\n+const trace = false\n \n type checker struct {\n-\tfset   *token.FileSet\n-\terrors scanner.ErrorList\n-\ttypes  map[ast.Expr]Type\n-}\n+\tfset *token.FileSet\n+\tpkg  *ast.Package\n+\terrh func(token.Pos, string)\n+\tmapf func(ast.Expr, Type)\n \n-func (c *checker) errorf(pos token.Pos, format string, args ...interface{}) string {\n-\tmsg := fmt.Sprintf(format, args...)\n-\tc.errors.Add(c.fset.Position(pos), msg)\n-\treturn msg\n+\t// lazily initialized\n+\tfirsterr  error\n+\tfilenames []string                      // sorted list of package file names for reproducible iteration order\n+\tinitexprs map[*ast.ValueSpec][]ast.Expr // \"inherited\" initialization expressions for constant declarations\n+\tfunctypes []*Signature                  // stack of function signatures; actively typechecked function on top\n+\tpos       []token.Pos                   // stack of expr positions; debugging support, used if trace is set\n }\n \n-// collectFields collects struct fields tok = token.STRUCT), interface methods\n-// (tok = token.INTERFACE), and function arguments/results (tok = token.FUNC).\n+// declare declares an object of the given kind and name (ident) in scope;\n+// decl is the corresponding declaration in the AST. An error is reported\n+// if the object was declared before.\n //\n-func (c *checker) collectFields(tok token.Token, list *ast.FieldList, cycleOk bool) (fields ObjList, tags []string, isVariadic bool) {\n-\tif list != nil {\n-\t\tfor _, field := range list.List {\n-\t\t\tftype := field.Type\n-\t\t\tif t, ok := ftype.(*ast.Ellipsis); ok {\n-\t\t\t\tftype = t.Elt\n-\t\t\t\tisVariadic = true\n-\t\t\t}\n-\t\t\ttyp := c.makeType(ftype, cycleOk)\n-\t\t\ttag := \"\"\n-\t\t\tif field.Tag != nil {\n-\t\t\t\tassert(field.Tag.Kind == token.STRING)\n-\t\t\t\ttag, _ = strconv.Unquote(field.Tag.Value)\n-\t\t\t}\n-\t\t\tif len(field.Names) > 0 {\n-\t\t\t\t// named fields\n-\t\t\t\tfor _, name := range field.Names {\n-\t\t\t\t\tobj := name.Obj\n-\t\t\t\t\tobj.Type = typ\n-\t\t\t\t\tfields = append(fields, obj)\n-\t\t\t\t\tif tok == token.STRUCT {\n-\t\t\t\t\t\ttags = append(tags, tag)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// anonymous field\n-\t\t\t\tswitch tok {\n-\t\t\t\tcase token.STRUCT:\n-\t\t\t\t\ttags = append(tags, tag)\n-\t\t\t\t\tfallthrough\n-\t\t\t\tcase token.FUNC:\n-\t\t\t\t\tobj := ast.NewObj(ast.Var, \"\")\n-\t\t\t\t\tobj.Type = typ\n-\t\t\t\t\tfields = append(fields, obj)\n-\t\t\t\tcase token.INTERFACE:\n-\t\t\t\t\tutyp := Underlying(typ)\n-\t\t\t\t\tif typ, ok := utyp.(*Interface); ok {\n-\t\t\t\t\t\t// TODO(gri) This is not good enough. Check for double declarations!\n-\t\t\t\t\t\tfields = append(fields, typ.Methods...)\n-\t\t\t\t\t} else if _, ok := utyp.(*Bad); !ok {\n-\t\t\t\t\t\t// if utyp is Bad, don't complain (the root cause was reported before)\n-\t\t\t\t\t\tc.errorf(ftype.Pos(), \"interface contains embedded non-interface type\")\n-\t\t\t\t\t}\n-\t\t\t\tdefault:\n-\t\t\t\t\tpanic(\"unreachable\")\n-\t\t\t\t}\n+// TODO(gri) This is very similar to the declare function in go/parser; it\n+// is only used to associate methods with their respective receiver base types.\n+// In a future version, it might be simpler and cleaner do to all the resolution\n+// in the type-checking phase. It would simplify the parser, AST, and also\n+// reduce some amount of code duplication.\n+//\n+func (check *checker) declare(scope *ast.Scope, kind ast.ObjKind, ident *ast.Ident, decl ast.Decl) {\n+\tassert(ident.Obj == nil) // identifier already declared or resolved\n+\tobj := ast.NewObj(kind, ident.Name)\n+\tobj.Decl = decl\n+\tident.Obj = obj\n+\tif ident.Name != \"_\" {\n+\t\tif alt := scope.Insert(obj); alt != nil {\n+\t\t\tprevDecl := \"\"\n+\t\t\tif pos := alt.Pos(); pos.IsValid() {\n+\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", check.fset.Position(pos))\n \t\t\t}\n+\t\t\tcheck.errorf(ident.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", ident.Name, prevDecl))\n \t\t}\n \t}\n-\treturn\n }\n \n-// makeType makes a new type for an AST type specification x or returns\n-// the type referred to by a type name x. If cycleOk is set, a type may\n-// refer to itself directly or indirectly; otherwise cycles are errors.\n-//\n-func (c *checker) makeType(x ast.Expr, cycleOk bool) (typ Type) {\n-\tif debug {\n-\t\tfmt.Printf(\"makeType (cycleOk = %v)\\n\", cycleOk)\n-\t\tast.Print(c.fset, x)\n-\t\tdefer func() {\n-\t\t\tfmt.Printf(\"-> %T %v\\n\\n\", typ, typ)\n-\t\t}()\n-\t}\n-\n-\tswitch t := x.(type) {\n-\tcase *ast.BadExpr:\n-\t\treturn &Bad{}\n-\n-\tcase *ast.Ident:\n-\t\t// type name\n-\t\tobj := t.Obj\n-\t\tif obj == nil {\n-\t\t\t// unresolved identifier (error has been reported before)\n-\t\t\treturn &Bad{Msg: fmt.Sprintf(\"%s is unresolved\", t.Name)}\n-\t\t}\n-\t\tif obj.Kind != ast.Typ {\n-\t\t\tmsg := c.errorf(t.Pos(), \"%s is not a type\", t.Name)\n-\t\t\treturn &Bad{Msg: msg}\n-\t\t}\n-\t\tc.checkObj(obj, cycleOk)\n-\t\tif !cycleOk && obj.Type.(*Name).Underlying == nil {\n-\t\t\tmsg := c.errorf(obj.Pos(), \"illegal cycle in declaration of %s\", obj.Name)\n-\t\t\treturn &Bad{Msg: msg}\n-\t\t}\n-\t\treturn obj.Type.(Type)\n-\n-\tcase *ast.ParenExpr:\n-\t\treturn c.makeType(t.X, cycleOk)\n-\n-\tcase *ast.SelectorExpr:\n-\t\t// qualified identifier\n-\t\t// TODO (gri) eventually, this code belongs to expression\n-\t\t//            type checking - here for the time being\n-\t\tif ident, ok := t.X.(*ast.Ident); ok {\n-\t\t\tif obj := ident.Obj; obj != nil {\n-\t\t\t\tif obj.Kind != ast.Pkg {\n-\t\t\t\t\tmsg := c.errorf(ident.Pos(), \"%s is not a package\", obj.Name)\n-\t\t\t\t\treturn &Bad{Msg: msg}\n-\t\t\t\t}\n-\t\t\t\t// TODO(gri) we have a package name but don't\n-\t\t\t\t// have the mapping from package name to package\n-\t\t\t\t// scope anymore (created in ast.NewPackage).\n-\t\t\t\treturn &Bad{} // for now\n-\t\t\t}\n-\t\t}\n-\t\t// TODO(gri) can this really happen (the parser should have excluded this)?\n-\t\tmsg := c.errorf(t.Pos(), \"expected qualified identifier\")\n-\t\treturn &Bad{Msg: msg}\n+func (check *checker) valueSpec(pos token.Pos, obj *ast.Object, lhs []*ast.Ident, typ ast.Expr, rhs []ast.Expr, iota int) {\n+\tif len(lhs) == 0 {\n+\t\tcheck.invalidAST(pos, \"missing lhs in declaration\")\n+\t\treturn\n+\t}\n \n-\tcase *ast.StarExpr:\n-\t\treturn &Pointer{Base: c.makeType(t.X, true)}\n+\t// determine type for all of lhs, if any\n+\t// (but only set it for the object we typecheck!)\n+\tvar t Type\n+\tif typ != nil {\n+\t\tt = check.typ(typ, false)\n+\t}\n \n-\tcase *ast.ArrayType:\n-\t\tif t.Len != nil {\n-\t\t\t// TODO(gri) compute length\n-\t\t\treturn &Array{Elt: c.makeType(t.Elt, cycleOk)}\n+\t// len(lhs) > 0\n+\tif len(lhs) == len(rhs) {\n+\t\t// check only lhs and rhs corresponding to obj\n+\t\tvar l, r ast.Expr\n+\t\tfor i, name := range lhs {\n+\t\t\tif name.Obj == obj {\n+\t\t\t\tl = lhs[i]\n+\t\t\t\tr = rhs[i]\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t}\n-\t\treturn &Slice{Elt: c.makeType(t.Elt, true)}\n-\n-\tcase *ast.StructType:\n-\t\tfields, tags, _ := c.collectFields(token.STRUCT, t.Fields, cycleOk)\n-\t\treturn &Struct{Fields: fields, Tags: tags}\n-\n-\tcase *ast.FuncType:\n-\t\tparams, _, isVariadic := c.collectFields(token.FUNC, t.Params, true)\n-\t\tresults, _, _ := c.collectFields(token.FUNC, t.Results, true)\n-\t\treturn &Func{Recv: nil, Params: params, Results: results, IsVariadic: isVariadic}\n+\t\tassert(l != nil)\n+\t\tobj.Type = t\n+\t\tcheck.assign1to1(l, r, nil, true, iota)\n+\t\treturn\n+\t}\n \n-\tcase *ast.InterfaceType:\n-\t\tmethods, _, _ := c.collectFields(token.INTERFACE, t.Methods, cycleOk)\n-\t\tmethods.Sort()\n-\t\treturn &Interface{Methods: methods}\n+\t// there must be a type or initialization expressions\n+\tif t == nil && len(rhs) == 0 {\n+\t\tcheck.invalidAST(pos, \"missing type or initialization expression\")\n+\t\tt = Typ[Invalid]\n+\t}\n \n-\tcase *ast.MapType:\n-\t\treturn &Map{Key: c.makeType(t.Key, true), Elt: c.makeType(t.Value, true)}\n+\t// if we have a type, mark all of lhs\n+\tif t != nil {\n+\t\tfor _, name := range lhs {\n+\t\t\tname.Obj.Type = t\n+\t\t}\n+\t}\n \n-\tcase *ast.ChanType:\n-\t\treturn &Chan{Dir: t.Dir, Elt: c.makeType(t.Value, true)}\n+\t// check initial values, if any\n+\tif len(rhs) > 0 {\n+\t\t// TODO(gri) should try to avoid this conversion\n+\t\tlhx := make([]ast.Expr, len(lhs))\n+\t\tfor i, e := range lhs {\n+\t\t\tlhx[i] = e\n+\t\t}\n+\t\tcheck.assignNtoM(lhx, rhs, true, iota)\n \t}\n+}\n \n-\tpanic(fmt.Sprintf(\"unreachable (%T)\", x))\n+func (check *checker) function(typ *Signature, body *ast.BlockStmt) {\n+\tcheck.functypes = append(check.functypes, typ)\n+\tcheck.stmt(body)\n+\tcheck.functypes = check.functypes[0 : len(check.functypes)-1]\n }\n \n-// checkObj type checks an object.\n-func (c *checker) checkObj(obj *ast.Object, ref bool) {\n-\tif obj.Type != nil {\n-\t\t// object has already been type checked\n-\t\treturn\n-\t}\n+// object typechecks an object by assigning it a type; obj.Type must be nil.\n+// Callers must check obj.Type before calling object; this eliminates a call\n+// for each identifier that has been typechecked already, a common scenario.\n+//\n+func (check *checker) object(obj *ast.Object, cycleOk bool) {\n+\tassert(obj.Type == nil)\n \n \tswitch obj.Kind {\n-\tcase ast.Bad:\n-\t\t// ignore\n+\tcase ast.Bad, ast.Pkg:\n+\t\t// nothing to do\n \n-\tcase ast.Con:\n-\t\t// TODO(gri) complete this\n+\tcase ast.Con, ast.Var:\n+\t\t// The obj.Data field for constants and variables is initialized\n+\t\t// to the respective (hypothetical, for variables) iota value by\n+\t\t// the parser. The object's fields can be in one of the following\n+\t\t// states:\n+\t\t// Type != nil  =>  the constant value is Data\n+\t\t// Type == nil  =>  the object is not typechecked yet, and Data can be:\n+\t\t// Data is int  =>  Data is the value of iota for this declaration\n+\t\t// Data == nil  =>  the object's expression is being evaluated\n+\t\tif obj.Data == nil {\n+\t\t\tcheck.errorf(obj.Pos(), \"illegal cycle in initialization of %s\", obj.Name)\n+\t\t\tobj.Type = Typ[Invalid]\n+\t\t\treturn\n+\t\t}\n+\t\tspec := obj.Decl.(*ast.ValueSpec)\n+\t\tiota := obj.Data.(int)\n+\t\tobj.Data = nil\n+\t\t// determine initialization expressions\n+\t\tvalues := spec.Values\n+\t\tif len(values) == 0 && obj.Kind == ast.Con {\n+\t\t\tvalues = check.initexprs[spec]\n+\t\t}\n+\t\tcheck.valueSpec(spec.Pos(), obj, spec.Names, spec.Type, values, iota)\n \n \tcase ast.Typ:\n-\t\ttyp := &Name{Obj: obj}\n+\t\ttyp := &NamedType{Obj: obj}\n \t\tobj.Type = typ // \"mark\" object so recursion terminates\n-\t\ttyp.Underlying = Underlying(c.makeType(obj.Decl.(*ast.TypeSpec).Type, ref))\n-\n-\tcase ast.Var:\n-\t\t// TODO(gri) complete this\n+\t\ttyp.Underlying = underlying(check.typ(obj.Decl.(*ast.TypeSpec).Type, cycleOk))\n+\t\t// typecheck associated method signatures\n+\t\tif obj.Data != nil {\n+\t\t\tscope := obj.Data.(*ast.Scope)\n+\t\t\tswitch t := typ.Underlying.(type) {\n+\t\t\tcase *Struct:\n+\t\t\t\t// struct fields must not conflict with methods\n+\t\t\t\tfor _, f := range t.Fields {\n+\t\t\t\t\tif m := scope.Lookup(f.Name); m != nil {\n+\t\t\t\t\t\tcheck.errorf(m.Pos(), \"type %s has both field and method named %s\", obj.Name, f.Name)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// ok to continue\n+\t\t\tcase *Interface:\n+\t\t\t\t// methods cannot be associated with an interface type\n+\t\t\t\tfor _, m := range scope.Objects {\n+\t\t\t\t\trecv := m.Decl.(*ast.FuncDecl).Recv.List[0].Type\n+\t\t\t\t\tcheck.errorf(recv.Pos(), \"invalid receiver type %s (%s is an interface type)\", obj.Name, obj.Name)\n+\t\t\t\t}\n+\t\t\t\t// ok to continue\n+\t\t\t}\n+\t\t\t// typecheck method signatures\n+\t\t\tfor _, m := range scope.Objects {\n+\t\t\t\tmdecl := m.Decl.(*ast.FuncDecl)\n+\t\t\t\t// TODO(gri) At the moment, the receiver is type-checked when checking\n+\t\t\t\t// the method body. Also, we don't properly track if the receiver is\n+\t\t\t\t// a pointer (i.e., currently, method sets are too large). FIX THIS.\n+\t\t\t\tmtyp := check.typ(mdecl.Type, cycleOk).(*Signature)\n+\t\t\t\tm.Type = mtyp\n+\t\t\t}\n+\t\t}\n \n \tcase ast.Fun:\n \t\tfdecl := obj.Decl.(*ast.FuncDecl)\n-\t\tftyp := c.makeType(fdecl.Type, ref).(*Func)\n-\t\tobj.Type = ftyp\n \t\tif fdecl.Recv != nil {\n-\t\t\trecvField := fdecl.Recv.List[0]\n-\t\t\tif len(recvField.Names) > 0 {\n-\t\t\t\tftyp.Recv = recvField.Names[0].Obj\n-\t\t\t} else {\n-\t\t\t\tftyp.Recv = ast.NewObj(ast.Var, \"_\")\n-\t\t\t\tftyp.Recv.Decl = recvField\n-\t\t\t}\n-\t\t\tc.checkObj(ftyp.Recv, ref)\n-\t\t\t// TODO(axw) add method to a list in the receiver type.\n+\t\t\t// This will ensure that the method base type is\n+\t\t\t// type-checked\n+\t\t\tcheck.collectFields(token.FUNC, fdecl.Recv, true)\n \t\t}\n-\t\t// TODO(axw) check function body, if non-nil.\n+\t\tftyp := check.typ(fdecl.Type, cycleOk).(*Signature)\n+\t\tobj.Type = ftyp\n+\t\tcheck.function(ftyp, fdecl.Body)\n \n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}\n }\n \n-// Check typechecks a package.\n-// It augments the AST by assigning types to all ast.Objects and returns a map\n-// of types for all expression nodes in statements, and a scanner.ErrorList if\n-// there are errors.\n+// assocInitvals associates \"inherited\" initialization expressions\n+// with the corresponding *ast.ValueSpec in the check.initexprs map\n+// for constant declarations without explicit initialization expressions.\n //\n-func Check(fset *token.FileSet, pkg *ast.Package) (types map[ast.Expr]Type, err error) {\n-\t// Sort objects so that we get reproducible error\n-\t// positions (this is only needed for testing).\n-\t// TODO(gri): Consider ast.Scope implementation that\n-\t// provides both a list and a map for fast lookup.\n-\t// Would permit the use of scopes instead of ObjMaps\n-\t// elsewhere.\n-\tlist := make(ObjList, len(pkg.Scope.Objects))\n-\ti := 0\n-\tfor _, obj := range pkg.Scope.Objects {\n-\t\tlist[i] = obj\n-\t\ti++\n-\t}\n-\tlist.Sort()\n-\n-\tvar c checker\n-\tc.fset = fset\n-\tc.types = make(map[ast.Expr]Type)\n-\n-\tfor _, obj := range list {\n-\t\tc.checkObj(obj, false)\n-\t}\n-\n-\tc.errors.RemoveMultiples()\n-\treturn c.types, c.errors.Err()\n+func (check *checker) assocInitvals(decl *ast.GenDecl) {\n+\tvar values []ast.Expr\n+\tfor _, s := range decl.Specs {\n+\t\tif s, ok := s.(*ast.ValueSpec); ok {\n+\t\t\tif len(s.Values) > 0 {\n+\t\t\t\tvalues = s.Values\n+\t\t\t} else {\n+\t\t\t\tcheck.initexprs[s] = values\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif len(values) == 0 {\n+\t\tcheck.invalidAST(decl.Pos(), \"no initialization values provided\")\n+\t}\n+}\n+\n+// assocMethod associates a method declaration with the respective\n+// receiver base type. meth.Recv must exist.\n+//\n+func (check *checker) assocMethod(meth *ast.FuncDecl) {\n+\t// The receiver type is one of the following (enforced by parser):\n+\t// - *ast.Ident\n+\t// - *ast.StarExpr{*ast.Ident}\n+\t// - *ast.BadExpr (parser error)\n+\ttyp := meth.Recv.List[0].Type\n+\tif ptr, ok := typ.(*ast.StarExpr); ok {\n+\t\ttyp = ptr.X\n+\t}\n+\t// determine receiver base type object (or nil if error)\n+\tvar obj *ast.Object\n+\tif ident, ok := typ.(*ast.Ident); ok && ident.Obj != nil {\n+\t\tobj = ident.Obj\n+\t\tif obj.Kind != ast.Typ {\n+\t\t\tcheck.errorf(ident.Pos(), \"%s is not a type\", ident.Name)\n+\t\t\tobj = nil\n+\t\t}\n+\t\t// TODO(gri) determine if obj was defined in this package\n+\t\t/*\n+\t\t\tif check.notLocal(obj) {\n+\t\t\t\tcheck.errorf(ident.Pos(), \"cannot define methods on non-local type %s\", ident.Name)\n+\t\t\t\tobj = nil\n+\t\t\t}\n+\t\t*/\n+\t} else {\n+\t\t// If it's not an identifier or the identifier wasn't declared/resolved,\n+\t\t// the parser/resolver already reported an error. Nothing to do here.\n+\t}\n+\t// determine base type scope (or nil if error)\n+\tvar scope *ast.Scope\n+\tif obj != nil {\n+\t\tif obj.Data != nil {\n+\t\t\tscope = obj.Data.(*ast.Scope)\n+\t\t} else {\n+\t\t\tscope = ast.NewScope(nil)\n+\t\t\tobj.Data = scope\n+\t\t}\n+\t} else {\n+\t\t// use a dummy scope so that meth can be declared in\n+\t\t// presence of an error and get an associated object\n+\t\t// (always use a new scope so that we don't get double\n+\t\t// declaration errors)\n+\t\tscope = ast.NewScope(nil)\n+\t}\n+\tcheck.declare(scope, ast.Fun, meth.Name, meth)\n+}\n+\n+func (check *checker) assocInitvalsOrMethod(decl ast.Decl) {\n+\tswitch d := decl.(type) {\n+\tcase *ast.GenDecl:\n+\t\tif d.Tok == token.CONST {\n+\t\t\tcheck.assocInitvals(d)\n+\t\t}\n+\tcase *ast.FuncDecl:\n+\t\tif d.Recv != nil {\n+\t\t\tcheck.assocMethod(d)\n+\t\t}\n+\t}\n+}\n+\n+func (check *checker) decl(decl ast.Decl) {\n+\tswitch d := decl.(type) {\n+\tcase *ast.BadDecl:\n+\t\t// ignore\n+\tcase *ast.GenDecl:\n+\t\tfor _, spec := range d.Specs {\n+\t\t\tswitch s := spec.(type) {\n+\t\t\tcase *ast.ImportSpec:\n+\t\t\t\t// nothing to do (handled by ast.NewPackage)\n+\t\t\tcase *ast.ValueSpec:\n+\t\t\t\tfor _, name := range s.Names {\n+\t\t\t\t\tif obj := name.Obj; obj.Type == nil {\n+\t\t\t\t\t\tcheck.object(obj, false)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase *ast.TypeSpec:\n+\t\t\t\tif obj := s.Name.Obj; obj.Type == nil {\n+\t\t\t\t\tcheck.object(obj, false)\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tcheck.invalidAST(s.Pos(), \"unknown ast.Spec node %T\", s)\n+\t\t\t}\n+\t\t}\n+\tcase *ast.FuncDecl:\n+\t\tif d.Name.Name == \"init\" {\n+\t\t\t// initialization function\n+\t\t\t// TODO(gri) ignore for now (has no object associated with it)\n+\t\t\t// (should probably collect in a first phase and properly initialize)\n+\t\t\treturn\n+\t\t}\n+\t\tif obj := d.Name.Obj; obj.Type == nil {\n+\t\t\tcheck.object(obj, false)\n+\t\t}\n+\tdefault:\n+\t\tcheck.invalidAST(d.Pos(), \"unknown ast.Decl node %T\", d)\n+\t}\n+}\n+\n+// iterate calls f for each package-level declaration.\n+func (check *checker) iterate(f func(*checker, ast.Decl)) {\n+\tlist := check.filenames\n+\n+\tif list == nil {\n+\t\t// initialize lazily\n+\t\tfor filename := range check.pkg.Files {\n+\t\t\tlist = append(list, filename)\n+\t\t}\n+\t\tsort.Strings(list)\n+\t\tcheck.filenames = list\n+\t}\n+\n+\tfor _, filename := range list {\n+\t\tfor _, decl := range check.pkg.Files[filename].Decls {\n+\t\t\tf(check, decl)\n+\t\t}\n+\t}\n+}\n+\n+// A bailout panic is raised to indicate early termination.\n+type bailout struct{}\n+\n+func check(fset *token.FileSet, pkg *ast.Package, errh func(token.Pos, string), f func(ast.Expr, Type)) (err error) {\n+\t// initialize checker\n+\tvar check checker\n+\tcheck.fset = fset\n+\tcheck.pkg = pkg\n+\tcheck.errh = errh\n+\tcheck.mapf = f\n+\tcheck.initexprs = make(map[*ast.ValueSpec][]ast.Expr)\n+\n+\t// handle bailouts\n+\tdefer func() {\n+\t\tif p := recover(); p != nil {\n+\t\t\t_ = p.(bailout) // re-panic if not a bailout\n+\t\t}\n+\t\terr = check.firsterr\n+\t}()\n+\n+\t// determine missing constant initialization expressions\n+\t// and associate methods with types\n+\tcheck.iterate((*checker).assocInitvalsOrMethod)\n+\n+\t// typecheck all declarations\n+\tcheck.iterate((*checker).decl)\n+\n+\treturn\n }"}, {"sha": "bd60f5b64844704452d08490281a7b8cfd2ee053", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -23,17 +23,21 @@\n package types\n \n import (\n-\t// \"fmt\"\n+\t\"flag\"\n+\t\"fmt\"\n \t\"go/ast\"\n \t\"go/parser\"\n \t\"go/scanner\"\n \t\"go/token\"\n \t\"io/ioutil\"\n-\t// \"os\"\n+\t\"os\"\n \t\"regexp\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n+var listErrors = flag.Bool(\"list\", false, \"list errors\")\n+\n // The test filenames do not end in .go so that they are invisible\n // to gofmt since they contain comments that must not change their\n // positions relative to surrounding tokens.\n@@ -42,7 +46,17 @@ var tests = []struct {\n \tname  string\n \tfiles []string\n }{\n-\t{\"test0\", []string{\"testdata/test0.src\"}},\n+\t{\"decls0\", []string{\"testdata/decls0.src\"}},\n+\t{\"decls1\", []string{\"testdata/decls1.src\"}},\n+\t{\"decls2\", []string{\"testdata/decls2a.src\", \"testdata/decls2b.src\"}},\n+\t{\"const0\", []string{\"testdata/const0.src\"}},\n+\t{\"expr0\", []string{\"testdata/expr0.src\"}},\n+\t{\"expr1\", []string{\"testdata/expr1.src\"}},\n+\t{\"expr2\", []string{\"testdata/expr2.src\"}},\n+\t{\"expr3\", []string{\"testdata/expr3.src\"}},\n+\t{\"builtins\", []string{\"testdata/builtins.src\"}},\n+\t{\"conversions\", []string{\"testdata/conversions.src\"}},\n+\t{\"stmt0\", []string{\"testdata/stmt0.src\"}},\n }\n \n var fset = token.NewFileSet()\n@@ -96,8 +110,9 @@ var errRx = regexp.MustCompile(`^/\\* *ERROR *\"([^\"]*)\" *\\*/$`)\n // expectedErrors collects the regular expressions of ERROR comments found\n // in files and returns them as a map of error positions to error messages.\n //\n-func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) map[token.Pos]string {\n-\terrors := make(map[token.Pos]string)\n+func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) map[token.Pos][]string {\n+\terrors := make(map[token.Pos][]string)\n+\n \tfor filename := range files {\n \t\tsrc, err := ioutil.ReadFile(filename)\n \t\tif err != nil {\n@@ -120,7 +135,8 @@ func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) m\n \t\t\tcase token.COMMENT:\n \t\t\t\ts := errRx.FindStringSubmatch(lit)\n \t\t\t\tif len(s) == 2 {\n-\t\t\t\t\terrors[prev] = string(s[1])\n+\t\t\t\t\tlist := errors[prev]\n+\t\t\t\t\terrors[prev] = append(list, string(s[1]))\n \t\t\t\t}\n \t\t\tcase token.SEMICOLON:\n \t\t\t\t// ignore automatically inserted semicolon\n@@ -133,45 +149,51 @@ func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) m\n \t\t\t}\n \t\t}\n \t}\n+\n \treturn errors\n }\n \n-func eliminate(t *testing.T, expected map[token.Pos]string, errors error) {\n-\tif errors == nil {\n+func eliminate(t *testing.T, expected map[token.Pos][]string, errors error) {\n+\tif *listErrors || errors == nil {\n \t\treturn\n \t}\n \tfor _, error := range errors.(scanner.ErrorList) {\n \t\t// error.Pos is a token.Position, but we want\n \t\t// a token.Pos so we can do a map lookup\n \t\tpos := getPos(error.Pos.Filename, error.Pos.Offset)\n-\t\tif msg, found := expected[pos]; found {\n-\t\t\t// we expect a message at pos; check if it matches\n+\t\tlist := expected[pos]\n+\t\tindex := -1 // list index of matching message, if any\n+\t\t// we expect one of the messages in list to match the error at pos\n+\t\tfor i, msg := range list {\n \t\t\trx, err := regexp.Compile(msg)\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"%s: %v\", error.Pos, err)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif match := rx.MatchString(error.Msg); !match {\n-\t\t\t\tt.Errorf(\"%s: %q does not match %q\", error.Pos, error.Msg, msg)\n-\t\t\t\tcontinue\n+\t\t\tif match := rx.MatchString(error.Msg); match {\n+\t\t\t\tindex = i\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif index >= 0 {\n+\t\t\t// eliminate from list\n+\t\t\tn := len(list) - 1\n+\t\t\tif n > 0 {\n+\t\t\t\t// not the last entry - swap in last element and shorten list by 1\n+\t\t\t\tlist[index] = list[n]\n+\t\t\t\texpected[pos] = list[:n]\n+\t\t\t} else {\n+\t\t\t\t// last entry - remove list from map\n+\t\t\t\tdelete(expected, pos)\n \t\t\t}\n-\t\t\t// we have a match - eliminate this error\n-\t\t\tdelete(expected, pos)\n \t\t} else {\n-\t\t\t// To keep in mind when analyzing failed test output:\n-\t\t\t// If the same error position occurs multiple times in errors,\n-\t\t\t// this message will be triggered (because the first error at\n-\t\t\t// the position removes this position from the expected errors).\n-\t\t\tt.Errorf(\"%s: no (multiple?) error expected, but found: %s\", error.Pos, error.Msg)\n+\t\t\tt.Errorf(\"%s: no error expected: %q\", error.Pos, error.Msg)\n+\t\t\tcontinue\n \t\t}\n \t}\n }\n \n-/*\n-\n-This test doesn't work with gccgo--it can't read gccgo imports.\n-\n-func check(t *testing.T, testname string, testfiles []string) {\n+func checkFiles(t *testing.T, testname string, testfiles []string) {\n \t// TODO(gri) Eventually all these different phases should be\n \t//           subsumed into a single function call that takes\n \t//           a set of files and creates a fully resolved and\n@@ -192,8 +214,17 @@ func check(t *testing.T, testname string, testfiles []string) {\n \teliminate(t, errors, err)\n \n \t// verify errors returned by the typechecker\n-\t_, err = Check(fset, pkg)\n-\teliminate(t, errors, err)\n+\tvar list scanner.ErrorList\n+\terrh := func(pos token.Pos, msg string) {\n+\t\tlist.Add(fset.Position(pos), msg)\n+\t}\n+\terr = Check(fset, pkg, errh, nil)\n+\teliminate(t, errors, list)\n+\n+\tif *listErrors {\n+\t\tscanner.PrintError(os.Stdout, err)\n+\t\treturn\n+\t}\n \n \t// there should be no expected errors left\n \tif len(errors) > 0 {\n@@ -205,19 +236,28 @@ func check(t *testing.T, testname string, testfiles []string) {\n }\n \n func TestCheck(t *testing.T) {\n+\t// This package does not yet know how to read gccgo export data.\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\treturn\n+\t}\n+\n+\t// Declare builtins for testing.\n+\t// Not done in an init func to avoid an init race with\n+\t// the construction of the Universe var.\n+\tdef(ast.Fun, \"assert\").Type = &builtin{aType, _Assert, \"assert\", 1, false, true}\n+\tdef(ast.Fun, \"trace\").Type = &builtin{aType, _Trace, \"trace\", 0, true, true}\n+\n \t// For easy debugging w/o changing the testing code,\n \t// if there is a local test file, only test that file.\n \tconst testfile = \"testdata/test.go\"\n \tif fi, err := os.Stat(testfile); err == nil && !fi.IsDir() {\n \t\tfmt.Printf(\"WARNING: Testing only %s (remove it to run all tests)\\n\", testfile)\n-\t\tcheck(t, testfile, []string{testfile})\n+\t\tcheckFiles(t, testfile, []string{testfile})\n \t\treturn\n \t}\n \n \t// Otherwise, run all the tests.\n \tfor _, test := range tests {\n-\t\tcheck(t, test.name, test.files)\n+\t\tcheckFiles(t, test.name, test.files)\n \t}\n }\n-\n-*/"}, {"sha": "55010407778dd8777aae8108f26c9a96a4604f80", "filename": "libgo/go/exp/types/const.go", "status": "modified", "additions": 588, "deletions": 258, "changes": 846, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -2,331 +2,661 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file implements operations on ideal constants.\n+// This file implements operations on constant values.\n \n package types\n \n import (\n+\t\"fmt\"\n \t\"go/token\"\n \t\"math/big\"\n \t\"strconv\"\n )\n \n-// TODO(gri) Consider changing the API so Const is an interface\n-//           and operations on consts don't have to type switch.\n-\n-// A Const implements an ideal constant Value.\n-// The zero value z for a Const is not a valid constant value.\n-type Const struct {\n-\t// representation of constant values:\n-\t// ideal bool     ->  bool\n-\t// ideal int      ->  *big.Int\n-\t// ideal float    ->  *big.Rat\n-\t// ideal complex  ->  cmplx\n-\t// ideal string   ->  string\n-\tval interface{}\n-}\n+// TODO(gri) At the moment, constants are different types\n+// passed around as interface{} values. Consider introducing\n+// a Const type and use methods instead of xConst functions.\n+\n+// Representation of constant values.\n+//\n+// bool     ->  bool (true, false)\n+// numeric  ->  int64, *big.Int, *big.Rat, complex (ordered by increasing data structure \"size\")\n+// string   ->  string\n+// nil      ->  nilType (nilConst)\n+//\n+// Numeric constants are normalized after each operation such\n+// that they are represented by the \"smallest\" data structure\n+// required to represent the constant, independent of actual\n+// type. Non-numeric constants are always normalized.\n \n-// Representation of complex values.\n-type cmplx struct {\n+// Representation of complex numbers.\n+type complex struct {\n \tre, im *big.Rat\n }\n \n-func assert(cond bool) {\n-\tif !cond {\n-\t\tpanic(\"go/types internal error: assertion failed\")\n+func (c complex) String() string {\n+\tif c.re.Sign() == 0 {\n+\t\treturn fmt.Sprintf(\"%si\", c.im)\n+\t}\n+\t// normalized complex values always have an imaginary part\n+\treturn fmt.Sprintf(\"(%s + %si)\", c.re, c.im)\n+}\n+\n+// Representation of nil.\n+type nilType struct{}\n+\n+func (nilType) String() string {\n+\treturn \"nil\"\n+}\n+\n+// Frequently used constants.\n+var (\n+\tzeroConst     = int64(0)\n+\toneConst      = int64(1)\n+\tminusOneConst = int64(-1)\n+\tnilConst      = nilType{}\n+)\n+\n+// int64 bounds\n+var (\n+\tminInt64 = big.NewInt(-1 << 63)\n+\tmaxInt64 = big.NewInt(1<<63 - 1)\n+)\n+\n+// normalizeIntConst returns the smallest constant representation\n+// for the specific value of x; either an int64 or a *big.Int value.\n+//\n+func normalizeIntConst(x *big.Int) interface{} {\n+\tif minInt64.Cmp(x) <= 0 && x.Cmp(maxInt64) <= 0 {\n+\t\treturn x.Int64()\n+\t}\n+\treturn x\n+}\n+\n+// normalizeRatConst returns the smallest constant representation\n+// for the specific value of x; either an int64, *big.Int value,\n+// or *big.Rat value.\n+//\n+func normalizeRatConst(x *big.Rat) interface{} {\n+\tif x.IsInt() {\n+\t\treturn normalizeIntConst(x.Num())\n+\t}\n+\treturn x\n+}\n+\n+// normalizeComplexConst returns the smallest constant representation\n+// for the specific value of x; either an int64, *big.Int value, *big.Rat,\n+// or complex value.\n+//\n+func normalizeComplexConst(x complex) interface{} {\n+\tif x.im.Sign() == 0 {\n+\t\treturn normalizeRatConst(x.re)\n+\t}\n+\treturn x\n+}\n+\n+// makeRuneConst returns the int64 code point for the rune literal\n+// lit. The result is nil if lit is not a correct rune literal.\n+//\n+func makeRuneConst(lit string) interface{} {\n+\tif n := len(lit); n >= 2 {\n+\t\tif code, _, _, err := strconv.UnquoteChar(lit[1:n-1], '\\''); err == nil {\n+\t\t\treturn int64(code)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// makeRuneConst returns the smallest integer constant representation\n+// (int64, *big.Int) for the integer literal lit. The result is nil if\n+// lit is not a correct integer literal.\n+//\n+func makeIntConst(lit string) interface{} {\n+\tif x, err := strconv.ParseInt(lit, 0, 64); err == nil {\n+\t\treturn x\n+\t}\n+\tif x, ok := new(big.Int).SetString(lit, 0); ok {\n+\t\treturn x\n+\t}\n+\treturn nil\n+}\n+\n+// makeFloatConst returns the smallest floating-point constant representation\n+// (int64, *big.Int, *big.Rat) for the floating-point literal lit. The result\n+// is nil if lit is not a correct floating-point literal.\n+//\n+func makeFloatConst(lit string) interface{} {\n+\tif x, ok := new(big.Rat).SetString(lit); ok {\n+\t\treturn normalizeRatConst(x)\n+\t}\n+\treturn nil\n+}\n+\n+// makeComplexConst returns the complex constant representation (complex) for\n+// the imaginary literal lit. The result is nil if lit is not a correct imaginary\n+// literal.\n+//\n+func makeComplexConst(lit string) interface{} {\n+\tn := len(lit)\n+\tif n > 0 && lit[n-1] == 'i' {\n+\t\tif im, ok := new(big.Rat).SetString(lit[0 : n-1]); ok {\n+\t\t\treturn normalizeComplexConst(complex{big.NewRat(0, 1), im})\n+\t\t}\n \t}\n+\treturn nil\n }\n \n-// MakeConst makes an ideal constant from a literal\n-// token and the corresponding literal string.\n-func MakeConst(tok token.Token, lit string) Const {\n-\tswitch tok {\n-\tcase token.INT:\n-\t\tvar x big.Int\n-\t\t_, ok := x.SetString(lit, 0)\n-\t\tassert(ok)\n-\t\treturn Const{&x}\n-\tcase token.FLOAT:\n-\t\tvar y big.Rat\n-\t\t_, ok := y.SetString(lit)\n-\t\tassert(ok)\n-\t\treturn Const{&y}\n-\tcase token.IMAG:\n-\t\tassert(lit[len(lit)-1] == 'i')\n-\t\tvar im big.Rat\n-\t\t_, ok := im.SetString(lit[0 : len(lit)-1])\n-\t\tassert(ok)\n-\t\treturn Const{cmplx{big.NewRat(0, 1), &im}}\n-\tcase token.CHAR:\n-\t\tassert(lit[0] == '\\'' && lit[len(lit)-1] == '\\'')\n-\t\tcode, _, _, err := strconv.UnquoteChar(lit[1:len(lit)-1], '\\'')\n-\t\tassert(err == nil)\n-\t\treturn Const{big.NewInt(int64(code))}\n-\tcase token.STRING:\n-\t\ts, err := strconv.Unquote(lit)\n-\t\tassert(err == nil)\n-\t\treturn Const{s}\n+// makeStringConst returns the string constant representation (string) for\n+// the string literal lit. The result is nil if lit is not a correct string\n+// literal.\n+//\n+func makeStringConst(lit string) interface{} {\n+\tif s, err := strconv.Unquote(lit); err == nil {\n+\t\treturn s\n \t}\n-\tpanic(\"unreachable\")\n+\treturn nil\n }\n \n-// MakeZero returns the zero constant for the given type.\n-func MakeZero(typ *Type) Const {\n-\t// TODO(gri) fix this\n-\treturn Const{0}\n+// isZeroConst reports whether the value of constant x is 0.\n+// x must be normalized.\n+//\n+func isZeroConst(x interface{}) bool {\n+\ti, ok := x.(int64) // good enough since constants are normalized\n+\treturn ok && i == 0\n }\n \n-// Match attempts to match the internal constant representations of x and y.\n-// If the attempt is successful, the result is the values of x and y,\n-// if necessary converted to have the same internal representation; otherwise\n-// the results are invalid.\n-func (x Const) Match(y Const) (u, v Const) {\n-\tswitch a := x.val.(type) {\n+// isNegConst reports whether the value of constant x is < 0.\n+// x must be a non-complex numeric value.\n+//\n+func isNegConst(x interface{}) bool {\n+\tswitch x := x.(type) {\n+\tcase int64:\n+\t\treturn x < 0\n+\tcase *big.Int:\n+\t\treturn x.Sign() < 0\n+\tcase *big.Rat:\n+\t\treturn x.Sign() < 0\n+\t}\n+\tunreachable()\n+\treturn false\n+}\n+\n+// isRepresentableConst reports whether the value of constant x can\n+// be represented as a value of the basic type Typ[as] without loss\n+// of precision.\n+//\n+func isRepresentableConst(x interface{}, as BasicKind) bool {\n+\tconst intBits = 32 // TODO(gri) implementation-specific constant\n+\tconst ptrBits = 64 // TODO(gri) implementation-specific constant\n+\n+\tswitch x := x.(type) {\n \tcase bool:\n-\t\tif _, ok := y.val.(bool); ok {\n-\t\t\tu, v = x, y\n+\t\treturn as == Bool || as == UntypedBool\n+\n+\tcase int64:\n+\t\tswitch as {\n+\t\tcase Int:\n+\t\t\treturn -1<<(intBits-1) <= x && x <= 1<<(intBits-1)-1\n+\t\tcase Int8:\n+\t\t\treturn -1<<(8-1) <= x && x <= 1<<(8-1)-1\n+\t\tcase Int16:\n+\t\t\treturn -1<<(16-1) <= x && x <= 1<<(16-1)-1\n+\t\tcase Int32, UntypedRune:\n+\t\t\treturn -1<<(32-1) <= x && x <= 1<<(32-1)-1\n+\t\tcase Int64:\n+\t\t\treturn true\n+\t\tcase Uint:\n+\t\t\treturn 0 <= x && x <= 1<<intBits-1\n+\t\tcase Uint8:\n+\t\t\treturn 0 <= x && x <= 1<<8-1\n+\t\tcase Uint16:\n+\t\t\treturn 0 <= x && x <= 1<<16-1\n+\t\tcase Uint32:\n+\t\t\treturn 0 <= x && x <= 1<<32-1\n+\t\tcase Uint64:\n+\t\t\treturn 0 <= x\n+\t\tcase Uintptr:\n+\t\t\tassert(ptrBits == 64)\n+\t\t\treturn 0 <= x\n+\t\tcase Float32:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Float64:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Complex64:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Complex128:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase UntypedInt, UntypedFloat, UntypedComplex:\n+\t\t\treturn true\n \t\t}\n+\n \tcase *big.Int:\n-\t\tswitch y.val.(type) {\n-\t\tcase *big.Int:\n-\t\t\tu, v = x, y\n-\t\tcase *big.Rat:\n-\t\t\tvar z big.Rat\n-\t\t\tz.SetInt(a)\n-\t\t\tu, v = Const{&z}, y\n-\t\tcase cmplx:\n-\t\t\tvar z big.Rat\n-\t\t\tz.SetInt(a)\n-\t\t\tu, v = Const{cmplx{&z, big.NewRat(0, 1)}}, y\n+\t\tswitch as {\n+\t\tcase Uint:\n+\t\t\treturn x.Sign() >= 0 && x.BitLen() <= intBits\n+\t\tcase Uint64:\n+\t\t\treturn x.Sign() >= 0 && x.BitLen() <= 64\n+\t\tcase Uintptr:\n+\t\t\treturn x.Sign() >= 0 && x.BitLen() <= ptrBits\n+\t\tcase Float32:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Float64:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Complex64:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Complex128:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase UntypedInt, UntypedFloat, UntypedComplex:\n+\t\t\treturn true\n \t\t}\n+\n \tcase *big.Rat:\n-\t\tswitch y.val.(type) {\n-\t\tcase *big.Int:\n-\t\t\tv, u = y.Match(x)\n-\t\tcase *big.Rat:\n-\t\t\tu, v = x, y\n-\t\tcase cmplx:\n-\t\t\tu, v = Const{cmplx{a, big.NewRat(0, 0)}}, y\n+\t\tswitch as {\n+\t\tcase Float32:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Float64:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Complex64:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Complex128:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase UntypedFloat, UntypedComplex:\n+\t\t\treturn true\n \t\t}\n-\tcase cmplx:\n-\t\tswitch y.val.(type) {\n-\t\tcase *big.Int, *big.Rat:\n-\t\t\tv, u = y.Match(x)\n-\t\tcase cmplx:\n-\t\t\tu, v = x, y\n+\n+\tcase complex:\n+\t\tswitch as {\n+\t\tcase Complex64:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase Complex128:\n+\t\t\treturn true // TODO(gri) fix this\n+\t\tcase UntypedComplex:\n+\t\t\treturn true\n \t\t}\n+\n \tcase string:\n-\t\tif _, ok := y.val.(string); ok {\n-\t\t\tu, v = x, y\n-\t\t}\n+\t\treturn as == String || as == UntypedString\n+\n+\tcase nilType:\n+\t\treturn as == UntypedNil\n+\n \tdefault:\n-\t\tpanic(\"unreachable\")\n+\t\tunreachable()\n \t}\n-\treturn\n+\n+\treturn false\n }\n \n-// Convert attempts to convert the constant x to a given type.\n-// If the attempt is successful, the result is the new constant;\n-// otherwise the result is invalid.\n-func (x Const) Convert(typ *Type) Const {\n-\t// TODO(gri) implement this\n-\tswitch x.val.(type) {\n-\tcase bool:\n+var (\n+\tint1 = big.NewInt(1)\n+\trat0 = big.NewRat(0, 1)\n+)\n+\n+// complexity returns a measure of representation complexity for constant x.\n+func complexity(x interface{}) int {\n+\tswitch x.(type) {\n+\tcase bool, string, nilType:\n+\t\treturn 1\n+\tcase int64:\n+\t\treturn 2\n \tcase *big.Int:\n+\t\treturn 3\n \tcase *big.Rat:\n-\tcase cmplx:\n-\tcase string:\n+\t\treturn 4\n+\tcase complex:\n+\t\treturn 5\n \t}\n-\treturn x\n+\tunreachable()\n+\treturn 0\n }\n \n-func (x Const) String() string {\n-\tswitch x := x.val.(type) {\n-\tcase bool:\n-\t\tif x {\n-\t\t\treturn \"true\"\n+// matchConst returns the matching representation (same type) with the\n+// smallest complexity for two constant values x and y. They must be\n+// of the same \"kind\" (boolean, numeric, string, or nilType).\n+//\n+func matchConst(x, y interface{}) (_, _ interface{}) {\n+\tif complexity(x) > complexity(y) {\n+\t\ty, x = matchConst(y, x)\n+\t\treturn x, y\n+\t}\n+\t// complexity(x) <= complexity(y)\n+\n+\tswitch x := x.(type) {\n+\tcase bool, complex, string, nilType:\n+\t\treturn x, y\n+\n+\tcase int64:\n+\t\tswitch y := y.(type) {\n+\t\tcase int64:\n+\t\t\treturn x, y\n+\t\tcase *big.Int:\n+\t\t\treturn big.NewInt(x), y\n+\t\tcase *big.Rat:\n+\t\t\treturn big.NewRat(x, 1), y\n+\t\tcase complex:\n+\t\t\treturn complex{big.NewRat(x, 1), rat0}, y\n \t\t}\n-\t\treturn \"false\"\n+\n \tcase *big.Int:\n-\t\treturn x.String()\n+\t\tswitch y := y.(type) {\n+\t\tcase *big.Int:\n+\t\t\treturn x, y\n+\t\tcase *big.Rat:\n+\t\t\treturn new(big.Rat).SetFrac(x, int1), y\n+\t\tcase complex:\n+\t\t\treturn complex{new(big.Rat).SetFrac(x, int1), rat0}, y\n+\t\t}\n+\n \tcase *big.Rat:\n-\t\treturn x.FloatString(10) // 10 digits of precision after decimal point seems fine\n-\tcase cmplx:\n-\t\t// TODO(gri) don't print 0 components\n-\t\treturn x.re.FloatString(10) + \" + \" + x.im.FloatString(10) + \"i\"\n-\tcase string:\n-\t\treturn x\n+\t\tswitch y := y.(type) {\n+\t\tcase *big.Rat:\n+\t\t\treturn x, y\n+\t\tcase complex:\n+\t\t\treturn complex{x, rat0}, y\n+\t\t}\n \t}\n-\tpanic(\"unreachable\")\n+\n+\tunreachable()\n+\treturn nil, nil\n+}\n+\n+// is32bit reports whether x can be represented using 32 bits.\n+func is32bit(x int64) bool {\n+\treturn -1<<31 <= x && x <= 1<<31-1\n }\n \n-func (x Const) UnaryOp(op token.Token) Const {\n-\tpanic(\"unimplemented\")\n+// is63bit reports whether x can be represented using 63 bits.\n+func is63bit(x int64) bool {\n+\treturn -1<<62 <= x && x <= 1<<62-1\n }\n \n-func (x Const) BinaryOp(op token.Token, y Const) Const {\n-\tvar z interface{}\n-\tswitch x := x.val.(type) {\n+// binaryOpConst returns the result of the constant evaluation x op y;\n+// both operands must be of the same \"kind\" (boolean, numeric, or string).\n+// If intDiv is true, division (op == token.QUO) is using integer division\n+// (and the result is guaranteed to be integer) rather than floating-point\n+// division. Division by zero leads to a run-time panic.\n+//\n+func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n+\tx, y = matchConst(x, y)\n+\n+\tswitch x := x.(type) {\n \tcase bool:\n-\t\tz = binaryBoolOp(x, op, y.val.(bool))\n+\t\ty := y.(bool)\n+\t\tswitch op {\n+\t\tcase token.LAND:\n+\t\t\treturn x && y\n+\t\tcase token.LOR:\n+\t\t\treturn x || y\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\n+\tcase int64:\n+\t\ty := y.(int64)\n+\t\tswitch op {\n+\t\tcase token.ADD:\n+\t\t\t// TODO(gri) can do better than this\n+\t\t\tif is63bit(x) && is63bit(y) {\n+\t\t\t\treturn x + y\n+\t\t\t}\n+\t\t\treturn normalizeIntConst(new(big.Int).Add(big.NewInt(x), big.NewInt(y)))\n+\t\tcase token.SUB:\n+\t\t\t// TODO(gri) can do better than this\n+\t\t\tif is63bit(x) && is63bit(y) {\n+\t\t\t\treturn x - y\n+\t\t\t}\n+\t\t\treturn normalizeIntConst(new(big.Int).Sub(big.NewInt(x), big.NewInt(y)))\n+\t\tcase token.MUL:\n+\t\t\t// TODO(gri) can do better than this\n+\t\t\tif is32bit(x) && is32bit(y) {\n+\t\t\t\treturn x * y\n+\t\t\t}\n+\t\t\treturn normalizeIntConst(new(big.Int).Mul(big.NewInt(x), big.NewInt(y)))\n+\t\tcase token.REM:\n+\t\t\treturn x % y\n+\t\tcase token.QUO:\n+\t\t\tif intDiv {\n+\t\t\t\treturn x / y\n+\t\t\t}\n+\t\t\treturn normalizeRatConst(new(big.Rat).SetFrac(big.NewInt(x), big.NewInt(y)))\n+\t\tcase token.AND:\n+\t\t\treturn x & y\n+\t\tcase token.OR:\n+\t\t\treturn x | y\n+\t\tcase token.XOR:\n+\t\t\treturn x ^ y\n+\t\tcase token.AND_NOT:\n+\t\t\treturn x &^ y\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\n \tcase *big.Int:\n-\t\tz = binaryIntOp(x, op, y.val.(*big.Int))\n+\t\ty := y.(*big.Int)\n+\t\tvar z big.Int\n+\t\tswitch op {\n+\t\tcase token.ADD:\n+\t\t\tz.Add(x, y)\n+\t\tcase token.SUB:\n+\t\t\tz.Sub(x, y)\n+\t\tcase token.MUL:\n+\t\t\tz.Mul(x, y)\n+\t\tcase token.REM:\n+\t\t\tz.Rem(x, y)\n+\t\tcase token.QUO:\n+\t\t\tif intDiv {\n+\t\t\t\tz.Quo(x, y)\n+\t\t\t} else {\n+\t\t\t\treturn normalizeRatConst(new(big.Rat).SetFrac(x, y))\n+\t\t\t}\n+\t\tcase token.AND:\n+\t\t\tz.And(x, y)\n+\t\tcase token.OR:\n+\t\t\tz.Or(x, y)\n+\t\tcase token.XOR:\n+\t\t\tz.Xor(x, y)\n+\t\tcase token.AND_NOT:\n+\t\t\tz.AndNot(x, y)\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\treturn normalizeIntConst(&z)\n+\n \tcase *big.Rat:\n-\t\tz = binaryFloatOp(x, op, y.val.(*big.Rat))\n-\tcase cmplx:\n-\t\tz = binaryCmplxOp(x, op, y.val.(cmplx))\n+\t\ty := y.(*big.Rat)\n+\t\tvar z big.Rat\n+\t\tswitch op {\n+\t\tcase token.ADD:\n+\t\t\tz.Add(x, y)\n+\t\tcase token.SUB:\n+\t\t\tz.Sub(x, y)\n+\t\tcase token.MUL:\n+\t\t\tz.Mul(x, y)\n+\t\tcase token.QUO:\n+\t\t\tz.Quo(x, y)\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\treturn normalizeRatConst(&z)\n+\n+\tcase complex:\n+\t\ty := y.(complex)\n+\t\ta, b := x.re, x.im\n+\t\tc, d := y.re, y.im\n+\t\tvar re, im big.Rat\n+\t\tswitch op {\n+\t\tcase token.ADD:\n+\t\t\t// (a+c) + i(b+d)\n+\t\t\tre.Add(a, c)\n+\t\t\tim.Add(b, d)\n+\t\tcase token.SUB:\n+\t\t\t// (a-c) + i(b-d)\n+\t\t\tre.Sub(a, c)\n+\t\t\tim.Sub(b, d)\n+\t\tcase token.MUL:\n+\t\t\t// (ac-bd) + i(bc+ad)\n+\t\t\tvar ac, bd, bc, ad big.Rat\n+\t\t\tac.Mul(a, c)\n+\t\t\tbd.Mul(b, d)\n+\t\t\tbc.Mul(b, c)\n+\t\t\tad.Mul(a, d)\n+\t\t\tre.Sub(&ac, &bd)\n+\t\t\tim.Add(&bc, &ad)\n+\t\tcase token.QUO:\n+\t\t\t// (ac+bd)/s + i(bc-ad)/s, with s = cc + dd\n+\t\t\tvar ac, bd, bc, ad, s big.Rat\n+\t\t\tac.Mul(a, c)\n+\t\t\tbd.Mul(b, d)\n+\t\t\tbc.Mul(b, c)\n+\t\t\tad.Mul(a, d)\n+\t\t\ts.Add(c.Mul(c, c), d.Mul(d, d))\n+\t\t\tre.Add(&ac, &bd)\n+\t\t\tre.Quo(&re, &s)\n+\t\t\tim.Sub(&bc, &ad)\n+\t\t\tim.Quo(&im, &s)\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\treturn normalizeComplexConst(complex{&re, &im})\n+\n \tcase string:\n-\t\tz = binaryStringOp(x, op, y.val.(string))\n-\tdefault:\n-\t\tpanic(\"unreachable\")\n+\t\tif op == token.ADD {\n+\t\t\treturn x + y.(string)\n+\t\t}\n \t}\n-\treturn Const{z}\n+\n+\tunreachable()\n+\treturn nil\n }\n \n-func binaryBoolOp(x bool, op token.Token, y bool) interface{} {\n-\tswitch op {\n-\tcase token.EQL:\n-\t\treturn x == y\n-\tcase token.NEQ:\n-\t\treturn x != y\n+// shiftConst returns the result of the constant evaluation x op s\n+// where op is token.SHL or token.SHR (<< or >>). x must be an\n+// integer constant.\n+//\n+func shiftConst(x interface{}, s uint, op token.Token) interface{} {\n+\tswitch x := x.(type) {\n+\tcase int64:\n+\t\tswitch op {\n+\t\tcase token.SHL:\n+\t\t\tz := big.NewInt(x)\n+\t\t\treturn normalizeIntConst(z.Lsh(z, s))\n+\t\tcase token.SHR:\n+\t\t\treturn x >> s\n+\t\t}\n+\n+\tcase *big.Int:\n+\t\tvar z big.Int\n+\t\tswitch op {\n+\t\tcase token.SHL:\n+\t\t\treturn normalizeIntConst(z.Lsh(x, s))\n+\t\tcase token.SHR:\n+\t\t\treturn normalizeIntConst(z.Rsh(x, s))\n+\t\t}\n \t}\n-\tpanic(\"unreachable\")\n+\n+\tunreachable()\n+\treturn nil\n }\n \n-func binaryIntOp(x *big.Int, op token.Token, y *big.Int) interface{} {\n-\tvar z big.Int\n+// compareConst returns the result of the constant comparison x op y;\n+// both operands must be of the same \"kind\" (boolean, numeric, string,\n+// or nilType).\n+//\n+func compareConst(x, y interface{}, op token.Token) (z bool) {\n+\tx, y = matchConst(x, y)\n+\n+\t// x == y  =>  x == y\n+\t// x != y  =>  x != y\n+\t// x >  y  =>  y <  x\n+\t// x >= y  =>  u <= x\n+\tswap := false\n \tswitch op {\n-\tcase token.ADD:\n-\t\treturn z.Add(x, y)\n-\tcase token.SUB:\n-\t\treturn z.Sub(x, y)\n-\tcase token.MUL:\n-\t\treturn z.Mul(x, y)\n-\tcase token.QUO:\n-\t\treturn z.Quo(x, y)\n-\tcase token.REM:\n-\t\treturn z.Rem(x, y)\n-\tcase token.AND:\n-\t\treturn z.And(x, y)\n-\tcase token.OR:\n-\t\treturn z.Or(x, y)\n-\tcase token.XOR:\n-\t\treturn z.Xor(x, y)\n-\tcase token.AND_NOT:\n-\t\treturn z.AndNot(x, y)\n-\tcase token.SHL:\n-\t\tpanic(\"unimplemented\")\n-\tcase token.SHR:\n-\t\tpanic(\"unimplemented\")\n-\tcase token.EQL:\n-\t\treturn x.Cmp(y) == 0\n-\tcase token.NEQ:\n-\t\treturn x.Cmp(y) != 0\n-\tcase token.LSS:\n-\t\treturn x.Cmp(y) < 0\n-\tcase token.LEQ:\n-\t\treturn x.Cmp(y) <= 0\n \tcase token.GTR:\n-\t\treturn x.Cmp(y) > 0\n+\t\tswap = true\n+\t\top = token.LSS\n \tcase token.GEQ:\n-\t\treturn x.Cmp(y) >= 0\n+\t\tswap = true\n+\t\top = token.LEQ\n \t}\n-\tpanic(\"unreachable\")\n-}\n \n-func binaryFloatOp(x *big.Rat, op token.Token, y *big.Rat) interface{} {\n-\tvar z big.Rat\n+\t// x == y  =>    x == y\n+\t// x != y  =>  !(x == y)\n+\t// x <  y  =>    x <  y\n+\t// x <= y  =>  !(y <  x)\n+\tnegate := false\n \tswitch op {\n-\tcase token.ADD:\n-\t\treturn z.Add(x, y)\n-\tcase token.SUB:\n-\t\treturn z.Sub(x, y)\n-\tcase token.MUL:\n-\t\treturn z.Mul(x, y)\n-\tcase token.QUO:\n-\t\treturn z.Quo(x, y)\n-\tcase token.EQL:\n-\t\treturn x.Cmp(y) == 0\n \tcase token.NEQ:\n-\t\treturn x.Cmp(y) != 0\n-\tcase token.LSS:\n-\t\treturn x.Cmp(y) < 0\n+\t\tnegate = true\n+\t\top = token.EQL\n \tcase token.LEQ:\n-\t\treturn x.Cmp(y) <= 0\n-\tcase token.GTR:\n-\t\treturn x.Cmp(y) > 0\n-\tcase token.GEQ:\n-\t\treturn x.Cmp(y) >= 0\n+\t\tswap = !swap\n+\t\tnegate = true\n+\t\top = token.LSS\n \t}\n-\tpanic(\"unreachable\")\n-}\n \n-func binaryCmplxOp(x cmplx, op token.Token, y cmplx) interface{} {\n-\ta, b := x.re, x.im\n-\tc, d := y.re, y.im\n-\tswitch op {\n-\tcase token.ADD:\n-\t\t// (a+c) + i(b+d)\n-\t\tvar re, im big.Rat\n-\t\tre.Add(a, c)\n-\t\tim.Add(b, d)\n-\t\treturn cmplx{&re, &im}\n-\tcase token.SUB:\n-\t\t// (a-c) + i(b-d)\n-\t\tvar re, im big.Rat\n-\t\tre.Sub(a, c)\n-\t\tim.Sub(b, d)\n-\t\treturn cmplx{&re, &im}\n-\tcase token.MUL:\n-\t\t// (ac-bd) + i(bc+ad)\n-\t\tvar ac, bd, bc, ad big.Rat\n-\t\tac.Mul(a, c)\n-\t\tbd.Mul(b, d)\n-\t\tbc.Mul(b, c)\n-\t\tad.Mul(a, d)\n-\t\tvar re, im big.Rat\n-\t\tre.Sub(&ac, &bd)\n-\t\tim.Add(&bc, &ad)\n-\t\treturn cmplx{&re, &im}\n-\tcase token.QUO:\n-\t\t// (ac+bd)/s + i(bc-ad)/s, with s = cc + dd\n-\t\tvar ac, bd, bc, ad, s big.Rat\n-\t\tac.Mul(a, c)\n-\t\tbd.Mul(b, d)\n-\t\tbc.Mul(b, c)\n-\t\tad.Mul(a, d)\n-\t\ts.Add(c.Mul(c, c), d.Mul(d, d))\n-\t\tvar re, im big.Rat\n-\t\tre.Add(&ac, &bd)\n-\t\tre.Quo(&re, &s)\n-\t\tim.Sub(&bc, &ad)\n-\t\tim.Quo(&im, &s)\n-\t\treturn cmplx{&re, &im}\n-\tcase token.EQL:\n-\t\treturn a.Cmp(c) == 0 && b.Cmp(d) == 0\n-\tcase token.NEQ:\n-\t\treturn a.Cmp(c) != 0 || b.Cmp(d) != 0\n+\tif negate {\n+\t\tdefer func() { z = !z }()\n \t}\n-\tpanic(\"unreachable\")\n-}\n \n-func binaryStringOp(x string, op token.Token, y string) interface{} {\n-\tswitch op {\n-\tcase token.ADD:\n-\t\treturn x + y\n-\tcase token.EQL:\n-\t\treturn x == y\n-\tcase token.NEQ:\n-\t\treturn x != y\n-\tcase token.LSS:\n-\t\treturn x < y\n-\tcase token.LEQ:\n-\t\treturn x <= y\n-\tcase token.GTR:\n-\t\treturn x > y\n-\tcase token.GEQ:\n-\t\treturn x >= y\n+\tif swap {\n+\t\tx, y = y, x\n \t}\n-\tpanic(\"unreachable\")\n+\n+\tswitch x := x.(type) {\n+\tcase bool:\n+\t\tif op == token.EQL {\n+\t\t\treturn x == y.(bool)\n+\t\t}\n+\n+\tcase int64:\n+\t\ty := y.(int64)\n+\t\tswitch op {\n+\t\tcase token.EQL:\n+\t\t\treturn x == y\n+\t\tcase token.LSS:\n+\t\t\treturn x < y\n+\t\t}\n+\n+\tcase *big.Int:\n+\t\ts := x.Cmp(y.(*big.Int))\n+\t\tswitch op {\n+\t\tcase token.EQL:\n+\t\t\treturn s == 0\n+\t\tcase token.LSS:\n+\t\t\treturn s < 0\n+\t\t}\n+\n+\tcase *big.Rat:\n+\t\ts := x.Cmp(y.(*big.Rat))\n+\t\tswitch op {\n+\t\tcase token.EQL:\n+\t\t\treturn s == 0\n+\t\tcase token.LSS:\n+\t\t\treturn s < 0\n+\t\t}\n+\n+\tcase complex:\n+\t\ty := y.(complex)\n+\t\tif op == token.EQL {\n+\t\t\treturn x.re.Cmp(y.re) == 0 && x.im.Cmp(y.im) == 0\n+\t\t}\n+\n+\tcase string:\n+\t\ty := y.(string)\n+\t\tswitch op {\n+\t\tcase token.EQL:\n+\t\t\treturn x == y\n+\t\tcase token.LSS:\n+\t\t\treturn x < y\n+\t\t}\n+\n+\tcase nilType:\n+\t\tif op == token.EQL {\n+\t\t\treturn x == y.(nilType)\n+\t\t}\n+\t}\n+\n+\tfmt.Printf(\"x = %s (%T), y = %s (%T)\\n\", x, x, y, y)\n+\tunreachable()\n+\treturn\n }"}, {"sha": "cbaef8aa9ae5fbaa6bad177edcd638758f662ed8", "filename": "libgo/go/exp/types/conversions.go", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fconversions.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fconversions.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fconversions.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -29,7 +29,9 @@ func (check *checker) conversion(x *operand, conv *ast.CallExpr, typ Type, iota\n \t}\n \n \t// TODO(gri) fix this - implement all checks and constant evaluation\n-\tx.mode = value\n+\tif x.mode != constant {\n+\t\tx.mode = value\n+\t}\n \tx.expr = conv\n \tx.typ = typ\n \treturn", "previous_filename": "libgo/go/exp/types/staging/conversions.go"}, {"sha": "1a1659538a50ce3d1a50e2f8c4c52cb87185e273", "filename": "libgo/go/exp/types/errors.go", "status": "renamed", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ferrors.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -13,10 +13,6 @@ import (\n \t\"go/token\"\n )\n \n-// debugging flags\n-const debug = false\n-const trace = false\n-\n // TODO(gri) eventually assert and unimplemented should disappear.\n func assert(p bool) {\n \tif !p {\n@@ -25,15 +21,40 @@ func assert(p bool) {\n }\n \n func unimplemented() {\n-\tif debug {\n-\t\tpanic(\"unimplemented\")\n-\t}\n+\t// enable for debugging\n+\t// panic(\"unimplemented\")\n }\n \n func unreachable() {\n \tpanic(\"unreachable\")\n }\n \n+func (check *checker) printTrace(format string, args []interface{}) {\n+\tconst dots = \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n+\tn := len(check.pos) - 1\n+\ti := 2 * n\n+\tfor i > len(dots) {\n+\t\tfmt.Print(dots)\n+\t\ti -= len(dots)\n+\t}\n+\t// i <= len(dots)\n+\tfmt.Printf(\"%s: \", check.fset.Position(check.pos[n]))\n+\tfmt.Print(dots[0:i])\n+\tfmt.Println(check.formatMsg(format, args))\n+}\n+\n+func (check *checker) trace(pos token.Pos, format string, args ...interface{}) {\n+\tcheck.pos = append(check.pos, pos)\n+\tcheck.printTrace(format, args)\n+}\n+\n+func (check *checker) untrace(format string, args ...interface{}) {\n+\tif len(format) > 0 {\n+\t\tcheck.printTrace(format, args)\n+\t}\n+\tcheck.pos = check.pos[:len(check.pos)-1]\n+}\n+\n func (check *checker) formatMsg(format string, args []interface{}) string {\n \tfor i, arg := range args {\n \t\tswitch a := arg.(type) {", "previous_filename": "libgo/go/exp/types/staging/errors.go"}, {"sha": "1f6a3c72526989c16e460c19f2882b897549195f", "filename": "libgo/go/exp/types/exportdata.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -22,7 +22,8 @@ func readGopackHeader(r *bufio.Reader) (name string, size int, err error) {\n \tif err != nil {\n \t\treturn\n \t}\n-\tif trace {\n+\t// leave for debugging\n+\tif false {\n \t\tfmt.Printf(\"header: %s\", hdr)\n \t}\n \ts := strings.TrimSpace(string(hdr[16+12+6+6+8:][:10]))"}, {"sha": "58a33d0548e8fabcbd984a8931bb8d82e665f229", "filename": "libgo/go/exp/types/expr.go", "status": "renamed", "additions": 172, "deletions": 99, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -15,6 +15,7 @@ import (\n // TODO(gri)\n // - don't print error messages referring to invalid types (they are likely spurious errors)\n // - simplify invalid handling: maybe just use Typ[Invalid] as marker, get rid of invalid Mode for values?\n+// - rethink error handling: should all callers check if x.mode == valid after making a call?\n \n func (check *checker) tag(field *ast.Field) string {\n \tif t := field.Tag; t != nil {\n@@ -94,7 +95,7 @@ func (check *checker) collectStructFields(list *ast.FieldList, cycleOk bool) (fi\n \t\t\t\tfields = append(fields, &StructField{t.Obj.Name, t, tag, true})\n \t\t\tdefault:\n \t\t\t\tif typ != Typ[Invalid] {\n-\t\t\t\t\tcheck.errorf(f.Type.Pos(), \"invalid anonymous field type %s\", typ)\n+\t\t\t\t\tcheck.invalidAST(f.Type.Pos(), \"anonymous field type %s must be named\", typ)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -105,11 +106,10 @@ func (check *checker) collectStructFields(list *ast.FieldList, cycleOk bool) (fi\n type opPredicates map[token.Token]func(Type) bool\n \n var unaryOpPredicates = opPredicates{\n-\ttoken.ADD:   isNumeric,\n-\ttoken.SUB:   isNumeric,\n-\ttoken.XOR:   isInteger,\n-\ttoken.NOT:   isBoolean,\n-\ttoken.ARROW: func(typ Type) bool { t, ok := underlying(typ).(*Chan); return ok && t.Dir&ast.RECV != 0 },\n+\ttoken.ADD: isNumeric,\n+\ttoken.SUB: isNumeric,\n+\ttoken.XOR: isInteger,\n+\ttoken.NOT: isBoolean,\n }\n \n func (check *checker) op(m opPredicates, x *operand, op token.Token) bool {\n@@ -129,20 +129,33 @@ func (check *checker) op(m opPredicates, x *operand, op token.Token) bool {\n }\n \n func (check *checker) unary(x *operand, op token.Token) {\n-\tif op == token.AND {\n+\tswitch op {\n+\tcase token.AND:\n \t\t// TODO(gri) need to check for composite literals, somehow (they are not variables, in general)\n \t\tif x.mode != variable {\n \t\t\tcheck.invalidOp(x.pos(), \"cannot take address of %s\", x)\n-\t\t\tx.mode = invalid\n-\t\t\treturn\n+\t\t\tgoto Error\n \t\t}\n \t\tx.typ = &Pointer{Base: x.typ}\n \t\treturn\n+\n+\tcase token.ARROW:\n+\t\ttyp, ok := underlying(x.typ).(*Chan)\n+\t\tif !ok {\n+\t\t\tcheck.invalidOp(x.pos(), \"cannot receive from non-channel %s\", x)\n+\t\t\tgoto Error\n+\t\t}\n+\t\tif typ.Dir&ast.RECV == 0 {\n+\t\t\tcheck.invalidOp(x.pos(), \"cannot receive from send-only channel %s\", x)\n+\t\t\tgoto Error\n+\t\t}\n+\t\tx.mode = valueok\n+\t\tx.typ = typ.Elt\n+\t\treturn\n \t}\n \n \tif !check.op(unaryOpPredicates, x, op) {\n-\t\tx.mode = invalid\n-\t\treturn\n+\t\tgoto Error\n \t}\n \n \tif x.mode == constant {\n@@ -156,7 +169,7 @@ func (check *checker) unary(x *operand, op token.Token) {\n \t\tcase token.NOT:\n \t\t\tx.val = !x.val.(bool)\n \t\tdefault:\n-\t\t\tunreachable()\n+\t\t\tunreachable() // operators where checked by check.op\n \t\t}\n \t\t// Typed constants must be representable in\n \t\t// their type after each constant operation.\n@@ -165,6 +178,11 @@ func (check *checker) unary(x *operand, op token.Token) {\n \t}\n \n \tx.mode = value\n+\t// x.typ remains unchanged\n+\treturn\n+\n+Error:\n+\tx.mode = invalid\n }\n \n func isShift(op token.Token) bool {\n@@ -216,8 +234,7 @@ func (check *checker) convertUntyped(x *operand, target Type) {\n \t\t\t\tx.typ = target\n \t\t\t}\n \t\t} else if xkind != tkind {\n-\t\t\tcheck.errorf(x.pos(), \"cannot convert %s to %s\", x, target)\n-\t\t\tx.mode = invalid // avoid spurious errors\n+\t\t\tgoto Error\n \t\t}\n \t\treturn\n \t}\n@@ -226,15 +243,22 @@ func (check *checker) convertUntyped(x *operand, target Type) {\n \tswitch t := underlying(target).(type) {\n \tcase *Basic:\n \t\tcheck.isRepresentable(x, t)\n-\n-\tcase *Pointer, *Signature, *Interface, *Slice, *Map, *Chan:\n-\t\tif x.typ != Typ[UntypedNil] {\n-\t\t\tcheck.errorf(x.pos(), \"cannot convert %s to %s\", x, target)\n-\t\t\tx.mode = invalid\n+\tcase *Interface:\n+\t\tif !x.isNil() && len(t.Methods) > 0 /* empty interfaces are ok */ {\n+\t\t\tgoto Error\n+\t\t}\n+\tcase *Pointer, *Signature, *Slice, *Map, *Chan:\n+\t\tif !x.isNil() {\n+\t\t\tgoto Error\n \t\t}\n \t}\n \n \tx.typ = target\n+\treturn\n+\n+Error:\n+\tcheck.errorf(x.pos(), \"cannot convert %s to %s\", x, target)\n+\tx.mode = invalid\n }\n \n func (check *checker) comparison(x, y *operand, op token.Token) {\n@@ -244,9 +268,11 @@ func (check *checker) comparison(x, y *operand, op token.Token) {\n \tif x.isAssignable(y.typ) || y.isAssignable(x.typ) {\n \t\tswitch op {\n \t\tcase token.EQL, token.NEQ:\n-\t\t\tvalid = isComparable(x.typ)\n+\t\t\tvalid = isComparable(x.typ) ||\n+\t\t\t\tx.isNil() && hasNil(y.typ) ||\n+\t\t\t\ty.isNil() && hasNil(x.typ)\n \t\tcase token.LSS, token.LEQ, token.GTR, token.GEQ:\n-\t\t\tvalid = isOrdered(y.typ)\n+\t\t\tvalid = isOrdered(x.typ)\n \t\tdefault:\n \t\t\tunreachable()\n \t\t}\n@@ -389,7 +415,7 @@ func (check *checker) binary(x, y *operand, op token.Token, hint Type) {\n \t\tx.val = binaryOpConst(x.val, y.val, op, isInteger(x.typ))\n \t\t// Typed constants must be representable in\n \t\t// their type after each constant operation.\n-\t\tcheck.isRepresentable(x, x.typ.(*Basic))\n+\t\tcheck.isRepresentable(x, underlying(x.typ).(*Basic))\n \t\treturn\n \t}\n \n@@ -398,38 +424,31 @@ func (check *checker) binary(x, y *operand, op token.Token, hint Type) {\n }\n \n // index checks an index expression for validity. If length >= 0, it is the upper\n-// bound for the index. The result is a valid constant index >= 0, or a negative\n-// value.\n+// bound for the index. The result is a valid integer constant, or nil.\n //\n-func (check *checker) index(index ast.Expr, length int64, iota int) int64 {\n+func (check *checker) index(index ast.Expr, length int64, iota int) interface{} {\n \tvar x operand\n-\tvar i int64 // index value, valid if >= 0\n \n \tcheck.expr(&x, index, nil, iota)\n \tif !x.isInteger() {\n \t\tcheck.errorf(x.pos(), \"index %s must be integer\", &x)\n-\t\treturn -1\n+\t\treturn nil\n \t}\n \tif x.mode != constant {\n-\t\treturn -1 // we cannot check more\n+\t\treturn nil // we cannot check more\n \t}\n \t// x.mode == constant and the index value must be >= 0\n \tif isNegConst(x.val) {\n \t\tcheck.errorf(x.pos(), \"index %s must not be negative\", &x)\n-\t\treturn -1\n-\t}\n-\tvar ok bool\n-\tif i, ok = x.val.(int64); !ok {\n-\t\t// index value doesn't fit into an int64\n-\t\ti = length // trigger out of bounds check below if we know length (>= 0)\n+\t\treturn nil\n \t}\n-\n-\tif length >= 0 && i >= length {\n+\t// x.val >= 0\n+\tif length >= 0 && compareConst(x.val, length, token.GEQ) {\n \t\tcheck.errorf(x.pos(), \"index %s is out of bounds (>= %d)\", &x, length)\n-\t\treturn -1\n+\t\treturn nil\n \t}\n \n-\treturn i\n+\treturn x.val\n }\n \n func (check *checker) callRecord(x *operand) {\n@@ -438,20 +457,25 @@ func (check *checker) callRecord(x *operand) {\n \t}\n }\n \n-// expr typechecks expression e and initializes x with the expression\n+// rawExpr typechecks expression e and initializes x with the expression\n // value or type. If an error occured, x.mode is set to invalid.\n // A hint != nil is used as operand type for untyped shifted operands;\n // iota >= 0 indicates that the expression is part of a constant declaration.\n // cycleOk indicates whether it is ok for a type expression to refer to itself.\n //\n-func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cycleOk bool) {\n+func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycleOk bool) {\n+\tif trace {\n+\t\tcheck.trace(e.Pos(), \"expr(%s, iota = %d, cycleOk = %v)\", e, iota, cycleOk)\n+\t\tdefer check.untrace(\"=> %s\", x)\n+\t}\n+\n \tif check.mapf != nil {\n \t\tdefer check.callRecord(x)\n \t}\n \n \tswitch e := e.(type) {\n \tcase *ast.BadExpr:\n-\t\tx.mode = invalid\n+\t\tgoto Error // error was reported before\n \n \tcase *ast.Ident:\n \t\tif e.Name == \"_\" {\n@@ -460,13 +484,14 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \t\t}\n \t\tobj := e.Obj\n \t\tif obj == nil {\n-\t\t\t// unresolved identifier (error has been reported before)\n-\t\t\tgoto Error\n+\t\t\tgoto Error // error was reported before\n+\t\t}\n+\t\tif obj.Type == nil {\n+\t\t\tcheck.object(obj, cycleOk)\n \t\t}\n-\t\tcheck.ident(e, cycleOk)\n \t\tswitch obj.Kind {\n \t\tcase ast.Bad:\n-\t\t\tgoto Error\n+\t\t\tgoto Error // error was reported before\n \t\tcase ast.Pkg:\n \t\t\tcheck.errorf(e.Pos(), \"use of package %s not in selector\", obj.Name)\n \t\t\tgoto Error\n@@ -501,6 +526,9 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \t\t}\n \t\tx.typ = obj.Type.(Type)\n \n+\tcase *ast.Ellipsis:\n+\t\tunimplemented()\n+\n \tcase *ast.BasicLit:\n \t\tx.setConst(e.Kind, e.Value)\n \t\tif x.mode == invalid {\n@@ -511,32 +539,41 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \tcase *ast.FuncLit:\n \t\tx.mode = value\n \t\tx.typ = check.typ(e.Type, false)\n-\t\tcheck.stmt(e.Body)\n+\t\t// TODO(gri) handle errors (e.g. x.typ is not a *Signature)\n+\t\tcheck.function(x.typ.(*Signature), e.Body)\n \n \tcase *ast.CompositeLit:\n \t\t// TODO(gri)\n \t\t//\t- determine element type if nil\n \t\t//\t- deal with map elements\n+\t\tvar typ Type\n+\t\tif e.Type != nil {\n+\t\t\t// TODO(gri) Fix this - just to get going for now\n+\t\t\ttyp = check.typ(e.Type, false)\n+\t\t}\n \t\tfor _, e := range e.Elts {\n \t\t\tvar x operand\n \t\t\tcheck.expr(&x, e, hint, iota)\n \t\t\t// TODO(gri) check assignment compatibility to element type\n \t\t}\n-\t\tx.mode = value // TODO(gri) composite literals are addressable\n+\t\t// TODO(gri) this is not correct - leave for now to get going\n+\t\tx.mode = variable\n+\t\tx.typ = typ\n \n \tcase *ast.ParenExpr:\n-\t\tcheck.exprOrType(x, e.X, hint, iota, cycleOk)\n+\t\tcheck.rawExpr(x, e.X, hint, iota, cycleOk)\n \n \tcase *ast.SelectorExpr:\n+\t\tsel := e.Sel.Name\n \t\t// If the identifier refers to a package, handle everything here\n \t\t// so we don't need a \"package\" mode for operands: package names\n \t\t// can only appear in qualified identifiers which are mapped to\n \t\t// selector expressions.\n \t\tif ident, ok := e.X.(*ast.Ident); ok {\n \t\t\tif obj := ident.Obj; obj != nil && obj.Kind == ast.Pkg {\n-\t\t\t\texp := obj.Data.(*ast.Scope).Lookup(e.Sel.Name)\n+\t\t\t\texp := obj.Data.(*ast.Scope).Lookup(sel)\n \t\t\t\tif exp == nil {\n-\t\t\t\t\tcheck.errorf(e.Sel.Pos(), \"cannot refer to unexported %s\", e.Sel.Name)\n+\t\t\t\t\tcheck.errorf(e.Sel.Pos(), \"cannot refer to unexported %s\", sel)\n \t\t\t\t\tgoto Error\n \t\t\t\t}\n \t\t\t\t// simplified version of the code for *ast.Idents:\n@@ -561,24 +598,39 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \t\t\t}\n \t\t}\n \n-\t\t// TODO(gri) lots of checks missing below - just raw outline\n-\t\tcheck.expr(x, e.X, hint, iota)\n-\t\tswitch typ := x.typ.(type) {\n-\t\tcase *Struct:\n-\t\t\tif fld := lookupField(typ, e.Sel.Name); fld != nil {\n-\t\t\t\t// TODO(gri) only variable if struct is variable \n-\t\t\t\tx.mode = variable\n-\t\t\t\tx.expr = e\n-\t\t\t\tx.typ = fld.Type\n-\t\t\t\treturn\n+\t\tcheck.exprOrType(x, e.X, nil, iota, false)\n+\t\tif x.mode == invalid {\n+\t\t\tgoto Error\n+\t\t}\n+\t\tmode, typ := lookupField(x.typ, sel)\n+\t\tif mode == invalid {\n+\t\t\tcheck.invalidOp(e.Pos(), \"%s has no field or method %s\", x, sel)\n+\t\t\tgoto Error\n+\t\t}\n+\t\tif x.mode == typexpr {\n+\t\t\t// method expression\n+\t\t\tsig, ok := typ.(*Signature)\n+\t\t\tif !ok {\n+\t\t\t\tcheck.invalidOp(e.Pos(), \"%s has no method %s\", x, sel)\n+\t\t\t\tgoto Error\n+\t\t\t}\n+\t\t\t// the receiver type becomes the type of the first function\n+\t\t\t// argument of the method expression's function type\n+\t\t\t// TODO(gri) at the moment, method sets don't correctly track\n+\t\t\t// pointer vs non-pointer receivers -> typechecker is too lenient\n+\t\t\targ := ast.NewObj(ast.Var, \"\")\n+\t\t\targ.Type = x.typ\n+\t\t\tx.mode = value\n+\t\t\tx.typ = &Signature{\n+\t\t\t\tParams:     append(ObjList{arg}, sig.Params...),\n+\t\t\t\tResults:    sig.Results,\n+\t\t\t\tIsVariadic: sig.IsVariadic,\n \t\t\t}\n-\t\tcase *Interface:\n-\t\t\tunimplemented()\n-\t\tcase *NamedType:\n-\t\t\tunimplemented()\n+\t\t} else {\n+\t\t\t// regular selector\n+\t\t\tx.mode = mode\n+\t\t\tx.typ = typ\n \t\t}\n-\t\tcheck.invalidOp(e.Pos(), \"%s has no field or method %s\", x.typ, e.Sel.Name)\n-\t\tgoto Error\n \n \tcase *ast.IndexExpr:\n \t\tcheck.expr(x, e.X, hint, iota)\n@@ -614,7 +666,7 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \n \t\tcase *Map:\n \t\t\t// TODO(gri) check index type\n-\t\t\tx.mode = variable\n+\t\t\tx.mode = valueok\n \t\t\tx.typ = typ.Elt\n \t\t\treturn\n \t\t}\n@@ -672,24 +724,26 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \t\t\tgoto Error\n \t\t}\n \n-\t\tvar lo int64\n+\t\tvar lo interface{} = zeroConst\n \t\tif e.Low != nil {\n \t\t\tlo = check.index(e.Low, length, iota)\n \t\t}\n \n-\t\tvar hi int64 = length\n+\t\tvar hi interface{}\n \t\tif e.High != nil {\n \t\t\thi = check.index(e.High, length, iota)\n+\t\t} else if length >= 0 {\n+\t\t\thi = length\n \t\t}\n \n-\t\tif hi >= 0 && lo > hi {\n-\t\t\tcheck.errorf(e.Low.Pos(), \"inverted slice range: %d > %d\", lo, hi)\n+\t\tif lo != nil && hi != nil && compareConst(lo, hi, token.GTR) {\n+\t\t\tcheck.errorf(e.Low.Pos(), \"inverted slice range: %v > %v\", lo, hi)\n \t\t\t// ok to continue\n \t\t}\n \n \tcase *ast.TypeAssertExpr:\n \t\tcheck.expr(x, e.X, hint, iota)\n-\t\tif _, ok := x.typ.(*Interface); !ok {\n+\t\tif _, ok := underlying(x.typ).(*Interface); !ok {\n \t\t\tcheck.invalidOp(e.X.Pos(), \"non-interface type %s in type assertion\", x.typ)\n \t\t\t// ok to continue\n \t\t}\n@@ -700,9 +754,10 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \n \tcase *ast.CallExpr:\n \t\tcheck.exprOrType(x, e.Fun, nil, iota, false)\n-\t\tif x.mode == typexpr {\n+\t\tif x.mode == invalid {\n+\t\t\tgoto Error\n+\t\t} else if x.mode == typexpr {\n \t\t\tcheck.conversion(x, e, x.typ, iota)\n-\n \t\t} else if sig, ok := underlying(x.typ).(*Signature); ok {\n \t\t\t// check parameters\n \t\t\t// TODO(gri) complete this\n@@ -747,8 +802,7 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \tcase *ast.StarExpr:\n \t\tcheck.exprOrType(x, e.X, hint, iota, true)\n \t\tswitch x.mode {\n-\t\tcase novalue:\n-\t\t\tcheck.errorf(x.pos(), \"%s used as value or type\", x)\n+\t\tcase invalid:\n \t\t\tgoto Error\n \t\tcase typexpr:\n \t\t\tx.typ = &Pointer{Base: x.typ}\n@@ -777,20 +831,28 @@ func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cy\n \n \tcase *ast.ArrayType:\n \t\tif e.Len != nil {\n-\t\t\tcheck.expr(x, e.Len, nil, 0)\n-\t\t\tif x.mode == invalid {\n-\t\t\t\tgoto Error\n-\t\t\t}\n \t\t\tvar n int64 = -1\n-\t\t\tif x.mode == constant {\n-\t\t\t\tif i, ok := x.val.(int64); ok && i == int64(int(i)) {\n-\t\t\t\t\tn = i\n+\t\t\tif ellip, ok := e.Len.(*ast.Ellipsis); ok {\n+\t\t\t\t// TODO(gri) need to check somewhere that [...]T types are only used with composite literals\n+\t\t\t\tif ellip.Elt != nil {\n+\t\t\t\t\tcheck.invalidAST(ellip.Pos(), \"ellipsis only expected\")\n+\t\t\t\t\t// ok to continue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcheck.expr(x, e.Len, nil, 0)\n+\t\t\t\tif x.mode == invalid {\n+\t\t\t\t\tgoto Error\n+\t\t\t\t}\n+\t\t\t\tif x.mode == constant {\n+\t\t\t\t\tif i, ok := x.val.(int64); ok && i == int64(int(i)) {\n+\t\t\t\t\t\tn = i\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif n < 0 {\n+\t\t\t\t\tcheck.errorf(e.Len.Pos(), \"invalid array bound %s\", e.Len)\n+\t\t\t\t\t// ok to continue\n+\t\t\t\t\tn = 0\n \t\t\t\t}\n-\t\t\t}\n-\t\t\tif n < 0 {\n-\t\t\t\tcheck.errorf(e.Len.Pos(), \"invalid array bound %s\", e.Len)\n-\t\t\t\t// ok to continue\n-\t\t\t\tn = 0\n \t\t\t}\n \t\t\tx.typ = &Array{Len: n, Elt: check.typ(e.Elt, cycleOk)}\n \t\t} else {\n@@ -836,9 +898,18 @@ Error:\n \tx.expr = e\n }\n \n-// expr is like exprOrType but also checks that e represents a value (rather than a type).\n+// exprOrType is like rawExpr but reports an error if e doesn't represents a value or type.\n+func (check *checker) exprOrType(x *operand, e ast.Expr, hint Type, iota int, cycleOk bool) {\n+\tcheck.rawExpr(x, e, hint, iota, cycleOk)\n+\tif x.mode == novalue {\n+\t\tcheck.errorf(x.pos(), \"%s used as value or type\", x)\n+\t\tx.mode = invalid\n+\t}\n+}\n+\n+// expr is like rawExpr but reports an error if e doesn't represents a value.\n func (check *checker) expr(x *operand, e ast.Expr, hint Type, iota int) {\n-\tcheck.exprOrType(x, e, hint, iota, false)\n+\tcheck.rawExpr(x, e, hint, iota, false)\n \tswitch x.mode {\n \tcase novalue:\n \t\tcheck.errorf(x.pos(), \"%s used as value\", x)\n@@ -849,19 +920,21 @@ func (check *checker) expr(x *operand, e ast.Expr, hint Type, iota int) {\n \t}\n }\n \n-// typ is like exprOrType but also checks that e represents a type (rather than a value).\n-// If an error occured, the result is Typ[Invalid].\n+// expr is like rawExpr but reports an error if e doesn't represents a type.\n+// It returns e's type, or Typ[Invalid] if an error occured.\n //\n func (check *checker) typ(e ast.Expr, cycleOk bool) Type {\n \tvar x operand\n-\tcheck.exprOrType(&x, e, nil, -1, cycleOk)\n-\tswitch {\n-\tcase x.mode == novalue:\n+\tcheck.rawExpr(&x, e, nil, -1, cycleOk)\n+\tswitch x.mode {\n+\tcase invalid:\n+\t\t// ignore - error reported before\n+\tcase novalue:\n \t\tcheck.errorf(x.pos(), \"%s used as type\", &x)\n-\t\tx.typ = Typ[Invalid]\n-\tcase x.mode != typexpr:\n+\tcase typexpr:\n+\t\treturn x.typ\n+\tdefault:\n \t\tcheck.errorf(x.pos(), \"%s is not a type\", &x)\n-\t\tx.typ = Typ[Invalid]\n \t}\n-\treturn x.typ\n+\treturn Typ[Invalid]\n }", "previous_filename": "libgo/go/exp/types/staging/expr.go"}, {"sha": "4318e6aa21e507271ff07bd7f92de7cf9b11a811", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 125, "deletions": 102, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -23,8 +23,6 @@ import (\n \t\"text/scanner\"\n )\n \n-const trace = false // set to true for debugging\n-\n var pkgExts = [...]string{\".a\", \".5\", \".6\", \".8\"}\n \n // FindPkg returns the filename and unique package id for an import\n@@ -86,10 +84,6 @@ func FindPkg(path, srcDir string) (filename, id string) {\n // in error messages.\n //\n func GcImportData(imports map[string]*ast.Object, filename, id string, data *bufio.Reader) (pkg *ast.Object, err error) {\n-\tif trace {\n-\t\tfmt.Printf(\"importing %s (%s)\\n\", id, filename)\n-\t}\n-\n \t// support for gcParser error handling\n \tdefer func() {\n \t\tif r := recover(); r != nil {\n@@ -182,12 +176,13 @@ func (p *gcParser) init(filename, id string, src io.Reader, imports map[string]*\n func (p *gcParser) next() {\n \tp.tok = p.scanner.Scan()\n \tswitch p.tok {\n-\tcase scanner.Ident, scanner.Int, scanner.String, '\u00b7':\n+\tcase scanner.Ident, scanner.Int, scanner.Char, scanner.String, '\u00b7':\n \t\tp.lit = p.scanner.TokenText()\n \tdefault:\n \t\tp.lit = \"\"\n \t}\n-\tif trace {\n+\t// leave for debugging\n+\tif false {\n \t\tfmt.Printf(\"%s: %q -> %q\\n\", scanner.TokenString(p.tok), p.scanner.TokenText(), p.lit)\n \t}\n }\n@@ -204,13 +199,13 @@ func (p *gcParser) declare(scope *ast.Scope, kind ast.ObjKind, name string) *ast\n \t// otherwise create a new object and insert it into the package scope\n \tobj := ast.NewObj(kind, name)\n \tif scope.Insert(obj) != nil {\n-\t\tp.errorf(\"already declared: %v %s\", kind, obj.Name)\n+\t\tunreachable() // Lookup should have found it\n \t}\n \n-\t// a new type object is a named type and may be referred\n+\t// if the new type object is a named type it may be referred\n \t// to before the underlying type is known - set it up\n \tif kind == ast.Typ {\n-\t\tobj.Type = &Name{Obj: obj}\n+\t\tobj.Type = &NamedType{Obj: obj}\n \t}\n \n \treturn obj\n@@ -244,7 +239,6 @@ func (p *gcParser) errorf(format string, args ...interface{}) {\n func (p *gcParser) expect(tok rune) string {\n \tlit := p.lit\n \tif p.tok != tok {\n-\t\tpanic(1)\n \t\tp.errorf(\"expected %s, got %s (%s)\", scanner.TokenString(tok), scanner.TokenString(p.tok), lit)\n \t}\n \tp.next()\n@@ -350,7 +344,7 @@ func (p *gcParser) parseArrayType() Type {\n \tlit := p.expect(scanner.Int)\n \tp.expect(']')\n \telt := p.parseType()\n-\tn, err := strconv.ParseUint(lit, 10, 64)\n+\tn, err := strconv.ParseInt(lit, 10, 64)\n \tif err != nil {\n \t\tp.error(err)\n \t}\n@@ -389,34 +383,33 @@ func (p *gcParser) parseName() (name string) {\n \n // Field = Name Type [ string_lit ] .\n //\n-func (p *gcParser) parseField() (fld *ast.Object, tag string) {\n-\tname := p.parseName()\n-\tftyp := p.parseType()\n-\tif name == \"\" {\n-\t\t// anonymous field - ftyp must be T or *T and T must be a type name\n-\t\tif _, ok := Deref(ftyp).(*Name); !ok {\n+func (p *gcParser) parseField() *StructField {\n+\tvar f StructField\n+\tf.Name = p.parseName()\n+\tf.Type = p.parseType()\n+\tif p.tok == scanner.String {\n+\t\tf.Tag = p.expect(scanner.String)\n+\t}\n+\tif f.Name == \"\" {\n+\t\t// anonymous field - typ must be T or *T and T must be a type name\n+\t\tif typ, ok := deref(f.Type).(*NamedType); ok && typ.Obj != nil {\n+\t\t\tf.Name = typ.Obj.Name\n+\t\t\tf.IsAnonymous = true\n+\t\t} else {\n \t\t\tp.errorf(\"anonymous field expected\")\n \t\t}\n \t}\n-\tif p.tok == scanner.String {\n-\t\ttag = p.expect(scanner.String)\n-\t}\n-\tfld = ast.NewObj(ast.Var, name)\n-\tfld.Type = ftyp\n-\treturn\n+\treturn &f\n }\n \n // StructType = \"struct\" \"{\" [ FieldList ] \"}\" .\n // FieldList  = Field { \";\" Field } .\n //\n func (p *gcParser) parseStructType() Type {\n-\tvar fields []*ast.Object\n-\tvar tags []string\n+\tvar fields []*StructField\n \n \tparseField := func() {\n-\t\tfld, tag := p.parseField()\n-\t\tfields = append(fields, fld)\n-\t\ttags = append(tags, tag)\n+\t\tfields = append(fields, p.parseField())\n \t}\n \n \tp.expectKeyword(\"struct\")\n@@ -430,7 +423,7 @@ func (p *gcParser) parseStructType() Type {\n \t}\n \tp.expect('}')\n \n-\treturn &Struct{Fields: fields, Tags: tags}\n+\treturn &Struct{Fields: fields}\n }\n \n // Parameter = ( identifier | \"?\" ) [ \"...\" ] Type [ string_lit ] .\n@@ -445,9 +438,9 @@ func (p *gcParser) parseParameter() (par *ast.Object, isVariadic bool) {\n \t\tisVariadic = true\n \t}\n \tptyp := p.parseType()\n-\t// ignore argument tag\n+\t// ignore argument tag (e.g. \"noescape\")\n \tif p.tok == scanner.String {\n-\t\tp.expect(scanner.String)\n+\t\tp.next()\n \t}\n \tpar = ast.NewObj(ast.Var, name)\n \tpar.Type = ptyp\n@@ -485,7 +478,7 @@ func (p *gcParser) parseParameters() (list []*ast.Object, isVariadic bool) {\n // Signature = Parameters [ Result ] .\n // Result    = Type | Parameters .\n //\n-func (p *gcParser) parseSignature() *Func {\n+func (p *gcParser) parseSignature() *Signature {\n \tparams, isVariadic := p.parseParameters()\n \n \t// optional result type\n@@ -505,16 +498,16 @@ func (p *gcParser) parseSignature() *Func {\n \t\t}\n \t}\n \n-\treturn &Func{Params: params, Results: results, IsVariadic: isVariadic}\n+\treturn &Signature{Params: params, Results: results, IsVariadic: isVariadic}\n }\n \n // InterfaceType = \"interface\" \"{\" [ MethodList ] \"}\" .\n-// MethodList = Method { \";\" Method } .\n-// Method = Name Signature .\n+// MethodList    = Method { \";\" Method } .\n+// Method        = Name Signature .\n //\n-// (The methods of embedded interfaces are always \"inlined\"\n+// The methods of embedded interfaces are always \"inlined\"\n // by the compiler and thus embedded interfaces are never\n-// visible in the export data.)\n+// visible in the export data.\n //\n func (p *gcParser) parseInterfaceType() Type {\n \tvar methods ObjList\n@@ -563,11 +556,12 @@ func (p *gcParser) parseChanType() Type {\n //\tBasicType | TypeName | ArrayType | SliceType | StructType |\n //      PointerType | FuncType | InterfaceType | MapType | ChanType |\n //      \"(\" Type \")\" .\n-// BasicType = ident .\n-// TypeName = ExportedName .\n-// SliceType = \"[\" \"]\" Type .\n+//\n+// BasicType   = ident .\n+// TypeName    = ExportedName .\n+// SliceType   = \"[\" \"]\" Type .\n // PointerType = \"*\" Type .\n-// FuncType = \"func\" Signature .\n+// FuncType    = \"func\" Signature .\n //\n func (p *gcParser) parseType() Type {\n \tswitch p.tok {\n@@ -635,11 +629,11 @@ func (p *gcParser) parseImportDecl() {\n \n // int_lit = [ \"+\" | \"-\" ] { \"0\" ... \"9\" } .\n //\n-func (p *gcParser) parseInt() (sign, val string) {\n+func (p *gcParser) parseInt() (neg bool, val string) {\n \tswitch p.tok {\n \tcase '-':\n-\t\tp.next()\n-\t\tsign = \"-\"\n+\t\tneg = true\n+\t\tfallthrough\n \tcase '+':\n \t\tp.next()\n \t}\n@@ -649,48 +643,58 @@ func (p *gcParser) parseInt() (sign, val string) {\n \n // number = int_lit [ \"p\" int_lit ] .\n //\n-func (p *gcParser) parseNumber() Const {\n+func (p *gcParser) parseNumber() (x operand) {\n+\tx.mode = constant\n+\n \t// mantissa\n-\tsign, val := p.parseInt()\n-\tmant, ok := new(big.Int).SetString(sign+val, 0)\n+\tneg, val := p.parseInt()\n+\tmant, ok := new(big.Int).SetString(val, 0)\n \tassert(ok)\n+\tif neg {\n+\t\tmant.Neg(mant)\n+\t}\n \n \tif p.lit == \"p\" {\n \t\t// exponent (base 2)\n \t\tp.next()\n-\t\tsign, val = p.parseInt()\n+\t\tneg, val = p.parseInt()\n \t\texp64, err := strconv.ParseUint(val, 10, 0)\n \t\tif err != nil {\n \t\t\tp.error(err)\n \t\t}\n \t\texp := uint(exp64)\n-\t\tif sign == \"-\" {\n+\t\tif neg {\n \t\t\tdenom := big.NewInt(1)\n \t\t\tdenom.Lsh(denom, exp)\n-\t\t\treturn Const{new(big.Rat).SetFrac(mant, denom)}\n+\t\t\tx.typ = Typ[UntypedFloat]\n+\t\t\tx.val = normalizeRatConst(new(big.Rat).SetFrac(mant, denom))\n+\t\t\treturn\n \t\t}\n \t\tif exp > 0 {\n \t\t\tmant.Lsh(mant, exp)\n \t\t}\n-\t\treturn Const{new(big.Rat).SetInt(mant)}\n+\t\tx.typ = Typ[UntypedFloat]\n+\t\tx.val = normalizeIntConst(mant)\n+\t\treturn\n \t}\n \n-\treturn Const{mant}\n+\tx.typ = Typ[UntypedInt]\n+\tx.val = normalizeIntConst(mant)\n+\treturn\n }\n \n // ConstDecl   = \"const\" ExportedName [ Type ] \"=\" Literal .\n-// Literal     = bool_lit | int_lit | float_lit | complex_lit | string_lit .\n+// Literal     = bool_lit | int_lit | float_lit | complex_lit | rune_lit | string_lit .\n // bool_lit    = \"true\" | \"false\" .\n // complex_lit = \"(\" float_lit \"+\" float_lit \"i\" \")\" .\n-// rune_lit = \"(\" int_lit \"+\" int_lit \")\" .\n+// rune_lit    = \"(\" int_lit \"+\" int_lit \")\" .\n // string_lit  = `\"` { unicode_char } `\"` .\n //\n func (p *gcParser) parseConstDecl() {\n \tp.expectKeyword(\"const\")\n \tpkg, name := p.parseExportedName()\n \tobj := p.declare(pkg.Data.(*ast.Scope), ast.Con, name)\n-\tvar x Const\n-\tvar typ Type\n+\tvar x operand\n \tif p.tok != '=' {\n \t\tobj.Type = p.parseType()\n \t}\n@@ -701,49 +705,53 @@ func (p *gcParser) parseConstDecl() {\n \t\tif p.lit != \"true\" && p.lit != \"false\" {\n \t\t\tp.error(\"expected true or false\")\n \t\t}\n-\t\tx = Const{p.lit == \"true\"}\n-\t\ttyp = Bool.Underlying\n+\t\tx.typ = Typ[UntypedBool]\n+\t\tx.val = p.lit == \"true\"\n \t\tp.next()\n+\n \tcase '-', scanner.Int:\n \t\t// int_lit\n \t\tx = p.parseNumber()\n-\t\ttyp = Int.Underlying\n-\t\tif _, ok := x.val.(*big.Rat); ok {\n-\t\t\ttyp = Float64.Underlying\n-\t\t}\n+\n \tcase '(':\n \t\t// complex_lit or rune_lit\n \t\tp.next()\n \t\tif p.tok == scanner.Char {\n \t\t\tp.next()\n \t\t\tp.expect('+')\n-\t\t\tp.parseNumber()\n+\t\t\tx = p.parseNumber()\n+\t\t\tx.typ = Typ[UntypedRune]\n \t\t\tp.expect(')')\n-\t\t\t// TODO: x = ...\n \t\t\tbreak\n \t\t}\n \t\tre := p.parseNumber()\n \t\tp.expect('+')\n \t\tim := p.parseNumber()\n \t\tp.expectKeyword(\"i\")\n \t\tp.expect(')')\n-\t\tx = Const{cmplx{re.val.(*big.Rat), im.val.(*big.Rat)}}\n-\t\ttyp = Complex128.Underlying\n+\t\tx.typ = Typ[UntypedComplex]\n+\t\t// TODO(gri) fix this\n+\t\t_, _ = re, im\n+\t\tx.val = zeroConst\n+\n \tcase scanner.Char:\n-\t\t// TODO: x = ...\n+\t\t// rune_lit\n+\t\tx.setConst(token.CHAR, p.lit)\n \t\tp.next()\n+\n \tcase scanner.String:\n \t\t// string_lit\n-\t\tx = MakeConst(token.STRING, p.lit)\n+\t\tx.setConst(token.STRING, p.lit)\n \t\tp.next()\n-\t\ttyp = String.Underlying\n+\n \tdefault:\n \t\tp.errorf(\"expected literal got %s\", scanner.TokenString(p.tok))\n \t}\n \tif obj.Type == nil {\n-\t\tobj.Type = typ\n+\t\tobj.Type = x.typ\n \t}\n-\tobj.Data = x\n+\tassert(x.val != nil)\n+\tobj.Data = x.val\n }\n \n // TypeDecl = \"type\" ExportedName Type .\n@@ -760,8 +768,7 @@ func (p *gcParser) parseTypeDecl() {\n \t// a given type declaration.\n \ttyp := p.parseType()\n \n-\tif name := obj.Type.(*Name); name.Underlying == nil {\n-\t\tassert(Underlying(typ) == typ)\n+\tif name := obj.Type.(*NamedType); name.Underlying == nil {\n \t\tname.Underlying = typ\n \t}\n }\n@@ -775,45 +782,61 @@ func (p *gcParser) parseVarDecl() {\n \tobj.Type = p.parseType()\n }\n \n-// FuncBody = \"{\" ... \"}\" .\n+// Func = Signature [ Body ] .\n+// Body = \"{\" ... \"}\" .\n //\n-func (p *gcParser) parseFuncBody() {\n-\tp.expect('{')\n-\tfor i := 1; i > 0; p.next() {\n-\t\tswitch p.tok {\n-\t\tcase '{':\n-\t\t\ti++\n-\t\tcase '}':\n-\t\t\ti--\n-\t\t}\n-\t}\n-}\n-\n-// FuncDecl = \"func\" ExportedName Signature [ FuncBody ] .\n-//\n-func (p *gcParser) parseFuncDecl() {\n-\t// \"func\" already consumed\n-\tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Fun, name)\n+func (p *gcParser) parseFunc(scope *ast.Scope, name string) {\n+\tobj := p.declare(scope, ast.Fun, name)\n \tobj.Type = p.parseSignature()\n \tif p.tok == '{' {\n-\t\tp.parseFuncBody()\n+\t\tp.next()\n+\t\tfor i := 1; i > 0; p.next() {\n+\t\t\tswitch p.tok {\n+\t\t\tcase '{':\n+\t\t\t\ti++\n+\t\t\tcase '}':\n+\t\t\t\ti--\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n-// MethodDecl = \"func\" Receiver Name Signature .\n-// Receiver   = \"(\" ( identifier | \"?\" ) [ \"*\" ] ExportedName \")\" [ FuncBody ].\n+// MethodDecl = \"func\" Receiver Name Func .\n+// Receiver   = \"(\" ( identifier | \"?\" ) [ \"*\" ] ExportedName \")\" .\n //\n func (p *gcParser) parseMethodDecl() {\n \t// \"func\" already consumed\n \tp.expect('(')\n-\tp.parseParameter() // receiver\n+\trecv, _ := p.parseParameter() // receiver\n \tp.expect(')')\n-\tp.parseName() // unexported method names in imports are qualified with their package.\n-\tp.parseSignature()\n-\tif p.tok == '{' {\n-\t\tp.parseFuncBody()\n+\n+\t// determine receiver base type object\n+\ttyp := recv.Type.(Type)\n+\tif ptr, ok := typ.(*Pointer); ok {\n+\t\ttyp = ptr.Base\n+\t}\n+\tobj := typ.(*NamedType).Obj\n+\n+\t// determine base type scope\n+\tvar scope *ast.Scope\n+\tif obj.Data != nil {\n+\t\tscope = obj.Data.(*ast.Scope)\n+\t} else {\n+\t\tscope = ast.NewScope(nil)\n+\t\tobj.Data = scope\n \t}\n+\n+\t// declare method in base type scope\n+\tname := p.parseName() // unexported method names in imports are qualified with their package.\n+\tp.parseFunc(scope, name)\n+}\n+\n+// FuncDecl = \"func\" ExportedName Func .\n+//\n+func (p *gcParser) parseFuncDecl() {\n+\t// \"func\" already consumed\n+\tpkg, name := p.parseExportedName()\n+\tp.parseFunc(pkg.Data.(*ast.Scope), name)\n }\n \n // Decl = [ ImportDecl | ConstDecl | TypeDecl | VarDecl | FuncDecl | MethodDecl ] \"\\n\" ."}, {"sha": "d1cf605fe950dd29e25e2d5f7693d1358e5b6596", "filename": "libgo/go/exp/types/gcimporter_test.go", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -113,24 +113,24 @@ func TestGcImport(t *testing.T) {\n \tt.Logf(\"tested %d imports\", nimports)\n }\n \n-/*\n-\n-Does not work with gccgo.\n-\n var importedObjectTests = []struct {\n \tname string\n \tkind ast.ObjKind\n \ttyp  string\n }{\n \t{\"unsafe.Pointer\", ast.Typ, \"Pointer\"},\n-\t{\"math.Pi\", ast.Con, \"basicType\"}, // TODO(gri) need to complete BasicType\n+\t{\"math.Pi\", ast.Con, \"untyped float\"},\n \t{\"io.Reader\", ast.Typ, \"interface{Read(p []byte) (n int, err error)}\"},\n \t{\"io.ReadWriter\", ast.Typ, \"interface{Read(p []byte) (n int, err error); Write(p []byte) (n int, err error)}\"},\n-\t{\"math.Sin\", ast.Fun, \"func(x float64) (_ float64)\"},\n+\t{\"math.Sin\", ast.Fun, \"func(x\u00b72 float64) (_ float64)\"},\n \t// TODO(gri) add more tests\n }\n \n func TestGcImportedTypes(t *testing.T) {\n+\t// This package does not yet know how to read gccgo export data.\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\treturn\n+\t}\n \tfor _, test := range importedObjectTests {\n \t\ts := strings.Split(test.name, \".\")\n \t\tif len(s) != 2 {\n@@ -149,11 +149,9 @@ func TestGcImportedTypes(t *testing.T) {\n \t\tif obj.Kind != test.kind {\n \t\t\tt.Errorf(\"%s: got kind = %q; want %q\", test.name, obj.Kind, test.kind)\n \t\t}\n-\t\ttyp := TypeString(Underlying(obj.Type.(Type)))\n+\t\ttyp := typeString(underlying(obj.Type.(Type)))\n \t\tif typ != test.typ {\n \t\t\tt.Errorf(\"%s: got type = %q; want %q\", test.name, typ, test.typ)\n \t\t}\n \t}\n }\n-\n-*/"}, {"sha": "49ba899d917980d37b573a9ed8678e3fefb62ea1", "filename": "libgo/go/exp/types/operand.go", "status": "renamed", "additions": 141, "deletions": 14, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -69,7 +69,11 @@ func (x *operand) String() string {\n \t}\n \tbuf.WriteString(operandModeString[x.mode])\n \tif x.mode == constant {\n-\t\tfmt.Fprintf(&buf, \" %v\", x.val)\n+\t\tformat := \" %v\"\n+\t\tif isString(x.typ) {\n+\t\t\tformat = \" %q\"\n+\t\t}\n+\t\tfmt.Fprintf(&buf, format, x.val)\n \t}\n \tif x.mode != novalue && (x.mode != constant || !isUntyped(x.typ)) {\n \t\tfmt.Fprintf(&buf, \" of type %s\", typeString(x.typ))\n@@ -80,7 +84,7 @@ func (x *operand) String() string {\n \treturn buf.String()\n }\n \n-// setConst sets x to the untyped constant for literal lit. \n+// setConst sets x to the untyped constant for literal lit.\n func (x *operand) setConst(tok token.Token, lit string) {\n \tx.mode = invalid\n \n@@ -125,6 +129,11 @@ func (x *operand) implements(T *Interface) bool {\n \treturn true\n }\n \n+// isNil reports whether x is the predeclared nil constant.\n+func (x *operand) isNil() bool {\n+\treturn x.mode == constant && x.val == nilConst\n+}\n+\n // isAssignable reports whether x is assignable to a variable of type T.\n func (x *operand) isAssignable(T Type) bool {\n \tif x.mode == invalid || T == Typ[Invalid] {\n@@ -163,7 +172,7 @@ func (x *operand) isAssignable(T Type) bool {\n \n \t// x is the predeclared identifier nil and T is a pointer,\n \t// function, slice, map, channel, or interface type\n-\tif x.typ == Typ[UntypedNil] {\n+\tif x.isNil() {\n \t\tswitch Tu.(type) {\n \t\tcase *Pointer, *Signature, *Slice, *Map, *Chan, *Interface:\n \t\t\treturn true\n@@ -185,17 +194,135 @@ func (x *operand) isInteger() bool {\n \t\tx.mode == constant && isRepresentableConst(x.val, UntypedInt)\n }\n \n-// lookupField returns the struct field with the given name in typ.\n-// If no such field exists, the result is nil.\n-// TODO(gri) should this be a method of Struct?\n-//\n-func lookupField(typ *Struct, name string) *StructField {\n-\t// TODO(gri) deal with embedding and conflicts - this is\n-\t//           a very basic version to get going for now.\n-\tfor _, f := range typ.Fields {\n-\t\tif f.Name == name {\n-\t\t\treturn f\n+type lookupResult struct {\n+\tmode operandMode\n+\ttyp  Type\n+}\n+\n+// lookupFieldRecursive is similar to FieldByNameFunc in reflect/type.go\n+// TODO(gri): FieldByNameFunc seems more complex - what are we missing?\n+func lookupFieldRecursive(list []*NamedType, name string) (res lookupResult) {\n+\t// visited records the types that have been searched already\n+\tvisited := make(map[Type]bool)\n+\n+\t// embedded types of the next lower level\n+\tvar next []*NamedType\n+\n+\tpotentialMatch := func(mode operandMode, typ Type) bool {\n+\t\tif res.mode != invalid {\n+\t\t\t// name appeared multiple times at this level - annihilate\n+\t\t\tres.mode = invalid\n+\t\t\treturn false\n+\t\t}\n+\t\tres.mode = mode\n+\t\tres.typ = typ\n+\t\treturn true\n+\t}\n+\n+\t// look for name in all types of this level\n+\tfor len(list) > 0 {\n+\t\tassert(res.mode == invalid)\n+\t\tfor _, typ := range list {\n+\t\t\tif visited[typ] {\n+\t\t\t\t// We have seen this type before, at a higher level.\n+\t\t\t\t// That higher level shadows the lower level we are\n+\t\t\t\t// at now, and either we would have found or not\n+\t\t\t\t// found the field before. Ignore this type now.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tvisited[typ] = true\n+\n+\t\t\t// look for a matching attached method\n+\t\t\tif data := typ.Obj.Data; data != nil {\n+\t\t\t\tif obj := data.(*ast.Scope).Lookup(name); obj != nil {\n+\t\t\t\t\tassert(obj.Type != nil)\n+\t\t\t\t\tif !potentialMatch(value, obj.Type.(Type)) {\n+\t\t\t\t\t\treturn // name collision\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tswitch typ := underlying(typ).(type) {\n+\t\t\tcase *Struct:\n+\t\t\t\t// look for a matching fieldm and collect embedded types\n+\t\t\t\tfor _, f := range typ.Fields {\n+\t\t\t\t\tif f.Name == name {\n+\t\t\t\t\t\tassert(f.Type != nil)\n+\t\t\t\t\t\tif !potentialMatch(variable, f.Type) {\n+\t\t\t\t\t\t\treturn // name collision\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\t// Collect embedded struct fields for searching the next\n+\t\t\t\t\t// lower level, but only if we have not seen a match yet.\n+\t\t\t\t\t// Embedded fields are always of the form T or *T where\n+\t\t\t\t\t// T is a named type.\n+\t\t\t\t\tif f.IsAnonymous && res.mode == invalid {\n+\t\t\t\t\t\tnext = append(next, deref(f.Type).(*NamedType))\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\tcase *Interface:\n+\t\t\t\t// look for a matching method\n+\t\t\t\tfor _, obj := range typ.Methods {\n+\t\t\t\t\tif obj.Name == name {\n+\t\t\t\t\t\tassert(obj.Type != nil)\n+\t\t\t\t\t\tif !potentialMatch(value, obj.Type.(Type)) {\n+\t\t\t\t\t\t\treturn // name collision\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif res.mode != invalid {\n+\t\t\t// we found a match on this level\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// search the next level\n+\t\tlist = append(list[:0], next...) // don't waste underlying arrays\n+\t\tnext = next[:0]\n+\t}\n+\treturn\n+}\n+\n+func lookupField(typ Type, name string) (operandMode, Type) {\n+\ttyp = deref(typ)\n+\n+\tif typ, ok := typ.(*NamedType); ok {\n+\t\tif data := typ.Obj.Data; data != nil {\n+\t\t\tif obj := data.(*ast.Scope).Lookup(name); obj != nil {\n+\t\t\t\tassert(obj.Type != nil)\n+\t\t\t\treturn value, obj.Type.(Type)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tswitch typ := underlying(typ).(type) {\n+\tcase *Struct:\n+\t\tvar list []*NamedType\n+\t\tfor _, f := range typ.Fields {\n+\t\t\tif f.Name == name {\n+\t\t\t\treturn variable, f.Type\n+\t\t\t}\n+\t\t\tif f.IsAnonymous {\n+\t\t\t\tlist = append(list, deref(f.Type).(*NamedType))\n+\t\t\t}\n+\t\t}\n+\t\tif len(list) > 0 {\n+\t\t\tres := lookupFieldRecursive(list, name)\n+\t\t\treturn res.mode, res.typ\n+\t\t}\n+\n+\tcase *Interface:\n+\t\tfor _, obj := range typ.Methods {\n+\t\t\tif obj.Name == name {\n+\t\t\t\treturn value, obj.Type.(Type)\n+\t\t\t}\n \t\t}\n \t}\n-\treturn nil\n+\n+\t// not found\n+\treturn invalid, nil\n }", "previous_filename": "libgo/go/exp/types/staging/operand.go"}, {"sha": "503027e2d9877e808db00a78ad387a2c10b0a37c", "filename": "libgo/go/exp/types/predicates.go", "status": "renamed", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -59,11 +59,16 @@ func isOrdered(typ Type) bool {\n \treturn ok && t.Info&IsOrdered != 0\n }\n \n+func isConstType(typ Type) bool {\n+\tt, ok := underlying(typ).(*Basic)\n+\treturn ok && t.Info&IsConstType != 0\n+}\n+\n func isComparable(typ Type) bool {\n \tswitch t := underlying(typ).(type) {\n \tcase *Basic:\n-\t\treturn t.Kind != Invalid\n-\tcase *Pointer, *Chan, *Interface:\n+\t\treturn t.Kind != Invalid && t.Kind != UntypedNil\n+\tcase *Pointer, *Interface, *Chan:\n \t\t// assumes types are equal for pointers and channels\n \t\treturn true\n \tcase *Struct:\n@@ -79,6 +84,14 @@ func isComparable(typ Type) bool {\n \treturn false\n }\n \n+func hasNil(typ Type) bool {\n+\tswitch underlying(typ).(type) {\n+\tcase *Slice, *Pointer, *Signature, *Interface, *Map, *Chan:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // identical returns true if x and y are identical.\n func isIdentical(x, y Type) bool {\n \tif x == y {", "previous_filename": "libgo/go/exp/types/staging/predicates.go"}, {"sha": "1fc41342d9bd956a08d76a4bc36f5ab15c158be5", "filename": "libgo/go/exp/types/staging/check.go", "status": "removed", "additions": 0, "deletions": 352, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,352 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements the Check function, which typechecks a package.\n-\n-package types\n-\n-import (\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"sort\"\n-)\n-\n-type checker struct {\n-\tfset *token.FileSet\n-\tpkg  *ast.Package\n-\terrh func(token.Pos, string)\n-\tmapf func(ast.Expr, Type)\n-\n-\t// lazily initialized\n-\tfirsterr  error\n-\tfilenames []string                      // sorted list of package file names for reproducible iteration order\n-\tinitexprs map[*ast.ValueSpec][]ast.Expr // \"inherited\" initialization expressions for constant declarations\n-}\n-\n-// declare declares an object of the given kind and name (ident) in scope;\n-// decl is the corresponding declaration in the AST. An error is reported\n-// if the object was declared before.\n-//\n-// TODO(gri) This is very similar to the declare function in go/parser; it\n-// is only used to associate methods with their respective receiver base types.\n-// In a future version, it might be simpler and cleaner do to all the resolution\n-// in the type-checking phase. It would simplify the parser, AST, and also\n-// reduce some amount of code duplication.\n-//\n-func (check *checker) declare(scope *ast.Scope, kind ast.ObjKind, ident *ast.Ident, decl ast.Decl) {\n-\tassert(ident.Obj == nil) // identifier already declared or resolved\n-\tobj := ast.NewObj(kind, ident.Name)\n-\tobj.Decl = decl\n-\tident.Obj = obj\n-\tif ident.Name != \"_\" {\n-\t\tif alt := scope.Insert(obj); alt != nil {\n-\t\t\tprevDecl := \"\"\n-\t\t\tif pos := alt.Pos(); pos.IsValid() {\n-\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", check.fset.Position(pos))\n-\t\t\t}\n-\t\t\tcheck.errorf(ident.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", ident.Name, prevDecl))\n-\t\t}\n-\t}\n-}\n-\n-func (check *checker) valueSpec(pos token.Pos, obj *ast.Object, lhs []*ast.Ident, typ ast.Expr, rhs []ast.Expr, iota int) {\n-\tif len(lhs) == 0 {\n-\t\tcheck.invalidAST(pos, \"missing lhs in declaration\")\n-\t\treturn\n-\t}\n-\n-\tvar t Type\n-\tif typ != nil {\n-\t\tt = check.typ(typ, false)\n-\t}\n-\n-\t// len(lhs) >= 1\n-\tif len(lhs) == len(rhs) {\n-\t\t// check only corresponding lhs and rhs\n-\t\tvar l, r ast.Expr\n-\t\tfor i, ident := range lhs {\n-\t\t\tif ident.Obj == obj {\n-\t\t\t\tl = lhs[i]\n-\t\t\t\tr = rhs[i]\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tassert(l != nil)\n-\t\tobj.Type = t\n-\t\t// check rhs\n-\t\tvar x operand\n-\t\tcheck.expr(&x, r, t, iota)\n-\t\t// assign to lhs\n-\t\tcheck.assignment(l, &x, true)\n-\t\treturn\n-\t}\n-\n-\tif t != nil {\n-\t\tfor _, name := range lhs {\n-\t\t\tname.Obj.Type = t\n-\t\t}\n-\t}\n-\n-\t// check initial values, if any\n-\tif len(rhs) > 0 {\n-\t\t// TODO(gri) should try to avoid this conversion\n-\t\tlhx := make([]ast.Expr, len(lhs))\n-\t\tfor i, e := range lhs {\n-\t\t\tlhx[i] = e\n-\t\t}\n-\t\tcheck.assignNtoM(lhx, rhs, true, iota)\n-\t}\n-}\n-\n-// ident type checks an identifier.\n-func (check *checker) ident(name *ast.Ident, cycleOk bool) {\n-\tobj := name.Obj\n-\tif obj == nil {\n-\t\tcheck.invalidAST(name.Pos(), \"missing object for %s\", name.Name)\n-\t\treturn\n-\t}\n-\n-\tif obj.Type != nil {\n-\t\t// object has already been type checked\n-\t\treturn\n-\t}\n-\n-\tswitch obj.Kind {\n-\tcase ast.Bad, ast.Pkg:\n-\t\t// nothing to do\n-\n-\tcase ast.Con, ast.Var:\n-\t\t// The obj.Data field for constants and variables is initialized\n-\t\t// to the respective (hypothetical, for variables) iota value by\n-\t\t// the parser. The object's fields can be in one of the following\n-\t\t// states:\n-\t\t// Type != nil  =>  the constant value is Data\n-\t\t// Type == nil  =>  the object is not typechecked yet, and Data can be:\n-\t\t// Data is int  =>  Data is the value of iota for this declaration\n-\t\t// Data == nil  =>  the object's expression is being evaluated\n-\t\tif obj.Data == nil {\n-\t\t\tcheck.errorf(obj.Pos(), \"illegal cycle in initialization of %s\", obj.Name)\n-\t\t\treturn\n-\t\t}\n-\t\tspec := obj.Decl.(*ast.ValueSpec)\n-\t\tiota := obj.Data.(int)\n-\t\tobj.Data = nil\n-\t\t// determine initialization expressions\n-\t\tvalues := spec.Values\n-\t\tif len(values) == 0 && obj.Kind == ast.Con {\n-\t\t\tvalues = check.initexprs[spec]\n-\t\t}\n-\t\tcheck.valueSpec(spec.Pos(), obj, spec.Names, spec.Type, values, iota)\n-\n-\tcase ast.Typ:\n-\t\ttyp := &NamedType{Obj: obj}\n-\t\tobj.Type = typ // \"mark\" object so recursion terminates\n-\t\ttyp.Underlying = underlying(check.typ(obj.Decl.(*ast.TypeSpec).Type, cycleOk))\n-\t\t// collect associated methods, if any\n-\t\tif obj.Data != nil {\n-\t\t\tscope := obj.Data.(*ast.Scope)\n-\t\t\t// struct fields must not conflict with methods\n-\t\t\tif t, ok := typ.Underlying.(*Struct); ok {\n-\t\t\t\tfor _, f := range t.Fields {\n-\t\t\t\t\tif m := scope.Lookup(f.Name); m != nil {\n-\t\t\t\t\t\tcheck.errorf(m.Pos(), \"type %s has both field and method named %s\", obj.Name, f.Name)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// collect methods\n-\t\t\tmethods := make(ObjList, len(scope.Objects))\n-\t\t\ti := 0\n-\t\t\tfor _, m := range scope.Objects {\n-\t\t\t\tmethods[i] = m\n-\t\t\t\ti++\n-\t\t\t}\n-\t\t\tmethods.Sort()\n-\t\t\ttyp.Methods = methods\n-\t\t\t// methods cannot be associated with an interface type\n-\t\t\t// (do this check after sorting for reproducible error positions - needed for testing)\n-\t\t\tif _, ok := typ.Underlying.(*Interface); ok {\n-\t\t\t\tfor _, m := range methods {\n-\t\t\t\t\trecv := m.Decl.(*ast.FuncDecl).Recv.List[0].Type\n-\t\t\t\t\tcheck.errorf(recv.Pos(), \"invalid receiver type %s (%s is an interface type)\", obj.Name, obj.Name)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\tcase ast.Fun:\n-\t\tfdecl := obj.Decl.(*ast.FuncDecl)\n-\t\tftyp := check.typ(fdecl.Type, cycleOk).(*Signature)\n-\t\tobj.Type = ftyp\n-\t\tif fdecl.Recv != nil {\n-\t\t\t// TODO(gri) handle method receiver\n-\t\t}\n-\t\tcheck.stmt(fdecl.Body)\n-\n-\tdefault:\n-\t\tpanic(\"unreachable\")\n-\t}\n-}\n-\n-// assocInitvals associates \"inherited\" initialization expressions\n-// with the corresponding *ast.ValueSpec in the check.initexprs map\n-// for constant declarations without explicit initialization expressions.\n-//\n-func (check *checker) assocInitvals(decl *ast.GenDecl) {\n-\tvar values []ast.Expr\n-\tfor _, s := range decl.Specs {\n-\t\tif s, ok := s.(*ast.ValueSpec); ok {\n-\t\t\tif len(s.Values) > 0 {\n-\t\t\t\tvalues = s.Values\n-\t\t\t} else {\n-\t\t\t\tcheck.initexprs[s] = values\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif len(values) == 0 {\n-\t\tcheck.invalidAST(decl.Pos(), \"no initialization values provided\")\n-\t}\n-}\n-\n-// assocMethod associates a method declaration with the respective\n-// receiver base type. meth.Recv must exist.\n-//\n-func (check *checker) assocMethod(meth *ast.FuncDecl) {\n-\t// The receiver type is one of the following (enforced by parser):\n-\t// - *ast.Ident\n-\t// - *ast.StarExpr{*ast.Ident}\n-\t// - *ast.BadExpr (parser error)\n-\ttyp := meth.Recv.List[0].Type\n-\tif ptr, ok := typ.(*ast.StarExpr); ok {\n-\t\ttyp = ptr.X\n-\t}\n-\t// determine receiver base type object (or nil if error)\n-\tvar obj *ast.Object\n-\tif ident, ok := typ.(*ast.Ident); ok && ident.Obj != nil {\n-\t\tobj = ident.Obj\n-\t\tif obj.Kind != ast.Typ {\n-\t\t\tcheck.errorf(ident.Pos(), \"%s is not a type\", ident.Name)\n-\t\t\tobj = nil\n-\t\t}\n-\t\t// TODO(gri) determine if obj was defined in this package\n-\t\t/*\n-\t\t\tif check.notLocal(obj) {\n-\t\t\t\tcheck.errorf(ident.Pos(), \"cannot define methods on non-local type %s\", ident.Name)\n-\t\t\t\tobj = nil\n-\t\t\t}\n-\t\t*/\n-\t} else {\n-\t\t// If it's not an identifier or the identifier wasn't declared/resolved,\n-\t\t// the parser/resolver already reported an error. Nothing to do here.\n-\t}\n-\t// determine base type scope (or nil if error)\n-\tvar scope *ast.Scope\n-\tif obj != nil {\n-\t\tif obj.Data != nil {\n-\t\t\tscope = obj.Data.(*ast.Scope)\n-\t\t} else {\n-\t\t\tscope = ast.NewScope(nil)\n-\t\t\tobj.Data = scope\n-\t\t}\n-\t} else {\n-\t\t// use a dummy scope so that meth can be declared in\n-\t\t// presence of an error and get an associated object\n-\t\t// (always use a new scope so that we don't get double\n-\t\t// declaration errors)\n-\t\tscope = ast.NewScope(nil)\n-\t}\n-\tcheck.declare(scope, ast.Fun, meth.Name, meth)\n-}\n-\n-func (check *checker) assocInitvalsOrMethod(decl ast.Decl) {\n-\tswitch d := decl.(type) {\n-\tcase *ast.GenDecl:\n-\t\tif d.Tok == token.CONST {\n-\t\t\tcheck.assocInitvals(d)\n-\t\t}\n-\tcase *ast.FuncDecl:\n-\t\tif d.Recv != nil {\n-\t\t\tcheck.assocMethod(d)\n-\t\t}\n-\t}\n-}\n-\n-func (check *checker) decl(decl ast.Decl) {\n-\tswitch d := decl.(type) {\n-\tcase *ast.BadDecl:\n-\t\t// ignore\n-\tcase *ast.GenDecl:\n-\t\tfor _, spec := range d.Specs {\n-\t\t\tswitch s := spec.(type) {\n-\t\t\tcase *ast.ImportSpec:\n-\t\t\t\t// nothing to do (handled by ast.NewPackage)\n-\t\t\tcase *ast.ValueSpec:\n-\t\t\t\tfor _, name := range s.Names {\n-\t\t\t\t\tif name.Name == \"_\" {\n-\t\t\t\t\t\t// TODO(gri) why is _ special here?\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tcheck.ident(name, false)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\tcase *ast.TypeSpec:\n-\t\t\t\tcheck.ident(s.Name, false)\n-\t\t\tdefault:\n-\t\t\t\tcheck.invalidAST(s.Pos(), \"unknown ast.Spec node %T\", s)\n-\t\t\t}\n-\t\t}\n-\tcase *ast.FuncDecl:\n-\t\tcheck.ident(d.Name, false)\n-\tdefault:\n-\t\tcheck.invalidAST(d.Pos(), \"unknown ast.Decl node %T\", d)\n-\t}\n-}\n-\n-// iterate calls f for each package-level declaration.\n-func (check *checker) iterate(f func(*checker, ast.Decl)) {\n-\tlist := check.filenames\n-\n-\tif list == nil {\n-\t\t// initialize lazily\n-\t\tfor filename := range check.pkg.Files {\n-\t\t\tlist = append(list, filename)\n-\t\t}\n-\t\tsort.Strings(list)\n-\t\tcheck.filenames = list\n-\t}\n-\n-\tfor _, filename := range list {\n-\t\tfor _, decl := range check.pkg.Files[filename].Decls {\n-\t\t\tf(check, decl)\n-\t\t}\n-\t}\n-}\n-\n-// A bailout panic is raised to indicate early termination.\n-type bailout struct{}\n-\n-func check(fset *token.FileSet, pkg *ast.Package, errh func(token.Pos, string), f func(ast.Expr, Type)) (err error) {\n-\t// initialize checker\n-\tvar check checker\n-\tcheck.fset = fset\n-\tcheck.pkg = pkg\n-\tcheck.errh = errh\n-\tcheck.mapf = f\n-\tcheck.initexprs = make(map[*ast.ValueSpec][]ast.Expr)\n-\n-\t// handle bailouts\n-\tdefer func() {\n-\t\tif p := recover(); p != nil {\n-\t\t\t_ = p.(bailout) // re-panic if not a bailout\n-\t\t}\n-\t\terr = check.firsterr\n-\t}()\n-\n-\t// determine missing constant initialization expressions\n-\t// and associate methods with types\n-\tcheck.iterate((*checker).assocInitvalsOrMethod)\n-\n-\t// typecheck all declarations\n-\tcheck.iterate((*checker).decl)\n-\n-\treturn\n-}"}, {"sha": "abcfcfb2cd3ab294cb5bfed309a232c5d5cd34d6", "filename": "libgo/go/exp/types/staging/check_test.go", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fcheck_test.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,257 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements a typechecker test harness. The packages specified\n-// in tests are typechecked. Error messages reported by the typechecker are\n-// compared against the error messages expected in the test files.\n-//\n-// Expected errors are indicated in the test files by putting a comment\n-// of the form /* ERROR \"rx\" */ immediately following an offending token.\n-// The harness will verify that an error matching the regular expression\n-// rx is reported at that source position. Consecutive comments may be\n-// used to indicate multiple errors for the same token position.\n-//\n-// For instance, the following test file indicates that a \"not declared\"\n-// error should be reported for the undeclared variable x:\n-//\n-//\tpackage p\n-//\tfunc f() {\n-//\t\t_ = x /* ERROR \"not declared\" */ + 1\n-//\t}\n-\n-package types\n-\n-import (\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/parser\"\n-\t\"go/scanner\"\n-\t\"go/token\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"regexp\"\n-\t\"testing\"\n-)\n-\n-var listErrors = flag.Bool(\"list\", false, \"list errors\")\n-\n-func init() {\n-\t// declare builtins for testing\n-\tdef(ast.Fun, \"assert\").Type = &builtin{aType, _Assert, \"assert\", 1, false, true}\n-\tdef(ast.Fun, \"trace\").Type = &builtin{aType, _Trace, \"trace\", 0, true, true}\n-}\n-\n-// The test filenames do not end in .go so that they are invisible\n-// to gofmt since they contain comments that must not change their\n-// positions relative to surrounding tokens.\n-\n-var tests = []struct {\n-\tname  string\n-\tfiles []string\n-}{\n-\t{\"decls0\", []string{\"testdata/decls0.src\"}},\n-\t{\"decls1\", []string{\"testdata/decls1.src\"}},\n-\t{\"decls2\", []string{\"testdata/decls2a.src\", \"testdata/decls2b.src\"}},\n-\t{\"const0\", []string{\"testdata/const0.src\"}},\n-\t{\"expr0\", []string{\"testdata/expr0.src\"}},\n-\t{\"expr1\", []string{\"testdata/expr1.src\"}},\n-\t{\"expr2\", []string{\"testdata/expr2.src\"}},\n-\t{\"expr3\", []string{\"testdata/expr3.src\"}},\n-\t{\"builtins\", []string{\"testdata/builtins.src\"}},\n-\t{\"conversions\", []string{\"testdata/conversions.src\"}},\n-\t{\"stmt0\", []string{\"testdata/stmt0.src\"}},\n-}\n-\n-var fset = token.NewFileSet()\n-\n-func getFile(filename string) (file *token.File) {\n-\tfset.Iterate(func(f *token.File) bool {\n-\t\tif f.Name() == filename {\n-\t\t\tfile = f\n-\t\t\treturn false // end iteration\n-\t\t}\n-\t\treturn true\n-\t})\n-\treturn file\n-}\n-\n-func getPos(filename string, offset int) token.Pos {\n-\tif f := getFile(filename); f != nil {\n-\t\treturn f.Pos(offset)\n-\t}\n-\treturn token.NoPos\n-}\n-\n-func parseFiles(t *testing.T, testname string, filenames []string) (map[string]*ast.File, error) {\n-\tfiles := make(map[string]*ast.File)\n-\tvar errors scanner.ErrorList\n-\tfor _, filename := range filenames {\n-\t\tif _, exists := files[filename]; exists {\n-\t\t\tt.Fatalf(\"%s: duplicate file %s\", testname, filename)\n-\t\t}\n-\t\tfile, err := parser.ParseFile(fset, filename, nil, parser.DeclarationErrors)\n-\t\tif file == nil {\n-\t\t\tt.Fatalf(\"%s: could not parse file %s\", testname, filename)\n-\t\t}\n-\t\tfiles[filename] = file\n-\t\tif err != nil {\n-\t\t\t// if the parser returns a non-scanner.ErrorList error\n-\t\t\t// the file couldn't be read in the first place and\n-\t\t\t// file == nil; in that case we shouldn't reach here\n-\t\t\terrors = append(errors, err.(scanner.ErrorList)...)\n-\t\t}\n-\n-\t}\n-\treturn files, errors\n-}\n-\n-// ERROR comments must be of the form /* ERROR \"rx\" */ and rx is\n-// a regular expression that matches the expected error message.\n-//\n-var errRx = regexp.MustCompile(`^/\\* *ERROR *\"([^\"]*)\" *\\*/$`)\n-\n-// expectedErrors collects the regular expressions of ERROR comments found\n-// in files and returns them as a map of error positions to error messages.\n-//\n-func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) map[token.Pos][]string {\n-\terrors := make(map[token.Pos][]string)\n-\n-\tfor filename := range files {\n-\t\tsrc, err := ioutil.ReadFile(filename)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"%s: could not read %s\", testname, filename)\n-\t\t}\n-\n-\t\tvar s scanner.Scanner\n-\t\t// file was parsed already - do not add it again to the file\n-\t\t// set otherwise the position information returned here will\n-\t\t// not match the position information collected by the parser\n-\t\ts.Init(getFile(filename), src, nil, scanner.ScanComments)\n-\t\tvar prev token.Pos // position of last non-comment, non-semicolon token\n-\n-\tscanFile:\n-\t\tfor {\n-\t\t\tpos, tok, lit := s.Scan()\n-\t\t\tswitch tok {\n-\t\t\tcase token.EOF:\n-\t\t\t\tbreak scanFile\n-\t\t\tcase token.COMMENT:\n-\t\t\t\ts := errRx.FindStringSubmatch(lit)\n-\t\t\t\tif len(s) == 2 {\n-\t\t\t\t\tlist := errors[prev]\n-\t\t\t\t\terrors[prev] = append(list, string(s[1]))\n-\t\t\t\t}\n-\t\t\tcase token.SEMICOLON:\n-\t\t\t\t// ignore automatically inserted semicolon\n-\t\t\t\tif lit == \"\\n\" {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tfallthrough\n-\t\t\tdefault:\n-\t\t\t\tprev = pos\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn errors\n-}\n-\n-func eliminate(t *testing.T, expected map[token.Pos][]string, errors error) {\n-\tif *listErrors || errors == nil {\n-\t\treturn\n-\t}\n-\tfor _, error := range errors.(scanner.ErrorList) {\n-\t\t// error.Pos is a token.Position, but we want\n-\t\t// a token.Pos so we can do a map lookup\n-\t\tpos := getPos(error.Pos.Filename, error.Pos.Offset)\n-\t\tlist := expected[pos]\n-\t\tindex := -1 // list index of matching message, if any\n-\t\t// we expect one of the messages in list to match the error at pos\n-\t\tfor i, msg := range list {\n-\t\t\trx, err := regexp.Compile(msg)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"%s: %v\", error.Pos, err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif match := rx.MatchString(error.Msg); match {\n-\t\t\t\tindex = i\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif index >= 0 {\n-\t\t\t// eliminate from list\n-\t\t\tn := len(list) - 1\n-\t\t\tif n > 0 {\n-\t\t\t\t// not the last entry - swap in last element and shorten list by 1\n-\t\t\t\tlist[index] = list[n]\n-\t\t\t\texpected[pos] = list[:n]\n-\t\t\t} else {\n-\t\t\t\t// last entry - remove list from map\n-\t\t\t\tdelete(expected, pos)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tt.Errorf(\"%s: no error expected: %q\", error.Pos, error.Msg)\n-\t\t\tcontinue\n-\t\t}\n-\t}\n-}\n-\n-func checkFiles(t *testing.T, testname string, testfiles []string) {\n-\t// TODO(gri) Eventually all these different phases should be\n-\t//           subsumed into a single function call that takes\n-\t//           a set of files and creates a fully resolved and\n-\t//           type-checked AST.\n-\n-\tfiles, err := parseFiles(t, testname, testfiles)\n-\n-\t// we are expecting the following errors\n-\t// (collect these after parsing the files so that\n-\t// they are found in the file set)\n-\terrors := expectedErrors(t, testname, files)\n-\n-\t// verify errors returned by the parser\n-\teliminate(t, errors, err)\n-\n-\t// verify errors returned after resolving identifiers\n-\tpkg, err := ast.NewPackage(fset, files, GcImport, Universe)\n-\teliminate(t, errors, err)\n-\n-\t// verify errors returned by the typechecker\n-\tvar list scanner.ErrorList\n-\terrh := func(pos token.Pos, msg string) {\n-\t\tlist.Add(fset.Position(pos), msg)\n-\t}\n-\terr = Check(fset, pkg, errh, nil)\n-\teliminate(t, errors, list)\n-\n-\tif *listErrors {\n-\t\tscanner.PrintError(os.Stdout, err)\n-\t\treturn\n-\t}\n-\n-\t// there should be no expected errors left\n-\tif len(errors) > 0 {\n-\t\tt.Errorf(\"%s: %d errors not reported:\", testname, len(errors))\n-\t\tfor pos, msg := range errors {\n-\t\t\tt.Errorf(\"%s: %s\\n\", fset.Position(pos), msg)\n-\t\t}\n-\t}\n-}\n-\n-func TestCheck(t *testing.T) {\n-\t// For easy debugging w/o changing the testing code,\n-\t// if there is a local test file, only test that file.\n-\tconst testfile = \"testdata/test.go\"\n-\tif fi, err := os.Stat(testfile); err == nil && !fi.IsDir() {\n-\t\tfmt.Printf(\"WARNING: Testing only %s (remove it to run all tests)\\n\", testfile)\n-\t\tcheckFiles(t, testfile, []string{testfile})\n-\t\treturn\n-\t}\n-\n-\t// Otherwise, run all the tests.\n-\tfor _, test := range tests {\n-\t\tcheckFiles(t, test.name, test.files)\n-\t}\n-}"}, {"sha": "e817f1fd85860733c383e0c55208e29f72df3fc2", "filename": "libgo/go/exp/types/staging/const.go", "status": "removed", "additions": 0, "deletions": 662, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fconst.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,662 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements operations on constant values.\n-\n-package types\n-\n-import (\n-\t\"fmt\"\n-\t\"go/token\"\n-\t\"math/big\"\n-\t\"strconv\"\n-)\n-\n-// TODO(gri) At the moment, constants are different types\n-// passed around as interface{} values. Consider introducing\n-// a Const type and use methods instead of xConst functions.\n-\n-// Representation of constant values.\n-//\n-// bool     ->  bool (true, false)\n-// numeric  ->  int64, *big.Int, *big.Rat, complex (ordered by increasing data structure \"size\")\n-// string   ->  string\n-// nil      ->  nilType (nilConst)\n-//\n-// Numeric constants are normalized after each operation such\n-// that they are represented by the \"smallest\" data structure\n-// required to represent the constant, independent of actual\n-// type. Non-numeric constants are always normalized.\n-\n-// Representation of complex numbers. \n-type complex struct {\n-\tre, im *big.Rat\n-}\n-\n-func (c complex) String() string {\n-\tif c.re.Sign() == 0 {\n-\t\treturn fmt.Sprintf(\"%si\", c.im)\n-\t}\n-\t// normalized complex values always have an imaginary part\n-\treturn fmt.Sprintf(\"(%s + %si)\", c.re, c.im)\n-}\n-\n-// Representation of nil.\n-type nilType struct{}\n-\n-func (nilType) String() string {\n-\treturn \"nil\"\n-}\n-\n-// Frequently used constants.\n-var (\n-\tzeroConst     = int64(0)\n-\toneConst      = int64(1)\n-\tminusOneConst = int64(-1)\n-\tnilConst      = new(nilType)\n-)\n-\n-// int64 bounds\n-var (\n-\tminInt64 = big.NewInt(-1 << 63)\n-\tmaxInt64 = big.NewInt(1<<63 - 1)\n-)\n-\n-// normalizeIntConst returns the smallest constant representation\n-// for the specific value of x; either an int64 or a *big.Int value.\n-//\n-func normalizeIntConst(x *big.Int) interface{} {\n-\tif minInt64.Cmp(x) <= 0 && x.Cmp(maxInt64) <= 0 {\n-\t\treturn x.Int64()\n-\t}\n-\treturn x\n-}\n-\n-// normalizeRatConst returns the smallest constant representation\n-// for the specific value of x; either an int64, *big.Int value,\n-// or *big.Rat value.\n-//\n-func normalizeRatConst(x *big.Rat) interface{} {\n-\tif x.IsInt() {\n-\t\treturn normalizeIntConst(x.Num())\n-\t}\n-\treturn x\n-}\n-\n-// normalizeComplexConst returns the smallest constant representation\n-// for the specific value of x; either an int64, *big.Int value, *big.Rat,\n-// or complex value.\n-//\n-func normalizeComplexConst(x complex) interface{} {\n-\tif x.im.Sign() == 0 {\n-\t\treturn normalizeRatConst(x.re)\n-\t}\n-\treturn x\n-}\n-\n-// makeRuneConst returns the int64 code point for the rune literal\n-// lit. The result is nil if lit is not a correct rune literal.\n-//\n-func makeRuneConst(lit string) interface{} {\n-\tif n := len(lit); n >= 2 {\n-\t\tif code, _, _, err := strconv.UnquoteChar(lit[1:n-1], '\\''); err == nil {\n-\t\t\treturn int64(code)\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// makeRuneConst returns the smallest integer constant representation\n-// (int64, *big.Int) for the integer literal lit. The result is nil if\n-// lit is not a correct integer literal.\n-//\n-func makeIntConst(lit string) interface{} {\n-\tif x, err := strconv.ParseInt(lit, 0, 64); err == nil {\n-\t\treturn x\n-\t}\n-\tif x, ok := new(big.Int).SetString(lit, 0); ok {\n-\t\treturn x\n-\t}\n-\treturn nil\n-}\n-\n-// makeFloatConst returns the smallest floating-point constant representation\n-// (int64, *big.Int, *big.Rat) for the floating-point literal lit. The result\n-// is nil if lit is not a correct floating-point literal.\n-//\n-func makeFloatConst(lit string) interface{} {\n-\tif x, ok := new(big.Rat).SetString(lit); ok {\n-\t\treturn normalizeRatConst(x)\n-\t}\n-\treturn nil\n-}\n-\n-// makeComplexConst returns the complex constant representation (complex) for\n-// the imaginary literal lit. The result is nil if lit is not a correct imaginary\n-// literal.\n-//\n-func makeComplexConst(lit string) interface{} {\n-\tn := len(lit)\n-\tif n > 0 && lit[n-1] == 'i' {\n-\t\tif im, ok := new(big.Rat).SetString(lit[0 : n-1]); ok {\n-\t\t\treturn normalizeComplexConst(complex{big.NewRat(0, 1), im})\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// makeStringConst returns the string constant representation (string) for\n-// the string literal lit. The result is nil if lit is not a correct string\n-// literal.\n-//\n-func makeStringConst(lit string) interface{} {\n-\tif s, err := strconv.Unquote(lit); err == nil {\n-\t\treturn s\n-\t}\n-\treturn nil\n-}\n-\n-// isZeroConst reports whether the value of constant x is 0.\n-// x must be normalized.\n-//\n-func isZeroConst(x interface{}) bool {\n-\ti, ok := x.(int64) // good enough since constants are normalized\n-\treturn ok && i == 0\n-}\n-\n-// isNegConst reports whether the value of constant x is < 0.\n-// x must be a non-complex numeric value.\n-//\n-func isNegConst(x interface{}) bool {\n-\tswitch x := x.(type) {\n-\tcase int64:\n-\t\treturn x < 0\n-\tcase *big.Int:\n-\t\treturn x.Sign() < 0\n-\tcase *big.Rat:\n-\t\treturn x.Sign() < 0\n-\t}\n-\tunreachable()\n-\treturn false\n-}\n-\n-// isRepresentableConst reports whether the value of constant x can\n-// be represented as a value of the basic type Typ[as] without loss\n-// of precision.\n-//\n-func isRepresentableConst(x interface{}, as BasicKind) bool {\n-\tconst intBits = 32 // TODO(gri) implementation-specific constant\n-\tconst ptrBits = 64 // TODO(gri) implementation-specific constant\n-\n-\tswitch x := x.(type) {\n-\tcase bool:\n-\t\treturn as == Bool || as == UntypedBool\n-\n-\tcase int64:\n-\t\tswitch as {\n-\t\tcase Int:\n-\t\t\treturn -1<<(intBits-1) <= x && x <= 1<<(intBits-1)-1\n-\t\tcase Int8:\n-\t\t\treturn -1<<(8-1) <= x && x <= 1<<(8-1)-1\n-\t\tcase Int16:\n-\t\t\treturn -1<<(16-1) <= x && x <= 1<<(16-1)-1\n-\t\tcase Int32, UntypedRune:\n-\t\t\treturn -1<<(32-1) <= x && x <= 1<<(32-1)-1\n-\t\tcase Int64:\n-\t\t\treturn true\n-\t\tcase Uint:\n-\t\t\treturn 0 <= x && x <= 1<<intBits-1\n-\t\tcase Uint8:\n-\t\t\treturn 0 <= x && x <= 1<<8-1\n-\t\tcase Uint16:\n-\t\t\treturn 0 <= x && x <= 1<<16-1\n-\t\tcase Uint32:\n-\t\t\treturn 0 <= x && x <= 1<<32-1\n-\t\tcase Uint64:\n-\t\t\treturn 0 <= x\n-\t\tcase Uintptr:\n-\t\t\tassert(ptrBits == 64)\n-\t\t\treturn 0 <= x\n-\t\tcase Float32:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Float64:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Complex64:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Complex128:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase UntypedInt, UntypedFloat, UntypedComplex:\n-\t\t\treturn true\n-\t\t}\n-\n-\tcase *big.Int:\n-\t\tswitch as {\n-\t\tcase Uint:\n-\t\t\treturn x.Sign() >= 0 && x.BitLen() <= intBits\n-\t\tcase Uint64:\n-\t\t\treturn x.Sign() >= 0 && x.BitLen() <= 64\n-\t\tcase Uintptr:\n-\t\t\treturn x.Sign() >= 0 && x.BitLen() <= ptrBits\n-\t\tcase Float32:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Float64:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Complex64:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Complex128:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase UntypedInt, UntypedFloat, UntypedComplex:\n-\t\t\treturn true\n-\t\t}\n-\n-\tcase *big.Rat:\n-\t\tswitch as {\n-\t\tcase Float32:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Float64:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Complex64:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Complex128:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase UntypedFloat, UntypedComplex:\n-\t\t\treturn true\n-\t\t}\n-\n-\tcase complex:\n-\t\tswitch as {\n-\t\tcase Complex64:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase Complex128:\n-\t\t\treturn true // TODO(gri) fix this\n-\t\tcase UntypedComplex:\n-\t\t\treturn true\n-\t\t}\n-\n-\tcase string:\n-\t\treturn as == String || as == UntypedString\n-\n-\tcase nilType:\n-\t\treturn as == UntypedNil\n-\n-\tdefault:\n-\t\tunreachable()\n-\t}\n-\n-\treturn false\n-}\n-\n-var (\n-\tint1 = big.NewInt(1)\n-\trat0 = big.NewRat(0, 1)\n-)\n-\n-// complexity returns a measure of representation complexity for constant x.\n-func complexity(x interface{}) int {\n-\tswitch x.(type) {\n-\tcase bool, string, nilType:\n-\t\treturn 1\n-\tcase int64:\n-\t\treturn 2\n-\tcase *big.Int:\n-\t\treturn 3\n-\tcase *big.Rat:\n-\t\treturn 4\n-\tcase complex:\n-\t\treturn 5\n-\t}\n-\tunreachable()\n-\treturn 0\n-}\n-\n-// matchConst returns the matching representation (same type) with the\n-// smallest complexity for two constant values x and y. They must be\n-// of the same \"kind\" (boolean, numeric, string, or nilType).\n-// \n-func matchConst(x, y interface{}) (_, _ interface{}) {\n-\tif complexity(x) > complexity(y) {\n-\t\ty, x = matchConst(y, x)\n-\t\treturn x, y\n-\t}\n-\t// complexity(x) <= complexity(y)\n-\n-\tswitch x := x.(type) {\n-\tcase bool, complex, string, nilType:\n-\t\treturn x, y\n-\n-\tcase int64:\n-\t\tswitch y := y.(type) {\n-\t\tcase int64:\n-\t\t\treturn x, y\n-\t\tcase *big.Int:\n-\t\t\treturn big.NewInt(x), y\n-\t\tcase *big.Rat:\n-\t\t\treturn big.NewRat(x, 1), y\n-\t\tcase complex:\n-\t\t\treturn complex{big.NewRat(x, 1), rat0}, y\n-\t\t}\n-\n-\tcase *big.Int:\n-\t\tswitch y := y.(type) {\n-\t\tcase *big.Int:\n-\t\t\treturn x, y\n-\t\tcase *big.Rat:\n-\t\t\treturn new(big.Rat).SetFrac(x, int1), y\n-\t\tcase complex:\n-\t\t\treturn complex{new(big.Rat).SetFrac(x, int1), rat0}, y\n-\t\t}\n-\n-\tcase *big.Rat:\n-\t\tswitch y := y.(type) {\n-\t\tcase *big.Rat:\n-\t\t\treturn x, y\n-\t\tcase complex:\n-\t\t\treturn complex{x, rat0}, y\n-\t\t}\n-\t}\n-\n-\tunreachable()\n-\treturn nil, nil\n-}\n-\n-// is32bit reports whether x can be represented using 32 bits.\n-func is32bit(x int64) bool {\n-\treturn -1<<31 <= x && x <= 1<<31-1\n-}\n-\n-// is63bit reports whether x can be represented using 63 bits.\n-func is63bit(x int64) bool {\n-\treturn -1<<62 <= x && x <= 1<<62-1\n-}\n-\n-// binaryOpConst returns the result of the constant evaluation x op y;\n-// both operands must be of the same \"kind\" (boolean, numeric, or string).\n-// If intDiv is true, division (op == token.QUO) is using integer division\n-// (and the result is guaranteed to be integer) rather than floating-point\n-// division. Division by zero leads to a run-time panic.\n-//\n-func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n-\tx, y = matchConst(x, y)\n-\n-\tswitch x := x.(type) {\n-\tcase bool:\n-\t\ty := y.(bool)\n-\t\tswitch op {\n-\t\tcase token.LAND:\n-\t\t\treturn x && y\n-\t\tcase token.LOR:\n-\t\t\treturn x || y\n-\t\tdefault:\n-\t\t\tunreachable()\n-\t\t}\n-\n-\tcase int64:\n-\t\ty := y.(int64)\n-\t\tswitch op {\n-\t\tcase token.ADD:\n-\t\t\t// TODO(gri) can do better than this\n-\t\t\tif is63bit(x) && is63bit(y) {\n-\t\t\t\treturn x + y\n-\t\t\t}\n-\t\t\treturn normalizeIntConst(new(big.Int).Add(big.NewInt(x), big.NewInt(y)))\n-\t\tcase token.SUB:\n-\t\t\t// TODO(gri) can do better than this\n-\t\t\tif is63bit(x) && is63bit(y) {\n-\t\t\t\treturn x - y\n-\t\t\t}\n-\t\t\treturn normalizeIntConst(new(big.Int).Sub(big.NewInt(x), big.NewInt(y)))\n-\t\tcase token.MUL:\n-\t\t\t// TODO(gri) can do better than this\n-\t\t\tif is32bit(x) && is32bit(y) {\n-\t\t\t\treturn x * y\n-\t\t\t}\n-\t\t\treturn normalizeIntConst(new(big.Int).Mul(big.NewInt(x), big.NewInt(y)))\n-\t\tcase token.REM:\n-\t\t\treturn x % y\n-\t\tcase token.QUO:\n-\t\t\tif intDiv {\n-\t\t\t\treturn x / y\n-\t\t\t}\n-\t\t\treturn normalizeRatConst(new(big.Rat).SetFrac(big.NewInt(x), big.NewInt(y)))\n-\t\tcase token.AND:\n-\t\t\treturn x & y\n-\t\tcase token.OR:\n-\t\t\treturn x | y\n-\t\tcase token.XOR:\n-\t\t\treturn x ^ y\n-\t\tcase token.AND_NOT:\n-\t\t\treturn x &^ y\n-\t\tdefault:\n-\t\t\tunreachable()\n-\t\t}\n-\n-\tcase *big.Int:\n-\t\ty := y.(*big.Int)\n-\t\tvar z big.Int\n-\t\tswitch op {\n-\t\tcase token.ADD:\n-\t\t\tz.Add(x, y)\n-\t\tcase token.SUB:\n-\t\t\tz.Sub(x, y)\n-\t\tcase token.MUL:\n-\t\t\tz.Mul(x, y)\n-\t\tcase token.REM:\n-\t\t\tz.Rem(x, y)\n-\t\tcase token.QUO:\n-\t\t\tif intDiv {\n-\t\t\t\tz.Quo(x, y)\n-\t\t\t} else {\n-\t\t\t\treturn normalizeRatConst(new(big.Rat).SetFrac(x, y))\n-\t\t\t}\n-\t\tcase token.AND:\n-\t\t\tz.And(x, y)\n-\t\tcase token.OR:\n-\t\t\tz.Or(x, y)\n-\t\tcase token.XOR:\n-\t\t\tz.Xor(x, y)\n-\t\tcase token.AND_NOT:\n-\t\t\tz.AndNot(x, y)\n-\t\tdefault:\n-\t\t\tunreachable()\n-\t\t}\n-\t\treturn normalizeIntConst(&z)\n-\n-\tcase *big.Rat:\n-\t\ty := y.(*big.Rat)\n-\t\tvar z big.Rat\n-\t\tswitch op {\n-\t\tcase token.ADD:\n-\t\t\tz.Add(x, y)\n-\t\tcase token.SUB:\n-\t\t\tz.Sub(x, y)\n-\t\tcase token.MUL:\n-\t\t\tz.Mul(x, y)\n-\t\tcase token.QUO:\n-\t\t\tz.Quo(x, y)\n-\t\tdefault:\n-\t\t\tunreachable()\n-\t\t}\n-\t\treturn normalizeRatConst(&z)\n-\n-\tcase complex:\n-\t\ty := y.(complex)\n-\t\ta, b := x.re, x.im\n-\t\tc, d := y.re, y.im\n-\t\tvar re, im big.Rat\n-\t\tswitch op {\n-\t\tcase token.ADD:\n-\t\t\t// (a+c) + i(b+d)\n-\t\t\tre.Add(a, c)\n-\t\t\tim.Add(b, d)\n-\t\tcase token.SUB:\n-\t\t\t// (a-c) + i(b-d)\n-\t\t\tre.Sub(a, c)\n-\t\t\tim.Sub(b, d)\n-\t\tcase token.MUL:\n-\t\t\t// (ac-bd) + i(bc+ad)\n-\t\t\tvar ac, bd, bc, ad big.Rat\n-\t\t\tac.Mul(a, c)\n-\t\t\tbd.Mul(b, d)\n-\t\t\tbc.Mul(b, c)\n-\t\t\tad.Mul(a, d)\n-\t\t\tre.Sub(&ac, &bd)\n-\t\t\tim.Add(&bc, &ad)\n-\t\tcase token.QUO:\n-\t\t\t// (ac+bd)/s + i(bc-ad)/s, with s = cc + dd\n-\t\t\tvar ac, bd, bc, ad, s big.Rat\n-\t\t\tac.Mul(a, c)\n-\t\t\tbd.Mul(b, d)\n-\t\t\tbc.Mul(b, c)\n-\t\t\tad.Mul(a, d)\n-\t\t\ts.Add(c.Mul(c, c), d.Mul(d, d))\n-\t\t\tre.Add(&ac, &bd)\n-\t\t\tre.Quo(&re, &s)\n-\t\t\tim.Sub(&bc, &ad)\n-\t\t\tim.Quo(&im, &s)\n-\t\tdefault:\n-\t\t\tunreachable()\n-\t\t}\n-\t\treturn normalizeComplexConst(complex{&re, &im})\n-\n-\tcase string:\n-\t\tif op == token.ADD {\n-\t\t\treturn x + y.(string)\n-\t\t}\n-\t}\n-\n-\tunreachable()\n-\treturn nil\n-}\n-\n-// shiftConst returns the result of the constant evaluation x op s\n-// where op is token.SHL or token.SHR (<< or >>). x must be an\n-// integer constant.\n-//\n-func shiftConst(x interface{}, s uint, op token.Token) interface{} {\n-\tswitch x := x.(type) {\n-\tcase int64:\n-\t\tswitch op {\n-\t\tcase token.SHL:\n-\t\t\tz := big.NewInt(x)\n-\t\t\treturn normalizeIntConst(z.Lsh(z, s))\n-\t\tcase token.SHR:\n-\t\t\treturn x >> s\n-\t\t}\n-\n-\tcase *big.Int:\n-\t\tvar z big.Int\n-\t\tswitch op {\n-\t\tcase token.SHL:\n-\t\t\treturn normalizeIntConst(z.Lsh(x, s))\n-\t\tcase token.SHR:\n-\t\t\treturn normalizeIntConst(z.Rsh(x, s))\n-\t\t}\n-\t}\n-\n-\tunreachable()\n-\treturn nil\n-}\n-\n-// compareConst returns the result of the constant comparison x op y;\n-// both operands must be of the same \"kind\" (boolean, numeric, string,\n-// or nilType).\n-//\n-func compareConst(x, y interface{}, op token.Token) (z bool) {\n-\tx, y = matchConst(x, y)\n-\n-\t// x == y  =>  x == y\n-\t// x != y  =>  x != y\n-\t// x >  y  =>  y <  x\n-\t// x >= y  =>  u <= x\n-\tswap := false\n-\tswitch op {\n-\tcase token.GTR:\n-\t\tswap = true\n-\t\top = token.LSS\n-\tcase token.GEQ:\n-\t\tswap = true\n-\t\top = token.LEQ\n-\t}\n-\n-\t// x == y  =>    x == y\n-\t// x != y  =>  !(x == y)\n-\t// x <  y  =>    x <  y\n-\t// x <= y  =>  !(y <  x)\n-\tnegate := false\n-\tswitch op {\n-\tcase token.NEQ:\n-\t\tnegate = true\n-\t\top = token.EQL\n-\tcase token.LEQ:\n-\t\tswap = !swap\n-\t\tnegate = true\n-\t\top = token.LSS\n-\t}\n-\n-\tif negate {\n-\t\tdefer func() { z = !z }()\n-\t}\n-\n-\tif swap {\n-\t\tx, y = y, x\n-\t}\n-\n-\tswitch x := x.(type) {\n-\tcase bool:\n-\t\tif op == token.EQL {\n-\t\t\treturn x == y.(bool)\n-\t\t}\n-\n-\tcase int64:\n-\t\ty := y.(int64)\n-\t\tswitch op {\n-\t\tcase token.EQL:\n-\t\t\treturn x == y\n-\t\tcase token.LSS:\n-\t\t\treturn x < y\n-\t\t}\n-\n-\tcase *big.Int:\n-\t\ts := x.Cmp(y.(*big.Int))\n-\t\tswitch op {\n-\t\tcase token.EQL:\n-\t\t\treturn s == 0\n-\t\tcase token.LSS:\n-\t\t\treturn s < 0\n-\t\t}\n-\n-\tcase *big.Rat:\n-\t\ts := x.Cmp(y.(*big.Rat))\n-\t\tswitch op {\n-\t\tcase token.EQL:\n-\t\t\treturn s == 0\n-\t\tcase token.LSS:\n-\t\t\treturn s < 0\n-\t\t}\n-\n-\tcase complex:\n-\t\ty := y.(complex)\n-\t\tif op == token.EQL {\n-\t\t\treturn x.re.Cmp(y.re) == 0 && x.im.Cmp(y.im) == 0\n-\t\t}\n-\n-\tcase string:\n-\t\ty := y.(string)\n-\t\tswitch op {\n-\t\tcase token.EQL:\n-\t\t\treturn x == y\n-\t\tcase token.LSS:\n-\t\t\treturn x < y\n-\t\t}\n-\n-\tcase nilType:\n-\t\tif op == token.EQL {\n-\t\t\treturn x == y.(nilType)\n-\t\t}\n-\t}\n-\n-\tfmt.Printf(\"x = %s (%T), y = %s (%T)\\n\", x, x, y, y)\n-\tunreachable()\n-\treturn\n-}"}, {"sha": "22190153bbf2daaf95928c4730d5aa1dabf42e31", "filename": "libgo/go/exp/types/staging/exportdata.go", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fexportdata.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,110 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements FindGcExportData.\n-\n-package types\n-\n-import (\n-\t\"bufio\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"strconv\"\n-\t\"strings\"\n-)\n-\n-func readGopackHeader(r *bufio.Reader) (name string, size int, err error) {\n-\t// See $GOROOT/include/ar.h.\n-\thdr := make([]byte, 16+12+6+6+8+10+2)\n-\t_, err = io.ReadFull(r, hdr)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif trace {\n-\t\tfmt.Printf(\"header: %s\", hdr)\n-\t}\n-\ts := strings.TrimSpace(string(hdr[16+12+6+6+8:][:10]))\n-\tsize, err = strconv.Atoi(s)\n-\tif err != nil || hdr[len(hdr)-2] != '`' || hdr[len(hdr)-1] != '\\n' {\n-\t\terr = errors.New(\"invalid archive header\")\n-\t\treturn\n-\t}\n-\tname = strings.TrimSpace(string(hdr[:16]))\n-\treturn\n-}\n-\n-// FindGcExportData positions the reader r at the beginning of the\n-// export data section of an underlying GC-created object/archive\n-// file by reading from it. The reader must be positioned at the\n-// start of the file before calling this function.\n-//\n-func FindGcExportData(r *bufio.Reader) (err error) {\n-\t// Read first line to make sure this is an object file.\n-\tline, err := r.ReadSlice('\\n')\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif string(line) == \"!<arch>\\n\" {\n-\t\t// Archive file.  Scan to __.PKGDEF, which should\n-\t\t// be second archive entry.\n-\t\tvar name string\n-\t\tvar size int\n-\n-\t\t// First entry should be __.GOSYMDEF.\n-\t\t// Older archives used __.SYMDEF, so allow that too.\n-\t\t// Read and discard.\n-\t\tif name, size, err = readGopackHeader(r); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif name != \"__.SYMDEF\" && name != \"__.GOSYMDEF\" {\n-\t\t\terr = errors.New(\"go archive does not begin with __.SYMDEF or __.GOSYMDEF\")\n-\t\t\treturn\n-\t\t}\n-\t\tconst block = 4096\n-\t\ttmp := make([]byte, block)\n-\t\tfor size > 0 {\n-\t\t\tn := size\n-\t\t\tif n > block {\n-\t\t\t\tn = block\n-\t\t\t}\n-\t\t\tif _, err = io.ReadFull(r, tmp[:n]); err != nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tsize -= n\n-\t\t}\n-\n-\t\t// Second entry should be __.PKGDEF.\n-\t\tif name, size, err = readGopackHeader(r); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif name != \"__.PKGDEF\" {\n-\t\t\terr = errors.New(\"go archive is missing __.PKGDEF\")\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// Read first line of __.PKGDEF data, so that line\n-\t\t// is once again the first line of the input.\n-\t\tif line, err = r.ReadSlice('\\n'); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\t// Now at __.PKGDEF in archive or still at beginning of file.\n-\t// Either way, line should begin with \"go object \".\n-\tif !strings.HasPrefix(string(line), \"go object \") {\n-\t\terr = errors.New(\"not a go object file\")\n-\t\treturn\n-\t}\n-\n-\t// Skip over object header to export data.\n-\t// Begins after first line with $$.\n-\tfor line[0] != '$' {\n-\t\tif line, err = r.ReadSlice('\\n'); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\treturn\n-}"}, {"sha": "b15238710e9abae3eaadf7e857f6c34a56584fa1", "filename": "libgo/go/exp/types/staging/gcimporter.go", "status": "removed", "additions": 0, "deletions": 889, "changes": 889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,889 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements an ast.Importer for gc-generated object files.\n-// TODO(gri) Eventually move this into a separate package outside types.\n-\n-package types\n-\n-import (\n-\t\"bufio\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/build\"\n-\t\"go/token\"\n-\t\"io\"\n-\t\"math/big\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"strconv\"\n-\t\"strings\"\n-\t\"text/scanner\"\n-)\n-\n-var pkgExts = [...]string{\".a\", \".5\", \".6\", \".8\"}\n-\n-// FindPkg returns the filename and unique package id for an import\n-// path based on package information provided by build.Import (using\n-// the build.Default build.Context).\n-// If no file was found, an empty filename is returned.\n-//\n-func FindPkg(path, srcDir string) (filename, id string) {\n-\tif len(path) == 0 {\n-\t\treturn\n-\t}\n-\n-\tid = path\n-\tvar noext string\n-\tswitch {\n-\tdefault:\n-\t\t// \"x\" -> \"$GOPATH/pkg/$GOOS_$GOARCH/x.ext\", \"x\"\n-\t\t// Don't require the source files to be present.\n-\t\tbp, _ := build.Import(path, srcDir, build.FindOnly|build.AllowBinary)\n-\t\tif bp.PkgObj == \"\" {\n-\t\t\treturn\n-\t\t}\n-\t\tnoext = bp.PkgObj\n-\t\tif strings.HasSuffix(noext, \".a\") {\n-\t\t\tnoext = noext[:len(noext)-len(\".a\")]\n-\t\t}\n-\n-\tcase build.IsLocalImport(path):\n-\t\t// \"./x\" -> \"/this/directory/x.ext\", \"/this/directory/x\"\n-\t\tnoext = filepath.Join(srcDir, path)\n-\t\tid = noext\n-\n-\tcase filepath.IsAbs(path):\n-\t\t// for completeness only - go/build.Import\n-\t\t// does not support absolute imports\n-\t\t// \"/x\" -> \"/x.ext\", \"/x\"\n-\t\tnoext = path\n-\t}\n-\n-\t// try extensions\n-\tfor _, ext := range pkgExts {\n-\t\tfilename = noext + ext\n-\t\tif f, err := os.Stat(filename); err == nil && !f.IsDir() {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tfilename = \"\" // not found\n-\treturn\n-}\n-\n-// GcImportData imports a package by reading the gc-generated export data,\n-// adds the corresponding package object to the imports map indexed by id,\n-// and returns the object.\n-//\n-// The imports map must contains all packages already imported, and no map\n-// entry with id as the key must be present. The data reader position must\n-// be the beginning of the export data section. The filename is only used\n-// in error messages.\n-//\n-func GcImportData(imports map[string]*ast.Object, filename, id string, data *bufio.Reader) (pkg *ast.Object, err error) {\n-\tif trace {\n-\t\tfmt.Printf(\"importing %s (%s)\\n\", id, filename)\n-\t}\n-\n-\t// support for gcParser error handling\n-\tdefer func() {\n-\t\tif r := recover(); r != nil {\n-\t\t\terr = r.(importError) // will re-panic if r is not an importError\n-\t\t}\n-\t}()\n-\n-\tvar p gcParser\n-\tp.init(filename, id, data, imports)\n-\tpkg = p.parseExport()\n-\n-\treturn\n-}\n-\n-// GcImport imports a gc-generated package given its import path, adds the\n-// corresponding package object to the imports map, and returns the object.\n-// Local import paths are interpreted relative to the current working directory.\n-// The imports map must contains all packages already imported.\n-// GcImport satisfies the ast.Importer signature.\n-//\n-func GcImport(imports map[string]*ast.Object, path string) (pkg *ast.Object, err error) {\n-\tif path == \"unsafe\" {\n-\t\treturn Unsafe, nil\n-\t}\n-\n-\tsrcDir, err := os.Getwd()\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tfilename, id := FindPkg(path, srcDir)\n-\tif filename == \"\" {\n-\t\terr = errors.New(\"can't find import: \" + id)\n-\t\treturn\n-\t}\n-\n-\t// Note: imports[id] may already contain a partially imported package.\n-\t//       We must continue doing the full import here since we don't\n-\t//       know if something is missing.\n-\t// TODO: There's no need to re-import a package if we know that we\n-\t//       have done a full import before. At the moment we cannot\n-\t//       tell from the available information in this function alone.\n-\n-\t// open file\n-\tf, err := os.Open(filename)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tdefer func() {\n-\t\tf.Close()\n-\t\tif err != nil {\n-\t\t\t// Add file name to error.\n-\t\t\terr = fmt.Errorf(\"reading export data: %s: %v\", filename, err)\n-\t\t}\n-\t}()\n-\n-\tbuf := bufio.NewReader(f)\n-\tif err = FindGcExportData(buf); err != nil {\n-\t\treturn\n-\t}\n-\n-\tpkg, err = GcImportData(imports, filename, id, buf)\n-\n-\treturn\n-}\n-\n-// ----------------------------------------------------------------------------\n-// gcParser\n-\n-// gcParser parses the exports inside a gc compiler-produced\n-// object/archive file and populates its scope with the results.\n-type gcParser struct {\n-\tscanner scanner.Scanner\n-\ttok     rune                   // current token\n-\tlit     string                 // literal string; only valid for Ident, Int, String tokens\n-\tid      string                 // package id of imported package\n-\timports map[string]*ast.Object // package id -> package object\n-}\n-\n-func (p *gcParser) init(filename, id string, src io.Reader, imports map[string]*ast.Object) {\n-\tp.scanner.Init(src)\n-\tp.scanner.Error = func(_ *scanner.Scanner, msg string) { p.error(msg) }\n-\tp.scanner.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanChars | scanner.ScanStrings | scanner.ScanComments | scanner.SkipComments\n-\tp.scanner.Whitespace = 1<<'\\t' | 1<<' '\n-\tp.scanner.Filename = filename // for good error messages\n-\tp.next()\n-\tp.id = id\n-\tp.imports = imports\n-}\n-\n-func (p *gcParser) next() {\n-\tp.tok = p.scanner.Scan()\n-\tswitch p.tok {\n-\tcase scanner.Ident, scanner.Int, scanner.Char, scanner.String, '\u00b7':\n-\t\tp.lit = p.scanner.TokenText()\n-\tdefault:\n-\t\tp.lit = \"\"\n-\t}\n-\tif trace {\n-\t\tfmt.Printf(\"%s: %q -> %q\\n\", scanner.TokenString(p.tok), p.scanner.TokenText(), p.lit)\n-\t}\n-}\n-\n-// Declare inserts a named object of the given kind in scope.\n-func (p *gcParser) declare(scope *ast.Scope, kind ast.ObjKind, name string) *ast.Object {\n-\t// the object may have been imported before - if it exists\n-\t// already in the respective package scope, return that object\n-\tif obj := scope.Lookup(name); obj != nil {\n-\t\tassert(obj.Kind == kind)\n-\t\treturn obj\n-\t}\n-\n-\t// otherwise create a new object and insert it into the package scope\n-\tobj := ast.NewObj(kind, name)\n-\tif scope.Insert(obj) != nil {\n-\t\tp.errorf(\"already declared: %v %s\", kind, obj.Name)\n-\t}\n-\n-\t// if the new type object is a named type it may be referred\n-\t// to before the underlying type is known - set it up\n-\tif kind == ast.Typ {\n-\t\tobj.Type = &NamedType{Obj: obj}\n-\t}\n-\n-\treturn obj\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Error handling\n-\n-// Internal errors are boxed as importErrors.\n-type importError struct {\n-\tpos scanner.Position\n-\terr error\n-}\n-\n-func (e importError) Error() string {\n-\treturn fmt.Sprintf(\"import error %s (byte offset = %d): %s\", e.pos, e.pos.Offset, e.err)\n-}\n-\n-func (p *gcParser) error(err interface{}) {\n-\tif s, ok := err.(string); ok {\n-\t\terr = errors.New(s)\n-\t}\n-\t// panic with a runtime.Error if err is not an error\n-\tpanic(importError{p.scanner.Pos(), err.(error)})\n-}\n-\n-func (p *gcParser) errorf(format string, args ...interface{}) {\n-\tp.error(fmt.Sprintf(format, args...))\n-}\n-\n-func (p *gcParser) expect(tok rune) string {\n-\tlit := p.lit\n-\tif p.tok != tok {\n-\t\tp.errorf(\"expected %s, got %s (%s)\", scanner.TokenString(tok), scanner.TokenString(p.tok), lit)\n-\t}\n-\tp.next()\n-\treturn lit\n-}\n-\n-func (p *gcParser) expectSpecial(tok string) {\n-\tsep := 'x' // not white space\n-\ti := 0\n-\tfor i < len(tok) && p.tok == rune(tok[i]) && sep > ' ' {\n-\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token\n-\t\tp.next()\n-\t\ti++\n-\t}\n-\tif i < len(tok) {\n-\t\tp.errorf(\"expected %q, got %q\", tok, tok[0:i])\n-\t}\n-}\n-\n-func (p *gcParser) expectKeyword(keyword string) {\n-\tlit := p.expect(scanner.Ident)\n-\tif lit != keyword {\n-\t\tp.errorf(\"expected keyword %s, got %q\", keyword, lit)\n-\t}\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Import declarations\n-\n-// ImportPath = string_lit .\n-//\n-func (p *gcParser) parsePkgId() *ast.Object {\n-\tid, err := strconv.Unquote(p.expect(scanner.String))\n-\tif err != nil {\n-\t\tp.error(err)\n-\t}\n-\n-\tswitch id {\n-\tcase \"\":\n-\t\t// id == \"\" stands for the imported package id\n-\t\t// (only known at time of package installation)\n-\t\tid = p.id\n-\tcase \"unsafe\":\n-\t\t// package unsafe is not in the imports map - handle explicitly\n-\t\treturn Unsafe\n-\t}\n-\n-\tpkg := p.imports[id]\n-\tif pkg == nil {\n-\t\tpkg = ast.NewObj(ast.Pkg, \"\")\n-\t\tpkg.Data = ast.NewScope(nil)\n-\t\tp.imports[id] = pkg\n-\t}\n-\n-\treturn pkg\n-}\n-\n-// dotIdentifier = ( ident | '\u00b7' ) { ident | int | '\u00b7' } .\n-func (p *gcParser) parseDotIdent() string {\n-\tident := \"\"\n-\tif p.tok != scanner.Int {\n-\t\tsep := 'x' // not white space\n-\t\tfor (p.tok == scanner.Ident || p.tok == scanner.Int || p.tok == '\u00b7') && sep > ' ' {\n-\t\t\tident += p.lit\n-\t\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token\n-\t\t\tp.next()\n-\t\t}\n-\t}\n-\tif ident == \"\" {\n-\t\tp.expect(scanner.Ident) // use expect() for error handling\n-\t}\n-\treturn ident\n-}\n-\n-// ExportedName = \"@\" ImportPath \".\" dotIdentifier .\n-//\n-func (p *gcParser) parseExportedName() (*ast.Object, string) {\n-\tp.expect('@')\n-\tpkg := p.parsePkgId()\n-\tp.expect('.')\n-\tname := p.parseDotIdent()\n-\treturn pkg, name\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Types\n-\n-// BasicType = identifier .\n-//\n-func (p *gcParser) parseBasicType() Type {\n-\tid := p.expect(scanner.Ident)\n-\tobj := Universe.Lookup(id)\n-\tif obj == nil || obj.Kind != ast.Typ {\n-\t\tp.errorf(\"not a basic type: %s\", id)\n-\t}\n-\treturn obj.Type.(Type)\n-}\n-\n-// ArrayType = \"[\" int_lit \"]\" Type .\n-//\n-func (p *gcParser) parseArrayType() Type {\n-\t// \"[\" already consumed and lookahead known not to be \"]\"\n-\tlit := p.expect(scanner.Int)\n-\tp.expect(']')\n-\telt := p.parseType()\n-\tn, err := strconv.ParseInt(lit, 10, 64)\n-\tif err != nil {\n-\t\tp.error(err)\n-\t}\n-\treturn &Array{Len: n, Elt: elt}\n-}\n-\n-// MapType = \"map\" \"[\" Type \"]\" Type .\n-//\n-func (p *gcParser) parseMapType() Type {\n-\tp.expectKeyword(\"map\")\n-\tp.expect('[')\n-\tkey := p.parseType()\n-\tp.expect(']')\n-\telt := p.parseType()\n-\treturn &Map{Key: key, Elt: elt}\n-}\n-\n-// Name = identifier | \"?\" | ExportedName  .\n-//\n-func (p *gcParser) parseName() (name string) {\n-\tswitch p.tok {\n-\tcase scanner.Ident:\n-\t\tname = p.lit\n-\t\tp.next()\n-\tcase '?':\n-\t\t// anonymous\n-\t\tp.next()\n-\tcase '@':\n-\t\t// exported name prefixed with package path\n-\t\t_, name = p.parseExportedName()\n-\tdefault:\n-\t\tp.error(\"name expected\")\n-\t}\n-\treturn\n-}\n-\n-// Field = Name Type [ string_lit ] .\n-//\n-func (p *gcParser) parseField() *StructField {\n-\tvar f StructField\n-\tf.Name = p.parseName()\n-\tf.Type = p.parseType()\n-\tif p.tok == scanner.String {\n-\t\tf.Tag = p.expect(scanner.String)\n-\t}\n-\tif f.Name == \"\" {\n-\t\t// anonymous field - typ must be T or *T and T must be a type name\n-\t\tif typ, ok := deref(f.Type).(*NamedType); ok && typ.Obj != nil {\n-\t\t\tf.Name = typ.Obj.Name\n-\t\t} else {\n-\t\t\tp.errorf(\"anonymous field expected\")\n-\t\t}\n-\t}\n-\treturn &f\n-}\n-\n-// StructType = \"struct\" \"{\" [ FieldList ] \"}\" .\n-// FieldList  = Field { \";\" Field } .\n-//\n-func (p *gcParser) parseStructType() Type {\n-\tvar fields []*StructField\n-\n-\tparseField := func() {\n-\t\tfields = append(fields, p.parseField())\n-\t}\n-\n-\tp.expectKeyword(\"struct\")\n-\tp.expect('{')\n-\tif p.tok != '}' {\n-\t\tparseField()\n-\t\tfor p.tok == ';' {\n-\t\t\tp.next()\n-\t\t\tparseField()\n-\t\t}\n-\t}\n-\tp.expect('}')\n-\n-\treturn &Struct{Fields: fields}\n-}\n-\n-// Parameter = ( identifier | \"?\" ) [ \"...\" ] Type [ string_lit ] .\n-//\n-func (p *gcParser) parseParameter() (par *ast.Object, isVariadic bool) {\n-\tname := p.parseName()\n-\tif name == \"\" {\n-\t\tname = \"_\" // cannot access unnamed identifiers\n-\t}\n-\tif p.tok == '.' {\n-\t\tp.expectSpecial(\"...\")\n-\t\tisVariadic = true\n-\t}\n-\tptyp := p.parseType()\n-\t// ignore argument tag (e.g. \"noescape\")\n-\tif p.tok == scanner.String {\n-\t\tp.expect(scanner.String)\n-\t}\n-\tpar = ast.NewObj(ast.Var, name)\n-\tpar.Type = ptyp\n-\treturn\n-}\n-\n-// Parameters    = \"(\" [ ParameterList ] \")\" .\n-// ParameterList = { Parameter \",\" } Parameter .\n-//\n-func (p *gcParser) parseParameters() (list []*ast.Object, isVariadic bool) {\n-\tparseParameter := func() {\n-\t\tpar, variadic := p.parseParameter()\n-\t\tlist = append(list, par)\n-\t\tif variadic {\n-\t\t\tif isVariadic {\n-\t\t\t\tp.error(\"... not on final argument\")\n-\t\t\t}\n-\t\t\tisVariadic = true\n-\t\t}\n-\t}\n-\n-\tp.expect('(')\n-\tif p.tok != ')' {\n-\t\tparseParameter()\n-\t\tfor p.tok == ',' {\n-\t\t\tp.next()\n-\t\t\tparseParameter()\n-\t\t}\n-\t}\n-\tp.expect(')')\n-\n-\treturn\n-}\n-\n-// Signature = Parameters [ Result ] .\n-// Result    = Type | Parameters .\n-//\n-func (p *gcParser) parseSignature() *Signature {\n-\tparams, isVariadic := p.parseParameters()\n-\n-\t// optional result type\n-\tvar results []*ast.Object\n-\tswitch p.tok {\n-\tcase scanner.Ident, '[', '*', '<', '@':\n-\t\t// single, unnamed result\n-\t\tresult := ast.NewObj(ast.Var, \"_\")\n-\t\tresult.Type = p.parseType()\n-\t\tresults = []*ast.Object{result}\n-\tcase '(':\n-\t\t// named or multiple result(s)\n-\t\tvar variadic bool\n-\t\tresults, variadic = p.parseParameters()\n-\t\tif variadic {\n-\t\t\tp.error(\"... not permitted on result type\")\n-\t\t}\n-\t}\n-\n-\treturn &Signature{Params: params, Results: results, IsVariadic: isVariadic}\n-}\n-\n-// InterfaceType = \"interface\" \"{\" [ MethodList ] \"}\" .\n-// MethodList = Method { \";\" Method } .\n-// Method = Name Signature .\n-//\n-// (The methods of embedded interfaces are always \"inlined\"\n-// by the compiler and thus embedded interfaces are never\n-// visible in the export data.)\n-//\n-func (p *gcParser) parseInterfaceType() Type {\n-\tvar methods ObjList\n-\n-\tparseMethod := func() {\n-\t\tobj := ast.NewObj(ast.Fun, p.parseName())\n-\t\tobj.Type = p.parseSignature()\n-\t\tmethods = append(methods, obj)\n-\t}\n-\n-\tp.expectKeyword(\"interface\")\n-\tp.expect('{')\n-\tif p.tok != '}' {\n-\t\tparseMethod()\n-\t\tfor p.tok == ';' {\n-\t\t\tp.next()\n-\t\t\tparseMethod()\n-\t\t}\n-\t}\n-\tp.expect('}')\n-\n-\tmethods.Sort()\n-\treturn &Interface{Methods: methods}\n-}\n-\n-// ChanType = ( \"chan\" [ \"<-\" ] | \"<-\" \"chan\" ) Type .\n-//\n-func (p *gcParser) parseChanType() Type {\n-\tdir := ast.SEND | ast.RECV\n-\tif p.tok == scanner.Ident {\n-\t\tp.expectKeyword(\"chan\")\n-\t\tif p.tok == '<' {\n-\t\t\tp.expectSpecial(\"<-\")\n-\t\t\tdir = ast.SEND\n-\t\t}\n-\t} else {\n-\t\tp.expectSpecial(\"<-\")\n-\t\tp.expectKeyword(\"chan\")\n-\t\tdir = ast.RECV\n-\t}\n-\telt := p.parseType()\n-\treturn &Chan{Dir: dir, Elt: elt}\n-}\n-\n-// Type =\n-//\tBasicType | TypeName | ArrayType | SliceType | StructType |\n-//      PointerType | FuncType | InterfaceType | MapType | ChanType |\n-//      \"(\" Type \")\" .\n-// BasicType = ident .\n-// TypeName = ExportedName .\n-// SliceType = \"[\" \"]\" Type .\n-// PointerType = \"*\" Type .\n-// FuncType = \"func\" Signature .\n-//\n-func (p *gcParser) parseType() Type {\n-\tswitch p.tok {\n-\tcase scanner.Ident:\n-\t\tswitch p.lit {\n-\t\tdefault:\n-\t\t\treturn p.parseBasicType()\n-\t\tcase \"struct\":\n-\t\t\treturn p.parseStructType()\n-\t\tcase \"func\":\n-\t\t\t// FuncType\n-\t\t\tp.next()\n-\t\t\treturn p.parseSignature()\n-\t\tcase \"interface\":\n-\t\t\treturn p.parseInterfaceType()\n-\t\tcase \"map\":\n-\t\t\treturn p.parseMapType()\n-\t\tcase \"chan\":\n-\t\t\treturn p.parseChanType()\n-\t\t}\n-\tcase '@':\n-\t\t// TypeName\n-\t\tpkg, name := p.parseExportedName()\n-\t\treturn p.declare(pkg.Data.(*ast.Scope), ast.Typ, name).Type.(Type)\n-\tcase '[':\n-\t\tp.next() // look ahead\n-\t\tif p.tok == ']' {\n-\t\t\t// SliceType\n-\t\t\tp.next()\n-\t\t\treturn &Slice{Elt: p.parseType()}\n-\t\t}\n-\t\treturn p.parseArrayType()\n-\tcase '*':\n-\t\t// PointerType\n-\t\tp.next()\n-\t\treturn &Pointer{Base: p.parseType()}\n-\tcase '<':\n-\t\treturn p.parseChanType()\n-\tcase '(':\n-\t\t// \"(\" Type \")\"\n-\t\tp.next()\n-\t\ttyp := p.parseType()\n-\t\tp.expect(')')\n-\t\treturn typ\n-\t}\n-\tp.errorf(\"expected type, got %s (%q)\", scanner.TokenString(p.tok), p.lit)\n-\treturn nil\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Declarations\n-\n-// ImportDecl = \"import\" identifier string_lit .\n-//\n-func (p *gcParser) parseImportDecl() {\n-\tp.expectKeyword(\"import\")\n-\t// The identifier has no semantic meaning in the import data.\n-\t// It exists so that error messages can print the real package\n-\t// name: binary.ByteOrder instead of \"encoding/binary\".ByteOrder.\n-\tname := p.expect(scanner.Ident)\n-\tpkg := p.parsePkgId()\n-\tassert(pkg.Name == \"\" || pkg.Name == name)\n-\tpkg.Name = name\n-}\n-\n-// int_lit = [ \"+\" | \"-\" ] { \"0\" ... \"9\" } .\n-//\n-func (p *gcParser) parseInt() (neg bool, val string) {\n-\tswitch p.tok {\n-\tcase '-':\n-\t\tneg = true\n-\t\tfallthrough\n-\tcase '+':\n-\t\tp.next()\n-\t}\n-\tval = p.expect(scanner.Int)\n-\treturn\n-}\n-\n-// number = int_lit [ \"p\" int_lit ] .\n-//\n-func (p *gcParser) parseNumber() (x operand) {\n-\tx.mode = constant\n-\n-\t// mantissa\n-\tneg, val := p.parseInt()\n-\tmant, ok := new(big.Int).SetString(val, 0)\n-\tassert(ok)\n-\tif neg {\n-\t\tmant.Neg(mant)\n-\t}\n-\n-\tif p.lit == \"p\" {\n-\t\t// exponent (base 2)\n-\t\tp.next()\n-\t\tneg, val = p.parseInt()\n-\t\texp64, err := strconv.ParseUint(val, 10, 0)\n-\t\tif err != nil {\n-\t\t\tp.error(err)\n-\t\t}\n-\t\texp := uint(exp64)\n-\t\tif neg {\n-\t\t\tdenom := big.NewInt(1)\n-\t\t\tdenom.Lsh(denom, exp)\n-\t\t\tx.typ = Typ[UntypedFloat]\n-\t\t\tx.val = normalizeRatConst(new(big.Rat).SetFrac(mant, denom))\n-\t\t\treturn\n-\t\t}\n-\t\tif exp > 0 {\n-\t\t\tmant.Lsh(mant, exp)\n-\t\t}\n-\t\tx.typ = Typ[UntypedFloat]\n-\t\tx.val = normalizeIntConst(mant)\n-\t\treturn\n-\t}\n-\n-\tx.typ = Typ[UntypedInt]\n-\tx.val = normalizeIntConst(mant)\n-\treturn\n-}\n-\n-// ConstDecl   = \"const\" ExportedName [ Type ] \"=\" Literal .\n-// Literal     = bool_lit | int_lit | float_lit | complex_lit | rune_lit | string_lit .\n-// bool_lit    = \"true\" | \"false\" .\n-// complex_lit = \"(\" float_lit \"+\" float_lit \"i\" \")\" .\n-// rune_lit = \"(\" int_lit \"+\" int_lit \")\" .\n-// string_lit  = `\"` { unicode_char } `\"` .\n-//\n-func (p *gcParser) parseConstDecl() {\n-\tp.expectKeyword(\"const\")\n-\tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Con, name)\n-\tvar x operand\n-\tif p.tok != '=' {\n-\t\tobj.Type = p.parseType()\n-\t}\n-\tp.expect('=')\n-\tswitch p.tok {\n-\tcase scanner.Ident:\n-\t\t// bool_lit\n-\t\tif p.lit != \"true\" && p.lit != \"false\" {\n-\t\t\tp.error(\"expected true or false\")\n-\t\t}\n-\t\tx.typ = Typ[UntypedBool]\n-\t\tx.val = p.lit == \"true\"\n-\t\tp.next()\n-\n-\tcase '-', scanner.Int:\n-\t\t// int_lit\n-\t\tx = p.parseNumber()\n-\n-\tcase '(':\n-\t\t// complex_lit or rune_lit\n-\t\tp.next()\n-\t\tif p.tok == scanner.Char {\n-\t\t\tp.next()\n-\t\t\tp.expect('+')\n-\t\t\tx = p.parseNumber()\n-\t\t\tx.typ = Typ[UntypedRune]\n-\t\t\tp.expect(')')\n-\t\t\tbreak\n-\t\t}\n-\t\tre := p.parseNumber()\n-\t\tp.expect('+')\n-\t\tim := p.parseNumber()\n-\t\tp.expectKeyword(\"i\")\n-\t\tp.expect(')')\n-\t\tx.typ = Typ[UntypedComplex]\n-\t\t// TODO(gri) fix this\n-\t\t_, _ = re, im\n-\t\tx.val = zeroConst\n-\n-\tcase scanner.Char:\n-\t\t// rune_lit\n-\t\tx.setConst(token.CHAR, p.lit)\n-\t\tp.next()\n-\n-\tcase scanner.String:\n-\t\t// string_lit\n-\t\tx.setConst(token.STRING, p.lit)\n-\t\tp.next()\n-\n-\tdefault:\n-\t\tp.errorf(\"expected literal got %s\", scanner.TokenString(p.tok))\n-\t}\n-\tif obj.Type == nil {\n-\t\tobj.Type = x.typ\n-\t}\n-\tassert(x.val != nil)\n-\tobj.Data = x.val\n-}\n-\n-// TypeDecl = \"type\" ExportedName Type .\n-//\n-func (p *gcParser) parseTypeDecl() {\n-\tp.expectKeyword(\"type\")\n-\tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Typ, name)\n-\n-\t// The type object may have been imported before and thus already\n-\t// have a type associated with it. We still need to parse the type\n-\t// structure, but throw it away if the object already has a type.\n-\t// This ensures that all imports refer to the same type object for\n-\t// a given type declaration.\n-\ttyp := p.parseType()\n-\n-\tif name := obj.Type.(*NamedType); name.Underlying == nil {\n-\t\tname.Underlying = typ\n-\t}\n-}\n-\n-// VarDecl = \"var\" ExportedName Type .\n-//\n-func (p *gcParser) parseVarDecl() {\n-\tp.expectKeyword(\"var\")\n-\tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Var, name)\n-\tobj.Type = p.parseType()\n-}\n-\n-// FuncBody = \"{\" ... \"}\" .\n-//\n-func (p *gcParser) parseFuncBody() {\n-\tp.expect('{')\n-\tfor i := 1; i > 0; p.next() {\n-\t\tswitch p.tok {\n-\t\tcase '{':\n-\t\t\ti++\n-\t\tcase '}':\n-\t\t\ti--\n-\t\t}\n-\t}\n-}\n-\n-// FuncDecl = \"func\" ExportedName Signature [ FuncBody ] .\n-//\n-func (p *gcParser) parseFuncDecl() {\n-\t// \"func\" already consumed\n-\tpkg, name := p.parseExportedName()\n-\tobj := p.declare(pkg.Data.(*ast.Scope), ast.Fun, name)\n-\tobj.Type = p.parseSignature()\n-\tif p.tok == '{' {\n-\t\tp.parseFuncBody()\n-\t}\n-}\n-\n-// MethodDecl = \"func\" Receiver Name Signature .\n-// Receiver   = \"(\" ( identifier | \"?\" ) [ \"*\" ] ExportedName \")\" [ FuncBody ].\n-//\n-func (p *gcParser) parseMethodDecl() {\n-\t// \"func\" already consumed\n-\tp.expect('(')\n-\tp.parseParameter() // receiver\n-\tp.expect(')')\n-\tp.parseName() // unexported method names in imports are qualified with their package.\n-\tp.parseSignature()\n-\tif p.tok == '{' {\n-\t\tp.parseFuncBody()\n-\t}\n-}\n-\n-// Decl = [ ImportDecl | ConstDecl | TypeDecl | VarDecl | FuncDecl | MethodDecl ] \"\\n\" .\n-//\n-func (p *gcParser) parseDecl() {\n-\tswitch p.lit {\n-\tcase \"import\":\n-\t\tp.parseImportDecl()\n-\tcase \"const\":\n-\t\tp.parseConstDecl()\n-\tcase \"type\":\n-\t\tp.parseTypeDecl()\n-\tcase \"var\":\n-\t\tp.parseVarDecl()\n-\tcase \"func\":\n-\t\tp.next() // look ahead\n-\t\tif p.tok == '(' {\n-\t\t\tp.parseMethodDecl()\n-\t\t} else {\n-\t\t\tp.parseFuncDecl()\n-\t\t}\n-\t}\n-\tp.expect('\\n')\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Export\n-\n-// Export        = \"PackageClause { Decl } \"$$\" .\n-// PackageClause = \"package\" identifier [ \"safe\" ] \"\\n\" .\n-//\n-func (p *gcParser) parseExport() *ast.Object {\n-\tp.expectKeyword(\"package\")\n-\tname := p.expect(scanner.Ident)\n-\tif p.tok != '\\n' {\n-\t\t// A package is safe if it was compiled with the -u flag,\n-\t\t// which disables the unsafe package.\n-\t\t// TODO(gri) remember \"safe\" package\n-\t\tp.expectKeyword(\"safe\")\n-\t}\n-\tp.expect('\\n')\n-\n-\tpkg := p.imports[p.id]\n-\tif pkg == nil {\n-\t\tpkg = ast.NewObj(ast.Pkg, name)\n-\t\tpkg.Data = ast.NewScope(nil)\n-\t\tp.imports[p.id] = pkg\n-\t}\n-\n-\tfor p.tok != '$' && p.tok != scanner.EOF {\n-\t\tp.parseDecl()\n-\t}\n-\n-\tif ch := p.scanner.Peek(); p.tok != '$' || ch != '$' {\n-\t\t// don't call next()/expect() since reading past the\n-\t\t// export data may cause scanner errors (e.g. NUL chars)\n-\t\tp.errorf(\"expected '$$', got %s %c\", scanner.TokenString(p.tok), ch)\n-\t}\n-\n-\tif n := p.scanner.ErrorCount; n != 0 {\n-\t\tp.errorf(\"expected no scanner errors, got %d\", n)\n-\t}\n-\n-\treturn pkg\n-}"}, {"sha": "2f89d3ac91274888d316778e8a91674733cc429f", "filename": "libgo/go/exp/types/staging/gcimporter_test.go", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fgcimporter_test.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,153 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package types\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/build\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"path/filepath\"\n-\t\"runtime\"\n-\t\"strings\"\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-var gcPath string // Go compiler path\n-\n-func init() {\n-\t// determine compiler\n-\tvar gc string\n-\tswitch runtime.GOARCH {\n-\tcase \"386\":\n-\t\tgc = \"8g\"\n-\tcase \"amd64\":\n-\t\tgc = \"6g\"\n-\tcase \"arm\":\n-\t\tgc = \"5g\"\n-\tdefault:\n-\t\tgcPath = \"unknown-GOARCH-compiler\"\n-\t\treturn\n-\t}\n-\tgcPath = filepath.Join(build.ToolDir, gc)\n-}\n-\n-func compile(t *testing.T, dirname, filename string) string {\n-\tcmd := exec.Command(gcPath, filename)\n-\tcmd.Dir = dirname\n-\tout, err := cmd.CombinedOutput()\n-\tif err != nil {\n-\t\tt.Logf(\"%s\", out)\n-\t\tt.Fatalf(\"%s %s failed: %s\", gcPath, filename, err)\n-\t}\n-\tarchCh, _ := build.ArchChar(runtime.GOARCH)\n-\t// filename should end with \".go\"\n-\treturn filepath.Join(dirname, filename[:len(filename)-2]+archCh)\n-}\n-\n-// Use the same global imports map for all tests. The effect is\n-// as if all tested packages were imported into a single package.\n-var imports = make(map[string]*ast.Object)\n-\n-func testPath(t *testing.T, path string) bool {\n-\t_, err := GcImport(imports, path)\n-\tif err != nil {\n-\t\tt.Errorf(\"testPath(%s): %s\", path, err)\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-const maxTime = 3 * time.Second\n-\n-func testDir(t *testing.T, dir string, endTime time.Time) (nimports int) {\n-\tdirname := filepath.Join(runtime.GOROOT(), \"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH, dir)\n-\tlist, err := ioutil.ReadDir(dirname)\n-\tif err != nil {\n-\t\tt.Errorf(\"testDir(%s): %s\", dirname, err)\n-\t}\n-\tfor _, f := range list {\n-\t\tif time.Now().After(endTime) {\n-\t\t\tt.Log(\"testing time used up\")\n-\t\t\treturn\n-\t\t}\n-\t\tswitch {\n-\t\tcase !f.IsDir():\n-\t\t\t// try extensions\n-\t\t\tfor _, ext := range pkgExts {\n-\t\t\t\tif strings.HasSuffix(f.Name(), ext) {\n-\t\t\t\t\tname := f.Name()[0 : len(f.Name())-len(ext)] // remove extension\n-\t\t\t\t\tif testPath(t, filepath.Join(dir, name)) {\n-\t\t\t\t\t\tnimports++\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\tcase f.IsDir():\n-\t\t\tnimports += testDir(t, filepath.Join(dir, f.Name()), endTime)\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func TestGcImport(t *testing.T) {\n-\t// On cross-compile builds, the path will not exist.\n-\t// Need to use GOHOSTOS, which is not available.\n-\tif _, err := os.Stat(gcPath); err != nil {\n-\t\tt.Logf(\"skipping test: %v\", err)\n-\t\treturn\n-\t}\n-\n-\tif outFn := compile(t, \"testdata\", \"exports.go\"); outFn != \"\" {\n-\t\tdefer os.Remove(outFn)\n-\t}\n-\n-\tnimports := 0\n-\tif testPath(t, \"./testdata/exports\") {\n-\t\tnimports++\n-\t}\n-\tnimports += testDir(t, \"\", time.Now().Add(maxTime)) // installed packages\n-\tt.Logf(\"tested %d imports\", nimports)\n-}\n-\n-var importedObjectTests = []struct {\n-\tname string\n-\tkind ast.ObjKind\n-\ttyp  string\n-}{\n-\t{\"unsafe.Pointer\", ast.Typ, \"Pointer\"},\n-\t{\"math.Pi\", ast.Con, \"untyped float\"},\n-\t{\"io.Reader\", ast.Typ, \"interface{Read(p []byte) (n int, err error)}\"},\n-\t{\"io.ReadWriter\", ast.Typ, \"interface{Read(p []byte) (n int, err error); Write(p []byte) (n int, err error)}\"},\n-\t{\"math.Sin\", ast.Fun, \"func(x float64) (_ float64)\"},\n-\t// TODO(gri) add more tests\n-}\n-\n-func TestGcImportedTypes(t *testing.T) {\n-\tfor _, test := range importedObjectTests {\n-\t\ts := strings.Split(test.name, \".\")\n-\t\tif len(s) != 2 {\n-\t\t\tt.Fatal(\"inconsistent test data\")\n-\t\t}\n-\t\timportPath := s[0]\n-\t\tobjName := s[1]\n-\n-\t\tpkg, err := GcImport(imports, importPath)\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tobj := pkg.Data.(*ast.Scope).Lookup(objName)\n-\t\tif obj.Kind != test.kind {\n-\t\t\tt.Errorf(\"%s: got kind = %q; want %q\", test.name, obj.Kind, test.kind)\n-\t\t}\n-\t\ttyp := typeString(underlying(obj.Type.(Type)))\n-\t\tif typ != test.typ {\n-\t\t\tt.Errorf(\"%s: got type = %q; want %q\", test.name, typ, test.typ)\n-\t\t}\n-\t}\n-}"}, {"sha": "4e9aa0938d986a0fb35b12b8881e99b7f1146a71", "filename": "libgo/go/exp/types/staging/resolver_test.go", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fresolver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fresolver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Fresolver_test.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package types\n-\n-import (\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/parser\"\n-\t\"go/scanner\"\n-\t\"go/token\"\n-\t\"testing\"\n-)\n-\n-var sources = []string{\n-\t`package p\n-\timport \"fmt\"\n-\timport \"math\"\n-\tconst pi = math.Pi\n-\tfunc sin(x float64) float64 {\n-\t\treturn math.Sin(x)\n-\t}\n-\tvar Println = fmt.Println\n-\t`,\n-\t`package p\n-\timport \"fmt\"\n-\tfunc f() string {\n-\t\treturn fmt.Sprintf(\"%d\", g())\n-\t}\n-\t`,\n-\t`package p\n-\timport . \"go/parser\"\n-\tfunc g() Mode { return ImportsOnly }`,\n-}\n-\n-var pkgnames = []string{\n-\t\"fmt\",\n-\t\"go/parser\",\n-\t\"math\",\n-}\n-\n-// ResolveQualifiedIdents resolves the selectors of qualified\n-// identifiers by associating the correct ast.Object with them.\n-// TODO(gri): Eventually, this functionality should be subsumed\n-//            by Check.\n-//\n-func ResolveQualifiedIdents(fset *token.FileSet, pkg *ast.Package) error {\n-\tvar errors scanner.ErrorList\n-\n-\tfindObj := func(pkg *ast.Object, name *ast.Ident) *ast.Object {\n-\t\tscope := pkg.Data.(*ast.Scope)\n-\t\tobj := scope.Lookup(name.Name)\n-\t\tif obj == nil {\n-\t\t\terrors.Add(fset.Position(name.Pos()), fmt.Sprintf(\"no %s in package %s\", name.Name, pkg.Name))\n-\t\t}\n-\t\treturn obj\n-\t}\n-\n-\tast.Inspect(pkg, func(n ast.Node) bool {\n-\t\tif s, ok := n.(*ast.SelectorExpr); ok {\n-\t\t\tif x, ok := s.X.(*ast.Ident); ok && x.Obj != nil && x.Obj.Kind == ast.Pkg {\n-\t\t\t\t// find selector in respective package\n-\t\t\t\ts.Sel.Obj = findObj(x.Obj, s.Sel)\n-\t\t\t}\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n-\t})\n-\n-\treturn errors.Err()\n-}\n-\n-func TestResolveQualifiedIdents(t *testing.T) {\n-\t// parse package files\n-\tfset := token.NewFileSet()\n-\tfiles := make(map[string]*ast.File)\n-\tfor i, src := range sources {\n-\t\tfilename := fmt.Sprintf(\"file%d\", i)\n-\t\tf, err := parser.ParseFile(fset, filename, src, parser.DeclarationErrors)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tfiles[filename] = f\n-\t}\n-\n-\t// resolve package AST\n-\tpkg, err := ast.NewPackage(fset, files, GcImport, Universe)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// check that all packages were imported\n-\tfor _, name := range pkgnames {\n-\t\tif pkg.Imports[name] == nil {\n-\t\t\tt.Errorf(\"package %s not imported\", name)\n-\t\t}\n-\t}\n-\n-\t// check that there are no top-level unresolved identifiers\n-\tfor _, f := range pkg.Files {\n-\t\tfor _, x := range f.Unresolved {\n-\t\t\tt.Errorf(\"%s: unresolved global identifier %s\", fset.Position(x.Pos()), x.Name)\n-\t\t}\n-\t}\n-\n-\t// resolve qualified identifiers\n-\tif err := ResolveQualifiedIdents(fset, pkg); err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\t// check that qualified identifiers are resolved\n-\tast.Inspect(pkg, func(n ast.Node) bool {\n-\t\tif s, ok := n.(*ast.SelectorExpr); ok {\n-\t\t\tif x, ok := s.X.(*ast.Ident); ok {\n-\t\t\t\tif x.Obj == nil {\n-\t\t\t\t\tt.Errorf(\"%s: unresolved qualified identifier %s\", fset.Position(x.Pos()), x.Name)\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tif x.Obj.Kind == ast.Pkg && s.Sel != nil && s.Sel.Obj == nil {\n-\t\t\t\t\tt.Errorf(\"%s: unresolved selector %s\", fset.Position(s.Sel.Pos()), s.Sel.Name)\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n-\t})\n-}"}, {"sha": "8ee28b0942b69cab01baef4e6203a6ce12c63c26", "filename": "libgo/go/exp/types/staging/testdata/exports.go", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftestdata%2Fexports.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,89 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file is used to generate an object file which\n-// serves as test file for gcimporter_test.go.\n-\n-package exports\n-\n-import (\n-\t\"go/ast\"\n-)\n-\n-// Issue 3682: Correctly read dotted identifiers from export data.\n-const init1 = 0\n-\n-func init() {}\n-\n-const (\n-\tC0 int = 0\n-\tC1     = 3.14159265\n-\tC2     = 2.718281828i\n-\tC3     = -123.456e-789\n-\tC4     = +123.456E+789\n-\tC5     = 1234i\n-\tC6     = \"foo\\n\"\n-\tC7     = `bar\\n`\n-)\n-\n-type (\n-\tT1  int\n-\tT2  [10]int\n-\tT3  []int\n-\tT4  *int\n-\tT5  chan int\n-\tT6a chan<- int\n-\tT6b chan (<-chan int)\n-\tT6c chan<- (chan int)\n-\tT7  <-chan *ast.File\n-\tT8  struct{}\n-\tT9  struct {\n-\t\ta    int\n-\t\tb, c float32\n-\t\td    []string `go:\"tag\"`\n-\t}\n-\tT10 struct {\n-\t\tT8\n-\t\tT9\n-\t\t_ *T10\n-\t}\n-\tT11 map[int]string\n-\tT12 interface{}\n-\tT13 interface {\n-\t\tm1()\n-\t\tm2(int) float32\n-\t}\n-\tT14 interface {\n-\t\tT12\n-\t\tT13\n-\t\tm3(x ...struct{}) []T9\n-\t}\n-\tT15 func()\n-\tT16 func(int)\n-\tT17 func(x int)\n-\tT18 func() float32\n-\tT19 func() (x float32)\n-\tT20 func(...interface{})\n-\tT21 struct{ next *T21 }\n-\tT22 struct{ link *T23 }\n-\tT23 struct{ link *T22 }\n-\tT24 *T24\n-\tT25 *T26\n-\tT26 *T27\n-\tT27 *T25\n-\tT28 func(T28) T28\n-)\n-\n-var (\n-\tV0 int\n-\tV1 = -991.0\n-)\n-\n-func F1()         {}\n-func F2(x int)    {}\n-func F3() int     { return 0 }\n-func F4() float32 { return 0 }\n-func F5(a, b, c int, u, v, w struct{ x, y T1 }, more ...interface{}) (p, q, r chan<- T10)\n-\n-func (p *T1) M1()"}, {"sha": "b6e7c1edb7a1eaaa24e377784249dbcc41c119a4", "filename": "libgo/go/exp/types/staging/types.go", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,235 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package types declares the data structures for representing\n-// Go types and implements typechecking of an *ast.Package.\n-//\n-// PACKAGE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\n-//\n-package types\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/token\"\n-\t\"sort\"\n-)\n-\n-// Check typechecks a package pkg. It returns the first error, or nil.\n-//\n-// Check augments the AST by assigning types to ast.Objects. It\n-// calls err with the error position and message for each error.\n-// It calls f with each valid AST expression and corresponding\n-// type. If err == nil, Check terminates as soon as the first error\n-// is found. If f is nil, it is not invoked.\n-//\n-func Check(fset *token.FileSet, pkg *ast.Package, err func(token.Pos, string), f func(ast.Expr, Type)) error {\n-\treturn check(fset, pkg, err, f)\n-}\n-\n-// All types implement the Type interface.\n-// TODO(gri) Eventually determine what common Type functionality should be exported.\n-type Type interface {\n-\taType()\n-}\n-\n-// BasicKind describes the kind of basic type.\n-type BasicKind int\n-\n-const (\n-\tInvalid BasicKind = iota // type is invalid\n-\n-\t// predeclared types\n-\tBool\n-\tInt\n-\tInt8\n-\tInt16\n-\tInt32\n-\tInt64\n-\tUint\n-\tUint8\n-\tUint16\n-\tUint32\n-\tUint64\n-\tUintptr\n-\tFloat32\n-\tFloat64\n-\tComplex64\n-\tComplex128\n-\tString\n-\tUnsafePointer\n-\n-\t// types for untyped values\n-\tUntypedBool\n-\tUntypedInt\n-\tUntypedRune\n-\tUntypedFloat\n-\tUntypedComplex\n-\tUntypedString\n-\tUntypedNil\n-\n-\t// aliases\n-\tByte = Uint8\n-\tRune = Int32\n-)\n-\n-// BasicInfo is a set of flags describing properties of a basic type.\n-type BasicInfo int\n-\n-// Properties of basic types.\n-const (\n-\tIsBoolean BasicInfo = 1 << iota\n-\tIsInteger\n-\tIsUnsigned\n-\tIsFloat\n-\tIsComplex\n-\tIsString\n-\tIsUntyped\n-\n-\tIsOrdered = IsInteger | IsFloat | IsString\n-\tIsNumeric = IsInteger | IsFloat | IsComplex\n-)\n-\n-// A Basic represents a basic type.\n-type Basic struct {\n-\timplementsType\n-\tKind BasicKind\n-\tInfo BasicInfo\n-\tSize int64 // > 0 if valid\n-\tName string\n-}\n-\n-// An Array represents an array type [Len]Elt.\n-type Array struct {\n-\timplementsType\n-\tLen int64\n-\tElt Type\n-}\n-\n-// A Slice represents a slice type []Elt.\n-type Slice struct {\n-\timplementsType\n-\tElt Type\n-}\n-\n-type StructField struct {\n-\tName        string // unqualified type name for anonymous fields\n-\tType        Type\n-\tTag         string\n-\tIsAnonymous bool\n-}\n-\n-// A Struct represents a struct type struct{...}.\n-type Struct struct {\n-\timplementsType\n-\tFields []*StructField\n-}\n-\n-// A Pointer represents a pointer type *Base.\n-type Pointer struct {\n-\timplementsType\n-\tBase Type\n-}\n-\n-// A tuple represents a multi-value function return.\n-// TODO(gri) use better name to avoid confusion (Go doesn't have tuples).\n-type tuple struct {\n-\timplementsType\n-\tlist []Type\n-}\n-\n-// A Signature represents a user-defined function type func(...) (...).\n-// TODO(gri) consider using \"tuples\" to represent parameters and results (see comment on tuples).\n-type Signature struct {\n-\timplementsType\n-\tRecv       *ast.Object // nil if not a method\n-\tParams     ObjList     // (incoming) parameters from left to right; or nil\n-\tResults    ObjList     // (outgoing) results from left to right; or nil\n-\tIsVariadic bool        // true if the last parameter's type is of the form ...T\n-}\n-\n-// builtinId is an id of a builtin function.\n-type builtinId int\n-\n-// Predeclared builtin functions.\n-const (\n-\t// Universe scope\n-\t_Append builtinId = iota\n-\t_Cap\n-\t_Close\n-\t_Complex\n-\t_Copy\n-\t_Delete\n-\t_Imag\n-\t_Len\n-\t_Make\n-\t_New\n-\t_Panic\n-\t_Print\n-\t_Println\n-\t_Real\n-\t_Recover\n-\n-\t// Unsafe package\n-\t_Alignof\n-\t_Offsetof\n-\t_Sizeof\n-\n-\t// Testing support\n-\t_Assert\n-\t_Trace\n-)\n-\n-// A builtin represents the type of a built-in function.\n-type builtin struct {\n-\timplementsType\n-\tid          builtinId\n-\tname        string\n-\tnargs       int // number of arguments (minimum if variadic)\n-\tisVariadic  bool\n-\tisStatement bool // true if the built-in is valid as an expression statement\n-}\n-\n-// An Interface represents an interface type interface{...}.\n-type Interface struct {\n-\timplementsType\n-\tMethods ObjList // interface methods sorted by name; or nil\n-}\n-\n-// A Map represents a map type map[Key]Elt.\n-type Map struct {\n-\timplementsType\n-\tKey, Elt Type\n-}\n-\n-// A Chan represents a channel type chan Elt, <-chan Elt, or chan<-Elt.\n-type Chan struct {\n-\timplementsType\n-\tDir ast.ChanDir\n-\tElt Type\n-}\n-\n-// A NamedType represents a named type as declared in a type declaration.\n-type NamedType struct {\n-\timplementsType\n-\tObj        *ast.Object // corresponding declared object\n-\tUnderlying Type        // nil if not fully declared yet, never a *NamedType\n-\tMethods    ObjList     // associated methods; or nil\n-}\n-\n-// An ObjList represents an ordered (in some fashion) list of objects.\n-type ObjList []*ast.Object\n-\n-// ObjList implements sort.Interface.\n-func (list ObjList) Len() int           { return len(list) }\n-func (list ObjList) Less(i, j int) bool { return list[i].Name < list[j].Name }\n-func (list ObjList) Swap(i, j int)      { list[i], list[j] = list[j], list[i] }\n-\n-// Sort sorts an object list by object name.\n-func (list ObjList) Sort() { sort.Sort(list) }\n-\n-// All concrete types embed implementsType which\n-// ensures that all types implement the Type interface.\n-type implementsType struct{}\n-\n-func (*implementsType) aType() {}"}, {"sha": "e6959bceeb0e0d260baec10cb014585ce0d1de27", "filename": "libgo/go/exp/types/staging/types_test.go", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Ftypes_test.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,181 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains tests verifying the types associated with an AST after\n-// type checking.\n-\n-package types\n-\n-import (\n-\t\"go/ast\"\n-\t\"go/parser\"\n-\t\"testing\"\n-)\n-\n-const filename = \"<src>\"\n-\n-func makePkg(t *testing.T, src string) (*ast.Package, error) {\n-\tfile, err := parser.ParseFile(fset, filename, src, parser.DeclarationErrors)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tfiles := map[string]*ast.File{filename: file}\n-\tpkg, err := ast.NewPackage(fset, files, GcImport, Universe)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif err := Check(fset, pkg, nil, nil); err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn pkg, nil\n-}\n-\n-type testEntry struct {\n-\tsrc, str string\n-}\n-\n-// dup returns a testEntry where both src and str are the same.\n-func dup(s string) testEntry {\n-\treturn testEntry{s, s}\n-}\n-\n-var testTypes = []testEntry{\n-\t// basic types\n-\tdup(\"int\"),\n-\tdup(\"float32\"),\n-\tdup(\"string\"),\n-\n-\t// arrays\n-\tdup(\"[10]int\"),\n-\n-\t// slices\n-\tdup(\"[]int\"),\n-\tdup(\"[][]int\"),\n-\n-\t// structs\n-\tdup(\"struct{}\"),\n-\tdup(\"struct{x int}\"),\n-\t{`struct {\n-\t\tx, y int\n-\t\tz float32 \"foo\"\n-\t}`, `struct{x int; y int; z float32 \"foo\"}`},\n-\t{`struct {\n-\t\tstring\n-\t\telems []T\n-\t}`, `struct{string; elems []T}`},\n-\n-\t// pointers\n-\tdup(\"*int\"),\n-\tdup(\"***struct{}\"),\n-\tdup(\"*struct{a int; b float32}\"),\n-\n-\t// functions\n-\tdup(\"func()\"),\n-\tdup(\"func(x int)\"),\n-\t{\"func(x, y int)\", \"func(x int, y int)\"},\n-\t{\"func(x, y int, z string)\", \"func(x int, y int, z string)\"},\n-\tdup(\"func(int)\"),\n-\t{\"func(int, string, byte)\", \"func(int, string, byte)\"},\n-\n-\tdup(\"func() int\"),\n-\t{\"func() (string)\", \"func() string\"},\n-\tdup(\"func() (u int)\"),\n-\t{\"func() (u, v int, w string)\", \"func() (u int, v int, w string)\"},\n-\n-\tdup(\"func(int) string\"),\n-\tdup(\"func(x int) string\"),\n-\tdup(\"func(x int) (u string)\"),\n-\t{\"func(x, y int) (u string)\", \"func(x int, y int) (u string)\"},\n-\n-\tdup(\"func(...int) string\"),\n-\tdup(\"func(x ...int) string\"),\n-\tdup(\"func(x ...int) (u string)\"),\n-\t{\"func(x, y ...int) (u string)\", \"func(x int, y ...int) (u string)\"},\n-\n-\t// interfaces\n-\tdup(\"interface{}\"),\n-\tdup(\"interface{m()}\"),\n-\t{`interface{\n-\t\tm(int) float32\n-\t\tString() string\n-\t}`, `interface{String() string; m(int) float32}`}, // methods are sorted\n-\t// TODO(gri) add test for interface w/ anonymous field\n-\n-\t// maps\n-\tdup(\"map[string]int\"),\n-\t{\"map[struct{x, y int}][]byte\", \"map[struct{x int; y int}][]byte\"},\n-\n-\t// channels\n-\tdup(\"chan int\"),\n-\tdup(\"chan<- func()\"),\n-\tdup(\"<-chan []func() int\"),\n-}\n-\n-func TestTypes(t *testing.T) {\n-\tfor _, test := range testTypes {\n-\t\tsrc := \"package p; type T \" + test.src\n-\t\tpkg, err := makePkg(t, src)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: %s\", src, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\ttyp := underlying(pkg.Scope.Lookup(\"T\").Type.(Type))\n-\t\tstr := typeString(typ)\n-\t\tif str != test.str {\n-\t\t\tt.Errorf(\"%s: got %s, want %s\", test.src, str, test.str)\n-\t\t}\n-\t}\n-}\n-\n-var testExprs = []testEntry{\n-\t// basic type literals\n-\tdup(\"x\"),\n-\tdup(\"true\"),\n-\tdup(\"42\"),\n-\tdup(\"3.1415\"),\n-\tdup(\"2.71828i\"),\n-\tdup(`'a'`),\n-\tdup(`\"foo\"`),\n-\tdup(\"`bar`\"),\n-\n-\t// arbitrary expressions\n-\tdup(\"&x\"),\n-\tdup(\"*x\"),\n-\tdup(\"(x)\"),\n-\tdup(\"x + y\"),\n-\tdup(\"x + y * 10\"),\n-\tdup(\"s.foo\"),\n-\tdup(\"s[0]\"),\n-\tdup(\"s[x:y]\"),\n-\tdup(\"s[:y]\"),\n-\tdup(\"s[x:]\"),\n-\tdup(\"s[:]\"),\n-\tdup(\"f(1, 2.3)\"),\n-\tdup(\"-f(10, 20)\"),\n-\tdup(\"f(x + y, +3.1415)\"),\n-\t{\"func(a, b int) {}\", \"(func literal)\"},\n-\t{\"func(a, b int) []int {}()[x]\", \"(func literal)()[x]\"},\n-\t{\"[]int{1, 2, 3}\", \"(composite literal)\"},\n-\t{\"[]int{1, 2, 3}[x:]\", \"(composite literal)[x:]\"},\n-\t{\"x.([]string)\", \"x.(...)\"},\n-}\n-\n-func TestExprs(t *testing.T) {\n-\tfor _, test := range testExprs {\n-\t\tsrc := \"package p; var _ = \" + test.src + \"; var (x, y int; s []string; f func(int, float32))\"\n-\t\tpkg, err := makePkg(t, src)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: %s\", src, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\t// TODO(gri) writing the code below w/o the decl variable will\n-\t\t//           cause a 386 compiler error (out of fixed registers)\n-\t\tdecl := pkg.Files[filename].Decls[0].(*ast.GenDecl)\n-\t\texpr := decl.Specs[0].(*ast.ValueSpec).Values[0]\n-\t\tstr := exprString(expr)\n-\t\tif str != test.str {\n-\t\t\tt.Errorf(\"%s: got %s, want %s\", test.src, str, test.str)\n-\t\t}\n-\t}\n-}"}, {"sha": "bb8b6a2bdacab89d7702a0999a3daecb4c7d45f5", "filename": "libgo/go/exp/types/staging/universe.go", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstaging%2Funiverse.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,159 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file implements the universe and unsafe package scopes.\n-\n-package types\n-\n-import (\n-\t\"go/ast\"\n-\t\"strings\"\n-)\n-\n-var (\n-\taType            implementsType\n-\tUniverse, unsafe *ast.Scope\n-\tUnsafe           *ast.Object // package unsafe\n-)\n-\n-// Predeclared types, indexed by BasicKind.\n-var Typ = [...]*Basic{\n-\tInvalid: {aType, Invalid, 0, 0, \"invalid type\"},\n-\n-\tBool:          {aType, Bool, IsBoolean, 1, \"bool\"},\n-\tInt:           {aType, Int, IsInteger, 0, \"int\"},\n-\tInt8:          {aType, Int8, IsInteger, 1, \"int8\"},\n-\tInt16:         {aType, Int16, IsInteger, 2, \"int16\"},\n-\tInt32:         {aType, Int32, IsInteger, 4, \"int32\"},\n-\tInt64:         {aType, Int64, IsInteger, 8, \"int64\"},\n-\tUint:          {aType, Uint, IsInteger | IsUnsigned, 0, \"uint\"},\n-\tUint8:         {aType, Uint8, IsInteger | IsUnsigned, 1, \"uint8\"},\n-\tUint16:        {aType, Uint16, IsInteger | IsUnsigned, 2, \"uint16\"},\n-\tUint32:        {aType, Uint32, IsInteger | IsUnsigned, 4, \"uint32\"},\n-\tUint64:        {aType, Uint64, IsInteger | IsUnsigned, 8, \"uint64\"},\n-\tUintptr:       {aType, Uintptr, IsInteger | IsUnsigned, 0, \"uintptr\"},\n-\tFloat32:       {aType, Float32, IsFloat, 4, \"float32\"},\n-\tFloat64:       {aType, Float64, IsFloat, 8, \"float64\"},\n-\tComplex64:     {aType, Complex64, IsComplex, 8, \"complex64\"},\n-\tComplex128:    {aType, Complex128, IsComplex, 16, \"complex128\"},\n-\tString:        {aType, String, IsString, 0, \"string\"},\n-\tUnsafePointer: {aType, UnsafePointer, 0, 0, \"Pointer\"},\n-\n-\tUntypedBool:    {aType, UntypedBool, IsBoolean | IsUntyped, 0, \"untyped boolean\"},\n-\tUntypedInt:     {aType, UntypedInt, IsInteger | IsUntyped, 0, \"untyped integer\"},\n-\tUntypedRune:    {aType, UntypedRune, IsInteger | IsUntyped, 0, \"untyped rune\"},\n-\tUntypedFloat:   {aType, UntypedFloat, IsFloat | IsUntyped, 0, \"untyped float\"},\n-\tUntypedComplex: {aType, UntypedComplex, IsComplex | IsUntyped, 0, \"untyped complex\"},\n-\tUntypedString:  {aType, UntypedString, IsString | IsUntyped, 0, \"untyped string\"},\n-\tUntypedNil:     {aType, UntypedNil, IsUntyped, 0, \"untyped nil\"},\n-}\n-\n-var aliases = [...]*Basic{\n-\t{aType, Byte, IsInteger | IsUnsigned, 1, \"byte\"},\n-\t{aType, Rune, IsInteger, 4, \"rune\"},\n-}\n-\n-var predeclaredConstants = [...]*struct {\n-\tkind BasicKind\n-\tname string\n-\tval  interface{}\n-}{\n-\t{UntypedBool, \"true\", true},\n-\t{UntypedBool, \"false\", false},\n-\t{UntypedInt, \"iota\", zeroConst},\n-\t{UntypedNil, \"nil\", nilConst},\n-}\n-\n-var predeclaredFunctions = [...]*builtin{\n-\t{aType, _Append, \"append\", 1, true, false},\n-\t{aType, _Cap, \"cap\", 1, false, false},\n-\t{aType, _Close, \"close\", 1, false, true},\n-\t{aType, _Complex, \"complex\", 2, false, false},\n-\t{aType, _Copy, \"copy\", 2, false, true},\n-\t{aType, _Delete, \"delete\", 2, false, true},\n-\t{aType, _Imag, \"imag\", 1, false, false},\n-\t{aType, _Len, \"len\", 1, false, false},\n-\t{aType, _Make, \"make\", 1, true, false},\n-\t{aType, _New, \"new\", 1, false, false},\n-\t{aType, _Panic, \"panic\", 1, false, true},\n-\t{aType, _Print, \"print\", 1, true, true},\n-\t{aType, _Println, \"println\", 1, true, true},\n-\t{aType, _Real, \"real\", 1, false, false},\n-\t{aType, _Recover, \"recover\", 0, false, true},\n-\n-\t{aType, _Alignof, \"Alignof\", 1, false, false},\n-\t{aType, _Offsetof, \"Offsetof\", 1, false, false},\n-\t{aType, _Sizeof, \"Sizeof\", 1, false, false},\n-}\n-\n-// commonly used types\n-var (\n-\temptyInterface = new(Interface)\n-)\n-\n-// commonly used constants\n-var (\n-\tuniverseIota *ast.Object\n-)\n-\n-func init() {\n-\t// Universe scope\n-\tUniverse = ast.NewScope(nil)\n-\n-\t// unsafe package and its scope\n-\tunsafe = ast.NewScope(nil)\n-\tUnsafe = ast.NewObj(ast.Pkg, \"unsafe\")\n-\tUnsafe.Data = unsafe\n-\n-\t// predeclared types\n-\tfor _, t := range Typ {\n-\t\tdef(ast.Typ, t.Name).Type = t\n-\t}\n-\tfor _, t := range aliases {\n-\t\tdef(ast.Typ, t.Name).Type = t\n-\t}\n-\n-\t// error type\n-\t{\n-\t\tobj := def(ast.Typ, \"error\")\n-\t\t// TODO(gri) set up correct interface type\n-\t\ttyp := &NamedType{Underlying: &Interface{}, Obj: obj}\n-\t\tobj.Type = typ\n-\t}\n-\n-\t// predeclared constants\n-\tfor _, t := range predeclaredConstants {\n-\t\tobj := def(ast.Con, t.name)\n-\t\tobj.Type = Typ[t.kind]\n-\t\tobj.Data = t.val\n-\t}\n-\n-\t// predeclared functions\n-\tfor _, f := range predeclaredFunctions {\n-\t\tdef(ast.Fun, f.name).Type = f\n-\t}\n-\n-\tuniverseIota = Universe.Lookup(\"iota\")\n-}\n-\n-// Objects with names containing blanks are internal and not entered into\n-// a scope. Objects with exported names are inserted in the unsafe package\n-// scope; other objects are inserted in the universe scope.\n-//\n-func def(kind ast.ObjKind, name string) *ast.Object {\n-\tobj := ast.NewObj(kind, name)\n-\t// insert non-internal objects into respective scope\n-\tif strings.Index(name, \" \") < 0 {\n-\t\tscope := Universe\n-\t\t// exported identifiers go into package unsafe\n-\t\tif ast.IsExported(name) {\n-\t\t\tscope = unsafe\n-\t\t}\n-\t\tif scope.Insert(obj) != nil {\n-\t\t\tpanic(\"internal error: double declaration\")\n-\t\t}\n-\t\tobj.Decl = scope\n-\t}\n-\treturn obj\n-}"}, {"sha": "4f012499a206dd91037a2f6aceee2a9792c40360", "filename": "libgo/go/exp/types/stmt.go", "status": "renamed", "additions": 126, "deletions": 148, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -27,183 +27,112 @@ func (check *checker) assignOperand(z, x *operand) {\n \t}\n }\n \n-// assignment typechecks a single assignment of the form lhs := x. If decl is set,\n-// the lhs operand must be an identifier. If its type is not set, it is deduced\n-// from the type or value of x.\n+// assign1to1 typechecks a single assignment of the form lhs := rhs (if rhs != nil),\n+// or lhs := x (if rhs == nil). If decl is set, the lhs operand must be an identifier.\n+// If its type is not set, it is deduced from the type or value of x. If lhs has a\n+// type it is used as a hint when evaluating rhs, if present.\n //\n-func (check *checker) assignment(lhs ast.Expr, x *operand, decl bool) {\n-\tif decl {\n-\t\tident, ok := lhs.(*ast.Ident)\n-\t\tif !ok {\n-\t\t\tcheck.errorf(lhs.Pos(), \"cannot declare %s\", lhs)\n-\t\t\treturn\n-\t\t}\n-\n-\t\tobj := ident.Obj\n-\t\tif obj.Type == nil {\n-\t\t\t// determine type from rhs expression\n-\t\t\tvar typ Type = Typ[Invalid]\n-\t\t\tif x.mode != invalid {\n-\t\t\t\ttyp = x.typ\n-\t\t\t\t// determine the default type for variables\n-\t\t\t\tif obj.Kind == ast.Var && isUntyped(typ) {\n-\t\t\t\t\ttyp = defaultType(typ)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tobj.Type = typ\n-\t\t}\n-\n-\t\tvar z operand\n-\t\tswitch obj.Kind {\n-\t\tcase ast.Con:\n-\t\t\tz.mode = constant\n-\t\tcase ast.Var:\n-\t\t\tz.mode = variable\n-\t\tdefault:\n-\t\t\tunreachable()\n-\t\t}\n-\t\tz.expr = ident\n-\t\tz.typ = obj.Type.(Type)\n-\n-\t\tcheck.assignOperand(&z, x)\n-\n-\t\t// for constants, set the constant value\n-\t\tif obj.Kind == ast.Con {\n-\t\t\tassert(obj.Data == nil)\n-\t\t\tif x.mode != invalid && x.mode != constant {\n-\t\t\t\tcheck.errorf(x.pos(), \"%s is not constant\", x) // TODO(gri) better error position\n-\t\t\t\tx.mode = invalid\n-\t\t\t}\n-\t\t\tif x.mode == constant {\n-\t\t\t\tobj.Data = x.val\n-\t\t\t} else {\n-\t\t\t\t// set the constant to the type's zero value to reduce spurious errors\n-\t\t\t\t// TODO(gri) factor this out - useful elsewhere\n-\t\t\t\tswitch typ := underlying(obj.Type.(Type)); {\n-\t\t\t\tcase typ == Typ[Invalid]:\n-\t\t\t\t\t// ignore\n-\t\t\t\tcase isBoolean(typ):\n-\t\t\t\t\tobj.Data = false\n-\t\t\t\tcase isNumeric(typ):\n-\t\t\t\t\tobj.Data = int64(0)\n-\t\t\t\tcase isString(typ):\n-\t\t\t\t\tobj.Data = \"\"\n-\t\t\t\tdefault:\n-\t\t\t\t\tcheck.dump(\"%s: typ(%s) = %s\", obj.Pos(), obj.Name, typ)\n-\t\t\t\t\tunreachable()\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn\n-\t}\n-\n-\t// regular assignment\n-\tvar z operand\n-\tcheck.expr(&z, lhs, nil, -1)\n-\tcheck.assignOperand(&z, x)\n-\tif x.mode != invalid && z.mode == constant {\n-\t\tcheck.errorf(x.pos(), \"cannot assign %s to %s\", x, z)\n-\t}\n-}\n-\n-func (check *checker) assign1to1(lhs, rhs ast.Expr, decl bool, iota int) {\n+func (check *checker) assign1to1(lhs, rhs ast.Expr, x *operand, decl bool, iota int) {\n \tident, _ := lhs.(*ast.Ident)\n+\tif x == nil {\n+\t\tassert(rhs != nil)\n+\t\tx = new(operand)\n+\t}\n \n \tif ident != nil && ident.Name == \"_\" {\n-\t\t// anything can be assigned to a blank identifier - check rhs only\n-\t\tvar x operand\n-\t\tcheck.expr(&x, rhs, nil, iota)\n+\t\t// anything can be assigned to a blank identifier - check rhs only, if present\n+\t\tif rhs != nil {\n+\t\t\tcheck.expr(x, rhs, nil, iota)\n+\t\t}\n \t\treturn\n \t}\n \n \tif !decl {\n-\t\t// regular assignment - start with lhs[0] to obtain a type hint\n+\t\t// regular assignment - start with lhs to obtain a type hint\n \t\tvar z operand\n \t\tcheck.expr(&z, lhs, nil, -1)\n \t\tif z.mode == invalid {\n \t\t\tz.typ = nil // so we can proceed with rhs\n \t\t}\n \n-\t\tvar x operand\n-\t\tcheck.expr(&x, rhs, z.typ, -1)\n-\t\tif x.mode == invalid {\n-\t\t\treturn\n+\t\tif rhs != nil {\n+\t\t\tcheck.expr(x, rhs, z.typ, -1)\n+\t\t\tif x.mode == invalid {\n+\t\t\t\treturn\n+\t\t\t}\n \t\t}\n \n-\t\tcheck.assignOperand(&z, &x)\n+\t\tcheck.assignOperand(&z, x)\n+\t\tif x.mode != invalid && z.mode == constant {\n+\t\t\tcheck.errorf(x.pos(), \"cannot assign %s to %s\", x, &z)\n+\t\t}\n \t\treturn\n \t}\n \n-\t// declaration - rhs may or may not be typed yet\n+\t// declaration - lhs must be an identifier\n \tif ident == nil {\n \t\tcheck.errorf(lhs.Pos(), \"cannot declare %s\", lhs)\n \t\treturn\n \t}\n \n+\t// lhs may or may not be typed yet\n \tobj := ident.Obj\n \tvar typ Type\n \tif obj.Type != nil {\n \t\ttyp = obj.Type.(Type)\n \t}\n \n-\tvar x operand\n-\tcheck.expr(&x, rhs, typ, iota)\n-\tif x.mode == invalid {\n-\t\treturn\n+\tif rhs != nil {\n+\t\tcheck.expr(x, rhs, typ, iota)\n+\t\t// continue even if x.mode == invalid\n \t}\n \n \tif typ == nil {\n \t\t// determine lhs type from rhs expression;\n \t\t// for variables, convert untyped types to\n \t\t// default types\n-\t\ttyp = x.typ\n-\t\tif obj.Kind == ast.Var && isUntyped(typ) {\n-\t\t\t// TODO(gri) factor this out\n-\t\t\tvar k BasicKind\n-\t\t\tswitch typ.(*Basic).Kind {\n-\t\t\tcase UntypedBool:\n-\t\t\t\tk = Bool\n-\t\t\tcase UntypedRune:\n-\t\t\t\tk = Rune\n-\t\t\tcase UntypedInt:\n-\t\t\t\tk = Int\n-\t\t\tcase UntypedFloat:\n-\t\t\t\tk = Float64\n-\t\t\tcase UntypedComplex:\n-\t\t\t\tk = Complex128\n-\t\t\tcase UntypedString:\n-\t\t\t\tk = String\n-\t\t\tdefault:\n-\t\t\t\tunreachable()\n+\t\ttyp = Typ[Invalid]\n+\t\tif x.mode != invalid {\n+\t\t\ttyp = x.typ\n+\t\t\tif obj.Kind == ast.Var && isUntyped(typ) {\n+\t\t\t\ttyp = defaultType(typ)\n \t\t\t}\n-\t\t\ttyp = Typ[k]\n \t\t}\n \t\tobj.Type = typ\n \t}\n \n-\tvar z operand\n-\tswitch obj.Kind {\n-\tcase ast.Con:\n-\t\tz.mode = constant\n-\tcase ast.Var:\n-\t\tz.mode = variable\n-\tdefault:\n-\t\tunreachable()\n+\tif x.mode != invalid {\n+\t\tvar z operand\n+\t\tswitch obj.Kind {\n+\t\tcase ast.Con:\n+\t\t\tz.mode = constant\n+\t\tcase ast.Var:\n+\t\t\tz.mode = variable\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\tz.expr = ident\n+\t\tz.typ = typ\n+\t\tcheck.assignOperand(&z, x)\n \t}\n-\tz.expr = ident\n-\tz.typ = typ\n-\n-\tcheck.assignOperand(&z, &x)\n \n \t// for constants, set their value\n \tif obj.Kind == ast.Con {\n \t\tassert(obj.Data == nil)\n-\t\tif x.mode != constant {\n-\t\t\tcheck.errorf(x.pos(), \"%s is not constant\", x)\n-\t\t\t// set the constant to the type's zero value to reduce spurious errors\n-\t\t\t// TODO(gri) factor this out - useful elsewhere\n-\t\t\tswitch typ := underlying(typ); {\n+\t\tif x.mode != invalid {\n+\t\t\tif x.mode == constant {\n+\t\t\t\tif isConstType(x.typ) {\n+\t\t\t\t\tobj.Data = x.val\n+\t\t\t\t} else {\n+\t\t\t\t\tcheck.errorf(x.pos(), \"%s has invalid constant type\", x)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcheck.errorf(x.pos(), \"%s is not constant\", x)\n+\t\t\t}\n+\t\t}\n+\t\tif obj.Data == nil {\n+\t\t\t// set the constant to its type's zero value to reduce spurious errors\n+\t\t\tswitch typ := underlying(obj.Type.(Type)); {\n \t\t\tcase typ == Typ[Invalid]:\n \t\t\t\t// ignore\n \t\t\tcase isBoolean(typ):\n@@ -212,12 +141,13 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, decl bool, iota int) {\n \t\t\t\tobj.Data = int64(0)\n \t\t\tcase isString(typ):\n \t\t\t\tobj.Data = \"\"\n+\t\t\tcase hasNil(typ):\n+\t\t\t\tobj.Data = nilConst\n \t\t\tdefault:\n-\t\t\t\tunreachable()\n+\t\t\t\t// in all other cases just prevent use of the constant\n+\t\t\t\tobj.Kind = ast.Bad\n \t\t\t}\n-\t\t\treturn\n \t\t}\n-\t\tobj.Data = x.val\n \t}\n }\n \n@@ -228,18 +158,18 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, decl bool, iota int) {\n // Precondition: len(lhs) > 0 .\n //\n func (check *checker) assignNtoM(lhs, rhs []ast.Expr, decl bool, iota int) {\n-\tassert(len(lhs) >= 1)\n+\tassert(len(lhs) > 0)\n \n \tif len(lhs) == len(rhs) {\n \t\tfor i, e := range rhs {\n-\t\t\tcheck.assign1to1(lhs[i], e, decl, iota)\n+\t\t\tcheck.assign1to1(lhs[i], e, nil, decl, iota)\n \t\t}\n \t\treturn\n \t}\n \n \tif len(rhs) == 1 {\n-\t\t// len(lhs) >= 2; therefore a correct rhs expression\n-\t\t// cannot be a shift and we don't need a type hint -\n+\t\t// len(lhs) > 1, therefore a correct rhs expression\n+\t\t// cannot be a shift and we don't need a type hint;\n \t\t// ok to evaluate rhs first\n \t\tvar x operand\n \t\tcheck.expr(&x, rhs[0], nil, iota)\n@@ -253,19 +183,19 @@ func (check *checker) assignNtoM(lhs, rhs []ast.Expr, decl bool, iota int) {\n \t\t\tfor i, typ := range t.list {\n \t\t\t\tx.expr = nil // TODO(gri) should do better here\n \t\t\t\tx.typ = typ\n-\t\t\t\tcheck.assignment(lhs[i], &x, decl)\n+\t\t\t\tcheck.assign1to1(lhs[i], nil, &x, decl, iota)\n \t\t\t}\n \t\t\treturn\n \t\t}\n \n \t\tif x.mode == valueok && len(lhs) == 2 {\n \t\t\t// comma-ok expression\n \t\t\tx.mode = value\n-\t\t\tcheck.assignment(lhs[0], &x, decl)\n+\t\t\tcheck.assign1to1(lhs[0], nil, &x, decl, iota)\n \n \t\t\tx.mode = value\n \t\t\tx.typ = Typ[UntypedBool]\n-\t\t\tcheck.assignment(lhs[1], &x, decl)\n+\t\t\tcheck.assign1to1(lhs[1], nil, &x, decl, iota)\n \t\t\treturn\n \t\t}\n \t}\n@@ -303,10 +233,11 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t// ignore\n \n \tcase *ast.DeclStmt:\n-\t\tunimplemented()\n+\t\tcheck.decl(s.Decl)\n \n \tcase *ast.LabeledStmt:\n-\t\tunimplemented()\n+\t\t// TODO(gri) anything to do with label itself?\n+\t\tcheck.stmt(s.Stmt)\n \n \tcase *ast.ExprStmt:\n \t\tvar x operand\n@@ -332,7 +263,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\tcheck.errorf(s.Pos(), \"%s not used\", s.X)\n \t\t\t// ok to continue\n \t\t}\n-\t\tcheck.exprOrType(&x, s.X, nil, -1, false)\n+\t\tcheck.rawExpr(&x, s.X, nil, -1, false)\n \t\tif x.mode == typexpr {\n \t\t\tcheck.errorf(x.pos(), \"%s is not an expression\", x)\n \t\t}\n@@ -349,7 +280,21 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t}\n \n \tcase *ast.IncDecStmt:\n-\t\tunimplemented()\n+\t\tvar op token.Token\n+\t\tswitch s.Tok {\n+\t\tcase token.INC:\n+\t\t\top = token.ADD\n+\t\tcase token.DEC:\n+\t\t\top = token.SUB\n+\t\tdefault:\n+\t\t\tcheck.invalidAST(s.TokPos, \"unknown inc/dec operation %s\", s.Tok)\n+\t\t\treturn\n+\t\t}\n+\t\tvar x, y operand\n+\t\tcheck.expr(&x, s.X, nil, -1)\n+\t\tcheck.expr(&y, &ast.BasicLit{ValuePos: x.pos(), Kind: token.INT, Value: \"1\"}, nil, -1) // use x's position\n+\t\tcheck.binary(&x, &y, op, nil)\n+\t\tcheck.assign1to1(s.X, nil, &x, false, -1)\n \n \tcase *ast.AssignStmt:\n \t\tswitch s.Tok {\n@@ -390,12 +335,15 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\t\t\top = token.SHR\n \t\t\tcase token.AND_NOT_ASSIGN:\n \t\t\t\top = token.AND_NOT\n+\t\t\tdefault:\n+\t\t\t\tcheck.invalidAST(s.TokPos, \"unknown assignment operation %s\", s.Tok)\n+\t\t\t\treturn\n \t\t\t}\n \t\t\tvar x, y operand\n \t\t\tcheck.expr(&x, s.Lhs[0], nil, -1)\n \t\t\tcheck.expr(&y, s.Rhs[0], nil, -1)\n \t\t\tcheck.binary(&x, &y, op, nil)\n-\t\t\tcheck.assignment(s.Lhs[0], &x, false)\n+\t\t\tcheck.assign1to1(s.Lhs[0], nil, &x, false, -1)\n \t\t}\n \n \tcase *ast.GoStmt:\n@@ -405,7 +353,28 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\tunimplemented()\n \n \tcase *ast.ReturnStmt:\n-\t\tunimplemented()\n+\t\tsig := check.functypes[len(check.functypes)-1]\n+\t\tif n := len(sig.Results); n > 0 {\n+\t\t\t// TODO(gri) should not have to compute lhs, named every single time - clean this up\n+\t\t\tlhs := make([]ast.Expr, n)\n+\t\t\tnamed := false // if set, function has named results\n+\t\t\tfor i, res := range sig.Results {\n+\t\t\t\tif len(res.Name) > 0 {\n+\t\t\t\t\t// a blank (_) result parameter is a named result parameter!\n+\t\t\t\t\tnamed = true\n+\t\t\t\t}\n+\t\t\t\tname := ast.NewIdent(res.Name)\n+\t\t\t\tname.NamePos = s.Pos()\n+\t\t\t\tname.Obj = res\n+\t\t\t\tlhs[i] = name\n+\t\t\t}\n+\t\t\tif len(s.Results) > 0 || !named {\n+\t\t\t\t// TODO(gri) assignNtoM should perhaps not require len(lhs) > 0\n+\t\t\t\tcheck.assignNtoM(lhs, s.Results, false, -1)\n+\t\t\t}\n+\t\t} else if len(s.Results) > 0 {\n+\t\t\tcheck.errorf(s.Pos(), \"no result values expected\")\n+\t\t}\n \n \tcase *ast.BranchStmt:\n \t\tunimplemented()\n@@ -429,6 +398,7 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\tif s.Tag != nil {\n \t\t\tcheck.expr(&x, s.Tag, nil, -1)\n \t\t} else {\n+\t\t\t// TODO(gri) should provide a position (see IncDec) for good error messages\n \t\t\tx.mode = constant\n \t\t\tx.typ = Typ[UntypedBool]\n \t\t\tx.val = true\n@@ -450,7 +420,15 @@ func (check *checker) stmt(s ast.Stmt) {\n \t\tunimplemented()\n \n \tcase *ast.SelectStmt:\n-\t\tunimplemented()\n+\t\tfor _, s := range s.Body.List {\n+\t\t\tc, ok := s.(*ast.CommClause)\n+\t\t\tif !ok {\n+\t\t\t\tcheck.invalidAST(s.Pos(), \"communication clause expected\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcheck.optionalStmt(c.Comm) // TODO(gri) check correctness of c.Comm (must be Send/RecvStmt)\n+\t\t\tcheck.stmtList(c.Body)\n+\t\t}\n \n \tcase *ast.ForStmt:\n \t\tcheck.optionalStmt(s.Init)", "previous_filename": "libgo/go/exp/types/staging/stmt.go"}, {"sha": "a07af89f414621e39cea8844f92157f4d41d9fa6", "filename": "libgo/go/exp/types/testdata/builtins.src", "status": "renamed", "additions": 73, "deletions": 68, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fbuiltins.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fbuiltins.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fbuiltins.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -68,11 +68,11 @@ func _imag() {\n \tvar f64 float64\n \tvar c64 complex64\n \tvar c128 complex128\n-\t_0 := imag /* ERROR \"argument\" */ ()\n-\t_1 := imag /* ERROR \"argument\" */ (1, 2)\n-\t_2 := imag(10 /* ERROR \"must be a complex number\" */)\n-\t_3 := imag(2.7182818 /* ERROR \"must be a complex number\" */)\n-\t_4 := imag(\"foo\" /* ERROR \"must be a complex number\" */)\n+\t_ = imag /* ERROR \"argument\" */ ()\n+\t_ = imag /* ERROR \"argument\" */ (1, 2)\n+\t_ = imag(10 /* ERROR \"must be a complex number\" */)\n+\t_ = imag(2.7182818 /* ERROR \"must be a complex number\" */)\n+\t_ = imag(\"foo\" /* ERROR \"must be a complex number\" */)\n \tconst _5 = imag(1 + 2i)\n \tassert(_5 == 2)\n \tf32 = _5\n@@ -92,16 +92,16 @@ func _len() {\n \tvar p *[20]int\n \tvar s []int\n \tvar m map[string]complex128\n-\t_0 := len /* ERROR \"argument\" */ ()\n-\t_1 := len /* ERROR \"argument\" */ (1, 2)\n-\t_2 := len(42 /* ERROR \"invalid\" */)\n+\t_ = len /* ERROR \"argument\" */ ()\n+\t_ = len /* ERROR \"argument\" */ (1, 2)\n+\t_ = len(42 /* ERROR \"invalid\" */)\n \tconst _3 = len(c)\n \tassert(_3 == 6)\n \tconst _4 = len(a)\n \tassert(_4 == 10)\n \tconst _5 = len(p)\n \tassert(_5 == 20)\n-\t_6 := len(m)\n+\t_ = len(m)\n \tlen /* ERROR \"not used\" */ (c)\n \n \t// esoteric case\n@@ -111,54 +111,59 @@ func _len() {\n \tassert /* ERROR \"failed\" */ (n == 10)\n \tvar ch <-chan int\n \tconst nn = len /* ERROR \"not constant\" */ (hash[<-ch][len(t)])\n-\t_7 := nn // TODO(gri) remove this once unused constants get type-checked\n+\t_ = nn // TODO(gri) remove this once unused constants get type-checked\n }\n \n func _make() {\n \tn := 0\n \n-\t_0 := make /* ERROR \"argument\" */ ()\n-\t_1 := make(1 /* ERROR \"not a type\" */)\n-\t_2 := make(int /* ERROR \"cannot make\" */)\n+\t_ = make /* ERROR \"argument\" */ ()\n+\t_ = make(1 /* ERROR \"not a type\" */)\n+\t_ = make(int /* ERROR \"cannot make\" */)\n \n \t// slices\n-\t_3 := make/* ERROR \"arguments\" */ ([]int)\n-\t_4 := make/* ERROR \"arguments\" */ ([]int, 2, 3, 4)\n-\t_5 := make([]int, int /* ERROR \"not an expression\" */)\n-\t_6 := make([]int, 10, float32 /* ERROR \"not an expression\" */)\n-\t_7 := make([]int, \"foo\" /* ERROR \"must be an integer\" */)\n-\t_8 := make([]int, 10, 2.3 /* ERROR \"must be an integer\" */)\n-\t_9 := make([]int, 5, 10.0)\n-\t_10 := make([]int, 0i)\n-\t_11 := make([]int, -1, 1<<100) // out-of-range constants lead to run-time errors\n+\t_ = make/* ERROR \"arguments\" */ ([]int)\n+\t_ = make/* ERROR \"arguments\" */ ([]int, 2, 3, 4)\n+\t_ = make([]int, int /* ERROR \"not an expression\" */)\n+\t_ = make([]int, 10, float32 /* ERROR \"not an expression\" */)\n+\t_ = make([]int, \"foo\" /* ERROR \"must be an integer\" */)\n+\t_ = make([]int, 10, 2.3 /* ERROR \"must be an integer\" */)\n+\t_ = make([]int, 5, 10.0)\n+\t_ = make([]int, 0i)\n+\t_ = make([]int, - /* ERROR \"must not be negative\" */ 1, 10)\n+\t_ = make([]int, 0, - /* ERROR \"must not be negative\" */ 1)\n+\t_ = make([]int, - /* ERROR \"must not be negative\" */ 1, - /* ERROR \"must not be negative\" */ 1)\n+\t_ = make([]int, 1<<100, 1<<100)  // run-time panic\n+\t_ = make([]int, 1 /* ERROR \"length and capacity swapped\" */ <<100 + 1, 1<<100)\n+\t_ = make([]int, 1 /* ERROR \"length and capacity swapped\" */ <<100, 12345)\n \n \t// maps\n-\t_12 := make /* ERROR \"arguments\" */ (map[int]string, 10, 20)\n-\t_13 := make(map[int]float32, int /* ERROR \"not an expression\" */)\n-\t_14 := make(map[int]float32, \"foo\" /* ERROR \"must be an integer\" */)\n-\t_15 := make(map[int]float32, 10)\n-\t_16 := make(map[int]float32, n)\n-\t_17 := make(map[int]float32, int64(n))\n+\t_ = make /* ERROR \"arguments\" */ (map[int]string, 10, 20)\n+\t_ = make(map[int]float32, int /* ERROR \"not an expression\" */)\n+\t_ = make(map[int]float32, \"foo\" /* ERROR \"must be an integer\" */)\n+\t_ = make(map[int]float32, 10)\n+\t_ = make(map[int]float32, n)\n+\t_ = make(map[int]float32, int64(n))\n \n \t// channels\n-\t_22 := make /* ERROR \"arguments\" */ (chan int, 10, 20)\n-\t_23 := make(chan int, int /* ERROR \"not an expression\" */)\n-\t_24 := make(chan<- int, \"foo\" /* ERROR \"must be an integer\" */)\n-\t_25 := make(<-chan float64, 10)\n-\t_26 := make(chan chan int, n)\n-\t_27 := make(chan string, int64(n))\n+\t_ = make /* ERROR \"arguments\" */ (chan int, 10, 20)\n+\t_ = make(chan int, int /* ERROR \"not an expression\" */)\n+\t_ = make(chan<- int, \"foo\" /* ERROR \"must be an integer\" */)\n+\t_ = make(<-chan float64, 10)\n+\t_ = make(chan chan int, n)\n+\t_ = make(chan string, int64(n))\n \n \tmake /* ERROR \"not used\" */ ([]int, 10)\n }\n \n func _new() {\n-\t_0 := new /* ERROR \"argument\" */ ()\n-\t_1 := new /* ERROR \"argument\" */ (1, 2)\n-\t_3 := new(\"foo\" /* ERROR \"not a type\" */)\n-\t_4 := new(float64)\n-\t_5 := new(struct{ x, y int })\n-\t_6 := new(*float64)\n-\t_7 := *_4 == **_6\n+\t_ = new /* ERROR \"argument\" */ ()\n+\t_ = new /* ERROR \"argument\" */ (1, 2)\n+\t_ = new(\"foo\" /* ERROR \"not a type\" */)\n+\tp := new(float64)\n+\t_ = new(struct{ x, y int })\n+\tq := new(*float64)\n+\t_ = *p == **q\n \tnew /* ERROR \"not used\" */ (int)\n }\n \n@@ -167,11 +172,11 @@ func _real() {\n \tvar f64 float64\n \tvar c64 complex64\n \tvar c128 complex128\n-\t_0 := real /* ERROR \"argument\" */ ()\n-\t_1 := real /* ERROR \"argument\" */ (1, 2)\n-\t_2 := real(10 /* ERROR \"must be a complex number\" */)\n-\t_3 := real(2.7182818 /* ERROR \"must be a complex number\" */)\n-\t_4 := real(\"foo\" /* ERROR \"must be a complex number\" */)\n+\t_ = real /* ERROR \"argument\" */ ()\n+\t_ = real /* ERROR \"argument\" */ (1, 2)\n+\t_ = real(10 /* ERROR \"must be a complex number\" */)\n+\t_ = real(2.7182818 /* ERROR \"must be a complex number\" */)\n+\t_ = real(\"foo\" /* ERROR \"must be a complex number\" */)\n \tconst _5 = real(1 + 2i)\n \tassert(_5 == 1)\n \tf32 = _5\n@@ -186,40 +191,40 @@ func _real() {\n }\n \n func _recover() {\n-\t_0 := recover()\n-\t_1 := recover /* ERROR \"argument\" */ (10)\n+\t_ = recover()\n+\t_ = recover /* ERROR \"argument\" */ (10)\n \trecover()\n }\n \n func _Alignof() {\n \tvar x int\n-\t_0 := unsafe /* ERROR \"argument\" */ .Alignof()\n-\t_1 := unsafe /* ERROR \"argument\" */ .Alignof(1, 2)\n-\t_3 := unsafe.Alignof(int /* ERROR \"not an expression\" */)\n-\t_4 := unsafe.Alignof(42)\n-\t_5 := unsafe.Alignof(new(struct{}))\n+\t_ = unsafe /* ERROR \"argument\" */ .Alignof()\n+\t_ = unsafe /* ERROR \"argument\" */ .Alignof(1, 2)\n+\t_ = unsafe.Alignof(int /* ERROR \"not an expression\" */)\n+\t_ = unsafe.Alignof(42)\n+\t_ = unsafe.Alignof(new(struct{}))\n \tunsafe /* ERROR \"not used\" */ .Alignof(x)\n }\n \n func _Offsetof() {\n \tvar x struct{ f int }\n-\t_0 := unsafe /* ERROR \"argument\" */ .Offsetof()\n-\t_1 := unsafe /* ERROR \"argument\" */ .Offsetof(1, 2)\n-\t_2 := unsafe.Offsetof(int /* ERROR \"not an expression\" */)\n-\t_3 := unsafe.Offsetof(x /* ERROR \"not a selector\" */)\n-\t_4 := unsafe.Offsetof(x.f)\n-\t_5 := unsafe.Offsetof((x.f))\n-\t_6 := unsafe.Offsetof((((((((x))).f)))))\n+\t_ = unsafe /* ERROR \"argument\" */ .Offsetof()\n+\t_ = unsafe /* ERROR \"argument\" */ .Offsetof(1, 2)\n+\t_ = unsafe.Offsetof(int /* ERROR \"not an expression\" */)\n+\t_ = unsafe.Offsetof(x /* ERROR \"not a selector\" */)\n+\t_ = unsafe.Offsetof(x.f)\n+\t_ = unsafe.Offsetof((x.f))\n+\t_ = unsafe.Offsetof((((((((x))).f)))))\n \tunsafe /* ERROR \"not used\" */ .Offsetof(x.f)\n }\n \n func _Sizeof() {\n \tvar x int\n-\t_0 := unsafe /* ERROR \"argument\" */ .Sizeof()\n-\t_1 := unsafe /* ERROR \"argument\" */ .Sizeof(1, 2)\n-\t_2 := unsafe.Sizeof(int /* ERROR \"not an expression\" */)\n-\t_3 := unsafe.Sizeof(42)\n-\t_4 := unsafe.Sizeof(new(complex128))\n+\t_ = unsafe /* ERROR \"argument\" */ .Sizeof()\n+\t_ = unsafe /* ERROR \"argument\" */ .Sizeof(1, 2)\n+\t_ = unsafe.Sizeof(int /* ERROR \"not an expression\" */)\n+\t_ = unsafe.Sizeof(42)\n+\t_ = unsafe.Sizeof(new(complex128))\n \tunsafe /* ERROR \"not used\" */ .Sizeof(x)\n \n \t// basic types have size guarantees\n@@ -252,7 +257,7 @@ func _assert() {\n // self-testing only\n func _trace() {\n \t// Uncomment the code below to test trace - will produce console output\n-\t// _0 := trace /* ERROR \"no value\" */ ()\n-\t// _1 := trace(1)\n-\t// _2 := trace(true, 1.2, '\\'', \"foo\", 42i, \"foo\" <= \"bar\")\n+\t// _ = trace /* ERROR \"no value\" */ ()\n+\t// _ = trace(1)\n+\t// _ = trace(true, 1.2, '\\'', \"foo\", 42i, \"foo\" <= \"bar\")\n }", "previous_filename": "libgo/go/exp/types/staging/testdata/builtins.src"}, {"sha": "a2ca344c788e6c0eb98090d6f62e68bbfa3caea5", "filename": "libgo/go/exp/types/testdata/const0.src", "status": "renamed", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fconst0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fconst0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fconst0.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -206,4 +206,10 @@ const (\n const (\n \t_b0 = iota\n \t_b1 = assert(iota + iota2 == 5)\n+)\n+\n+// special cases\n+const (\n+\t_n0 = nil /* ERROR \"invalid constant type\" */\n+\t_n1 = [ /* ERROR \"not constant\" */ ]int{}\n )\n\\ No newline at end of file", "previous_filename": "libgo/go/exp/types/staging/testdata/const0.src"}, {"sha": "1b1518366f34d09ce6a90f8093ba21c05923aa29", "filename": "libgo/go/exp/types/testdata/conversions.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fconversions.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fconversions.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fconversions.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "previous_filename": "libgo/go/exp/types/staging/testdata/conversions.src"}, {"sha": "3537a9e55832be4c6fdcdd6d6b633e46a8f38279", "filename": "libgo/go/exp/types/testdata/decls0.src", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls0.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -16,7 +16,7 @@ import (\n const pi = 3.1415\n \n type (\n-\tN undeclared /* ERROR \"undeclared\" */ /* ERROR \"not a type\" */\n+\tN undeclared /* ERROR \"undeclared\" */\n \tB bool\n \tI int32\n \tA [10]P\n@@ -41,7 +41,7 @@ type (\n \n \n type (\n-\tp1 pi /* ERROR \"no field or method foo\" */ /* ERROR \"not a type\" */ .foo\n+\tp1 pi /* ERROR \"no field or method foo\" */ .foo\n \tp2 unsafe.Pointer\n )\n ", "previous_filename": "libgo/go/exp/types/staging/testdata/decls0.src"}, {"sha": "16da045ef29d378fc42f5673d91257f6ef338997", "filename": "libgo/go/exp/types/testdata/decls1.src", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -26,7 +26,7 @@ var (\n \tarray []byte\n \tiface interface{}\n \t\n-\tblank _ /* ERROR \"cannot use _\" */ /* ERROR \"not a type\" */\n+\tblank _ /* ERROR \"cannot use _\" */\n )\n \n // Global variables with initialization\n@@ -63,8 +63,8 @@ var (\n \tt12 complex64 = -(u + *t11) / *&v\n \tt13 int = a /* ERROR \"shifted operand\" */ << d\n \tt14 int = i << j /* ERROR \"must be unsigned\" */ \n-\tt15 math /* ERROR \"not in selector\" */ /* ERROR \"not a type\" */\n-\tt16 math /* ERROR \"not a type\" */ .xxx /* ERROR \"unexported\" */\n+\tt15 math /* ERROR \"not in selector\" */\n+\tt16 math.xxx /* ERROR \"unexported\" */\n \tt17 math /* ERROR \"not a type\" */ .Pi\n \tt18 float64 = math.Pi * 10.0\n \tt19 int = t1 /* ERROR \"cannot call\" */ ()", "previous_filename": "libgo/go/exp/types/staging/testdata/decls1.src"}, {"sha": "8323829f35240f2e74208adc43a894e4deb06d42", "filename": "libgo/go/exp/types/testdata/decls2a.src", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls2a.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls2a.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls2a.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -28,9 +28,10 @@ type T2 struct {\n func (undeclared /* ERROR \"undeclared\" */) m() {}\n func (x *undeclared /* ERROR \"undeclared\" */) m() {}\n \n-func (pi /* ERROR \"not a type\" */) m1() {}\n-func (x pi /* ERROR \"not a type\" */) m2() {}\n-func (x *pi /* ERROR \"not a type\" */) m3() {}\n+// TODO(gri) try to get rid of double error reporting here\n+func (pi /* ERROR \"not a type\" */ /* ERROR \"not a type\" */) m1() {}\n+func (x pi /* ERROR \"not a type\" */ /* ERROR \"not a type\" */) m2() {}\n+func (x *pi /* ERROR \"not a type\" */ /* ERROR \"cannot indirect\" */) m3() {} // TODO(gri) not closing the last /* comment crashes the system\n \n // Blank types.\n type _ struct { m int }", "previous_filename": "libgo/go/exp/types/staging/testdata/decls2a.src"}, {"sha": "c7f9ddf01add6c2702a60743f24a914b46f889a6", "filename": "libgo/go/exp/types/testdata/decls2b.src", "status": "renamed", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls2b.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls2b.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls2b.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -13,3 +13,16 @@ func (T1) m /* ERROR \"redeclared\" */ () {}\n type T3 struct {\n \tf *T3\n }\n+\n+type T6 struct {\n+\tx int\n+}\n+\n+func (t *T6) m1() int {\n+\treturn t.x\n+}\n+\n+func f() {\n+\tvar t *T6\n+\tt.m1()\n+}\n\\ No newline at end of file", "previous_filename": "libgo/go/exp/types/staging/testdata/decls2b.src"}, {"sha": "0ed314a95cf5968ac404e55488f72ecaf12e1c14", "filename": "libgo/go/exp/types/testdata/expr0.src", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr0.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -20,7 +20,7 @@ var (\n \tb9 = *b0 /* ERROR \"cannot indirect\" */\n \tb10 = &true /* ERROR \"cannot take address\" */\n \tb11 = &b0\n-\tb12 = <-b0 /* ERROR \"not defined\" */\n+\tb12 = <-b0 /* ERROR \"cannot receive\" */\n \n \t// int\n \ti0 = 1\n@@ -41,7 +41,7 @@ var (\n \ti15 = *i0 /* ERROR \"cannot indirect\" */\n \ti16 = &i0\n \ti17 = *i16\n-\ti18 = <-i16 /* ERROR \"not defined\" */\n+\ti18 = <-i16 /* ERROR \"cannot receive\" */\n \n \t// uint\n \tu0 = uint(1)\n@@ -62,7 +62,7 @@ var (\n \tu15 = *u0 /* ERROR \"cannot indirect\" */\n \tu16 = &u0\n \tu17 = *u16\n-\tu18 = <-u16 /* ERROR \"not defined\" */\n+\tu18 = <-u16 /* ERROR \"cannot receive\" */\n \n \t// float64\n \tf0 = float64(1)\n@@ -83,7 +83,7 @@ var (\n \tf15 = *f0 /* ERROR \"cannot indirect\" */\n \tf16 = &f0\n \tf17 = *u16\n-\tf18 = <-u16 /* ERROR \"not defined\" */\n+\tf18 = <-u16 /* ERROR \"cannot receive\" */\n \n \t// complex128\n \tc0 = complex128(1)\n@@ -104,7 +104,7 @@ var (\n \tc15 = *c0 /* ERROR \"cannot indirect\" */\n \tc16 = &c0\n \tc17 = *u16\n-\tc18 = <-u16 /* ERROR \"not defined\" */\n+\tc18 = <-u16 /* ERROR \"cannot receive\" */\n \n \t// string\n \ts0 = \"foo\"\n@@ -115,7 +115,7 @@ var (\n \ts5 = *s4 /* ERROR \"cannot indirect\" */\n \ts6 = &s4\n \ts7 = *s6\n-\ts8 = <-s7  /* ERROR \"not defined\" */\n+\ts8 = <-s7  /* ERROR \"cannot receive\" */\n \n \t// channel\n \tch chan int\n@@ -130,6 +130,6 @@ var (\n \tch6 = *ch5\n \tch7 = <-ch\n \tch8 = <-rc\n-\tch9 = <-sc /* ERROR \"not defined\" */\n+\tch9 = <-sc /* ERROR \"cannot receive\" */\n \n )\n\\ No newline at end of file", "previous_filename": "libgo/go/exp/types/staging/testdata/expr0.src"}, {"sha": "8ef0aed6d2ea16ed8d811338a04c1f68fab08751", "filename": "libgo/go/exp/types/testdata/expr1.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr1.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "previous_filename": "libgo/go/exp/types/staging/testdata/expr1.src"}, {"sha": "4bc2769651b0c8207261cf179408b0d4ac61e301", "filename": "libgo/go/exp/types/testdata/expr2.src", "status": "renamed", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr2.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr2.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr2.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -5,3 +5,8 @@\n // comparisons\n \n package expr2\n+\n+// corner cases\n+var (\n+\tv0 = nil /* ERROR \"cannot compare\" */ == nil\n+)\n\\ No newline at end of file", "previous_filename": "libgo/go/exp/types/staging/testdata/expr2.src"}, {"sha": "890f5e993859a04b417e9b26d590ae5e72a30e31", "filename": "libgo/go/exp/types/testdata/expr3.src", "status": "renamed", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -88,6 +88,11 @@ func indexes() {\n \t_ = s[1 : 2]\n \t_ = s[2 /* ERROR \"inverted slice range\" */ : 1]\n \t_ = s[2 :]\n+\t_ = s[: 1<<100]\n+\t_ = s[1<<100 :]\n+\t_ = s[1<<100 : 1<<100]\n+\t_ = s[1 /* ERROR \"inverted slice range\" */ <<100+1 : 1<<100]\n+\t_ = s[1 /* ERROR \"inverted slice range\" */ <<100+1 : 10]\n \n \tvar t string\n \t_ = t[- /* ERROR \"index .* negative\" */ 1]\n@@ -113,3 +118,17 @@ func indexes() {\n \n \t_ = s[1<<30] // no compile-time error here\n }\n+\n+type T struct {\n+\tx int\n+}\n+\n+func (*T) m() {}\n+\n+func method_expressions() {\n+\t_ = T /* ERROR \"no field or method\" */ .a\n+\t_ = T /* ERROR \"has no method\" */ .x\n+\t_ = T.m\n+\tvar f func(*T) = (*T).m\n+\tvar g func(*T) = ( /* ERROR \"cannot assign\" */ T).m\n+}\n\\ No newline at end of file", "previous_filename": "libgo/go/exp/types/staging/testdata/expr3.src"}, {"sha": "e3436bc41d9af813621ffc8322403bb90a6da8b5", "filename": "libgo/go/exp/types/testdata/stmt0.src", "status": "renamed", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -31,6 +31,22 @@ func _() {\n \ts += 1 /* ERROR \"cannot convert.*string\" */\n }\n \n+func _incdecs() {\n+\tconst c = 3.14\n+\tc /* ERROR \"cannot assign\" */ ++\n+\ts := \"foo\"\n+\ts /* ERROR \"cannot convert\" */ --\n+\t3.14 /* ERROR \"cannot assign\" */ ++\n+\tvar (\n+\t\tx int\n+\t\ty float32\n+\t\tz complex128\n+\t)\n+\tx++\n+\ty--\n+\tz++\n+}\n+\n func _sends() {\n \tvar ch chan int\n \tvar rch <-chan int\n@@ -39,4 +55,20 @@ func _sends() {\n \trch /* ERROR \"cannot send\" */ <- x\n \tch /* ERROR \"cannot send\" */ <- \"foo\"\n \tch <- x\n+}\n+\n+func _selects() {\n+\tselect {}\n+\tvar (\n+\t\tch chan int\n+\t\tsc chan <- bool\n+\t\tx int\n+\t)\n+\tselect {\n+\tcase <-ch:\n+\t\tch <- x\n+\tcase t, ok := <-ch:\n+\t\tx = t\n+\tcase <-sc /* ERROR \"cannot receive from send-only channel\" */ :\n+\t}\n }\n\\ No newline at end of file", "previous_filename": "libgo/go/exp/types/staging/testdata/stmt0.src"}, {"sha": "a770a19b803a5b7e92798f65185b954981d7d45d", "filename": "libgo/go/exp/types/testdata/test0.src", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b", "patch": "@@ -1,163 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// type declarations\n-\n-package test0\n-\n-import (\n-\t\"unsafe\"\n-\t// we can have multiple blank imports (was bug)\n-\t_ \"math\"\n-\t_ \"net/rpc\"\n-)\n-\n-const pi = 3.1415\n-\n-type (\n-\tN undeclared /* ERROR \"undeclared\" */\n-\tB bool\n-\tI int32\n-\tA [10]P\n-\tT struct {\n-\t\tx, y P\n-\t}\n-\tP *T\n-\tR (*R)\n-\tF func(A) I\n-\tY interface {\n-\t\tf(A) I\n-\t}\n-\tS [](((P)))\n-\tM map[I]F\n-\tC chan<- I\n-)\n-\n-\n-type (\n-\tp1 pi /* ERROR \"not a package\" */ .foo\n-\tp2 unsafe.Pointer\n-)\n-\n-\n-type (\n-\tPi pi /* ERROR \"not a type\" */\n-\n-\ta /* ERROR \"illegal cycle\" */ a\n-\ta /* ERROR \"redeclared\" */ int\n-\n-\t// where the cycle error appears depends on the\n-\t// order in which declarations are processed\n-\t// (which depends on the order in which a map\n-\t// is iterated through)\n-\tb /* ERROR \"illegal cycle\" */ c\n-\tc d\n-\td e\n-\te b\n-\n-\tt *t\n-\n-\tU V\n-\tV *W\n-\tW U\n-\n-\tP1 *S2\n-\tP2 P1\n-\n-\tS0 struct {\n-\t}\n-\tS1 struct {\n-\t\ta, b, c int\n-\t\tu, v, a /* ERROR \"redeclared\" */ float32\n-\t}\n-\tS2 struct {\n-\t\tU // anonymous field\n-\t\t// TODO(gri) recognize double-declaration below\n-\t\t// U /* ERROR \"redeclared\" */ int\n-\t}\n-\tS3 struct {\n-\t\tx S2\n-\t}\n-\tS4/* ERROR \"illegal cycle\" */ struct {\n-\t\tS4\n-\t}\n-\tS5 /* ERROR \"illegal cycle\" */ struct {\n-\t\tS6\n-\t}\n-\tS6 struct {\n-\t\tfield S7\n-\t}\n-\tS7 struct {\n-\t\tS5\n-\t}\n-\n-\tL1 []L1\n-\tL2 []int\n-\n-\tA1 [10]int\n-\tA2 /* ERROR \"illegal cycle\" */ [10]A2\n-\tA3 /* ERROR \"illegal cycle\" */ [10]struct {\n-\t\tx A4\n-\t}\n-\tA4 [10]A3\n-\n-\tF1 func()\n-\tF2 func(x, y, z float32)\n-\tF3 func(x, y, x /* ERROR \"redeclared\" */ float32)\n-\tF4 func() (x, y, x /* ERROR \"redeclared\" */ float32)\n-\tF5 func(x int) (x /* ERROR \"redeclared\" */ float32)\n-\tF6 func(x ...int)\n-\n-\tI1 interface{}\n-\tI2 interface {\n-\t\tm1()\n-\t}\n-\tI3 interface {\n-\t\tm1()\n-\t\tm1 /* ERROR \"redeclared\" */ ()\n-\t}\n-\tI4 interface {\n-\t\tm1(x, y, x /* ERROR \"redeclared\" */ float32)\n-\t\tm2() (x, y, x /* ERROR \"redeclared\" */ float32)\n-\t\tm3(x int) (x /* ERROR \"redeclared\" */ float32)\n-\t}\n-\tI5 interface {\n-\t\tm1(I5)\n-\t}\n-\tI6 interface {\n-\t\tS0 /* ERROR \"non-interface\" */\n-\t}\n-\tI7 interface {\n-\t\tI1\n-\t\tI1\n-\t}\n-\tI8 /* ERROR \"illegal cycle\" */ interface {\n-\t\tI8\n-\t}\n-\t// Use I09 (rather than I9) because it appears lexically before\n-\t// I10 so that we get the illegal cycle here rather then in the\n-\t// declaration of I10. If the implementation sorts by position\n-\t// rather than name, the error message will still be here.\n-\tI09 /* ERROR \"illegal cycle\" */ interface {\n-\t\tI10\n-\t}\n-\tI10 interface {\n-\t\tI11\n-\t}\n-\tI11 interface {\n-\t\tI09\n-\t}\n-\n-\tC1 chan int\n-\tC2 <-chan int\n-\tC3 chan<- C3\n-\tC4 chan C5\n-\tC5 chan C6\n-\tC6 chan C4\n-\n-\tM1 map[Last]string\n-\tM2 map[string]M2\n-\n-\tLast int\n-)"}, {"sha": "eed0c8a6c3468ce8dc146bd4b302efa02abaaedb", "filename": "libgo/go/exp/types/types.go", "status": "modified", "additions": 151, "deletions": 293, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -2,45 +2,108 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package types declares the types used to represent Go types\n-// (UNDER CONSTRUCTION). ANY AND ALL PARTS MAY CHANGE.\n+// Package types declares the data structures for representing\n+// Go types and implements typechecking of an *ast.Package.\n+//\n+// PACKAGE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\n //\n package types\n \n import (\n-\t\"bytes\"\n-\t\"fmt\"\n \t\"go/ast\"\n+\t\"go/token\"\n \t\"sort\"\n )\n \n-// All types implement the Type interface.\n-type Type interface {\n-\tisType()\n+// Check typechecks a package pkg. It returns the first error, or nil.\n+//\n+// Check augments the AST by assigning types to ast.Objects. It\n+// calls err with the error position and message for each error.\n+// It calls f with each valid AST expression and corresponding\n+// type. If err == nil, Check terminates as soon as the first error\n+// is found. If f is nil, it is not invoked.\n+//\n+func Check(fset *token.FileSet, pkg *ast.Package, err func(token.Pos, string), f func(ast.Expr, Type)) error {\n+\treturn check(fset, pkg, err, f)\n }\n \n-// All concrete types embed implementsType which\n-// ensures that all types implement the Type interface.\n-type implementsType struct{}\n-\n-func (t *implementsType) isType() {}\n+// All types implement the Type interface.\n+// TODO(gri) Eventually determine what common Type functionality should be exported.\n+type Type interface {\n+\taType()\n+}\n+\n+// BasicKind describes the kind of basic type.\n+type BasicKind int\n+\n+const (\n+\tInvalid BasicKind = iota // type is invalid\n+\n+\t// predeclared types\n+\tBool\n+\tInt\n+\tInt8\n+\tInt16\n+\tInt32\n+\tInt64\n+\tUint\n+\tUint8\n+\tUint16\n+\tUint32\n+\tUint64\n+\tUintptr\n+\tFloat32\n+\tFloat64\n+\tComplex64\n+\tComplex128\n+\tString\n+\tUnsafePointer\n+\n+\t// types for untyped values\n+\tUntypedBool\n+\tUntypedInt\n+\tUntypedRune\n+\tUntypedFloat\n+\tUntypedComplex\n+\tUntypedString\n+\tUntypedNil\n+\n+\t// aliases\n+\tByte = Uint8\n+\tRune = Int32\n+)\n \n-// A Bad type is a non-nil placeholder type when we don't know a type.\n-type Bad struct {\n-\timplementsType\n-\tMsg string // for better error reporting/debugging\n-}\n+// BasicInfo is a set of flags describing properties of a basic type.\n+type BasicInfo int\n+\n+// Properties of basic types.\n+const (\n+\tIsBoolean BasicInfo = 1 << iota\n+\tIsInteger\n+\tIsUnsigned\n+\tIsFloat\n+\tIsComplex\n+\tIsString\n+\tIsUntyped\n+\n+\tIsOrdered   = IsInteger | IsFloat | IsString\n+\tIsNumeric   = IsInteger | IsFloat | IsComplex\n+\tIsConstType = IsBoolean | IsNumeric | IsString\n+)\n \n-// A Basic represents a (unnamed) basic type.\n+// A Basic represents a basic type.\n type Basic struct {\n \timplementsType\n-\t// TODO(gri) need a field specifying the exact basic type\n+\tKind BasicKind\n+\tInfo BasicInfo\n+\tSize int64 // > 0 if valid\n+\tName string\n }\n \n // An Array represents an array type [Len]Elt.\n type Array struct {\n \timplementsType\n-\tLen uint64\n+\tLen int64\n \tElt Type\n }\n \n@@ -50,16 +113,17 @@ type Slice struct {\n \tElt Type\n }\n \n+type StructField struct {\n+\tName        string // unqualified type name for anonymous fields\n+\tType        Type\n+\tTag         string\n+\tIsAnonymous bool\n+}\n+\n // A Struct represents a struct type struct{...}.\n-// Anonymous fields are represented by objects with empty names.\n type Struct struct {\n \timplementsType\n-\tFields ObjList  // struct fields; or nil\n-\tTags   []string // corresponding tags; or nil\n-\t// TODO(gri) This type needs some rethinking:\n-\t// - at the moment anonymous fields are marked with \"\" object names,\n-\t//   and their names have to be reconstructed\n-\t// - there is no scope for fast lookup (but the parser creates one)\n+\tFields []*StructField\n }\n \n // A Pointer represents a pointer type *Base.\n@@ -68,16 +132,65 @@ type Pointer struct {\n \tBase Type\n }\n \n-// A Func represents a function type func(...) (...).\n-// Unnamed parameters are represented by objects with empty names.\n-type Func struct {\n+// A tuple represents a multi-value function return.\n+// TODO(gri) use better name to avoid confusion (Go doesn't have tuples).\n+type tuple struct {\n+\timplementsType\n+\tlist []Type\n+}\n+\n+// A Signature represents a user-defined function type func(...) (...).\n+// TODO(gri) consider using \"tuples\" to represent parameters and results (see comment on tuples).\n+type Signature struct {\n \timplementsType\n \tRecv       *ast.Object // nil if not a method\n \tParams     ObjList     // (incoming) parameters from left to right; or nil\n \tResults    ObjList     // (outgoing) results from left to right; or nil\n \tIsVariadic bool        // true if the last parameter's type is of the form ...T\n }\n \n+// builtinId is an id of a builtin function.\n+type builtinId int\n+\n+// Predeclared builtin functions.\n+const (\n+\t// Universe scope\n+\t_Append builtinId = iota\n+\t_Cap\n+\t_Close\n+\t_Complex\n+\t_Copy\n+\t_Delete\n+\t_Imag\n+\t_Len\n+\t_Make\n+\t_New\n+\t_Panic\n+\t_Print\n+\t_Println\n+\t_Real\n+\t_Recover\n+\n+\t// Unsafe package\n+\t_Alignof\n+\t_Offsetof\n+\t_Sizeof\n+\n+\t// Testing support\n+\t_Assert\n+\t_Trace\n+)\n+\n+// A builtin represents the type of a built-in function.\n+type builtin struct {\n+\timplementsType\n+\tid          builtinId\n+\tname        string\n+\tnargs       int // number of arguments (minimum if variadic)\n+\tisVariadic  bool\n+\tisStatement bool // true if the built-in is valid as an expression statement\n+}\n+\n // An Interface represents an interface type interface{...}.\n type Interface struct {\n \timplementsType\n@@ -97,155 +210,11 @@ type Chan struct {\n \tElt Type\n }\n \n-// A Name represents a named type as declared in a type declaration.\n-type Name struct {\n+// A NamedType represents a named type as declared in a type declaration.\n+type NamedType struct {\n \timplementsType\n-\tUnderlying Type        // nil if not fully declared\n-\tObj        *ast.Object // corresponding declared object\n-\t// TODO(gri) need to remember fields and methods.\n-}\n-\n-func writeParams(buf *bytes.Buffer, params ObjList, isVariadic bool) {\n-\tbuf.WriteByte('(')\n-\tfor i, par := range params {\n-\t\tif i > 0 {\n-\t\t\tbuf.WriteString(\", \")\n-\t\t}\n-\t\tif par.Name != \"\" {\n-\t\t\tbuf.WriteString(par.Name)\n-\t\t\tbuf.WriteByte(' ')\n-\t\t}\n-\t\tif isVariadic && i == len(params)-1 {\n-\t\t\tbuf.WriteString(\"...\")\n-\t\t}\n-\t\twriteType(buf, par.Type.(Type))\n-\t}\n-\tbuf.WriteByte(')')\n-}\n-\n-func writeSignature(buf *bytes.Buffer, t *Func) {\n-\twriteParams(buf, t.Params, t.IsVariadic)\n-\tif len(t.Results) == 0 {\n-\t\t// no result\n-\t\treturn\n-\t}\n-\n-\tbuf.WriteByte(' ')\n-\tif len(t.Results) == 1 && t.Results[0].Name == \"\" {\n-\t\t// single unnamed result\n-\t\twriteType(buf, t.Results[0].Type.(Type))\n-\t\treturn\n-\t}\n-\n-\t// multiple or named result(s)\n-\twriteParams(buf, t.Results, false)\n-}\n-\n-func writeType(buf *bytes.Buffer, typ Type) {\n-\tswitch t := typ.(type) {\n-\tcase *Bad:\n-\t\tfmt.Fprintf(buf, \"badType(%s)\", t.Msg)\n-\n-\tcase *Basic:\n-\t\tbuf.WriteString(\"basicType\") // TODO(gri) print actual type information\n-\n-\tcase *Array:\n-\t\tfmt.Fprintf(buf, \"[%d]\", t.Len)\n-\t\twriteType(buf, t.Elt)\n-\n-\tcase *Slice:\n-\t\tbuf.WriteString(\"[]\")\n-\t\twriteType(buf, t.Elt)\n-\n-\tcase *Struct:\n-\t\tbuf.WriteString(\"struct{\")\n-\t\tfor i, fld := range t.Fields {\n-\t\t\tif i > 0 {\n-\t\t\t\tbuf.WriteString(\"; \")\n-\t\t\t}\n-\t\t\tif fld.Name != \"\" {\n-\t\t\t\tbuf.WriteString(fld.Name)\n-\t\t\t\tbuf.WriteByte(' ')\n-\t\t\t}\n-\t\t\twriteType(buf, fld.Type.(Type))\n-\t\t\tif i < len(t.Tags) && t.Tags[i] != \"\" {\n-\t\t\t\tfmt.Fprintf(buf, \" %q\", t.Tags[i])\n-\t\t\t}\n-\t\t}\n-\t\tbuf.WriteByte('}')\n-\n-\tcase *Pointer:\n-\t\tbuf.WriteByte('*')\n-\t\twriteType(buf, t.Base)\n-\n-\tcase *Func:\n-\t\tbuf.WriteString(\"func\")\n-\t\twriteSignature(buf, t)\n-\n-\tcase *Interface:\n-\t\tbuf.WriteString(\"interface{\")\n-\t\tfor i, m := range t.Methods {\n-\t\t\tif i > 0 {\n-\t\t\t\tbuf.WriteString(\"; \")\n-\t\t\t}\n-\t\t\tbuf.WriteString(m.Name)\n-\t\t\twriteSignature(buf, m.Type.(*Func))\n-\t\t}\n-\t\tbuf.WriteByte('}')\n-\n-\tcase *Map:\n-\t\tbuf.WriteString(\"map[\")\n-\t\twriteType(buf, t.Key)\n-\t\tbuf.WriteByte(']')\n-\t\twriteType(buf, t.Elt)\n-\n-\tcase *Chan:\n-\t\tvar s string\n-\t\tswitch t.Dir {\n-\t\tcase ast.SEND:\n-\t\t\ts = \"chan<- \"\n-\t\tcase ast.RECV:\n-\t\t\ts = \"<-chan \"\n-\t\tdefault:\n-\t\t\ts = \"chan \"\n-\t\t}\n-\t\tbuf.WriteString(s)\n-\t\twriteType(buf, t.Elt)\n-\n-\tcase *Name:\n-\t\tbuf.WriteString(t.Obj.Name)\n-\n-\t}\n-}\n-\n-// TypeString returns a string representation for typ.\n-func TypeString(typ Type) string {\n-\tvar buf bytes.Buffer\n-\twriteType(&buf, typ)\n-\treturn buf.String()\n-}\n-\n-// If typ is a pointer type, Deref returns the pointer's base type;\n-// otherwise it returns typ.\n-func Deref(typ Type) Type {\n-\tif typ, ok := typ.(*Pointer); ok {\n-\t\treturn typ.Base\n-\t}\n-\treturn typ\n-}\n-\n-// Underlying returns the underlying type of a type.\n-func Underlying(typ Type) Type {\n-\tif typ, ok := typ.(*Name); ok {\n-\t\tutyp := typ.Underlying\n-\t\tif _, ok := utyp.(*Basic); !ok {\n-\t\t\treturn utyp\n-\t\t}\n-\t\t// the underlying type of a type name referring\n-\t\t// to an (untyped) basic type is the basic type\n-\t\t// name\n-\t}\n-\treturn typ\n+\tObj        *ast.Object // corresponding declared object; Obj.Data.(*ast.Scope) contains methods, if any\n+\tUnderlying Type        // nil if not fully declared yet; never a *NamedType\n }\n \n // An ObjList represents an ordered (in some fashion) list of objects.\n@@ -259,119 +228,8 @@ func (list ObjList) Swap(i, j int)      { list[i], list[j] = list[j], list[i] }\n // Sort sorts an object list by object name.\n func (list ObjList) Sort() { sort.Sort(list) }\n \n-// identicalTypes returns true if both lists a and b have the\n-// same length and corresponding objects have identical types.\n-func identicalTypes(a, b ObjList) bool {\n-\tif len(a) == len(b) {\n-\t\tfor i, x := range a {\n-\t\t\ty := b[i]\n-\t\t\tif !Identical(x.Type.(Type), y.Type.(Type)) {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n+// All concrete types embed implementsType which\n+// ensures that all types implement the Type interface.\n+type implementsType struct{}\n \n-// Identical returns true if two types are identical.\n-func Identical(x, y Type) bool {\n-\tif x == y {\n-\t\treturn true\n-\t}\n-\n-\tswitch x := x.(type) {\n-\tcase *Bad:\n-\t\t// A Bad type is always identical to any other type\n-\t\t// (to avoid spurious follow-up errors).\n-\t\treturn true\n-\n-\tcase *Basic:\n-\t\tif y, ok := y.(*Basic); ok {\n-\t\t\tpanic(\"unimplemented\")\n-\t\t\t_ = y\n-\t\t}\n-\n-\tcase *Array:\n-\t\t// Two array types are identical if they have identical element types\n-\t\t// and the same array length.\n-\t\tif y, ok := y.(*Array); ok {\n-\t\t\treturn x.Len == y.Len && Identical(x.Elt, y.Elt)\n-\t\t}\n-\n-\tcase *Slice:\n-\t\t// Two slice types are identical if they have identical element types.\n-\t\tif y, ok := y.(*Slice); ok {\n-\t\t\treturn Identical(x.Elt, y.Elt)\n-\t\t}\n-\n-\tcase *Struct:\n-\t\t// Two struct types are identical if they have the same sequence of fields,\n-\t\t// and if corresponding fields have the same names, and identical types,\n-\t\t// and identical tags. Two anonymous fields are considered to have the same\n-\t\t// name. Lower-case field names from different packages are always different.\n-\t\tif y, ok := y.(*Struct); ok {\n-\t\t\t// TODO(gri) handle structs from different packages\n-\t\t\tif identicalTypes(x.Fields, y.Fields) {\n-\t\t\t\tfor i, f := range x.Fields {\n-\t\t\t\t\tg := y.Fields[i]\n-\t\t\t\t\tif f.Name != g.Name || x.Tags[i] != y.Tags[i] {\n-\t\t\t\t\t\treturn false\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t}\n-\n-\tcase *Pointer:\n-\t\t// Two pointer types are identical if they have identical base types.\n-\t\tif y, ok := y.(*Pointer); ok {\n-\t\t\treturn Identical(x.Base, y.Base)\n-\t\t}\n-\n-\tcase *Func:\n-\t\t// Two function types are identical if they have the same number of parameters\n-\t\t// and result values, corresponding parameter and result types are identical,\n-\t\t// and either both functions are variadic or neither is. Parameter and result\n-\t\t// names are not required to match.\n-\t\tif y, ok := y.(*Func); ok {\n-\t\t\treturn identicalTypes(x.Params, y.Params) &&\n-\t\t\t\tidenticalTypes(x.Results, y.Results) &&\n-\t\t\t\tx.IsVariadic == y.IsVariadic\n-\t\t}\n-\n-\tcase *Interface:\n-\t\t// Two interface types are identical if they have the same set of methods with\n-\t\t// the same names and identical function types. Lower-case method names from\n-\t\t// different packages are always different. The order of the methods is irrelevant.\n-\t\tif y, ok := y.(*Interface); ok {\n-\t\t\treturn identicalTypes(x.Methods, y.Methods) // methods are sorted\n-\t\t}\n-\n-\tcase *Map:\n-\t\t// Two map types are identical if they have identical key and value types.\n-\t\tif y, ok := y.(*Map); ok {\n-\t\t\treturn Identical(x.Key, y.Key) && Identical(x.Elt, y.Elt)\n-\t\t}\n-\n-\tcase *Chan:\n-\t\t// Two channel types are identical if they have identical value types\n-\t\t// and the same direction.\n-\t\tif y, ok := y.(*Chan); ok {\n-\t\t\treturn x.Dir == y.Dir && Identical(x.Elt, y.Elt)\n-\t\t}\n-\n-\tcase *Name:\n-\t\t// Two named types are identical if their type names originate\n-\t\t// in the same type declaration.\n-\t\tif y, ok := y.(*Name); ok {\n-\t\t\treturn x.Obj == y.Obj ||\n-\t\t\t\t// permit bad objects to be equal to avoid\n-\t\t\t\t// follow up errors\n-\t\t\t\tx.Obj != nil && x.Obj.Kind == ast.Bad ||\n-\t\t\t\ty.Obj != nil && y.Obj.Kind == ast.Bad\n-\t\t}\n-\t}\n-\n-\treturn false\n-}\n+func (*implementsType) aType() {}"}, {"sha": "62ca19badca2ce93435626039ca36774a26983b3", "filename": "libgo/go/exp/types/types_test.go", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -13,8 +13,9 @@ import (\n \t\"testing\"\n )\n \n+const filename = \"<src>\"\n+\n func makePkg(t *testing.T, src string) (*ast.Package, error) {\n-\tconst filename = \"<src>\"\n \tfile, err := parser.ParseFile(fset, filename, src, parser.DeclarationErrors)\n \tif err != nil {\n \t\treturn nil, err\n@@ -24,7 +25,7 @@ func makePkg(t *testing.T, src string) (*ast.Package, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tif _, err := Check(fset, pkg); err != nil {\n+\tif err := Check(fset, pkg, nil, nil); err != nil {\n \t\treturn nil, err\n \t}\n \treturn pkg, nil\n@@ -46,7 +47,7 @@ var testTypes = []testEntry{\n \tdup(\"string\"),\n \n \t// arrays\n-\t{\"[10]int\", \"[0]int\"}, // TODO(gri) fix array length, add more array tests\n+\tdup(\"[10]int\"),\n \n \t// slices\n \tdup(\"[]int\"),\n@@ -75,7 +76,7 @@ var testTypes = []testEntry{\n \t{\"func(x, y int)\", \"func(x int, y int)\"},\n \t{\"func(x, y int, z string)\", \"func(x int, y int, z string)\"},\n \tdup(\"func(int)\"),\n-\tdup(\"func(int, string, byte)\"),\n+\t{\"func(int, string, byte)\", \"func(int, string, byte)\"},\n \n \tdup(\"func() int\"),\n \t{\"func() (string)\", \"func() string\"},\n@@ -119,8 +120,60 @@ func TestTypes(t *testing.T) {\n \t\t\tt.Errorf(\"%s: %s\", src, err)\n \t\t\tcontinue\n \t\t}\n-\t\ttyp := Underlying(pkg.Scope.Lookup(\"T\").Type.(Type))\n-\t\tstr := TypeString(typ)\n+\t\ttyp := underlying(pkg.Scope.Lookup(\"T\").Type.(Type))\n+\t\tstr := typeString(typ)\n+\t\tif str != test.str {\n+\t\t\tt.Errorf(\"%s: got %s, want %s\", test.src, str, test.str)\n+\t\t}\n+\t}\n+}\n+\n+var testExprs = []testEntry{\n+\t// basic type literals\n+\tdup(\"x\"),\n+\tdup(\"true\"),\n+\tdup(\"42\"),\n+\tdup(\"3.1415\"),\n+\tdup(\"2.71828i\"),\n+\tdup(`'a'`),\n+\tdup(`\"foo\"`),\n+\tdup(\"`bar`\"),\n+\n+\t// arbitrary expressions\n+\tdup(\"&x\"),\n+\tdup(\"*&x\"),\n+\tdup(\"(x)\"),\n+\tdup(\"x + y\"),\n+\tdup(\"x + y * 10\"),\n+\tdup(\"t.foo\"),\n+\tdup(\"s[0]\"),\n+\tdup(\"s[x:y]\"),\n+\tdup(\"s[:y]\"),\n+\tdup(\"s[x:]\"),\n+\tdup(\"s[:]\"),\n+\tdup(\"f(1, 2.3)\"),\n+\tdup(\"-f(10, 20)\"),\n+\tdup(\"f(x + y, +3.1415)\"),\n+\t{\"func(a, b int) {}\", \"(func literal)\"},\n+\t{\"func(a, b int) []int {}()[x]\", \"(func literal)()[x]\"},\n+\t{\"[]int{1, 2, 3}\", \"(composite literal)\"},\n+\t{\"[]int{1, 2, 3}[x:]\", \"(composite literal)[x:]\"},\n+\t{\"i.([]string)\", \"i.(...)\"},\n+}\n+\n+func TestExprs(t *testing.T) {\n+\tfor _, test := range testExprs {\n+\t\tsrc := \"package p; var _ = \" + test.src + \"; var (x, y int; s []string; f func(int, float32) int; i interface{}; t interface { foo() })\"\n+\t\tpkg, err := makePkg(t, src)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %s\", src, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// TODO(gri) writing the code below w/o the decl variable will\n+\t\t//           cause a 386 compiler error (out of fixed registers)\n+\t\tdecl := pkg.Files[filename].Decls[0].(*ast.GenDecl)\n+\t\texpr := decl.Specs[0].(*ast.ValueSpec).Values[0]\n+\t\tstr := exprString(expr)\n \t\tif str != test.str {\n \t\t\tt.Errorf(\"%s: got %s, want %s\", test.src, str, test.str)\n \t\t}"}, {"sha": "bb8b6a2bdacab89d7702a0999a3daecb4c7d45f5", "filename": "libgo/go/exp/types/universe.go", "status": "modified", "additions": 131, "deletions": 79, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -2,106 +2,158 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// FILE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\n // This file implements the universe and unsafe package scopes.\n \n package types\n \n-import \"go/ast\"\n+import (\n+\t\"go/ast\"\n+\t\"strings\"\n+)\n \n var (\n-\tscope    *ast.Scope // current scope to use for initialization\n-\tUniverse *ast.Scope\n-\tUnsafe   *ast.Object // package unsafe\n+\taType            implementsType\n+\tUniverse, unsafe *ast.Scope\n+\tUnsafe           *ast.Object // package unsafe\n )\n \n-func define(kind ast.ObjKind, name string) *ast.Object {\n-\tobj := ast.NewObj(kind, name)\n-\tif scope.Insert(obj) != nil {\n-\t\tpanic(\"types internal error: double declaration\")\n-\t}\n-\tobj.Decl = scope\n-\treturn obj\n+// Predeclared types, indexed by BasicKind.\n+var Typ = [...]*Basic{\n+\tInvalid: {aType, Invalid, 0, 0, \"invalid type\"},\n+\n+\tBool:          {aType, Bool, IsBoolean, 1, \"bool\"},\n+\tInt:           {aType, Int, IsInteger, 0, \"int\"},\n+\tInt8:          {aType, Int8, IsInteger, 1, \"int8\"},\n+\tInt16:         {aType, Int16, IsInteger, 2, \"int16\"},\n+\tInt32:         {aType, Int32, IsInteger, 4, \"int32\"},\n+\tInt64:         {aType, Int64, IsInteger, 8, \"int64\"},\n+\tUint:          {aType, Uint, IsInteger | IsUnsigned, 0, \"uint\"},\n+\tUint8:         {aType, Uint8, IsInteger | IsUnsigned, 1, \"uint8\"},\n+\tUint16:        {aType, Uint16, IsInteger | IsUnsigned, 2, \"uint16\"},\n+\tUint32:        {aType, Uint32, IsInteger | IsUnsigned, 4, \"uint32\"},\n+\tUint64:        {aType, Uint64, IsInteger | IsUnsigned, 8, \"uint64\"},\n+\tUintptr:       {aType, Uintptr, IsInteger | IsUnsigned, 0, \"uintptr\"},\n+\tFloat32:       {aType, Float32, IsFloat, 4, \"float32\"},\n+\tFloat64:       {aType, Float64, IsFloat, 8, \"float64\"},\n+\tComplex64:     {aType, Complex64, IsComplex, 8, \"complex64\"},\n+\tComplex128:    {aType, Complex128, IsComplex, 16, \"complex128\"},\n+\tString:        {aType, String, IsString, 0, \"string\"},\n+\tUnsafePointer: {aType, UnsafePointer, 0, 0, \"Pointer\"},\n+\n+\tUntypedBool:    {aType, UntypedBool, IsBoolean | IsUntyped, 0, \"untyped boolean\"},\n+\tUntypedInt:     {aType, UntypedInt, IsInteger | IsUntyped, 0, \"untyped integer\"},\n+\tUntypedRune:    {aType, UntypedRune, IsInteger | IsUntyped, 0, \"untyped rune\"},\n+\tUntypedFloat:   {aType, UntypedFloat, IsFloat | IsUntyped, 0, \"untyped float\"},\n+\tUntypedComplex: {aType, UntypedComplex, IsComplex | IsUntyped, 0, \"untyped complex\"},\n+\tUntypedString:  {aType, UntypedString, IsString | IsUntyped, 0, \"untyped string\"},\n+\tUntypedNil:     {aType, UntypedNil, IsUntyped, 0, \"untyped nil\"},\n }\n \n-func defType(name string) *Name {\n-\tobj := define(ast.Typ, name)\n-\ttyp := &Name{Underlying: &Basic{}, Obj: obj}\n-\tobj.Type = typ\n-\treturn typ\n+var aliases = [...]*Basic{\n+\t{aType, Byte, IsInteger | IsUnsigned, 1, \"byte\"},\n+\t{aType, Rune, IsInteger, 4, \"rune\"},\n }\n \n-func defConst(name string) {\n-\tobj := define(ast.Con, name)\n-\t_ = obj // TODO(gri) fill in other properties\n+var predeclaredConstants = [...]*struct {\n+\tkind BasicKind\n+\tname string\n+\tval  interface{}\n+}{\n+\t{UntypedBool, \"true\", true},\n+\t{UntypedBool, \"false\", false},\n+\t{UntypedInt, \"iota\", zeroConst},\n+\t{UntypedNil, \"nil\", nilConst},\n }\n \n-func defFun(name string) {\n-\tobj := define(ast.Fun, name)\n-\t_ = obj // TODO(gri) fill in other properties\n+var predeclaredFunctions = [...]*builtin{\n+\t{aType, _Append, \"append\", 1, true, false},\n+\t{aType, _Cap, \"cap\", 1, false, false},\n+\t{aType, _Close, \"close\", 1, false, true},\n+\t{aType, _Complex, \"complex\", 2, false, false},\n+\t{aType, _Copy, \"copy\", 2, false, true},\n+\t{aType, _Delete, \"delete\", 2, false, true},\n+\t{aType, _Imag, \"imag\", 1, false, false},\n+\t{aType, _Len, \"len\", 1, false, false},\n+\t{aType, _Make, \"make\", 1, true, false},\n+\t{aType, _New, \"new\", 1, false, false},\n+\t{aType, _Panic, \"panic\", 1, false, true},\n+\t{aType, _Print, \"print\", 1, true, true},\n+\t{aType, _Println, \"println\", 1, true, true},\n+\t{aType, _Real, \"real\", 1, false, false},\n+\t{aType, _Recover, \"recover\", 0, false, true},\n+\n+\t{aType, _Alignof, \"Alignof\", 1, false, false},\n+\t{aType, _Offsetof, \"Offsetof\", 1, false, false},\n+\t{aType, _Sizeof, \"Sizeof\", 1, false, false},\n }\n \n+// commonly used types\n var (\n-\tBool,\n-\tInt,\n-\tFloat64,\n-\tComplex128,\n-\tString *Name\n+\temptyInterface = new(Interface)\n+)\n+\n+// commonly used constants\n+var (\n+\tuniverseIota *ast.Object\n )\n \n func init() {\n-\tscope = ast.NewScope(nil)\n-\tUniverse = scope\n-\n-\tBool = defType(\"bool\")\n-\tdefType(\"byte\") // TODO(gri) should be an alias for uint8\n-\tdefType(\"rune\") // TODO(gri) should be an alias for int\n-\tdefType(\"complex64\")\n-\tComplex128 = defType(\"complex128\")\n-\tdefType(\"error\")\n-\tdefType(\"float32\")\n-\tFloat64 = defType(\"float64\")\n-\tdefType(\"int8\")\n-\tdefType(\"int16\")\n-\tdefType(\"int32\")\n-\tdefType(\"int64\")\n-\tString = defType(\"string\")\n-\tdefType(\"uint8\")\n-\tdefType(\"uint16\")\n-\tdefType(\"uint32\")\n-\tdefType(\"uint64\")\n-\tInt = defType(\"int\")\n-\tdefType(\"uint\")\n-\tdefType(\"uintptr\")\n-\n-\tdefConst(\"true\")\n-\tdefConst(\"false\")\n-\tdefConst(\"iota\")\n-\tdefConst(\"nil\")\n-\n-\tdefFun(\"append\")\n-\tdefFun(\"cap\")\n-\tdefFun(\"close\")\n-\tdefFun(\"complex\")\n-\tdefFun(\"copy\")\n-\tdefFun(\"delete\")\n-\tdefFun(\"imag\")\n-\tdefFun(\"len\")\n-\tdefFun(\"make\")\n-\tdefFun(\"new\")\n-\tdefFun(\"panic\")\n-\tdefFun(\"print\")\n-\tdefFun(\"println\")\n-\tdefFun(\"real\")\n-\tdefFun(\"recover\")\n-\n-\tscope = ast.NewScope(nil)\n+\t// Universe scope\n+\tUniverse = ast.NewScope(nil)\n+\n+\t// unsafe package and its scope\n+\tunsafe = ast.NewScope(nil)\n \tUnsafe = ast.NewObj(ast.Pkg, \"unsafe\")\n-\tUnsafe.Data = scope\n+\tUnsafe.Data = unsafe\n \n-\tdefType(\"Pointer\")\n+\t// predeclared types\n+\tfor _, t := range Typ {\n+\t\tdef(ast.Typ, t.Name).Type = t\n+\t}\n+\tfor _, t := range aliases {\n+\t\tdef(ast.Typ, t.Name).Type = t\n+\t}\n \n-\tdefFun(\"Alignof\")\n-\tdefFun(\"Offsetof\")\n-\tdefFun(\"Sizeof\")\n+\t// error type\n+\t{\n+\t\tobj := def(ast.Typ, \"error\")\n+\t\t// TODO(gri) set up correct interface type\n+\t\ttyp := &NamedType{Underlying: &Interface{}, Obj: obj}\n+\t\tobj.Type = typ\n+\t}\n+\n+\t// predeclared constants\n+\tfor _, t := range predeclaredConstants {\n+\t\tobj := def(ast.Con, t.name)\n+\t\tobj.Type = Typ[t.kind]\n+\t\tobj.Data = t.val\n+\t}\n+\n+\t// predeclared functions\n+\tfor _, f := range predeclaredFunctions {\n+\t\tdef(ast.Fun, f.name).Type = f\n+\t}\n+\n+\tuniverseIota = Universe.Lookup(\"iota\")\n+}\n+\n+// Objects with names containing blanks are internal and not entered into\n+// a scope. Objects with exported names are inserted in the unsafe package\n+// scope; other objects are inserted in the universe scope.\n+//\n+func def(kind ast.ObjKind, name string) *ast.Object {\n+\tobj := ast.NewObj(kind, name)\n+\t// insert non-internal objects into respective scope\n+\tif strings.Index(name, \" \") < 0 {\n+\t\tscope := Universe\n+\t\t// exported identifiers go into package unsafe\n+\t\tif ast.IsExported(name) {\n+\t\t\tscope = unsafe\n+\t\t}\n+\t\tif scope.Insert(obj) != nil {\n+\t\t\tpanic(\"internal error: double declaration\")\n+\t\t}\n+\t\tobj.Decl = scope\n+\t}\n+\treturn obj\n }"}, {"sha": "ff947b68a746e958b5e3bce6932c02ff1a2e1d09", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -31,8 +31,8 @@\n \t\t%X\tbase 16, with upper-case letters for A-F\n \t\t%U\tUnicode format: U+1234; same as \"U+%04X\"\n \tFloating-point and complex constituents:\n-\t\t%b\tdecimalless scientific notation with exponent a power of two, \n-\t\t\tin the manner of strconv.FormatFloat with the 'b' format, \n+\t\t%b\tdecimalless scientific notation with exponent a power of two,\n+\t\t\tin the manner of strconv.FormatFloat with the 'b' format,\n \t\t\te.g. -123456p-78\n \t\t%e\tscientific notation, e.g. -1234.456e+78\n \t\t%E\tscientific notation, e.g. -1234.456E+78\n@@ -56,9 +56,12 @@\n \tcharacter '*', causing their values to be obtained from the next\n \toperand, which must be of type int.\n \n-\tFor numeric values, width sets the width of the field and precision\n-\tsets the number of places after the decimal, if appropriate.  For\n-\texample, the format %6.2f prints 123.45.\n+\tFor numeric values, width sets the minimum width of the field and\n+\tprecision sets the number of places after the decimal, if appropriate,\n+\texcept that for %g/%G it sets the total number of digits. For example,\n+\tgiven 123.45 the format %6.2f prints 123.45 while %.4g prints 123.5.\n+\tThe default precision for %e and %f is 6; for %g it is the smallest\n+\tnumber of digits necessary to identify the value uniquely.\n \n \tFor strings, width is the minimum number of characters to output,\n \tpadding with spaces if necessary, and precision is the maximum\n@@ -152,6 +155,7 @@\n \t\t%T is not implemented\n \t\t%e %E %f %F %g %G are all equivalent and scan any floating point or complex value\n \t\t%s and %v on strings scan a space-delimited token\n+\t\tFlags # and + are not implemented.\n \n \tThe familiar base-setting prefixes 0 (octal) and 0x\n \t(hexadecimal) are accepted when scanning integers without a"}, {"sha": "dce46d8a687dd0d8786fee1e276beb4533a94ac2", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -231,7 +231,7 @@ func Sprintf(format string, a ...interface{}) string {\n \treturn s\n }\n \n-// Errorf formats according to a format specifier and returns the string \n+// Errorf formats according to a format specifier and returns the string\n // as a value that satisfies error.\n func Errorf(format string, a ...interface{}) error {\n \treturn errors.New(Sprintf(format, a...))"}, {"sha": "62de3a2efa6be32f834d329e5501d7bd9b8f0794", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -33,8 +33,8 @@ type ScanState interface {\n \tReadRune() (r rune, size int, err error)\n \t// UnreadRune causes the next call to ReadRune to return the same rune.\n \tUnreadRune() error\n-\t// SkipSpace skips space in the input. Newlines are treated as space \n-\t// unless the scan operation is Scanln, Fscanln or Sscanln, in which case \n+\t// SkipSpace skips space in the input. Newlines are treated as space\n+\t// unless the scan operation is Scanln, Fscanln or Sscanln, in which case\n \t// a newline is treated as EOF.\n \tSkipSpace()\n \t// Token skips space in the input if skipSpace is true, then returns the\n@@ -312,7 +312,7 @@ func notSpace(r rune) bool {\n \treturn !isSpace(r)\n }\n \n-// skipSpace provides Scan() methods the ability to skip space and newline characters \n+// skipSpace provides Scan() methods the ability to skip space and newline characters\n // in keeping with the current scanning mode set by format strings and Scan()/Scanln().\n func (s *ss) SkipSpace() {\n \ts.skipSpace(false)"}, {"sha": "252d460af9a766eb5acdeb66e5f586394e1ca135", "filename": "libgo/go/go/ast/commentmap.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fcommentmap.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -99,7 +99,7 @@ func (r *commentListReader) next() {\n \n // A nodeStack keeps track of nested nodes.\n // A node lower on the stack lexically contains the nodes higher on the stack.\n-// \n+//\n type nodeStack []Node\n \n // push pops all nodes that appear lexically before n\n@@ -113,7 +113,7 @@ func (s *nodeStack) push(n Node) {\n // pop pops all nodes that appear lexically before pos\n // (i.e., whose lexical extent has ended before or at pos).\n // It returns the last node popped.\n-// \n+//\n func (s *nodeStack) pop(pos token.Pos) (top Node) {\n \ti := len(*s)\n \tfor i > 0 && (*s)[i-1].End() <= pos {"}, {"sha": "4db5814cb83a167332d9f51706b5765f5fbf7409", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -414,7 +414,7 @@ func MergePackageFiles(pkg *Package, mode MergeMode) *File {\n \t\t\t\tif path := imp.Path.Value; !seen[path] {\n \t\t\t\t\t// TODO: consider handling cases where:\n \t\t\t\t\t// - 2 imports exist with the same import path but\n-\t\t\t\t\t//   have different local names (one should probably \n+\t\t\t\t\t//   have different local names (one should probably\n \t\t\t\t\t//   keep both of them)\n \t\t\t\t\t// - 2 imports exist but only one has a comment\n \t\t\t\t\t// - 2 imports exist and they both have (possibly"}, {"sha": "0406bfc584abf9579c2828f1fd61b08d254897db", "filename": "libgo/go/go/ast/resolve.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -57,7 +57,7 @@ func resolve(scope *Scope, ident *Ident) bool {\n // An Importer must determine the canonical import path and\n // check the map to see if it is already present in the imports map.\n // If so, the Importer can return the map entry.  Otherwise, the\n-// Importer should load the package data for the given path into \n+// Importer should load the package data for the given path into\n // a new *Object (pkg), record pkg in the imports map, and then\n // return pkg.\n type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)"}, {"sha": "6edb31016e03d47f406369a15c2beff243ce99d3", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -76,6 +76,7 @@ func (s *Scope) String() string {\n //\tPkg\t*Scope       package scope\n //\tCon     int          iota for the respective declaration\n //\tCon     != nil       constant value\n+//\tTyp     *Scope       method scope; nil if no methods\n //\n type Object struct {\n \tKind ObjKind"}, {"sha": "fef2503c37e8baa3c7b3d92627bc6ec5b7af89e9", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -158,7 +158,9 @@ func Walk(v Visitor, node Node) {\n \t\tWalk(v, n.Fields)\n \n \tcase *FuncType:\n-\t\tWalk(v, n.Params)\n+\t\tif n.Params != nil {\n+\t\t\tWalk(v, n.Params)\n+\t\t}\n \t\tif n.Results != nil {\n \t\t\tWalk(v, n.Results)\n \t\t}"}, {"sha": "e65d8453bc9374b0e10f0f411122f9e6a3398d2b", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -216,6 +216,7 @@ var cgoEnabled = map[string]bool{\n \t\"darwin/amd64\":  true,\n \t\"freebsd/386\":   true,\n \t\"freebsd/amd64\": true,\n+\t\"freebsd/arm\":   true,\n \t\"linux/386\":     true,\n \t\"linux/amd64\":   true,\n \t\"linux/arm\":     true,\n@@ -897,6 +898,8 @@ func splitQuoted(s string) (r []string, err error) {\n //\t$GOARCH\n //\tcgo (if cgo is enabled)\n //\t!cgo (if cgo is disabled)\n+//\tctxt.Compiler\n+//\t!ctxt.Compiler\n //\ttag (if tag is listed in ctxt.BuildTags)\n //\t!tag (if tag is not listed in ctxt.BuildTags)\n //\ta comma-separated list of any of these\n@@ -928,7 +931,7 @@ func (ctxt *Context) match(name string) bool {\n \tif ctxt.CgoEnabled && name == \"cgo\" {\n \t\treturn true\n \t}\n-\tif name == ctxt.GOOS || name == ctxt.GOARCH {\n+\tif name == ctxt.GOOS || name == ctxt.GOARCH || name == ctxt.Compiler {\n \t\treturn true\n \t}\n "}, {"sha": "e303b7ae23991180f8b359d6c0f3e4c196cbe224", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -24,7 +24,7 @@ import (\n // be used as dependencies by other rules.\n //\n // DO NOT CHANGE THIS DATA TO FIX BUILDS.\n-// \n+//\n var pkgDeps = map[string][]string{\n \t// L0 is the lowest level, core, nearly unavoidable packages.\n \t\"errors\":      {},\n@@ -249,18 +249,23 @@ var pkgDeps = map[string][]string{\n \t\"net/mail\":      {\"L4\", \"NET\", \"OS\"},\n \t\"net/textproto\": {\"L4\", \"OS\", \"net\"},\n \n+\t// Support libraries for crypto that aren't L2.\n+\t\"CRYPTO-SUPPORT\": {\n+\t\t\"crypto/subtle\",\n+\t},\n+\n \t// Core crypto.\n \t\"crypto/aes\":    {\"L3\"},\n \t\"crypto/des\":    {\"L3\"},\n-\t\"crypto/hmac\":   {\"L3\"},\n+\t\"crypto/hmac\":   {\"L3\", \"CRYPTO-SUPPORT\"},\n \t\"crypto/md5\":    {\"L3\"},\n \t\"crypto/rc4\":    {\"L3\"},\n \t\"crypto/sha1\":   {\"L3\"},\n \t\"crypto/sha256\": {\"L3\"},\n \t\"crypto/sha512\": {\"L3\"},\n-\t\"crypto/subtle\": {\"L3\"},\n \n \t\"CRYPTO\": {\n+\t\t\"CRYPTO-SUPPORT\",\n \t\t\"crypto/aes\",\n \t\t\"crypto/des\",\n \t\t\"crypto/hmac\",\n@@ -269,7 +274,6 @@ var pkgDeps = map[string][]string{\n \t\t\"crypto/sha1\",\n \t\t\"crypto/sha256\",\n \t\t\"crypto/sha512\",\n-\t\t\"crypto/subtle\",\n \t},\n \n \t// Random byte, number generation."}, {"sha": "36dd308934c57227c2b22e81eff571df93cfb752", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -23,24 +23,24 @@\n // As in the Go tree, each target operating system and\n // architecture pair has its own subdirectory of pkg\n // (pkg/GOOS_GOARCH).\n-// \n+//\n // If DIR is a directory listed in the Go path, a package with\n // source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n // has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\"\n // (or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\").\n-// \n+//\n // The bin/ directory holds compiled commands.\n // Each command is named for its source directory, but only\n // using the final element, not the entire path.  That is, the\n // command with source in DIR/src/foo/quux is installed into\n // DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n // so that you can add DIR/bin to your PATH to get at the\n // installed commands.\n-// \n+//\n // Here's an example directory layout:\n-// \n+//\n //\tGOPATH=/home/user/gocode\n-// \n+//\n //\t/home/user/gocode/\n //\t    src/\n //\t        foo/\n@@ -74,10 +74,21 @@\n //\n //\t(linux AND 386) OR (darwin AND (NOT cgo))\n //\n+// A file may have multiple build constraints. The overall constraint is the AND\n+// of the individual constraints. That is, the build constraints:\n+//\n+//\t// +build linux darwin\n+//\t// +build 386\n+//\n+// corresponds to the boolean formula:\n+//\n+//\t(linux OR darwin) AND 386\n+//\n // During a particular build, the following words are satisfied:\n //\n //\t- the target operating system, as spelled by runtime.GOOS\n //\t- the target architecture, as spelled by runtime.GOARCH\n+//\t- the compiler being used, currently either \"gc\" or \"gccgo\"\n //\t- \"cgo\", if ctxt.CgoEnabled is true\n //\t- any additional words listed in ctxt.BuildTags\n //"}, {"sha": "51e2bf73243372e62ae75398c0498f4cee23fe79", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -174,7 +174,7 @@ func unindent(block []string) {\n }\n \n // heading returns the trimmed line if it passes as a section heading;\n-// otherwise it returns the empty string. \n+// otherwise it returns the empty string.\n func heading(line string) string {\n \tline = strings.TrimSpace(line)\n \tif len(line) == 0 {"}, {"sha": "e5752bb15a16ee22124f6a9bd37cd0f36c82994d", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -119,7 +119,7 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t\treturn nil\n \t}\n \n-\t// Find unresolved identifiers \n+\t// Find unresolved identifiers\n \tunresolved := make(map[string]bool)\n \tast.Inspect(body, func(n ast.Node) bool {\n \t\t// For an expression like fmt.Println, only add \"fmt\" to the\n@@ -145,23 +145,28 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \n \t// Use unresolved identifiers to determine the imports used by this\n \t// example. The heuristic assumes package names match base import\n-\t// paths. (Should be good enough most of the time.)\n-\timports := make(map[string]string) // [name]path\n+\t// paths for imports w/o renames (should be good enough most of the time).\n+\tnamedImports := make(map[string]string) // [name]path\n+\tvar blankImports []ast.Spec             // _ imports\n \tfor _, s := range file.Imports {\n \t\tp, err := strconv.Unquote(s.Path.Value)\n \t\tif err != nil {\n \t\t\tcontinue\n \t\t}\n \t\tn := path.Base(p)\n \t\tif s.Name != nil {\n-\t\t\tif s.Name.Name == \".\" {\n+\t\t\tn = s.Name.Name\n+\t\t\tswitch n {\n+\t\t\tcase \"_\":\n+\t\t\t\tblankImports = append(blankImports, s)\n+\t\t\t\tcontinue\n+\t\t\tcase \".\":\n \t\t\t\t// We can't resolve dot imports (yet).\n \t\t\t\treturn nil\n \t\t\t}\n-\t\t\tn = s.Name.Name\n \t\t}\n \t\tif unresolved[n] {\n-\t\t\timports[n] = p\n+\t\t\tnamedImports[n] = p\n \t\t\tdelete(unresolved, n)\n \t\t}\n \t}\n@@ -172,13 +177,19 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t\treturn nil\n \t}\n \n-\t// Filter out comments that are outside the function body.\n+\t// Include documentation belonging to blank imports.\n \tvar comments []*ast.CommentGroup\n+\tfor _, s := range blankImports {\n+\t\tif c := s.(*ast.ImportSpec).Doc; c != nil {\n+\t\t\tcomments = append(comments, c)\n+\t\t}\n+\t}\n+\n+\t// Include comments that are inside the function body.\n \tfor _, c := range file.Comments {\n-\t\tif c.Pos() < body.Pos() || c.Pos() >= body.End() {\n-\t\t\tcontinue\n+\t\tif body.Pos() <= c.Pos() && c.End() <= body.End() {\n+\t\t\tcomments = append(comments, c)\n \t\t}\n-\t\tcomments = append(comments, c)\n \t}\n \n \t// Strip \"Output:\" commment and adjust body end position.\n@@ -190,13 +201,14 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t\tLparen: 1, // Need non-zero Lparen and Rparen so that printer\n \t\tRparen: 1, // treats this as a factored import.\n \t}\n-\tfor n, p := range imports {\n+\tfor n, p := range namedImports {\n \t\ts := &ast.ImportSpec{Path: &ast.BasicLit{Value: strconv.Quote(p)}}\n \t\tif path.Base(p) != n {\n \t\t\ts.Name = ast.NewIdent(n)\n \t\t}\n \t\timportDecl.Specs = append(importDecl.Specs, s)\n \t}\n+\timportDecl.Specs = append(importDecl.Specs, blankImports...)\n \n \t// Synthesize main function.\n \tfuncDecl := &ast.FuncDecl{\n@@ -213,7 +225,7 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t}\n }\n \n-// playExample takes a whole file example and synthesizes a new *ast.File\n+// playExampleFile takes a whole file example and synthesizes a new *ast.File\n // such that the example is function main in package main.\n func playExampleFile(file *ast.File) *ast.File {\n \t// Strip copyright comment if present.\n@@ -243,7 +255,7 @@ func playExampleFile(file *ast.File) *ast.File {\n \treturn &f\n }\n \n-// stripOutputComment finds and removes an \"Output:\" commment from body \n+// stripOutputComment finds and removes an \"Output:\" commment from body\n // and comments, and adjusts the body block's end position.\n func stripOutputComment(body *ast.BlockStmt, comments []*ast.CommentGroup) (*ast.BlockStmt, []*ast.CommentGroup) {\n \t// Do nothing if no \"Output:\" comment found."}, {"sha": "ff01285d4c31aaf6c33d38706c7dda9abbcf7be7", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -107,7 +107,7 @@ func (r *reader) filterParamList(fields *ast.FieldList) {\n \n // filterType strips any unexported struct fields or method types from typ\n // in place. If fields (or methods) have been removed, the corresponding\n-// struct or interface type has the Incomplete field set to true. \n+// struct or interface type has the Incomplete field set to true.\n //\n func (r *reader) filterType(parent *namedType, typ ast.Expr) {\n \tswitch t := typ.(type) {"}, {"sha": "fafd8f98eaf1225ddae4bdadede8207e84c0a2a8", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -46,7 +46,7 @@ func (mset methodSet) set(f *ast.FuncDecl) {\n \t\t// since it has documentation, assume f is simply another\n \t\t// implementation and ignore it. This does not happen if the\n \t\t// caller is using go/build.ScanDir to determine the list of\n-\t\t// files implementing a package. \n+\t\t// files implementing a package.\n \t\treturn\n \t}\n \t// function doesn't exist or has no documentation; use f\n@@ -597,7 +597,7 @@ func (r *reader) computeMethodSets() {\n // types that have no declaration. Instead, these functions and methods\n // are shown at the package level. It also removes types with missing\n // declarations or which are not visible.\n-// \n+//\n func (r *reader) cleanupTypes() {\n \tfor _, t := range r.types {\n \t\tvisible := r.isVisible(t.name)"}, {"sha": "ec432e3e527f18e8f71465231721bed43625d978", "filename": "libgo/go/go/doc/testdata/e.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -106,7 +106,7 @@ type U4 struct {\n \t*u5\n }\n \n-// U4.M should appear as method of U4. \n+// U4.M should appear as method of U4.\n func (*U4) M() {}\n \n type u5 struct {"}, {"sha": "c2499ad77997b650e04b4dd27d7b3ee9206faa33", "filename": "libgo/go/go/doc/testdata/testing.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -197,7 +197,7 @@ func (c *common) Fatalf(format string, args ...interface{}) {\n \tc.FailNow()\n }\n \n-// Parallel signals that this test is to be run in parallel with (and only with) \n+// Parallel signals that this test is to be run in parallel with (and only with)\n // other parallel tests in this CPU group.\n func (t *T) Parallel() {\n \tt.signal <- (*T)(nil) // Release main testing loop\n@@ -215,7 +215,7 @@ func tRunner(t *T, test *InternalTest) {\n \tt.start = time.Now()\n \n \t// When this goroutine is done, either because test.F(t)\n-\t// returned normally or because a test failure triggered \n+\t// returned normally or because a test failure triggered\n \t// a call to runtime.Goexit, record the duration and send\n \t// a signal saying that the test is done.\n \tdefer func() {"}, {"sha": "fac513e557c0a9074198eb9f3324cb128816be7b", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -158,7 +158,7 @@ func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, m\n \n // ParseExpr is a convenience function for obtaining the AST of an expression x.\n // The position information recorded in the AST is undefined.\n-// \n+//\n func ParseExpr(x string) (ast.Expr, error) {\n \t// parse x within the context of a complete package for correct scopes;\n \t// use //line directive for correct positions in error messages and put"}, {"sha": "31f5ef0883c1b64e1f48983438fb3bd091dec16a", "filename": "libgo/go/go/printer/performance_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // This file implements a simple printer performance benchmark:\n-// go test -bench=BenchmarkPrint \n+// go test -bench=BenchmarkPrint\n \n package printer\n "}, {"sha": "e79e3ffda2629fa15d9374339188a9abf6b8a8d3", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"text/tabwriter\"\n+\t\"unicode\"\n )\n \n const (\n@@ -220,14 +221,6 @@ func (p *printer) writeString(pos token.Position, s string, isLit bool) {\n \t\t// atLineBegin updates p.pos if there's indentation, but p.pos\n \t\t// is the position of s.\n \t\tp.pos = pos\n-\t\t// reset state if the file changed\n-\t\t// (used when printing merged ASTs of different files\n-\t\t// e.g., the result of ast.MergePackageFiles)\n-\t\tif p.last.IsValid() && p.last.Filename != pos.Filename {\n-\t\t\tp.indent = 0\n-\t\t\tp.mode = 0\n-\t\t\tp.wsbuf = p.wsbuf[0:0]\n-\t\t}\n \t}\n \n \tif isLit {\n@@ -405,6 +398,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n // Split comment text into lines\n // (using strings.Split(text, \"\\n\") is significantly slower for\n // this specific purpose, as measured with: go test -bench=Print)\n+//\n func split(text string) []string {\n \t// count lines (comment text never ends in a newline)\n \tn := 1\n@@ -432,6 +426,7 @@ func split(text string) []string {\n \n // Returns true if s contains only white space\n // (only tabs and blanks can appear in the printer's context).\n+//\n func isBlank(s string) bool {\n \tfor i := 0; i < len(s); i++ {\n \t\tif s[i] > ' ' {\n@@ -441,6 +436,7 @@ func isBlank(s string) bool {\n \treturn true\n }\n \n+// commonPrefix returns the common prefix of a and b.\n func commonPrefix(a, b string) string {\n \ti := 0\n \tfor i < len(a) && i < len(b) && a[i] == b[i] && (a[i] <= ' ' || a[i] == '*') {\n@@ -449,6 +445,11 @@ func commonPrefix(a, b string) string {\n \treturn a[0:i]\n }\n \n+// trimRight returns s with trailing whitespace removed.\n+func trimRight(s string) string {\n+\treturn strings.TrimRightFunc(s, unicode.IsSpace)\n+}\n+\n // stripCommonPrefix removes a common prefix from /*-style comment lines (unless no\n // comment line is indented, all but the first line have some form of space prefix).\n // The prefix is computed using heuristics such that is is likely that the comment\n@@ -611,7 +612,7 @@ func (p *printer) writeComment(comment *ast.Comment) {\n \n \t// shortcut common case of //-style comments\n \tif text[1] == '/' {\n-\t\tp.writeString(pos, text, true)\n+\t\tp.writeString(pos, trimRight(text), true)\n \t\treturn\n \t}\n \n@@ -641,7 +642,7 @@ func (p *printer) writeComment(comment *ast.Comment) {\n \t\t\tpos = p.pos\n \t\t}\n \t\tif len(line) > 0 {\n-\t\t\tp.writeString(pos, line, true)\n+\t\t\tp.writeString(pos, trimRight(line), true)\n \t\t}\n \t}\n }\n@@ -1159,7 +1160,7 @@ func (p *trimmer) Write(data []byte) (n int, err error) {\n // ----------------------------------------------------------------------------\n // Public interface\n \n-// A Mode value is a set of flags (or 0). They control printing. \n+// A Mode value is a set of flags (or 0). They control printing.\n type Mode uint\n \n const ("}, {"sha": "610a42a68bda5bf1b9ea7258404c9a11b5d114a7", "filename": "libgo/go/go/printer/testdata/comments.golden", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -529,7 +529,7 @@ func _() {\n }\n \n func _() {\n-\tvar a = []int{1, 2}// jasldf \n+\tvar a = []int{1, 2}// jasldf\n \n \t_ = a\n }\n@@ -626,4 +626,13 @@ func _() {\n \tvar lflag bool\t\t// -l\t\t\t- disable line directives\n }\n \n+// Trailing white space in comments should be trimmed\n+func _() {\n+\t// This comment has 4 blanks following that should be trimmed:\n+\t/* Each line of this comment has blanks or tabs following that should be trimmed:\n+\t   line 2:\n+\t   line 3:\n+\t*/\n+}\n+\n /* This comment is the last entry in this file. It must be printed and should be followed by a newline */"}, {"sha": "d121dd4be77d706162dad3db38132247a85d3aef", "filename": "libgo/go/go/printer/testdata/comments.input", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -534,7 +534,7 @@ func _() {\n }\n \n func _() {\n-\tvar a = []int{1, 2, // jasldf \n+\tvar a = []int{1, 2, // jasldf\n \t}\n \t_ = a\n }\n@@ -630,5 +630,13 @@ var\tvflag\t\tstring\t\t\t\t// -v [y.output]\t- y.output file\n var\tlflag\t\tbool\t\t\t\t// -l\t\t\t- disable line directives\n }\n \n+// Trailing white space in comments should be trimmed\n+func _() {\n+// This comment has 4 blanks following that should be trimmed:    \n+/* Each line of this comment has blanks or tabs following that should be trimmed:\t\n+   line 2:    \n+   line 3:    \t\t\t\n+*/\n+}\n \n /* This comment is the last entry in this file. It must be printed and should be followed by a newline */"}, {"sha": "fc45c1e7693efd56fc38784556f4c7e27d6602a3", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -76,7 +76,7 @@ type Pos int\n // associated with it, and NoPos().IsValid() is false. NoPos is always\n // smaller than any other Pos value. The corresponding Position value\n // for NoPos is the zero value for Position.\n-// \n+//\n const NoPos Pos = 0\n \n // IsValid returns true if the position is valid.\n@@ -347,7 +347,7 @@ func (s *FileSet) AddFile(filename string, base, size int) *File {\n \n // Iterate calls f for the files in the file set in the order they were added\n // until f returns false.\n-// \n+//\n func (s *FileSet) Iterate(f func(*File) bool) {\n \tfor i := 0; ; i++ {\n \t\tvar file *File"}, {"sha": "eff0384e089e32139d266138c1ea63a5608e5dfa", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -15,7 +15,7 @@ type writer interface {\n \tWriteString(string) (int, error)\n }\n \n-// These replacements permit compatibility with old numeric entities that \n+// These replacements permit compatibility with old numeric entities that\n // assumed Windows-1252 encoding.\n // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#consume-a-character-reference\n var replacementTable = [...]rune{\n@@ -51,7 +51,7 @@ var replacementTable = [...]rune{\n \t'\\u009D',\n \t'\\u017E',\n \t'\\u0178', // Last entry is 0x9F.\n-\t// 0x00->'\\uFFFD' is handled programmatically. \n+\t// 0x00->'\\uFFFD' is handled programmatically.\n \t// 0x0D->'\\u000D' is a no-op.\n }\n "}, {"sha": "9d1f74f6f01772ae17a63ed0e6b724746a845cce", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -30,7 +30,7 @@ type (\n \tHTMLAttr string\n \n \t// JS encapsulates a known safe EcmaScript5 Expression, for example,\n-\t// `(x + y * z())`. \n+\t// `(x + y * z())`.\n \t// Template authors are responsible for ensuring that typed expressions\n \t// do not break the intended precedence and that there is no\n \t// statement/expression ambiguity as when passing an expression like"}, {"sha": "46e49ccf83021a0b197f9430fa2cadc02aaee245", "filename": "libgo/go/html/template/error.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -102,7 +102,7 @@ const (\n \t//\n \t//   {{define \"main\"}} <script>{{template \"helper\"}}</script> {{end}}\n \t//   {{define \"helper\"}} document.write(' <div title=\" ') {{end}}\n-\t// \n+\t//\n \t//   \"helper\" does not produce a valid document fragment, so should\n \t//   not be Executed directly.\n \tErrEndContext\n@@ -161,7 +161,7 @@ const (\n \t//   In the example, there is missing a quote, so it is not clear\n \t//   whether {{.}} is meant to be inside a JS string or in a JS value\n \t//   context.  The second iteration would produce something like\n-\t// \n+\t//\n \t//     <script>var x = ['firstValue,'secondValue]</script>\n \tErrRangeLoopReentry\n "}, {"sha": "f25f1074c7beb5f8cca249a4c9688b5be5f342fc", "filename": "libgo/go/html/template/html.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Ftemplate%2Fhtml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fhtml%2Ftemplate%2Fhtml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fhtml.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -106,7 +106,7 @@ var htmlNospaceReplacementTable = []string{\n \t'<':  \"&lt;\",\n \t'=':  \"&#61;\",\n \t'>':  \"&gt;\",\n-\t// A parse error in the attribute value (unquoted) and \n+\t// A parse error in the attribute value (unquoted) and\n \t// before attribute value states.\n \t// Treated as a quoting character by IE.\n \t'`': \"&#96;\",\n@@ -128,7 +128,7 @@ var htmlNospaceNormReplacementTable = []string{\n \t'<':  \"&lt;\",\n \t'=':  \"&#61;\",\n \t'>':  \"&gt;\",\n-\t// A parse error in the attribute value (unquoted) and \n+\t// A parse error in the attribute value (unquoted) and\n \t// before attribute value states.\n \t// Treated as a quoting character by IE.\n \t'`': \"&#96;\",\n@@ -143,7 +143,7 @@ func htmlReplacer(s string, replacementTable []string, badRunes bool) string {\n \t\t\tif repl := replacementTable[r]; len(repl) != 0 {\n \t\t\t\tb.WriteString(s[written:i])\n \t\t\t\tb.WriteString(repl)\n-\t\t\t\t// Valid as long as replacementTable doesn't \n+\t\t\t\t// Valid as long as replacementTable doesn't\n \t\t\t\t// include anything above 0x7f.\n \t\t\t\twritten = i + utf8.RuneLen(r)\n \t\t\t}"}, {"sha": "8dee57ee4678231682c2ec1ebbd3ca611b160575", "filename": "libgo/go/image/decode_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -31,6 +31,7 @@ var imageTests = []imageTest{\n \t{\"testdata/video-001.png\", \"testdata/video-001.5bpp.gif\", 128 << 8},\n \t// JPEG is a lossy format and hence needs a non-zero tolerance.\n \t{\"testdata/video-001.png\", \"testdata/video-001.jpeg\", 8 << 8},\n+\t{\"testdata/video-001.png\", \"testdata/video-001.progressive.jpeg\", 8 << 8},\n \t// Grayscale images.\n \t{\"testdata/video-005.gray.png\", \"testdata/video-005.gray.jpeg\", 8 << 8},\n \t{\"testdata/video-005.gray.png\", \"testdata/video-005.gray.png\", 0},"}, {"sha": "56d30dd6f824f1f112c3256906ff67c4a0ce8fb8", "filename": "libgo/go/image/draw/draw.go", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -81,8 +81,9 @@ func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mas\n \t\t\t\t\tdrawNRGBAOver(dst0, r, src0, sp)\n \t\t\t\t\treturn\n \t\t\t\tcase *image.YCbCr:\n-\t\t\t\t\tdrawYCbCr(dst0, r, src0, sp)\n-\t\t\t\t\treturn\n+\t\t\t\t\tif drawYCbCr(dst0, r, src0, sp) {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else if mask0, ok := mask.(*image.Alpha); ok {\n \t\t\t\tswitch src0 := src.(type) {\n@@ -104,8 +105,9 @@ func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mas\n \t\t\t\t\tdrawNRGBASrc(dst0, r, src0, sp)\n \t\t\t\t\treturn\n \t\t\t\tcase *image.YCbCr:\n-\t\t\t\t\tdrawYCbCr(dst0, r, src0, sp)\n-\t\t\t\t\treturn\n+\t\t\t\t\tif drawYCbCr(dst0, r, src0, sp) {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -345,14 +347,27 @@ func drawNRGBASrc(dst *image.RGBA, r image.Rectangle, src *image.NRGBA, sp image\n \t}\n }\n \n-func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Point) {\n+func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Point) (ok bool) {\n \t// An image.YCbCr is always fully opaque, and so if the mask is implicitly nil\n \t// (i.e. fully opaque) then the op is effectively always Src.\n \tx0 := (r.Min.X - dst.Rect.Min.X) * 4\n \tx1 := (r.Max.X - dst.Rect.Min.X) * 4\n \ty0 := r.Min.Y - dst.Rect.Min.Y\n \ty1 := r.Max.Y - dst.Rect.Min.Y\n \tswitch src.SubsampleRatio {\n+\tcase image.YCbCrSubsampleRatio444:\n+\t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n+\t\t\tdpix := dst.Pix[y*dst.Stride:]\n+\t\t\tyi := (sy-src.Rect.Min.Y)*src.YStride + (sp.X - src.Rect.Min.X)\n+\t\t\tci := (sy-src.Rect.Min.Y)*src.CStride + (sp.X - src.Rect.Min.X)\n+\t\t\tfor x := x0; x != x1; x, yi, ci = x+4, yi+1, ci+1 {\n+\t\t\t\trr, gg, bb := color.YCbCrToRGB(src.Y[yi], src.Cb[ci], src.Cr[ci])\n+\t\t\t\tdpix[x+0] = rr\n+\t\t\t\tdpix[x+1] = gg\n+\t\t\t\tdpix[x+2] = bb\n+\t\t\t\tdpix[x+3] = 255\n+\t\t\t}\n+\t\t}\n \tcase image.YCbCrSubsampleRatio422:\n \t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n \t\t\tdpix := dst.Pix[y*dst.Stride:]\n@@ -381,12 +396,11 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Po\n \t\t\t\tdpix[x+3] = 255\n \t\t\t}\n \t\t}\n-\tdefault:\n-\t\t// Default to 4:4:4 subsampling.\n+\tcase image.YCbCrSubsampleRatio440:\n \t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n \t\t\tdpix := dst.Pix[y*dst.Stride:]\n \t\t\tyi := (sy-src.Rect.Min.Y)*src.YStride + (sp.X - src.Rect.Min.X)\n-\t\t\tci := (sy-src.Rect.Min.Y)*src.CStride + (sp.X - src.Rect.Min.X)\n+\t\t\tci := (sy/2-src.Rect.Min.Y/2)*src.CStride + (sp.X - src.Rect.Min.X)\n \t\t\tfor x := x0; x != x1; x, yi, ci = x+4, yi+1, ci+1 {\n \t\t\t\trr, gg, bb := color.YCbCrToRGB(src.Y[yi], src.Cb[ci], src.Cr[ci])\n \t\t\t\tdpix[x+0] = rr\n@@ -395,7 +409,10 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Po\n \t\t\t\tdpix[x+3] = 255\n \t\t\t}\n \t\t}\n+\tdefault:\n+\t\treturn false\n \t}\n+\treturn true\n }\n \n func drawGlyphOver(dst *image.RGBA, r image.Rectangle, src *image.Uniform, mask *image.Alpha, mp image.Point) {"}, {"sha": "7389f7e4fe81395e81e71a152bfd72808f6f0f6c", "filename": "libgo/go/image/jpeg/dct_test.go", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fdct_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -42,7 +42,7 @@ func TestDCT(t *testing.T) {\n \t\tb := block{}\n \t\tn := r.Int() % 64\n \t\tfor j := 0; j < n; j++ {\n-\t\t\tb[r.Int()%len(b)] = r.Int() % 256\n+\t\t\tb[r.Int()%len(b)] = r.Int31() % 256\n \t\t}\n \t\tblocks = append(blocks, b)\n \t}\n@@ -112,6 +112,14 @@ func alpha(i int) float64 {\n \treturn math.Sqrt2\n }\n \n+var cosines [32]float64 // cosines[k] =\u00a0cos(\u03c0/2 * k/8)\n+\n+func init() {\n+\tfor k := range cosines {\n+\t\tcosines[k] = math.Cos(math.Pi * float64(k) / 16)\n+\t}\n+}\n+\n // slowFDCT performs the 8*8 2-dimensional forward discrete cosine transform:\n //\n //\tdst[u,v] = (1/8) * \u03a3_x \u03a3_y alpha(u) * alpha(v) * src[x,y] *\n@@ -129,16 +137,16 @@ func slowFDCT(b *block) {\n \t\t\tfor y := 0; y < 8; y++ {\n \t\t\t\tfor x := 0; x < 8; x++ {\n \t\t\t\t\tsum += alpha(u) * alpha(v) * float64(b[8*y+x]) *\n-\t\t\t\t\t\tmath.Cos(math.Pi*float64((2*x+1)*u)/16) *\n-\t\t\t\t\t\tmath.Cos(math.Pi*float64((2*y+1)*v)/16)\n+\t\t\t\t\t\tcosines[((2*x+1)*u)%32] *\n+\t\t\t\t\t\tcosines[((2*y+1)*v)%32]\n \t\t\t\t}\n \t\t\t}\n \t\t\tdst[8*v+u] = sum / 8\n \t\t}\n \t}\n-\t// Convert from float64 to int.\n+\t// Convert from float64 to int32.\n \tfor i := range dst {\n-\t\tb[i] = int(dst[i] + 0.5)\n+\t\tb[i] = int32(dst[i] + 0.5)\n \t}\n }\n \n@@ -159,16 +167,16 @@ func slowIDCT(b *block) {\n \t\t\tfor v := 0; v < 8; v++ {\n \t\t\t\tfor u := 0; u < 8; u++ {\n \t\t\t\t\tsum += alpha(u) * alpha(v) * float64(b[8*v+u]) *\n-\t\t\t\t\t\tmath.Cos(math.Pi*float64((2*x+1)*u)/16) *\n-\t\t\t\t\t\tmath.Cos(math.Pi*float64((2*y+1)*v)/16)\n+\t\t\t\t\t\tcosines[((2*x+1)*u)%32] *\n+\t\t\t\t\t\tcosines[((2*y+1)*v)%32]\n \t\t\t\t}\n \t\t\t}\n \t\t\tdst[8*y+x] = sum / 8\n \t\t}\n \t}\n-\t// Convert from float64 to int.\n+\t// Convert from float64 to int32.\n \tfor i := range dst {\n-\t\tb[i] = int(dst[i] + 0.5)\n+\t\tb[i] = int32(dst[i] + 0.5)\n \t}\n }\n "}, {"sha": "2fc64ade546dd82db9a4a0eb7c5557391de76533", "filename": "libgo/go/image/jpeg/huffman.go", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -15,9 +15,9 @@ const maxNumValues = 256\n // Bit stream for the Huffman decoder.\n // The n least significant bits of a form the unread bits, to be read in MSB to LSB order.\n type bits struct {\n-\ta int // accumulator.\n-\tn int // the number of unread bits in a.\n-\tm int // mask. m==1<<(n-1) when n>0, with m==0 when n==0.\n+\ta uint32 // accumulator.\n+\tm uint32 // mask. m==1<<(n-1) when n>0, with m==0 when n==0.\n+\tn int    // the number of unread bits in a.\n }\n \n // Huffman table decoder, specified in section C.\n@@ -39,7 +39,7 @@ func (d *decoder) ensureNBits(n int) error {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\td.b.a = d.b.a<<8 | int(c)\n+\t\td.b.a = d.b.a<<8 | uint32(c)\n \t\td.b.n += 8\n \t\tif d.b.m == 0 {\n \t\t\td.b.m = 1 << 7\n@@ -61,15 +61,16 @@ func (d *decoder) ensureNBits(n int) error {\n }\n \n // The composition of RECEIVE and EXTEND, specified in section F.2.2.1.\n-func (d *decoder) receiveExtend(t uint8) (int, error) {\n-\terr := d.ensureNBits(int(t))\n-\tif err != nil {\n-\t\treturn 0, err\n+func (d *decoder) receiveExtend(t uint8) (int32, error) {\n+\tif d.b.n < int(t) {\n+\t\tif err := d.ensureNBits(int(t)); err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n \t}\n \td.b.n -= int(t)\n \td.b.m >>= t\n-\ts := 1 << t\n-\tx := (d.b.a >> uint8(d.b.n)) & (s - 1)\n+\ts := int32(1) << t\n+\tx := int32(d.b.a>>uint8(d.b.n)) & (s - 1)\n \tif x < s>>1 {\n \t\tx += ((-1) << t) + 1\n \t}\n@@ -92,8 +93,7 @@ func (d *decoder) processDHT(n int) error {\n \t\t\treturn FormatError(\"bad Tc value\")\n \t\t}\n \t\tth := d.tmp[0] & 0x0f\n-\t\tconst isBaseline = true // Progressive mode is not yet supported.\n-\t\tif th > maxTh || isBaseline && th > 1 {\n+\t\tif th > maxTh || !d.progressive && th > 1 {\n \t\t\treturn FormatError(\"bad Th value\")\n \t\t}\n \t\th := &d.huff[tc][th]\n@@ -169,9 +169,10 @@ func (d *decoder) decodeHuffman(h *huffman) (uint8, error) {\n \t\treturn 0, FormatError(\"uninitialized Huffman table\")\n \t}\n \tfor i, code := 0, 0; i < maxCodeLength; i++ {\n-\t\terr := d.ensureNBits(1)\n-\t\tif err != nil {\n-\t\t\treturn 0, err\n+\t\tif d.b.n == 0 {\n+\t\t\tif err := d.ensureNBits(1); err != nil {\n+\t\t\t\treturn 0, err\n+\t\t\t}\n \t\t}\n \t\tif d.b.a&d.b.m != 0 {\n \t\t\tcode |= 1\n@@ -185,3 +186,28 @@ func (d *decoder) decodeHuffman(h *huffman) (uint8, error) {\n \t}\n \treturn 0, FormatError(\"bad Huffman code\")\n }\n+\n+func (d *decoder) decodeBit() (bool, error) {\n+\tif d.b.n == 0 {\n+\t\tif err := d.ensureNBits(1); err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n+\tret := d.b.a&d.b.m != 0\n+\td.b.n--\n+\td.b.m >>= 1\n+\treturn ret, nil\n+}\n+\n+func (d *decoder) decodeBits(n int) (uint32, error) {\n+\tif d.b.n < n {\n+\t\tif err := d.ensureNBits(n); err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t}\n+\tret := d.b.a >> uint(d.b.n-n)\n+\tret &= (1 << uint(n)) - 1\n+\td.b.n -= n\n+\td.b.m >>= uint(n)\n+\treturn ret, nil\n+}"}, {"sha": "46fcaecb798524ab0ec288c985935522a20a5818", "filename": "libgo/go/image/jpeg/idct.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -39,7 +39,7 @@ package jpeg\n \n const blockSize = 64 // A DCT block is 8x8.\n \n-type block [blockSize]int\n+type block [blockSize]int32\n \n const (\n \tw1 = 2841 // 2048*sqrt(2)*cos(1*pi/16)"}, {"sha": "24dd65defcc75b96de8a1906e86a75c60d404587", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 14, "deletions": 185, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -98,7 +98,10 @@ type decoder struct {\n \timg3          *image.YCbCr\n \tri            int // Restart Interval.\n \tnComp         int\n+\tprogressive   bool\n+\teobRun        uint16 // End-of-Band run, specified in section G.1.2.2.\n \tcomp          [nColorComponent]component\n+\tprogCoeffs    [nColorComponent][]block // Saved state between progressive-mode scans.\n \thuff          [maxTc + 1][maxTh + 1]huffman\n \tquant         [maxTq + 1]block // Quantization tables, in zig-zag order.\n \ttmp           [1024]byte\n@@ -184,7 +187,7 @@ func (d *decoder) processDQT(n int) error {\n \t\t\treturn FormatError(\"bad Tq value\")\n \t\t}\n \t\tfor i := range d.quant[tq] {\n-\t\t\td.quant[tq][i] = int(d.tmp[i+1])\n+\t\t\td.quant[tq][i] = int32(d.tmp[i+1])\n \t\t}\n \t}\n \tif n != 0 {\n@@ -193,187 +196,6 @@ func (d *decoder) processDQT(n int) error {\n \treturn nil\n }\n \n-// makeImg allocates and initializes the destination image.\n-func (d *decoder) makeImg(h0, v0, mxx, myy int) {\n-\tif d.nComp == nGrayComponent {\n-\t\tm := image.NewGray(image.Rect(0, 0, 8*mxx, 8*myy))\n-\t\td.img1 = m.SubImage(image.Rect(0, 0, d.width, d.height)).(*image.Gray)\n-\t\treturn\n-\t}\n-\tvar subsampleRatio image.YCbCrSubsampleRatio\n-\tswitch {\n-\tcase h0 == 1 && v0 == 1:\n-\t\tsubsampleRatio = image.YCbCrSubsampleRatio444\n-\tcase h0 == 1 && v0 == 2:\n-\t\tsubsampleRatio = image.YCbCrSubsampleRatio440\n-\tcase h0 == 2 && v0 == 1:\n-\t\tsubsampleRatio = image.YCbCrSubsampleRatio422\n-\tcase h0 == 2 && v0 == 2:\n-\t\tsubsampleRatio = image.YCbCrSubsampleRatio420\n-\tdefault:\n-\t\tpanic(\"unreachable\")\n-\t}\n-\tm := image.NewYCbCr(image.Rect(0, 0, 8*h0*mxx, 8*v0*myy), subsampleRatio)\n-\td.img3 = m.SubImage(image.Rect(0, 0, d.width, d.height)).(*image.YCbCr)\n-}\n-\n-// Specified in section B.2.3.\n-func (d *decoder) processSOS(n int) error {\n-\tif d.nComp == 0 {\n-\t\treturn FormatError(\"missing SOF marker\")\n-\t}\n-\tif n != 4+2*d.nComp {\n-\t\treturn UnsupportedError(\"SOS has wrong length\")\n-\t}\n-\t_, err := io.ReadFull(d.r, d.tmp[0:4+2*d.nComp])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif int(d.tmp[0]) != d.nComp {\n-\t\treturn UnsupportedError(\"SOS has wrong number of image components\")\n-\t}\n-\tvar scan [nColorComponent]struct {\n-\t\ttd uint8 // DC table selector.\n-\t\tta uint8 // AC table selector.\n-\t}\n-\tfor i := 0; i < d.nComp; i++ {\n-\t\tcs := d.tmp[1+2*i] // Component selector.\n-\t\tif cs != d.comp[i].c {\n-\t\t\treturn UnsupportedError(\"scan components out of order\")\n-\t\t}\n-\t\tscan[i].td = d.tmp[2+2*i] >> 4\n-\t\tscan[i].ta = d.tmp[2+2*i] & 0x0f\n-\t}\n-\t// mxx and myy are the number of MCUs (Minimum Coded Units) in the image.\n-\th0, v0 := d.comp[0].h, d.comp[0].v // The h and v values from the Y components.\n-\tmxx := (d.width + 8*h0 - 1) / (8 * h0)\n-\tmyy := (d.height + 8*v0 - 1) / (8 * v0)\n-\tif d.img1 == nil && d.img3 == nil {\n-\t\td.makeImg(h0, v0, mxx, myy)\n-\t}\n-\n-\tmcu, expectedRST := 0, uint8(rst0Marker)\n-\tvar (\n-\t\tb  block\n-\t\tdc [nColorComponent]int\n-\t)\n-\tfor my := 0; my < myy; my++ {\n-\t\tfor mx := 0; mx < mxx; mx++ {\n-\t\t\tfor i := 0; i < d.nComp; i++ {\n-\t\t\t\tqt := &d.quant[d.comp[i].tq]\n-\t\t\t\tfor j := 0; j < d.comp[i].h*d.comp[i].v; j++ {\n-\t\t\t\t\t// TODO(nigeltao): make this a \"var b block\" once the compiler's escape\n-\t\t\t\t\t// analysis is good enough to allocate it on the stack, not the heap.\n-\t\t\t\t\t// b is in natural (not zig-zag) order.\n-\t\t\t\t\tb = block{}\n-\n-\t\t\t\t\t// Decode the DC coefficient, as specified in section F.2.2.1.\n-\t\t\t\t\tvalue, err := d.decodeHuffman(&d.huff[dcTable][scan[i].td])\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn err\n-\t\t\t\t\t}\n-\t\t\t\t\tif value > 16 {\n-\t\t\t\t\t\treturn UnsupportedError(\"excessive DC component\")\n-\t\t\t\t\t}\n-\t\t\t\t\tdcDelta, err := d.receiveExtend(value)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn err\n-\t\t\t\t\t}\n-\t\t\t\t\tdc[i] += dcDelta\n-\t\t\t\t\tb[0] = dc[i] * qt[0]\n-\n-\t\t\t\t\t// Decode the AC coefficients, as specified in section F.2.2.2.\n-\t\t\t\t\tfor zig := 1; zig < blockSize; zig++ {\n-\t\t\t\t\t\tvalue, err := d.decodeHuffman(&d.huff[acTable][scan[i].ta])\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\treturn err\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tval0 := value >> 4\n-\t\t\t\t\t\tval1 := value & 0x0f\n-\t\t\t\t\t\tif val1 != 0 {\n-\t\t\t\t\t\t\tzig += int(val0)\n-\t\t\t\t\t\t\tif zig > blockSize {\n-\t\t\t\t\t\t\t\treturn FormatError(\"bad DCT index\")\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tac, err := d.receiveExtend(val1)\n-\t\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\t\treturn err\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tb[unzig[zig]] = ac * qt[zig]\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tif val0 != 0x0f {\n-\t\t\t\t\t\t\t\tbreak\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tzig += 0x0f\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Perform the inverse DCT and store the MCU component to the image.\n-\t\t\t\t\tidct(&b)\n-\t\t\t\t\tdst, stride := []byte(nil), 0\n-\t\t\t\t\tif d.nComp == nGrayComponent {\n-\t\t\t\t\t\tdst, stride = d.img1.Pix[8*(my*d.img1.Stride+mx):], d.img1.Stride\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tswitch i {\n-\t\t\t\t\t\tcase 0:\n-\t\t\t\t\t\t\tmx0, my0 := h0*mx, v0*my\n-\t\t\t\t\t\t\tif h0 == 1 {\n-\t\t\t\t\t\t\t\tmy0 += j\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tmx0 += j % 2\n-\t\t\t\t\t\t\t\tmy0 += j / 2\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tdst, stride = d.img3.Y[8*(my0*d.img3.YStride+mx0):], d.img3.YStride\n-\t\t\t\t\t\tcase 1:\n-\t\t\t\t\t\t\tdst, stride = d.img3.Cb[8*(my*d.img3.CStride+mx):], d.img3.CStride\n-\t\t\t\t\t\tcase 2:\n-\t\t\t\t\t\t\tdst, stride = d.img3.Cr[8*(my*d.img3.CStride+mx):], d.img3.CStride\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t// Level shift by +128, clip to [0, 255], and write to dst.\n-\t\t\t\t\tfor y := 0; y < 8; y++ {\n-\t\t\t\t\t\ty8 := y * 8\n-\t\t\t\t\t\tyStride := y * stride\n-\t\t\t\t\t\tfor x := 0; x < 8; x++ {\n-\t\t\t\t\t\t\tc := b[y8+x]\n-\t\t\t\t\t\t\tif c < -128 {\n-\t\t\t\t\t\t\t\tc = 0\n-\t\t\t\t\t\t\t} else if c > 127 {\n-\t\t\t\t\t\t\t\tc = 255\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tc += 128\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tdst[yStride+x] = uint8(c)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} // for j\n-\t\t\t} // for i\n-\t\t\tmcu++\n-\t\t\tif d.ri > 0 && mcu%d.ri == 0 && mcu < mxx*myy {\n-\t\t\t\t// A more sophisticated decoder could use RST[0-7] markers to resynchronize from corrupt input,\n-\t\t\t\t// but this one assumes well-formed input, and hence the restart marker follows immediately.\n-\t\t\t\t_, err := io.ReadFull(d.r, d.tmp[0:2])\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tif d.tmp[0] != 0xff || d.tmp[1] != expectedRST {\n-\t\t\t\t\treturn FormatError(\"bad RST marker\")\n-\t\t\t\t}\n-\t\t\t\texpectedRST++\n-\t\t\t\tif expectedRST == rst7Marker+1 {\n-\t\t\t\t\texpectedRST = rst0Marker\n-\t\t\t\t}\n-\t\t\t\t// Reset the Huffman decoder.\n-\t\t\t\td.b = bits{}\n-\t\t\t\t// Reset the DC components, as per section F.2.1.3.1.\n-\t\t\t\tdc = [nColorComponent]int{}\n-\t\t\t}\n-\t\t} // for mx\n-\t} // for my\n-\n-\treturn nil\n-}\n-\n // Specified in section B.2.4.4.\n func (d *decoder) processDRI(n int) error {\n \tif n != 2 {\n@@ -414,6 +236,14 @@ func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\n \t\t\treturn nil, FormatError(\"missing 0xff marker start\")\n \t\t}\n \t\tmarker := d.tmp[1]\n+\t\tfor marker == 0xff {\n+\t\t\t// Section B.1.1.2 says, \"Any marker may optionally be preceded by any\n+\t\t\t// number of fill bytes, which are bytes assigned code X'FF'\".\n+\t\t\tmarker, err = d.r.ReadByte()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n \t\tif marker == eoiMarker { // End Of Image.\n \t\t\tbreak\n \t\t}\n@@ -439,13 +269,12 @@ func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\n \t\t}\n \n \t\tswitch {\n-\t\tcase marker == sof0Marker: // Start Of Frame (Baseline).\n+\t\tcase marker == sof0Marker || marker == sof2Marker: // Start Of Frame.\n+\t\t\td.progressive = marker == sof2Marker\n \t\t\terr = d.processSOF(n)\n \t\t\tif configOnly {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\tcase marker == sof2Marker: // Start Of Frame (Progressive).\n-\t\t\terr = UnsupportedError(\"progressive mode\")\n \t\tcase marker == dhtMarker: // Define Huffman Table.\n \t\t\terr = d.processDHT(n)\n \t\tcase marker == dqtMarker: // Define Quantization Table."}, {"sha": "f7fbd9a8a5ea48f169853654e151cc4b9bf7708a", "filename": "libgo/go/image/jpeg/reader_test.go", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package jpeg\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"image\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+// TestDecodeProgressive tests that decoding the baseline and progressive\n+// versions of the same image result in exactly the same pixel data, in YCbCr\n+// space for color images, and Y space for grayscale images.\n+func TestDecodeProgressive(t *testing.T) {\n+\ttestCases := []string{\n+\t\t\"../testdata/video-001\",\n+\t\t\"../testdata/video-001.q50.420\",\n+\t\t\"../testdata/video-001.q50.422\",\n+\t\t\"../testdata/video-001.q50.440\",\n+\t\t\"../testdata/video-001.q50.444\",\n+\t\t\"../testdata/video-005.gray.q50\",\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tm0, err := decodeFile(tc + \".jpeg\")\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %v\", tc+\".jpeg\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tm1, err := decodeFile(tc + \".progressive.jpeg\")\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %v\", tc+\".progressive.jpeg\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif m0.Bounds() != m1.Bounds() {\n+\t\t\tt.Errorf(\"%s: bounds differ: %v and %v\", tc, m0.Bounds(), m1.Bounds())\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch m0 := m0.(type) {\n+\t\tcase *image.YCbCr:\n+\t\t\tm1 := m1.(*image.YCbCr)\n+\t\t\tif err := check(m0.Bounds(), m0.Y, m1.Y, m0.YStride, m1.YStride); err != nil {\n+\t\t\t\tt.Errorf(\"%s (Y): %v\", tc, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := check(m0.Bounds(), m0.Cb, m1.Cb, m0.CStride, m1.CStride); err != nil {\n+\t\t\t\tt.Errorf(\"%s (Cb): %v\", tc, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := check(m0.Bounds(), m0.Cr, m1.Cr, m0.CStride, m1.CStride); err != nil {\n+\t\t\t\tt.Errorf(\"%s (Cr): %v\", tc, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\tcase *image.Gray:\n+\t\t\tm1 := m1.(*image.Gray)\n+\t\t\tif err := check(m0.Bounds(), m0.Pix, m1.Pix, m0.Stride, m1.Stride); err != nil {\n+\t\t\t\tt.Errorf(\"%s: %v\", tc, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tt.Errorf(\"%s: unexpected image type %T\", tc, m0)\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n+func decodeFile(filename string) (image.Image, error) {\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer f.Close()\n+\treturn Decode(f)\n+\n+}\n+\n+// check checks that the two pix data are equal, within the given bounds.\n+func check(bounds image.Rectangle, pix0, pix1 []byte, stride0, stride1 int) error {\n+\tif len(pix0) != len(pix1) {\n+\t\treturn fmt.Errorf(\"len(pix) %d and %d differ\", len(pix0), len(pix1))\n+\t}\n+\tif stride0 != stride1 {\n+\t\treturn fmt.Errorf(\"strides %d and %d differ\", stride0, stride1)\n+\t}\n+\tif stride0%8 != 0 {\n+\t\treturn fmt.Errorf(\"stride %d is not a multiple of 8\", stride0)\n+\t}\n+\t// Compare the two pix data, one 8x8 block at a time.\n+\tfor y := 0; y < len(pix0)/stride0; y += 8 {\n+\t\tfor x := 0; x < stride0; x += 8 {\n+\t\t\tif x >= bounds.Max.X || y >= bounds.Max.Y {\n+\t\t\t\t// We don't care if the two pix data differ if the 8x8 block is\n+\t\t\t\t// entirely outside of the image's bounds. For example, this can\n+\t\t\t\t// occur with a 4:2:0 chroma subsampling and a 1x1 image. Baseline\n+\t\t\t\t// decoding works on the one 16x16 MCU as a whole; progressive\n+\t\t\t\t// decoding's first pass works on that 16x16 MCU as a whole but\n+\t\t\t\t// refinement passes only process one 8x8 block within the MCU.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfor j := 0; j < 8; j++ {\n+\t\t\t\tfor i := 0; i < 8; i++ {\n+\t\t\t\t\tindex := (y+j)*stride0 + (x + i)\n+\t\t\t\t\tif pix0[index] != pix1[index] {\n+\t\t\t\t\t\treturn fmt.Errorf(\"blocks at (%d, %d) differ:\\n%sand\\n%s\", x, y,\n+\t\t\t\t\t\t\tpixString(pix0, stride0, x, y),\n+\t\t\t\t\t\t\tpixString(pix1, stride1, x, y),\n+\t\t\t\t\t\t)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func pixString(pix []byte, stride, x, y int) string {\n+\ts := bytes.NewBuffer(nil)\n+\tfor j := 0; j < 8; j++ {\n+\t\tfmt.Fprintf(s, \"\\t\")\n+\t\tfor i := 0; i < 8; i++ {\n+\t\t\tfmt.Fprintf(s, \"%02x \", pix[(y+j)*stride+(x+i)])\n+\t\t}\n+\t\tfmt.Fprintf(s, \"\\n\")\n+\t}\n+\treturn s.String()\n+}\n+\n+func benchmarkDecode(b *testing.B, filename string) {\n+\tb.StopTimer()\n+\tdata, err := ioutil.ReadFile(filename)\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tcfg, err := DecodeConfig(bytes.NewReader(data))\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tb.SetBytes(int64(cfg.Width * cfg.Height * 4))\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tDecode(bytes.NewReader(data))\n+\t}\n+}\n+\n+func BenchmarkDecodeBaseline(b *testing.B) {\n+\tbenchmarkDecode(b, \"../testdata/video-001.jpeg\")\n+}\n+\n+func BenchmarkDecodeProgressive(b *testing.B) {\n+\tbenchmarkDecode(b, \"../testdata/video-001.progressive.jpeg\")\n+}"}, {"sha": "e3ae8ae441c6e9d3de7bba45173d6821b2a84a73", "filename": "libgo/go/image/jpeg/scan.go", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fscan.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,432 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package jpeg\n+\n+import (\n+\t\"image\"\n+\t\"io\"\n+)\n+\n+// makeImg allocates and initializes the destination image.\n+func (d *decoder) makeImg(h0, v0, mxx, myy int) {\n+\tif d.nComp == nGrayComponent {\n+\t\tm := image.NewGray(image.Rect(0, 0, 8*mxx, 8*myy))\n+\t\td.img1 = m.SubImage(image.Rect(0, 0, d.width, d.height)).(*image.Gray)\n+\t\treturn\n+\t}\n+\tvar subsampleRatio image.YCbCrSubsampleRatio\n+\tswitch {\n+\tcase h0 == 1 && v0 == 1:\n+\t\tsubsampleRatio = image.YCbCrSubsampleRatio444\n+\tcase h0 == 1 && v0 == 2:\n+\t\tsubsampleRatio = image.YCbCrSubsampleRatio440\n+\tcase h0 == 2 && v0 == 1:\n+\t\tsubsampleRatio = image.YCbCrSubsampleRatio422\n+\tcase h0 == 2 && v0 == 2:\n+\t\tsubsampleRatio = image.YCbCrSubsampleRatio420\n+\tdefault:\n+\t\tpanic(\"unreachable\")\n+\t}\n+\tm := image.NewYCbCr(image.Rect(0, 0, 8*h0*mxx, 8*v0*myy), subsampleRatio)\n+\td.img3 = m.SubImage(image.Rect(0, 0, d.width, d.height)).(*image.YCbCr)\n+}\n+\n+// Specified in section B.2.3.\n+func (d *decoder) processSOS(n int) error {\n+\tif d.nComp == 0 {\n+\t\treturn FormatError(\"missing SOF marker\")\n+\t}\n+\tif n < 6 || 4+2*d.nComp < n || n%2 != 0 {\n+\t\treturn FormatError(\"SOS has wrong length\")\n+\t}\n+\t_, err := io.ReadFull(d.r, d.tmp[:n])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tnComp := int(d.tmp[0])\n+\tif n != 4+2*nComp {\n+\t\treturn FormatError(\"SOS length inconsistent with number of components\")\n+\t}\n+\tvar scan [nColorComponent]struct {\n+\t\tcompIndex uint8\n+\t\ttd        uint8 // DC table selector.\n+\t\tta        uint8 // AC table selector.\n+\t}\n+\tfor i := 0; i < nComp; i++ {\n+\t\tcs := d.tmp[1+2*i] // Component selector.\n+\t\tcompIndex := -1\n+\t\tfor j, comp := range d.comp {\n+\t\t\tif cs == comp.c {\n+\t\t\t\tcompIndex = j\n+\t\t\t}\n+\t\t}\n+\t\tif compIndex < 0 {\n+\t\t\treturn FormatError(\"unknown component selector\")\n+\t\t}\n+\t\tscan[i].compIndex = uint8(compIndex)\n+\t\tscan[i].td = d.tmp[2+2*i] >> 4\n+\t\tscan[i].ta = d.tmp[2+2*i] & 0x0f\n+\t}\n+\n+\t// zigStart and zigEnd are the spectral selection bounds.\n+\t// ah and al are the successive approximation high and low values.\n+\t// The spec calls these values Ss, Se, Ah and Al.\n+\t//\n+\t// For progressive JPEGs, these are the two more-or-less independent\n+\t// aspects of progression. Spectral selection progression is when not\n+\t// all of a block's 64 DCT coefficients are transmitted in one pass.\n+\t// For example, three passes could transmit coefficient 0 (the DC\n+\t// component), coefficients 1-5, and coefficients 6-63, in zig-zag\n+\t// order. Successive approximation is when not all of the bits of a\n+\t// band of coefficients are transmitted in one pass. For example,\n+\t// three passes could transmit the 6 most significant bits, followed\n+\t// by the second-least significant bit, followed by the least\n+\t// significant bit.\n+\t//\n+\t// For baseline JPEGs, these parameters are hard-coded to 0/63/0/0.\n+\tzigStart, zigEnd, ah, al := int32(0), int32(blockSize-1), uint32(0), uint32(0)\n+\tif d.progressive {\n+\t\tzigStart = int32(d.tmp[1+2*nComp])\n+\t\tzigEnd = int32(d.tmp[2+2*nComp])\n+\t\tah = uint32(d.tmp[3+2*nComp] >> 4)\n+\t\tal = uint32(d.tmp[3+2*nComp] & 0x0f)\n+\t\tif (zigStart == 0 && zigEnd != 0) || zigStart > zigEnd || blockSize <= zigEnd {\n+\t\t\treturn FormatError(\"bad spectral selection bounds\")\n+\t\t}\n+\t\tif zigStart != 0 && nComp != 1 {\n+\t\t\treturn FormatError(\"progressive AC coefficients for more than one component\")\n+\t\t}\n+\t\tif ah != 0 && ah != al+1 {\n+\t\t\treturn FormatError(\"bad successive approximation values\")\n+\t\t}\n+\t}\n+\n+\t// mxx and myy are the number of MCUs (Minimum Coded Units) in the image.\n+\th0, v0 := d.comp[0].h, d.comp[0].v // The h and v values from the Y components.\n+\tmxx := (d.width + 8*h0 - 1) / (8 * h0)\n+\tmyy := (d.height + 8*v0 - 1) / (8 * v0)\n+\tif d.img1 == nil && d.img3 == nil {\n+\t\td.makeImg(h0, v0, mxx, myy)\n+\t\tif d.progressive {\n+\t\t\tfor i := 0; i < nComp; i++ {\n+\t\t\t\tcompIndex := scan[i].compIndex\n+\t\t\t\td.progCoeffs[compIndex] = make([]block, mxx*myy*d.comp[compIndex].h*d.comp[compIndex].v)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\td.b = bits{}\n+\tmcu, expectedRST := 0, uint8(rst0Marker)\n+\tvar (\n+\t\t// b is the decoded coefficients, in natural (not zig-zag) order.\n+\t\tb  block\n+\t\tdc [nColorComponent]int32\n+\t\t// mx0 and my0 are the location of the current (in terms of 8x8 blocks).\n+\t\t// For example, with 4:2:0 chroma subsampling, the block whose top left\n+\t\t// pixel co-ordinates are (16, 8) is the third block in the first row:\n+\t\t// mx0 is 2 and my0 is 0, even though the pixel is in the second MCU.\n+\t\t// TODO(nigeltao): rename mx0 and my0 to bx and by?\n+\t\tmx0, my0   int\n+\t\tblockCount int\n+\t)\n+\tfor my := 0; my < myy; my++ {\n+\t\tfor mx := 0; mx < mxx; mx++ {\n+\t\t\tfor i := 0; i < nComp; i++ {\n+\t\t\t\tcompIndex := scan[i].compIndex\n+\t\t\t\tqt := &d.quant[d.comp[compIndex].tq]\n+\t\t\t\tfor j := 0; j < d.comp[compIndex].h*d.comp[compIndex].v; j++ {\n+\t\t\t\t\t// The blocks are traversed one MCU at a time. For 4:2:0 chroma\n+\t\t\t\t\t// subsampling, there are four Y 8x8 blocks in every 16x16 MCU.\n+\t\t\t\t\t// For a baseline 32x16 pixel image, the Y blocks visiting order is:\n+\t\t\t\t\t//\t0 1 4 5\n+\t\t\t\t\t//\t2 3 6 7\n+\t\t\t\t\t//\n+\t\t\t\t\t// For progressive images, the DC data blocks (zigStart == 0) are traversed\n+\t\t\t\t\t// as above, but AC data blocks are traversed left to right, top to bottom:\n+\t\t\t\t\t//\t0 1 2 3\n+\t\t\t\t\t//\t4 5 6 7\n+\t\t\t\t\t//\n+\t\t\t\t\t// To further complicate matters, there is no AC data for any blocks that\n+\t\t\t\t\t// are inside the image at the MCU level but outside the image at the pixel\n+\t\t\t\t\t// level. For example, a 24x16 pixel 4:2:0 progressive image consists of\n+\t\t\t\t\t// two 16x16 MCUs. The earlier scans will process 8 Y blocks:\n+\t\t\t\t\t//\t0 1 4 5\n+\t\t\t\t\t//\t2 3 6 7\n+\t\t\t\t\t// The later scans will process only 6 Y blocks:\n+\t\t\t\t\t//\t0 1 2\n+\t\t\t\t\t//\t3 4 5\n+\t\t\t\t\tif zigStart == 0 {\n+\t\t\t\t\t\tmx0, my0 = d.comp[compIndex].h*mx, d.comp[compIndex].v*my\n+\t\t\t\t\t\tif h0 == 1 {\n+\t\t\t\t\t\t\tmy0 += j\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmx0 += j % 2\n+\t\t\t\t\t\t\tmy0 += j / 2\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tq := mxx * d.comp[compIndex].h\n+\t\t\t\t\t\tmx0 = blockCount % q\n+\t\t\t\t\t\tmy0 = blockCount / q\n+\t\t\t\t\t\tblockCount++\n+\t\t\t\t\t\tif mx0*8 >= d.width || my0*8 >= d.height {\n+\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Load the previous partially decoded coefficients, if applicable.\n+\t\t\t\t\tif d.progressive {\n+\t\t\t\t\t\tb = d.progCoeffs[compIndex][my0*mxx*d.comp[compIndex].h+mx0]\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tb = block{}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif ah != 0 {\n+\t\t\t\t\t\tif err := d.refine(&b, &d.huff[acTable][scan[i].ta], zigStart, zigEnd, 1<<al); err != nil {\n+\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tzig := zigStart\n+\t\t\t\t\t\tif zig == 0 {\n+\t\t\t\t\t\t\tzig++\n+\t\t\t\t\t\t\t// Decode the DC coefficient, as specified in section F.2.2.1.\n+\t\t\t\t\t\t\tvalue, err := d.decodeHuffman(&d.huff[dcTable][scan[i].td])\n+\t\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif value > 16 {\n+\t\t\t\t\t\t\t\treturn UnsupportedError(\"excessive DC component\")\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tdcDelta, err := d.receiveExtend(value)\n+\t\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tdc[compIndex] += dcDelta\n+\t\t\t\t\t\t\tb[0] = dc[compIndex] << al\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif zig <= zigEnd && d.eobRun > 0 {\n+\t\t\t\t\t\t\td.eobRun--\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t// Decode the AC coefficients, as specified in section F.2.2.2.\n+\t\t\t\t\t\t\tfor ; zig <= zigEnd; zig++ {\n+\t\t\t\t\t\t\t\tvalue, err := d.decodeHuffman(&d.huff[acTable][scan[i].ta])\n+\t\t\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tval0 := value >> 4\n+\t\t\t\t\t\t\t\tval1 := value & 0x0f\n+\t\t\t\t\t\t\t\tif val1 != 0 {\n+\t\t\t\t\t\t\t\t\tzig += int32(val0)\n+\t\t\t\t\t\t\t\t\tif zig > zigEnd {\n+\t\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tac, err := d.receiveExtend(val1)\n+\t\t\t\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb[unzig[zig]] = ac << al\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif val0 != 0x0f {\n+\t\t\t\t\t\t\t\t\t\td.eobRun = uint16(1 << val0)\n+\t\t\t\t\t\t\t\t\t\tif val0 != 0 {\n+\t\t\t\t\t\t\t\t\t\t\tbits, err := d.decodeBits(int(val0))\n+\t\t\t\t\t\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\td.eobRun |= uint16(bits)\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\td.eobRun--\n+\t\t\t\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tzig += 0x0f\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif d.progressive {\n+\t\t\t\t\t\tif zigEnd != blockSize-1 || al != 0 {\n+\t\t\t\t\t\t\t// We haven't completely decoded this 8x8 block. Save the coefficients.\n+\t\t\t\t\t\t\td.progCoeffs[compIndex][my0*mxx*d.comp[compIndex].h+mx0] = b\n+\t\t\t\t\t\t\t// At this point, we could execute the rest of the loop body to dequantize and\n+\t\t\t\t\t\t\t// perform the inverse DCT, to save early stages of a progressive image to the\n+\t\t\t\t\t\t\t// *image.YCbCr buffers (the whole point of progressive encoding), but in Go,\n+\t\t\t\t\t\t\t// the jpeg.Decode function does not return until the entire image is decoded,\n+\t\t\t\t\t\t\t// so we \"continue\" here to avoid wasted computation.\n+\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Dequantize, perform the inverse DCT and store the block to the image.\n+\t\t\t\t\tfor zig := 0; zig < blockSize; zig++ {\n+\t\t\t\t\t\tb[unzig[zig]] *= qt[zig]\n+\t\t\t\t\t}\n+\t\t\t\t\tidct(&b)\n+\t\t\t\t\tdst, stride := []byte(nil), 0\n+\t\t\t\t\tif d.nComp == nGrayComponent {\n+\t\t\t\t\t\tdst, stride = d.img1.Pix[8*(my0*d.img1.Stride+mx0):], d.img1.Stride\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tswitch compIndex {\n+\t\t\t\t\t\tcase 0:\n+\t\t\t\t\t\t\tdst, stride = d.img3.Y[8*(my0*d.img3.YStride+mx0):], d.img3.YStride\n+\t\t\t\t\t\tcase 1:\n+\t\t\t\t\t\t\tdst, stride = d.img3.Cb[8*(my0*d.img3.CStride+mx0):], d.img3.CStride\n+\t\t\t\t\t\tcase 2:\n+\t\t\t\t\t\t\tdst, stride = d.img3.Cr[8*(my0*d.img3.CStride+mx0):], d.img3.CStride\n+\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\treturn UnsupportedError(\"too many components\")\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\t// Level shift by +128, clip to [0, 255], and write to dst.\n+\t\t\t\t\tfor y := 0; y < 8; y++ {\n+\t\t\t\t\t\ty8 := y * 8\n+\t\t\t\t\t\tyStride := y * stride\n+\t\t\t\t\t\tfor x := 0; x < 8; x++ {\n+\t\t\t\t\t\t\tc := b[y8+x]\n+\t\t\t\t\t\t\tif c < -128 {\n+\t\t\t\t\t\t\t\tc = 0\n+\t\t\t\t\t\t\t} else if c > 127 {\n+\t\t\t\t\t\t\t\tc = 255\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tc += 128\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tdst[yStride+x] = uint8(c)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} // for j\n+\t\t\t} // for i\n+\t\t\tmcu++\n+\t\t\tif d.ri > 0 && mcu%d.ri == 0 && mcu < mxx*myy {\n+\t\t\t\t// A more sophisticated decoder could use RST[0-7] markers to resynchronize from corrupt input,\n+\t\t\t\t// but this one assumes well-formed input, and hence the restart marker follows immediately.\n+\t\t\t\t_, err := io.ReadFull(d.r, d.tmp[0:2])\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tif d.tmp[0] != 0xff || d.tmp[1] != expectedRST {\n+\t\t\t\t\treturn FormatError(\"bad RST marker\")\n+\t\t\t\t}\n+\t\t\t\texpectedRST++\n+\t\t\t\tif expectedRST == rst7Marker+1 {\n+\t\t\t\t\texpectedRST = rst0Marker\n+\t\t\t\t}\n+\t\t\t\t// Reset the Huffman decoder.\n+\t\t\t\td.b = bits{}\n+\t\t\t\t// Reset the DC components, as per section F.2.1.3.1.\n+\t\t\t\tdc = [nColorComponent]int32{}\n+\t\t\t\t// Reset the progressive decoder state, as per section G.1.2.2.\n+\t\t\t\td.eobRun = 0\n+\t\t\t}\n+\t\t} // for mx\n+\t} // for my\n+\n+\treturn nil\n+}\n+\n+// refine decodes a successive approximation refinement block, as specified in\n+// section G.1.2.\n+func (d *decoder) refine(b *block, h *huffman, zigStart, zigEnd, delta int32) error {\n+\t// Refining a DC component is trivial.\n+\tif zigStart == 0 {\n+\t\tif zigEnd != 0 {\n+\t\t\tpanic(\"unreachable\")\n+\t\t}\n+\t\tbit, err := d.decodeBit()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif bit {\n+\t\t\tb[0] |= delta\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\t// Refining AC components is more complicated; see sections G.1.2.2 and G.1.2.3.\n+\tzig := zigStart\n+\tif d.eobRun == 0 {\n+\tloop:\n+\t\tfor ; zig <= zigEnd; zig++ {\n+\t\t\tz := int32(0)\n+\t\t\tvalue, err := d.decodeHuffman(h)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tval0 := value >> 4\n+\t\t\tval1 := value & 0x0f\n+\n+\t\t\tswitch val1 {\n+\t\t\tcase 0:\n+\t\t\t\tif val0 != 0x0f {\n+\t\t\t\t\td.eobRun = uint16(1 << val0)\n+\t\t\t\t\tif val0 != 0 {\n+\t\t\t\t\t\tbits, err := d.decodeBits(int(val0))\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\td.eobRun |= uint16(bits)\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak loop\n+\t\t\t\t}\n+\t\t\tcase 1:\n+\t\t\t\tz = delta\n+\t\t\t\tbit, err := d.decodeBit()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tif !bit {\n+\t\t\t\t\tz = -z\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\treturn FormatError(\"unexpected Huffman code\")\n+\t\t\t}\n+\n+\t\t\tzig, err = d.refineNonZeroes(b, zig, zigEnd, int32(val0), delta)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif zig > zigEnd {\n+\t\t\t\treturn FormatError(\"too many coefficients\")\n+\t\t\t}\n+\t\t\tif z != 0 {\n+\t\t\t\tb[unzig[zig]] = z\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif d.eobRun > 0 {\n+\t\td.eobRun--\n+\t\tif _, err := d.refineNonZeroes(b, zig, zigEnd, -1, delta); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// refineNonZeroes refines non-zero entries of b in zig-zag order. If nz >= 0,\n+// the first nz zero entries are skipped over.\n+func (d *decoder) refineNonZeroes(b *block, zig, zigEnd, nz, delta int32) (int32, error) {\n+\tfor ; zig <= zigEnd; zig++ {\n+\t\tu := unzig[zig]\n+\t\tif b[u] == 0 {\n+\t\t\tif nz == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tnz--\n+\t\t\tcontinue\n+\t\t}\n+\t\tbit, err := d.decodeBit()\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\tif !bit {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif b[u] >= 0 {\n+\t\t\tb[u] += delta\n+\t\t} else {\n+\t\t\tb[u] -= delta\n+\t\t}\n+\t}\n+\treturn zig, nil\n+}"}, {"sha": "375d8a66d5aadebd4a53fd538d65bb99c9176916", "filename": "libgo/go/image/jpeg/writer.go", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -21,7 +21,7 @@ func min(x, y int) int {\n }\n \n // div returns a/b rounded to the nearest integer, instead of rounded to zero.\n-func div(a int, b int) int {\n+func div(a, b int32) int32 {\n \tif a >= 0 {\n \t\treturn (a + (b >> 1)) / b\n \t}\n@@ -268,14 +268,14 @@ func (e *encoder) emit(bits, nBits uint32) {\n }\n \n // emitHuff emits the given value with the given Huffman encoder.\n-func (e *encoder) emitHuff(h huffIndex, value int) {\n+func (e *encoder) emitHuff(h huffIndex, value int32) {\n \tx := theHuffmanLUT[h][value]\n \te.emit(x&(1<<24-1), x>>24)\n }\n \n // emitHuffRLE emits a run of runLength copies of value encoded with the given\n // Huffman encoder.\n-func (e *encoder) emitHuffRLE(h huffIndex, runLength, value int) {\n+func (e *encoder) emitHuffRLE(h huffIndex, runLength, value int32) {\n \ta, b := value, value\n \tif a < 0 {\n \t\ta, b = -value, value-1\n@@ -286,7 +286,7 @@ func (e *encoder) emitHuffRLE(h huffIndex, runLength, value int) {\n \t} else {\n \t\tnBits = 8 + uint32(bitCount[a>>8])\n \t}\n-\te.emitHuff(h, runLength<<4|int(nBits))\n+\te.emitHuff(h, runLength<<4|int32(nBits))\n \tif nBits > 0 {\n \t\te.emit(uint32(b)&(1<<nBits-1), nBits)\n \t}\n@@ -347,15 +347,15 @@ func (e *encoder) writeDHT() {\n // writeBlock writes a block of pixel data using the given quantization table,\n // returning the post-quantized DC value of the DCT-transformed block.\n // b is in natural (not zig-zag) order.\n-func (e *encoder) writeBlock(b *block, q quantIndex, prevDC int) int {\n+func (e *encoder) writeBlock(b *block, q quantIndex, prevDC int32) int32 {\n \tfdct(b)\n \t// Emit the DC delta.\n-\tdc := div(b[0], (8 * int(e.quant[q][0])))\n+\tdc := div(b[0], 8*int32(e.quant[q][0]))\n \te.emitHuffRLE(huffIndex(2*q+0), 0, dc-prevDC)\n \t// Emit the AC components.\n-\th, runLength := huffIndex(2*q+1), 0\n+\th, runLength := huffIndex(2*q+1), int32(0)\n \tfor zig := 1; zig < blockSize; zig++ {\n-\t\tac := div(b[unzig[zig]], (8 * int(e.quant[q][zig])))\n+\t\tac := div(b[unzig[zig]], 8*int32(e.quant[q][zig]))\n \t\tif ac == 0 {\n \t\t\trunLength++\n \t\t} else {\n@@ -383,9 +383,9 @@ func toYCbCr(m image.Image, p image.Point, yBlock, cbBlock, crBlock *block) {\n \t\tfor i := 0; i < 8; i++ {\n \t\t\tr, g, b, _ := m.At(min(p.X+i, xmax), min(p.Y+j, ymax)).RGBA()\n \t\t\tyy, cb, cr := color.RGBToYCbCr(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n-\t\t\tyBlock[8*j+i] = int(yy)\n-\t\t\tcbBlock[8*j+i] = int(cb)\n-\t\t\tcrBlock[8*j+i] = int(cr)\n+\t\t\tyBlock[8*j+i] = int32(yy)\n+\t\t\tcbBlock[8*j+i] = int32(cb)\n+\t\t\tcrBlock[8*j+i] = int32(cr)\n \t\t}\n \t}\n }\n@@ -408,9 +408,9 @@ func rgbaToYCbCr(m *image.RGBA, p image.Point, yBlock, cbBlock, crBlock *block)\n \t\t\t}\n \t\t\tpix := m.Pix[offset+sx*4:]\n \t\t\tyy, cb, cr := color.RGBToYCbCr(pix[0], pix[1], pix[2])\n-\t\t\tyBlock[8*j+i] = int(yy)\n-\t\t\tcbBlock[8*j+i] = int(cb)\n-\t\t\tcrBlock[8*j+i] = int(cr)\n+\t\t\tyBlock[8*j+i] = int32(yy)\n+\t\t\tcbBlock[8*j+i] = int32(cb)\n+\t\t\tcrBlock[8*j+i] = int32(cr)\n \t\t}\n \t}\n }\n@@ -450,12 +450,10 @@ func (e *encoder) writeSOS(m image.Image) {\n \tvar (\n \t\t// Scratch buffers to hold the YCbCr values.\n \t\t// The blocks are in natural (not zig-zag) order.\n-\t\tyBlock  block\n-\t\tcbBlock [4]block\n-\t\tcrBlock [4]block\n-\t\tcBlock  block\n+\t\tb      block\n+\t\tcb, cr [4]block\n \t\t// DC components are delta-encoded.\n-\t\tprevDCY, prevDCCb, prevDCCr int\n+\t\tprevDCY, prevDCCb, prevDCCr int32\n \t)\n \tbounds := m.Bounds()\n \trgba, _ := m.(*image.RGBA)\n@@ -466,16 +464,16 @@ func (e *encoder) writeSOS(m image.Image) {\n \t\t\t\tyOff := (i & 2) * 4\n \t\t\t\tp := image.Pt(x+xOff, y+yOff)\n \t\t\t\tif rgba != nil {\n-\t\t\t\t\trgbaToYCbCr(rgba, p, &yBlock, &cbBlock[i], &crBlock[i])\n+\t\t\t\t\trgbaToYCbCr(rgba, p, &b, &cb[i], &cr[i])\n \t\t\t\t} else {\n-\t\t\t\t\ttoYCbCr(m, p, &yBlock, &cbBlock[i], &crBlock[i])\n+\t\t\t\t\ttoYCbCr(m, p, &b, &cb[i], &cr[i])\n \t\t\t\t}\n-\t\t\t\tprevDCY = e.writeBlock(&yBlock, 0, prevDCY)\n+\t\t\t\tprevDCY = e.writeBlock(&b, 0, prevDCY)\n \t\t\t}\n-\t\t\tscale(&cBlock, &cbBlock)\n-\t\t\tprevDCCb = e.writeBlock(&cBlock, 1, prevDCCb)\n-\t\t\tscale(&cBlock, &crBlock)\n-\t\t\tprevDCCr = e.writeBlock(&cBlock, 1, prevDCCr)\n+\t\t\tscale(&b, &cb)\n+\t\t\tprevDCCb = e.writeBlock(&b, 1, prevDCCb)\n+\t\t\tscale(&b, &cr)\n+\t\t\tprevDCCr = e.writeBlock(&b, 1, prevDCCr)\n \t\t}\n \t}\n \t// Pad the last byte with 1's."}, {"sha": "0b2143f5b89a5c3b9344eabe2ad4f109b24a8f4c", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -171,23 +171,6 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n-func BenchmarkDecode(b *testing.B) {\n-\tb.StopTimer()\n-\tdata, err := ioutil.ReadFile(\"../testdata/video-001.jpeg\")\n-\tif err != nil {\n-\t\tb.Fatal(err)\n-\t}\n-\tcfg, err := DecodeConfig(bytes.NewReader(data))\n-\tif err != nil {\n-\t\tb.Fatal(err)\n-\t}\n-\tb.SetBytes(int64(cfg.Width * cfg.Height * 4))\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tDecode(bytes.NewReader(data))\n-\t}\n-}\n-\n func BenchmarkEncode(b *testing.B) {\n \tb.StopTimer()\n \timg := image.NewRGBA(image.Rect(0, 0, 640, 480))"}, {"sha": "ff837331f81b991ee0768bc62849c2b5c9a7a03c", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -193,10 +193,19 @@ func (d *decoder) parsePLTE(length uint32) error {\n \td.crc.Write(d.tmp[:n])\n \tswitch d.cb {\n \tcase cbP1, cbP2, cbP4, cbP8:\n-\t\td.palette = color.Palette(make([]color.Color, np))\n+\t\td.palette = make(color.Palette, 256)\n \t\tfor i := 0; i < np; i++ {\n \t\t\td.palette[i] = color.RGBA{d.tmp[3*i+0], d.tmp[3*i+1], d.tmp[3*i+2], 0xff}\n \t\t}\n+\t\tfor i := np; i < 256; i++ {\n+\t\t\t// Initialize the rest of the palette to opaque black. The spec (section\n+\t\t\t// 11.2.3) says that \"any out-of-range pixel value found in the image data\n+\t\t\t// is an error\", but some real-world PNG files have out-of-range pixel\n+\t\t\t// values. We fall back to opaque black, the same as libpng 1.5.13;\n+\t\t\t// ImageMagick 6.5.7 returns an error.\n+\t\t\td.palette[i] = color.RGBA{0x00, 0x00, 0x00, 0xff}\n+\t\t}\n+\t\td.palette = d.palette[:np]\n \tcase cbTC8, cbTCA8, cbTC16, cbTCA16:\n \t\t// As per the PNG spec, a PLTE chunk is optional (and for practical purposes,\n \t\t// ignorable) for the ctTrueColor and ctTrueColorAlpha color types (section 4.1.2).\n@@ -221,8 +230,8 @@ func (d *decoder) parsetRNS(length uint32) error {\n \tcase cbTC8, cbTC16:\n \t\treturn UnsupportedError(\"truecolor transparency\")\n \tcase cbP1, cbP2, cbP4, cbP8:\n-\t\tif n > len(d.palette) {\n-\t\t\treturn FormatError(\"bad tRNS length\")\n+\t\tif len(d.palette) < n {\n+\t\t\td.palette = d.palette[:n]\n \t\t}\n \t\tfor i := 0; i < n; i++ {\n \t\t\trgba := d.palette[i].(color.RGBA)\n@@ -279,7 +288,6 @@ func (d *decoder) decode() (image.Image, error) {\n \t}\n \tdefer r.Close()\n \tbitsPerPixel := 0\n-\tmaxPalette := uint8(0)\n \tpixOffset := 0\n \tvar (\n \t\tgray     *image.Gray\n@@ -308,7 +316,6 @@ func (d *decoder) decode() (image.Image, error) {\n \t\tbitsPerPixel = d.depth\n \t\tpaletted = image.NewPaletted(image.Rect(0, 0, d.width, d.height), d.palette)\n \t\timg = paletted\n-\t\tmaxPalette = uint8(len(d.palette) - 1)\n \tcase cbTCA8:\n \t\tbitsPerPixel = 32\n \t\tnrgba = image.NewNRGBA(image.Rect(0, 0, d.width, d.height))\n@@ -421,8 +428,8 @@ func (d *decoder) decode() (image.Image, error) {\n \t\t\t\tb := cdat[x/8]\n \t\t\t\tfor x2 := 0; x2 < 8 && x+x2 < d.width; x2++ {\n \t\t\t\t\tidx := b >> 7\n-\t\t\t\t\tif idx > maxPalette {\n-\t\t\t\t\t\treturn nil, FormatError(\"palette index out of range\")\n+\t\t\t\t\tif len(paletted.Palette) <= int(idx) {\n+\t\t\t\t\t\tpaletted.Palette = paletted.Palette[:int(idx)+1]\n \t\t\t\t\t}\n \t\t\t\t\tpaletted.SetColorIndex(x+x2, y, idx)\n \t\t\t\t\tb <<= 1\n@@ -433,8 +440,8 @@ func (d *decoder) decode() (image.Image, error) {\n \t\t\t\tb := cdat[x/4]\n \t\t\t\tfor x2 := 0; x2 < 4 && x+x2 < d.width; x2++ {\n \t\t\t\t\tidx := b >> 6\n-\t\t\t\t\tif idx > maxPalette {\n-\t\t\t\t\t\treturn nil, FormatError(\"palette index out of range\")\n+\t\t\t\t\tif len(paletted.Palette) <= int(idx) {\n+\t\t\t\t\t\tpaletted.Palette = paletted.Palette[:int(idx)+1]\n \t\t\t\t\t}\n \t\t\t\t\tpaletted.SetColorIndex(x+x2, y, idx)\n \t\t\t\t\tb <<= 2\n@@ -445,18 +452,18 @@ func (d *decoder) decode() (image.Image, error) {\n \t\t\t\tb := cdat[x/2]\n \t\t\t\tfor x2 := 0; x2 < 2 && x+x2 < d.width; x2++ {\n \t\t\t\t\tidx := b >> 4\n-\t\t\t\t\tif idx > maxPalette {\n-\t\t\t\t\t\treturn nil, FormatError(\"palette index out of range\")\n+\t\t\t\t\tif len(paletted.Palette) <= int(idx) {\n+\t\t\t\t\t\tpaletted.Palette = paletted.Palette[:int(idx)+1]\n \t\t\t\t\t}\n \t\t\t\t\tpaletted.SetColorIndex(x+x2, y, idx)\n \t\t\t\t\tb <<= 4\n \t\t\t\t}\n \t\t\t}\n \t\tcase cbP8:\n-\t\t\tif maxPalette != 255 {\n+\t\t\tif len(paletted.Palette) != 255 {\n \t\t\t\tfor x := 0; x < d.width; x++ {\n-\t\t\t\t\tif cdat[x] > maxPalette {\n-\t\t\t\t\t\treturn nil, FormatError(\"palette index out of range\")\n+\t\t\t\t\tif len(paletted.Palette) <= int(cdat[x]) {\n+\t\t\t\t\t\tpaletted.Palette = paletted.Palette[:int(cdat[x])+1]\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}"}, {"sha": "b8cae23593caba27b79edb7ae8dad65d7b40eb25", "filename": "libgo/go/image/testdata/video-001.progressive.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.progressive.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.progressive.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.progressive.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "83fb0f8abd0204ec12e635830f5b5024a6ddd04f", "filename": "libgo/go/image/testdata/video-001.q50.420.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.420.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.420.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.420.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "b048eb205bb4418772af9991bb5c28b3ed575c8b", "filename": "libgo/go/image/testdata/video-001.q50.420.progressive.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.420.progressive.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.420.progressive.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.420.progressive.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "60fff4ff9fe0a88bbfd99ffa76b902fef83cc0ce", "filename": "libgo/go/image/testdata/video-001.q50.422.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.422.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.422.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.422.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "926d005de973f16904027116290fb2b606ab67b7", "filename": "libgo/go/image/testdata/video-001.q50.422.progressive.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.422.progressive.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.422.progressive.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.422.progressive.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "32eeeaef6fc3cb82c21b76689139c8faac8738c1", "filename": "libgo/go/image/testdata/video-001.q50.440.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.440.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.440.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.440.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "e641a3bbbcaecb6298537a82950b8a0005fdc137", "filename": "libgo/go/image/testdata/video-001.q50.440.progressive.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.440.progressive.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.440.progressive.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.440.progressive.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "7d57433827c28e4763006be1e43ca6d2339982b5", "filename": "libgo/go/image/testdata/video-001.q50.444.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.444.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.444.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.444.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "ff7d5f9ff0a8dc71c7122b1c3b9b6e943fe32515", "filename": "libgo/go/image/testdata/video-001.q50.444.progressive.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.444.progressive.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.444.progressive.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.q50.444.progressive.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "c65b5a794a6db2a6effe51c8a4e728a84d3bd42c", "filename": "libgo/go/image/testdata/video-005.gray.q50.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "24b70e8bff956ee626e1b3edfba11306281254e3", "filename": "libgo/go/image/testdata/video-005.gray.q50.progressive.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.progressive.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.progressive.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-005.gray.q50.progressive.jpeg?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "bddb701786bb41bed7068d612763b062d1af3925", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -216,6 +216,11 @@ type ByteScanner interface {\n \tUnreadByte() error\n }\n \n+// ByteWriter is the interface that wraps the WriteByte method.\n+type ByteWriter interface {\n+\tWriteByte(c byte) error\n+}\n+\n // RuneReader is the interface that wraps the ReadRune method.\n //\n // ReadRune reads a single UTF-8 encoded Unicode character"}, {"sha": "4a06e9756fb3f909e1ce84db6084a608694d2839", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -12,7 +12,7 @@ import (\n \t\"time\"\n )\n \n-// Random number state, accessed without lock; racy but harmless.\n+// Random number state.\n // We generate random temporary file names so that there's a good\n // chance the file doesn't exist yet - keeps the number of tries in\n // TempFile to a minimum.\n@@ -42,8 +42,8 @@ func nextSuffix() string {\n // for temporary files (see os.TempDir).\n // Multiple programs calling TempFile simultaneously\n // will not choose the same file.  The caller can use f.Name()\n-// to find the name of the file.  It is the caller's responsibility to\n-// remove the file when no longer needed.\n+// to find the pathname of the file.  It is the caller's responsibility\n+// to remove the file when no longer needed.\n func TempFile(dir, prefix string) (f *os.File, err error) {\n \tif dir == \"\" {\n \t\tdir = os.TempDir()"}, {"sha": "95c0d58ee9798568819a4d92c297b3d9774bd1f6", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -412,7 +412,7 @@ func (x *Int) Format(s fmt.State, ch rune) {\n \tif precisionSet {\n \t\tswitch {\n \t\tcase len(digits) < precision:\n-\t\t\tzeroes = precision - len(digits) // count of zero padding \n+\t\t\tzeroes = precision - len(digits) // count of zero padding\n \t\tcase digits == \"0\" && precision == 0:\n \t\t\treturn // print nothing if zero value (x == 0) and zero precision (\".\" or \".0\")\n \t\t}\n@@ -561,19 +561,18 @@ func (x *Int) BitLen() int {\n \treturn x.abs.bitLen()\n }\n \n-// Exp sets z = x**y mod m and returns z. If m is nil, z = x**y.\n+// Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.\n+// If y <= 0, the result is 1; if m == nil or m == 0, z = x**y.\n // See Knuth, volume 2, section 4.6.3.\n func (z *Int) Exp(x, y, m *Int) *Int {\n \tif y.neg || len(y.abs) == 0 {\n-\t\tneg := x.neg\n-\t\tz.SetInt64(1)\n-\t\tz.neg = neg\n-\t\treturn z\n+\t\treturn z.SetInt64(1)\n \t}\n+\t// y > 0\n \n \tvar mWords nat\n \tif m != nil {\n-\t\tmWords = m.abs\n+\t\tmWords = m.abs // m.abs may be nil for m == 0\n \t}\n \n \tz.abs = z.abs.expNN(x.abs, y.abs, mWords)"}, {"sha": "d3c5a0e8bfe7481a4dd444d20bad7d49b2b8f54e", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -767,8 +767,10 @@ var expTests = []struct {\n \tx, y, m string\n \tout     string\n }{\n+\t{\"5\", \"-7\", \"\", \"1\"},\n+\t{\"-5\", \"-7\", \"\", \"1\"},\n \t{\"5\", \"0\", \"\", \"1\"},\n-\t{\"-5\", \"0\", \"\", \"-1\"},\n+\t{\"-5\", \"0\", \"\", \"1\"},\n \t{\"5\", \"1\", \"\", \"5\"},\n \t{\"-5\", \"1\", \"\", \"-5\"},\n \t{\"-2\", \"3\", \"2\", \"0\"},\n@@ -779,6 +781,7 @@ var expTests = []struct {\n \t{\"0x8000000000000000\", \"3\", \"6719\", \"5447\"},\n \t{\"0x8000000000000000\", \"1000\", \"6719\", \"1603\"},\n \t{\"0x8000000000000000\", \"1000000\", \"6719\", \"3199\"},\n+\t{\"0x8000000000000000\", \"-1000000\", \"6719\", \"1\"},\n \t{\n \t\t\"2938462938472983472983659726349017249287491026512746239764525612965293865296239471239874193284792387498274256129746192347\",\n \t\t\"298472983472983471903246121093472394872319615612417471234712061\",\n@@ -807,12 +810,22 @@ func TestExp(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tz := y.Exp(x, y, m)\n-\t\tif !isNormalized(z) {\n-\t\t\tt.Errorf(\"#%d: %v is not normalized\", i, *z)\n+\t\tz1 := new(Int).Exp(x, y, m)\n+\t\tif !isNormalized(z1) {\n+\t\t\tt.Errorf(\"#%d: %v is not normalized\", i, *z1)\n+\t\t}\n+\t\tif z1.Cmp(out) != 0 {\n+\t\t\tt.Errorf(\"#%d: got %s want %s\", i, z1, out)\n \t\t}\n-\t\tif z.Cmp(out) != 0 {\n-\t\t\tt.Errorf(\"#%d: got %s want %s\", i, z, out)\n+\n+\t\tif m == nil {\n+\t\t\t// the result should be the same as for m == 0;\n+\t\t\t// specifically, there should be no div-zero panic\n+\t\t\tm = &Int{abs: nat{}} // m != nil && len(m.abs) == 0\n+\t\t\tz2 := new(Int).Exp(x, y, m)\n+\t\t\tif z2.Cmp(z1) != 0 {\n+\t\t\t\tt.Errorf(\"#%d: got %s want %s\", i, z1, z2)\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "13a623a70327b0fd771387baa79dfc7678721697", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 116, "deletions": 48, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -421,17 +421,17 @@ func (z nat) mul(x, y nat) nat {\n \tz[2*k:].clear() // upper portion of z is garbage (and 2*k <= m+n since k <= n <= m)\n \n \t// If xh != 0 or yh != 0, add the missing terms to z. For\n-\t// \n-\t//   xh = xi*b^i + ... + x2*b^2 + x1*b (0 <= xi < b) \n-\t//   yh =                         y1*b (0 <= y1 < b) \n-\t// \n-\t// the missing terms are \n-\t// \n-\t//   x0*y1*b and xi*y0*b^i, xi*y1*b^(i+1) for i > 0 \n-\t// \n-\t// since all the yi for i > 1 are 0 by choice of k: If any of them \n-\t// were > 0, then yh >= b^2 and thus y >= b^2. Then k' = k*2 would \n-\t// be a larger valid threshold contradicting the assumption about k. \n+\t//\n+\t//   xh = xi*b^i + ... + x2*b^2 + x1*b (0 <= xi < b)\n+\t//   yh =                         y1*b (0 <= y1 < b)\n+\t//\n+\t// the missing terms are\n+\t//\n+\t//   x0*y1*b and xi*y0*b^i, xi*y1*b^(i+1) for i > 0\n+\t//\n+\t// since all the yi for i > 1 are 0 by choice of k: If any of them\n+\t// were > 0, then yh >= b^2 and thus y >= b^2. Then k' = k*2 would\n+\t// be a larger valid threshold contradicting the assumption about k.\n \t//\n \tif k < n || m != n {\n \t\tvar t nat\n@@ -828,16 +828,16 @@ func (x nat) string(charset string) string {\n // by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using\n // repeated nat/Word divison.\n //\n-// The iterative method processes n Words by n divW() calls, each of which visits every Word in the \n-// incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s. \n-// Recursive conversion divides q by its approximate square root, yielding two parts, each half \n+// The iterative method processes n Words by n divW() calls, each of which visits every Word in the\n+// incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s.\n+// Recursive conversion divides q by its approximate square root, yielding two parts, each half\n // the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s\n // plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and\n-// is made better by splitting the subblocks recursively. Best is to split blocks until one more \n-// split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the \n-// iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the \n-// range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and \n-// ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for \n+// is made better by splitting the subblocks recursively. Best is to split blocks until one more\n+// split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the\n+// iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the\n+// range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and\n+// ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for\n // specific hardware.\n //\n func (q nat) convertWords(s []byte, charset string, b Word, ndigits int, bb Word, table []divisor) {\n@@ -920,8 +920,10 @@ type divisor struct {\n \tndigits int // digit length of divisor in terms of output base digits\n }\n \n-var cacheBase10 [64]divisor // cached divisors for base 10\n-var cacheLock sync.Mutex    // protects cacheBase10\n+var cacheBase10 struct {\n+\tsync.Mutex\n+\ttable [64]divisor // cached divisors for base 10\n+}\n \n // expWW computes x**y\n func (z nat) expWW(x, y Word) nat {\n@@ -937,34 +939,28 @@ func divisors(m int, b Word, ndigits int, bb Word) []divisor {\n \n \t// determine k where (bb**leafSize)**(2**k) >= sqrt(x)\n \tk := 1\n-\tfor words := leafSize; words < m>>1 && k < len(cacheBase10); words <<= 1 {\n+\tfor words := leafSize; words < m>>1 && k < len(cacheBase10.table); words <<= 1 {\n \t\tk++\n \t}\n \n-\t// create new table of divisors or extend and reuse existing table as appropriate\n-\tvar table []divisor\n-\tvar cached bool\n-\tswitch b {\n-\tcase 10:\n-\t\ttable = cacheBase10[0:k] // reuse old table for this conversion\n-\t\tcached = true\n-\tdefault:\n-\t\ttable = make([]divisor, k) // new table for this conversion\n+\t// reuse and extend existing table of divisors or create new table as appropriate\n+\tvar table []divisor // for b == 10, table overlaps with cacheBase10.table\n+\tif b == 10 {\n+\t\tcacheBase10.Lock()\n+\t\ttable = cacheBase10.table[0:k] // reuse old table for this conversion\n+\t} else {\n+\t\ttable = make([]divisor, k) // create new table for this conversion\n \t}\n \n \t// extend table\n \tif table[k-1].ndigits == 0 {\n-\t\tif cached {\n-\t\t\tcacheLock.Lock() // begin critical section\n-\t\t}\n-\n \t\t// add new entries as needed\n \t\tvar larger nat\n \t\tfor i := 0; i < k; i++ {\n \t\t\tif table[i].ndigits == 0 {\n \t\t\t\tif i == 0 {\n-\t\t\t\t\ttable[i].bbb = nat(nil).expWW(bb, Word(leafSize))\n-\t\t\t\t\ttable[i].ndigits = ndigits * leafSize\n+\t\t\t\t\ttable[0].bbb = nat(nil).expWW(bb, Word(leafSize))\n+\t\t\t\t\ttable[0].ndigits = ndigits * leafSize\n \t\t\t\t} else {\n \t\t\t\t\ttable[i].bbb = nat(nil).mul(table[i-1].bbb, table[i-1].bbb)\n \t\t\t\t\ttable[i].ndigits = 2 * table[i-1].ndigits\n@@ -980,10 +976,10 @@ func divisors(m int, b Word, ndigits int, bb Word) []divisor {\n \t\t\t\ttable[i].nbits = table[i].bbb.bitLen()\n \t\t\t}\n \t\t}\n+\t}\n \n-\t\tif cached {\n-\t\t\tcacheLock.Unlock() // end critical section\n-\t\t}\n+\tif b == 10 {\n+\t\tcacheBase10.Unlock()\n \t}\n \n \treturn table\n@@ -1231,8 +1227,8 @@ func (z nat) random(rand *rand.Rand, limit nat, n int) nat {\n \treturn z.norm()\n }\n \n-// If m != nil, expNN calculates x**y mod m. Otherwise it calculates x**y. It\n-// reuses the storage of z if possible.\n+// If m != 0 (i.e., len(m) != 0), expNN sets z to x**y mod m;\n+// otherwise it sets z to x**y. The result is the value of z.\n func (z nat) expNN(x, y, m nat) nat {\n \tif alias(z, x) || alias(z, y) {\n \t\t// We cannot allow in-place modification of x or y.\n@@ -1244,15 +1240,24 @@ func (z nat) expNN(x, y, m nat) nat {\n \t\tz[0] = 1\n \t\treturn z\n \t}\n+\t// y > 0\n \n-\tif m != nil {\n+\tif len(m) != 0 {\n \t\t// We likely end up being as long as the modulus.\n \t\tz = z.make(len(m))\n \t}\n \tz = z.set(x)\n-\tv := y[len(y)-1]\n-\t// It's invalid for the most significant word to be zero, therefore we\n-\t// will find a one bit.\n+\n+\t// If the base is non-trivial and the exponent is large, we use\n+\t// 4-bit, windowed exponentiation. This involves precomputing 14 values\n+\t// (x^2...x^15) but then reduces the number of multiply-reduces by a\n+\t// third. Even for a 32-bit exponent, this reduces the number of\n+\t// operations.\n+\tif len(x) > 1 && len(y) > 1 && len(m) > 0 {\n+\t\treturn z.expNNWindowed(x, y, m)\n+\t}\n+\n+\tv := y[len(y)-1] // v > 0 because y is normalized and y > 0\n \tshift := leadingZeros(v) + 1\n \tv <<= shift\n \tvar q nat\n@@ -1276,7 +1281,7 @@ func (z nat) expNN(x, y, m nat) nat {\n \t\t\tzz, z = z, zz\n \t\t}\n \n-\t\tif m != nil {\n+\t\tif len(m) != 0 {\n \t\t\tzz, r = zz.div(r, z, m)\n \t\t\tzz, r, q, z = q, z, zz, r\n \t\t}\n@@ -1296,7 +1301,7 @@ func (z nat) expNN(x, y, m nat) nat {\n \t\t\t\tzz, z = z, zz\n \t\t\t}\n \n-\t\t\tif m != nil {\n+\t\t\tif len(m) != 0 {\n \t\t\t\tzz, r = zz.div(r, z, m)\n \t\t\t\tzz, r, q, z = q, z, zz, r\n \t\t\t}\n@@ -1308,6 +1313,69 @@ func (z nat) expNN(x, y, m nat) nat {\n \treturn z.norm()\n }\n \n+// expNNWindowed calculates x**y mod m using a fixed, 4-bit window.\n+func (z nat) expNNWindowed(x, y, m nat) nat {\n+\t// zz and r are used to avoid allocating in mul and div as otherwise\n+\t// the arguments would alias.\n+\tvar zz, r nat\n+\n+\tconst n = 4\n+\t// powers[i] contains x^i.\n+\tvar powers [1 << n]nat\n+\tpowers[0] = natOne\n+\tpowers[1] = x\n+\tfor i := 2; i < 1<<n; i += 2 {\n+\t\tp2, p, p1 := &powers[i/2], &powers[i], &powers[i+1]\n+\t\t*p = p.mul(*p2, *p2)\n+\t\tzz, r = zz.div(r, *p, m)\n+\t\t*p, r = r, *p\n+\t\t*p1 = p1.mul(*p, x)\n+\t\tzz, r = zz.div(r, *p1, m)\n+\t\t*p1, r = r, *p1\n+\t}\n+\n+\tz = z.setWord(1)\n+\n+\tfor i := len(y) - 1; i >= 0; i-- {\n+\t\tyi := y[i]\n+\t\tfor j := 0; j < _W; j += n {\n+\t\t\tif i != len(y)-1 || j != 0 {\n+\t\t\t\t// Unrolled loop for significant performance\n+\t\t\t\t// gain.  Use go test -bench=\".*\" in crypto/rsa\n+\t\t\t\t// to check performance before making changes.\n+\t\t\t\tzz = zz.mul(z, z)\n+\t\t\t\tzz, z = z, zz\n+\t\t\t\tzz, r = zz.div(r, z, m)\n+\t\t\t\tz, r = r, z\n+\n+\t\t\t\tzz = zz.mul(z, z)\n+\t\t\t\tzz, z = z, zz\n+\t\t\t\tzz, r = zz.div(r, z, m)\n+\t\t\t\tz, r = r, z\n+\n+\t\t\t\tzz = zz.mul(z, z)\n+\t\t\t\tzz, z = z, zz\n+\t\t\t\tzz, r = zz.div(r, z, m)\n+\t\t\t\tz, r = r, z\n+\n+\t\t\t\tzz = zz.mul(z, z)\n+\t\t\t\tzz, z = z, zz\n+\t\t\t\tzz, r = zz.div(r, z, m)\n+\t\t\t\tz, r = r, z\n+\t\t\t}\n+\n+\t\t\tzz = zz.mul(z, powers[yi>>(_W-n)])\n+\t\t\tzz, z = z, zz\n+\t\t\tzz, r = zz.div(r, z, m)\n+\t\t\tz, r = r, z\n+\n+\t\t\tyi <<= n\n+\t\t}\n+\t}\n+\n+\treturn z.norm()\n+}\n+\n // probablyPrime performs reps Miller-Rabin tests to check whether n is prime.\n // If it returns true, n is prime with probability 1 - 1/4^reps.\n // If it returns false, n is not prime."}, {"sha": "6244eeefc91af70ae9292d34e4af305f19e50227", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -166,7 +166,7 @@ func TestMulRangeN(t *testing.T) {\n \t}\n }\n \n-// allocBytes returns the number of bytes allocated by invoking f. \n+// allocBytes returns the number of bytes allocated by invoking f.\n func allocBytes(f func()) uint64 {\n \tvar stats runtime.MemStats\n \truntime.ReadMemStats(&stats)\n@@ -409,13 +409,49 @@ func TestScanPi(t *testing.T) {\n \t}\n }\n \n+func TestScanPiParallel(t *testing.T) {\n+\tconst n = 2\n+\tc := make(chan int)\n+\tfor i := 0; i < n; i++ {\n+\t\tgo func() {\n+\t\t\tTestScanPi(t)\n+\t\t\tc <- 0\n+\t\t}()\n+\t}\n+\tfor i := 0; i < n; i++ {\n+\t\t<-c\n+\t}\n+}\n+\n func BenchmarkScanPi(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tvar x nat\n \t\tx.scan(strings.NewReader(pi), 10)\n \t}\n }\n \n+func BenchmarkStringPiParallel(b *testing.B) {\n+\tvar x nat\n+\tx, _, _ = x.scan(strings.NewReader(pi), 0)\n+\tif x.decimalString() != pi {\n+\t\tpanic(\"benchmark incorrect: conversion failed\")\n+\t}\n+\tn := runtime.GOMAXPROCS(0)\n+\tm := b.N / n // n*m <= b.N due to flooring, but the error is neglibible (n is not very large)\n+\tc := make(chan int, n)\n+\tfor i := 0; i < n; i++ {\n+\t\tgo func() {\n+\t\t\tfor j := 0; j < m; j++ {\n+\t\t\t\tx.decimalString()\n+\t\t\t}\n+\t\t\tc <- 0\n+\t\t}()\n+\t}\n+\tfor i := 0; i < n; i++ {\n+\t\t<-c\n+\t}\n+}\n+\n func BenchmarkScan10Base2(b *testing.B)     { ScanHelper(b, 2, 10, 10) }\n func BenchmarkScan100Base2(b *testing.B)    { ScanHelper(b, 2, 10, 100) }\n func BenchmarkScan1000Base2(b *testing.B)   { ScanHelper(b, 2, 10, 1000) }\n@@ -510,13 +546,13 @@ func BenchmarkLeafSize13(b *testing.B) { LeafSizeHelper(b, 10, 13) }\n func BenchmarkLeafSize14(b *testing.B) { LeafSizeHelper(b, 10, 14) }\n func BenchmarkLeafSize15(b *testing.B) { LeafSizeHelper(b, 10, 15) }\n func BenchmarkLeafSize16(b *testing.B) { LeafSizeHelper(b, 10, 16) }\n-func BenchmarkLeafSize32(b *testing.B) { LeafSizeHelper(b, 10, 32) } // try some large lengths \n+func BenchmarkLeafSize32(b *testing.B) { LeafSizeHelper(b, 10, 32) } // try some large lengths\n func BenchmarkLeafSize64(b *testing.B) { LeafSizeHelper(b, 10, 64) }\n \n func LeafSizeHelper(b *testing.B, base Word, size int) {\n \tb.StopTimer()\n \toriginalLeafSize := leafSize\n-\tresetTable(cacheBase10[:])\n+\tresetTable(cacheBase10.table[:])\n \tleafSize = size\n \tb.StartTimer()\n \n@@ -533,7 +569,7 @@ func LeafSizeHelper(b *testing.B, base Word, size int) {\n \t}\n \n \tb.StopTimer()\n-\tresetTable(cacheBase10[:])\n+\tresetTable(cacheBase10.table[:])\n \tleafSize = originalLeafSize\n \tb.StartTimer()\n }"}, {"sha": "037ce805055b7b088b33350766c44eb0daa49f3d", "filename": "libgo/go/net/conn_test.go", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fconn_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net_test\n+\n+import (\n+\t\"net\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+var connTests = []struct {\n+\tnet  string\n+\taddr string\n+}{\n+\t{\"tcp\", \"127.0.0.1:0\"},\n+\t{\"unix\", \"/tmp/gotest.net\"},\n+\t{\"unixpacket\", \"/tmp/gotest.net\"},\n+}\n+\n+func TestConnAndListener(t *testing.T) {\n+\tfor _, tt := range connTests {\n+\t\tswitch tt.net {\n+\t\tcase \"unix\", \"unixpacket\":\n+\t\t\tswitch runtime.GOOS {\n+\t\t\tcase \"plan9\", \"windows\":\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif tt.net == \"unixpacket\" && runtime.GOOS != \"linux\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tos.Remove(tt.addr)\n+\t\t}\n+\n+\t\tln, err := net.Listen(tt.net, tt.addr)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"net.Listen failed: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tln.Addr()\n+\t\tdefer ln.Close()\n+\n+\t\tdone := make(chan int)\n+\t\tgo transponder(t, ln, done)\n+\n+\t\tc, err := net.Dial(tt.net, ln.Addr().String())\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"net.Dial failed: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tc.LocalAddr()\n+\t\tc.RemoteAddr()\n+\t\tc.SetDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\tc.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\tc.SetWriteDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\tdefer c.Close()\n+\n+\t\tif _, err := c.Write([]byte(\"CONN TEST\")); err != nil {\n+\t\t\tt.Errorf(\"net.Conn.Write failed: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\trb := make([]byte, 128)\n+\t\tif _, err := c.Read(rb); err != nil {\n+\t\t\tt.Errorf(\"net.Conn.Read failed: %v\", err)\n+\t\t}\n+\n+\t\t<-done\n+\t\tswitch tt.net {\n+\t\tcase \"unix\", \"unixpacket\":\n+\t\t\tos.Remove(tt.addr)\n+\t\t}\n+\t}\n+}\n+\n+func transponder(t *testing.T, ln net.Listener, done chan<- int) {\n+\tdefer func() { done <- 1 }()\n+\n+\tc, err := ln.Accept()\n+\tif err != nil {\n+\t\tt.Errorf(\"net.Listener.Accept failed: %v\", err)\n+\t\treturn\n+\t}\n+\tc.LocalAddr()\n+\tc.RemoteAddr()\n+\tc.SetDeadline(time.Now().Add(100 * time.Millisecond))\n+\tc.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n+\tc.SetWriteDeadline(time.Now().Add(100 * time.Millisecond))\n+\tdefer c.Close()\n+\n+\tb := make([]byte, 128)\n+\tn, err := c.Read(b)\n+\tif err != nil {\n+\t\tt.Errorf(\"net.Conn.Read failed: %v\", err)\n+\t\treturn\n+\t}\n+\tif _, err := c.Write(b[:n]); err != nil {\n+\t\tt.Errorf(\"net.Conn.Write failed: %v\", err)\n+\t\treturn\n+\t}\n+}"}, {"sha": "a85e3c673bfe835f096a86b5a5497e1dcf93d43b", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -5,6 +5,7 @@\n package net\n \n import (\n+\t\"runtime\"\n \t\"time\"\n )\n \n@@ -36,33 +37,33 @@ func parseDialNetwork(net string) (afnet string, proto int, err error) {\n \treturn \"\", 0, UnknownNetworkError(net)\n }\n \n-func resolveNetAddr(op, net, addr string) (afnet string, a Addr, err error) {\n+func resolveNetAddr(op, net, addr string, deadline time.Time) (afnet string, a Addr, err error) {\n \tafnet, _, err = parseDialNetwork(net)\n \tif err != nil {\n \t\treturn \"\", nil, &OpError{op, net, nil, err}\n \t}\n \tif op == \"dial\" && addr == \"\" {\n \t\treturn \"\", nil, &OpError{op, net, nil, errMissingAddress}\n \t}\n+\ta, err = resolveAfnetAddr(afnet, addr, deadline)\n+\treturn\n+}\n+\n+func resolveAfnetAddr(afnet, addr string, deadline time.Time) (Addr, error) {\n+\tif addr == \"\" {\n+\t\treturn nil, nil\n+\t}\n \tswitch afnet {\n \tcase \"tcp\", \"tcp4\", \"tcp6\":\n-\t\tif addr != \"\" {\n-\t\t\ta, err = ResolveTCPAddr(afnet, addr)\n-\t\t}\n+\t\treturn resolveTCPAddr(afnet, addr, deadline)\n \tcase \"udp\", \"udp4\", \"udp6\":\n-\t\tif addr != \"\" {\n-\t\t\ta, err = ResolveUDPAddr(afnet, addr)\n-\t\t}\n+\t\treturn resolveUDPAddr(afnet, addr, deadline)\n \tcase \"ip\", \"ip4\", \"ip6\":\n-\t\tif addr != \"\" {\n-\t\t\ta, err = ResolveIPAddr(afnet, addr)\n-\t\t}\n+\t\treturn resolveIPAddr(afnet, addr, deadline)\n \tcase \"unix\", \"unixgram\", \"unixpacket\":\n-\t\tif addr != \"\" {\n-\t\t\ta, err = ResolveUnixAddr(afnet, addr)\n-\t\t}\n+\t\treturn ResolveUnixAddr(afnet, addr)\n \t}\n-\treturn\n+\treturn nil, nil\n }\n \n // Dial connects to the address addr on the network net.\n@@ -89,23 +90,23 @@ func resolveNetAddr(op, net, addr string) (afnet string, a Addr, err error) {\n //\tDial(\"ip6:ospf\", \"::1\")\n //\n func Dial(net, addr string) (Conn, error) {\n-\t_, addri, err := resolveNetAddr(\"dial\", net, addr)\n+\t_, addri, err := resolveNetAddr(\"dial\", net, addr, noDeadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn dialAddr(net, addr, addri)\n+\treturn dialAddr(net, addr, addri, noDeadline)\n }\n \n-func dialAddr(net, addr string, addri Addr) (c Conn, err error) {\n+func dialAddr(net, addr string, addri Addr, deadline time.Time) (c Conn, err error) {\n \tswitch ra := addri.(type) {\n \tcase *TCPAddr:\n-\t\tc, err = DialTCP(net, nil, ra)\n+\t\tc, err = dialTCP(net, nil, ra, deadline)\n \tcase *UDPAddr:\n-\t\tc, err = DialUDP(net, nil, ra)\n+\t\tc, err = dialUDP(net, nil, ra, deadline)\n \tcase *IPAddr:\n-\t\tc, err = DialIP(net, nil, ra)\n+\t\tc, err = dialIP(net, nil, ra, deadline)\n \tcase *UnixAddr:\n-\t\tc, err = DialUnix(net, nil, ra)\n+\t\tc, err = dialUnix(net, nil, ra, deadline)\n \tdefault:\n \t\terr = &OpError{\"dial\", net + \" \" + addr, nil, UnknownNetworkError(net)}\n \t}\n@@ -115,13 +116,31 @@ func dialAddr(net, addr string, addri Addr) (c Conn, err error) {\n \treturn\n }\n \n+const useDialTimeoutRace = runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\"\n+\n // DialTimeout acts like Dial but takes a timeout.\n // The timeout includes name resolution, if required.\n func DialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\n-\t// TODO(bradfitz): the timeout should be pushed down into the\n-\t// net package's event loop, so on timeout to dead hosts we\n-\t// don't have a goroutine sticking around for the default of\n-\t// ~3 minutes.\n+\tif useDialTimeoutRace {\n+\t\t// On windows and plan9, use the relatively inefficient\n+\t\t// goroutine-racing implementation of DialTimeout that\n+\t\t// doesn't push down deadlines to the pollster.\n+\t\t// TODO: remove this once those are implemented.\n+\t\treturn dialTimeoutRace(net, addr, timeout)\n+\t}\n+\tdeadline := time.Now().Add(timeout)\n+\t_, addri, err := resolveNetAddr(\"dial\", net, addr, deadline)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn dialAddr(net, addr, addri, deadline)\n+}\n+\n+// dialTimeoutRace is the old implementation of DialTimeout, still used\n+// on operating systems where the deadline hasn't been pushed down\n+// into the pollserver.\n+// TODO: fix this on Windows and plan9.\n+func dialTimeoutRace(net, addr string, timeout time.Duration) (Conn, error) {\n \tt := time.NewTimer(timeout)\n \tdefer t.Stop()\n \ttype pair struct {\n@@ -131,13 +150,13 @@ func DialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\n \tch := make(chan pair, 1)\n \tresolvedAddr := make(chan Addr, 1)\n \tgo func() {\n-\t\t_, addri, err := resolveNetAddr(\"dial\", net, addr)\n+\t\t_, addri, err := resolveNetAddr(\"dial\", net, addr, noDeadline)\n \t\tif err != nil {\n \t\t\tch <- pair{nil, err}\n \t\t\treturn\n \t\t}\n \t\tresolvedAddr <- addri // in case we need it for OpError\n-\t\tc, err := dialAddr(net, addr, addri)\n+\t\tc, err := dialAddr(net, addr, addri, noDeadline)\n \t\tch <- pair{c, err}\n \t}()\n \tselect {\n@@ -175,7 +194,7 @@ func (a stringAddr) String() string  { return a.addr }\n // The network string net must be a stream-oriented network:\n // \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n func Listen(net, laddr string) (Listener, error) {\n-\tafnet, a, err := resolveNetAddr(\"listen\", net, laddr)\n+\tafnet, a, err := resolveNetAddr(\"listen\", net, laddr, noDeadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -200,7 +219,7 @@ func Listen(net, laddr string) (Listener, error) {\n // The network string net must be a packet-oriented network:\n // \"udp\", \"udp4\", \"udp6\", \"ip\", \"ip4\", \"ip6\" or \"unixgram\".\n func ListenPacket(net, addr string) (PacketConn, error) {\n-\tafnet, a, err := resolveNetAddr(\"listen\", net, addr)\n+\tafnet, a, err := resolveNetAddr(\"listen\", net, addr, noDeadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "865dd627778adf3348ece0937dc2f160b20d258b", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -7,6 +7,8 @@ package net\n import (\n \t\"flag\"\n \t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n \t\"regexp\"\n \t\"runtime\"\n \t\"testing\"\n@@ -55,7 +57,7 @@ func TestDialTimeout(t *testing.T) {\n \t\t// on our 386 builder, this Dial succeeds, connecting\n \t\t// to an IIS web server somewhere.  The data center\n \t\t// or VM or firewall must be stealing the TCP connection.\n-\t\t// \n+\t\t//\n \t\t// IANA Service Name and Transport Protocol Port Number Registry\n \t\t// <http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml>\n \t\tgo func() {\n@@ -222,3 +224,79 @@ func TestDialError(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestDialTimeoutFDLeak(t *testing.T) {\n+\tif runtime.GOOS != \"linux\" {\n+\t\t// TODO(bradfitz): test on other platforms\n+\t\tt.Logf(\"skipping test on %s\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\n+\ttype connErr struct {\n+\t\tconn Conn\n+\t\terr  error\n+\t}\n+\tdials := listenerBacklog + 100\n+\tmaxGoodConnect := listenerBacklog + 5 // empirically 131 good ones (of 128). who knows?\n+\tresc := make(chan connErr)\n+\tfor i := 0; i < dials; i++ {\n+\t\tgo func() {\n+\t\t\tconn, err := DialTimeout(\"tcp\", ln.Addr().String(), 500*time.Millisecond)\n+\t\t\tresc <- connErr{conn, err}\n+\t\t}()\n+\t}\n+\n+\tvar firstErr string\n+\tvar ngood int\n+\tvar toClose []io.Closer\n+\tfor i := 0; i < dials; i++ {\n+\t\tce := <-resc\n+\t\tif ce.err == nil {\n+\t\t\tngood++\n+\t\t\tif ngood > maxGoodConnect {\n+\t\t\t\tt.Errorf(\"%d good connects; expected at most %d\", ngood, maxGoodConnect)\n+\t\t\t}\n+\t\t\ttoClose = append(toClose, ce.conn)\n+\t\t\tcontinue\n+\t\t}\n+\t\terr := ce.err\n+\t\tif firstErr == \"\" {\n+\t\t\tfirstErr = err.Error()\n+\t\t} else if err.Error() != firstErr {\n+\t\t\tt.Fatalf(\"inconsistent error messages: first was %q, then later %q\", firstErr, err)\n+\t\t}\n+\t}\n+\tfor _, c := range toClose {\n+\t\tc.Close()\n+\t}\n+\tfor i := 0; i < 100; i++ {\n+\t\tif got := numFD(); got < dials {\n+\t\t\t// Test passes.\n+\t\t\treturn\n+\t\t}\n+\t\ttime.Sleep(10 * time.Millisecond)\n+\t}\n+\tif got := numFD(); got >= dials {\n+\t\tt.Errorf(\"num fds after %d timeouts = %d; want <%d\", dials, got, dials)\n+\t}\n+}\n+\n+func numFD() int {\n+\tif runtime.GOOS == \"linux\" {\n+\t\tf, err := os.Open(\"/proc/self/fd\")\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tnames, err := f.Readdirnames(0)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\treturn len(names)\n+\t}\n+\t// All tests using this should be skipped anyway, but:\n+\tpanic(\"numFDs not implemented on \" + runtime.GOOS)\n+}"}, {"sha": "dd3c4ba7e156cf368147776b222d97ddd405c5cc", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -116,7 +116,12 @@ func TestDialGoogleIPv6(t *testing.T) {\n \t\treturn\n \t}\n \t// Only run tcp6 if the kernel will take it.\n-\tif !*testIPv6 || !supportsIPv6 {\n+\tif !supportsIPv6 {\n+\t\tt.Logf(\"skipping test; ipv6 is not supported\")\n+\t\treturn\n+\t}\n+\tif !*testIPv6 {\n+\t\tt.Logf(\"test disabled; use -ipv6 to enable\")\n \t\treturn\n \t}\n "}, {"sha": "76b192645aafc2442f34e7d7b4044fa7d54f34ed", "filename": "libgo/go/net/dnsclient.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdnsclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdnsclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -183,7 +183,7 @@ func (s byPriorityWeight) Less(i, j int) bool {\n }\n \n // shuffleByWeight shuffles SRV records by weight using the algorithm\n-// described in RFC 2782.  \n+// described in RFC 2782.\n func (addrs byPriorityWeight) shuffleByWeight() {\n \tsum := 0\n \tfor _, addr := range addrs {\n@@ -244,3 +244,8 @@ func (s byPref) sort() {\n \t}\n \tsort.Sort(s)\n }\n+\n+// An NS represents a single DNS NS record.\n+type NS struct {\n+\tHost string\n+}"}, {"sha": "161afb2a55675eaaa855c4840c97b4c9af3c2e18", "filename": "libgo/go/net/dnsmsg.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsmsg.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -618,7 +618,7 @@ func printStruct(any dnsStruct) string {\n \t\ts += name + \"=\"\n \t\tswitch tag {\n \t\tcase \"ipv4\":\n-\t\t\ti := val.(uint32)\n+\t\t\ti := *val.(*uint32)\n \t\t\ts += IPv4(byte(i>>24), byte(i>>16), byte(i>>8), byte(i)).String()\n \t\tcase \"ipv6\":\n \t\t\ti := val.([]byte)"}, {"sha": "6d7ab388ae783c02bfd792742a71801a47c8ad84", "filename": "libgo/go/net/fd_plan9.go", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"io\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+// Network file descritor.\n+type netFD struct {\n+\tproto, name, dir string\n+\tctl, data        *os.File\n+\tladdr, raddr     Addr\n+}\n+\n+var canCancelIO = true // used for testing current package\n+\n+func sysInit() {\n+}\n+\n+func newFD(proto, name string, ctl *os.File, laddr, raddr Addr) *netFD {\n+\treturn &netFD{proto, name, \"/net/\" + proto + \"/\" + name, ctl, nil, laddr, raddr}\n+}\n+\n+func (fd *netFD) ok() bool { return fd != nil && fd.ctl != nil }\n+\n+func (fd *netFD) Read(b []byte) (n int, err error) {\n+\tif !fd.ok() {\n+\t\treturn 0, syscall.EINVAL\n+\t}\n+\tif fd.data == nil {\n+\t\tfd.data, err = os.OpenFile(fd.dir+\"/data\", os.O_RDWR, 0)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t}\n+\tn, err = fd.data.Read(b)\n+\tif fd.proto == \"udp\" && err == io.EOF {\n+\t\tn = 0\n+\t\terr = nil\n+\t}\n+\treturn\n+}\n+\n+func (fd *netFD) Write(b []byte) (n int, err error) {\n+\tif !fd.ok() {\n+\t\treturn 0, syscall.EINVAL\n+\t}\n+\tif fd.data == nil {\n+\t\tfd.data, err = os.OpenFile(fd.dir+\"/data\", os.O_RDWR, 0)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t}\n+\treturn fd.data.Write(b)\n+}\n+\n+func (fd *netFD) CloseRead() error {\n+\tif !fd.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn syscall.EPLAN9\n+}\n+\n+func (fd *netFD) CloseWrite() error {\n+\tif !fd.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn syscall.EPLAN9\n+}\n+\n+func (fd *netFD) Close() error {\n+\tif !fd.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\terr := fd.ctl.Close()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif fd.data != nil {\n+\t\terr = fd.data.Close()\n+\t}\n+\tfd.ctl = nil\n+\tfd.data = nil\n+\treturn err\n+}\n+\n+func (fd *netFD) dup() (*os.File, error) {\n+\treturn nil, syscall.EPLAN9\n+}\n+\n+func setDeadline(fd *netFD, t time.Time) error {\n+\treturn syscall.EPLAN9\n+}\n+\n+func setReadDeadline(fd *netFD, t time.Time) error {\n+\treturn syscall.EPLAN9\n+}\n+\n+func setWriteDeadline(fd *netFD, t time.Time) error {\n+\treturn syscall.EPLAN9\n+}\n+\n+func setReadBuffer(fd *netFD, bytes int) error {\n+\treturn syscall.EPLAN9\n+}\n+\n+func setWriteBuffer(fd *netFD, bytes int) error {\n+\treturn syscall.EPLAN9\n+}"}, {"sha": "096ad41bbfad340f7f4ffe8572ab3e8913eb4aaa", "filename": "libgo/go/net/fd_unix.go", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -7,7 +7,6 @@\n package net\n \n import (\n-\t\"errors\"\n \t\"io\"\n \t\"os\"\n \t\"runtime\"\n@@ -97,15 +96,11 @@ func (s *pollServer) AddFD(fd *netFD, mode int) error {\n \t}\n \n \twake, err := s.poll.AddFD(intfd, mode, false)\n+\ts.Unlock()\n \tif err != nil {\n-\t\tpanic(\"pollServer AddFD \" + err.Error())\n-\t}\n-\tif wake {\n-\t\tdoWakeup = true\n+\t\treturn &OpError{\"addfd\", fd.net, fd.laddr, err}\n \t}\n-\ts.Unlock()\n-\n-\tif doWakeup {\n+\tif wake || doWakeup {\n \t\ts.Wakeup()\n \t}\n \treturn nil\n@@ -167,7 +162,7 @@ func (s *pollServer) CheckDeadlines() {\n \t// TODO(rsc): This will need to be handled more efficiently,\n \t// probably with a heap indexed by wakeup time.\n \n-\tvar next_deadline int64\n+\tvar nextDeadline int64\n \tfor key, fd := range s.pending {\n \t\tvar t int64\n \t\tvar mode int\n@@ -192,12 +187,12 @@ func (s *pollServer) CheckDeadlines() {\n \t\t\t\t\tfd.wdeadline = -1\n \t\t\t\t}\n \t\t\t\ts.WakeFD(fd, mode, nil)\n-\t\t\t} else if next_deadline == 0 || t < next_deadline {\n-\t\t\t\tnext_deadline = t\n+\t\t\t} else if nextDeadline == 0 || t < nextDeadline {\n+\t\t\t\tnextDeadline = t\n \t\t\t}\n \t\t}\n \t}\n-\ts.deadline = next_deadline\n+\ts.deadline = nextDeadline\n }\n \n func (s *pollServer) Run() {\n@@ -265,7 +260,9 @@ var pollMaxN int\n var pollservers []*pollServer\n var startServersOnce []func()\n \n-func init() {\n+var canCancelIO = true // used for testing current package\n+\n+func sysInit() {\n \tpollMaxN = runtime.NumCPU()\n \tif pollMaxN > 8 {\n \t\tpollMaxN = 8 // No improvement then.\n@@ -316,22 +313,30 @@ func newFD(fd, family, sotype int, net string) (*netFD, error) {\n func (fd *netFD) setAddr(laddr, raddr Addr) {\n \tfd.laddr = laddr\n \tfd.raddr = raddr\n+\tfd.sysfile = os.NewFile(uintptr(fd.sysfd), fd.net)\n+}\n+\n+func (fd *netFD) name() string {\n \tvar ls, rs string\n-\tif laddr != nil {\n-\t\tls = laddr.String()\n+\tif fd.laddr != nil {\n+\t\tls = fd.laddr.String()\n \t}\n-\tif raddr != nil {\n-\t\trs = raddr.String()\n+\tif fd.raddr != nil {\n+\t\trs = fd.raddr.String()\n \t}\n-\tfd.sysfile = os.NewFile(uintptr(fd.sysfd), fd.net+\":\"+ls+\"->\"+rs)\n+\treturn fd.net + \":\" + ls + \"->\" + rs\n }\n \n func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \terr := syscall.Connect(fd.sysfd, ra)\n+\thadTimeout := fd.wdeadline > 0\n \tif err == syscall.EINPROGRESS {\n \t\tif err = fd.pollServer.WaitWrite(fd); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif hadTimeout && fd.wdeadline < 0 {\n+\t\t\treturn errTimeout\n+\t\t}\n \t\tvar e int\n \t\te, err = syscall.GetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_ERROR)\n \t\tif err != nil {\n@@ -344,15 +349,10 @@ func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \treturn err\n }\n \n-var errClosing = errors.New(\"use of closed network connection\")\n-\n // Add a reference to this fd.\n // If closing==true, pollserver must be locked; mark the fd as closing.\n // Returns an error if the fd cannot be used.\n func (fd *netFD) incref(closing bool) error {\n-\tif fd == nil {\n-\t\treturn errClosing\n-\t}\n \tfd.sysmu.Lock()\n \tif fd.closing {\n \t\tfd.sysmu.Unlock()\n@@ -369,9 +369,6 @@ func (fd *netFD) incref(closing bool) error {\n // Remove a reference to this FD and close if we've been asked to do so (and\n // there are no references left.\n func (fd *netFD) decref() {\n-\tif fd == nil {\n-\t\treturn\n-\t}\n \tfd.sysmu.Lock()\n \tfd.sysref--\n \tif fd.closing && fd.sysref == 0 && fd.sysfile != nil {\n@@ -664,7 +661,7 @@ func (fd *netFD) dup() (f *os.File, err error) {\n \t\treturn nil, &OpError{\"setnonblock\", fd.net, fd.laddr, err}\n \t}\n \n-\treturn os.NewFile(uintptr(ns), fd.sysfile.Name()), nil\n+\treturn os.NewFile(uintptr(ns), fd.name()), nil\n }\n \n func closesocket(s int) error {"}, {"sha": "d1eb573d0040f0cae2078dcba9e42f1ed41123b9", "filename": "libgo/go/net/fd_unix_test.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd\n+\n+package net\n+\n+import (\n+\t\"testing\"\n+)\n+\n+// Issue 3590. netFd.AddFD should return an error\n+// from the underlying pollster rather than panicing.\n+func TestAddFDReturnsError(t *testing.T) {\n+\tl, err := Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer l.Close()\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tc, err := l.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer c.Close()\n+\t\t}\n+\t}()\n+\n+\tc, err := Dial(\"tcp\", l.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer c.Close()\n+\n+\t// replace c's pollServer with a closed version.\n+\tps, err := newPollServer()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tps.poll.Close()\n+\tc.(*TCPConn).conn.fd.pollServer = ps\n+\n+\tvar b [1]byte\n+\t_, err = c.Read(b[:])\n+\tif err, ok := err.(*OpError); ok {\n+\t\tif err.Op == \"addfd\" {\n+\t\t\treturn\n+\t\t}\n+\t\tif err, ok := err.Err.(*OpError); ok {\n+\t\t\t// the err is sometimes wrapped by another OpError\n+\t\t\tif err.Op == \"addfd\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+\tt.Error(err)\n+}"}, {"sha": "5338def92205be12bad90de2b038eb14d132e63d", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 103, "deletions": 80, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -17,19 +17,35 @@ import (\n \n var initErr error\n \n-func init() {\n+// CancelIo Windows API cancels all outstanding IO for a particular\n+// socket on current thread. To overcome that limitation, we run\n+// special goroutine, locked to OS single thread, that both starts\n+// and cancels IO. It means, there are 2 unavoidable thread switches\n+// for every IO.\n+// Some newer versions of Windows has new CancelIoEx API, that does\n+// not have that limitation and can be used from any thread. This\n+// package uses CancelIoEx API, if present, otherwise it fallback\n+// to CancelIo.\n+\n+var canCancelIO bool // determines if CancelIoEx API is present\n+\n+func sysInit() {\n \tvar d syscall.WSAData\n \te := syscall.WSAStartup(uint32(0x202), &d)\n \tif e != nil {\n \t\tinitErr = os.NewSyscallError(\"WSAStartup\", e)\n \t}\n+\tcanCancelIO = syscall.LoadCancelIoEx() == nil\n+\tif syscall.LoadGetAddrInfo() == nil {\n+\t\tlookupIP = newLookupIP\n+\t}\n }\n \n func closesocket(s syscall.Handle) error {\n \treturn syscall.Closesocket(s)\n }\n \n-// Interface for all io operations.\n+// Interface for all IO operations.\n type anOpIface interface {\n \tOp() *anOp\n \tName() string\n@@ -42,7 +58,7 @@ type ioResult struct {\n \terr error\n }\n \n-// anOp implements functionality common to all io operations.\n+// anOp implements functionality common to all IO operations.\n type anOp struct {\n \t// Used by IOCP interface, it must be first field\n \t// of the struct, as our code rely on it.\n@@ -75,7 +91,7 @@ func (o *anOp) Op() *anOp {\n \treturn o\n }\n \n-// bufOp is used by io operations that read / write\n+// bufOp is used by IO operations that read / write\n // data from / to client buffer.\n type bufOp struct {\n \tanOp\n@@ -92,7 +108,7 @@ func (o *bufOp) Init(fd *netFD, buf []byte, mode int) {\n \t}\n }\n \n-// resultSrv will retrieve all io completion results from\n+// resultSrv will retrieve all IO completion results from\n // iocp and send them to the correspondent waiting client\n // goroutine via channel supplied in the request.\n type resultSrv struct {\n@@ -107,30 +123,31 @@ func (s *resultSrv) Run() {\n \t\tr.err = syscall.GetQueuedCompletionStatus(s.iocp, &(r.qty), &key, &o, syscall.INFINITE)\n \t\tswitch {\n \t\tcase r.err == nil:\n-\t\t\t// Dequeued successfully completed io packet.\n+\t\t\t// Dequeued successfully completed IO packet.\n \t\tcase r.err == syscall.Errno(syscall.WAIT_TIMEOUT) && o == nil:\n \t\t\t// Wait has timed out (should not happen now, but might be used in the future).\n \t\t\tpanic(\"GetQueuedCompletionStatus timed out\")\n \t\tcase o == nil:\n \t\t\t// Failed to dequeue anything -> report the error.\n \t\t\tpanic(\"GetQueuedCompletionStatus failed \" + r.err.Error())\n \t\tdefault:\n-\t\t\t// Dequeued failed io packet.\n+\t\t\t// Dequeued failed IO packet.\n \t\t}\n \t\t(*anOp)(unsafe.Pointer(o)).resultc <- r\n \t}\n }\n \n-// ioSrv executes net io requests.\n+// ioSrv executes net IO requests.\n type ioSrv struct {\n-\tsubmchan chan anOpIface // submit io requests\n-\tcanchan  chan anOpIface // cancel io requests\n+\tsubmchan chan anOpIface // submit IO requests\n+\tcanchan  chan anOpIface // cancel IO requests\n }\n \n-// ProcessRemoteIO will execute submit io requests on behalf\n+// ProcessRemoteIO will execute submit IO requests on behalf\n // of other goroutines, all on a single os thread, so it can\n // cancel them later. Results of all operations will be sent\n // back to their requesters via channel supplied in request.\n+// It is used only when the CancelIoEx API is unavailable.\n func (s *ioSrv) ProcessRemoteIO() {\n \truntime.LockOSThread()\n \tdefer runtime.UnlockOSThread()\n@@ -144,20 +161,21 @@ func (s *ioSrv) ProcessRemoteIO() {\n \t}\n }\n \n-// ExecIO executes a single io operation. It either executes it\n-// inline, or, if a deadline is employed, passes the request onto\n+// ExecIO executes a single IO operation oi. It submits and cancels\n+// IO in the current thread for systems where Windows CancelIoEx API\n+// is available. Alternatively, it passes the request onto\n // a special goroutine and waits for completion or cancels request.\n // deadline is unix nanos.\n func (s *ioSrv) ExecIO(oi anOpIface, deadline int64) (int, error) {\n \tvar err error\n \to := oi.Op()\n-\tif deadline != 0 {\n+\tif canCancelIO {\n+\t\terr = oi.Submit()\n+\t} else {\n \t\t// Send request to a special dedicated thread,\n-\t\t// so it can stop the io with CancelIO later.\n+\t\t// so it can stop the IO with CancelIO later.\n \t\ts.submchan <- oi\n \t\terr = <-o.errnoc\n-\t} else {\n-\t\terr = oi.Submit()\n \t}\n \tswitch err {\n \tcase nil:\n@@ -168,27 +186,50 @@ func (s *ioSrv) ExecIO(oi anOpIface, deadline int64) (int, error) {\n \tdefault:\n \t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, err}\n \t}\n-\t// Wait for our request to complete.\n-\tvar r ioResult\n+\t// Setup timer, if deadline is given.\n+\tvar timer <-chan time.Time\n \tif deadline != 0 {\n \t\tdt := deadline - time.Now().UnixNano()\n \t\tif dt < 1 {\n \t\t\tdt = 1\n \t\t}\n-\t\ttimer := time.NewTimer(time.Duration(dt) * time.Nanosecond)\n-\t\tdefer timer.Stop()\n-\t\tselect {\n-\t\tcase r = <-o.resultc:\n-\t\tcase <-timer.C:\n+\t\tt := time.NewTimer(time.Duration(dt) * time.Nanosecond)\n+\t\tdefer t.Stop()\n+\t\ttimer = t.C\n+\t}\n+\t// Wait for our request to complete.\n+\tvar r ioResult\n+\tvar cancelled, timeout bool\n+\tselect {\n+\tcase r = <-o.resultc:\n+\tcase <-timer:\n+\t\tcancelled = true\n+\t\ttimeout = true\n+\tcase <-o.fd.closec:\n+\t\tcancelled = true\n+\t}\n+\tif cancelled {\n+\t\t// Cancel it.\n+\t\tif canCancelIO {\n+\t\t\terr := syscall.CancelIoEx(syscall.Handle(o.Op().fd.sysfd), &o.o)\n+\t\t\t// Assuming ERROR_NOT_FOUND is returned, if IO is completed.\n+\t\t\tif err != nil && err != syscall.ERROR_NOT_FOUND {\n+\t\t\t\t// TODO(brainman): maybe do something else, but panic.\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t} else {\n \t\t\ts.canchan <- oi\n \t\t\t<-o.errnoc\n-\t\t\tr = <-o.resultc\n-\t\t\tif r.err == syscall.ERROR_OPERATION_ABORTED { // IO Canceled\n-\t\t\t\tr.err = syscall.EWOULDBLOCK\n-\t\t\t}\n \t\t}\n-\t} else {\n+\t\t// Wait for IO to be canceled or complete successfully.\n \t\tr = <-o.resultc\n+\t\tif r.err == syscall.ERROR_OPERATION_ABORTED { // IO Canceled\n+\t\t\tif timeout {\n+\t\t\t\tr.err = errTimeout\n+\t\t\t} else {\n+\t\t\t\tr.err = errClosing\n+\t\t\t}\n+\t\t}\n \t}\n \tif r.err != nil {\n \t\terr = &OpError{oi.Name(), o.fd.net, o.fd.laddr, r.err}\n@@ -211,9 +252,13 @@ func startServer() {\n \tgo resultsrv.Run()\n \n \tiosrv = new(ioSrv)\n-\tiosrv.submchan = make(chan anOpIface)\n-\tiosrv.canchan = make(chan anOpIface)\n-\tgo iosrv.ProcessRemoteIO()\n+\tif !canCancelIO {\n+\t\t// Only CancelIo API is available. Lets start special goroutine\n+\t\t// locked to an OS thread, that both starts and cancels IO.\n+\t\tiosrv.submchan = make(chan anOpIface)\n+\t\tiosrv.canchan = make(chan anOpIface)\n+\t\tgo iosrv.ProcessRemoteIO()\n+\t}\n }\n \n // Network file descriptor.\n@@ -233,6 +278,7 @@ type netFD struct {\n \traddr       Addr\n \tresultc     [2]chan ioResult // read/write completion results\n \terrnoc      [2]chan error    // read/write submit or cancel operation errors\n+\tclosec      chan bool        // used by Close to cancel pending IO\n \n \t// owned by client\n \trdeadline int64\n@@ -247,6 +293,7 @@ func allocFD(fd syscall.Handle, family, sotype int, net string) *netFD {\n \t\tfamily: family,\n \t\tsotype: sotype,\n \t\tnet:    net,\n+\t\tclosec: make(chan bool),\n \t}\n \truntime.SetFinalizer(netfd, (*netFD).Close)\n \treturn netfd\n@@ -273,8 +320,6 @@ func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \treturn syscall.Connect(fd.sysfd, ra)\n }\n \n-var errClosing = errors.New(\"use of closed network connection\")\n-\n // Add a reference to this fd.\n // If closing==true, mark the fd as closing.\n // Returns an error if the fd cannot be used.\n@@ -299,24 +344,12 @@ func (fd *netFD) incref(closing bool) error {\n // Remove a reference to this FD and close if we've been asked to do so (and\n // there are no references left.\n func (fd *netFD) decref() {\n+\tif fd == nil {\n+\t\treturn\n+\t}\n \tfd.sysmu.Lock()\n \tfd.sysref--\n-\t// NOTE(rsc): On Unix we check fd.sysref == 0 here before closing,\n-\t// but on Windows we have no way to wake up the blocked I/O other\n-\t// than closing the socket (or calling Shutdown, which breaks other\n-\t// programs that might have a reference to the socket).  So there is\n-\t// a small race here that we might close fd.sysfd and then some other\n-\t// goroutine might start a read of fd.sysfd (having read it before we\n-\t// write InvalidHandle to it), which might refer to some other file\n-\t// if the specific handle value gets reused.  I think handle values on\n-\t// Windows are not reused as aggressively as file descriptors on Unix,\n-\t// so this might be tolerable.\n-\tif fd.closing && fd.sysfd != syscall.InvalidHandle {\n-\t\t// In case the user has set linger, switch to blocking mode so\n-\t\t// the close blocks.  As long as this doesn't happen often, we\n-\t\t// can handle the extra OS processes.  Otherwise we'll need to\n-\t\t// use the resultsrv for Close too.  Sigh.\n-\t\tsyscall.SetNonblock(fd.sysfd, false)\n+\tif fd.closing && fd.sysref == 0 && fd.sysfd != syscall.InvalidHandle {\n \t\tclosesocket(fd.sysfd)\n \t\tfd.sysfd = syscall.InvalidHandle\n \t\t// no need for a finalizer anymore\n@@ -329,14 +362,22 @@ func (fd *netFD) Close() error {\n \tif err := fd.incref(true); err != nil {\n \t\treturn err\n \t}\n-\tfd.decref()\n+\tdefer fd.decref()\n+\t// unblock pending reader and writer\n+\tclose(fd.closec)\n+\t// wait for both reader and writer to exit\n+\tfd.rio.Lock()\n+\tdefer fd.rio.Unlock()\n+\tfd.wio.Lock()\n+\tdefer fd.wio.Unlock()\n \treturn nil\n }\n \n func (fd *netFD) shutdown(how int) error {\n-\tif fd == nil || fd.sysfd == syscall.InvalidHandle {\n-\t\treturn syscall.EINVAL\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n \t}\n+\tdefer fd.decref()\n \terr := syscall.Shutdown(fd.sysfd, how)\n \tif err != nil {\n \t\treturn &OpError{\"shutdown\", fd.net, fd.laddr, err}\n@@ -368,18 +409,12 @@ func (o *readOp) Name() string {\n }\n \n func (fd *netFD) Read(buf []byte) (int, error) {\n-\tif fd == nil {\n-\t\treturn 0, syscall.EINVAL\n-\t}\n-\tfd.rio.Lock()\n-\tdefer fd.rio.Unlock()\n \tif err := fd.incref(false); err != nil {\n \t\treturn 0, err\n \t}\n \tdefer fd.decref()\n-\tif fd.sysfd == syscall.InvalidHandle {\n-\t\treturn 0, syscall.EINVAL\n-\t}\n+\tfd.rio.Lock()\n+\tdefer fd.rio.Unlock()\n \tvar o readOp\n \to.Init(fd, buf, 'r')\n \tn, err := iosrv.ExecIO(&o, fd.rdeadline)\n@@ -407,18 +442,15 @@ func (o *readFromOp) Name() string {\n }\n \n func (fd *netFD) ReadFrom(buf []byte) (n int, sa syscall.Sockaddr, err error) {\n-\tif fd == nil {\n-\t\treturn 0, nil, syscall.EINVAL\n-\t}\n \tif len(buf) == 0 {\n \t\treturn 0, nil, nil\n \t}\n-\tfd.rio.Lock()\n-\tdefer fd.rio.Unlock()\n \tif err := fd.incref(false); err != nil {\n \t\treturn 0, nil, err\n \t}\n \tdefer fd.decref()\n+\tfd.rio.Lock()\n+\tdefer fd.rio.Unlock()\n \tvar o readFromOp\n \to.Init(fd, buf, 'r')\n \to.rsan = int32(unsafe.Sizeof(o.rsa))\n@@ -446,15 +478,12 @@ func (o *writeOp) Name() string {\n }\n \n func (fd *netFD) Write(buf []byte) (int, error) {\n-\tif fd == nil {\n-\t\treturn 0, syscall.EINVAL\n-\t}\n-\tfd.wio.Lock()\n-\tdefer fd.wio.Unlock()\n \tif err := fd.incref(false); err != nil {\n \t\treturn 0, err\n \t}\n \tdefer fd.decref()\n+\tfd.wio.Lock()\n+\tdefer fd.wio.Unlock()\n \tvar o writeOp\n \to.Init(fd, buf, 'w')\n \treturn iosrv.ExecIO(&o, fd.wdeadline)\n@@ -477,21 +506,15 @@ func (o *writeToOp) Name() string {\n }\n \n func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error) {\n-\tif fd == nil {\n-\t\treturn 0, syscall.EINVAL\n-\t}\n \tif len(buf) == 0 {\n \t\treturn 0, nil\n \t}\n-\tfd.wio.Lock()\n-\tdefer fd.wio.Unlock()\n \tif err := fd.incref(false); err != nil {\n \t\treturn 0, err\n \t}\n \tdefer fd.decref()\n-\tif fd.sysfd == syscall.InvalidHandle {\n-\t\treturn 0, syscall.EINVAL\n-\t}\n+\tfd.wio.Lock()\n+\tdefer fd.wio.Unlock()\n \tvar o writeToOp\n \to.Init(fd, buf, 'w')\n \to.sa = sa\n@@ -544,7 +567,7 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n \tvar o acceptOp\n \to.Init(fd, 'r')\n \to.newsock = s\n-\t_, err = iosrv.ExecIO(&o, 0)\n+\t_, err = iosrv.ExecIO(&o, fd.rdeadline)\n \tif err != nil {\n \t\tclosesocket(s)\n \t\treturn nil, err"}, {"sha": "dcefe4e7af55c29d69f6e8157ddf8068c1419b3b", "filename": "libgo/go/net/http/cgi/testdata/test.cgi", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Ftestdata%2Ftest.cgi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Ftestdata%2Ftest.cgi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Ftestdata%2Ftest.cgi?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -8,6 +8,25 @@\n use strict;\n use Cwd;\n \n+binmode STDOUT;\n+\n+sub on_windows {\n+    return $^O eq 'MSWin32' || $^O eq 'msys';\n+}\n+\n+# normalize_windows_path normalizes the various Windows Perl path\n+# formats into Go's format.\n+sub normalize_windows_path {\n+    my $dir = shift;\n+    return $dir unless on_windows();\n+    $dir =~ s!^[a-z]:!uc($&)!e;\n+    if ($dir =~ s!^/([a-zA-Z])/!!) {\n+        $dir = uc($1) . \":\\\\$dir\";\n+    }\n+    $dir =~ s!/!\\\\!g;\n+    return $dir;\n+}\n+\n my $q = MiniCGI->new;\n my $params = $q->Vars;\n \n@@ -20,7 +39,7 @@ my $NL = \"\\r\\n\";\n $NL = \"\\n\" if $params->{mode} eq \"NL\";\n \n my $p = sub {\n-  print \"$_[0]$NL\";\n+    print \"$_[0]$NL\";\n };\n \n # With carriage returns\n@@ -39,29 +58,18 @@ if ($params->{\"bigresponse\"}) {\n print \"test=Hello CGI\\n\";\n \n foreach my $k (sort keys %$params) {\n-  print \"param-$k=$params->{$k}\\n\";\n+    print \"param-$k=$params->{$k}\\n\";\n }\n \n foreach my $k (sort keys %ENV) {\n-  my $clean_env = $ENV{$k};\n-  $clean_env =~ s/[\\n\\r]//g;\n-  print \"env-$k=$clean_env\\n\";\n+    my $clean_env = $ENV{$k};\n+    $clean_env =~ s/[\\n\\r]//g;\n+    print \"env-$k=$clean_env\\n\";\n }\n \n-# NOTE: don't call getcwd() for windows.\n-# msys return /c/go/src/... not C:\\go\\...\n-my $dir;\n-if ($^O eq 'MSWin32' || $^O eq 'msys') {\n-  my $cmd = $ENV{'COMSPEC'} || 'c:\\\\windows\\\\system32\\\\cmd.exe';\n-  $cmd =~ s!\\\\!/!g;\n-  $dir = `$cmd /c cd`;\n-  chomp $dir;\n-} else {\n-  $dir = getcwd();\n-}\n+my $dir = normalize_windows_path(getcwd());\n print \"cwd=$dir\\n\";\n \n-\n # A minimal version of CGI.pm, for people without the perl-modules\n # package installed.  (CGI.pm used to be part of the Perl core, but\n # some distros now bundle perl-base and perl-modules separately...)\n@@ -94,3 +102,24 @@ sub _urldecode {\n     $v =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack(\"C\", hex($1))/eg;\n     return $v;\n }\n+\n+package Tests;\n+\n+sub test_normalize_windows_paths {\n+    my @tests = (\n+        {in => \"C:\\\\foo\\\\bar\", want => \"C:\\\\foo\\\\bar\"},\n+        {in => \"C:/foo/bar\", want => \"C:\\\\foo\\\\bar\"},\n+        {in => \"c:/foo/bar\", want => \"C:\\\\foo\\\\bar\"},\n+        {in => \"/c/foo/bar\", want => \"C:\\\\foo\\\\bar\"},\n+    );\n+    foreach my $tt (@tests) {\n+        my $got = ::normalize_windows_path($tt->{in});\n+        unless ($got eq $tt->{want}) {\n+            die \"For path $tt->{in}, normalize = $got; want $tt->{want}\\n\";\n+        }\n+    }\n+}\n+\n+BEGIN {\n+    test_normalize_windows_paths() if ::on_windows();\n+}"}, {"sha": "7cf39cfa5fcee812534f5ca96c898ee9066e6707", "filename": "libgo/go/net/http/chunked.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n \t\"strconv\"\n )\n@@ -22,7 +23,7 @@ const maxLineLength = 4096 // assumed <= bufio.defaultBufSize\n var ErrLineTooLong = errors.New(\"header line too long\")\n \n // newChunkedReader returns a new chunkedReader that translates the data read from r\n-// out of HTTP \"chunked\" format before returning it. \n+// out of HTTP \"chunked\" format before returning it.\n // The chunkedReader returns io.EOF when the final 0-length chunk is read.\n //\n // newChunkedReader is not needed by normal applications. The http package\n@@ -39,6 +40,7 @@ type chunkedReader struct {\n \tr   *bufio.Reader\n \tn   uint64 // unread bytes in chunk\n \terr error\n+\tbuf [2]byte\n }\n \n func (cr *chunkedReader) beginChunk() {\n@@ -74,9 +76,8 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n \tcr.n -= uint64(n)\n \tif cr.n == 0 && cr.err == nil {\n \t\t// end of chunk (CRLF)\n-\t\tb := make([]byte, 2)\n-\t\tif _, cr.err = io.ReadFull(cr.r, b); cr.err == nil {\n-\t\t\tif b[0] != '\\r' || b[1] != '\\n' {\n+\t\tif _, cr.err = io.ReadFull(cr.r, cr.buf[:]); cr.err == nil {\n+\t\t\tif cr.buf[0] != '\\r' || cr.buf[1] != '\\n' {\n \t\t\t\tcr.err = errors.New(\"malformed chunked encoding\")\n \t\t\t}\n \t\t}\n@@ -147,9 +148,7 @@ func (cw *chunkedWriter) Write(data []byte) (n int, err error) {\n \t\treturn 0, nil\n \t}\n \n-\thead := strconv.FormatInt(int64(len(data)), 16) + \"\\r\\n\"\n-\n-\tif _, err = io.WriteString(cw.Wire, head); err != nil {\n+\tif _, err = fmt.Fprintf(cw.Wire, \"%x\\r\\n\", len(data)); err != nil {\n \t\treturn 0, err\n \t}\n \tif n, err = cw.Wire.Write(data); err != nil {"}, {"sha": "2f957d23dbe7b27e94d5da191dbd67afcdc69767", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // HTTP client. See RFC 2616.\n-// \n+//\n // This is the high-level Client interface.\n // The low-level implementation is in transport.go.\n \n@@ -44,8 +44,8 @@ type Client struct {\n \t// which is to stop after 10 consecutive requests.\n \tCheckRedirect func(req *Request, via []*Request) error\n \n-\t// Jar specifies the cookie jar. \n-\t// If Jar is nil, cookies are not sent in requests and ignored \n+\t// Jar specifies the cookie jar.\n+\t// If Jar is nil, cookies are not sent in requests and ignored\n \t// in responses.\n \tJar CookieJar\n }\n@@ -87,6 +87,22 @@ type readClose struct {\n \tio.Closer\n }\n \n+func (c *Client) send(req *Request) (*Response, error) {\n+\tif c.Jar != nil {\n+\t\tfor _, cookie := range c.Jar.Cookies(req.URL) {\n+\t\t\treq.AddCookie(cookie)\n+\t\t}\n+\t}\n+\tresp, err := send(req, c.Transport)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif c.Jar != nil {\n+\t\tc.Jar.SetCookies(req.URL, resp.Cookies())\n+\t}\n+\treturn resp, err\n+}\n+\n // Do sends an HTTP request and returns an HTTP response, following\n // policy (e.g. redirects, cookies, auth) as configured on the client.\n //\n@@ -106,7 +122,7 @@ func (c *Client) Do(req *Request) (resp *Response, err error) {\n \tif req.Method == \"GET\" || req.Method == \"HEAD\" {\n \t\treturn c.doFollowingRedirects(req)\n \t}\n-\treturn send(req, c.Transport)\n+\treturn c.send(req)\n }\n \n // send issues an HTTP request.\n@@ -215,11 +231,6 @@ func (c *Client) doFollowingRedirects(ireq *Request) (resp *Response, err error)\n \t\treturn nil, errors.New(\"http: nil Request.URL\")\n \t}\n \n-\tjar := c.Jar\n-\tif jar == nil {\n-\t\tjar = blackHoleJar{}\n-\t}\n-\n \treq := ireq\n \turlStr := \"\" // next relative or absolute URL to fetch (after first request)\n \tredirectFailed := false\n@@ -247,16 +258,10 @@ func (c *Client) doFollowingRedirects(ireq *Request) (resp *Response, err error)\n \t\t\t}\n \t\t}\n \n-\t\tfor _, cookie := range jar.Cookies(req.URL) {\n-\t\t\treq.AddCookie(cookie)\n-\t\t}\n \t\turlStr = req.URL.String()\n-\t\tif resp, err = send(req, c.Transport); err != nil {\n+\t\tif resp, err = c.send(req); err != nil {\n \t\t\tbreak\n \t\t}\n-\t\tif c := resp.Cookies(); len(c) > 0 {\n-\t\t\tjar.SetCookies(req.URL, c)\n-\t\t}\n \n \t\tif shouldRedirect(resp.StatusCode) {\n \t\t\tresp.Body.Close()\n@@ -316,16 +321,7 @@ func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Respon\n \t\treturn nil, err\n \t}\n \treq.Header.Set(\"Content-Type\", bodyType)\n-\tif c.Jar != nil {\n-\t\tfor _, cookie := range c.Jar.Cookies(req.URL) {\n-\t\t\treq.AddCookie(cookie)\n-\t\t}\n-\t}\n-\tresp, err = send(req, c.Transport)\n-\tif err == nil && c.Jar != nil {\n-\t\tc.Jar.SetCookies(req.URL, resp.Cookies())\n-\t}\n-\treturn\n+\treturn c.send(req)\n }\n \n // PostForm issues a POST to the specified URL, with data's keys and\n@@ -339,7 +335,7 @@ func PostForm(url string, data url.Values) (resp *Response, err error) {\n \treturn DefaultClient.PostForm(url, data)\n }\n \n-// PostForm issues a POST to the specified URL, \n+// PostForm issues a POST to the specified URL,\n // with data's keys and values urlencoded as the request body.\n //\n // When err is nil, resp always contains a non-nil resp.Body."}, {"sha": "9a45b147ef1894f1f5405395ddab6e23cf241838", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -219,6 +219,9 @@ func TestRedirects(t *testing.T) {\n \t\treturn checkErr\n \t}}\n \tres, err := c.Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get error: %v\", err)\n+\t}\n \tfinalUrl := res.Request.URL.String()\n \tif e, g := \"<nil>\", fmt.Sprintf(\"%v\", err); e != g {\n \t\tt.Errorf(\"with custom client, expected error %q, got %q\", e, g)\n@@ -285,6 +288,10 @@ func TestClientSendsCookieFromJar(t *testing.T) {\n \treq, _ := NewRequest(\"GET\", us, nil)\n \tclient.Do(req) // Note: doesn't hit network\n \tmatchReturnedCookies(t, expectedCookies, tr.req.Cookies())\n+\n+\treq, _ = NewRequest(\"POST\", us, nil)\n+\tclient.Do(req) // Note: doesn't hit network\n+\tmatchReturnedCookies(t, expectedCookies, tr.req.Cookies())\n }\n \n // Just enough correctness for our redirect tests. Uses the URL.Host as the\n@@ -331,7 +338,10 @@ func TestRedirectCookiesJar(t *testing.T) {\n \tc.Jar = &TestJar{perURL: make(map[string][]*Cookie)}\n \tu, _ := url.Parse(ts.URL)\n \tc.Jar.SetCookies(u, []*Cookie{expectedCookies[0]})\n-\tresp, _ := c.Get(ts.URL)\n+\tresp, err := c.Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get: %v\", err)\n+\t}\n \tmatchReturnedCookies(t, expectedCookies, resp.Cookies())\n }\n "}, {"sha": "155b09223e4cd32786fef2f68328232422a98a92", "filename": "libgo/go/net/http/cookie.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -26,7 +26,7 @@ type Cookie struct {\n \tExpires    time.Time\n \tRawExpires string\n \n-\t// MaxAge=0 means no 'Max-Age' attribute specified. \n+\t// MaxAge=0 means no 'Max-Age' attribute specified.\n \t// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'\n \t// MaxAge>0 means Max-Age attribute present and given in seconds\n \tMaxAge   int"}, {"sha": "f84f73936c75370c1c8989e86d6bfb716eddf0c7", "filename": "libgo/go/net/http/cookie_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -217,7 +217,7 @@ var readCookiesTests = []struct {\n \n func TestReadCookies(t *testing.T) {\n \tfor i, tt := range readCookiesTests {\n-\t\tfor n := 0; n < 2; n++ { // to verify readCookies doesn't mutate its input                                                  \n+\t\tfor n := 0; n < 2; n++ { // to verify readCookies doesn't mutate its input\n \t\t\tc := readCookies(tt.Header, tt.Filter)\n \t\t\tif !reflect.DeepEqual(c, tt.Cookies) {\n \t\t\t\tt.Errorf(\"#%d readCookies:\\nhave: %s\\nwant: %s\\n\", i, toJSON(c), toJSON(tt.Cookies))"}, {"sha": "59e30a19fcaaa7c207500efb2b8297ff5aa757fc", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -648,6 +648,8 @@ func TestServeContent(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n+\t\tio.Copy(ioutil.Discard, res.Body)\n+\t\tres.Body.Close()\n \t\tif res.StatusCode != tt.wantStatus {\n \t\t\tt.Errorf(\"test %q: status = %d; want %d\", testName, res.StatusCode, tt.wantStatus)\n \t\t}"}, {"sha": "26daee5f2c74f80ebb822c24072fe3917cb24396", "filename": "libgo/go/net/http/httputil/chunked.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n \t\"strconv\"\n )\n@@ -24,7 +25,7 @@ const maxLineLength = 4096 // assumed <= bufio.defaultBufSize\n var ErrLineTooLong = errors.New(\"header line too long\")\n \n // NewChunkedReader returns a new chunkedReader that translates the data read from r\n-// out of HTTP \"chunked\" format before returning it. \n+// out of HTTP \"chunked\" format before returning it.\n // The chunkedReader returns io.EOF when the final 0-length chunk is read.\n //\n // NewChunkedReader is not needed by normal applications. The http package\n@@ -41,6 +42,7 @@ type chunkedReader struct {\n \tr   *bufio.Reader\n \tn   uint64 // unread bytes in chunk\n \terr error\n+\tbuf [2]byte\n }\n \n func (cr *chunkedReader) beginChunk() {\n@@ -76,9 +78,8 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n \tcr.n -= uint64(n)\n \tif cr.n == 0 && cr.err == nil {\n \t\t// end of chunk (CRLF)\n-\t\tb := make([]byte, 2)\n-\t\tif _, cr.err = io.ReadFull(cr.r, b); cr.err == nil {\n-\t\t\tif b[0] != '\\r' || b[1] != '\\n' {\n+\t\tif _, cr.err = io.ReadFull(cr.r, cr.buf[:]); cr.err == nil {\n+\t\t\tif cr.buf[0] != '\\r' || cr.buf[1] != '\\n' {\n \t\t\t\tcr.err = errors.New(\"malformed chunked encoding\")\n \t\t\t}\n \t\t}\n@@ -149,9 +150,7 @@ func (cw *chunkedWriter) Write(data []byte) (n int, err error) {\n \t\treturn 0, nil\n \t}\n \n-\thead := strconv.FormatInt(int64(len(data)), 16) + \"\\r\\n\"\n-\n-\tif _, err = io.WriteString(cw.Wire, head); err != nil {\n+\tif _, err = fmt.Fprintf(cw.Wire, \"%x\\r\\n\", len(data)); err != nil {\n \t\treturn 0, err\n \t}\n \tif n, err = cw.Wire.Write(data); err != nil {"}, {"sha": "35eee682f9f70ccdd3f3b6098b9047fec1b14e99", "filename": "libgo/go/net/http/jar.go", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fjar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fjar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fjar.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -8,23 +8,18 @@ import (\n \t\"net/url\"\n )\n \n-// A CookieJar manages storage and use of cookies in HTTP requests. \n+// A CookieJar manages storage and use of cookies in HTTP requests.\n //\n // Implementations of CookieJar must be safe for concurrent use by multiple\n // goroutines.\n type CookieJar interface {\n-\t// SetCookies handles the receipt of the cookies in a reply for the \n-\t// given URL.  It may or may not choose to save the cookies, depending \n-\t// on the jar's policy and implementation. \n+\t// SetCookies handles the receipt of the cookies in a reply for the\n+\t// given URL.  It may or may not choose to save the cookies, depending\n+\t// on the jar's policy and implementation.\n \tSetCookies(u *url.URL, cookies []*Cookie)\n \n \t// Cookies returns the cookies to send in a request for the given URL.\n-\t// It is up to the implementation to honor the standard cookie use \n-\t// restrictions such as in RFC 6265. \n+\t// It is up to the implementation to honor the standard cookie use\n+\t// restrictions such as in RFC 6265.\n \tCookies(u *url.URL) []*Cookie\n }\n-\n-type blackHoleJar struct{}\n-\n-func (blackHoleJar) SetCookies(u *url.URL, cookies []*Cookie) {}\n-func (blackHoleJar) Cookies(u *url.URL) []*Cookie             { return nil }"}, {"sha": "86db976b838f583c1d2c56b399a43f11cd190519", "filename": "libgo/go/net/http/proxy_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -25,7 +25,7 @@ var UseProxyTests = []struct {\n \t{\"[::2]\", true}, // not a loopback address\n \n \t{\"barbaz.net\", false},     // match as .barbaz.net\n-\t{\"foobar.com\", false},     // have a port but match \n+\t{\"foobar.com\", false},     // have a port but match\n \t{\"foofoobar.com\", true},   // not match as a part of foobar.com\n \t{\"baz.com\", true},         // not match as a part of barbaz.com\n \t{\"localhost.net\", true},   // not match as suffix of address"}, {"sha": "c0b738c6e6569828f666496b0cff5e2db4baec3b", "filename": "libgo/go/net/http/request_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -161,7 +161,7 @@ func TestSetBasicAuth(t *testing.T) {\n }\n \n func TestMultipartRequest(t *testing.T) {\n-\t// Test that we can read the values and files of a \n+\t// Test that we can read the values and files of a\n \t// multipart request with FormValue and FormFile,\n \t// and that ParseMultipartForm can be called multiple times.\n \treq := newTestMultipartRequest(t)"}, {"sha": "355efb2cac9f3b5d9beb59eb3f30718b127c1ec2", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -314,7 +314,7 @@ func TestServerTimeouts(t *testing.T) {\n \tl.Close()\n }\n \n-// TestIdentityResponse verifies that a handler can unset \n+// TestIdentityResponse verifies that a handler can unset\n func TestIdentityResponse(t *testing.T) {\n \thandler := HandlerFunc(func(rw ResponseWriter, req *Request) {\n \t\trw.Header().Set(\"Content-Length\", \"3\")\n@@ -1063,7 +1063,7 @@ type countReader struct {\n \n func (cr countReader) Read(p []byte) (n int, err error) {\n \tn, err = cr.r.Read(p)\n-\t*cr.n += int64(n)\n+\tatomic.AddInt64(cr.n, int64(n))\n \treturn\n }\n \n@@ -1081,8 +1081,8 @@ func TestRequestBodyLimit(t *testing.T) {\n \t}))\n \tdefer ts.Close()\n \n-\tnWritten := int64(0)\n-\treq, _ := NewRequest(\"POST\", ts.URL, io.LimitReader(countReader{neverEnding('a'), &nWritten}, limit*200))\n+\tnWritten := new(int64)\n+\treq, _ := NewRequest(\"POST\", ts.URL, io.LimitReader(countReader{neverEnding('a'), nWritten}, limit*200))\n \n \t// Send the POST, but don't care it succeeds or not.  The\n \t// remote side is going to reply and then close the TCP\n@@ -1095,7 +1095,7 @@ func TestRequestBodyLimit(t *testing.T) {\n \t// the remote side hung up on us before we wrote too much.\n \t_, _ = DefaultClient.Do(req)\n \n-\tif nWritten > limit*100 {\n+\tif atomic.LoadInt64(nWritten) > limit*100 {\n \t\tt.Errorf(\"handler restricted the request body to %d bytes, but client managed to write %d\",\n \t\t\tlimit, nWritten)\n \t}"}, {"sha": "719cecfbdaade59addf7d8015dbead7ac66eca39", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -579,13 +579,27 @@ func (c *conn) close() {\n \t}\n }\n \n-// closeWrite flushes any outstanding data and sends a FIN packet (if client\n-// is connected via TCP), signalling that we're done.\n-func (c *conn) closeWrite() {\n+// rstAvoidanceDelay is the amount of time we sleep after closing the\n+// write side of a TCP connection before closing the entire socket.\n+// By sleeping, we increase the chances that the client sees our FIN\n+// and processes its final data before they process the subsequent RST\n+// from closing a connection with known unread data.\n+// This RST seems to occur mostly on BSD systems. (And Windows?)\n+// This timeout is somewhat arbitrary (~latency around the planet).\n+const rstAvoidanceDelay = 500 * time.Millisecond\n+\n+// closeWrite flushes any outstanding data and sends a FIN packet (if\n+// client is connected via TCP), signalling that we're done.  We then\n+// pause for a bit, hoping the client processes it before `any\n+// subsequent RST.\n+//\n+// See http://golang.org/issue/3595\n+func (c *conn) closeWriteAndWait() {\n \tc.finalFlush()\n \tif tcp, ok := c.rwc.(*net.TCPConn); ok {\n \t\ttcp.CloseWrite()\n \t}\n+\ttime.Sleep(rstAvoidanceDelay)\n }\n \n // Serve a new connection.\n@@ -618,20 +632,21 @@ func (c *conn) serve() {\n \tfor {\n \t\tw, err := c.readRequest()\n \t\tif err != nil {\n-\t\t\tmsg := \"400 Bad Request\"\n \t\t\tif err == errTooLarge {\n \t\t\t\t// Their HTTP client may or may not be\n \t\t\t\t// able to read this if we're\n \t\t\t\t// responding to them and hanging up\n \t\t\t\t// while they're still writing their\n \t\t\t\t// request.  Undefined behavior.\n-\t\t\t\tmsg = \"413 Request Entity Too Large\"\n+\t\t\t\tio.WriteString(c.rwc, \"HTTP/1.1 413 Request Entity Too Large\\r\\n\\r\\n\")\n+\t\t\t\tc.closeWriteAndWait()\n+\t\t\t\tbreak\n \t\t\t} else if err == io.EOF {\n \t\t\t\tbreak // Don't reply\n \t\t\t} else if neterr, ok := err.(net.Error); ok && neterr.Timeout() {\n \t\t\t\tbreak // Don't reply\n \t\t\t}\n-\t\t\tfmt.Fprintf(c.rwc, \"HTTP/1.1 %s\\r\\n\\r\\n\", msg)\n+\t\t\tio.WriteString(c.rwc, \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")\n \t\t\tbreak\n \t\t}\n \n@@ -685,18 +700,7 @@ func (c *conn) serve() {\n \t\tw.finishRequest()\n \t\tif w.closeAfterReply {\n \t\t\tif w.requestBodyLimitHit {\n-\t\t\t\t// Flush our response and send a FIN packet and wait a bit\n-\t\t\t\t// before closing the connection, so the client has a chance\n-\t\t\t\t// to read our response before they possibly get a RST from\n-\t\t\t\t// our TCP stack from ignoring their unread body.\n-\t\t\t\t// See http://golang.org/issue/3595\n-\t\t\t\tc.closeWrite()\n-\t\t\t\t// Now wait a bit for our machine to send the FIN and the client's\n-\t\t\t\t// machine's HTTP client to read the request before we close\n-\t\t\t\t// the connection, which might send a RST (on BSDs, at least).\n-\t\t\t\t// 250ms is somewhat arbitrary (~latency around half the planet),\n-\t\t\t\t// but this doesn't need to be a full second probably.\n-\t\t\t\ttime.Sleep(250 * time.Millisecond)\n+\t\t\t\tc.closeWriteAndWait()\n \t\t\t}\n \t\t\tbreak\n \t\t}"}, {"sha": "9833dddf2b65b4dce25267112955e92c053011ef", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -567,14 +567,22 @@ func seeUpcomingDoubleCRLF(r *bufio.Reader) bool {\n \treturn false\n }\n \n+var errTrailerEOF = errors.New(\"http: unexpected EOF reading trailer\")\n+\n func (b *body) readTrailer() error {\n \t// The common case, since nobody uses trailers.\n-\tbuf, _ := b.r.Peek(2)\n+\tbuf, err := b.r.Peek(2)\n \tif bytes.Equal(buf, singleCRLF) {\n \t\tb.r.ReadByte()\n \t\tb.r.ReadByte()\n \t\treturn nil\n \t}\n+\tif len(buf) < 2 {\n+\t\treturn errTrailerEOF\n+\t}\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n \t// Make sure there's a header terminator coming up, to prevent\n \t// a DoS with an unbounded size Trailer.  It's not easy to\n@@ -590,6 +598,9 @@ func (b *body) readTrailer() error {\n \n \thdr, err := textproto.NewReader(b.r).ReadMIMEHeader()\n \tif err != nil {\n+\t\tif err == io.EOF {\n+\t\t\treturn errTrailerEOF\n+\t\t}\n \t\treturn err\n \t}\n \tswitch rr := b.hdr.(type) {"}, {"sha": "8627a374c8f6ba1cc73bc30c022e888d021139d8", "filename": "libgo/go/net/http/transfer_test.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"bufio\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestBodyReadBadTrailer(t *testing.T) {\n+\tb := &body{\n+\t\tReader: strings.NewReader(\"foobar\"),\n+\t\thdr:    true, // force reading the trailer\n+\t\tr:      bufio.NewReader(strings.NewReader(\"\")),\n+\t}\n+\tbuf := make([]byte, 7)\n+\tn, err := b.Read(buf[:3])\n+\tgot := string(buf[:n])\n+\tif got != \"foo\" || err != nil {\n+\t\tt.Fatalf(`first Read = %d (%q), %v; want 3 (\"foo\")`, n, got, err)\n+\t}\n+\n+\tn, err = b.Read(buf[:])\n+\tgot = string(buf[:n])\n+\tif got != \"bar\" || err != nil {\n+\t\tt.Fatalf(`second Read = %d (%q), %v; want 3 (\"bar\")`, n, got, err)\n+\t}\n+\n+\tn, err = b.Read(buf[:])\n+\tgot = string(buf[:n])\n+\tif err == nil {\n+\t\tt.Errorf(\"final Read was successful (%q), expected error from trailer read\", got)\n+\t}\n+}"}, {"sha": "38ea6f7ba8288f6769aa02a8e829976c6d28c202", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // HTTP client implementation. See RFC 2616.\n-// \n+//\n // This is the low-level Transport implementation of RoundTripper.\n // The high-level interface is in client.go.\n \n@@ -24,6 +24,7 @@ import (\n \t\"os\"\n \t\"strings\"\n \t\"sync\"\n+\t\"sync/atomic\"\n \t\"time\"\n )\n \n@@ -604,6 +605,9 @@ func (pc *persistConn) readLoop() {\n \t\t\talive = false\n \t\t}\n \n+\t\t// TODO(bradfitz): this hasBody conflicts with the defition\n+\t\t// above which excludes HEAD requests.  Is this one\n+\t\t// incomplete?\n \t\thasBody := resp != nil && resp.ContentLength != 0\n \t\tvar waitForBodyRead chan bool\n \t\tif hasBody {\n@@ -706,7 +710,7 @@ func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err err\n \t// requested it.\n \trequestedGzip := false\n \tif !pc.t.DisableCompression && req.Header.Get(\"Accept-Encoding\") == \"\" {\n-\t\t// Request gzip only, not deflate. Deflate is ambiguous and \n+\t\t// Request gzip only, not deflate. Deflate is ambiguous and\n \t\t// not as universally supported anyway.\n \t\t// See: http://www.gzip.org/zlib/zlib_faq.html#faq38\n \t\trequestedGzip = true\n@@ -805,24 +809,19 @@ func canonicalAddr(url *url.URL) string {\n \treturn addr\n }\n \n-func responseIsKeepAlive(res *Response) bool {\n-\t// TODO: implement.  for now just always shutting down the connection.\n-\treturn false\n-}\n-\n // bodyEOFSignal wraps a ReadCloser but runs fn (if non-nil) at most\n // once, right before the final Read() or Close() call returns, but after\n // EOF has been seen.\n type bodyEOFSignal struct {\n \tbody     io.ReadCloser\n \tfn       func()\n-\tisClosed bool\n+\tisClosed uint32 // atomic bool, non-zero if true\n \tonce     sync.Once\n }\n \n func (es *bodyEOFSignal) Read(p []byte) (n int, err error) {\n \tn, err = es.body.Read(p)\n-\tif es.isClosed && n > 0 {\n+\tif es.closed() && n > 0 {\n \t\tpanic(\"http: unexpected bodyEOFSignal Read after Close; see issue 1725\")\n \t}\n \tif err == io.EOF {\n@@ -832,10 +831,10 @@ func (es *bodyEOFSignal) Read(p []byte) (n int, err error) {\n }\n \n func (es *bodyEOFSignal) Close() (err error) {\n-\tif es.isClosed {\n+\tif !es.setClosed() {\n+\t\t// already closed\n \t\treturn nil\n \t}\n-\tes.isClosed = true\n \terr = es.body.Close()\n \tif err == nil {\n \t\tes.condfn()\n@@ -849,6 +848,14 @@ func (es *bodyEOFSignal) condfn() {\n \t}\n }\n \n+func (es *bodyEOFSignal) closed() bool {\n+\treturn atomic.LoadUint32(&es.isClosed) != 0\n+}\n+\n+func (es *bodyEOFSignal) setClosed() bool {\n+\treturn atomic.CompareAndSwapUint32(&es.isClosed, 0, 1)\n+}\n+\n type readFirstCloseBoth struct {\n \tio.ReadCloser\n \tio.Closer"}, {"sha": "43b02aef2ea1f040a9292b769857222ce4d4e955", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -21,7 +21,7 @@ var icmpTests = []struct {\n \tipv6  bool // test with underlying AF_INET6 socket\n }{\n \t{\"ip4:icmp\", \"\", \"127.0.0.1\", false},\n-\t{\"ip6:icmp\", \"\", \"::1\", true},\n+\t{\"ip6:ipv6-icmp\", \"\", \"::1\", true},\n }\n \n func TestICMP(t *testing.T) {\n@@ -206,3 +206,33 @@ func parseICMPEchoReply(b []byte) (id, seqnum int) {\n \tseqnum = int(b[6])<<8 | int(b[7])\n \treturn\n }\n+\n+var ipConnLocalNameTests = []struct {\n+\tnet   string\n+\tladdr *IPAddr\n+}{\n+\t{\"ip4:icmp\", &IPAddr{IP: IPv4(127, 0, 0, 1)}},\n+\t{\"ip4:icmp\", &IPAddr{}},\n+\t{\"ip4:icmp\", nil},\n+}\n+\n+func TestIPConnLocalName(t *testing.T) {\n+\tif os.Getuid() != 0 {\n+\t\tt.Logf(\"skipping test; must be root\")\n+\t\treturn\n+\t}\n+\n+\tfor _, tt := range ipConnLocalNameTests {\n+\t\tc, err := ListenIP(tt.net, tt.laddr)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"ListenIP failed: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer c.Close()\n+\t\tla := c.LocalAddr()\n+\t\tif la == nil {\n+\t\t\tt.Error(\"IPConn.LocalAddr failed\")\n+\t\t\treturn\n+\t\t}\n+\t}\n+}"}, {"sha": "d7bffc69e95d37b3944a45302778fc2b41a5fd9c", "filename": "libgo/go/net/iprawsock.go", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fiprawsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fiprawsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -6,6 +6,10 @@\n \n package net\n \n+import (\n+\t\"time\"\n+)\n+\n // IPAddr represents the address of an IP end point.\n type IPAddr struct {\n \tIP IP\n@@ -26,15 +30,19 @@ func (a *IPAddr) String() string {\n // \"ip\", \"ip4\" or \"ip6\".  A literal IPv6 host address must be\n // enclosed in square brackets, as in \"[::]\".\n func ResolveIPAddr(net, addr string) (*IPAddr, error) {\n-\tip, err := hostToIP(net, addr)\n+\treturn resolveIPAddr(net, addr, noDeadline)\n+}\n+\n+func resolveIPAddr(net, addr string, deadline time.Time) (*IPAddr, error) {\n+\tip, err := hostToIP(net, addr, deadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn &IPAddr{ip}, nil\n }\n \n // Convert \"host\" into IP address.\n-func hostToIP(net, host string) (ip IP, err error) {\n+func hostToIP(net, host string, deadline time.Time) (ip IP, err error) {\n \tvar addr IP\n \t// Try as an IP address.\n \taddr = ParseIP(host)\n@@ -47,7 +55,7 @@ func hostToIP(net, host string) (ip IP, err error) {\n \t\t\tfilter = ipv6only\n \t\t}\n \t\t// Not an IP address.  Try as a DNS name.\n-\t\taddrs, err1 := LookupHost(host)\n+\t\taddrs, err1 := lookupHostDeadline(host, deadline)\n \t\tif err1 != nil {\n \t\t\terr = err1\n \t\t\tgoto Error"}, {"sha": "e77c5476afad6a506c7fb65ed0733a9599f9c096", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -130,6 +130,10 @@ func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error\n // netProto, which must be \"ip\", \"ip4\", or \"ip6\" followed by a colon\n // and a protocol number or name.\n func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error) {\n+\treturn dialIP(netProto, laddr, raddr, noDeadline)\n+}\n+\n+func dialIP(netProto string, laddr, raddr *IPAddr, deadline time.Time) (*IPConn, error) {\n \treturn nil, syscall.EPLAN9\n }\n "}, {"sha": "00e87cfbf0dda38c65d9d314f56f924a0c5eaf58", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -10,6 +10,7 @@ package net\n \n import (\n \t\"syscall\"\n+\t\"time\"\n )\n \n func sockaddrToIP(sa syscall.Sockaddr) Addr {\n@@ -163,19 +164,23 @@ func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error\n // DialIP connects to the remote address raddr on the network protocol netProto,\n // which must be \"ip\", \"ip4\", or \"ip6\" followed by a colon and a protocol number or name.\n func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error) {\n+\treturn dialIP(netProto, laddr, raddr, noDeadline)\n+}\n+\n+func dialIP(netProto string, laddr, raddr *IPAddr, deadline time.Time) (*IPConn, error) {\n \tnet, proto, err := parseDialNetwork(netProto)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tswitch net {\n \tcase \"ip\", \"ip4\", \"ip6\":\n \tdefault:\n-\t\treturn nil, UnknownNetworkError(net)\n+\t\treturn nil, UnknownNetworkError(netProto)\n \t}\n \tif raddr == nil {\n \t\treturn nil, &OpError{\"dial\", netProto, nil, errMissingAddress}\n \t}\n-\tfd, err := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_RAW, proto, \"dial\", sockaddrToIP)\n+\tfd, err := internetSocket(net, laddr.toAddr(), raddr.toAddr(), deadline, syscall.SOCK_RAW, proto, \"dial\", sockaddrToIP)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -194,9 +199,9 @@ func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) {\n \tswitch net {\n \tcase \"ip\", \"ip4\", \"ip6\":\n \tdefault:\n-\t\treturn nil, UnknownNetworkError(net)\n+\t\treturn nil, UnknownNetworkError(netProto)\n \t}\n-\tfd, err := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_RAW, proto, \"listen\", sockaddrToIP)\n+\tfd, err := internetSocket(net, laddr.toAddr(), nil, noDeadline, syscall.SOCK_RAW, proto, \"listen\", sockaddrToIP)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "9d48e8c1036347d94e7a1d34d796f9d44efbcf47", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "patch": "@@ -6,7 +6,14 @@\n \n package net\n \n-var supportsIPv6, supportsIPv4map = probeIPv6Stack()\n+import \"time\"\n+\n+var supportsIPv6, supportsIPv4map bool\n+\n+func init() {\n+\tsysInit()\n+\tsupportsIPv6, supportsIPv4map = probeIPv6Stack()\n+}\n \n func firstFavoriteAddr(filter func(IP) IP, addrs []string) (addr IP) {\n \tif filter == nil {\n@@ -98,7 +105,7 @@ func JoinHostPort(host, port string) string {\n }\n \n // Convert \"host:port\" into IP address and port.\n-func hostPortToIP(net, hostport string) (ip IP, iport int, err error) {\n+func hostPortToIP(net, hostport string, deadline time.Time) (ip IP, iport int, err error) {\n \thost, port, err := SplitHostPort(hostport)\n \tif err != nil {\n \t\treturn nil, 0, err\n@@ -117,7 +124,7 @@ func hostPortToIP(net, hostport string) (ip IP, iport int, err error) {\n \t\t\t\tfilter = ipv6only\n \t\t\t}\n \t\t\t// Not an IP address.  Try as a DNS name.\n-\t\t\taddrs, err := LookupHost(host)\n+\t\t\taddrs, err := lookupHostDeadline(host, deadline)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, 0, err\n \t\t\t}"}, {"sha": "138c3b4855b7f4a6d864a5f20160302a6ee6b26e", "filename": "libgo/go/net/ipsock_plan9.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "87a2288973b9c1a9cefc67d275a5f1c075b33a07", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "bec93ec08cd0415219ddcf8d8477ee5acf515b88", "filename": "libgo/go/net/lookup.go", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "ae7cf794216b5516ecf1475da5f6dca24388c42a", "filename": "libgo/go/net/lookup_plan9.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "990ade9e2104243901c6204ecddd7e6c2bc8406b", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "fa98eed5f2675c7c42f1adccd868074f232a1448", "filename": "libgo/go/net/lookup_unix.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_unix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "390fe7f4405e6ea0fb7ce1a6273e9e7338fcf688", "filename": "libgo/go/net/lookup_windows.go", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Flookup_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_windows.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "d4a8a35627dd937977dacd1d8f9f96f55cffa6d8", "filename": "libgo/go/net/multicast_posix_test.go", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_posix_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "feb92a2737d5623fc57c3997d044d1b79bd78eb8", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "3bcc54fe53a81bb775ba2aa928a7db29b2f5b488", "filename": "libgo/go/net/net_posix.go", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fnet%2Fnet_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51fb17f48428e7cfc96a72a9f9f87901363bb6b/libgo%2Fgo%2Fnet%2Fnet_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_posix.go?ref=a51fb17f48428e7cfc96a72a9f9f87901363bb6b"}, {"sha": "a4e8dcd4455822ecf52b7320c84c7dc15009c7cf", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "5075baa609bd451b62c8defe87ec40c085021039", "filename": "libgo/go/net/packetconn_test.go", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fpacketconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fpacketconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fpacketconn_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "f249372f3925bde4279865b9a2d9e0d4a94ff43d", "filename": "libgo/go/net/protoconn_test.go", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fprotoconn_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "ee3cc4d34d53a66f25fde463e4f482fe277ec485", "filename": "libgo/go/net/rpc/client.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "8898b98abad488a9b3a713e549a87b232f8cd1f7", "filename": "libgo/go/net/rpc/server.go", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "d9ebe71e5c310a6cecff9a6435681ae9de18d4a1", "filename": "libgo/go/net/rpc/server_test.go", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "2d64f2f5bff93fe8d98d12a0258e5d872e5dfb41", "filename": "libgo/go/net/sendfile_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fsendfile_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fsendfile_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_windows.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "78417fd2ee7f95547ec09a05b55102167fc6410b", "filename": "libgo/go/net/sock_posix.go", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_posix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "f6e4df30a8b322f50d254b0c46ad95d91e7a78ac", "filename": "libgo/go/net/tcp_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcp_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "6aba1f89fc82451e93a5d13abca13afcd23879ae", "filename": "libgo/go/net/tcpsock.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "cec5bd2aa5ea3e0a3574f4bd67fa23e8acac8dfc", "filename": "libgo/go/net/tcpsock_plan9.go", "status": "modified", "additions": 111, "deletions": 16, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "e5b3a09f75c257eba7f46f6e7346d3562c375c68", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "855350c31f05447e3b0809de67f4122c69e76faf", "filename": "libgo/go/net/textproto/reader.go", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "26987f6113263bbb0f3bf6fb9123c3a2253a6bdc", "filename": "libgo/go/net/textproto/reader_test.go", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "68d8ced011a2b66dd131352072a1ad288a6f606e", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "37b904f3242218d606b7ea1a2a1ab0f43a34f00b", "filename": "libgo/go/net/udp_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudp_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "bf2107b03a22438267ccc8be78ce1127684a2325", "filename": "libgo/go/net/udpsock.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "6a828e14d20378dac788baff9237b4901179d3be", "filename": "libgo/go/net/udpsock_plan9.go", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "d7329bf32fc1809fce396a925b3ef7a3dd681be9", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "e1d4b0d47aa7ebaf982039c18e836b546c378b04", "filename": "libgo/go/net/unicast_posix_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Funicast_posix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Funicast_posix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funicast_posix_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "342e26fce0239ba8d2533cbffb352c57f22714a3", "filename": "libgo/go/net/unixsock_plan9.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "16ebd58d6e89dee1d48cc573b5c20788d8cf6832", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "a65b2607996b79ec1c227a24cda173b15ed41a8c", "filename": "libgo/go/old/netchan/export.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fold%2Fnetchan%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fold%2Fnetchan%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fnetchan%2Fexport.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "060c0b2e8f870c4d654b26025c708f06091ede95", "filename": "libgo/go/os/dir_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fdir_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fdir_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "c469e585331c1bcef222773606006e37ca3a3342", "filename": "libgo/go/os/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdoc.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "a7977ff19145bf7da3e468fecc4013c152dde836", "filename": "libgo/go/os/error.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "8368491b0fef54b46bca40baea1f770736fd912a", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "32cac6d89a4d3e22d88cb47187f868756b23140d", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "b3dd188343320fb18b3277db824f50a84bbf6ece", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "c561ea04fb8c248278b9ecf7356de9351e121ee8", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "e0baae2dc487fe7c1663d004ba85e55ef7fc5d5b", "filename": "libgo/go/os/user/lookup_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "bbd738d8c81293421b6c58e748661cabde54c1f5", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "dc2b5b4e0efcc2e2b870071ef868c609a2cbffb8", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 160, "deletions": 2, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "db047963eb175c11f3bcae27ddb4246381763033", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "cd8cf2cf2c98b98768dddad971348839fbb855b6", "filename": "libgo/go/reflect/export_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fexport_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "83b6507f1a1da268beaae5baf800be0f93ecce22", "filename": "libgo/go/reflect/set_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fset_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fset_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fset_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "fb0606d58b80a596224e50928490855df98f2fa9", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 400, "deletions": 166, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "442f1c41618aad17a99050eaaee8a4f35d4538e1", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 105, "deletions": 77, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "aa92e0b58bc7ab9da192a118b155e9c3d086faf5", "filename": "libgo/go/regexp/example_test.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexample_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "f89027a0a080722f707a6d3be76d1f885d3df376", "filename": "libgo/go/regexp/exec_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexec_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "2a1ae56bd829b1d5dd65b82b60b6f73cb02cc41c", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "95f6f15698d459139fdc2ec45a8b92a669230a67", "filename": "libgo/go/regexp/syntax/compile.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "0bf5799b00137e9b6c3fb05220601680fd73c992", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "2113cbf01c112a9bfad416a3d5170de3e9ac574d", "filename": "libgo/go/runtime/crash_test.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "0211ce61b88560d7275d1d47838463725ef9df32", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "fd423c82fdfbee64bb41f4f0d3f3e3dc5f668e5f", "filename": "libgo/go/runtime/mem.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fmem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fmem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmem.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "a7ddaf0a7cb90c52e328ee21dd57699528aaeabf", "filename": "libgo/go/runtime/mgc0.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fmgc0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fmgc0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc0.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "b382b76a7b2b687e642310298dc94d46e87e696e", "filename": "libgo/go/runtime/parfor_test.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fparfor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fparfor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fparfor_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "ee81c94a25b0049aeb7b3a922feebf2f0e3d26c5", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "eba34e4a6badc9843b693468587952275fe6cd2f", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "cd28419adfa05d86ee74dcd54fffbf0b350fd411", "filename": "libgo/go/runtime/vlop_arm_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fvlop_arm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fruntime%2Fvlop_arm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fvlop_arm_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "8a2c1c33b14b36013925f74e6e560aca2d1b3c21", "filename": "libgo/go/sort/search.go", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsort%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsort%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fsearch.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "b7eaaa61bf4d92016c62a3fe4c4cd3bf6bb7da79", "filename": "libgo/go/strconv/extfloat.go", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fextfloat.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "db5f0fbae0cf7c92f7043c94bfba3aa658261c2f", "filename": "libgo/go/strconv/isprint.go", "status": "modified", "additions": 81, "deletions": 44, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrconv%2Fisprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrconv%2Fisprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fisprint.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "98325ce75bf659f69e14db9228e03d91dad38914", "filename": "libgo/go/strings/reader.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrings%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrings%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freader.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "bab91fc71979767871946702c2329de43eff5912", "filename": "libgo/go/strings/reader_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrings%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrings%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freader_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "7be41a8dcadc128dfa0fd4d9269910329e8bc1f3", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "f070e78bd3c3c7f52122ed7bfbb16140db021269", "filename": "libgo/go/sync/atomic/64bit_arm.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsync%2Fatomic%2F64bit_arm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsync%2Fatomic%2F64bit_arm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2F64bit_arm.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7", "previous_filename": "libgo/go/sync/atomic/64bit_linux_arm.go"}, {"sha": "242bbf298f068e49c673ec090209136969396a09", "filename": "libgo/go/sync/atomic/race.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsync%2Fatomic%2Frace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsync%2Fatomic%2Frace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Frace.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "75c61f0f9f1fa6722adde3c2c43671f9df668da5", "filename": "libgo/go/syscall/exec_linux.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_linux.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "a5421d436d62405372db7d8a23b9e7ae5facee5a", "filename": "libgo/go/syscall/libcall_linux.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "66b41a50fa7bad82eae15e9bf0d6bf840d1942a8", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "aab4a4d6b6093db5a8ae2af829f5b4cd4acdce6f", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "657e25410312767912b0f7a9b921086e20e7989f", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "b92c339c02a21ac7cab801b4361181ae6c73ba1d", "filename": "libgo/go/time/tick.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Ftick.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Ftick.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}, {"sha": "9888d0d9c190347d2d353dadbf8ad0fef2b87a4a", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabcaa8df3d6eb852b87821ef090d31d222870b7/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=fabcaa8df3d6eb852b87821ef090d31d222870b7"}]}