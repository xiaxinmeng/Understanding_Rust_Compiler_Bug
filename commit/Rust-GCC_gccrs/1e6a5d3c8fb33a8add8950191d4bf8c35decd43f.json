{"sha": "1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2YTVkM2M4ZmIzM2E4YWRkODk1MDE5MWQ0YmY4YzM1ZGVjZDQzZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-17T06:42:03Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-17T06:42:03Z"}, "message": "tree-flow-inline.h (get_stmt_operands): Remove.\n\n\t* tree-flow-inline.h (get_stmt_operands): Remove.\n\t* lambda-code.c, tree-ssa-loop-unswitch.c,\n\ttree-ssa-operands.c, tree-ssa-pre.c, tree-ssa-propagate.c,\n\ttree-ssa-sink.c, tree-ssa.c, tree-tailcall.c,\n\ttree-vect-transform.c, tree-vectorizer.c, tree-vrp.c): Remove\n\tcalls to get_stmt_operands.\n\t* doc/tree-ssa.texi: Don't mention get_stmt_operands.\n\nFrom-SVN: r98262", "tree": {"sha": "ef804854e7d9e15b6b91599f5e2f31a6de445f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef804854e7d9e15b6b91599f5e2f31a6de445f81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/comments", "author": null, "committer": null, "parents": [{"sha": "911204fec298ee649cc092030638145d107f542f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911204fec298ee649cc092030638145d107f542f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/911204fec298ee649cc092030638145d107f542f"}], "stats": {"total": 115, "additions": 21, "deletions": 94}, "files": [{"sha": "4698d048c5cdf2f2379bf0157ef683d13811089e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -7,6 +7,14 @@\n \n \t* c-parser.c (N_C_TTYPES): Remove.\n \n+\t* tree-flow-inline.h (get_stmt_operands): Remove.\n+\t* lambda-code.c, tree-ssa-loop-unswitch.c,\n+\ttree-ssa-operands.c, tree-ssa-pre.c, tree-ssa-propagate.c,\n+\ttree-ssa-sink.c, tree-ssa.c, tree-tailcall.c,\n+\ttree-vect-transform.c, tree-vectorizer.c, tree-vrp.c): Remove\n+\tcalls to get_stmt_operands.\n+\t* doc/tree-ssa.texi: Don't mention get_stmt_operands.\n+\n 2005-04-17  Richard Henderson  <rth@redhat.com>\n \n \tPR target/20375"}, {"sha": "faf8cccb292c9d8d9c097cd7a33b8565276550f2", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -886,15 +886,14 @@ print_ops (tree stmt)\n @}\n @end smallexample\n \n-Operands were once updated lazily via calls to @code{get_stmt_operands}.\n-This function is now deprecated and operands are updated as soon as the\n-statement is finished via a call to @code{update_stmt}.  If statement elements\n-are changed via @code{SET_USE} or @code{SET_DEF}, then no further action is\n-required (ie, those macros take care of updating the statement).  If\n-changes are made by manipulating the statement's tree directly, then a call\n+Operands are updated as soon as the statement is finished via a call\n+to @code{update_stmt}.  If statement elements are changed via\n+@code{SET_USE} or @code{SET_DEF}, then no further action is required\n+(ie, those macros take care of updating the statement).  If changes\n+are made by manipulating the statement's tree directly, then a call\n must be made to @code{update_stmt} when complete.  Calling one of the\n-@code{bsi_insert} routines or @code{bsi_replace} performs an implicit call\n-to @code{update_stmt}.\n+@code{bsi_insert} routines or @code{bsi_replace} performs an implicit\n+call to @code{update_stmt}.\n \n @subsection Operand Iterators\n @cindex Operand Iterators"}, {"sha": "50815f981b1a12284ec13139b7d9874ecb5dc2ab", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -1294,7 +1294,6 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   phi = SSA_NAME_DEF_STMT (inductionvar);\n   if (TREE_CODE (phi) != PHI_NODE)\n     {\n-      get_stmt_operands (phi);\n       uses = STMT_USE_OPS (phi);\n \n       if (!uses)"}, {"sha": "6bed701e5da6121e41310ebcd1b6e01f431d3373", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -4730,9 +4730,6 @@ tree_duplicate_bb (basic_block bb)\n       if (TREE_CODE (stmt) == LABEL_EXPR)\n \tcontinue;\n \n-      /* Record the definitions.  */\n-      get_stmt_operands (stmt);\n-\n       FOR_EACH_SSA_TREE_OPERAND (val, stmt, op_iter, SSA_OP_ALL_DEFS)\n \tmark_for_rewrite (val);\n \n@@ -4946,7 +4943,6 @@ rewrite_to_new_ssa_names_bb (basic_block bb, htab_t map)\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       stmt = bsi_stmt (bsi);\n-      get_stmt_operands (stmt);\n       ann = stmt_ann (stmt);\n \n       uses = USE_OPS (ann);"}, {"sha": "f41448bc0e94e5b6da1635e784d8f8597cf9e072", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -172,27 +172,6 @@ update_stmt_if_modified (tree t)\n     update_stmt_operands (t);\n }\n \n-static inline void \n-get_stmt_operands (tree stmt ATTRIBUTE_UNUSED)\n-{\n-#ifdef ENABLE_CHECKING\n-  stmt_ann_t ann;\n-                                                                                \n-  /* The optimizers cannot handle statements that are nothing but a\n-     _DECL.  This indicates a bug in the gimplifier.  */\n-  gcc_assert (!SSA_VAR_P (stmt));\n-                                                                                \n-  /* Ignore error statements.  */\n-  if (TREE_CODE (stmt) == ERROR_MARK)\n-    return;\n-                                                                                \n-  ann = get_stmt_ann (stmt);\n-  gcc_assert (!ann->modified);\n-\n-  return;\n-#endif\n-}\n-\n /* Return true if T is marked as modified, false otherwise.  */\n static inline bool\n stmt_modified_p (tree t)"}, {"sha": "657d1b5461088bdaa57b96207a2b50aed257dd4c", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -1885,7 +1885,6 @@ rewrite_trees (var_map map, tree *values)\n \t  stmt_ann_t ann;\n \t  ssa_op_iter iter;\n \n-\t  get_stmt_operands (stmt);\n \t  ann = stmt_ann (stmt);\n \t  changed = false;\n "}, {"sha": "b926113ded878ab2f8777a2fa00b3898a576f96d", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -656,7 +656,6 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t     statement.  Note that this will miss all the addresses taken\n \t     in PHI nodes (those are discovered while following the use-def\n \t     chains).  */\n-\t  get_stmt_operands (stmt);\n \t  addr_taken = addresses_taken (stmt);\n \t  if (addr_taken)\n \t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)"}, {"sha": "9003a9d974a33f5af5e11fee6ddbef8a9043ca00", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -475,8 +475,6 @@ likely_value (tree stmt)\n       && TREE_CODE (stmt) != SWITCH_EXPR)\n     return VARYING;\n \n-  get_stmt_operands (stmt);\n-\n   found_constant = false;\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE|SSA_OP_VUSE)\n     {\n@@ -525,8 +523,6 @@ ccp_initialize (void)\n \t  bool is_varying = false;\n \t  tree stmt = bsi_stmt (i);\n \n-\t  get_stmt_operands (stmt);\n-\n \t  if (likely_value (stmt) == VARYING)\n \n \t    {"}, {"sha": "f152321ab9a940af08923a62c69ac6cfbfb7f381", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -355,8 +355,6 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n       return;\n     }\n \n-  get_stmt_operands (stmt);\n-\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n     {\n       if (is_global_var (SSA_NAME_VAR (def)))\n@@ -539,8 +537,6 @@ propagate_necessity (struct edge_list *el)\n \t  ssa_op_iter iter;\n \t  tree use;\n \n-\t  get_stmt_operands (i);\n-\n \t  /* The operands of V_MAY_DEF expressions are also needed as they\n \t     represent potential definitions that may reach this\n \t     statement (V_MAY_DEF operands allow us to follow def-def "}, {"sha": "1f376c4b964928096a402317fcb1b95208399022", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -178,7 +178,6 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n   stmt_ann_t ann = stmt_ann (stmt);\n   v_may_def_optype v_may_defs;\n \n-  get_stmt_operands (stmt);\n   v_may_defs = V_MAY_DEF_OPS (ann);\n \n   /* If this statement has no virtual defs, then there is nothing"}, {"sha": "718c3a39dfbb4f26d6ac3ff0b3810f059af963d3", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -367,7 +367,6 @@ create_ssa_var_map (int flags)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n         {\n \t  stmt = bsi_stmt (bsi);\n-\t  get_stmt_operands (stmt);\n \n \t  /* Register USE and DEF operands in each statement.  */\n \t  FOR_EACH_SSA_TREE_OPERAND (use , stmt, iter, SSA_OP_USE)\n@@ -612,7 +611,6 @@ calculate_live_on_entry (var_map map)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n         {\n \t  stmt = bsi_stmt (bsi);\n-\t  get_stmt_operands (stmt);\n \n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t    {\n@@ -1324,8 +1322,6 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \t  bool is_a_copy = false;\n \t  tree stmt = bsi_stmt (bsi);\n \n-\t  get_stmt_operands (stmt);\n-\n \t  /* A copy between 2 partitions does not introduce an interference \n \t     by itself.  If they did, you would never be able to coalesce \n \t     two things which are copied.  If the two variables really do "}, {"sha": "b51b5e11806b74ab5605c355895c53fd8a50b870", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -220,8 +220,6 @@ movement_possibility (tree stmt)\n     {\n       /* If we perform unswitching, force the operands of the invariant\n \t condition to be moved out of the loop.  */\n-      get_stmt_operands (stmt);\n-\n       return MOVE_POSSIBLE;\n     }\n \n@@ -231,8 +229,6 @@ movement_possibility (tree stmt)\n   if (stmt_ends_bb_p (stmt))\n     return MOVE_IMPOSSIBLE;\n \n-  get_stmt_operands (stmt);\n-\n   if (stmt_ann (stmt)->has_volatile_ops)\n     return MOVE_IMPOSSIBLE;\n \n@@ -622,7 +618,6 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t     The multiply stmt is not invariant, so update iterator\n \t     and avoid rescanning.  */\n \t  bsi_replace (&bsi, stmt1, true);\n-\t  get_stmt_operands (stmt1);  /* Should not be necessary.  */\n \t  bsi_insert_after (&bsi, stmt2, BSI_NEW_STMT);\n \t  SSA_NAME_DEF_STMT (lhs) = stmt2;\n "}, {"sha": "d1bf6a52dc10ed90c889bea0cdf2f74aa913d6aa", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -1553,7 +1553,6 @@ find_invariants_stmt (struct ivopts_data *data, tree stmt)\n     n = PHI_NUM_ARGS (stmt);\n   else\n     {\n-      get_stmt_operands (stmt);\n       uses = STMT_USE_OPS (stmt);\n       n = NUM_USES (uses);\n     }\n@@ -4994,8 +4993,6 @@ protect_loop_closed_ssa_form (edge exit, tree stmt)\n   v_may_def_optype v_may_defs;\n   unsigned i;\n \n-  get_stmt_operands (stmt);\n-\n   uses = STMT_USE_OPS (stmt);\n   for (i = 0; i < NUM_USES (uses); i++)\n     protect_loop_closed_ssa_form_use (exit, USE_OP_PTR (uses, i));"}, {"sha": "02b21a32f943612e61cb2ec482138bf446607bc6", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -256,8 +256,6 @@ find_uses_to_rename_stmt (tree stmt, bitmap *use_blocks)\n   tree var;\n   basic_block bb = bb_for_stmt (stmt);\n \n-  get_stmt_operands (stmt);\n-\n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n     find_uses_to_rename_use (bb, var, use_blocks);\n }\n@@ -402,8 +400,6 @@ check_loop_closed_ssa_stmt (basic_block bb, tree stmt)\n   ssa_op_iter iter;\n   tree var;\n \n-  get_stmt_operands (stmt);\n-\n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n     check_loop_closed_ssa_use (bb, var);\n }"}, {"sha": "b1af67f00111535bf66b44821af32130733cbe8a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -1028,7 +1028,6 @@ chain_of_csts_start (struct loop *loop, tree x)\n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return NULL_TREE;\n \n-  get_stmt_operands (stmt);\n   if (NUM_VUSES (STMT_VUSE_OPS (stmt)) > 0)\n     return NULL_TREE;\n   if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0)"}, {"sha": "7b8855e7f5846638c909721aab0528e371508696", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -128,7 +128,6 @@ tree_may_unswitch_on (basic_block bb, struct loop *loop)\n     return NULL_TREE;\n \n   /* Condition must be invariant.  */\n-  get_stmt_operands (stmt);\n   uses = STMT_USE_OPS (stmt);\n   for (i = 0; i < NUM_USES (uses); i++)\n     {"}, {"sha": "b2f8b32fea1a4091cb360ce2b150297a14641790", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -50,8 +50,6 @@ Boston, MA 02111-1307, USA.  */\n    The routines in this file are concerned with creating this operand cache \n    from a stmt tree.\n \n-   get_stmt_operands() in the primary entry point. \n-\n    The operand tree is the parsed by the various get_* routines which look \n    through the stmt tree for the occurrence of operands which may be of \n    interest, and calls are made to the append_* routines whenever one is \n@@ -81,7 +79,7 @@ Boston, MA 02111-1307, USA.  */\n */\n \n \n-/* Flags to describe operand properties in get_stmt_operands and helpers.  */\n+/* Flags to describe operand properties in helpers.  */\n \n /* By default, operands are loaded.  */\n #define opf_none\t0\n@@ -520,9 +518,7 @@ finalize_ssa_uses (use_optype *old_ops_p, tree stmt)\n   {\n     unsigned x;\n     /* If the pointer to the operand is the statement itself, something is\n-       wrong.  It means that we are pointing to a local variable (the \n-       initial call to get_stmt_operands does not pass a pointer to a \n-       statement).  */\n+       wrong.  It means that we are pointing to a local variable.  */\n     for (x = 0; x < num; x++)\n       gcc_assert (*(VARRAY_TREE_PTR (build_uses, x)) != stmt);\n   }\n@@ -1219,18 +1215,15 @@ swap_tree_operands (tree *exp0, tree *exp1)\n   *exp1 = op0;\n }\n \n-/* Get the operands of statement STMT.  Note that repeated calls to\n-   get_stmt_operands for the same statement will do nothing until the\n-   statement is marked modified by a call to mark_stmt_modified().  */\n+/* Get the operands of statement STMT.  */\n \n void\n update_stmt_operands (tree stmt)\n {\n   stmt_ann_t ann;\n   stmt_operands_t old_operands;\n \n-  /* If get_stmt_operands is called before SSA is initialized, dont\n-  do anything.  */\n+  /* Don't do anything if we are called before SSA is initialized.  */\n   if (build_defs == NULL)\n     return;\n   /* The optimizers cannot handle statements that are nothing but a\n@@ -1249,9 +1242,7 @@ update_stmt_operands (tree stmt)\n   build_ssa_operands (stmt, ann, &old_operands, &(ann->operands));\n   free_ssa_operands (&old_operands);\n \n-  /* Clear the modified bit for STMT.  Subsequent calls to\n-     get_stmt_operands for this statement will do nothing until the\n-     statement is marked modified by a call to mark_stmt_modified().  */\n+  /* Clear the modified bit for STMT.  */\n   ann->modified = 0;\n \n   timevar_pop (TV_TREE_OPS);"}, {"sha": "9029dbe3de304550008f7837ffb3ee3945ddc43e", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -1958,7 +1958,6 @@ compute_avail (void)\n \n \t  stmt = bsi_stmt (bsi);\n \t  ann = stmt_ann (stmt);\n-\t  get_stmt_operands (stmt);\n \n \t  /* We are only interested in assignments of the form\n \t     X_i = EXPR, where EXPR represents an \"interesting\"\n@@ -2176,8 +2175,6 @@ remove_dead_inserted_code (void)\n \t  ssa_op_iter iter;\n \t  tree use;\n \n-\t  get_stmt_operands (t);\n-\n \t  /* The operands of V_MAY_DEF expressions are also needed as they\n \t     represent potential definitions that may reach this\n \t     statement (V_MAY_DEF operands allow us to follow def-def "}, {"sha": "0cac9f462dfcad15ddfd38d278e2bd4d11827dbf", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -1032,8 +1032,6 @@ substitute_and_fold (prop_value_t *prop_value)\n           bool replaced_address, did_replace;\n \t  tree stmt = bsi_stmt (i);\n \n-\t  get_stmt_operands (stmt);\n-\n \t  /* Replace the statement with its folded version and mark it\n \t     folded.  */\n \t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "7751c4a8d7e07970370a0ef3b60cf8af9bef9b4f", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -462,7 +462,6 @@ sink_code_in_bb (basic_block bb)\n       tree stmt = bsi_stmt (bsi);\t\n       block_stmt_iterator tobsi;\n       tree sinkstmt;\n-      get_stmt_operands (stmt);\n       \n       sinkstmt = statement_sink_location (stmt, bb);\n       if (!sinkstmt)"}, {"sha": "8efbdde0b916979a7aa5a29973d27093096f7814", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -930,10 +930,7 @@ tree_ssa_useless_type_conversion (tree expr)\n bool\n stmt_references_memory_p (tree stmt)\n {\n-  stmt_ann_t ann;\n-\n-  get_stmt_operands (stmt);\n-  ann = stmt_ann (stmt);\n+  stmt_ann_t ann = stmt_ann (stmt);\n \n   if (ann->has_volatile_ops)\n     return true;"}, {"sha": "4034b8c3d96931d82a226cf8f9f3691a2f1f6e2f", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -394,8 +394,6 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       if (TREE_CODE (stmt) == LABEL_EXPR)\n \tcontinue;\n \n-      get_stmt_operands (stmt);\n-\n       /* Check for a call.  */\n       if (TREE_CODE (stmt) == MODIFY_EXPR)\n \t{\n@@ -687,7 +685,6 @@ eliminate_tail_call (struct tailcall *t)\n   block_stmt_iterator bsi;\n \n   stmt = bsi_stmt (t->call_bsi);\n-  get_stmt_operands (stmt);\n   ann = stmt_ann (stmt);\n   bb = t->call_block;\n "}, {"sha": "f07669bb8f7598cc817fb5e4e3a2b0b4c61dfa1d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -146,7 +146,6 @@ vect_create_index_for_vector_ref (loop_vec_info loop_vinfo)\n   create_iv (init, step, NULL_TREE, loop, &incr_bsi, insert_after,\n \t&indx_before_incr, &indx_after_incr);\n   incr = bsi_stmt (incr_bsi);\n-  get_stmt_operands (incr);\n   set_stmt_info (stmt_ann (incr), new_stmt_vec_info (incr, loop_vinfo));\n \n   return indx_before_incr;"}, {"sha": "13b2281e1747834511c420db24e9f8eee27cbbd9", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -282,7 +282,6 @@ rename_variables_in_bb (basic_block bb)\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       stmt = bsi_stmt (bsi);\n-      get_stmt_operands (stmt);\n       ann = stmt_ann (stmt);\n \n       uses = USE_OPS (ann);\n@@ -1485,7 +1484,6 @@ new_loop_vec_info (struct loop *loop)\n \t  tree stmt = bsi_stmt (si);\n \t  stmt_ann_t ann;\n \n-\t  get_stmt_operands (stmt);\n \t  ann = stmt_ann (stmt);\n \t  set_stmt_info (ann, new_stmt_vec_info (stmt, res));\n \t}"}, {"sha": "c1f910e5ce10beabe1e7d6a682fbf31b5fc3006c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a5d3c8fb33a8add8950191d4bf8c35decd43f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1e6a5d3c8fb33a8add8950191d4bf8c35decd43f", "patch": "@@ -1443,7 +1443,6 @@ maybe_add_assert_expr (basic_block bb)\n       ssa_op_iter i;\n       \n       stmt = bsi_stmt (si);\n-      get_stmt_operands (stmt);\n \n       /* Mark all the SSA names used by STMT in bitmap FOUND.  If STMT\n \t is inside the sub-graph of a conditional block, when we"}]}