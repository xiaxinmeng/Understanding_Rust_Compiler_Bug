{"sha": "2c5d803d03209478b4f060785c6f6ba2f0de88ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1ZDgwM2QwMzIwOTQ3OGI0ZjA2MDc4NWM2ZjZiYTJmMGRlODhhZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-23T07:37:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-23T07:37:36Z"}, "message": "openmp: Diagnose invalid mixing of the attribute and pragma syntax directives\n\nThe OpenMP 5.1 spec says that the attribute and pragma syntax directives\nshould not be mixed on the same statement.  The following patch adds diagnostic\nfor that,\n  [[omp::directive (...)]]\n  #pragma omp ...\nis always an error and for the other order\n  #pragma omp ...\n  [[omp::directive (...)]]\nit depends on whether the pragma directive is an OpenMP construct\n(then it is an error because it needs a structured block or loop\nor statement as body) or e.g. a standalone directive (then it is fine).\n\nOnly block scope is handled for now though, namespace scope and class scope\nstill needs implementing even the basic support.\n\n2021-07-23  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/c-family/\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP__START_ and\n\tPRAGMA_OMP__LAST_ enumerators.\ngcc/cp/\n\t* parser.h (struct cp_parser): Add omp_attrs_forbidden_p member.\n\t* parser.c (cp_parser_handle_statement_omp_attributes): Diagnose\n\tmixing of attribute and pragma syntax directives when seeing\n\tomp::directive if parser->omp_attrs_forbidden_p or if attribute syntax\n\tdirectives are followed by OpenMP pragma.\n\t(cp_parser_statement): Clear parser->omp_attrs_forbidden_p after\n\tthe cp_parser_handle_statement_omp_attributes call.\n\t(cp_parser_omp_structured_block): Add disallow_omp_attrs argument,\n\tif true, set parser->omp_attrs_forbidden_p.\n\t(cp_parser_omp_scan_loop_body, cp_parser_omp_sections_scope): Pass\n\tfalse as disallow_omp_attrs to cp_parser_omp_structured_block.\n\t(cp_parser_omp_parallel, cp_parser_omp_task): Set\n\tparser->omp_attrs_forbidden_p.\ngcc/testsuite/\n\t* g++.dg/gomp/attrs-4.C: New test.\n\t* g++.dg/gomp/attrs-5.C: New test.", "tree": {"sha": "6b07db47a86a003c6ee098da3e6bc7029969dda8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b07db47a86a003c6ee098da3e6bc7029969dda8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c5d803d03209478b4f060785c6f6ba2f0de88ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5d803d03209478b4f060785c6f6ba2f0de88ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c5d803d03209478b4f060785c6f6ba2f0de88ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5d803d03209478b4f060785c6f6ba2f0de88ad/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19e05058799ffd611f4946d1871e747bae7a0046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e05058799ffd611f4946d1871e747bae7a0046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19e05058799ffd611f4946d1871e747bae7a0046"}], "stats": {"total": 154, "additions": 149, "deletions": 5}, "files": [{"sha": "abd66672f527fb5d4bbc4e6143fbd3b39914e9d7", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=2c5d803d03209478b4f060785c6f6ba2f0de88ad", "patch": "@@ -42,7 +42,9 @@ enum pragma_kind {\n   PRAGMA_OACC_UPDATE,\n   PRAGMA_OACC_WAIT,\n \n+  /* PRAGMA_OMP__START_ should be equal to the first PRAGMA_OMP_* code.  */\n   PRAGMA_OMP_ALLOCATE,\n+  PRAGMA_OMP__START_ = PRAGMA_OMP_ALLOCATE,\n   PRAGMA_OMP_ATOMIC,\n   PRAGMA_OMP_BARRIER,\n   PRAGMA_OMP_CANCEL,\n@@ -72,6 +74,8 @@ enum pragma_kind {\n   PRAGMA_OMP_TASKYIELD,\n   PRAGMA_OMP_THREADPRIVATE,\n   PRAGMA_OMP_TEAMS,\n+  /* PRAGMA_OMP__LAST_ should be equal to the last PRAGMA_OMP_* code.  */\n+  PRAGMA_OMP__LAST_ = PRAGMA_OMP_TEAMS,\n \n   PRAGMA_GCC_PCH_PREPROCESS,\n   PRAGMA_IVDEP,"}, {"sha": "18905cf0fbd791892702b68e754010705bda098a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2c5d803d03209478b4f060785c6f6ba2f0de88ad", "patch": "@@ -11665,6 +11665,7 @@ cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n   auto_vec<cp_omp_attribute_data, 16> vec;\n   int cnt = 0;\n   int tokens = 0;\n+  bool bad = false;\n   for (tree *pa = &attrs; *pa; )\n     if (get_attribute_namespace (*pa) == omp_identifier\n \t&& is_attribute_p (\"directive\", get_attribute_name (*pa)))\n@@ -11676,6 +11677,14 @@ cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n \t    gcc_assert (TREE_CODE (d) == DEFERRED_PARSE);\n \t    cp_token *first = DEFPARSE_TOKENS (d)->first;\n \t    cp_token *last = DEFPARSE_TOKENS (d)->last;\n+\t    if (parser->omp_attrs_forbidden_p)\n+\t      {\n+\t\terror_at (first->location,\n+\t\t\t  \"mixing OpenMP directives with attribute and pragma \"\n+\t\t\t  \"syntax on the same statement\");\n+\t\tparser->omp_attrs_forbidden_p = false;\n+\t\tbad = true;\n+\t      }\n \t    const char *directive[3] = {};\n \t    for (int i = 0; i < 3; i++)\n \t      {\n@@ -11731,6 +11740,9 @@ cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n     else\n       pa = &TREE_CHAIN (*pa);\n \n+  if (bad)\n+    return attrs;\n+\n   unsigned int i;\n   cp_omp_attribute_data *v;\n   cp_omp_attribute_data *construct_seen = nullptr;\n@@ -11780,6 +11792,18 @@ cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n \t\t\" can only appear on an empty statement\");\n       return attrs;\n     }\n+  if (cnt && cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n+    {\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      enum pragma_kind kind = cp_parser_pragma_kind (token);\n+      if (kind >= PRAGMA_OMP__START_ && kind <= PRAGMA_OMP__LAST_)\n+\t{\n+\t  error_at (token->location,\n+\t\t    \"mixing OpenMP directives with attribute and pragma \"\n+\t\t    \"syntax on the same statement\");\n+\t  return attrs;\n+\t}\n+    }\n \n   if (!tokens)\n     return attrs;\n@@ -11904,6 +11928,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \n   if (std_attrs && (flag_openmp || flag_openmp_simd))\n     std_attrs = cp_parser_handle_statement_omp_attributes (parser, std_attrs);\n+  parser->omp_attrs_forbidden_p = false;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -39391,11 +39416,14 @@ cp_parser_end_omp_structured_block (cp_parser *parser, unsigned save)\n }\n \n static tree\n-cp_parser_omp_structured_block (cp_parser *parser, bool *if_p)\n+cp_parser_omp_structured_block (cp_parser *parser, bool *if_p,\n+\t\t\t\tbool disallow_omp_attrs = true)\n {\n   tree stmt = begin_omp_structured_block ();\n   unsigned int save = cp_parser_begin_omp_structured_block (parser);\n \n+  if (disallow_omp_attrs)\n+    parser->omp_attrs_forbidden_p = true;\n   cp_parser_statement (parser, NULL_TREE, false, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n@@ -40761,7 +40789,7 @@ cp_parser_omp_scan_loop_body (cp_parser *parser)\n   if (!braces.require_open (parser))\n     return;\n \n-  substmt = cp_parser_omp_structured_block (parser, NULL);\n+  substmt = cp_parser_omp_structured_block (parser, NULL, false);\n   substmt = build2 (OMP_SCAN, void_type_node, substmt, NULL_TREE);\n   add_stmt (substmt);\n \n@@ -40796,7 +40824,7 @@ cp_parser_omp_scan_loop_body (cp_parser *parser)\n     error (\"expected %<#pragma omp scan%>\");\n \n   clauses = finish_omp_clauses (clauses, C_ORT_OMP);\n-  substmt = cp_parser_omp_structured_block (parser, NULL);\n+  substmt = cp_parser_omp_structured_block (parser, NULL, false);\n   substmt = build2_loc (tok->location, OMP_SCAN, void_type_node, substmt,\n \t\t\tclauses);\n   add_stmt (substmt);\n@@ -41597,7 +41625,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n   if (cp_parser_pragma_kind (cp_lexer_peek_token (parser->lexer))\n       != PRAGMA_OMP_SECTION)\n     {\n-      substmt = cp_parser_omp_structured_block (parser, NULL);\n+      substmt = cp_parser_omp_structured_block (parser, NULL, false);\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       add_stmt (substmt);\n     }\n@@ -41622,7 +41650,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n \t  error_suppress = true;\n \t}\n \n-      substmt = cp_parser_omp_structured_block (parser, NULL);\n+      substmt = cp_parser_omp_structured_block (parser, NULL, false);\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       add_stmt (substmt);\n     }\n@@ -41842,6 +41870,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \n   block = begin_omp_parallel ();\n   save = cp_parser_begin_omp_structured_block (parser);\n+  parser->omp_attrs_forbidden_p = true;\n   cp_parser_statement (parser, NULL_TREE, false, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   stmt = finish_omp_parallel (clauses, block);\n@@ -41904,6 +41933,7 @@ cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t\t\t\t       \"#pragma omp task\", pragma_tok);\n   block = begin_omp_task ();\n   save = cp_parser_begin_omp_structured_block (parser);\n+  parser->omp_attrs_forbidden_p = true;\n   cp_parser_statement (parser, NULL_TREE, false, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   return finish_omp_task (clauses, block);"}, {"sha": "6fdd214788a27ce045639ec4877792db9ad004af", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=2c5d803d03209478b4f060785c6f6ba2f0de88ad", "patch": "@@ -398,6 +398,9 @@ struct GTY(()) cp_parser {\n      identifiers) rather than an explicit template parameter list.  */\n   bool fully_implicit_function_template_p;\n \n+  /* TRUE if omp::directive or omp::sequence attributes may not appear.  */\n+  bool omp_attrs_forbidden_p;\n+\n   /* Tracks the function's template parameter list when declaring a function\n      using generic type parameters.  This is either a new chain in the case of a\n      fully implicit function template or an extension of the function's existing"}, {"sha": "005add826ba52054c6508eff0df7376c777c6628", "filename": "gcc/testsuite/g++.dg/gomp/attrs-4.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-4.C?ref=2c5d803d03209478b4f060785c6f6ba2f0de88ad", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do compile { target c++11 } }\n+\n+void\n+foo (int x)\n+{\n+  [[omp::directive (parallel)]]\n+  #pragma omp for\t\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  for (int i = 0; i < 16; i++)\n+    ;\n+  [[omp::directive (barrier)]]\t\t\t\t\t// { dg-error \"standalone OpenMP directives in 'omp::directive' attribute can only appear on an empty statement\" }\n+  #pragma omp flush\n+  ;\n+  #pragma omp parallel\n+  [[omp::directive (master)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp teams\n+  [[omp::sequence (directive (parallel), directive (master))]]\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp task\n+  [[omp::directive (flush)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp master\n+  [[omp::directive (flush)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp for ordered\n+  for (int i = 0; i < 16; i++)\n+    #pragma omp ordered\n+    [[omp::directive (flush)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+    ;\n+  #pragma omp single\n+  [[omp::directive (flush)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp taskgroup\n+  [[omp::directive (taskyield)]]\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp target data map (tofrom: x)\n+  [[omp::directive (flush)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp target\n+  [[omp::directive (teams)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  [[omp::directive (parallel)]]\n+  #pragma omp master\t\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  [[omp::sequence (omp::directive (taskloop))]]\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  for (int i = 0; i < 16; i++)\n+    ;\n+  #pragma omp parallel\n+  [[omp::directive (for)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  for (int i = 0; i < 16; i++)\n+    ;\n+  #pragma omp for\n+  [[omp::directive (master)]]\t\t\t\t\t// { dg-error \"for statement expected before '\\\\\\[' token\" }\n+  ;\n+  #pragma omp target teams\n+  [[omp::directive (parallel)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  ;\n+  #pragma omp parallel master\n+  [[omp::directive (taskloop)]]\t\t\t\t\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  for (int i = 0; i < 16; i++)\n+    ;\n+}"}, {"sha": "f6d24b9540c600b3d71b3a1031f4e7c20f406b60", "filename": "gcc/testsuite/g++.dg/gomp/attrs-5.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5d803d03209478b4f060785c6f6ba2f0de88ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-5.C?ref=2c5d803d03209478b4f060785c6f6ba2f0de88ad", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do compile { target c++11 } }\n+\n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+\n+void\n+foo (int x)\n+{\n+  #pragma omp barrier\n+  [[omp::directive (barrier)]];\n+  #pragma omp parallel\n+  {\n+    #pragma omp cancel parallel\n+    [[omp::directive (cancellation point, parallel)]];\n+  }\n+  #pragma omp parallel\n+  {\n+    #pragma omp cancellation point parallel\n+    [[omp::directive (cancel parallel)]];\n+  }\n+  #pragma omp parallel\n+  {\n+    [[omp::directive (cancel, parallel)]];\n+    #pragma omp cancellation point parallel\n+  }\n+  omp_depend_t depobj;\n+  #pragma omp depobj(depobj) update(inout)\n+  [[omp::directive (depobj(depobj), destroy)]];\n+  #pragma omp flush\n+  [[omp::directive (flush)]];\n+  #pragma omp target enter data map (to: x)\n+  [[omp::directive (target exit data, map (from: x))]];\n+  [[omp::directive (target enter data, map (to: x))]];\n+  #pragma omp target exit data map (from: x)\n+  [[omp::directive (flush)]];\n+  #pragma omp target update to (x)\n+  [[omp::directive (flush)]];\n+  #pragma omp taskwait\n+  [[omp::directive (flush)]];\n+  #pragma omp taskyield\n+  [[omp::directive (flush)]];\n+  extern int t;\n+  #pragma omp threadprivate (t)\n+  [[omp::directive (flush)]];\n+}"}]}