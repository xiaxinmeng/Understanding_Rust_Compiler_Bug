{"sha": "11064ef947189c93dda3fef4ea4c3135366ee9a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwNjRlZjk0NzE4OWM5M2RkYTNmZWY0ZWE0YzMxMzUzNjZlZTlhOA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2001-10-08T18:53:49Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2001-10-08T18:53:49Z"}, "message": "* java/io/BufferedInputStream.java: Merge with Classpath\n\nFrom-SVN: r46086", "tree": {"sha": "a8b18be5088d6f869ad9f82803cc84aa55155e13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8b18be5088d6f869ad9f82803cc84aa55155e13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11064ef947189c93dda3fef4ea4c3135366ee9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11064ef947189c93dda3fef4ea4c3135366ee9a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11064ef947189c93dda3fef4ea4c3135366ee9a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11064ef947189c93dda3fef4ea4c3135366ee9a8/comments", "author": null, "committer": null, "parents": [{"sha": "67f28219a6b5f2ee69aea599a76d15c899d8a8c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f28219a6b5f2ee69aea599a76d15c899d8a8c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f28219a6b5f2ee69aea599a76d15c899d8a8c3"}], "stats": {"total": 217, "additions": 201, "deletions": 16}, "files": [{"sha": "b79cb4936080f52b36554f2b9c0123ba5538d503", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11064ef947189c93dda3fef4ea4c3135366ee9a8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11064ef947189c93dda3fef4ea4c3135366ee9a8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=11064ef947189c93dda3fef4ea4c3135366ee9a8", "patch": "@@ -1,3 +1,7 @@\n+2001-10-06  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/io/BufferedInputStream.java: Merge with Classpath\n+\n 2001-10-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* defineclass.cc, java/awt/image/ColorModel.java,"}, {"sha": "8eae02ddd1f0773d97694c9d16a6d0561d24e90d", "filename": "libjava/java/io/BufferedInputStream.java", "status": "modified", "additions": 197, "deletions": 16, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11064ef947189c93dda3fef4ea4c3135366ee9a8/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11064ef947189c93dda3fef4ea4c3135366ee9a8/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedInputStream.java?ref=11064ef947189c93dda3fef4ea4c3135366ee9a8", "patch": "@@ -1,45 +1,118 @@\n-/* Copyright (C) 1998, 1999, 2001  Free Software Foundation\n+/* BufferedInputStream.java -- An input stream that implements buffering\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n  \n package java.io;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 8, 1998.\n- */\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n  \n+/**\n+ * This subclass of <code>FilterInputStream</code> buffers input from an \n+ * underlying implementation to provide a possibly more efficient read\n+ * mechanism.  It maintains the buffer and buffer state in instance \n+ * variables that are available to subclasses.  The default buffer size\n+ * of 2048 bytes can be overridden by the creator of the stream.\n+ * <p>\n+ * This class also implements mark/reset functionality.  It is capable\n+ * of remembering any number of input bytes, to the limits of\n+ * system memory or the size of <code>Integer.MAX_VALUE</code>\n+ * <p>\n+ * Please note that this class does not properly handle character\n+ * encodings.  Consider using the <code>BufferedReader</code> class which\n+ * does.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ */\n public class BufferedInputStream extends FilterInputStream\n {\n-  /* Internal buffer array for data. */\n+\n+  /**\n+   * This is the default buffer size\n+   */\n+  private static final int DEFAULT_BUFFER_SIZE = 2048;\n+\n+  /**\n+   * The buffer used for storing data from the underlying stream.\n+   */\n   protected byte[] buf;\n \n-  /* Index one greater than the last valid byte in the buffer. */\n+  /**\n+   * The number of valid bytes currently in the buffer.  It is also the index\n+   * of the buffer position one byte past the end of the valid data.\n+   */\n   protected int count = 0;\n \n-  /* The current position in the buffer. */\n+  /**\n+   * The index of the next character that will by read from the buffer.\n+   * When <code>pos == count</code>, the buffer is empty.\n+   */\n   protected int pos = 0;\n \n-  /* The value of pos the last time mark() was called. */\n+  /**\n+   * The value of <code>pos</code> when the <code>mark()</code> method was\n+   * called.  \n+   * This is set to -1 if there is no mark set.\n+   */\n   protected int markpos = -1;\n \n-  /* The maximum read-ahead allowed before calls to reset() fail. */\n+  /**\n+   * This is the maximum number of bytes than can be read after a \n+   * call to <code>mark()</code> before the mark can be discarded.\n+   * After this may bytes are read, the <code>reset()</code> method\n+   * may not be called successfully.\n+   */\n   protected int marklimit = 0;\n \n+  /**\n+   * This method initializes a new <code>BufferedInputStream</code> that will\n+   * read from the specified subordinate stream with a default buffer size\n+   * of 2048 bytes\n+   *\n+   * @param in The subordinate stream to read from\n+   */\n   public BufferedInputStream(InputStream in)\n   {\n-    this(in, 2048);\n+    this(in, DEFAULT_BUFFER_SIZE);\n   }\n \n+  /**\n+   * This method initializes a new <code>BufferedInputStream</code> that will\n+   * read from the specified subordinate stream with a buffer size that\n+   * is specified by the caller.\n+   *\n+   * @param in The subordinate stream to read from\n+   * @param size The buffer size to use\n+   *\n+   * @exception IllegalArgumentException when size is smaller then 1\n+   */\n   public BufferedInputStream(InputStream in, int size)\n   {\n     super(in);\n@@ -48,29 +121,85 @@ public BufferedInputStream(InputStream in, int size)\n     buf = new byte[size];\n   }\n \n+  /**\n+   * This method returns the number of bytes that can be read from this\n+   * stream before a read can block.  A return of 0 indicates that blocking\n+   * might (or might not) occur on the very next read attempt.\n+   * <p>\n+   * The number of available bytes will be the number of read ahead bytes \n+   * stored in the internal buffer plus the number of available bytes in\n+   * the underlying stream.\n+   *\n+   * @return The number of bytes that can be read before blocking could occur\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public synchronized int available() throws IOException\n   {\n     return count - pos + super.available();\n   }\n \n+  /**\n+   * This method closes the underlying input stream and frees any\n+   * resources associated with it. Sets <code>buf</code> to <code>null</code>.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public void close() throws IOException\n   {\n     // Free up the array memory.\n     buf = null;\n     super.close();\n   }\n \n+  /**\n+   * This method marks a position in the input to which the stream can be\n+   * \"reset\" by calling the <code>reset()</code> method.  The parameter\n+   * <code>readlimit</code> is the number of bytes that can be read from the \n+   * stream after setting the mark before the mark becomes invalid.  For\n+   * example, if <code>mark()</code> is called with a read limit of 10, then\n+   * when 11 bytes of data are read from the stream before the\n+   * <code>reset()</code> method is called, then the mark is invalid and the\n+   * stream object instance is not required to remember the mark.\n+   * <p>\n+   * Note that the number of bytes that can be remembered by this method\n+   * can be greater than the size of the internal read buffer.  It is also\n+   * not dependent on the subordinate stream supporting mark/reset\n+   * functionality.\n+   *\n+   * @param readlimit The number of bytes that can be read before the mark\n+   * becomes invalid\n+   */\n   public synchronized void mark(int readlimit)\n   {\n     marklimit = readlimit;\n     markpos = pos;\n   }\n \n+  /**\n+   * This method returns <code>true</code> to indicate that this class\n+   * supports mark/reset functionality.\n+   *\n+   * @return <code>true</code> to indicate that mark/reset functionality is\n+   * supported\n+   *\n+   */\n   public boolean markSupported()\n   {\n     return true;\n   }\n \n+  /**\n+   * This method reads an unsigned byte from the input stream and returns it\n+   * as an int in the range of 0-255.  This method also will return -1 if\n+   * the end of the stream has been reached.\n+   * <p>\n+   * This method will block until the byte can be read.\n+   *\n+   * @return The byte read or -1 if end of stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public synchronized int read() throws IOException\n   {\n     if (pos >= count && !refill())\n@@ -82,10 +211,31 @@ public synchronized int read() throws IOException\n     return ((int) buf[pos++]) & 0xFF;\n   }\n \n+  /**\n+   * This method reads bytes from a stream and stores them into a caller\n+   * supplied buffer.  It starts storing the data at index <code>off</code>\n+   * into the buffer and attempts to read <code>len</code> bytes.  This method\n+   * can return before reading the number of bytes requested.  The actual\n+   * number of bytes read is returned as an int.  A -1 is returned to indicate\n+   * the end of the stream.\n+   * <p>\n+   * This method will block until some data can be read.\n+   *\n+   * @param b The array into which the bytes read should be stored\n+   * @param off The offset into the array to start storing bytes\n+   * @param len The requested number of bytes to read\n+   *\n+   * @return The actual number of bytes read, or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   * @exception IndexOutOfBoundsException when <code>off</code> or\n+   *            <code>len</code> are negative, or when <code>off + len</code>\n+   *            is larger then the size of <code>b</code>,\n+   */\n   public synchronized int read(byte[] b, int off, int len) throws IOException\n   {\n     if (off < 0 || len < 0 || off + len > b.length)\n-      throw new ArrayIndexOutOfBoundsException();\n+      throw new IndexOutOfBoundsException();\n \n     if (pos >= count && !refill())\n       return -1;\t\t// No bytes were read before EOF.\n@@ -100,6 +250,19 @@ public synchronized int read(byte[] b, int off, int len) throws IOException\n     return remain;\n   }\n \n+  /**\n+   * This method resets a stream to the point where the <code>mark()</code>\n+   * method was called.  Any bytes that were read after the mark point was\n+   * set will be re-read during subsequent reads.\n+   * <p>\n+   * This method will throw an IOException if the number of bytes read from\n+   * the stream since the call to <code>mark()</code> exceeds the mark limit\n+   * passed when establishing the mark.\n+   *\n+   * @exception IOException If <code>mark()</code> was never called or more\n+   *            then <code>markLimit</code> bytes were read since the last\n+   *            call to <code>mark()</code>\n+   */\n   public synchronized void reset() throws IOException\n   {\n     if (markpos < 0)\n@@ -108,6 +271,17 @@ public synchronized void reset() throws IOException\n     pos = markpos;\n   }\n \n+  /**\n+   * This method skips the specified number of bytes in the stream.  It\n+   * returns the actual number of bytes skipped, which may be less than the\n+   * requested amount.\n+   *\n+   * @param n The requested number of bytes to skip\n+   *\n+   * @return The actual number of bytes skipped.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public synchronized long skip(long n) throws IOException\n   {\n     final long origN = n;\n@@ -131,6 +305,13 @@ public synchronized long skip(long n) throws IOException\n     return origN - n;\n   }\n \n+  /**\n+   * Called to refill the buffer (when count is equal or greater the pos).\n+   * Package local so BufferedReader can call it when needed.\n+   *\n+   * @return <code>true</code> when <code>buf</code> can be (partly) refilled,\n+   *         <code>false</code> otherwise.\n+   */\n   boolean refill() throws IOException\n   {\n     if (markpos < 0)"}]}