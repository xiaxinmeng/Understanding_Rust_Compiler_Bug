{"sha": "296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2YjRlZDljYjMwNmM2NDliOWViYmZhYmU0M2Y5YjBhZTMwZjFiYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-05-06T10:17:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-06T10:17:11Z"}, "message": "expr.c (get_subtarget): New function.\n\n\t* expr.c (get_subtarget): New function.\n\t(force_operand, expand_expr, do_store_flag): Use it.\n\n\t* toplev.c (compile_file): Don't take strlen of NAME if null.\n\nFrom-SVN: r33722", "tree": {"sha": "5df8201c1289345f19b75a6684b365b62209322f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5df8201c1289345f19b75a6684b365b62209322f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc/comments", "author": null, "committer": null, "parents": [{"sha": "593ca8d43283156ae2022f068f99aaf46775cb70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/593ca8d43283156ae2022f068f99aaf46775cb70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/593ca8d43283156ae2022f068f99aaf46775cb70"}], "stats": {"total": 52, "additions": 35, "deletions": 17}, "files": [{"sha": "58bb7a68bed2e2cae55866029552ff2a1a77b889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc", "patch": "@@ -1,3 +1,10 @@\n+Sat May  6 06:25:56 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (get_subtarget): New function.\n+\t(force_operand, expand_expr, do_store_flag): Use it.\n+\n+\t* toplev.c (compile_file): Don't take strlen of NAME if null.\n+\n 2000-05-06  David Edelsohn  <edelsohn@gnu.org>\n \n \t* xcoffout.c (xcoff_current_include_file,"}, {"sha": "a70545b2b03f3beddf96fdbee2dbfd23d2ffd1b6", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc", "patch": "@@ -155,6 +155,7 @@ static void clear_by_pieces\tPARAMS ((rtx, int, unsigned int));\n static void clear_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...),\n \t\t\t\t\t enum machine_mode,\n \t\t\t\t\t struct clear_by_pieces *));\n+static rtx get_subtarget\tPARAMS ((rtx));\n static int is_zeros_p\t\tPARAMS ((tree));\n static int mostly_zeros_p\tPARAMS ((tree));\n static void store_constructor_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n@@ -335,6 +336,7 @@ free_expr_status (f)\n }\n \n /* Small sanity check that the queue is empty at the end of a function.  */\n+\n void\n finish_expr_for_function ()\n {\n@@ -2177,7 +2179,6 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n   return tgtblk;\n }\n \n-\n /* Add a USE expression for REG to the (possibly empty) list pointed\n    to by CALL_FUSAGE.  REG must denote a hard register.  */\n \n@@ -3324,6 +3325,26 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n     anti_adjust_stack (alignment_pad);\n }\n \f\n+/* Return X if X can be used as a subtarget in a sequence of arithmetic\n+   operations.  */\n+\n+static rtx\n+get_subtarget (x)\n+     rtx x;\n+{\n+  return ((x == 0\n+\t   /* Only registers can be subtargets.  */\n+\t   || GET_CODE (x) != REG\n+\t   /* If the register is readonly, it can't be set more than once.  */\n+\t   || RTX_UNCHANGING_P (x)\n+\t   /* Don't use hard regs to avoid extending their life.  */\n+\t   || REGNO (x) < FIRST_PSEUDO_REGISTER\n+\t   /* Avoid subtargets inside loops,\n+\t      since they hide some invariant expressions.  */\n+\t   || preserve_subexpressions_p ())\n+\t  ? 0 : x);\n+}\n+\n /* Expand an assignment that stores the value of FROM into TO.\n    If WANT_VALUE is nonzero, return an rtx for the value of TO.\n    (This may contain a QUEUED rtx;\n@@ -5164,7 +5185,7 @@ force_operand (value, target)\n   rtx tmp;\n   register rtx op2;\n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n-  register rtx subtarget = (target != 0 && GET_CODE (target) == REG ? target : 0);\n+  register rtx subtarget = get_subtarget (target);\n \n   /* Check for a PIC address load.  */\n   if (flag_pic\n@@ -5707,7 +5728,7 @@ expand_expr (exp, target, tmode, modifier)\n \n   mode = TYPE_MODE (type);\n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n-  subtarget = (target != 0 && GET_CODE (target) == REG ? target : 0);\n+  subtarget = get_subtarget (target);\n   original_target = target;\n   ignore = (target == const0_rtx\n \t    || ((code == NON_LVALUE_EXPR || code == NOP_EXPR\n@@ -5722,15 +5743,6 @@ expand_expr (exp, target, tmode, modifier)\n   else\n     ro_modifier = EXPAND_NORMAL;\n \n-  /* Don't use hard regs as subtargets, because the combiner\n-     can only handle pseudo regs.  */\n-  if (subtarget && REGNO (subtarget) < FIRST_PSEUDO_REGISTER)\n-    subtarget = 0;\n-  /* Avoid subtargets inside loops,\n-     since they hide some invariant expressions.  */\n-  if (preserve_subexpressions_p ())\n-    subtarget = 0;\n-\n   /* If we are going to ignore this result, we need only do something\n      if there is a side-effect somewhere in the expression.  If there\n      is, short-circuit the most common cases here.  Note that we must\n@@ -10244,8 +10256,7 @@ do_store_flag (exp, target, mode, only_cheap)\n #endif\n \t\t       );\n \n-      if (subtarget == 0 || GET_CODE (subtarget) != REG\n-\t  || GET_MODE (subtarget) != operand_mode\n+      if (! get_subtarget (subtarget)\n \t  || ! safe_from_p (subtarget, inner, 1))\n \tsubtarget = 0;\n \n@@ -10295,8 +10306,7 @@ do_store_flag (exp, target, mode, only_cheap)\n     }\n       \n   preexpand_calls (exp);\n-  if (subtarget == 0 || GET_CODE (subtarget) != REG\n-      || GET_MODE (subtarget) != operand_mode\n+  if (! get_subtarget (target)\n       || ! safe_from_p (subtarget, arg1, 1))\n     subtarget = 0;\n "}, {"sha": "e780587e8ccc128037e17771561f6077ea593a83", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=296b4ed9cb306c649b9ebbfabe43f9b0ae30f1bc", "patch": "@@ -2124,8 +2124,9 @@ compile_file (name)\n #endif\n     }\n \n-  if (ggc_p)\n+  if (ggc_p && name != 0)\n     name = ggc_alloc_string (name, strlen (name));\n+\n   input_filename = name;\n \n   /* Put an entry on the input file stack for the main input file.  */"}]}