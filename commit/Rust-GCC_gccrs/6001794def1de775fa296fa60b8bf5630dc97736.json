{"sha": "6001794def1de775fa296fa60b8bf5630dc97736", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwMTc5NGRlZjFkZTc3NWZhMjk2ZmE2MGI4YmY1NjMwZGM5NzczNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-01T01:15:07Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-01T01:15:07Z"}, "message": "combine.c (distribute_notes): Don't bother REG_WAS_0.\n\n\t* combine.c (distribute_notes): Don't bother REG_WAS_0.\n\t* cse.c (cse_insn): Likewise.\n\t* final.c (final_scan_insn): Likewise.\n\t* jump.c (duplicate_loop_exit_test): Likewise.\n\t* rtl.c (reg_note_name): Remove REG_WAS_0.\n\t* rtl.h (REG_WAS_0): Remove.\n\t* unroll.c (final_reg_note_copy): Don't bother REG_WAS_0.\n\t* config/avr/avr.c (output_movqi): Don't use reg_was_0.\n\t(output_movhi): Likewise.\n\t(output_movsisf): Likewise.\n\t(reg_was_0): Remove.\n\t* config/m68hc11/m68hc11.c (m68hc11_gen_movhi): Don't use\n\tREG_WAS_0.\n\t(m68hc11_gen_movqi): Likewise.\n\t* config/vax/vax-protos.h: Remove the prototype for\n\treg_was_0_p.\n\t* config/vax/vax.c (follows_p): Remove.\n\t(reg_was_0_p): Likewise.\n\t* config/vax/vax.md (movsi): Don't use reg_was_0_p.\n\t(movhi): Likewise.\n\t(movqi): Likewise.\n\t* doc/rtl.texi (REG_WAS_0): Remove.\n\nFrom-SVN: r68753", "tree": {"sha": "5598774dfea689770b311deffdc2ccd8112d6016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5598774dfea689770b311deffdc2ccd8112d6016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6001794def1de775fa296fa60b8bf5630dc97736", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6001794def1de775fa296fa60b8bf5630dc97736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6001794def1de775fa296fa60b8bf5630dc97736", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6001794def1de775fa296fa60b8bf5630dc97736/comments", "author": null, "committer": null, "parents": [{"sha": "7d896ee96b213c6e77acd70f44bfb18d1a72c905", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d896ee96b213c6e77acd70f44bfb18d1a72c905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d896ee96b213c6e77acd70f44bfb18d1a72c905"}], "stats": {"total": 344, "additions": 52, "deletions": 292}, "files": [{"sha": "a17e655b34a693ab541326d4a3eb6743cd271675", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -1,3 +1,28 @@\n+2003-06-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* combine.c (distribute_notes): Don't bother REG_WAS_0.\n+\t* cse.c (cse_insn): Likewise.\n+\t* final.c (final_scan_insn): Likewise.\n+\t* jump.c (duplicate_loop_exit_test): Likewise.\n+\t* rtl.c (reg_note_name): Remove REG_WAS_0.\n+\t* rtl.h (REG_WAS_0): Remove.\n+\t* unroll.c (final_reg_note_copy): Don't bother REG_WAS_0.\n+\t* config/avr/avr.c (output_movqi): Don't use reg_was_0.\n+\t(output_movhi): Likewise.\n+\t(output_movsisf): Likewise.\n+\t(reg_was_0): Remove.\n+\t* config/m68hc11/m68hc11.c (m68hc11_gen_movhi): Don't use\n+\tREG_WAS_0.\n+\t(m68hc11_gen_movqi): Likewise.\n+\t* config/vax/vax-protos.h: Remove the prototype for\n+\treg_was_0_p.\n+\t* config/vax/vax.c (follows_p): Remove.\n+\t(reg_was_0_p): Likewise.\n+\t* config/vax/vax.md (movsi): Don't use reg_was_0_p.\n+\t(movhi): Likewise.\n+\t(movqi): Likewise.\n+\t* doc/rtl.texi (REG_WAS_0): Remove.\n+\n 2003-06-30  Mark Mitchell  <mark@codesourcery.com>\n \n \t* config/rs6000/spe.h (__ev_set_spefscr_frmc): Set the flag."}, {"sha": "b0d21c0fad1f55abdb0c719e2fddb36e663debe2", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -12605,8 +12605,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t  break;\n \n \tcase REG_NONNEG:\n-\tcase REG_WAS_0:\n-\t  /* These notes say something about the value of a register prior\n+\t  /* This note says something about the value of a register prior\n \t     to the execution of an insn.  It is too much trouble to see\n \t     if the note is still correct in all situations.  It is better\n \t     to simply delete it.  */"}, {"sha": "432dd538ae6c68cb7de39e27784d1a93d57a8ac8", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 13, "deletions": 113, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -58,7 +58,6 @@ static int    out_adj_frame_ptr    PARAMS ((FILE *, int));\n static int    out_set_stack_ptr    PARAMS ((FILE *, int, int));\n static RTX_CODE compare_condition  PARAMS ((rtx insn));\n static int    compare_sign_p       PARAMS ((rtx insn));\n-static int    reg_was_0            PARAMS ((rtx insn, rtx op));\n static tree   avr_handle_progmem_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree   avr_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n const struct attribute_spec avr_attribute_table[];\n@@ -1612,19 +1611,13 @@ output_movqi (insn, operands, l)\n \t\treturn AS1 (clr,%0);\n \t      else if (src == const1_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    return AS1 (inc,%0 ; reg_was_0);\n-\n \t\t  *l = 2;\n \t\t  return (AS1 (clr,%0) CR_TAB\n \t\t\t  AS1 (inc,%0));\n \t\t}\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    return AS1 (dec,%0 ; reg_was_0);\n-\n \t\t  *l = 2;\n \t\t  return (AS1 (clr,%0) CR_TAB\n \t\t\t  AS1 (dec,%0));\n@@ -1635,19 +1628,10 @@ output_movqi (insn, operands, l)\n \n \t\t  if (bit_nr >= 0)\n \t\t    {\n-\t\t      if (reg_was_0 (insn, dest))\n-\t\t\t{\n-\t\t\t  *l = 2;\n-\t\t\t  if (!real_l)\n-\t\t\t    output_asm_insn (\"set ; reg_was_0\", operands);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  *l = 3;\n-\t\t\t  if (!real_l)\n-\t\t\t    output_asm_insn ((AS1 (clr,%0) CR_TAB\n-\t\t\t\t\t      \"set\"), operands);\n-\t\t\t}\n+\t\t      *l = 3;\n+\t\t      if (!real_l)\n+\t\t\toutput_asm_insn ((AS1 (clr,%0) CR_TAB\n+\t\t\t\t\t  \"set\"), operands);\n \t\t      if (!real_l)\n \t\t\tavr_output_bld (operands, bit_nr);\n \n@@ -1753,13 +1737,6 @@ output_movhi (insn, operands, l)\n \t{\n \t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n \t    {\n-\t      if (byte_immediate_operand (src, HImode)\n-\t\t  && reg_was_0 (insn, dest))\n-\t\t{\n-\t\t  *l = 1;\n-\t\t  return (AS2 (ldi,%A0,lo8(%1) ; reg_was_0));\n-\t\t}\n-\n \t      *l = 2;\n \t      return (AS2 (ldi,%A0,lo8(%1)) CR_TAB\n \t\t      AS2 (ldi,%B0,hi8(%1)));\n@@ -1775,12 +1752,6 @@ output_movhi (insn, operands, l)\n \t\t}\n \t      else if (src == const1_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    {\n-\t\t      *l = 1;\n-\t\t      return AS1 (inc,%0 ; reg_was_0);\n-\t\t    }\n-\n \t\t  *l = 3;\n \t\t  return (AS1 (clr,%A0) CR_TAB\n \t\t\t  AS1 (clr,%B0) CR_TAB\n@@ -1789,13 +1760,6 @@ output_movhi (insn, operands, l)\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    {\n-\t\t      *l = 2;\n-\t\t      return (AS1 (dec,%A0 ; reg_was_0) CR_TAB\n-\t\t\t      AS1 (dec,%B0));\n-\t\t    }\n-\n \t\t  *l = 3;\n \t\t  return (AS1 (clr,%0)  CR_TAB\n \t\t\t  AS1 (dec,%A0) CR_TAB\n@@ -1807,20 +1771,11 @@ output_movhi (insn, operands, l)\n \n \t\t  if (bit_nr >= 0)\n \t\t    {\n-\t\t      if (reg_was_0 (insn, dest))\n-\t\t\t{\n-\t\t\t  *l = 2;\n-\t\t\t  if (!real_l)\n-\t\t\t    output_asm_insn (\"set ; reg_was_0\", operands);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  *l = 4;\n-\t\t\t  if (!real_l)\n-\t\t\t    output_asm_insn ((AS1 (clr,%A0) CR_TAB\n-\t\t\t\t\t      AS1 (clr,%B0) CR_TAB\n-\t\t\t\t\t      \"set\"), operands);\n-\t\t\t}\n+\t\t      *l = 4;\n+\t\t      if (!real_l)\n+\t\t\toutput_asm_insn ((AS1 (clr,%A0) CR_TAB\n+\t\t\t\t\t  AS1 (clr,%B0) CR_TAB\n+\t\t\t\t\t  \"set\"), operands);\n \t\t      if (!real_l)\n \t\t\tavr_output_bld (operands, bit_nr);\n \n@@ -2452,13 +2407,6 @@ output_movsisf(insn, operands, l)\n \t{\n \t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n \t    {\n-\t      if (byte_immediate_operand (src, SImode)\n-\t\t  && reg_was_0 (insn, dest))\n-\t\t{\n-\t\t  *l = 1;\n-\t\t  return (AS2 (ldi,%A0,lo8(%1) ; reg_was_0));\n-\t\t}\n-\n \t      *l = 4;\n \t      return (AS2 (ldi,%A0,lo8(%1))  CR_TAB\n \t\t      AS2 (ldi,%B0,hi8(%1))  CR_TAB\n@@ -2484,11 +2432,6 @@ output_movsisf(insn, operands, l)\n \t\t}\n \t      else if (src == const1_rtx)\n \t\t{\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    {\n-\t\t      *l = 1;\n-\t\t      return AS1 (inc,%A0 ; reg_was_0);\n-\t\t    }\n \t\t  if (!real_l)\n \t\t    output_asm_insn (clr_op0, operands);\n \t\t  *l = AVR_ENHANCED ? 4 : 5;\n@@ -2497,21 +2440,6 @@ output_movsisf(insn, operands, l)\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    {\n-\t\t      if (AVR_ENHANCED)\n-\t\t\t{\n-\t\t\t  *l = 3;\n-\t\t\t  return (AS1 (dec,%A0) CR_TAB\n-\t\t\t\t  AS1 (dec,%B0) CR_TAB\n-\t\t\t\t  AS2 (movw,%C0,%A0));\n-\t\t\t}\n-\t\t      *l = 4;\n-\t\t      return (AS1 (dec,%D0 ; reg_was_0) CR_TAB\n-\t\t\t      AS1 (dec,%C0)             CR_TAB\n-\t\t\t      AS1 (dec,%B0)             CR_TAB\n-\t\t\t      AS1 (dec,%A0));\n-\t\t    }\n \t\t  if (AVR_ENHANCED)\n \t\t    {\n \t\t      *l = 4;\n@@ -2533,20 +2461,11 @@ output_movsisf(insn, operands, l)\n \n \t\t  if (bit_nr >= 0)\n \t\t    {\n-\t\t      if (reg_was_0 (insn, dest))\n-\t\t\t{\n-\t\t\t  *l = 2;\n-\t\t\t  if (!real_l)\n-\t\t\t    output_asm_insn (\"set ; reg_was_0\", operands);\n-\t\t\t}\n-\t\t      else\n+\t\t      *l = AVR_ENHANCED ? 5 : 6;\n+\t\t      if (!real_l)\n \t\t\t{\n-\t\t\t  *l = AVR_ENHANCED ? 5 : 6;\n-\t\t\t  if (!real_l)\n-\t\t\t    {\n-\t\t\t      output_asm_insn (clr_op0, operands);\n-\t\t\t      output_asm_insn (\"set\", operands);\n-\t\t\t    }\n+\t\t\t  output_asm_insn (clr_op0, operands);\n+\t\t\t  output_asm_insn (\"set\", operands);\n \t\t\t}\n \t\t      if (!real_l)\n \t\t\tavr_output_bld (operands, bit_nr);\n@@ -5401,25 +5320,6 @@ avr_hard_regno_mode_ok (regno, mode)\n   return !(regno & 1);\n }\n \n-/* Returns 1 if we know register operand OP was 0 before INSN.  */\n-\n-static int\n-reg_was_0 (insn, op)\n-     rtx insn;\n-     rtx op;\n-{\n-  rtx link;\n-  return (optimize > 0 && insn && op && REG_P (op)\n-\t  && (link = find_reg_note (insn, REG_WAS_0, 0))\n-\t  /* Make sure the insn that stored the 0 is still present.  */\n-\t  && ! INSN_DELETED_P (XEXP (link, 0))\n-\t  && GET_CODE (XEXP (link, 0)) != NOTE\n-\t  /* Make sure cross jumping didn't happen here.  */\n-\t  && no_labels_between_p (XEXP (link, 0), insn)\n-\t  /* Make sure the reg hasn't been clobbered.  */\n-\t  && ! reg_set_between_p (op, XEXP (link, 0), insn));\n-}\n-\n /* Returns 1 if X is a valid address for an I/O register of size SIZE\n    (1 or 2).  Used for lds/sts -> in/out optimization.  Add 0x20 to SIZE\n    to check for the lower half of I/O space (for cbi/sbi/sbic/sbis).  */"}, {"sha": "7fc3a6412f79895a7147c89deb49444f4120d678", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -3295,17 +3295,6 @@ m68hc11_gen_movhi (insn, operands)\n \t{\n \t  if (SP_REG_P (operands[0]))\n \t    output_asm_insn (\"lds\\t%1\", operands);\n-\t  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */\n-                   && !D_REG_P (operands[0])\n-                   && GET_CODE (operands[1]) == CONST_INT\n-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)\n-                   && find_reg_note (insn, REG_WAS_0, 0))\n-            {\n-              if (INTVAL (operands[1]) == 1)\n-                output_asm_insn (\"in%0\", operands);\n-              else\n-                output_asm_insn (\"de%0\", operands);\n-            }\n \t  else\n \t    output_asm_insn (\"ld%0\\t%1\", operands);\n \t}\n@@ -3489,16 +3478,6 @@ m68hc11_gen_movhi (insn, operands)\n \t      cc_status = cc_prev_status;\n \t      output_asm_insn (\"tsx\", operands);\n \t    }\n-\t  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */\n-                   && GET_CODE (operands[1]) == CONST_INT\n-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)\n-                   && find_reg_note (insn, REG_WAS_0, 0))\n-            {\n-              if (INTVAL (operands[1]) == 1)\n-                output_asm_insn (\"in%0\", operands);\n-              else\n-                output_asm_insn (\"de%0\", operands);\n-            }\n \t  else\n \t    {\n \t      output_asm_insn (\"ldx\\t%1\", operands);\n@@ -3547,16 +3526,6 @@ m68hc11_gen_movhi (insn, operands)\n \t      cc_status = cc_prev_status;\n \t      output_asm_insn (\"tsy\", operands);\n \t    }\n-\t  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */\n-                   && GET_CODE (operands[1]) == CONST_INT\n-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)\n-                   && find_reg_note (insn, REG_WAS_0, 0))\n-            {\n-              if (INTVAL (operands[1]) == 1)\n-                output_asm_insn (\"in%0\", operands);\n-              else\n-                output_asm_insn (\"de%0\", operands);\n-            }\n           else\n \t    {\n \t      output_asm_insn (\"ldy\\t%1\", operands);\n@@ -3797,16 +3766,6 @@ m68hc11_gen_movqi (insn, operands)\n \t\t  output_asm_insn (\"ldab\\t%T0\", operands);\n \t\t}\n \t    }\n-\t  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */\n-                   && GET_CODE (operands[1]) == CONST_INT\n-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)\n-                   && find_reg_note (insn, REG_WAS_0, 0))\n-            {\n-              if (INTVAL (operands[1]) == 1)\n-                output_asm_insn (\"inc%b0\", operands);\n-              else\n-                output_asm_insn (\"dec%b0\", operands);\n-            }          \n \t  else if (!DB_REG_P (operands[1]) && !D_REG_P (operands[1])\n \t\t   && !DA_REG_P (operands[1]))\n \t    {"}, {"sha": "199db19af55cd2c710861d15780d07525ec05128", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -25,7 +25,6 @@ extern const char *rev_cond_name PARAMS ((rtx));\n extern void split_quadword_operands PARAMS ((rtx *, rtx *, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern int vax_float_literal PARAMS ((rtx));\n-extern int reg_was_0_p PARAMS ((rtx, rtx));\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "1b94beef01dd172e62c8c6c5a9e501c0fb1d0fc8", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n-static int follows_p PARAMS ((rtx, rtx));\n static void vax_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void vax_file_start PARAMS ((void));\n static void vax_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n@@ -755,41 +754,6 @@ vax_rtx_costs (x, code, outer_code, total)\n   return true;\n }\n \f\n-/* Return 1 if insn A follows B.  */\n-\n-static int\n-follows_p (a, b)\n-     rtx a, b;\n-{\n-  register rtx p;\n-\n-  for (p = a; p != b; p = NEXT_INSN (p))\n-    if (! p)\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* Returns 1 if we know operand OP was 0 before INSN.  */\n-\n-int\n-reg_was_0_p (insn, op)\n-     rtx insn, op;\n-{\n-  rtx link;\n-\n-  return ((link = find_reg_note (insn, REG_WAS_0, 0))\n-\t  /* Make sure the insn that stored the 0 is still present\n-\t     and doesn't follow INSN in the insn sequence.  */\n-\t  && ! INSN_DELETED_P (XEXP (link, 0))\n-\t  && GET_CODE (XEXP (link, 0)) != NOTE\n-\t  && ! follows_p (XEXP (link, 0), insn)\n-\t  /* Make sure cross jumping didn't happen here.  */\n-\t  && no_labels_between_p (XEXP (link, 0), insn)\n-\t  /* Make sure the reg hasn't been clobbered.  */\n-\t  && ! reg_set_between_p (op, XEXP (link, 0), insn));\n-}\n-\n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.\n \t.mask\t^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>  #conservative entry mask"}, {"sha": "7027604ed9e0984b36ad623c869940f9266d7416", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -193,9 +193,6 @@\n   \"\"\n   \"*\n {\n-  if (operands[1] == const1_rtx && reg_was_0_p (insn, operands[0]))\n-    return \\\"incl %0\\\";\n-\n   if (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n     {\n       if (push_operand (operands[0], SImode))\n@@ -230,9 +227,6 @@\n   \"\"\n   \"*\n {\n-  if (operands[1] == const1_rtx && reg_was_0_p (insn, operands[0]))\n-    return \\\"incw %0\\\";\n-\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n       int i = INTVAL (operands[1]);\n@@ -275,9 +269,6 @@\n   \"\"\n   \"*\n {\n-  if (operands[1] == const1_rtx && reg_was_0_p (insn, operands[0]))\n-    return \\\"incb %0\\\";\n-\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n       int i = INTVAL (operands[1]);"}, {"sha": "5e6c9e40b17e3a2b2bc7da42d55298df75ce2896", "filename": "gcc/cse.c", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -5598,41 +5598,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t making a new one if one does not already exist.  */\n \t      set_unique_reg_note (insn, REG_EQUAL, src_const);\n \t    }\n-\n-\t  /* If storing a constant value in a register that\n-\t     previously held the constant value 0,\n-\t     record this fact with a REG_WAS_0 note on this insn.\n-\n-\t     Note that the *register* is required to have previously held 0,\n-\t     not just any register in the quantity and we must point to the\n-\t     insn that set that register to zero.\n-\n-\t     Rather than track each register individually, we just see if\n-\t     the last set for this quantity was for this register.  */\n-\n-\t  if (REGNO_QTY_VALID_P (REGNO (dest)))\n-\t    {\n-\t      int dest_q = REG_QTY (REGNO (dest));\n-\t      struct qty_table_elem *dest_ent = &qty_table[dest_q];\n-\n-\t      if (dest_ent->const_rtx == const0_rtx)\n-\t\t{\n-\t\t  /* See if we previously had a REG_WAS_0 note.  */\n-\t\t  rtx note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n-\t\t  rtx const_insn = dest_ent->const_insn;\n-\n-\t\t  if ((tem = single_set (const_insn)) != 0\n-\t\t      && rtx_equal_p (SET_DEST (tem), dest))\n-\t\t    {\n-\t\t      if (note)\n-\t\t\tXEXP (note, 0) = const_insn;\n-\t\t      else\n-\t\t\tREG_NOTES (insn)\n-\t\t\t  = gen_rtx_INSN_LIST (REG_WAS_0, const_insn,\n-\t\t\t\t\t       REG_NOTES (insn));\n-\t\t    }\n-\t\t}\n-\t    }\n \t}\n \n       /* Now deal with the destination.  */\n@@ -6238,20 +6203,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t      validate_change (insn, &SET_SRC (sets[0].rtl), dest, 1);\n \t      apply_change_group ();\n \n-\t      /* If there was a REG_WAS_0 note on PREV, remove it.  Move\n-\t\t any REG_WAS_0 note on INSN to PREV.  */\n-\t      note = find_reg_note (prev, REG_WAS_0, NULL_RTX);\n-\t      if (note)\n-\t\tremove_note (prev, note);\n-\n-\t      note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n-\t      if (note)\n-\t\t{\n-\t\t  remove_note (insn, note);\n-\t\t  XEXP (note, 1) = REG_NOTES (prev);\n-\t\t  REG_NOTES (prev) = note;\n-\t\t}\n-\n \t      /* If INSN has a REG_EQUAL note, and this note mentions\n \t\t REG0, then we must delete it, because the value in\n \t\t REG0 has changed.  If the note's value is REG1, we must"}, {"sha": "ca3c2de9700abce186e7861796fef0767446e841", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -3354,13 +3354,6 @@ destination register.\n Thus, compiler passes prior to register allocation need only check for\n @code{REG_EQUAL} notes and passes subsequent to register allocation\n need only check for @code{REG_EQUIV} notes.\n-\n-@findex REG_WAS_0\n-@item REG_WAS_0\n-The single output of this insn contained zero before this insn.\n-@var{op} is the insn that set it to zero.  You can rely on this note if\n-it is present and @var{op} has not been deleted or turned into a @code{note};\n-its absence implies nothing.\n @end table\n \n These notes describe linkages between insns.  They occur in pairs: one"}, {"sha": "5ce81afa145dec287edd42f193e43139b7341fb7", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -2503,9 +2503,9 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n #endif\n \n #if 0\n-\t/* It's not at all clear why we did this and doing so interferes\n-\t   with tests we'd like to do to use REG_WAS_0 notes, so let's try\n-\t   with this out.  */\n+\t/* It's not at all clear why we did this and doing so used to\n+\t   interfere with tests that used REG_WAS_0 notes, which are\n+\t   now gone, so let's try with this out.  */\n \n \t/* Mark this insn as having been output.  */\n \tINSN_DELETED_P (insn) = 1;"}, {"sha": "693e274093145121b1e07caf5d8a35ed067c89c1", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -357,10 +357,6 @@ duplicate_loop_exit_test (loop_start)\n \t  break;\n \tcase JUMP_INSN:\n \tcase INSN:\n-\t  /* The code below would grossly mishandle REG_WAS_0 notes,\n-\t     so get rid of them here.  */\n-\t  while ((p = find_reg_note (insn, REG_WAS_0, NULL_RTX)) != 0)\n-\t    remove_note (insn, p);\n \t  if (++num_insns > 20\n \t      || find_reg_note (insn, REG_RETVAL, NULL_RTX)\n \t      || find_reg_note (insn, REG_LIBCALL, NULL_RTX))"}, {"sha": "852b8ca18627fdbd448bf4924e122630ae200add", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -225,7 +225,7 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n const char * const reg_note_name[] =\n {\n   \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_EQUAL\",\n-  \"REG_WAS_0\", \"REG_RETVAL\", \"REG_LIBCALL\", \"REG_NONNEG\",\n+  \"REG_RETVAL\", \"REG_LIBCALL\", \"REG_NONNEG\",\n   \"REG_NO_CONFLICT\", \"REG_UNUSED\", \"REG_CC_SETTER\", \"REG_CC_USER\",\n   \"REG_LABEL\", \"REG_DEP_ANTI\", \"REG_DEP_OUTPUT\", \"REG_BR_PROB\",\n   \"REG_NOALIAS\", \"REG_SAVE_AREA\", \"REG_BR_PRED\","}, {"sha": "bba530181ba08828e61526497eeceee1e4128ef3", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -633,12 +633,6 @@ enum reg_note\n      but it can be used for cse.  */\n   REG_EQUAL,\n \n-  /* The register set in this insn held 0 before the insn.  The contents of\n-     the note is the insn that stored the 0.  If that insn is deleted or\n-     patched to a NOTE, the REG_WAS_0 is inoperative.  The REG_WAS_0 note\n-     is actually an INSN_LIST, not an EXPR_LIST.  */\n-  REG_WAS_0,\n-\n   /* This insn copies the return-value of a library call out of the hard reg\n      for return values.  This note is actually an INSN_LIST and it points to\n      the first insn involved in setting up arguments for the call.  flow.c"}, {"sha": "84ace299e4ee8c1c50a3be05697ed7bbc9c524ea", "filename": "gcc/unroll.c", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001794def1de775fa296fa60b8bf5630dc97736/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=6001794def1de775fa296fa60b8bf5630dc97736", "patch": "@@ -1735,29 +1735,18 @@ final_reg_note_copy (notesp, map)\n \n       if (GET_CODE (note) == INSN_LIST)\n \t{\n-\t  /* Sometimes, we have a REG_WAS_0 note that points to a\n-\t     deleted instruction.  In that case, we can just delete the\n-\t     note.  */\n-\t  if (REG_NOTE_KIND (note) == REG_WAS_0)\n+\t  rtx insn = map->insn_map[INSN_UID (XEXP (note, 0))];\n+\n+\t  /* If we failed to remap the note, something is awry.\n+\t     Allow REG_LABEL as it may reference label outside\n+\t     the unrolled loop.  */\n+\t  if (!insn)\n \t    {\n-\t      *notesp = XEXP (note, 1);\n-\t      continue;\n+\t      if (REG_NOTE_KIND (note) != REG_LABEL)\n+\t\tabort ();\n \t    }\n \t  else\n-\t    {\n-\t      rtx insn = map->insn_map[INSN_UID (XEXP (note, 0))];\n-\n-\t      /* If we failed to remap the note, something is awry.\n-\t\t Allow REG_LABEL as it may reference label outside\n-\t\t the unrolled loop.  */\n-\t      if (!insn)\n-\t\t{\n-\t\t  if (REG_NOTE_KIND (note) != REG_LABEL)\n-\t\t    abort ();\n-\t\t}\n-\t      else\n-\t        XEXP (note, 0) = insn;\n-\t    }\n+\t    XEXP (note, 0) = insn;\n \t}\n \n       notesp = &XEXP (note, 1);"}]}