{"sha": "3307b9a07a3c515c6805d435e4bedada77687183", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwN2I5YTA3YTNjNTE1YzY4MDVkNDM1ZTRiZWRhZGE3NzY4NzE4Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-03-02T21:30:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-01T09:45:06Z"}, "message": "c++: C++11 range-for and ovl/lkp_iterator\n\nWe can't use C++11 range-based 'for' over a tree directly, because we don't\nknow what kind of range we want to use it as.  I suppose in some cases we\ncould guess, but it seems better to tersely make it explicit.  This patch\nadds range adaptors ovl_range and lkp_range for use as the range of a\nrange-for, e.g.\n\n  for (tree fn : lkp_range (fns)) { ... }\n\nThis patch also removes the private copy ops from ovl_iterator; it's\nnecessary for range-for, and these are effectively C++ forward_iterators,\nwhich allow copying, so I don't see a reason to prevent it.  A bit more\nwould need to be done to make them actually conform as C++11 forward\niterators, but I don't think we particularly want to #include <iterator>\nyet.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (class ovl_iterator): Allow copying.  Add op==.\n\t(class ovl_range, class lkp_range): New.\n\t* call.c (build_op_call_1, add_candidates): Use them.\n\t(build_op_delete_call, has_trivial_copy_assign_p): Likewise.\n\t(has_trivial_copy_p): Likewise.\n\t* class.c (handle_using_decl, get_basefndecls): Likewise.\n\t(maybe_warn_about_overly_private_class): Likewise.\n\t(warn_hidden, add_implicitly_declared_members): Likewise.\n\t(check_methods, clone_constructors_and_destructors): Likewise.\n\t(type_has_user_nondefault_constructor): Likewise.", "tree": {"sha": "b78aa228c7c0c568b647be2091a969c86cd736df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b78aa228c7c0c568b647be2091a969c86cd736df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3307b9a07a3c515c6805d435e4bedada77687183", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3307b9a07a3c515c6805d435e4bedada77687183", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3307b9a07a3c515c6805d435e4bedada77687183", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3307b9a07a3c515c6805d435e4bedada77687183/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c65858787dc52b65b26fa7018587c01510f442c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c65858787dc52b65b26fa7018587c01510f442c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c65858787dc52b65b26fa7018587c01510f442c"}], "stats": {"total": 102, "additions": 55, "deletions": 47}, "files": [{"sha": "57bac05fe70bc5a73ff3223faadd033a00d06da4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3307b9a07a3c515c6805d435e4bedada77687183/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3307b9a07a3c515c6805d435e4bedada77687183/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3307b9a07a3c515c6805d435e4bedada77687183", "patch": "@@ -4914,10 +4914,8 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \t  || TYPE_REFFN_P (totype)\n \t  || (TYPE_REF_P (totype)\n \t      && TYPE_PTRFN_P (TREE_TYPE (totype))))\n-\tfor (ovl_iterator iter (TREE_VALUE (convs)); iter; ++iter)\n+\tfor (tree fn : ovl_range (TREE_VALUE (convs)))\n \t  {\n-\t    tree fn = *iter;\n-\n \t    if (DECL_NONCONVERTING_P (fn))\n \t      continue;\n \n@@ -5981,10 +5979,8 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n     which = non_templates;\n \n  again:\n-  for (lkp_iterator iter (fns); iter; ++iter)\n+  for (tree fn : lkp_range (fns))\n     {\n-      fn = *iter;\n-\n       if (check_converting && DECL_NONCONVERTING_P (fn))\n \tcontinue;\n       if (check_list_ctor && !is_list_ctor (fn))\n@@ -7016,10 +7012,8 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t     the usual deallocation function, so we shouldn't complain\n \t     about using the operator delete (void *, size_t).  */\n \t  if (DECL_CLASS_SCOPE_P (fn))\n-\t    for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (fns));\n-\t\t iter; ++iter)\n+\t    for (tree elt : lkp_range (MAYBE_BASELINK_FUNCTIONS (fns)))\n \t      {\n-\t\ttree elt = *iter;\n \t\tif (usual_deallocation_fn_p (elt)\n \t\t    && FUNCTION_ARG_CHAIN (elt) == void_list_node)\n \t\t  goto ok;\n@@ -7062,9 +7056,8 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n        allocation function. If the lookup finds a single matching\n        deallocation function, that function will be called; otherwise, no\n        deallocation function will be called.\"  */\n-    for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (fns)); iter; ++iter)\n+    for (tree elt : lkp_range (MAYBE_BASELINK_FUNCTIONS (fns)))\n       {\n-\ttree elt = *iter;\n \tdealloc_info di_elt;\n \tif (usual_deallocation_fn_p (elt, &di_elt))\n \t  {\n@@ -9669,10 +9662,8 @@ has_trivial_copy_assign_p (tree type, bool access, bool *hasassign)\n   /* Iterate over overloads of the assignment operator, checking\n      accessible copy assignments for triviality.  */\n \n-  for (ovl_iterator oi (fns); oi; ++oi)\n+  for (tree f : ovl_range (fns))\n     {\n-      tree f = *oi;\n-\n       /* Skip operators that aren't copy assignments.  */\n       if (!copy_fn_p (f))\n \tcontinue;\n@@ -9715,10 +9706,8 @@ has_trivial_copy_p (tree type, bool access, bool hasctor[2])\n   tree fns = get_class_binding (type, complete_ctor_identifier);\n   bool all_trivial = true;\n \n-  for (ovl_iterator oi (fns); oi; ++oi)\n+  for (tree f : ovl_range (fns))\n     {\n-      tree f = *oi;\n-\n       /* Skip template constructors.  */\n       if (TREE_CODE (f) != FUNCTION_DECL)\n \tcontinue;"}, {"sha": "66bc1eea682258e25f3413241ffb84cee35ffb4c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3307b9a07a3c515c6805d435e4bedada77687183/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3307b9a07a3c515c6805d435e4bedada77687183/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3307b9a07a3c515c6805d435e4bedada77687183", "patch": "@@ -1347,10 +1347,10 @@ handle_using_decl (tree using_decl, tree t)\n \n   /* Make type T see field decl FDECL with access ACCESS.  */\n   if (flist)\n-    for (ovl_iterator iter (flist); iter; ++iter)\n+    for (tree f : ovl_range (flist))\n       {\n-\tadd_method (t, *iter, true);\n-\talter_access (t, *iter, access);\n+\tadd_method (t, f, true);\n+\talter_access (t, f, access);\n       }\n   else if (USING_DECL_UNRELATED_P (using_decl))\n     {\n@@ -2259,18 +2259,20 @@ maybe_warn_about_overly_private_class (tree t)\n       if (!TYPE_HAS_COPY_CTOR (t))\n \tnonprivate_ctor = true;\n       else\n-\tfor (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t));\n-\t     !nonprivate_ctor && iter; ++iter)\n-\t  if (TREE_PRIVATE (*iter))\n+\tfor (tree fn : ovl_range (CLASSTYPE_CONSTRUCTORS (t)))\n+\t  if (TREE_PRIVATE (fn))\n \t    continue;\n-\t  else if (copy_fn_p (*iter) || move_fn_p (*iter))\n+\t  else if (copy_fn_p (fn) || move_fn_p (fn))\n \t    /* Ideally, we wouldn't count any constructor that takes\n \t       an argument of the class type as a parameter, because\n \t       such things cannot be used to construct an instance of\n \t       the class unless you already have one.  */\n-\t    copy_or_move = *iter;\n+\t    copy_or_move = fn;\n \t  else\n-\t    nonprivate_ctor = true;\n+\t    {\n+\t      nonprivate_ctor = true;\n+\t      break;\n+\t    }\n \n       if (!nonprivate_ctor)\n \t{\n@@ -2876,10 +2878,8 @@ get_basefndecls (tree name, tree t, vec<tree> *base_fndecls)\n   bool found_decls = false;\n \n   /* Find virtual functions in T with the indicated NAME.  */\n-  for (ovl_iterator iter (get_class_binding (t, name)); iter; ++iter)\n+  for (tree method : ovl_range (get_class_binding (t, name)))\n     {\n-      tree method = *iter;\n-\n       if (TREE_CODE (method) == FUNCTION_DECL && DECL_VINDEX (method))\n \t{\n \t  base_fndecls->safe_push (method);\n@@ -2988,9 +2988,8 @@ warn_hidden (tree t)\n \t  continue;\n \n \t/* Remove any overridden functions.  */\n-\tfor (ovl_iterator iter (fns); iter; ++iter)\n+\tfor (tree fndecl : ovl_range (fns))\n \t  {\n-\t    tree fndecl = *iter;\n \t    if (TREE_CODE (fndecl) == FUNCTION_DECL\n \t\t&& DECL_VINDEX (fndecl))\n \t      {\n@@ -3334,8 +3333,8 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n \t  tree ctor_list = decl;\n \t  location_t loc = input_location;\n \t  input_location = DECL_SOURCE_LOCATION (using_decl);\n-\t  for (ovl_iterator iter (ctor_list); iter; ++iter)\n-\t    one_inherited_ctor (*iter, t, using_decl);\n+\t  for (tree fn : ovl_range (ctor_list))\n+\t    one_inherited_ctor (fn, t, using_decl);\n \t  *access_decls = TREE_CHAIN (*access_decls);\n \t  input_location = loc;\n \t}\n@@ -4751,9 +4750,8 @@ check_methods (tree t)\n \tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = true;\n     }\n \n-  for (ovl_iterator i (CLASSTYPE_CONSTRUCTORS (t)); i; ++i)\n+  for (tree fn : ovl_range (CLASSTYPE_CONSTRUCTORS (t)))\n     {\n-      tree fn = *i;\n       if (!user_provided_p (fn))\n \t/* Might be trivial.  */;\n       else if (copy_fn_p (fn))\n@@ -4762,10 +4760,8 @@ check_methods (tree t)\n \tTYPE_HAS_COMPLEX_MOVE_CTOR (t) = true;\n     }\n \n-  for (ovl_iterator i (get_class_binding_direct (t, assign_op_identifier));\n-       i; ++i)\n+  for (tree fn : ovl_range (get_class_binding_direct (t, assign_op_identifier)))\n     {\n-      tree fn = *i;\n       if (!user_provided_p (fn))\n \t/* Might be trivial.  */;\n       else if (copy_fn_p (fn))\n@@ -5107,8 +5103,8 @@ clone_constructors_and_destructors (tree t)\n {\n   /* We do not need to propagate the usingness to the clone, at this\n      point that is not needed.  */\n-  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n-    clone_cdtor (*iter, /*update_methods=*/true);\n+  for (tree fn : ovl_range (CLASSTYPE_CONSTRUCTORS (t)))\n+    clone_cdtor (fn, /*update_methods=*/true);\n \n   if (tree dtor = CLASSTYPE_DESTRUCTOR (t))\n     clone_cdtor (dtor, /*update_methods=*/true);\n@@ -5283,9 +5279,8 @@ type_has_user_nondefault_constructor (tree t)\n   if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n     return false;\n \n-  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+  for (tree fn : ovl_range (CLASSTYPE_CONSTRUCTORS (t)))\n     {\n-      tree fn = *iter;\n       if (user_provided_p (fn)\n \t  && (TREE_CODE (fn) == TEMPLATE_DECL\n \t      || (skip_artificial_parms_for (fn, DECL_ARGUMENTS (fn))"}, {"sha": "a08867aea628cad0d8dcf2f0a954f646f2144032", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3307b9a07a3c515c6805d435e4bedada77687183/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3307b9a07a3c515c6805d435e4bedada77687183/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3307b9a07a3c515c6805d435e4bedada77687183", "patch": "@@ -817,11 +817,6 @@ class ovl_iterator {\n   {\n   }\n \n- private:\n-  /* Do not duplicate.  */\n-  ovl_iterator &operator= (const ovl_iterator &);\n-  ovl_iterator (const ovl_iterator &);\n-\n  public:\n   operator bool () const\n   {\n@@ -841,6 +836,10 @@ class ovl_iterator {\n \n     return fn;\n   }\n+  bool operator== (const ovl_iterator &o) const\n+  {\n+    return ovl == o.ovl;\n+  }\n   tree get_using () const\n   {\n     gcc_checking_assert (using_p ());\n@@ -903,6 +902,19 @@ class ovl_iterator {\n   static tree reveal_node (tree ovl, tree node);\n };\n \n+/* Treat a tree as a range of ovl_iterator, e.g.\n+   for (tree f : ovl_range (fns)) { ... }  */\n+\n+class ovl_range\n+{\n+  tree t;\n+  bool allow;\n+public:\n+  explicit ovl_range (tree t, bool allow = false): t(t), allow(allow) { }\n+  ovl_iterator begin() { return ovl_iterator (t, allow); }\n+  ovl_iterator end() { return ovl_iterator (NULL_TREE, allow); }\n+};\n+\n /* Iterator over a (potentially) 2 dimensional overload, which is\n    produced by name lookup.  */\n \n@@ -935,6 +947,18 @@ class lkp_iterator : public ovl_iterator {\n   }\n };\n \n+/* Treat a tree as a range of lkp_iterator, e.g.\n+   for (tree f : lkp_range (fns)) { ... }  */\n+\n+class lkp_range\n+{\n+  tree t;\n+public:\n+  lkp_range (tree t): t(t) { }\n+  lkp_iterator begin() { return lkp_iterator (t); }\n+  lkp_iterator end() { return lkp_iterator (NULL_TREE); }\n+};\n+\n /* hash traits for declarations.  Hashes potential overload sets via\n    DECL_NAME.  */\n "}]}