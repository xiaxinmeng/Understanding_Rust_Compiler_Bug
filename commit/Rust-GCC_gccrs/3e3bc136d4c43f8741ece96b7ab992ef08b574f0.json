{"sha": "3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UzYmMxMzZkNGM0M2Y4NzQxZWNlOTZiN2FiOTkyZWYwOGI1NzRmMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T12:33:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T12:33:25Z"}, "message": "[multiple changes]\n\n2017-04-25  Claire Dross  <dross@adacore.com>\n\n\t* sem_prag.adb (Collect_Inherited_Class_Wide_Conditions): Go to\n\tultimate alias when accessing overridden operation. Indeed, if the\n\toverridden operation is itself inherited, it won't have any explicit\n\tcontract.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_warn.adb (Warn_On_Overlapping_Actuals): There can be no\n\toverlap if the two formals have different types, because formally\n\tthe corresponding actuals cannot designate the same objects.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_dim.adb (Dimensions_Of_Operand): minot cleanups: a) If\n\tdimensions are present from context, use them.\tb) If operand is\n\ta static constant rewritten as a literal, obtain the dimensions\n\tfrom the original declaration, otherwise use dimensions of type\n\testablished from context.\n\n2017-04-25  Yannick Moy  <moy@adacore.com>\n\n\t* sem_util.adb (Is_Effectively_Volatile): Protect against base type\n\tof array that is private.\n\nFrom-SVN: r247209", "tree": {"sha": "7fc4d793c27b5ee4b189cacf44036d4349abe36b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fc4d793c27b5ee4b189cacf44036d4349abe36b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/comments", "author": null, "committer": null, "parents": [{"sha": "bed3fd4637d24e27b61fbd7f366e98a211080a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed3fd4637d24e27b61fbd7f366e98a211080a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed3fd4637d24e27b61fbd7f366e98a211080a0b"}], "stats": {"total": 130, "additions": 104, "deletions": 26}, "files": [{"sha": "c13e016c5518ed73c78aa4582a64477e04a3aca2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "patch": "@@ -1,3 +1,29 @@\n+2017-04-25  Claire Dross  <dross@adacore.com>\n+\n+\t* sem_prag.adb (Collect_Inherited_Class_Wide_Conditions): Go to\n+\tultimate alias when accessing overridden operation. Indeed, if the\n+\toverridden operation is itself inherited, it won't have any explicit\n+\tcontract.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_warn.adb (Warn_On_Overlapping_Actuals): There can be no\n+\toverlap if the two formals have different types, because formally\n+\tthe corresponding actuals cannot designate the same objects.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_dim.adb (Dimensions_Of_Operand): minot cleanups: a) If\n+\tdimensions are present from context, use them.\tb) If operand is\n+\ta static constant rewritten as a literal, obtain the dimensions\n+\tfrom the original declaration, otherwise use dimensions of type\n+\testablished from context.\n+\n+2017-04-25  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_util.adb (Is_Effectively_Volatile): Protect against base type\n+\tof array that is private.\n+\n 2017-04-25  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch3.adb, exp_util.adb, sem_prag.adb, exp_ch4.adb: Minor"}, {"sha": "1e956011d51306e6345a095fb5b1879d81cb0a0c", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "patch": "@@ -1343,7 +1343,11 @@ package body Sem_Dim is\n       function Dimensions_Of_Operand (N : Node_Id) return Dimension_Type;\n       --  If the operand is a numeric literal that comes from a declared\n       --  constant, use the dimensions of the constant which were computed\n-      --  from the expression of the constant declaration.\n+      --  from the expression of the constant declaration. Otherwise the\n+      --  dimensions are those of the operand, or the type of the operand.\n+      --  This takes care of node rewritings from validity checks, where the\n+      --  dimensions of the operand itself may not be preserved, while the\n+      --  type comes from context and must have dimension information.\n \n       procedure Error_Dim_Msg_For_Binary_Op (N, L, R : Node_Id);\n       --  Error using Error_Msg_NE and Error_Msg_N at node N. Output the\n@@ -1354,13 +1358,28 @@ package body Sem_Dim is\n       ---------------------------\n \n       function Dimensions_Of_Operand (N : Node_Id) return Dimension_Type is\n+         Dims : constant Dimension_Type := Dimensions_Of (N);\n+\n       begin\n-         if Nkind (N) = N_Real_Literal\n-           and then Present (Original_Entity (N))\n-         then\n-            return Dimensions_Of (Original_Entity (N));\n+         if Exists (Dims) then\n+            return Dims;\n+\n+         elsif Is_Entity_Name (N) then\n+            return Dimensions_Of (Etype (Entity (N)));\n+\n+         elsif Nkind (N) = N_Real_Literal then\n+\n+            if Present (Original_Entity (N)) then\n+               return Dimensions_Of (Original_Entity (N));\n+\n+            else\n+               return Dimensions_Of (Etype (N));\n+            end if;\n+\n+         --  Otherwise return the default dimensions\n+\n          else\n-            return Dimensions_Of (N);\n+            return Dims;\n          end if;\n       end Dimensions_Of_Operand;\n "}, {"sha": "acaacf88566d4bb1acaa6fa1fc103d8bd9ead785", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "patch": "@@ -27915,8 +27915,12 @@ package body Sem_Prag is\n    ---------------------------------------------\n \n    procedure Collect_Inherited_Class_Wide_Conditions (Subp : Entity_Id) is\n-      Parent_Subp  : constant Entity_Id := Overridden_Operation (Subp);\n-      Prags        : constant Node_Id   := Contract (Parent_Subp);\n+      Parent_Subp : constant Entity_Id :=\n+                      Ultimate_Alias (Overridden_Operation (Subp));\n+      --  The Overridden_Operation may itself be inherited and as such have no\n+      --  explicit contract.\n+\n+      Prags        : constant Node_Id := Contract (Parent_Subp);\n       In_Spec_Expr : Boolean;\n       Installed    : Boolean;\n       Prag         : Node_Id;"}, {"sha": "1cae279da0bee166dc8d35f1401d68430f7e0396", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "patch": "@@ -12805,10 +12805,18 @@ package body Sem_Util is\n          --  effectively volatile.\n \n          elsif Is_Array_Type (Id) then\n-            return\n-              Has_Volatile_Components (Id)\n-                or else\n-              Is_Effectively_Volatile (Component_Type (Base_Type (Id)));\n+            declare\n+               Anc : Entity_Id := Base_Type (Id);\n+            begin\n+               if Ekind (Anc) in Private_Kind then\n+                  Anc := Full_View (Anc);\n+               end if;\n+\n+               return\n+                 Has_Volatile_Components (Id)\n+                   or else\n+                 Is_Effectively_Volatile (Component_Type (Anc));\n+            end;\n \n          --  A protected type is always volatile\n "}, {"sha": "6e8032c855c4269fc6048d9d5b022b805b0197d2", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3bc136d4c43f8741ece96b7ab992ef08b574f0/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=3e3bc136d4c43f8741ece96b7ab992ef08b574f0", "patch": "@@ -3487,13 +3487,12 @@ package body Sem_Warn is\n    ---------------------------------\n \n    procedure Warn_On_Overlapping_Actuals (Subp : Entity_Id; N : Node_Id) is\n-      Act1, Act2   : Node_Id;\n-      Form1, Form2 : Entity_Id;\n-\n       function Is_Covered_Formal (Formal : Node_Id) return Boolean;\n       --  Return True if Formal is covered by the rule\n \n-      function Refer_Same_Object (Act1, Act2 : Node_Id) return Boolean;\n+      function Refer_Same_Object\n+        (Act1 : Node_Id;\n+         Act2 : Node_Id) return Boolean;\n       --  Two names are known to refer to the same object if the two names\n       --  are known to denote the same object; or one of the names is a\n       --  selected_component, indexed_component, or slice and its prefix is\n@@ -3502,16 +3501,6 @@ package body Sem_Warn is\n       --  object_name is known to refer to the same object as the other name\n       --  (RM 6.4.1(6.11/3))\n \n-      -----------------------\n-      -- Refer_Same_Object --\n-      -----------------------\n-\n-      function Refer_Same_Object (Act1, Act2 : Node_Id) return Boolean is\n-      begin\n-         return Denotes_Same_Object (Act1, Act2)\n-           or else Denotes_Same_Prefix (Act1, Act2);\n-      end Refer_Same_Object;\n-\n       -----------------------\n       -- Is_Covered_Formal --\n       -----------------------\n@@ -3525,7 +3514,31 @@ package body Sem_Warn is\n                         or else Is_Array_Type (Etype (Formal)));\n       end Is_Covered_Formal;\n \n+      -----------------------\n+      -- Refer_Same_Object --\n+      -----------------------\n+\n+      function Refer_Same_Object\n+        (Act1 : Node_Id;\n+         Act2 : Node_Id) return Boolean\n+      is\n+      begin\n+         return\n+           Denotes_Same_Object (Act1, Act2)\n+             or else Denotes_Same_Prefix (Act1, Act2);\n+      end Refer_Same_Object;\n+\n+      --  Local variables\n+\n+      Act1  : Node_Id;\n+      Act2  : Node_Id;\n+      Form1 : Entity_Id;\n+      Form2 : Entity_Id;\n+\n+   --  Start of processing for Warn_On_Overlapping_Actuals\n+\n    begin\n+\n       if Ada_Version < Ada_2012 and then not Warn_On_Overlap then\n          return;\n       end if;\n@@ -3593,6 +3606,14 @@ package body Sem_Warn is\n                   then\n                      null;\n \n+                  --  If the types of the formals are different there can\n+                  --  be no aliasing (even though there might be overlap\n+                  --  through address clauses, which must be intentional).\n+\n+                  elsif Base_Type (Etype (Form1)) /= Base_Type (Etype (Form2))\n+                  then\n+                     null;\n+\n                   --  Here we may need to issue overlap message\n \n                   else"}]}