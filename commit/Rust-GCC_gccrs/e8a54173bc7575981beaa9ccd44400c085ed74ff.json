{"sha": "e8a54173bc7575981beaa9ccd44400c085ed74ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThhNTQxNzNiYzc1NzU5ODFiZWFhOWNjZDQ0NDAwYzA4NWVkNzRmZg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-09-09T17:02:34Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-09-09T17:02:34Z"}, "message": "single_set takes an insn\n\ngcc/ChangeLog:\n2014-09-09  David Malcolm  <dmalcolm@redhat.com>\n\n\t* rtl.h (single_set_2): Strengthen first param from const_rtx to\n\tconst rtx_insn *, and move prototype to above...\n\t(single_set): ...this.  Convert this from a macro to an inline\n\tfunction, enforcing the requirement that the param is a const\n\trtx_insn *.\n\t(find_args_size_adjust): Strengthen param from rtx to rtx_insn *.\n\n\t* config/arm/aarch-common-protos.h (aarch_crypto_can_dual_issue):\n\tStrengthen both params from rtx to rtx_insn *.\n\t* config/arm/aarch-common.c (aarch_crypto_can_dual_issue):\n\tLikewise; introduce locals \"producer_set\", \"consumer_set\", using\n\tthem in place of \"producer\" and \"consumer\" when dealing with SET\n\trather than insn.\n\t* config/avr/avr.c (avr_out_plus): Add checked cast to rtx_insn *\n\twhen invoking single_set in region guarded by INSN_P.\n\t(avr_out_bitop): Likewise.\n\t(_reg_unused_after): Introduce local rtx_sequence * \"seq\" in\n\tregion guarded by GET_CODE check, using methods to strengthen\n\tlocal \"this_insn\" from rtx to rtx_insn *, and for clarity.\n\t* config/avr/avr.md (define_insn_and_split \"xload8<mode>_A\"):\n\tStrengthen local \"insn\" from rtx to rtx_insn *.\n\t(define_insn_and_split \"xload<mode>_A\"): Likewise.\n\t* config/bfin/bfin.c (trapping_loads_p): Likewise for param\n\t\"insn\".\n\t(find_load): Likewise for return type.\n\t(workaround_speculation): Likewise for both locals named\n\t\"load_insn\".\n\t* config/cris/cris.c (cris_cc0_user_requires_cmp): Likewise for\n\tlocal \"cc0_user\".\n\t* config/cris/cris.md (define_peephole2 ; moversideqi): Likewise\n\tfor local \"prev\".\n\t* config/h8300/h8300-protos.h (notice_update_cc): Likewise for\n\tparam 2.\n\t* config/h8300/h8300.c (notice_update_cc): Likewise.\n\t* config/i386/i386.c (ix86_flags_dependent): Likewise for params\n\t\"insn\" and \"dep_insn\".\n\t(exact_store_load_dependency): Likewise for both params.\n\t(ix86_macro_fusion_pair_p): Eliminate local named \"single_set\"\n\tsince this now clashes with inline function.  Instead, delay\n\tcalling single_set until the point where its needed, and then\n\tassign the result to \"compare_set\" and rework the conditional that\n\tfollows.\n\t* config/ia64/ia64.md (define_expand \"tablejump\"): Strengthen\n\tlocal \"last\" from rtx to rtx_insn *.\n\t* config/mips/mips-protos.h (mips_load_store_insns): Likewise for\n\tsecond param.\n\t(mips_store_data_bypass_p): Likewise for both params.\n\t* config/mips/mips.c (mips_load_store_insns): Likewise for second\n\tparam.\n\t(mips_store_data_bypass_p): Likewise for both params.\n\t(mips_orphaned_high_part_p): Likewise for param \"insn\".\n\t* config/mn10300/mn10300.c (extract_bundle): Likewise.\n\t(mn10300_bundle_liw): Likewise for locals \"r\", \"insn1\", \"insn2\".\n\tIntroduce local rtx \"insn2_pat\".\n\t* config/rl78/rl78.c (move_elim_pass): Likewise for locals \"insn\",\n\t\"ninsn\".\n\t(rl78_remove_unused_sets): Likewise for locals \"insn\", \"ninsn\".\n\tIntroduce local rtx \"set\", using it in place of \"insn\" for the\n\tresult of single_set.  This appears to fix a bug, since the call\n\tto find_regno_note on a SET does nothing.\n\t* config/rs6000/rs6000.c (set_to_load_agen): Strengthen both\n\tparams from rtx to rtx_insn *.\n\t(set_to_load_agen): Likewise.\n\t* config/s390/s390.c (s390_label_align): Likewise for local\n\t\"prev_insn\".  Introduce new rtx locals \"set\" and \"src\", using\n\tthem in place of \"prev_insn\" for the results of single_set\n\tand SET_SRC respectively.\n\t(s390_swap_cmp): Strengthen local \"jump\" from rtx to rtx_insn *.\n\tIntroduce new rtx local \"set\" using in place of \"jump\" for the\n\tresult of single_set.  Use SET_SRC (set) rather than plain\n\tXEXP (set, 1).\n\t* config/sh/sh.c (noncall_uses_reg): Strengthen param 2from\n\trtx to rtx_insn *.\n\t(noncall_uses_reg): Likewise.\n\t(reg_unused_after): Introduce local rtx_sequence * \"seq\" in region\n\tguarded by GET_CODE check, using its methods for clarity, and to\n\tenable strengthening local \"this_insn\" from rtx to rtx_insn *.\n\t* config/sh/sh.md (define_expand \"mulhisi3\"): Strengthen local\n\t\"insn\" from rtx to rtx_insn *.\n\t(define_expand \"umulhisi3\"): Likewise.\n\t(define_expand \"smulsi3_highpart\"): Likewise.\n\t(define_expand \"umulsi3_highpart\"): Likewise.\n\t* config/sparc/sparc.c (sparc_do_work_around_errata): Likewise for\n\tlocal \"after\".  Replace GET_CODE check with a dyn_cast,\n\tintroducing new local rtx_sequence * \"seq\", using insn method for\n\ttypesafety.\n\n\t* dwarf2cfi.c (dwarf2out_frame_debug): Strengthen param \"insn\"\n\tfrom rtx to rtx_insn *.  Introduce local rtx \"pat\", using it in\n\tplace of \"insn\" once we're dealing with patterns rather than the\n\tinput insn.\n\t(scan_insn_after): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(scan_trace): Likewise for local \"elt\", updating lookups within\n\tsequence to use insn method rather than element method.\n\t* expr.c (find_args_size_adjust): Strengthen param \"insn\" from rtx\n\tto rtx_insn *.\n\t* gcse.c (gcse_emit_move_after): Likewise for local \"new_rtx\".\n\t* ifcvt.c (noce_try_abs): Likewise for local \"insn\".\n\t* ira.c (fix_reg_equiv_init): Add checked cast to rtx_insn * when\n\tinvoking single_set.\n\t* lra-constraints.c (insn_rhs_dead_pseudo_p): Strengthen param\n\t\"insn\" from rtx to rtx_insn *.\n\t(skip_usage_debug_insns): Likewise for return type, adding a\n\tchecked cast.\n\t(check_secondary_memory_needed_p): Likewise for local \"insn\".\n\t(inherit_reload_reg): Likewise.\n\t* modulo-sched.c (sms_schedule): Likewise for local \"count_init\".\n\t* recog.c (peep2_attempt): Likewise for local \"old_insn\", adding\n\tchecked casts.\n\t(store_data_bypass_p): Likewise for both params.\n\t(if_test_bypass_p): Likewise.\n\t* recog.h (store_data_bypass_p): Likewise for both params.\n\t(if_test_bypass_p): Likewise.\n\t* reload.c (find_equiv_reg): Likewise for local \"where\".\n\t* reorg.c (delete_jump): Likewise for param \"insn\".\n\t* rtlanal.c (single_set_2): Strenghen param \"insn\" from const_rtx\n\tto const rtx_insn *.\n\t* store-motion.c (replace_store_insn): Likewise for param \"del\".\n\t(delete_store): Strengthen local \"i\" from rtx to rtx_insn_list *,\n\tand use its methods for clarity, and to strengthen local \"del\"\n\tfrom rtx to rtx_insn *.\n\t(build_store_vectors): Use insn method of \"st\" when calling\n\treplace_store_insn for typesafety and clarity.\n\nFrom-SVN: r215089", "tree": {"sha": "e333a5598adb0b0ee5837750327aaf9c5b269549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e333a5598adb0b0ee5837750327aaf9c5b269549"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8a54173bc7575981beaa9ccd44400c085ed74ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8a54173bc7575981beaa9ccd44400c085ed74ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8a54173bc7575981beaa9ccd44400c085ed74ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8a54173bc7575981beaa9ccd44400c085ed74ff/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65cf8039d32910001c273c983969825597f00d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65cf8039d32910001c273c983969825597f00d5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65cf8039d32910001c273c983969825597f00d5b"}], "stats": {"total": 401, "additions": 276, "deletions": 125}, "files": [{"sha": "8c1b755b8aa7369780ded751587fc6aa21709df3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -1,3 +1,129 @@\n+2014-09-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* rtl.h (single_set_2): Strengthen first param from const_rtx to\n+\tconst rtx_insn *, and move prototype to above...\n+\t(single_set): ...this.  Convert this from a macro to an inline\n+\tfunction, enforcing the requirement that the param is a const\n+\trtx_insn *.\n+\t(find_args_size_adjust): Strengthen param from rtx to rtx_insn *.\n+\n+\t* config/arm/aarch-common-protos.h (aarch_crypto_can_dual_issue):\n+\tStrengthen both params from rtx to rtx_insn *.\n+\t* config/arm/aarch-common.c (aarch_crypto_can_dual_issue):\n+\tLikewise; introduce locals \"producer_set\", \"consumer_set\", using\n+\tthem in place of \"producer\" and \"consumer\" when dealing with SET\n+\trather than insn.\n+\t* config/avr/avr.c (avr_out_plus): Add checked cast to rtx_insn *\n+\twhen invoking single_set in region guarded by INSN_P.\n+\t(avr_out_bitop): Likewise.\n+\t(_reg_unused_after): Introduce local rtx_sequence * \"seq\" in\n+\tregion guarded by GET_CODE check, using methods to strengthen\n+\tlocal \"this_insn\" from rtx to rtx_insn *, and for clarity.\n+\t* config/avr/avr.md (define_insn_and_split \"xload8<mode>_A\"):\n+\tStrengthen local \"insn\" from rtx to rtx_insn *.\n+\t(define_insn_and_split \"xload<mode>_A\"): Likewise.\n+\t* config/bfin/bfin.c (trapping_loads_p): Likewise for param\n+\t\"insn\".\n+\t(find_load): Likewise for return type.\n+\t(workaround_speculation): Likewise for both locals named\n+\t\"load_insn\".\n+\t* config/cris/cris.c (cris_cc0_user_requires_cmp): Likewise for\n+\tlocal \"cc0_user\".\n+\t* config/cris/cris.md (define_peephole2 ; moversideqi): Likewise\n+\tfor local \"prev\".\n+\t* config/h8300/h8300-protos.h (notice_update_cc): Likewise for\n+\tparam 2.\n+\t* config/h8300/h8300.c (notice_update_cc): Likewise.\n+\t* config/i386/i386.c (ix86_flags_dependent): Likewise for params\n+\t\"insn\" and \"dep_insn\".\n+\t(exact_store_load_dependency): Likewise for both params.\n+\t(ix86_macro_fusion_pair_p): Eliminate local named \"single_set\"\n+\tsince this now clashes with inline function.  Instead, delay\n+\tcalling single_set until the point where its needed, and then\n+\tassign the result to \"compare_set\" and rework the conditional that\n+\tfollows.\n+\t* config/ia64/ia64.md (define_expand \"tablejump\"): Strengthen\n+\tlocal \"last\" from rtx to rtx_insn *.\n+\t* config/mips/mips-protos.h (mips_load_store_insns): Likewise for\n+\tsecond param.\n+\t(mips_store_data_bypass_p): Likewise for both params.\n+\t* config/mips/mips.c (mips_load_store_insns): Likewise for second\n+\tparam.\n+\t(mips_store_data_bypass_p): Likewise for both params.\n+\t(mips_orphaned_high_part_p): Likewise for param \"insn\".\n+\t* config/mn10300/mn10300.c (extract_bundle): Likewise.\n+\t(mn10300_bundle_liw): Likewise for locals \"r\", \"insn1\", \"insn2\".\n+\tIntroduce local rtx \"insn2_pat\".\n+\t* config/rl78/rl78.c (move_elim_pass): Likewise for locals \"insn\",\n+\t\"ninsn\".\n+\t(rl78_remove_unused_sets): Likewise for locals \"insn\", \"ninsn\".\n+\tIntroduce local rtx \"set\", using it in place of \"insn\" for the\n+\tresult of single_set.  This appears to fix a bug, since the call\n+\tto find_regno_note on a SET does nothing.\n+\t* config/rs6000/rs6000.c (set_to_load_agen): Strengthen both\n+\tparams from rtx to rtx_insn *.\n+\t(set_to_load_agen): Likewise.\n+\t* config/s390/s390.c (s390_label_align): Likewise for local\n+\t\"prev_insn\".  Introduce new rtx locals \"set\" and \"src\", using\n+\tthem in place of \"prev_insn\" for the results of single_set\n+\tand SET_SRC respectively.\n+\t(s390_swap_cmp): Strengthen local \"jump\" from rtx to rtx_insn *.\n+\tIntroduce new rtx local \"set\" using in place of \"jump\" for the\n+\tresult of single_set.  Use SET_SRC (set) rather than plain\n+\tXEXP (set, 1).\n+\t* config/sh/sh.c (noncall_uses_reg): Strengthen param 2from\n+\trtx to rtx_insn *.\n+\t(noncall_uses_reg): Likewise.\n+\t(reg_unused_after): Introduce local rtx_sequence * \"seq\" in region\n+\tguarded by GET_CODE check, using its methods for clarity, and to\n+\tenable strengthening local \"this_insn\" from rtx to rtx_insn *.\n+\t* config/sh/sh.md (define_expand \"mulhisi3\"): Strengthen local\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(define_expand \"umulhisi3\"): Likewise.\n+\t(define_expand \"smulsi3_highpart\"): Likewise.\n+\t(define_expand \"umulsi3_highpart\"): Likewise.\n+\t* config/sparc/sparc.c (sparc_do_work_around_errata): Likewise for\n+\tlocal \"after\".  Replace GET_CODE check with a dyn_cast,\n+\tintroducing new local rtx_sequence * \"seq\", using insn method for\n+\ttypesafety.\n+\n+\t* dwarf2cfi.c (dwarf2out_frame_debug): Strengthen param \"insn\"\n+\tfrom rtx to rtx_insn *.  Introduce local rtx \"pat\", using it in\n+\tplace of \"insn\" once we're dealing with patterns rather than the\n+\tinput insn.\n+\t(scan_insn_after): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(scan_trace): Likewise for local \"elt\", updating lookups within\n+\tsequence to use insn method rather than element method.\n+\t* expr.c (find_args_size_adjust): Strengthen param \"insn\" from rtx\n+\tto rtx_insn *.\n+\t* gcse.c (gcse_emit_move_after): Likewise for local \"new_rtx\".\n+\t* ifcvt.c (noce_try_abs): Likewise for local \"insn\".\n+\t* ira.c (fix_reg_equiv_init): Add checked cast to rtx_insn * when\n+\tinvoking single_set.\n+\t* lra-constraints.c (insn_rhs_dead_pseudo_p): Strengthen param\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(skip_usage_debug_insns): Likewise for return type, adding a\n+\tchecked cast.\n+\t(check_secondary_memory_needed_p): Likewise for local \"insn\".\n+\t(inherit_reload_reg): Likewise.\n+\t* modulo-sched.c (sms_schedule): Likewise for local \"count_init\".\n+\t* recog.c (peep2_attempt): Likewise for local \"old_insn\", adding\n+\tchecked casts.\n+\t(store_data_bypass_p): Likewise for both params.\n+\t(if_test_bypass_p): Likewise.\n+\t* recog.h (store_data_bypass_p): Likewise for both params.\n+\t(if_test_bypass_p): Likewise.\n+\t* reload.c (find_equiv_reg): Likewise for local \"where\".\n+\t* reorg.c (delete_jump): Likewise for param \"insn\".\n+\t* rtlanal.c (single_set_2): Strenghen param \"insn\" from const_rtx\n+\tto const rtx_insn *.\n+\t* store-motion.c (replace_store_insn): Likewise for param \"del\".\n+\t(delete_store): Strengthen local \"i\" from rtx to rtx_insn_list *,\n+\tand use its methods for clarity, and to strengthen local \"del\"\n+\tfrom rtx to rtx_insn *.\n+\t(build_store_vectors): Use insn method of \"st\" when calling\n+\treplace_store_insn for typesafety and clarity.\n+\n 2014-09-09  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rtx_is_swappable_p): Add"}, {"sha": "ba0ea9d83fdff28736f8c482a348595a796e54d3", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -23,7 +23,7 @@\n #ifndef GCC_AARCH_COMMON_PROTOS_H\n #define GCC_AARCH_COMMON_PROTOS_H\n \n-extern int aarch_crypto_can_dual_issue (rtx, rtx);\n+extern int aarch_crypto_can_dual_issue (rtx_insn *, rtx_insn *);\n extern bool aarch_rev16_p (rtx);\n extern bool aarch_rev16_shleft_mask_imm_p (rtx, enum machine_mode);\n extern bool aarch_rev16_shright_mask_imm_p (rtx, enum machine_mode);"}, {"sha": "1c35264840692c89f1b5a772d0551072379aea99", "filename": "gcc/config/arm/aarch-common.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Farm%2Faarch-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Farm%2Faarch-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -41,15 +41,16 @@\n    implementations.  This function identifies such pairs.  */\n \n int\n-aarch_crypto_can_dual_issue (rtx producer, rtx consumer)\n+aarch_crypto_can_dual_issue (rtx_insn *producer_insn, rtx_insn *consumer_insn)\n {\n+  rtx producer_set, consumer_set;\n   rtx producer_src, consumer_src;\n \n-  producer = single_set (producer);\n-  consumer = single_set (consumer);\n+  producer_set = single_set (producer_insn);\n+  consumer_set = single_set (consumer_insn);\n \n-  producer_src = producer ? SET_SRC (producer) : NULL;\n-  consumer_src = consumer ? SET_SRC (consumer) : NULL;\n+  producer_src = producer_set ? SET_SRC (producer_set) : NULL;\n+  consumer_src = consumer_set ? SET_SRC (consumer_set) : NULL;\n \n   if (producer_src && consumer_src\n       && GET_CODE (producer_src) == UNSPEC && GET_CODE (consumer_src) == UNSPEC\n@@ -58,9 +59,9 @@ aarch_crypto_can_dual_issue (rtx producer, rtx consumer)\n           || (XINT (producer_src, 1) == UNSPEC_AESD\n               && XINT (consumer_src, 1) == UNSPEC_AESIMC)))\n   {\n-    unsigned int regno = REGNO (SET_DEST (producer));\n+    unsigned int regno = REGNO (SET_DEST (producer_set));\n \n-    return REGNO (SET_DEST (consumer)) == regno\n+    return REGNO (SET_DEST (consumer_set)) == regno\n            && REGNO (XVECEXP (consumer_src, 0, 0)) == regno;\n   }\n "}, {"sha": "e74979302ad011f37f03b850c230db06e64ffb17", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -6769,7 +6769,7 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc, bool out_label)\n   int cc_plus, cc_minus, cc_dummy;\n   int len_plus, len_minus;\n   rtx op[4];\n-  rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;\n+  rtx xpattern = INSN_P (insn) ? single_set (as_a <rtx_insn *> (insn)) : insn;\n   rtx xdest = SET_DEST (xpattern);\n   enum machine_mode mode = GET_MODE (xdest);\n   enum machine_mode imode = int_mode_for_mode (mode);\n@@ -6864,7 +6864,7 @@ const char*\n avr_out_bitop (rtx insn, rtx *xop, int *plen)\n {\n   /* CODE and MODE of the operation.  */\n-  rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;\n+  rtx xpattern = INSN_P (insn) ? single_set (as_a <rtx_insn *> (insn)) : insn;\n   enum rtx_code code = GET_CODE (SET_SRC (xpattern));\n   enum machine_mode mode = GET_MODE (xop[0]);\n \n@@ -7922,12 +7922,13 @@ _reg_unused_after (rtx_insn *insn, rtx reg)\n \t we must return 0.  */\n       else if (code == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t{\n+\t  rtx_sequence *seq = as_a <rtx_sequence *> (PATTERN (insn));\n \t  int i;\n \t  int retval = 0;\n \n-\t  for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\t  for (i = 0; i < seq->len (); i++)\n \t    {\n-\t      rtx this_insn = XVECEXP (PATTERN (insn), 0, i);\n+\t      rtx_insn *this_insn = seq->insn (i);\n \t      rtx set = single_set (this_insn);\n \n \t      if (CALL_P (this_insn))"}, {"sha": "a959b9bb7fa74ee7bb03027d4de3e4f1ca96bc21", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -477,7 +477,8 @@\n        ; in not able to allocate segment registers and reload the resulting\n        ; expressions.  Notice that no address register can hold a PSImode.  */\n \n-    rtx insn, addr = XEXP (operands[1], 0);\n+    rtx_insn *insn;\n+    rtx addr = XEXP (operands[1], 0);\n     rtx hi8 = gen_reg_rtx (QImode);\n     rtx reg_z = gen_rtx_REG (HImode, REG_Z);\n \n@@ -512,7 +513,7 @@\n     rtx reg_z = gen_rtx_REG (HImode, REG_Z);\n     rtx addr_hi8 = simplify_gen_subreg (QImode, addr, PSImode, 2);\n     addr_space_t as = MEM_ADDR_SPACE (operands[1]);\n-    rtx insn;\n+    rtx_insn *insn;\n \n     /* Split the address to R21:Z */\n     emit_move_insn (reg_z, simplify_gen_subreg (HImode, addr, PSImode, 0));"}, {"sha": "b8ea932a81f60eac7badce5a67a87c371fba1323", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -4217,7 +4217,7 @@ harmless_null_pointer_p (rtx mem, int np_reg)\n /* Return nonzero if INSN contains any loads that may trap.  */\n \n static bool\n-trapping_loads_p (rtx insn, int np_reg, bool after_np_branch)\n+trapping_loads_p (rtx_insn *insn, int np_reg, bool after_np_branch)\n {\n   rtx mem = SET_SRC (single_set (insn));\n \n@@ -4229,23 +4229,23 @@ trapping_loads_p (rtx insn, int np_reg, bool after_np_branch)\n \n /* Return INSN if it is of TYPE_MCLD.  Alternatively, if INSN is the start of\n    a three-insn bundle, see if one of them is a load and return that if so.\n-   Return NULL_RTX if the insn does not contain loads.  */\n-static rtx\n+   Return NULL if the insn does not contain loads.  */\n+static rtx_insn *\n find_load (rtx_insn *insn)\n {\n   if (!NONDEBUG_INSN_P (insn))\n-    return NULL_RTX;\n+    return NULL;\n   if (get_attr_type (insn) == TYPE_MCLD)\n     return insn;\n   if (GET_MODE (insn) != SImode)\n-    return NULL_RTX;\n+    return NULL;\n   do {\n     insn = NEXT_INSN (insn);\n     if ((GET_MODE (insn) == SImode || GET_MODE (insn) == QImode)\n \t&& get_attr_type (insn) == TYPE_MCLD)\n       return insn;\n   } while (GET_MODE (insn) != QImode);\n-  return NULL_RTX;\n+  return NULL;\n }\n \n /* Determine whether PAT is an indirect call pattern.  */\n@@ -4359,7 +4359,7 @@ workaround_speculation (void)\n \t}\n       else if (NONDEBUG_INSN_P (insn))\n \t{\n-\t  rtx load_insn = find_load (insn);\n+\t  rtx_insn *load_insn = find_load (insn);\n \t  enum attr_type type = type_for_anomaly (insn);\n \n \t  if (cycles_since_jump < INT_MAX)\n@@ -4475,7 +4475,7 @@ workaround_speculation (void)\n \n \t      if (NONDEBUG_INSN_P (target))\n \t\t{\n-\t\t  rtx load_insn = find_load (target);\n+\t\t  rtx_insn *load_insn = find_load (target);\n \t\t  enum attr_type type = type_for_anomaly (target);\n \t\t  int delay_needed = 0;\n \t\t  if (cycles_since_jump < INT_MAX)"}, {"sha": "57285e5ba4bd5a3df435245d59361972ac9bbe17", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2410,7 +2410,7 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n bool\n cris_cc0_user_requires_cmp (rtx insn)\n {\n-  rtx cc0_user = NULL;\n+  rtx_insn *cc0_user = NULL;\n   rtx body;\n   rtx set;\n "}, {"sha": "9a201f672d9edc1caf3172128187741afdc71c10", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -4732,7 +4732,7 @@\n      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])]\n   ;; Checking the previous insn is a bit too awkward for the condition.\n {\n-  rtx prev = prev_nonnote_insn (curr_insn);\n+  rtx_insn *prev = prev_nonnote_insn (curr_insn);\n   if (prev != NULL_RTX)\n     {\n       rtx set = single_set (prev);"}, {"sha": "e19580b7493302581694de0b23f11727db4c0804", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -35,7 +35,7 @@ extern unsigned int compute_a_rotate_length (rtx *);\n extern const char *output_simode_bld (int, rtx[]);\n extern void final_prescan_insn (rtx_insn *, rtx *, int);\n extern int h8300_expand_movsi (rtx[]);\n-extern void notice_update_cc (rtx, rtx);\n+extern void notice_update_cc (rtx, rtx_insn *);\n extern const char *output_logical_op (enum machine_mode, rtx *);\n extern unsigned int compute_logical_op_length (enum machine_mode,\n \t\t\t\t\t       rtx *);"}, {"sha": "896f44873044f5e25b0b1fa6c4acbc25ecd6a144", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2022,7 +2022,7 @@ h8300_return_addr_rtx (int count, rtx frame)\n /* Update the condition code from the insn.  */\n \n void\n-notice_update_cc (rtx body, rtx insn)\n+notice_update_cc (rtx body, rtx_insn *insn)\n {\n   rtx set;\n "}, {"sha": "5f796bc6baed450a17d2a07ce09b478454cdf197", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -25396,7 +25396,7 @@ ix86_issue_rate (void)\n    by DEP_INSN and nothing set by DEP_INSN.  */\n \n static bool\n-ix86_flags_dependent (rtx insn, rtx dep_insn, enum attr_type insn_type)\n+ix86_flags_dependent (rtx_insn *insn, rtx_insn *dep_insn, enum attr_type insn_type)\n {\n   rtx set, set2;\n \n@@ -25504,7 +25504,7 @@ exact_dependency_1 (rtx addr, rtx insn)\n /* Return true if there exists exact dependency for store & load, i.e.\n    the same memory address is used in them.  */\n static bool\n-exact_store_load_dependency (rtx store, rtx load)\n+exact_store_load_dependency (rtx_insn *store, rtx_insn *load)\n {\n   rtx set1, set2;\n \n@@ -25803,7 +25803,6 @@ static bool\n ix86_macro_fusion_pair_p (rtx_insn *condgen, rtx_insn *condjmp)\n {\n   rtx src, dest;\n-  rtx single_set = single_set (condgen);\n   enum rtx_code ccode;\n   rtx compare_set = NULL_RTX, test_if, cond;\n   rtx alu_set = NULL_RTX, addr = NULL_RTX;\n@@ -25817,13 +25816,12 @@ ix86_macro_fusion_pair_p (rtx_insn *condgen, rtx_insn *condjmp)\n       && get_attr_type (condgen) != TYPE_ALU)\n     return false;\n \n-  if (single_set == NULL_RTX\n+  compare_set = single_set (condgen);\n+  if (compare_set == NULL_RTX\n       && !TARGET_FUSE_ALU_AND_BRANCH)\n     return false;\n \n-  if (single_set != NULL_RTX)\n-    compare_set = single_set;\n-  else\n+  if (compare_set == NULL_RTX)\n     {\n       int i;\n       rtx pat = PATTERN (condgen);"}, {"sha": "986ef024968141f5ec7fa89fab2df6ed46ed721e", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -4592,7 +4592,8 @@\n \t stream was the memory load.  Grab the address from that.\n \t Note we have to momentarily pop out of the sequence started\n \t by the insn-emit wrapper in order to grab the last insn.  */\n-      rtx last, set;\n+      rtx_insn *last;\n+      rtx set;\n \n       end_sequence ();\n       last = get_last_insn ();"}, {"sha": "01e53a9824ebcc7666701476e5e5e728d7c68303", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -197,7 +197,7 @@ extern bool mips_stack_address_p (rtx, enum machine_mode);\n extern int mips_address_insns (rtx, enum machine_mode, bool);\n extern int mips_const_insns (rtx);\n extern int mips_split_const_insns (rtx);\n-extern int mips_load_store_insns (rtx, rtx);\n+extern int mips_load_store_insns (rtx, rtx_insn *);\n extern int mips_idiv_insns (void);\n extern rtx_insn *mips_emit_move (rtx, rtx);\n #ifdef RTX_CODE\n@@ -300,7 +300,7 @@ extern const char *mips_output_division (const char *, rtx *);\n extern const char *mips_output_probe_stack_range (rtx, rtx);\n extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n extern bool mips_linked_madd_p (rtx_insn *, rtx_insn *);\n-extern bool mips_store_data_bypass_p (rtx, rtx);\n+extern bool mips_store_data_bypass_p (rtx_insn *, rtx_insn *);\n extern int mips_dspalu_bypass_p (rtx, rtx);\n extern rtx mips_prefetch_cookie (rtx, rtx);\n "}, {"sha": "646bb4dc7ebd30f51c87148a14c0f284ba4e9b0f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2678,7 +2678,7 @@ mips_split_const_insns (rtx x)\n    BASE_INSN_LENGTH is the length of one instruction.  */\n \n int\n-mips_load_store_insns (rtx mem, rtx insn)\n+mips_load_store_insns (rtx mem, rtx_insn *insn)\n {\n   enum machine_mode mode;\n   bool might_split_p;\n@@ -13084,7 +13084,7 @@ mips_linked_madd_p (rtx_insn *out_insn, rtx_insn *in_insn)\n    for that case.  */\n \n bool\n-mips_store_data_bypass_p (rtx out_insn, rtx in_insn)\n+mips_store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n   if (GET_CODE (PATTERN (in_insn)) == UNSPEC_VOLATILE)\n     return false;\n@@ -16083,7 +16083,7 @@ mips_record_lo_sum (rtx *loc, void *data)\n    LO_SUMs in the current function.  */\n \n static bool\n-mips_orphaned_high_part_p (mips_offset_table *htab, rtx insn)\n+mips_orphaned_high_part_p (mips_offset_table *htab, rtx_insn *insn)\n {\n   enum mips_symbol_type type;\n   rtx x, set;"}, {"sha": "0fa7931b1d96729388dab17663f3c0d755b33f5c", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2974,14 +2974,14 @@ struct liw_data\n    cannot be bundled.  */\n \n static bool\n-extract_bundle (rtx insn, struct liw_data * pdata)\n+extract_bundle (rtx_insn *insn, struct liw_data * pdata)\n {\n   bool allow_consts = true;\n   rtx p;\n \n   gcc_assert (pdata != NULL);\n \n-  if (insn == NULL_RTX)\n+  if (insn == NULL)\n     return false;\n   /* Make sure that we are dealing with a simple SET insn.  */\n   p = single_set (insn);\n@@ -3100,11 +3100,11 @@ check_liw_constraints (struct liw_data * pliw1, struct liw_data * pliw2)\n static void\n mn10300_bundle_liw (void)\n {\n-  rtx r;\n+  rtx_insn *r;\n \n-  for (r = get_insns (); r != NULL_RTX; r = next_nonnote_nondebug_insn (r))\n+  for (r = get_insns (); r != NULL; r = next_nonnote_nondebug_insn (r))\n     {\n-      rtx insn1, insn2;\n+      rtx_insn *insn1, *insn2;\n       struct liw_data liw1, liw2;\n \n       insn1 = r;\n@@ -3130,17 +3130,18 @@ mn10300_bundle_liw (void)\n \n       delete_insn (insn2);\n \n+      rtx insn2_pat;\n       if (liw1.op == LIW_OP_CMP)\n-\tinsn2 = gen_cmp_liw (liw2.dest, liw2.src, liw1.dest, liw1.src,\n-\t\t\t     GEN_INT (liw2.op));\n+\tinsn2_pat = gen_cmp_liw (liw2.dest, liw2.src, liw1.dest, liw1.src,\n+\t\t\t\t GEN_INT (liw2.op));\n       else if (liw2.op == LIW_OP_CMP)\n-\tinsn2 = gen_liw_cmp (liw1.dest, liw1.src, liw2.dest, liw2.src,\n-\t\t\t     GEN_INT (liw1.op));\n+\tinsn2_pat = gen_liw_cmp (liw1.dest, liw1.src, liw2.dest, liw2.src,\n+\t\t\t\t GEN_INT (liw1.op));\n       else\n-\tinsn2 = gen_liw (liw1.dest, liw2.dest, liw1.src, liw2.src,\n-\t\t\t GEN_INT (liw1.op), GEN_INT (liw2.op));\n+\tinsn2_pat = gen_liw (liw1.dest, liw2.dest, liw1.src, liw2.src,\n+\t\t\t     GEN_INT (liw1.op), GEN_INT (liw2.op));\n \n-      insn2 = emit_insn_after (insn2, insn1);\n+      insn2 = emit_insn_after (insn2_pat, insn1);\n       delete_insn (insn1);\n       r = insn2;\n     }"}, {"sha": "6b2ddd53cd92aa0a25ccd9ded186566eea17c570", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -167,7 +167,8 @@ make_pass_rl78_devirt (gcc::context *ctxt)\n static unsigned int\n move_elim_pass (void)\n {\n-  rtx insn, ninsn, prev = NULL_RTX;\n+  rtx_insn *insn, *ninsn;\n+  rtx prev = NULL_RTX;\n \n   for (insn = get_insns (); insn; insn = ninsn)\n     {\n@@ -3586,17 +3587,18 @@ rl78_propogate_register_origins (void)\n static void\n rl78_remove_unused_sets (void)\n {\n-  rtx insn, ninsn = NULL_RTX;\n+  rtx_insn *insn, *ninsn = NULL;\n   rtx dest;\n \n   for (insn = get_insns (); insn; insn = ninsn)\n     {\n       ninsn = next_nonnote_nondebug_insn (insn);\n \n-      if ((insn = single_set (insn)) == NULL_RTX)\n+      rtx set = single_set (insn);\n+      if (set == NULL)\n \tcontinue;\n \n-      dest = SET_DEST (insn);\n+      dest = SET_DEST (set);\n \n       if (GET_CODE (dest) != REG || REGNO (dest) > 23)\n \tcontinue;"}, {"sha": "2141bc04503808cd61030f0cd8dada71c04a2291", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -1081,7 +1081,7 @@ static bool is_nonpipeline_insn (rtx);\n static bool is_cracked_insn (rtx);\n static bool is_load_insn (rtx, rtx *);\n static bool is_store_insn (rtx, rtx *);\n-static bool set_to_load_agen (rtx,rtx);\n+static bool set_to_load_agen (rtx_insn *,rtx_insn *);\n static bool insn_terminates_group_p (rtx , enum group_termination);\n static bool insn_must_be_first_in_group (rtx);\n static bool insn_must_be_last_in_group (rtx);\n@@ -26740,7 +26740,7 @@ is_branch_slot_insn (rtx insn)\n /* The function returns true if out_inst sets a value that is\n    used in the address generation computation of in_insn */\n static bool\n-set_to_load_agen (rtx out_insn, rtx in_insn)\n+set_to_load_agen (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n   rtx out_set, in_set;\n "}, {"sha": "46fa02be8543b8e21966e5670fa3758521578139", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -495,21 +495,22 @@ static const struct attribute_spec s390_attribute_table[] = {\n int\n s390_label_align (rtx label)\n {\n-  rtx prev_insn = prev_active_insn (label);\n+  rtx_insn *prev_insn = prev_active_insn (label);\n+  rtx set, src;\n \n   if (prev_insn == NULL_RTX)\n     goto old;\n \n-  prev_insn = single_set (prev_insn);\n+  set = single_set (prev_insn);\n \n-  if (prev_insn == NULL_RTX)\n+  if (set == NULL_RTX)\n     goto old;\n \n-  prev_insn = SET_SRC (prev_insn);\n+  src = SET_SRC (set);\n \n   /* Don't align literal pool base labels.  */\n-  if (GET_CODE (prev_insn) == UNSPEC\n-      && XINT (prev_insn, 1) == UNSPEC_MAIN_BASE)\n+  if (GET_CODE (src) == UNSPEC\n+      && XINT (src, 1) == UNSPEC_MAIN_BASE)\n     return 0;\n \n  old:\n@@ -11155,13 +11156,13 @@ s390_swap_cmp (rtx cond, rtx *op0, rtx *op1, rtx_insn *insn)\n \n   if (cond == NULL_RTX)\n     {\n-      rtx jump = find_cond_jump (NEXT_INSN (insn));\n-      jump = jump ? single_set (jump) : NULL_RTX;\n+      rtx_insn *jump = find_cond_jump (NEXT_INSN (insn));\n+      rtx set = jump ? single_set (jump) : NULL_RTX;\n \n-      if (jump == NULL_RTX)\n+      if (set == NULL_RTX)\n \treturn;\n \n-      cond = XEXP (XEXP (jump, 1), 0);\n+      cond = XEXP (SET_SRC (set), 0);\n     }\n \n   *op0 = *op1;"}, {"sha": "8c1da68ae6895d0b2488c5916feeb1562d7734a9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -190,7 +190,7 @@ static void dump_table (rtx_insn *, rtx_insn *);\n static bool broken_move (rtx_insn *);\n static bool mova_p (rtx_insn *);\n static rtx_insn *find_barrier (int, rtx_insn *, rtx_insn *);\n-static bool noncall_uses_reg (rtx, rtx, rtx *);\n+static bool noncall_uses_reg (rtx, rtx_insn *, rtx *);\n static rtx_insn *gen_block_redirect (rtx_insn *, int, int);\n static void sh_reorg (void);\n static void sh_option_override (void);\n@@ -5405,7 +5405,7 @@ sfunc_uses_reg (rtx insn)\n    setting it while calling it.  Set *SET to a SET rtx if the register\n    is set by INSN.  */\n static bool\n-noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n+noncall_uses_reg (rtx reg, rtx_insn *insn, rtx *set)\n {\n   rtx pattern, reg2;\n \n@@ -9953,12 +9953,13 @@ reg_unused_after (rtx reg, rtx_insn *insn)\n \t we must return 0.  */\n       else if (code == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t{\n+\t  rtx_sequence *seq = as_a <rtx_sequence *> (PATTERN (insn));\n \t  int i;\n \t  int retval = 0;\n \n-\t  for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\t  for (i = 0; i < seq->len (); i++)\n \t    {\n-\t      rtx this_insn = XVECEXP (PATTERN (insn), 0, i);\n+\t      rtx_insn *this_insn = seq->insn (i);\n \t      rtx set = single_set (this_insn);\n \n \t      if (CALL_P (this_insn))"}, {"sha": "56dee824f1c0674d51224a3e3b9be20bec7920cc", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -3336,7 +3336,8 @@ label:\n \t(reg:SI MACL_REG))]\n   \"TARGET_SH1\"\n {\n-  rtx insn, macl;\n+  rtx_insn *insn;\n+  rtx macl;\n \n   macl = gen_rtx_REG (SImode, MACL_REG);\n   start_sequence ();\n@@ -3365,7 +3366,8 @@ label:\n \t(reg:SI MACL_REG))]\n   \"TARGET_SH1\"\n {\n-  rtx insn, macl;\n+  rtx_insn *insn;\n+  rtx macl;\n \n   macl = gen_rtx_REG (SImode, MACL_REG);\n   start_sequence ();\n@@ -3613,7 +3615,8 @@ label:\n \t(reg:SI MACH_REG))]\n   \"TARGET_SH2\"\n {\n-  rtx insn, mach;\n+  rtx_insn *insn;\n+  rtx mach;\n \n   mach = gen_rtx_REG (SImode, MACH_REG);\n   start_sequence ();\n@@ -3659,7 +3662,8 @@ label:\n \t(reg:SI MACH_REG))]\n   \"TARGET_SH2\"\n {\n-  rtx insn, mach;\n+  rtx_insn *insn;\n+  rtx mach;\n \n   mach = gen_rtx_REG (SImode, MACH_REG);\n   start_sequence ();"}, {"sha": "dca08af1f27d10515b12ac9fa6ab94878301fcae", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -1016,7 +1016,7 @@ sparc_do_work_around_errata (void)\n \t  /* The problematic combination is with the sibling FP register.  */\n \t  const unsigned int x = REGNO (SET_DEST (set));\n \t  const unsigned int y = x ^ 1;\n-\t  rtx after;\n+\t  rtx_insn *after;\n \t  int i;\n \n \t  next = next_active_insn (insn);\n@@ -1050,15 +1050,16 @@ sparc_do_work_around_errata (void)\n \t\t  if (++i == n_insns)\n \t\t    break;\n \t\t  branch_p = true;\n-\t\t  after = NULL_RTX;\n+\t\t  after = NULL;\n \t\t}\n \t      /* This is a branch with a filled delay slot.  */\n-\t      else if (GET_CODE (PATTERN (after)) == SEQUENCE)\n+\t      else if (rtx_sequence *seq =\n+\t\t         dyn_cast <rtx_sequence *> (PATTERN (after)))\n \t\t{\n \t\t  if (++i == n_insns)\n \t\t    break;\n \t\t  branch_p = true;\n-\t\t  after = XVECEXP (PATTERN (after), 0, 1);\n+\t\t  after = seq->insn (1);\n \t\t}\n \t      /* This is a regular instruction.  */\n \t      else"}, {"sha": "c8c8a4257964e9dc23b9dc232da760a555118440", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -1935,16 +1935,16 @@ dwarf2out_frame_debug_expr (rtx expr)\n    register to the stack.  */\n \n static void\n-dwarf2out_frame_debug (rtx insn)\n+dwarf2out_frame_debug (rtx_insn *insn)\n {\n-  rtx note, n;\n+  rtx note, n, pat;\n   bool handled_one = false;\n \n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     switch (REG_NOTE_KIND (note))\n       {\n       case REG_FRAME_RELATED_EXPR:\n-\tinsn = XEXP (note, 0);\n+\tpat = XEXP (note, 0);\n \tgoto do_frame_expr;\n \n       case REG_CFA_DEF_CFA:\n@@ -2036,14 +2036,14 @@ dwarf2out_frame_debug (rtx insn)\n \n   if (!handled_one)\n     {\n-      insn = PATTERN (insn);\n+      pat = PATTERN (insn);\n     do_frame_expr:\n-      dwarf2out_frame_debug_expr (insn);\n+      dwarf2out_frame_debug_expr (pat);\n \n       /* Check again.  A parallel can save and update the same register.\n          We could probably check just once, here, but this is safer than\n          removing the check at the start of the function.  */\n-      if (clobbers_queued_reg_save (insn))\n+      if (clobbers_queued_reg_save (pat))\n \tdwarf2out_flush_queued_reg_saves ();\n     }\n }\n@@ -2362,7 +2362,7 @@ create_trace_edges (rtx_insn *insn)\n /* A subroutine of scan_trace.  Do what needs to be done \"after\" INSN.  */\n \n static void\n-scan_insn_after (rtx insn)\n+scan_insn_after (rtx_insn *insn)\n {\n   if (RTX_FRAME_RELATED_P (insn))\n     dwarf2out_frame_debug (insn);\n@@ -2423,7 +2423,7 @@ scan_trace (dw_trace_info *trace)\n \t handling for the positioning of the notes.  */\n       if (rtx_sequence *pat = dyn_cast <rtx_sequence *> (PATTERN (insn)))\n \t{\n-\t  rtx elt;\n+\t  rtx_insn *elt;\n \t  int i, n = pat->len ();\n \n \t  control = pat->insn (0);\n@@ -2438,7 +2438,7 @@ scan_trace (dw_trace_info *trace)\n \t      gcc_assert (!RTX_FRAME_RELATED_P (control));\n \t      gcc_assert (!find_reg_note (control, REG_ARGS_SIZE, NULL));\n \n-\t      elt = pat->element (1);\n+\t      elt = pat->insn (1);\n \n \t      if (INSN_FROM_TARGET_P (elt))\n \t\t{\n@@ -2493,7 +2493,7 @@ scan_trace (dw_trace_info *trace)\n \n \t  for (i = 1; i < n; ++i)\n \t    {\n-\t      elt = pat->element (i);\n+\t      elt = pat->insn (i);\n \t      scan_insn_after (elt);\n \t    }\n "}, {"sha": "0a0ac80bb6cce26fd70b11ccc3841da10660fb38", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -3830,7 +3830,7 @@ mem_autoinc_base (rtx mem)\n    cannot be trivially extracted, the return value is INT_MIN.  */\n \n HOST_WIDE_INT\n-find_args_size_adjust (rtx insn)\n+find_args_size_adjust (rtx_insn *insn)\n {\n   rtx dest, set, pat;\n   int i;"}, {"sha": "b7c4788a4f7d6eed1ceb1762a67b1b4ad5dc99b5", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2573,7 +2573,7 @@ single_set_gcse (rtx_insn *insn)\n static rtx\n gcse_emit_move_after (rtx dest, rtx src, rtx_insn *insn)\n {\n-  rtx new_rtx;\n+  rtx_insn *new_rtx;\n   const_rtx set = single_set_gcse (insn);\n   rtx set2;\n   rtx note;"}, {"sha": "6c801d3b3b7ec68c2600b2bbda09d0081cd403ec", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2063,7 +2063,8 @@ noce_try_abs (struct noce_if_info *if_info)\n      REG_EQUAL note or a simple source if necessary.  */\n   if (REG_P (c))\n     {\n-      rtx set, insn = prev_nonnote_insn (earliest);\n+      rtx set;\n+      rtx_insn *insn = prev_nonnote_insn (earliest);\n       if (insn\n \t  && BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (earliest)\n \t  && (set = single_set (insn))"}, {"sha": "09b1f88b280698edc0fc802f0c7276c935866a29", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2689,7 +2689,7 @@ fix_reg_equiv_init (void)\n \t  {\n \t    next = XEXP (x, 1);\n \t    insn = XEXP (x, 0);\n-\t    set = single_set (insn);\n+\t    set = single_set (as_a <rtx_insn *> (insn));\n \t    ira_assert (set != NULL_RTX\n \t\t\t&& (REG_P (SET_DEST (set)) || REG_P (SET_SRC (set))));\n \t    if (REG_P (SET_DEST (set))"}, {"sha": "d8489541fa61f3c77bc74bf6027ef25fcc1332b5", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -3939,7 +3939,7 @@ dead_pseudo_p (rtx x, rtx insn)\n /* Return true if INSN contains a dying pseudo in INSN right hand\n    side.  */\n static bool\n-insn_rhs_dead_pseudo_p (rtx insn)\n+insn_rhs_dead_pseudo_p (rtx_insn *insn)\n {\n   rtx set = single_set (insn);\n \n@@ -4390,7 +4390,7 @@ substitute_pseudo_within_insn (rtx_insn *insn, int old_regno, rtx new_reg)\n }\n \n /* Return first non-debug insn in list USAGE_INSNS.  */\n-static rtx\n+static rtx_insn *\n skip_usage_debug_insns (rtx usage_insns)\n {\n   rtx insn;\n@@ -4400,7 +4400,7 @@ skip_usage_debug_insns (rtx usage_insns)\n        insn != NULL_RTX && GET_CODE (insn) == INSN_LIST;\n        insn = XEXP (insn, 1))\n     ;\n-  return insn;\n+  return safe_as_a <rtx_insn *> (insn);\n }\n \n /* Return true if we need secondary memory moves for insn in\n@@ -4413,7 +4413,8 @@ check_secondary_memory_needed_p (enum reg_class inher_cl ATTRIBUTE_UNUSED,\n #ifndef SECONDARY_MEMORY_NEEDED\n   return false;\n #else\n-  rtx insn, set, dest;\n+  rtx_insn *insn;\n+  rtx set, dest;\n   enum reg_class cl;\n \n   if (inher_cl == ALL_REGS\n@@ -4508,7 +4509,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t transformation will be unprofitable.  */\n       if (lra_dump_file != NULL)\n \t{\n-\t  rtx insn = skip_usage_debug_insns (next_usage_insns);\n+\t  rtx_insn *insn = skip_usage_debug_insns (next_usage_insns);\n \t  rtx set = single_set (insn);\n \n \t  lra_assert (set != NULL_RTX);"}, {"sha": "c59c16b0badde79d6dadd49b133f10abb0165988", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -1539,7 +1539,8 @@ sms_schedule (void)\n   FOR_EACH_LOOP (loop, 0)\n     {\n       rtx_insn *head, *tail;\n-      rtx count_reg, count_init;\n+      rtx count_reg;\n+      rtx_insn *count_init;\n       int mii, rec_mii, stage_count, min_cycle;\n       int64_t loop_count = 0;\n       bool opt_sc_p;\n@@ -1589,7 +1590,7 @@ sms_schedule (void)\n \n       /* In case of th loop have doloop register it gets special\n \t handling.  */\n-      count_init = NULL_RTX;\n+      count_init = NULL;\n       if ((count_reg = doloop_register_get (head, tail)))\n \t{\n \t  basic_block pre_header;"}, {"sha": "2150b7a88a308e0459e8a91b2b9408d080f45fbf", "filename": "gcc/recog.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -3167,13 +3167,13 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n   int i;\n   rtx_insn *last, *before_try, *x;\n   rtx eh_note, as_note;\n-  rtx old_insn;\n+  rtx_insn *old_insn;\n   rtx_insn *new_insn;\n   bool was_call = false;\n \n   /* If we are splitting an RTX_FRAME_RELATED_P insn, do not allow it to\n      match more than one insn, or to be split into more than one insn.  */\n-  old_insn = peep2_insn_data[peep2_current].insn;\n+  old_insn = as_a <rtx_insn *> (peep2_insn_data[peep2_current].insn);\n   if (RTX_FRAME_RELATED_P (old_insn))\n     {\n       bool any_note = false;\n@@ -3261,7 +3261,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n       rtx note;\n \n       j = peep2_buf_position (peep2_current + i);\n-      old_insn = peep2_insn_data[j].insn;\n+      old_insn = as_a <rtx_insn *> (peep2_insn_data[j].insn);\n       if (!CALL_P (old_insn))\n \tcontinue;\n       was_call = true;\n@@ -3300,7 +3300,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n       while (++i <= match_len)\n \t{\n \t  j = peep2_buf_position (peep2_current + i);\n-\t  old_insn = peep2_insn_data[j].insn;\n+\t  old_insn = as_a <rtx_insn *> (peep2_insn_data[j].insn);\n \t  gcc_assert (!CALL_P (old_insn));\n \t}\n       break;\n@@ -3312,7 +3312,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n   for (i = match_len; i >= 0; --i)\n     {\n       int j = peep2_buf_position (peep2_current + i);\n-      old_insn = peep2_insn_data[j].insn;\n+      old_insn = as_a <rtx_insn *> (peep2_insn_data[j].insn);\n \n       as_note = find_reg_note (old_insn, REG_ARGS_SIZE, NULL);\n       if (as_note)\n@@ -3572,7 +3572,7 @@ peephole2_optimize (void)\n    must be either a single_set or a PARALLEL with SETs inside.  */\n \n int\n-store_data_bypass_p (rtx out_insn, rtx in_insn)\n+store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n   rtx out_set, in_set;\n   rtx out_pat, in_pat;\n@@ -3665,7 +3665,7 @@ store_data_bypass_p (rtx out_insn, rtx in_insn)\n    of insn categorization may be any JUMP or CALL insn.  */\n \n int\n-if_test_bypass_p (rtx out_insn, rtx in_insn)\n+if_test_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n   rtx out_set, in_set;\n "}, {"sha": "3f94a166c737a3950abb94f168970dbb323e2e57", "filename": "gcc/recog.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -149,8 +149,8 @@ extern rtx peep2_find_free_register (int, int, const char *,\n #endif\n extern rtx peephole2_insns (rtx, rtx, int *);\n \n-extern int store_data_bypass_p (rtx, rtx);\n-extern int if_test_bypass_p (rtx, rtx);\n+extern int store_data_bypass_p (rtx_insn *, rtx_insn *);\n+extern int if_test_bypass_p (rtx_insn *, rtx_insn *);\n \n #ifndef GENERATOR_FILE\n /* Try recognizing the instruction INSN,"}, {"sha": "529cd1401b90db3d1abf6a91b0a81d0e6e56a58d", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -6677,7 +6677,8 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t\tshort *reload_reg_p, int goalreg, enum machine_mode mode)\n {\n   rtx_insn *p = insn;\n-  rtx goaltry, valtry, value, where;\n+  rtx goaltry, valtry, value;\n+  rtx_insn *where;\n   rtx pat;\n   int regno = -1;\n   int valueno;"}, {"sha": "c37ae1e96ca39afd83c1ec0ffd6f0ae21b8cabc9", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -3135,7 +3135,7 @@ delete_computation (rtx insn)\n    if that's what the previous thing was.  */\n \n static void\n-delete_jump (rtx insn)\n+delete_jump (rtx_insn *insn)\n {\n   rtx set = single_set (insn);\n "}, {"sha": "56a06e1ade046ee7c0df9154122ca07fbea0d035", "filename": "gcc/rtl.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -2723,12 +2723,21 @@ extern void set_insn_deleted (rtx);\n \n /* Functions in rtlanal.c */\n \n-/* Single set is implemented as macro for performance reasons.  */\n-#define single_set(I) (INSN_P (I) \\\n-\t\t       ? (GET_CODE (PATTERN (I)) == SET \\\n-\t\t\t  ? PATTERN (I) : single_set_1 (I)) \\\n-\t\t       : NULL_RTX)\n-#define single_set_1(I) single_set_2 (I, PATTERN (I))\n+extern rtx single_set_2 (const rtx_insn *, const_rtx);\n+\n+/* Handle the cheap and common cases inline for performance.  */\n+\n+inline rtx single_set (const rtx_insn *insn)\n+{\n+  if (!INSN_P (insn))\n+    return NULL_RTX;\n+\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    return PATTERN (insn);\n+\n+  /* Defer to the more expensive case.  */\n+  return single_set_2 (insn, PATTERN (insn));\n+}\n \n extern enum machine_mode get_address_mode (rtx mem);\n extern int rtx_addr_can_trap_p (const_rtx);\n@@ -2753,7 +2762,6 @@ extern int modified_between_p (const_rtx, const rtx_insn *, const rtx_insn *);\n extern int no_labels_between_p (const rtx_insn *, const rtx_insn *);\n extern int modified_in_p (const_rtx, const_rtx);\n extern int reg_set_p (const_rtx, const_rtx);\n-extern rtx single_set_2 (const_rtx, const_rtx);\n extern int multiple_sets (const_rtx);\n extern int set_noop_p (const_rtx);\n extern int noop_move_p (const_rtx);\n@@ -3372,7 +3380,7 @@ extern void emit_jump (rtx);\n /* In expr.c */\n extern rtx move_by_pieces (rtx, rtx, unsigned HOST_WIDE_INT,\n \t\t\t   unsigned int, int);\n-extern HOST_WIDE_INT find_args_size_adjust (rtx);\n+extern HOST_WIDE_INT find_args_size_adjust (rtx_insn *);\n extern int fixup_args_size_notes (rtx_insn *, rtx_insn *, int);\n \n /* In cfgrtl.c */"}, {"sha": "d3a3e0277b408b3262bda9c15227b86324b5920f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -1183,7 +1183,7 @@ record_hard_reg_uses (rtx *px, void *data)\n    will not be used, which we ignore.  */\n \n rtx\n-single_set_2 (const_rtx insn, const_rtx pat)\n+single_set_2 (const rtx_insn *insn, const_rtx pat)\n {\n   rtx set = NULL;\n   int set_verified = 1;"}, {"sha": "85870f6815b509d818b17c4be8c421de1758c7f0", "filename": "gcc/store-motion.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8a54173bc7575981beaa9ccd44400c085ed74ff/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=e8a54173bc7575981beaa9ccd44400c085ed74ff", "patch": "@@ -920,7 +920,8 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n /* This routine will replace a store with a SET to a specified register.  */\n \n static void\n-replace_store_insn (rtx reg, rtx del, basic_block bb, struct st_expr *smexpr)\n+replace_store_insn (rtx reg, rtx_insn *del, basic_block bb,\n+\t\t    struct st_expr *smexpr)\n {\n   rtx_insn *insn;\n   rtx mem, note, set, ptr;\n@@ -984,16 +985,16 @@ replace_store_insn (rtx reg, rtx del, basic_block bb, struct st_expr *smexpr)\n static void\n delete_store (struct st_expr * expr, basic_block bb)\n {\n-  rtx reg, i, del;\n+  rtx reg;\n \n   if (expr->reaching_reg == NULL_RTX)\n     expr->reaching_reg = gen_reg_rtx_and_attrs (expr->pattern);\n \n   reg = expr->reaching_reg;\n \n-  for (i = expr->avail_stores; i; i = XEXP (i, 1))\n+  for (rtx_insn_list *i = expr->avail_stores; i; i = i->next ())\n     {\n-      del = XEXP (i, 0);\n+      rtx_insn *del = i->insn ();\n       if (BLOCK_FOR_INSN (del) == bb)\n \t{\n \t  /* We know there is only one since we deleted redundant\n@@ -1042,7 +1043,7 @@ build_store_vectors (void)\n \t      rtx r = gen_reg_rtx_and_attrs (ptr->pattern);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Removing redundant store:\\n\");\n-\t      replace_store_insn (r, XEXP (st, 0), bb, ptr);\n+\t      replace_store_insn (r, st->insn (), bb, ptr);\n \t      continue;\n \t    }\n \t  bitmap_set_bit (st_avloc[bb->index], ptr->index);"}]}