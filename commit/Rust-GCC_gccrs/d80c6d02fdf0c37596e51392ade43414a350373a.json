{"sha": "d80c6d02fdf0c37596e51392ade43414a350373a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwYzZkMDJmZGYwYzM3NTk2ZTUxMzkyYWRlNDM0MTRhMzUwMzczYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-01-05T07:38:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-01-05T07:38:48Z"}, "message": "re PR rtl-optimization/78812 (Wrong code generation due to hoisting memory load across function call)\n\n\tPR tree-optimizatin/78812\n\t* rtl.h (contains_mem_rtx_p): Prototype.\n\t* ifcvt.c (containts_mem_rtx_p): Move from here to...\n\t* rtlanal.c (contains_mem_rtx_p): Here and remvoe static linkage.\n\t* gcse.c (prune_expressions): Use contains_mem_rtx_p to discover\n\tand prune MEMs that are not at the toplevel of a SET_SRC rtx.  Look\n\tthrough ZERO_EXTEND and SIGN_EXTEND when trying to avoid pruning\n\tMEMs.\n\n\tPR tree-optimization/78812\n\t* g++.dg/torture/pr78812.C: New test.\n\nFrom-SVN: r244093", "tree": {"sha": "8e37be87c8ec04e67bbf7f825c453fd039b46d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e37be87c8ec04e67bbf7f825c453fd039b46d57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d80c6d02fdf0c37596e51392ade43414a350373a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80c6d02fdf0c37596e51392ade43414a350373a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d80c6d02fdf0c37596e51392ade43414a350373a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80c6d02fdf0c37596e51392ade43414a350373a/comments", "author": null, "committer": null, "parents": [{"sha": "0f9cf7ff836bbc7d4f68e47918c878983c08e386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9cf7ff836bbc7d4f68e47918c878983c08e386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f9cf7ff836bbc7d4f68e47918c878983c08e386"}], "stats": {"total": 100, "additions": 77, "deletions": 23}, "files": [{"sha": "78b4412a0617c8799202a78fb08a49c1bff22cc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d80c6d02fdf0c37596e51392ade43414a350373a", "patch": "@@ -1,3 +1,14 @@\n+2017-01-04  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimizatin/78812\n+\t* rtl.h (contains_mem_rtx_p): Prototype.\n+\t* ifcvt.c (containts_mem_rtx_p): Move from here to...\n+\t* rtlanal.c (contains_mem_rtx_p): Here and remvoe static linkage.\n+\t* gcse.c (prune_expressions): Use contains_mem_rtx_p to discover\n+\tand prune MEMs that are not at the toplevel of a SET_SRC rtx.  Look\n+\tthrough ZERO_EXTEND and SIGN_EXTEND when trying to avoid pruning\n+\tMEMs.\n+\n 2017-01-04  Alexandre Oliva <aoliva@redhat.com>\n \n \t* input.c (assert_char_at_range): Default-initialize"}, {"sha": "d28288df95c076ffeb5327d9609593536fb19b53", "filename": "gcc/gcse.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=d80c6d02fdf0c37596e51392ade43414a350373a", "patch": "@@ -1709,23 +1709,36 @@ prune_expressions (bool pre_p)\n \t      continue;\n \t    }\n \n-\t  if (!pre_p && MEM_P (expr->expr))\n+\t  if (!pre_p && contains_mem_rtx_p (expr->expr))\n \t    /* Note memory references that can be clobbered by a call.\n \t       We do not split abnormal edges in hoisting, so would\n \t       a memory reference get hoisted along an abnormal edge,\n \t       it would be placed /before/ the call.  Therefore, only\n \t       constant memory references can be hoisted along abnormal\n \t       edges.  */\n \t    {\n-\t      if (GET_CODE (XEXP (expr->expr, 0)) == SYMBOL_REF\n-\t\t  && CONSTANT_POOL_ADDRESS_P (XEXP (expr->expr, 0)))\n-\t\tcontinue;\n-\n-\t      if (MEM_READONLY_P (expr->expr)\n-\t\t  && !MEM_VOLATILE_P (expr->expr)\n-\t\t  && MEM_NOTRAP_P (expr->expr))\n-\t\t/* Constant memory reference, e.g., a PIC address.  */\n-\t\tcontinue;\n+\t      rtx x = expr->expr;\n+\n+\t      /* Common cases where we might find the MEM which may allow us\n+\t\t to avoid pruning the expression.  */\n+\t      while (GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)\n+\t\tx = XEXP (x, 0);\n+\n+\t      /* If we found the MEM, go ahead and look at it to see if it has\n+\t\t properties that allow us to avoid pruning its expression out\n+\t\t of the tables.  */\n+\t      if (MEM_P (x))\n+\t\t{\n+\t\t  if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t\t      && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n+\t\t    continue;\n+\n+\t\t  if (MEM_READONLY_P (x)\n+\t\t      && !MEM_VOLATILE_P (x)\n+\t\t      && MEM_NOTRAP_P (x))\n+\t\t    /* Constant memory reference, e.g., a PIC address.  */\n+\t\t    continue;\n+\t\t}\n \n \t      /* ??? Optimally, we would use interprocedural alias\n \t\t analysis to determine if this mem is actually killed"}, {"sha": "68c1a1d42c406aa605aed7b8e3d92efd7bd43a9a", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d80c6d02fdf0c37596e51392ade43414a350373a", "patch": "@@ -3010,19 +3010,6 @@ noce_operand_ok (const_rtx op)\n   return ! may_trap_p (op);\n }\n \n-/* Return true if X contains a MEM subrtx.  */\n-\n-static bool\n-contains_mem_rtx_p (rtx x)\n-{\n-  subrtx_iterator::array_type array;\n-  FOR_EACH_SUBRTX (iter, array, x, ALL)\n-    if (MEM_P (*iter))\n-      return true;\n-\n-  return false;\n-}\n-\n /* Return true iff basic block TEST_BB is valid for noce if-conversion.\n    The condition used in this if-conversion is in COND.\n    In practice, check that TEST_BB ends with a single set"}, {"sha": "b9a7989c0d7e621aa2e657802920aa5a50413d05", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d80c6d02fdf0c37596e51392ade43414a350373a", "patch": "@@ -3090,6 +3090,7 @@ extern bool rtx_referenced_p (const_rtx, const_rtx);\n extern bool tablejump_p (const rtx_insn *, rtx_insn **, rtx_jump_table_data **);\n extern int computed_jump_p (const rtx_insn *);\n extern bool tls_referenced_p (const_rtx);\n+extern bool contains_mem_rtx_p (rtx x);\n \n /* Overload for refers_to_regno_p for checking a single register.  */\n inline bool"}, {"sha": "acb4230aac83eb9dd0e608349e51197dae66539c", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=d80c6d02fdf0c37596e51392ade43414a350373a", "patch": "@@ -685,6 +685,19 @@ rtx_addr_can_trap_p (const_rtx x)\n   return rtx_addr_can_trap_p_1 (x, 0, 0, VOIDmode, false);\n }\n \n+/* Return true if X contains a MEM subrtx.  */\n+\n+bool\n+contains_mem_rtx_p (rtx x)\n+{\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, x, ALL)\n+    if (MEM_P (*iter))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Return true if X is an address that is known to not be zero.  */\n \n bool"}, {"sha": "16b27e61d6f8c44049cad2916beb6e92390ed41c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d80c6d02fdf0c37596e51392ade43414a350373a", "patch": "@@ -1,3 +1,8 @@\n+2017-01-04  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/78812\n+\t* g++.dg/torture/pr78812.C: New test.\n+\n 2017-01-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/71977"}, {"sha": "efe0936767d71c4e3f878b3a1a2bcc4f6fe6ebc9", "filename": "gcc/testsuite/g++.dg/torture/pr78812.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr78812.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c6d02fdf0c37596e51392ade43414a350373a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr78812.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr78812.C?ref=d80c6d02fdf0c37596e51392ade43414a350373a", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do run } \n+// { dg-options \"-fpic\" { target fpic } }\n+\n+struct T\n+{\n+  bool a;\n+  T () : a (false) {}\n+  ~T () { if (!a) __builtin_abort (); }\n+};\n+\n+__attribute__((noinline))\n+void\n+test (T &x)\n+{\n+  x.a = true;\n+}\n+\n+int\n+main ()\n+{\n+  T T;\n+  test (T);\n+}\n+"}]}