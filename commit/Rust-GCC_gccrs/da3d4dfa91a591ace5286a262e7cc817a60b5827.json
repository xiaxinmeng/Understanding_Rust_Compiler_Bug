{"sha": "da3d4dfa91a591ace5286a262e7cc817a60b5827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEzZDRkZmE5MWE1OTFhY2U1Mjg2YTI2MmU3Y2M4MTdhNjBiNTgyNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-28T19:27:15Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-28T19:27:15Z"}, "message": "Put RTTI entries at negative offsets in new ABI.\n\n\t* class.c (dfs_build_vbase_offset_vtbl_entries): Put the first\n\tvbase offset at index -3, not -1.\n\t(build_vtabe_offset_vtbl_entries): Use unmarked_vtable_pathp, not\n\tdfs_vtable_path_unmarked_real_bases_queue_p to walk bases.\n\t(dfs_build_vcall_offset_vtbl_entries): Don't use skip_rtti_stuff.\n\t(build_rtti_vtbl_entries): New function.\n\t(set_rtti_entry): Remove.\n\t(build_primary_vtable): Don't use it.\n\t(build_secondary_vtable): Likewise.\n\t(start_vtable): Remove.\n\t(first_vfun_index): New function.\n\t(set_vindex): Likewise.\n\t(add_virtual_function): Don't call start_vtable.  Do call\n\tset_vindex.\n\t(set_primary_base): Rename parameter.\n\t(determine_primary_base): Likewise.\n\t(num_vfun_entries): Don't use skip_rtti_stuff.\n\t(num_extra_vtbl_entries): Include RTTI information.\n\t(build_vtbl_initializer): Use build_rtti_vtbl_entries.\n\t(skip_rtti_stuff): Remove.\n\t(dfs_modify_vtables): Don't use it.\n\t(modify_all_vtables): Don't use start_vtable.  Do use set_vindex.\n\t(layout_nonempty_base_or_field): Update size handling.\n\t(create_vtable_ptr): Tweak.\n\t(layout_class_type): Adjust parameter names.\n\t(finish_struct_1): Simplify.\n\t* cp-tree.h (CLASSTYPE_VSIZE): Tweak documentation.\n\t(skip_rtti_stuff): Remove.\n\t(first_vfun_index): New function.\n\t(dfs_vtable_path_unmarked_real_bases_queue_p): Remove.\n\t(dfs_vtable_path_marked_real_bases_queue_p): Remove.\n\t(marked_vtable_pathp): Declare.\n\t(unmarked_vtable_pathp): Likewise.\n\t* error.c (dump_expr): Use first_vfun_index to calculate vtable\n\toffsets.\n\t* rtti.c (build_headof): Look for RTTI at negative offsets.\n\t(get_tinfo_decl_dynamic): Likewise.\n\t(tinfo_base_init): Don't take the address of the TINFO_VTABLE_DECL\n\there.\n\t(create_pseudo_type_info): Do it here instead.  Adjust so that\n\tvptr points at first virtual function.\n\t* search.c (marked_vtable_pathp): Make it global.\n\t(unmarked_vtable_pathp): Likewise.\n\t(dfs_vtable_path_unmarked_real_bases_queue_p): Remove.\n\t(dfs_vtable_path_marked_real_bases_queue_p): Likewise.\n\t(dfs_get_pure_virtuals): Don't use skip_rtti_stuff.\n\t(get_pure_virtuals): Likewise.\n\t(expand_upcast_fixups): Likewise.\n\t* tree.c (debug_binfo): Likewise.\n\t* tinfo.cc (__dynamic_cast): Look for vtable_prefix at appropriate\n\tnegative offset.\n\nFrom-SVN: r32787", "tree": {"sha": "3d2b3ff39b53629e00a55e4fccb013b1edbff512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d2b3ff39b53629e00a55e4fccb013b1edbff512"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da3d4dfa91a591ace5286a262e7cc817a60b5827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da3d4dfa91a591ace5286a262e7cc817a60b5827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da3d4dfa91a591ace5286a262e7cc817a60b5827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da3d4dfa91a591ace5286a262e7cc817a60b5827/comments", "author": null, "committer": null, "parents": [{"sha": "65a0aad55d6e7d02cc09f8d869ff9cb7555544b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a0aad55d6e7d02cc09f8d869ff9cb7555544b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65a0aad55d6e7d02cc09f8d869ff9cb7555544b4"}], "stats": {"total": 562, "additions": 275, "deletions": 287}, "files": [{"sha": "a787eb30cc9209f26334a8e42e413518bb9a6228", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -1,3 +1,58 @@\n+2000-03-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPut RTTI entries at negative offsets in new ABI.\n+\t* class.c (dfs_build_vbase_offset_vtbl_entries): Put the first\n+\tvbase offset at index -3, not -1.\n+\t(build_vtabe_offset_vtbl_entries): Use unmarked_vtable_pathp, not\n+\tdfs_vtable_path_unmarked_real_bases_queue_p to walk bases.\n+\t(dfs_build_vcall_offset_vtbl_entries): Don't use skip_rtti_stuff.\n+\t(build_rtti_vtbl_entries): New function.\n+\t(set_rtti_entry): Remove.\n+\t(build_primary_vtable): Don't use it.\n+\t(build_secondary_vtable): Likewise.\n+\t(start_vtable): Remove.\n+\t(first_vfun_index): New function.\n+\t(set_vindex): Likewise.\n+\t(add_virtual_function): Don't call start_vtable.  Do call\n+\tset_vindex.\n+\t(set_primary_base): Rename parameter.\n+\t(determine_primary_base): Likewise.\n+\t(num_vfun_entries): Don't use skip_rtti_stuff.\n+\t(num_extra_vtbl_entries): Include RTTI information.\n+\t(build_vtbl_initializer): Use build_rtti_vtbl_entries.\n+\t(skip_rtti_stuff): Remove.\n+\t(dfs_modify_vtables): Don't use it.\n+\t(modify_all_vtables): Don't use start_vtable.  Do use set_vindex.\n+\t(layout_nonempty_base_or_field): Update size handling.\n+\t(create_vtable_ptr): Tweak.\n+\t(layout_class_type): Adjust parameter names.\n+\t(finish_struct_1): Simplify.\n+\t* cp-tree.h (CLASSTYPE_VSIZE): Tweak documentation.\n+\t(skip_rtti_stuff): Remove.\n+\t(first_vfun_index): New function.\n+\t(dfs_vtable_path_unmarked_real_bases_queue_p): Remove.\n+\t(dfs_vtable_path_marked_real_bases_queue_p): Remove.\n+\t(marked_vtable_pathp): Declare.\n+\t(unmarked_vtable_pathp): Likewise.\n+\t* error.c (dump_expr): Use first_vfun_index to calculate vtable\n+\toffsets.\n+\t* rtti.c (build_headof): Look for RTTI at negative offsets.\n+\t(get_tinfo_decl_dynamic): Likewise.\n+\t(tinfo_base_init): Don't take the address of the TINFO_VTABLE_DECL\n+\there.\n+\t(create_pseudo_type_info): Do it here instead.  Adjust so that\n+\tvptr points at first virtual function.\n+\t* search.c (marked_vtable_pathp): Make it global.\n+\t(unmarked_vtable_pathp): Likewise.\n+\t(dfs_vtable_path_unmarked_real_bases_queue_p): Remove.\n+\t(dfs_vtable_path_marked_real_bases_queue_p): Likewise.\n+\t(dfs_get_pure_virtuals): Don't use skip_rtti_stuff.\n+\t(get_pure_virtuals): Likewise.\n+\t(expand_upcast_fixups): Likewise.\n+\t* tree.c (debug_binfo): Likewise.\n+\t* tinfo.cc (__dynamic_cast): Look for vtable_prefix at appropriate\n+\tnegative offset.\n+\t\n Sun Mar 26 20:15:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* class.c (check_field_decl): Fix typo."}, {"sha": "a0bbf7f972de212ff93c05f79db8337c5962949a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 170, "deletions": 230, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -80,7 +80,6 @@ static tree build_vtable_entry PARAMS ((tree, tree, tree));\n static tree get_vtable_name PARAMS ((tree));\n static tree get_derived_offset PARAMS ((tree, tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n-static void set_rtti_entry PARAMS ((tree, tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n static tree dfs_finish_vtbls PARAMS ((tree, void *));\n@@ -142,7 +141,6 @@ static tree dfs_vcall_offset_queue_p PARAMS ((tree, void *));\n static tree dfs_build_vcall_offset_vtbl_entries PARAMS ((tree, void *));\n static tree build_vcall_offset_vtbl_entries PARAMS ((tree, tree));\n static tree dfs_count_virtuals PARAMS ((tree, void *));\n-static void start_vtable PARAMS ((tree, int *));\n static void layout_vtable_decl PARAMS ((tree, int));\n static int num_vfun_entries PARAMS ((tree));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n@@ -162,6 +160,8 @@ static int layout_conflict_p PARAMS ((tree, varray_type));\n static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n static void layout_empty_base PARAMS ((tree, tree, varray_type));\n static void accumulate_vtbl_inits PARAMS ((tree, tree));\n+static void set_vindex PARAMS ((tree, tree, int *));\n+static tree build_rtti_vtbl_entries PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -279,7 +279,7 @@ dfs_build_vbase_offset_vtbl_entries (binfo, data)\n \t base.  */\n       vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n       if (!TREE_VALUE (list))\n-\tBINFO_VPTR_FIELD (vbase) = build_int_2 (-1, 0);\n+\tBINFO_VPTR_FIELD (vbase) = build_int_2 (-3, 0);\n       else\n \t{\n \t  BINFO_VPTR_FIELD (vbase) = TREE_PURPOSE (TREE_VALUE (list));\n@@ -333,11 +333,11 @@ build_vbase_offset_vtbl_entries (binfo, t)\n   TREE_TYPE (list) = binfo;\n   dfs_walk (binfo,\n \t    dfs_build_vbase_offset_vtbl_entries,\n-\t    dfs_vtable_path_unmarked_real_bases_queue_p,\n+\t    unmarked_vtable_pathp,\n \t    list);\n   dfs_walk (binfo,\n \t    dfs_vtable_path_unmark,\n-\t    dfs_vtable_path_marked_real_bases_queue_p,\n+\t    marked_vtable_pathp,\n \t    list);\n   inits = nreverse (TREE_VALUE (list));\n \n@@ -405,9 +405,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \n   /* We chain the offsets on in reverse order.  That's correct --\n      build_vtbl_initializer will straighten them out.  */\n-  for (virtuals = skip_rtti_stuff (binfo,\n-\t\t\t\t   BINFO_TYPE (binfo),\n-\t\t\t\t   NULL);\n+  for (virtuals = BINFO_VIRTUALS (binfo);\n        virtuals;\n        virtuals = TREE_CHAIN (virtuals))\n     {\n@@ -486,6 +484,82 @@ build_vcall_offset_vtbl_entries (binfo, t)\n   return vod.inits;\n }\n \n+/* Return vtbl initializers for the RTTI entries coresponding to the\n+   BINFO's vtable.  BINFO is a part of the hierarchy dominated by \n+   T.  */\n+\n+static tree\n+build_rtti_vtbl_entries (binfo, t)\n+     tree binfo;\n+     tree t;\n+{\n+  tree b;\n+  tree basetype;\n+  tree inits;\n+  tree offset;\n+  tree decl;\n+  tree init;\n+\n+  basetype = BINFO_TYPE (binfo);\n+  inits = NULL_TREE;\n+\n+  /* For a COM object there is no RTTI entry.  */\n+  if (CLASSTYPE_COM_INTERFACE (basetype))\n+    return inits;\n+\n+  /* To find the complete object, we will first convert to our most\n+     primary base, and then add the offset in the vtbl to that value.  */\n+  b = binfo;\n+  while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (b)))\n+    b = BINFO_BASETYPE (b, \n+\t\t\tCLASSTYPE_VFIELD_PARENT (BINFO_TYPE (b)));\n+  offset = size_diffop (size_zero_node, BINFO_OFFSET (b));\n+\n+  /* Add the offset-to-top entry.  */\n+  if (flag_vtable_thunks)\n+    {\n+      /* Convert the offset to look like a function pointer, so that\n+\t we can put it in the vtable.  */\n+      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n+      TREE_CONSTANT (init) = 1;\n+      inits = tree_cons (NULL_TREE, init, inits);\n+    }\n+\n+  /* The second entry is, in the case of the new ABI, the address of\n+     the typeinfo object, or, in the case of the old ABI, a function\n+     which returns a typeinfo object.  */\n+  if (new_abi_rtti_p ())\n+    {\n+      if (flag_rtti)\n+\tdecl = build_unary_op (ADDR_EXPR, get_tinfo_decl (t), 0);\n+      else\n+\tdecl = integer_zero_node;\n+\n+      /* Convert the declaration to a type that can be stored in the\n+\t vtable.  */\n+      init = build1 (NOP_EXPR, vfunc_ptr_type_node, decl);\n+      TREE_CONSTANT (init) = 1;\n+    }\n+  else\n+    {\n+      if (flag_rtti)\n+\tdecl = get_tinfo_decl (t);\n+      else\n+\tdecl = abort_fndecl;\n+\n+      /* Convert the declaration to a type that can be stored in the\n+\t vtable.  */\n+      init = build1 (ADDR_EXPR, vfunc_ptr_type_node, decl);\n+      TREE_CONSTANT (init) = 1;\n+      init = build_vtable_entry (offset, integer_zero_node, init);\n+    }\n+\n+  /* Hook the RTTI declaration onto the list.  */\n+  inits = tree_cons (NULL_TREE, init, inits);\n+\n+  return inits;\n+}\n+\n /* Returns a pointer to the virtual base class of EXP that has the\n    indicated TYPE.  EXP is of class type, not a pointer type.  */\n \n@@ -945,47 +1019,6 @@ get_derived_offset (binfo, type)\n   return size_binop (MINUS_EXPR, offset1, offset2);\n }\n \n-/* Update the rtti info for this class.  */\n-\n-static void\n-set_rtti_entry (virtuals, offset, type)\n-     tree virtuals, offset, type;\n-{\n-  tree decl;\n-\n-  if (CLASSTYPE_COM_INTERFACE (type))\n-    return;\n-\n-  if (flag_rtti)\n-    decl = get_tinfo_decl (type);\n-  else if (!new_abi_rtti_p ())\n-    /* If someone tries to get RTTI information for a type compiled\n-       without RTTI, they're out of luck.  By calling __pure_virtual\n-       in this case, we give a small clue as to what went wrong.  We\n-       could consider having a __no_typeinfo function as well, for a\n-       more specific hint.  */\n-    decl = abort_fndecl;\n-  else\n-    /* For the new-abi, we just point to the type_info object.  */\n-    decl = NULL_TREE;\n-\n-  if (flag_vtable_thunks)\n-    {\n-      /* The first slot holds the offset.  */\n-      BV_DELTA (virtuals) = offset;\n-      BV_VCALL_INDEX (virtuals) = integer_zero_node;\n-\n-      /* The next node holds the decl.  */\n-      virtuals = TREE_CHAIN (virtuals);\n-      offset = ssize_int (0);\n-    }\n-\n-  /* This slot holds the function to call.  */\n-  BV_DELTA (virtuals) = offset;\n-  BV_VCALL_INDEX (virtuals) = integer_zero_node;\n-  BV_FN (virtuals) = decl;\n-}\n-\n /* Create a VAR_DECL for a primary or secondary vtable for\n    CLASS_TYPE.  Use NAME for the name of the vtable, and VTABLE_TYPE\n    for its type.  */\n@@ -1067,8 +1100,6 @@ build_primary_vtable (binfo, type)\n   \n   if (binfo)\n     {\n-      tree offset;\n-\n       if (BINFO_NEW_VTABLE_MARKED (binfo, type))\n \t/* We have already created a vtable for this base, so there's\n \t   no need to do it again.  */\n@@ -1079,11 +1110,6 @@ build_primary_vtable (binfo, type)\n       DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (BINFO_VTABLE (binfo)));\n       DECL_SIZE_UNIT (decl)\n \t= TYPE_SIZE_UNIT (TREE_TYPE (BINFO_VTABLE (binfo)));\n-\n-      /* Now do rtti stuff.  */\n-      offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n-      offset = size_diffop (size_zero_node, offset);\n-      set_rtti_entry (virtuals, offset, type);\n     }\n   else\n     {\n@@ -1171,10 +1197,6 @@ build_secondary_vtable (binfo, for_type)\n   else\n     offset = BINFO_OFFSET (binfo);\n \n-  set_rtti_entry (BINFO_VIRTUALS (binfo),\n-\t\t  size_diffop (size_zero_node, offset),\n-\t\t  for_type);\n-\n   /* In the new ABI, secondary vtables are laid out as part of the\n      same structure as the primary vtable.  */\n   if (merge_primary_and_secondary_vtables_p ())\n@@ -1349,42 +1371,52 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n     }\n }\n \n-/* Call this function whenever its known that a vtable for T is going\n-   to be needed.  It's safe to call it more than once.  *HAS_VIRTUAL_P\n-   is initialized to the number of slots that are reserved at the\n-   beginning of the vtable for RTTI information.  */\n+/* Return the index (in the virtual function table) of the first\n+   virtual function.  */\n+\n+int\n+first_vfun_index (t)\n+     tree t;\n+{\n+  /* Under the old ABI, the offset-to-top and RTTI entries are at\n+     indices zero and one; under the new ABI, the first virtual\n+     function is at index zero.  */\n+  if (!CLASSTYPE_COM_INTERFACE (t) && !flag_new_abi)\n+    return flag_vtable_thunks ? 2 : 1;\n+\n+  return 0;\n+}\n+\n+/* Set DECL_VINDEX for DECL.  VINDEX_P is the number of virtual\n+   functions present in the vtable so far.  */\n \n static void\n-start_vtable (t, has_virtual_p)\n+set_vindex (t, decl, vfuns_p)\n      tree t;\n-     int *has_virtual_p;\n+     tree decl;\n+     int *vfuns_p;\n {\n-  if (*has_virtual_p == 0 && ! CLASSTYPE_COM_INTERFACE (t))\n-    {\n-      /* If we are using thunks, use two slots at the front, one\n-\t for the offset pointer, one for the tdesc pointer.\n-         For ARM-style vtables, use the same slot for both.  */\n-      if (flag_vtable_thunks)\n-\t*has_virtual_p = 2;\n-      else\n-\t*has_virtual_p = 1;\n-    }\n+  int vindex;\n+\n+  vindex = (*vfuns_p)++;\n+  vindex += first_vfun_index (t);\n+  DECL_VINDEX (decl) = build_shared_int_cst (vindex);\n }\n \n /* Add a virtual function to all the appropriate vtables for the class\n    T.  DECL_VINDEX(X) should be error_mark_node, if we want to\n    allocate a new slot in our table.  If it is error_mark_node, we\n    know that no other function from another vtable is overridden by X.\n-   HAS_VIRTUAL keeps track of how many virtuals there are in our main\n-   vtable for the type, and we build upon the NEW_VIRTUALS list\n+   VFUNS_P keeps track of how many virtuals there are in our\n+   main vtable for the type, and we build upon the NEW_VIRTUALS list\n    and return it.  */\n \n static void\n add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n-\t\t      has_virtual, fndecl, t)\n+\t\t      vfuns_p, fndecl, t)\n      tree *new_virtuals_p;\n      tree *overridden_virtuals_p;\n-     int *has_virtual;\n+     int *vfuns_p;\n      tree fndecl;\n      tree t; /* Structure type.  */\n {\n@@ -1409,10 +1441,8 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n       /* We remember that this was the base sub-object for rtti.  */\n       CLASSTYPE_RTTI (t) = t;\n \n-      start_vtable (t, has_virtual);\n-\n       /* Now assign virtual dispatch information.  */\n-      DECL_VINDEX (fndecl) = build_shared_int_cst ((*has_virtual)++);\n+      set_vindex (t, fndecl, vfuns_p);\n       DECL_VIRTUAL_CONTEXT (fndecl) = t;\n \n       /* Save the state we've computed on the NEW_VIRTUALS list.  */\n@@ -1969,10 +1999,10 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n /* Make the Ith baseclass of T its primary base.  */\n \n static void\n-set_primary_base (t, i, has_virtual_p)\n+set_primary_base (t, i, vfuns_p)\n      tree t;\n      int i;\n-     int *has_virtual_p;\n+     int *vfuns_p;\n {\n   tree basetype;\n \n@@ -1982,23 +2012,23 @@ set_primary_base (t, i, has_virtual_p)\n   TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n   TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n   CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n-  *has_virtual_p = CLASSTYPE_VSIZE (basetype);\n+  *vfuns_p = CLASSTYPE_VSIZE (basetype);\n }\n \n /* Determine the primary class for T.  */\n \n static void\n-determine_primary_base (t, has_virtual_p)\n+determine_primary_base (t, vfuns_p)\n      tree t;\n-     int *has_virtual_p;\n+     int *vfuns_p;\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n   /* If there are no baseclasses, there is certainly no primary base.  */\n   if (n_baseclasses == 0)\n     return;\n \n-  *has_virtual_p = 0;\n+  *vfuns_p = 0;\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n@@ -2021,7 +2051,7 @@ determine_primary_base (t, has_virtual_p)\n \n \t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t    {\n-\t      set_primary_base (t, i, has_virtual_p);\n+\t      set_primary_base (t, i, vfuns_p);\n \t      CLASSTYPE_VFIELDS (t) = copy_list (CLASSTYPE_VFIELDS (basetype));\n \t    }\n \t  else\n@@ -2039,8 +2069,8 @@ determine_primary_base (t, has_virtual_p)\n \t\t\t\t VF_BASETYPE_VALUE (vfields),\n \t\t\t\t CLASSTYPE_VFIELDS (t));\n \n-\t      if (*has_virtual_p == 0)\n-\t\tset_primary_base (t, i, has_virtual_p);\n+\t      if (*vfuns_p == 0)\n+\t\tset_primary_base (t, i, vfuns_p);\n \t    }\n \t}\n     }\n@@ -2060,7 +2090,7 @@ determine_primary_base (t, has_virtual_p)\n \tif (TREE_VIA_VIRTUAL (base_binfo) \n \t    && CLASSTYPE_NEARLY_EMPTY_P (basetype))\n \t  {\n-\t    set_primary_base (t, i, has_virtual_p);\n+\t    set_primary_base (t, i, vfuns_p);\n \t    CLASSTYPE_VFIELDS (t) = copy_list (CLASSTYPE_VFIELDS (basetype));\n \t    break;\n \t  }\n@@ -2557,9 +2587,7 @@ static int\n num_vfun_entries (binfo)\n      tree binfo;\n {\n-  return list_length (skip_rtti_stuff (binfo,\n-\t\t\t\t       BINFO_TYPE (binfo),\n-\t\t\t\t       NULL));\n+  return list_length (BINFO_VIRTUALS (binfo));\n }\n \n /* Called from num_extra_vtbl_entries via dfs_walk.  */\n@@ -2609,7 +2637,19 @@ num_extra_vtbl_entries (binfo)\n       entries += vod.offsets;\n     }\n       \n-  return entries ? size_int (entries) : size_zero_node;\n+  /* When laying out COM-compatible classes, there are no RTTI\n+     entries.  */\n+  if (CLASSTYPE_COM_INTERFACE (type))\n+    ;\n+  /* When using vtable thunks, there are two RTTI entries: the \"offset\n+     to top\" value and the RTTI entry itself.  */\n+  else if (flag_vtable_thunks)\n+    entries += 2;\n+  /* When not using vtable thunks there is only a single entry.  */\n+  else\n+    entries += 1;\n+\n+  return size_int (entries);\n }\n \n /* Returns the offset (in bytes) from the beginning of BINFO's vtable\n@@ -2636,7 +2676,6 @@ build_vtbl_initializer (binfo, t)\n {\n   tree v = BINFO_VIRTUALS (binfo);\n   tree inits = NULL_TREE;\n-  tree type = BINFO_TYPE (binfo);\n \n   /* Add entries to the vtable that indicate how to adjust the this\n      pointer when calling a virtual function in this class.  */\n@@ -2646,48 +2685,8 @@ build_vtbl_initializer (binfo, t)\n   inits = chainon (build_vbase_offset_vtbl_entries (binfo, t),\n \t\t   inits);\n \n-  /* Process the RTTI stuff at the head of the list.  If we're not\n-     using vtable thunks, then the RTTI entry is just an ordinary\n-     function, and we can process it just like the other virtual\n-     function entries.  */\n-  if (!CLASSTYPE_COM_INTERFACE (type) && flag_vtable_thunks)\n-    {\n-      tree offset;\n-      tree init;\n-\n-      /* The first entry is an offset.  */\n-      offset = TREE_PURPOSE (v);\n-      my_friendly_assert (TREE_CODE (offset) == INTEGER_CST,\n-\t\t\t  19990727);\n-\n-      /* Convert the offset to look like a function pointer, so that\n-\t we can put it in the vtable.  */\n-      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n-      TREE_CONSTANT (init) = 1;\n-      inits = tree_cons (NULL_TREE, init, inits);\n-\n-      v = TREE_CHAIN (v);\n-      \n-      if (new_abi_rtti_p ())\n-        {\n-          tree decl = TREE_VALUE (v);\n-          \n-          if (decl)\n-            decl = build_unary_op (ADDR_EXPR, decl, 0);\n-          else\n-            decl = integer_zero_node;\n-          decl = build1 (NOP_EXPR, vfunc_ptr_type_node, decl);\n-          TREE_CONSTANT (decl) = 1;\n-          decl = build_vtable_entry (integer_zero_node, integer_zero_node,\n-                                     decl);\n-          inits = tree_cons (NULL_TREE, decl, inits);\n-          \n-          v = TREE_CHAIN (v);\n-        }\n-      /* In the old abi the second entry (the tdesc pointer) is\n-\t just an ordinary function, so it can be dealt with like the\n-\t virtual functions.  */\n-    }\n+  /* Add entries to the vtable for RTTI.  */\n+  inits = chainon (build_rtti_vtbl_entries (binfo, t), inits);\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n@@ -3048,43 +3047,6 @@ find_final_overrider (t, binfo, fn)\n   return build_tree_list (ffod.overriding_fn, ffod.overriding_base);\n }\n \n-/* Return the BINFO_VIRTUALS list for BINFO, without the RTTI stuff at\n-   the front.  If non-NULL, N is set to the number of entries\n-   skipped.  */\n-\n-tree\n-skip_rtti_stuff (binfo, t, n)\n-     tree binfo;\n-     tree t;\n-     HOST_WIDE_INT *n;\n-{\n-  tree virtuals;\n-\n-  if (CLASSTYPE_COM_INTERFACE (t))\n-    return 0;\n-\n-  if (n)\n-    *n = 0;\n-  virtuals = BINFO_VIRTUALS (binfo);\n-  if (virtuals)\n-    {\n-      /* We always reserve a slot for the offset/tdesc entry.  */\n-      if (n)\n-\t++*n;\n-      virtuals = TREE_CHAIN (virtuals);\n-    }\n-  if (flag_vtable_thunks && virtuals)\n-    {\n-      /* The second slot is reserved for the tdesc pointer when thunks\n-         are used.  */\n-      if (n)\n-\t++*n;\n-      virtuals = TREE_CHAIN (virtuals);\n-    }\n-\n-  return virtuals;\n-}\n-\n /* Called via dfs_walk.  Returns BINFO if BINFO has the same type as\n    DATA (which is really an _TYPE node).  */\n \n@@ -3125,10 +3087,8 @@ dfs_modify_vtables (binfo, data)\n       /* Now, go through each of the virtual functions in the virtual\n \t function table for BINFO.  Find the final overrider, and\n \t update the BINFO_VIRTUALS list appropriately.  */\n-      for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL),\n-\t     old_virtuals = skip_rtti_stuff (TYPE_BINFO (BINFO_TYPE (binfo)),\n-\t\t\t\t\t     BINFO_TYPE (binfo),\n-\t\t\t\t\t     NULL);\n+      for (virtuals = BINFO_VIRTUALS (binfo),\n+\t     old_virtuals = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (binfo)));\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals),\n \t     old_virtuals = TREE_CHAIN (old_virtuals))\n@@ -3138,17 +3098,16 @@ dfs_modify_vtables (binfo, data)\n \t  tree overrider;\n \t  tree vindex;\n \t  tree delta;\n-\t  HOST_WIDE_INT vindex_val, i;\n-\n+\t  HOST_WIDE_INT vindex_val;\n+\t  HOST_WIDE_INT i;\n \n \t  /* Find the function which originally caused this vtable\n \t     entry to be present.  */\n \t  fn = BV_FN (old_virtuals);\n \t  vindex = DECL_VINDEX (fn);\n \t  b = dfs_walk (binfo, dfs_find_base, NULL, DECL_VIRTUAL_CONTEXT (fn));\n-\t  fn = skip_rtti_stuff (TYPE_BINFO (BINFO_TYPE (b)),\n-\t\t\t\tBINFO_TYPE (b),\n-\t\t\t\t&i);\n+\t  fn = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (b)));\n+\t  i = first_vfun_index (BINFO_TYPE (b));\n \t  vindex_val = tree_low_cst (vindex, 0);\n \t  while (i < vindex_val)\n \t    {\n@@ -3195,9 +3154,9 @@ dfs_modify_vtables (binfo, data)\n    which should therefore be appended to the end of the vtable for T.  */\n \n static tree\n-modify_all_vtables (t, has_virtual_p, overridden_virtuals)\n+modify_all_vtables (t, vfuns_p, overridden_virtuals)\n      tree t;\n-     int *has_virtual_p;\n+     int *vfuns_p;\n      tree overridden_virtuals;\n {\n   tree binfo;\n@@ -3224,11 +3183,8 @@ modify_all_vtables (t, has_virtual_p, overridden_virtuals)\n \t  if (BINFO_VIRTUALS (binfo)\n \t      && !value_member (fn, BINFO_VIRTUALS (binfo)))\n \t    {\n-\t      /* We know we need a vtable for this class now.  */\n-\t      start_vtable (t, has_virtual_p);\n \t      /* Set the vtable index.  */\n-\t      DECL_VINDEX (fn) \n-\t\t= build_shared_int_cst ((*has_virtual_p)++);\n+\t      set_vindex (t, fn, vfuns_p);\n \t      /* We don't need to convert to a base class when calling\n \t\t this function.  */\n \t      DECL_VIRTUAL_CONTEXT (fn) = t;\n@@ -4220,9 +4176,10 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n       \n       /* Now that we know where it wil be placed, update its\n \t BINFO_OFFSET.  */\n-      offset = convert (ssizetype, byte_position (decl));\n+      offset = byte_position (decl);\n       if (binfo)\n-\tpropagate_binfo_offsets (binfo, offset);\n+\tpropagate_binfo_offsets (binfo, \n+\t\t\t\t convert (ssizetype, offset));\n  \n       /* We have to check to see whether or not there is already\n \t something of the same type at the offset we're about to use.\n@@ -4243,7 +4200,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n \t{\n \t  /* Undo the propogate_binfo_offsets call.  */\n \t  offset = size_diffop (size_zero_node, offset);\n-\t  propagate_binfo_offsets (binfo, offset);\n+\t  propagate_binfo_offsets (binfo, convert (ssizetype, offset));\n \t \n \t  /* Strip off the size allocated to this field.  That puts us\n \t     at the first place we could have put the field with\n@@ -4601,11 +4558,11 @@ check_bases_and_members (t, empty_p)\n    responsibility to do that.  */\n \n static tree\n-create_vtable_ptr (t, empty_p, has_virtual_p, \n+create_vtable_ptr (t, empty_p, vfuns_p,\n \t\t   new_virtuals_p, overridden_virtuals_p)\n      tree t;\n      int *empty_p;\n-     int *has_virtual_p;\n+     int *vfuns_p;\n      tree *new_virtuals_p;\n      tree *overridden_virtuals_p;\n {\n@@ -4616,17 +4573,15 @@ create_vtable_ptr (t, empty_p, has_virtual_p,\n   for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n     if (DECL_VINDEX (fn))\n       add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n-\t\t\t    has_virtual_p, fn, t);\n+\t\t\t    vfuns_p, fn, t);\n \n-  /* Even if there weren't any new virtual functions, we might need a\n+  /* If we couldn't find an appropriate base class, create a new field\n+     here.  Even if there weren't any new virtual functions, we might need a\n      new virtual function table if we're supposed to include vptrs in\n      all classes that need them.  */\n-  if (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ())\n-    start_vtable (t, has_virtual_p);\n-    \n-  /* If we couldn't find an appropriate base class, create a new field\n-     here.  */\n-  if (*has_virtual_p && !TYPE_VFIELD (t))\n+  if (!TYPE_VFIELD (t)\n+      && (*vfuns_p \n+\t  || (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ())))\n     {\n       /* We build this decl with vtbl_ptr_type_node, which is a\n \t `vtable_entry_type*'.  It might seem more precise to use\n@@ -4972,11 +4927,11 @@ end_of_class (t, include_virtuals_p)\n    pointer.  */\n \n static void\n-layout_class_type (t, empty_p, has_virtual_p, \n+layout_class_type (t, empty_p, vfuns_p, \n \t\t   new_virtuals_p, overridden_virtuals_p)\n      tree t;\n      int *empty_p;\n-     int *has_virtual_p;\n+     int *vfuns_p;\n      tree *new_virtuals_p;\n      tree *overridden_virtuals_p;\n {\n@@ -4995,10 +4950,10 @@ layout_class_type (t, empty_p, has_virtual_p,\n \n   /* If possible, we reuse the virtual function table pointer from one\n      of our base classes.  */\n-  determine_primary_base (t, has_virtual_p);\n+  determine_primary_base (t, vfuns_p);\n \n   /* Create a pointer to our virtual function table.  */\n-  vptr = create_vtable_ptr (t, empty_p, has_virtual_p,\n+  vptr = create_vtable_ptr (t, empty_p, vfuns_p,\n \t\t\t    new_virtuals_p, overridden_virtuals_p);\n \n   /* Under the new ABI, the vptr is always the first thing in the\n@@ -5215,7 +5170,7 @@ finish_struct_1 (t)\n      tree t;\n {\n   tree x;\n-  int has_virtual;\n+  int vfuns;\n   /* The NEW_VIRTUALS is a TREE_LIST.  The TREE_VALUE of each node is\n      a FUNCTION_DECL.  Each of these functions is a virtual function\n      declared in T that does not override any virtual function from a\n@@ -5246,15 +5201,15 @@ finish_struct_1 (t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n   CLASSTYPE_VFIELD_PARENT (t) = -1;\n-  has_virtual = 0;\n+  vfuns = 0;\n   CLASSTYPE_RTTI (t) = NULL_TREE;\n \n   /* Do end-of-class semantic processing: checking the validity of the\n      bases and members and add implicitly generated methods.  */\n   check_bases_and_members (t, &empty);\n \n   /* Layout the class itself.  */\n-  layout_class_type (t, &empty, &has_virtual,\n+  layout_class_type (t, &empty, &vfuns,\n \t\t     &new_virtuals, &overridden_virtuals);\n \n   /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n@@ -5278,7 +5233,7 @@ finish_struct_1 (t)\n     }\n \n   overridden_virtuals \n-    = modify_all_vtables (t, &has_virtual, nreverse (overridden_virtuals));\n+    = modify_all_vtables (t, &vfuns, nreverse (overridden_virtuals));\n \n   /* If necessary, create the primary vtable for this class.  */\n   if (new_virtuals\n@@ -5288,22 +5243,7 @@ finish_struct_1 (t)\n       new_virtuals = nreverse (new_virtuals);\n       /* We must enter these virtuals into the table.  */\n       if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-\t{\n-\t  if (! CLASSTYPE_COM_INTERFACE (t))\n-\t    {\n-\t      /* The second slot is for the tdesc pointer when thunks\n-\t\t are used.  */\n-\t      if (flag_vtable_thunks)\n-\t\tnew_virtuals = tree_cons (NULL_TREE, NULL_TREE, new_virtuals);\n-\n-\t      /* The first slot is for the rtti offset.  */\n-\t      new_virtuals = tree_cons (NULL_TREE, NULL_TREE, new_virtuals);\n-\n-\t      set_rtti_entry (new_virtuals,\n-\t\t\t      convert (ssizetype, integer_zero_node), t);\n-\t    }\n-\t  build_primary_vtable (NULL_TREE, t);\n-\t}\n+\tbuild_primary_vtable (NULL_TREE, t);\n       else if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t), t))\n \t/* Here we know enough to change the type of our virtual\n \t   function table, but we will wait until later this function.  */\n@@ -5346,7 +5286,7 @@ finish_struct_1 (t)\n \tmy_friendly_assert (TYPE_BINFO_VIRTUALS (t) == NULL_TREE,\n \t\t\t    20000116);\n \n-      CLASSTYPE_VSIZE (t) = has_virtual;\n+      CLASSTYPE_VSIZE (t) = vfuns;\n       /* Entries for virtual functions defined in the primary base are\n \t followed by entries for new functions unique to this class.  */\n       TYPE_BINFO_VIRTUALS (t) "}, {"sha": "0433135fc1c9556032c87edc84c875ac3b75bed3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -1545,8 +1545,8 @@ struct lang_type\n \t\t     CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (NODE)))\t\\\n    : NULL_TREE)\n \n-/* The number of virtual functions defined for this\n-   _CLASSTYPE node.  */\n+/* The number of virtual functions present in this classes virtual\n+   function table.  */\n #define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vsize)\n \n /* A chain of BINFOs for the direct and indirect virtual base classes\n@@ -3685,8 +3685,7 @@ extern void push_lang_context\t\t\tPARAMS ((tree));\n extern void pop_lang_context\t\t\tPARAMS ((void));\n extern tree instantiate_type\t\t\tPARAMS ((tree, tree, int));\n extern void print_class_statistics\t\tPARAMS ((void));\n-extern tree skip_rtti_stuff\t                PARAMS ((tree, tree,\n-\t\t\t\t\t\t\t HOST_WIDE_INT *));\n+extern int first_vfun_index                     PARAMS ((tree));\n extern void build_self_reference\t\tPARAMS ((void));\n extern void warn_hidden\t\t\t\tPARAMS ((tree));\n extern tree get_enclosing_class\t\t\tPARAMS ((tree));\n@@ -4212,11 +4211,9 @@ extern tree dfs_skip_nonprimary_vbases_unmarkedp PARAMS ((tree, void *));\n extern tree dfs_skip_nonprimary_vbases_markedp  PARAMS ((tree, void *));\n extern tree dfs_unmarked_real_bases_queue_p     PARAMS ((tree, void *));\n extern tree dfs_marked_real_bases_queue_p       PARAMS ((tree, void *));\n-extern tree dfs_vtable_path_unmarked_real_bases_queue_p\n-                                                PARAMS ((tree, void *));\n-extern tree dfs_vtable_path_marked_real_bases_queue_p\n-                                                PARAMS ((tree, void *));\n extern tree dfs_skip_vbases                     PARAMS ((tree, void *));\n+extern tree marked_vtable_pathp                 PARAMS ((tree, void *));\n+extern tree unmarked_vtable_pathp               PARAMS ((tree, void *));\n extern void mark_primary_bases                  PARAMS ((tree));\n extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));"}, {"sha": "5600176d1c0b5e25b094ed69b6800e79e225c747", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -1857,7 +1857,7 @@ dump_expr (t, flags)\n \t      t = TYPE_METHOD_BASETYPE (t);\n \t      virtuals = TYPE_BINFO_VIRTUALS (TYPE_MAIN_VARIANT (t));\n \t      \n-\t      n = tree_low_cst (idx, 0);\n+\t      n = tree_low_cst (idx, 0) - first_vfun_index (t);\n \n \t      /* Map vtable index back one, to allow for the null pointer to\n \t\t member.  */"}, {"sha": "ea217560296e0856cbf5046aee63c463167f7307", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -132,6 +132,7 @@ build_headof (exp)\n   tree type = TREE_TYPE (exp);\n   tree aref;\n   tree offset;\n+  tree index;\n \n   my_friendly_assert (TREE_CODE (type) == POINTER_TYPE, 20000112);\n   type = TREE_TYPE (type);\n@@ -151,7 +152,15 @@ build_headof (exp)\n   /* We use this a couple of times below, protect it.  */\n   exp = save_expr (exp);\n \n-  aref = build_vtbl_ref (build_indirect_ref (exp, NULL_PTR), integer_zero_node);\n+  /* Under the new ABI, the offset-to-top field is at index -2 from\n+     the vptr.  */\n+  if (new_abi_rtti_p ())\n+    index = build_int_2 (-2, -1);\n+  /* But under the old ABI, it is at offset zero.  */\n+  else\n+    index = integer_zero_node;\n+\n+  aref = build_vtbl_ref (build_indirect_ref (exp, NULL_PTR), index);\n \n   if (flag_vtable_thunks)\n     offset = aref;\n@@ -230,6 +239,7 @@ get_tinfo_decl_dynamic (exp)\n     {\n       /* build reference to type_info from vtable.  */\n       tree t;\n+      tree index;\n \n       if (! flag_rtti)\n \terror (\"taking dynamic typeid of object with -fno-rtti\");\n@@ -247,10 +257,15 @@ get_tinfo_decl_dynamic (exp)\n \t  exp = build_indirect_ref (exp, NULL_PTR);\n \t}\n \n-      if (flag_vtable_thunks)\n-\tt = build_vfn_ref ((tree *) 0, exp, integer_one_node);\n+      /* The RTTI information is always in the vtable, but it's at\n+\t different indices depending on the ABI.  */\n+      if (new_abi_rtti_p ())\n+\tindex = minus_one_node;\n+      else if (flag_vtable_thunks)\n+\tindex = integer_one_node;\n       else\n-\tt = build_vfn_ref ((tree *) 0, exp, integer_zero_node);\n+\tindex = integer_zero_node;\n+      t = build_vfn_ref ((tree *) 0, exp, index);\n       TREE_TYPE (t) = build_pointer_type (tinfo_decl_type);\n       return t;\n     }\n@@ -1284,8 +1299,7 @@ tinfo_base_init (desc, target)\n   \n   if (TINFO_VTABLE_DECL (desc))\n     {\n-      tree vtbl_ptr = build_unary_op (ADDR_EXPR, TINFO_VTABLE_DECL (desc), 0);\n-  \n+      tree vtbl_ptr = TINFO_VTABLE_DECL (desc);\n       init = tree_cons (NULL_TREE, vtbl_ptr, init);\n     }\n   \n@@ -1616,7 +1630,18 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n   /* Get the vtable decl. */\n   real_type = xref_tag (class_type_node, get_identifier (real_name), 1);\n   vtable_decl = get_vtable_decl (real_type, /*complete=*/1);\n-  \n+  vtable_decl = build_unary_op (ADDR_EXPR, vtable_decl, 0);\n+\n+  /* Under the new ABI, we need to point into the middle of the\n+     vtable.  */\n+  if (vbase_offsets_in_vtable_p ())\n+    {\n+      vtable_decl = build (PLUS_EXPR, TREE_TYPE (vtable_decl), \n+\t\t\t   vtable_decl,\n+\t\t\t   size_extra_vtbl_entries (TYPE_BINFO (real_type)));\n+      TREE_CONSTANT (vtable_decl) = 1;\n+    }\n+\n   /* First field is the pseudo type_info base class. */\n   fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n   "}, {"sha": "14ceff28982d03ca8f84a6012475f155de248009", "filename": "gcc/cp/search.c", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -104,8 +104,6 @@ static void expand_upcast_fixups\n static void fixup_virtual_upcast_offsets\n \tPARAMS ((tree, tree, int, int, tree, tree, tree, tree,\n \t       tree *));\n-static tree marked_vtable_pathp PARAMS ((tree, void *));\n-static tree unmarked_vtable_pathp PARAMS ((tree, void *));\n static tree marked_new_vtablep PARAMS ((tree, void *));\n static tree unmarked_new_vtablep PARAMS ((tree, void *));\n static tree marked_pushdecls_p PARAMS ((tree, void *));\n@@ -2346,30 +2344,6 @@ dfs_marked_real_bases_queue_p (binfo, data)\n   return binfo ? markedp (binfo, NULL) : NULL_TREE;\n }\n \n-/* Like dfs_unmarked_real_bases_queue_p but walks only into things\n-   that are not BINFO_VTABLE_PATH_MARKED.  */\n-\n-tree\n-dfs_vtable_path_unmarked_real_bases_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  binfo = get_shared_vbase_if_not_primary (binfo, data); \n-  return binfo ? unmarked_vtable_pathp (binfo, NULL): NULL_TREE;\n-}\n-\n-/* Like dfs_unmarked_real_bases_queue_p but walks only into things\n-   that are BINFO_VTABLE_PATH_MARKED.  */\n-\n-tree\n-dfs_vtable_path_marked_real_bases_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  binfo = get_shared_vbase_if_not_primary (binfo, data); \n-  return binfo ? marked_vtable_pathp (binfo, NULL): NULL_TREE;\n-}\n-\n /* A queue function that skips all virtual bases (and their \n    bases).  */\n \n@@ -2400,9 +2374,7 @@ dfs_get_pure_virtuals (binfo, data)\n     {\n       tree virtuals;\n       \n-      for (virtuals = skip_rtti_stuff (binfo, \n-\t\t\t\t       BINFO_TYPE (binfo), \n-\t\t\t\t       NULL);\n+      for (virtuals = BINFO_VIRTUALS (binfo);\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n \tif (DECL_PURE_VIRTUAL_P (TREE_VALUE (virtuals)))\n@@ -2447,7 +2419,7 @@ get_pure_virtuals (type)\n     {\n       tree virtuals;\n \n-      for (virtuals = skip_rtti_stuff (vbases, BINFO_TYPE (vbases), NULL);\n+      for (virtuals = BINFO_VIRTUALS (vbases);\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n \t{\n@@ -2527,15 +2499,15 @@ unmarkedp (binfo, data)\n   return !BINFO_MARKED (binfo) ? binfo : NULL_TREE;\n }\n \n-static tree\n+tree\n marked_vtable_pathp (binfo, data) \n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n { \n   return BINFO_VTABLE_PATH_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n-static tree\n+tree\n unmarked_vtable_pathp (binfo, data) \n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n@@ -2863,9 +2835,10 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n       *vbase_offsets = delta;\n     }\n \n-  virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n-\n-  while (virtuals)\n+  for (virtuals = BINFO_VIRTUALS (binfo), \n+\t n = first_vfun_index (BINFO_TYPE (binfo));\n+       virtuals;\n+       virtuals = TREE_CHAIN (virtuals), ++n)\n     {\n       tree current_fndecl = TREE_VALUE (virtuals);\n \n@@ -2956,8 +2929,6 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t  finish_expr_stmt (build_modify_expr (new_delta, NOP_EXPR,\n \t\t\t\t\t       old_delta));\n \t}\n-      ++n;\n-      virtuals = TREE_CHAIN (virtuals);\n     }\n }\n "}, {"sha": "3bf3c90a2d8339240e35d9273546e089a7e7b379", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -1100,9 +1100,8 @@ __dynamic_cast (const void *src_ptr,    // object started from\n {\n   const void *vtable = *static_cast <const void *const *> (src_ptr);\n   const vtable_prefix *prefix =\n-      adjust_pointer <vtable_prefix> (vtable, 0);\n-  // FIXME: the above offset should be -offsetof (vtable_prefix, origin));\n-  // but we don't currently layout vtables correctly.\n+      adjust_pointer <vtable_prefix> (vtable, \n+\t\t\t\t      -offsetof (vtable_prefix, origin));\n   const void *whole_ptr =\n       adjust_pointer <void> (src_ptr, prefix->whole_object);\n   const __class_type_info *whole_type = prefix->whole_type;"}, {"sha": "e27ff7b71e2dad1a674156a2a29196d5699e8022", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3d4dfa91a591ace5286a262e7cc817a60b5827/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=da3d4dfa91a591ace5286a262e7cc817a60b5827", "patch": "@@ -925,7 +925,8 @@ debug_binfo (elem)\n   else\n     fprintf (stderr, \"no vtable decl yet\\n\");\n   fprintf (stderr, \"virtuals:\\n\");\n-  virtuals = skip_rtti_stuff (elem, BINFO_TYPE (elem), &n);\n+  virtuals = BINFO_VIRTUALS (elem);\n+  n = first_vfun_index (BINFO_TYPE (elem));\n \n   while (virtuals)\n     {"}]}