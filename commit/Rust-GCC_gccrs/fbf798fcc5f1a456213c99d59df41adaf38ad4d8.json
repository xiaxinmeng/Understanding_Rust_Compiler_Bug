{"sha": "fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJmNzk4ZmNjNWYxYTQ1NjIxM2M5OWQ1OWRmNDFhZGFmMzhhZDRkOA==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-02-06T10:08:51Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-02-06T10:08:51Z"}, "message": "tree-vectorizer.c (vect_is_simple_use): Support induction.\n\n2007-02-06  Dorit Nuzman  <dorit@il.ibm.com>\n            Victor Kaplansky  <victork@il.ibm.com>\n\n        * tree-vectorizer.c (vect_is_simple_use): Support induction.\n        (vect_is_simple_reduction): Support reduction with induction as\n        one of the operands.\n        (vect_is_simple_iv_evolution): Fix formatting.\n        * tree-vect-analyze.c (vect_mark_stmts_to_be_vectorized): Fix\n        formatting.  Don't mark induction phis for vectorization.\n        (vect_analyze_scalar_cycles): Analyze all inductions, then reductions.\n        * tree-vect-transform.c (get_initial_def_for_induction): New function.\n        (vect_get_vec_def_for_operand): Support induction.\n        (vect_get_vec_def_for_stmt_copy): Fix formatting and add check for\n        induction case.\n        (vectorizable_reduction): Support reduction with induction as one of\n        the operands.\n        (vectorizable_type_demotion): Use def-type of stmt argument rather\n        than dummy def-type.\n\n        * tree-ssa-loop.c (gate_scev_const_prop): Return the value of\n        flag_tree_scev_cprop.\n        * common.opt (tree-scev-cprop): New flag.\n\n        * tree-vect-transform.c (vect_create_destination_var): Use 'kind' in\n        call to vect_get_new_vect_var.\n\n\nCo-Authored-By: Victor Kaplansky <victork@il.ibm.com>\n\nFrom-SVN: r121643", "tree": {"sha": "3e78c2931f5a1e916ecd248c65d21ec69fd56509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e78c2931f5a1e916ecd248c65d21ec69fd56509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/comments", "author": null, "committer": null, "parents": [{"sha": "426147a1e8ca92e3c32168f50dc9a2d04825c42c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/426147a1e8ca92e3c32168f50dc9a2d04825c42c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/426147a1e8ca92e3c32168f50dc9a2d04825c42c"}], "stats": {"total": 980, "additions": 892, "deletions": 88}, "files": [{"sha": "8badc160f2caf591032ca461f2606f9e7e60d2d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -1,3 +1,29 @@\n+2007-02-06  Dorit Nuzman  <dorit@il.ibm.com>\n+\t    Victor Kaplansky  <victork@il.ibm.com>\n+\n+\t* tree-vectorizer.c (vect_is_simple_use): Support induction.\n+\t(vect_is_simple_reduction): Support reduction with induction as\n+\tone of the operands.\n+\t(vect_is_simple_iv_evolution): Fix formatting.\n+\t* tree-vect-analyze.c (vect_mark_stmts_to_be_vectorized): Fix \n+\tformatting.  Don't mark induction phis for vectorization.\n+\t(vect_analyze_scalar_cycles): Analyze all inductions, then reductions.\n+\t* tree-vect-transform.c (get_initial_def_for_induction): New function.\n+\t(vect_get_vec_def_for_operand): Support induction.\n+\t(vect_get_vec_def_for_stmt_copy): Fix formatting and add check for\n+\tinduction case.\n+\t(vectorizable_reduction): Support reduction with induction as one of \n+\tthe operands. \n+\t(vectorizable_type_demotion): Use def-type of stmt argument rather\n+\tthan dummy def-type.\n+\n+\t* tree-ssa-loop.c (gate_scev_const_prop): Return the value of\n+\tflag_tree_scev_cprop.\n+\t* common.opt (tree-scev-cprop): New flag.\n+\n+\t* tree-vect-transform.c (vect_create_destination_var): Use 'kind' in\n+\tcall to vect_get_new_vect_var.\n+\n 2007-02-06  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-vect-patterns.c (vect_recog_widen_mult_pattern): Check that "}, {"sha": "cfb7967c2863dfb96f266722385df29521198e83", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -1080,6 +1080,10 @@ ftree-vectorizer-verbose=\n Common RejectNegative Joined\n -ftree-vectorizer-verbose=<number>\tSet the verbosity level of the vectorizer\n \n+ftree-scev-cprop\n+Common Report Var(flag_tree_scev_cprop) Init(1)\n+Enable copy propagation of scalar-evolution information.\n+\n ; -fverbose-asm causes extra commentary information to be produced in\n ; the generated assembly code (to make it more readable).  This option\n ; is generally only of use to those who actually need to read the"}, {"sha": "d86d8725ef53421c1531428e62c00bae5ae2d091", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -1,3 +1,28 @@\n+2007-02-06  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect.exp: Add support for -fno-tree-scev-cprop tests.\n+\t* gcc.dg/vect/vect-iv-1.c: New test.\n+\t* gcc.dg/vect/vect-iv-2.c: New test.\n+\t* gcc.dg/vect/vect-iv-3.c: New test.\n+\t* gcc.dg/vect/vect-iv-4.c: New test.\n+\t* gcc.dg/vect/vect-iv-5.c: New test.\n+\t* gcc.dg/vect/vect-iv-6.c: New test.\n+\t* gcc.dg/vect/vect-iv-7.c: New test.\n+\t* gcc.dg/vect/vect-iv-8.c: New test.\n+\t* gcc.dg/vect/vect-iv-9.c: New test.\n+\t* gcc.dg/vect/vect-iv-10.c: New test.\n+\t* gcc.dg/vect/vect-iv-11.c: New test.\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-1.c: New test.\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-2.c: New test.\n+\t* gcc.dg/vect/vect-14.c: Now vectorizable.\n+\t* gcc.dg/vect/pr21591.c: Additional loop vectorized (initilization loop).\n+\t* gcc.dg/vect/vect-27.c: Likewise.\n+\t* gcc.dg/vect/vect-29.c Likewise.\n+\t* gcc.dg/vect/vect-dv-2.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-u16a.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-dot-u16b.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-u16.c: Likewise.\n+\n 2007-02-06  Ira Rosen  <irar@il.ibm.com> \n \n \t* gcc.dg/vect/fast-math-vect-pow-2.c: New test."}, {"sha": "60c6ff59b0f282ff5bbc40046c5e44a90adc1253", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-scev-cprop-vect-iv-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-1.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 26\n+ \n+int main1 (int X)\n+{  \n+  int s = X;\n+  int i;\n+\n+  /* vectorization of reduction with induction. \n+     Need -fno-tree-scev-cprop or else the loop is eliminated.  */\n+  for (i = 0; i < N; i++)\n+    s += i;\n+\n+  return s;\n+}\n+\n+int main (void)\n+{ \n+  int s;\n+  check_vect ();\n+  \n+  s = main1 (3);\n+  if (s != 328)\n+    abort ();\n+\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5e1c7b89bac1a2f505747b47c8b081dc60b9c2d4", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-scev-cprop-vect-iv-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-2.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+ \n+int main1 ()\n+{  \n+  int arr1[N];\n+  int k = 0;\n+  int m = 3, i = 0;\n+  \n+  /* Vectorization of induction that is used after the loop.  \n+     Currently vectorizable because scev_ccp disconnects the\n+     use-after-the-loop from the iv def inside the loop.  */\n+\n+   do { \n+        k = k + 2;\n+        arr1[i] = k;\n+\tm = m + k;\n+\ti++;\n+   } while (i < N);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (arr1[i] != 2+2*i)\n+        abort ();\n+    }\n+\n+  return m + k;\n+}\n+\n+int main (void)\n+{ \n+  int res;\n+\n+  check_vect ();\n+  \n+  res = main1 ();\n+  if (res != 32 + 275)\n+    abort ();\n+\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0a665b6a797154e3bc8e4ea5c87c49ea752a0943", "filename": "gcc/testsuite/gcc.dg/vect/pr21591.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr21591.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr21591.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr21591.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -30,6 +30,6 @@ void f(void)\n    free(c);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "cb0407654f09be415860915ae01cd0297b9cfce7", "filename": "gcc/testsuite/gcc.dg/vect/vect-14.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-14.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -10,8 +10,7 @@ int main1 ()\n   int i;\n   int ia[N];\n \n-\n-  /* Not vectorizable yet (induction).  */\n+  /* Induction.  */\n   for ( i = 0; i < N; i++) {\n     ia[i] = i;\n   }\n@@ -33,5 +32,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9faf77643ab0f4e9c85c059130fd7fe38a6d2848", "filename": "gcc/testsuite/gcc.dg/vect/vect-27.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -40,7 +40,9 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* The initialization induction loop (with aligned access) is also vectorized.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "eef68e4100056eb3b13fa2e50696436bf8b502f2", "filename": "gcc/testsuite/gcc.dg/vect/vect-29.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -46,7 +46,8 @@ int main (void)\n /* For targets that don't support misaligned loads we version for the load.\n    (The store is aligned).  */\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* The initialization induction loop (with aligned access) is also vectorized.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" {target vect_no_align } } } */"}, {"sha": "30d229c1996afbc0426f33201d220530c8afbc0b", "filename": "gcc/testsuite/gcc.dg/vect/vect-dv-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -71,7 +71,7 @@ int main ()\n }\n \n \n-\n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* The initialization induction loop (with aligned access) is also vectorized.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4bd082a8da4c7e50579ae4585f55c0f37e125fc9", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-1.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+int result[N] = {8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38};\n+ \n+int main1 (int X)\n+{  \n+  int arr[N];\n+  int k = X;\n+  int m, i=0;\n+  \n+   /* vectorization of induction.  */\n+\n+   do { \n+        m = k + 5;\n+        arr[i] = m;\n+        k = k + 2;\n+\ti++;\n+   } while (i < N);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (arr[i] != result[i])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 (3);\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e4242009b41c26a2c3523b40ee0d92dbcf4f0ceb", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-10.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-10.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+int main1 ()\n+{\n+  int i,j;\n+  int ia[N];\n+\n+  /* Induction.  */\n+  for (j=0,i=N;  j<N,i>0;  i--,j++) {\n+    ia[j] = i;\n+  }\n+\n+  /* check results:  */\n+  for (j=0,i=N;  j<N,i>0;  i--,j++) {\n+      if (ia[j] != i)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "2caadec1f93dfe7d0b52cc491f5eea87b4b61f93", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-11.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-11.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+int main1 (int len)\n+{  \n+  int s = 0;\n+  int i = len;\n+\n+  /* vectorization of induction with reduction.  */\n+  for ( ; i > 1; i -=2)\n+    s += i;\n+\n+  return s;\n+}\n+\n+int main (void)\n+{ \n+  int s;\n+  check_vect ();\n+  \n+  s = main1 (26);\n+  if (s != 182)\n+    abort ();\n+\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "831b00588db08da3b29f6f2a1e2af32827ede804", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-2.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+ \n+int main1 ()\n+{  \n+  int arr1[N];\n+  int k = 0;\n+  int m = 3, i = 0;\n+  \n+  /* Vectorization of induction that is used after the loop.  \n+     Currently vectorizable because scev_ccp disconnects the\n+     use-after-the-loop from the iv def inside the loop.  */\n+\n+   do { \n+        k = k + 2;\n+        arr1[i] = k;\n+\tm = m + k;\n+\ti++;\n+   } while (i < N);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (arr1[i] != 2+2*i)\n+        abort ();\n+    }\n+\n+  return m + k;\n+}\n+\n+int main (void)\n+{ \n+  int res;\n+\n+  check_vect ();\n+  \n+  res = main1 ();\n+  if (res != 32 + 275)\n+    abort ();\n+\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "effa8ecffb30a0a0f266d46cd0b54455b9a3d8a2", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-3.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-3.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+ \n+int main1 ()\n+{  \n+  int arr1[N];\n+  int arr2[N];\n+  int k = 0;\n+  int m = 3, i = 0;\n+  \n+  /* vectorization of induction. \n+     Peeling to align the store is also applied.  */\n+\n+   do { \n+        k = k + 2;\n+        arr1[i] = k;\n+\tm = k + 3;\n+\tarr2[i] = m;\n+\ti++;\n+   } while (i < N);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (arr1[i] != 2+2*i || arr2[i] != 5 + 2*i)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c860f6860585df627237ab9f238a9b39fdd1691c", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-4.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+ \n+int main1 ()\n+{  \n+  unsigned int arr1[N];\n+  unsigned short arr2[N];\n+  unsigned int k = 0;\n+  unsigned short m = 3;\n+  int i = 0;\n+  \n+  /* Vectorization of induction with multiple data types.  */\n+\n+   do { \n+        k = k + 2;\n+        arr1[i] = k;\n+\tm = k + 3;\n+\tarr2[i] = m;\n+\ti++;\n+   } while (i < N);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (arr1[i] != 2+2*i || arr2[i] != 5 + 2*i)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "6c5cb669783681e410b8e58a57d4387e7c332cc4", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-5.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-5.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+ \n+int main1 ()\n+{  \n+  float arr[N];\n+  float f = 1.0;\n+  int i;\n+  \n+  /* Vectorization of fp induction.  */\n+\n+  for (i=0; i<N; i++)\n+    {\n+      arr[i] = f;\n+      f += 2.0;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (arr[i] != 1.0 + 2.0*i)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3c301eb58d1e1eb6f07ac3ebaa8c9641d1d32650", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-6.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-6.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+ \n+int main1 (int X)\n+{  \n+  int arr1[N+1];\n+  int arr2[N+1];\n+  int k = X;\n+  int m, i=0;\n+  \n+   /* Vectorization of induction with non-constant initial condition X. \n+      Also we have here two uses of the induction-variable k as defined\n+      by the loop-header phi (as opposed to the other uses of k that are\n+      defined in the loop), in which case we exercise the fact that we\n+      reuse the same vector def-use-cycle for both uses. \n+      Peeling to align the store is also applied.  */\n+\n+   do { \n+\tarr2[i+1] = 2*k;\n+        k = k + 2;\n+        arr1[i+1] = k;\n+        k = k + 4;\n+\ti++;\n+   } while (i < N);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (arr1[i+1] != X+6*i+2\n+\t  || arr2[i+1] != 2*(X+6*i))\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 (3);\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "eafeb309dd82babf383ddede07f85b031f5482cc", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-7.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-7.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+int result[N] = {8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38};\n+ \n+int main1 (int X)\n+{  \n+  int arr[N];\n+  int k = 3;\n+  int m, i=0;\n+  \n+   /* Vectorization of induction with non-constant step X.  */\n+\n+   do { \n+        m = k + 5;\n+        arr[i] = m;\n+        k = k + X;\n+\ti++;\n+   } while (i < N);\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (arr[i] != result[i])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 (2);\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a2d4e375299b75f5e8ed491e61eb986481fd405d", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-8.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-8.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 26\n+ \n+int main1 (short X)\n+{  \n+  unsigned char a[N];\n+  unsigned short b[N];\n+  unsigned int c[N];\n+  int i;\n+\n+  /* vectorization of induction with type conversions.  */\n+  for (i = 0; i < N; i++)\n+  {\n+    a[i] = (unsigned char)X;\n+    b[i] = X;\n+    c[i] = (unsigned int)X;\n+  }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (a[i] != (char)X || b[i] != X || c[i] != (int)X)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 (3);\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_pack_mod && vect_unpack } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "12d4d35b7532f229bb03cc2b881be35185508fe5", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-9.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-9.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 26\n+int a[N];\n+ \n+int main1 (int X)\n+{  \n+  int s = X;\n+  int i;\n+\n+  /* vectorization of reduction with induction.  */\n+  for (i = 0; i < N; i++)\n+    s += (i + a[i]);\n+\n+  return s;\n+}\n+\n+int main (void)\n+{ \n+  int s, i;\n+  check_vect ();\n+  \n+  for (i = 0; i < N; i++)\n+    a[i] = 2*i;\n+\n+  s = main1 (3);\n+  if (s != 978)\n+    abort ();\n+\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "334cc239d8bd29cf430f7eff9a51d71ac514e3dc", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16a.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16a.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -46,7 +46,7 @@ int main (void)\n   return 0;\n }\n \n+/* The initialization loop in main also gets vectorized.  */\n /* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_short_mult && vect_widen_sum_hi_to_si } } } } */ \n-\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target { vect_short_mult && vect_widen_sum_hi_to_si } } } } */ \n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9bb5cdf0fb6031991938d2181623a415c6999628", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16b.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-dot-u16b.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -51,6 +51,8 @@ int main (void)\n /* Once the dot-product pattern is detected, we expect\n    that loop to be vectorized on vect_udot_hi targets (targets that support \n    dot-product of unsigned shorts) and targets that support widening multiplication.  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */ \n+/* The induction loop in main is vectorized.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */ \n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */ \n \n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c2cd0801a3ae131a47ff7b1933b4278db47a837b", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u16.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -42,6 +42,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/*The induction loop is vectorized  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "547dbd4346440f6bcd15b3aad986abfe958504f0", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -156,6 +156,12 @@ lappend DEFAULT_VECTCFLAGS \"-fno-trapping-math\"\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-trapping-math-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n+# -fno-tree-scev-cprop\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-scev-cprop-*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n # With -Os\n lappend DEFAULT_VECTCFLAGS \"-Os\"\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/Os-vect-*.\\[cS\\]]]  \\"}, {"sha": "bdf7ade94a547eb55b51c4994a2e785a95fab73a", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -280,7 +280,7 @@ struct tree_opt_pass pass_iv_canon =\n static bool\n gate_scev_const_prop (void)\n {\n-  return true;\n+  return flag_tree_scev_cprop;\n }\n \n struct tree_opt_pass pass_scev_cprop ="}, {"sha": "4d74d18c8c4415d18445738d01b57565c02de285", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 60, "deletions": 45, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -509,58 +509,69 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n   tree phi;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block bb = loop->header;\n-  tree dummy;\n+  tree dumy;\n+  VEC(tree,heap) *worklist = VEC_alloc (tree, heap, 64);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_scalar_cycles ===\");\n \n+  /* First - identify all inductions.  */\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree access_fn = NULL;\n       tree def = PHI_RESULT (phi);\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n-      tree reduc_stmt;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n-          fprintf (vect_dump, \"Analyze phi: \");\n-          print_generic_expr (vect_dump, phi, TDF_SLIM);\n+\t  fprintf (vect_dump, \"Analyze phi: \");\n+\t  print_generic_expr (vect_dump, phi, TDF_SLIM);\n \t}\n \n       /* Skip virtual phi's. The data dependences that are associated with\n          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n-\n       if (!is_gimple_reg (SSA_NAME_VAR (def)))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"virtual phi. skip.\");\n-\t  continue;\n-\t}\n+\tcontinue;\n \n       STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_unknown_def_type;\n \n       /* Analyze the evolution function.  */\n-\n       access_fn = analyze_scalar_evolution (loop, def);\n+      if (access_fn && vect_print_dump_info (REPORT_DETAILS))\n+\t{\n+\t  fprintf (vect_dump, \"Access function of PHI: \");\n+\t  print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n+\t}\n \n-      if (!access_fn)\n-\tcontinue;\n+      if (!access_fn\n+\t  || !vect_is_simple_iv_evolution (loop->num, access_fn, &dumy, &dumy)) \n+\t{\n+\t  VEC_safe_push (tree, heap, worklist, phi);\t  \n+\t  continue;\n+\t}\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n-        {\n-           fprintf (vect_dump, \"Access function of PHI: \");\n-           print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n-        }\n+\tfprintf (vect_dump, \"Detected induction.\");\n+      STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_induction_def;\n+    }\n \n-      if (vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, &dummy))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"Detected induction.\");\n-\t  STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_induction_def;\n-          continue;\n-\t}\n \n-      /* TODO: handle invariant phis  */\n+  /* Second - identify all reductions.  */\n+  while (VEC_length (tree, worklist) > 0)\n+    {\n+      tree phi = VEC_pop (tree, worklist);\n+      tree def = PHI_RESULT (phi);\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n+      tree reduc_stmt;\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        { \n+          fprintf (vect_dump, \"Analyze phi: \");\n+          print_generic_expr (vect_dump, phi, TDF_SLIM);\n+        }\n+\n+      gcc_assert (is_gimple_reg (SSA_NAME_VAR (def)));\n+      gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_unknown_def_type);\n \n       reduc_stmt = vect_is_simple_reduction (loop, phi);\n       if (reduc_stmt)\n@@ -574,9 +585,9 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n       else\n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Unknown def-use cycle pattern.\");\n-\n     }\n \n+  VEC_free (tree, heap, worklist);\n   return;\n }\n \n@@ -1908,7 +1919,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n   tree scalar_type;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_data_refs ===\");\n+    fprintf (vect_dump, \"=== vect_analyze_data_refs ===\\n\");\n \n   compute_data_dependences_for_loop (loop, true,\n                                      &LOOP_VINFO_DATAREFS (loop_vinfo),\n@@ -1933,7 +1944,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n       /* Update DR field in stmt_vec_info struct.  */\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n-  \n+\n       if (STMT_VINFO_DATA_REF (stmt_info))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n@@ -2249,14 +2260,21 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n       /* case 2.2:  */\n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n-        {\n-          gcc_assert (relevant == vect_unused_in_loop && live_p);\n-          relevant = vect_used_by_reduction;\n-          live_p = false;\n-        }\n+\t{\n+\t  gcc_assert (relevant == vect_unused_in_loop && live_p);\n+\t  relevant = vect_used_by_reduction;\n+\t  live_p = false;\n+\t}\n \n+      i = 0;\n       FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n \t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"worklist: examine use %d: \", i++);\n+\t      print_generic_expr (vect_dump, use, TDF_SLIM);\n+\t    }\n+\n \t  /* case 1: we are only interested in uses that need to be vectorized. \n \t     Uses that are used for address computation are not considered \n \t     relevant.\n@@ -2265,32 +2283,29 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    continue;\n \n \t  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n-            {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t\tfprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n \t      VEC_free (tree, heap, worklist);\n-              return false;\n+\t      return false;\n             }\n \n \t  if (!def_stmt || IS_EMPTY_STMT (def_stmt))\n \t    continue;\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"worklist: examine use %d: \", i);\n-              print_generic_expr (vect_dump, use, TDF_SLIM);\n-            }\n-\n \t  bb = bb_for_stmt (def_stmt);\n-          if (!flow_bb_inside_loop_p (loop, bb))\n-            continue;\n+\t  if (!flow_bb_inside_loop_p (loop, bb))\n+\t    continue;\n \n \t  /* case 2.1: the reduction-use does not mark the defining-phi\n \t     as relevant.  */\n \t  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n \t      && TREE_CODE (def_stmt) == PHI_NODE)\n \t    continue;\n \n+\t  if (dt == vect_induction_def && TREE_CODE (def_stmt) == PHI_NODE)\n+\t    continue;\n+\n \t  vect_mark_relevant (&worklist, def_stmt, relevant, live_p);\n \t}\n     }\t\t\t\t/* while worklist */"}, {"sha": "d7488b1b47d97a108899b3b766d832ceca56ba8f", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 199, "deletions": 13, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -462,7 +462,7 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n   new_name = get_name (scalar_dest);\n   if (!new_name)\n     new_name = \"var_\";\n-  vec_dest = vect_get_new_vect_var (type, vect_simple_var, new_name);\n+  vec_dest = vect_get_new_vect_var (type, kind, new_name);\n   add_referenced_var (vec_dest);\n \n   return vec_dest;\n@@ -510,6 +510,189 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n }\n \n \n+/* Function get_initial_def_for_induction\n+\n+   Input:\n+   STMT - a stmt that performs an induction operation in the loop.\n+   IV_PHI - the initial value of the induction variable\n+\n+   Output:\n+   Return a vector variable, initialized with the first VF values of\n+   the induction variable. E.g., for an iv with IV_PHI='X' and\n+   evolution S, for a vector of 4 units, we want to return: \n+   [X, X + S, X + 2*S, X + 3*S].  */\n+\n+static tree\n+get_initial_def_for_induction (tree stmt, tree iv_phi)\n+{\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  tree scalar_type = TREE_TYPE (iv_phi);\n+  tree vectype = get_vectype_for_scalar_type (scalar_type);\n+  int nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n+  edge pe = loop_preheader_edge (loop);\n+  basic_block new_bb;\n+  block_stmt_iterator bsi;\n+  tree vec, vec_init, vec_step, t;\n+  tree access_fn;\n+  tree new_var;\n+  tree new_name;\n+  tree init_stmt;\n+  tree induction_phi, induc_def, new_stmt, vec_def, vec_dest;\n+  tree init_expr, step_expr;\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  int i;\n+  bool ok;\n+  int ncopies = vf / nunits;\n+  tree expr;\n+  stmt_vec_info phi_info = vinfo_for_stmt (iv_phi);\n+\n+  gcc_assert (phi_info);\n+\n+  if (STMT_VINFO_VEC_STMT (phi_info))\n+    {\n+      induction_phi = STMT_VINFO_VEC_STMT (phi_info);\n+      gcc_assert (TREE_CODE (induction_phi) == PHI_NODE);\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\t{\n+\t  fprintf (vect_dump, \"induction already vectorized:\");\n+\t  print_generic_expr (vect_dump, iv_phi, TDF_SLIM);\n+\t  fprintf (vect_dump, \"\\n\");\n+\t  print_generic_expr (vect_dump, induction_phi, TDF_SLIM);\n+\t}\n+\n+      return PHI_RESULT (induction_phi);\n+    }\n+\n+  gcc_assert (ncopies >= 1);\n+ \n+  access_fn = analyze_scalar_evolution (loop, PHI_RESULT (iv_phi));\n+  gcc_assert (access_fn);\n+  ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_expr, &step_expr);\n+  gcc_assert (ok);\n+\n+  /* Create the vector that holds the initial_value of the induction.  */\n+  new_name = init_expr;\n+  t = NULL_TREE;\n+  t = tree_cons (NULL_TREE, init_expr, t);\n+  for (i = 1; i < nunits; i++)\n+    {\n+      /* Create: new_name = new_name + step_expr  */\n+      new_var = vect_get_new_vect_var (scalar_type, vect_scalar_var, \"var_\");\n+      add_referenced_var (new_var);\n+      init_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var,\n+                          fold_build2 (PLUS_EXPR, scalar_type, new_name, step_expr));\n+      new_name = make_ssa_name (new_var, init_stmt);\n+      GIMPLE_STMT_OPERAND (init_stmt, 0) = new_name;\n+\n+      new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n+      gcc_assert (!new_bb);\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"created new init_stmt: \");\n+          print_generic_expr (vect_dump, init_stmt, TDF_SLIM);\n+        }\n+      t = tree_cons (NULL_TREE, new_name, t);\n+    }\n+  vec = build_constructor_from_list (vectype, nreverse (t));\n+  vec_init = vect_init_vector (stmt, vec, vectype);\n+\n+\n+  /* Create the vector that holds the step of the induction.  */\n+  expr = build_int_cst (scalar_type, vf);\n+  new_name = fold_build2 (MULT_EXPR, scalar_type, expr, step_expr);\n+  t = NULL_TREE;\n+  for (i = 0; i < nunits; i++)\n+    t = tree_cons (NULL_TREE, unshare_expr (new_name), t);\n+  vec = build_constructor_from_list (vectype, t);\n+  vec_step = vect_init_vector (stmt, vec, vectype);\n+\n+\n+  /* Create the following def-use cycle:\n+     loop prolog:\n+         vec_init = [X, X+S, X+2*S, X+3*S]\n+\t vec_step = [VF*S, VF*S, VF*S, VF*S]\n+     loop:\n+         vec_iv = PHI <vec_init, vec_loop>\n+         ...\n+         STMT\n+         ...\n+         vec_loop = vec_iv + vec_step;  */\n+\n+  /* Create the induction-phi that defines the induction-operand.  */\n+  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n+  add_referenced_var (vec_dest);\n+  induction_phi = create_phi_node (vec_dest, loop->header);\n+  set_stmt_info (get_stmt_ann (induction_phi),\n+                 new_stmt_vec_info (induction_phi, loop_vinfo));\n+  induc_def = PHI_RESULT (induction_phi);\n+\n+  /* Create the iv update inside the loop  */\n+  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, NULL_TREE,\n+                     build2 (PLUS_EXPR, vectype, induc_def, vec_step));\n+  vec_def = make_ssa_name (vec_dest, new_stmt);\n+  GIMPLE_STMT_OPERAND (new_stmt, 0) = vec_def;\n+  bsi = bsi_for_stmt (stmt);\n+  vect_finish_stmt_generation (stmt, new_stmt, &bsi);\n+\n+  /* Set the arguments of the phi node:  */\n+  add_phi_arg (induction_phi, vec_init, loop_preheader_edge (loop));\n+  add_phi_arg (induction_phi, vec_def, loop_latch_edge (loop));\n+\n+\n+  /* In case the vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits.  For more details see documentation\n+     in vectorizable_operation.  */\n+  \n+  if (ncopies > 1)\n+    {\n+      stmt_vec_info prev_stmt_vinfo;\n+\n+      /* Create the vector that holds the step of the induction.  */\n+      expr = build_int_cst (scalar_type, nunits);\n+      new_name = fold_build2 (MULT_EXPR, scalar_type, expr, step_expr);\n+      t = NULL_TREE;\n+      for (i = 0; i < nunits; i++)\n+\tt = tree_cons (NULL_TREE, unshare_expr (new_name), t);\n+      vec = build_constructor_from_list (vectype, t);\n+      vec_step = vect_init_vector (stmt, vec, vectype);\n+\n+      vec_def = induc_def;\n+      prev_stmt_vinfo = vinfo_for_stmt (induction_phi);\n+      for (i = 1; i < ncopies; i++)\n+\t{\n+\t  /* vec_i = vec_prev + vec_{step*nunits}  */\n+\t\t\t \n+\t  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, NULL_TREE,\n+\t\t\tbuild2 (PLUS_EXPR, vectype, vec_def, vec_step));\n+\t  vec_def = make_ssa_name (vec_dest, new_stmt);\n+\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = vec_def;\n+\t  bsi = bsi_for_stmt (stmt);\n+\t  vect_finish_stmt_generation (stmt, new_stmt, &bsi);\n+\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt;\n+\t  prev_stmt_vinfo = vinfo_for_stmt (new_stmt); \n+\t}\n+    }\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    {\n+      fprintf (vect_dump, \"transform induction: created def-use cycle:\");\n+      print_generic_expr (vect_dump, induction_phi, TDF_SLIM);\n+      fprintf (vect_dump, \"\\n\");\n+      print_generic_expr (vect_dump, SSA_NAME_DEF_STMT (vec_def), TDF_SLIM);\n+    }\n+\n+  STMT_VINFO_VEC_STMT (phi_info) = induction_phi;\n+  return induc_def;\n+}\n+\n+\n /* Function vect_get_vec_def_for_operand.\n \n    OP is an operand in STMT. This function returns a (vector) def that will be\n@@ -634,9 +817,10 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n     /* Case 5: operand is defined by loop-header phi - induction.  */\n     case vect_induction_def:\n       {\n-        if (vect_print_dump_info (REPORT_DETAILS))\n-          fprintf (vect_dump, \"induction - unsupported.\");\n-        internal_error (\"no support for induction\"); /* FORNOW */\n+\tgcc_assert (TREE_CODE (def_stmt) == PHI_NODE);\n+\n+\t/* Get the def before the loop  */\n+\treturn get_initial_def_for_induction (stmt, def_stmt);\n       }\n \n     default:\n@@ -707,14 +891,14 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n   tree vec_stmt_for_operand;\n   stmt_vec_info def_stmt_info;\n \n-  if (dt == vect_invariant_def || dt == vect_constant_def)\n-    {\n-      /* Do nothing; can reuse same def.  */ ;\n-      return vec_oprnd;\n-    }\n+  /* Do nothing; can reuse same def.  */\n+  if (dt == vect_invariant_def || dt == vect_constant_def )\n+    return vec_oprnd;\n \n   vec_stmt_for_operand = SSA_NAME_DEF_STMT (vec_oprnd);\n   def_stmt_info = vinfo_for_stmt (vec_stmt_for_operand);\n+  if (dt == vect_induction_def)\n+    gcc_assert (TREE_CODE (vec_stmt_for_operand) == PHI_NODE);  \n   gcc_assert (def_stmt_info);\n   vec_stmt_for_operand = STMT_VINFO_RELATED_STMT (def_stmt_info);\n   gcc_assert (vec_stmt_for_operand);\n@@ -1386,8 +1570,11 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       op = TREE_OPERAND (operation, i);\n       is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt);\n       gcc_assert (is_simple_use);\n-      gcc_assert (dt == vect_loop_def || dt == vect_invariant_def ||\n-                  dt == vect_constant_def);\n+      if (dt != vect_loop_def\n+\t  && dt != vect_invariant_def\n+\t  && dt != vect_constant_def\n+\t  && dt != vect_induction_def)\n+\treturn false;\n     }\n \n   op = TREE_OPERAND (operation, i);\n@@ -2260,9 +2447,8 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n       /* Handle uses.  */\n       if (j == 0)\n \t{\n-\t  enum vect_def_type dt = vect_unknown_def_type; /* Dummy */\n \t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd0);\n+\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n \t}\n       else\n \t{"}, {"sha": "9f64f2c18b79b9389d1e69cf745145d2d96f23a4", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf798fcc5f1a456213c99d59df41adaf38ad4d8/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=fbf798fcc5f1a456213c99d59df41adaf38ad4d8", "patch": "@@ -1745,13 +1745,6 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n       return false;\n     }\n \n-  if (*dt == vect_induction_def)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"induction not supported.\");\n-      return false;\n-    }\n-\n   return true;\n }\n \n@@ -2050,7 +2043,7 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n    */\n   def1 = SSA_NAME_DEF_STMT (op1);\n   def2 = SSA_NAME_DEF_STMT (op2);\n-  if (!def1 || !def2)\n+  if (!def1 || !def2 || IS_EMPTY_STMT (def1) || IS_EMPTY_STMT (def2))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n@@ -2060,9 +2053,15 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n       return NULL_TREE;\n     }\n \n-  if (TREE_CODE (def1) == GIMPLE_MODIFY_STMT\n+\n+  /* Check that one def is the reduction def, defined by PHI,\n+     the other def is either defined in the loop by a GIMPLE_MODIFY_STMT,\n+     or it's an induction (defined by some phi node).  */\n+\n+  if (def2 == phi\n       && flow_bb_inside_loop_p (loop, bb_for_stmt (def1))\n-      && def2 == phi)\n+      && (TREE_CODE (def1) == GIMPLE_MODIFY_STMT \n+\t  || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_induction_def))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n@@ -2071,9 +2070,10 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n         }\n       return def_stmt;\n     }\n-  else if (TREE_CODE (def2) == GIMPLE_MODIFY_STMT\n-      && flow_bb_inside_loop_p (loop, bb_for_stmt (def2))\n-      && def1 == phi)\n+  else if (def1 == phi\n+\t   && flow_bb_inside_loop_p (loop, bb_for_stmt (def2))\n+\t   && (TREE_CODE (def2) == GIMPLE_MODIFY_STMT \n+\t       || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_induction_def))\n     {\n       /* Swap operands (just for simplicity - so that the rest of the code\n \t can assume that the reduction variable is always the last (second)\n@@ -2110,7 +2110,6 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n {\n   tree init_expr;\n   tree step_expr;\n-  \n   tree evolution_part = evolution_part_in_loop_num (access_fn, loop_nb);\n \n   /* When there is no evolution in this loop, the evolution function\n@@ -2124,8 +2123,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n     return false;\n   \n   step_expr = evolution_part;\n-  init_expr = unshare_expr (initial_condition_in_loop_num (access_fn,\n-                                                           loop_nb));\n+  init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, loop_nb));\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -2139,7 +2137,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n   *step = step_expr;\n \n   if (TREE_CODE (step_expr) != INTEGER_CST)\n-    {\n+    { \n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"step unknown.\");\n       return false;"}]}