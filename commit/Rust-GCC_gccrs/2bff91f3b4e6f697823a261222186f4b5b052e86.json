{"sha": "2bff91f3b4e6f697823a261222186f4b5b052e86", "node_id": "C_kwDOANBUbNoAKDJiZmY5MWYzYjRlNmY2OTc4MjNhMjYxMjIyMTg2ZjRiNWIwNTJlODY", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-12-09T02:37:09Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-12-09T02:37:09Z"}, "message": "[PR103024,PR103530] support throwing compares and non-boolean types\n\nThis patch adjusts the harden-compares pass to cope with compares that\nend basic blocks, and to accept non-boolean integral types whose\nconversion to boolean may have been discarded.\n\n\nfor  gcc/ChangeLog\n\n\tPR tree-optimization/103024\n\tPR middle-end/103530\n\t* gimple-harden-conditionals.cc (non_eh_succ_edge): New.\n\t(pass_harden_compares::execute): Accept 1-bit integral types,\n\tand cope with throwing compares.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR tree-optimization/103024\n\tPR middle-end/103530\n\t* g++.dg/pr103024.C: New.\n\t* g++.dg/pr103530.C: New.", "tree": {"sha": "cba13c4bcd310347f5c0722bd0e19077adaea3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cba13c4bcd310347f5c0722bd0e19077adaea3b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bff91f3b4e6f697823a261222186f4b5b052e86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bff91f3b4e6f697823a261222186f4b5b052e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bff91f3b4e6f697823a261222186f4b5b052e86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bff91f3b4e6f697823a261222186f4b5b052e86/comments", "author": null, "committer": null, "parents": [{"sha": "641ff2196fe3909bba852a5ac1d55e7cdab6d361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641ff2196fe3909bba852a5ac1d55e7cdab6d361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641ff2196fe3909bba852a5ac1d55e7cdab6d361"}], "stats": {"total": 113, "additions": 109, "deletions": 4}, "files": [{"sha": "5e709c66416b7f4d41e7045bd59144693d698b2e", "filename": "gcc/gimple-harden-conditionals.cc", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bff91f3b4e6f697823a261222186f4b5b052e86/gcc%2Fgimple-harden-conditionals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bff91f3b4e6f697823a261222186f4b5b052e86/gcc%2Fgimple-harden-conditionals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-harden-conditionals.cc?ref=2bff91f3b4e6f697823a261222186f4b5b052e86", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"cfghooks.h\"\n #include \"cfgloop.h\"\n+#include \"tree-eh.h\"\n #include \"diagnostic.h\"\n #include \"intl.h\"\n \n@@ -359,6 +360,24 @@ make_pass_harden_conditional_branches (gcc::context *ctxt)\n   return new pass_harden_conditional_branches (ctxt);\n }\n \n+/* Return the fallthru edge of a block whose other edge is an EH\n+   edge.  */\n+static inline edge\n+non_eh_succ_edge (basic_block bb)\n+{\n+  gcc_checking_assert (EDGE_COUNT (bb->succs) == 2);\n+\n+  edge ret = find_fallthru_edge (bb->succs);\n+\n+  int eh_idx = EDGE_SUCC (bb, 0) == ret;\n+  edge eh = EDGE_SUCC (bb, eh_idx);\n+\n+  gcc_checking_assert (!(ret->flags & EDGE_EH)\n+\t\t       && (eh->flags & EDGE_EH));\n+\n+  return ret;\n+}\n+\n /* Harden boolean-yielding compares in FUN.  */\n \n unsigned int\n@@ -449,7 +468,11 @@ pass_harden_compares::execute (function *fun)\n \tif (VECTOR_TYPE_P (TREE_TYPE (op1)))\n \t  continue;\n \n-\tgcc_checking_assert (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE);\n+\t/* useless_type_conversion_p enables conversions from 1-bit\n+\t   integer types to boolean to be discarded.  */\n+\tgcc_checking_assert (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE\n+\t\t\t     || (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t\t\t\t && TYPE_PRECISION (TREE_TYPE (lhs)) == 1));\n \n \ttree rhs = copy_ssa_name (lhs);\n \n@@ -460,6 +483,20 @@ pass_harden_compares::execute (function *fun)\n \t   won't be debug stmts only.  */\n \tgsi_next_nondebug (&gsi_split);\n \n+\tbool throwing_compare_p = stmt_ends_bb_p (asgn);\n+\tif (throwing_compare_p)\n+\t  {\n+\t    basic_block nbb = split_edge (non_eh_succ_edge\n+\t\t\t\t\t  (gimple_bb (asgn)));\n+\t    gsi_split = gsi_start_bb (nbb);\n+\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n+\t\t       \"Splitting non-EH edge from block %i into %i\"\n+\t\t       \" after a throwing compare\\n\",\n+\t\t       gimple_bb (asgn)->index, nbb->index);\n+\t  }\n+\n \tbool same_p = (op1 == op2);\n \top1 = detach_value (loc, &gsi_split, op1);\n \top2 = same_p ? op1 : detach_value (loc, &gsi_split, op2);\n@@ -473,17 +510,46 @@ pass_harden_compares::execute (function *fun)\n \tif (!gsi_end_p (gsi_split))\n \t  {\n \t    gsi_prev (&gsi_split);\n-\t    split_block (bb, gsi_stmt (gsi_split));\n+\t    basic_block obb = gsi_bb (gsi_split);\n+\t    basic_block nbb = split_block (obb, gsi_stmt (gsi_split))->dest;\n \t    gsi_next (&gsi_split);\n \t    gcc_checking_assert (gsi_end_p (gsi_split));\n \n \t    single_succ_edge (bb)->goto_locus = loc;\n \n \t    if (dump_file)\n-\t      fprintf (dump_file, \"Splitting block %i\\n\", bb->index);\n+\t      fprintf (dump_file,\n+\t\t       \"Splitting block %i into %i\"\n+\t\t       \" before the conditional trap branch\\n\",\n+\t\t       obb->index, nbb->index);\n+\t  }\n+\n+\t/* If the check assignment must end a basic block, we can't\n+\t   insert the conditional branch in the same block, so split\n+\t   the block again, and prepare to insert the conditional\n+\t   branch in the new block.\n+\n+\t   Also assign an EH region to the compare.  Even though it's\n+\t   unlikely that the hardening compare will throw after the\n+\t   original compare didn't, the compiler won't even know that\n+\t   it's the same compare operands, so add the EH edge anyway.  */\n+\tif (throwing_compare_p)\n+\t  {\n+\t    add_stmt_to_eh_lp (asgnck, lookup_stmt_eh_lp (asgn));\n+\t    make_eh_edges (asgnck);\n+\n+\t    basic_block nbb = split_edge (non_eh_succ_edge\n+\t\t\t\t\t  (gimple_bb (asgnck)));\n+\t    gsi_split = gsi_start_bb (nbb);\n+\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n+\t\t       \"Splitting non-EH edge from block %i into %i after\"\n+\t\t       \" the newly-inserted reversed throwing compare\\n\",\n+\t\t       gimple_bb (asgnck)->index, nbb->index);\n \t  }\n \n-\tgcc_checking_assert (single_succ_p (bb));\n+\tgcc_checking_assert (single_succ_p (gsi_bb (gsi_split)));\n \n \tinsert_check_and_trap (loc, &gsi_split, EDGE_TRUE_VALUE,\n \t\t\t       EQ_EXPR, lhs, rhs);"}, {"sha": "15e68d40213283e39d22c908a2edbfb99045e41e", "filename": "gcc/testsuite/g++.dg/pr103024.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bff91f3b4e6f697823a261222186f4b5b052e86/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr103024.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bff91f3b4e6f697823a261222186f4b5b052e86/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr103024.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr103024.C?ref=2bff91f3b4e6f697823a261222186f4b5b052e86", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fnon-call-exceptions -fharden-compares -fsignaling-nans\" } */\n+\n+struct G4ErrorMatrix {\n+  G4ErrorMatrix(int);\n+  ~G4ErrorMatrix();\n+};\n+double PropagateError_charge;\n+void PropagateError() {\n+  G4ErrorMatrix transf(0);\n+  int field(PropagateError_charge && field);\n+}"}, {"sha": "c1d2059542ba3da27ca8ffdebaa5b952e41da735", "filename": "gcc/testsuite/g++.dg/pr103530.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bff91f3b4e6f697823a261222186f4b5b052e86/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr103530.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bff91f3b4e6f697823a261222186f4b5b052e86/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr103530.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr103530.C?ref=2bff91f3b4e6f697823a261222186f4b5b052e86", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fharden-compares -Wno-c++11-extensions\" } */\n+\n+enum E:bool\n+{ E0, E1 };\n+\n+int x;\n+\n+E\n+baz (E rtt)\n+{\n+  return rtt == E0 ? E1 : E0;\n+}\n+\n+bool bar ();\n+\n+void\n+foo (E)\n+{\n+  E a = x ? E1 : E0;\n+  if (bar ())\n+    if (bar ())\n+      {\n+\tE b = baz (a);\n+\tfoo (b);\n+      }\n+}"}]}