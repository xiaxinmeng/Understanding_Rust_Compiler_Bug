{"sha": "5785e34c37bc9f15b77e66ee802b41443bd063ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc4NWUzNGMzN2JjOWYxNWI3N2U2NmVlODAyYjQxNDQzYmQwNjNlZg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-19T20:59:51Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-19T20:59:51Z"}, "message": "(emit_move_sequence): Add scratch register.\n\n (emit_move_sequence): Add scratch register.  All callers\n\tchanged.\n\t(legitimize_address): Add scratch register.  All callers changed\n\tto pass zero instead of gen_reg_rtx result.  Allocate another temp\n\tregister for -fPIC case.  Use scratch register for pic cases with\n\ta large constant term.\n\nFrom-SVN: r2517", "tree": {"sha": "2763f39bb6119a9a4e7a6f42decf4810b25933ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2763f39bb6119a9a4e7a6f42decf4810b25933ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5785e34c37bc9f15b77e66ee802b41443bd063ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5785e34c37bc9f15b77e66ee802b41443bd063ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5785e34c37bc9f15b77e66ee802b41443bd063ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5785e34c37bc9f15b77e66ee802b41443bd063ef/comments", "author": null, "committer": null, "parents": [{"sha": "1a31d08dae9d6afa0a329c0dd96a19b705d9d13b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a31d08dae9d6afa0a329c0dd96a19b705d9d13b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a31d08dae9d6afa0a329c0dd96a19b705d9d13b"}], "stats": {"total": 111, "additions": 82, "deletions": 29}, "files": [{"sha": "f720b2a077a2942c72397de774044f5b8b0ec330", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 82, "deletions": 29, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5785e34c37bc9f15b77e66ee802b41443bd063ef/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5785e34c37bc9f15b77e66ee802b41443bd063ef/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=5785e34c37bc9f15b77e66ee802b41443bd063ef", "patch": "@@ -47,7 +47,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.2.13.2 10/13/92 09:26:24\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.2.13.5 10/19/92 15:27:15\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -211,12 +211,16 @@ output_load_const_dimode (operands)\n \n    Return 1 if we have written out everything that needs to be done to\n    do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally.  */\n+   normally.\n+\n+   SCRATCH if non zero can be used as a scratch register for the move\n+   operation.  It is provided by a SECONDARY_RELOAD_* macro if needed.  */\n \n int\n-emit_move_sequence (operands, mode)\n+emit_move_sequence (operands, mode, scratch)\n      rtx *operands;\n      enum machine_mode mode;\n+     rtx scratch;\n {\n   register rtx operand0 = operands[0];\n   register rtx operand1 = operands[1];\n@@ -258,10 +262,10 @@ emit_move_sequence (operands, mode)\n \t    && GET_CODE (operand1) != CONST_DOUBLE)\n \t  {\n \t    rtx temp = ((reload_in_progress || reload_completed)\n-\t\t\t? operand0 : gen_reg_rtx (Pmode));\n+\t\t\t? operand0 : 0);\n \t    operands[1] = legitimize_address (flag_pic\n \t\t\t\t\t      && symbolic_address_p (operand1),\n-\t\t\t\t\t      operand1, temp);\n+\t\t\t\t\t      operand1, temp, scratch);\n \t    if (mode != SImode)\n \t      operands[1] = gen_rtx (SUBREG, mode, operands[1], 0);\n \t  }\n@@ -271,47 +275,61 @@ emit_move_sequence (operands, mode)\n   return 0;\n }\n \n-/* Return a legitimate reference for ORIG (either an address or a MEM) using\n-   the register REG.  If PIC and the address is already position-independent,\n-   use ORIG.  */\n+/* Return a legitimate reference for ORIG (either an address or a MEM)\n+   using the register REG.  If PIC and the address is already\n+   position-independent, use ORIG.  Newly generated position-independent\n+   addresses go into a reg.  This is REG if non zero, otherwise we\n+   allocate register(s) as necessary.  If this is called during reload,\n+   and we need a second temp register, then we use SCRATCH, which is\n+   provided via the SECONDARY_INPUT_RELOAD_CLASS mechanism.  */\n \n struct rtx_def *\n-legitimize_address (pic, orig, reg)\n+legitimize_address (pic, orig, reg, scratch)\n      int pic;\n      rtx orig;\n      rtx reg;\n+     rtx scratch;\n {\n   rtx addr = (GET_CODE (orig) == MEM ? XEXP (orig, 0) : orig);\n   rtx new = orig;\n-  rtx temp;\n+  rtx temp, insn;\n \n   if (pic)\n     {\n-      if (GET_CODE (addr) == SYMBOL_REF\n-\t  || GET_CODE (addr) == LABEL_REF)\n+      if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n \t{\n-\t  if (reg == 0) abort ();\n+\t  if (reg == 0)\n+\t    {\n+\t      if (reload_in_progress || reload_completed)\n+\t\tabort ();\n+\t      else\n+\t\treg = gen_reg_rtx (Pmode);\n+\t    }\n \n \t  if (flag_pic == 2)\n \t    {\n+\t      /* If not during reload, allocate another temp reg here for\n+\t\t loading in the address, so that these instructions can be\n+\t\t optimized properly.  */\n+\t      temp = ((reload_in_progress || reload_completed)\n+\t\t      ? reg : gen_reg_rtx (Pmode));\n+\n \t      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t  reg, gen_rtx (HIGH, SImode, addr)));\n+\t\t\t\t  temp, gen_rtx (HIGH, SImode, addr)));\n \t      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t  reg, gen_rtx (LO_SUM, SImode, reg, addr)));\n-\t      addr = reg;\n+\t\t\t\t  temp, gen_rtx (LO_SUM, SImode, temp, addr)));\n+\t      addr = temp;\n \t    }\n \t  new = gen_rtx (MEM, Pmode,\n \t\t\t gen_rtx (PLUS, SImode,\n \t\t\t\t  pic_offset_table_rtx, addr));\n \t  current_function_uses_pic_offset_table = 1;\n \t  RTX_UNCHANGING_P (new) = 1;\n-\t  {\n-\t    rtx insn = emit_move_insn (reg, new);\n-\t    /* Put a REG_EQUAL note on this insn, so that it can be optimized\n-\t       by loop.  */\n-\t    REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n-\t\t\t\t\tREG_NOTES (insn));\n-\t  }\n+\t  insn = emit_move_insn (reg, new);\n+\t  /* Put a REG_EQUAL note on this insn, so that it can be optimized\n+\t     by loop.  */\n+\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n+\t\t\t\t      REG_NOTES (insn));\n \t  new = reg;\n \t}\n       else if (GET_CODE (addr) == CONST)\n@@ -323,23 +341,52 @@ legitimize_address (pic, orig, reg)\n \t    return orig;\n \n \t  if (reg == 0)\n-\t    abort ();\n+\t    {\n+\t      if (reload_in_progress || reload_completed)\n+\t\tabort ();\n+\t      else\n+\t\treg = gen_reg_rtx (Pmode);\n+\t    }\n \n \t  if (GET_CODE (XEXP (addr, 0)) != PLUS) abort ();\n \n-\t  base = legitimize_address (1, XEXP (XEXP (addr, 0), 0), reg);\n+\t  base = legitimize_address (1, XEXP (XEXP (addr, 0), 0), reg, 0);\n \t  addr = legitimize_address (1, XEXP (XEXP (addr, 0), 1),\n-\t\t\t\t     base == reg ? 0 : reg);\n+\t\t\t\t     base == reg ? 0 : reg, 0);\n \n \t  if (GET_CODE (addr) == CONST_INT)\n-\t    new = plus_constant_for_output (base, INTVAL (addr));\n-\t  else\n-\t    new = gen_rtx (PLUS, SImode, base, addr);\n+\t    {\n+\t      if (SMALL_INT (addr))\n+\t\treturn plus_constant_for_output (base, INTVAL (addr));\n+\t      else if (! reload_in_progress && ! reload_completed)\n+\t\taddr = force_reg (Pmode, addr);\n+\t      /* We can't create any new registers during reload, so use the\n+\t\t SCRATCH reg provided by the reload_insi pattern.  */\n+\t      else if (scratch)\n+\t\t{\n+\t\t  emit_move_insn (scratch, addr);\n+\t\t  addr = scratch;\n+\t\t}\n+\t      else\n+\t\t/* If we reach here, then the SECONDARY_INPUT_RELOAD_CLASS\n+\t\t   macro needs to be adjusted so that a scratch reg is provided\n+\t\t   for this address.  */\n+\t\tabort ();\n+\t    }\n+\t  new = gen_rtx (PLUS, SImode, base, addr);\n \t  /* Should we set special REG_NOTEs here?  */\n \t}\n     }\n   else if (! SHORT_ADDRESS_P (addr, temp))\n     {\n+      if (reg == 0)\n+\t{\n+\t  if (reload_in_progress || reload_completed)\n+\t    abort ();\n+\t  else\n+\t    reg = gen_reg_rtx (Pmode);\n+\t}\n+\n       emit_insn (gen_rtx (SET, VOIDmode,\n \t\t\t  reg, gen_rtx (HIGH, SImode, addr)));\n       new = gen_rtx (LO_SUM, SImode, reg, addr);\n@@ -2210,6 +2257,8 @@ output_function_profiler (file, labelno, name, savep)\n   char dbi[256];\n   char *temp = (savep ? reg_names[2] : reg_names[10]);\n \n+  /* Remember to update FUNCTION_PROFILER_LENGTH.  */\n+\n   if (savep)\n     {\n       fprintf (file, \"\\tsubu\\t %s,%s,64\\n\", reg_names[31], reg_names[31]);\n@@ -2269,6 +2318,8 @@ output_function_block_profiler (file, labelno)\n   char block[256];\n   char label[256];\n \n+  /* Remember to update FUNCTION_BLOCK_PROFILER_LENGTH.  */\n+\n   ASM_GENERATE_INTERNAL_LABEL (block, \"LPBX\", 0);\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LPY\", labelno);\n \n@@ -2308,6 +2359,8 @@ output_block_profiler (file, blockno)\n {\n   char block[256];\n \n+  /* Remember to update BLOCK_PROFILER_LENGTH.  */\n+\n   ASM_GENERATE_INTERNAL_LABEL (block, \"LPBX\", 2);\n \n   /* @@ Need to deal with PIC.  I'm not sure what the requirements are on"}]}