{"sha": "5558f089e39350824d7bc3d5467f72e1e90b2fae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU1OGYwODllMzkzNTA4MjRkN2JjM2Q1NDY3ZjcyZTFlOTBiMmZhZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-03-10T07:53:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-03-10T07:53:57Z"}, "message": "re PR tree-optimization/77975 (Missed optimization for some small constants)\n\n\tPR tree-optimization/77975\n\t* tree-ssa-loop-niter.c (get_base_for): Allow phi argument from latch\n\tedge to be constant.\n\t(get_val_for): For constant x return it.  Formatting fix.\n\t(loop_niter_by_eval): Avoid pointless looping if the next iteration\n\twould use the same bases as the current one.\n\n\t* gcc.dg/pr77975.c: New test.\n\nFrom-SVN: r246021", "tree": {"sha": "048b43e76b3678907b012f3965fd13785fdd8779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/048b43e76b3678907b012f3965fd13785fdd8779"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5558f089e39350824d7bc3d5467f72e1e90b2fae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5558f089e39350824d7bc3d5467f72e1e90b2fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5558f089e39350824d7bc3d5467f72e1e90b2fae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5558f089e39350824d7bc3d5467f72e1e90b2fae/comments", "author": null, "committer": null, "parents": [{"sha": "e837554452518ca73af4ec64b0468991fdff4f7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e837554452518ca73af4ec64b0468991fdff4f7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e837554452518ca73af4ec64b0468991fdff4f7d"}], "stats": {"total": 73, "additions": 63, "deletions": 10}, "files": [{"sha": "211e9e77e124a956df6cf0d17cd1ba9612ba3eee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5558f089e39350824d7bc3d5467f72e1e90b2fae", "patch": "@@ -1,3 +1,13 @@\n+2017-03-10  Richard Biener  <rguenther@suse.de>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/77975\n+\t* tree-ssa-loop-niter.c (get_base_for): Allow phi argument from latch\n+\tedge to be constant.\n+\t(get_val_for): For constant x return it.  Formatting fix.\n+\t(loop_niter_by_eval): Avoid pointless looping if the next iteration\n+\twould use the same bases as the current one.\n+\n 2017-03-09  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_gen_le_vsx_permute): Use rotate"}, {"sha": "d00f5df7540e4972efea34a9f6a8ec3394243263", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5558f089e39350824d7bc3d5467f72e1e90b2fae", "patch": "@@ -1,3 +1,8 @@\n+2017-03-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/77975\n+\t* gcc.dg/pr77975.c: New test.\n+\n 2017-03-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/79962"}, {"sha": "148cebdded964da7fce148abdf2a430c55650513", "filename": "gcc/testsuite/gcc.dg/pr77975.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77975.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77975.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77975.c?ref=5558f089e39350824d7bc3d5467f72e1e90b2fae", "patch": "@@ -0,0 +1,31 @@\n+/* PR tree-optimization/77975 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivcanon-details\" } */\n+\n+/* { dg-final { scan-tree-dump-times \"Proved that loop 1 iterates 1 times using brute force\" 1 \"ivcanon\" } } */\n+\n+unsigned int\n+foo (unsigned int *b)\n+{\n+  unsigned int a = 3;\n+  while (a)\n+    {\n+      a >>= 1;\n+      *b += a;\n+    }\n+  return a; \n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Proved that loop 1 iterates 2 times using brute force\" 1 \"ivcanon\" } } */\n+\n+unsigned int\n+bar (unsigned int *b)\n+{\n+  unsigned int a = 7;\n+  while (a)\n+    {\n+      a >>= 1;\n+      *b += a;\n+    }\n+  return a; \n+}"}, {"sha": "de206471edb236b691e8e94d5e08af98b9ef1ebf", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5558f089e39350824d7bc3d5467f72e1e90b2fae/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=5558f089e39350824d7bc3d5467f72e1e90b2fae", "patch": "@@ -2521,7 +2521,8 @@ chain_of_csts_start (struct loop *loop, tree x)\n    * the derivation of X consists only from operations with constants\n    * the initial value of the phi node is constant\n    * the value of the phi node in the next iteration can be derived from the\n-     value in the current iteration by a chain of operations with constants.\n+     value in the current iteration by a chain of operations with constants,\n+     or is also a constant\n \n    If such phi node exists, it is returned, otherwise NULL is returned.  */\n \n@@ -2541,13 +2542,11 @@ get_base_for (struct loop *loop, tree x)\n   init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n   next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (loop));\n \n-  if (TREE_CODE (next) != SSA_NAME)\n-    return NULL;\n-\n   if (!is_gimple_min_invariant (init))\n     return NULL;\n \n-  if (chain_of_csts_start (loop, next) != phi)\n+  if (TREE_CODE (next) == SSA_NAME\n+      && chain_of_csts_start (loop, next) != phi)\n     return NULL;\n \n   return phi;\n@@ -2556,6 +2555,7 @@ get_base_for (struct loop *loop, tree x)\n /* Given an expression X, then\n \n    * if X is NULL_TREE, we return the constant BASE.\n+   * if X is a constant, we return the constant X.\n    * otherwise X is a SSA name, whose value in the considered loop is derived\n      by a chain of operations with constant from a result of a phi node in\n      the header of the loop.  Then we return value of X when the value of the\n@@ -2570,6 +2570,8 @@ get_val_for (tree x, tree base)\n \n   if (!x)\n     return base;\n+  else if (is_gimple_min_invariant (x))\n+    return x;\n \n   stmt = SSA_NAME_DEF_STMT (x);\n   if (gimple_code (stmt) == GIMPLE_PHI)\n@@ -2584,11 +2586,9 @@ get_val_for (tree x, tree base)\n     return get_val_for (gimple_assign_rhs1 (stmt), base);\n   else if (gimple_assign_rhs_class (stmt) == GIMPLE_UNARY_RHS\n \t   && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)\n-    {\n-      return fold_build1 (gimple_assign_rhs_code (stmt),\n-\t\t\t  gimple_expr_type (stmt),\n-\t\t\t  get_val_for (gimple_assign_rhs1 (stmt), base));\n-    }\n+    return fold_build1 (gimple_assign_rhs_code (stmt),\n+\t\t\tgimple_expr_type (stmt),\n+\t\t\tget_val_for (gimple_assign_rhs1 (stmt), base));\n   else if (gimple_assign_rhs_class (stmt) == GIMPLE_BINARY_RHS)\n     {\n       tree rhs1 = gimple_assign_rhs1 (stmt);\n@@ -2687,13 +2687,20 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n \n       for (j = 0; j < 2; j++)\n \t{\n+\t  aval[j] = val[j];\n \t  val[j] = get_val_for (next[j], val[j]);\n \t  if (!is_gimple_min_invariant (val[j]))\n \t    {\n \t      fold_undefer_and_ignore_overflow_warnings ();\n \t      return chrec_dont_know;\n \t    }\n \t}\n+\n+      /* If the next iteration would use the same base values\n+\t as the current one, there is no point looping further,\n+\t all following iterations will be the same as this one.  */\n+      if (val[0] == aval[0] && val[1] == aval[1])\n+\tbreak;\n     }\n \n   fold_undefer_and_ignore_overflow_warnings ();"}]}