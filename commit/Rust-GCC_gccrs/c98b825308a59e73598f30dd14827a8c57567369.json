{"sha": "c98b825308a59e73598f30dd14827a8c57567369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk4YjgyNTMwOGE1OWU3MzU5OGYzMGRkMTQ4MjdhOGM1NzU2NzM2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:26:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:26:55Z"}, "message": "[multiple changes]\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb, sem_ch3.ads: Minor code reorganization.\n\n2014-07-30  Pascal Obry  <obry@adacore.com>\n\n\t* clean.adb (Clean_Project): Properly check for directory\n\texistence before trying to enter it.\n\nFrom-SVN: r213284", "tree": {"sha": "e6820aa8254dde3d04565c8889d576814db35acb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6820aa8254dde3d04565c8889d576814db35acb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c98b825308a59e73598f30dd14827a8c57567369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98b825308a59e73598f30dd14827a8c57567369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c98b825308a59e73598f30dd14827a8c57567369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98b825308a59e73598f30dd14827a8c57567369/comments", "author": null, "committer": null, "parents": [{"sha": "2e471ec7641db7c5f0291f1b90de6ccecc1aea4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e471ec7641db7c5f0291f1b90de6ccecc1aea4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e471ec7641db7c5f0291f1b90de6ccecc1aea4a"}], "stats": {"total": 226, "additions": 124, "deletions": 102}, "files": [{"sha": "2141f0bb0d511a67a37e8da80d576846fcd971d4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c98b825308a59e73598f30dd14827a8c57567369", "patch": "@@ -1,3 +1,12 @@\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb, sem_ch3.ads: Minor code reorganization.\n+\n+2014-07-30  Pascal Obry  <obry@adacore.com>\n+\n+\t* clean.adb (Clean_Project): Properly check for directory\n+\texistence before trying to enter it.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.ads, prj.ads, prj-nmsc.adb: Minor reformatting."}, {"sha": "4abbc94b9f3e392a9c7172375bfe9d689f1903e1", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=c98b825308a59e73598f30dd14827a8c57567369", "patch": "@@ -666,51 +666,58 @@ package body Clean is\n             Canonical_Case_File_Name (Archive_Name);\n             Canonical_Case_File_Name (DLL_Name);\n \n-            Change_Dir (Lib_Directory);\n-            Open (Direc, \".\");\n+            if Is_Directory (Lib_Directory) then\n+               Change_Dir (Lib_Directory);\n+               Open (Direc, \".\");\n \n-            --  For each regular file in the directory, if switch -n has not\n-            --  been specified, make it writable and delete the file if it is\n-            --  the library file.\n+               --  For each regular file in the directory, if switch -n has not\n+               --  not been specified, make it writable and delete the file if\n+               --  it is the library file.\n \n-            loop\n-               Read (Direc, Name, Last);\n-               exit when Last = 0;\n-\n-               declare\n-                  Filename : constant String := Name (1 .. Last);\n+               loop\n+                  Read (Direc, Name, Last);\n+                  exit when Last = 0;\n \n-               begin\n-                  if Is_Regular_File (Filename)\n-                    or else Is_Symbolic_Link (Filename)\n-                  then\n-                     Canonical_Case_File_Name (Name (1 .. Last));\n-                     Delete_File := False;\n+                  declare\n+                     Filename : constant String := Name (1 .. Last);\n \n-                     if (Project.Library_Kind = Static\n-                          and then Name (1 .. Last) =  Archive_Name)\n-                       or else\n-                         ((Project.Library_Kind = Dynamic\n-                             or else\n-                           Project.Library_Kind = Relocatable)\n-                          and then\n-                            (Name (1 .. Last) = DLL_Name\n-                               or else\n-                             Name (1 .. Last) = Minor.all\n-                               or else\n-                             Name (1 .. Last) = Major.all))\n+                  begin\n+                     if Is_Regular_File (Filename)\n+                       or else Is_Symbolic_Link (Filename)\n                      then\n-                        if not Do_Nothing then\n-                           Set_Writable (Filename);\n-                        end if;\n+                        Canonical_Case_File_Name (Name (1 .. Last));\n+                        Delete_File := False;\n+\n+                        if (Project.Library_Kind = Static\n+                             and then Name (1 .. Last) =  Archive_Name)\n+                          or else\n+                            ((Project.Library_Kind = Dynamic\n+                                or else\n+                              Project.Library_Kind = Relocatable)\n+                             and then\n+                               (Name (1 .. Last) = DLL_Name\n+                                  or else\n+                                Name (1 .. Last) = Minor.all\n+                                  or else\n+                                Name (1 .. Last) = Major.all))\n+                        then\n+                           if not Do_Nothing then\n+                              Set_Writable (Filename);\n+                           end if;\n \n-                        Delete (Lib_Directory, Filename);\n+                           Delete (Lib_Directory, Filename);\n+                        end if;\n                      end if;\n-                  end if;\n-               end;\n-            end loop;\n+                  end;\n+               end loop;\n \n-            Close (Direc);\n+               Close (Direc);\n+            end if;\n+\n+            if not Is_Directory (Lib_ALI_Directory) then\n+               --  Nothing more to do, return now\n+               return;\n+            end if;\n \n             Change_Dir (Lib_ALI_Directory);\n             Open (Direc, \".\");\n@@ -860,7 +867,10 @@ package body Clean is\n          Processed_Projects.Increment_Last;\n          Processed_Projects.Table (Processed_Projects.Last) := Project;\n \n-         if Project.Object_Directory /= No_Path_Information then\n+         if Project.Object_Directory /= No_Path_Information\n+           and then Is_Directory\n+             (Get_Name_String (Project.Object_Directory.Display_Name))\n+         then\n             declare\n                Obj_Dir : constant String :=\n                  Get_Name_String (Project.Object_Directory.Display_Name);\n@@ -1188,7 +1198,10 @@ package body Clean is\n                   end;\n                end if;\n \n-               if Project.Object_Directory /= No_Path_Information then\n+               if Project.Object_Directory /= No_Path_Information\n+                 and then Is_Directory\n+                   (Get_Name_String (Project.Object_Directory.Display_Name))\n+               then\n                   Delete_Binder_Generated_Files\n                     (Get_Name_String (Project.Object_Directory.Display_Name),\n                      Strip_Suffix (Main_Source_File));"}, {"sha": "0a1bfd93b9478cad98e9af8fe170ff1db8c0f4d3", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c98b825308a59e73598f30dd14827a8c57567369", "patch": "@@ -17139,11 +17139,11 @@ package body Sem_Ch3 is\n    ----------------\n \n    procedure Make_Index\n-     (I            : Node_Id;\n+     (N            : Node_Id;\n       Related_Nod  : Node_Id;\n       Related_Id   : Entity_Id := Empty;\n-      Suffix_Index : Nat := 1;\n-      In_Iter_Schm : Boolean := False)\n+      Suffix_Index : Nat       := 1;\n+      In_Iter_Schm : Boolean   := False)\n    is\n       R      : Node_Id;\n       T      : Entity_Id;\n@@ -17164,21 +17164,21 @@ package body Sem_Ch3 is\n       --  Character literals also have a universal type in the absence of\n       --  of additional context,  and are resolved to Standard_Character.\n \n-      if Nkind (I) = N_Range then\n+      if Nkind (N) = N_Range then\n \n          --  The index is given by a range constraint. The bounds are known\n          --  to be of a consistent type.\n \n-         if not Is_Overloaded (I) then\n-            T := Etype (I);\n+         if not Is_Overloaded (N) then\n+            T := Etype (N);\n \n             --  For universal bounds, choose the specific predefined type\n \n             if T = Universal_Integer then\n                T := Standard_Integer;\n \n             elsif T = Any_Character then\n-               Ambiguous_Character (Low_Bound (I));\n+               Ambiguous_Character (Low_Bound (N));\n \n                T := Standard_Character;\n             end if;\n@@ -17187,7 +17187,7 @@ package body Sem_Ch3 is\n          --  are available, but if a universal interpretation exists it is\n          --  also the selected one.\n \n-         elsif Universal_Interpretation (I) = Universal_Integer then\n+         elsif Universal_Interpretation (N) = Universal_Integer then\n             T := Standard_Integer;\n \n          else\n@@ -17198,15 +17198,15 @@ package body Sem_Ch3 is\n                It  : Interp;\n \n             begin\n-               Get_First_Interp (I, Ind, It);\n+               Get_First_Interp (N, Ind, It);\n                while Present (It.Typ) loop\n                   if Is_Discrete_Type (It.Typ) then\n \n                      if Found\n                        and then not Covers (It.Typ, T)\n                        and then not Covers (T, It.Typ)\n                      then\n-                        Error_Msg_N (\"ambiguous bounds in discrete range\", I);\n+                        Error_Msg_N (\"ambiguous bounds in discrete range\", N);\n                         exit;\n                      else\n                         T := It.Typ;\n@@ -17218,8 +17218,8 @@ package body Sem_Ch3 is\n                end loop;\n \n                if T = Any_Type then\n-                  Error_Msg_N (\"discrete type required for range\", I);\n-                  Set_Etype (I, Any_Type);\n+                  Error_Msg_N (\"discrete type required for range\", N);\n+                  Set_Etype (N, Any_Type);\n                   return;\n \n                elsif T = Universal_Integer then\n@@ -17229,70 +17229,70 @@ package body Sem_Ch3 is\n          end if;\n \n          if not Is_Discrete_Type (T) then\n-            Error_Msg_N (\"discrete type required for range\", I);\n-            Set_Etype (I, Any_Type);\n+            Error_Msg_N (\"discrete type required for range\", N);\n+            Set_Etype (N, Any_Type);\n             return;\n          end if;\n \n-         if Nkind (Low_Bound (I)) = N_Attribute_Reference\n-           and then Attribute_Name (Low_Bound (I)) = Name_First\n-           and then Is_Entity_Name (Prefix (Low_Bound (I)))\n-           and then Is_Type (Entity (Prefix (Low_Bound (I))))\n-           and then Is_Discrete_Type (Entity (Prefix (Low_Bound (I))))\n+         if Nkind (Low_Bound (N)) = N_Attribute_Reference\n+           and then Attribute_Name (Low_Bound (N)) = Name_First\n+           and then Is_Entity_Name (Prefix (Low_Bound (N)))\n+           and then Is_Type (Entity (Prefix (Low_Bound (N))))\n+           and then Is_Discrete_Type (Entity (Prefix (Low_Bound (N))))\n          then\n             --  The type of the index will be the type of the prefix, as long\n             --  as the upper bound is 'Last of the same type.\n \n-            Def_Id := Entity (Prefix (Low_Bound (I)));\n+            Def_Id := Entity (Prefix (Low_Bound (N)));\n \n-            if Nkind (High_Bound (I)) /= N_Attribute_Reference\n-              or else Attribute_Name (High_Bound (I)) /= Name_Last\n-              or else not Is_Entity_Name (Prefix (High_Bound (I)))\n-              or else Entity (Prefix (High_Bound (I))) /= Def_Id\n+            if Nkind (High_Bound (N)) /= N_Attribute_Reference\n+              or else Attribute_Name (High_Bound (N)) /= Name_Last\n+              or else not Is_Entity_Name (Prefix (High_Bound (N)))\n+              or else Entity (Prefix (High_Bound (N))) /= Def_Id\n             then\n                Def_Id := Empty;\n             end if;\n          end if;\n \n-         R := I;\n+         R := N;\n          Process_Range_Expr_In_Decl (R, T, In_Iter_Schm => In_Iter_Schm);\n \n-      elsif Nkind (I) = N_Subtype_Indication then\n+      elsif Nkind (N) = N_Subtype_Indication then\n \n          --  The index is given by a subtype with a range constraint\n \n-         T :=  Base_Type (Entity (Subtype_Mark (I)));\n+         T :=  Base_Type (Entity (Subtype_Mark (N)));\n \n          if not Is_Discrete_Type (T) then\n-            Error_Msg_N (\"discrete type required for range\", I);\n-            Set_Etype (I, Any_Type);\n+            Error_Msg_N (\"discrete type required for range\", N);\n+            Set_Etype (N, Any_Type);\n             return;\n          end if;\n \n-         R := Range_Expression (Constraint (I));\n+         R := Range_Expression (Constraint (N));\n \n          Resolve (R, T);\n          Process_Range_Expr_In_Decl\n-           (R, Entity (Subtype_Mark (I)), In_Iter_Schm => In_Iter_Schm);\n+           (R, Entity (Subtype_Mark (N)), In_Iter_Schm => In_Iter_Schm);\n \n-      elsif Nkind (I) = N_Attribute_Reference then\n+      elsif Nkind (N) = N_Attribute_Reference then\n \n          --  The parser guarantees that the attribute is a RANGE attribute\n \n          --  If the node denotes the range of a type mark, that is also the\n          --  resulting type, and we do no need to create an Itype for it.\n \n-         if Is_Entity_Name (Prefix (I))\n-           and then Comes_From_Source (I)\n-           and then Is_Type (Entity (Prefix (I)))\n-           and then Is_Discrete_Type (Entity (Prefix (I)))\n+         if Is_Entity_Name (Prefix (N))\n+           and then Comes_From_Source (N)\n+           and then Is_Type (Entity (Prefix (N)))\n+           and then Is_Discrete_Type (Entity (Prefix (N)))\n          then\n-            Def_Id := Entity (Prefix (I));\n+            Def_Id := Entity (Prefix (N));\n          end if;\n \n-         Analyze_And_Resolve (I);\n-         T := Etype (I);\n-         R := I;\n+         Analyze_And_Resolve (N);\n+         T := Etype (N);\n+         R := N;\n \n       --  If none of the above, must be a subtype. We convert this to a\n       --  range attribute reference because in the case of declared first\n@@ -17306,41 +17306,41 @@ package body Sem_Ch3 is\n       --  original index for instantiation purposes.\n \n       else\n-         if not Is_Entity_Name (I) or else not Is_Type (Entity (I)) then\n-            Error_Msg_N (\"invalid subtype mark in discrete range \", I);\n-            Set_Etype (I, Any_Integer);\n+         if not Is_Entity_Name (N) or else not Is_Type (Entity (N)) then\n+            Error_Msg_N (\"invalid subtype mark in discrete range \", N);\n+            Set_Etype (N, Any_Integer);\n             return;\n \n          else\n             --  The type mark may be that of an incomplete type. It is only\n             --  now that we can get the full view, previous analysis does\n             --  not look specifically for a type mark.\n \n-            Set_Entity (I, Get_Full_View (Entity (I)));\n-            Set_Etype  (I, Entity (I));\n-            Def_Id := Entity (I);\n+            Set_Entity (N, Get_Full_View (Entity (N)));\n+            Set_Etype  (N, Entity (N));\n+            Def_Id := Entity (N);\n \n             if not Is_Discrete_Type (Def_Id) then\n-               Error_Msg_N (\"discrete type required for index\", I);\n-               Set_Etype (I, Any_Type);\n+               Error_Msg_N (\"discrete type required for index\", N);\n+               Set_Etype (N, Any_Type);\n                return;\n             end if;\n          end if;\n \n          if Expander_Active then\n-            Rewrite (I,\n-              Make_Attribute_Reference (Sloc (I),\n+            Rewrite (N,\n+              Make_Attribute_Reference (Sloc (N),\n                 Attribute_Name => Name_Range,\n-                Prefix         => Relocate_Node (I)));\n+                Prefix         => Relocate_Node (N)));\n \n             --  The original was a subtype mark that does not freeze. This\n             --  means that the rewritten version must not freeze either.\n \n-            Set_Must_Not_Freeze (I);\n-            Set_Must_Not_Freeze (Prefix (I));\n-            Analyze_And_Resolve (I);\n-            T := Etype (I);\n-            R := I;\n+            Set_Must_Not_Freeze (N);\n+            Set_Must_Not_Freeze (Prefix (N));\n+            Analyze_And_Resolve (N);\n+            T := Etype (N);\n+            R := N;\n \n          --  If expander is inactive, type is legal, nothing else to construct\n \n@@ -17350,12 +17350,12 @@ package body Sem_Ch3 is\n       end if;\n \n       if not Is_Discrete_Type (T) then\n-         Error_Msg_N (\"discrete type required for range\", I);\n-         Set_Etype (I, Any_Type);\n+         Error_Msg_N (\"discrete type required for range\", N);\n+         Set_Etype (N, Any_Type);\n          return;\n \n       elsif T = Any_Type then\n-         Set_Etype (I, Any_Type);\n+         Set_Etype (N, Any_Type);\n          return;\n       end if;\n \n@@ -17401,16 +17401,16 @@ package body Sem_Ch3 is\n          --  new subtype is non-static, then the subtype we create is non-\n          --  static, even if its bounds are static.\n \n-         if Nkind (I) = N_Subtype_Indication\n-           and then not Is_OK_Static_Subtype (Entity (Subtype_Mark (I)))\n+         if Nkind (N) = N_Subtype_Indication\n+           and then not Is_OK_Static_Subtype (Entity (Subtype_Mark (N)))\n          then\n             Set_Is_Non_Static_Subtype (Def_Id);\n          end if;\n       end if;\n \n       --  Final step is to label the index with this constructed type\n \n-      Set_Etype (I, Def_Id);\n+      Set_Etype (N, Def_Id);\n    end Make_Index;\n \n    ------------------------------"}, {"sha": "a0465802b10a81ede49d84beaf564ba36aba7076", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98b825308a59e73598f30dd14827a8c57567369/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=c98b825308a59e73598f30dd14827a8c57567369", "patch": "@@ -193,7 +193,7 @@ package Sem_Ch3 is\n    --  C is automatically visible.\n \n    procedure Make_Index\n-     (I            : Node_Id;\n+     (N            : Node_Id;\n       Related_Nod  : Node_Id;\n       Related_Id   : Entity_Id := Empty;\n       Suffix_Index : Nat       := 1;"}]}