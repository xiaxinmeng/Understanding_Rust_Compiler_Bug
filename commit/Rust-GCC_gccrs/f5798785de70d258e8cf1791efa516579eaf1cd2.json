{"sha": "f5798785de70d258e8cf1791efa516579eaf1cd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3OTg3ODVkZTcwZDI1OGU4Y2YxNzkxZWZhNTE2NTc5ZWFmMWNkMg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-10-22T13:59:33Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-10-22T13:59:33Z"}, "message": "i386.c (memory_address_length): Assert that non-null base or index RTXes are registers.\n\n\t* config/i386/i386.c (memory_address_length): Assert that non-null\n\tbase or index RTXes are registers.  Do not check for REG RTXes.\n\tDetermine addr32 prefix from original base and index RTXes.\n\tSimplify code.\n\nFrom-SVN: r192690", "tree": {"sha": "56d664082b8fcdd5492d78ea50e4986603128dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56d664082b8fcdd5492d78ea50e4986603128dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5798785de70d258e8cf1791efa516579eaf1cd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5798785de70d258e8cf1791efa516579eaf1cd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5798785de70d258e8cf1791efa516579eaf1cd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5798785de70d258e8cf1791efa516579eaf1cd2/comments", "author": null, "committer": null, "parents": [{"sha": "43b1bad65d0d1142c37a91dcf6cf2a035c541e4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b1bad65d0d1142c37a91dcf6cf2a035c541e4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43b1bad65d0d1142c37a91dcf6cf2a035c541e4d"}], "stats": {"total": 98, "additions": 48, "deletions": 50}, "files": [{"sha": "9878490b163d446d7ebe7abb88c18ee6d96e9711", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5798785de70d258e8cf1791efa516579eaf1cd2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5798785de70d258e8cf1791efa516579eaf1cd2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5798785de70d258e8cf1791efa516579eaf1cd2", "patch": "@@ -1,3 +1,10 @@\n+2012-10-22  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (memory_address_length): Assert that non-null\n+\tbase or index RTXes are registers.  Do not check for REG RTXes.\n+\tDetermine addr32 prefix from original base and index RTXes.\n+\tSimplify code.\n+\n 2012-10-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/55011\n@@ -25,21 +32,20 @@\n \t    Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.c (thumb2_emit_strd_push): New function.\n-       (arm_expand_prologue): Use the new function.\n+\t(arm_expand_prologue): Use the new function.\n \n 2012-10-22  Sameera Deshpande  <sameera.deshpande@arm.com>\n \t    Greta Yorsh  <Greta.Yorsh@arm.com>\n \n-        * config/arm/arm-protos.h (offset_ok_for_ldrd_strd): New\n-        declaration.\n-        (operands_ok_ldrd_strd): Likewise.\n-        * config/arm/arm.c (offset_ok_for_ldrd_strd): New function.\n-        (operands_ok_ldrd_strd): Likewise.\n-        * config/arm/arm.md (thumb2_ldrd, thumb2_ldrd_base): New patterns.\n-        (thumb2_ldrd_base_neg): Likewise.\n-        (thumb2_strd, thumb2_strd_base, thumb_strd_base_neg): Likewise.\n-        * predicates.md (ldrd_strd_offset_operand): New predicate.\n-        * config/arm/constraints.md (Do): New constraint.\n+\t* config/arm/arm-protos.h (offset_ok_for_ldrd_strd): New declaration.\n+\t(operands_ok_ldrd_strd): Likewise.\n+\t* config/arm/arm.c (offset_ok_for_ldrd_strd): New function.\n+\t(operands_ok_ldrd_strd): Likewise.\n+\t* config/arm/arm.md (thumb2_ldrd, thumb2_ldrd_base): New patterns.\n+\t(thumb2_ldrd_base_neg): Likewise.\n+\t(thumb2_strd, thumb2_strd_base, thumb_strd_base_neg): Likewise.\n+\t* predicates.md (ldrd_strd_offset_operand): New predicate.\n+\t* config/arm/constraints.md (Do): New constraint.\n \n 2012-10-22  Hans-Peter Nilsson  <hp@bitrange.com>\n "}, {"sha": "8e78fbabc0d895d9de37a70b99d2b33af380bacb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5798785de70d258e8cf1791efa516579eaf1cd2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5798785de70d258e8cf1791efa516579eaf1cd2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f5798785de70d258e8cf1791efa516579eaf1cd2", "patch": "@@ -23764,7 +23764,7 @@ memory_address_length (rtx addr, bool lea)\n {\n   struct ix86_address parts;\n   rtx base, index, disp;\n-  int len = 0;\n+  int len;\n   int ok;\n \n   if (GET_CODE (addr) == PRE_DEC\n@@ -23776,15 +23776,26 @@ memory_address_length (rtx addr, bool lea)\n   ok = ix86_decompose_address (addr, &parts);\n   gcc_assert (ok);\n \n-  if (parts.base && GET_CODE (parts.base) == SUBREG)\n-    parts.base = SUBREG_REG (parts.base);\n-  if (parts.index && GET_CODE (parts.index) == SUBREG)\n-    parts.index = SUBREG_REG (parts.index);\n+  len = (parts.seg == SEG_DEFAULT) ? 0 : 1;\n+\n+  /*  If this is not LEA instruction, add the length of addr32 prefix.  */\n+  if (TARGET_64BIT && !lea\n+      && ((parts.base && GET_MODE (parts.base) == SImode)\n+\t  || (parts.index && GET_MODE (parts.index) == SImode)))\n+    len++;\n \n   base = parts.base;\n   index = parts.index;\n   disp = parts.disp;\n \n+  if (base && GET_CODE (base) == SUBREG)\n+    base = SUBREG_REG (base);\n+  if (index && GET_CODE (index) == SUBREG)\n+    index = SUBREG_REG (index);\n+\n+  gcc_assert (base == NULL_RTX || REG_P (base));\n+  gcc_assert (index == NULL_RTX || REG_P (index));\n+\n   /* Rule of thumb:\n        - esp as the base always wants an index,\n        - ebp as the base always wants a displacement,\n@@ -23797,14 +23808,13 @@ memory_address_length (rtx addr, bool lea)\n       /* esp (for its index) and ebp (for its displacement) need\n \t the two-byte modrm form.  Similarly for r12 and r13 in 64-bit\n \t code.  */\n-      if (REG_P (base)\n-\t  && (base == arg_pointer_rtx\n-\t      || base == frame_pointer_rtx\n-\t      || REGNO (base) == SP_REG\n-\t      || REGNO (base) == BP_REG\n-\t      || REGNO (base) == R12_REG\n-\t      || REGNO (base) == R13_REG))\n-\tlen = 1;\n+      if (base == arg_pointer_rtx\n+\t  || base == frame_pointer_rtx\n+\t  || REGNO (base) == SP_REG\n+\t  || REGNO (base) == BP_REG\n+\t  || REGNO (base) == R12_REG\n+\t  || REGNO (base) == R13_REG)\n+\tlen++;\n     }\n \n   /* Direct Addressing.  In 64-bit mode mod 00 r/m 5\n@@ -23814,7 +23824,7 @@ memory_address_length (rtx addr, bool lea)\n      by UNSPEC.  */\n   else if (disp && !base && !index)\n     {\n-      len = 4;\n+      len += 4;\n       if (TARGET_64BIT)\n \t{\n \t  rtx symbol = disp;\n@@ -23832,7 +23842,7 @@ memory_address_length (rtx addr, bool lea)\n \t\t  || (XINT (symbol, 1) != UNSPEC_GOTPCREL\n \t\t      && XINT (symbol, 1) != UNSPEC_PCREL\n \t\t      && XINT (symbol, 1) != UNSPEC_GOTNTPOFF)))\n-\t    len += 1;\n+\t    len++;\n \t}\n     }\n   else\n@@ -23841,41 +23851,23 @@ memory_address_length (rtx addr, bool lea)\n       if (disp)\n \t{\n \t  if (base && satisfies_constraint_K (disp))\n-\t    len = 1;\n+\t    len += 1;\n \t  else\n-\t    len = 4;\n+\t    len += 4;\n \t}\n       /* ebp always wants a displacement.  Similarly r13.  */\n-      else if (base && REG_P (base)\n-\t       && (REGNO (base) == BP_REG || REGNO (base) == R13_REG))\n-\tlen = 1;\n+      else if (base && (REGNO (base) == BP_REG || REGNO (base) == R13_REG))\n+\tlen++;\n \n       /* An index requires the two-byte modrm form....  */\n       if (index\n \t  /* ...like esp (or r12), which always wants an index.  */\n \t  || base == arg_pointer_rtx\n \t  || base == frame_pointer_rtx\n-\t  || (base && REG_P (base)\n-\t      && (REGNO (base) == SP_REG || REGNO (base) == R12_REG)))\n-\tlen += 1;\n-    }\n-\n-  switch (parts.seg)\n-    {\n-    case SEG_FS:\n-    case SEG_GS:\n-      len += 1;\n-      break;\n-    default:\n-      break;\n+\t  || (base && (REGNO (base) == SP_REG || REGNO (base) == R12_REG)))\n+\tlen++;\n     }\n \n-  /*  If this is not LEA instruction, add the length of addr32 prefix.  */\n-  if (TARGET_64BIT && !lea\n-      && ((base && GET_MODE (base) == SImode)\n-\t  || (index && GET_MODE (index) == SImode)))\n-    len += 1;\n-\n   return len;\n }\n "}]}