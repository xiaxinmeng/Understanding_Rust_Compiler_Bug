{"sha": "902197eb4fbf3b936300d6df647e9d978d32ca28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAyMTk3ZWI0ZmJmM2I5MzYzMDBkNmRmNjQ3ZTlkOTc4ZDMyY2EyOA==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2001-11-15T03:02:24Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2001-11-15T03:02:24Z"}, "message": "integrate.c (get_hard_reg_initial_reg): New.\n\n* integrate.c (get_hard_reg_initial_reg): New.\n* integrate.h (get_hard_reg_initial_reg): Prototype.\n* local-alloc.c (block_alloc): Don't tie pseudos that\nrepresent call-saved hard regs' initial values.\n\nFrom-SVN: r47037", "tree": {"sha": "fc5ff2b3569ac8524c310ed350940c212918d81a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc5ff2b3569ac8524c310ed350940c212918d81a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/902197eb4fbf3b936300d6df647e9d978d32ca28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/902197eb4fbf3b936300d6df647e9d978d32ca28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/902197eb4fbf3b936300d6df647e9d978d32ca28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/902197eb4fbf3b936300d6df647e9d978d32ca28/comments", "author": null, "committer": null, "parents": [{"sha": "6345b6810a52cf188959805bccc4ff8fba71ce74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6345b6810a52cf188959805bccc4ff8fba71ce74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6345b6810a52cf188959805bccc4ff8fba71ce74"}], "stats": {"total": 43, "additions": 42, "deletions": 1}, "files": [{"sha": "c7e5fba7ba5744a96e2f1660c1553e458e6bdd05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=902197eb4fbf3b936300d6df647e9d978d32ca28", "patch": "@@ -1,3 +1,10 @@\n+2001-11-14  DJ Delorie  <dj@redhat.com>\n+\n+\t* integrate.c (get_hard_reg_initial_reg): New.\n+\t* integrate.h (get_hard_reg_initial_reg): Prototype.\n+\t* local-alloc.c (block_alloc): Don't tie pseudos that\n+\trepresent call-saved hard regs' initial values.\n+\n 2001-11-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* m68k/linux.h: Include <linux.h> not \"linux.h\" to avoid infinite"}, {"sha": "4aa87006f2cf729492f5ce6cec6953854c78794d", "filename": "gcc/integrate.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=902197eb4fbf3b936300d6df647e9d978d32ca28", "patch": "@@ -2963,6 +2963,24 @@ output_inline_function (fndecl)\n /* Functions to keep track of the values hard regs had at the start of\n    the function.  */\n \n+rtx\n+get_hard_reg_initial_reg (fun, reg)\n+     struct function *fun;\n+     rtx reg;\n+{\n+  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n+  int i;\n+\n+  if (ivs == 0)\n+    return NULL_RTX;\n+\n+  for (i = 0; i < ivs->num_entries; i++)\n+    if (rtx_equal_p (ivs->entries[i].pseudo, reg))\n+      return ivs->entries[i].hard_reg;\n+\n+  return NULL_RTX;\n+}\n+\n rtx\n has_func_hard_reg_initial_val (fun, reg)\n      struct function *fun;"}, {"sha": "9ddefefc9567e6d7de22f43f75d0009a5523ca71", "filename": "gcc/integrate.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=902197eb4fbf3b936300d6df647e9d978d32ca28", "patch": "@@ -140,6 +140,9 @@ extern rtx get_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n extern rtx has_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n /* Likewise, but for common cases.  */\n extern rtx has_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n+/* If a pseudo represents an initial hard reg (or expression), return\n+   it, else return NULL_RTX.  */\n+extern rtx get_hard_reg_initial_reg\t\tPARAMS ((struct function *, rtx));\n /* This is for GC.  */\n extern void mark_hard_reg_initial_vals\t\tPARAMS ((struct function *));\n /* Called from rest_of_compilation.  */"}, {"sha": "1c45ae4f0697760afd834c65e6605e4823728ae6", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902197eb4fbf3b936300d6df647e9d978d32ca28/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=902197eb4fbf3b936300d6df647e9d978d32ca28", "patch": "@@ -74,6 +74,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n #include \"toplev.h\"\n #include \"except.h\"\n+#include \"integrate.h\"\n \f\n /* Next quantity number available for allocation.  */\n \n@@ -1216,7 +1217,7 @@ block_alloc (b)\n {\n   int i, q;\n   rtx insn;\n-  rtx note;\n+  rtx note, hard_reg;\n   int insn_number = 0;\n   int insn_count = 0;\n   int max_uid = get_max_uid ();\n@@ -1340,6 +1341,18 @@ block_alloc (b)\n \t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n \t\t      r1 = XEXP (r1, 0);\n \n+\t\t  /* Avoid making a call-saved register unnecessarily\n+                     clobbered.  */\n+\t\t  hard_reg = get_hard_reg_initial_reg (cfun, r1);\n+\t\t  if (hard_reg != NULL_RTX)\n+\t\t    {\n+\t\t      if (GET_CODE (hard_reg) == REG\n+\t\t\t  && REGNO (hard_reg) >= 0\n+\t\t\t  && REGNO (hard_reg) < FIRST_PSEUDO_REGISTER\n+\t\t\t  && ! call_used_regs[REGNO (hard_reg)])\n+\t\t\tcontinue;\n+\t\t    }\n+\n \t\t  if (GET_CODE (r0) == REG || GET_CODE (r0) == SUBREG)\n \t\t    {\n \t\t      /* We have two priorities for hard register preferences."}]}