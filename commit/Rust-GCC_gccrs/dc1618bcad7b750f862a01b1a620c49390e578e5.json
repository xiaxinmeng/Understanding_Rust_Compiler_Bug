{"sha": "dc1618bcad7b750f862a01b1a620c49390e578e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxNjE4YmNhZDdiNzUwZjg2MmEwMWIxYTYyMGM0OTM5MGU1NzhlNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-05-20T13:28:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-20T13:28:13Z"}, "message": "alias.c (aliases_everything_p): Don't special-case QImode here.\n\n\t* alias.c (aliases_everything_p): Don't special-case QImode here.\n\t* c-common.c (c_get_alias_set): Do it here.\n\tHandle BIT_FIELD_REF by getting alias info for arg.\n\tUse POINTER_TYPE_P.\n\nFrom-SVN: r34050", "tree": {"sha": "8e4c5560417631a9c39228f416dbb994727e10b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e4c5560417631a9c39228f416dbb994727e10b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc1618bcad7b750f862a01b1a620c49390e578e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1618bcad7b750f862a01b1a620c49390e578e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc1618bcad7b750f862a01b1a620c49390e578e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1618bcad7b750f862a01b1a620c49390e578e5/comments", "author": null, "committer": null, "parents": [{"sha": "de467fe702dde575e78d7f07fa2d9189273f99cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de467fe702dde575e78d7f07fa2d9189273f99cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de467fe702dde575e78d7f07fa2d9189273f99cc"}], "stats": {"total": 55, "additions": 31, "deletions": 24}, "files": [{"sha": "6f8d3966b79c3afe736395c6a1e957487e9f9ac1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1618bcad7b750f862a01b1a620c49390e578e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1618bcad7b750f862a01b1a620c49390e578e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc1618bcad7b750f862a01b1a620c49390e578e5", "patch": "@@ -1,3 +1,10 @@\n+Sat May 20 09:30:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (aliases_everything_p): Don't special-case QImode here.\n+\t* c-common.c (c_get_alias_set): Do it here.\n+\tHandle BIT_FIELD_REF by getting alias info for arg.\n+\tUse POINTER_TYPE_P.\n+\n 2000-05-20  Alexandre Oliva  <aoliva@cygnus.com>\n \n \t* mklibgcc.in: Restore rule to create ${dir}."}, {"sha": "897c27d08afa33c30b496ce1b035048f3abb8394", "filename": "gcc/alias.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1618bcad7b750f862a01b1a620c49390e578e5/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1618bcad7b750f862a01b1a620c49390e578e5/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=dc1618bcad7b750f862a01b1a620c49390e578e5", "patch": "@@ -1213,14 +1213,12 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n    changed.  A volatile and non-volatile reference can be interchanged\n    though. \n \n-   A MEM_IN_STRUCT reference at a non-QImode non-AND varying address can never\n-   conflict with a non-MEM_IN_STRUCT reference at a fixed address.   We must\n-   allow QImode aliasing because the ANSI C standard allows character\n-   pointers to alias anything.  We are assuming that characters are\n-   always QImode here.  We also must allow AND addresses, because they may\n-   generate accesses outside the object being referenced.  This is used to\n-   generate aligned addresses from unaligned addresses, for instance, the\n-   alpha storeqi_unaligned pattern.  */\n+   A MEM_IN_STRUCT reference at a non-AND varying address can never\n+   conflict with a non-MEM_IN_STRUCT reference at a fixed address.  We\n+   also must allow AND addresses, because they may generate accesses\n+   outside the object being referenced.  This is used to generate\n+   aligned addresses from unaligned addresses, for instance, the alpha\n+   storeqi_unaligned pattern.  */\n \n /* Read dependence: X is read after read in MEM takes place.  There can\n    only be a dependence here if both reads are volatile.  */\n@@ -1269,10 +1267,6 @@ static int\n aliases_everything_p (mem)\n      rtx mem;\n {\n-  if (GET_MODE (mem) == QImode)\n-    /* ANSI C says that a `char*' can point to anything.  */\n-    return 1;\n-\n   if (GET_CODE (XEXP (mem, 0)) == AND)\n     /* If the address is an AND, its very hard to know at what it is\n        actually pointing.  */"}, {"sha": "4631417b90d94c561b1d2f174080a2dab0398eef", "filename": "gcc/c-common.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1618bcad7b750f862a01b1a620c49390e578e5/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1618bcad7b750f862a01b1a620c49390e578e5/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=dc1618bcad7b750f862a01b1a620c49390e578e5", "patch": "@@ -3332,21 +3332,20 @@ c_get_alias_set (t)\n   if (t == error_mark_node)\n     return 0;\n \n-  type = (TYPE_P (t)) ? t : TREE_TYPE (t);\n+  /* For a bit field reference that's not to a specific field,\n+     all we can say is the aliasing information for the underlying object. */\n+  if (TREE_CODE (t) == BIT_FIELD_REF)\n+    t = TREE_OPERAND (t, 0);\n \n+  /* If this is a type, use it, otherwise get the type of the expression.\n+     If the type is an error type, say this may alias anything.  */\n+  type = TYPE_P (t) ? t : TREE_TYPE (t);\n   if (type == error_mark_node)\n     return 0;\n \n   /* Deal with special cases first; for certain kinds of references\n      we're interested in more than just the type.  */\n \n-  if (TREE_CODE (t) == BIT_FIELD_REF)\n-    /* Perhaps reads and writes to this piece of data alias fields\n-       neighboring the bitfield.  Perhaps that's impossible.  For now,\n-       let's just assume that bitfields can alias everything, which is\n-       the conservative assumption.  */\n-    return 0;\n-\n   /* Permit type-punning when accessing a union, provided the access\n      is directly through the union.  For example, this code does not\n      permit taking the address of a union member and then storing\n@@ -3363,11 +3362,19 @@ c_get_alias_set (t)\n   if (TREE_CODE (t) == INDIRECT_REF)\n     {\n       /* Check for accesses through restrict-qualified pointers.  */\n-      tree decl = c_find_base_decl (TREE_OPERAND (t, 0));\n+      tree op = TREE_OPERAND (t, 0);\n+      tree decl = c_find_base_decl (op);\n \n       if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n \t/* We use the alias set indicated in the declaration.  */\n \treturn DECL_POINTER_ALIAS_SET (decl);\n+\n+      /* If this is a char *, the ANSI C standard says it can alias\n+         anything.  */\n+      if (TREE_CODE (TREE_TYPE (op)) == INTEGER_TYPE\n+\t  && (TYPE_PRECISION (TREE_TYPE (op))\n+\t      == TYPE_PRECISION (char_type_node)))\n+\treturn 0;\n     }\n \n   /* From here on, only the type matters.  */\n@@ -3424,8 +3431,7 @@ c_get_alias_set (t)\n        whose type is the same as one of the fields, recursively, but\n        we don't yet make any use of that information.)  */\n     TYPE_ALIAS_SET (type) = 0;\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   || TREE_CODE (type) == REFERENCE_TYPE)\n+  else if (POINTER_TYPE_P (type))\n     {\n       tree t;\n \n@@ -3459,7 +3465,7 @@ c_get_alias_set (t)\n \tTYPE_ALIAS_SET (type) = c_get_alias_set (t);\n     }\n \n-  if (!TYPE_ALIAS_SET_KNOWN_P (type))\n+  if (! TYPE_ALIAS_SET_KNOWN_P (type))\n     /* TYPE is something we haven't seen before.  Put it in a new\n        alias set.  */\n     TYPE_ALIAS_SET (type) = new_alias_set ();"}]}