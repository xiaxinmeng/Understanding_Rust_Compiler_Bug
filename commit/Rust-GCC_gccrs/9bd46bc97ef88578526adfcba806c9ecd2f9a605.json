{"sha": "9bd46bc97ef88578526adfcba806c9ecd2f9a605", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJkNDZiYzk3ZWY4ODU3ODUyNmFkZmNiYTgwNmM5ZWNkMmY5YTYwNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-10-27T23:46:39Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-10-27T23:46:39Z"}, "message": "internal-fn.def (IFN_GOACC_DIM_SIZE, [...]): New.\n\n\t* internal-fn.def (IFN_GOACC_DIM_SIZE, IFN_GOACC_DIM_POS,\n\tIFN_GOACC_LOOP): New.\n\t* internal-fn.h (enum ifn_unique_kind): Add IFN_UNIQUE_OACC_FORK,\n\tIFN_UNIQUE_OACC_JOIN, IFN_UNIQUE_OACC_HEAD_MARK,\n\tIFN_UNIQUE_OACC_TAIL_MARK.\n\t(enum ifn_goacc_loop_kind): New.\n\t* internal-fn.c (expand_UNIQUE): Add IFN_UNIQUE_OACC_FORK,\n\tIFN_UNIQUE_OACC_JOIN cases.\n\t(expand_GOACC_DIM_SIZE, expand_GOACC_DIM_POS): New.\n\t(expand_GOACC_LOOP): New.\n\t* target-insns.def (oacc_dim_pos, oacc_dim_size): New.\n\t* omp-low.c: Include gimple-pretty-print.h.\n\t(struct oacc_loop): New.\n\t(enum oacc_loop_flags): New.\n\t(oacc_thread_numbers): New.\n\t(oacc_xform_loop): New.\n\t(new_oacc_loop_raw, new_oacc_loop_outer, new_oacc_loop,\n\tnew_oacc_loop_routine, finish_oacc_loop, free_oacc_loop): New,\n\t(dump_oacc_loop_part, dump_oacc_loop, debug_oacc_loop): New,\n\t(oacc_loop_discover_walk, oacc_loop_sibling_nrevers,\n\toacc_loop_discovery): New.\n\t(oacc_loop_xform_head_tail, oacc_loop_xform_loop,\n\toacc_loop_process): New.\n\t(oacc_loop_fixed_partitions, oacc_loop_partition): New.\n\t(execute_oacc_device_lower): Discover & process loops.  Process\n\tinternal fns.\n\t* target.def (goacc.fork_join): Change sense of hook, clarify\n\tdocumentation.\n\t* doc/tm.texi: Regenerated.\n\nFrom-SVN: r229466", "tree": {"sha": "735ed3e643e6b1a554e7891e978d7b69a5d66821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/735ed3e643e6b1a554e7891e978d7b69a5d66821"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bd46bc97ef88578526adfcba806c9ecd2f9a605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bd46bc97ef88578526adfcba806c9ecd2f9a605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bd46bc97ef88578526adfcba806c9ecd2f9a605", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bd46bc97ef88578526adfcba806c9ecd2f9a605/comments", "author": null, "committer": null, "parents": [{"sha": "6e91acf8bbf95ec5f19c7b93ddf10b61e5cc37e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e91acf8bbf95ec5f19c7b93ddf10b61e5cc37e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e91acf8bbf95ec5f19c7b93ddf10b61e5cc37e6"}], "stats": {"total": 1116, "additions": 1103, "deletions": 13}, "files": [{"sha": "f2480ab028721c21f2e7a9a9024cd04f15d1e5b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -1,3 +1,35 @@\n+2015-10-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* internal-fn.def (IFN_GOACC_DIM_SIZE, IFN_GOACC_DIM_POS,\n+\tIFN_GOACC_LOOP): New.\n+\t* internal-fn.h (enum ifn_unique_kind): Add IFN_UNIQUE_OACC_FORK,\n+\tIFN_UNIQUE_OACC_JOIN, IFN_UNIQUE_OACC_HEAD_MARK,\n+\tIFN_UNIQUE_OACC_TAIL_MARK.\n+\t(enum ifn_goacc_loop_kind): New.\n+\t* internal-fn.c (expand_UNIQUE): Add IFN_UNIQUE_OACC_FORK,\n+\tIFN_UNIQUE_OACC_JOIN cases.\n+\t(expand_GOACC_DIM_SIZE, expand_GOACC_DIM_POS): New.\n+\t(expand_GOACC_LOOP): New.\n+\t* target-insns.def (oacc_dim_pos, oacc_dim_size): New.\n+\t* omp-low.c: Include gimple-pretty-print.h.\n+\t(struct oacc_loop): New.\n+\t(enum oacc_loop_flags): New.\n+\t(oacc_thread_numbers): New.\n+\t(oacc_xform_loop): New.\n+\t(new_oacc_loop_raw, new_oacc_loop_outer, new_oacc_loop,\n+\tnew_oacc_loop_routine, finish_oacc_loop, free_oacc_loop): New,\n+\t(dump_oacc_loop_part, dump_oacc_loop, debug_oacc_loop): New,\n+\t(oacc_loop_discover_walk, oacc_loop_sibling_nrevers,\n+\toacc_loop_discovery): New.\n+\t(oacc_loop_xform_head_tail, oacc_loop_xform_loop,\n+\toacc_loop_process): New.\n+\t(oacc_loop_fixed_partitions, oacc_loop_partition): New.\n+\t(execute_oacc_device_lower): Discover & process loops.  Process\n+\tinternal fns.\n+\t* target.def (goacc.fork_join): Change sense of hook, clarify\n+\tdocumentation.\n+\t* doc/tm.texi: Regenerated.\n+\n 2015-10-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* target-insns.def (oacc_fork, oacc_join): Define."}, {"sha": "3b1e2dcde7963649b0e304835a18b8925f001010", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -5778,11 +5778,13 @@ provide dimensions larger than 1.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_GOACC_FORK_JOIN (gcall *@var{call}, const int *@var{dims}, bool @var{is_fork})\n-This hook should convert IFN_GOACC_FORK and IFN_GOACC_JOIN function\n-calls to target-specific gimple.  It is executed during the\n-oacc_device_lower pass.  It should return true, if the functions\n-should be deleted.  The default hook returns true, if there are no\n-RTL expanders for them.\n+This hook can be used to convert IFN_GOACC_FORK and IFN_GOACC_JOIN\n+function calls to target-specific gimple, or indicate whether they\n+should be retained.  It is executed during the oacc_device_lower pass.\n+It should return true, if the call should be retained.  It should\n+return false, if it is to be deleted (either because target-specific\n+gimple has been inserted before it, or there is no need for it).\n+The default hook returns false, if there are no RTL expanders for them.\n @end deftypefn\n \n @node Anchored Addresses"}, {"sha": "cf1ba22c77d763518927953c0504a4aa8dfa8c34", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -1976,12 +1976,84 @@ expand_UNIQUE (gcall *stmt)\n       if (targetm.have_unique ())\n \tpattern = targetm.gen_unique ();\n       break;\n+\n+    case IFN_UNIQUE_OACC_FORK:\n+    case IFN_UNIQUE_OACC_JOIN:\n+      if (targetm.have_oacc_fork () && targetm.have_oacc_join ())\n+\t{\n+\t  tree lhs = gimple_call_lhs (stmt);\n+\t  rtx target = const0_rtx;\n+\n+\t  if (lhs)\n+\t    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\n+\t  rtx data_dep = expand_normal (gimple_call_arg (stmt, 1));\n+\t  rtx axis = expand_normal (gimple_call_arg (stmt, 2));\n+\n+\t  if (kind == IFN_UNIQUE_OACC_FORK)\n+\t    pattern = targetm.gen_oacc_fork (target, data_dep, axis);\n+\t  else\n+\t    pattern = targetm.gen_oacc_join (target, data_dep, axis);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      break;\n     }\n \n   if (pattern)\n     emit_insn (pattern);\n }\n \n+/* The size of an OpenACC compute dimension.  */\n+\n+static void\n+expand_GOACC_DIM_SIZE (gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  if (targetm.have_oacc_dim_size ())\n+    {\n+      rtx dim = expand_expr (gimple_call_arg (stmt, 0), NULL_RTX,\n+\t\t\t     VOIDmode, EXPAND_NORMAL);\n+      emit_insn (targetm.gen_oacc_dim_size (target, dim));\n+    }\n+  else\n+    emit_move_insn (target, GEN_INT (1));\n+}\n+\n+/* The position of an OpenACC execution engine along one compute axis.  */\n+\n+static void\n+expand_GOACC_DIM_POS (gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  if (targetm.have_oacc_dim_pos ())\n+    {\n+      rtx dim = expand_expr (gimple_call_arg (stmt, 0), NULL_RTX,\n+\t\t\t     VOIDmode, EXPAND_NORMAL);\n+      emit_insn (targetm.gen_oacc_dim_pos (target, dim));\n+    }\n+  else\n+    emit_move_insn (target, const0_rtx);\n+}\n+\n+/* This is expanded by oacc_device_lower pass.  */\n+\n+static void\n+expand_GOACC_LOOP (gcall *stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "78266d91632a139b84c39e4c2fc3a83181cea980", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -72,3 +72,14 @@ DEF_INTERNAL_FN (VA_ARG, ECF_NOTHROW | ECF_LEAF, NULL)\n    between uses.  See internal-fn.h for usage.  */\n DEF_INTERNAL_FN (UNIQUE, ECF_NOTHROW, NULL)\n \n+/* DIM_SIZE and DIM_POS return the size of a particular compute\n+   dimension and the executing thread's position within that\n+   dimension.  DIM_POS is pure (and not const) so that it isn't\n+   thought to clobber memory and can be gcse'd within a single\n+   parallel region, but not across FORK/JOIN boundaries.  They take a\n+   single INTEGER_CST argument.  */\n+DEF_INTERNAL_FN (GOACC_DIM_SIZE, ECF_CONST | ECF_NOTHROW | ECF_LEAF, \".\")\n+DEF_INTERNAL_FN (GOACC_DIM_POS, ECF_PURE | ECF_NOTHROW | ECF_LEAF, \".\")\n+\n+/* OpenACC looping abstraction.  See internal-fn.h for usage.  */\n+DEF_INTERNAL_FN (GOACC_LOOP, ECF_PURE | ECF_NOTHROW, NULL)"}, {"sha": "2b675e83c1a488a66ee6fda4387a0169a902ebb3", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -22,7 +22,48 @@ along with GCC; see the file COPYING3.  If not see\n \n /* INTEGER_CST values for IFN_UNIQUE function arg-0.  */\n enum ifn_unique_kind {\n-  IFN_UNIQUE_UNSPEC   /* Undifferentiated UNIQUE.  */\n+  IFN_UNIQUE_UNSPEC,  /* Undifferentiated UNIQUE.  */\n+\n+  /* FORK and JOIN mark the points at which OpenACC partitioned\n+     execution is entered or exited.\n+     return: data dependency value\n+     arg-1: data dependency var\n+     arg-2: INTEGER_CST argument, indicating the axis.  */\n+  IFN_UNIQUE_OACC_FORK,\n+  IFN_UNIQUE_OACC_JOIN,\n+\n+  /* HEAD_MARK and TAIL_MARK are used to demark the sequence entering\n+     or leaving partitioned execution.\n+     return: data dependency value\n+     arg-1: data dependency var\n+     arg-2: INTEGER_CST argument, remaining markers in this sequence\n+     arg-3...: varargs on primary header  */\n+  IFN_UNIQUE_OACC_HEAD_MARK,\n+  IFN_UNIQUE_OACC_TAIL_MARK\n+};\n+\n+/* INTEGER_CST values for IFN_GOACC_LOOP arg-0.  Allows the precise\n+   stepping of the compute geometry over the loop iterations to be\n+   deferred until it is known which compiler is generating the code.\n+   The action is encoded in a constant first argument.\n+\n+     CHUNK_MAX = LOOP (CODE_CHUNKS, DIR, RANGE, STEP, CHUNK_SIZE, MASK)\n+     STEP = LOOP (CODE_STEP, DIR, RANGE, STEP, CHUNK_SIZE, MASK)\n+     OFFSET = LOOP (CODE_OFFSET, DIR, RANGE, STEP, CHUNK_SIZE, MASK, CHUNK_NO)\n+     BOUND = LOOP (CODE_BOUND, DIR, RANGE, STEP, CHUNK_SIZE, MASK, OFFSET)\n+\n+     DIR - +1 for up loop, -1 for down loop\n+     RANGE - Range of loop (END - BASE)\n+     STEP - iteration step size\n+     CHUNKING - size of chunking, (constant zero for no chunking)\n+     CHUNK_NO - chunk number\n+     MASK - partitioning mask.  */\n+\n+enum ifn_goacc_loop_kind {\n+  IFN_GOACC_LOOP_CHUNKS,  /* Number of chunks.  */\n+  IFN_GOACC_LOOP_STEP,    /* Size of each thread's step.  */\n+  IFN_GOACC_LOOP_OFFSET,  /* Initial iteration value.  */\n+  IFN_GOACC_LOOP_BOUND    /* Limit of iteration value.  */\n };\n \n /* Initialize internal function tables.  */"}, {"sha": "750a885120684f874c4d05cf6cf83c01aaeda738", "filename": "gcc/omp-low.c", "status": "modified", "additions": 930, "deletions": 2, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -81,6 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"context.h\"\n #include \"lto-section-names.h\"\n #include \"gomp-constants.h\"\n+#include \"gimple-pretty-print.h\"\n \n /* Lowering of OMP parallel and workshare constructs proceeds in two\n    phases.  The first phase scans the function looking for OMP statements\n@@ -233,6 +234,49 @@ struct omp_for_data\n   struct omp_for_data_loop *loops;\n };\n \n+/* Describe the OpenACC looping structure of a function.  The entire\n+   function is held in a 'NULL' loop.  */\n+\n+struct oacc_loop\n+{\n+  oacc_loop *parent; /* Containing loop.  */\n+\n+  oacc_loop *child; /* First inner loop.  */\n+\n+  oacc_loop *sibling; /* Next loop within same parent.  */\n+\n+  location_t loc; /* Location of the loop start.  */\n+\n+  gcall *marker; /* Initial head marker.  */\n+  \n+  gcall *heads[GOMP_DIM_MAX];  /* Head marker functions. */\n+  gcall *tails[GOMP_DIM_MAX];  /* Tail marker functions. */\n+\n+  tree routine;  /* Pseudo-loop enclosing a routine.  */\n+\n+  unsigned mask;   /* Partitioning mask.  */\n+  unsigned flags;   /* Partitioning flags.  */\n+  tree chunk_size;   /* Chunk size.  */\n+  gcall *head_end; /* Final marker of head sequence.  */\n+};\n+\n+/*  Flags for an OpenACC loop.  */\n+\n+enum oacc_loop_flags {\n+  OLF_SEQ\t= 1u << 0,  /* Explicitly sequential  */\n+  OLF_AUTO\t= 1u << 1,\t/* Compiler chooses axes.  */\n+  OLF_INDEPENDENT = 1u << 2,\t/* Iterations are known independent.  */\n+  OLF_GANG_STATIC = 1u << 3,\t/* Gang partitioning is static (has op). */\n+\n+  /* Explicitly specified loop axes.  */\n+  OLF_DIM_BASE = 4,\n+  OLF_DIM_GANG   = 1u << (OLF_DIM_BASE + GOMP_DIM_GANG),\n+  OLF_DIM_WORKER = 1u << (OLF_DIM_BASE + GOMP_DIM_WORKER),\n+  OLF_DIM_VECTOR = 1u << (OLF_DIM_BASE + GOMP_DIM_VECTOR),\n+\n+  OLF_MAX = OLF_DIM_BASE + GOMP_DIM_MAX\n+};\n+\n \n static splay_tree all_contexts;\n static int taskreg_nesting_level;\n@@ -17584,6 +17628,241 @@ omp_finish_file (void)\n     }\n }\n \n+/* Find the number of threads (POS = false), or thread number (POS =\n+   true) for an OpenACC region partitioned as MASK.  Setup code\n+   required for the calculation is added to SEQ.  */\n+\n+static tree\n+oacc_thread_numbers (bool pos, int mask, gimple_seq *seq)\n+{\n+  tree res = pos ? NULL_TREE : build_int_cst (unsigned_type_node, 1);\n+  unsigned ix;\n+\n+  /* Start at gang level, and examine relevant dimension indices.  */\n+  for (ix = GOMP_DIM_GANG; ix != GOMP_DIM_MAX; ix++)\n+    if (GOMP_DIM_MASK (ix) & mask)\n+      {\n+\ttree arg = build_int_cst (unsigned_type_node, ix);\n+\n+\tif (res)\n+\t  {\n+\t    /* We had an outer index, so scale that by the size of\n+\t       this dimension.  */\n+\t    tree n = create_tmp_var (integer_type_node);\n+\t    gimple *call\n+\t      = gimple_build_call_internal (IFN_GOACC_DIM_SIZE, 1, arg);\n+\t    \n+\t    gimple_call_set_lhs (call, n);\n+\t    gimple_seq_add_stmt (seq, call);\n+\t    res = fold_build2 (MULT_EXPR, integer_type_node, res, n);\n+\t  }\n+\tif (pos)\n+\t  {\n+\t    /* Determine index in this dimension.  */\n+\t    tree id = create_tmp_var (integer_type_node);\n+\t    gimple *call = gimple_build_call_internal\n+\t      (IFN_GOACC_DIM_POS, 1, arg);\n+\n+\t    gimple_call_set_lhs (call, id);\n+\t    gimple_seq_add_stmt (seq, call);\n+\t    if (res)\n+\t      res = fold_build2 (PLUS_EXPR, integer_type_node, res, id);\n+\t    else\n+\t      res = id;\n+\t  }\n+      }\n+\n+  if (res == NULL_TREE)\n+    res = integer_zero_node;\n+\n+  return res;\n+}\n+\n+/* Transform IFN_GOACC_LOOP calls to actual code.  See\n+   expand_oacc_for for where these are generated.  At the vector\n+   level, we stride loops, such that each member of a warp will\n+   operate on adjacent iterations.  At the worker and gang level,\n+   each gang/warp executes a set of contiguous iterations.  Chunking\n+   can override this such that each iteration engine executes a\n+   contiguous chunk, and then moves on to stride to the next chunk.   */\n+\n+static void\n+oacc_xform_loop (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  enum ifn_goacc_loop_kind code\n+    = (enum ifn_goacc_loop_kind) TREE_INT_CST_LOW (gimple_call_arg (call, 0));\n+  tree dir = gimple_call_arg (call, 1);\n+  tree range = gimple_call_arg (call, 2);\n+  tree step = gimple_call_arg (call, 3);\n+  tree chunk_size = NULL_TREE;\n+  unsigned mask = (unsigned) TREE_INT_CST_LOW (gimple_call_arg (call, 5));\n+  tree lhs = gimple_call_lhs (call);\n+  tree type = TREE_TYPE (lhs);\n+  tree diff_type = TREE_TYPE (range);\n+  tree r = NULL_TREE;\n+  gimple_seq seq = NULL;\n+  bool chunking = false, striding = true;\n+  unsigned outer_mask = mask & (~mask + 1); // Outermost partitioning\n+  unsigned inner_mask = mask & ~outer_mask; // Inner partitioning (if any)\n+\n+#ifdef ACCEL_COMPILER\n+  chunk_size = gimple_call_arg (call, 4);\n+  if (integer_minus_onep (chunk_size)  /* Force static allocation.  */\n+      || integer_zerop (chunk_size))   /* Default (also static).  */\n+    {\n+      /* If we're at the gang level, we want each to execute a\n+\t contiguous run of iterations.  Otherwise we want each element\n+\t to stride.  */\n+      striding = !(outer_mask & GOMP_DIM_MASK (GOMP_DIM_GANG));\n+      chunking = false;\n+    }\n+  else\n+    {\n+      /* Chunk of size 1 is striding.  */\n+      striding = integer_onep (chunk_size);\n+      chunking = !striding;\n+    }\n+#endif\n+\n+  /* striding=true, chunking=true\n+       -> invalid.\n+     striding=true, chunking=false\n+       -> chunks=1\n+     striding=false,chunking=true\n+       -> chunks=ceil (range/(chunksize*threads*step))\n+     striding=false,chunking=false\n+       -> chunk_size=ceil(range/(threads*step)),chunks=1  */\n+  push_gimplify_context (true);\n+\n+  switch (code)\n+    {\n+    default: gcc_unreachable ();\n+\n+    case IFN_GOACC_LOOP_CHUNKS:\n+      if (!chunking)\n+\tr = build_int_cst (type, 1);\n+      else\n+\t{\n+\t  /* chunk_max\n+\t     = (range - dir) / (chunks * step * num_threads) + dir  */\n+\t  tree per = oacc_thread_numbers (false, mask, &seq);\n+\t  per = fold_convert (type, per);\n+\t  chunk_size = fold_convert (type, chunk_size);\n+\t  per = fold_build2 (MULT_EXPR, type, per, chunk_size);\n+\t  per = fold_build2 (MULT_EXPR, type, per, step);\n+\t  r = build2 (MINUS_EXPR, type, range, dir);\n+\t  r = build2 (PLUS_EXPR, type, r, per);\n+\t  r = build2 (TRUNC_DIV_EXPR, type, r, per);\n+\t}\n+      break;\n+\n+    case IFN_GOACC_LOOP_STEP:\n+      {\n+\t/* If striding, step by the entire compute volume, otherwise\n+\t   step by the inner volume.  */\n+\tunsigned volume = striding ? mask : inner_mask;\n+\n+\tr = oacc_thread_numbers (false, volume, &seq);\n+\tr = build2 (MULT_EXPR, type, fold_convert (type, r), step);\n+      }\n+      break;\n+\n+    case IFN_GOACC_LOOP_OFFSET:\n+      if (striding)\n+\t{\n+\t  r = oacc_thread_numbers (true, mask, &seq);\n+\t  r = fold_convert (diff_type, r);\n+\t}\n+      else\n+\t{\n+\t  tree inner_size = oacc_thread_numbers (false, inner_mask, &seq);\n+\t  tree outer_size = oacc_thread_numbers (false, outer_mask, &seq);\n+\t  tree volume = fold_build2 (MULT_EXPR, TREE_TYPE (inner_size),\n+\t\t\t\t     inner_size, outer_size);\n+\n+\t  volume = fold_convert (diff_type, volume);\n+\t  if (chunking)\n+\t    chunk_size = fold_convert (diff_type, chunk_size);\n+\t  else\n+\t    {\n+\t      tree per = fold_build2 (MULT_EXPR, diff_type, volume, step);\n+\n+\t      chunk_size = build2 (MINUS_EXPR, diff_type, range, dir);\n+\t      chunk_size = build2 (PLUS_EXPR, diff_type, chunk_size, per);\n+\t      chunk_size = build2 (TRUNC_DIV_EXPR, diff_type, chunk_size, per);\n+\t    }\n+\n+\t  tree span = build2 (MULT_EXPR, diff_type, chunk_size,\n+\t\t\t      fold_convert (diff_type, inner_size));\n+\t  r = oacc_thread_numbers (true, outer_mask, &seq);\n+\t  r = fold_convert (diff_type, r);\n+\t  r = build2 (MULT_EXPR, diff_type, r, span);\n+\n+\t  tree inner = oacc_thread_numbers (true, inner_mask, &seq);\n+\t  inner = fold_convert (diff_type, inner);\n+\t  r = fold_build2 (PLUS_EXPR, diff_type, r, inner);\n+\n+\t  if (chunking)\n+\t    {\n+\t      tree chunk = fold_convert (diff_type, gimple_call_arg (call, 6));\n+\t      tree per\n+\t\t= fold_build2 (MULT_EXPR, diff_type, volume, chunk_size);\n+\t      per = build2 (MULT_EXPR, diff_type, per, chunk);\n+\n+\t      r = build2 (PLUS_EXPR, diff_type, r, per);\n+\t    }\n+\t}\n+      r = fold_build2 (MULT_EXPR, diff_type, r, step);\n+      if (type != diff_type)\n+\tr = fold_convert (type, r);\n+      break;\n+\n+    case IFN_GOACC_LOOP_BOUND:\n+      if (striding)\n+\tr = range;\n+      else\n+\t{\n+\t  tree inner_size = oacc_thread_numbers (false, inner_mask, &seq);\n+\t  tree outer_size = oacc_thread_numbers (false, outer_mask, &seq);\n+\t  tree volume = fold_build2 (MULT_EXPR, TREE_TYPE (inner_size),\n+\t\t\t\t     inner_size, outer_size);\n+\n+\t  volume = fold_convert (diff_type, volume);\n+\t  if (chunking)\n+\t    chunk_size = fold_convert (diff_type, chunk_size);\n+\t  else\n+\t    {\n+\t      tree per = fold_build2 (MULT_EXPR, diff_type, volume, step);\n+\n+\t      chunk_size = build2 (MINUS_EXPR, diff_type, range, dir);\n+\t      chunk_size = build2 (PLUS_EXPR, diff_type, chunk_size, per);\n+\t      chunk_size = build2 (TRUNC_DIV_EXPR, diff_type, chunk_size, per);\n+\t    }\n+\n+\t  tree span = build2 (MULT_EXPR, diff_type, chunk_size,\n+\t\t\t      fold_convert (diff_type, inner_size));\n+\n+\t  r = fold_build2 (MULT_EXPR, diff_type, span, step);\n+\n+\t  tree offset = gimple_call_arg (call, 6);\n+\t  r = build2 (PLUS_EXPR, diff_type, r,\n+\t\t      fold_convert (diff_type, offset));\n+\t  r = build2 (integer_onep (dir) ? MIN_EXPR : MAX_EXPR,\n+\t\t      diff_type, r, range);\n+\t}\n+      if (diff_type != type)\n+\tr = fold_convert (type, r);\n+      break;\n+    }\n+\n+  gimplify_assign (lhs, r, &seq);\n+\n+  pop_gimplify_context (NULL);\n+\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n /* Validate and update the dimensions for offloaded FN.  ATTRS is the\n    raw attribute.  DIMS is an array of dimensions, which is returned.\n    Returns the function level dimensionality --  the level at which an\n@@ -17642,6 +17921,553 @@ oacc_validate_dims (tree fn, tree attrs, int *dims)\n   return fn_level;\n }\n \n+/* Create an empty OpenACC loop structure at LOC.  */\n+\n+static oacc_loop *\n+new_oacc_loop_raw (oacc_loop *parent, location_t loc)\n+{\n+  oacc_loop *loop = XCNEW (oacc_loop);\n+\n+  loop->parent = parent;\n+  loop->child = loop->sibling = NULL;\n+\n+  if (parent)\n+    {\n+      loop->sibling = parent->child;\n+      parent->child = loop;\n+    }\n+\n+  loop->loc = loc;\n+  loop->marker = NULL;\n+  memset (loop->heads, 0, sizeof (loop->heads));\n+  memset (loop->tails, 0, sizeof (loop->tails));\n+  loop->routine = NULL_TREE;\n+\n+  loop->mask = loop->flags = 0;\n+  loop->chunk_size = 0;\n+  loop->head_end = NULL;\n+\n+  return loop;\n+}\n+\n+/* Create an outermost, dummy OpenACC loop for offloaded function\n+   DECL.  */\n+\n+static oacc_loop *\n+new_oacc_loop_outer (tree decl)\n+{\n+  return new_oacc_loop_raw (NULL, DECL_SOURCE_LOCATION (decl));\n+}\n+\n+/* Start a new OpenACC loop  structure beginning at head marker HEAD.\n+   Link into PARENT loop.  Return the new loop.  */\n+\n+static oacc_loop *\n+new_oacc_loop (oacc_loop *parent, gcall *marker)\n+{\n+  oacc_loop *loop = new_oacc_loop_raw (parent, gimple_location (marker));\n+\n+  loop->marker = marker;\n+  \n+  /* TODO: This is where device_type flattening would occur for the loop\n+     flags.   */\n+\n+  loop->flags = TREE_INT_CST_LOW (gimple_call_arg (marker, 3));\n+\n+  tree chunk_size = integer_zero_node;\n+  if (loop->flags & OLF_GANG_STATIC)\n+    chunk_size = gimple_call_arg (marker, 4);\n+  loop->chunk_size = chunk_size;\n+\n+  return loop;\n+}\n+\n+/* Create a dummy loop encompassing a call to a openACC routine.\n+   Extract the routine's partitioning requirements.  */\n+\n+static void\n+new_oacc_loop_routine (oacc_loop *parent, gcall *call, tree decl, tree attrs)\n+{\n+  oacc_loop *loop = new_oacc_loop_raw (parent, gimple_location (call));\n+  int dims[GOMP_DIM_MAX];\n+  int level = oacc_validate_dims (decl, attrs, dims);\n+\n+  gcc_assert (level >= 0);\n+\n+  loop->marker = call;\n+  loop->routine = decl;\n+  loop->mask = ((GOMP_DIM_MASK (GOMP_DIM_MAX) - 1)\n+\t\t^ (GOMP_DIM_MASK (level) - 1));\n+}\n+\n+/* Finish off the current OpenACC loop ending at tail marker TAIL.\n+   Return the parent loop.  */\n+\n+static oacc_loop *\n+finish_oacc_loop (oacc_loop *loop)\n+{\n+  return loop->parent;\n+}\n+\n+/* Free all OpenACC loop structures within LOOP (inclusive).  */\n+\n+static void\n+free_oacc_loop (oacc_loop *loop)\n+{\n+  if (loop->sibling)\n+    free_oacc_loop (loop->sibling);\n+  if (loop->child)\n+    free_oacc_loop (loop->child);\n+\n+  free (loop);\n+}\n+\n+/* Dump out the OpenACC loop head or tail beginning at FROM.  */\n+\n+static void\n+dump_oacc_loop_part (FILE *file, gcall *from, int depth,\n+\t\t     const char *title, int level)\n+{\n+  enum ifn_unique_kind kind\n+    = (enum ifn_unique_kind) TREE_INT_CST_LOW (gimple_call_arg (from, 0));\n+\n+  fprintf (file, \"%*s%s-%d:\\n\", depth * 2, \"\", title, level);\n+  for (gimple_stmt_iterator gsi = gsi_for_stmt (from);;)\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      if (is_gimple_call (stmt)\n+\t  && gimple_call_internal_p (stmt)\n+\t  && gimple_call_internal_fn (stmt) == IFN_UNIQUE)\n+\t{\n+\t  enum ifn_unique_kind k\n+\t    = ((enum ifn_unique_kind) TREE_INT_CST_LOW\n+\t       (gimple_call_arg (stmt, 0)));\n+\n+\t  if (k == kind && stmt != from)\n+\t    break;\n+\t}\n+      print_gimple_stmt (file, stmt, depth * 2 + 2, 0);\n+\n+      gsi_next (&gsi);\n+      while (gsi_end_p (gsi))\n+\tgsi = gsi_start_bb (single_succ (gsi_bb (gsi)));\n+    }\n+}\n+\n+/* Dump OpenACC loops LOOP, its siblings and its children.  */\n+\n+static void\n+dump_oacc_loop (FILE *file, oacc_loop *loop, int depth)\n+{\n+  int ix;\n+  \n+  fprintf (file, \"%*sLoop %x(%x) %s:%u\\n\", depth * 2, \"\",\n+\t   loop->flags, loop->mask,\n+\t   LOCATION_FILE (loop->loc), LOCATION_LINE (loop->loc));\n+\n+  if (loop->marker)\n+    print_gimple_stmt (file, loop->marker, depth * 2, 0);\n+\n+  if (loop->routine)\n+    fprintf (file, \"%*sRoutine %s:%u:%s\\n\",\n+\t     depth * 2, \"\", DECL_SOURCE_FILE (loop->routine),\n+\t     DECL_SOURCE_LINE (loop->routine),\n+\t     IDENTIFIER_POINTER (DECL_NAME (loop->routine)));\n+\n+  for (ix = GOMP_DIM_GANG; ix != GOMP_DIM_MAX; ix++)\n+    if (loop->heads[ix])\n+      dump_oacc_loop_part (file, loop->heads[ix], depth, \"Head\", ix);\n+  for (ix = GOMP_DIM_MAX; ix--;)\n+    if (loop->tails[ix])\n+      dump_oacc_loop_part (file, loop->tails[ix], depth, \"Tail\", ix);\n+\n+  if (loop->child)\n+    dump_oacc_loop (file, loop->child, depth + 1);\n+  if (loop->sibling)\n+    dump_oacc_loop (file, loop->sibling, depth);\n+}\n+\n+void debug_oacc_loop (oacc_loop *);\n+\n+/* Dump loops to stderr.  */\n+\n+DEBUG_FUNCTION void\n+debug_oacc_loop (oacc_loop *loop)\n+{\n+  dump_oacc_loop (stderr, loop, 0);\n+}\n+\n+/* DFS walk of basic blocks BB onwards, creating OpenACC loop\n+   structures as we go.  By construction these loops are properly\n+   nested.  */\n+\n+static void\n+oacc_loop_discover_walk (oacc_loop *loop, basic_block bb)\n+{\n+  int marker = 0;\n+  int remaining = 0;\n+\n+  if (bb->flags & BB_VISITED)\n+    return;\n+\n+ follow:\n+  bb->flags |= BB_VISITED;\n+\n+  /* Scan for loop markers.  */\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      if (!is_gimple_call (stmt))\n+\tcontinue;\n+\n+      gcall *call = as_a <gcall *> (stmt);\n+      \n+      /* If this is a routine, make a dummy loop for it.  */\n+      if (tree decl = gimple_call_fndecl (call))\n+\tif (tree attrs = get_oacc_fn_attrib (decl))\n+\t  {\n+\t    gcc_assert (!marker);\n+\t    new_oacc_loop_routine (loop, call, decl, attrs);\n+\t  }\n+\n+      if (!gimple_call_internal_p (call))\n+\tcontinue;\n+\n+      if (gimple_call_internal_fn (call) != IFN_UNIQUE)\n+\tcontinue;\n+\n+      enum ifn_unique_kind kind\n+\t= (enum ifn_unique_kind) TREE_INT_CST_LOW (gimple_call_arg (call, 0));\n+      if (kind == IFN_UNIQUE_OACC_HEAD_MARK\n+\t  || kind == IFN_UNIQUE_OACC_TAIL_MARK)\n+\t{\n+\t  if (gimple_call_num_args (call) == 2)\n+\t    {\n+\t      gcc_assert (marker && !remaining);\n+\t      marker = 0;\n+\t      if (kind == IFN_UNIQUE_OACC_TAIL_MARK)\n+\t\tloop = finish_oacc_loop (loop);\n+\t      else\n+\t\tloop->head_end = call;\n+\t    }\n+\t  else\n+\t    {\n+\t      int count = TREE_INT_CST_LOW (gimple_call_arg (call, 2));\n+\n+\t      if (!marker)\n+\t\t{\n+\t\t  if (kind == IFN_UNIQUE_OACC_HEAD_MARK)\n+\t\t    loop = new_oacc_loop (loop, call);\n+\t\t  remaining = count;\n+\t\t}\n+\t      gcc_assert (count == remaining);\n+\t      if (remaining)\n+\t\t{\n+\t\t  remaining--;\n+\t\t  if (kind == IFN_UNIQUE_OACC_HEAD_MARK)\n+\t\t    loop->heads[marker] = call;\n+\t\t  else\n+\t\t    loop->tails[remaining] = call;\n+\t\t}\n+\t      marker++;\n+\t    }\n+\t}\n+    }\n+  if (remaining || marker)\n+    {\n+      bb = single_succ (bb);\n+      gcc_assert (single_pred_p (bb) && !(bb->flags & BB_VISITED));\n+      goto follow;\n+    }\n+\n+  /* Walk successor blocks.  */\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    oacc_loop_discover_walk (loop, e->dest);\n+}\n+\n+/* LOOP is the first sibling.  Reverse the order in place and return\n+   the new first sibling.  Recurse to child loops.  */\n+\n+static oacc_loop *\n+oacc_loop_sibling_nreverse (oacc_loop *loop)\n+{\n+  oacc_loop *last = NULL;\n+  do\n+    {\n+      if (loop->child)\n+\tloop->child = oacc_loop_sibling_nreverse  (loop->child);\n+\n+      oacc_loop *next = loop->sibling;\n+      loop->sibling = last;\n+      last = loop;\n+      loop = next;\n+    }\n+  while (loop);\n+\n+  return last;\n+}\n+\n+/* Discover the OpenACC loops marked up by HEAD and TAIL markers for\n+   the current function.  */\n+\n+static oacc_loop *\n+oacc_loop_discovery ()\n+{\n+  basic_block bb;\n+  \n+  oacc_loop *top = new_oacc_loop_outer (current_function_decl);\n+  oacc_loop_discover_walk (top, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+  /* The siblings were constructed in reverse order, reverse them so\n+     that diagnostics come out in an unsurprising order.  */\n+  top = oacc_loop_sibling_nreverse (top);\n+\n+  /* Reset the visited flags.  */\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bb->flags &= ~BB_VISITED;\n+\n+  return top;\n+}\n+\n+/* Transform the abstract internal function markers starting at FROM\n+   to be for partitioning level LEVEL.  Stop when we meet another HEAD\n+   or TAIL  marker.  */\n+\n+static void\n+oacc_loop_xform_head_tail (gcall *from, int level)\n+{\n+  enum ifn_unique_kind kind\n+    = (enum ifn_unique_kind) TREE_INT_CST_LOW (gimple_call_arg (from, 0));\n+  tree replacement = build_int_cst (unsigned_type_node, level);\n+\n+  for (gimple_stmt_iterator gsi = gsi_for_stmt (from);;)\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      \n+      if (is_gimple_call (stmt)\n+\t  && gimple_call_internal_p (stmt)\n+\t  && gimple_call_internal_fn (stmt) == IFN_UNIQUE)\n+\t{\n+\t  enum ifn_unique_kind k\n+\t    = ((enum ifn_unique_kind)\n+\t       TREE_INT_CST_LOW (gimple_call_arg (stmt, 0)));\n+\n+\t  if (k == IFN_UNIQUE_OACC_FORK || k == IFN_UNIQUE_OACC_JOIN)\n+\t    *gimple_call_arg_ptr (stmt, 2) = replacement;\n+\t  else if (k == kind && stmt != from)\n+\t    break;\n+\t}\n+      gsi_next (&gsi);\n+      while (gsi_end_p (gsi))\n+\tgsi = gsi_start_bb (single_succ (gsi_bb (gsi)));\n+    }\n+}\n+\n+/* Transform the IFN_GOACC_LOOP internal functions by providing the\n+   determined partitioning mask and chunking argument.  */\n+\n+static void\n+oacc_loop_xform_loop (gcall *end_marker, tree mask_arg, tree chunk_arg)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (end_marker);\n+  \n+  for (;;)\n+    {\n+      for (; !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  if (!is_gimple_call (stmt))\n+\t    continue;\n+\n+\t  gcall *call = as_a <gcall *> (stmt);\n+      \n+\t  if (!gimple_call_internal_p (call))\n+\t    continue;\n+\n+\t  if (gimple_call_internal_fn (call) != IFN_GOACC_LOOP)\n+\t    continue;\n+\n+\t  *gimple_call_arg_ptr (call, 5) = mask_arg;\n+\t  *gimple_call_arg_ptr (call, 4) = chunk_arg;\n+\t  if (TREE_INT_CST_LOW (gimple_call_arg (call, 0))\n+\t      == IFN_GOACC_LOOP_BOUND)\n+\t    return;\n+\t}\n+\n+      /* If we didn't see LOOP_BOUND, it should be in the single\n+\t successor block.  */\n+      basic_block bb = single_succ (gsi_bb (gsi));\n+      gsi = gsi_start_bb (bb);\n+    }\n+}\n+\n+/* Process the discovered OpenACC loops, setting the correct\n+   partitioning level etc.  */\n+\n+static void\n+oacc_loop_process (oacc_loop *loop)\n+{\n+  if (loop->child)\n+    oacc_loop_process (loop->child);\n+\n+  if (loop->mask && !loop->routine)\n+    {\n+      int ix;\n+      unsigned mask = loop->mask;\n+      unsigned dim = GOMP_DIM_GANG;\n+      tree mask_arg = build_int_cst (unsigned_type_node, mask);\n+      tree chunk_arg = loop->chunk_size;\n+\n+      oacc_loop_xform_loop (loop->head_end, mask_arg, chunk_arg);\n+\n+      for (ix = 0; ix != GOMP_DIM_MAX && loop->heads[ix]; ix++)\n+\t{\n+\t  gcc_assert (mask);\n+\n+\t  while (!(GOMP_DIM_MASK (dim) & mask))\n+\t    dim++;\n+\n+\t  oacc_loop_xform_head_tail (loop->heads[ix], dim);\n+\t  oacc_loop_xform_head_tail (loop->tails[ix], dim);\n+\n+\t  mask ^= GOMP_DIM_MASK (dim);\n+\t}\n+    }\n+\n+  if (loop->sibling)\n+    oacc_loop_process (loop->sibling);\n+}\n+\n+/* Walk the OpenACC loop heirarchy checking and assigning the\n+   programmer-specified partitionings.  OUTER_MASK is the partitioning\n+   this loop is contained within.  Return partitiong mask used within\n+   this loop nest.  */\n+\n+static unsigned\n+oacc_loop_fixed_partitions (oacc_loop *loop, unsigned outer_mask)\n+{\n+  unsigned this_mask = loop->mask;\n+  bool has_auto = false;\n+  bool noisy = true;\n+\n+#ifdef ACCEL_COMPILER\n+  /* When device_type is supported, we want the device compiler to be\n+     noisy, if the loop parameters are device_type-specific.  */\n+  noisy = false;\n+#endif\n+\n+  if (!loop->routine)\n+    {\n+      bool auto_par = (loop->flags & OLF_AUTO) != 0;\n+      bool seq_par = (loop->flags & OLF_SEQ) != 0;\n+\n+      this_mask = ((loop->flags >> OLF_DIM_BASE)\n+\t\t   & (GOMP_DIM_MASK (GOMP_DIM_MAX) - 1));\n+\n+      if ((this_mask != 0) + auto_par + seq_par > 1)\n+\t{\n+\t  if (noisy)\n+\t    error_at (loop->loc,\n+\t\t      seq_par\n+\t\t      ? \"%<seq%> overrides other OpenACC loop specifiers\"\n+\t\t      : \"%<auto%> conflicts with other OpenACC loop specifiers\");\n+\t  auto_par = false;\n+\t  loop->flags &= ~OLF_AUTO;\n+\t  if (seq_par)\n+\t    {\n+\t      loop->flags &=\n+\t\t~((GOMP_DIM_MASK (GOMP_DIM_MAX) - 1) << OLF_DIM_BASE);\n+\t      this_mask = 0;\n+\t    }\n+\t}\n+      if (auto_par && (loop->flags & OLF_INDEPENDENT))\n+\thas_auto = true;\n+    }\n+\n+  if (this_mask & outer_mask)\n+    {\n+      const oacc_loop *outer;\n+      for (outer = loop->parent; outer; outer = outer->parent)\n+\tif (outer->mask & this_mask)\n+\t  break;\n+\n+      if (noisy)\n+\t{\n+\t  if (outer)\n+\t    {\n+\t      error_at (loop->loc,\n+\t\t\t\"%s uses same OpenACC parallelism as containing loop\",\n+\t\t\tloop->routine ? \"routine call\" : \"inner loop\");\n+\t      inform (outer->loc, \"containing loop here\");\n+\t    }\n+\t  else\n+\t    error_at (loop->loc,\n+\t\t      \"%s uses OpenACC parallelism disallowed by containing routine\",\n+\t\t      loop->routine ? \"routine call\" : \"loop\");\n+      \n+\t  if (loop->routine)\n+\t    inform (DECL_SOURCE_LOCATION (loop->routine),\n+\t\t    \"routine %qD declared here\", loop->routine);\n+\t}\n+      this_mask &= ~outer_mask;\n+    }\n+  else\n+    {\n+      unsigned outermost = this_mask & -this_mask;\n+\n+      if (outermost && outermost <= outer_mask)\n+\t{\n+\t  if (noisy)\n+\t    {\n+\t      error_at (loop->loc,\n+\t\t\t\"incorrectly nested OpenACC loop parallelism\");\n+\n+\t      const oacc_loop *outer;\n+\t      for (outer = loop->parent;\n+\t\t   outer->flags && outer->flags < outermost;\n+\t\t   outer = outer->parent)\n+\t\tcontinue;\n+\t      inform (outer->loc, \"containing loop here\");\n+\t    }\n+\n+\t  this_mask &= ~outermost;\n+\t}\n+    }\n+\n+  loop->mask = this_mask;\n+\n+  if (loop->child\n+      && oacc_loop_fixed_partitions (loop->child, outer_mask | this_mask))\n+    has_auto = true;\n+\n+  if (loop->sibling\n+      && oacc_loop_fixed_partitions (loop->sibling, outer_mask))\n+    has_auto = true;\n+\n+  return has_auto;\n+}\n+\n+/* Walk the OpenACC loop heirarchy to check and assign partitioning\n+   axes.  */\n+\n+static void\n+oacc_loop_partition (oacc_loop *loop, int fn_level)\n+{\n+  unsigned outer_mask = 0;\n+\n+  if (fn_level >= 0)\n+    outer_mask = GOMP_DIM_MASK (fn_level) - 1;\n+\n+  oacc_loop_fixed_partitions (loop, outer_mask);\n+}\n+\n /* Default fork/join early expander.  Delete the function calls if\n    there is no RTL expander.  */\n \n@@ -17669,8 +18495,110 @@ execute_oacc_device_lower ()\n     /* Not an offloaded function.  */\n     return 0;\n \n-  oacc_validate_dims (current_function_decl, attrs, dims);\n-  \n+  int fn_level = oacc_validate_dims (current_function_decl, attrs, dims);\n+\n+  /* Discover, partition and process the loops.  */\n+  oacc_loop *loops = oacc_loop_discovery ();\n+  oacc_loop_partition (loops, fn_level);\n+  oacc_loop_process (loops);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"OpenACC loops\\n\");\n+      dump_oacc_loop (dump_file, loops, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* Now lower internal loop functions to target-specific code\n+     sequences.  */\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\tif (!is_gimple_call (stmt))\n+\t  {\n+\t    gsi_next (&gsi);\n+\t    continue;\n+\t  }\n+\n+\tgcall *call = as_a <gcall *> (stmt);\n+\tif (!gimple_call_internal_p (call))\n+\t  {\n+\t    gsi_next (&gsi);\n+\t    continue;\n+\t  }\n+\n+\t/* Rewind to allow rescan.  */\n+\tgsi_prev (&gsi);\n+\tbool rescan = false, remove = false;\n+\tenum  internal_fn ifn_code = gimple_call_internal_fn (call);\n+\n+\tswitch (ifn_code)\n+\t  {\n+\t  default: break;\n+\n+\t  case IFN_GOACC_LOOP:\n+\t    oacc_xform_loop (call);\n+\t    rescan = true;\n+\t    break;\n+\n+\t  case IFN_UNIQUE:\n+\t    {\n+\t      enum ifn_unique_kind kind\n+\t\t= ((enum ifn_unique_kind)\n+\t\t   TREE_INT_CST_LOW (gimple_call_arg (call, 0)));\n+\n+\t      switch (kind)\n+\t\t{\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\n+\t\tcase IFN_UNIQUE_OACC_FORK:\n+\t\tcase IFN_UNIQUE_OACC_JOIN:\n+\t\t  if (integer_minus_onep (gimple_call_arg (call, 2)))\n+\t\t    remove = true;\n+\t\t  else if (!targetm.goacc.fork_join\n+\t\t\t   (call, dims, kind == IFN_UNIQUE_OACC_FORK))\n+\t\t    remove = true;\n+\t\t  break;\n+\n+\t\tcase IFN_UNIQUE_OACC_HEAD_MARK:\n+\t\tcase IFN_UNIQUE_OACC_TAIL_MARK:\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  }\n+\n+\tif (gsi_end_p (gsi))\n+\t  /* We rewound past the beginning of the BB.  */\n+\t  gsi = gsi_start_bb (bb);\n+\telse\n+\t  /* Undo the rewind.  */\n+\t  gsi_next (&gsi);\n+\n+\tif (remove)\n+\t  {\n+\t    if (gimple_vdef (call))\n+\t      replace_uses_by (gimple_vdef (call), gimple_vuse (call));\n+\t    if (gimple_call_lhs (call))\n+\t      {\n+\t\t/* Propagate the data dependency var.  */\n+\t\tgimple *ass = gimple_build_assign (gimple_call_lhs (call),\n+\t\t\t\t\t\t   gimple_call_arg (call, 1));\n+\t\tgsi_replace (&gsi, ass,  false);\n+\t      }\n+\t    else\n+\t      gsi_remove (&gsi, true);\n+\t  }\n+\telse if (!rescan)\n+\t  /* If not rescanning, advance over the call.  */\n+\t  gsi_next (&gsi);\n+      }\n+\n+  free_oacc_loop (loops);\n+\n   return 0;\n }\n "}, {"sha": "0353bb50c0ab2859408b6204de6f2a23c38899da", "filename": "gcc/target-insns.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -64,6 +64,8 @@ DEF_TARGET_INSN (memory_barrier, (void))\n DEF_TARGET_INSN (movstr, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (nonlocal_goto, (rtx x0, rtx x1, rtx x2, rtx x3))\n DEF_TARGET_INSN (nonlocal_goto_receiver, (void))\n+DEF_TARGET_INSN (oacc_dim_pos, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (oacc_dim_size, (rtx x0, rtx x1))\n DEF_TARGET_INSN (oacc_fork, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (oacc_join, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (prefetch, (rtx x0, rtx x1, rtx x2))"}, {"sha": "773b6ef02bd45b42c18a31b50b8c4ca7b20a33cc", "filename": "gcc/target.def", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bd46bc97ef88578526adfcba806c9ecd2f9a605/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=9bd46bc97ef88578526adfcba806c9ecd2f9a605", "patch": "@@ -1660,11 +1660,13 @@ default_goacc_validate_dims)\n \n DEFHOOK\n (fork_join,\n-\"This hook should convert IFN_GOACC_FORK and IFN_GOACC_JOIN function\\n\\\n-calls to target-specific gimple.  It is executed during the\\n\\\n-oacc_device_lower pass.  It should return true, if the functions\\n\\\n-should be deleted.  The default hook returns true, if there are no\\n\\\n-RTL expanders for them.\",\n+\"This hook can be used to convert IFN_GOACC_FORK and IFN_GOACC_JOIN\\n\\\n+function calls to target-specific gimple, or indicate whether they\\n\\\n+should be retained.  It is executed during the oacc_device_lower pass.\\n\\\n+It should return true, if the call should be retained.  It should\\n\\\n+return false, if it is to be deleted (either because target-specific\\n\\\n+gimple has been inserted before it, or there is no need for it).\\n\\\n+The default hook returns false, if there are no RTL expanders for them.\",\n bool, (gcall *call, const int *dims, bool is_fork),\n default_goacc_fork_join)\n "}]}