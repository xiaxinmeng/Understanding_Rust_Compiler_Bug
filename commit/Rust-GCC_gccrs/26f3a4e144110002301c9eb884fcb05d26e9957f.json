{"sha": "26f3a4e144110002301c9eb884fcb05d26e9957f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZmM2E0ZTE0NDExMDAwMjMwMWM5ZWI4ODRmY2IwNWQyNmU5OTU3Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-09-01T11:35:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-09-01T11:35:10Z"}, "message": "tree-ssa-sccvn.h (copy_reference_ops_from_ref, [...]): Remove.\n\n2014-09-01  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-sccvn.h (copy_reference_ops_from_ref,\n\tcopy_reference_ops_from_call, vn_nary_op_compute_hash,\n\tvn_reference_compute_hash, vn_reference_insert): Remove.\n\t(vn_reference_lookup_call): New function.\n\t* tree-ssa-sccvn.c (vn_reference_compute_hash,\n\tcopy_reference_ops_from_ref, copy_reference_ops_from_call,\n\tvn_reference_insert, vn_nary_op_compute_hash): Make static.\n\t(create_reference_ops_from_call): Remove.\n\t(vn_reference_lookup_3): Properly update shared_lookup_references.\n\t(vn_reference_lookup_pieces): Assert that we updated\n\tshared_lookup_references properly.\n\t(vn_reference_lookup): Likewise.\n\t(vn_reference_lookup_call): New function.\n\t(visit_reference_op_call): Use it.  Avoid re-building the\n\treference ops.\n\t(visit_reference_op_load): Remove redundant lookup.\n\t(visit_reference_op_store): Perform special tail-merging work\n\tonly when possibly doing tail-merging.\n\t(visit_use): Likewise.\n\t* tree-ssa-pre.c (compute_avail): Use vn_reference_lookup_call.\n\nFrom-SVN: r214787", "tree": {"sha": "a50714c621ef63ef6cb6fa0e243cdd2cd6bd5c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50714c621ef63ef6cb6fa0e243cdd2cd6bd5c60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26f3a4e144110002301c9eb884fcb05d26e9957f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f3a4e144110002301c9eb884fcb05d26e9957f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26f3a4e144110002301c9eb884fcb05d26e9957f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f3a4e144110002301c9eb884fcb05d26e9957f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0107bd001ec4bc30b345a157561f27ca4419e0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0107bd001ec4bc30b345a157561f27ca4419e0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0107bd001ec4bc30b345a157561f27ca4419e0b"}], "stats": {"total": 135, "additions": 77, "deletions": 58}, "files": [{"sha": "ad35a11f7100505740a85d77ac351909949dfee3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26f3a4e144110002301c9eb884fcb05d26e9957f", "patch": "@@ -1,3 +1,26 @@\n+2014-09-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.h (copy_reference_ops_from_ref,\n+\tcopy_reference_ops_from_call, vn_nary_op_compute_hash,\n+\tvn_reference_compute_hash, vn_reference_insert): Remove.\n+\t(vn_reference_lookup_call): New function.\n+\t* tree-ssa-sccvn.c (vn_reference_compute_hash,\n+\tcopy_reference_ops_from_ref, copy_reference_ops_from_call,\n+\tvn_reference_insert, vn_nary_op_compute_hash): Make static.\n+\t(create_reference_ops_from_call): Remove.\n+\t(vn_reference_lookup_3): Properly update shared_lookup_references.\n+\t(vn_reference_lookup_pieces): Assert that we updated\n+\tshared_lookup_references properly.\n+\t(vn_reference_lookup): Likewise.\n+\t(vn_reference_lookup_call): New function.\n+\t(visit_reference_op_call): Use it.  Avoid re-building the\n+\treference ops.\n+\t(visit_reference_op_load): Remove redundant lookup.\n+\t(visit_reference_op_store): Perform special tail-merging work\n+\tonly when possibly doing tail-merging.\n+\t(visit_use): Likewise.\n+\t* tree-ssa-pre.c (compute_avail): Use vn_reference_lookup_call.\n+\n 2014-09-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/62025"}, {"sha": "7acf25f41194ceee589f39ab95465997455441ef", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=26f3a4e144110002301c9eb884fcb05d26e9957f", "patch": "@@ -3767,17 +3767,14 @@ compute_avail (void)\n \t    case GIMPLE_CALL:\n \t      {\n \t\tvn_reference_t ref;\n+\t\tvn_reference_s ref1;\n \t\tpre_expr result = NULL;\n-\t\tauto_vec<vn_reference_op_s> ops;\n \n \t\t/* We can value number only calls to real functions.  */\n \t\tif (gimple_call_internal_p (stmt))\n \t\t  continue;\n \n-\t\tcopy_reference_ops_from_call (stmt, &ops);\n-\t\tvn_reference_lookup_pieces (gimple_vuse (stmt), 0,\n-\t\t\t\t\t    gimple_expr_type (stmt),\n-\t\t\t\t\t    ops, &ref, VN_NOWALK);\n+\t\tvn_reference_lookup_call (stmt, &ref, &ref1);\n \t\tif (!ref)\n \t\t  continue;\n "}, {"sha": "1bcbde35f8a922a715c966bc975d9d9f5d24a78f", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=26f3a4e144110002301c9eb884fcb05d26e9957f", "patch": "@@ -608,7 +608,7 @@ vn_reference_op_compute_hash (const vn_reference_op_t vro1, inchash::hash &hstat\n \n /* Compute a hash for the reference operation VR1 and return it.  */\n \n-hashval_t\n+static hashval_t\n vn_reference_compute_hash (const vn_reference_t vr1)\n {\n   inchash::hash hstate;\n@@ -756,7 +756,7 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)\n /* Copy the operations present in load/store REF into RESULT, a vector of\n    vn_reference_op_s's.  */\n \n-void\n+static void\n copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n {\n   if (TREE_CODE (ref) == TARGET_MEM_REF)\n@@ -1118,7 +1118,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n /* Copy the operations present in load/store/call REF into RESULT, a vector of\n    vn_reference_op_s's.  */\n \n-void\n+static void\n copy_reference_ops_from_call (gimple call,\n \t\t\t      vec<vn_reference_op_s> *result)\n {\n@@ -1160,18 +1160,6 @@ copy_reference_ops_from_call (gimple call,\n     }\n }\n \n-/* Create a vector of vn_reference_op_s structures from CALL, a\n-   call statement.  The vector is not shared.  */\n-\n-static vec<vn_reference_op_s> \n-create_reference_ops_from_call (gimple call)\n-{\n-  vec<vn_reference_op_s> result = vNULL;\n-\n-  copy_reference_ops_from_call (call, &result);\n-  return result;\n-}\n-\n /* Fold *& at position *I_P in a vn_reference_op_s vector *OPS.  Updates\n    *I_P to point to the last element of the replacement.  */\n void\n@@ -1864,19 +1852,20 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n       /* Now re-write REF to be based on the rhs of the assignment.  */\n       copy_reference_ops_from_ref (gimple_assign_rhs1 (def_stmt), &rhs);\n       /* We need to pre-pend vr->operands[0..i] to rhs.  */\n+      vec<vn_reference_op_s> old = vr->operands;\n       if (i + 1 + rhs.length () > vr->operands.length ())\n \t{\n-\t  vec<vn_reference_op_s> old = vr->operands;\n \t  vr->operands.safe_grow (i + 1 + rhs.length ());\n-\t  if (old == shared_lookup_references\n-\t      && vr->operands != old)\n-\t    shared_lookup_references = vNULL;\n+\t  if (old == shared_lookup_references)\n+\t    shared_lookup_references = vr->operands;\n \t}\n       else\n \tvr->operands.truncate (i + 1 + rhs.length ());\n       FOR_EACH_VEC_ELT (rhs, j, vro)\n \tvr->operands[i + 1 + j] = *vro;\n       vr->operands = valueize_refs (vr->operands);\n+      if (old == shared_lookup_references)\n+\tshared_lookup_references = vr->operands;\n       vr->hashcode = vn_reference_compute_hash (vr);\n \n       /* Adjust *ref from the new operands.  */\n@@ -2001,7 +1990,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t  vr->operands.safe_grow_cleared (2);\n \t  if (old == shared_lookup_references\n \t      && vr->operands != old)\n-\t    shared_lookup_references.create (0);\n+\t    shared_lookup_references = vr->operands;\n \t}\n       else\n \tvr->operands.truncate (2);\n@@ -2084,8 +2073,7 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n \t  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n \t\t\t\t\t\t  vn_reference_lookup_2,\n \t\t\t\t\t\t  vn_reference_lookup_3, &vr1);\n-      if (vr1.operands != operands)\n-\tvr1.operands.release ();\n+      gcc_checking_assert (vr1.operands == shared_lookup_references);\n     }\n \n   if (*vnresult)\n@@ -2137,8 +2125,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n \t(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n \t\t\t\t\t\tvn_reference_lookup_2,\n \t\t\t\t\t\tvn_reference_lookup_3, &vr1);\n-      if (vr1.operands != operands)\n-\tvr1.operands.release ();\n+      gcc_checking_assert (vr1.operands == shared_lookup_references);\n       if (wvnresult)\n \t{\n \t  if (vnresult)\n@@ -2152,11 +2139,27 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n   return vn_reference_lookup_1 (&vr1, vnresult);\n }\n \n+/* Lookup CALL in the current hash table and return the entry in\n+   *VNRESULT if found.  Populates *VR for the hashtable lookup.  */\n+\n+void\n+vn_reference_lookup_call (gimple call, vn_reference_t *vnresult,\n+\t\t\t  vn_reference_t vr)\n+{\n+  tree vuse = gimple_vuse (call);\n+\n+  vr->vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n+  vr->operands = valueize_shared_reference_ops_from_call (call);\n+  vr->type = gimple_expr_type (call);\n+  vr->set = 0;\n+  vr->hashcode = vn_reference_compute_hash (vr);\n+  vn_reference_lookup_1 (vr, vnresult);\n+}\n \n /* Insert OP into the current hash table with a value number of\n    RESULT, and return the resulting reference structure we created.  */\n \n-vn_reference_t\n+static vn_reference_t\n vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n {\n   vn_reference_s **slot;\n@@ -2235,7 +2238,7 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n \n /* Compute and return the hash value for nary operation VBO1.  */\n \n-hashval_t\n+static hashval_t\n vn_nary_op_compute_hash (const vn_nary_op_t vno1)\n {\n   inchash::hash hstate;\n@@ -2845,20 +2848,13 @@ visit_reference_op_call (tree lhs, gimple stmt)\n   bool changed = false;\n   struct vn_reference_s vr1;\n   vn_reference_t vnresult = NULL;\n-  tree vuse = gimple_vuse (stmt);\n   tree vdef = gimple_vdef (stmt);\n \n   /* Non-ssa lhs is handled in copy_reference_ops_from_call.  */\n   if (lhs && TREE_CODE (lhs) != SSA_NAME)\n     lhs = NULL_TREE;\n \n-  vr1.vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n-  vr1.operands = valueize_shared_reference_ops_from_call (stmt);\n-  vr1.type = gimple_expr_type (stmt);\n-  vr1.set = 0;\n-  vr1.hashcode = vn_reference_compute_hash (&vr1);\n-  vn_reference_lookup_1 (&vr1, &vnresult);\n-\n+  vn_reference_lookup_call (stmt, &vnresult, &vr1);\n   if (vnresult)\n     {\n       if (vnresult->result_vdef && vdef)\n@@ -2877,24 +2873,26 @@ visit_reference_op_call (tree lhs, gimple stmt)\n     }\n   else\n     {\n-      vn_reference_s **slot;\n       vn_reference_t vr2;\n+      vn_reference_s **slot;\n       if (vdef)\n \tchanged |= set_ssa_val_to (vdef, vdef);\n       if (lhs)\n \tchanged |= set_ssa_val_to (lhs, lhs);\n       vr2 = (vn_reference_t) pool_alloc (current_info->references_pool);\n       vr2->vuse = vr1.vuse;\n-      vr2->operands = valueize_refs (create_reference_ops_from_call (stmt));\n+      /* As we are not walking the virtual operand chain we know the\n+\t shared_lookup_references are still original so we can re-use\n+\t them here.  */\n+      vr2->operands = vr1.operands.copy ();\n       vr2->type = vr1.type;\n       vr2->set = vr1.set;\n       vr2->hashcode = vr1.hashcode;\n       vr2->result = lhs;\n       vr2->result_vdef = vdef;\n       slot = current_info->references->find_slot_with_hash (vr2, vr2->hashcode,\n \t\t\t\t\t\t\t    INSERT);\n-      if (*slot)\n-\tfree_reference (*slot);\n+      gcc_assert (!*slot);\n       *slot = vr2;\n     }\n \n@@ -2917,12 +2915,6 @@ visit_reference_op_load (tree lhs, tree op, gimple stmt)\n \t\t\t\tdefault_vn_walk_kind, NULL);\n   last_vuse_ptr = NULL;\n \n-  /* If we have a VCE, try looking up its operand as it might be stored in\n-     a different type.  */\n-  if (!result && TREE_CODE (op) == VIEW_CONVERT_EXPR)\n-    result = vn_reference_lookup (TREE_OPERAND (op, 0), gimple_vuse (stmt),\n-    \t\t\t\t  default_vn_walk_kind, NULL);\n-\n   /* We handle type-punning through unions by value-numbering based\n      on offset and size of the access.  Be prepared to handle a\n      type-mismatch here via creating a VIEW_CONVERT_EXPR.  */\n@@ -3047,7 +3039,10 @@ visit_reference_op_store (tree lhs, tree op, gimple stmt)\n       resultsame = expressions_equal_p (result, op);\n     }\n \n-  if (!result || !resultsame)\n+  if ((!result || !resultsame)\n+      /* Only perform the following when being called from PRE\n+\t which embeds tail merging.  */\n+      && default_vn_walk_kind == VN_WALK)\n     {\n       assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);\n       vn_reference_lookup (assign, vuse, VN_NOWALK, &vnresult);\n@@ -3081,8 +3076,13 @@ visit_reference_op_store (tree lhs, tree op, gimple stmt)\n \t  || is_gimple_reg (op))\n         vn_reference_insert (lhs, op, vdef, NULL);\n \n-      assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);\n-      vn_reference_insert (assign, lhs, vuse, vdef);\n+      /* Only perform the following when being called from PRE\n+\t which embeds tail merging.  */\n+      if (default_vn_walk_kind == VN_WALK)\n+\t{\n+\t  assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);\n+\t  vn_reference_insert (assign, lhs, vuse, vdef);\n+\t}\n     }\n   else\n     {\n@@ -3663,7 +3663,10 @@ visit_use (tree use)\n \t\t         not alias with anything else.  In which case the\n \t\t\t information that the values are distinct are encoded\n \t\t\t in the IL.  */\n-\t\t      && !(gimple_call_return_flags (stmt) & ERF_NOALIAS))))\n+\t\t      && !(gimple_call_return_flags (stmt) & ERF_NOALIAS)\n+\t\t      /* Only perform the following when being called from PRE\n+\t\t\t which embeds tail merging.  */\n+\t\t      && default_vn_walk_kind == VN_WALK)))\n \t    changed = visit_reference_op_call (lhs, stmt);\n \t  else\n \t    changed = defs_to_varying (stmt);"}, {"sha": "ad996043faa2466d863d8ab17f72450d3e832f95", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f3a4e144110002301c9eb884fcb05d26e9957f/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=26f3a4e144110002301c9eb884fcb05d26e9957f", "patch": "@@ -204,24 +204,20 @@ vn_nary_op_t vn_nary_op_insert_pieces (unsigned int, enum tree_code,\n \t\t\t\t       tree, tree *, tree, unsigned int);\n void vn_reference_fold_indirect (vec<vn_reference_op_s> *,\n \t\t\t\t unsigned int *);\n-void copy_reference_ops_from_ref (tree, vec<vn_reference_op_s> *);\n-void copy_reference_ops_from_call (gimple, vec<vn_reference_op_s> *);\n bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,\n \t\t\t\t    vec<vn_reference_op_s> );\n tree vn_reference_lookup_pieces (tree, alias_set_type, tree,\n \t\t\t\t vec<vn_reference_op_s> ,\n \t\t\t\t vn_reference_t *, vn_lookup_kind);\n tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *);\n-vn_reference_t vn_reference_insert (tree, tree, tree, tree);\n+void vn_reference_lookup_call (gimple, vn_reference_t *, vn_reference_t);\n vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,\n \t\t\t\t\t   vec<vn_reference_op_s> ,\n \t\t\t\t\t   tree, unsigned int);\n \n-hashval_t vn_nary_op_compute_hash (const vn_nary_op_t);\n bool vn_nary_op_eq (const_vn_nary_op_t const vno1,\n \t\t    const_vn_nary_op_t const vno2);\n bool vn_nary_may_trap (vn_nary_op_t);\n-hashval_t vn_reference_compute_hash (const vn_reference_t);\n bool vn_reference_eq (const_vn_reference_t const, const_vn_reference_t const);\n unsigned int get_max_value_id (void);\n unsigned int get_next_value_id (void);"}]}