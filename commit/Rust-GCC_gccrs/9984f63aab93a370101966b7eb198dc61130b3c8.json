{"sha": "9984f63aab93a370101966b7eb198dc61130b3c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk4NGY2M2FhYjkzYTM3MDEwMTk2NmI3ZWIxOThkYzYxMTMwYjNjOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-02T19:59:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-02T19:59:21Z"}, "message": "openmp: Initial support for OpenMP directives expressed as C++11 attributes\n\nThis is an OpenMP 5.1 feature, but I think it is something very useful for\nOpenMP users, so I'm committing it now instead of waiting until all 5.0\nwork is done.\n\nThe support is incomplete, only attributes on statements (or block local\ndeclarations) are supported right now, while for non-executable directives\nthey should be also supported at namespace scope and at class scope, and\nfor declarations in all places that appertain to the declarations rather\nthan e.g. types.\n\nI need to also fix up handling of C++11 non-OpenMP attributes mixed with\nOpenMP attributes before block local declarations (currently it throws\nthem away), probably reject if the directives appertain to labels etc.\n\nIn order not to complicate all the OpenMP directive parsing, it is done\nby remembering the tokens from the attribute, slightly adjusting them and\nfeeding them through a temporary new lexer to cp_parse_pragma.\n\n2021-07-02  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/c-family/\n\t* c-common.h (enum c_omp_directive_kind): New enum.\n\t(struct c_omp_directive): New type.\n\t(c_omp_categorize_directive): Declare.\n\t* c-omp.c (omp_directives): New variable.\n\t(c_omp_categorize_directive): New function.\ngcc/cp/\n\t* parser.h (struct cp_lexer): Add in_omp_attribute_pragma member.\n\t(struct cp_omp_declare_simd_data): Likewise.\n\t* cp-tree.h (enum cp_tree_index): Add CPTI_OMP_IDENTIFIER.\n\t(omp_identifier): Define.\n\t* parser.c (cp_parser_skip_to_pragma_eol): Handle\n\tin_omp_attribute_pragma CPP_PRAGMA_EOL followed by CPP_EOF.\n\t(cp_parser_require_pragma_eol): Likewise.\n\t(struct cp_omp_attribute_data): New type.\n\t(cp_parser_handle_statement_omp_attributes): New function.\n\t(cp_parser_statement): Handle OpenMP directives in statement's\n\tattribute-specifier-seq.\n\t(cp_parser_omp_directive_args, cp_parser_omp_sequence_args): New\n\tfunctions.\n\t(cp_parser_std_attribute): Handle omp::directive and omp::sequence\n\tattributes.\n\t(cp_parser_omp_all_clauses): If in_omp_attribute_pragma, allow\n\ta comma also before the first clause.\n\t(cp_parser_omp_allocate): Likewise.\n\t(cp_parser_omp_atomic): Likewise.\n\t(cp_parser_omp_depobj): Likewise.\n\t(cp_parser_omp_flush): Likewise.\n\t(cp_parser_omp_ordered): Likewise.\n\t(cp_parser_omp_declare_simd): Save in_omp_attribute_pragma\n\tinto struct cp_omp_declare_simd_data.\n\t(cp_finish_omp_declare_variant): Add in_omp_attribute_pragma\n\targument.  If set, allow a comma also before match clause.\n\t(cp_parser_late_parsing_omp_declare_simd): If in_omp_attribute_pragma,\n\tallow a comma also before the first clause.  Adjust\n\tcp_finish_omp_declare_variant caller.\n\t(cp_parser_omp_declare_target): If in_omp_attribute_pragma, allow\n\ta comma also before the first clause.\n\t(cp_parser_omp_declare_reduction_exprs): Likewise.\n\t(cp_parser_omp_requires): Likewise.\n\t* decl.c (initialize_predefined_identifiers): Initialize\n\tomp_identifier.\n\t* decl2.c (cplus_decl_attributes): Reject omp::directive and\n\tomp::sequence attributes.\ngcc/testsuite/\n\t* g++.dg/gomp/attrs-1.C: New test.\n\t* g++.dg/gomp/attrs-2.C: New test.\n\t* g++.dg/gomp/attrs-3.C: New test.", "tree": {"sha": "88a41229e3f99fe790101d1400024e8e30d90909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88a41229e3f99fe790101d1400024e8e30d90909"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9984f63aab93a370101966b7eb198dc61130b3c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9984f63aab93a370101966b7eb198dc61130b3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9984f63aab93a370101966b7eb198dc61130b3c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9984f63aab93a370101966b7eb198dc61130b3c8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ca89394280da4afad6074ec3cb7136b6142af7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca89394280da4afad6074ec3cb7136b6142af7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca89394280da4afad6074ec3cb7136b6142af7b"}], "stats": {"total": 1749, "additions": 1739, "deletions": 10}, "files": [{"sha": "50ca8fb6ebd8e2a43e2a95967d067bfdfcd5f34a", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -1246,6 +1246,25 @@ extern void c_omp_mark_declare_variant (location_t, tree, tree);\n extern const char *c_omp_map_clause_name (tree, bool);\n extern void c_omp_adjust_map_clauses (tree, bool);\n \n+enum c_omp_directive_kind {\n+  C_OMP_DIR_STANDALONE,\n+  C_OMP_DIR_CONSTRUCT,\n+  C_OMP_DIR_DECLARATIVE,\n+  C_OMP_DIR_UTILITY,\n+  C_OMP_DIR_INFORMATIONAL\n+};\n+\n+struct c_omp_directive {\n+  const char *first, *second, *third;\n+  unsigned int id;\n+  enum c_omp_directive_kind kind;\n+  bool simd;\n+};\n+\n+extern const struct c_omp_directive *c_omp_categorize_directive (const char *,\n+\t\t\t\t\t\t\t\t const char *,\n+\t\t\t\t\t\t\t\t const char *);\n+\n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n static inline tree\n c_tree_chain_next (tree t)"}, {"sha": "e70974d4a22c91828e031b4649ff29c6eb17ed88", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -2912,3 +2912,154 @@ c_omp_adjust_map_clauses (tree clauses, bool is_target)\n \t}\n     }\n }\n+\n+static const struct c_omp_directive omp_directives[] = {\n+  /* Keep this alphabetically sorted by the first word.  Non-null second/third\n+     if any should precede null ones.  */\n+  { \"allocate\", nullptr, nullptr, PRAGMA_OMP_ALLOCATE,\n+    C_OMP_DIR_DECLARATIVE, false },\n+  /* { \"assume\", nullptr, nullptr, PRAGMA_OMP_ASSUME,\n+    C_OMP_DIR_INFORMATIONAL, false }, */\n+  /* { \"assumes\", nullptr, nullptr, PRAGMA_OMP_ASSUMES,\n+    C_OMP_DIR_INFORMATIONAL, false }, */\n+  { \"atomic\", nullptr, nullptr, PRAGMA_OMP_ATOMIC,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  { \"barrier\", nullptr, nullptr, PRAGMA_OMP_BARRIER,\n+    C_OMP_DIR_STANDALONE, false },\n+  /* { \"begin\", \"assumes\", nullptr, PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_INFORMATIONAL, false }, */\n+  /* { \"begin\", \"declare\", \"target\", PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_DECLARATIVE, false }, */\n+  /* { \"begin\", \"declare\", \"variant\", PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_DECLARATIVE, false }, */\n+  /* { \"begin\", \"metadirective\", nullptr, PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_???, ??? },  */\n+  { \"cancel\", nullptr, nullptr, PRAGMA_OMP_CANCEL,\n+    C_OMP_DIR_STANDALONE, false },\n+  { \"cancellation\", \"point\", nullptr, PRAGMA_OMP_CANCELLATION_POINT,\n+    C_OMP_DIR_STANDALONE, false },\n+  { \"critical\", nullptr, nullptr, PRAGMA_OMP_CRITICAL,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  /* { \"declare\", \"mapper\", nullptr, PRAGMA_OMP_DECLARE,\n+    C_OMP_DIR_DECLARATIVE, false },  */\n+  { \"declare\", \"reduction\", nullptr, PRAGMA_OMP_DECLARE,\n+    C_OMP_DIR_DECLARATIVE, true },\n+  { \"declare\", \"simd\", nullptr, PRAGMA_OMP_DECLARE,\n+    C_OMP_DIR_DECLARATIVE, true },\n+  { \"declare\", \"target\", nullptr, PRAGMA_OMP_DECLARE,\n+    C_OMP_DIR_DECLARATIVE, false },\n+  { \"declare\", \"variant\", nullptr, PRAGMA_OMP_DECLARE,\n+    C_OMP_DIR_DECLARATIVE, false },\n+  { \"depobj\", nullptr, nullptr, PRAGMA_OMP_DEPOBJ,\n+    C_OMP_DIR_STANDALONE, false },\n+  /* { \"dispatch\", nullptr, nullptr, PRAGMA_OMP_DISPATCH,\n+    C_OMP_DIR_CONSTRUCT, false },  */\n+  { \"distribute\", nullptr, nullptr, PRAGMA_OMP_DISTRIBUTE,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  /* { \"end\", \"assumes\", nullptr, PRAGMA_OMP_END,\n+    C_OMP_DIR_INFORMATIONAL, false }, */\n+  { \"end\", \"declare\", \"target\", PRAGMA_OMP_END_DECLARE_TARGET,\n+    C_OMP_DIR_DECLARATIVE, false },\n+  /* { \"end\", \"declare\", \"variant\", PRAGMA_OMP_END,\n+    C_OMP_DIR_DECLARATIVE, false }, */\n+  /* { \"end\", \"metadirective\", nullptr, PRAGMA_OMP_END,\n+    C_OMP_DIR_???, ??? },  */\n+  /* error with at(execution) is C_OMP_DIR_STANDALONE.  */\n+  /* { \"error\", nullptr, nullptr, PRAGMA_OMP_ERROR,\n+    C_OMP_DIR_UTILITY, false },  */\n+  { \"flush\", nullptr, nullptr, PRAGMA_OMP_FLUSH,\n+    C_OMP_DIR_STANDALONE, false },\n+  { \"for\", nullptr, nullptr, PRAGMA_OMP_FOR,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  /* { \"interop\", nullptr, nullptr, PRAGMA_OMP_INTEROP,\n+    C_OMP_DIR_STANDALONE, false },  */\n+  { \"loop\", nullptr, nullptr, PRAGMA_OMP_LOOP,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  /* { \"masked\", nullptr, nullptr, PRAGMA_OMP_MASKED,\n+    C_OMP_DIR_CONSTRUCT, true },  */\n+  { \"master\", nullptr, nullptr, PRAGMA_OMP_MASTER,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  /* { \"metadirective\", nullptr, nullptr, PRAGMA_OMP_METADIRECTIVE,\n+    C_OMP_DIR_???, ??? },  */\n+  /* { \"nothing\", nullptr, nullptr, PRAGMA_OMP_NOTHING,\n+    C_OMP_DIR_UTILITY, false },  */\n+  /* ordered with depend clause is C_OMP_DIR_STANDALONE.  */\n+  { \"ordered\", nullptr, nullptr, PRAGMA_OMP_ORDERED,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  { \"parallel\", nullptr, nullptr, PRAGMA_OMP_PARALLEL,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  { \"requires\", nullptr, nullptr, PRAGMA_OMP_REQUIRES,\n+    C_OMP_DIR_INFORMATIONAL, false },\n+  { \"scan\", nullptr, nullptr, PRAGMA_OMP_SCAN,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  /* { \"scope\", nullptr, nullptr, PRAGMA_OMP_SCOPE,\n+    C_OMP_DIR_CONSTRUCT, false },  */\n+  { \"section\", nullptr, nullptr, PRAGMA_OMP_SECTION,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  { \"sections\", nullptr, nullptr, PRAGMA_OMP_SECTIONS,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  { \"simd\", nullptr, nullptr, PRAGMA_OMP_SIMD,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  { \"single\", nullptr, nullptr, PRAGMA_OMP_SINGLE,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  { \"target\", \"data\", nullptr, PRAGMA_OMP_TARGET,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  { \"target\", \"enter\", \"data\", PRAGMA_OMP_TARGET,\n+    C_OMP_DIR_STANDALONE, false },\n+  { \"target\", \"exit\", \"data\", PRAGMA_OMP_TARGET,\n+    C_OMP_DIR_STANDALONE, false },\n+  { \"target\", \"update\", nullptr, PRAGMA_OMP_TARGET,\n+    C_OMP_DIR_STANDALONE, false },\n+  { \"target\", nullptr, nullptr, PRAGMA_OMP_TARGET,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  { \"task\", nullptr, nullptr, PRAGMA_OMP_TASK,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  { \"taskgroup\", nullptr, nullptr, PRAGMA_OMP_TASKGROUP,\n+    C_OMP_DIR_CONSTRUCT, false },\n+  { \"taskloop\", nullptr, nullptr, PRAGMA_OMP_TASKLOOP,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  { \"taskwait\", nullptr, nullptr, PRAGMA_OMP_TASKWAIT,\n+    C_OMP_DIR_STANDALONE, false },\n+  { \"taskyield\", nullptr, nullptr, PRAGMA_OMP_TASKYIELD,\n+    C_OMP_DIR_STANDALONE, false },\n+  /* { \"tile\", nullptr, nullptr, PRAGMA_OMP_TILE,\n+    C_OMP_DIR_CONSTRUCT, false },  */\n+  { \"teams\", nullptr, nullptr, PRAGMA_OMP_TEAMS,\n+    C_OMP_DIR_CONSTRUCT, true },\n+  { \"threadprivate\", nullptr, nullptr, PRAGMA_OMP_THREADPRIVATE,\n+    C_OMP_DIR_DECLARATIVE, false }\n+  /* { \"unroll\", nullptr, nullptr, PRAGMA_OMP_UNROLL,\n+    C_OMP_DIR_CONSTRUCT, false },  */\n+};\n+\n+/* Find (non-combined/composite) OpenMP directive (if any) which starts\n+   with FIRST keyword and for multi-word directives has SECOND and\n+   THIRD keyword after it.  */\n+\n+const struct c_omp_directive *\n+c_omp_categorize_directive (const char *first, const char *second,\n+\t\t\t    const char *third)\n+{\n+  const size_t n_omp_directives = ARRAY_SIZE (omp_directives);\n+  for (size_t i = 0; i < n_omp_directives; i++)\n+    {\n+      if ((unsigned char) omp_directives[i].first[0]\n+\t  < (unsigned char) first[0])\n+\tcontinue;\n+      if ((unsigned char) omp_directives[i].first[0]\n+\t  > (unsigned char) first[0])\n+\tbreak;\n+      if (strcmp (omp_directives[i].first, first))\n+\tcontinue;\n+      if (!omp_directives[i].second)\n+\treturn &omp_directives[i];\n+      if (!second || strcmp (omp_directives[i].second, second))\n+\tcontinue;\n+      if (!omp_directives[i].third)\n+\treturn &omp_directives[i];\n+      if (!third || strcmp (omp_directives[i].third, third))\n+\tcontinue;\n+      return &omp_directives[i];\n+    }\n+  return NULL;\n+}"}, {"sha": "b4501576b26c290fca948d937abaf94819263c62", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -176,6 +176,7 @@ enum cp_tree_index\n     CPTI_HEAP_DELETED_IDENTIFIER,\n     CPTI_HEAP_VEC_UNINIT_IDENTIFIER,\n     CPTI_HEAP_VEC_IDENTIFIER,\n+    CPTI_OMP_IDENTIFIER,\n \n     CPTI_LANG_NAME_C,\n     CPTI_LANG_NAME_CPLUSPLUS,\n@@ -337,6 +338,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define heap_deleted_identifier\t\tcp_global_trees[CPTI_HEAP_DELETED_IDENTIFIER]\n #define heap_vec_uninit_identifier\tcp_global_trees[CPTI_HEAP_VEC_UNINIT_IDENTIFIER]\n #define heap_vec_identifier\t\tcp_global_trees[CPTI_HEAP_VEC_IDENTIFIER]\n+#define omp_identifier\t\t\tcp_global_trees[CPTI_OMP_IDENTIFIER]\n #define lang_name_c\t\t\tcp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus\t\tcp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n "}, {"sha": "ebe1318d38d5ef2046e877da0faecffdfb84516b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -4387,6 +4387,7 @@ initialize_predefined_identifiers (void)\n     {\"heap deleted\", &heap_deleted_identifier, cik_normal},\n     {\"heap [] uninit\", &heap_vec_uninit_identifier, cik_normal},\n     {\"heap []\", &heap_vec_identifier, cik_normal},\n+    {\"omp\", &omp_identifier, cik_normal},\n     {NULL, NULL, cik_normal}\n   };\n "}, {"sha": "9564b0d619fcbca74fec2f390bd57d7ec7e77bda", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -1584,6 +1584,31 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n \n   cp_check_const_attributes (attributes);\n \n+  if ((flag_openmp || flag_openmp_simd) && attributes != error_mark_node)\n+    {\n+      bool diagnosed = false;\n+      for (tree *pa = &attributes; *pa; )\n+\t{\n+\t  if (get_attribute_namespace (*pa) == omp_identifier)\n+\t    {\n+\t      tree name = get_attribute_name (*pa);\n+\t      if (is_attribute_p (\"directive\", name)\n+\t\t  || is_attribute_p (\"sequence\", name))\n+\t\t{\n+\t\t  if (!diagnosed)\n+\t\t    {\n+\t\t      error (\"%<omp::%E%> not allowed to be specified in this \"\n+\t\t\t     \"context\", name);\n+\t\t      diagnosed = true;\n+\t\t    }\n+\t\t  *pa = TREE_CHAIN (*pa);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  pa = &TREE_CHAIN (*pa);\n+\t}\n+    }\n+\n   if (TREE_CODE (*decl) == TEMPLATE_DECL)\n     decl = &DECL_TEMPLATE_RESULT (*decl);\n "}, {"sha": "93698aa14c9e40e04c2cf59a630924625e79a6da", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 389, "deletions": 10, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -1,4 +1,3 @@\n-\n /* -*- C++ -*- Parser.\n    Copyright (C) 2000-2021 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>.\n@@ -4061,6 +4060,14 @@ cp_parser_skip_to_pragma_eol (cp_parser* parser, cp_token *pragma_tok)\n       /* Ensure that the pragma is not parsed again.  */\n       cp_lexer_purge_tokens_after (parser->lexer, pragma_tok);\n       parser->lexer->in_pragma = false;\n+      if (parser->lexer->in_omp_attribute_pragma\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+\t{\n+\t  parser->lexer = parser->lexer->next;\n+\t  /* Put the current source position back where it was before this\n+\t     lexer was pushed.  */\n+\t  cp_lexer_set_source_position_from_token (parser->lexer->next_token);\n+\t}\n     }\n }\n \n@@ -4073,6 +4080,14 @@ cp_parser_require_pragma_eol (cp_parser *parser, cp_token *pragma_tok)\n   parser->lexer->in_pragma = false;\n   if (!cp_parser_require (parser, CPP_PRAGMA_EOL, RT_PRAGMA_EOL))\n     cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  else if (parser->lexer->in_omp_attribute_pragma\n+\t   && cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+    {\n+      parser->lexer = parser->lexer->next;\n+      /* Put the current source position back where it was before this\n+\t lexer was pushed.  */\n+      cp_lexer_set_source_position_from_token (parser->lexer->next_token);\n+    }\n }\n \n /* This is a simple wrapper around make_typename_type. When the id is\n@@ -11631,6 +11646,187 @@ add_debug_begin_stmt (location_t loc)\n   add_stmt (stmt);\n }\n \n+struct cp_omp_attribute_data\n+{\n+  cp_token_cache *tokens;\n+  const c_omp_directive *dir;\n+  c_omp_directive_kind kind;\n+};\n+\n+/* Handle omp::directive and omp::sequence attributes in ATTRS\n+   (if any) at the start of a statement.  */\n+\n+static tree\n+cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n+{\n+  if (!flag_openmp && !flag_openmp_simd)\n+    return attrs;\n+\n+  auto_vec<cp_omp_attribute_data, 16> vec;\n+  int cnt = 0;\n+  int tokens = 0;\n+  for (tree *pa = &attrs; *pa; )\n+    if (get_attribute_namespace (*pa) == omp_identifier\n+\t&& is_attribute_p (\"directive\", get_attribute_name (*pa)))\n+      {\n+\tcnt++;\n+\tfor (tree a = TREE_VALUE (*pa); a; a = TREE_CHAIN (a))\n+\t  {\n+\t    tree d = TREE_VALUE (a);\n+\t    gcc_assert (TREE_CODE (d) == DEFERRED_PARSE);\n+\t    cp_token *first = DEFPARSE_TOKENS (d)->first;\n+\t    cp_token *last = DEFPARSE_TOKENS (d)->last;\n+\t    const char *directive[3] = {};\n+\t    for (int i = 0; i < 3; i++)\n+\t      {\n+\t\ttree id = NULL_TREE;\n+\t\tif (first + i == last)\n+\t\t  break;\n+\t\tif (first[i].type == CPP_NAME)\n+\t\t  id = first[i].u.value;\n+\t\telse if (first[i].type == CPP_KEYWORD)\n+\t\t  id = ridpointers[(int) first[i].keyword];\n+\t\telse\n+\t\t  break;\n+\t\tdirective[i] = IDENTIFIER_POINTER (id);\n+\t      }\n+\t    const c_omp_directive *dir = NULL;\n+\t    if (directive[0])\n+\t      dir = c_omp_categorize_directive (directive[0], directive[1],\n+\t\t\t\t\t\tdirective[2]);\n+\t    if (dir == NULL)\n+\t      {\n+\t\terror_at (first->location,\n+\t\t\t  \"unknown OpenMP directive name in %<omp::directive%>\"\n+\t\t\t  \" attribute argument\");\n+\t\tcontinue;\n+\t      }\n+\t    c_omp_directive_kind kind = dir->kind;\n+\t    if (dir->id == PRAGMA_OMP_ORDERED)\n+\t      {\n+\t\t/* ordered is C_OMP_DIR_CONSTRUCT only if it doesn't contain\n+\t\t   depend clause.  */\n+\t\tif (directive[1] && strcmp (directive[1], \"depend\") == 0)\n+\t\t  kind = C_OMP_DIR_STANDALONE;\n+\t\telse if (first + 2 < last\n+\t\t\t && first[1].type == CPP_COMMA\n+\t\t\t && first[2].type == CPP_NAME\n+\t\t\t && strcmp (IDENTIFIER_POINTER (first[2].u.value),\n+\t\t\t\t    \"depend\") == 0)\n+\t\t  kind = C_OMP_DIR_STANDALONE;\n+\t      }\n+\t    /* else if (dir->id == PRAGMA_OMP_ERROR)\n+\t      {\n+\t\terror with at(execution) clause is C_OMP_DIR_STANDALONE.\n+\t      }  */\n+\t    cp_omp_attribute_data v = { DEFPARSE_TOKENS (d), dir, kind };\n+\t    vec.safe_push (v);\n+\t    if (flag_openmp || dir->simd)\n+\t      tokens += (last - first) + 1;\n+\t  }\n+\tcp_omp_attribute_data v = {};\n+\tvec.safe_push (v);\n+\t*pa = TREE_CHAIN (*pa);\n+      }\n+    else\n+      pa = &TREE_CHAIN (*pa);\n+\n+  unsigned int i;\n+  cp_omp_attribute_data *v;\n+  cp_omp_attribute_data *construct_seen = nullptr;\n+  cp_omp_attribute_data *standalone_seen = nullptr;\n+  cp_omp_attribute_data *prev_standalone_seen = nullptr;\n+  FOR_EACH_VEC_ELT (vec, i, v)\n+    if (v->tokens)\n+      {\n+\tif (v->kind == C_OMP_DIR_CONSTRUCT && !construct_seen)\n+\t  construct_seen = v;\n+\telse if (v->kind == C_OMP_DIR_STANDALONE && !standalone_seen)\n+\t  standalone_seen = v;\n+      }\n+    else\n+      {\n+\tif (standalone_seen && !prev_standalone_seen)\n+\t  {\n+\t    prev_standalone_seen = standalone_seen;\n+\t    standalone_seen = nullptr;\n+\t  }\n+      }\n+\n+  if (cnt > 1 && construct_seen)\n+    {\n+      error_at (construct_seen->tokens->first->location,\n+\t\t\"OpenMP construct among %<omp::directive%> attributes\"\n+\t\t\" requires all %<omp::directive%> attributes on the\"\n+\t\t\" same statement to be in the same %<omp::sequence%>\");\n+      return attrs;\n+    }\n+  if (cnt > 1 && standalone_seen && prev_standalone_seen)\n+    {\n+      error_at (standalone_seen->tokens->first->location,\n+\t\t\"multiple OpenMP standalone directives among\"\n+\t\t\" %<omp::directive%> attributes must be all within the\"\n+\t\t\" same %<omp::sequence%>\");\n+      return attrs;\n+    }\n+\n+  if (prev_standalone_seen)\n+    standalone_seen = prev_standalone_seen;\n+  if (standalone_seen\n+      && !cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+    {\n+      error_at (standalone_seen->tokens->first->location,\n+\t\t\"standalone OpenMP directives in %<omp::directive%> attribute\"\n+\t\t\" can only appear on an empty statement\");\n+      return attrs;\n+    }\n+\n+  if (!tokens)\n+    return attrs;\n+  tokens++;\n+  cp_lexer *lexer = cp_lexer_alloc ();\n+  lexer->debugging_p = parser->lexer->debugging_p;\n+  vec_safe_reserve (lexer->buffer, tokens, true);\n+  FOR_EACH_VEC_ELT (vec, i, v)\n+    {\n+      if (!v->tokens)\n+\tcontinue;\n+      if (!flag_openmp && !v->dir->simd)\n+\tcontinue;\n+      cp_token *first = v->tokens->first;\n+      cp_token *last = v->tokens->last;\n+      cp_token tok = {};\n+      tok.type = CPP_PRAGMA;\n+      tok.keyword = RID_MAX;\n+      tok.u.value = build_int_cst (NULL, v->dir->id);\n+      tok.location = first->location;\n+      lexer->buffer->quick_push (tok);\n+      while (++first < last)\n+\tlexer->buffer->quick_push (*first);\n+      tok = {};\n+      tok.type = CPP_PRAGMA_EOL;\n+      tok.keyword = RID_MAX;\n+      tok.location = last->location;\n+      lexer->buffer->quick_push (tok);\n+    }\n+  cp_token tok = {};\n+  tok.type = CPP_EOF;\n+  tok.keyword = RID_MAX;\n+  tok.location = lexer->buffer->last ().location;\n+  lexer->buffer->quick_push (tok);\n+  lexer->next = parser->lexer;\n+  lexer->next_token = lexer->buffer->address ();\n+  lexer->last_token = lexer->next_token\n+\t\t      + lexer->buffer->length ()\n+\t\t      - 1;\n+  lexer->in_omp_attribute_pragma = true;\n+  parser->lexer = lexer;\n+  /* Move the current source position to that of the first token in the\n+     new lexer.  */\n+  cp_lexer_set_source_position_from_token (lexer->next_token);\n+  return attrs;\n+}\n+\n /* Parse a statement.\n \n    statement:\n@@ -11681,8 +11877,10 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n   tree statement, std_attrs = NULL_TREE;\n   cp_token *token;\n   location_t statement_location, attrs_loc;\n+  bool in_omp_attribute_pragma;\n \n  restart:\n+  in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n   if (if_p != NULL)\n     *if_p = false;\n   /* There is no statement yet.  */\n@@ -11704,6 +11902,9 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \tstd_attrs = NULL_TREE;\n     }\n \n+  if (std_attrs && (flag_openmp || flag_openmp_simd))\n+    std_attrs = cp_parser_handle_statement_omp_attributes (parser, std_attrs);\n+\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Remember the location of the first token in the statement.  */\n@@ -11821,6 +12022,8 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n      a statement all its own.  */\n   else if (token->type == CPP_PRAGMA)\n     {\n+      cp_lexer *lexer = parser->lexer;\n+      bool do_restart = false;\n       /* Only certain OpenMP pragmas are attached to statements, and thus\n \t are considered statements themselves.  All others are not.  In\n \t the context of a compound, accept the pragma as a \"statement\" and\n@@ -11829,6 +12032,13 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n       if (in_compound)\n \tcp_parser_pragma (parser, pragma_compound, if_p);\n       else if (!cp_parser_pragma (parser, pragma_stmt, if_p))\n+\tdo_restart = true;\n+      if (lexer->in_omp_attribute_pragma && !in_omp_attribute_pragma)\n+\t{\n+\t  gcc_assert (parser->lexer != lexer);\n+\t  cp_lexer_destroy (lexer);\n+\t}\n+      if (do_restart)\n \tgoto restart;\n       return;\n     }\n@@ -27935,6 +28145,92 @@ cp_parser_gnu_attribute_list (cp_parser* parser, bool exactly_one /* = false */)\n   return nreverse (attribute_list);\n }\n \n+/* Parse arguments of omp::directive attribute.\n+\n+   ( directive-name ,[opt] clause-list[opt] )\n+\n+   For directive just remember the first/last tokens for subsequent\n+   parsing.  */\n+\n+static void\n+cp_parser_omp_directive_args (cp_parser *parser, tree attribute)\n+{\n+  cp_token *first = cp_lexer_peek_nth_token (parser->lexer, 2);\n+  if (first->type == CPP_CLOSE_PAREN)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      error_at (first->location, \"expected OpenMP directive name\");\n+      cp_lexer_consume_token (parser->lexer);\n+      TREE_VALUE (attribute) = NULL_TREE;\n+      return;\n+    }\n+  for (size_t n = cp_parser_skip_balanced_tokens (parser, 1) - 2; n; --n)\n+    cp_lexer_consume_token (parser->lexer);\n+  cp_token *last = cp_lexer_peek_token (parser->lexer);\n+  cp_lexer_consume_token (parser->lexer);\n+  tree arg = make_node (DEFERRED_PARSE);\n+  DEFPARSE_TOKENS (arg) = cp_token_cache_new (first, last);\n+  DEFPARSE_INSTANTIATIONS (arg) = nullptr;\n+  TREE_VALUE (attribute) = tree_cons (NULL_TREE, arg, TREE_VALUE (attribute));\n+}\n+\n+/* Parse arguments of omp::sequence attribute.\n+\n+   ( omp::[opt] directive-attr [ , omp::[opt] directive-attr ]... )  */\n+\n+static void\n+cp_parser_omp_sequence_args (cp_parser *parser, tree attribute)\n+{\n+  matching_parens parens;\n+  parens.consume_open (parser);\n+  do\n+    {\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_NAME\n+\t  && token->u.value == omp_identifier\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_SCOPE))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t}\n+      bool directive = false;\n+      const char *p;\n+      if (token->type != CPP_NAME)\n+\tp = \"\";\n+      else\n+\tp = IDENTIFIER_POINTER (token->u.value);\n+      if (strcmp (p, \"directive\") == 0)\n+\tdirective = true;\n+      else if (strcmp (p, \"sequence\") != 0)\n+\t{\n+\t  error_at (token->location, \"expected %<directive%> or %<sequence%>\");\n+\t  cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t /*recovering=*/true,\n+\t\t\t\t\t\t /*or_comma=*/true,\n+\t\t\t\t\t\t /*consume_paren=*/false);\n+\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\t    break;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+      cp_lexer_consume_token (parser->lexer);\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n+\tcp_parser_required_error (parser, RT_OPEN_PAREN, false,\n+\t\t\t\t  UNKNOWN_LOCATION);\n+      else if (directive)\n+\tcp_parser_omp_directive_args (parser, attribute);\n+      else\n+\tcp_parser_omp_sequence_args (parser, attribute);\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\tbreak;\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+  while (1);\n+  if (!parens.require_close (parser))\n+    cp_parser_skip_to_closing_parenthesis (parser, true, false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+}\n+\n /*  Parse a standard C++11 attribute.\n \n     The returned representation is a TREE_LIST which TREE_PURPOSE is\n@@ -28066,7 +28362,18 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n   /* Now parse the optional argument clause of the attribute.  */\n \n   if (token->type != CPP_OPEN_PAREN)\n-    return attribute;\n+    {\n+      if ((flag_openmp || flag_openmp_simd)\n+\t  && attr_ns == omp_identifier\n+\t  && (is_attribute_p (\"directive\", attr_id)\n+\t      || is_attribute_p (\"sequence\", attr_id)))\n+\t{\n+\t  error_at (token->location, \"%<omp::%E%> attribute requires argument\",\n+\t\t    attr_id);\n+\t  return NULL_TREE;\n+\t}\n+      return attribute;\n+    }\n \n   {\n     vec<tree, va_gc> *vec;\n@@ -28093,6 +28400,23 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n \n     if (as == NULL)\n       {\n+\tif ((flag_openmp || flag_openmp_simd) && attr_ns == omp_identifier)\n+\t  {\n+\t    if (is_attribute_p (\"directive\", attr_id))\n+\t      {\n+\t\tcp_parser_omp_directive_args (parser, attribute);\n+\t\treturn attribute;\n+\t      }\n+\t    else if (is_attribute_p (\"sequence\", attr_id))\n+\t      {\n+\t\tTREE_VALUE (TREE_PURPOSE (attribute))\n+\t\t  = get_identifier (\"directive\");\n+\t\tcp_parser_omp_sequence_args (parser, attribute);\n+\t\tTREE_VALUE (attribute) = nreverse (TREE_VALUE (attribute));\n+\t\treturn attribute;\n+\t      }\n+\t  }\n+\n \t/* For unknown attributes, just skip balanced tokens instead of\n \t   trying to parse the arguments.  */\n \tfor (size_t n = cp_parser_skip_balanced_tokens (parser, 1) - 1; n; --n)\n@@ -38675,7 +38999,12 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n       if (nested && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n \tbreak;\n \n-      if (!first)\n+      if (!first\n+\t  /* OpenMP 5.1 allows optional comma in between directive-name and\n+\t     clauses everywhere, but as we aren't done with OpenMP 5.0\n+\t     implementation yet, let's allow it for now only in C++11\n+\t     attributes.  */\n+\t  || (parser->lexer->in_omp_attribute_pragma && nested != 2))\n \t{\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t    cp_lexer_consume_token (parser->lexer);\n@@ -39080,6 +39409,12 @@ cp_parser_omp_allocate (cp_parser *parser, cp_token *pragma_tok)\n   location_t loc = pragma_tok->location;\n   tree nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n \n+  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+  if (parser->lexer->in_omp_attribute_pragma\n+      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+    cp_lexer_consume_token (parser->lexer);\n+\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       matching_parens parens;\n@@ -39171,7 +39506,8 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n-      if (!first\n+      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+      if ((!first || parser->lexer->in_omp_attribute_pragma)\n \t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n \t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n \tcp_lexer_consume_token (parser->lexer);\n@@ -39735,6 +40071,10 @@ cp_parser_omp_depobj (cp_parser *parser, cp_token *pragma_tok)\n   tree clause = NULL_TREE;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_SOURCE;\n   location_t c_loc = cp_lexer_peek_token (parser->lexer)->location;\n+  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+  if (parser->lexer->in_omp_attribute_pragma\n+      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+    cp_lexer_consume_token (parser->lexer);\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -39815,6 +40155,11 @@ static void\n cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n {\n   enum memmodel mo = MEMMODEL_LAST;\n+  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+  if (parser->lexer->in_omp_attribute_pragma\n+      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+    cp_lexer_consume_token (parser->lexer);\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -41175,10 +41520,16 @@ cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n \t\t       enum pragma_context context, bool *if_p)\n {\n   location_t loc = pragma_tok->location;\n+  int n = 1;\n \n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+  if (parser->lexer->in_omp_attribute_pragma\n+      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+    n = 2;\n+\n+  if (cp_lexer_nth_token_is (parser->lexer, n, CPP_NAME))\n     {\n-      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      tree id = cp_lexer_peek_nth_token (parser->lexer, n)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n \n       if (strcmp (p, \"depend\") == 0)\n@@ -43020,6 +43371,7 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n       data.error_seen = false;\n       data.fndecl_seen = false;\n       data.variant_p = variant_p;\n+      data.in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n       data.tokens = vNULL;\n       data.clauses = NULL_TREE;\n       /* It is safe to take the address of a local variable; it will only be\n@@ -43458,7 +43810,7 @@ cp_parser_omp_context_selector_specification (cp_parser *parser,\n \n static tree\n cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n-\t\t\t       tree attrs)\n+\t\t\t       tree attrs, bool in_omp_attribute_pragma)\n {\n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -43516,6 +43868,12 @@ cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n   location_t finish_loc = get_finish (varid.get_location ());\n   location_t varid_loc = make_location (caret_loc, start_loc, finish_loc);\n \n+  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+  if (in_omp_attribute_pragma\n+      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+    cp_lexer_consume_token (parser->lexer);\n+\n   const char *clause = \"\";\n   location_t match_loc = cp_lexer_peek_token (parser->lexer)->location;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n@@ -43588,6 +43946,12 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n       cp_lexer_consume_token (parser->lexer);\n       if (strcmp (kind, \"simd\") == 0)\n \t{\n+\t  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+\t  if (data->in_omp_attribute_pragma\n+\t      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\n \t  cl = cp_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n \t\t\t\t\t  \"#pragma omp declare simd\",\n \t\t\t\t\t  pragma_tok);\n@@ -43602,7 +43966,9 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n       else\n \t{\n \t  gcc_assert (strcmp (kind, \"variant\") == 0);\n-\t  attrs = cp_finish_omp_declare_variant (parser, pragma_tok, attrs);\n+\t  attrs\n+\t    = cp_finish_omp_declare_variant (parser, pragma_tok, attrs,\n+\t\t\t\t\t     data->in_omp_attribute_pragma);\n \t}\n       cp_parser_pop_lexer (parser);\n     }\n@@ -43633,7 +43999,11 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n   tree clauses = NULL_TREE;\n   int device_type = 0;\n   bool only_device_type = true;\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+      || (parser->lexer->in_omp_attribute_pragma\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME)))\n     clauses\n       = cp_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,\n \t\t\t\t   \"#pragma omp declare target\", pragma_tok);\n@@ -43812,6 +44182,12 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)\n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     return false;\n \n+  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+  if (parser->lexer->in_omp_attribute_pragma\n+      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+    cp_lexer_consume_token (parser->lexer);\n+\n   const char *p = \"\";\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -44246,7 +44622,10 @@ cp_parser_omp_requires (cp_parser *parser, cp_token *pragma_tok)\n   location_t loc = pragma_tok->location;\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n-      if (!first && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+      if ((!first || parser->lexer->in_omp_attribute_pragma)\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n \tcp_lexer_consume_token (parser->lexer);\n \n       first = false;"}, {"sha": "5ef704721e202f73bfe18a089031dc144071711f", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -113,6 +113,10 @@ struct GTY (()) cp_lexer {\n   /* True if we're in the context of parsing a pragma, and should not\n      increment past the end-of-line marker.  */\n   bool in_pragma;\n+\n+  /* True if we're in the context of OpenMP directives written as C++11\n+     attributes turned into pragma.  */\n+  bool in_omp_attribute_pragma;\n };\n \n \n@@ -208,6 +212,8 @@ struct cp_omp_declare_simd_data {\n   bool error_seen; /* Set if error has been reported.  */\n   bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */\n   bool variant_p; /* Set for #pragma omp declare variant.  */\n+  bool in_omp_attribute_pragma; /* True if declare simd/variant comes from\n+\t\t\t\t   C++11 attribute rather than pragma.  */\n   vec<cp_token_cache_ptr> tokens;\n   tree clauses;\n };"}, {"sha": "c2734a17c5a9440003fd6d6b9a0c8ce8d3946770", "filename": "gcc/testsuite/g++.dg/gomp/attrs-1.C", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -0,0 +1,553 @@\n+// { dg-do compile { target c++11 } }\n+\n+typedef enum omp_allocator_handle_t\n+: __UINTPTR_TYPE__\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+typedef enum omp_sync_hint_t {\n+omp_sync_hint_none = 0x0,\n+omp_lock_hint_none = omp_sync_hint_none,\n+omp_sync_hint_uncontended = 0x1,\n+omp_lock_hint_uncontended = omp_sync_hint_uncontended,\n+omp_sync_hint_contended = 0x2,\n+omp_lock_hint_contended = omp_sync_hint_contended,\n+omp_sync_hint_nonspeculative = 0x4,\n+omp_lock_hint_nonspeculative = omp_sync_hint_nonspeculative,\n+omp_sync_hint_speculative = 0x8,\n+omp_lock_hint_speculative = omp_sync_hint_speculative\n+} omp_sync_hint_t;\n+\n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+\n+int t;\n+#pragma omp threadprivate (t)\n+\n+#pragma omp declare target\n+int f, l, ll, r, r2;\n+\n+void\n+foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n+{\n+  [[omp::directive (distribute parallel for\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) order(concurrent) allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute parallel for simd\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) order(concurrent) allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute simd\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16)\n+    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm)\n+    order(concurrent) allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16)\n+    allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+}\n+\n+void\n+qux (int p)\n+{\n+  [[omp::directive (loop bind(teams) order(concurrent)\n+    private (p) lastprivate (l) collapse(1) reduction(+:r))]]\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+}\n+#pragma omp end declare target\n+\n+void\n+baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n+{\n+  [[omp::directive (distribute parallel for\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) copyin(t) order(concurrent) allocate (p))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute parallel for simd\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) copyin(t) order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute simd\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16)\n+    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm)\n+    order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (loop bind(parallel) order(concurrent)\n+    private (p) lastprivate (l) collapse(1) reduction(+:r))]]\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+}\n+\n+void\n+bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm)\n+{\n+  [[omp::directive (for simd\n+    private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1) order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (for\n+    private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait\n+    order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (simd\n+    private (p) lastprivate (l) linear (ll:1) reduction(+:r) collapse(1) safelen(8) simdlen(4) aligned(q: 32)\n+    nontemporal(ntm) if(i1) order(concurrent))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel for\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel for\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel for simd\n+    private (p) firstprivate (f) if (i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1)\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel sections\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) allocate (f))]]\n+  {\n+    #pragma omp section\n+    {}\n+    #pragma omp section\n+    {}\n+  }\n+  [[omp::directive (sections private (p) firstprivate (f) reduction(+:r) lastprivate (l) allocate (f) nowait)]]\n+  {\n+    ;\n+    #pragma omp section\n+    ;\n+    #pragma omp section\n+    {}\n+  }\n+  [[omp::directive (barrier)]];\n+  [[omp::sequence (omp::directive (single private (p) firstprivate (f) allocate (f) nowait))]]\n+    ;\n+  [[omp::sequence (directive (barrier))]];\n+  [[omp::sequence (directive (parallel private (p)),\n+    omp::directive (single copyprivate (p) firstprivate (f) allocate (f)))]]\n+    p = 6;\n+  [[omp::directive (target parallel\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+    ;\n+  [[omp::directive (target parallel for\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) nowait depend(inout: dd[0])\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (target parallel for\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) order(concurrent)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (omp::directive (target parallel for simd\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1)\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) order(concurrent)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (target teams\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0])\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    ;\n+  [[omp::sequence (directive (target\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    ;\n+  [[omp::sequence (omp::directive (target teams distribute\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  [[omp::directive (target teams distribute parallel for\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0]) order(concurrent)\n+     allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (target teams distribute parallel for simd\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (target teams distribute simd\n+    device(d) map (tofrom: m) if (i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (target simd\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r)\n+    nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3) order(concurrent)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup task_reduction(+:r2) allocate (r2)),\n+    omp::directive (taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    order(concurrent) allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (omp::directive (taskgroup task_reduction(+:r) allocate (r)),\n+    directive (taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(i1) final(fi) mergeable nogroup priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) in_reduction(+:r) nontemporal(ntm)\n+    order(concurrent) allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (taskwait)]];\n+  [[omp::directive (taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) if(taskloop: i1) final(fi) priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r) if (simd: i3) nontemporal(ntm)\n+    order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup task_reduction(+:r2) allocate (r2)),\n+    omp::directive (taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) in_reduction(+:r2) allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup task_reduction(+:r2) allocate (r2)),\n+    omp::directive (task\n+    private (p) firstprivate (f) shared (s) default(shared) untied if(task: i1) final(fi) mergeable priority (pp)\n+    in_reduction(+:r2) allocate (f)))]]\n+    ;\n+  [[omp::directive (taskyield)]];\n+  [[omp::directive (target data if (target data: i1) device(d) map (tofrom: m) use_device_ptr (q) use_device_addr (p))]]\n+  ;\n+  [[omp::directive (target enter data if (target enter data: i1) device(d) map (to: m) depend(inout: dd[0]) nowait)]]\n+  ;\n+  [[omp::directive (target exit data if (target exit data: i1) device(d) map (from: m) depend(inout: dd[0]) nowait)]]\n+  ;\n+  [[omp::directive (target update if (target update: i1) device(d) to (m) depend(inout: dd[0]) nowait)]]\n+  ;\n+  [[omp::directive (target update if (target update: i1) device(d) from (m) depend(inout: dd[0]) nowait)]]\n+  ;\n+  [[omp::directive (taskwait)]];\n+  [[omp::sequence (directive (target nowait depend(inout: dd[0]) in_reduction(+:r2)),\n+    directive (teams distribute\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16) allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  [[omp::directive (teams\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    allocate (omp_default_mem_alloc: f))]]\n+    ;\n+  [[omp::sequence (omp::directive (target),\n+    omp::directive (teams distribute parallel for\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) order(concurrent) allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (target),\n+    directive (teams distribute parallel for simd\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n+    allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (target),\n+    directive (teams distribute simd\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n+    allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (teams distribute parallel for\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16) order(concurrent)\n+    if (parallel: i2) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) copyin(t) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (teams distribute parallel for simd\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16)\n+    if (parallel: i2) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) schedule(static, 4) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t)\n+    allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (teams distribute simd\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) dist_schedule(static, 16) order(concurrent)\n+    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm) allocate(f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r)\n+    num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n+    ;\n+  [[omp::directive (parallel\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r)\n+    num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n+    ;\n+  [[omp::sequence (directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    omp::directive (master taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) in_reduction(+:r2) allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (master)]];\n+  [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    directive (master taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    order(concurrent) allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n+    order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    directive (master taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) in_reduction(+:r2)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    omp::directive (master taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    order(concurrent) allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t)\n+    order(concurrent) allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (loop bind(thread) order(concurrent)\n+    private (p) lastprivate (l) collapse(1) reduction(+:r))]]\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+  [[omp::directive (parallel loop\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) collapse(1) bind(parallel) order(concurrent) allocate (f))]]\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  [[omp::directive (parallel loop\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    lastprivate (l) collapse(1) allocate (f))]]\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  [[omp::directive (teams loop\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) lastprivate (l) bind(teams) allocate (f))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (teams loop\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl)\n+    collapse(1) lastprivate (l) order(concurrent) allocate (f))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target parallel loop\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    nowait depend(inout: dd[0]) lastprivate (l) bind(parallel) order(concurrent) collapse(1)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target parallel loop\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n+    nowait depend(inout: dd[0]) lastprivate (l) order(concurrent) collapse(1)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target teams loop\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0])\n+    lastprivate (l) bind(teams) collapse(1)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target teams loop\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0])\n+    lastprivate (l) order(concurrent) collapse(1)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (critical)]] {\n+  }\n+  [[omp::directive (critical (foobar) hint(omp_sync_hint_none))]]\n+  ;\n+  [[omp::directive (taskwait depend (inout: dd[0]))]]\n+  ;\n+  [[omp::directive (taskgroup task_reduction(+:r2) allocate (r2))]]\n+  ;\n+  [[omp::directive (atomic update seq_cst hint(omp_sync_hint_none))]]\n+  p++;\n+  [[omp::directive (atomic read hint(omp_sync_hint_none) relaxed)]]\n+  f = p;\n+  [[omp::directive (atomic write release hint(omp_sync_hint_none))]]\n+  p = f;\n+  [[omp::directive (flush)]]\n+  ;\n+  [[omp::directive (flush acq_rel)]]\n+  ;\n+  [[omp::directive (flush (p, f))]]\n+  ;\n+  [[omp::directive (simd\n+    private (p) lastprivate (l) linear (ll:1) reduction(+:r) collapse(1) safelen(8) simdlen(4) aligned(q: 32)\n+    nontemporal(ntm) if(i1))]]\n+  for (int i = 0; i < 64; i++)\n+    [[omp::directive (ordered simd)]]\n+      ll++;\n+  [[omp::directive (for\n+    private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait\n+    ordered allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    [[omp::directive (ordered threads)]]\n+      ll++;\n+  [[omp::directive(for ordered (1))]]\n+  for (l = 0; l < 64; l++)\n+    {\n+      [[omp::directive(ordered depend (sink: l - 1))]];\n+      [[omp::directive(ordered depend (source))]];\n+    }\n+  extern omp_depend_t depobj;\n+  [[omp::directive (depobj(depobj) depend(in : dd[0]))]];\n+  [[omp::directive (parallel)]] {\n+    if (p) {\n+      [[omp::directive (cancel parallel)]];\n+    } else {\n+      [[omp::directive (cancellation point parallel)]];\n+    }\n+  }\n+  extern int t2;\n+  [[omp::directive (threadprivate (t2))]]\n+  extern int t2;\n+  [[omp::directive (declare reduction (dr: int: omp_out += omp_in) initializer (omp_priv = 0))]]\n+  ;\n+}\n+\n+void corge1 ();\n+\n+void\n+corge ()\n+{\n+  [[omp::directive (declare variant (corge1) match (construct={parallel,for}))]]\n+  extern void corge2 ();\n+  [[omp::sequence (directive (parallel), directive (for))]]\n+  for (int i = 0; i < 5; i++)\n+    corge2 ();\n+  [[omp::directive (declare simd simdlen(4) linear(l) aligned(p:4) uniform(p) inbranch),\n+    omp::directive (declare simd simdlen(8) notinbranch)]]\n+  extern int corge3 (int l, int *p);\n+  [[omp::directive (declare simd simdlen(4) linear(l) aligned(p:4) uniform(p) inbranch),\n+    directive (declare simd simdlen(8) notinbranch)]]\n+  extern int corge4 (int l, int *p);\n+  [[omp::sequence (directive (declare simd simdlen(4) linear(l) aligned(p:4) uniform(p) inbranch),\n+    omp::directive (declare simd simdlen(8) notinbranch))]]\n+  extern int corge5 (int l, int *p);\n+  [[omp::directive (declare target)]];\n+  extern void corge6 ();\n+  [[omp::directive (end declare target)]];\n+}\n+\n+int\n+garply (int a, int *c, int *d, int *e, int *f)\n+{\n+  int i;\n+  [[omp::directive (simd reduction (inscan, +: a))]]\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      #pragma omp scan exclusive (a)\n+      a += c[i];\n+    }\n+  [[omp::directive (simd reduction (inscan, +: a))]]\n+  for (i = 0; i < 64; i++)\n+    {\n+      a += c[i];\n+      #pragma omp scan inclusive (a)\n+      d[i] = a;\n+    }\n+  return a;\n+}"}, {"sha": "1eb626330c4655a79bf688ea1b9c278500daad5b", "filename": "gcc/testsuite/g++.dg/gomp/attrs-2.C", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -0,0 +1,553 @@\n+// { dg-do compile { target c++17 } }\n+\n+typedef enum omp_allocator_handle_t\n+: __UINTPTR_TYPE__\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+typedef enum omp_sync_hint_t {\n+omp_sync_hint_none = 0x0,\n+omp_lock_hint_none = omp_sync_hint_none,\n+omp_sync_hint_uncontended = 0x1,\n+omp_lock_hint_uncontended = omp_sync_hint_uncontended,\n+omp_sync_hint_contended = 0x2,\n+omp_lock_hint_contended = omp_sync_hint_contended,\n+omp_sync_hint_nonspeculative = 0x4,\n+omp_lock_hint_nonspeculative = omp_sync_hint_nonspeculative,\n+omp_sync_hint_speculative = 0x8,\n+omp_lock_hint_speculative = omp_sync_hint_speculative\n+} omp_sync_hint_t;\n+\n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+\n+int t;\n+#pragma omp threadprivate (t)\n+\n+#pragma omp declare target\n+int f, l, ll, r, r2;\n+\n+void\n+foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n+{\n+  [[omp::directive (distribute parallel for,\n+    private (p),firstprivate (f),collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),order(concurrent),allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute parallel for simd,\n+    private (p),firstprivate (f),collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),if(simd: i1),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),nontemporal(ntm),\n+    safelen(8),simdlen(4),aligned(q: 32),order(concurrent),allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute simd,\n+    private (p),firstprivate (f),collapse(1),dist_schedule(static, 16),\n+    safelen(8),simdlen(4),aligned(q: 32),reduction(+:r),if(i1),nontemporal(ntm),\n+    order(concurrent),allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute,\n+    private (p),firstprivate (f),collapse(1),dist_schedule(static, 16),\n+    allocate (omp_default_mem_alloc:f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+}\n+\n+void\n+qux (int p)\n+{\n+  [[omp::directive (loop, bind(teams),order(concurrent),\n+    private (p),lastprivate (l),collapse(1),reduction(+:r))]]\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+}\n+#pragma omp end declare target\n+\n+void\n+baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n+{\n+  [[omp::directive (distribute parallel for,\n+    private (p),firstprivate (f),collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),copyin(t),order(concurrent),allocate (p))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute parallel for simd,\n+    private (p),firstprivate (f),collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),if(simd: i1),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),nontemporal(ntm),\n+    safelen(8),simdlen(4),aligned(q: 32),copyin(t),order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (distribute simd,\n+    private (p),firstprivate (f),collapse(1),dist_schedule(static, 16),\n+    safelen(8),simdlen(4),aligned(q: 32),reduction(+:r),if(i1),nontemporal(ntm),\n+    order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (loop, bind(parallel),order(concurrent),\n+    private (p),lastprivate (l),collapse(1),reduction(+:r))]]\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+}\n+\n+void\n+bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm)\n+{\n+  [[omp::directive (for simd,\n+    private (p),firstprivate (f),lastprivate (l),linear (ll:1),reduction(+:r),schedule(static, 4),collapse(1),nowait,\n+    safelen(8),simdlen(4),aligned(q: 32),nontemporal(ntm),if(i1),order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (for,\n+    private (p),firstprivate (f),lastprivate (l),linear (ll:1),reduction(+:r),schedule(static, 4),collapse(1),nowait,\n+    order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (simd,\n+    private (p),lastprivate (l),linear (ll:1),reduction(+:r),collapse(1),safelen(8),simdlen(4),aligned(q: 32),\n+    nontemporal(ntm),if(i1),order(concurrent))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel for,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),copyin(t),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),linear (ll:1),ordered schedule(static, 4),collapse(1),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel for,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),copyin(t),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),linear (ll:1),schedule(static, 4),collapse(1),order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel for simd,\n+    private (p),firstprivate (f),if (i2),default(shared),shared(s),copyin(t),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),linear (ll:1),schedule(static, 4),collapse(1),\n+    safelen(8),simdlen(4),aligned(q: 32),nontemporal(ntm),order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel sections,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),copyin(t),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),allocate (f))]]\n+  {\n+    #pragma omp section\n+    {}\n+    #pragma omp section\n+    {}\n+  }\n+  [[omp::directive (sections, private (p),firstprivate (f),reduction(+:r),lastprivate (l),allocate (f),nowait)]]\n+  {\n+    ;\n+    #pragma omp section\n+    ;\n+    #pragma omp section\n+    {}\n+  }\n+  [[omp::directive (barrier)]];\n+  [[using omp:sequence (omp::directive (single, private (p),firstprivate (f),allocate (f),nowait))]]\n+    ;\n+  [[omp::sequence (directive (barrier))]];\n+  [[using omp:sequence (directive (parallel, private (p)),\n+    omp::directive (single, copyprivate (p),firstprivate (f),allocate (f)))]]\n+    p = 6;\n+  [[omp::directive (target parallel,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread)\n+    nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    ;\n+  [[omp::directive (target parallel for,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),linear (ll:1),ordered schedule(static, 4),collapse(1),nowait depend(inout: dd[0]),\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[using omp:directive (target parallel for,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),linear (ll:1),schedule(static, 4),collapse(1),nowait depend(inout: dd[0]),order(concurrent),\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (omp::directive (target parallel for simd,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),linear (ll:1),schedule(static, 4),collapse(1),\n+    safelen(8),simdlen(4),aligned(q: 32),nowait depend(inout: dd[0]),nontemporal(ntm),if (simd: i3),order(concurrent),\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[using omp:sequence (directive (target teams,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),nowait, depend(inout: dd[0]),\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    ;\n+  [[using omp:sequence (directive (target,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2)))]]\n+    ;\n+  [[omp::sequence (omp::directive (target teams distribute,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2)))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  [[omp::directive (target teams distribute parallel for,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),nowait depend(inout: dd[0]),order(concurrent),\n+     allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (target teams distribute parallel for simd,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),order(concurrent),\n+    safelen(8),simdlen(4),aligned(q: 32),nowait depend(inout: dd[0]),nontemporal(ntm),if (simd: i3),\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (target teams distribute simd,\n+    device(d),map (tofrom: m),if (i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),order(concurrent),\n+    safelen(8),simdlen(4),aligned(q: 32),nowait depend(inout: dd[0]),nontemporal(ntm),\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (target simd,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    safelen(8),simdlen(4),lastprivate (l),linear(ll: 1),aligned(q: 32),reduction(+:r),\n+    nowait depend(inout: dd[0]),nontemporal(ntm),if(simd:i3),order(concurrent),\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup, task_reduction(+:r2), allocate (r2)),\n+    omp::directive (taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),if(simd: i2),final(fi),mergeable,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),in_reduction(+:r2),nontemporal(ntm),\n+    order(concurrent),allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[using omp:sequence (omp::directive (taskgroup, task_reduction(+:r), allocate (r)),\n+    directive (taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(i1),final(fi),mergeable,nogroup,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),in_reduction(+:r),nontemporal(ntm),\n+    order(concurrent),allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (taskwait)]];\n+  [[omp::directive (taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),if(taskloop: i1),final(fi),priority (pp)\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(+:r),if (simd: i3),nontemporal(ntm),\n+    order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup, task_reduction(+:r2), allocate (r2)),\n+    omp::directive (taskloop\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied, if(taskloop: i1),final(fi),mergeable, priority (pp),\n+    reduction(default, +:r),in_reduction(+:r2),allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup, task_reduction(+:r2),allocate (r2)),\n+    omp::directive (task,\n+    private (p),firstprivate (f),shared (s),default(shared),untied,if(task: i1),final(fi),mergeable,priority (pp),\n+    in_reduction(+:r2),allocate (f)))]]\n+    ;\n+  [[omp::directive (taskyield)]];\n+  [[omp::directive (target data, if (target data: i1),device(d),map (tofrom: m),use_device_ptr (q),use_device_addr (p))]]\n+  ;\n+  [[omp::directive (target enter data, if (target enter data: i1),device(d),map (to: m),depend(inout: dd[0]),nowait)]]\n+  ;\n+  [[omp::directive (target exit data, if (target exit data: i1),device(d),map (from: m),depend(inout: dd[0]),nowait)]]\n+  ;\n+  [[omp::directive (target update, if (target update: i1),device(d),to (m),depend(inout: dd[0]),nowait)]]\n+  ;\n+  [[omp::directive (target update, if (target update: i1),device(d),from (m),depend(inout: dd[0]),nowait)]]\n+  ;\n+  [[omp::directive (taskwait)]];\n+  [[omp::sequence (directive (target, nowait,depend(inout: dd[0]),in_reduction(+:r2)),\n+    directive (teams distribute,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n+  [[omp::directive (teams,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    allocate (omp_default_mem_alloc: f))]]\n+    ;\n+  [[omp::sequence (omp::directive (target),\n+    omp::directive (teams distribute parallel for,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),order(concurrent),allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[using omp:sequence (directive (target),\n+    directive (teams distribute parallel for simd,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),order(concurrent),\n+    safelen(8),simdlen(4),aligned(q: 32),if (simd: i3),nontemporal(ntm),\n+    allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (target),\n+    directive (teams distribute simd,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),order(concurrent),\n+    safelen(8),simdlen(4),aligned(q: 32),if(i3),nontemporal(ntm),\n+    allocate (omp_default_mem_alloc: f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (teams distribute parallel for,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),order(concurrent),\n+    if (parallel: i2),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),copyin(t),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (teams distribute parallel for simd,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),\n+    if (parallel: i2),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),schedule(static, 4),order(concurrent),\n+    safelen(8),simdlen(4),aligned(q: 32),if (simd: i3),nontemporal(ntm),copyin(t),\n+    allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (teams distribute simd,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),dist_schedule(static, 16),order(concurrent),\n+    safelen(8),simdlen(4),aligned(q: 32),if(i3),nontemporal(ntm),allocate(f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),reduction(+:r),\n+    num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n+    ;\n+  [[omp::directive (parallel,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),reduction(+:r),\n+    num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n+    ;\n+  [[using omp:sequence (directive (taskgroup, task_reduction (+:r2),allocate (r2)),\n+    omp::directive (master taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied, if(taskloop: i1),final(fi),mergeable, priority (pp),\n+    reduction(default, +:r),in_reduction(+:r2),allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[using omp:directive (master)]];\n+  [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2),allocate (r2)),\n+    directive (master taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),if(simd: i2),final(fi),mergeable,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),in_reduction(+:r2),nontemporal(ntm),\n+    order(concurrent),allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),final(fi),mergeable,priority (pp),\n+    reduction(default, +:r),if (parallel: i2),num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),if(simd: i2),final(fi),mergeable,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),nontemporal(ntm),if (parallel: i2),num_threads (nth),proc_bind(spread),copyin(t),\n+    order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (directive (taskgroup,task_reduction (+:r2),allocate (r2)),\n+    directive (master taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied,if(i1),final(fi),mergeable,priority (pp),\n+    reduction(default, +:r),in_reduction(+:r2)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::sequence (omp::directive (taskgroup,task_reduction (+:r2),allocate (r2)),\n+    omp::directive (master taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied,if(i1),final(fi),mergeable,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),in_reduction(+:r2),nontemporal(ntm),\n+    order(concurrent),allocate (f)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied if(i1),final(fi),mergeable priority (pp),\n+    reduction(default, +:r),num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (parallel master taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied if(i1),final(fi),mergeable priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),nontemporal(ntm),num_threads (nth),proc_bind(spread),copyin(t),\n+    order(concurrent),allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  [[omp::directive (loop, bind(thread),order(concurrent),\n+    private (p),lastprivate (l),collapse(1),reduction(+:r))]]\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+  [[omp::directive (parallel loop,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),copyin(t),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),collapse(1),bind(parallel),order(concurrent),allocate (f))]]\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  [[omp::directive (parallel loop,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),copyin(t),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    lastprivate (l),collapse(1),allocate (f))]]\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  [[omp::directive (teams loop,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),lastprivate (l),bind(teams),allocate (f))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (teams loop,\n+    private(p),firstprivate (f),shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n+    collapse(1),lastprivate (l),order(concurrent),allocate (f))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target parallel loop,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    nowait depend(inout: dd[0]),lastprivate (l),bind(parallel),order(concurrent),collapse(1),\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target parallel loop,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n+    nowait depend(inout: dd[0]),lastprivate (l),order(concurrent),collapse(1),\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target teams loop,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),nowait,depend(inout: dd[0]),\n+    lastprivate (l),bind(teams),collapse(1),\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (target teams loop,\n+    device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),nowait,depend(inout: dd[0]),\n+    lastprivate (l),order(concurrent),collapse(1)\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  [[omp::directive (critical)]] {\n+  }\n+  [[omp::directive (critical (foobar),hint(omp_sync_hint_none))]]\n+  ;\n+  [[using omp:directive (taskwait, depend (inout: dd[0]))]]\n+  ;\n+  [[omp::directive (taskgroup, task_reduction(+:r2),allocate (r2))]]\n+  ;\n+  [[omp::directive (atomic, update,seq_cst,hint(omp_sync_hint_none))]]\n+  p++;\n+  [[omp::directive (atomic, read, hint(omp_sync_hint_none),relaxed)]]\n+  f = p;\n+  [[omp::directive (atomic,write, release hint(omp_sync_hint_none))]]\n+  p = f;\n+  [[omp::directive (flush)]]\n+  ;\n+  [[omp::directive (flush, acq_rel)]]\n+  ;\n+  [[omp::directive (flush (p, f))]]\n+  ;\n+  [[omp::directive (simd,\n+    private (p),lastprivate (l),linear (ll:1),reduction(+:r),collapse(1),safelen(8),simdlen(4),aligned(q: 32),\n+    nontemporal(ntm),if(i1))]]\n+  for (int i = 0; i < 64; i++)\n+    [[omp::directive (ordered, simd)]]\n+      ll++;\n+  [[omp::directive (for,\n+    private (p),firstprivate (f),lastprivate (l),linear (ll:1),reduction(+:r),schedule(static, 4),collapse(1),nowait,\n+    ordered, allocate (f))]]\n+  for (int i = 0; i < 64; i++)\n+    [[omp::directive (ordered, threads)]]\n+      ll++;\n+  [[omp::directive(for, ordered (1))]]\n+  for (l = 0; l < 64; l++)\n+    {\n+      [[omp::directive(ordered, depend (sink: l - 1))]];\n+      [[omp::directive(ordered, depend (source))]];\n+    }\n+  extern omp_depend_t depobj;\n+  [[omp::directive (depobj(depobj),depend(in : dd[0]))]];\n+  [[omp::directive (parallel)]] {\n+    if (p) {\n+      [[omp::directive (cancel, parallel)]];\n+    } else {\n+      [[omp::directive (cancellation point, parallel)]];\n+    }\n+  }\n+  extern int t2;\n+  [[omp::directive (threadprivate (t2))]]\n+  extern int t2;\n+  [[omp::directive (declare reduction (dr: int: omp_out += omp_in),initializer (omp_priv = 0))]]\n+  ;\n+}\n+\n+void corge1 ();\n+\n+void\n+corge ()\n+{\n+  [[omp::directive (declare variant (corge1),match (construct={parallel,for}))]]\n+  extern void corge2 ();\n+  [[omp::sequence (directive (parallel), directive (for))]]\n+  for (int i = 0; i < 5; i++)\n+    corge2 ();\n+  [[omp::directive (declare simd, simdlen(4),linear(l),aligned(p:4),uniform(p),inbranch),\n+    omp::directive (declare simd,simdlen(8),notinbranch)]]\n+  extern int corge3 (int l, int *p);\n+  [[using omp:directive (declare simd, simdlen(4),linear(l),aligned(p:4),uniform(p),inbranch),\n+    directive (declare simd, simdlen(8),notinbranch)]]\n+  extern int corge4 (int l, int *p);\n+  [[omp::sequence (directive (declare simd, simdlen(4),linear(l),aligned(p:4),uniform(p),inbranch),\n+    omp::directive (declare simd, simdlen(8),notinbranch))]]\n+  extern int corge5 (int l, int *p);\n+  [[omp::directive (declare target)]];\n+  extern void corge6 ();\n+  [[omp::directive (end declare target)]];\n+}\n+\n+int\n+garply (int a, int *c, int *d, int *e, int *f)\n+{\n+  int i;\n+  [[omp::directive (simd, reduction (inscan, +: a))]]\n+  for (i = 0; i < 64; i++)\n+    {\n+      d[i] = a;\n+      #pragma omp scan exclusive (a)\n+      a += c[i];\n+    }\n+  [[omp::directive (simd, reduction (inscan, +: a))]]\n+  for (i = 0; i < 64; i++)\n+    {\n+      a += c[i];\n+      #pragma omp scan inclusive (a)\n+      d[i] = a;\n+    }\n+  return a;\n+}"}, {"sha": "7aab6370d499d282dfd9dd1f20056d133d413981", "filename": "gcc/testsuite/g++.dg/gomp/attrs-3.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9984f63aab93a370101966b7eb198dc61130b3c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-3.C?ref=9984f63aab93a370101966b7eb198dc61130b3c8", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile { target c++11 } }\n+\n+int i;\n+int t1, t2, t3, t4, t5, t6, t7;\n+\n+void\n+foo ()\n+{\n+  [[omp::directive]];\t\t// { dg-error \"'omp::directive' attribute requires argument\" }\n+  [[omp::directive ()]];\t// { dg-error \"expected OpenMP directive name\" }\n+  [[omp::directive (nonexistent foobar)]];\t// { dg-error \"unknown OpenMP directive name in 'omp::directive' attribute argument\" }\n+  [[omp::sequence]];\t\t// { dg-error \"'omp::sequence' attribute requires argument\" }\n+  [[omp::sequence()]];\t\t// { dg-error \"expected 'directive' or 'sequence'\" }\n+  [[omp::sequence(foobar())]];\t\t// { dg-error \"expected 'directive' or 'sequence'\" }\n+  [[omp::sequence(omp::foobar())]];\t\t// { dg-error \"expected 'directive' or 'sequence'\" }\n+  [[omp::sequence(directive(taskwait), foobar())]];\t\t// { dg-error \"expected 'directive' or 'sequence'\" }\n+  [[omp::sequence(omp::directive(taskwait), omp::foobar())]];\t// { dg-error \"expected 'directive' or 'sequence'\" }\n+  [[omp::sequence(directive(taskwait) foobar())]];\t\t// { dg-error \"expected '\\\\\\)' before 'foobar'\" }\n+  [[omp::sequence(directive)]];\t\t// { dg-error \"expected '\\\\\\(' before '\\\\\\)' token\" }\n+  [[omp::sequence(omp::sequence)]];\t// { dg-error \"expected '\\\\\\(' before '\\\\\\)' token\" }\n+  [[omp::directive (parallel), omp::directive (single)]]\t// { dg-error \"OpenMP construct among 'omp::directive' attributes requires all 'omp::directive' attributes on the same statement to be in the same 'omp::sequence'\" }\n+    ;\n+  [[omp::directive (parallel)]]\t// { dg-error \"OpenMP construct among 'omp::directive' attributes requires all 'omp::directive' attributes on the same statement to be in the same 'omp::sequence'\" }\n+  [[omp::directive (single)]]\n+    ;\n+  [[omp::directive (taskwait), omp::directive (taskyield)]]\t// { dg-error \"multiple OpenMP standalone directives among 'omp::directive' attributes must be all within the same 'omp::sequence'\" }\n+    ;\n+  [[omp::directive (taskwait)]]\n+  [[omp::directive (taskyield)]]\t// { dg-error \"multiple OpenMP standalone directives among 'omp::directive' attributes must be all within the same 'omp::sequence'\" }\n+    ;\n+  [[omp::directive (flush)]]\t// { dg-error \"standalone OpenMP directives in 'omp::directive' attribute can only appear on an empty statement\" }\n+    i++;\n+  auto a = [] () [[omp::directive (threadprivate (t1))]] {};\t// { dg-error \"'omp::directive' not allowed to be specified in this context\" }\n+  int [[omp::directive (threadprivate (t2))]] b;\t\t// { dg-warning \"attribute ignored\" }\n+  int *[[omp::directive (threadprivate (t3))]] c;\t\t// { dg-warning \"'omp::directive' scoped attribute directive ignored\" }\n+  int &[[omp::directive (threadprivate (t4))]] d = b;\t\t// { dg-warning \"'omp::directive' scoped attribute directive ignored\" }\n+  typedef int T [[omp::directive (threadprivate (t5))]];\t// { dg-error \"'omp::directive' not allowed to be specified in this context\" }\n+  int e[10] [[omp::directive (threadprivate (t6))]];\t\t// { dg-error \"'omp::directive' not allowed to be specified in this context\" }\n+  struct [[omp::directive (threadprivate (t7))]] S {};\t\t// { dg-error \"'omp::directive' not allowed to be specified in this context\" }\n+}"}]}