{"sha": "267bac1078ce623767a9effa063d5b63fbbeb6ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY3YmFjMTA3OGNlNjIzNzY3YTllZmZhMDYzZDViNjNmYmJlYjZjYQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2013-11-07T21:15:25Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2013-11-07T21:15:25Z"}, "message": "tree-core.h (enum cv_qualifier): Add TYPE_QUAL_ATOMIC.\n\ngcc:\n2013-11-05  Andrew MacLeod  <amacleod@redhat.com>\n\t    Joseph Myers  <joseph@codesourcery.com>\n\n\t* tree-core.h (enum cv_qualifier): Add TYPE_QUAL_ATOMIC.\n\t(enum tree_index): Add TI_ATOMICQI_TYPE, TI_ATOMICHI_TYPE,\n\tTI_ATOMICSI_TYPE, TI_ATOMICDI_TYPE and TI_ATOMICTI_TYPE.\n\t(struct tree_base): Add atomic_flag field.\n\t* tree.h (TYPE_ATOMIC): New accessor macro.\n\t(TYPE_QUALS, TYPE_QUALS_NO_ADDR_SPACE): Add TYPE_QUAL_ATOMIC.\n\t(TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC): New macro.\n\t(atomicQI_type_node, atomicHI_type_node, atomicSI_type_node)\n\t(atomicDI_type_node, atomicTI_type_node): New macros for type\n\tnodes.\n\t* tree.c (set_type_quals): Set TYPE_ATOMIC.\n\t(find_atomic_core_type): New function.\n\t(build_qualified_type): Adjust alignment for qualified types.\n\t(build_atomic_base): New function\n\t(build_common_tree_nodes): Build atomicQI_type_node,\n\tatomicHI_type_node, atomicSI_type_node, atomicDI_type_node and\n\tatomicTI_type_node.\n\t* print-tree.c (print_node): Print atomic qualifier.\n\t* tree-pretty-print.c (dump_generic_node): Print atomic type\n\tattribute.\n\t* target.def (atomic_assign_expand_fenv): New hook.\n\t* doc/tm.texi.in (TARGET_ATOMIC_ASSIGN_EXPAND_FENV): New @hook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_atomic_assign_expand_fenv): New function.\n\t* targhooks.h (default_atomic_assign_expand_fenv): Declare.\n\t* sync-builtins.def (__atomic_feraiseexcept): New built-in\n\tfunction.\n\t* config/i386/i386-builtin-types.def (VOID_FTYPE_PUSHORT): New\n\tfunction type.\n\t* config/i386/i386.c (enum ix86_builtins): Add\n\tIX86_BUILTIN_FNSTENV, IX86_BUILTIN_FLDENV, IX86_BUILTIN_FNSTSW and\n\tIX86_BUILTIN_FNCLEX.\n\t(bdesc_special_args): Add __builtin_ia32_fnstenv,\n\t__builtin_ia32_fldenv, __builtin_ia32_fnstsw and\n\t__builtin_ia32_fnclex.\n\t(ix86_expand_builtin): Handle the new built-in functions.\n\t(ix86_atomic_assign_expand_fenv): New function.\n\t(TARGET_ATOMIC_ASSIGN_EXPAND_FENV): New macro.\n\t* config/i386/i386.md (UNSPECV_FNSTENV, UNSPECV_FLDENV)\n\t(UNSPECV_FNSTSW, UNSPECV_FNCLEX): New unspecs.\n\t(fnstenv, fldenv, fnstsw, fnclex): New insns.\n\ngcc/c-family:\n2013-11-05  Andrew MacLeod  <amacleod@redhat.com>\n\t    Joseph Myers  <joseph@codesourcery.com>\n\n\t* c-common.h (enum rid): Add RID_ATOMIC.\n\t* c-common.c (c_common_reswords): Add _Atomic.\n\t(sync_resolve_params): Use TYPE_MAIN_VARIANT on pointer argument.\n\t(keyword_is_type_qualifier): Accept RID_ATOMIC.\n\t* c-format.c (check_format_types): Check for extra _Atomic\n\tqualifiers in format argument.\n\t* c-pretty-print.c (pp_c_cv_qualifiers): Handle atomic qualifier.\n\t(pp_c_type_qualifier_list): Mention _Atomic in comment.\n\ngcc/c:\n2013-11-05  Joseph Myers  <joseph@codesourcery.com>\n\t    Andrew MacLeod  <amacleod@redhat.com>\n\n\t* c-aux-info.c (gen_type): Handle atomic qualifier.\n\t* c-decl.c (validate_proto_after_old_defn): Do not remove atomic\n\tqualifiers when compating types.\n\t(shadow_tag_warned): Handle atomic_p in declspecs.\n\t(quals_from_declspecs): Likewise.\n\t(start_decl): Use c_type_promotes_to when promoting argument\n\ttypes.\n\t(grokdeclarator): Handle _Atomic.\n\t(get_parm_info): Diagnose any qualifier on \"void\" as only\n\tparameter.\n\t(store_parm_decls_oldstyle): Do not remove atomic qualifiers when\n\tcomparing types.  Use c_type_promotes_to when promoting argument\n\ttypes.\n\t(finish_function): Use c_type_promotes_to when promoting argument\n\ttypes.\n\t(build_null_declspecs): Handle atomic_p in declspecs.\n\t(declspecs_add_qual): Handle RID_ATOMIC.\n\t* c-parser.c (c_token_starts_typename, c_token_is_qualifier)\n\t(c_token_starts_declspecs): Handle RID_ATOMIC.\n\t(c_parser_declspecs): Handle atomic type specifiers and\n\tqualifiers.\n\t(c_parser_typeof_specifier): Remove const and _Atomic qualifiers\n\tfrom types of expressions with atomic type.\n\t(c_parser_direct_declarator_inner): Use convert_lvalue_to_rvalue.\n\t(c_parser_attribute_any_word): Handle RID_ATOMIC.\n\t(c_parser_initializer, c_parser_initelt, c_parser_initval)\n\t(c_parser_statement_after_labels, c_parser_switch_statement)\n\t(c_parser_for_statement, c_parser_expr_no_commas)\n\t(c_parser_conditional_expression, c_parser_binary_expression)\n\t(c_parser_cast_expression, c_parser_unary_expression)\n\t(c_parser_postfix_expression)\n\t(c_parser_postfix_expression_after_primary, c_parser_expression):\n\tUse convert_lvalue_to_rvalue.\n\t(c_parser_expression_conv, c_parser_expr_list): Document\n\tconversion of lvalues to rvalues.  Use convert_lvalue_to_rvalue.\n\t(c_parser_objc_synchronized_statement): Use\n\tconvert_lvalue_to_rvalue.\n\t(c_parser_objc_selector): Handle RID_ATOMIC.\n\t(c_parser_objc_receiver, c_parser_array_notation): Use\n\tconvert_lvalue_to_rvalue.\n\t* c-tree.h (ctsk_typeof): Adjust comment to mention use for\n\t_Atomic (type-name).\n\t(struct c_declspecs): Add atomic_p field.\n\t(convert_lvalue_to_rvalue): Declare.\n\t* c-typeck.c (c_type_promotes_to): Promote atomic types to\n\tcorresponding atomic types.\n\t(qualify_type): Don't add _Atomic qualifiers from second argument.\n\t(comp_target_types): Do not allow _Atomic mismatches.\n\t(type_lists_compatible_p): Do not remove atomic qualifiers when\n\tcomparing types.\n\t(really_atomic_lvalue, convert_lvalue_to_rvalue)\n\t(build_atomic_assign): New functions.\n\t(build_unary_op): Use build_atomic_assign for atomic increment and\n\tdecrement.\n\t(build_conditional_expr): Do not treat _Atomic void as a qualified\n\tversion of void.\n\t(build_modify_expr): Use build_atomic_assign for atomic LHS.\n\t(find_anonymous_field_with_type, convert_to_anonymous_field)\n\t(convert_for_assignment): Do not remove atomic qualifiers when\n\tcomparing types.\n\t(digest_init): Do not accept initialization of arrays of atomic\n\telements by string constants.\n\t(build_asm_expr): Use convert_lvalue_to_rvalue.\n\t(build_binary_op): Do not treat _Atomic void as a qualified\n\tversion of void.\n\ngcc/objc:\n2013-11-05  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* objc-act.c (objc_push_parm): Handle atomic qualifier.\n\ngcc/testsuite:\n2013-11-05  Joseph Myers  <joseph@codesourcery.com>\n\n\t* lib/target-supports.exp\n\t(check_effective_target_fenv_exceptions): New function.\n\t* lib/atomic-dg.exp, gcc.dg/atomic/atomic.exp: New files.\n\t* gcc.dg/atomic/c11-atomic-exec-1.c,\n\tgcc.dg/atomic/c11-atomic-exec-2.c,\n\tgcc.dg/atomic/c11-atomic-exec-3.c,\n\tgcc.dg/atomic/c11-atomic-exec-4.c,\n\tgcc.dg/atomic/c11-atomic-exec-5.c, gcc.dg/c11-atomic-1.c,\n\tgcc.dg/c11-atomic-2.c, gcc.dg/c11-atomic-3.c,\n\tgcc.dg/c90-atomic-1.c, gcc.dg/c99-atomic-1.c: New tests.\n\nlibatomic:\n2013-11-05  Joseph Myers  <joseph@codesourcery.com>\n\n\t* fenv.c: New file.\n\t* libatomic.map (LIBATOMIC_1.1): New symbol version.  Include\n\t__atomic_feraiseexcept.\n\t* configure.ac (libtool_VERSION): Change to 2:0:1.\n\t(fenv.h): Test for header.\n\t* Makefile.am (libatomic_la_SOURCES): Add fenv.c.\n\t* Makefile.in, auto-config.h.in, configure: Regenerate.\n\nFrom-SVN: r204544", "tree": {"sha": "b7c9a4da58703fc4f909e241272dfbc85c92459e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7c9a4da58703fc4f909e241272dfbc85c92459e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/267bac1078ce623767a9effa063d5b63fbbeb6ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267bac1078ce623767a9effa063d5b63fbbeb6ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/267bac1078ce623767a9effa063d5b63fbbeb6ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267bac1078ce623767a9effa063d5b63fbbeb6ca/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07cb5010c806d4d41d4ecf06acab9306a3d4cdc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07cb5010c806d4d41d4ecf06acab9306a3d4cdc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07cb5010c806d4d41d4ecf06acab9306a3d4cdc6"}], "stats": {"total": 3490, "additions": 3337, "deletions": 153}, "files": [{"sha": "23cf4eca02b3de5862e93d0f95cf51b75daf7166", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1,3 +1,48 @@\n+2013-11-07  Andrew MacLeod  <amacleod@redhat.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* tree-core.h (enum cv_qualifier): Add TYPE_QUAL_ATOMIC.\n+\t(enum tree_index): Add TI_ATOMICQI_TYPE, TI_ATOMICHI_TYPE,\n+\tTI_ATOMICSI_TYPE, TI_ATOMICDI_TYPE and TI_ATOMICTI_TYPE.\n+\t(struct tree_base): Add atomic_flag field.\n+\t* tree.h (TYPE_ATOMIC): New accessor macro.\n+\t(TYPE_QUALS, TYPE_QUALS_NO_ADDR_SPACE): Add TYPE_QUAL_ATOMIC.\n+\t(TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC): New macro.\n+\t(atomicQI_type_node, atomicHI_type_node, atomicSI_type_node)\n+\t(atomicDI_type_node, atomicTI_type_node): New macros for type\n+\tnodes.\n+\t* tree.c (set_type_quals): Set TYPE_ATOMIC.\n+\t(find_atomic_core_type): New function.\n+\t(build_qualified_type): Adjust alignment for qualified types.\n+\t(build_atomic_base): New function\n+\t(build_common_tree_nodes): Build atomicQI_type_node,\n+\tatomicHI_type_node, atomicSI_type_node, atomicDI_type_node and\n+\tatomicTI_type_node.\n+\t* print-tree.c (print_node): Print atomic qualifier.\n+\t* tree-pretty-print.c (dump_generic_node): Print atomic type\n+\tattribute.\n+\t* target.def (atomic_assign_expand_fenv): New hook.\n+\t* doc/tm.texi.in (TARGET_ATOMIC_ASSIGN_EXPAND_FENV): New @hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_atomic_assign_expand_fenv): New function.\n+\t* targhooks.h (default_atomic_assign_expand_fenv): Declare.\n+\t* sync-builtins.def (__atomic_feraiseexcept): New built-in\n+\tfunction.\n+\t* config/i386/i386-builtin-types.def (VOID_FTYPE_PUSHORT): New\n+\tfunction type.\n+\t* config/i386/i386.c (enum ix86_builtins): Add\n+\tIX86_BUILTIN_FNSTENV, IX86_BUILTIN_FLDENV, IX86_BUILTIN_FNSTSW and\n+\tIX86_BUILTIN_FNCLEX.\n+\t(bdesc_special_args): Add __builtin_ia32_fnstenv,\n+\t__builtin_ia32_fldenv, __builtin_ia32_fnstsw and\n+\t__builtin_ia32_fnclex.\n+\t(ix86_expand_builtin): Handle the new built-in functions.\n+\t(ix86_atomic_assign_expand_fenv): New function.\n+\t(TARGET_ATOMIC_ASSIGN_EXPAND_FENV): New macro.\n+\t* config/i386/i386.md (UNSPECV_FNSTENV, UNSPECV_FLDENV)\n+\t(UNSPECV_FNSTSW, UNSPECV_FNCLEX): New unspecs.\n+\t(fnstenv, fldenv, fnstsw, fnclex): New insns.\n+\n 2013-11-07  Steve Ellcey  <sellcey@mips.com>\n \n \t* config/mips/mti-linux.h (SYSROOT_SUFFIX_SPEC): Add fp64 directory."}, {"sha": "4ff4310e8b65b50866f52bba821dd7f101d5a99a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1,3 +1,15 @@\n+2013-11-07  Andrew MacLeod  <amacleod@redhat.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-common.h (enum rid): Add RID_ATOMIC.\n+\t* c-common.c (c_common_reswords): Add _Atomic.\n+\t(sync_resolve_params): Use TYPE_MAIN_VARIANT on pointer argument.\n+\t(keyword_is_type_qualifier): Accept RID_ATOMIC.\n+\t* c-format.c (check_format_types): Check for extra _Atomic\n+\tqualifiers in format argument.\n+\t* c-pretty-print.c (pp_c_cv_qualifiers): Handle atomic qualifier.\n+\t(pp_c_type_qualifier_list): Mention _Atomic in comment.\n+\n 2013-11-06  Tobias Burnus  <burnus@net-b.de>\n \n \t* c-common.c (reason_option_codes_t): Add CPP_W_DATE_TIME."}, {"sha": "e237926c5733aae8ddab77bdca0ada0a5f0812ca", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -409,6 +409,7 @@ const struct c_common_resword c_common_reswords[] =\n {\n   { \"_Alignas\",\t\tRID_ALIGNAS,   D_CONLY },\n   { \"_Alignof\",\t\tRID_ALIGNOF,   D_CONLY },\n+  { \"_Atomic\",\t\tRID_ATOMIC,    D_CONLY },\n   { \"_Bool\",\t\tRID_BOOL,      D_CONLY },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n   { \"_Cilk_spawn\",      RID_CILK_SPAWN, 0 },\n@@ -10172,6 +10173,7 @@ sync_resolve_params (location_t loc, tree orig_function, tree function,\n      call to check_function_arguments what ever type the user used.  */\n   function_args_iter_next (&iter);\n   ptype = TREE_TYPE (TREE_TYPE ((*params)[0]));\n+  ptype = TYPE_MAIN_VARIANT (ptype);\n \n   /* For the rest of the values, we need to cast these to FTYPE, so that we\n      don't get warnings for passing pointer types, etc.  */\n@@ -11568,6 +11570,7 @@ keyword_is_type_qualifier (enum rid keyword)\n     case RID_CONST:\n     case RID_VOLATILE:\n     case RID_RESTRICT:\n+    case RID_ATOMIC:\n       return true;\n     default:\n       return false;"}, {"sha": "74fd59fb5eedd10fa44ac761a3d15e8650d26333", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -66,7 +66,7 @@ enum rid\n   RID_UNSIGNED, RID_LONG,    RID_CONST, RID_EXTERN,\n   RID_REGISTER, RID_TYPEDEF, RID_SHORT, RID_INLINE,\n   RID_VOLATILE, RID_SIGNED,  RID_AUTO,  RID_RESTRICT,\n-  RID_NORETURN,\n+  RID_NORETURN, RID_ATOMIC,\n \n   /* C extensions */\n   RID_COMPLEX, RID_THREAD, RID_SAT,"}, {"sha": "99cae172a5bd8dbc0585278c66e62cff885c059d", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -2374,6 +2374,7 @@ check_format_types (format_wanted_type *types)\n \t\t  && pedantic\n \t\t  && (TYPE_READONLY (cur_type)\n \t\t      || TYPE_VOLATILE (cur_type)\n+\t\t      || TYPE_ATOMIC (cur_type)\n \t\t      || TYPE_RESTRICT (cur_type)))\n \t\twarning (OPT_Wformat_, \"extra type qualifiers in format \"\n \t\t\t \"argument (argument %d)\","}, {"sha": "652c3a892154e72653266adc43d473887634ae23", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -179,8 +179,16 @@ pp_c_cv_qualifiers (c_pretty_printer *pp, int qualifiers, bool func_type)\n   if (p != NULL && (*p == '*' || *p == '&'))\n     pp_c_whitespace (pp);\n \n+  if (qualifiers & TYPE_QUAL_ATOMIC)\n+    {\n+      pp_c_ws_string (pp, \"_Atomic\");\n+      previous = true;\n+    }\n+\n   if (qualifiers & TYPE_QUAL_CONST)\n     {\n+      if (previous)\n+        pp_c_whitespace (pp);\n       pp_c_ws_string (pp, func_type ? \"__attribute__((const))\" : \"const\");\n       previous = true;\n     }\n@@ -244,6 +252,7 @@ pp_c_space_for_pointer_operator (c_pretty_printer *pp, tree t)\n        __restrict__                          -- GNU C\n        address-space-qualifier\t\t     -- GNU C\n        volatile\n+       _Atomic                               -- C11\n \n    address-space-qualifier:\n        identifier\t\t\t     -- GNU C  */"}, {"sha": "e38bcb8cdbd936ccbdb2397600e502519deb5902", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1,3 +1,72 @@\n+2013-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\t    Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* c-aux-info.c (gen_type): Handle atomic qualifier.\n+\t* c-decl.c (validate_proto_after_old_defn): Do not remove atomic\n+\tqualifiers when compating types.\n+\t(shadow_tag_warned): Handle atomic_p in declspecs.\n+\t(quals_from_declspecs): Likewise.\n+\t(start_decl): Use c_type_promotes_to when promoting argument\n+\ttypes.\n+\t(grokdeclarator): Handle _Atomic.\n+\t(get_parm_info): Diagnose any qualifier on \"void\" as only\n+\tparameter.\n+\t(store_parm_decls_oldstyle): Do not remove atomic qualifiers when\n+\tcomparing types.  Use c_type_promotes_to when promoting argument\n+\ttypes.\n+\t(finish_function): Use c_type_promotes_to when promoting argument\n+\ttypes.\n+\t(build_null_declspecs): Handle atomic_p in declspecs.\n+\t(declspecs_add_qual): Handle RID_ATOMIC.\n+\t* c-parser.c (c_token_starts_typename, c_token_is_qualifier)\n+\t(c_token_starts_declspecs): Handle RID_ATOMIC.\n+\t(c_parser_declspecs): Handle atomic type specifiers and\n+\tqualifiers.\n+\t(c_parser_typeof_specifier): Remove const and _Atomic qualifiers\n+\tfrom types of expressions with atomic type.\n+\t(c_parser_direct_declarator_inner): Use convert_lvalue_to_rvalue.\n+\t(c_parser_attribute_any_word): Handle RID_ATOMIC.\n+\t(c_parser_initializer, c_parser_initelt, c_parser_initval)\n+\t(c_parser_statement_after_labels, c_parser_switch_statement)\n+\t(c_parser_for_statement, c_parser_expr_no_commas)\n+\t(c_parser_conditional_expression, c_parser_binary_expression)\n+\t(c_parser_cast_expression, c_parser_unary_expression)\n+\t(c_parser_postfix_expression)\n+\t(c_parser_postfix_expression_after_primary, c_parser_expression):\n+\tUse convert_lvalue_to_rvalue.\n+\t(c_parser_expression_conv, c_parser_expr_list): Document\n+\tconversion of lvalues to rvalues.  Use convert_lvalue_to_rvalue.\n+\t(c_parser_objc_synchronized_statement): Use\n+\tconvert_lvalue_to_rvalue.\n+\t(c_parser_objc_selector): Handle RID_ATOMIC.\n+\t(c_parser_objc_receiver, c_parser_array_notation): Use\n+\tconvert_lvalue_to_rvalue.\n+\t* c-tree.h (ctsk_typeof): Adjust comment to mention use for\n+\t_Atomic (type-name).\n+\t(struct c_declspecs): Add atomic_p field.\n+\t(convert_lvalue_to_rvalue): Declare.\n+\t* c-typeck.c (c_type_promotes_to): Promote atomic types to\n+\tcorresponding atomic types.\n+\t(qualify_type): Don't add _Atomic qualifiers from second argument.\n+\t(comp_target_types): Do not allow _Atomic mismatches.\n+\t(type_lists_compatible_p): Do not remove atomic qualifiers when\n+\tcomparing types.\n+\t(really_atomic_lvalue, convert_lvalue_to_rvalue)\n+\t(build_atomic_assign): New functions.\n+\t(build_unary_op): Use build_atomic_assign for atomic increment and\n+\tdecrement.\n+\t(build_conditional_expr): Do not treat _Atomic void as a qualified\n+\tversion of void.\n+\t(build_modify_expr): Use build_atomic_assign for atomic LHS.\n+\t(find_anonymous_field_with_type, convert_to_anonymous_field)\n+\t(convert_for_assignment): Do not remove atomic qualifiers when\n+\tcomparing types.\n+\t(digest_init): Do not accept initialization of arrays of atomic\n+\telements by string constants.\n+\t(build_asm_expr): Use convert_lvalue_to_rvalue.\n+\t(build_binary_op): Do not treat _Atomic void as a qualified\n+\tversion of void.\n+\n 2013-11-06  DJ Delorie  <dj@redhat.com>\n \n \t* c-decl.c (locate_old_decl): If a previous conflicting decl is"}, {"sha": "823a3c49f6f926a0e18e60eae0a028063b021380", "filename": "gcc/c/c-aux-info.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-aux-info.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -285,6 +285,8 @@ gen_type (const char *ret_val, tree t, formals_style style)\n       switch (TREE_CODE (t))\n \t{\n \tcase POINTER_TYPE:\n+\t  if (TYPE_ATOMIC (t))\n+\t    ret_val = concat (\"_Atomic \", ret_val, NULL);\n \t  if (TYPE_READONLY (t))\n \t    ret_val = concat (\"const \", ret_val, NULL);\n \t  if (TYPE_VOLATILE (t))\n@@ -425,6 +427,8 @@ gen_type (const char *ret_val, tree t, formals_style style)\n \t  gcc_unreachable ();\n \t}\n     }\n+  if (TYPE_ATOMIC (t))\n+    ret_val = concat (\"_Atomic \", ret_val, NULL);\n   if (TYPE_READONLY (t))\n     ret_val = concat (\"const \", ret_val, NULL);\n   if (TYPE_VOLATILE (t))"}, {"sha": "9520e4d2d6ef4644a4d61cf8e913b93b11cc5333", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 97, "deletions": 21, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1584,8 +1584,14 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n       if (oldargtype == error_mark_node || newargtype == error_mark_node)\n \treturn false;\n \n-      oldargtype = TYPE_MAIN_VARIANT (oldargtype);\n-      newargtype = TYPE_MAIN_VARIANT (newargtype);\n+      oldargtype = (TYPE_ATOMIC (oldargtype)\n+\t\t    ? c_build_qualified_type (TYPE_MAIN_VARIANT (oldargtype),\n+\t\t\t\t\t      TYPE_QUAL_ATOMIC)\n+\t\t    : TYPE_MAIN_VARIANT (oldargtype));\n+      newargtype = (TYPE_ATOMIC (newargtype)\n+\t\t    ? c_build_qualified_type (TYPE_MAIN_VARIANT (newargtype),\n+\t\t\t\t\t      TYPE_QUAL_ATOMIC)\n+\t\t    : TYPE_MAIN_VARIANT (newargtype));\n \n       if (END_OF_ARGLIST (oldargtype) && END_OF_ARGLIST (newargtype))\n \tbreak;\n@@ -3715,6 +3721,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n                    && declspecs->typespec_kind != ctsk_tagfirstref\n \t\t   && (declspecs->const_p\n \t\t       || declspecs->volatile_p\n+\t\t       || declspecs->atomic_p\n \t\t       || declspecs->restrict_p\n \t\t       || declspecs->address_space))\n \t    {\n@@ -3804,6 +3811,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \n   if (!warned && !in_system_header && (declspecs->const_p\n \t\t\t\t       || declspecs->volatile_p\n+\t\t\t\t       || declspecs->atomic_p\n \t\t\t\t       || declspecs->restrict_p\n \t\t\t\t       || declspecs->address_space))\n     {\n@@ -3835,6 +3843,7 @@ quals_from_declspecs (const struct c_declspecs *specs)\n   int quals = ((specs->const_p ? TYPE_QUAL_CONST : 0)\n \t       | (specs->volatile_p ? TYPE_QUAL_VOLATILE : 0)\n \t       | (specs->restrict_p ? TYPE_QUAL_RESTRICT : 0)\n+\t       | (specs->atomic_p ? TYPE_QUAL_ATOMIC : 0)\n \t       | (ENCODE_QUAL_ADDR_SPACE (specs->address_space)));\n   gcc_assert (!specs->type\n \t      && !specs->decl_attr\n@@ -4170,7 +4179,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \t      tree type = TREE_TYPE (args);\n \t      if (type && INTEGRAL_TYPE_P (type)\n \t\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-\t\tDECL_ARG_TYPE (args) = integer_type_node;\n+\t\tDECL_ARG_TYPE (args) = c_type_promotes_to (type);\n \t    }\n \t}\n     }\n@@ -4943,6 +4952,7 @@ grokdeclarator (const struct c_declarator *declarator,\n   int constp;\n   int restrictp;\n   int volatilep;\n+  int atomicp;\n   int type_quals = TYPE_UNQUALIFIED;\n   tree name = NULL_TREE;\n   bool funcdef_flag = false;\n@@ -5097,6 +5107,7 @@ grokdeclarator (const struct c_declarator *declarator,\n   constp = declspecs->const_p + TYPE_READONLY (element_type);\n   restrictp = declspecs->restrict_p + TYPE_RESTRICT (element_type);\n   volatilep = declspecs->volatile_p + TYPE_VOLATILE (element_type);\n+  atomicp = declspecs->atomic_p + TYPE_ATOMIC (element_type);\n   as1 = declspecs->address_space;\n   as2 = TYPE_ADDR_SPACE (element_type);\n   address_space = ADDR_SPACE_GENERIC_P (as1)? as2 : as1;\n@@ -5109,6 +5120,9 @@ grokdeclarator (const struct c_declarator *declarator,\n \tpedwarn (loc, OPT_Wpedantic, \"duplicate %<restrict%>\");\n       if (volatilep > 1)\n \tpedwarn (loc, OPT_Wpedantic, \"duplicate %<volatile%>\");\n+      if (atomicp > 1)\n+\tpedwarn (loc, OPT_Wpedantic, \"duplicate %<_Atomic%>\");\n+\n     }\n \n   if (!ADDR_SPACE_GENERIC_P (as1) && !ADDR_SPACE_GENERIC_P (as2) && as1 != as2)\n@@ -5122,8 +5136,16 @@ grokdeclarator (const struct c_declarator *declarator,\n   type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n \t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n \t\t| (volatilep ? TYPE_QUAL_VOLATILE : 0)\n+\t\t| (atomicp ? TYPE_QUAL_ATOMIC : 0)\n \t\t| ENCODE_QUAL_ADDR_SPACE (address_space));\n \n+  /* Applying the _Atomic qualifier to an array type (through the use\n+     of typedefs or typeof) must be detected here.  If the qualifier\n+     is introduced later, any appearance of applying it to an array is\n+     actually applying it to an element of that array.  */\n+  if (atomicp && TREE_CODE (type) == ARRAY_TYPE)\n+    error_at (loc, \"%<_Atomic%>-qualified array type\");\n+\n   /* Warn about storage classes that are invalid for certain\n      kinds of declarations (parameters, typenames, etc.).  */\n \n@@ -5699,9 +5721,15 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  {\n \t    /* Merge any constancy or volatility into the target type\n \t       for the pointer.  */\n-\n-\t    if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n-\t\t&& type_quals)\n+\t    if ((type_quals & TYPE_QUAL_ATOMIC)\n+\t\t&& TREE_CODE (type) == FUNCTION_TYPE)\n+\t      {\n+\t\terror_at (loc,\n+\t\t\t  \"%<_Atomic%>-qualified function type\");\n+\t\ttype_quals &= ~TYPE_QUAL_ATOMIC;\n+\t      }\n+\t    else if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n+\t\t     && type_quals)\n \t      pedwarn (loc, OPT_Wpedantic,\n \t\t       \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n@@ -5815,7 +5843,20 @@ grokdeclarator (const struct c_declarator *declarator,\n \n   /* Check the type and width of a bit-field.  */\n   if (bitfield)\n-    check_bitfield_type_and_width (&type, width, name);\n+    {\n+      check_bitfield_type_and_width (&type, width, name);\n+      /* C11 makes it implementation-defined (6.7.2.1#5) whether\n+\t atomic types are permitted for bit-fields; we have no code to\n+\t make bit-field accesses atomic, so disallow them.  */\n+      if (type_quals & TYPE_QUAL_ATOMIC)\n+\t{\n+\t  if (name)\n+\t    error (\"bit-field %qE has atomic type\", name);\n+\t  else\n+\t    error (\"bit-field has atomic type\");\n+\t  type_quals &= ~TYPE_QUAL_ATOMIC;\n+\t}\n+    }\n \n   /* Reject invalid uses of _Alignas.  */\n   if (declspecs->alignas_p)\n@@ -5878,8 +5919,15 @@ grokdeclarator (const struct c_declarator *declarator,\n   if (storage_class == csc_typedef)\n     {\n       tree decl;\n-      if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n-\t  && type_quals)\n+      if ((type_quals & TYPE_QUAL_ATOMIC)\n+\t  && TREE_CODE (type) == FUNCTION_TYPE)\n+\t{\n+\t  error_at (loc,\n+\t\t    \"%<_Atomic%>-qualified function type\");\n+\t  type_quals &= ~TYPE_QUAL_ATOMIC;\n+\t}\n+      else if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n+\t       && type_quals)\n \tpedwarn (loc, OPT_Wpedantic,\n \t\t \"ISO C forbids qualified function types\");\n       if (type_quals)\n@@ -5924,8 +5972,15 @@ grokdeclarator (const struct c_declarator *declarator,\n \t and fields.  */\n       gcc_assert (storage_class == csc_none && !threadp\n \t\t  && !declspecs->inline_p && !declspecs->noreturn_p);\n-      if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n-\t  && type_quals)\n+      if ((type_quals & TYPE_QUAL_ATOMIC)\n+\t  && TREE_CODE (type) == FUNCTION_TYPE)\n+\t{\n+\t  error_at (loc,\n+\t\t    \"%<_Atomic%>-qualified function type\");\n+\t  type_quals &= ~TYPE_QUAL_ATOMIC;\n+\t}\n+      else if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n+\t       && type_quals)\n \tpedwarn (loc, OPT_Wpedantic,\n \t\t \"ISO C forbids const or volatile function types\");\n       if (type_quals)\n@@ -5991,7 +6046,13 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n-\t    if (type_quals)\n+\t    if (type_quals & TYPE_QUAL_ATOMIC)\n+\t      {\n+\t\terror_at (loc,\n+\t\t\t  \"%<_Atomic%>-qualified function type\");\n+\t\ttype_quals &= ~TYPE_QUAL_ATOMIC;\n+\t      }\n+\t    else if (type_quals)\n \t      pedwarn (loc, OPT_Wpedantic,\n \t\t       \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n@@ -6086,7 +6147,13 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t\t   FUNCTION_DECL, declarator->u.id, type);\n \tdecl = build_decl_attribute_variant (decl, decl_attr);\n \n-\tif (pedantic && type_quals && !DECL_IN_SYSTEM_HEADER (decl))\n+\tif (type_quals & TYPE_QUAL_ATOMIC)\n+\t  {\n+\t    error_at (loc,\n+\t\t      \"%<_Atomic%>-qualified function type\");\n+\t    type_quals &= ~TYPE_QUAL_ATOMIC;\n+\t  }\n+\telse if (pedantic && type_quals && !DECL_IN_SYSTEM_HEADER (decl))\n \t  pedwarn (loc, OPT_Wpedantic,\n \t\t   \"ISO C forbids qualified function types\");\n \n@@ -6459,8 +6526,7 @@ get_parm_info (bool ellipsis, tree expr)\n       && !DECL_NAME (b->decl)               /* anonymous */\n       && VOID_TYPE_P (TREE_TYPE (b->decl))) /* of void type */\n     {\n-      if (TREE_THIS_VOLATILE (b->decl)\n-\t  || TREE_READONLY (b->decl)\n+      if (TYPE_QUALS (TREE_TYPE (b->decl)) != TYPE_UNQUALIFIED\n \t  || C_DECL_REGISTER (b->decl))\n \terror (\"%<void%> as only parameter may not be qualified\");\n \n@@ -8213,11 +8279,15 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t     type for parameters declared with qualified type.  */\n \t  if (TREE_TYPE (parm) != error_mark_node\n \t      && TREE_TYPE (type) != error_mark_node\n-\t      && !comptypes (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parm)),\n-\t\t\t     TYPE_MAIN_VARIANT (TREE_VALUE (type))))\n+\t      && ((TYPE_ATOMIC (DECL_ARG_TYPE (parm))\n+\t\t   != TYPE_ATOMIC (TREE_VALUE (type)))\n+\t\t  || !comptypes (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parm)),\n+\t\t\t\t TYPE_MAIN_VARIANT (TREE_VALUE (type)))))\n \t    {\n-\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (parm))\n-\t\t  == TYPE_MAIN_VARIANT (TREE_VALUE (type)))\n+\t      if ((TYPE_ATOMIC (DECL_ARG_TYPE (parm))\n+\t\t   == TYPE_ATOMIC (TREE_VALUE (type)))\n+\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (parm))\n+\t\t      == TYPE_MAIN_VARIANT (TREE_VALUE (type))))\n \t\t{\n \t\t  /* Adjust argument to match prototype.  E.g. a previous\n \t\t     `int foo(float);' prototype causes\n@@ -8230,7 +8300,8 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t\t      && INTEGRAL_TYPE_P (TREE_TYPE (parm))\n \t\t      && TYPE_PRECISION (TREE_TYPE (parm))\n \t\t      < TYPE_PRECISION (integer_type_node))\n-\t\t    DECL_ARG_TYPE (parm) = integer_type_node;\n+\t\t    DECL_ARG_TYPE (parm)\n+\t\t      = c_type_promotes_to (TREE_TYPE (parm));\n \n \t\t  /* ??? Is it possible to get here with a\n \t\t     built-in prototype or will it always have\n@@ -8432,7 +8503,7 @@ finish_function (void)\n \t  tree type = TREE_TYPE (args);\n \t  if (INTEGRAL_TYPE_P (type)\n \t      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-\t    DECL_ARG_TYPE (args) = integer_type_node;\n+\t    DECL_ARG_TYPE (args) = c_type_promotes_to (type);\n \t}\n     }\n \n@@ -8911,6 +8982,7 @@ build_null_declspecs (void)\n   ret->thread_p = false;\n   ret->const_p = false;\n   ret->volatile_p = false;\n+  ret->atomic_p = false;\n   ret->restrict_p = false;\n   ret->saturating_p = false;\n   ret->alignas_p = false;\n@@ -8972,6 +9044,10 @@ declspecs_add_qual (source_location loc,\n       specs->restrict_p = true;\n       specs->locations[cdw_restrict] = loc;\n       break;\n+    case RID_ATOMIC:\n+      dupe = specs->atomic_p;\n+      specs->atomic_p = true;\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "09cce1c092430ffdb244ba287594851caf0b69e6", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 170, "deletions": 57, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -494,6 +494,7 @@ c_token_starts_typename (c_token *token)\n \tcase RID_UNION:\n \tcase RID_TYPEOF:\n \tcase RID_CONST:\n+\tcase RID_ATOMIC:\n \tcase RID_VOLATILE:\n \tcase RID_RESTRICT:\n \tcase RID_ATTRIBUTE:\n@@ -576,6 +577,7 @@ c_token_is_qualifier (c_token *token)\n \tcase RID_VOLATILE:\n \tcase RID_RESTRICT:\n \tcase RID_ATTRIBUTE:\n+\tcase RID_ATOMIC:\n \t  return true;\n \tdefault:\n \t  return false;\n@@ -656,6 +658,7 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_ACCUM:\n \tcase RID_SAT:\n \tcase RID_ALIGNAS:\n+\tcase RID_ATOMIC:\n \t  return true;\n \tdefault:\n \t  return false;\n@@ -1991,8 +1994,10 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n      struct-or-union-specifier\n      enum-specifier\n      typedef-name\n+     atomic-type-specifier\n \n    (_Bool and _Complex are new in C99.)\n+   (atomic-type-specifier is new in C11.)\n \n    C90 6.5.3, C99 6.7.3:\n \n@@ -2001,8 +2006,10 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n      restrict\n      volatile\n      address-space-qualifier\n+     _Atomic\n \n    (restrict is new in C99.)\n+   (_Atomic is new in C11.)\n \n    GNU extensions:\n \n@@ -2031,6 +2038,9 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n   (_Fract, _Accum, and _Sat are new from ISO/IEC DTR 18037:\n    http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1169.pdf)\n \n+   atomic-type-specifier\n+    _Atomic ( type-name )\n+\n    Objective-C:\n \n    type-specifier:\n@@ -2224,6 +2234,64 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  t = c_parser_typeof_specifier (parser);\n \t  declspecs_add_type (loc, specs, t);\n \t  break;\n+\tcase RID_ATOMIC:\n+\t  /* C parser handling of Objective-C constructs needs\n+\t     checking for correct lvalue-to-rvalue conversions, and\n+\t     the code in build_modify_expr handling various\n+\t     Objective-C cases, and that in build_unary_op handling\n+\t     Objective-C cases for increment / decrement, also needs\n+\t     updating; uses of TYPE_MAIN_VARIANT in objc_compare_types\n+\t     and objc_types_are_equivalent may also need updates.  */\n+\t  if (c_dialect_objc ())\n+\t    sorry (\"%<_Atomic%> in Objective-C\");\n+\t  /* C parser handling of OpenMP constructs needs checking for\n+\t     correct lvalue-to-rvalue conversions.  */\n+\t  if (flag_openmp)\n+\t    sorry (\"%<_Atomic%> with OpenMP\");\n+\t  if (!flag_isoc11)\n+\t    {\n+\t      if (flag_isoc99)\n+\t\tpedwarn (loc, OPT_Wpedantic,\n+\t\t\t \"ISO C99 does not support the %<_Atomic%> qualifier\");\n+\t      else\n+\t\tpedwarn (loc, OPT_Wpedantic,\n+\t\t\t \"ISO C90 does not support the %<_Atomic%> qualifier\");\n+\t    }\n+\t  attrs_ok = true;\n+\t  tree value;\n+\t  value = c_parser_peek_token (parser)->value;\n+\t  c_parser_consume_token (parser);\n+\t  if (typespec_ok && c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+\t    {\n+\t      /* _Atomic ( type-name ).  */\n+\t      seen_type = true;\n+\t      c_parser_consume_token (parser);\n+\t      struct c_type_name *type = c_parser_type_name (parser);\n+\t      t.kind = ctsk_typeof;\n+\t      t.spec = error_mark_node;\n+\t      t.expr = NULL_TREE;\n+\t      t.expr_const_operands = true;\n+\t      if (type != NULL)\n+\t\tt.spec = groktypename (type, &t.expr,\n+\t\t\t\t       &t.expr_const_operands);\n+\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t\t \"expected %<)%>\");\n+\t      if (t.spec != error_mark_node)\n+\t\t{\n+\t\t  if (TREE_CODE (t.spec) == ARRAY_TYPE)\n+\t\t    error_at (loc, \"%<_Atomic%>-qualified array type\");\n+\t\t  else if (TREE_CODE (t.spec) == FUNCTION_TYPE)\n+\t\t    error_at (loc, \"%<_Atomic%>-qualified function type\");\n+\t\t  else if (TYPE_QUALS (t.spec) != TYPE_UNQUALIFIED)\n+\t\t    error_at (loc, \"%<_Atomic%> applied to a qualified type\");\n+\t\t  else\n+\t\t    t.spec = c_build_qualified_type (t.spec, TYPE_QUAL_ATOMIC);\n+\t\t}\n+\t      declspecs_add_type (loc, specs, t);\n+\t    }\n+\t  else\n+\t    declspecs_add_qual (loc, specs, value);\n+\t  break;\n \tcase RID_CONST:\n \tcase RID_VOLATILE:\n \tcase RID_RESTRICT:\n@@ -2826,6 +2894,16 @@ c_parser_typeof_specifier (c_parser *parser)\n       if (was_vm)\n \tret.expr = c_fully_fold (expr.value, false, &ret.expr_const_operands);\n       pop_maybe_used (was_vm);\n+      /* For use in macros such as those in <stdatomic.h>, remove\n+\t _Atomic and const qualifiers from atomic types.  (Possibly\n+\t all qualifiers should be removed; const can be an issue for\n+\t more macros using typeof than just the <stdatomic.h>\n+\t ones.)  */\n+      if (ret.spec != error_mark_node && TYPE_ATOMIC (ret.spec))\n+\tret.spec = c_build_qualified_type (ret.spec,\n+\t\t\t\t\t   (TYPE_QUALS (ret.spec)\n+\t\t\t\t\t    & ~(TYPE_QUAL_ATOMIC\n+\t\t\t\t\t\t| TYPE_QUAL_CONST)));\n     }\n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n   return ret;\n@@ -3114,7 +3192,10 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n       struct c_declspecs *quals_attrs = build_null_declspecs ();\n       bool static_seen;\n       bool star_seen;\n-      tree dimen;\n+      struct c_expr dimen;\n+      dimen.value = NULL_TREE;\n+      dimen.original_code = ERROR_MARK;\n+      dimen.original_type = NULL_TREE;\n       c_parser_consume_token (parser);\n       c_parser_declspecs (parser, quals_attrs, false, false, true,\n \t\t\t  false, cla_prefer_id);\n@@ -3132,19 +3213,19 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n       if (static_seen)\n \t{\n \t  star_seen = false;\n-\t  dimen = c_parser_expr_no_commas (parser, NULL).value;\n+\t  dimen = c_parser_expr_no_commas (parser, NULL);\n \t}\n       else\n \t{\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \t    {\n-\t      dimen = NULL_TREE;\n+\t      dimen.value = NULL_TREE;\n \t      star_seen = false;\n \t    }\n \t  else if (flag_enable_cilkplus\n \t\t   && c_parser_next_token_is (parser, CPP_COLON))\n \t    {\n-\t      dimen = error_mark_node;\n+\t      dimen.value = error_mark_node;\n \t      star_seen = false;\n \t      error_at (c_parser_peek_token (parser)->location,\n \t\t\t\"array notations cannot be used in declaration\");\n@@ -3154,20 +3235,20 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t    {\n \t      if (c_parser_peek_2nd_token (parser)->type == CPP_CLOSE_SQUARE)\n \t\t{\n-\t\t  dimen = NULL_TREE;\n+\t\t  dimen.value = NULL_TREE;\n \t\t  star_seen = true;\n \t\t  c_parser_consume_token (parser);\n \t\t}\n \t      else\n \t\t{\n \t\t  star_seen = false;\n-\t\t  dimen = c_parser_expr_no_commas (parser, NULL).value;\n+\t\t  dimen = c_parser_expr_no_commas (parser, NULL);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      star_seen = false;\n-\t      dimen = c_parser_expr_no_commas (parser, NULL).value;\n+\t      dimen = c_parser_expr_no_commas (parser, NULL);\n \t    }\n \t}\n       if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n@@ -3186,9 +3267,9 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t\t\t\t     \"expected %<]%>\");\n \t  return NULL;\n \t}\n-      if (dimen)\n-\tmark_exp_read (dimen);\n-      declarator = build_array_declarator (brace_loc, dimen, quals_attrs,\n+      if (dimen.value)\n+\tdimen = convert_lvalue_to_rvalue (brace_loc, dimen, true, true);\n+      declarator = build_array_declarator (brace_loc, dimen.value, quals_attrs,\n \t\t\t\t\t   static_seen, star_seen);\n       if (declarator == NULL)\n \treturn NULL;\n@@ -3558,6 +3639,7 @@ c_parser_attribute_any_word (c_parser *parser)\n \tcase RID_SAT:\n \tcase RID_TRANSACTION_ATOMIC:\n \tcase RID_TRANSACTION_CANCEL:\n+\tcase RID_ATOMIC:\n \t  ok = true;\n \t  break;\n \tdefault:\n@@ -3814,7 +3896,7 @@ c_parser_initializer (c_parser *parser)\n       ret = c_parser_expr_no_commas (parser, NULL);\n       if (TREE_CODE (ret.value) != STRING_CST\n \t  && TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR)\n-\tret = default_function_array_read_conversion (loc, ret);\n+\tret = convert_lvalue_to_rvalue (loc, ret, true, true);\n       return ret;\n     }\n }\n@@ -3993,8 +4075,8 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t\t      c_parser_consume_token (parser);\n \t\t      exp_loc = c_parser_peek_token (parser)->location;\n \t\t      next = c_parser_expr_no_commas (parser, NULL);\n-\t\t      next = default_function_array_read_conversion (exp_loc,\n-\t\t\t\t\t\t\t\t     next);\n+\t\t      next = convert_lvalue_to_rvalue (exp_loc, next,\n+\t\t\t\t\t\t       true, true);\n \t\t      rec = build_compound_expr (comma_loc, rec, next.value);\n \t\t    }\n \t\tparse_message_args:\n@@ -4090,7 +4172,7 @@ c_parser_initval (c_parser *parser, struct c_expr *after,\n       if (init.value != NULL_TREE\n \t  && TREE_CODE (init.value) != STRING_CST\n \t  && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)\n-\tinit = default_function_array_read_conversion (loc, init);\n+\tinit = convert_lvalue_to_rvalue (loc, init, true, true);\n     }\n   process_init_element (init, false, braced_init_obstack);\n }\n@@ -4605,12 +4687,12 @@ c_parser_statement_after_labels (c_parser *parser)\n \t    }\n \t  else if (c_parser_next_token_is (parser, CPP_MULT))\n \t    {\n-\t      tree val;\n+\t      struct c_expr val;\n \n \t      c_parser_consume_token (parser);\n-\t      val = c_parser_expression (parser).value;\n-\t      mark_exp_read (val);\n-\t      stmt = c_finish_goto_ptr (loc, val);\n+\t      val = c_parser_expression (parser);\n+\t      val = convert_lvalue_to_rvalue (loc, val, false, true);\n+\t      stmt = c_finish_goto_ptr (loc, val.value);\n \t    }\n \t  else\n \t    c_parser_error (parser, \"expected identifier or %<*%>\");\n@@ -4659,9 +4741,10 @@ c_parser_statement_after_labels (c_parser *parser)\n \t    }\n \t  else\n \t    {\n-\t      tree expr = c_parser_expression (parser).value;\n-\t      expr = c_fully_fold (expr, false, NULL);\n-\t      stmt = objc_build_throw_stmt (loc, expr);\n+\t      struct c_expr expr = c_parser_expression (parser);\n+\t      expr = convert_lvalue_to_rvalue (loc, expr, false, false);\n+\t      expr.value = c_fully_fold (expr.value, false, NULL);\n+\t      stmt = objc_build_throw_stmt (loc, expr.value);\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -4873,6 +4956,7 @@ c_parser_if_statement (c_parser *parser)\n static void\n c_parser_switch_statement (c_parser *parser)\n {\n+  struct c_expr ce;\n   tree block, expr, body, save_break;\n   location_t switch_loc = c_parser_peek_token (parser)->location;\n   location_t switch_cond_loc;\n@@ -4882,7 +4966,9 @@ c_parser_switch_statement (c_parser *parser)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       switch_cond_loc = c_parser_peek_token (parser)->location;\n-      expr = c_parser_expression (parser).value;\n+      ce = c_parser_expression (parser);\n+      ce = convert_lvalue_to_rvalue (switch_cond_loc, ce, true, false);\n+      expr = ce.value;\n       if (flag_enable_cilkplus && contains_array_notation_expr (expr))\n \t{\n \t  error_at (switch_cond_loc,\n@@ -5135,8 +5221,10 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n \t{\n \tinit_expr:\n \t  {\n+\t    struct c_expr ce;\n \t    tree init_expression;\n-\t    init_expression = c_parser_expression (parser).value;\n+\t    ce = c_parser_expression (parser);\n+\t    init_expression = ce.value;\n \t    parser->objc_could_be_foreach_context = false;\n \t    if (c_parser_next_token_is_keyword (parser, RID_IN))\n \t      {\n@@ -5148,6 +5236,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n \t      }\n \t    else\n \t      {\n+\t\tce = convert_lvalue_to_rvalue (loc, ce, true, false);\n+\t\tinit_expression = ce.value;\n \t\tc_finish_expr_stmt (loc, init_expression);\n \t\tc_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t      }\n@@ -5208,7 +5298,11 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n \t    collection_expression = c_fully_fold (c_parser_expression (parser).value,\n \t\t\t\t\t\t  false, NULL);\n \t  else\n-\t    incr = c_process_expr_stmt (loc, c_parser_expression (parser).value);\n+\t    {\n+\t      struct c_expr ce = c_parser_expression (parser);\n+\t      ce = convert_lvalue_to_rvalue (loc, ce, true, false);\n+\t      incr = c_process_expr_stmt (loc, ce.value);\n+\t    }\n \t}\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n@@ -5565,7 +5659,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after,\n   c_parser_consume_token (parser);\n   exp_location = c_parser_peek_token (parser)->location;\n   rhs = c_parser_expr_no_commas (parser, NULL);\n-  rhs = default_function_array_read_conversion (exp_location, rhs);\n+  rhs = convert_lvalue_to_rvalue (exp_location, rhs, true, true);\n   \n   ret.value = build_modify_expr (op_location, lhs.value, lhs.original_type,\n \t\t\t\t code, exp_location, rhs.value,\n@@ -5609,7 +5703,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after,\n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n   cond_loc = c_parser_peek_token (parser)->location;\n-  cond = default_function_array_read_conversion (cond_loc, cond);\n+  cond = convert_lvalue_to_rvalue (cond_loc, cond, true, true);\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n@@ -5657,7 +5751,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after,\n   {\n     location_t exp2_loc = c_parser_peek_token (parser)->location;\n     exp2 = c_parser_conditional_expression (parser, NULL, NULL_TREE);\n-    exp2 = default_function_array_read_conversion (exp2_loc, exp2);\n+    exp2 = convert_lvalue_to_rvalue (exp2_loc, exp2, true, true);\n   }\n   c_inhibit_evaluation_warnings -= cond.value == truthvalue_true_node;\n   ret.value = build_conditional_expr (colon_loc, cond.value,\n@@ -5801,11 +5895,11 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n \tbreak;\t\t\t\t\t\t\t\t      \\\n       }\t\t\t\t\t\t\t\t\t      \\\n     stack[sp - 1].expr\t\t\t\t\t\t\t      \\\n-      = default_function_array_read_conversion (stack[sp - 1].loc,\t      \\\n-\t\t\t\t\t\tstack[sp - 1].expr);\t      \\\n+      = convert_lvalue_to_rvalue (stack[sp - 1].loc,\t\t\t      \\\n+\t\t\t\t  stack[sp - 1].expr, true, true);\t      \\\n     stack[sp].expr\t\t\t\t\t\t\t      \\\n-      = default_function_array_read_conversion (stack[sp].loc,\t\t      \\\n-\t\t\t\t\t\tstack[sp].expr);\t      \\\n+      = convert_lvalue_to_rvalue (stack[sp].loc,\t\t\t      \\\n+\t\t\t\t  stack[sp].expr, true, true);\t\t      \\\n     if (__builtin_expect (omp_atomic_lhs != NULL_TREE, 0) && sp == 1\t      \\\n \t&& c_parser_peek_token (parser)->type == CPP_SEMICOLON\t\t      \\\n \t&& ((1 << stack[sp].prec)\t\t\t\t\t      \\\n@@ -5924,17 +6018,17 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n \t{\n \tcase TRUTH_ANDIF_EXPR:\n \t  stack[sp].expr\n-\t    = default_function_array_read_conversion (stack[sp].loc,\n-\t\t\t\t\t\t      stack[sp].expr);\n+\t    = convert_lvalue_to_rvalue (stack[sp].loc,\n+\t\t\t\t\tstack[sp].expr, true, true);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  c_inhibit_evaluation_warnings += (stack[sp].expr.value\n \t\t\t\t\t    == truthvalue_false_node);\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n \t  stack[sp].expr\n-\t    = default_function_array_read_conversion (stack[sp].loc,\n-\t\t\t\t\t\t      stack[sp].expr);\n+\t    = convert_lvalue_to_rvalue (stack[sp].loc,\n+\t\t\t\t\tstack[sp].expr, true, true);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  c_inhibit_evaluation_warnings += (stack[sp].expr.value\n@@ -6005,7 +6099,7 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       {\n \tlocation_t expr_loc = c_parser_peek_token (parser)->location;\n \texpr = c_parser_cast_expression (parser, NULL);\n-\texpr = default_function_array_read_conversion (expr_loc, expr);\n+\texpr = convert_lvalue_to_rvalue (expr_loc, expr, true, true);\n       }\n       ret.value = c_cast_expr (cast_loc, type_name, expr.value);\n       ret.original_code = ERROR_MARK;\n@@ -6096,7 +6190,7 @@ c_parser_unary_expression (c_parser *parser)\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_read_conversion (exp_loc, op);\n+      op = convert_lvalue_to_rvalue (exp_loc, op, true, true);\n       ret.value = build_indirect_ref (op_loc, op.value, RO_UNARY_STAR);\n       return ret;\n     case CPP_PLUS:\n@@ -6107,25 +6201,25 @@ c_parser_unary_expression (c_parser *parser)\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_read_conversion (exp_loc, op);\n+      op = convert_lvalue_to_rvalue (exp_loc, op, true, true);\n       return parser_build_unary_op (op_loc, CONVERT_EXPR, op);\n     case CPP_MINUS:\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_read_conversion (exp_loc, op);\n+      op = convert_lvalue_to_rvalue (exp_loc, op, true, true);\n       return parser_build_unary_op (op_loc, NEGATE_EXPR, op);\n     case CPP_COMPL:\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_read_conversion (exp_loc, op);\n+      op = convert_lvalue_to_rvalue (exp_loc, op, true, true);\n       return parser_build_unary_op (op_loc, BIT_NOT_EXPR, op);\n     case CPP_NOT:\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_read_conversion (exp_loc, op);\n+      op = convert_lvalue_to_rvalue (exp_loc, op, true, true);\n       return parser_build_unary_op (op_loc, TRUTH_NOT_EXPR, op);\n     case CPP_AND_AND:\n       /* Refer to the address of a label as a pointer.  */\n@@ -6918,10 +7012,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t      }\n \t\t    else\n \t\t      {\n+\t\t\tstruct c_expr ce;\n \t\t\ttree idx;\n \t\t\tloc = c_parser_peek_token (parser)->location;\n \t\t\tc_parser_consume_token (parser);\n-\t\t\tidx = c_parser_expression (parser).value;\n+\t\t\tce = c_parser_expression (parser);\n+\t\t\tce = convert_lvalue_to_rvalue (loc, ce, false, false);\n+\t\t\tidx = ce.value;\n \t\t\tidx = c_fully_fold (idx, false, NULL);\n \t\t\tc_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t\t\t   \"expected %<]%>\");\n@@ -7044,11 +7141,11 @@ c_parser_postfix_expression (c_parser *parser)\n \t    e1_p = &(*cexpr_list)[0];\n \t    e2_p = &(*cexpr_list)[1];\n \n-\t    mark_exp_read (e1_p->value);\n+\t    *e1_p = convert_lvalue_to_rvalue (loc, *e1_p, true, true);\n \t    if (TREE_CODE (e1_p->value) == EXCESS_PRECISION_EXPR)\n \t      e1_p->value = convert (TREE_TYPE (e1_p->value),\n \t\t\t\t     TREE_OPERAND (e1_p->value, 0));\n-\t    mark_exp_read (e2_p->value);\n+\t    *e2_p = convert_lvalue_to_rvalue (loc, *e2_p, true, true);\n \t    if (TREE_CODE (e2_p->value) == EXCESS_PRECISION_EXPR)\n \t      e2_p->value = convert (TREE_TYPE (e2_p->value),\n \t\t\t\t     TREE_OPERAND (e2_p->value, 0));\n@@ -7096,7 +7193,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t      }\n \n \t    FOR_EACH_VEC_SAFE_ELT (cexpr_list, i, p)\n-\t      mark_exp_read (p->value);\n+\t      *p = convert_lvalue_to_rvalue (loc, *p, true, true);\n \n \t    if (vec_safe_length (cexpr_list) == 2)\n \t      expr.value =\n@@ -7440,7 +7537,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_DEREF:\n \t  /* Structure element reference.  */\n \t  c_parser_consume_token (parser);\n-\t  expr = default_function_array_conversion (expr_loc, expr);\n+\t  expr = convert_lvalue_to_rvalue (expr_loc, expr, true, false);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    ident = c_parser_peek_token (parser)->value;\n \t  else\n@@ -7518,8 +7615,11 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n static struct c_expr\n c_parser_expression (c_parser *parser)\n {\n+  location_t tloc = c_parser_peek_token (parser)->location;\n   struct c_expr expr;\n   expr = c_parser_expr_no_commas (parser, NULL);\n+  if (c_parser_next_token_is (parser, CPP_COMMA))\n+    expr = convert_lvalue_to_rvalue (tloc, expr, true, false);\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       struct c_expr next;\n@@ -7534,29 +7634,30 @@ c_parser_expression (c_parser *parser)\n       if (DECL_P (lhsval) || handled_component_p (lhsval))\n \tmark_exp_read (lhsval);\n       next = c_parser_expr_no_commas (parser, NULL);\n-      next = default_function_array_conversion (expr_loc, next);\n+      next = convert_lvalue_to_rvalue (expr_loc, next, true, false);\n       expr.value = build_compound_expr (loc, expr.value, next.value);\n       expr.original_code = COMPOUND_EXPR;\n       expr.original_type = next.original_type;\n     }\n   return expr;\n }\n \n-/* Parse an expression and convert functions or arrays to\n-   pointers.  */\n+/* Parse an expression and convert functions or arrays to pointers and\n+   lvalues to rvalues.  */\n \n static struct c_expr\n c_parser_expression_conv (c_parser *parser)\n {\n   struct c_expr expr;\n   location_t loc = c_parser_peek_token (parser)->location;\n   expr = c_parser_expression (parser);\n-  expr = default_function_array_conversion (loc, expr);\n+  expr = convert_lvalue_to_rvalue (loc, expr, true, false);\n   return expr;\n }\n \n /* Parse a non-empty list of expressions.  If CONVERT_P, convert\n-   functions and arrays to pointers.  If FOLD_P, fold the expressions.\n+   functions and arrays to pointers and lvalues to rvalues.  If\n+   FOLD_P, fold the expressions.\n \n    nonempty-expr-list:\n      assignment-expression\n@@ -7586,7 +7687,7 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n     cur_sizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n-    expr = default_function_array_read_conversion (loc, expr);\n+    expr = convert_lvalue_to_rvalue (loc, expr, true, true);\n   if (fold_p)\n     expr.value = c_fully_fold (expr.value, false, NULL);\n   ret->quick_push (expr.value);\n@@ -7610,7 +7711,7 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \tcur_sizeof_arg_loc = UNKNOWN_LOCATION;\n       expr = c_parser_expr_no_commas (parser, NULL);\n       if (convert_p)\n-\texpr = default_function_array_read_conversion (loc, expr);\n+\texpr = convert_lvalue_to_rvalue (loc, expr, true, true);\n       if (fold_p)\n \texpr.value = c_fully_fold (expr.value, false, NULL);\n       vec_safe_push (ret, expr.value);\n@@ -8516,7 +8617,9 @@ c_parser_objc_synchronized_statement (c_parser *parser)\n   objc_maybe_warn_exceptions (loc);\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n-      expr = c_parser_expression (parser).value;\n+      struct c_expr ce = c_parser_expression (parser);\n+      ce = convert_lvalue_to_rvalue (loc, ce, false, false);\n+      expr = ce.value;\n       expr = c_fully_fold (expr, false, NULL);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n@@ -8536,6 +8639,7 @@ c_parser_objc_synchronized_statement (c_parser *parser)\n        break continue return goto asm sizeof typeof __alignof\n        unsigned long const short volatile signed restrict _Complex\n        in out inout bycopy byref oneway int char float double void _Bool\n+       _Atomic\n \n    ??? Why this selection of keywords but not, for example, storage\n    class specifiers?  */\n@@ -8594,6 +8698,7 @@ c_parser_objc_selector (c_parser *parser)\n     case RID_DOUBLE:\n     case RID_VOID:\n     case RID_BOOL:\n+    case RID_ATOMIC:\n       c_parser_consume_token (parser);\n       return value;\n     default:\n@@ -8646,6 +8751,8 @@ c_parser_objc_selector_arg (c_parser *parser)\n static tree\n c_parser_objc_receiver (c_parser *parser)\n {\n+  location_t loc = c_parser_peek_token (parser)->location;\n+\n   if (c_parser_peek_token (parser)->type == CPP_NAME\n       && (c_parser_peek_token (parser)->id_kind == C_ID_TYPENAME\n \t  || c_parser_peek_token (parser)->id_kind == C_ID_CLASSNAME))\n@@ -8654,7 +8761,9 @@ c_parser_objc_receiver (c_parser *parser)\n       c_parser_consume_token (parser);\n       return objc_get_class_reference (id);\n     }\n-  return c_fully_fold (c_parser_expression (parser).value, false, NULL);\n+  struct c_expr ce = c_parser_expression (parser);\n+  ce = convert_lvalue_to_rvalue (loc, ce, false, false);\n+  return c_fully_fold (ce.value, false, NULL);\n }\n \n /* Parse objc-message-args.\n@@ -13441,7 +13550,9 @@ c_parser_array_notation (location_t loc, c_parser *parser, tree initial_index,\n \t      return error_mark_node;\n \t    }\n \t  c_parser_consume_token (parser); /* consume the ':' */\n-\t  end_index = c_parser_expression (parser).value;\n+\t  struct c_expr ce = c_parser_expression (parser);\n+\t  ce = convert_lvalue_to_rvalue (loc, ce, false, false);\n+\t  end_index = ce.value;\n \t  if (!end_index || end_index == error_mark_node)\n \t    {\n \t      c_parser_skip_to_end_of_block_or_statement (parser);\n@@ -13450,7 +13561,9 @@ c_parser_array_notation (location_t loc, c_parser *parser, tree initial_index,\n \t  if (c_parser_peek_token (parser)->type == CPP_COLON)\n \t    {\n \t      c_parser_consume_token (parser);\n-\t      stride = c_parser_expression (parser).value;\n+\t      ce = c_parser_expression (parser);\n+\t      ce = convert_lvalue_to_rvalue (loc, ce, false, false);\n+\t      stride = ce.value;\n \t      if (!stride || stride == error_mark_node)\n \t\t{\n \t\t  c_parser_skip_to_end_of_block_or_statement (parser);"}, {"sha": "8dffa9c16745f031936363783ba9d70bc23291b1", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -163,7 +163,7 @@ enum c_typespec_kind {\n   ctsk_typedef,\n   /* An ObjC-specific kind of type specifier.  */\n   ctsk_objc,\n-  /* A typeof specifier.  */\n+  /* A typeof specifier, or _Atomic ( type-name ).  */\n   ctsk_typeof\n };\n \n@@ -328,6 +328,8 @@ struct c_declspecs {\n   BOOL_BITFIELD volatile_p : 1;\n   /* Whether \"restrict\" was specified.  */\n   BOOL_BITFIELD restrict_p : 1;\n+  /* Whether \"_Atomic\" was specified.  */\n+  BOOL_BITFIELD atomic_p : 1;\n   /* Whether \"_Sat\" was specified.  */\n   BOOL_BITFIELD saturating_p : 1;\n   /* Whether any alignment specifier (even with zero alignment) was\n@@ -585,6 +587,8 @@ extern struct c_expr default_function_array_conversion (location_t,\n \t\t\t\t\t\t\tstruct c_expr);\n extern struct c_expr default_function_array_read_conversion (location_t,\n \t\t\t\t\t\t\t     struct c_expr);\n+extern struct c_expr convert_lvalue_to_rvalue (location_t, struct c_expr,\n+\t\t\t\t\t       bool, bool);\n extern void mark_exp_read (tree);\n extern tree composite_type (tree, tree);\n extern tree build_component_ref (location_t, tree, tree);"}, {"sha": "5ef1f9303f1dc9dae7b79e05216248c3b7996d6f", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 452, "deletions": 61, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -265,18 +265,25 @@ c_incomplete_type_error (const_tree value, const_tree type)\n tree\n c_type_promotes_to (tree type)\n {\n-  if (TYPE_MAIN_VARIANT (type) == float_type_node)\n-    return double_type_node;\n+  tree ret = NULL_TREE;\n \n-  if (c_promoting_integer_type_p (type))\n+  if (TYPE_MAIN_VARIANT (type) == float_type_node)\n+    ret = double_type_node;\n+  else if (c_promoting_integer_type_p (type))\n     {\n       /* Preserve unsignedness if not really getting any wider.  */\n       if (TYPE_UNSIGNED (type)\n \t  && (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)))\n-\treturn unsigned_type_node;\n-      return integer_type_node;\n+\tret = unsigned_type_node;\n+      else\n+\tret = integer_type_node;\n     }\n \n+  if (ret != NULL_TREE)\n+    return (TYPE_ATOMIC (type)\n+\t    ? c_build_qualified_type (ret, TYPE_QUAL_ATOMIC)\n+\t    : ret);\n+\n   return type;\n }\n \n@@ -327,7 +334,7 @@ qualify_type (tree type, tree like)\n \n   return c_build_qualified_type (type,\n \t\t\t\t TYPE_QUALS_NO_ADDR_SPACE (type)\n-\t\t\t\t | TYPE_QUALS_NO_ADDR_SPACE (like)\n+\t\t\t\t | TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (like)\n \t\t\t\t | ENCODE_QUAL_ADDR_SPACE (as_common));\n }\n \n@@ -1214,9 +1221,13 @@ comp_target_types (location_t location, tree ttl, tree ttr)\n   /* Do not lose qualifiers on element types of array types that are\n      pointer targets by taking their TYPE_MAIN_VARIANT.  */\n   if (TREE_CODE (mvl) != ARRAY_TYPE)\n-    mvl = TYPE_MAIN_VARIANT (mvl);\n+    mvl = (TYPE_ATOMIC (mvl)\n+\t   ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvl), TYPE_QUAL_ATOMIC)\n+\t   : TYPE_MAIN_VARIANT (mvl));\n   if (TREE_CODE (mvr) != ARRAY_TYPE)\n-    mvr = TYPE_MAIN_VARIANT (mvr);\n+    mvr = (TYPE_ATOMIC (mvr)\n+\t   ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvr), TYPE_QUAL_ATOMIC)\n+\t   : TYPE_MAIN_VARIANT (mvr));\n   enum_and_int_p = false;\n   val = comptypes_check_enum_int (mvl, mvr, &enum_and_int_p);\n \n@@ -1633,9 +1644,15 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n       mv1 = a1 = TREE_VALUE (args1);\n       mv2 = a2 = TREE_VALUE (args2);\n       if (mv1 && mv1 != error_mark_node && TREE_CODE (mv1) != ARRAY_TYPE)\n-\tmv1 = TYPE_MAIN_VARIANT (mv1);\n+\tmv1 = (TYPE_ATOMIC (mv1)\n+\t       ? c_build_qualified_type (TYPE_MAIN_VARIANT (mv1),\n+\t\t\t\t\t TYPE_QUAL_ATOMIC)\n+\t       : TYPE_MAIN_VARIANT (mv1));\n       if (mv2 && mv2 != error_mark_node && TREE_CODE (mv2) != ARRAY_TYPE)\n-\tmv2 = TYPE_MAIN_VARIANT (mv2);\n+\tmv2 = (TYPE_ATOMIC (mv2)\n+\t       ? c_build_qualified_type (TYPE_MAIN_VARIANT (mv2),\n+\t\t\t\t\t TYPE_QUAL_ATOMIC)\n+\t       : TYPE_MAIN_VARIANT (mv2));\n       /* A null pointer instead of a type\n \t means there is supposed to be an argument\n \t but nothing is specified about what type it has.\n@@ -1678,7 +1695,10 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t\t  tree mv3 = TREE_TYPE (memb);\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n-\t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n+\t\t    mv3 = (TYPE_ATOMIC (mv3)\n+\t\t\t   ? c_build_qualified_type (TYPE_MAIN_VARIANT (mv3),\n+\t\t\t\t\t\t     TYPE_QUAL_ATOMIC)\n+\t\t\t   : TYPE_MAIN_VARIANT (mv3));\n \t\t  if (comptypes_internal (mv3, mv2, enum_and_int_p,\n \t\t\t\t\t  different_types_p))\n \t\t    break;\n@@ -1700,7 +1720,10 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t\t  tree mv3 = TREE_TYPE (memb);\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n-\t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n+\t\t    mv3 = (TYPE_ATOMIC (mv3)\n+\t\t\t   ? c_build_qualified_type (TYPE_MAIN_VARIANT (mv3),\n+\t\t\t\t\t\t     TYPE_QUAL_ATOMIC)\n+\t\t\t   : TYPE_MAIN_VARIANT (mv3));\n \t\t  if (comptypes_internal (mv3, mv1, enum_and_int_p,\n \t\t\t\t\t  different_types_p))\n \t\t    break;\n@@ -1913,6 +1936,84 @@ default_function_array_read_conversion (location_t loc, struct c_expr exp)\n   return default_function_array_conversion (loc, exp);\n }\n \n+/* Return whether EXPR should be treated as an atomic lvalue for the\n+   purposes of load and store handling.  */\n+\n+static bool\n+really_atomic_lvalue (tree expr)\n+{\n+  if (expr == error_mark_node || TREE_TYPE (expr) == error_mark_node)\n+    return false;\n+  if (!TYPE_ATOMIC (TREE_TYPE (expr)))\n+    return false;\n+  if (!lvalue_p (expr))\n+    return false;\n+\n+  /* Ignore _Atomic on register variables, since their addresses can't\n+     be taken so (a) atomicity is irrelevant and (b) the normal atomic\n+     sequences wouldn't work.  Ignore _Atomic on structures containing\n+     bit-fields, since accessing elements of atomic structures or\n+     unions is undefined behavior (C11 6.5.2.3#5), but it's unclear if\n+     it's undefined at translation time or execution time, and the\n+     normal atomic sequences again wouldn't work.  */\n+  while (handled_component_p (expr))\n+    {\n+      if (TREE_CODE (expr) == COMPONENT_REF\n+\t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n+\treturn false;\n+      expr = TREE_OPERAND (expr, 0);\n+    }\n+  if (DECL_P (expr) && C_DECL_REGISTER (expr))\n+    return false;\n+  return true;\n+}\n+\n+/* Convert expression EXP (location LOC) from lvalue to rvalue,\n+   including converting functions and arrays to pointers if CONVERT_P.\n+   If READ_P, also mark the expression as having been read.  */\n+\n+struct c_expr\n+convert_lvalue_to_rvalue (location_t loc, struct c_expr exp,\n+\t\t\t  bool convert_p, bool read_p)\n+{\n+  if (read_p)\n+    mark_exp_read (exp.value);\n+  if (convert_p)\n+    exp = default_function_array_conversion (loc, exp);\n+  if (really_atomic_lvalue (exp.value))\n+    {\n+      vec<tree, va_gc> *params;\n+      tree nonatomic_type, tmp, tmp_addr, fndecl, func_call;\n+      tree expr_type = TREE_TYPE (exp.value);\n+      tree expr_addr = build_unary_op (loc, ADDR_EXPR, exp.value, 0);\n+      tree seq_cst = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n+\n+      gcc_assert (TYPE_ATOMIC (expr_type));\n+\n+      /* Expansion of a generic atomic load may require an addition\n+\t element, so allocate enough to prevent a resize.  */\n+      vec_alloc (params, 4);\n+\n+      /* Remove the qualifiers for the rest of the expressions and\n+\t create the VAL temp variable to hold the RHS.  */\n+      nonatomic_type = build_qualified_type (expr_type, TYPE_UNQUALIFIED);\n+      tmp = create_tmp_var (nonatomic_type, NULL);\n+      tmp_addr = build_unary_op (loc, ADDR_EXPR, tmp, 0);\n+      TREE_ADDRESSABLE (tmp) = 1;\n+\n+      /* Issue __atomic_load (&expr, &tmp, SEQ_CST);  */\n+      fndecl = builtin_decl_explicit (BUILT_IN_ATOMIC_LOAD);\n+      params->quick_push (expr_addr);\n+      params->quick_push (tmp_addr);\n+      params->quick_push (seq_cst);\n+      func_call = build_function_call_vec (loc, fndecl, params, NULL);\n+\n+      /* Return tmp which contains the value loaded.  */\n+      exp.value = build2 (COMPOUND_EXPR, nonatomic_type, func_call, tmp);\n+    }\n+  return exp;\n+}\n+\n /* EXP is an expression of integer type.  Apply the integer promotions\n    to it and return the promoted value.  */\n \n@@ -3435,6 +3536,215 @@ pointer_diff (location_t loc, tree op0, tree op1)\n   return convert (restype, result);\n }\n \f\n+/* Expand atomic compound assignments into an approriate sequence as\n+   specified by the C11 standard section 6.5.16.2.   \n+    given \n+       _Atomic T1 E1\n+       T2 E2\n+       E1 op= E2\n+\n+  This sequence is used for all types for which these operations are\n+  supported.\n+\n+  In addition, built-in versions of the 'fe' prefixed routines may\n+  need to be invoked for floating point (real, complex or vector) when\n+  floating-point exceptions are supported.  See 6.5.16.2 footnote 113.\n+\n+  T1 newval;\n+  T1 old;\n+  T1 *addr\n+  T2 val\n+  fenv_t fenv\n+\n+  addr = &E1;\n+  val = (E2);\n+  __atomic_load (addr, &old, SEQ_CST);\n+  feholdexcept (&fenv);\n+loop:\n+    newval = old op val;\n+    if (__atomic_compare_exchange_strong (addr, &old, &newval, SEQ_CST,\n+\t\t\t\t\t  SEQ_CST))\n+      goto done;\n+    feclearexcept (FE_ALL_EXCEPT);\n+    goto loop:\n+done:\n+  feupdateenv (&fenv);\n+\n+  Also note that the compiler is simply issuing the generic form of\n+  the atomic operations.  This requires temp(s) and has their address\n+  taken.  The atomic processing is smart enough to figure out when the\n+  size of an object can utilize a lock-free version, and convert the\n+  built-in call to the appropriate lock-free routine.  The optimizers\n+  will then dispose of any temps that are no longer required, and\n+  lock-free implementations are utilized as long as there is target\n+  support for the required size.\n+\n+  If the operator is NOP_EXPR, then this is a simple assignment, and\n+  an __atomic_store is issued to perform the assignment rather than\n+  the above loop.\n+\n+*/\n+\n+/* Build an atomic assignment at LOC, expanding into the proper\n+   sequence to store LHS MODIFYCODE= RHS.  Return a value representing\n+   the result of the operation, unless RETURN_OLD_P in which case\n+   return the old value of LHS (this is only for postincrement and\n+   postdecrement).  */\n+static tree\n+build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n+\t\t     tree rhs, bool return_old_p)\n+{\n+  tree fndecl, func_call;\n+  vec<tree, va_gc> *params;\n+  tree val, nonatomic_lhs_type, nonatomic_rhs_type, newval, newval_addr;\n+  tree old, old_addr;\n+  tree compound_stmt;\n+  tree stmt, goto_stmt;\n+  tree loop_label, loop_decl, done_label, done_decl;\n+\n+  tree lhs_type = TREE_TYPE (lhs);\n+  tree lhs_addr = build_unary_op (loc, ADDR_EXPR, lhs, 0);\n+  tree seq_cst = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n+  tree rhs_type = TREE_TYPE (rhs);\n+\n+  gcc_assert (TYPE_ATOMIC (lhs_type));\n+\n+  if (return_old_p)\n+    gcc_assert (modifycode == PLUS_EXPR || modifycode == MINUS_EXPR);\n+\n+  /* Allocate enough vector items for a compare_exchange.  */\n+  vec_alloc (params, 6);\n+\n+  /* Create a compound statement to hold the sequence of statements\n+     with a loop.  */\n+  compound_stmt = c_begin_compound_stmt (false);\n+\n+  /* Fold the RHS if it hasn't already been folded.  */\n+  if (modifycode != NOP_EXPR)\n+    rhs = c_fully_fold (rhs, false, NULL);\n+\n+  /* Remove the qualifiers for the rest of the expressions and create\n+     the VAL temp variable to hold the RHS.  */\n+  nonatomic_lhs_type = build_qualified_type (lhs_type, TYPE_UNQUALIFIED);\n+  nonatomic_rhs_type = build_qualified_type (rhs_type, TYPE_UNQUALIFIED);\n+  val = create_tmp_var (nonatomic_rhs_type, NULL);\n+  TREE_ADDRESSABLE (val) = 1;\n+  rhs = build2 (MODIFY_EXPR, nonatomic_rhs_type, val, rhs);\n+  SET_EXPR_LOCATION (rhs, loc);\n+  add_stmt (rhs);\n+\n+  /* NOP_EXPR indicates it's a straight store of the RHS. Simply issue\n+     an atomic_store.  */\n+  if (modifycode == NOP_EXPR)\n+    {\n+      /* Build __atomic_store (&lhs, &val, SEQ_CST)  */\n+      rhs = build_unary_op (loc, ADDR_EXPR, val, 0);\n+      fndecl = builtin_decl_explicit (BUILT_IN_ATOMIC_STORE);\n+      params->quick_push (lhs_addr);\n+      params->quick_push (rhs);\n+      params->quick_push (seq_cst);\n+      func_call = build_function_call_vec (loc, fndecl, params, NULL);\n+      add_stmt (func_call);\n+\n+      /* Finish the compound statement.  */\n+      compound_stmt = c_end_compound_stmt (loc, compound_stmt, false);\n+\n+      /* VAL is the value which was stored, return a COMPOUND_STMT of\n+\t the statement and that value.  */\n+      return build2 (COMPOUND_EXPR, nonatomic_lhs_type, compound_stmt, val);\n+    }\n+\n+  /* Create the variables and labels required for the op= form.  */\n+  old = create_tmp_var (nonatomic_lhs_type, NULL);\n+  old_addr = build_unary_op (loc, ADDR_EXPR, old, 0);\n+  TREE_ADDRESSABLE (val) = 1;\n+\n+  newval = create_tmp_var (nonatomic_lhs_type, NULL);\n+  newval_addr = build_unary_op (loc, ADDR_EXPR, newval, 0);\n+  TREE_ADDRESSABLE (newval) = 1;\n+\n+  loop_decl = create_artificial_label (loc);\n+  loop_label = build1 (LABEL_EXPR, void_type_node, loop_decl);\n+\n+  done_decl = create_artificial_label (loc);\n+  done_label = build1 (LABEL_EXPR, void_type_node, done_decl);\n+\n+  /* __atomic_load (addr, &old, SEQ_CST).  */\n+  fndecl = builtin_decl_explicit (BUILT_IN_ATOMIC_LOAD);\n+  params->quick_push (lhs_addr);\n+  params->quick_push (old_addr);\n+  params->quick_push (seq_cst);\n+  func_call = build_function_call_vec (loc, fndecl, params, NULL);\n+  add_stmt (func_call);\n+  params->truncate (0);\n+\n+  /* Create the expressions for floating-point environment\n+     manipulation, if required.  */\n+  bool need_fenv = (flag_trapping_math\n+\t\t    && (FLOAT_TYPE_P (lhs_type) || FLOAT_TYPE_P (rhs_type)));\n+  tree hold_call = NULL_TREE, clear_call = NULL_TREE, update_call = NULL_TREE;\n+  if (need_fenv)\n+    targetm.atomic_assign_expand_fenv (&hold_call, &clear_call, &update_call);\n+\n+  if (hold_call)\n+    add_stmt (hold_call);\n+\n+  /* loop:  */\n+  add_stmt (loop_label);\n+\n+  /* newval = old + val;  */\n+  rhs = build_binary_op (loc, modifycode, old, val, 1);\n+  rhs = convert_for_assignment (loc, nonatomic_lhs_type, rhs, NULL_TREE,\n+\t\t\t\tic_assign, false, NULL_TREE,\n+\t\t\t\tNULL_TREE, 0);\n+  if (rhs != error_mark_node)\n+    {\n+      rhs = build2 (MODIFY_EXPR, nonatomic_lhs_type, newval, rhs);\n+      SET_EXPR_LOCATION (rhs, loc);\n+      add_stmt (rhs);\n+    }\n+\n+  /* if (__atomic_compare_exchange (addr, &old, &new, false, SEQ_CST, SEQ_CST))\n+       goto done;  */\n+  fndecl = builtin_decl_explicit (BUILT_IN_ATOMIC_COMPARE_EXCHANGE);\n+  params->quick_push (lhs_addr);\n+  params->quick_push (old_addr);\n+  params->quick_push (newval_addr);\n+  params->quick_push (integer_zero_node);\n+  params->quick_push (seq_cst);\n+  params->quick_push (seq_cst);\n+  func_call = build_function_call_vec (loc, fndecl, params, NULL);\n+\n+  goto_stmt = build1 (GOTO_EXPR, void_type_node, done_decl);\n+  SET_EXPR_LOCATION (goto_stmt, loc);\n+\n+  stmt = build3 (COND_EXPR, void_type_node, func_call, goto_stmt, NULL_TREE);\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+  \n+  if (clear_call)\n+    add_stmt (clear_call);\n+\n+  /* goto loop;  */\n+  goto_stmt  = build1 (GOTO_EXPR, void_type_node, loop_decl);\n+  SET_EXPR_LOCATION (goto_stmt, loc);\n+  add_stmt (goto_stmt);\n+ \n+  /* done:  */\n+  add_stmt (done_label);\n+\n+  if (update_call)\n+    add_stmt (update_call);\n+\n+  /* Finish the compound statement.  */\n+  compound_stmt = c_end_compound_stmt (loc, compound_stmt, false);\n+\n+  /* NEWVAL is the value that was successfully stored, return a\n+     COMPOUND_EXPR of the statement and the appropriate value.  */\n+  return build2 (COMPOUND_EXPR, nonatomic_lhs_type, compound_stmt,\n+\t\t return_old_p ? old : newval);\n+}\n+\n /* Construct and perhaps optimize a tree representation\n    for a unary operation.  CODE, a tree_code, specifies the operation\n    and XARG is the operand.\n@@ -3635,6 +3945,9 @@ build_unary_op (location_t location,\n       /* Ensure the argument is fully folded inside any SAVE_EXPR.  */\n       arg = c_fully_fold (arg, false, NULL);\n \n+      bool atomic_op;\n+      atomic_op = really_atomic_lvalue (arg);\n+\n       /* Increment or decrement the real part of the value,\n \t and don't change the imaginary part.  */\n       if (typecode == COMPLEX_TYPE)\n@@ -3644,21 +3957,25 @@ build_unary_op (location_t location,\n \t  pedwarn (location, OPT_Wpedantic,\n \t\t   \"ISO C does not support %<++%> and %<--%> on complex types\");\n \n-\t  arg = stabilize_reference (arg);\n-\t  real = build_unary_op (EXPR_LOCATION (arg), REALPART_EXPR, arg, 1);\n-\t  imag = build_unary_op (EXPR_LOCATION (arg), IMAGPART_EXPR, arg, 1);\n-\t  real = build_unary_op (EXPR_LOCATION (arg), code, real, 1);\n-\t  if (real == error_mark_node || imag == error_mark_node)\n-\t    return error_mark_node;\n-\t  ret = build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n-\t\t\treal, imag);\n-\t  goto return_build_unary_op;\n+\t  if (!atomic_op)\n+\t    {\n+\t      arg = stabilize_reference (arg);\n+\t      real = build_unary_op (EXPR_LOCATION (arg), REALPART_EXPR, arg, 1);\n+\t      imag = build_unary_op (EXPR_LOCATION (arg), IMAGPART_EXPR, arg, 1);\n+\t      real = build_unary_op (EXPR_LOCATION (arg), code, real, 1);\n+\t      if (real == error_mark_node || imag == error_mark_node)\n+\t\treturn error_mark_node;\n+\t      ret = build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n+\t\t\t    real, imag);\n+\t      goto return_build_unary_op;\n+\t    }\n \t}\n \n       /* Report invalid types.  */\n \n       if (typecode != POINTER_TYPE && typecode != FIXED_POINT_TYPE\n-\t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE)\n+\t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE\n+\t  && typecode != COMPLEX_TYPE)\n \t{\n \t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t    error_at (location, \"wrong type argument to increment\");\n@@ -3749,6 +4066,24 @@ build_unary_op (location_t location,\n \t\t\t      || code == POSTINCREMENT_EXPR)\n \t\t\t     ? lv_increment : lv_decrement));\n \n+\t/* If the argument is atomic, use the special code sequences for\n+\t   atomic compound assignment.  */\n+\tif (atomic_op)\n+\t  {\n+\t    arg = stabilize_reference (arg);\n+\t    ret = build_atomic_assign (location, arg,\n+\t\t\t\t       ((code == PREINCREMENT_EXPR\n+\t\t\t\t\t || code == POSTINCREMENT_EXPR)\n+\t\t\t\t\t? PLUS_EXPR\n+\t\t\t\t\t: MINUS_EXPR),\n+\t\t\t\t       (FRACT_MODE_P (TYPE_MODE (argtype))\n+\t\t\t\t\t? inc\n+\t\t\t\t\t: integer_one_node),\n+\t\t\t\t       (code == POSTINCREMENT_EXPR\n+\t\t\t\t\t|| code == POSTDECREMENT_EXPR));\n+\t    goto return_build_unary_op;\n+\t  }\n+\n \tif (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n \t  val = boolean_increment (code, arg);\n \telse\n@@ -4259,7 +4594,8 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t\t    \"used in conditional expression\");\n \t  return error_mark_node;\n \t}\n-      else if (VOID_TYPE_P (TREE_TYPE (type1)))\n+      else if (VOID_TYPE_P (TREE_TYPE (type1))\n+\t       && !TYPE_ATOMIC (TREE_TYPE (type1)))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n \t    pedwarn (colon_loc, OPT_Wpedantic,\n@@ -4268,7 +4604,8 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type1),\n \t\t\t\t\t\t\t  TREE_TYPE (type2)));\n \t}\n-      else if (VOID_TYPE_P (TREE_TYPE (type2)))\n+      else if (VOID_TYPE_P (TREE_TYPE (type2))\n+\t       && !TYPE_ATOMIC (TREE_TYPE (type2)))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n \t    pedwarn (colon_loc, OPT_Wpedantic,\n@@ -4850,6 +5187,7 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n   bool npc;\n+  bool is_atomic_op;\n \n   /* Types that aren't fully specified cannot be used in assignments.  */\n   lhs = require_complete_type (lhs);\n@@ -4862,6 +5200,8 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   if (!objc_is_property_ref (lhs) && !lvalue_or_else (location, lhs, lv_assign))\n     return error_mark_node;\n \n+  is_atomic_op = really_atomic_lvalue (lhs);\n+\n   if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n     {\n       rhs_semantic_type = TREE_TYPE (rhs);\n@@ -4892,12 +5232,17 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n     {\n       lhs = c_fully_fold (lhs, false, NULL);\n       lhs = stabilize_reference (lhs);\n-      newrhs = build_binary_op (location,\n-\t\t\t\tmodifycode, lhs, rhs, 1);\n \n-      /* The original type of the right hand side is no longer\n-\t meaningful.  */\n-      rhs_origtype = NULL_TREE;\n+      /* Construct the RHS for any non-atomic compound assignemnt. */\n+      if (!is_atomic_op)\n+        {\n+\t  newrhs = build_binary_op (location,\n+\t\t\t\t    modifycode, lhs, rhs, 1);\n+\n+\t  /* The original type of the right hand side is no longer\n+\t     meaningful.  */\n+\t  rhs_origtype = NULL_TREE;\n+\t}\n     }\n \n   if (c_dialect_objc ())\n@@ -4959,23 +5304,39 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n \t\t\t? rhs_origtype\n \t\t\t: TREE_TYPE (rhs));\n       if (checktype != error_mark_node\n-\t  && TYPE_MAIN_VARIANT (checktype) != TYPE_MAIN_VARIANT (lhs_origtype))\n+\t  && (TYPE_MAIN_VARIANT (checktype) != TYPE_MAIN_VARIANT (lhs_origtype)\n+\t      || (is_atomic_op && modifycode != NOP_EXPR)))\n \twarning_at (location, OPT_Wc___compat,\n \t\t    \"enum conversion in assignment is invalid in C++\");\n     }\n \n+  /* If the lhs is atomic, remove that qualifier.  */\n+  if (is_atomic_op)\n+    {\n+      lhstype = build_qualified_type (lhstype, \n+\t\t\t\t      (TYPE_QUALS (lhstype)\n+\t\t\t\t       & ~TYPE_QUAL_ATOMIC));\n+      olhstype = build_qualified_type (olhstype, \n+\t\t\t\t       (TYPE_QUALS (lhstype)\n+\t\t\t\t\t& ~TYPE_QUAL_ATOMIC));\n+    }\n+\n   /* Convert new value to destination type.  Fold it first, then\n      restore any excess precision information, for the sake of\n      conversion warnings.  */\n \n-  npc = null_pointer_constant_p (newrhs);\n-  newrhs = c_fully_fold (newrhs, false, NULL);\n-  if (rhs_semantic_type)\n-    newrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n-  newrhs = convert_for_assignment (location, lhstype, newrhs, rhs_origtype,\n-\t\t\t\t   ic_assign, npc, NULL_TREE, NULL_TREE, 0);\n-  if (TREE_CODE (newrhs) == ERROR_MARK)\n-    return error_mark_node;\n+  if (!(is_atomic_op && modifycode != NOP_EXPR))\n+    {\n+      npc = null_pointer_constant_p (newrhs);\n+      newrhs = c_fully_fold (newrhs, false, NULL);\n+      if (rhs_semantic_type)\n+\tnewrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n+      newrhs = convert_for_assignment (location, lhstype, newrhs, rhs_origtype,\n+\t\t\t\t       ic_assign, npc, NULL_TREE,\n+\t\t\t\t       NULL_TREE, 0);\n+      if (TREE_CODE (newrhs) == ERROR_MARK)\n+\treturn error_mark_node;\n+    }\n \n   /* Emit ObjC write barrier, if necessary.  */\n   if (c_dialect_objc () && flag_objc_gc)\n@@ -4990,9 +5351,14 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n \n   /* Scan operands.  */\n \n-  result = build2 (MODIFY_EXPR, lhstype, lhs, newrhs);\n-  TREE_SIDE_EFFECTS (result) = 1;\n-  protected_set_expr_location (result, location);\n+  if (is_atomic_op)\n+    result = build_atomic_assign (location, lhs, modifycode, newrhs, false);\n+  else\n+    {\n+      result = build2 (MODIFY_EXPR, lhstype, lhs, newrhs);\n+      TREE_SIDE_EFFECTS (result) = 1;\n+      protected_set_expr_location (result, location);\n+    }\n \n   /* If we got the LHS in a different type for storing in,\n      convert the result back to the nominal type of LHS\n@@ -5024,8 +5390,12 @@ find_anonymous_field_with_type (tree struct_type, tree type)\n        field != NULL_TREE;\n        field = TREE_CHAIN (field))\n     {\n+      tree fieldtype = (TYPE_ATOMIC (TREE_TYPE (field))\n+\t\t\t? c_build_qualified_type (TREE_TYPE (field),\n+\t\t\t\t\t\t  TYPE_QUAL_ATOMIC)\n+\t\t\t: TYPE_MAIN_VARIANT (TREE_TYPE (field)));\n       if (DECL_NAME (field) == NULL\n-\t  && comptypes (type, TYPE_MAIN_VARIANT (TREE_TYPE (field))))\n+\t  && comptypes (type, fieldtype))\n \t{\n \t  if (found)\n \t    return false;\n@@ -5063,7 +5433,10 @@ convert_to_anonymous_field (location_t location, tree type, tree rhs)\n \t      || TREE_CODE (rhs_struct_type) == UNION_TYPE);\n \n   gcc_assert (POINTER_TYPE_P (type));\n-  lhs_main_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+  lhs_main_type = (TYPE_ATOMIC (TREE_TYPE (type))\n+\t\t   ? c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t     TYPE_QUAL_ATOMIC)\n+\t\t   : TYPE_MAIN_VARIANT (TREE_TYPE (type)));\n \n   found_field = NULL_TREE;\n   found_sub_field = false;\n@@ -5075,7 +5448,11 @@ convert_to_anonymous_field (location_t location, tree type, tree rhs)\n \t  || (TREE_CODE (TREE_TYPE (field)) != RECORD_TYPE\n \t      && TREE_CODE (TREE_TYPE (field)) != UNION_TYPE))\n \tcontinue;\n-      if (comptypes (lhs_main_type, TYPE_MAIN_VARIANT (TREE_TYPE (field))))\n+      tree fieldtype = (TYPE_ATOMIC (TREE_TYPE (field))\n+\t\t\t? c_build_qualified_type (TREE_TYPE (field),\n+\t\t\t\t\t\t  TYPE_QUAL_ATOMIC)\n+\t\t\t: TYPE_MAIN_VARIANT (TREE_TYPE (field)));\n+      if (comptypes (lhs_main_type, fieldtype))\n \t{\n \t  if (found_field != NULL_TREE)\n \t    return NULL_TREE;\n@@ -5365,17 +5742,18 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t and vice versa; otherwise, targets must be the same.\n \t\t Meanwhile, the lhs target must have all the qualifiers of\n \t\t the rhs.  */\n-\t      if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n+\t      if ((VOID_TYPE_P (ttl) && !TYPE_ATOMIC (ttl))\n+\t\t  || (VOID_TYPE_P (ttr) && !TYPE_ATOMIC (ttr))\n \t\t  || comp_target_types (location, memb_type, rhstype))\n \t\t{\n+\t\t  int lquals = TYPE_QUALS (ttl) & ~TYPE_QUAL_ATOMIC;\n+\t\t  int rquals = TYPE_QUALS (ttr) & ~TYPE_QUAL_ATOMIC;\n \t\t  /* If this type won't generate any warnings, use it.  */\n-\t\t  if (TYPE_QUALS (ttl) == TYPE_QUALS (ttr)\n+\t\t  if (lquals == rquals\n \t\t      || ((TREE_CODE (ttr) == FUNCTION_TYPE\n \t\t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)\n-\t\t\t  ? ((TYPE_QUALS (ttl) | TYPE_QUALS (ttr))\n-\t\t\t     == TYPE_QUALS (ttr))\n-\t\t\t  : ((TYPE_QUALS (ttl) | TYPE_QUALS (ttr))\n-\t\t\t     == TYPE_QUALS (ttl))))\n+\t\t\t  ? ((lquals | rquals) == rquals)\n+\t\t\t  : ((lquals | rquals) == lquals)))\n \t\t    break;\n \n \t\t  /* Keep looking for a better type, but remember this one.  */\n@@ -5466,9 +5844,15 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n       addr_space_t asr;\n \n       if (TREE_CODE (mvl) != ARRAY_TYPE)\n-\tmvl = TYPE_MAIN_VARIANT (mvl);\n+\tmvl = (TYPE_ATOMIC (mvl)\n+\t       ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvl),\n+\t\t\t\t\t TYPE_QUAL_ATOMIC)\n+\t       : TYPE_MAIN_VARIANT (mvl));\n       if (TREE_CODE (mvr) != ARRAY_TYPE)\n-\tmvr = TYPE_MAIN_VARIANT (mvr);\n+\tmvr = (TYPE_ATOMIC (mvr)\n+\t       ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvr),\n+\t\t\t\t\t TYPE_QUAL_ATOMIC)\n+\t       : TYPE_MAIN_VARIANT (mvr));\n       /* Opaque pointers are treated like void pointers.  */\n       is_opaque_pointer = vector_targets_convertible_p (ttl, ttr);\n \n@@ -5569,13 +5953,15 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n       /* Any non-function converts to a [const][volatile] void *\n \t and vice versa; otherwise, targets must be the same.\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n-      if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n+      if ((VOID_TYPE_P (ttl) && !TYPE_ATOMIC (ttl))\n+\t  || (VOID_TYPE_P (ttr) && !TYPE_ATOMIC (ttr))\n \t  || (target_cmp = comp_target_types (location, type, rhstype))\n \t  || is_opaque_pointer\n \t  || ((c_common_unsigned_type (mvl)\n \t       == c_common_unsigned_type (mvr))\n-\t      && c_common_signed_type (mvl)\n-\t\t == c_common_signed_type (mvr)))\n+\t      && (c_common_signed_type (mvl)\n+\t\t  == c_common_signed_type (mvr))\n+\t      && TYPE_ATOMIC (mvl) == TYPE_ATOMIC (mvr)))\n \t{\n \t  if (pedantic\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)\n@@ -5598,8 +5984,9 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n-\t      if (TYPE_QUALS_NO_ADDR_SPACE (ttr)\n-\t\t  & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))\n+\t      /* Assignments between atomic and non-atomic objects are OK.  */\n+\t      if (TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n+\t\t  & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl))\n \t\t{\n \t\t  WARN_FOR_QUALIFIERS (location, 0,\n \t\t\t\t       G_(\"passing argument %d of %qE discards \"\n@@ -6072,7 +6459,11 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n   if (code == ARRAY_TYPE && inside_init\n       && TREE_CODE (inside_init) == STRING_CST)\n     {\n-      tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+      tree typ1\n+\t= (TYPE_ATOMIC (TREE_TYPE (type))\n+\t   ? c_build_qualified_type (TYPE_MAIN_VARIANT (TREE_TYPE (type)),\n+\t\t\t\t     TYPE_QUAL_ATOMIC)\n+\t   : TYPE_MAIN_VARIANT (TREE_TYPE (type)));\n       /* Note that an array could be both an array of character type\n \t and an array of wchar_t if wchar_t is signed char or unsigned\n \t char.  */\n@@ -8610,7 +9001,7 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n \t      struct c_expr expr;\n \t      memset (&expr, 0, sizeof (expr));\n \t      expr.value = input;\n-\t      expr = default_function_array_conversion (loc, expr);\n+\t      expr = convert_lvalue_to_rvalue (loc, expr, true, false);\n \t      input = c_fully_fold (expr.value, false, NULL);\n \n \t      if (input != error_mark_node && VOID_TYPE_P (TREE_TYPE (input)))\n@@ -10096,13 +10487,13 @@ build_binary_op (location_t location, enum tree_code code,\n \t\t\t\"disjoint address spaces\");\n \t      return error_mark_node;\n \t    }\n-\t  else if (VOID_TYPE_P (tt0))\n+\t  else if (VOID_TYPE_P (tt0) && !TYPE_ATOMIC (tt0))\n \t    {\n \t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE)\n \t\tpedwarn (location, OPT_Wpedantic, \"ISO C forbids \"\n \t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n-\t  else if (VOID_TYPE_P (tt1))\n+\t  else if (VOID_TYPE_P (tt1) && !TYPE_ATOMIC (tt1))\n \t    {\n \t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE)\n \t\tpedwarn (location, OPT_Wpedantic, \"ISO C forbids \""}, {"sha": "c866170bde8148dce0158dc9f6b239d3441594b2", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -227,6 +227,7 @@ DEF_FUNCTION_TYPE (VOID, PCVOID)\n DEF_FUNCTION_TYPE (VOID, PVOID)\n DEF_FUNCTION_TYPE (VOID, UINT64)\n DEF_FUNCTION_TYPE (VOID, UNSIGNED)\n+DEF_FUNCTION_TYPE (VOID, PUSHORT)\n DEF_FUNCTION_TYPE (INT, PUSHORT)\n DEF_FUNCTION_TYPE (INT, PUNSIGNED)\n DEF_FUNCTION_TYPE (INT, PULONGLONG)"}, {"sha": "430d56202349b7d27018d24c9cf202fb7896a023", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 126, "deletions": 1, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -26993,6 +26993,11 @@ enum ix86_builtins\n   IX86_BUILTIN_LFENCE,\n   IX86_BUILTIN_PAUSE,\n \n+  IX86_BUILTIN_FNSTENV,\n+  IX86_BUILTIN_FLDENV,\n+  IX86_BUILTIN_FNSTSW,\n+  IX86_BUILTIN_FNCLEX,\n+\n   IX86_BUILTIN_BSRSI,\n   IX86_BUILTIN_BSRDI,\n   IX86_BUILTIN_RDPMC,\n@@ -27969,6 +27974,12 @@ static const struct builtin_description bdesc_special_args[] =\n   { ~OPTION_MASK_ISA_64BIT, CODE_FOR_nothing, \"__builtin_ia32_rdtscp\", IX86_BUILTIN_RDTSCP, UNKNOWN, (int) UINT64_FTYPE_PUNSIGNED },\n   { ~OPTION_MASK_ISA_64BIT, CODE_FOR_pause, \"__builtin_ia32_pause\", IX86_BUILTIN_PAUSE, UNKNOWN, (int) VOID_FTYPE_VOID },\n \n+  /* 80387 (for use internally for atomic compound assignment).  */\n+  { 0, CODE_FOR_fnstenv, \"__builtin_ia32_fnstenv\", IX86_BUILTIN_FNSTENV, UNKNOWN, (int) VOID_FTYPE_PVOID },\n+  { 0, CODE_FOR_fldenv, \"__builtin_ia32_fldenv\", IX86_BUILTIN_FLDENV, UNKNOWN, (int) VOID_FTYPE_PCVOID },\n+  { 0, CODE_FOR_fnstsw, \"__builtin_ia32_fnstsw\", IX86_BUILTIN_FNSTSW, UNKNOWN, (int) VOID_FTYPE_PUSHORT },\n+  { 0, CODE_FOR_fnclex, \"__builtin_ia32_fnclex\", IX86_BUILTIN_FNCLEX, UNKNOWN, (int) VOID_FTYPE_VOID },\n+\n   /* MMX */\n   { OPTION_MASK_ISA_MMX, CODE_FOR_mmx_emms, \"__builtin_ia32_emms\", IX86_BUILTIN_EMMS, UNKNOWN, (int) VOID_FTYPE_VOID },\n \n@@ -32930,6 +32941,10 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n     case IX86_BUILTIN_FXRSTOR:\n     case IX86_BUILTIN_FXSAVE64:\n     case IX86_BUILTIN_FXRSTOR64:\n+    case IX86_BUILTIN_FNSTENV:\n+    case IX86_BUILTIN_FLDENV:\n+    case IX86_BUILTIN_FNSTSW:\n+      mode0 = BLKmode;\n       switch (fcode)\n \t{\n \tcase IX86_BUILTIN_FXSAVE:\n@@ -32944,6 +32959,16 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \tcase IX86_BUILTIN_FXRSTOR64:\n \t  icode = CODE_FOR_fxrstor64;\n \t  break;\n+\tcase IX86_BUILTIN_FNSTENV:\n+\t  icode = CODE_FOR_fnstenv;\n+\t  break;\n+\tcase IX86_BUILTIN_FLDENV:\n+\t  icode = CODE_FOR_fldenv;\n+\t  break;\n+\tcase IX86_BUILTIN_FNSTSW:\n+\t  icode = CODE_FOR_fnstsw;\n+\t  mode0 = HImode;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -32956,7 +32981,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t  op0 = convert_memory_address (Pmode, op0);\n \t  op0 = copy_addr_to_reg (op0);\n \t}\n-      op0 = gen_rtx_MEM (BLKmode, op0);\n+      op0 = gen_rtx_MEM (mode0, op0);\n \n       pat = GEN_FCN (icode) (op0);\n       if (pat)\n@@ -43566,6 +43591,103 @@ ix86_float_exceptions_rounding_supported_p (void)\n   return TARGET_80387 || TARGET_SSE_MATH;\n }\n \n+/* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */\n+\n+static void\n+ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n+{\n+  if (!TARGET_80387 && !TARGET_SSE_MATH)\n+    return;\n+  tree exceptions_var = create_tmp_var (integer_type_node, NULL);\n+  if (TARGET_80387)\n+    {\n+      tree fenv_index_type = build_index_type (size_int (6));\n+      tree fenv_type = build_array_type (unsigned_type_node, fenv_index_type);\n+      tree fenv_var = create_tmp_var (fenv_type, NULL);\n+      mark_addressable (fenv_var);\n+      tree fenv_ptr = build_pointer_type (fenv_type);\n+      tree fenv_addr = build1 (ADDR_EXPR, fenv_ptr, fenv_var);\n+      fenv_addr = fold_convert (ptr_type_node, fenv_addr);\n+      tree fnstenv = ix86_builtins[IX86_BUILTIN_FNSTENV];\n+      tree fldenv = ix86_builtins[IX86_BUILTIN_FLDENV];\n+      tree fnstsw = ix86_builtins[IX86_BUILTIN_FNSTSW];\n+      tree fnclex = ix86_builtins[IX86_BUILTIN_FNCLEX];\n+      tree hold_fnstenv = build_call_expr (fnstenv, 1, fenv_addr);\n+      tree hold_fnclex = build_call_expr (fnclex, 0);\n+      *hold = build2 (COMPOUND_EXPR, void_type_node, hold_fnstenv,\n+\t\t      hold_fnclex);\n+      *clear = build_call_expr (fnclex, 0);\n+      tree sw_var = create_tmp_var (short_unsigned_type_node, NULL);\n+      mark_addressable (sw_var);\n+      tree su_ptr = build_pointer_type (short_unsigned_type_node);\n+      tree sw_addr = build1 (ADDR_EXPR, su_ptr, sw_var);\n+      tree fnstsw_call = build_call_expr (fnstsw, 1, sw_addr);\n+      tree exceptions_x87 = fold_convert (integer_type_node, sw_var);\n+      tree update_mod = build2 (MODIFY_EXPR, integer_type_node,\n+\t\t\t\texceptions_var, exceptions_x87);\n+      *update = build2 (COMPOUND_EXPR, integer_type_node,\n+\t\t\tfnstsw_call, update_mod);\n+      tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);\n+      *update = build2 (COMPOUND_EXPR, void_type_node, *update, update_fldenv);\n+    }\n+  if (TARGET_SSE_MATH)\n+    {\n+      tree mxcsr_orig_var = create_tmp_var (unsigned_type_node, NULL);\n+      tree mxcsr_mod_var = create_tmp_var (unsigned_type_node, NULL);\n+      tree stmxcsr = ix86_builtins[IX86_BUILTIN_STMXCSR];\n+      tree ldmxcsr = ix86_builtins[IX86_BUILTIN_LDMXCSR];\n+      tree stmxcsr_hold_call = build_call_expr (stmxcsr, 0);\n+      tree hold_assign_orig = build2 (MODIFY_EXPR, unsigned_type_node,\n+\t\t\t\t      mxcsr_orig_var, stmxcsr_hold_call);\n+      tree hold_mod_val = build2 (BIT_IOR_EXPR, unsigned_type_node,\n+\t\t\t\t  mxcsr_orig_var,\n+\t\t\t\t  build_int_cst (unsigned_type_node, 0x1f80));\n+      hold_mod_val = build2 (BIT_AND_EXPR, unsigned_type_node, hold_mod_val,\n+\t\t\t     build_int_cst (unsigned_type_node, 0xffffffc0));\n+      tree hold_assign_mod = build2 (MODIFY_EXPR, unsigned_type_node,\n+\t\t\t\t     mxcsr_mod_var, hold_mod_val);\n+      tree ldmxcsr_hold_call = build_call_expr (ldmxcsr, 1, mxcsr_mod_var);\n+      tree hold_all = build2 (COMPOUND_EXPR, unsigned_type_node,\n+\t\t\t      hold_assign_orig, hold_assign_mod);\n+      hold_all = build2 (COMPOUND_EXPR, void_type_node, hold_all,\n+\t\t\t ldmxcsr_hold_call);\n+      if (*hold)\n+\t*hold = build2 (COMPOUND_EXPR, void_type_node, *hold, hold_all);\n+      else\n+\t*hold = hold_all;\n+      tree ldmxcsr_clear_call = build_call_expr (ldmxcsr, 1, mxcsr_mod_var);\n+      if (*clear)\n+\t*clear = build2 (COMPOUND_EXPR, void_type_node, *clear,\n+\t\t\t ldmxcsr_clear_call);\n+      else\n+\t*clear = ldmxcsr_clear_call;\n+      tree stxmcsr_update_call = build_call_expr (stmxcsr, 0);\n+      tree exceptions_sse = fold_convert (integer_type_node,\n+\t\t\t\t\t  stxmcsr_update_call);\n+      if (*update)\n+\t{\n+\t  tree exceptions_mod = build2 (BIT_IOR_EXPR, integer_type_node,\n+\t\t\t\t\texceptions_var, exceptions_sse);\n+\t  tree exceptions_assign = build2 (MODIFY_EXPR, integer_type_node,\n+\t\t\t\t\t   exceptions_var, exceptions_mod);\n+\t  *update = build2 (COMPOUND_EXPR, integer_type_node, *update,\n+\t\t\t    exceptions_assign);\n+\t}\n+      else\n+\t*update = build2 (MODIFY_EXPR, integer_type_node,\n+\t\t\t  exceptions_var, exceptions_sse);\n+      tree ldmxcsr_update_call = build_call_expr (ldmxcsr, 1, mxcsr_orig_var);\n+      *update = build2 (COMPOUND_EXPR, void_type_node, *update,\n+\t\t\tldmxcsr_update_call);\n+    }\n+  tree atomic_feraiseexcept\n+    = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);\n+  tree atomic_feraiseexcept_call = build_call_expr (atomic_feraiseexcept,\n+\t\t\t\t\t\t    1, exceptions_var);\n+  *update = build2 (COMPOUND_EXPR, void_type_node, *update,\n+\t\t    atomic_feraiseexcept_call);\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n@@ -43677,6 +43799,9 @@ ix86_float_exceptions_rounding_supported_p (void)\n #undef TARGET_MEMMODEL_CHECK\n #define TARGET_MEMMODEL_CHECK ix86_memmodel_check\n \n+#undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n+#define TARGET_ATOMIC_ASSIGN_EXPAND_FENV ix86_atomic_assign_expand_fenv\n+\n #ifdef HAVE_AS_TLS\n #undef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS true"}, {"sha": "a37fa64a03eeb829b407ca1f807f223dd0746f81", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -222,6 +222,12 @@\n   UNSPECV_XSAVEOPT\n   UNSPECV_XSAVEOPT64\n \n+  ;; For atomic compound assignments.\n+  UNSPECV_FNSTENV\n+  UNSPECV_FLDENV\n+  UNSPECV_FNSTSW\n+  UNSPECV_FNCLEX\n+\n   ;; For RDRAND support\n   UNSPECV_RDRAND\n \n@@ -18012,6 +18018,71 @@\n    (set (attr \"length\")\n         (symbol_ref \"ix86_attr_length_address_default (insn) + 4\"))])\n \n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Floating-point instructions for atomic compound assignments\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+; Clobber all floating-point registers on environment save and restore\n+; to ensure that the TOS value saved at fnstenv is valid after fldenv.\n+(define_insn \"fnstenv\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:BLK [(const_int 0)] UNSPECV_FNSTENV))\n+   (clobber (reg:HI FPCR_REG))\n+   (clobber (reg:XF ST0_REG))\n+   (clobber (reg:XF ST1_REG))\n+   (clobber (reg:XF ST2_REG))\n+   (clobber (reg:XF ST3_REG))\n+   (clobber (reg:XF ST4_REG))\n+   (clobber (reg:XF ST5_REG))\n+   (clobber (reg:XF ST6_REG))\n+   (clobber (reg:XF ST7_REG))]\n+  \"TARGET_80387\"\n+  \"fnstenv\\t%0\"\n+  [(set_attr \"type\" \"other\")\n+   (set_attr \"memory\" \"store\")\n+   (set (attr \"length\")\n+        (symbol_ref \"ix86_attr_length_address_default (insn) + 2\"))])\n+\n+(define_insn \"fldenv\"\n+  [(unspec_volatile [(match_operand:BLK 0 \"memory_operand\" \"m\")]\n+\t\t    UNSPECV_FLDENV)\n+   (clobber (reg:CCFP FPSR_REG))\n+   (clobber (reg:HI FPCR_REG))\n+   (clobber (reg:XF ST0_REG))\n+   (clobber (reg:XF ST1_REG))\n+   (clobber (reg:XF ST2_REG))\n+   (clobber (reg:XF ST3_REG))\n+   (clobber (reg:XF ST4_REG))\n+   (clobber (reg:XF ST5_REG))\n+   (clobber (reg:XF ST6_REG))\n+   (clobber (reg:XF ST7_REG))]\n+  \"TARGET_80387\"\n+  \"fldenv\\t%0\"\n+  [(set_attr \"type\" \"other\")\n+   (set_attr \"memory\" \"load\")\n+   (set (attr \"length\")\n+        (symbol_ref \"ix86_attr_length_address_default (insn) + 2\"))])\n+\n+(define_insn \"fnstsw\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+\t(unspec_volatile:HI [(const_int 0)] UNSPECV_FNSTSW))]\n+  \"TARGET_80387\"\n+  \"fnstsw\\t%0\"\n+  [(set_attr \"type\" \"other\")\n+   (set_attr \"memory\" \"store\")\n+   (set (attr \"length\")\n+        (symbol_ref \"ix86_attr_length_address_default (insn) + 2\"))])\n+\n+(define_insn \"fnclex\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_FNCLEX)]\n+  \"TARGET_80387\"\n+  \"fnclex\"\n+  [(set_attr \"type\" \"other\")\n+   (set_attr \"memory\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; LWP instructions"}, {"sha": "5e7910bdd2023d4c11efcb5f75986e4cb43789ec", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -11485,3 +11485,7 @@ It returns true if the target supports GNU indirect functions.\n The support includes the assembler, linker and dynamic linker.\n The default value of this hook is based on target's libc.\n @end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_ATOMIC_ASSIGN_EXPAND_FENV (tree *@var{hold}, tree *@var{clear}, tree *@var{update})\n+ISO C11 requires atomic compound assignments that may raise floating-point exceptions to raise exceptions corresponding to the arithmetic operation whose result was successfully stored in a compare-and-exchange sequence.  This requires code equivalent to calls to @code{feholdexcept}, @code{feclearexcept} and @code{feupdateenv} to be generated at appropriate points in the compare-and-exchange sequence.  This hook should set @code{*@var{hold}} to an expression equivalent to the call to @code{feholdexcept}, @code{*@var{clear}} to an expression equivalent to the call to @code{feclearexcept} and @code{*@var{update}} to an expression equivalent to the call to @code{feupdateenv}.  The three expressions are @code{NULL_TREE} on entry to the hook and may be left as @code{NULL_TREE} if no code is required in a particular place.  The default implementation leaves all three expressions as @code{NULL_TREE}.  The @code{__atomic_feraiseexcept} function from @code{libatomic} may be of use as part of the code generated in @code{*@var{update}}.\n+@end deftypefn"}, {"sha": "4e60d48a337ceb49ec4300291e69aeaf65e7a752", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -8404,3 +8404,5 @@ and the associated definitions of those functions.\n @hook TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n \n @hook TARGET_HAS_IFUNC_P\n+\n+@hook TARGET_ATOMIC_ASSIGN_EXPAND_FENV"}, {"sha": "e3be5f8d212000ca4e4cc79a68e429b5191cf0be", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1,3 +1,7 @@\n+2013-11-07  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* objc-act.c (objc_push_parm): Handle atomic qualifier.\n+\n 2013-09-25  Tom Tromey  <tromey@redhat.com>\n \n \t* Make-lang.in (START_HDRS, cc1obj-checksum.o, objc/objc-lang.o)"}, {"sha": "3125398c27678b3bcf4d172f6845ebb92e05f276", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -8244,6 +8244,7 @@ objc_push_parm (tree parm)\n   c_apply_type_quals_to_decl\n   ((TYPE_READONLY (TREE_TYPE (parm)) ? TYPE_QUAL_CONST : 0)\n    | (TYPE_RESTRICT (TREE_TYPE (parm)) ? TYPE_QUAL_RESTRICT : 0)\n+   | (TYPE_ATOMIC (TREE_TYPE (parm)) ? TYPE_QUAL_ATOMIC : 0)\n    | (TYPE_VOLATILE (TREE_TYPE (parm)) ? TYPE_QUAL_VOLATILE : 0), parm);\n \n   objc_parmlist = chainon (objc_parmlist, parm);"}, {"sha": "08af30d7f19ad78b5757ae793ac896c04ac5a904", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -305,6 +305,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n   if (TYPE_P (node) ? TYPE_READONLY (node) : TREE_READONLY (node))\n     fputs (\" readonly\", file);\n+  if (TYPE_P (node) && TYPE_ATOMIC (node))\n+    fputs (\" atomic\", file);\n   if (!TYPE_P (node) && TREE_CONSTANT (node))\n     fputs (\" constant\", file);\n   else if (TYPE_P (node) && TYPE_SIZES_GIMPLIFIED (node))"}, {"sha": "26c8ba09f9bcf5fa731d272460ce026c5ec775ad", "filename": "gcc/sync-builtins.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fsync-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Fsync-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsync-builtins.def?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -606,3 +606,9 @@ DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_SIGNAL_FENCE,\n \t\t  \"__atomic_signal_fence\",\n \t\t  BT_FN_VOID_INT, ATTR_NOTHROW_LEAF_LIST)\n \n+/* This one is actually a function in libatomic and not expected to be\n+   inlined, declared here for convenience of targets generating calls\n+   to it.  */\n+DEF_SYNC_BUILTIN (BUILT_IN_ATOMIC_FERAISEEXCEPT,\n+\t\t  \"__atomic_feraiseexcept\",\n+\t\t  BT_FN_VOID_INT, ATTR_LEAF_LIST)"}, {"sha": "caf1cb6da6d3b52f5ddf01f9bd89635e6c9ae074", "filename": "gcc/target.def", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -5279,7 +5279,27 @@ DEFHOOKPOD\n  @code{atomic_test_and_set} is not exactly 1, i.e. the\\\n  @code{bool} @code{true}.\",\n  unsigned char, 1)\n- \n+\n+DEFHOOK\n+(atomic_assign_expand_fenv,\n+\"ISO C11 requires atomic compound assignments that may raise floating-point\\\n+ exceptions to raise exceptions corresponding to the arithmetic operation\\\n+ whose result was successfully stored in a compare-and-exchange sequence. \\\n+ This requires code equivalent to calls to @code{feholdexcept},\\\n+ @code{feclearexcept} and @code{feupdateenv} to be generated at\\\n+ appropriate points in the compare-and-exchange sequence.  This hook should\\\n+ set @code{*@var{hold}} to an expression equivalent to the call to\\\n+ @code{feholdexcept}, @code{*@var{clear}} to an expression equivalent to\\\n+ the call to @code{feclearexcept} and @code{*@var{update}} to an expression\\\n+ equivalent to the call to @code{feupdateenv}.  The three expressions are\\\n+ @code{NULL_TREE} on entry to the hook and may be left as @code{NULL_TREE}\\\n+ if no code is required in a particular place.  The default implementation\\\n+ leaves all three expressions as @code{NULL_TREE}.  The\\\n+ @code{__atomic_feraiseexcept} function from @code{libatomic} may be of use\\\n+ as part of the code generated in @code{*@var{update}}.\",\n+ void, (tree *hold, tree *clear, tree *update),\n+ default_atomic_assign_expand_fenv)\n+\n /* Leave the boolean fields at the end.  */\n \n /* True if we can create zeroed data by switching to a BSS section"}, {"sha": "e262fcb43cee2c9799763c08f446af3ffa277cf0", "filename": "gcc/targhooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1600,6 +1600,13 @@ default_canonicalize_comparison (int *, rtx *, rtx *, bool)\n {\n }\n \n+/* Default implementation of TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */\n+\n+void\n+default_atomic_assign_expand_fenv (tree *, tree *, tree *)\n+{\n+}\n+\n #ifndef PAD_VARARGS_DOWN\n #define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n #endif"}, {"sha": "a939fdbc6e56c8f2e7fbbd0ec8013840699dec1c", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -203,6 +203,7 @@ extern void default_asm_output_ident_directive (const char*);\n \n extern enum machine_mode default_cstore_mode (enum insn_code);\n extern bool default_member_type_forces_blk (const_tree, enum machine_mode);\n+extern void default_atomic_assign_expand_fenv (tree *, tree *, tree *);\n extern tree build_va_arg_indirect_ref (tree);\n extern tree std_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n "}, {"sha": "099c392ad6c777be3666a85319bfd5a37efc6ef0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1,3 +1,16 @@\n+2013-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_fenv_exceptions): New function.\n+\t* lib/atomic-dg.exp, gcc.dg/atomic/atomic.exp: New files.\n+\t* gcc.dg/atomic/c11-atomic-exec-1.c,\n+\tgcc.dg/atomic/c11-atomic-exec-2.c,\n+\tgcc.dg/atomic/c11-atomic-exec-3.c,\n+\tgcc.dg/atomic/c11-atomic-exec-4.c,\n+\tgcc.dg/atomic/c11-atomic-exec-5.c, gcc.dg/c11-atomic-1.c,\n+\tgcc.dg/c11-atomic-2.c, gcc.dg/c11-atomic-3.c,\n+\tgcc.dg/c90-atomic-1.c, gcc.dg/c99-atomic-1.c: New tests.\n+\n 2013-11-07  Cong Hou  <congh@google.com>\n \n \t* gcc.dg/vect/vect-alias-check.c: New."}, {"sha": "ac2ca729d1dba5506001930d8a30b7df85b7dbbe", "filename": "gcc/testsuite/gcc.dg/atomic/atomic.exp", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fatomic.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fatomic.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fatomic.exp?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,34 @@\n+# Copyright (C) 2012-2013 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+load_lib atomic-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+if [atomic_init] {\n+    # Main loop.\n+    gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] \"\"\n+}\n+\n+# All done.\n+atomic_finish\n+dg-finish"}, {"sha": "c0db93f07dcb747fd89676a85b249fa190c048b2", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-1.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-1.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,88 @@\n+/* Test for _Atomic in C11.  Basic execution tests for atomic loads\n+   and stores.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+\n+#define CMPLX(X, Y) __builtin_complex ((X), (Y))\n+\n+#define TEST_SIMPLE_ASSIGN(TYPE, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      static volatile _Atomic (TYPE) a, b = (TYPE) (VALUE);\t\\\n+      if (a != 0)\t\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+      if (b != ((TYPE) (VALUE)))\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+      if ((a = b) != ((TYPE) (VALUE)))\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+      if (a != ((TYPE) (VALUE)))\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_SIMPLE_ASSIGN_ARITH(VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      TEST_SIMPLE_ASSIGN (_Bool, (VALUE));\t\t\t\\\n+      TEST_SIMPLE_ASSIGN (char, (VALUE));\t\t\t\\\n+      TEST_SIMPLE_ASSIGN (signed char, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (unsigned char, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (signed short, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (unsigned short, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (signed int, (VALUE));\t\t\t\\\n+      TEST_SIMPLE_ASSIGN (unsigned int, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (signed long, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (unsigned long, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (signed long long, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (unsigned long long, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (float, (VALUE));\t\t\t\\\n+      TEST_SIMPLE_ASSIGN (double, (VALUE));\t\t\t\\\n+      TEST_SIMPLE_ASSIGN (long double, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (_Complex float, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (_Complex double, (VALUE));\t\t\\\n+      TEST_SIMPLE_ASSIGN (_Complex long double, (VALUE));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+static void\n+test_simple_assign (void)\n+{\n+  TEST_SIMPLE_ASSIGN_ARITH (0);\n+  TEST_SIMPLE_ASSIGN_ARITH (1);\n+  TEST_SIMPLE_ASSIGN_ARITH (2);\n+  TEST_SIMPLE_ASSIGN_ARITH (-1);\n+  TEST_SIMPLE_ASSIGN_ARITH (1ULL << 63);\n+  TEST_SIMPLE_ASSIGN_ARITH (1.5);\n+  TEST_SIMPLE_ASSIGN_ARITH (CMPLX (2.5, 3.5));\n+  static int i;\n+  TEST_SIMPLE_ASSIGN (int *, 0);\n+  TEST_SIMPLE_ASSIGN (int *, &i);\n+  struct s { short a[1024]; };\n+  struct s init, copy;\n+  _Atomic struct s s1, s2;\n+  for (int j = 0; j < 1024; j++)\n+    init.a[j] = j;\n+  copy = (s1 = init);\n+  if (memcmp (&init, &copy, sizeof init) != 0)\n+    abort ();\n+  copy = (s2 = s1);\n+  if (memcmp (&init, &copy, sizeof init) != 0)\n+    abort ();\n+  copy = s1;\n+  if (memcmp (&init, &copy, sizeof init) != 0)\n+    abort ();\n+  copy = s2;\n+  if (memcmp (&init, &copy, sizeof init) != 0)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  test_simple_assign ();\n+  exit (0);\n+}"}, {"sha": "9ee56b601937de9c4a5fe6f4cc1065502b8581e6", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-2.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-2.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,171 @@\n+/* Test for _Atomic in C11.  Basic execution tests for atomic compound\n+   assignment.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+#define CMPLX(X, Y) __builtin_complex ((X), (Y))\n+\n+#define TEST_COMPOUND(TYPE, LHSVAL, RHSVAL, OP)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static volatile _Atomic (TYPE) a = (TYPE) (LHSVAL);\t\t\\\n+      if ((a OP##= (RHSVAL)) != (TYPE) ((TYPE) (LHSVAL) OP (RHSVAL)))\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      if (a != (TYPE) ((TYPE) (LHSVAL) OP (RHSVAL)))\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_COMPOUND_ARITH(LHSVAL, RHSVAL, OP)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TEST_COMPOUND (_Bool, (LHSVAL), (RHSVAL), OP);\t\t\t\\\n+      TEST_COMPOUND (char, (LHSVAL), (RHSVAL), OP);\t\t\t\\\n+      TEST_COMPOUND (signed char, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned char, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed short, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned short, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed int, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned int, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed long, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned long, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed long long, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned long long, (LHSVAL), (RHSVAL), OP);\t\\\n+      TEST_COMPOUND (float, (LHSVAL), (RHSVAL), OP);\t\t\t\\\n+      TEST_COMPOUND (double, (LHSVAL), (RHSVAL), OP);\t\t\t\\\n+      TEST_COMPOUND (long double, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (_Complex float, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (_Complex double, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (_Complex long double, (LHSVAL), (RHSVAL), OP);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_COMPOUND_INT(LHSVAL, RHSVAL, OP)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TEST_COMPOUND (_Bool, (LHSVAL), (RHSVAL), OP);\t\t\t\\\n+      TEST_COMPOUND (char, (LHSVAL), (RHSVAL), OP);\t\t\t\\\n+      TEST_COMPOUND (signed char, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned char, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed short, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned short, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed int, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned int, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed long, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned long, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (signed long long, (LHSVAL), (RHSVAL), OP);\t\t\\\n+      TEST_COMPOUND (unsigned long long, (LHSVAL), (RHSVAL), OP);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+static void\n+test_mult (void)\n+{\n+  TEST_COMPOUND_ARITH (1, 2, *);\n+  TEST_COMPOUND_ARITH (-3, 5, *);\n+  TEST_COMPOUND_ARITH (-7, -20, *);\n+  TEST_COMPOUND_ARITH (1.25, 3.5, *);\n+  TEST_COMPOUND_ARITH (CMPLX (1.5, 2.5), CMPLX (3.5, 4.5), *);\n+  TEST_COMPOUND_ARITH (CMPLX (1.5, 2.5), 2, *);\n+}\n+\n+static void\n+test_div (void)\n+{\n+  TEST_COMPOUND_ARITH (1, 2, /);\n+  TEST_COMPOUND_ARITH (-6, 3, /);\n+  TEST_COMPOUND_ARITH (-70, -10, /);\n+  TEST_COMPOUND_ARITH (1.25, 2.5, /);\n+  TEST_COMPOUND_ARITH (CMPLX (1.0, 1.0), CMPLX (0.5, 0.5), /);\n+  TEST_COMPOUND_ARITH (CMPLX (1.5, 2.5), 2, /);\n+}\n+\n+static void\n+test_mod (void)\n+{\n+  TEST_COMPOUND_INT (1, 2, %);\n+  TEST_COMPOUND_INT (-3, 5, %);\n+  TEST_COMPOUND_INT (-7, -2, %);\n+}\n+\n+static void\n+test_plus (void)\n+{\n+  TEST_COMPOUND_ARITH (1, 2, +);\n+  TEST_COMPOUND_ARITH (-3, 5, +);\n+  TEST_COMPOUND_ARITH (-7, -20, +);\n+  TEST_COMPOUND_ARITH (1.25, 3.5, +);\n+  TEST_COMPOUND_ARITH (CMPLX (1.5, 2.5), CMPLX (3.5, 4.5), +);\n+  TEST_COMPOUND_ARITH (CMPLX (1.5, 2.5), 2, +);\n+  static int ia[2];\n+  TEST_COMPOUND (int *, &ia[1], 1, +);\n+  TEST_COMPOUND (int *, &ia[1], -1, +);\n+}\n+\n+static void\n+test_minus (void)\n+{\n+  TEST_COMPOUND_ARITH (1, 2, -);\n+  TEST_COMPOUND_ARITH (-3, 5, -);\n+  TEST_COMPOUND_ARITH (-7, -20, -);\n+  TEST_COMPOUND_ARITH (3.5, 1.25, -);\n+  TEST_COMPOUND_ARITH (CMPLX (3.5, 4.5), CMPLX (1.5, 2.5), -);\n+  TEST_COMPOUND_ARITH (CMPLX (3.5, 2.5), 2, -);\n+  static int ia[2];\n+  TEST_COMPOUND (int *, &ia[1], 1, -);\n+  TEST_COMPOUND (int *, &ia[1], -1, -);\n+}\n+\n+static void\n+test_lshift (void)\n+{\n+  TEST_COMPOUND_INT (1, 7, <<);\n+  TEST_COMPOUND_INT (15, 3, <<);\n+}\n+\n+static void\n+test_rshift (void)\n+{\n+  TEST_COMPOUND_INT (1, 1, >>);\n+  TEST_COMPOUND_INT (127, 4, >>);\n+}\n+\n+static void\n+test_and (void)\n+{\n+  TEST_COMPOUND_INT (0x1234, 0x7856, &);\n+  TEST_COMPOUND_INT (-1, 0x12345678, &);\n+}\n+\n+static void\n+test_xor (void)\n+{\n+  TEST_COMPOUND_INT (0x1234, 0x7856, ^);\n+  TEST_COMPOUND_INT (-1, 0x12345678, ^);\n+}\n+\n+static void\n+test_or (void)\n+{\n+  TEST_COMPOUND_INT (0x1234, 0x7856, |);\n+  TEST_COMPOUND_INT (-12345, 0x12345678, |);\n+}\n+\n+int\n+main (void)\n+{\n+  test_mult ();\n+  test_div ();\n+  test_mod ();\n+  test_plus ();\n+  test_minus ();\n+  test_lshift ();\n+  test_rshift ();\n+  test_and ();\n+  test_xor ();\n+  test_or ();\n+  exit (0);\n+}"}, {"sha": "7bfa8c05f96cf73e5f29dc1c8cdd759edb79176f", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-3.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-3.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,85 @@\n+/* Test for _Atomic in C11.  Basic execution tests for atomic\n+   increment and decrement.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+#define TEST_INCDEC(TYPE, VALUE, PREOP, POSTOP, PRE_P, CHANGE)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static volatile _Atomic (TYPE) a = (TYPE) (VALUE);\t\t\\\n+      if (PREOP a POSTOP != (PRE_P\t\t\t\t\t\\\n+\t\t\t     ? (TYPE) ((TYPE) (VALUE) + (CHANGE))\t\\\n+\t\t\t     : (TYPE) (VALUE)))\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      if (a != (TYPE) ((TYPE) (VALUE) + (CHANGE)))\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_INCDEC_ARITH(VALUE, PREOP, POSTOP, PRE_P, CHANGE)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TEST_INCDEC (_Bool, (VALUE), PREOP, POSTOP, (PRE_P), (CHANGE));\t\\\n+      TEST_INCDEC (char, (VALUE), PREOP, POSTOP, (PRE_P), (CHANGE));\t\\\n+      TEST_INCDEC (signed char, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (unsigned char, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (signed short, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (unsigned short, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (signed int, (VALUE), PREOP, POSTOP, (PRE_P),\t\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (unsigned int, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (signed long, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (unsigned long, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (signed long long, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (unsigned long long, (VALUE), PREOP, POSTOP, (PRE_P), \\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+      TEST_INCDEC (float, (VALUE), PREOP, POSTOP, (PRE_P), (CHANGE));\t\\\n+      TEST_INCDEC (double, (VALUE), PREOP, POSTOP, (PRE_P), (CHANGE));\t\\\n+      TEST_INCDEC (long double, (VALUE), PREOP, POSTOP, (PRE_P),\t\\\n+\t\t   (CHANGE));\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_ALL_INCDEC_ARITH(VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      TEST_INCDEC_ARITH ((VALUE), ++, , 1, 1);\t\\\n+      TEST_INCDEC_ARITH ((VALUE), --, , 1, -1);\t\\\n+      TEST_INCDEC_ARITH ((VALUE), , ++, 0, 1);\t\\\n+      TEST_INCDEC_ARITH ((VALUE), , --, 0, -1);\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+static void\n+test_incdec (void)\n+{\n+  TEST_ALL_INCDEC_ARITH (0);\n+  TEST_ALL_INCDEC_ARITH (1);\n+  TEST_ALL_INCDEC_ARITH (2);\n+  TEST_ALL_INCDEC_ARITH (-1);\n+  TEST_ALL_INCDEC_ARITH (1ULL << 60);\n+  TEST_ALL_INCDEC_ARITH (1.5);\n+  static int ia[2];\n+  TEST_INCDEC (int *, &ia[1], ++, , 1, 1);\n+  TEST_INCDEC (int *, &ia[1], --, , 1, -1);\n+  TEST_INCDEC (int *, &ia[1], , ++, 0, 1);\n+  TEST_INCDEC (int *, &ia[1], , --, 0, -1);\n+}\n+\n+int\n+main (void)\n+{\n+  test_incdec ();\n+  exit (0);\n+}"}, {"sha": "02bb3cb796089c5ae67be8f38c8959e2d8911788", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-4.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-4.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,208 @@\n+/* Test for _Atomic in C11.  Test that compare-and-exchange is\n+   operating properly when operations on the same variable are carried\n+   out in two threads.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors -pthread -D_POSIX_C_SOURCE=200809L\" } */\n+/* { dg-require-effective-target pthread } */\n+\n+#include <stdint.h>\n+#include <pthread.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define ITER_COUNT 10000\n+\n+static volatile _Atomic bool thread_ready;\n+\n+/* Generate test code (with NAME used to name functions and variables)\n+   for atomic compound assignments to a variable of type LHSTYPE.  The\n+   variable is initialized to INIT, then PRE var POST is executed\n+   ITER_COUNT times in each of two threads, and the final result\n+   should be FINAL.  A function test_main_##NAME is generated that\n+   returns nonzero on failure, zero on success.  */\n+\n+#define TEST_FUNCS(NAME, LHSTYPE, PRE, POST, INIT, FINAL)\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static volatile _Atomic LHSTYPE var_##NAME = (INIT);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void *\t\t\t\t\t\t\t\t\\\n+test_thread_##NAME (void *arg)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  thread_ready = true;\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < ITER_COUNT; i++)\t\t\t\t\t\\\n+    PRE var_##NAME POST;\t\t\t\t\t\t\\\n+  return NULL;\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static int\t\t\t\t\t\t\t\t\\\n+test_main_##NAME (void)\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  thread_ready = false;\t\t\t\t\t\t\t\\\n+  pthread_t thread_id;\t\t\t\t\t\t\t\\\n+  int pret = pthread_create (&thread_id, NULL, test_thread_##NAME,\t\\\n+\t\t\t     NULL);\t\t\t\t\t\\\n+  if (pret != 0)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (\"pthread_create failed: %d\\n\", pret);\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (!thread_ready)\t\t\t\t\t\t\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < ITER_COUNT; i++)\t\t\t\t\t\\\n+    PRE var_##NAME POST;\t\t\t\t\t\t\\\n+  pthread_join (thread_id, NULL);\t\t\t\t\t\\\n+  if (var_##NAME != (FINAL))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (#NAME \" failed\\n\");\t\t\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (#NAME \" passed\\n\");\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+TEST_FUNCS (uint8_add, uint8_t, , += 1, 0, (uint8_t) 20000)\n+TEST_FUNCS (uint8_add_3, uint8_t, , += 3, 0, (uint8_t) 60000)\n+TEST_FUNCS (uint16_add, uint16_t, , += 1, 0, (uint16_t) 20000)\n+TEST_FUNCS (uint16_add_3, uint16_t, , += 3, 0, (uint16_t) 60000)\n+TEST_FUNCS (uint32_add, uint32_t, , += 1, 0, (uint32_t) 20000)\n+TEST_FUNCS (uint32_add_3, uint32_t, , += 3, 0, (uint32_t) 60000)\n+TEST_FUNCS (uint64_add, uint64_t, , += 1, 0, (uint64_t) 20000)\n+TEST_FUNCS (uint64_add_3, uint64_t, , += 3, 0, (uint64_t) 60000)\n+TEST_FUNCS (uint64_add_neg, uint64_t, , += 1, -10000, (uint64_t) 10000)\n+TEST_FUNCS (float_add, float, , += 1, 0, 20000)\n+TEST_FUNCS (double_add, double, , += 1, 0, 20000)\n+TEST_FUNCS (long_double_add, long double, , += 1, 0, 20000)\n+TEST_FUNCS (complex_float_add, _Complex float, , += 1, 0, 20000)\n+TEST_FUNCS (complex_double_add, _Complex double, , += 1, 0, 20000)\n+TEST_FUNCS (complex_long_double_add, _Complex long double, , += 1, 0, 20000)\n+TEST_FUNCS (uint8_postinc, uint8_t, , ++, 0, (uint8_t) 20000)\n+TEST_FUNCS (uint16_postinc, uint16_t, , ++, 0, (uint16_t) 20000)\n+TEST_FUNCS (uint32_postinc, uint32_t, , ++, 0, (uint32_t) 20000)\n+TEST_FUNCS (uint64_postinc, uint64_t, , ++, 0, (uint64_t) 20000)\n+TEST_FUNCS (uint64_postinc_neg, uint64_t, , ++, -10000, (uint64_t) 10000)\n+TEST_FUNCS (float_postinc, float, , ++, 0, 20000)\n+TEST_FUNCS (double_postinc, double, , ++, 0, 20000)\n+TEST_FUNCS (long_double_postinc, long double, , ++, 0, 20000)\n+TEST_FUNCS (uint8_preinc, uint8_t, ++, , 0, (uint8_t) 20000)\n+TEST_FUNCS (uint16_preinc, uint16_t, ++, , 0, (uint16_t) 20000)\n+TEST_FUNCS (uint32_preinc, uint32_t, ++, , 0, (uint32_t) 20000)\n+TEST_FUNCS (uint64_preinc, uint64_t, ++, , 0, (uint64_t) 20000)\n+TEST_FUNCS (uint64_preinc_neg, uint64_t, ++, , -10000, (uint64_t) 10000)\n+TEST_FUNCS (float_preinc, float, ++, , 0, 20000)\n+TEST_FUNCS (double_preinc, double, ++, , 0, 20000)\n+TEST_FUNCS (long_double_preinc, long double, ++, , 0, 20000)\n+TEST_FUNCS (uint8_sub, uint8_t, , -= 1, 0, (uint8_t) -20000)\n+TEST_FUNCS (uint8_sub_3, uint8_t, , -= 3, 0, (uint8_t) -60000)\n+TEST_FUNCS (uint16_sub, uint16_t, , -= 1, 0, (uint16_t) -20000)\n+TEST_FUNCS (uint16_sub_3, uint16_t, , -= 3, 0, (uint16_t) -60000)\n+TEST_FUNCS (uint32_sub, uint32_t, , -= 1, 0, (uint32_t) -20000)\n+TEST_FUNCS (uint32_sub_3, uint32_t, , -= 3, 0, (uint32_t) -60000)\n+TEST_FUNCS (uint64_sub, uint64_t, , -= 1, 0, (uint64_t) -20000)\n+TEST_FUNCS (uint64_sub_3, uint64_t, , -= 3, 0, (uint64_t) -60000)\n+TEST_FUNCS (uint64_sub_neg, uint64_t, , -= 1, 10000, (uint64_t) -10000)\n+TEST_FUNCS (float_sub, float, , -= 1, 0, -20000)\n+TEST_FUNCS (double_sub, double, , -= 1, 0, -20000)\n+TEST_FUNCS (long_double_sub, long double, , -= 1, 0, -20000)\n+TEST_FUNCS (complex_float_sub, _Complex float, , -= 1, 0, -20000)\n+TEST_FUNCS (complex_double_sub, _Complex double, , -= 1, 0, -20000)\n+TEST_FUNCS (complex_long_double_sub, _Complex long double, , -= 1, 0, -20000)\n+TEST_FUNCS (uint8_postdec, uint8_t, , --, 0, (uint8_t) -20000)\n+TEST_FUNCS (uint16_postdec, uint16_t, , --, 0, (uint16_t) -20000)\n+TEST_FUNCS (uint32_postdec, uint32_t, , --, 0, (uint32_t) -20000)\n+TEST_FUNCS (uint64_postdec, uint64_t, , --, 0, (uint64_t) -20000)\n+TEST_FUNCS (uint64_postdec_neg, uint64_t, , --, 10000, (uint64_t) -10000)\n+TEST_FUNCS (float_postdec, float, , --, 0, -20000)\n+TEST_FUNCS (double_postdec, double, , --, 0, -20000)\n+TEST_FUNCS (long_double_postdec, long double, , --, 0, -20000)\n+TEST_FUNCS (uint8_predec, uint8_t, --, , 0, (uint8_t) -20000)\n+TEST_FUNCS (uint16_predec, uint16_t, --, , 0, (uint16_t) -20000)\n+TEST_FUNCS (uint32_predec, uint32_t, --, , 0, (uint32_t) -20000)\n+TEST_FUNCS (uint64_predec, uint64_t, --, , 0, (uint64_t) -20000)\n+TEST_FUNCS (uint64_predec_neg, uint64_t, --, , 10000, (uint64_t) -10000)\n+TEST_FUNCS (float_predec, float, --, , 0, -20000)\n+TEST_FUNCS (double_predec, double, --, , 0, -20000)\n+TEST_FUNCS (long_double_predec, long double, --, , 0, -20000)\n+TEST_FUNCS (uint8_mul, uint8_t, , *= 3, 1, (uint8_t) 0x81)\n+TEST_FUNCS (uint16_mul, uint16_t, , *= 3, 1, (uint16_t) 0x9681)\n+TEST_FUNCS (uint32_mul, uint32_t, , *= 3, 1, (uint32_t) 0x62b49681U)\n+TEST_FUNCS (uint64_mul, uint64_t, , *= 3, 1, (uint64_t) 0xcd926beb62b49681ULL)\n+\n+int\n+main (void)\n+{\n+  int ret = 0;\n+  ret |= test_main_uint8_add ();\n+  ret |= test_main_uint8_add_3 ();\n+  ret |= test_main_uint16_add ();\n+  ret |= test_main_uint16_add_3 ();\n+  ret |= test_main_uint32_add ();\n+  ret |= test_main_uint32_add_3 ();\n+  ret |= test_main_uint64_add ();\n+  ret |= test_main_uint64_add_3 ();\n+  ret |= test_main_uint64_add_neg ();\n+  ret |= test_main_float_add ();\n+  ret |= test_main_double_add ();\n+  ret |= test_main_long_double_add ();\n+  ret |= test_main_complex_float_add ();\n+  ret |= test_main_complex_double_add ();\n+  ret |= test_main_complex_long_double_add ();\n+  ret |= test_main_uint8_postinc ();\n+  ret |= test_main_uint16_postinc ();\n+  ret |= test_main_uint32_postinc ();\n+  ret |= test_main_uint64_postinc ();\n+  ret |= test_main_uint64_postinc_neg ();\n+  ret |= test_main_float_postinc ();\n+  ret |= test_main_double_postinc ();\n+  ret |= test_main_long_double_postinc ();\n+  ret |= test_main_uint8_preinc ();\n+  ret |= test_main_uint16_preinc ();\n+  ret |= test_main_uint32_preinc ();\n+  ret |= test_main_uint64_preinc ();\n+  ret |= test_main_uint64_preinc_neg ();\n+  ret |= test_main_float_preinc ();\n+  ret |= test_main_double_preinc ();\n+  ret |= test_main_long_double_preinc ();\n+  ret |= test_main_uint8_sub ();\n+  ret |= test_main_uint8_sub_3 ();\n+  ret |= test_main_uint16_sub ();\n+  ret |= test_main_uint16_sub_3 ();\n+  ret |= test_main_uint32_sub ();\n+  ret |= test_main_uint32_sub_3 ();\n+  ret |= test_main_uint64_sub ();\n+  ret |= test_main_uint64_sub_3 ();\n+  ret |= test_main_uint64_sub_neg ();\n+  ret |= test_main_float_sub ();\n+  ret |= test_main_double_sub ();\n+  ret |= test_main_long_double_sub ();\n+  ret |= test_main_complex_float_sub ();\n+  ret |= test_main_complex_double_sub ();\n+  ret |= test_main_complex_long_double_sub ();\n+  ret |= test_main_uint8_postdec ();\n+  ret |= test_main_uint16_postdec ();\n+  ret |= test_main_uint32_postdec ();\n+  ret |= test_main_uint64_postdec ();\n+  ret |= test_main_uint64_postdec_neg ();\n+  ret |= test_main_float_postdec ();\n+  ret |= test_main_double_postdec ();\n+  ret |= test_main_long_double_postdec ();\n+  ret |= test_main_uint8_predec ();\n+  ret |= test_main_uint16_predec ();\n+  ret |= test_main_uint32_predec ();\n+  ret |= test_main_uint64_predec ();\n+  ret |= test_main_uint64_predec_neg ();\n+  ret |= test_main_float_predec ();\n+  ret |= test_main_double_predec ();\n+  ret |= test_main_long_double_predec ();\n+  ret |= test_main_uint8_mul ();\n+  ret |= test_main_uint16_mul ();\n+  ret |= test_main_uint32_mul ();\n+  ret |= test_main_uint64_mul ();\n+  if (ret)\n+    abort ();\n+  else\n+    exit (0);\n+}"}, {"sha": "9e6977b42860db31c876f45788ec01b06243dfc7", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c", "status": "added", "additions": 541, "deletions": 0, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-5.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,541 @@\n+/* Test for _Atomic in C11.  Test floating-point exceptions for\n+   compound assignment are consistent with result (so that if multiple\n+   iterations of the compare-and-exchange loop are needed, exceptions\n+   get properly cleared).  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors -pthread -D_POSIX_C_SOURCE=200809L\" } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+/* { dg-require-effective-target pthread } */\n+\n+#include <fenv.h>\n+#include <float.h>\n+#include <pthread.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define TEST_ALL_EXCEPT (FE_DIVBYZERO\t\t\\\n+\t\t\t | FE_INEXACT\t\t\\\n+\t\t\t | FE_INVALID\t\t\\\n+\t\t\t | FE_OVERFLOW\t\t\\\n+\t\t\t | FE_UNDERFLOW)\n+\n+#define ITER_COUNT 10000\n+\n+static volatile _Atomic bool thread_ready, thread_stop;\n+\n+/* Generate test code (with NAME used to name functions and variables)\n+   for atomic compound assignments to a variable of type LHSTYPE.  One\n+   thread repeatedly stores the values INIT1 and INIT2 in a variable,\n+   while the other repeatedly executes PRE var POST having set\n+   floating-point exceptions to BEXC.  If the value of the assignment\n+   operation satisfies VALTEST1 (var), the floating-point exceptions\n+   should be BEXC | EXC1; otherwise, they should be BEXC | EXC2.  A\n+   function test_main_##NAME is generated that returns nonzero on\n+   failure, zero on success.  */\n+\n+#define TEST_FUNCS(NAME, LHSTYPE, PRE, POST, BEXC,\t\t\t\\\n+\t\t   INIT1, VALTEST1, EXC1, INIT2, EXC2)\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static volatile _Atomic LHSTYPE var_##NAME;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void *\t\t\t\t\t\t\t\t\\\n+test_thread_##NAME (void *arg)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  thread_ready = true;\t\t\t\t\t\t\t\\\n+  while (!thread_stop)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      var_##NAME = (INIT1);\t\t\t\t\t\t\\\n+      var_##NAME = (INIT2);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  return NULL;\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static int\t\t\t\t\t\t\t\t\\\n+test_main_##NAME (void)\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  thread_stop = false;\t\t\t\t\t\t\t\\\n+  thread_ready = false;\t\t\t\t\t\t\t\\\n+  var_##NAME = (INIT1);\t\t\t\t\t\t\t\\\n+  pthread_t thread_id;\t\t\t\t\t\t\t\\\n+  int pret = pthread_create (&thread_id, NULL, test_thread_##NAME,\t\\\n+\t\t\t     NULL);\t\t\t\t\t\\\n+  if (pret != 0)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (\"pthread_create failed: %d\\n\", pret);\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  int num_1_pass = 0, num_1_fail = 0, num_2_pass = 0, num_2_fail = 0;\t\\\n+  while (!thread_ready)\t\t\t\t\t\t\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < ITER_COUNT; i++)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      feclearexcept (FE_ALL_EXCEPT);\t\t\t\t\t\\\n+      feraiseexcept (BEXC);\t\t\t\t\t\t\\\n+      LHSTYPE r = (PRE var_##NAME POST);\t\t\t\t\\\n+      int rexc = fetestexcept (TEST_ALL_EXCEPT);\t\t\t\\\n+      if (VALTEST1 (r))\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (rexc == ((BEXC) | (EXC1)))\t\t\t\t\\\n+\t    num_1_pass++;\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    num_1_fail++;\t\t\t\t\t\t\\\n+\t  var_##NAME = (INIT2);\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (rexc == ((BEXC) | (EXC2)))\t\t\t\t\\\n+\t    num_2_pass++;\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    num_2_fail++;\t\t\t\t\t\t\\\n+\t  var_##NAME = (INIT1);\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  thread_stop = true;\t\t\t\t\t\t\t\\\n+  pthread_join (thread_id, NULL);\t\t\t\t\t\\\n+  printf (#NAME \" (a) %d pass, %d fail; (b) %d pass, %d fail\\n\",\t\\\n+\t  num_1_pass, num_1_fail, num_2_pass, num_2_fail);\t\t\\\n+  return num_1_fail || num_2_fail;\t\t\t\t\t\\\n+}\n+\n+TEST_FUNCS (float_add_invalid, float, , += __builtin_inff (), 0,\n+\t    0, __builtin_isinf, 0,\n+\t    -__builtin_inff (), FE_INVALID)\n+TEST_FUNCS (float_add_invalid_prev, float, , += __builtin_inff (),\n+\t    FE_DIVBYZERO | FE_INEXACT | FE_OVERFLOW | FE_UNDERFLOW,\n+\t    0, __builtin_isinf, 0,\n+\t    -__builtin_inff (), FE_INVALID)\n+TEST_FUNCS (float_add_overflow, float, , += FLT_MAX, 0,\n+\t    FLT_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_add_overflow_prev, float, , += FLT_MAX, FE_INVALID,\n+\t    FLT_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_add_overflow_double, float, , += (double) FLT_MAX, 0,\n+\t    FLT_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_add_overflow_long_double, float, , += (long double) FLT_MAX, 0,\n+\t    FLT_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+#define NOT_FLT_EPSILON_2(X) ((X) != FLT_EPSILON / 2)\n+TEST_FUNCS (float_add_inexact, float, , += FLT_EPSILON / 2, 0,\n+\t    1.0f, NOT_FLT_EPSILON_2, FE_INEXACT,\n+\t    0, 0)\n+#define NOT_0(X) ((X) != 0)\n+TEST_FUNCS (float_add_inexact_int, float, , += 1, 0,\n+\t    FLT_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    -1, 0)\n+TEST_FUNCS (float_preinc_inexact, float, ++, , 0,\n+\t    FLT_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    -1, 0)\n+#define NOT_MINUS_1(X) ((X) != -1)\n+TEST_FUNCS (float_postinc_inexact, float, , ++, 0,\n+\t    FLT_EPSILON / 2, NOT_MINUS_1, FE_INEXACT,\n+\t    -1, 0)\n+#if FLT_EVAL_METHOD == 0\n+TEST_FUNCS (long_add_float_inexact, long, , += 2 / FLT_EPSILON, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    -2 / FLT_EPSILON, 0)\n+#endif\n+#define REAL_ISINF(X) (__builtin_isinf (__real__ (X)))\n+TEST_FUNCS (complex_float_add_overflow, _Complex float, , += FLT_MAX, 0,\n+\t    FLT_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_sub_invalid, float, , -= __builtin_inff (), 0,\n+\t    0, __builtin_isinf, 0,\n+\t    __builtin_inff (), FE_INVALID)\n+TEST_FUNCS (float_sub_overflow, float, , -= FLT_MAX, 0,\n+\t    -FLT_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+#define NOT_MINUS_FLT_EPSILON_2(X) ((X) != -FLT_EPSILON / 2)\n+TEST_FUNCS (float_sub_inexact, float, , -= FLT_EPSILON / 2, 0,\n+\t    -1.0f, NOT_MINUS_FLT_EPSILON_2, FE_INEXACT,\n+\t    0, 0)\n+#define NOT_0(X) ((X) != 0)\n+TEST_FUNCS (float_sub_inexact_int, float, , -= 1, 0,\n+\t    -FLT_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    1, 0)\n+TEST_FUNCS (float_predec_inexact, float, --, , 0,\n+\t    -FLT_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    1, 0)\n+#define NOT_1(X) ((X) != 1)\n+TEST_FUNCS (float_postdec_inexact, float, , --, 0,\n+\t    -FLT_EPSILON / 2, NOT_1, FE_INEXACT,\n+\t    1, 0)\n+#if FLT_EVAL_METHOD == 0\n+TEST_FUNCS (long_sub_float_inexact, long, , -= 2 / FLT_EPSILON, 0,\n+\t    -1, NOT_0, FE_INEXACT,\n+\t    2 / FLT_EPSILON, 0)\n+#endif\n+TEST_FUNCS (complex_float_sub_overflow, _Complex float, , -= FLT_MAX, 0,\n+\t    -FLT_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_mul_invalid, float, , *= __builtin_inff (), 0,\n+\t    __builtin_inff (), __builtin_isinf, 0,\n+\t    0, FE_INVALID)\n+TEST_FUNCS (float_mul_overflow, float, , *= FLT_MAX, 0,\n+\t    FLT_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+#define IS_0(X) ((X) == 0)\n+TEST_FUNCS (float_mul_underflow, float, , *= FLT_MIN, 0,\n+\t    FLT_MIN, IS_0, FE_UNDERFLOW | FE_INEXACT,\n+\t    1, 0)\n+TEST_FUNCS (float_mul_inexact, float, , *= 1 + FLT_EPSILON, 0,\n+\t    1 + FLT_EPSILON, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_mul_inexact_int, float, , *= 3, 0,\n+\t    1 + FLT_EPSILON, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+#if FLT_EVAL_METHOD == 0\n+TEST_FUNCS(long_mul_float_inexact, long, , *= 3.0f, 0,\n+\t   1 + 1 / FLT_EPSILON, NOT_0, FE_INEXACT,\n+\t   0, 0)\n+#endif\n+TEST_FUNCS (complex_float_mul_overflow, _Complex float, , *= FLT_MAX, 0,\n+\t    FLT_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_div_invalid_divbyzero, float, , /= 0.0f, 0,\n+\t    1, __builtin_isinf, FE_DIVBYZERO,\n+\t    0, FE_INVALID)\n+TEST_FUNCS (float_div_overflow, float, , /= FLT_MIN, 0,\n+\t    FLT_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_div_underflow, float, , /= FLT_MAX, 0,\n+\t    FLT_MIN, IS_0, FE_UNDERFLOW | FE_INEXACT,\n+\t    FLT_MAX, 0)\n+TEST_FUNCS (float_div_inexact, float, , /= 3.0f, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (float_div_inexact_int, float, , /= 3, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (int_div_float_inexact, int, , /= 3.0f, 0,\n+\t    4, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (complex_float_div_overflow, _Complex float, , /= FLT_MIN, 0,\n+\t    FLT_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+\n+TEST_FUNCS (double_add_invalid, double, , += __builtin_inf (), 0,\n+\t    0, __builtin_isinf, 0,\n+\t    -__builtin_inf (), FE_INVALID)\n+TEST_FUNCS (double_add_overflow, double, , += DBL_MAX, 0,\n+\t    DBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_add_overflow_long_double, double, , += (long double) DBL_MAX, 0,\n+\t    DBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+#define NOT_DBL_EPSILON_2(X) ((X) != DBL_EPSILON / 2)\n+TEST_FUNCS (double_add_inexact, double, , += DBL_EPSILON / 2, 0,\n+\t    1.0, NOT_DBL_EPSILON_2, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_add_inexact_int, double, , += 1, 0,\n+\t    DBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    -1, 0)\n+TEST_FUNCS (double_preinc_inexact, double, ++, , 0,\n+\t    DBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    -1, 0)\n+TEST_FUNCS (double_postinc_inexact, double, , ++, 0,\n+\t    DBL_EPSILON / 2, NOT_MINUS_1, FE_INEXACT,\n+\t    -1, 0)\n+#if FLT_EVAL_METHOD == 0\n+TEST_FUNCS (long_long_add_double_inexact, long long, , += 2 / DBL_EPSILON, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    -2 / DBL_EPSILON, 0)\n+#endif\n+TEST_FUNCS (complex_double_add_overflow, _Complex double, , += DBL_MAX, 0,\n+\t    DBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_sub_invalid, double, , -= __builtin_inf (), 0,\n+\t    0, __builtin_isinf, 0,\n+\t    __builtin_inf (), FE_INVALID)\n+TEST_FUNCS (double_sub_overflow, double, , -= DBL_MAX, 0,\n+\t    -DBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+#define NOT_MINUS_DBL_EPSILON_2(X) ((X) != -DBL_EPSILON / 2)\n+TEST_FUNCS (double_sub_inexact, double, , -= DBL_EPSILON / 2, 0,\n+\t    -1.0, NOT_MINUS_DBL_EPSILON_2, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_sub_inexact_int, double, , -= 1, 0,\n+\t    -DBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    1, 0)\n+TEST_FUNCS (double_predec_inexact, double, --, , 0,\n+\t    -DBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    1, 0)\n+TEST_FUNCS (double_postdec_inexact, double, , --, 0,\n+\t    -DBL_EPSILON / 2, NOT_1, FE_INEXACT,\n+\t    1, 0)\n+#if FLT_EVAL_METHOD == 0\n+TEST_FUNCS (long_long_sub_double_inexact, long long, , -= 2 / DBL_EPSILON, 0,\n+\t    -1, NOT_0, FE_INEXACT,\n+\t    2 / DBL_EPSILON, 0)\n+#endif\n+TEST_FUNCS (complex_double_sub_overflow, _Complex double, , -= DBL_MAX, 0,\n+\t    -DBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_mul_invalid, double, , *= __builtin_inf (), 0,\n+\t    __builtin_inf (), __builtin_isinf, 0,\n+\t    0, FE_INVALID)\n+TEST_FUNCS (double_mul_overflow, double, , *= DBL_MAX, 0,\n+\t    DBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_mul_overflow_float, double, , *= FLT_MAX, 0,\n+\t    DBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_mul_underflow, double, , *= DBL_MIN, 0,\n+\t    DBL_MIN, IS_0, FE_UNDERFLOW | FE_INEXACT,\n+\t    1, 0)\n+TEST_FUNCS (double_mul_inexact, double, , *= 1 + DBL_EPSILON, 0,\n+\t    1 + DBL_EPSILON, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_mul_inexact_int, double, , *= 3, 0,\n+\t    1 + DBL_EPSILON, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+#if FLT_EVAL_METHOD == 0\n+TEST_FUNCS(long_long_mul_double_inexact, long long, , *= 3.0, 0,\n+\t   1 + 1 / DBL_EPSILON, NOT_0, FE_INEXACT,\n+\t   0, 0)\n+#endif\n+TEST_FUNCS (complex_double_mul_overflow, _Complex double, , *= DBL_MAX, 0,\n+\t    DBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_div_invalid_divbyzero, double, , /= 0.0, 0,\n+\t    1, __builtin_isinf, FE_DIVBYZERO,\n+\t    0, FE_INVALID)\n+TEST_FUNCS (double_div_overflow, double, , /= DBL_MIN, 0,\n+\t    DBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_div_underflow, double, , /= DBL_MAX, 0,\n+\t    DBL_MIN, IS_0, FE_UNDERFLOW | FE_INEXACT,\n+\t    DBL_MAX, 0)\n+TEST_FUNCS (double_div_inexact, double, , /= 3.0, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (double_div_inexact_int, double, , /= 3, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (int_div_double_inexact, int, , /= 3.0, 0,\n+\t    4, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (complex_double_div_overflow, _Complex double, , /= DBL_MIN, 0,\n+\t    DBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+\n+TEST_FUNCS (long_double_add_invalid, long double, , += __builtin_infl (), 0,\n+\t    0, __builtin_isinf, 0,\n+\t    -__builtin_infl (), FE_INVALID)\n+TEST_FUNCS (long_double_add_overflow, long double, , += LDBL_MAX, 0,\n+\t    LDBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+#define NOT_LDBL_EPSILON_2(X) ((X) != LDBL_EPSILON / 2)\n+#if LDBL_MANT_DIG != 106\n+TEST_FUNCS (long_double_add_inexact, long double, , += LDBL_EPSILON / 2, 0,\n+\t    1.0L, NOT_LDBL_EPSILON_2, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_add_inexact_int, long double, , += 1, 0,\n+\t    LDBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    -1, 0)\n+TEST_FUNCS (long_double_preinc_inexact, long double, ++, , 0,\n+\t    LDBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    -1, 0)\n+TEST_FUNCS (long_double_postinc_inexact, long double, , ++, 0,\n+\t    LDBL_EPSILON / 2, NOT_MINUS_1, FE_INEXACT,\n+\t    -1, 0)\n+#endif\n+TEST_FUNCS (complex_long_double_add_overflow, _Complex long double, , += LDBL_MAX, 0,\n+\t    LDBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_sub_invalid, long double, , -= __builtin_infl (), 0,\n+\t    0, __builtin_isinf, 0,\n+\t    __builtin_infl (), FE_INVALID)\n+TEST_FUNCS (long_double_sub_overflow, long double, , -= LDBL_MAX, 0,\n+\t    -LDBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+#define NOT_MINUS_LDBL_EPSILON_2(X) ((X) != -LDBL_EPSILON / 2)\n+#if LDBL_MANT_DIG != 106\n+TEST_FUNCS (long_double_sub_inexact, long double, , -= LDBL_EPSILON / 2, 0,\n+\t    -1.0L, NOT_MINUS_LDBL_EPSILON_2, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_sub_inexact_int, long double, , -= 1, 0,\n+\t    -LDBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    1, 0)\n+TEST_FUNCS (long_double_predec_inexact, long double, --, , 0,\n+\t    -LDBL_EPSILON / 2, NOT_0, FE_INEXACT,\n+\t    1, 0)\n+TEST_FUNCS (long_double_postdec_inexact, long double, , --, 0,\n+\t    -LDBL_EPSILON / 2, NOT_1, FE_INEXACT,\n+\t    1, 0)\n+#endif\n+TEST_FUNCS (complex_long_double_sub_overflow, _Complex long double, , -= LDBL_MAX, 0,\n+\t    -LDBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_mul_invalid, long double, , *= __builtin_infl (), 0,\n+\t    __builtin_infl (), __builtin_isinf, 0,\n+\t    0, FE_INVALID)\n+TEST_FUNCS (long_double_mul_overflow, long double, , *= LDBL_MAX, 0,\n+\t    LDBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_mul_overflow_float, long double, , *= FLT_MAX, 0,\n+\t    LDBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_mul_overflow_double, long double, , *= DBL_MAX, 0,\n+\t    LDBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_mul_underflow, long double, , *= LDBL_MIN, 0,\n+\t    LDBL_MIN, IS_0, FE_UNDERFLOW | FE_INEXACT,\n+\t    1, 0)\n+#if LDBL_MANT_DIG != 106\n+TEST_FUNCS (long_double_mul_inexact, long double, , *= 1 + LDBL_EPSILON, 0,\n+\t    1 + LDBL_EPSILON, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_mul_inexact_int, long double, , *= 3, 0,\n+\t    1 + LDBL_EPSILON, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+#endif\n+TEST_FUNCS (complex_long_double_mul_overflow, _Complex long double, , *= LDBL_MAX, 0,\n+\t    LDBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_div_invalid_divbyzero, long double, , /= 0.0L, 0,\n+\t    1, __builtin_isinf, FE_DIVBYZERO,\n+\t    0, FE_INVALID)\n+TEST_FUNCS (long_double_div_overflow, long double, , /= LDBL_MIN, 0,\n+\t    LDBL_MAX, __builtin_isinf, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_div_underflow, long double, , /= LDBL_MAX, 0,\n+\t    LDBL_MIN, IS_0, FE_UNDERFLOW | FE_INEXACT,\n+\t    LDBL_MAX, 0)\n+TEST_FUNCS (long_double_div_inexact, long double, , /= 3.0L, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (long_double_div_inexact_int, long double, , /= 3, 0,\n+\t    1, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (int_div_long_double_inexact, int, , /= 3.0L, 0,\n+\t    4, NOT_0, FE_INEXACT,\n+\t    0, 0)\n+TEST_FUNCS (complex_long_double_div_overflow, _Complex long double, , /= LDBL_MIN, 0,\n+\t    LDBL_MAX, REAL_ISINF, FE_OVERFLOW | FE_INEXACT,\n+\t    0, 0)\n+\n+int\n+main (void)\n+{\n+  int ret = 0;\n+  ret |= test_main_float_add_invalid ();\n+  ret |= test_main_float_add_invalid_prev ();\n+  ret |= test_main_float_add_overflow ();\n+  ret |= test_main_float_add_overflow_prev ();\n+  ret |= test_main_float_add_overflow_double ();\n+  ret |= test_main_float_add_overflow_long_double ();\n+  ret |= test_main_float_add_inexact ();\n+  ret |= test_main_float_add_inexact_int ();\n+  ret |= test_main_float_preinc_inexact ();\n+  ret |= test_main_float_postinc_inexact ();\n+#if FLT_EVAL_METHOD == 0\n+  ret |= test_main_long_add_float_inexact ();\n+#endif\n+  ret |= test_main_complex_float_add_overflow ();\n+  ret |= test_main_float_sub_invalid ();\n+  ret |= test_main_float_sub_overflow ();\n+  ret |= test_main_float_sub_inexact ();\n+  ret |= test_main_float_sub_inexact_int ();\n+  ret |= test_main_float_predec_inexact ();\n+  ret |= test_main_float_postdec_inexact ();\n+#if FLT_EVAL_METHOD == 0\n+  ret |= test_main_long_sub_float_inexact ();\n+#endif\n+  ret |= test_main_complex_float_sub_overflow ();\n+  ret |= test_main_float_mul_invalid ();\n+  ret |= test_main_float_mul_overflow ();\n+  ret |= test_main_float_mul_underflow ();\n+  ret |= test_main_float_mul_inexact ();\n+  ret |= test_main_float_mul_inexact_int ();\n+#if FLT_EVAL_METHOD == 0\n+  ret |= test_main_long_mul_float_inexact ();\n+#endif\n+  ret |= test_main_complex_float_mul_overflow ();\n+  ret |= test_main_float_div_invalid_divbyzero ();\n+  ret |= test_main_float_div_overflow ();\n+  ret |= test_main_float_div_underflow ();\n+  ret |= test_main_float_div_inexact ();\n+  ret |= test_main_float_div_inexact_int ();\n+  ret |= test_main_int_div_float_inexact ();\n+  ret |= test_main_complex_float_div_overflow ();\n+  ret |= test_main_double_add_invalid ();\n+  ret |= test_main_double_add_overflow ();\n+  ret |= test_main_double_add_overflow_long_double ();\n+  ret |= test_main_double_add_inexact ();\n+  ret |= test_main_double_add_inexact_int ();\n+  ret |= test_main_double_preinc_inexact ();\n+  ret |= test_main_double_postinc_inexact ();\n+#if FLT_EVAL_METHOD == 0\n+  ret |= test_main_long_long_add_double_inexact ();\n+#endif\n+  ret |= test_main_complex_double_add_overflow ();\n+  ret |= test_main_double_sub_invalid ();\n+  ret |= test_main_double_sub_overflow ();\n+  ret |= test_main_double_sub_inexact ();\n+  ret |= test_main_double_sub_inexact_int ();\n+  ret |= test_main_double_predec_inexact ();\n+  ret |= test_main_double_postdec_inexact ();\n+#if FLT_EVAL_METHOD == 0\n+  ret |= test_main_long_long_sub_double_inexact ();\n+#endif\n+  ret |= test_main_complex_double_sub_overflow ();\n+  ret |= test_main_double_mul_invalid ();\n+  ret |= test_main_double_mul_overflow ();\n+  ret |= test_main_double_mul_overflow_float ();\n+  ret |= test_main_double_mul_underflow ();\n+  ret |= test_main_double_mul_inexact ();\n+  ret |= test_main_double_mul_inexact_int ();\n+#if FLT_EVAL_METHOD == 0\n+  ret |= test_main_long_long_mul_double_inexact ();\n+#endif\n+  ret |= test_main_complex_double_mul_overflow ();\n+  ret |= test_main_double_div_invalid_divbyzero ();\n+  ret |= test_main_double_div_overflow ();\n+  ret |= test_main_double_div_underflow ();\n+  ret |= test_main_double_div_inexact ();\n+  ret |= test_main_double_div_inexact_int ();\n+  ret |= test_main_int_div_double_inexact ();\n+  ret |= test_main_complex_double_div_overflow ();\n+  ret |= test_main_long_double_add_invalid ();\n+  ret |= test_main_long_double_add_overflow ();\n+#if LDBL_MANT_DIG != 106\n+  ret |= test_main_long_double_add_inexact ();\n+  ret |= test_main_long_double_add_inexact_int ();\n+  ret |= test_main_long_double_preinc_inexact ();\n+  ret |= test_main_long_double_postinc_inexact ();\n+#endif\n+  ret |= test_main_complex_long_double_add_overflow ();\n+  ret |= test_main_long_double_sub_invalid ();\n+  ret |= test_main_long_double_sub_overflow ();\n+#if LDBL_MANT_DIG != 106\n+  ret |= test_main_long_double_sub_inexact ();\n+  ret |= test_main_long_double_sub_inexact_int ();\n+  ret |= test_main_long_double_predec_inexact ();\n+  ret |= test_main_long_double_postdec_inexact ();\n+#endif\n+  ret |= test_main_complex_long_double_sub_overflow ();\n+  ret |= test_main_long_double_mul_invalid ();\n+  ret |= test_main_long_double_mul_overflow ();\n+  ret |= test_main_long_double_mul_overflow_float ();\n+  ret |= test_main_long_double_mul_overflow_double ();\n+  ret |= test_main_long_double_mul_underflow ();\n+#if LDBL_MANT_DIG != 106\n+  ret |= test_main_long_double_mul_inexact ();\n+  ret |= test_main_long_double_mul_inexact_int ();\n+#endif\n+  ret |= test_main_complex_long_double_mul_overflow ();\n+  ret |= test_main_long_double_div_invalid_divbyzero ();\n+  ret |= test_main_long_double_div_overflow ();\n+  ret |= test_main_long_double_div_underflow ();\n+  ret |= test_main_long_double_div_inexact ();\n+  ret |= test_main_long_double_div_inexact_int ();\n+  ret |= test_main_int_div_long_double_inexact ();\n+  ret |= test_main_complex_long_double_div_overflow ();\n+  if (ret != 0)\n+    abort ();\n+  else\n+    exit (0);\n+}"}, {"sha": "c7f9a1ef464c5c3b869cbcf4e266e601ea20dce7", "filename": "gcc/testsuite/gcc.dg/c11-atomic-1.c", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-1.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,267 @@\n+/* Test for _Atomic in C11.  Test of valid code.  See c11-atomic-2.c\n+   for more exhaustive tests of assignment cases.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+/* The use of _Atomic as a qualifier, and of _Atomic (type-name), give\n+   the same type.  */\n+extern _Atomic int a;\n+extern _Atomic (int) a;\n+extern int *_Atomic b;\n+extern _Atomic (int *) b;\n+extern void f (int [_Atomic]);\n+extern void f (int *_Atomic);\n+\n+/* _Atomic may be applied to arbitrary types, with or without other\n+   qualifiers, and assignments may be made as with non-atomic\n+   types.  Structure and union elements may be atomic.  */\n+_Atomic int ai1, ai2;\n+int i1;\n+volatile _Atomic long double ald1;\n+const _Atomic long double ald2;\n+long double ld1;\n+_Atomic _Complex double acd1, acd2;\n+_Complex double d1;\n+_Atomic volatile _Bool ab1;\n+int *p;\n+int *_Atomic restrict ap;\n+struct s { char c[1000]; };\n+_Atomic struct s as1;\n+struct s s1;\n+struct t { _Atomic int i; };\n+_Atomic struct t at1;\n+_Atomic struct t *atp1;\n+struct t t1;\n+union u { char c[1000]; };\n+_Atomic union u au1;\n+union u u1;\n+union v { _Atomic int i; };\n+_Atomic union v av1;\n+union v v1;\n+\n+void\n+func (_Atomic volatile long al1)\n+{\n+  ai1 = ai2;\n+  ai1 = i1;\n+  i1 = ai2;\n+  ai1 = ald2;\n+  ald1 = d1;\n+  ld1 = acd2;\n+  acd1 += ab1;\n+  acd2 /= ai1;\n+  p = ap;\n+  ap = p;\n+  ab1 = p;\n+  as1 = s1;\n+  s1 = as1;\n+  at1 = t1;\n+  t1 = at1;\n+  /* It's unclear whether the undefined behavior (6.5.2.3#5) for\n+     accessing elements of atomic structures and unions is at\n+     translation or execution time; presume here that it's at\n+     execution time.  */\n+  t1.i = at1.i;\n+  at1.i = t1.i;\n+  atp1->i = t1.i;\n+  au1 = u1;\n+  u1 = au1;\n+  av1 = v1;\n+  v1 = av1;\n+  v1.i = av1.i;\n+  av1.i = v1.i;\n+  /* _Atomic is valid on register variables, even if not particularly\n+     useful.  */\n+  register _Atomic volatile int ra1 = 1, ra2 = 2;\n+  ra1 = ra2;\n+  ra2 = ra1;\n+  /* And on parameters.  */\n+  al1 = ra1;\n+  ra2 = al1;\n+}\n+\n+/* A function may return an atomic type.  */\n+_Atomic int\n+func2 (int i)\n+{\n+  return i;\n+}\n+\n+/* Casts may specify atomic type.  */\n+int\n+func3 (int i)\n+{\n+  return func2 ((_Atomic long) i);\n+}\n+\n+/* The _Atomic void type is valid.  */\n+_Atomic void *avp;\n+\n+/* An array of atomic elements is valid (the elements being atomic,\n+   not the array).  */\n+_Atomic int aa[10];\n+int\n+func4 (void)\n+{\n+  return aa[2];\n+}\n+\n+/* Increment and decrement are valid for atomic types when they are\n+   valid for non-atomic types.  */\n+void\n+func5 (void)\n+{\n+  ald1++;\n+  ald1--;\n+  ++ald1;\n+  --ald1;\n+  ai1++;\n+  ai1--;\n+  ++ai1;\n+  --ai1;\n+  ab1++;\n+  ab1--;\n+  ++ab1;\n+  --ab1;\n+  ap++;\n+  ap--;\n+  ++ap;\n+  --ap;\n+}\n+\n+/* Compound literals may have atomic type.  */\n+_Atomic int *aiclp = &(_Atomic int) { 1 };\n+\n+/* Test unary & and *.  */\n+void\n+func6 (void)\n+{\n+  int i = *aiclp;\n+  _Atomic int *p = &ai2;\n+}\n+\n+/* Casts to atomic type are valid (although the _Atomic has little\n+   effect because the result is an rvalue).  */\n+int i2 = (_Atomic int) 1.0;\n+\n+/* For pointer subtraction and comparisons, _Atomic does not count as\n+   a qualifier.  Likewise for conditional expressions.  */\n+_Atomic int *xaip1;\n+volatile _Atomic int *xaip2;\n+void *xvp1;\n+\n+void\n+func7 (void)\n+{\n+  int r;\n+  r = xaip1 - xaip2;\n+  r = xaip1 < xaip2;\n+  r = xaip1 > xaip2;\n+  r = xaip1 <= xaip2;\n+  r = xaip1 >= xaip2;\n+  r = xaip1 == xaip2;\n+  r = xaip1 != xaip2;\n+  r = xaip1 == xvp1;\n+  r = xaip1 != xvp1;\n+  r = xvp1 == xaip1;\n+  r = xvp1 != xaip1;\n+  r = xaip1 == 0;\n+  r = ((void *) 0) == xaip2;\n+  (void) (r ? xaip1 : xaip2);\n+  (void) (r ? xvp1 : xaip2);\n+  (void) (r ? xaip2 : xvp1);\n+  (void) (r ? xaip1 : 0);\n+  (void) (r ? 0 : xaip1);\n+  /* The result of a conditional expression between a pointer to\n+     qualified or unqualified (but not atomic) void, and a pointer to\n+     an atomic type, is a pointer to appropriately qualified, not\n+     atomic, void.  As such, it is valid to use further in conditional\n+     expressions with other pointer types.  */\n+  (void) (r ? xaip1 : (r ? xaip1 : xvp1));\n+}\n+\n+/* Pointer += and -= integer is valid.  */\n+void\n+func8 (void)\n+{\n+  b += 1;\n+  b -= 2ULL;\n+  ap += 3;\n+}\n+\n+/* Various other cases of simple assignment are valid (some already\n+   tested above).  */\n+void\n+func9 (void)\n+{\n+  ap = 0;\n+  ap = (void *) 0;\n+  xvp1 = atp1;\n+  atp1 = xvp1;\n+}\n+\n+/* Test compatibility of function types in cases where _Atomic matches\n+   (see c11-atomic-3.c for corresponding cases where it doesn't\n+   match).  */\n+void fc0a (int const);\n+void fc0a (int);\n+void fc0b (int _Atomic);\n+void fc0b (int _Atomic);\n+void fc1a (int);\n+void\n+fc1a (x)\n+     volatile int x;\n+{\n+}\n+void fc1b (_Atomic int);\n+void\n+fc1b (x)\n+     volatile _Atomic int x;\n+{\n+}\n+void\n+fc2a (x)\n+     const int x;\n+{\n+}\n+void fc2a (int); /* { dg-warning \"follows non-prototype\" } */\n+void\n+fc2b (x)\n+     _Atomic int x;\n+{\n+}\n+void fc2b (_Atomic int); /* { dg-warning \"follows non-prototype\" } */\n+void fc3a (int);\n+void\n+fc3a (x)\n+     volatile short x;\n+{\n+}\n+void fc3b (_Atomic int);\n+void\n+fc3b (x)\n+     _Atomic short x;\n+{\n+}\n+void\n+fc4a (x)\n+     const short x;\n+{\n+}\n+void fc4a (int); /* { dg-warning \"follows non-prototype\" } */\n+void\n+fc4b (x)\n+     _Atomic short x;\n+{\n+}\n+void fc4b (_Atomic int); /* { dg-warning \"follows non-prototype\" } */\n+\n+/* Test cases involving C_MAYBE_CONST_EXPR work.  */\n+void\n+func10 (_Atomic int *p)\n+{\n+  p[0 / 0] = 1; /* { dg-warning \"division by zero\" } */\n+  p[0 / 0] += 1; /* { dg-warning \"division by zero\" } */\n+  *p = 0 / 0; /* { dg-warning \"division by zero\" } */\n+  *p += 0 / 0; /* { dg-warning \"division by zero\" } */\n+}"}, {"sha": "34ee081d421e85f6e9fdfbc7030a5d91f5a3e85d", "filename": "gcc/testsuite/gcc.dg/c11-atomic-2.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-2.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,165 @@\n+/* Test for _Atomic in C11.  Test of valid assignment cases for\n+   arithmetic types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#define TEST_ASSIGN(TYPE1, OP, TYPE2)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _Atomic TYPE1 a = 0;\t\t\t\\\n+      TYPE2 b = 0;\t\t\t\t\\\n+      _Atomic TYPE2 c = 0;\t\t\t\\\n+      a OP b;\t\t\t\t\t\\\n+      a OP c;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_ASSIGN_ARITHR(TYPE1, OP)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, _Bool);\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, char);\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed char);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned char);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed short);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned short);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed int);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned int);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed long);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned long);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed long long);\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned long long);\t\\\n+      TEST_ASSIGN (TYPE1, OP, float);\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, double);\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, long double);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, _Complex float);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, _Complex double);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, _Complex long double);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_ASSIGN_ARITHBOTH(OP)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TEST_ASSIGN_ARITHR (_Bool, OP);\t\t\t\\\n+      TEST_ASSIGN_ARITHR (char, OP);\t\t\t\\\n+      TEST_ASSIGN_ARITHR (signed char, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (unsigned char, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (signed short, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (unsigned short, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (signed int, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (unsigned int, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (signed long, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (unsigned long, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (signed long long, OP);\t\\\n+      TEST_ASSIGN_ARITHR (unsigned long long, OP);\t\\\n+      TEST_ASSIGN_ARITHR (float, OP);\t\t\t\\\n+      TEST_ASSIGN_ARITHR (double, OP);\t\t\t\\\n+      TEST_ASSIGN_ARITHR (long double, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (_Complex float, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (_Complex double, OP);\t\t\\\n+      TEST_ASSIGN_ARITHR (_Complex long double, OP);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_ASSIGN_INTR(TYPE1, OP)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, _Bool);\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, char);\t\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed char);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned char);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed short);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned short);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed int);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned int);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed long);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned long);\t\t\\\n+      TEST_ASSIGN (TYPE1, OP, signed long long);\t\\\n+      TEST_ASSIGN (TYPE1, OP, unsigned long long);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_ASSIGN_INTBOTH(OP)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TEST_ASSIGN_INTR (_Bool, OP);\t\t\t\\\n+      TEST_ASSIGN_INTR (char, OP);\t\t\t\\\n+      TEST_ASSIGN_INTR (signed char, OP);\t\t\\\n+      TEST_ASSIGN_INTR (unsigned char, OP);\t\t\\\n+      TEST_ASSIGN_INTR (signed short, OP);\t\t\\\n+      TEST_ASSIGN_INTR (unsigned short, OP);\t\t\\\n+      TEST_ASSIGN_INTR (signed int, OP);\t\t\\\n+      TEST_ASSIGN_INTR (unsigned int, OP);\t\t\\\n+      TEST_ASSIGN_INTR (signed long, OP);\t\t\\\n+      TEST_ASSIGN_INTR (unsigned long, OP);\t\t\\\n+      TEST_ASSIGN_INTR (signed long long, OP);\t\t\\\n+      TEST_ASSIGN_INTR (unsigned long long, OP);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+void\n+test_simple (void)\n+{\n+  TEST_ASSIGN_ARITHBOTH (=);\n+}\n+\n+void\n+test_mult (void)\n+{\n+  TEST_ASSIGN_ARITHBOTH (*=);\n+}\n+\n+void\n+test_div (void)\n+{\n+  TEST_ASSIGN_ARITHBOTH (/=);\n+}\n+\n+void\n+test_mod (void)\n+{\n+  TEST_ASSIGN_INTBOTH (%=);\n+}\n+\n+void\n+test_plus (void)\n+{\n+  TEST_ASSIGN_ARITHBOTH (+=);\n+}\n+\n+void\n+test_minus (void)\n+{\n+  TEST_ASSIGN_ARITHBOTH (-=);\n+}\n+\n+void\n+test_lshift (void)\n+{\n+  TEST_ASSIGN_INTBOTH (<<=);\n+}\n+\n+void\n+test_rshift (void)\n+{\n+  TEST_ASSIGN_INTBOTH (>>=);\n+}\n+\n+void\n+test_and (void)\n+{\n+  TEST_ASSIGN_INTBOTH (&=);\n+}\n+\n+void\n+test_xor (void)\n+{\n+  TEST_ASSIGN_INTBOTH (^=);\n+}\n+\n+void\n+test_or (void)\n+{\n+  TEST_ASSIGN_INTBOTH (|=);\n+}"}, {"sha": "4b314e88ad559faaca882bf320f161986dfb4f1b", "filename": "gcc/testsuite/gcc.dg/c11-atomic-3.c", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-atomic-3.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,174 @@\n+/* Test for _Atomic in C11.  Test of invalid code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+/* Increment and decrement are invalid for atomic complex types and\n+   atomic pointers to incomplete types, just as for the corresponding\n+   non-atomic types.  Likewise for types on which arithmetic is\n+   invalid.  */\n+_Atomic _Complex float acf;\n+void *_Atomic apv;\n+struct s *_Atomic aps;\n+_Atomic struct t { char c; } as;\n+\n+void\n+func (void)\n+{\n+  acf++; /* { dg-error \"complex types\" } */\n+  acf--; /* { dg-error \"complex types\" } */\n+  ++acf; /* { dg-error \"complex types\" } */\n+  --acf; /* { dg-error \"complex types\" } */\n+  apv++; /* { dg-error \"wrong type|pointer of type\" } */\n+  apv--; /* { dg-error \"wrong type|pointer of type\" } */\n+  ++apv; /* { dg-error \"wrong type|pointer of type\" } */\n+  --apv; /* { dg-error \"wrong type|pointer of type\" } */\n+  aps++; /* { dg-error \"pointer to|invalid use of undefined type\" } */\n+  aps--; /* { dg-error \"pointer to|invalid use of undefined type\" } */\n+  ++aps; /* { dg-error \"pointer to|invalid use of undefined type\" } */\n+  --aps; /* { dg-error \"pointer to|invalid use of undefined type\" } */\n+  as++; /* { dg-error \"wrong type\" } */\n+  as--; /* { dg-error \"wrong type\" } */\n+  ++as; /* { dg-error \"wrong type\" } */\n+  --as; /* { dg-error \"wrong type\" } */\n+}\n+\n+/* Pointer subtraction and comparisons differing in _Atomic are\n+   invalid where such subtraction and comparisons differing in\n+   qualifiers are valid.  There is no special allowance for equality\n+   comparisons of pointers to atomic void to pointers to object\n+   types.  Likewise for conditional expressions.  */\n+int *pi;\n+_Atomic int *pai;\n+_Atomic void *pav;\n+int r;\n+\n+void\n+func2 (void)\n+{\n+  r = pai - pi; /* { dg-error \"invalid operands\" } */\n+  r = pi - pai; /* { dg-error \"invalid operands\" } */\n+  r = pi < pai; /* { dg-error \"distinct pointer types\" } */\n+  r = pi > pai; /* { dg-error \"distinct pointer types\" } */\n+  r = pi <= pai; /* { dg-error \"distinct pointer types\" } */\n+  r = pi >= pai; /* { dg-error \"distinct pointer types\" } */\n+  r = pai < pi; /* { dg-error \"distinct pointer types\" } */\n+  r = pai > pi; /* { dg-error \"distinct pointer types\" } */\n+  r = pai <= pi; /* { dg-error \"distinct pointer types\" } */\n+  r = pai >= pi; /* { dg-error \"distinct pointer types\" } */\n+  r = pav == pi; /* { dg-error \"distinct pointer types\" } */\n+  r = pav != pi; /* { dg-error \"distinct pointer types\" } */\n+  r = pi == pav; /* { dg-error \"distinct pointer types\" } */\n+  r = pi != pav; /* { dg-error \"distinct pointer types\" } */\n+  (void) (r ? pai : pi); /* { dg-error \"pointer type mismatch\" } */\n+  (void) (r ? pi : pai); /* { dg-error \"pointer type mismatch\" } */\n+  (void) (r ? pai : pav); /* { dg-error \"pointer type mismatch\" } */\n+  (void) (r ? pav : pai); /* { dg-error \"pointer type mismatch\" } */\n+}\n+\n+/* Likewise for pointer assignment.  */\n+void\n+func3 (void)\n+{\n+  pai = pi; /* { dg-error \"incompatible pointer type\" } */\n+  pi = pai; /* { dg-error \"incompatible pointer type\" } */\n+  pav = pai; /* { dg-error \"incompatible pointer type\" } */\n+  pai = pav; /* { dg-error \"incompatible pointer type\" } */\n+}\n+\n+/* Cases that are invalid for normal assignments are just as invalid\n+   (and should not ICE) when the LHS is atomic.  */\n+void\n+func4 (void)\n+{\n+  as = acf; /* { dg-error \"incompatible types\" } */\n+  apv = as; /* { dg-error \"incompatible types\" } */\n+  as += 1; /* { dg-error \"invalid operands\" } */\n+  apv -= 1; /* { dg-error \"pointer of type\" } */\n+  apv *= 1; /* { dg-error \"invalid operands\" } */\n+  apv /= 1; /* { dg-error \"invalid operands\" } */\n+  apv %= 1; /* { dg-error \"invalid operands\" } */\n+  apv <<= 1; /* { dg-error \"invalid operands\" } */\n+  apv >>= 1; /* { dg-error \"invalid operands\" } */\n+  apv &= 1; /* { dg-error \"invalid operands\" } */\n+  apv ^= 1; /* { dg-error \"invalid operands\" } */\n+  apv |= 1; /* { dg-error \"invalid operands\" } */\n+}\n+\n+/* We don't allow atomic bit-fields in GCC (implementation-defined\n+   whether they are permitted).  */\n+struct abf\n+{\n+  _Atomic int i : 1; /* { dg-error \"atomic type\" } */\n+  _Atomic int : 0; /* { dg-error \"atomic type\" } */\n+};\n+\n+/* _Atomic (type-name) may not use a name for an array, function,\n+   qualified or atomic type.  */\n+_Atomic (int [2]) v0; /* { dg-error \"array type\" } */\n+_Atomic (void (void)) v1; /* { dg-error \"function type\" } */\n+_Atomic (_Atomic int) v2; /* { dg-error \"applied to a qualified type\" } */\n+_Atomic (const int) v3; /* { dg-error \"applied to a qualified type\" } */\n+_Atomic (volatile int) v4; /* { dg-error \"applied to a qualified type\" } */\n+_Atomic (int *restrict) v5; /* { dg-error \"applied to a qualified type\" } */\n+\n+/* _Atomic, used as a qualifier, may not be applied to a function or\n+   array type.  */\n+typedef int arraytype[2];\n+typedef void functiontype (void);\n+_Atomic arraytype v6; /* { dg-error \"array type\" } */\n+_Atomic arraytype *v7; /* { dg-error \"array type\" } */\n+typedef _Atomic arraytype v8; /* { dg-error \"array type\" } */\n+int v9 = sizeof (_Atomic arraytype); /* { dg-error \"array type\" } */\n+void v10 (_Atomic arraytype parm); /* { dg-error \"array type\" } */\n+struct v11 { _Atomic arraytype f; }; /* { dg-error \"array type\" } */\n+_Atomic functiontype v12; /* { dg-error \"function type\" } */\n+_Atomic functiontype *v13; /* { dg-error \"function type\" } */\n+typedef _Atomic functiontype *v14; /* { dg-error \"function type\" } */\n+void v15 (_Atomic functiontype parm); /* { dg-error \"function type\" } */\n+\n+/* Function parameters, when function types are required to be\n+   compatible, may not differ in the presence of _Atomic.  See\n+   c11-atomic-1.c for corresponding tests where _Atomic matches.  */\n+void fc0 (int _Atomic); /* { dg-message \"previous declaration\" } */\n+void fc0 (int); /* { dg-error \"conflicting types\" } */\n+void fc1 (int); /* { dg-message \"prototype declaration\" } */\n+void\n+fc1 (x)\n+     _Atomic int x; /* { dg-error \"match prototype\" } */\n+{\n+}\n+void\n+fc2 (x) /* { dg-message \"previous definition\" } */\n+     _Atomic int x;\n+{\n+}\n+void fc2 (int); /* { dg-error \"incompatible type\" } */\n+void fc3 (int); /* { dg-message \"prototype declaration\" } */\n+void\n+fc3 (x)\n+     _Atomic short x; /* { dg-error \"match prototype\" } */\n+{\n+}\n+void\n+fc4 (x) /* { dg-message \"previous definition\" } */\n+     _Atomic short x;\n+{\n+}\n+void fc4 (int); /* { dg-error \"incompatible type\" } */\n+\n+/* Arrays of atomic elements cannot be initialized with string\n+   literals.  */\n+_Atomic char si0[] = \"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic char si1[] = u8\"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic signed char si2[] = \"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic signed char si3[] = u8\"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic unsigned char si4[] = \"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic unsigned char si5[] = u8\"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic __WCHAR_TYPE__ si6[] = L\"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic __CHAR16_TYPE__ si7[] = u\"\"; /* { dg-error \"inappropriate type\" } */\n+_Atomic __CHAR32_TYPE__ si8[] = U\"\"; /* { dg-error \"inappropriate type\" } */\n+\n+/* Anything that is syntactically a qualifier applied to the (void)\n+   parameter list results in undefined behavior, which we\n+   diagnose.  */\n+void fv (_Atomic void); /* { dg-error \"may not be qualified\" } */"}, {"sha": "3506563940d97ecd6a3b2a2a1c2ad2f8d67797ae", "filename": "gcc/testsuite/gcc.dg/c90-atomic-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-atomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-atomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-atomic-1.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,7 @@\n+/* Test for _Atomic: not in C90.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c90 -pedantic-errors\" } */\n+\n+_Atomic int i; /* { dg-error \"_Atomic\" } */\n+_Atomic (int) j; /* { dg-error \"_Atomic\" } */\n+int *_Atomic p; /* { dg-error \"_Atomic\" } */"}, {"sha": "3a13f77712207b02a674099b2f2272ceeb071004", "filename": "gcc/testsuite/gcc.dg/c99-atomic-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-atomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-atomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-atomic-1.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,8 @@\n+/* Test for _Atomic: not in C99.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+_Atomic int i; /* { dg-error \"_Atomic\" } */\n+_Atomic (int) j; /* { dg-error \"_Atomic\" } */\n+int *_Atomic p; /* { dg-error \"_Atomic\" } */\n+void f (int a[_Atomic]); /* { dg-error \"_Atomic\" } */"}, {"sha": "c1317e47c2fa7dc823d5b01b191cdbc028b4eb63", "filename": "gcc/testsuite/lib/atomic-dg.exp", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Flib%2Fatomic-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Flib%2Fatomic-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fatomic-dg.exp?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,104 @@\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+#\n+# atomic_link_flags -- compute library path and flags to find libatomic.\n+# (originally from g++.exp)\n+#\n+\n+proc atomic_link_flags { paths } {\n+    global srcdir\n+    global ld_library_path\n+    global shlib_ext\n+\n+    set gccpath ${paths}\n+    set flags \"\"\n+\n+    set shlib_ext [get_shlib_extension]\n+\n+    if { $gccpath != \"\" } {\n+      if { [file exists \"${gccpath}/libatomic/.libs/libatomic.a\"]\n+\t   || [file exists \"${gccpath}/libatomic/.libs/libatomic.${shlib_ext}\"] } {\n+\t  append flags \" -B${gccpath}/libatomic/ \"\n+\t  append flags \" -L${gccpath}/libatomic/.libs\"\n+\t  append ld_library_path \":${gccpath}/libatomic/.libs\"\n+      }\n+    } else {\n+      global tool_root_dir\n+\n+      set libatomic [lookfor_file ${tool_root_dir} libatomic]\n+      if { $libatomic != \"\" } {\n+\t  append flags \"-L${libatomic} \"\n+\t  append ld_library_path \":${libatomic}\"\n+      }\n+    }\n+\n+    set_ld_library_path_env_vars\n+\n+    append flags \" -latomic \"\n+    return \"$flags\"\n+}\n+\n+#\n+# atomic_init -- called at the start of each subdir of tests\n+#\n+\n+proc atomic_init { args } {\n+    global TEST_ALWAYS_FLAGS\n+    global ALWAYS_CXXFLAGS\n+    global TOOL_OPTIONS\n+    global atomic_saved_TEST_ALWAYS_FLAGS\n+\n+    set link_flags \"\"\n+    if ![is_remote host] {\n+\tif [info exists TOOL_OPTIONS] {\n+\t    set link_flags \"[atomic_link_flags [get_multilibs ${TOOL_OPTIONS}]]\"\n+\t} else {\n+\t    set link_flags \"[atomic_link_flags [get_multilibs]]\"\n+\t}\n+    }\n+\n+    if [info exists TEST_ALWAYS_FLAGS] {\n+\tset atomic_saved_TEST_ALWAYS_FLAGS $TEST_ALWAYS_FLAGS\n+    }\n+    if [info exists ALWAYS_CXXFLAGS] {\n+\tset ALWAYS_CXXFLAGS [concat \"{ldflags=$link_flags}\" $ALWAYS_CXXFLAGS]\n+    } else {\n+\tif [info exists TEST_ALWAYS_FLAGS] {\n+\t    set TEST_ALWAYS_FLAGS \"$link_flags $TEST_ALWAYS_FLAGS\"\n+\t} else {\n+\t    set TEST_ALWAYS_FLAGS \"$link_flags\"\n+\t}\n+    }\n+    return [check_no_compiler_messages_nocache libatomic_available executable {\n+\tint main (void) { return 0; }\n+    }]\n+}\n+\n+#\n+# atomic_finish -- called at the end of each subdir of tests\n+#\n+\n+proc atomic_finish { args } {\n+    global TEST_ALWAYS_FLAGS\n+    global atomic_saved_TEST_ALWAYS_FLAGS\n+\n+    if [info exists atomic_saved_TEST_ALWAYS_FLAGS] {\n+\tset TEST_ALWAYS_FLAGS $atomic_saved_TEST_ALWAYS_FLAGS\n+    } else {\n+\tunset TEST_ALWAYS_FLAGS\n+    }\n+}"}, {"sha": "c3d9712772ed304f4592a6c8364b38f01249bbfc", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -5477,3 +5477,40 @@ proc check_effective_target_aarch64_large { } {\n \treturn 0\n     }\n }\n+\n+# Return 1 if <fenv.h> is available with all the standard IEEE\n+# exceptions and floating-point exceptions are raised by arithmetic\n+# operations.  (If the target requires special options for \"inexact\"\n+# exceptions, those need to be specified in the testcases.)\n+\n+proc check_effective_target_fenv_exceptions {} {\n+    return [check_runtime fenv_exceptions {\n+\t#include <fenv.h>\n+\t#include <stdlib.h>\n+\t#ifndef FE_DIVBYZERO\n+\t# error Missing FE_DIVBYZERO\n+\t#endif\n+\t#ifndef FE_INEXACT\n+\t# error Missing FE_INEXACT\n+\t#endif\n+\t#ifndef FE_INVALID\n+\t# error Missing FE_INVALID\n+\t#endif\n+\t#ifndef FE_OVERFLOW\n+\t# error Missing FE_OVERFLOW\n+\t#endif\n+\t#ifndef FE_UNDERFLOW\n+\t# error Missing FE_UNDERFLOW\n+\t#endif\n+\tvolatile float a = 0.0f, r;\n+\tint\n+\tmain (void)\n+\t{\n+\t  r = a / a;\n+\t  if (fetestexcept (FE_INVALID))\n+\t    exit (0);\n+\t  else\n+\t    abort ();\n+\t}\n+    } \"-std=gnu99\"]\n+}"}, {"sha": "351f906f001c97c10bcc0ba48effbbe372a6f942", "filename": "gcc/tree-core.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -368,7 +368,8 @@ enum cv_qualifier {\n   TYPE_UNQUALIFIED   = 0x0,\n   TYPE_QUAL_CONST    = 0x1,\n   TYPE_QUAL_VOLATILE = 0x2,\n-  TYPE_QUAL_RESTRICT = 0x4\n+  TYPE_QUAL_RESTRICT = 0x4,\n+  TYPE_QUAL_ATOMIC   = 0x8\n };\n \n /* Enumerate visibility settings.  */\n@@ -397,6 +398,12 @@ enum tree_index {\n   TI_UINTDI_TYPE,\n   TI_UINTTI_TYPE,\n \n+  TI_ATOMICQI_TYPE,\n+  TI_ATOMICHI_TYPE,\n+  TI_ATOMICSI_TYPE,\n+  TI_ATOMICDI_TYPE,\n+  TI_ATOMICTI_TYPE,\n+\n   TI_UINT16_TYPE,\n   TI_UINT32_TYPE,\n   TI_UINT64_TYPE,\n@@ -738,7 +745,8 @@ struct GTY(()) tree_base {\n       unsigned packed_flag : 1;\n       unsigned user_align : 1;\n       unsigned nameless_flag : 1;\n-      unsigned spare0 : 4;\n+      unsigned atomic_flag : 1;\n+      unsigned spare0 : 3;\n \n       unsigned spare1 : 8;\n "}, {"sha": "7cd578cf99629c2b9afd65f3e32c94237b1792a9", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -878,6 +878,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tunsigned int quals = TYPE_QUALS (node);\n \tenum tree_code_class tclass;\n \n+\tif (quals & TYPE_QUAL_ATOMIC)\n+\t  pp_string (buffer, \"atomic \");\n \tif (quals & TYPE_QUAL_CONST)\n \t  pp_string (buffer, \"const \");\n \telse if (quals & TYPE_QUAL_VOLATILE)\n@@ -1179,6 +1181,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       {\n \tunsigned int quals = TYPE_QUALS (node);\n \n+\tif (quals & TYPE_QUAL_ATOMIC)\n+\t  pp_string (buffer, \"atomic \");\n \tif (quals & TYPE_QUAL_CONST)\n \t  pp_string (buffer, \"const \");\n \tif (quals & TYPE_QUAL_VOLATILE)"}, {"sha": "21b790a5de06a2639967421505f92c2e569c3a6d", "filename": "gcc/tree.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -6202,6 +6202,7 @@ set_type_quals (tree type, int type_quals)\n   TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;\n   TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n   TYPE_RESTRICT (type) = (type_quals & TYPE_QUAL_RESTRICT) != 0;\n+  TYPE_ATOMIC (type) = (type_quals & TYPE_QUAL_ATOMIC) != 0;\n   TYPE_ADDR_SPACE (type) = DECODE_QUAL_ADDR_SPACE (type_quals);\n }\n \n@@ -6235,6 +6236,48 @@ check_aligned_type (const_tree cand, const_tree base, unsigned int align)\n \t\t\t\t   TYPE_ATTRIBUTES (base)));\n }\n \n+/* This function checks to see if TYPE matches the size one of the built-in \n+   atomic types, and returns that core atomic type.  */\n+\n+static tree\n+find_atomic_core_type (tree type)\n+{\n+  tree base_atomic_type;\n+\n+  /* Only handle complete types.  */\n+  if (TYPE_SIZE (type) == NULL_TREE)\n+    return NULL_TREE;\n+\n+  HOST_WIDE_INT type_size = tree_low_cst (TYPE_SIZE (type), 1);\n+  switch (type_size)\n+    {\n+    case 8:\n+      base_atomic_type = atomicQI_type_node;\n+      break;\n+\n+    case 16:\n+      base_atomic_type = atomicHI_type_node;\n+      break;\n+\n+    case 32:\n+      base_atomic_type = atomicSI_type_node;\n+      break;\n+\n+    case 64:\n+      base_atomic_type = atomicDI_type_node;\n+      break;\n+\n+    case 128:\n+      base_atomic_type = atomicTI_type_node;\n+      break;\n+\n+    default:\n+      base_atomic_type = NULL_TREE;\n+    }\n+\n+  return base_atomic_type;\n+}\n+\n /* Return a version of the TYPE, qualified as indicated by the\n    TYPE_QUALS, if one exists.  If no qualified version exists yet,\n    return NULL_TREE.  */\n@@ -6274,6 +6317,19 @@ build_qualified_type (tree type, int type_quals)\n       t = build_variant_type_copy (type);\n       set_type_quals (t, type_quals);\n \n+      if (((type_quals & TYPE_QUAL_ATOMIC) == TYPE_QUAL_ATOMIC))\n+\t{\n+\t  /* See if this object can map to a basic atomic type.  */\n+\t  tree atomic_type = find_atomic_core_type (type);\n+\t  if (atomic_type)\n+\t    {\n+\t      /* Ensure the alignment of this type is compatible with\n+\t\t the required alignment of the atomic type.  */\n+\t      if (TYPE_ALIGN (atomic_type) > TYPE_ALIGN (t))\n+\t\tTYPE_ALIGN (t) = TYPE_ALIGN (atomic_type);\n+\t    }\n+\t}\n+\n       if (TYPE_STRUCTURAL_EQUALITY_P (type))\n \t/* Propagate structural equality. */\n \tSET_TYPE_STRUCTURAL_EQUALITY (t);\n@@ -9774,6 +9830,28 @@ make_or_reuse_accum_type (unsigned size, int unsignedp, int satp)\n   return make_accum_type (size, unsignedp, satp);\n }\n \n+\n+/* Create an atomic variant node for TYPE.  This routine is called\n+   during initialization of data types to create the 5 basic atomic\n+   types. The generic build_variant_type function requires these to\n+   already be set up in order to function properly, so cannot be\n+   called from there.  */\n+\n+static tree\n+build_atomic_base (tree type)\n+{\n+  tree t;\n+\n+  /* Make sure its not already registered.  */\n+  if ((t = get_qualified_type (type, TYPE_QUAL_ATOMIC)))\n+    return t;\n+  \n+  t = build_variant_type_copy (type);\n+  set_type_quals (t, TYPE_QUAL_ATOMIC);\n+\n+  return t;\n+}\n+\n /* Create nodes for all integer types (and error_mark_node) using the sizes\n    of C datatypes.  SIGNED_CHAR specifies whether char is signed,\n    SHORT_DOUBLE specifies whether double should be of the same precision\n@@ -9856,6 +9934,16 @@ build_common_tree_nodes (bool signed_char, bool short_double)\n   unsigned_intDI_type_node = make_or_reuse_type (GET_MODE_BITSIZE (DImode), 1);\n   unsigned_intTI_type_node = make_or_reuse_type (GET_MODE_BITSIZE (TImode), 1);\n \n+  /* Don't call build_qualified type for atomics.  That routine does\n+     special processing for atomics, and until they are initialized\n+     it's better not to make that call.  */\n+\n+  atomicQI_type_node = build_atomic_base (unsigned_intQI_type_node);\n+  atomicHI_type_node = build_atomic_base (unsigned_intHI_type_node);\n+  atomicSI_type_node = build_atomic_base (unsigned_intSI_type_node);\n+  atomicDI_type_node = build_atomic_base (unsigned_intDI_type_node);\n+  atomicTI_type_node = build_atomic_base (unsigned_intTI_type_node);\n+\n   access_public_node = get_identifier (\"public\");\n   access_protected_node = get_identifier (\"protected\");\n   access_private_node = get_identifier (\"private\");"}, {"sha": "96948f152a576f3d9fbcc1770e58449e537b7c70", "filename": "gcc/tree.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1598,6 +1598,9 @@ extern enum machine_mode vector_type_mode (const_tree);\n /* Nonzero in a type considered volatile as a whole.  */\n #define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->base.volatile_flag)\n \n+/* Nonzero in a type considered atomic as a whole.  */\n+#define TYPE_ATOMIC(NODE) (TYPE_CHECK (NODE)->base.u.bits.atomic_flag)\n+\n /* Means this type is const-qualified.  */\n #define TYPE_READONLY(NODE) (TYPE_CHECK (NODE)->base.readonly_flag)\n \n@@ -1627,11 +1630,20 @@ extern enum machine_mode vector_type_mode (const_tree);\n #define TYPE_QUALS(NODE)\t\t\t\t\t\\\n   ((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\\\n \t  | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n+\t  | (TYPE_ATOMIC (NODE) * TYPE_QUAL_ATOMIC)\t\t\\\n \t  | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)\t\t\\\n \t  | (ENCODE_QUAL_ADDR_SPACE (TYPE_ADDR_SPACE (NODE)))))\n \n /* The same as TYPE_QUALS without the address space qualifications.  */\n #define TYPE_QUALS_NO_ADDR_SPACE(NODE)\t\t\t\t\\\n+  ((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\\\n+\t  | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n+\t  | (TYPE_ATOMIC (NODE) * TYPE_QUAL_ATOMIC)\t\t\\\n+\t  | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)))\n+\n+/* The same as TYPE_QUALS without the address space and atomic \n+   qualifications.  */\n+#define TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC(NODE)\t\t\\\n   ((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\\\n \t  | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n \t  | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)))\n@@ -3176,6 +3188,12 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n #define unsigned_intDI_type_node\tglobal_trees[TI_UINTDI_TYPE]\n #define unsigned_intTI_type_node\tglobal_trees[TI_UINTTI_TYPE]\n \n+#define atomicQI_type_node\tglobal_trees[TI_ATOMICQI_TYPE]\n+#define atomicHI_type_node\tglobal_trees[TI_ATOMICHI_TYPE]\n+#define atomicSI_type_node\tglobal_trees[TI_ATOMICSI_TYPE]\n+#define atomicDI_type_node\tglobal_trees[TI_ATOMICDI_TYPE]\n+#define atomicTI_type_node\tglobal_trees[TI_ATOMICTI_TYPE]\n+\n #define uint16_type_node\t\tglobal_trees[TI_UINT16_TYPE]\n #define uint32_type_node\t\tglobal_trees[TI_UINT32_TYPE]\n #define uint64_type_node\t\tglobal_trees[TI_UINT64_TYPE]"}, {"sha": "900a6198e97f5f813d5fe098a2ed38ab84dc7ac1", "filename": "libatomic/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FChangeLog?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -1,3 +1,13 @@\n+2013-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* fenv.c: New file.\n+\t* libatomic.map (LIBATOMIC_1.1): New symbol version.  Include\n+\t__atomic_feraiseexcept.\n+\t* configure.ac (libtool_VERSION): Change to 2:0:1.\n+\t(fenv.h): Test for header.\n+\t* Makefile.am (libatomic_la_SOURCES): Add fenv.c.\n+\t* Makefile.in, auto-config.h.in, configure: Regenerate.\n+\n 2013-10-17  Michael Hudson-Doyle  <michael.hudson@linaro.org>\n \n \t* libatomic/configure.tgt (aarch64*): Remove code preventing"}, {"sha": "537b24a714927d5f164eec4b882bf2482df95a6a", "filename": "libatomic/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FMakefile.am?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -67,7 +67,8 @@ endif\n libatomic_version_info = -version-info $(libtool_VERSION)\n \n libatomic_la_LDFLAGS = $(libatomic_version_info) $(libatomic_version_script)\n-libatomic_la_SOURCES = gload.c gstore.c gcas.c gexch.c glfree.c lock.c init.c\n+libatomic_la_SOURCES = gload.c gstore.c gcas.c gexch.c glfree.c lock.c init.c \\\n+\tfenv.c\n \n SIZEOBJS = load store cas exch fadd fsub fand fior fxor fnand tas\n SIZES = @SIZES@"}, {"sha": "22c384b43222ca1761f5dc90637a380eddbfff58", "filename": "libatomic/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FMakefile.in?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -90,14 +90,14 @@ am__base_list = \\\n am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n am_libatomic_la_OBJECTS = gload.lo gstore.lo gcas.lo gexch.lo \\\n-\tglfree.lo lock.lo init.lo\n+\tglfree.lo lock.lo init.lo fenv.lo\n libatomic_la_OBJECTS = $(am_libatomic_la_OBJECTS)\n libatomic_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n \t$(libatomic_la_LDFLAGS) $(LDFLAGS) -o $@\n libatomic_convenience_la_DEPENDENCIES = $(libatomic_la_LIBADD)\n am__objects_1 = gload.lo gstore.lo gcas.lo gexch.lo glfree.lo lock.lo \\\n-\tinit.lo\n+\tinit.lo fenv.lo\n am_libatomic_convenience_la_OBJECTS = $(am__objects_1)\n libatomic_convenience_la_OBJECTS =  \\\n \t$(am_libatomic_convenience_la_OBJECTS)\n@@ -286,7 +286,9 @@ noinst_LTLIBRARIES = libatomic_convenience.la\n @LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libatomic_version_dep = libatomic.map-sun\n libatomic_version_info = -version-info $(libtool_VERSION)\n libatomic_la_LDFLAGS = $(libatomic_version_info) $(libatomic_version_script)\n-libatomic_la_SOURCES = gload.c gstore.c gcas.c gexch.c glfree.c lock.c init.c\n+libatomic_la_SOURCES = gload.c gstore.c gcas.c gexch.c glfree.c lock.c init.c \\\n+\tfenv.c\n+\n SIZEOBJS = load store cas exch fadd fsub fand fior fxor fnand tas\n EXTRA_libatomic_la_SOURCES = $(addsuffix _n.c,$(SIZEOBJS))\n libatomic_la_DEPENDENCIES = $(libatomic_la_LIBADD) $(libatomic_version_dep)\n@@ -425,6 +427,7 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fenv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gcas.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gexch.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glfree.Plo@am__quote@"}, {"sha": "83e54e2db3b06a9d8bc294b57457b931035b9881", "filename": "libatomic/auto-config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Fauto-config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Fauto-config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fauto-config.h.in?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -105,6 +105,9 @@\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n+/* Define to 1 if you have the <fenv.h> header file. */\n+#undef HAVE_FENV_H\n+\n /* Define to 1 if the target supports __attribute__((ifunc(...))). */\n #undef HAVE_IFUNC\n "}, {"sha": "d707b096c2ecbc5ac9bb9049cdbd0a555839935e", "filename": "libatomic/configure", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfigure?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -2000,6 +2000,93 @@ rm -f conftest.val\n   return $ac_retval\n \n } # ac_fn_c_compute_int\n+\n+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES\n+# -------------------------------------------------------\n+# Tests whether HEADER exists, giving a warning if it cannot be compiled using\n+# the include files in INCLUDES and setting the cache variable VAR\n+# accordingly.\n+ac_fn_c_check_header_mongrel ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n+$as_echo_n \"checking for $2... \" >&6; }\n+if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+else\n+  # Is the header compilable?\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking $2 usability\" >&5\n+$as_echo_n \"checking $2 usability... \" >&6; }\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+#include <$2>\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_header_compiler=yes\n+else\n+  ac_header_compiler=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler\" >&5\n+$as_echo \"$ac_header_compiler\" >&6; }\n+\n+# Is the header present?\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking $2 presence\" >&5\n+$as_echo_n \"checking $2 presence... \" >&6; }\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <$2>\n+_ACEOF\n+if ac_fn_c_try_cpp \"$LINENO\"; then :\n+  ac_header_preproc=yes\n+else\n+  ac_header_preproc=no\n+fi\n+rm -f conftest.err conftest.$ac_ext\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc\" >&5\n+$as_echo \"$ac_header_preproc\" >&6; }\n+\n+# So?  What about this header?\n+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((\n+  yes:no: )\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!\" >&5\n+$as_echo \"$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result\" >&5\n+$as_echo \"$as_me: WARNING: $2: proceeding with the compiler's result\" >&2;}\n+    ;;\n+  no:yes:* )\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled\" >&5\n+$as_echo \"$as_me: WARNING: $2: present but cannot be compiled\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?\" >&5\n+$as_echo \"$as_me: WARNING: $2:     check for missing prerequisite headers?\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation\" >&5\n+$as_echo \"$as_me: WARNING: $2: see the Autoconf documentation\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \\\"Present But Cannot Be Compiled\\\"\" >&5\n+$as_echo \"$as_me: WARNING: $2:     section \\\"Present But Cannot Be Compiled\\\"\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result\" >&5\n+$as_echo \"$as_me: WARNING: $2: proceeding with the compiler's result\" >&2;}\n+    ;;\n+esac\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n+$as_echo_n \"checking for $2... \" >&6; }\n+if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  eval \"$3=\\$ac_header_compiler\"\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+fi\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+\n+} # ac_fn_c_check_header_mongrel\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n@@ -11019,7 +11106,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11022 \"configure\"\n+#line 11109 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11125,7 +11212,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11128 \"configure\"\n+#line 11215 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11389,7 +11476,7 @@ fi\n \n \n # For libtool versioning info, format is CURRENT:REVISION:AGE\n-libtool_VERSION=1:0:0\n+libtool_VERSION=2:0:1\n \n \n # Get target configury.\n@@ -11953,6 +12040,18 @@ ac_config_commands=\"$ac_config_commands gstdint.h\"\n \n \n \n+for ac_header in fenv.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"fenv.h\" \"ac_cv_header_fenv_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_fenv_h\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_FENV_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n \n # Check for common type sizes\n "}, {"sha": "fd2d35bf04f325fc217cafbd9c2715c63d2a093d", "filename": "libatomic/configure.ac", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfigure.ac?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -148,7 +148,7 @@ AC_SUBST(enable_static)\n AM_MAINTAINER_MODE\n \n # For libtool versioning info, format is CURRENT:REVISION:AGE\n-libtool_VERSION=1:0:0\n+libtool_VERSION=2:0:1\n AC_SUBST(libtool_VERSION)\n \n # Get target configury.\n@@ -165,6 +165,7 @@ CFLAGS=\"$save_CFLAGS -fno-sync-libcalls $XCFLAGS\"\n AC_STDC_HEADERS\n ACX_HEADER_STRING\n GCC_HEADER_STDINT(gstdint.h)\n+AC_CHECK_HEADERS([fenv.h])\n \n # Check for common type sizes\n LIBAT_FORALL_MODES([LIBAT_HAVE_INT_MODE])"}, {"sha": "752cf3b378d92976ef278e5c9b489832b8561b00", "filename": "libatomic/fenv.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Ffenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Ffenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffenv.c?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2012-2013 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+/* Raise the supported floating-point exceptions from EXCEPTS.  Other\n+   bits in EXCEPTS are ignored.  */\n+\n+void\n+__atomic_feraiseexcept (int excepts __attribute__ ((unused)))\n+{\n+  volatile float r __attribute__ ((unused));\n+#ifdef FE_INVALID\n+  if (excepts & FE_INVALID)\n+  {\n+    volatile float zero = 0.0f;\n+    r = zero / zero;\n+  }\n+#endif\n+#ifdef FE_DIVBYZERO\n+  if (excepts & FE_DIVBYZERO)\n+    {\n+      volatile float zero = 0.0f;\n+      r = 1.0f / zero;\n+    }\n+#endif\n+#ifdef FE_OVERFLOW\n+  if (excepts & FE_OVERFLOW)\n+    {\n+      volatile float max = __FLT_MAX__;\n+      r = max * max;\n+    }\n+#endif\n+#ifdef FE_UNDERFLOW\n+  if (excepts & FE_UNDERFLOW)\n+    {\n+      volatile float min = __FLT_MIN__;\n+      r = min * min;\n+    }\n+#endif\n+#ifdef FE_INEXACT\n+  if (excepts & FE_INEXACT)\n+    {\n+      volatile float three = 3.0f;\n+      r = 1.0f / three;\n+    }\n+#endif\n+}"}, {"sha": "8fd2bafd80c49ffcf9aa27b90812d54c5c4e0e0a", "filename": "libatomic/libatomic.map", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Flibatomic.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267bac1078ce623767a9effa063d5b63fbbeb6ca/libatomic%2Flibatomic.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Flibatomic.map?ref=267bac1078ce623767a9effa063d5b63fbbeb6ca", "patch": "@@ -95,3 +95,7 @@ LIBATOMIC_1.0 {\n   local:\n \t*;\n };\n+LIBATOMIC_1.1 {\n+  global:\n+\t__atomic_feraiseexcept;\n+} LIBATOMIC_1.0;"}]}