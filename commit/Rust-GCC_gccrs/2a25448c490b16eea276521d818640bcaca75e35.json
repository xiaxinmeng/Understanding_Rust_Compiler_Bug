{"sha": "2a25448c490b16eea276521d818640bcaca75e35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyNTQ0OGM0OTBiMTZlZWEyNzY1MjFkODE4NjQwYmNhY2E3NWUzNQ==", "commit": {"author": {"name": "Igor Tsimbalist", "email": "igor.v.tsimbalist@intel.com", "date": "2017-10-21T21:09:53Z"}, "committer": {"name": "Igor Tsimbalist", "email": "itsimbal@gcc.gnu.org", "date": "2017-10-21T21:09:53Z"}, "message": "Update x86 backend to enable Intel CET.\n\nAll platforms except i386 will report the error and do no\ninstrumentation with -finstrument-control-flow option. i386\nwill provide the implementation based on a specification\npublished by Intel for a new technology called Control-flow\nEnforcement Technology (CET). The spec is available at\n\nhttps://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf\n\nThe implementation in this patch:\n1) enables Control-flow Enforcement Technology (CET), published by\nIntel. This part introduces i386 specific options -mcet, -mibt and\n-mshstk, new instructions and intrinsics;\n\n2) provides support for -fcf-protection option and 'nocf_check'\nattribute by doing needed code instrumentation, which is based on\nCET features.\n\ngcc/\n\n\t* common/config/i386/i386-common.c (OPTION_MASK_ISA_IBT_SET): New.\n\t(OPTION_MASK_ISA_SHSTK_SET): Likewise.\n\t(OPTION_MASK_ISA_IBT_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SHSTK_UNSET): Likewise.\n\t(ix86_handle_option): Add -mibt, -mshstk, -mcet handling.\n\t* config.gcc (extra_headers): Add cetintrin.h for x86 targets.\n\t(extra_objs): Add cet.o for Linux/x86 targets.\n\t(tmake_file): Add i386/t-cet for Linux/x86 targets.\n\t* config/i386/cet.c: New file.\n\t* config/i386/cetintrin.h: Likewise.\n\t* config/i386/t-cet: Likewise.\n\t* config/i386/cpuid.h (bit_SHSTK): New.\n\t(bit_IBT): Likewise.\n\t* config/i386/driver-i386.c (host_detect_local_cpu): Detect and\n\tpass IBT and SHSTK bits.\n\t* config/i386/i386-builtin-types.def\n\t(VOID_FTYPE_UNSIGNED_PVOID): New.\n\t(VOID_FTYPE_UINT64_PVOID): Likewise.\n\t* config/i386/i386-builtin.def: Add CET intrinsics.\n\t* config/i386/i386-c.c (ix86_target_macros_internal): Add\n\tOPTION_MASK_ISA_IBT, OPTION_MASK_ISA_SHSTK handling.\n\t* config/i386/i386-passes.def: Add pass_insert_endbranch pass.\n\t* config/i386/i386-protos.h (make_pass_insert_endbranch): New\n\tprototype.\n\t* config/i386/i386.c (rest_of_insert_endbranch): New.\n\t(pass_data_insert_endbranch): Likewise.\n\t(pass_insert_endbranch): Likewise.\n\t(make_pass_insert_endbranch): Likewise.\n\t(ix86_notrack_prefixed_insn_p): Likewise.\n\t(ix86_target_string): Add -mibt, -mshstk flags.\n\t(ix86_option_override_internal): Add flag_cf_protection\n\tprocessing.\n\t(ix86_valid_target_attribute_inner_p): Set OPT_mibt, OPT_mshstk.\n\t(ix86_print_operand): Add 'notrack' prefix output.\n\t(ix86_init_mmx_sse_builtins): Add CET intrinsics.\n\t(ix86_expand_builtin): Expand CET intrinsics.\n\t(x86_output_mi_thunk): Add 'endbranch' instruction.\n\t* config/i386/i386.h (TARGET_IBT): New.\n\t(TARGET_IBT_P): Likewise.\n\t(TARGET_SHSTK): Likewise.\n\t(TARGET_SHSTK_P): Likewise.\n\t   * config/i386/i386.md (unspecv): Add UNSPECV_NOP_RDSSP,\n\tUNSPECV_INCSSP, UNSPECV_SAVEPREVSSP, UNSPECV_RSTORSSP,\n\tUNSPECV_WRSS, UNSPECV_WRUSS, UNSPECV_SETSSBSY, UNSPECV_CLRSSBSY.\n\t(builtin_setjmp_setup): New pattern.\n\t(builtin_longjmp): Likewise.\n\t(rdssp<mode>): Likewise.\n\t(incssp<mode>): Likewise.\n\t(saveprevssp): Likewise.\n\t(rstorssp): Likewise.\n\t(wrss<mode>): Likewise.\n\t(wruss<mode>): Likewise.\n\t(setssbsy): Likewise.\n\t(clrssbsy): Likewise.\n\t(nop_endbr): Likewise.\n\t* config/i386/i386.opt: Add -mcet, -mibt, -mshstk and -mcet-switch\n\toptions.\n\t* config/i386/immintrin.h: Include <cetintrin.h>.\n\t* config/i386/linux-common.h\n\t(file_end_indicate_exec_stack_and_cet): New prototype.\n\t(TARGET_ASM_FILE_END): New.\n\nFrom-SVN: r253977", "tree": {"sha": "aae8d11f62b9f0d4cf57dad0b00bb196c82fa871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aae8d11f62b9f0d4cf57dad0b00bb196c82fa871"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a25448c490b16eea276521d818640bcaca75e35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a25448c490b16eea276521d818640bcaca75e35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a25448c490b16eea276521d818640bcaca75e35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a25448c490b16eea276521d818640bcaca75e35/comments", "author": {"login": "itsimbal", "id": 29258612, "node_id": "MDQ6VXNlcjI5MjU4NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/29258612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/itsimbal", "html_url": "https://github.com/itsimbal", "followers_url": "https://api.github.com/users/itsimbal/followers", "following_url": "https://api.github.com/users/itsimbal/following{/other_user}", "gists_url": "https://api.github.com/users/itsimbal/gists{/gist_id}", "starred_url": "https://api.github.com/users/itsimbal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/itsimbal/subscriptions", "organizations_url": "https://api.github.com/users/itsimbal/orgs", "repos_url": "https://api.github.com/users/itsimbal/repos", "events_url": "https://api.github.com/users/itsimbal/events{/privacy}", "received_events_url": "https://api.github.com/users/itsimbal/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6fd8f2bd4e9a91b4683e2cbb144631ff201f587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6fd8f2bd4e9a91b4683e2cbb144631ff201f587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6fd8f2bd4e9a91b4683e2cbb144631ff201f587"}], "stats": {"total": 935, "additions": 927, "deletions": 8}, "files": [{"sha": "98f7cce0023e3c1e0cfad3317be3eb6e6641cde9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -1,3 +1,67 @@\n+2017-10-21  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n+\n+\t* common/config/i386/i386-common.c (OPTION_MASK_ISA_IBT_SET): New.\n+\t(OPTION_MASK_ISA_SHSTK_SET): Likewise.\n+\t(OPTION_MASK_ISA_IBT_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SHSTK_UNSET): Likewise.\n+\t(ix86_handle_option): Add -mibt, -mshstk, -mcet handling.\n+\t* config.gcc (extra_headers): Add cetintrin.h for x86 targets.\n+\t(extra_objs): Add cet.o for Linux/x86 targets.\n+\t(tmake_file): Add i386/t-cet for Linux/x86 targets.\n+\t* config/i386/cet.c: New file.\n+\t* config/i386/cetintrin.h: Likewise.\n+\t* config/i386/t-cet: Likewise.\n+\t* config/i386/cpuid.h (bit_SHSTK): New.\n+\t(bit_IBT): Likewise.\n+\t* config/i386/driver-i386.c (host_detect_local_cpu): Detect and\n+\tpass IBT and SHSTK bits.\n+\t* config/i386/i386-builtin-types.def\n+\t(VOID_FTYPE_UNSIGNED_PVOID): New.\n+\t(VOID_FTYPE_UINT64_PVOID): Likewise.\n+\t* config/i386/i386-builtin.def: Add CET intrinsics.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Add\n+\tOPTION_MASK_ISA_IBT, OPTION_MASK_ISA_SHSTK handling.\n+\t* config/i386/i386-passes.def: Add pass_insert_endbranch pass.\n+\t* config/i386/i386-protos.h (make_pass_insert_endbranch): New\n+\tprototype.\n+\t* config/i386/i386.c (rest_of_insert_endbranch): New.\n+\t(pass_data_insert_endbranch): Likewise.\n+\t(pass_insert_endbranch): Likewise.\n+\t(make_pass_insert_endbranch): Likewise.\n+\t(ix86_notrack_prefixed_insn_p): Likewise.\n+\t(ix86_target_string): Add -mibt, -mshstk flags.\n+\t(ix86_option_override_internal): Add flag_cf_protection\n+\tprocessing.\n+\t(ix86_valid_target_attribute_inner_p): Set OPT_mibt, OPT_mshstk.\n+\t(ix86_print_operand): Add 'notrack' prefix output.\n+\t(ix86_init_mmx_sse_builtins): Add CET intrinsics.\n+\t(ix86_expand_builtin): Expand CET intrinsics.\n+\t(x86_output_mi_thunk): Add 'endbranch' instruction.\n+\t* config/i386/i386.h (TARGET_IBT): New.\n+\t(TARGET_IBT_P): Likewise.\n+\t(TARGET_SHSTK): Likewise.\n+\t(TARGET_SHSTK_P): Likewise.\n+\t* config/i386/i386.md (unspecv): Add UNSPECV_NOP_RDSSP,\n+\tUNSPECV_INCSSP, UNSPECV_SAVEPREVSSP, UNSPECV_RSTORSSP,\n+\tUNSPECV_WRSS, UNSPECV_WRUSS, UNSPECV_SETSSBSY, UNSPECV_CLRSSBSY.\n+\t(builtin_setjmp_setup): New pattern.\n+\t(builtin_longjmp): Likewise.\n+\t(rdssp<mode>): Likewise.\n+\t(incssp<mode>): Likewise.\n+\t(saveprevssp): Likewise.\n+\t(rstorssp): Likewise.\n+\t(wrss<mode>): Likewise.\n+\t(wruss<mode>): Likewise.\n+\t(setssbsy): Likewise.\n+\t(clrssbsy): Likewise.\n+\t(nop_endbr): Likewise.\n+\t* config/i386/i386.opt: Add -mcet, -mibt, -mshstk and -mcet-switch\n+\toptions.\n+\t* config/i386/immintrin.h: Include <cetintrin.h>.\n+\t* config/i386/linux-common.h\n+\t(file_end_indicate_exec_stack_and_cet): New prototype.\n+\t(TARGET_ASM_FILE_END): New.\n+\n 2017-10-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* x86-tune-costs.h (intel_cost, generic_cost): Fix move costs."}, {"sha": "ada918e6f2a4c324c3194238f5a7ec9de958675b", "filename": "gcc/common/config/i386/i386-common.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -138,6 +138,8 @@ along with GCC; see the file COPYING3.  If not see\n #define OPTION_MASK_ISA_PKU_SET OPTION_MASK_ISA_PKU\n #define OPTION_MASK_ISA_RDPID_SET OPTION_MASK_ISA_RDPID\n #define OPTION_MASK_ISA_GFNI_SET OPTION_MASK_ISA_GFNI\n+#define OPTION_MASK_ISA_IBT_SET OPTION_MASK_ISA_IBT\n+#define OPTION_MASK_ISA_SHSTK_SET OPTION_MASK_ISA_SHSTK\n \n /* Define a set of ISAs which aren't available when a given ISA is\n    disabled.  MMX and SSE ISAs are handled separately.  */\n@@ -204,6 +206,8 @@ along with GCC; see the file COPYING3.  If not see\n #define OPTION_MASK_ISA_PKU_UNSET OPTION_MASK_ISA_PKU\n #define OPTION_MASK_ISA_RDPID_UNSET OPTION_MASK_ISA_RDPID\n #define OPTION_MASK_ISA_GFNI_UNSET OPTION_MASK_ISA_GFNI\n+#define OPTION_MASK_ISA_IBT_UNSET OPTION_MASK_ISA_IBT\n+#define OPTION_MASK_ISA_SHSTK_UNSET OPTION_MASK_ISA_SHSTK\n \n /* SSE4 includes both SSE4.1 and SSE4.2.  -mno-sse4 should the same\n    as -mno-sse4.1. */\n@@ -499,6 +503,35 @@ ix86_handle_option (struct gcc_options *opts,\n \t}\n       return true;\n \n+    case OPT_mcet:\n+    case OPT_mibt:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_IBT_SET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_IBT_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA_IBT_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_IBT_UNSET;\n+\t}\n+      if (code != OPT_mcet)\n+\treturn true;\n+      /* fall through.  */\n+\n+    case OPT_mshstk:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_SHSTK_SET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_SHSTK_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA_SHSTK_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_SHSTK_UNSET;\n+\t}\n+      return true;\n+\n     case OPT_mavx5124fmaps:\n       if (value)\n \t{"}, {"sha": "c3dab848345ae1c8bd1b3fd50f8e4ef4f2b6e18b", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -378,7 +378,7 @@ i[34567]86-*-*)\n \t\t       avx512ifmaintrin.h avx512ifmavlintrin.h avx512vbmiintrin.h\n \t\t       avx512vbmivlintrin.h avx5124fmapsintrin.h avx5124vnniwintrin.h\n \t\t       avx512vpopcntdqintrin.h clwbintrin.h mwaitxintrin.h\n-\t\t       clzerointrin.h pkuintrin.h sgxintrin.h\"\n+\t\t       clzerointrin.h pkuintrin.h sgxintrin.h cetintrin.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n@@ -402,7 +402,7 @@ x86_64-*-*)\n \t\t       avx512ifmaintrin.h avx512ifmavlintrin.h avx512vbmiintrin.h\n \t\t       avx512vbmivlintrin.h avx5124fmapsintrin.h avx5124vnniwintrin.h\n \t\t       avx512vpopcntdqintrin.h clwbintrin.h mwaitxintrin.h\n-\t\t       clzerointrin.h pkuintrin.h sgxintrin.h\"\n+\t\t       clzerointrin.h pkuintrin.h sgxintrin.h cetintrin.h\"\n \t;;\n ia64-*-*)\n \textra_headers=ia64intrin.h\n@@ -4551,7 +4551,8 @@ case ${target} in\n \ti[34567]86-*-darwin* | x86_64-*-darwin*)\n \t\t;;\n \ti[34567]86-*-linux* | x86_64-*-linux*)\n-\t\ttmake_file=\"$tmake_file i386/t-linux\"\n+\t\textra_objs=\"${extra_objs} cet.o\"\n+\t\ttmake_file=\"$tmake_file i386/t-linux i386/t-cet\"\n \t\t;;\n \ti[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu)\n \t\ttmake_file=\"$tmake_file i386/t-kfreebsd\""}, {"sha": "a53c499fd921539ea6fbd3f216e4271b071ce505", "filename": "gcc/config/i386/cet.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fcet.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fcet.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcet.c?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -0,0 +1,76 @@\n+/* Functions for CET/x86.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"output.h\"\n+#include \"linux-common.h\"\n+\n+void\n+file_end_indicate_exec_stack_and_cet (void)\n+{\n+  file_end_indicate_exec_stack ();\n+\n+  if (flag_cf_protection == CF_NONE)\n+    return;\n+\n+  unsigned int feature_1 = 0;\n+\n+  if (TARGET_IBT)\n+    /* GNU_PROPERTY_X86_FEATURE_1_IBT.  */\n+    feature_1 |= 0x1;\n+\n+  if (TARGET_SHSTK)\n+    /* GNU_PROPERTY_X86_FEATURE_1_SHSTK.  */\n+    feature_1 |= 0x2;\n+\n+  if (feature_1)\n+    {\n+      int p2align = ptr_mode == SImode ? 2 : 3;\n+\n+      /* Generate GNU_PROPERTY_X86_FEATURE_1_XXX.  */\n+      switch_to_section (get_section (\".note.gnu.property\",\n+\t\t\t\t      SECTION_NOTYPE, NULL));\n+\n+      ASM_OUTPUT_ALIGN (asm_out_file, p2align);\n+      /* name length.  */\n+      fprintf (asm_out_file, ASM_LONG \" 1f - 0f\\n\");\n+      /* data length.  */\n+      fprintf (asm_out_file, ASM_LONG \" 4f - 1f\\n\");\n+      /* note type: NT_GNU_PROPERTY_TYPE_0.  */\n+      fprintf (asm_out_file, ASM_LONG \" 5\\n\");\n+      ASM_OUTPUT_LABEL (asm_out_file, \"0\");\n+      /* vendor name: \"GNU\".  */\n+      fprintf (asm_out_file, STRING_ASM_OP \" \\\"GNU\\\"\\n\");\n+      ASM_OUTPUT_LABEL (asm_out_file, \"1\");\n+      ASM_OUTPUT_ALIGN (asm_out_file, p2align);\n+      /* pr_type: GNU_PROPERTY_X86_FEATURE_1_AND.  */\n+      fprintf (asm_out_file, ASM_LONG \" 0xc0000002\\n\");\n+      /* pr_datasz.  */\\\n+      fprintf (asm_out_file, ASM_LONG \" 3f - 2f\\n\");\n+      ASM_OUTPUT_LABEL (asm_out_file, \"2\");\n+      /* GNU_PROPERTY_X86_FEATURE_1_XXX.  */\n+      fprintf (asm_out_file, ASM_LONG \" 0x%x\\n\", feature_1);\n+      ASM_OUTPUT_LABEL (asm_out_file, \"3\");\n+      ASM_OUTPUT_ALIGN (asm_out_file, p2align);\n+      ASM_OUTPUT_LABEL (asm_out_file, \"4\");\n+    }\n+}"}, {"sha": "b15a776d7f83f86409ffe97557ed7f23636078af", "filename": "gcc/config/i386/cetintrin.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fcetintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fcetintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcetintrin.h?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -0,0 +1,134 @@\n+/* Copyright (C) 2015-2017 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#if !defined _IMMINTRIN_H_INCLUDED\n+# error \"Never use <cetintrin.h> directly; include <x86intrin.h> instead.\"\n+#endif\n+\n+#ifndef _CETINTRIN_H_INCLUDED\n+#define _CETINTRIN_H_INCLUDED\n+\n+#ifndef __SHSTK__\n+#pragma GCC push_options\n+#pragma GCC target (\"shstk\")\n+#define __DISABLE_SHSTK__\n+#endif /* __SHSTK__ */\n+\n+extern __inline unsigned int\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_rdsspd (unsigned int __B)\n+{\n+  return __builtin_ia32_rdsspd (__B);\n+}\n+\n+#ifdef __x86_64__\n+extern __inline unsigned long long\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_rdsspq (unsigned long long __B)\n+{\n+  return __builtin_ia32_rdsspq (__B);\n+}\n+#endif\n+\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_incsspd (unsigned int __B)\n+{\n+  __builtin_ia32_incsspd (__B);\n+}\n+\n+#ifdef __x86_64__\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_incsspq (unsigned long long __B)\n+{\n+  __builtin_ia32_incsspq (__B);\n+}\n+#endif\n+\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_saveprevssp (void)\n+{\n+  __builtin_ia32_saveprevssp ();\n+}\n+\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_rstorssp (void *__B)\n+{\n+  __builtin_ia32_rstorssp (__B);\n+}\n+\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_wrssd (unsigned int __B, void *__C)\n+{\n+  __builtin_ia32_wrssd (__B, __C);\n+}\n+\n+#ifdef __x86_64__\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_wrssq (unsigned long long __B, void *__C)\n+{\n+  __builtin_ia32_wrssq (__B, __C);\n+}\n+#endif\n+\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_wrussd (unsigned int __B, void *__C)\n+{\n+  __builtin_ia32_wrussd (__B, __C);\n+}\n+\n+#ifdef __x86_64__\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_wrussq (unsigned long long __B, void *__C)\n+{\n+  __builtin_ia32_wrussq (__B, __C);\n+}\n+#endif\n+\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_setssbsy (void)\n+{\n+  __builtin_ia32_setssbsy ();\n+}\n+\n+extern __inline void\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_clrssbsy (void *__B)\n+{\n+  __builtin_ia32_clrssbsy (__B);\n+}\n+\n+#ifdef __DISABLE_SHSTK__\n+#undef __DISABLE_SHSTK__\n+#pragma GCC pop_options\n+#endif /* __DISABLE_SHSTK__ */\n+\n+#endif /* _CETINTRIN_H_INCLUDED.  */"}, {"sha": "8cb1848dff5c1a7e414704ecacab699eb608788e", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -97,13 +97,15 @@\n #define bit_AVX512VBMI\t(1 << 1)\n #define bit_PKU\t(1 << 3)\n #define bit_OSPKE\t(1 << 4)\n+#define bit_SHSTK\t(1 << 7)\n #define bit_GFNI\t(1 << 8)\n #define bit_AVX512VPOPCNTDQ\t(1 << 14)\n #define bit_RDPID\t(1 << 22)\n \n /* %edx */\n #define bit_AVX5124VNNIW (1 << 2)\n #define bit_AVX5124FMAPS (1 << 3)\n+#define bit_IBT\t(1 << 20)\n \n /* XFEATURE_ENABLED_MASK register bits (%eax == 13, %ecx == 0) */\n #define bit_BNDREGS     (1 << 3)"}, {"sha": "80283996343bc0f62ff8a844855e8b7436bc3cab", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -416,6 +416,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   unsigned int has_mwaitx = 0, has_clzero = 0, has_pku = 0, has_rdpid = 0;\n   unsigned int has_avx5124fmaps = 0, has_avx5124vnniw = 0;\n   unsigned int has_gfni = 0;\n+  unsigned int has_ibt = 0, has_shstk = 0;\n \n   bool arch;\n \n@@ -509,6 +510,9 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \n       has_avx5124vnniw = edx & bit_AVX5124VNNIW;\n       has_avx5124fmaps = edx & bit_AVX5124FMAPS;\n+\n+      has_shstk = ecx & bit_SHSTK;\n+      has_ibt = edx & bit_IBT;\n     }\n \n   if (max_level >= 13)\n@@ -1051,6 +1055,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       const char *pku = has_pku ? \" -mpku\" : \" -mno-pku\";\n       const char *rdpid = has_rdpid ? \" -mrdpid\" : \" -mno-rdpid\";\n       const char *gfni = has_gfni ? \" -mgfni\" : \" -mno-gfni\";\n+      const char *ibt = has_ibt ? \" -mibt\" : \" -mno-ibt\";\n+      const char *shstk = has_shstk ? \" -mshstk\" : \" -mno-shstk\";\n       options = concat (options, mmx, mmx3dnow, sse, sse2, sse3, ssse3,\n \t\t\tsse4a, cx16, sahf, movbe, aes, sha, pclmul,\n \t\t\tpopcnt, abm, lwp, fma, fma4, xop, bmi, sgx, bmi2,\n@@ -1060,7 +1066,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \t\t\tavx512cd, avx512pf, prefetchwt1, clflushopt,\n \t\t\txsavec, xsaves, avx512dq, avx512bw, avx512vl,\n \t\t\tavx512ifma, avx512vbmi, avx5124fmaps, avx5124vnniw,\n-\t\t\tclwb, mwaitx, clzero, pku, rdpid, gfni, NULL);\n+\t\t\tclwb, mwaitx, clzero, pku, rdpid, gfni, ibt, shstk, NULL);\n     }\n \n done:"}, {"sha": "1c0c6b498fe8a2d7812fbd88e9ce0c8878c2d287", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -286,7 +286,9 @@ DEF_FUNCTION_TYPE (V8SI, V8SI)\n DEF_FUNCTION_TYPE (VOID, PCVOID)\n DEF_FUNCTION_TYPE (VOID, PVOID)\n DEF_FUNCTION_TYPE (VOID, UINT64)\n+DEF_FUNCTION_TYPE (VOID, UINT64, PVOID)\n DEF_FUNCTION_TYPE (VOID, UNSIGNED)\n+DEF_FUNCTION_TYPE (VOID, UNSIGNED, PVOID)\n DEF_FUNCTION_TYPE (INT, PUSHORT)\n DEF_FUNCTION_TYPE (INT, PUNSIGNED)\n DEF_FUNCTION_TYPE (INT, PULONGLONG)"}, {"sha": "5a58b94ebd31e5df07b5b5271b1431bd52a61fb0", "filename": "gcc/config/i386/i386-builtin.def", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin.def?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -2779,4 +2779,25 @@ BDESC (OPTION_MASK_ISA_XOP, CODE_FOR_xop_vpermil2v4sf3,     \"__builtin_ia32_vper\n BDESC (OPTION_MASK_ISA_XOP, CODE_FOR_xop_vpermil2v4df3,     \"__builtin_ia32_vpermil2pd256\", IX86_BUILTIN_VPERMIL2PD256, UNKNOWN, (int)MULTI_ARG_4_DF2_DI_I1)\n BDESC (OPTION_MASK_ISA_XOP, CODE_FOR_xop_vpermil2v8sf3,     \"__builtin_ia32_vpermil2ps256\", IX86_BUILTIN_VPERMIL2PS256, UNKNOWN, (int)MULTI_ARG_4_SF2_SI_I1)\n \n-BDESC_END (MULTI_ARG, MAX)\n+BDESC_END (MULTI_ARG, CET)\n+\n+/* CET.  */\n+BDESC_FIRST (cet, CET,\n+       OPTION_MASK_ISA_SHSTK, CODE_FOR_incsspsi, \"__builtin_ia32_incsspd\", IX86_BUILTIN_INCSSPD, UNKNOWN, (int) VOID_FTYPE_UNSIGNED)\n+BDESC (OPTION_MASK_ISA_SHSTK | OPTION_MASK_ISA_64BIT, CODE_FOR_incsspdi, \"__builtin_ia32_incsspq\", IX86_BUILTIN_INCSSPQ, UNKNOWN, (int) VOID_FTYPE_UINT64)\n+BDESC (OPTION_MASK_ISA_SHSTK, CODE_FOR_saveprevssp, \"__builtin_ia32_saveprevssp\", IX86_BUILTIN_SAVEPREVSSP, UNKNOWN, (int) VOID_FTYPE_VOID)\n+BDESC (OPTION_MASK_ISA_SHSTK, CODE_FOR_rstorssp, \"__builtin_ia32_rstorssp\", IX86_BUILTIN_RSTORSSP, UNKNOWN, (int) VOID_FTYPE_PVOID)\n+BDESC (OPTION_MASK_ISA_SHSTK, CODE_FOR_wrsssi, \"__builtin_ia32_wrssd\", IX86_BUILTIN_WRSSD, UNKNOWN, (int) VOID_FTYPE_UNSIGNED_PVOID)\n+BDESC (OPTION_MASK_ISA_SHSTK | OPTION_MASK_ISA_64BIT, CODE_FOR_wrssdi, \"__builtin_ia32_wrssq\", IX86_BUILTIN_WRSSQ, UNKNOWN, (int) VOID_FTYPE_UINT64_PVOID)\n+BDESC (OPTION_MASK_ISA_SHSTK, CODE_FOR_wrusssi, \"__builtin_ia32_wrussd\", IX86_BUILTIN_WRUSSD, UNKNOWN, (int) VOID_FTYPE_UNSIGNED_PVOID)\n+BDESC (OPTION_MASK_ISA_SHSTK | OPTION_MASK_ISA_64BIT, CODE_FOR_wrussdi, \"__builtin_ia32_wrussq\", IX86_BUILTIN_WRUSSQ, UNKNOWN, (int) VOID_FTYPE_UINT64_PVOID)\n+BDESC (OPTION_MASK_ISA_SHSTK, CODE_FOR_setssbsy, \"__builtin_ia32_setssbsy\", IX86_BUILTIN_SETSSBSY, UNKNOWN, (int) VOID_FTYPE_VOID)\n+BDESC (OPTION_MASK_ISA_SHSTK, CODE_FOR_clrssbsy, \"__builtin_ia32_clrssbsy\", IX86_BUILTIN_CLRSSBSY, UNKNOWN, (int) VOID_FTYPE_PVOID)\n+\n+BDESC_END (CET, CET_NORMAL)\n+\n+BDESC_FIRST (cet_rdssp, CET_NORMAL,\n+       OPTION_MASK_ISA_SHSTK, CODE_FOR_rdsspsi, \"__builtin_ia32_rdsspd\", IX86_BUILTIN_RDSSPD, UNKNOWN, (int) UINT_FTYPE_UINT)\n+BDESC (OPTION_MASK_ISA_SHSTK | OPTION_MASK_ISA_64BIT, CODE_FOR_rdsspdi, \"__builtin_ia32_rdsspq\", IX86_BUILTIN_RDSSPQ, UNKNOWN, (int) UINT64_FTYPE_UINT64)\n+\n+BDESC_END (CET_NORMAL, MAX)"}, {"sha": "7f88bef3e587384887a5a8f4c07a2accff4f9f7c", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -459,6 +459,18 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__RDPID__\");\n   if (isa_flag2 & OPTION_MASK_ISA_GFNI)\n     def_or_undef (parse_in, \"__GFNI__\");\n+  if (isa_flag2 & OPTION_MASK_ISA_IBT)\n+    {\n+      def_or_undef (parse_in, \"__IBT__\");\n+      if (flag_cf_protection != CF_NONE)\n+\tdef_or_undef (parse_in, \"__CET__\");\n+    }\n+  if (isa_flag2 & OPTION_MASK_ISA_SHSTK)\n+    {\n+      def_or_undef (parse_in, \"__SHSTK__\");\n+      if (flag_cf_protection != CF_NONE)\n+\tdef_or_undef (parse_in, \"__CET__\");\n+    }\n   if (TARGET_IAMCU)\n     {\n       def_or_undef (parse_in, \"__iamcu\");"}, {"sha": "5c6e9c3494e8203252a666d665b131836cf65c64", "filename": "gcc/config/i386/i386-passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-passes.def?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -29,3 +29,5 @@ along with GCC; see the file COPYING3.  If not see\n   /* Run the 64-bit STV pass before the CSE pass so that CONST0_RTX and\n      CONSTM1_RTX generated by the STV pass can be CSEed.  */\n   INSERT_PASS_BEFORE (pass_cse2, 1, pass_stv, true /* timode_p */);\n+\n+  INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_endbranch);"}, {"sha": "c94cccdfbcaf15d72310dd905a4c3ae18b4b9710", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -354,3 +354,4 @@ class rtl_opt_pass;\n \n extern rtl_opt_pass *make_pass_insert_vzeroupper (gcc::context *);\n extern rtl_opt_pass *make_pass_stv (gcc::context *);\n+extern rtl_opt_pass *make_pass_insert_endbranch (gcc::context *);"}, {"sha": "fb0b7e71469274e5935e3b1612a2f72b59950d00", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 328, "deletions": 2, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -100,6 +100,7 @@ static rtx legitimize_pe_coff_symbol (rtx, bool);\n static void ix86_print_operand_address_as (FILE *, rtx, addr_space_t, bool);\n static bool ix86_save_reg (unsigned int, bool, bool);\n static bool ix86_function_naked (const_tree);\n+static bool ix86_notrack_prefixed_insn_p (rtx);\n \n #ifndef CHECK_STACK_LIMIT\n #define CHECK_STACK_LIMIT (-1)\n@@ -2568,6 +2569,150 @@ make_pass_stv (gcc::context *ctxt)\n   return new pass_stv (ctxt);\n }\n \n+/* Inserting ENDBRANCH instructions.  */\n+\n+static unsigned int\n+rest_of_insert_endbranch (void)\n+{\n+  timevar_push (TV_MACH_DEP);\n+\n+  rtx cet_eb;\n+  rtx_insn *insn;\n+  basic_block bb;\n+\n+  /* Currently emit EB if it's a tracking function, i.e. 'nocf_check' is\n+     absent among function attributes.  Later an optimization will be\n+     introduced to make analysis if an address of a static function is\n+     taken.  A static function whose address is not taken will get a\n+     nocf_check attribute.  This will allow to reduce the number of EB.  */\n+\n+  if (!lookup_attribute (\"nocf_check\",\n+\t\t\t TYPE_ATTRIBUTES (TREE_TYPE (cfun->decl))))\n+    {\n+      cet_eb = gen_nop_endbr ();\n+\n+      bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n+      insn = BB_HEAD (bb);\n+      emit_insn_before (cet_eb, insn);\n+    }\n+\n+  bb = 0;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_P (insn) && GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      rtx_insn *next_insn = insn;\n+\n+\t      while ((next_insn != BB_END (bb))\n+\t\t      && (DEBUG_INSN_P (NEXT_INSN (next_insn))\n+\t\t\t  || NOTE_P (NEXT_INSN (next_insn))\n+\t\t\t  || BARRIER_P (NEXT_INSN (next_insn))))\n+\t\tnext_insn = NEXT_INSN (next_insn);\n+\n+\t      /* Generate ENDBRANCH after CALL, which can return more than\n+\t\t twice, setjmp-like functions.  */\n+\t      if (find_reg_note (insn, REG_SETJMP, NULL) != NULL)\n+\t\t{\n+\t\t  cet_eb = gen_nop_endbr ();\n+\t\t  emit_insn_after (cet_eb, next_insn);\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  if (INSN_P (insn) && JUMP_P (insn) && flag_cet_switch)\n+\t    {\n+\t      rtx target = JUMP_LABEL (insn);\n+\t      if (target == NULL_RTX || ANY_RETURN_P (target))\n+\t\tcontinue;\n+\n+\t      /* Check the jump is a switch table.  */\n+\t      rtx_insn *label = as_a<rtx_insn *> (target);\n+\t      rtx_insn *table = next_insn (label);\n+\t      if (table == NULL_RTX || !JUMP_TABLE_DATA_P (table))\n+\t\tcontinue;\n+\n+\t      /* For the indirect jump find out all places it jumps and insert\n+\t\t ENDBRANCH there.  It should be done under a special flag to\n+\t\t control ENDBRANCH generation for switch stmts.  */\n+\t      edge_iterator ei;\n+\t      edge e;\n+\t      basic_block dest_blk;\n+\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t{\n+\t\t  rtx_insn *insn;\n+\n+\t\t  dest_blk = e->dest;\n+\t\t  insn = BB_HEAD (dest_blk);\n+\t\t  gcc_assert (LABEL_P (insn));\n+\t\t  cet_eb = gen_nop_endbr ();\n+\t\t  emit_insn_after (cet_eb, insn);\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  if ((LABEL_P (insn) && LABEL_PRESERVE_P (insn))\n+\t      || (NOTE_P (insn)\n+\t\t  && NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL))\n+/* TODO.  Check /s bit also.  */\n+\t    {\n+\t      cet_eb = gen_nop_endbr ();\n+\t      emit_insn_after (cet_eb, insn);\n+\t      continue;\n+\t    }\n+\t}\n+    }\n+\n+  timevar_pop (TV_MACH_DEP);\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_insert_endbranch =\n+{\n+  RTL_PASS, /* type.  */\n+  \"cet\", /* name.  */\n+  OPTGROUP_NONE, /* optinfo_flags.  */\n+  TV_MACH_DEP, /* tv_id.  */\n+  0, /* properties_required.  */\n+  0, /* properties_provided.  */\n+  0, /* properties_destroyed.  */\n+  0, /* todo_flags_start.  */\n+  0, /* todo_flags_finish.  */\n+};\n+\n+class pass_insert_endbranch : public rtl_opt_pass\n+{\n+public:\n+  pass_insert_endbranch (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_insert_endbranch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return ((flag_cf_protection & CF_BRANCH) && TARGET_IBT);\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_insert_endbranch ();\n+    }\n+\n+}; // class pass_insert_endbranch\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_insert_endbranch (gcc::context *ctxt)\n+{\n+  return new pass_insert_endbranch (ctxt);\n+}\n+\n /* Return true if a red-zone is in use.  */\n \n bool\n@@ -2600,7 +2745,9 @@ ix86_target_string (HOST_WIDE_INT isa, HOST_WIDE_INT isa2,\n     { \"-msgx\",\t\tOPTION_MASK_ISA_SGX },\n     { \"-mavx5124vnniw\", OPTION_MASK_ISA_AVX5124VNNIW },\n     { \"-mavx5124fmaps\", OPTION_MASK_ISA_AVX5124FMAPS },\n-    { \"-mavx512vpopcntdq\", OPTION_MASK_ISA_AVX512VPOPCNTDQ }\n+    { \"-mavx512vpopcntdq\", OPTION_MASK_ISA_AVX512VPOPCNTDQ },\n+    { \"-mibt\",\tOPTION_MASK_ISA_IBT },\n+    { \"-mshstk\",\tOPTION_MASK_ISA_SHSTK }\n   };\n   static struct ix86_target_opts isa_opts[] =\n   {\n@@ -4693,6 +4840,37 @@ ix86_option_override_internal (bool main_args_p,\n     target_option_default_node = target_option_current_node\n       = build_target_option_node (opts);\n \n+  /* Do not support control flow instrumentation if CET is not enabled.  */\n+  if (opts->x_flag_cf_protection != CF_NONE)\n+    {\n+      if (!(TARGET_IBT_P (opts->x_ix86_isa_flags2)\n+\t    || TARGET_SHSTK_P (opts->x_ix86_isa_flags2)))\n+\t{\n+\t  if (flag_cf_protection == CF_FULL)\n+\t    {\n+\t      error (\"%<-fcf-protection=full%> requires CET support \"\n+\t\t     \"on this target. Use -mcet or one of -mibt, \"\n+\t\t     \"-mshstk options to enable CET\");\n+\t    }\n+\t  else if (flag_cf_protection == CF_BRANCH)\n+\t    {\n+\t      error (\"%<-fcf-protection=branch%> requires CET support \"\n+\t\t     \"on this target. Use -mcet or one of -mibt, \"\n+\t\t     \"-mshstk options to enable CET\");\n+\t    }\n+\t  else if (flag_cf_protection == CF_RETURN)\n+\t    {\n+\t      error (\"%<-fcf-protection=return%> requires CET support \"\n+\t\t     \"on this target. Use -mcet or one of -mibt, \"\n+\t\t     \"-mshstk options to enable CET\");\n+\t    }\n+\t  flag_cf_protection = CF_NONE;\n+\t  return false;\n+\t}\n+      opts->x_flag_cf_protection =\n+\t(cf_protection_level) (opts->x_flag_cf_protection | CF_SET);\n+    }\n+\n   return true;\n }\n \n@@ -5123,6 +5301,8 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n     IX86_ATTR_ISA (\"clwb\",\tOPT_mclwb),\n     IX86_ATTR_ISA (\"rdpid\",\tOPT_mrdpid),\n     IX86_ATTR_ISA (\"gfni\",\tOPT_mgfni),\n+    IX86_ATTR_ISA (\"ibt\",\tOPT_mibt),\n+    IX86_ATTR_ISA (\"shstk\",\tOPT_mshstk),\n \n     /* enum options */\n     IX86_ATTR_ENUM (\"fpmath=\",\tOPT_mfpmath_),\n@@ -17617,6 +17797,8 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \tcase '!':\n \t  if (ix86_bnd_prefixed_insn_p (current_output_insn))\n \t    fputs (\"bnd \", file);\n+\t  if (ix86_notrack_prefixed_insn_p (current_output_insn))\n+\t    fputs (\"notrack \", file);\n \t  return;\n \n \tdefault:\n@@ -29778,8 +29960,12 @@ BDESC_VERIFYS (IX86_BUILTIN__BDESC_MPX_CONST_FIRST,\n \t       IX86_BUILTIN__BDESC_MPX_LAST, 1);\n BDESC_VERIFYS (IX86_BUILTIN__BDESC_MULTI_ARG_FIRST,\n \t       IX86_BUILTIN__BDESC_MPX_CONST_LAST, 1);\n-BDESC_VERIFYS (IX86_BUILTIN_MAX,\n+BDESC_VERIFYS (IX86_BUILTIN__BDESC_CET_FIRST,\n \t       IX86_BUILTIN__BDESC_MULTI_ARG_LAST, 1);\n+BDESC_VERIFYS (IX86_BUILTIN__BDESC_CET_NORMAL_FIRST,\n+\t       IX86_BUILTIN__BDESC_CET_LAST, 1);\n+BDESC_VERIFYS (IX86_BUILTIN_MAX,\n+\t       IX86_BUILTIN__BDESC_CET_NORMAL_LAST, 1);\n \n /* Set up all the MMX/SSE builtins, even builtins for instructions that are not\n    in the current target ISA to allow the user to compile particular modules\n@@ -30446,6 +30632,35 @@ ix86_init_mmx_sse_builtins (void)\n   BDESC_VERIFYS (IX86_BUILTIN__BDESC_MULTI_ARG_LAST,\n \t\t IX86_BUILTIN__BDESC_MULTI_ARG_FIRST,\n \t\t ARRAY_SIZE (bdesc_multi_arg) - 1);\n+\n+  /* Add CET inrinsics.  */\n+  for (i = 0, d = bdesc_cet; i < ARRAY_SIZE (bdesc_cet); i++, d++)\n+    {\n+      BDESC_VERIFY (d->code, IX86_BUILTIN__BDESC_CET_FIRST, i);\n+      if (d->name == 0)\n+\tcontinue;\n+\n+      ftype = (enum ix86_builtin_func_type) d->flag;\n+      def_builtin2 (d->mask, d->name, ftype, d->code);\n+    }\n+  BDESC_VERIFYS (IX86_BUILTIN__BDESC_CET_LAST,\n+\t\t IX86_BUILTIN__BDESC_CET_FIRST,\n+\t\t ARRAY_SIZE (bdesc_cet) - 1);\n+\n+  for (i = 0, d = bdesc_cet_rdssp;\n+       i < ARRAY_SIZE (bdesc_cet_rdssp);\n+       i++, d++)\n+    {\n+      BDESC_VERIFY (d->code, IX86_BUILTIN__BDESC_CET_NORMAL_FIRST, i);\n+      if (d->name == 0)\n+\tcontinue;\n+\n+      ftype = (enum ix86_builtin_func_type) d->flag;\n+      def_builtin2 (d->mask, d->name, ftype, d->code);\n+    }\n+  BDESC_VERIFYS (IX86_BUILTIN__BDESC_CET_NORMAL_LAST,\n+\t\t IX86_BUILTIN__BDESC_CET_NORMAL_FIRST,\n+\t\t ARRAY_SIZE (bdesc_cet_rdssp) - 1);\n }\n \n static void\n@@ -36630,6 +36845,57 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n       emit_insn (gen_xabort (op0));\n       return 0;\n \n+    case IX86_BUILTIN_RSTORSSP:\n+    case IX86_BUILTIN_CLRSSBSY:\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      op0 = expand_normal (arg0);\n+      icode = (fcode == IX86_BUILTIN_RSTORSSP\n+\t  ? CODE_FOR_rstorssp\n+\t  : CODE_FOR_clrssbsy);\n+      if (!address_operand (op0, VOIDmode))\n+\t{\n+\t  op1 = convert_memory_address (Pmode, op0);\n+\t  op0 = copy_addr_to_reg (op1);\n+\t}\n+      emit_insn (GEN_FCN (icode) (gen_rtx_MEM (Pmode, op0)));\n+      return 0;\n+\n+    case IX86_BUILTIN_WRSSD:\n+    case IX86_BUILTIN_WRSSQ:\n+    case IX86_BUILTIN_WRUSSD:\n+    case IX86_BUILTIN_WRUSSQ:\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      op0 = expand_normal (arg0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      op1 = expand_normal (arg1);\n+      switch (fcode)\n+\t{\n+\tcase IX86_BUILTIN_WRSSD:\n+\t  icode = CODE_FOR_wrsssi;\n+\t  mode = SImode;\n+\t  break;\n+\tcase IX86_BUILTIN_WRSSQ:\n+\t  icode = CODE_FOR_wrssdi;\n+\t  mode = DImode;\n+\t  break;\n+\tcase IX86_BUILTIN_WRUSSD:\n+\t  icode = CODE_FOR_wrusssi;\n+\t  mode = SImode;\n+\t  break;\n+\tcase IX86_BUILTIN_WRUSSQ:\n+\t  icode = CODE_FOR_wrussdi;\n+\t  mode = DImode;\n+\t  break;\n+\t}\n+      op0 = force_reg (mode, op0);\n+      if (!address_operand (op1, VOIDmode))\n+\t{\n+\t  op2 = convert_memory_address (Pmode, op1);\n+\t  op1 = copy_addr_to_reg (op2);\n+\t}\n+      emit_insn (GEN_FCN (icode) (op0, gen_rtx_MEM (mode, op1)));\n+      return 0;\n+\n     default:\n       break;\n     }\n@@ -36932,6 +37198,22 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t\t\t\t\t    d->flag, d->comparison);\n     }\n \n+  if (fcode >= IX86_BUILTIN__BDESC_CET_FIRST\n+      && fcode <= IX86_BUILTIN__BDESC_CET_LAST)\n+    {\n+      i = fcode - IX86_BUILTIN__BDESC_CET_FIRST;\n+      return ix86_expand_special_args_builtin (bdesc_cet + i, exp,\n+\t\t\t\t\t       target);\n+    }\n+\n+  if (fcode >= IX86_BUILTIN__BDESC_CET_NORMAL_FIRST\n+      && fcode <= IX86_BUILTIN__BDESC_CET_NORMAL_LAST)\n+    {\n+      i = fcode - IX86_BUILTIN__BDESC_CET_NORMAL_FIRST;\n+      return ix86_expand_args_builtin (bdesc_cet_rdssp + i, exp,\n+\t\t\t\t       target);\n+    }\n+\n   gcc_unreachable ();\n }\n \n@@ -39825,6 +40107,10 @@ x86_output_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n+  /* CET is enabled, insert EB instruction.  */\n+  if ((flag_cf_protection & CF_BRANCH) && TARGET_IBT)\n+    emit_insn (gen_nop_endbr ());\n+\n   /* If VCALL_OFFSET, we'll need THIS in a register.  Might as well\n      pull it in now and let DELTA benefit.  */\n   if (REG_P (this_param))\n@@ -47668,6 +47954,46 @@ ix86_bnd_prefixed_insn_p (rtx insn)\n   return chkp_function_instrumented_p (current_function_decl);\n }\n \n+/* Return 1 if control tansfer instruction INSN\n+   should be encoded with notrack prefix.  */\n+\n+static bool\n+ix86_notrack_prefixed_insn_p (rtx insn)\n+{\n+  if (!insn || !((flag_cf_protection & CF_BRANCH) && TARGET_IBT))\n+    return false;\n+\n+  if (CALL_P (insn))\n+    {\n+      rtx call = get_call_rtx_from (insn);\n+      gcc_assert (call != NULL_RTX);\n+      rtx addr = XEXP (call, 0);\n+\n+      /* Do not emit 'notrack' if it's not an indirect call.  */\n+      if (MEM_P (addr)\n+\t  && GET_CODE (XEXP (addr, 0)) == SYMBOL_REF)\n+\treturn false;\n+      else\n+\treturn find_reg_note (insn, REG_CALL_NOCF_CHECK, 0);\n+    }\n+\n+  if (JUMP_P (insn) && !flag_cet_switch)\n+    {\n+      rtx target = JUMP_LABEL (insn);\n+      if (target == NULL_RTX || ANY_RETURN_P (target))\n+\treturn false;\n+\n+      /* Check the jump is a switch table.  */\n+      rtx_insn *label = as_a<rtx_insn *> (target);\n+      rtx_insn *table = next_insn (label);\n+      if (table == NULL_RTX || !JUMP_TABLE_DATA_P (table))\n+\treturn false;\n+      else\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Calculate integer abs() using only SSE2 instructions.  */\n \n void"}, {"sha": "8fbad16b4081b0510d64c7635068646056137d74", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -169,6 +169,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_MWAITX_P(x)\tTARGET_ISA_MWAITX_P(x)\n #define TARGET_PKU\tTARGET_ISA_PKU\n #define TARGET_PKU_P(x)\tTARGET_ISA_PKU_P(x)\n+#define TARGET_IBT\tTARGET_ISA_IBT\n+#define TARGET_IBT_P(x)\tTARGET_ISA_IBT_P(x)\n+#define TARGET_SHSTK\tTARGET_ISA_SHSTK\n+#define TARGET_SHSTK_P(x)\tTARGET_ISA_SHSTK_P(x)\n \n #define TARGET_LP64\tTARGET_ABI_64\n #define TARGET_LP64_P(x)\tTARGET_ABI_64_P(x)"}, {"sha": "fcb3edddf82e6d35bf6704fd1b07fe24239dfa29", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 188, "deletions": 1, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -62,7 +62,7 @@\n ;; ; -- print a semicolon (after prefixes due to bug in older gas).\n ;; ~ -- print \"i\" if TARGET_AVX2, \"f\" otherwise.\n ;; ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n-;; ! -- print MPX prefix for jxx/call/ret instructions if required.\n+;; ! -- print MPX or NOTRACK prefix for jxx/call/ret instructions if required.\n \n (define_c_enum \"unspec\" [\n   ;; Relocation specifiers\n@@ -274,6 +274,17 @@\n \n   ;; For RDPID support\n   UNSPECV_RDPID\n+\n+  ;; For CET support\n+  UNSPECV_NOP_ENDBR\n+  UNSPECV_NOP_RDSSP\n+  UNSPECV_INCSSP\n+  UNSPECV_SAVEPREVSSP\n+  UNSPECV_RSTORSSP\n+  UNSPECV_WRSS\n+  UNSPECV_WRUSS\n+  UNSPECV_SETSSBSY\n+  UNSPECV_CLRSSBSY\n ])\n \n ;; Constants to represent rounding modes in the ROUND instruction\n@@ -18215,6 +18226,28 @@\n   \"* return output_probe_stack_range (operands[0], operands[2]);\"\n   [(set_attr \"type\" \"multi\")])\n \n+/* Additional processing for builtin_setjmp.  Store the shadow stack pointer\n+   as a forth element in jmpbuf.  */\n+(define_expand \"builtin_setjmp_setup\"\n+  [(match_operand 0 \"address_operand\")]\n+  \"TARGET_SHSTK\"\n+{\n+  if (flag_cf_protection & CF_RETURN)\n+    {\n+      rtx mem, reg_ssp;\n+\n+      mem = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0],\n+\t\t\t\t\t       3 * GET_MODE_SIZE (Pmode)));\n+      reg_ssp = gen_reg_rtx (Pmode);\n+      emit_insn (gen_rtx_SET (reg_ssp, const0_rtx));\n+      emit_insn ((Pmode == SImode)\n+\t\t  ? gen_rdsspsi (reg_ssp, reg_ssp)\n+\t\t  : gen_rdsspdi (reg_ssp, reg_ssp));\n+      emit_move_insn (mem, reg_ssp);\n+    }\n+  DONE;\n+})\n+\n (define_expand \"builtin_setjmp_receiver\"\n   [(label_ref (match_operand 0))]\n   \"!TARGET_64BIT && flag_pic\"\n@@ -18235,6 +18268,83 @@\n   DONE;\n })\n \n+(define_expand \"builtin_longjmp\"\n+  [(match_operand 0 \"address_operand\")]\n+  \"TARGET_SHSTK\"\n+{\n+  rtx fp, lab, stack;\n+  rtx jump, label, reg_adj, reg_ssp, reg_minus, mem_buf, tmp, clob;\n+  machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+\n+  /* Adjust the shadow stack pointer (ssp) to the value saved in the\n+     jmp_buf.  The saving was done in the builtin_setjmp_setup.  */\n+  if (flag_cf_protection & CF_RETURN)\n+    {\n+      /* Get current shadow stack pointer.  The code below will check if\n+\t SHSTK feature is enabled.  If it's not enabled RDSSP instruction\n+\t is a NOP.  */\n+      reg_ssp = gen_reg_rtx (Pmode);\n+      emit_insn (gen_rtx_SET (reg_ssp, const0_rtx));\n+      emit_insn ((Pmode == SImode)\n+\t\t ? gen_rdsspsi (reg_ssp, reg_ssp)\n+\t\t : gen_rdsspdi (reg_ssp, reg_ssp));\n+      mem_buf = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0],\n+\t\t\t\t\t\t   3 * GET_MODE_SIZE (Pmode))),\n+\n+      /* Compare through substraction the saved and the current ssp to decide\n+\t if ssp has to be adjusted.  */\n+      reg_minus = gen_reg_rtx (Pmode);\n+      tmp = gen_rtx_SET (reg_minus, gen_rtx_MINUS (Pmode, reg_ssp, mem_buf));\n+      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, clob));\n+      emit_insn (tmp);\n+\n+      /* Jump over adjustment code.  */\n+      label = gen_label_rtx ();\n+      tmp = gen_rtx_REG (CCmode, FLAGS_REG);\n+      tmp = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t\t  pc_rtx);\n+      jump = emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));\n+      JUMP_LABEL (jump) = label;\n+\n+      /* Adjust the ssp.  */\n+      reg_adj = gen_reg_rtx (Pmode);\n+      tmp = gen_rtx_SET (reg_adj,\n+\t\t\t gen_rtx_LSHIFTRT (Pmode, negate_rtx (Pmode, reg_minus),\n+\t\t\t\t\t   GEN_INT (3)));\n+      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, clob));\n+      emit_insn (tmp);\n+      emit_insn ((Pmode == SImode)\n+\t\t ? gen_incsspsi (reg_adj)\n+\t\t : gen_incsspdi (reg_adj));\n+\n+      emit_label (label);\n+      LABEL_NUSES (label) = 1;\n+    }\n+\n+  /* This code is the same as in expand_buildin_longjmp.  */\n+  fp = gen_rtx_MEM (Pmode, operands[0]);\n+  lab = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0],\n+\t\t\t\t\t   GET_MODE_SIZE (Pmode)));\n+  stack = gen_rtx_MEM (sa_mode, plus_constant (Pmode, operands[0],\n+\t\t\t\t\t       2 * GET_MODE_SIZE (Pmode)));\n+  lab = copy_to_reg (lab);\n+\n+  emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n+  emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n+\n+  emit_move_insn (hard_frame_pointer_rtx, fp);\n+  emit_stack_restore (SAVE_NONLOCAL, stack);\n+\n+  emit_use (hard_frame_pointer_rtx);\n+  emit_use (stack_pointer_rtx);\n+  emit_indirect_jump (lab);\n+})\n+\n+\n ;; Avoid redundant prefixes by splitting HImode arithmetic to SImode.\n ;; Do not split instructions with mask registers.\n (define_split\n@@ -19855,6 +19965,83 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"memory\" \"unknown\")])\n \n+;; CET instructions\n+(define_insn \"rdssp<mode>\"\n+  [(set (match_operand:SWI48x 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SWI48x\n+\t  [(match_operand:SWI48x 1 \"register_operand\" \"0\")]\n+\t  UNSPECV_NOP_RDSSP))]\n+  \"TARGET_SHSTK\"\n+  \"rdssp<mskmodesuffix>\\t%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"incssp<mode>\"\n+  [(unspec_volatile [(match_operand:SWI48x 0 \"register_operand\" \"r\")]\n+\t\t   UNSPECV_INCSSP)]\n+  \"TARGET_SHSTK\"\n+  \"incssp<mskmodesuffix>\\t%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"saveprevssp\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SAVEPREVSSP)]\n+  \"TARGET_SHSTK\"\n+  \"saveprevssp\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"rstorssp\"\n+  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")]\n+\t\t   UNSPECV_RSTORSSP)]\n+  \"TARGET_SHSTK\"\n+  \"rstorssp\\t%0\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"wrss<mode>\"\n+  [(unspec_volatile [(match_operand:SWI48x 0 \"register_operand\" \"r\")\n+\t\t     (match_operand:SWI48x 1 \"memory_operand\" \"m\")]\n+\t\t   UNSPECV_WRSS)]\n+  \"TARGET_SHSTK\"\n+  \"wrss<mskmodesuffix>\\t%0, %1\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"wruss<mode>\"\n+  [(unspec_volatile [(match_operand:SWI48x 0 \"register_operand\" \"r\")\n+\t\t     (match_operand:SWI48x 1 \"memory_operand\" \"m\")]\n+\t\t   UNSPECV_WRUSS)]\n+  \"TARGET_SHSTK\"\n+  \"wruss<mskmodesuffix>\\t%0, %1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"setssbsy\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SETSSBSY)]\n+  \"TARGET_SHSTK\"\n+  \"setssbsy\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"clrssbsy\"\n+  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")]\n+\t\t   UNSPECV_CLRSSBSY)]\n+  \"TARGET_SHSTK\"\n+  \"clrssbsy\\t%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"other\")])\n+\n+(define_insn \"nop_endbr\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_NOP_ENDBR)]\n+  \"TARGET_IBT\"\n+  \"*\n+{ return (TARGET_64BIT)? \\\"endbr64\\\" : \\\"endbr32\\\"; }\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"modrm\" \"0\")])\n+\n+;; For RTM support\n (define_expand \"xbegin\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_XBEGIN))]"}, {"sha": "7c9dd471686b6d98efdd0646d9b779573d7866c5", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -957,3 +957,23 @@ Attempt to avoid generating instruction sequences containing ret bytes.\n mgeneral-regs-only\n Target Report RejectNegative Mask(GENERAL_REGS_ONLY) Var(ix86_target_flags) Save\n Generate code which uses only the general registers.\n+\n+mcet\n+Target Report Var(flag_cet) Init(0)\n+Support Control-flow  Enforcment Technology (CET) built-in functions\n+and code generation.\n+\n+mibt\n+Target Report Mask(ISA_IBT) Var(ix86_isa_flags2) Save\n+Specifically enables an indirect branch tracking feature from Control-flow\n+Enforcment Technology (CET).\n+\n+mshstk\n+Target Report Mask(ISA_SHSTK) Var(ix86_isa_flags2) Save\n+Specifically enables an shadow stack support feature from Control-flow\n+Enforcment Technology (CET).\n+\n+mcet-switch\n+Target Report Undocumented Var(flag_cet_switch) Init(0)\n+Turn on CET instrumentation for switch statements, which use jump table and\n+indirect jump."}, {"sha": "696cd20e5381fcfd92a7eef7bd00ee04069d5f22", "filename": "gcc/config/i386/immintrin.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fimmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Fimmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fimmintrin.h?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -90,6 +90,8 @@\n \n #include <xtestintrin.h>\n \n+#include <cetintrin.h>\n+\n #ifndef __RDRND__\n #pragma GCC push_options\n #pragma GCC target(\"rdrnd\")"}, {"sha": "6613807180e1961b24e3d04dd3dcb7ac86e5b9d2", "filename": "gcc/config/i386/linux-common.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Flinux-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Flinux-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux-common.h?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -121,3 +121,8 @@ along with GCC; see the file COPYING3.  If not see\n #define CHKP_SPEC \"\\\n %{!nostdlib:%{!nodefaultlibs:\" LIBMPX_SPEC LIBMPXWRAPPERS_SPEC \"}}\" MPX_SPEC\n #endif\n+\n+extern void file_end_indicate_exec_stack_and_cet (void);\n+\n+#undef TARGET_ASM_FILE_END\n+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack_and_cet"}, {"sha": "317f30dbb98d8c2f7ec67114414249329eb4867b", "filename": "gcc/config/i386/t-cet", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Ft-cet", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a25448c490b16eea276521d818640bcaca75e35/gcc%2Fconfig%2Fi386%2Ft-cet", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-cet?ref=2a25448c490b16eea276521d818640bcaca75e35", "patch": "@@ -0,0 +1,21 @@\n+# Copyright (C) 2017 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+cet.o: $(srcdir)/config/i386/cet.c\n+\t  $(COMPILE) $<\n+\t  $(POSTCOMPILE)"}]}