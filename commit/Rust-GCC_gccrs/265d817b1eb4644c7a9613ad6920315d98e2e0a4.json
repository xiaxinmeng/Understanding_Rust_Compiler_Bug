{"sha": "265d817b1eb4644c7a9613ad6920315d98e2e0a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY1ZDgxN2IxZWI0NjQ0YzdhOTYxM2FkNjkyMDMxNWQ5OGUyZTBhNA==", "commit": {"author": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2020-08-04T03:09:15Z"}, "committer": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2020-08-04T03:09:15Z"}, "message": "dse: Remove partial load after full store for high part access[PR71309]\n\nv5 update as comments:\n1. Move const_rhs out of loop;\n2. Iterate from int size for read_mode.\n\nThis patch could optimize(works for char/short/int/void*):\n\n6: r119:TI=[r118:DI+0x10]\n7: [r118:DI]=r119:TI\n8: r121:DI=[r118:DI+0x8]\n\n=>\n\n6: r119:TI=[r118:DI+0x10]\n16: r122:DI=r119:TI#8\n\nFinal ASM will be as below without partial load after full store(stxv+ld):\n  ld 10,16(3)\n  mr 9,3\n  ld 3,24(3)\n  std 10,0(9)\n  std 3,8(9)\n  blr\n\nIt could achieve ~25% performance improvement for typical cases on\nPower9.  Bootstrap and regression tested on Power9-LE.\n\nFor AArch64, one ldr is replaced by mov with this patch:\n\nldp     x2, x3, [x0, 16]\nstp     x2, x3, [x0]\nldr     x0, [x0, 8]\n\n=>\n\nmov     x1, x0\nldp     x2, x0, [x0, 16]\nstp     x2, x0, [x1]\n\ngcc/ChangeLog:\n\n2020-08-04  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\tPR rtl-optimization/71309\n\t* dse.c (find_shift_sequence): Use subreg of shifted from high part\n\tregister to avoid loading from address.\n\ngcc/testsuite/ChangeLog:\n\n2020-08-04  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\tPR rtl-optimization/71309\n\t* gcc.target/powerpc/pr71309.c: New test.", "tree": {"sha": "10b0950642c2dc9f5e0468fcfd882a895396e817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10b0950642c2dc9f5e0468fcfd882a895396e817"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/265d817b1eb4644c7a9613ad6920315d98e2e0a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265d817b1eb4644c7a9613ad6920315d98e2e0a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265d817b1eb4644c7a9613ad6920315d98e2e0a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265d817b1eb4644c7a9613ad6920315d98e2e0a4/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a1ad710ad20ef05296013679dd42724865a0396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1ad710ad20ef05296013679dd42724865a0396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a1ad710ad20ef05296013679dd42724865a0396"}], "stats": {"total": 112, "additions": 83, "deletions": 29}, "files": [{"sha": "d65266b547646706bd443d4c2841a098c3a6fc90", "filename": "gcc/dse.c", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d817b1eb4644c7a9613ad6920315d98e2e0a4/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d817b1eb4644c7a9613ad6920315d98e2e0a4/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=265d817b1eb4644c7a9613ad6920315d98e2e0a4", "patch": "@@ -1720,6 +1720,35 @@ find_shift_sequence (poly_int64 access_size,\n   scalar_int_mode new_mode;\n   rtx read_reg = NULL;\n \n+  /* If a constant was stored into memory, try to simplify it here,\n+     otherwise the cost of the shift might preclude this optimization\n+     e.g. at -Os, even when no actual shift will be needed.  */\n+  if (store_info->const_rhs)\n+    {\n+      auto new_mode = smallest_int_mode_for_size (access_size * BITS_PER_UNIT);\n+      auto byte = subreg_lowpart_offset (new_mode, store_mode);\n+      rtx ret\n+\t= simplify_subreg (new_mode, store_info->const_rhs, store_mode, byte);\n+      if (ret && CONSTANT_P (ret))\n+\t{\n+\t  rtx shift_rtx = gen_int_shift_amount (new_mode, shift);\n+\t  ret = simplify_const_binary_operation (LSHIFTRT, new_mode, ret,\n+\t\t\t\t\t\t shift_rtx);\n+\t  if (ret && CONSTANT_P (ret))\n+\t    {\n+\t      byte = subreg_lowpart_offset (read_mode, new_mode);\n+\t      ret = simplify_subreg (read_mode, ret, new_mode, byte);\n+\t      if (ret && CONSTANT_P (ret)\n+\t\t  && (set_src_cost (ret, read_mode, speed)\n+\t\t      <= COSTS_N_INSNS (1)))\n+\t\treturn ret;\n+\t    }\n+\t}\n+    }\n+\n+  if (require_cst)\n+    return NULL_RTX;\n+\n   /* Some machines like the x86 have shift insns for each size of\n      operand.  Other machines like the ppc or the ia-64 may only have\n      shift insns that shift values within 32 or 64 bit registers.\n@@ -1729,7 +1758,7 @@ find_shift_sequence (poly_int64 access_size,\n \n   opt_scalar_int_mode new_mode_iter;\n   FOR_EACH_MODE_FROM (new_mode_iter,\n-\t\t      smallest_int_mode_for_size (access_size * BITS_PER_UNIT))\n+\t\t      smallest_int_mode_for_size (GET_MODE_BITSIZE (read_mode)))\n     {\n       rtx target, new_reg, new_lhs;\n       rtx_insn *shift_seq, *insn;\n@@ -1739,34 +1768,6 @@ find_shift_sequence (poly_int64 access_size,\n       if (GET_MODE_BITSIZE (new_mode) > BITS_PER_WORD)\n \tbreak;\n \n-      /* If a constant was stored into memory, try to simplify it here,\n-\t otherwise the cost of the shift might preclude this optimization\n-\t e.g. at -Os, even when no actual shift will be needed.  */\n-      if (store_info->const_rhs)\n-\t{\n-\t  poly_uint64 byte = subreg_lowpart_offset (new_mode, store_mode);\n-\t  rtx ret = simplify_subreg (new_mode, store_info->const_rhs,\n-\t\t\t\t     store_mode, byte);\n-\t  if (ret && CONSTANT_P (ret))\n-\t    {\n-\t      rtx shift_rtx = gen_int_shift_amount (new_mode, shift);\n-\t      ret = simplify_const_binary_operation (LSHIFTRT, new_mode,\n-\t\t\t\t\t\t     ret, shift_rtx);\n-\t      if (ret && CONSTANT_P (ret))\n-\t\t{\n-\t\t  byte = subreg_lowpart_offset (read_mode, new_mode);\n-\t\t  ret = simplify_subreg (read_mode, ret, new_mode, byte);\n-\t\t  if (ret && CONSTANT_P (ret)\n-\t\t      && (set_src_cost (ret, read_mode, speed)\n-\t\t\t  <= COSTS_N_INSNS (1)))\n-\t\t    return ret;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (require_cst)\n-\treturn NULL_RTX;\n-\n       /* Try a wider mode if truncating the store mode to NEW_MODE\n \t requires a real instruction.  */\n       if (maybe_lt (GET_MODE_SIZE (new_mode), GET_MODE_SIZE (store_mode))\n@@ -1779,6 +1780,25 @@ find_shift_sequence (poly_int64 access_size,\n \t  && !targetm.modes_tieable_p (new_mode, store_mode))\n \tcontinue;\n \n+      if (multiple_p (shift, GET_MODE_BITSIZE (new_mode))\n+\t  && known_le (GET_MODE_SIZE (new_mode), GET_MODE_SIZE (store_mode)))\n+\t{\n+\t  /* Try to implement the shift using a subreg.  */\n+\t  poly_int64 offset\n+\t    = subreg_offset_from_lsb (new_mode, store_mode, shift);\n+\t  rtx rhs_subreg = simplify_gen_subreg (new_mode, store_info->rhs,\n+\t\t\t\t\t\tstore_mode, offset);\n+\t  if (rhs_subreg)\n+\t    {\n+\t      read_reg\n+\t\t= extract_low_bits (read_mode, new_mode, copy_rtx (rhs_subreg));\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (maybe_lt (GET_MODE_SIZE (new_mode), access_size))\n+\tcontinue;\n+\n       new_reg = gen_reg_rtx (new_mode);\n \n       start_sequence ();"}, {"sha": "e1cbcea7e76393d748c2617765643e26bb6eaed4", "filename": "gcc/testsuite/gcc.target/powerpc/pr71309.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d817b1eb4644c7a9613ad6920315d98e2e0a4/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71309.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d817b1eb4644c7a9613ad6920315d98e2e0a4/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71309.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71309.c?ref=265d817b1eb4644c7a9613ad6920315d98e2e0a4", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power9\" } */\n+\n+#define TYPE void*\n+#define TYPE2 void*\n+\n+struct path {\n+    TYPE2 mnt;\n+    TYPE dentry;\n+};\n+\n+struct nameidata {\n+    struct path path;\n+    struct path root;\n+};\n+\n+__attribute__ ((noinline))\n+TYPE foo(struct nameidata *nd)\n+{\n+  TYPE d;\n+  TYPE2 d2;\n+\n+  nd->path = nd->root;\n+  d = nd->path.dentry;\n+  d2 = nd->path.mnt;\n+  return d;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\mlxv\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mstxv\\M} } } */\n+/* { dg-final { scan-assembler-times {\\mld\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstd\\M} 2 } } */"}]}