{"sha": "af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY5ZTRhMGNmMDQ2OGI0ZDFhZjdlOWZiNDhkNzBjOWUyOTAzYmNmNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-30T20:25:14Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-30T20:25:14Z"}, "message": "Initial revision\n\nFrom-SVN: r3922", "tree": {"sha": "1755a4ff834e1fe42ae9a925d795a08e78779a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1755a4ff834e1fe42ae9a925d795a08e78779a00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6/comments", "author": null, "committer": null, "parents": [{"sha": "d08ea79fd7805fc3ab72391dcb778a2b232e2868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08ea79fd7805fc3ab72391dcb778a2b232e2868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d08ea79fd7805fc3ab72391dcb778a2b232e2868"}], "stats": {"total": 376, "additions": 376, "deletions": 0}, "files": [{"sha": "ba164c0fced06f72da70c620ff01f3e92aa3127d", "filename": "gcc/genopinit.c", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=af9e4a0cf0468b4d1af7e9fb48d70c9e2903bcf6", "patch": "@@ -0,0 +1,376 @@\n+/* Generate code to initialize optabs from machine description.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"hconfig.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+#include <ctype.h>\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+extern rtx read_rtx ();\n+\n+char *xmalloc ();\n+static void fatal ();\n+void fancy_abort ();\n+\n+/* Many parts of GCC use arrays that are indexed by machine mode and\n+   contain the insn codes for pattern in the MD file that perform a given\n+   operation on operands of that mode.\n+\n+   These patterns are present in the MD file with names that contain\n+   the mode(s) used and the name of the operation.  This program\n+   writes a function `init_all_optabs' that initializes the optabs with\n+   all the insn codes of the relevant patterns present in the MD file.\n+\n+   This array contains a list of optabs that need to be initialized.  Within\n+   each string, the name of the pattern to be matched against is delimited\n+   with %( and %).  In the string, %a and %b are used to match a short mode\n+   name (the part of the mode name not including `mode' and converted to\n+   lower-case).  When writing out the initializer, the entire string is\n+   used.  %A and %B are replaced with the full name of the mode; %a and %b\n+   are replaced with the short form of the name, as above.\n+\n+   If %N is present in the pattern, it means the two modes must be consecutive\n+   widths in the same mode class (e.g, QImode and HImode).  %I means that\n+   only integer modes should be considered for the next mode, and %F means\n+   that only float modes should be considered.\n+\n+   For some optabs, we store the operation by RTL codes.  These are only\n+   used for comparisons.  In that case, %c and %C are the lower-case and\n+   upper-case forms of the comparison, respectively.  */\n+\n+char *optabs[] =\n+{ \"extendtab[(int) %B][(int) %A][0] = CODE_FOR_%(extend%a%b2%)\",\n+  \"extendtab[(int) %B][(int) %A][1] = CODE_FOR_%(zero_extend%a%b2%)\",\n+  \"fixtab[(int) %A][(int) %B][0] = CODE_FOR_%(fix_%F%a%I%b2%)\",\n+  \"fixtab[(int) %A][(int) %B][1] = CODE_FOR_%(fixuns%F%a%b2%)\",\n+  \"fixtrunctab[(int) %A][(int) %B][0] = CODE_FOR_%(fix_trunc%F%a%I%b2%)\",\n+  \"fixtrunctab[(int) %A][(int) %B][1] = CODE_FOR_%(fixuns_trunc%F%a%I%b2%)\",\n+  \"floattab[(int) %B][(int) %A][0] = CODE_FOR_%(float%I%a%F%b2%)\",\n+  \"floattab[(int) %B][(int) %A][1] = CODE_FOR_%(floatuns%I%a%F%b%)\",\n+  \"add_optab->handlers[(int) %A].insn_code = CODE_FOR_%(add%a3%)\",\n+  \"sub_optab->handlers[(int) %A].insn_code = CODE_FOR_%(sub%a3%)\",\n+  \"smul_optab->handlers[(int) %A].insn_code = CODE_FOR_%(mul%a3%)\",\n+  \"smul_widen_optab->handlers[(int) %B].insn_code = CODE_FOR_%(mul%a%b3%)%N\",\n+  \"umul_widen_optab->handlers[(int) %B].insn_code = CODE_FOR_%(umul%a%b3%)%N\",\n+  \"sdiv_optab->handlers[(int) %A].insn_code = CODE_FOR_%(div%I%a3%)\",\n+  \"udiv_optab->handlers[(int) %A].insn_code = CODE_FOR_%(udiv%I%a3%)\",\n+  \"sdivmod_optab->handlers[(int) %A].insn_code = CODE_FOR_%(divmod%a4%)\",\n+  \"udivmod_optab->handlers[(int) %A].insn_code = CODE_FOR_%(udivmod%a4%)\",\n+  \"smod_optab->handlers[(int) %A].insn_code = CODE_FOR_%(mod%a3%)\",\n+  \"umod_optab->handlers[(int) %A].insn_code = CODE_FOR_%(umod%a3%)\",\n+  \"flodiv_optab->handlers[(int) %A].insn_code = CODE_FOR_%(div%F%a3%)\",\n+  \"ftrunc_optab->handlers[(int) %A].insn_code = CODE_FOR_%(ftrunc%F%a2%)\",\n+  \"and_optab->handlers[(int) %A].insn_code = CODE_FOR_%(and%a3%)\",\n+  \"ior_optab->handlers[(int) %A].insn_code = CODE_FOR_%(ior%a3%)\",\n+  \"xor_optab->handlers[(int) %A].insn_code = CODE_FOR_%(xor%a3%)\",\n+  \"ashl_optab->handlers[(int) %A].insn_code = CODE_FOR_%(ashl%a3%)\",\n+  \"ashr_optab->handlers[(int) %A].insn_code = CODE_FOR_%(ashr%a3%)\",\n+  \"lshl_optab->handlers[(int) %A].insn_code = CODE_FOR_%(lshl%a3%)\",\n+  \"lshr_optab->handlers[(int) %A].insn_code = CODE_FOR_%(lshr%a3%)\",\n+  \"rotl_optab->handlers[(int) %A].insn_code = CODE_FOR_%(rotl%a3%)\",\n+  \"rotr_optab->handlers[(int) %A].insn_code = CODE_FOR_%(rotr%a3%)\",\n+  \"smin_optab->handlers[(int) %A].insn_code = CODE_FOR_%(smin%I%a3%)\",\n+  \"smin_optab->handlers[(int) %A].insn_code = CODE_FOR_%(min%F%a3%)\",\n+  \"smax_optab->handlers[(int) %A].insn_code = CODE_FOR_%(smax%I%a3%)\",\n+  \"smax_optab->handlers[(int) %A].insn_code = CODE_FOR_%(max%F%a3%)\",\n+  \"umin_optab->handlers[(int) %A].insn_code = CODE_FOR_%(umin%I%a3%)\",\n+  \"umax_optab->handlers[(int) %A].insn_code = CODE_FOR_%(umax%I%a3%)\",\n+  \"neg_optab->handlers[(int) %A].insn_code = CODE_FOR_%(neg%a2%)\",\n+  \"abs_optab->handlers[(int) %A].insn_code = CODE_FOR_%(abs%a2%)\",\n+  \"sqrt_optab->handlers[(int) %A].insn_code = CODE_FOR_%(sqrt%a2%)\",\n+  \"sin_optab->handlers[(int) %A].insn_code = CODE_FOR_%(sin%a2%)\",\n+  \"cos_optab->handlers[(int) %A].insn_code = CODE_FOR_%(cos%a2%)\",\n+  \"strlen_optab->handlers[(int) %A].insn_code = CODE_FOR_%(strlen%a2%)\",\n+  \"one_cmpl_optab->handlers[(int) %A].insn_code = CODE_FOR_%(one_cmpl%a2%)\",\n+  \"ffs_optab->handlers[(int) %A].insn_code = CODE_FOR_%(ffs%a2%)\",\n+  \"mov_optab->handlers[(int) %A].insn_code = CODE_FOR_%(mov%a%)\",\n+  \"movstrict_optab->handlers[(int) %A].insn_code = CODE_FOR_%(movstrict%a%)\",\n+  \"cmp_optab->handlers[(int) %A].insn_code = CODE_FOR_%(cmp%a%)\",\n+  \"tst_optab->handlers[(int) %A].insn_code = CODE_FOR_%(tst%a%)\",\n+  \"bcc_gen_fctn[(int) %C] = gen_%(b%c%)\",\n+  \"setcc_gen_code[(int) %C] = CODE_FOR_%(s%c%)\",\n+  \"reload_in_optab[(int) %A] = CODE_FOR_%(reload_in%a%)\",\n+  \"reload_out_optab[(int) %A] = CODE_FOR_%(reload_out%a%)\",\n+  \"movstr_optab[(int) %A] = CODE_FOR_%(movstr%a%)\" };\n+\n+static void\n+gen_insn (insn)\n+     rtx insn;\n+{\n+  char *name = XSTR (insn, 0);\n+  int m1, m2, op;\n+  int pindex;\n+  int i;\n+  char *np, *pp, *p, *q;\n+  struct obstack *obstack_ptr;\n+\n+  /* Don't mention instructions whose names are the null string.\n+     They are in the machine description just to be recognized.  */\n+  if (*name == 0)\n+    return;\n+\n+  /* See if NAME matches one of the patterns we have for the optabs we know\n+     about.  */\n+\n+  for (pindex = 0; pindex < sizeof optabs / sizeof optabs[0]; pindex++)\n+    {\n+      int force_float = 0, force_int = 0;\n+      int force_consec = 0;\n+      int matches = 1;\n+\n+      for (pp = optabs[pindex]; pp[0] != '%' || pp[1] != '('; pp++)\n+\t;\n+\n+      for (pp += 2, np = name; matches && ! (pp[0] == '%' && pp[1] == ')');\n+\t   pp++)\n+\t{\n+\t  if (*pp != '%')\n+\t    {\n+\t      if (*pp != *np++)\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    switch (*++pp)\n+\t      {\n+\t      case 'N':\n+\t\tforce_consec = 1;\n+\t\tbreak;\n+\t      case 'I':\n+\t\tforce_int = 1;\n+\t\tbreak;\n+\t      case 'F':\n+\t\tforce_float = 1;\n+\t\tbreak;\n+\t      case 'c':\n+\t\tfor (op = 0; op < NUM_RTX_CODE; op++)\n+\t\t  {\n+\t\t    for (p = rtx_name[op], q = np; *p; p++, q++)\n+\t\t      if (*p != *q)\n+\t\t\tbreak;\n+\n+\t\t    /* We have to be concerned about matching \"gt\" and\n+\t\t       missing \"gtu\", e.g., so verify we have reached the\n+\t\t       end of thing we are to match.  We do not have this\n+\t\t       problem with modes since no mode is a prefix of\n+\t\t       another.  */\n+\t\t    if (*p == 0 && *q == 0 && rtx_class[op] == '<')\n+\t\t      break;\n+\t\t  }\n+\n+\t\tif (op == NUM_RTX_CODE)\n+\t\t  matches = 0;\n+\t\telse\n+\t\t  np += strlen (rtx_name[op]);\n+\t\tbreak;\n+\t      case 'a':\n+\t      case 'b':\n+\t\tfor (i = 0; i < (int) MAX_MACHINE_MODE; i++)\n+\t\t  {\n+\t\t    for (p = mode_name[i], q = np; *p; p++, q++)\n+\t\t      if (tolower (*p) != *q)\n+\t\t\tbreak;\n+\n+\t\t    if (*p == 0\n+\t\t\t&& (! force_int || mode_class[i] == MODE_INT)\n+\t\t\t&& (! force_float || mode_class[i] == MODE_FLOAT))\n+\t\t      break;\n+\t\t  }\n+\n+\t\tif (i == (int) MAX_MACHINE_MODE)\n+\t\t  matches = 0;\n+\t\telse if (*pp == 'a')\n+\t\t  m1 = i, np += strlen (mode_name[i]);\n+\t\telse\n+\t\t  m2 = i, np += strlen (mode_name[i]);\n+\n+\t\tforce_int = force_float = 0;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tabort ();\n+\t      }\n+\t}\n+\n+      if (matches && pp[0] == '%' && pp[1] == ')'\n+\t  && *np == 0\n+\t  && (! force_consec || (int) mode_wider_mode[m1] == m2))\n+\tbreak;\n+    }\n+\n+  if (pindex == sizeof optabs / sizeof optabs[0])\n+    return;\n+\n+  /* We found a match.  If this pattern is only conditionally present,\n+     write out the \"if\" and two extra blanks.  */\n+\n+  if (*XSTR (insn, 2) != 0)\n+    printf (\"  if (HAVE_%s)\\n  \", name);\n+\n+  printf (\"  \");\n+\n+  /* Now write out the initialization, making all required substitutions.  */\n+  for (pp = optabs[pindex]; *pp; pp++)\n+    {\n+      if (*pp != '%')\n+\tprintf (\"%c\", *pp);\n+      else\n+\tswitch (*++pp)\n+\t  {\n+\t  case '(':  case ')':\n+\t  case 'I':  case 'F':  case 'N':\n+\t    break;\n+\t  case 'a':\n+\t    for (np = mode_name[m1]; *np; np++)\n+\t      printf (\"%c\", tolower (*np));\n+\t    break;\n+\t  case 'b':\n+\t    for (np = mode_name[m2]; *np; np++)\n+\t      printf (\"%c\", tolower (*np));\n+\t    break;\n+\t  case 'A':\n+\t    printf (\"%smode\", mode_name[m1]);\n+\t    break;\n+\t  case 'B':\n+\t    printf (\"%smode\", mode_name[m2]);\n+\t    break;\n+\t  case 'c':\n+\t    printf (\"%s\", rtx_name[op]);\n+\t    break;\n+\t  case 'C':\n+\t    for (np = rtx_name[op]; *np; np++)\n+\t      printf (\"%c\", toupper (*np));\n+\t    break;\n+\t  }\n+    }\n+\n+  printf (\";\\n\");\n+}\n+\f\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genopinit: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  rtx dummy;\n+  rtx *insn_ptr;\n+  FILE *infile;\n+  register int c;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  printf (\"/* Generated automatically by the program `genopinit'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"flags.h\\\"\\n\");\n+  printf (\"#include \\\"insn-flags.h\\\"\\n\");\n+  printf (\"#include \\\"insn-codes.h\\\"\\n\");\n+  printf (\"#include \\\"insn-config.h\\\"\\n\");\n+  printf (\"#include \\\"recog.h\\\"\\n\");\n+  printf (\"#include \\\"expr.h\\\"\\n\");\n+  printf (\"#include \\\"reload.h\\\"\\n\\n\");\n+\n+  printf (\"void\\ninit_all_optabs ()\\n{\\n\");\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n+\tgen_insn (desc);\n+    }\n+\n+  printf (\"}\\n\");\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}]}