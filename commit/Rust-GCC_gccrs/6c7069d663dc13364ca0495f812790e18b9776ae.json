{"sha": "6c7069d663dc13364ca0495f812790e18b9776ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM3MDY5ZDY2M2RjMTMzNjRjYTA0OTVmODEyNzkwZTE4Yjk3NzZhZQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2014-08-26T18:25:49Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2014-08-26T18:25:49Z"}, "message": "frontend_passes (expr_array): Replace by vec template.\n\n2014-08-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* frontend_passes (expr_array):  Replace by vec template.\n\t(expr_size):  Remove.\n\t(expr_count):  Remove.\n\t(doloop_list):  Replace by vec template.\n\t(doloop_size):  Remove.\n\t(gfc_run_passes):  Adjust to use of vec template.\n\t(cfe_register_funcs):  Likewise.\n\t(cfe_expr_0):  Likewise.\n\t(doloop_code):  Likewise.\n\nFrom-SVN: r214532", "tree": {"sha": "13239f4b3d334a93029ffc3e82bf4d5b0e6bb22a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13239f4b3d334a93029ffc3e82bf4d5b0e6bb22a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c7069d663dc13364ca0495f812790e18b9776ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7069d663dc13364ca0495f812790e18b9776ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7069d663dc13364ca0495f812790e18b9776ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7069d663dc13364ca0495f812790e18b9776ae/comments", "author": null, "committer": null, "parents": [{"sha": "dd60a84ce04bbd5f33d500135fc9911a26ada6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd60a84ce04bbd5f33d500135fc9911a26ada6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd60a84ce04bbd5f33d500135fc9911a26ada6e2"}], "stats": {"total": 95, "additions": 47, "deletions": 48}, "files": [{"sha": "a6abbe200380b3fcd1e0fd4d0af1f5ec55d18fe6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7069d663dc13364ca0495f812790e18b9776ae/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7069d663dc13364ca0495f812790e18b9776ae/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6c7069d663dc13364ca0495f812790e18b9776ae", "patch": "@@ -1,3 +1,15 @@\n+2014-08-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* frontend_passes (expr_array):  Replace by vec template.\n+\t(expr_size):  Remove.\n+\t(expr_count):  Remove.\n+\t(doloop_list):  Replace by vec template.\n+\t(doloop_size):  Remove.\n+\t(gfc_run_passes):  Adjust to use of vec template.\n+\t(cfe_register_funcs):  Likewise.\n+\t(cfe_expr_0):  Likewise.\n+\t(doloop_code):  Likewise.\n+\n 2014-08-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR fortran/62135"}, {"sha": "1ad302932372f39879227f68f77488d30051da55", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7069d663dc13364ca0495f812790e18b9776ae/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7069d663dc13364ca0495f812790e18b9776ae/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=6c7069d663dc13364ca0495f812790e18b9776ae", "patch": "@@ -47,11 +47,9 @@ static int callback_reduction (gfc_expr **, int *, void *);\n \n static int count_arglist;\n \n-/* Pointer to an array of gfc_expr ** we operate on, plus its size\n-   and counter.  */\n+/* Vector of gfc_expr ** we operate on.  */\n \n-static gfc_expr ***expr_array;\n-static int expr_size, expr_count;\n+static vec<gfc_expr **> expr_array;\n \n /* Pointer to the gfc_code we currently work on - to be able to insert\n    a block before the statement.  */\n@@ -81,8 +79,9 @@ static int iterator_level;\n \n /* Keep track of DO loop levels.  */\n \n-static gfc_code **doloop_list;\n-static int doloop_size, doloop_level;\n+static vec<gfc_code *> doloop_list;\n+\n+static int doloop_level;\n \n /* Vector of gfc_expr * to keep track of DO loops.  */\n \n@@ -101,23 +100,18 @@ gfc_run_passes (gfc_namespace *ns)\n   /* Warn about dubious DO loops where the index might\n      change.  */\n \n-  doloop_size = 20;\n   doloop_level = 0;\n-  doloop_list = XNEWVEC(gfc_code *, doloop_size);\n   doloop_warn (ns);\n-  XDELETEVEC (doloop_list);\n+  doloop_list.release ();\n \n   if (gfc_option.flag_frontend_optimize)\n     {\n-      expr_size = 20;\n-      expr_array = XNEWVEC(gfc_expr **, expr_size);\n-\n       optimize_namespace (ns);\n       optimize_reduction (ns);\n       if (gfc_option.dump_fortran_optimized)\n \tgfc_dump_parse_tree (ns, stdout);\n \n-      XDELETEVEC (expr_array);\n+      expr_array.release ();\n     }\n }\n \n@@ -420,13 +414,7 @@ cfe_register_funcs (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \treturn 0;\n     }\n \n-  if (expr_count >= expr_size)\n-    {\n-      expr_size += expr_size;\n-      expr_array = XRESIZEVEC(gfc_expr **, expr_array, expr_size);\n-    }\n-  expr_array[expr_count] = e;\n-  expr_count ++;\n+  expr_array.safe_push (e);\n   return 0;\n }\n \n@@ -599,6 +587,7 @@ cfe_expr_0 (gfc_expr **e, int *walk_subtrees,\n {\n   int i,j;\n   gfc_expr *newvar;\n+  gfc_expr **ei, **ej;\n \n   /* Don't do this optimization within OMP workshare. */\n \n@@ -608,36 +597,36 @@ cfe_expr_0 (gfc_expr **e, int *walk_subtrees,\n       return 0;\n     }\n \n-  expr_count = 0;\n+  expr_array.release ();\n \n   gfc_expr_walker (e, cfe_register_funcs, NULL);\n \n   /* Walk through all the functions.  */\n \n-  for (i=1; i<expr_count; i++)\n+  FOR_EACH_VEC_ELT_FROM (expr_array, i, ei, 1)\n     {\n       /* Skip if the function has been replaced by a variable already.  */\n-      if ((*(expr_array[i]))->expr_type == EXPR_VARIABLE)\n+      if ((*ei)->expr_type == EXPR_VARIABLE)\n \tcontinue;\n \n       newvar = NULL;\n       for (j=0; j<i; j++)\n \t{\n-\t  if (gfc_dep_compare_functions (*(expr_array[i]),\n-\t\t\t\t\t*(expr_array[j]), true)\t== 0)\n+\t  ej = expr_array[j];\n+\t  if (gfc_dep_compare_functions (*ei, *ej, true) == 0)\n \t    {\n \t      if (newvar == NULL)\n-\t\tnewvar = create_var (*(expr_array[i]));\n+\t\tnewvar = create_var (*ei);\n \n \t      if (gfc_option.warn_function_elimination)\n-\t\twarn_function_elimination (*(expr_array[j]));\n+\t\twarn_function_elimination (*ej);\n \n-\t      free (*(expr_array[j]));\n-\t      *(expr_array[j]) = gfc_copy_expr (newvar);\n+\t      free (*ej);\n+\t      *ej = gfc_copy_expr (newvar);\n \t    }\n \t}\n       if (newvar)\n-\t*(expr_array[i]) = newvar;\n+\t*ei = newvar;\n     }\n \n   /* We did all the necessary walking in this function.  */\n@@ -1671,25 +1660,23 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   int i;\n   gfc_formal_arglist *f;\n   gfc_actual_arglist *a;\n+  gfc_code *cl;\n \n   co = *c;\n \n+  /* If the doloop_list grew, we have to truncate it here.  */\n+\n+  if ((unsigned) doloop_level < doloop_list.length())\n+    doloop_list.truncate (doloop_level);\n+\n   switch (co->op)\n     {\n     case EXEC_DO:\n \n-      /* Grow the temporary storage if necessary.  */\n-      if (doloop_level >= doloop_size)\n-\t{\n-\t  doloop_size = 2 * doloop_size;\n-\t  doloop_list = XRESIZEVEC (gfc_code *, doloop_list, doloop_size);\n-\t}\n-\n-      /* Mark the DO loop variable if there is one.  */\n       if (co->ext.iterator && co->ext.iterator->var)\n-\tdoloop_list[doloop_level] = co;\n+\tdoloop_list.safe_push (co);\n       else\n-\tdoloop_list[doloop_level] = NULL;\n+\tdoloop_list.safe_push ((gfc_code *) NULL);\n       break;\n \n     case EXEC_CALL:\n@@ -1708,14 +1695,14 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n       while (a && f)\n \t{\n-\t  for (i=0; i<doloop_level; i++)\n+\t  FOR_EACH_VEC_ELT (doloop_list, i, cl)\n \t    {\n \t      gfc_symbol *do_sym;\n \t      \n-\t      if (doloop_list[i] == NULL)\n+\t      if (cl == NULL)\n \t\tbreak;\n \n-\t      do_sym = doloop_list[i]->ext.iterator->var->symtree->n.sym;\n+\t      do_sym = cl->ext.iterator->var->symtree->n.sym;\n \t      \n \t      if (a->expr && a->expr->symtree\n \t\t  && a->expr->symtree->n.sym == do_sym)\n@@ -1755,6 +1742,7 @@ do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n   gfc_formal_arglist *f;\n   gfc_actual_arglist *a;\n   gfc_expr *expr;\n+  gfc_code *dl;\n   int i;\n \n   expr = *e;\n@@ -1777,15 +1765,14 @@ do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n   while (a && f)\n     {\n-      for (i=0; i<doloop_level; i++)\n+      FOR_EACH_VEC_ELT (doloop_list, i, dl)\n \t{\n \t  gfc_symbol *do_sym;\n-\t \n-    \n-\t  if (doloop_list[i] == NULL)\n+\n+\t  if (dl == NULL)\n \t    break;\n \n-\t  do_sym = doloop_list[i]->ext.iterator->var->symtree->n.sym;\n+\t  do_sym = dl->ext.iterator->var->symtree->n.sym;\n \t  \n \t  if (a->expr && a->expr->symtree\n \t      && a->expr->symtree->n.sym == do_sym)"}]}