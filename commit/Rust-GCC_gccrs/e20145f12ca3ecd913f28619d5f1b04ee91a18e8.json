{"sha": "e20145f12ca3ecd913f28619d5f1b04ee91a18e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIwMTQ1ZjEyY2EzZWNkOTEzZjI4NjE5ZDVmMWIwNGVlOTFhMThlOA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-11-26T17:27:34Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-11-26T17:27:34Z"}, "message": "libphobos: Fix backtraces in Fibers on AArch64.\n\nWhen throwing an Exception in the Fiber the backtrace generation\ncrashes.  This happens because backtrace does not func the stack bottom.\nUsing '.cfi_undefined x30' tells the debug info that the value in the lr\nis unknown, which seems to be the nicest way to stop the unwinder.\nSetting x30 to 0 is another option, however it still creates one invalid\nframe in gdb, so the .cfi variant is used here instead.\n\nBackport from upstream druntime 2.083.\n\nReviewed-on: https://github.com/dlang/druntime/pull/2308\n\nFrom-SVN: r266470", "tree": {"sha": "04572dc92a8c39a8c2aa204bc4e855af4590b308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04572dc92a8c39a8c2aa204bc4e855af4590b308"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e20145f12ca3ecd913f28619d5f1b04ee91a18e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e20145f12ca3ecd913f28619d5f1b04ee91a18e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e20145f12ca3ecd913f28619d5f1b04ee91a18e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e20145f12ca3ecd913f28619d5f1b04ee91a18e8/comments", "author": null, "committer": null, "parents": [{"sha": "ef6e6914c8245ca24dae952bc054ae2328e751ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6e6914c8245ca24dae952bc054ae2328e751ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6e6914c8245ca24dae952bc054ae2328e751ab"}], "stats": {"total": 62, "additions": 61, "deletions": 1}, "files": [{"sha": "ff15d066a4968c4c8624eb60612b7b36dd30dfc3", "filename": "libphobos/libdruntime/core/thread.d", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e20145f12ca3ecd913f28619d5f1b04ee91a18e8/libphobos%2Flibdruntime%2Fcore%2Fthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e20145f12ca3ecd913f28619d5f1b04ee91a18e8/libphobos%2Flibdruntime%2Fcore%2Fthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread.d?ref=e20145f12ca3ecd913f28619d5f1b04ee91a18e8", "patch": "@@ -3582,6 +3582,15 @@ private\n             version = AsmExternal;\n         }\n     }\n+    else version (AArch64)\n+    {\n+        version (Posix)\n+        {\n+            version = AsmAArch64_Posix;\n+            version = AsmExternal;\n+            version = AlignFiberStackTo16Byte;\n+        }\n+    }\n     else version (ARM)\n     {\n         version (Posix)\n@@ -3673,7 +3682,11 @@ private\n \n   // Look above the definition of 'class Fiber' for some information about the implementation of this routine\n   version (AsmExternal)\n-    extern (C) void fiber_switchContext( void** oldp, void* newp ) nothrow @nogc;\n+  {\n+      extern (C) void fiber_switchContext( void** oldp, void* newp ) nothrow @nogc;\n+      version (AArch64)\n+          extern (C) void fiber_trampoline() nothrow;\n+  }\n   else\n     extern (C) void fiber_switchContext( void** oldp, void* newp ) nothrow @nogc\n     {\n@@ -4909,6 +4922,29 @@ private:\n             pstack -= ABOVE;\n             *cast(size_t*)(pstack - SZ_RA) = cast(size_t)&fiber_entryPoint;\n         }\n+        else version (AsmAArch64_Posix)\n+        {\n+            // Like others, FP registers and return address (lr) are kept\n+            // below the saved stack top (tstack) to hide from GC scanning.\n+            // fiber_switchContext expects newp sp to look like this:\n+            //   19: x19\n+            //   ...\n+            //    9: x29 (fp)  <-- newp tstack\n+            //    8: x30 (lr)  [&fiber_entryPoint]\n+            //    7: d8\n+            //   ...\n+            //    0: d15\n+\n+            version (StackGrowsDown) {}\n+            else\n+                static assert(false, \"Only full descending stacks supported on AArch64\");\n+\n+            // Only need to set return address (lr).  Everything else is fine\n+            // zero initialized.\n+            pstack -= size_t.sizeof * 11;    // skip past x19-x29\n+            push(cast(size_t) &fiber_trampoline); // see threadasm.S for docs\n+            pstack += size_t.sizeof;         // adjust sp (newp) above lr\n+        }\n         else version (AsmARM_Posix)\n         {\n             /* We keep the FP registers and the return address below"}, {"sha": "140e5f9a9e4f30a089a01c3169d9766c34d05714", "filename": "libphobos/libdruntime/core/threadasm.S", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e20145f12ca3ecd913f28619d5f1b04ee91a18e8/libphobos%2Flibdruntime%2Fcore%2Fthreadasm.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e20145f12ca3ecd913f28619d5f1b04ee91a18e8/libphobos%2Flibdruntime%2Fcore%2Fthreadasm.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthreadasm.S?ref=e20145f12ca3ecd913f28619d5f1b04ee91a18e8", "patch": "@@ -487,6 +487,7 @@ fiber_switchContext:\n  */\n         .text\n         .global CSYM(fiber_switchContext)\n+        .type   fiber_switchContext, %function\n         .p2align  2\n CSYM(fiber_switchContext):\n         stp     d15, d14, [sp, #-20*8]!\n@@ -518,6 +519,29 @@ CSYM(fiber_switchContext):\n         ldp     d15, d14, [sp], #20*8\n         ret\n \n+\n+/**\n+ * When generating any kind of backtrace (gdb, exception handling) for\n+ * a function called in a Fiber, we need to tell the unwinder to stop\n+ * at our Fiber main entry point, i.e. we need to mark the bottom of\n+ * the call stack. This can be done by clearing the link register lr\n+ * prior to calling fiber_entryPoint (i.e. in fiber_switchContext) or\n+ * using a .cfi_undefined directive for the link register in the\n+ * Fiber entry point. cfi_undefined seems to yield better results in gdb.\n+ * Unfortunately we can't place it into fiber_entryPoint using inline\n+ * asm, so we use this trampoline instead.\n+ */\n+        .text\n+        .global CSYM(fiber_trampoline)\n+        .p2align  2\n+        .type   fiber_trampoline, %function\n+CSYM(fiber_trampoline):\n+        .cfi_startproc\n+        .cfi_undefined x30\n+        // fiber_entryPoint never returns\n+        bl fiber_entryPoint\n+        .cfi_endproc\n+\n #elif defined(__MINGW32__)\n /************************************************************************************\n  * GDC MinGW ASM BITS"}]}