{"sha": "62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI1MTFmYjFlYTJmZGY2NjU2ZGFjMTUwY2NiOWRjMzg1OWRhZDliMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-08T17:56:37Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-08T17:56:37Z"}, "message": "trans-array.c (constant_array_constructor_p): New function to determine whether an array constructor consists only of...\n\n\n\t* trans-array.c (constant_array_constructor_p): New function to\n\tdetermine whether an array constructor consists only of constant\n\telements, and if so return it's size.\n\t(gfc_build_constant_array_constructor): Construct a statically\n\tinitialized gfortran array for a given EXPR_ARRAY.\n\t(gfc_trans_constant_array_constructor): Efficiently scalarize\n\ta constant array constructor.\n\t(gfc_trans_array_constructor):  Tidy up use of CONST_STRING.\n\tSpecial case scalarization of constant array constructors, all of\n\twhose elements are specified, using constant_array_constructor_p \n\tand gfc_trans_constant_array_constructor.\n\t(gfc_conv_scalarized_array_ref): Check whetger info->offset is zero\n\tbefore adding it to index, to avoid creating a NON_LVALUE_EXPR.\n\n\t* gfortran.dg/array_constructor_14.f90: New test case.\n\t* gfortran.dg/vect/vect-5.f90: Update test for improved alignment.\n\nFrom-SVN: r120584", "tree": {"sha": "c9b5bb0f48cbe819949ec64d4b6789655ee9d72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9b5bb0f48cbe819949ec64d4b6789655ee9d72f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/comments", "author": null, "committer": null, "parents": [{"sha": "f255541fb7bdd1b1da1a8c661967021164fa515b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f255541fb7bdd1b1da1a8c661967021164fa515b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f255541fb7bdd1b1da1a8c661967021164fa515b"}], "stats": {"total": 181, "additions": 173, "deletions": 8}, "files": [{"sha": "5ec612c06ab33adbd9320f3680f50bfd0226f4bf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "patch": "@@ -1,3 +1,19 @@\n+2007-01-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-array.c (constant_array_constructor_p): New function to\n+\tdetermine whether an array constructor consists only of constant\n+\telements, and if so return it's size.\n+\t(gfc_build_constant_array_constructor): Construct a statically\n+\tinitialized gfortran array for a given EXPR_ARRAY.\n+\t(gfc_trans_constant_array_constructor): Efficiently scalarize\n+\ta constant array constructor.\n+\t(gfc_trans_array_constructor):  Tidy up use of CONST_STRING.\n+\tSpecial case scalarization of constant array constructors, all of\n+\twhose elements are specified, using constant_array_constructor_p \n+\tand gfc_trans_constant_array_constructor.\n+\t(gfc_conv_scalarized_array_ref): Check whetger info->offset is zero\n+\tbefore adding it to index, to avoid creating a NON_LVALUE_EXPR.\n+\n 2007-01-08  Kazu Hirata  <kazu@codesourcery.com>\n \n \tgfortran.texi: Fix typos."}, {"sha": "7eb56afa7ea8aadc30c47f9b0d51571ca37f19cf", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 136, "deletions": 7, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "patch": "@@ -1463,6 +1463,119 @@ get_array_ctor_strlen (gfc_constructor * c, tree * len)\n   return is_const;\n }\n \n+/* Check whether the array constructor C consists entirely of constant\n+   elements, and if so returns the number of those elements, otherwise\n+   return zero.  Note, an empty or NULL array constructor returns zero.  */\n+\n+static unsigned HOST_WIDE_INT\n+constant_array_constructor_p (gfc_constructor * c)\n+{\n+  unsigned HOST_WIDE_INT nelem = 0;\n+\n+  while (c)\n+    {\n+      if (c->iterator\n+\t  || c->expr->rank > 0\n+\t  || c->expr->expr_type != EXPR_CONSTANT)\n+\treturn 0;\n+      c = c->next;\n+      nelem++;\n+    }\n+  return nelem;\n+}\n+\n+\n+/* Given EXPR, the constant array constructor specified by an EXPR_ARRAY,\n+   and the tree type of it's elements, TYPE, return a static constant\n+   variable that is compile-time initialized.  */\n+\n+static tree\n+gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n+{\n+  tree tmptype, list, init, tmp;\n+  HOST_WIDE_INT nelem;\n+  gfc_constructor *c;\n+  gfc_array_spec as;\n+  gfc_se se;\n+\n+\n+  /* First traverse the constructor list, converting the constants\n+     to tree to build an initializer.  */\n+  nelem = 0;\n+  list = NULL_TREE;\n+  c = expr->value.constructor;\n+  while (c)\n+    {\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_constant (&se, c->expr);\n+      if (c->expr->ts.type == BT_CHARACTER\n+\t  && POINTER_TYPE_P (type))\n+\tse.expr = gfc_build_addr_expr (pchar_type_node, se.expr);\n+      list = tree_cons (NULL_TREE, se.expr, list);\n+      c = c->next;\n+      nelem++;\n+    }\n+\n+  /* Next detemine the tree type for the array.  We use the gfortran\n+     front-end's gfc_get_nodesc_array_type in order to create a suitable\n+     GFC_ARRAY_TYPE_P that may be used by the scalarizer.  */\n+\n+  memset (&as, 0, sizeof (gfc_array_spec));\n+\n+  as.rank = 1;\n+  as.type = AS_EXPLICIT;\n+  as.lower[0] = gfc_int_expr (0);\n+  as.upper[0] = gfc_int_expr (nelem - 1);\n+  tmptype = gfc_get_nodesc_array_type (type, &as, 3);\n+\n+  init = build_constructor_from_list (tmptype, nreverse (list));\n+\n+  TREE_CONSTANT (init) = 1;\n+  TREE_INVARIANT (init) = 1;\n+  TREE_STATIC (init) = 1;\n+\n+  tmp = gfc_create_var (tmptype, \"A\");\n+  TREE_STATIC (tmp) = 1;\n+  TREE_CONSTANT (tmp) = 1;\n+  TREE_INVARIANT (tmp) = 1;\n+  TREE_READONLY (tmp) = 1;\n+  DECL_INITIAL (tmp) = init;\n+\n+  return tmp;\n+}\n+\n+\n+/* Translate a constant EXPR_ARRAY array constructor for the scalarizer.\n+   This mostly initializes the scalarizer state info structure with the\n+   appropriate values to directly use the array created by the function\n+   gfc_build_constant_array_constructor.  */\n+\n+static void\n+gfc_trans_constant_array_constructor (gfc_loopinfo * loop,\n+\t\t\t\t      gfc_ss * ss, tree type)\n+{\n+  gfc_ss_info *info;\n+  tree tmp;\n+\n+  tmp = gfc_build_constant_array_constructor (ss->expr, type);\n+\n+  info = &ss->data.info;\n+\n+  info->descriptor = tmp;\n+  info->data = build_fold_addr_expr (tmp);\n+  info->offset = fold_build1 (NEGATE_EXPR, gfc_array_index_type,\n+\t\t\t      loop->from[0]);\n+\n+  info->delta[0] = gfc_index_zero_node;\n+  info->start[0] = gfc_index_zero_node;\n+  info->end[0] = gfc_index_zero_node;\n+  info->stride[0] = gfc_index_one_node;\n+  info->dim[0] = 0;\n+\n+  if (info->dimen > loop->temp_dim)\n+    loop->temp_dim = info->dimen;\n+}\n+\n \n /* Array constructors are handled by constructing a temporary, then using that\n    within the scalarization loop.  This is not optimal, but seems by far the\n@@ -1476,15 +1589,14 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n   tree offsetvar;\n   tree desc;\n   tree type;\n-  bool const_string;\n   bool dynamic;\n \n   ss->data.info.dimen = loop->dimen;\n \n   c = ss->expr->value.constructor;\n   if (ss->expr->ts.type == BT_CHARACTER)\n     {\n-      const_string = get_array_ctor_strlen (c, &ss->string_length);\n+      bool const_string = get_array_ctor_strlen (c, &ss->string_length);\n       if (!ss->string_length)\n \tgfc_todo_error (\"complex character array constructors\");\n \n@@ -1493,10 +1605,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n \ttype = build_pointer_type (type);\n     }\n   else\n-    {\n-      const_string = TRUE;\n-      type = gfc_typenode_for_spec (&ss->expr->ts);\n-    }\n+    type = gfc_typenode_for_spec (&ss->expr->ts);\n \n   /* See if the constructor determines the loop bounds.  */\n   dynamic = false;\n@@ -1518,6 +1627,25 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n       mpz_clear (size);\n     }\n \n+  /* Special case constant array constructors.  */\n+  if (!dynamic\n+      && loop->dimen == 1\n+      && INTEGER_CST_P (loop->from[0])\n+      && INTEGER_CST_P (loop->to[0]))\n+    {\n+      unsigned HOST_WIDE_INT nelem = constant_array_constructor_p (c);\n+      if (nelem > 0)\n+\t{\n+\t  tree diff = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t   loop->to[0], loop->from[0]);\n+\t  if (compare_tree_int (diff, nelem - 1) == 0)\n+\t    {\n+\t      gfc_trans_constant_array_constructor (loop, ss, type);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n   gfc_trans_create_temp_array (&loop->pre, &loop->post, loop, &ss->data.info,\n \t\t\t       type, dynamic, true, false, false);\n \n@@ -2045,7 +2173,8 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \t\t\t\t       info->stride0);\n   /* Add the offset for this dimension to the stored offset for all other\n      dimensions.  */\n-  index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, info->offset);\n+  if (!integer_zerop (info->offset))\n+    index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, info->offset);\n \n   tmp = build_fold_indirect_ref (info->data);\n   se->expr = gfc_build_array_ref (tmp, index);"}, {"sha": "8da20bc382a0ab5bf2a355f1cf22136efb4ed469", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "patch": "@@ -1,3 +1,8 @@\n+2007-01-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.dg/array_constructor_14.f90: New test case.\n+\t* gfortran.dg/vect/vect-5.f90: Update test for improved alignment.\n+\n 2007-01-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/23603"}, {"sha": "f2f89cd04307c8416bff665ad92a5188c2264230", "filename": "gcc/testsuite/gfortran.dg/array_constructor_14.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_14.f90?ref=62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+\n+subroutine foo(x)\n+  integer :: x(4)\n+  x(:) = (/ 3, 1, 4, 1 /)\n+end subroutine\n+\n+subroutine bar(x)\n+  integer :: x(4)\n+  x = (/ 3, 1, 4, 1 /)\n+end subroutine\n+\n+! { dg-final { scan-tree-dump-times \"data\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "90b0f3257750bce4a895989cbae8deac3ecec1eb", "filename": "gcc/testsuite/gfortran.dg/vect/vect-5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62511fb1ea2fdf6656dac150ccb9dc3859dad9b3/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90?ref=62511fb1ea2fdf6656dac150ccb9dc3859dad9b3", "patch": "@@ -37,7 +37,7 @@ program main\n \n ! { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  } }\n ! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align } } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align } } } }\n ! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target { ilp32 && vect_no_align } } } }\n \n ! We also expect to vectorize one loop for lp64 targets that support "}]}