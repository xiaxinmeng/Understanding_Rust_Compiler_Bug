{"sha": "34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRmYTc2OTBhYzY2YzZkM2M1ZGRiMWQzNWQyNjc4MzZlM2MyM2YzZA==", "commit": {"author": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2012-03-04T21:11:09Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2012-03-04T21:11:09Z"}, "message": "Merge upstream libffi\n\nFrom-SVN: r184897", "tree": {"sha": "3289bacfc83a97eaf50f42a61d0b9a06f4c76e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3289bacfc83a97eaf50f42a61d0b9a06f4c76e9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/comments", "author": null, "committer": null, "parents": [{"sha": "8b59af5c6af6e67e151b72e48074f58b677b2e42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b59af5c6af6e67e151b72e48074f58b677b2e42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b59af5c6af6e67e151b72e48074f58b677b2e42"}], "stats": {"total": 6955, "additions": 6319, "deletions": 636}, "files": [{"sha": "bb5bc1625ce9f8dd6631cfbf6175827d8b1e977d", "filename": "libffi/ChangeLog", "status": "modified", "additions": 267, "deletions": 21, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,37 +1,36 @@\n-2012-02-27  Mikael Pettersson  <mikpe@it.uu.se>\n+2012-03-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n-\tPR libffi/52223\n-\t* Makefile.am (FLAGS_TO_PASS): Define.\n-\t* Makefile.in: Regenerate.\n+\t* src/x86/ffi64.c (ffi_call): Cast the return value to unsigned\n+\tlong.\n+\t(ffi_prep_closure_loc): Cast to 64bit address in trampoline.\n+\t(ffi_closure_unix64_inner): Cast return pointer to unsigned long\n+\tfirst.\n+\n+\t* src/x86/ffitarget.h (FFI_SIZEOF_ARG): Defined to 8 for x32.\n+\t(ffi_arg): Set to unsigned long long for x32.\n+\t(ffi_sarg): Set to long long for x32.\n \n-2012-02-23  Kai Tietz  <ktietz@redhat.com>\n+2012-03-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n-\tPR libffi/52221\n-\t* src/x86/ffi.c (ffi_closure_raw_THISCALL): New\n-\tprototype.\n-\t(ffi_prep_raw_closure_loc): Use ffi_closure_raw_THISCALL for\n-\tthiscall-convention.\n-\t(ffi_raw_call): Use ffi_prep_args_raw.\n-\t* src/x86/win32.S (ffi_closure_raw_THISCALL): Add\n-\timplementation for stub.\n+\t* src/prep_cif.c (ffi_prep_cif_core): Properly check bad ABI.\n \n-2012-02-13  Kai Tietz  <ktietz@redhat.com>\n+2012-03-03  Andoni Morales Alastruey  <ylatuya@gmail.com>\n \n-\tPR libffi/52221\n-\t* src/x86/ffi.c (ffi_prep_raw_closure_loc): Add thiscall\n-\tsupport for X86_WIN32.\n-\t(FFI_INIT_TRAMPOLINE_THISCALL): Fix displacement.\n+\t* configure.ac: Add -no-undefined for both 32- and 64-bit x86\n+\twindows-like hosts.\n+\t* configure: Rebuilt.\n \n-2012-02-11  Eric Botcazou  <ebotcazou@adacore.com>\n+2012-02-23  Anthony Green  <green@moxielogic.com>\n \n-\t* src/sparc/v9.S (STACKFRAME): Bump to 176.\n+\t* src/*/ffitarget.h: Ensure that users never include ffitarget.h\n+\tdirectly.\n \n 2012-02-10  Kai Tietz  <ktietz@redhat.com>\n \n \t* configure.ac (AM_LTLDFLAGS): Add -no-undefine for x64\n \twindows target.\n \t* configure: Regenerated.\n-\t\n+\n 2012-02-08  Kai Tietz  <ktietz@redhat.com>\n \n \t* src/prep_cif.c (ffi_prep_cif): Allow for X86_WIN32\n@@ -63,6 +62,20 @@\n \t* testsuite/libffi.call/struct1_win32.c: New test.\n \t* testsuite/libffi.call/struct2_win32.c: New test.\n \n+2012-01-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* src/alpha/ffi.c (ffi_prep_closure_loc): Check for bad ABI.\n+\n+2012-01-23  Anthony Green  <green@moxielogic.com>\n+\t    Chris Young  <cdyoung@ntlworld.com>\n+\n+\t* configure.ac: Add Amiga support.\n+\t* configure: Rebuilt.\n+\n+2012-01-23  Dmitry Nadezhin  <dmitry.nadezhin@gmail.com>\n+\n+\t* include/ffi_common.h (LIKELY, UNLIKELY): Fix definitions.\n+\n 2012-01-23  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* src/m68k/sysv.S (ffi_call_SYSV): Properly test for plain\n@@ -87,6 +100,67 @@\n \n \t* configure: Regenerate.\n \n+2011-11-12  David Gilbert <david.gilbert@linaro.org>\n+\n+\t* doc/libffi.texi, include/ffi.h.in, include/ffi_common.h,\n+\tman/Makefile.am, man/ffi.3, man/ffi_prep_cif.3,\n+\tman/ffi_prep_cif_var.3, src/arm/ffi.c, src/arm/ffitarget.h,\n+\tsrc/cris/ffi.c, src/prep_cif.c,\n+\ttestsuite/libffi.call/cls_double_va.c,\n+\ttestsuite/libffi.call/cls_longdouble_va.c,\n+\ttestsuite/libffi.call/float_va.c: Many changes to support variadic\n+\tfunction calls.\n+\n+2011-11-12  Kyle Moffett <Kyle.D.Moffett@boeing.com>\n+\n+\t* src/powerpc/ffi.c, src/powerpc/ffitarget.h,\n+\tsrc/powerpc/ppc_closure.S, src/powerpc/sysv.S: Many changes for\n+\tsoftfloat powerpc variants.\n+\n+2011-11-12  Petr Salinger <Petr.Salinger@seznam.cz>\n+\n+\t* configure.ac (FFI_EXEC_TRAMPOLINE_TABLE): Fix kfreebsd support.\n+\t* configure: Rebuilt.\n+\n+2011-11-12  Timothy Wall  <twall@users.sf.net>\n+\n+\t* src/arm/ffi.c (ffi_prep_args, ffi_prep_incoming_args_SYSV): Max\n+\talignment of 4 for wince on ARM.\n+\n+2011-11-12  Kyle Moffett <Kyle.D.Moffett@boeing.com>\n+\t    Anthony Green <green@moxielogic.com>\n+\n+\t* src/ppc/sysv.S, src/ppc/ffi.c: Remove use of ppc string\n+\tinstructions (not available on some cores, like the PPC440).\n+\n+2011-11-12  Kimura Wataru  <kimuraw@i.nifty.jp>\n+\n+\t* m4/ax_enable_builddir: Change from string comparison to numeric\n+\tcomparison for wc output.\n+\t* configure.ac: Enable FFI_MMAP_EXEC_WRIT for darwin11 aka Mac OS\n+\tX 10.7.\n+\t* configure: Rebuilt.\n+\n+2011-11-12  Anthony Green  <green@moxielogic.com>\n+\n+\t* Makefile.am (AM_CCASFLAGS): Add -g option to build assembly\n+\tfiles with debug info.\n+\t* Makefile.in: Rebuilt.\n+\n+2011-11-12  Jasper Lievisse Adriaanse <jasper@openbsd.org>\n+\n+\t* README: Update list of supported OpenBSD systems.\n+\n+2011-11-12  Anthony Green  <green@moxielogic.com>\n+\n+\t* libtool-version: Update.\n+\t* Makefile.am (nodist_libffi_la_SOURCES): Add src/debug.c if\n+\tFFI_DEBUG.\n+\t(libffi_la_SOURCES): Remove src/debug.c\n+\t(EXTRA_DIST): Add src/debug.c\n+\t* Makefile.in: Rebuilt.\n+\t* README: Update for 3.0.11.\n+\n 2011-11-10  Richard Henderson  <rth@redhat.com>\n \n \t* configure.ac (GCC_AS_CFI_PSEUDO_OP): Use it instead of inline check.\n@@ -135,17 +209,139 @@\n \tUse them to handle ELF vs. ECOFF differences.\n \t[__osf__] (_GLOBAL__F_ffi_call_osf): Define.\n \n+2011-03-30  Timothy Wall  <twall@users.sf.net>\n+\n+\t* src/powerpc/darwin.S: Fix unknown FDE encoding.\n+\t* src/powerpc/darwin_closure.S: ditto.\n+\n+2011-02-25  Anthony Green  <green@moxielogic.com>\n+\n+\t* src/powerpc/ffi.c (ffi_prep_closure_loc): Allow for more\n+\t32-bit ABIs.\n+\n+2011-02-15  Anthony Green  <green@moxielogic.com>\n+\n+\t* m4/ax_cc_maxopt.m4: Don't -malign-double or use -ffast-math.\n+\t* configure: Rebuilt.\n+\n 2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* configure: Regenerate.\n \n+2011-02-13  Anthony Green  <green@moxielogic.com>\n+\n+\t* include/ffi_common.h (UNLIKELY, LIKELY): Define.\n+\t* src/x86/ffi64.c (UNLIKELY, LIKELY): Remove definition.\n+\t* src/prep_cif.c (UNLIKELY, LIKELY): Remove definition.\n+\n+\t* src/prep_cif.c (initialize_aggregate): Convert assertion into\n+\tFFI_BAD_TYPEDEF return.  Initialize arg size and alignment to 0.\n+\n+\t* src/pa/ffi.c (ffi_prep_closure_loc): Don't ASSERT ABI test,\n+\tjust return FFI_BAD_ABI when things are wrong.\n+\t* src/arm/ffi.c (ffi_prep_closure_loc): Ditto.\n+\t* src/powerpc/ffi.c (ffi_prep_closure_loc): Ditto.\n+\t* src/mips/ffi.c (ffi_prep_closure_loc): Ditto.\n+\t* src/ia64/ffi.c (ffi_prep_closure_loc): Ditto.\n+\t* src/avr32/ffi.c (ffi_prep_closure_loc): Ditto.\n+\n+2011-02-11  Anthony Green  <green@moxielogic.com>\n+\n+\t* src/sparc/ffi.c (ffi_prep_closure_loc): Don't ASSERT ABI test,\n+\tjust return FFI_BAD_ABI when things are wrong.\n+\n+2011-02-09  Stuart Shelton  <srcshelton@gmail.com>\n+\n+\thttp://bugs.gentoo.org/show_bug.cgi?id=286911\n+\t* src/mips/ffitarget.h: Clean up error messages.\n+\t* src/java_raw_api.c (ffi_java_translate_args): Cast raw arg to\n+\tffi_raw*.\n+\t* include/ffi.h.in: Add pragma for SGI compiler.\n+\n+2011-02-09  Anthony Green  <green@moxielogic.com>\n+\n+\t* configure.ac: Add powerpc64-*-darwin* support.\n+\n+2011-02-09  Anthony Green <green@moxielogic.com>\n+\n+\t* README: Mention Interix.\n+\n+2011-02-09  Jonathan Callen  <abcd@gentoo.org>\n+\n+\t* configure.ac: Add Interix to win32/cygwin/mingw case.\n+\t* configure: Ditto.\n+\t* src/closures.c: Treat Interix like Cygwin, instead of as a\n+\tgeneric win32.\n+\n+2011-02-09  Anthony Green <green@moxielogic.com>\n+\n+\t* testsuite/libffi.call/err_bad_typedef.c: Remove xfail.\n+\t* testsuite/libffi.call/err_bad_abi.c: Remove xfail.\n+\t* src/x86/ffi64.c (UNLIKELY, LIKELY): Define.\n+\t(ffi_prep_closure_loc): Check for bad ABI.\n+\t* src/prep_cif.c (UNLIKELY, LIKELY): Define.\n+\t(initialize_aggregate): Check for bad types.\n+\n+2011-02-09  Landon Fuller <landonf@plausible.coop>\n+\n+\t* Makefile.am (EXTRA_DIST): Add build-ios.sh, src/arm/gentramp.sh,\n+\tsrc/arm/trampoline.S.\n+\t(nodist_libffi_la_SOURCES): Add src/arc/trampoline.S.\n+\t* configure.ac (FFI_EXEC_TRAMPOLINE_TABLE): Define.\n+\t* src/arm/ffi.c (ffi_trampoline_table)\n+\t(ffi_closure_trampoline_table_page, ffi_trampoline_table_entry)\n+\t(FFI_TRAMPOLINE_CODELOC_CONFIG, FFI_TRAMPOLINE_CONFIG_PAGE_OFFSET)\n+\t(FFI_TRAMPOLINE_COUNT, ffi_trampoline_lock, ffi_trampoline_tables)\n+\t(ffi_trampoline_table_alloc, ffi_closure_alloc, ffi_closure_free):\n+\tDefine for FFI_EXEC_TRAMPOLINE_TABLE case (iOS).\n+\t(ffi_prep_closure_loc): Handl FFI_EXEC_TRAMPOLINE_TABLE case\n+\tseparately.\n+\t* src/arm/sysv.S: Handle Apple iOS host.\n+\t* src/closures.c: Handle FFI_EXEC_TRAMPOLINE_TABLE case.\n+\t* build-ios.sh: New file.\n+\t* fficonfig.h.in, configure, Makefile.in: Rebuilt.\n+\t* README: Mention ARM iOS.\n+\n+2011-02-08  Oren Held  <orenhe@il.ibm.com>\n+\n+\t* src/dlmalloc.c (_STRUCT_MALLINFO): Define in order to avoid\n+\tredefinition of mallinfo on HP-UX.\n+\n+2011-02-08  Ginn Chen  <ginn.chen@oracle.com>\n+\n+\t* src/sparc/ffi.c (ffi_call): Make compatible with Solaris Studio\n+\taggregate return ABI.  Flush cache.\n+\t(ffi_prep_closure_loc): Flush cache.\n+\n+2011-02-11  Anthony Green  <green@moxielogic.com>\n+\n+\tFrom Tom Honermann <tom.honermann@oracle.com>:\n+\t* src/powerpc/aix.S (ffi_call_AIX): Support for xlc toolchain on\n+\tAIX.  Declare .ffi_prep_args.  Insert nops after branch\n+\tinstructions so that the AIX linker can insert TOC reload\n+\tinstructions.\n+\t* src/powerpc/aix_closure.S: Declare .ffi_closure_helper_DARWIN.\n+\n+2011-02-08  Ed  <ed@kdtc.net>\n+\n+\t* src/powerpc/asm.h: Fix grammar nit in comment.\n+\n+2011-02-08  Uli Link  <ul.mcamafia@linkitup.de>\n+\n+\t* include/ffi.h.in (FFI_64_BIT_MAX): Define and use.\n+\n 2011-02-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR libffi/46661\n \t* testsuite/libffi.call/cls_pointer.c (main): Cast void * to\n \tuintptr_t first.\n \t* testsuite/libffi.call/cls_pointer_stack.c (main): Likewise.\n \n+2011-02-08  Rafael Avila de Espindola  <respindola@mozilla.com>\n+\n+\t* configure.ac: Fix x86 test for pc related relocs.\n+\t* configure: Rebuilt.\n+\n 2011-02-07  Joel Sherrill <joel.sherrill@oarcorp.com>\n \n \t* libffi/src/m68k/ffi.c: Add RTEMS support for cache flushing.\n@@ -204,6 +400,13 @@\n \t(.eh_frame): Use FDE_ENCODING.\n \t(.LASFDE1, .LASFDE2, LASFDE3): Simplify with FDE_ENCODE.\n \n+2010-11-22  Jacek Caban <jacek@codeweavers.com>\n+\n+\t* configure.ac: Check for symbol underscores on mingw-w64.\n+\t* configure: Rebuilt.\n+\t* src/x86/win64.S: Correctly access extern symbols in respect to\n+\tunderscores.\n+\n 2010-11-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* testsuite/lib/libffi-dg.exp: Rename ...\n@@ -271,6 +474,31 @@\n \t* testsuite/libffi.call/cls_longdouble.c: Likewise.\n \t* testsuite/libffi.call/huge_struct.c: Likewise.\n \n+2010-08-05  Dan Witte  <dwitte@mozilla.com>\n+\n+        * Makefile.am: Pass FFI_DEBUG define to msvcc.sh for linking to the\n+        debug CRT when --enable-debug is given.\n+        * configure.ac: Define it.\n+        * msvcc.sh: Translate -g and -DFFI_DEBUG appropriately.\n+\n+2010-08-04  Dan Witte  <dwitte@mozilla.com>\n+\n+\t* src/x86/ffitarget.h: Add X86_ANY define for all x86/x86_64\n+\tplatforms.\n+\t* src/x86/ffi.c: Remove redundant ifdef checks.\n+\t* src/prep_cif.c: Push stack space computation into src/x86/ffi.c\n+\tfor X86_ANY so return value space doesn't get added twice.\n+\n+2010-08-03  Neil Rashbrooke <neil@parkwaycc.co.uk>\n+\n+\t* msvcc.sh: Don't pass -safeseh to ml64 because behavior is buggy.\n+\n+2010-07-22  Dan Witte  <dwitte@mozilla.com>\n+\n+\t* src/*/ffitarget.h: Make FFI_LAST_ABI one past the last valid ABI.\n+\t* src/prep_cif.c: Fix ABI assertion.\n+        * src/cris/ffi.c: Ditto.\n+\n 2010-07-10  Evan Phoenix  <evan@fallingsnow.net>\n \n \t* src/closures.c (selinux_enabled_check): Fix strncmp usage bug.\n@@ -302,6 +530,14 @@\n \t* fficonfig.h.in: Regenerate.\n \t* src/x86/sysv.S (.eh_frame): Use .ascii, .string or error.\n \n+2010-05-11  Dan Witte  <dwitte@mozilla.com>\n+\n+\t* doc/libffi.tex: Document previous change.\n+\n+2010-05-11  Makoto Kato <m_kato@ga2.so-net.ne.jp>\n+\n+\t* src/x86/ffi.c (ffi_call): Don't copy structs passed by value.\n+\n 2010-05-05  Michael Kohler <michaelkohler@live.com>\n \n \t* src/dlmalloc.c (dlfree): Fix spelling.\n@@ -337,6 +573,11 @@\n \t* man/Makefile.in: Regenerate.\n \t* testsuite/Makefile.in: Regenerate.\n \n+2010-03-30  Dan Witte  <dwitte@mozilla.com>\n+\n+\t* msvcc.sh: Disable build warnings.\n+\t* README (tested): Clarify windows build procedure.\n+\n 2010-03-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (libffi_cv_as_x86_64_unwind_section_type): New test.\n@@ -711,6 +952,11 @@\n \t* man/Makefile.in: Regenerate.\n \t* testsuite/Makefile.in: Regenerate.\n \n+2011-08-22  Jasper Lievisse Adriaanse <jasper@openbsd.org>\n+\n+\t* configure.ac: Add OpenBSD/hppa and OpenBSD/powerpc support.\n+\t* configure: Rebuilt.\n+\n 2009-07-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* configure.ac (_AC_ARG_VAR_PRECIOUS): Use m4_rename_force."}, {"sha": "aa60342dfcc1892776f1ae29615955d6908d178b", "filename": "libffi/LICENSE", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2FLICENSE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2FLICENSE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FLICENSE?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,4 +1,5 @@\n-libffi - Copyright (c) 1996-2003  Red Hat, Inc.\n+libffi - Copyright (c) 1996-2012  Anthony Green, Red Hat, Inc and others.\n+See source files for details.\n \n Permission is hereby granted, free of charge, to any person obtaining\n a copy of this software and associated documentation files (the\n@@ -8,13 +9,13 @@ distribute, sublicense, and/or sell copies of the Software, and to\n permit persons to whom the Software is furnished to do so, subject to\n the following conditions:\n \n-The above copyright notice and this permission notice shall be included\n-in all copies or substantial portions of the Software.\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n \n-THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n-OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."}, {"sha": "1da4e89c73675407f65d38bf37f76fd9c6d2cc8d", "filename": "libffi/README", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,10 +1,7 @@\n-This directory contains the libffi package, which is not part of GCC but\n-shipped with GCC as convenience.\n-\n Status\n ======\n \n-libffi-3.0.9 was released on December 31, 2009. Check the libffi web\n+libffi-3.0.11 was released on *****************. Check the libffi web\n page for updates: <URL:http://sourceware.org/libffi/>.\n \n \n@@ -46,7 +43,7 @@ Libffi has been ported to many different platforms.\n For specific configuration details and testing status, please\n refer to the wiki page here:\n \n- http://www.moxielogic.org/wiki/index.php?title=Libffi_3.0.9\n+ http://www.moxielogic.org/wiki/index.php?title=Libffi_3.0.11\n \n At the time of release, the following basic configurations have been\n tested:\n@@ -55,13 +52,18 @@ tested:\n | Architecture | Operating System |\n |--------------+------------------|\n | Alpha        | Linux            |\n+| Alpha        | Tru64            |\n | ARM          | Linux            |\n+| ARM          | iOS              |\n | AVR32        | Linux            |\n | HPPA         | HPUX             |\n | IA-64        | Linux            |\n+| M68K         | RTEMS            |\n | MIPS         | IRIX             |\n | MIPS         | Linux            |\n+| MIPS         | RTEMS            |\n | MIPS64       | Linux            |\n+| PowerPC      | AMIGA            |\n | PowerPC      | Linux            |\n | PowerPC      | Mac OSX          |\n | PowerPC      | FreeBSD          |\n@@ -73,8 +75,10 @@ tested:\n | SPARC64      | Linux            |\n | SPARC64      | FreeBSD          |\n | X86          | FreeBSD          |\n+| X86          | Interix          |\n | X86          | kFreeBSD         |\n | X86          | Linux            |\n+| X86          | Linux/x32        |\n | X86          | Mac OSX          |\n | X86          | OpenBSD          |\n | X86          | OS/2             |\n@@ -84,6 +88,7 @@ tested:\n | X86-64       | FreeBSD          |\n | X86-64       | Linux            |\n | X86-64       | OpenBSD          |\n+| X86-64       | Windows/MingW    |\n |--------------+------------------|\n \n Please send additional platform test results to\n@@ -115,9 +120,15 @@ It's also possible to build libffi on Windows platforms with\n Microsoft's Visual C++ compiler.  In this case, use the msvcc.sh\n wrapper script during configuration like so:\n \n-path/to/configure --enable-shared --enable-static \\\n-\tCC=path/to/msvcc.sh LD=link \\\n-\tCPP=\\\"cl -nologo -EP\\\"\n+path/to/configure CC=path/to/msvcc.sh LD=link CPP=\\\"cl -nologo -EP\\\"\n+\n+For 64-bit Windows builds, use CC=\"path/to/msvcc.sh -m64\".\n+You may also need to specify --build appropriately. When building with MSVC\n+under a MingW environment, you may need to remove the line in configure\n+that sets 'fix_srcfile_path' to a 'cygpath' command. ('cygpath' is not\n+present in MingW, and is not required when using MingW-style paths.)\n+\n+For iOS builds, refer to the build-ios.sh script for guidance.\n \n Configure has many other options. Use \"configure --help\" to see them all.\n \n@@ -135,11 +146,27 @@ History\n \n See the ChangeLog files for details.\n \n-3.0.10 ???-??-??\n+3.0.11 MMM-DD-YY\n+        Lots of build fixes.\n+        Add Amiga newer MacOS support.\n+\tAdd Linux/x32 support.\n+\tAdd thiscall and fastcall support on Windows.\n+\tFix Octeon and MC68881 support.\n+\tFix code pessimizations.\n+\n+3.0.10 Aug-23-11\n+        Add support for Apple's iOS.\n+\tAdd support for ARM VFP ABI.\n+        Add RTEMS support for MIPS and M68K.\n+\tFix instruction cache clearing problems on\n+\t  ARM and SPARC.\n \tFix the N64 build on mips-sgi-irix6.5.\n-\tTestsuite fixes for Tru64 Unix.\n \tEnable builds with Microsoft's compiler.\n-\tEnable x86 builds with Sun's compiler.\n+\tEnable x86 builds with Oracle's Solaris compiler.\n+\tFix support for calling code compiled with Oracle's Sparc\n+\t  Solaris compiler.\n+\tTestsuite fixes for Tru64 Unix.\n+\tAdditional platform support.\n \n 3.0.9 Dec-31-09\n         Add AVR32 and win64 ports.  Add ARM softfp support.\n@@ -320,5 +347,6 @@ Alex Oliva solved the executable page problem for SElinux.\n The list above is almost certainly incomplete and inaccurate.  I'm\n happy to make corrections or additions upon request.\n \n-If you have a problem, or have found a bug, please send a note to\n-green@redhat.com.\n+If you have a problem, or have found a bug, please send a note to the\n+author at green@moxielogic.com, or the project mailing list at\n+libffi-discuss@sourceware.org."}, {"sha": "3dea242255ee90d0fafbdf200977457755b0c56e", "filename": "libffi/build-ios.sh", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fbuild-ios.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fbuild-ios.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fbuild-ios.sh?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -0,0 +1,67 @@\n+#!/bin/sh\n+\n+PLATFORM_IOS=/Developer/Platforms/iPhoneOS.platform/\n+PLATFORM_IOS_SIM=/Developer/Platforms/iPhoneSimulator.platform/\n+SDK_IOS_VERSION=\"4.2\"\n+MIN_IOS_VERSION=\"3.0\"\n+OUTPUT_DIR=\"universal-ios\"\n+\n+build_target () {\n+    local platform=$1\n+    local sdk=$2\n+    local arch=$3\n+    local triple=$4\n+    local builddir=$5\n+\n+    mkdir -p \"${builddir}\"\n+    pushd \"${builddir}\"\n+    export CC=\"${platform}\"/Developer/usr/bin/gcc-4.2\n+    export CFLAGS=\"-arch ${arch} -isysroot ${sdk} -miphoneos-version-min=${MIN_IOS_VERSION}\"\n+    ../configure --host=${triple} && make\n+    popd\n+}\n+\n+# Build all targets\n+build_target \"${PLATFORM_IOS}\" \"${PLATFORM_IOS}/Developer/SDKs/iPhoneOS${SDK_IOS_VERSION}.sdk/\" armv6 arm-apple-darwin10 armv6-ios\n+build_target \"${PLATFORM_IOS}\" \"${PLATFORM_IOS}/Developer/SDKs/iPhoneOS${SDK_IOS_VERSION}.sdk/\" armv7 arm-apple-darwin10 armv7-ios\n+build_target \"${PLATFORM_IOS_SIM}\" \"${PLATFORM_IOS_SIM}/Developer/SDKs/iPhoneSimulator${SDK_IOS_VERSION}.sdk/\" i386 i386-apple-darwin10 i386-ios-sim\n+\n+# Create universal output directories\n+mkdir -p \"${OUTPUT_DIR}\"\n+mkdir -p \"${OUTPUT_DIR}/include\"\n+mkdir -p \"${OUTPUT_DIR}/include/armv6\"\n+mkdir -p \"${OUTPUT_DIR}/include/armv7\"\n+mkdir -p \"${OUTPUT_DIR}/include/i386\"\n+\n+# Create the universal binary\n+lipo -create armv6-ios/.libs/libffi.a armv7-ios/.libs/libffi.a i386-ios-sim/.libs/libffi.a -output \"${OUTPUT_DIR}/libffi.a\"\n+\n+# Copy in the headers\n+copy_headers () {\n+    local src=$1\n+    local dest=$2\n+\n+    # Fix non-relative header reference\n+    sed 's/<ffitarget.h>/\"ffitarget.h\"/' < \"${src}/include/ffi.h\" > \"${dest}/ffi.h\"\n+    cp \"${src}/include/ffitarget.h\" \"${dest}\"\n+}\n+\n+copy_headers armv6-ios \"${OUTPUT_DIR}/include/armv6\"\n+copy_headers armv7-ios \"${OUTPUT_DIR}/include/armv7\"\n+copy_headers i386-ios-sim \"${OUTPUT_DIR}/include/i386\"\n+\n+# Create top-level header\n+(\n+cat << EOF\n+#ifdef __arm__\n+  #include <arm/arch.h>\n+  #ifdef _ARM_ARCH_6\n+    #include \"include/armv6/ffi.h\"\n+  #elif _ARM_ARCH_7\n+    #include \"include/armv7/ffi.h\"\n+  #endif\n+#elif defined(__i386__)\n+  #include \"include/i386/ffi.h\"\n+#endif\n+EOF\n+) > \"${OUTPUT_DIR}/ffi.h\""}, {"sha": "f0e6517de163cb376a18c250695c8057257ebfb1", "filename": "libffi/doc/libffi.texi", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fdoc%2Flibffi.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fdoc%2Flibffi.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Flibffi.texi?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -19,7 +19,7 @@\n This manual is for Libffi, a portable foreign-function interface\n library.\n \n-Copyright @copyright{} 2008, 2010 Red Hat, Inc.\n+Copyright @copyright{} 2008, 2010, 2011 Red Hat, Inc.\n \n @quotation\n Permission is granted to copy, distribute and/or modify this document\n@@ -133,8 +133,6 @@ This initializes @var{cif} according to the given parameters.\n you want.  @ref{Multiple ABIs} for more information.\n \n @var{nargs} is the number of arguments that this function accepts.\n-@samp{libffi} does not yet handle varargs functions; see @ref{Missing\n-Features} for more information.\n \n @var{rtype} is a pointer to an @code{ffi_type} structure that\n describes the return type of the function.  @xref{Types}.\n@@ -150,6 +148,30 @@ objects is incorrect; or @code{FFI_BAD_ABI} if the @var{abi} parameter\n is invalid.\n @end defun\n \n+If the function being called is variadic (varargs) then\n+@code{ffi_prep_cif_var} must be used instead of @code{ffi_prep_cif}.\n+\n+@findex ffi_prep_cif_var\n+@defun ffi_status ffi_prep_cif_var (ffi_cif *@var{cif}, ffi_abi var{abi}, unsigned int @var{nfixedargs}, unsigned int var{ntotalargs}, ffi_type *@var{rtype}, ffi_type **@var{argtypes})\n+This initializes @var{cif} according to the given parameters for\n+a call to a variadic function.  In general it's operation is the\n+same as for @code{ffi_prep_cif} except that:\n+\n+@var{nfixedargs} is the number of fixed arguments, prior to any\n+variadic arguments.  It must be greater than zero.\n+\n+@var{ntotalargs} the total number of arguments, including variadic\n+and fixed arguments.\n+\n+Note that, different cif's must be prepped for calls to the same\n+function when different numbers of arguments are passed.\n+\n+Also note that a call to @code{ffi_prep_cif_var} with\n+@var{nfixedargs}=@var{nototalargs} is NOT equivalent to a call to\n+@code{ffi_prep_cif}.\n+\n+@end defun\n+\n \n To call a function using an initialized @code{ffi_cif}, use the\n @code{ffi_call} function:\n@@ -171,7 +193,9 @@ discarded.\n @var{avalues} is a vector of @code{void *} pointers that point to the\n memory locations holding the argument values for a call.  If @var{cif}\n declares that the function has no arguments (i.e., @var{nargs} was 0),\n-then @var{avalues} is ignored.\n+then @var{avalues} is ignored.  Note that argument values may be\n+modified by the callee (for instance, structs passed by value); the\n+burden of copying pass-by-value arguments is placed on the caller.\n @end defun\n \n \n@@ -570,9 +594,7 @@ support for these.\n \n @itemize @bullet\n @item\n-There is no support for calling varargs functions.  This may work on\n-some platforms, depending on how the ABI is defined, but it is not\n-reliable.\n+Variadic closures.\n \n @item\n There is no support for bit fields in structures.\n@@ -589,6 +611,8 @@ The ``raw'' API is undocumented.\n @c anything else?\n @end itemize\n \n+Note that variadic support is very new and tested on a relatively\n+small number of platforms.\n \n @node Index\n @unnumbered Index"}, {"sha": "b54b273f95753d01af4fb806fafac61225ceda4c", "filename": "libffi/fficonfig.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ffficonfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ffficonfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ffficonfig.h.in?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -17,6 +17,9 @@\n /* Define this if you want extra debugging. */\n #undef FFI_DEBUG\n \n+/* Cannot use PROT_EXEC on this target, so, we revert to alternative means */\n+#undef FFI_EXEC_TRAMPOLINE_TABLE\n+\n /* Cannot use malloc on this target, so, we revert to alternative means */\n #undef FFI_MMAP_EXEC_WRIT\n "}, {"sha": "84017f1f4450d2ab3be8e3daf63ce79052c7dc72", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,16 +1,17 @@\n /* -----------------------------------------------------------------*-C-*-\n-   libffi @VERSION@ - Copyright (c) 1996-2003, 2007, 2008  Red Hat, Inc.\n+   libffi @VERSION@ - Copyright (c) 2011 Anthony Green\n+                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n \n-   Permission is hereby granted, free of charge, to any person obtaining\n-   a copy of this software and associated documentation files (the\n-   ``Software''), to deal in the Software without restriction, including\n-   without limitation the rights to use, copy, modify, merge, publish,\n-   distribute, sublicense, and/or sell copies of the Software, and to\n-   permit persons to whom the Software is furnished to do so, subject to\n-   the following conditions:\n+   Permission is hereby granted, free of charge, to any person\n+   obtaining a copy of this software and associated documentation\n+   files (the ``Software''), to deal in the Software without\n+   restriction, including without limitation the rights to use, copy,\n+   modify, merge, publish, distribute, sublicense, and/or sell copies\n+   of the Software, and to permit persons to whom the Software is\n+   furnished to do so, subject to the following conditions:\n \n-   The above copyright notice and this permission notice shall be included\n-   in all copies or substantial portions of the Software.\n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n \n    THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n@@ -77,15 +78,31 @@ extern \"C\" {\n /* LONG_LONG_MAX is not always defined (not if STRICT_ANSI, for example).\n    But we can find it either under the correct ANSI name, or under GNU\n    C's internal name.  */\n+\n+#define FFI_64_BIT_MAX 9223372036854775807\n+\n #ifdef LONG_LONG_MAX\n # define FFI_LONG_LONG_MAX LONG_LONG_MAX\n #else\n # ifdef LLONG_MAX\n #  define FFI_LONG_LONG_MAX LLONG_MAX\n+#  ifdef _AIX52 /* or newer has C99 LLONG_MAX */\n+#   undef FFI_64_BIT_MAX\n+#   define FFI_64_BIT_MAX 9223372036854775807LL\n+#  endif /* _AIX52 or newer */\n # else\n #  ifdef __GNUC__\n #   define FFI_LONG_LONG_MAX __LONG_LONG_MAX__\n #  endif\n+#  ifdef _AIX /* AIX 5.1 and earlier have LONGLONG_MAX */\n+#   ifndef __PPC64__\n+#    if defined (__IBMC__) || defined (__IBMCPP__)\n+#     define FFI_LONG_LONG_MAX LONGLONG_MAX\n+#    endif\n+#   endif /* __PPC64__ */\n+#   undef  FFI_64_BIT_MAX\n+#   define FFI_64_BIT_MAX 9223372036854775807LL\n+#  endif\n # endif\n #endif\n \n@@ -132,17 +149,17 @@ typedef struct _ffi_type\n #endif\n \n #if LONG_MAX == 2147483647\n-# if FFI_LONG_LONG_MAX != 9223372036854775807\n+# if FFI_LONG_LONG_MAX != FFI_64_BIT_MAX\n  #error \"no 64-bit data type supported\"\n # endif\n-#elif LONG_MAX != 9223372036854775807\n+#elif LONG_MAX != FFI_64_BIT_MAX\n  #error \"long size not supported\"\n #endif\n \n #if LONG_MAX == 2147483647\n # define ffi_type_ulong        ffi_type_uint32\n # define ffi_type_slong        ffi_type_sint32\n-#elif LONG_MAX == 9223372036854775807\n+#elif LONG_MAX == FFI_64_BIT_MAX\n # define ffi_type_ulong        ffi_type_uint64\n # define ffi_type_slong        ffi_type_sint64\n #else\n@@ -190,12 +207,21 @@ typedef struct {\n #endif\n } ffi_cif;\n \n+/* Used internally, but overridden by some architectures */\n+ffi_status ffi_prep_cif_core(ffi_cif *cif,\n+\t\t\t     ffi_abi abi,\n+\t\t\t     unsigned int isvariadic,\n+\t\t\t     unsigned int nfixedargs,\n+\t\t\t     unsigned int ntotalargs,\n+\t\t\t     ffi_type *rtype,\n+\t\t\t     ffi_type **atypes);\n+\n /* ---- Definitions for the raw API -------------------------------------- */\n \n #ifndef FFI_SIZEOF_ARG\n # if LONG_MAX == 2147483647\n #  define FFI_SIZEOF_ARG        4\n-# elif LONG_MAX == 9223372036854775807\n+# elif LONG_MAX == FFI_64_BIT_MAX\n #  define FFI_SIZEOF_ARG        8\n # endif\n #endif\n@@ -265,6 +291,9 @@ typedef struct {\n } ffi_closure __attribute__((aligned (8)));\n #else\n } ffi_closure;\n+# ifdef __sgi\n+#  pragma pack 0\n+# endif\n #endif\n \n void *ffi_closure_alloc (size_t size, void **code);\n@@ -283,6 +312,9 @@ ffi_prep_closure_loc (ffi_closure*,\n \t\t      void *user_data,\n \t\t      void*codeloc);\n \n+#ifdef __sgi\n+# pragma pack 8\n+#endif\n typedef struct {\n   char tramp[FFI_TRAMPOLINE_SIZE];\n \n@@ -361,6 +393,13 @@ ffi_status ffi_prep_cif(ffi_cif *cif,\n \t\t\tffi_type *rtype,\n \t\t\tffi_type **atypes);\n \n+ffi_status ffi_prep_cif_var(ffi_cif *cif,\n+\t\t\t    ffi_abi abi,\n+\t\t\t    unsigned int nfixedargs,\n+\t\t\t    unsigned int ntotalargs,\n+\t\t\t    ffi_type *rtype,\n+\t\t\t    ffi_type **atypes);\n+\n void ffi_call(ffi_cif *cif,\n \t      void (*fn)(void),\n \t      void *rvalue,"}, {"sha": "c179d68157ba24cb96c43bf8796fccb0d573f228", "filename": "libffi/include/ffi_common.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Finclude%2Fffi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Finclude%2Fffi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi_common.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,7 +1,8 @@\n /* -----------------------------------------------------------------------\n-   ffi_common.h - Copyright (c) 1996  Red Hat, Inc.\n-   Copyright (C) 2007 Free Software Foundation, Inc\n-\n+   ffi_common.h - Copyright (C) 2011, 2012  Anthony Green\n+                  Copyright (C) 2007  Free Software Foundation, Inc\n+                  Copyright (c) 1996  Red Hat, Inc.\n+                  \n    Common internal definitions and macros. Only necessary for building\n    libffi.\n    ----------------------------------------------------------------------- */\n@@ -74,6 +75,8 @@ void ffi_type_test(ffi_type *a, char *file, int line);\n \n /* Perform machine dependent cif processing */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif);\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n+\t unsigned int nfixedargs, unsigned int ntotalargs);\n \n /* Extended cif, used in callback from assembly routine */\n typedef struct\n@@ -112,11 +115,14 @@ typedef signed int   SINT64 __attribute__((__mode__(__DI__)));\n \n typedef float FLOAT32;\n \n+#ifndef __GNUC__\n+#define __builtin_expect(x, expected_value) (x)\n+#endif\n+#define LIKELY(x)    __builtin_expect(!!(x),1)\n+#define UNLIKELY(x)  __builtin_expect((x)!=0,0)\n \n #ifdef __cplusplus\n }\n #endif\n \n #endif\n-\n-"}, {"sha": "1f1d3031c99772fb01aa08c126ea0e654aef5e2b", "filename": "libffi/man/ffi.3", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fman%2Fffi.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fman%2Fffi.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2Fffi.3?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -16,6 +16,15 @@ libffi, -lffi\n .Fa \"ffi_type **atypes\"\n .Fc\n .Ft void\n+.Fo ffi_prep_cif_var\n+.Fa \"ffi_cif *cif\"\n+.Fa \"ffi_abi abi\"\n+.Fa \"unsigned int nfixedargs\"\n+.Fa \"unsigned int ntotalargs\"\n+.Fa \"ffi_type *rtype\"\n+.Fa \"ffi_type **atypes\"\n+.Fc\n+.Ft void\n .Fo ffi_call\n .Fa \"ffi_cif *cif\"\n .Fa \"void (*fn)(void)\"\n@@ -28,4 +37,5 @@ generate a call to another function at runtime without requiring knowledge of\n the called function's interface at compile time.\n .Sh SEE ALSO\n .Xr ffi_prep_cif 3 ,\n+.Xr ffi_prep_cif_var 3 ,\n .Xr ffi_call 3"}, {"sha": "e1bdbd7c46ae3b235fd483918a5994fca3b06d64", "filename": "libffi/man/ffi_prep_cif.3", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fman%2Fffi_prep_cif.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fman%2Fffi_prep_cif.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2Fffi_prep_cif.3?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -37,7 +37,9 @@ structs that describe the data type, size and alignment of each argument.\n points to an\n .Nm ffi_type\n that describes the data type, size and alignment of the\n-return value.\n+return value. Note that to call a variadic function\n+.Nm ffi_prep_cif_var\n+must be used instead.\n .Sh RETURN VALUES\n Upon successful completion,\n .Nm ffi_prep_cif\n@@ -63,4 +65,6 @@ defined in\n .\n .Sh SEE ALSO\n .Xr ffi 3 ,\n-.Xr ffi_call 3 \n+.Xr ffi_call 3 ,\n+.Xr ffi_prep_cif_var 3\n+"}, {"sha": "7e19d0b070f17fed3f0890dd433e188b890d1466", "filename": "libffi/man/ffi_prep_cif_var.3", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fman%2Fffi_prep_cif_var.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fman%2Fffi_prep_cif_var.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2Fffi_prep_cif_var.3?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -0,0 +1,73 @@\n+.Dd January 25, 2011\n+.Dt ffi_prep_cif_var 3\n+.Sh NAME\n+.Nm ffi_prep_cif_var\n+.Nd Prepare a\n+.Nm ffi_cif\n+structure for use with\n+.Nm ffi_call\n+for variadic functions.\n+.Sh SYNOPSIS\n+.In ffi.h\n+.Ft ffi_status\n+.Fo ffi_prep_cif_var\n+.Fa \"ffi_cif *cif\"\n+.Fa \"ffi_abi abi\"\n+.Fa \"unsigned int nfixedargs\"\n+.Fa \"unsigned int ntotalargs\"\n+.Fa \"ffi_type *rtype\"\n+.Fa \"ffi_type **atypes\"\n+.Fc\n+.Sh DESCRIPTION\n+The\n+.Nm ffi_prep_cif_var\n+function prepares a\n+.Nm ffi_cif\n+structure for use with\n+.Nm ffi_call\n+for variadic functions.\n+.Fa abi\n+specifies a set of calling conventions to use.\n+.Fa atypes\n+is an array of\n+.Fa ntotalargs\n+pointers to\n+.Nm ffi_type\n+structs that describe the data type, size and alignment of each argument.\n+.Fa rtype\n+points to an\n+.Nm ffi_type\n+that describes the data type, size and alignment of the\n+return value.\n+.Fa nfixedargs\n+must contain the number of fixed (non-variadic) arguments.\n+Note that to call a non-variadic function\n+.Nm ffi_prep_cif\n+must be used.\n+.Sh RETURN VALUES\n+Upon successful completion,\n+.Nm ffi_prep_cif_var\n+returns\n+.Nm FFI_OK .\n+It will return\n+.Nm FFI_BAD_TYPEDEF\n+if\n+.Fa cif\n+is\n+.Nm NULL\n+or\n+.Fa atypes\n+or\n+.Fa rtype\n+is malformed. If\n+.Fa abi\n+does not refer to a valid ABI,\n+.Nm FFI_BAD_ABI\n+will be returned. Available ABIs are\n+defined in\n+.Nm <ffitarget.h>\n+.\n+.Sh SEE ALSO\n+.Xr ffi 3 ,\n+.Xr ffi_call 3 ,\n+.Xr ffi_prep_cif 3"}, {"sha": "dcdbeab16aea8053821959fa1b9a634d91fde5c7", "filename": "libffi/msvcc.sh", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fmsvcc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fmsvcc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fmsvcc.sh?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -42,10 +42,11 @@\n # format and translated into something sensible for cl or ml.\n #\n \n-args=\"-nologo\"\n+args=\"-nologo -W3\"\n md=-MD\n cl=\"cl\"\n ml=\"ml\"\n+safeseh=\"-safeseh\"\n output=\n \n while [ $# -gt 0 ]\n@@ -63,15 +64,28 @@ do\n     -m64)\n       cl=\"cl\"   # \"$MSVC/x86_amd64/cl\"\n       ml=\"ml64\" # \"$MSVC/x86_amd64/ml64\"\n+      safeseh=\n+      shift 1\n+    ;;\n+    -O0)\n+      args=\"$args -Od\"\n       shift 1\n     ;;\n     -O*)\n-      args=\"$args $1\"\n+      # If we're optimizing, make sure we explicitly turn on some optimizations\n+      # that are implicitly disabled by debug symbols (-Zi).\n+      args=\"$args $1 -OPT:REF -OPT:ICF -INCREMENTAL:NO\"\n       shift 1\n     ;;\n     -g)\n-      # Can't specify -RTC1 or -Zi in opt. -Gy is ok. Use -OPT:REF?\n-      args=\"$args -D_DEBUG -RTC1 -Zi\"\n+      # Enable debug symbol generation.\n+      args=\"$args -Zi -DEBUG\"\n+      shift 1\n+    ;;\n+    -DFFI_DEBUG)\n+      # Link against debug CRT and enable runtime error checks.\n+      args=\"$args -RTC1\"\n+      defines=\"$defines $1\"\n       md=-MDd\n       shift 1\n     ;;\n@@ -108,8 +122,8 @@ do\n       shift 1\n     ;;\n     -Wall)\n-      # -Wall on MSVC is overzealous. Use -W3 instead.\n-      args=\"$args -W3\"\n+      # -Wall on MSVC is overzealous, and we already build with -W3. Nothing\n+      # to do here.\n       shift 1\n     ;;\n     -Werror)\n@@ -164,7 +178,7 @@ if [ -n \"$assembly\" ]; then\n     echo \"$cl -nologo -EP $includes $defines $src > $ppsrc\"\n     \"$cl\" -nologo -EP $includes $defines $src > $ppsrc || exit $?\n     output=\"$(echo $output | sed 's%/F[dpa][^ ]*%%g')\"\n-    args=\"-nologo -safeseh $single $output $ppsrc\"\n+    args=\"-nologo $safeseh $single $output $ppsrc\"\n \n     echo \"$ml $args\"\n     eval \"\\\"$ml\\\" $args\""}, {"sha": "192f691c4a20a8f0465affc3463231db2657335c", "filename": "libffi/src/alpha/ffi.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Falpha%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Falpha%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1998, 2001, 2007, 2008  Red Hat, Inc.\n+   ffi.c - Copyright (c) 2012  Anthony Green\n+           Copyright (c) 1998, 2001, 2007, 2008  Red Hat, Inc.\n    \n    Alpha Foreign Function Interface \n \n@@ -178,6 +179,9 @@ ffi_prep_closure_loc (ffi_closure* closure,\n {\n   unsigned int *tramp;\n \n+  if (cif->abi != FFI_OSF)\n+    return FFI_BAD_ABI;\n+\n   tramp = (unsigned int *) &closure->tramp[0];\n   tramp[0] = 0x47fb0401;\t/* mov $27,$1\t\t*/\n   tramp[1] = 0xa77b0010;\t/* ldq $27,16($27)\t*/"}, {"sha": "af145bce839ba86fdf83d3ad8d0cc60129c38854", "filename": "libffi/src/alpha/ffitarget.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Falpha%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Falpha%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for Alpha.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #ifndef LIBFFI_ASM\n typedef unsigned long          ffi_arg;\n typedef signed long            ffi_sarg;"}, {"sha": "1f8597da88cdb48668ec40d1bc35989376308579", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 254, "deletions": 6, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,6 +1,10 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1998, 2008  Red Hat, Inc.\n-   \n+   ffi.c - Copyright (c) 2011 Timothy Wall\n+           Copyright (c) 2011 Plausible Labs Cooperative, Inc.\n+           Copyright (c) 2011 Anthony Green\n+\t   Copyright (c) 2011 Free Software Foundation\n+           Copyright (c) 1998, 2008, 2011  Red Hat, Inc.\n+\t   \n    ARM Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -61,6 +65,7 @@ int ffi_prep_args(char *stack, extended_cif *ecif, float *vfp_space)\n        i--, p_arg++)\n     {\n       size_t z;\n+      size_t alignment;\n \n       /* Allocated in VFP registers. */\n       if (ecif->cif->abi == FFI_VFP\n@@ -78,8 +83,13 @@ int ffi_prep_args(char *stack, extended_cif *ecif, float *vfp_space)\n \t}\n \n       /* Align if necessary */\n-      if (((*p_arg)->alignment - 1) & (unsigned) argp) {\n-\targp = (char *) ALIGN(argp, (*p_arg)->alignment);\n+      alignment = (*p_arg)->alignment;\n+#ifdef _WIN32_WCE\n+      if (alignment > 4)\n+\talignment = 4;\n+#endif\n+      if ((alignment - 1) & (unsigned) argp) {\n+\targp = (char *) ALIGN(argp, alignment);\n       }\n \n       if ((*p_arg)->type == FFI_TYPE_STRUCT)\n@@ -186,6 +196,18 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n+/* Perform machine dependent cif processing for variadic calls */\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n+\t\t\t\t    unsigned int nfixedargs,\n+\t\t\t\t    unsigned int ntotalargs)\n+{\n+  /* VFP variadic calls actually use the SYSV ABI */\n+  if (cif->abi == FFI_VFP)\n+\tcif->abi = FFI_SYSV;\n+\n+  return ffi_prep_cif_machdep(cif);\n+}\n+\n /* Prototypes for assembly functions, in sysv.S */\n extern void ffi_call_SYSV (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);\n extern void ffi_call_VFP (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);\n@@ -317,6 +339,11 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n       alignment = (*p_arg)->alignment;\n       if (alignment < 4)\n \talignment = 4;\n+#ifdef _WIN32_WCE\n+      else\n+\tif (alignment > 4)\n+\t  alignment = 4;\n+#endif\n       /* Align if necessary */\n       if ((alignment - 1) & (unsigned) argp) {\n \targp = (char *) ALIGN(argp, alignment);\n@@ -339,6 +366,220 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n \n extern unsigned int ffi_arm_trampoline[3];\n \n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+\n+#include <mach/mach.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+extern void *ffi_closure_trampoline_table_page;\n+\n+typedef struct ffi_trampoline_table ffi_trampoline_table;\n+typedef struct ffi_trampoline_table_entry ffi_trampoline_table_entry;\n+\n+struct ffi_trampoline_table {\n+  /* contigious writable and executable pages */\n+  vm_address_t config_page;\n+  vm_address_t trampoline_page;\n+\n+  /* free list tracking */\n+  uint16_t free_count;\n+  ffi_trampoline_table_entry *free_list;\n+  ffi_trampoline_table_entry *free_list_pool;\n+\n+  ffi_trampoline_table *prev;\n+  ffi_trampoline_table *next;\n+};\n+\n+struct ffi_trampoline_table_entry {\n+  void *(*trampoline)();\n+  ffi_trampoline_table_entry *next;\n+};\n+\n+/* Override the standard architecture trampoline size */\n+// XXX TODO - Fix\n+#undef FFI_TRAMPOLINE_SIZE\n+#define FFI_TRAMPOLINE_SIZE 12\n+\n+/* The trampoline configuration is placed at 4080 bytes prior to the trampoline's entry point */\n+#define FFI_TRAMPOLINE_CODELOC_CONFIG(codeloc) ((void **) (((uint8_t *) codeloc) - 4080));\n+\n+/* The first 16 bytes of the config page are unused, as they are unaddressable from the trampoline page. */\n+#define FFI_TRAMPOLINE_CONFIG_PAGE_OFFSET 16\n+\n+/* Total number of trampolines that fit in one trampoline table */\n+#define FFI_TRAMPOLINE_COUNT ((PAGE_SIZE - FFI_TRAMPOLINE_CONFIG_PAGE_OFFSET) / FFI_TRAMPOLINE_SIZE)\n+\n+static pthread_mutex_t ffi_trampoline_lock = PTHREAD_MUTEX_INITIALIZER;\n+static ffi_trampoline_table *ffi_trampoline_tables = NULL;\n+\n+static ffi_trampoline_table *\n+ffi_trampoline_table_alloc ()\n+{\n+  ffi_trampoline_table *table = NULL;\n+\n+  /* Loop until we can allocate two contigious pages */\n+  while (table == NULL) {\n+    vm_address_t config_page = 0x0;\n+    kern_return_t kt;\n+\n+    /* Try to allocate two pages */\n+    kt = vm_allocate (mach_task_self (), &config_page, PAGE_SIZE*2, VM_FLAGS_ANYWHERE);\n+    if (kt != KERN_SUCCESS) {\n+      fprintf(stderr, \"vm_allocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n+      break;\n+    }\n+\n+    /* Now drop the second half of the allocation to make room for the trampoline table */\n+    vm_address_t trampoline_page = config_page+PAGE_SIZE;\n+    kt = vm_deallocate (mach_task_self (), trampoline_page, PAGE_SIZE);\n+    if (kt != KERN_SUCCESS) {\n+      fprintf(stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n+      break;\n+    }\n+\n+    /* Remap the trampoline table to directly follow the config page */\n+    vm_prot_t cur_prot;\n+    vm_prot_t max_prot;\n+\n+    kt = vm_remap (mach_task_self (), &trampoline_page, PAGE_SIZE, 0x0, FALSE, mach_task_self (), (vm_address_t) &ffi_closure_trampoline_table_page, FALSE, &cur_prot, &max_prot, VM_INHERIT_SHARE);\n+\n+    /* If we lost access to the destination trampoline page, drop our config allocation mapping and retry */\n+    if (kt != KERN_SUCCESS) {\n+      /* Log unexpected failures */\n+      if (kt != KERN_NO_SPACE) {\n+        fprintf(stderr, \"vm_remap() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n+      }\n+\n+      vm_deallocate (mach_task_self (), config_page, PAGE_SIZE);\n+      continue;\n+    }\n+\n+    /* We have valid trampoline and config pages */\n+    table = calloc (1, sizeof(ffi_trampoline_table));\n+    table->free_count = FFI_TRAMPOLINE_COUNT;\n+    table->config_page = config_page;\n+    table->trampoline_page = trampoline_page;\n+\n+    /* Create and initialize the free list */\n+    table->free_list_pool = calloc(FFI_TRAMPOLINE_COUNT, sizeof(ffi_trampoline_table_entry));\n+\n+    uint16_t i;\n+    for (i = 0; i < table->free_count; i++) {\n+      ffi_trampoline_table_entry *entry = &table->free_list_pool[i];\n+      entry->trampoline = (void *) (table->trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n+\n+      if (i < table->free_count - 1)\n+        entry->next = &table->free_list_pool[i+1];\n+    }\n+\n+    table->free_list = table->free_list_pool;\n+  }\n+\n+  return table;\n+}\n+\n+void *\n+ffi_closure_alloc (size_t size, void **code)\n+{\n+  /* Create the closure */\n+  ffi_closure *closure = malloc(size);\n+  if (closure == NULL)\n+    return NULL;\n+\n+  pthread_mutex_lock(&ffi_trampoline_lock);\n+\n+  /* Check for an active trampoline table with available entries. */\n+  ffi_trampoline_table *table = ffi_trampoline_tables;\n+  if (table == NULL || table->free_list == NULL) {\n+    table = ffi_trampoline_table_alloc ();\n+    if (table == NULL) {\n+      free(closure);\n+      return NULL;\n+    }\n+\n+    /* Insert the new table at the top of the list */\n+    table->next = ffi_trampoline_tables;\n+    if (table->next != NULL)\n+        table->next->prev = table;\n+\n+    ffi_trampoline_tables = table;\n+  }\n+\n+  /* Claim the free entry */\n+  ffi_trampoline_table_entry *entry = ffi_trampoline_tables->free_list;\n+  ffi_trampoline_tables->free_list = entry->next;\n+  ffi_trampoline_tables->free_count--;\n+  entry->next = NULL;\n+\n+  pthread_mutex_unlock(&ffi_trampoline_lock);\n+\n+  /* Initialize the return values */\n+  *code = entry->trampoline;\n+  closure->trampoline_table = table;\n+  closure->trampoline_table_entry = entry;\n+\n+  return closure;\n+}\n+\n+void\n+ffi_closure_free (void *ptr)\n+{\n+  ffi_closure *closure = ptr;\n+\n+  pthread_mutex_lock(&ffi_trampoline_lock);\n+\n+  /* Fetch the table and entry references */\n+  ffi_trampoline_table *table = closure->trampoline_table;\n+  ffi_trampoline_table_entry *entry = closure->trampoline_table_entry;\n+\n+  /* Return the entry to the free list */\n+  entry->next = table->free_list;\n+  table->free_list = entry;\n+  table->free_count++;\n+\n+  /* If all trampolines within this table are free, and at least one other table exists, deallocate\n+   * the table */\n+  if (table->free_count == FFI_TRAMPOLINE_COUNT && ffi_trampoline_tables != table) {\n+    /* Remove from the list */\n+    if (table->prev != NULL)\n+      table->prev->next = table->next;\n+\n+    if (table->next != NULL)\n+      table->next->prev = table->prev;\n+\n+    /* Deallocate pages */\n+    kern_return_t kt;\n+    kt = vm_deallocate (mach_task_self (), table->config_page, PAGE_SIZE);\n+    if (kt != KERN_SUCCESS)\n+      fprintf(stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n+\n+    kt = vm_deallocate (mach_task_self (), table->trampoline_page, PAGE_SIZE);\n+    if (kt != KERN_SUCCESS)\n+      fprintf(stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n+\n+    /* Deallocate free list */\n+    free (table->free_list_pool);\n+    free (table);\n+  } else if (ffi_trampoline_tables != table) {\n+    /* Otherwise, bump this table to the top of the list */\n+    table->prev = NULL;\n+    table->next = ffi_trampoline_tables;\n+    if (ffi_trampoline_tables != NULL)\n+      ffi_trampoline_tables->prev = table;\n+\n+    ffi_trampoline_tables = table;\n+  }\n+\n+  pthread_mutex_unlock (&ffi_trampoline_lock);\n+\n+  /* Free the closure */\n+  free (closure);\n+}\n+\n+#else\n+\n #define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX)\t\t\t\t\\\n ({ unsigned char *__tramp = (unsigned char*)(TRAMP);\t\t\t\\\n    unsigned int  __fun = (unsigned int)(FUN);\t\t\t\t\\\n@@ -353,6 +594,7 @@ extern unsigned int ffi_arm_trampoline[3];\n                                                     mapping.  */        \\\n  })\n \n+#endif\n \n /* the cif must already be prep'ed */\n \n@@ -370,12 +612,18 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   else if (cif->abi == FFI_VFP)\n     closure_func = &ffi_closure_VFP;\n   else\n-    FFI_ASSERT (0);\n+    return FFI_BAD_ABI;\n     \n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+  void **config = FFI_TRAMPOLINE_CODELOC_CONFIG(codeloc);\n+  config[0] = closure;\n+  config[1] = closure_func;\n+#else\n   FFI_INIT_TRAMPOLINE (&closure->tramp[0], \\\n \t\t       closure_func,  \\\n \t\t       codeloc);\n-    \n+#endif\n+\n   closure->cif  = cif;\n   closure->user_data = user_data;\n   closure->fun  = fun;"}, {"sha": "26d494d616a22641c558abe87ffa3753bab5f11b", "filename": "libffi/src/arm/ffitarget.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n-                 Copyright (c) 2010 CodeSourcery\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 2010  CodeSourcery\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n \n    Target configuration macros for ARM.\n \n@@ -29,6 +30,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #ifndef LIBFFI_ASM\n typedef unsigned long          ffi_arg;\n typedef signed long            ffi_sarg;\n@@ -55,11 +60,12 @@ typedef enum ffi_abi {\n #define FFI_TYPE_STRUCT_VFP_FLOAT  (FFI_TYPE_LAST + 1)\n #define FFI_TYPE_STRUCT_VFP_DOUBLE (FFI_TYPE_LAST + 2)\n \n+#define FFI_TARGET_SPECIFIC_VARIADIC\n+\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n #define FFI_TRAMPOLINE_SIZE 20\n #define FFI_NATIVE_RAW_API 0\n \n #endif\n-"}, {"sha": "74f0b867daec8f08c52f312850cc698a809962fc", "filename": "libffi/src/arm/gentramp.sh", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fgentramp.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fgentramp.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fgentramp.sh?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -0,0 +1,118 @@\n+#!/bin/sh\n+\n+# -----------------------------------------------------------------------\n+#  gentramp.sh - Copyright (c) 2010, Plausible Labs Cooperative, Inc.\n+#  \n+#  ARM Trampoline Page Generator\n+#\n+#  Permission is hereby granted, free of charge, to any person obtaining\n+#  a copy of this software and associated documentation files (the\n+#  ``Software''), to deal in the Software without restriction, including\n+#  without limitation the rights to use, copy, modify, merge, publish,\n+#  distribute, sublicense, and/or sell copies of the Software, and to\n+#  permit persons to whom the Software is furnished to do so, subject to\n+#  the following conditions:\n+#\n+#  The above copyright notice and this permission notice shall be included\n+#  in all copies or substantial portions of the Software.\n+#\n+#  THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+#  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+#  DEALINGS IN THE SOFTWARE.\n+#  -----------------------------------------------------------------------\n+\n+PROGNAME=$0\n+\n+# Each trampoline is exactly 3 instructions, or 12 bytes. If any of these values change,\n+# the entire arm trampoline implementation must be updated to match, too.\n+\n+# Size of an individual trampoline, in bytes\n+TRAMPOLINE_SIZE=12\n+\n+# Page size, in bytes\n+PAGE_SIZE=4096\n+\n+# Compute the size of the reachable config page; The first 16 bytes of the config page\n+# are unreachable due to our maximum pc-relative ldr offset.\n+PAGE_AVAIL=`expr $PAGE_SIZE - 16`\n+\n+# Compute the number of of available trampolines. \n+TRAMPOLINE_COUNT=`expr $PAGE_AVAIL / $TRAMPOLINE_SIZE`\n+\n+header () {\n+    echo \"# GENERATED CODE - DO NOT EDIT\"\n+    echo \"# This file was generated by $PROGNAME\"\n+    echo \"\"\n+\n+    # Write out the license header\n+cat << EOF\n+#  Copyright (c) 2010, Plausible Labs Cooperative, Inc.\n+#  \n+#  Permission is hereby granted, free of charge, to any person obtaining\n+#  a copy of this software and associated documentation files (the\n+#  ``Software''), to deal in the Software without restriction, including\n+#  without limitation the rights to use, copy, modify, merge, publish,\n+#  distribute, sublicense, and/or sell copies of the Software, and to\n+#  permit persons to whom the Software is furnished to do so, subject to\n+#  the following conditions:\n+#\n+#  The above copyright notice and this permission notice shall be included\n+#  in all copies or substantial portions of the Software.\n+#\n+#  THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+#  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+#  DEALINGS IN THE SOFTWARE.\n+#  -----------------------------------------------------------------------\n+\n+EOF\n+\n+    # Write out the trampoline table, aligned to the page boundary\n+    echo \".text\"\n+    echo \".align 12\"\n+    echo \".globl _ffi_closure_trampoline_table_page\"\n+    echo \"_ffi_closure_trampoline_table_page:\"\n+}\n+\n+\n+# WARNING - Don't modify the trampoline code size without also updating the relevent libffi code\n+trampoline () {\n+    cat << END\n+\n+    // trampoline\n+    // Save to stack\n+    stmfd sp!, {r0-r3}\n+\n+    // Load the context argument from the config page.\n+    // This places the first usable config value at _ffi_closure_trampoline_table-4080\n+    // This accounts for the above 4-byte stmfd instruction, plus 8 bytes constant when loading from pc.\n+    ldr r0, [pc, #-4092]\n+\n+    // Load the jump address from the config page.\n+    ldr pc, [pc, #-4092]\n+\n+END\n+}\n+\n+main () {\n+    # Write out the header\n+    header\n+\n+    # Write out the trampolines\n+    local i=0\n+    while [ $i -lt ${TRAMPOLINE_COUNT} ]; do\n+        trampoline\n+        local i=`expr $i + 1`\n+    done\n+}\n+\n+main"}, {"sha": "60e2ae3d552c1d32ee857f5df567c3e197650ebc", "filename": "libffi/src/arm/sysv.S", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   sysv.S - Copyright (c) 1998, 2008 Red Hat, Inc.\n+   sysv.S - Copyright (c) 1998, 2008, 2011 Red Hat, Inc.\n+\t    Copyright (c) 2011 Plausible Labs Cooperative, Inc.\n    \n    ARM Foreign Function Interface \n \n@@ -39,7 +40,11 @@\n #else\n #define CNAME(x) x\n #endif\n+#ifdef __APPLE__\n+#define ENTRY(x) .globl CNAME(x); CNAME(x):\n+#else\n #define ENTRY(x) .globl CNAME(x); .type CNAME(x),%function; CNAME(x):\n+#endif /* __APPLE__ */\n #endif\n \n #ifdef __ELF__\n@@ -48,6 +53,12 @@\n #define LSYM(x) x\n #endif\n \n+/* Use the SOFTFP return value ABI on Mac OS X, as per the iOS ABI\n+  Function Call Guide */\n+#ifdef __APPLE__\n+#define __SOFTFP__\n+#endif\n+\n /* We need a better way of testing for this, but for now, this is all \n    we can do.  */\n @ This selects the minimum architecture level required.\n@@ -105,21 +116,33 @@\n \t.align 0\n \t.thumb\n \t.thumb_func\n+#ifdef __APPLE__\n+\tENTRY($0)\n+#else\n \tENTRY(\\name)\n+#endif\n \tbx\tpc\n \tnop\n \t.arm\n \tUNWIND .fnstart\n /* A hook to tell gdb that we've switched to ARM mode.  Also used to call\n    directly from other local arm routines.  */\n-_L__\\name:\t\t\n+#ifdef __APPLE__\n+_L__$0:\n+#else\n+_L__\\name:\n+#endif\n .endm\n #else\n .macro\tARM_FUNC_START name\n \t.text\n \t.align 0\n \t.arm\n+#ifdef __APPLE__\n+\tENTRY($0)\n+#else\n \tENTRY(\\name)\n+#endif\n \tUNWIND .fnstart\n .endm\n #endif\n@@ -141,8 +164,7 @@ _L__\\name:\n #endif\n .endm\n \n-\n-\t@ r0:   fn\n+\t@ r0:   ffi_prep_args\n \t@ r1:   &ecif\n \t@ r2:   cif->bytes\n \t@ r3:   fig->flags\n@@ -222,11 +244,18 @@ ARM_FUNC_START ffi_call_SYSV\n #endif\n \n LSYM(Lepilogue):\n-\tRETLDM\t\"r0-r3,fp\"\n+#if defined (__INTERWORKING__)\n+\tldmia   sp!, {r0-r3,fp, lr}\n+\tbx\tlr\n+#else\n+\tldmia   sp!, {r0-r3,fp, pc}\n+#endif\n \n .ffi_call_SYSV_end:\n \tUNWIND .fnend\n+#ifdef __ELF__\n         .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)\n+#endif\n \n \n /*\n@@ -247,7 +276,7 @@ ARM_FUNC_START ffi_closure_SYSV\n \tsub\tsp, sp, #16\n \tstr\tsp, [sp, #8]\n \tadd\tr1, sp, #8\n-\tbl\tffi_closure_SYSV_inner\n+\tbl\tCNAME(ffi_closure_SYSV_inner)\n \tcmp\tr0, #FFI_TYPE_INT\n \tbeq\t.Lretint\n \n@@ -299,7 +328,9 @@ ARM_FUNC_START ffi_closure_SYSV\n \n .ffi_closure_SYSV_end:\n \tUNWIND .fnend\n+#ifdef __ELF__\n         .size    CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)\n+#endif\n \n \n /* Below are VFP hard-float ABI call and closure implementations.\n@@ -371,7 +402,7 @@ LSYM(Lbase_args):\n \t@ assume no return value.\n \tcmp\tr2, #0\n \tbeq\tLSYM(Lepilogue_vfp)\n-\t\n+\n \tcmp\tr3, #FFI_TYPE_INT\n \tstreq\tr0, [r2]\n \tbeq\tLSYM(Lepilogue_vfp)"}, {"sha": "7b474291a25adf37f3820ad2e2bd79035a255bdc", "filename": "libffi/src/arm/trampoline.S", "status": "added", "additions": 4450, "deletions": 0, "changes": 4450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Ftrampoline.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Farm%2Ftrampoline.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Ftrampoline.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d"}, {"sha": "3d43397b03ad1f505f0b3b77f71c321be55450c5", "filename": "libffi/src/avr32/ffi.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Favr32%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Favr32%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Favr32%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>\n+   ffi.c - Copyright (c) 2011  Anthony Green\n+           Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>\n \n    AVR32 Foreign Function Interface\n \n@@ -394,7 +395,8 @@ ffi_status ffi_prep_closure_loc(ffi_closure* closure, ffi_cif* cif,\n     void (*fun)(ffi_cif*, void*, void**, void*), void *user_data,\n     void *codeloc)\n {\n-    FFI_ASSERT(cif->abi == FFI_SYSV);\n+    if (cif->abi != FFI_SYSV)\n+      return FFI_BAD_ABI;\n \n     unsigned char *__tramp = (unsigned char*)(&closure->tramp[0]);\n     unsigned int  __fun = (unsigned int)(&ffi_closure_SYSV);"}, {"sha": "d0c7586f9a8b032459906a182def691d29c88eb3", "filename": "libffi/src/avr32/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Favr32%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Favr32%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Favr32%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>\n    Target configuration macros for AVR32.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,15 +28,19 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #ifndef LIBFFI_ASM\n typedef unsigned long          ffi_arg;\n typedef signed long            ffi_sarg;\n \n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_SYSV,\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n } ffi_abi;\n #endif\n "}, {"sha": "1b378270363bed1b68e029f8a32247d4e54eecbd", "filename": "libffi/src/closures.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fclosures.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fclosures.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fclosures.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------------\n-   closures.c - Copyright (c) 2007  Red Hat, Inc.\n-   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc\n+   closures.c - Copyright (c) 2007, 2009, 2010  Red Hat, Inc.\n+                Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc\n+                Copyright (c) 2011 Plausible Labs Cooperative, Inc.\n \n    Code to allocate and deallocate memory for closures.\n \n@@ -32,7 +33,7 @@\n #include <ffi.h>\n #include <ffi_common.h>\n \n-#ifndef FFI_MMAP_EXEC_WRIT\n+#if !FFI_MMAP_EXEC_WRIT && !FFI_EXEC_TRAMPOLINE_TABLE\n # if __gnu_linux__\n /* This macro indicates it may be forbidden to map anonymous memory\n    with both write and execute permission.  Code compiled when this\n@@ -63,7 +64,11 @@\n \n #if FFI_CLOSURES\n \n-# if FFI_MMAP_EXEC_WRIT\n+# if FFI_EXEC_TRAMPOLINE_TABLE\n+\n+// Per-target implementation; It's unclear what can reasonable be shared between two OS/architecture implementations.\n+\n+# elif FFI_MMAP_EXEC_WRIT /* !FFI_EXEC_TRAMPOLINE_TABLE */\n \n #define USE_LOCKS 1\n #define USE_DL_PREFIX 1\n@@ -167,7 +172,7 @@ selinux_enabled_check (void)\n \n #endif /* !FFI_MMAP_EXEC_SELINUX */\n \n-#elif defined (__CYGWIN__)\n+#elif defined (__CYGWIN__) || defined(__INTERIX)\n \n #include <sys/mman.h>\n \n@@ -193,11 +198,11 @@ static int dlmalloc_trim(size_t) MAYBE_UNUSED;\n static size_t dlmalloc_usable_size(void*) MAYBE_UNUSED;\n static void dlmalloc_stats(void) MAYBE_UNUSED;\n \n-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__)\n+#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n /* Use these for mmap and munmap within dlmalloc.c.  */\n static void *dlmmap(void *, size_t, int, int, int, off_t);\n static int dlmunmap(void *, size_t);\n-#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) */\n+#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */\n \n #define mmap dlmmap\n #define munmap dlmunmap\n@@ -207,7 +212,7 @@ static int dlmunmap(void *, size_t);\n #undef mmap\n #undef munmap\n \n-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__)\n+#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n \n /* A mutex used to synchronize access to *exec* variables in this file.  */\n static pthread_mutex_t open_temp_exec_file_mutex = PTHREAD_MUTEX_INITIALIZER;\n@@ -522,7 +527,7 @@ segment_holding_code (mstate m, char* addr)\n }\n #endif\n \n-#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) */\n+#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */\n \n /* Allocate a chunk of memory with the given size.  Returns a pointer\n    to the writable address, and sets *CODE to the executable"}, {"sha": "aaca5b1cbaa4d17732a0b3d8c8b612d8be9e1f64", "filename": "libffi/src/cris/ffi.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fcris%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fcris%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fcris%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -153,21 +153,24 @@ ffi_prep_args (char *stack, extended_cif * ecif)\n   return (struct_count);\n }\n \n-ffi_status\n-ffi_prep_cif (ffi_cif * cif,\n-\t      ffi_abi abi, unsigned int nargs,\n-\t      ffi_type * rtype, ffi_type ** atypes)\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_core (ffi_cif * cif,\n+\t           ffi_abi abi, unsigned int isvariadic,\n+\t\t   unsigned int nfixedargs, unsigned int ntotalargs,\n+\t           ffi_type * rtype, ffi_type ** atypes)\n {\n   unsigned bytes = 0;\n   unsigned int i;\n   ffi_type **ptr;\n \n   FFI_ASSERT (cif != NULL);\n-  FFI_ASSERT ((abi > FFI_FIRST_ABI) && (abi <= FFI_DEFAULT_ABI));\n+  FFI_ASSERT((!isvariadic) || (nfixedargs >= 1));\n+  FFI_ASSERT(nfixedargs <= ntotalargs);\n+  FFI_ASSERT (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI);\n \n   cif->abi = abi;\n   cif->arg_types = atypes;\n-  cif->nargs = nargs;\n+  cif->nargs = ntotalargs;\n   cif->rtype = rtype;\n \n   cif->flags = 0;"}, {"sha": "b837e976e4e8b695420f6edfb5594d206e9a3501", "filename": "libffi/src/cris/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fcris%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fcris%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fcris%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for CRIS.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,15 +28,19 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #ifndef LIBFFI_ASM\n typedef unsigned long          ffi_arg;\n typedef signed long            ffi_sarg;\n \n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_SYSV,\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n } ffi_abi;\n #endif\n "}, {"sha": "5c9f9c2d2398f04459709f49c1510ce053a6fa5c", "filename": "libffi/src/dlmalloc.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fdlmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fdlmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fdlmalloc.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -622,6 +622,9 @@ DEFAULT_MMAP_THRESHOLD       default: 256K\n #include \"/usr/include/malloc.h\"\n #else /* HAVE_USR_INCLUDE_MALLOC_H */\n \n+/* HP-UX's stdlib.h redefines mallinfo unless _STRUCT_MALLINFO is defined */\n+#define _STRUCT_MALLINFO\n+\n struct mallinfo {\n   MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */\n   MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */"}, {"sha": "d42540e53d3ad65a474952d3f14e1d186babd0b1", "filename": "libffi/src/frv/ffitarget.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Ffrv%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Ffrv%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ffrv%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2004  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2004  Red Hat, Inc.\n    Target configuration macros for FR-V\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- System specific configurations ----------------------------------- */\n \n #ifndef LIBFFI_ASM\n@@ -35,13 +40,9 @@ typedef signed long            ffi_sarg;\n \n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n-\n-#ifdef FRV\n   FFI_EABI,\n-  FFI_DEFAULT_ABI = FFI_EABI,\n-#endif\n-\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_EABI\n } ffi_abi;\n #endif\n "}, {"sha": "9533ef68b584664e9ba44c79fca2d07543d29ed4", "filename": "libffi/src/ia64/ffi.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fia64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fia64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 1998, 2007, 2008, 2012 Red Hat, Inc.\n \t   Copyright (c) 2000 Hewlett Packard Company\n+\t   Copyright (c) 2011 Anthony Green\n    \n    IA64 Foreign Function Interface \n \n@@ -429,7 +430,8 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   struct ffi_ia64_trampoline_struct *tramp;\n   struct ia64_fd *fd;\n \n-  FFI_ASSERT (cif->abi == FFI_UNIX);\n+  if (cif->abi != FFI_UNIX)\n+    return FFI_BAD_ABI;\n \n   tramp = (struct ffi_ia64_trampoline_struct *)closure->tramp;\n   fd = (struct ia64_fd *)(void *)ffi_closure_unix;"}, {"sha": "e68cea61544c55b819b1b9cc483159ee8244c1b1", "filename": "libffi/src/ia64/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fia64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fia64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for IA-64.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,15 +28,19 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #ifndef LIBFFI_ASM\n typedef unsigned long long          ffi_arg;\n typedef signed long long            ffi_sarg;\n \n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_UNIX,   \t/* Linux and all Unix variants use the same conventions\t*/\n-  FFI_DEFAULT_ABI = FFI_UNIX,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_UNIX\n } ffi_abi;\n #endif\n "}, {"sha": "522c8bfd67eac3f9667cc6ed1bf09b35304aaecb", "filename": "libffi/src/java_raw_api.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -311,7 +311,7 @@ ffi_java_translate_args (ffi_cif *cif, void *rvalue,\n   ffi_raw_closure *cl = (ffi_raw_closure*)user_data;\n \n   ffi_java_ptrarray_to_raw (cif, avalue, raw);\n-  (*cl->fun) (cif, rvalue, raw, cl->user_data);\n+  (*cl->fun) (cif, rvalue, (ffi_raw*)raw, cl->user_data);\n   ffi_java_raw_to_rvalue (cif, rvalue);\n }\n "}, {"sha": "6c34801982f6edef3b5a5909236b211d2ab929a8", "filename": "libffi/src/m32r/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fm32r%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fm32r%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm32r%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 2004  Renesas Technology.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 2004  Renesas Technology.\n    Target configuration macros for M32R.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -26,6 +27,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- Generic type definitions ----------------------------------------- */\n \n #ifndef LIBFFI_ASM\n@@ -36,8 +41,8 @@ typedef enum ffi_abi\n   {\n     FFI_FIRST_ABI = 0,\n     FFI_SYSV,\n-    FFI_DEFAULT_ABI = FFI_SYSV,\n-    FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+    FFI_LAST_ABI,\n+    FFI_DEFAULT_ABI = FFI_SYSV\n   } ffi_abi;\n #endif\n "}, {"sha": "d95c72b93bd8b9f2591e4d4321a2ce1675e072e4", "filename": "libffi/src/m68k/ffi.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fm68k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fm68k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -261,7 +261,8 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \t\t      void *user_data,\n \t\t      void *codeloc)\n {\n-  FFI_ASSERT (cif->abi == FFI_SYSV);\n+  if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n \n   *(unsigned short *)closure->tramp = 0x207c;\n   *(void **)(closure->tramp + 2) = codeloc;"}, {"sha": "e81dde2b2eb404bc0a60c37b9635dc3b0e972cc2", "filename": "libffi/src/m68k/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fm68k%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fm68k%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for Motorola 68K.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,15 +28,19 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #ifndef LIBFFI_ASM\n typedef unsigned long          ffi_arg;\n typedef signed long            ffi_sarg;\n \n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_SYSV,\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n } ffi_abi;\n #endif\n "}, {"sha": "79cff9b5304e5149ea86b864ae830ee6af07eea9", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996, 2007, 2008  Red Hat, Inc.\n-           Copyright (c) 2008       David Daney\n+   ffi.c - Copyright (c) 2011  Anthony Green\n+           Copyright (c) 2008  David Daney\n+           Copyright (c) 1996, 2007, 2008, 2011  Red Hat, Inc.\n    \n    MIPS Foreign Function Interface \n \n@@ -37,7 +38,11 @@\n #endif\n \n #ifndef USE__BUILTIN___CLEAR_CACHE\n-#include <sys/cachectl.h>\n+#  if defined(__OpenBSD__)\n+#    include <mips64/sysarch.h>\n+#  else\n+#    include <sys/cachectl.h>\n+#  endif\n #endif\n \n #ifdef FFI_DEBUG\n@@ -662,10 +667,12 @@ ffi_prep_closure_loc (ffi_closure *closure,\n   char *clear_location = (char *) codeloc;\n \n #if defined(FFI_MIPS_O32)\n-  FFI_ASSERT(cif->abi == FFI_O32 || cif->abi == FFI_O32_SOFT_FLOAT);\n+  if (cif->abi != FFI_O32 && cif->abi != FFI_O32_SOFT_FLOAT)\n+    return FFI_BAD_ABI;\n   fn = ffi_closure_O32;\n #else /* FFI_MIPS_N32 */\n-  FFI_ASSERT(cif->abi == FFI_N32 || cif->abi == FFI_N64);\n+  if (cif->abi != FFI_N32 && cif->abi != FFI_N64)\n+    return FFI_BAD_ABI;\n   fn = ffi_closure_N32;\n #endif /* FFI_MIPS_O32 */\n "}, {"sha": "717d65951c36393540f018c5eea9dd119b30880b", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for MIPS.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #ifdef linux\n # include <asm/sgidefs.h>\n #elif defined(__rtems__)\n@@ -36,7 +41,7 @@\n #define _MIPS_SIM_ABI32\t\t1\n #define _MIPS_SIM_NABI32\t2\n #define _MIPS_SIM_ABI64\t\t3\n-#else\n+#elif !defined(__OpenBSD__)\n # include <sgidefs.h>\n #endif\n \n@@ -51,15 +56,15 @@\n #  endif\n \n #if !defined(_MIPS_SIM)\n--- something is very wrong --\n+# error -- something is very wrong --\n #else\n #  if (_MIPS_SIM==_ABIN32 && defined(_ABIN32)) || (_MIPS_SIM==_ABI64 && defined(_ABI64))\n #    define FFI_MIPS_N32\n #  else\n #    if (_MIPS_SIM==_ABIO32 && defined(_ABIO32))\n #      define FFI_MIPS_O32\n #    else\n--- this is an unsupported platform --\n+#     error -- this is an unsupported platform --\n #    endif\n #  endif\n #endif\n@@ -194,30 +199,29 @@ typedef enum ffi_abi {\n   FFI_O32_SOFT_FLOAT,\n   FFI_N32_SOFT_FLOAT,\n   FFI_N64_SOFT_FLOAT,\n+  FFI_LAST_ABI,\n \n #ifdef FFI_MIPS_O32\n #ifdef __mips_soft_float\n-  FFI_DEFAULT_ABI = FFI_O32_SOFT_FLOAT,\n+  FFI_DEFAULT_ABI = FFI_O32_SOFT_FLOAT\n #else\n-  FFI_DEFAULT_ABI = FFI_O32,\n+  FFI_DEFAULT_ABI = FFI_O32\n #endif\n #else\n # if _MIPS_SIM==_ABI64\n #  ifdef __mips_soft_float\n-  FFI_DEFAULT_ABI = FFI_N64_SOFT_FLOAT,\n+  FFI_DEFAULT_ABI = FFI_N64_SOFT_FLOAT\n #  else\n-  FFI_DEFAULT_ABI = FFI_N64,\n+  FFI_DEFAULT_ABI = FFI_N64\n #  endif\n # else\n #  ifdef __mips_soft_float\n-  FFI_DEFAULT_ABI = FFI_N32_SOFT_FLOAT,\n+  FFI_DEFAULT_ABI = FFI_N32_SOFT_FLOAT\n #  else\n-  FFI_DEFAULT_ABI = FFI_N32,\n+  FFI_DEFAULT_ABI = FFI_N32\n #  endif\n # endif\n #endif\n-\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n } ffi_abi;\n \n #define FFI_EXTRA_CIF_FIELDS unsigned rstruct_flag"}, {"sha": "4ce2bc6f0e4c46336acffbc05fb754c93ffbf881", "filename": "libffi/src/pa/ffi.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,9 +1,11 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - (c) 2003-2004 Randolph Chung <tausq@debian.org>\n+   ffi.c - (c) 2011 Anthony Green\n            (c) 2008 Red Hat, Inc.\n-\n+\t   (c) 2006 Free Software Foundation, Inc.\n+           (c) 2003-2004 Randolph Chung <tausq@debian.org>\n+           \n    HPPA Foreign Function Interface\n-   HP-UX PA ABI support (c) 2006 Free Software Foundation, Inc.\n+   HP-UX PA ABI support \n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -633,7 +635,8 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   UINT32 *tmp;\n #endif\n \n-  FFI_ASSERT (cif->abi == FFI_PA32);\n+  if (cif->abi != FFI_PA32)\n+    return FFI_BAD_ABI;\n \n   /* Make a small trampoline that will branch to our\n      handler function. Use PC-relative addressing.  */"}, {"sha": "5e364d38f8b57d7f38ca2efb9fa87d893157223b", "filename": "libffi/src/pa/ffitarget.h", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpa%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpa%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for hppa.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- System specific configurations ----------------------------------- */\n \n #ifndef LIBFFI_ASM\n@@ -38,21 +43,22 @@ typedef enum ffi_abi {\n \n #ifdef PA_LINUX\n   FFI_PA32,\n-  FFI_DEFAULT_ABI = FFI_PA32,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_PA32\n #endif\n \n #ifdef PA_HPUX\n   FFI_PA32,\n-  FFI_DEFAULT_ABI = FFI_PA32,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_PA32\n #endif\n \n #ifdef PA64_HPUX\n #error \"PA64_HPUX FFI is not yet implemented\"\n   FFI_PA64,\n-  FFI_DEFAULT_ABI = FFI_PA64,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_PA64\n #endif\n-\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n } ffi_abi;\n #endif\n "}, {"sha": "213f2db39dec21bdcea725e7c615766f2041b109", "filename": "libffi/src/powerpc/aix.S", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Faix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Faix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   aix.S - Copyright (c) 2002,2009 Free Software Foundation, Inc.\n+   aix.S - Copyright (c) 2002, 2009 Free Software Foundation, Inc.\n    based on darwin.S by John Hornkvist\n \n    PowerPC Assembly glue.\n@@ -79,6 +79,8 @@\n \t.set f20,20\n \t.set f21,21\n \n+\t.extern .ffi_prep_args\n+\n #define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n@@ -125,6 +127,7 @@ ffi_call_AIX:\n \t/* Call ffi_prep_args.  */\n \tmr\tr4, r1\n \tbl\t.ffi_prep_args\n+\tnop\n \n \t/* Now do the call.  */\n \tld\tr0, 0(r29)\n@@ -226,6 +229,7 @@ L(float_return_value):\n \t/* Call ffi_prep_args.  */\n \tmr\tr4, r1\n \tbl\t.ffi_prep_args\n+\tnop\n \n \t/* Now do the call.  */\n \tlwz\tr0, 0(r29)"}, {"sha": "c906017c45992f53ac642df0b5a063926699f496", "filename": "libffi/src/powerpc/aix_closure.S", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -79,6 +79,8 @@\n \t.set f20,20\n \t.set f21,21\n \n+\t.extern .ffi_closure_helper_DARWIN\n+\n #define LIBFFI_ASM\n #define JUMPTARGET(name) name\n #define L(x) x"}, {"sha": "994f62d079d4742445c5165ac49f6aed7325fc39", "filename": "libffi/src/powerpc/asm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fasm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fasm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fasm.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -42,7 +42,7 @@\n \n /* If compiled for profiling, call `_mcount' at the start of each function.  */\n #ifdef\tPROF\n-/* The mcount code relies on a the return address being on the stack\n+/* The mcount code relies on the return address being on the stack\n    to locate our caller and so it can restore it; so store one just\n    for its benefit.  */\n #ifdef PIC"}, {"sha": "4f987dc7482482ee142fe2c793f203f1ef40bc98", "filename": "libffi/src/powerpc/darwin.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -335,7 +335,7 @@ LSCIE1:\n \t.byte\tEH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n \t.byte\t0x1\t; uleb128 0x1; Augmentation size\n-\t.byte\t0x90\t; FDE Encoding (indirect pcrel)\n+\t.byte\t0x10\t; FDE Encoding (indirect pcrel)\n \t.byte\t0xc\t; DW_CFA_def_cfa\n \t.byte\t0x1\t; uleb128 0x1\n \t.byte\t0x0\t; uleb128 0x0"}, {"sha": "3f6790f6bb39286e0bcf22146f5e5185f6b20eb8", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -484,7 +484,7 @@ LSCIE1:\n \t.byte\tEH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n \t.byte\t0x1\t; uleb128 0x1; Augmentation size\n-\t.byte\t0x90\t; FDE Encoding (indirect pcrel)\n+\t.byte\t0x10\t; FDE Encoding (indirect pcrel)\n \t.byte\t0xc\t; DW_CFA_def_cfa\n \t.byte\t0x1\t; uleb128 0x1\n \t.byte\t0x0\t; uleb128 0x0"}, {"sha": "1920c91104db01b68a71d31af5eb922dceaf36e8", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 329, "deletions": 301, "changes": 630, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,7 +1,9 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1998 Geoffrey Keating\n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc\n-   Copyright (C) 2008 Red Hat, Inc\n+   ffi.c - Copyright (C) 2011 Anthony Green\n+           Copyright (C) 2011 Kyle Moffett\n+           Copyright (C) 2008 Red Hat, Inc\n+           Copyright (C) 2007, 2008 Free Software Foundation, Inc\n+\t   Copyright (c) 1998 Geoffrey Keating\n \n    PowerPC Foreign Function Interface\n \n@@ -39,32 +41,28 @@ enum {\n   /* The assembly depends on these exact flags.  */\n   FLAG_RETURNS_SMST\t= 1 << (31-31), /* Used for FFI_SYSV small structs.  */\n   FLAG_RETURNS_NOTHING  = 1 << (31-30), /* These go in cr7 */\n+#ifndef __NO_FPRS__\n   FLAG_RETURNS_FP       = 1 << (31-29),\n+#endif\n   FLAG_RETURNS_64BITS   = 1 << (31-28),\n \n   FLAG_RETURNS_128BITS  = 1 << (31-27), /* cr6  */\n-  FLAG_SYSV_SMST_R4     = 1 << (31-26), /* use r4 for FFI_SYSV 8 byte\n-\t\t\t\t\t   structs.  */\n-  FLAG_SYSV_SMST_R3     = 1 << (31-25), /* use r3 for FFI_SYSV 4 byte\n-\t\t\t\t\t   structs.  */\n-  /* Bits (31-24) through (31-19) store shift value for SMST */\n \n   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),\n+#ifndef __NO_FPRS__\n   FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */\n+#endif\n   FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),\n   FLAG_RETVAL_REFERENCE = 1 << (31- 4)\n };\n \n /* About the SYSV ABI.  */\n-unsigned int NUM_GPR_ARG_REGISTERS = 8;\n+#define ASM_NEEDS_REGISTERS 4\n+#define NUM_GPR_ARG_REGISTERS 8\n #ifndef __NO_FPRS__\n-unsigned int NUM_FPR_ARG_REGISTERS = 8;\n-#else\n-unsigned int NUM_FPR_ARG_REGISTERS = 0;\n+# define NUM_FPR_ARG_REGISTERS 8\n #endif\n \n-enum { ASM_NEEDS_REGISTERS = 4 };\n-\n /* ffi_prep_args_SYSV is called by the assembly routine once stack space\n    has been allocated for the function's arguments.\n \n@@ -113,10 +111,12 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   valp gpr_base;\n   int intarg_count;\n \n+#ifndef __NO_FPRS__\n   /* 'fpr_base' points at the space for fpr1, and grows upwards as\n      we use FPR registers.  */\n   valp fpr_base;\n   int fparg_count;\n+#endif\n \n   /* 'copy_space' grows down as we put structures in it.  It should\n      stay 16-byte aligned.  */\n@@ -125,9 +125,8 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   /* 'next_arg' grows up as we put parameters in it.  */\n   valp next_arg;\n \n-  int i, ii MAYBE_UNUSED;\n+  int i;\n   ffi_type **ptr;\n-  double double_tmp;\n   union {\n     void **v;\n     char **c;\n@@ -143,15 +142,16 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   size_t struct_copy_size;\n   unsigned gprvalue;\n \n-  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)\n-    NUM_FPR_ARG_REGISTERS = 0;\n-\n   stacktop.c = (char *) stack + bytes;\n   gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;\n   intarg_count = 0;\n+#ifndef __NO_FPRS__\n   fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS;\n   fparg_count = 0;\n   copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);\n+#else\n+  copy_space.c = gpr_base.c;\n+#endif\n   next_arg.u = stack + 2;\n \n   /* Check that everything starts aligned properly.  */\n@@ -174,12 +174,28 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n        i > 0;\n        i--, ptr++, p_argv.v++)\n     {\n-      switch ((*ptr)->type)\n-\t{\n+      unsigned short typenum = (*ptr)->type;\n+\n+      /* We may need to handle some values depending on ABI */\n+      if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT) {\n+\t\tif (typenum == FFI_TYPE_FLOAT)\n+\t\t\ttypenum = FFI_TYPE_UINT32;\n+\t\tif (typenum == FFI_TYPE_DOUBLE)\n+\t\t\ttypenum = FFI_TYPE_UINT64;\n+\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n+\t\t\ttypenum = FFI_TYPE_UINT128;\n+      } else if (ecif->cif->abi != FFI_LINUX) {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n+\t\t\ttypenum = FFI_TYPE_STRUCT;\n+#endif\n+      }\n+\n+      /* Now test the translated value */\n+      switch (typenum) {\n+#ifndef __NO_FPRS__\n \tcase FFI_TYPE_FLOAT:\n \t  /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */\n-\t  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t    goto soft_float_prep;\n \t  double_tmp = **p_argv.f;\n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n \t    {\n@@ -218,43 +234,6 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  if ((ecif->cif->abi != FFI_LINUX)\n-\t\t&& (ecif->cif->abi != FFI_LINUX_SOFT_FLOAT))\n-\t    goto do_struct;\n-\t  /* The soft float ABI for long doubles works like this,\n-\t     a long double is passed in four consecutive gprs if available.\n-\t     A maximum of 2 long doubles can be passed in gprs.\n-\t     If we do not have 4 gprs left, the long double is passed on the\n-\t     stack, 4-byte aligned.  */\n-\t  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t    {\n-\t      unsigned int int_tmp = (*p_argv.ui)[0];\n-\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3)\n-\t\t{\n-\t\t  if (intarg_count < NUM_GPR_ARG_REGISTERS)\n-\t\t    intarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;\n-\t\t  *next_arg.u = int_tmp;\n-\t\t  next_arg.u++;\n-\t\t  for (ii = 1; ii < 4; ii++)\n-\t\t    {\n-\t\t      int_tmp = (*p_argv.ui)[ii];\n-\t\t      *next_arg.u = int_tmp;\n-\t\t      next_arg.u++;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  *gpr_base.u++ = int_tmp;\n-\t\t  for (ii = 1; ii < 4; ii++)\n-\t\t    {\n-\t\t      int_tmp = (*p_argv.ui)[ii];\n-\t\t      *gpr_base.u++ = int_tmp;\n-\t\t    }\n-\t\t}\n-\t      intarg_count +=4;\n-\t    }\n-\t  else\n-\t    {\n \t      double_tmp = (*p_argv.d)[0];\n \n \t      if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)\n@@ -280,13 +259,40 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \n \t      fparg_count += 2;\n \t      FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n-\t    }\n \t  break;\n #endif\n+#endif /* have FPRs */\n+\n+\t/*\n+\t * The soft float ABI for long doubles works like this, a long double\n+\t * is passed in four consecutive GPRs if available.  A maximum of 2\n+\t * long doubles can be passed in gprs.  If we do not have 4 GPRs\n+\t * left, the long double is passed on the stack, 4-byte aligned.\n+\t */\n+\tcase FFI_TYPE_UINT128: {\n+\t\tunsigned int int_tmp = (*p_argv.ui)[0];\n+\t\tunsigned int ii;\n+\t\tif (intarg_count >= NUM_GPR_ARG_REGISTERS - 3) {\n+\t\t\tif (intarg_count < NUM_GPR_ARG_REGISTERS)\n+\t\t\t\tintarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;\n+\t\t\t*(next_arg.u++) = int_tmp;\n+\t\t\tfor (ii = 1; ii < 4; ii++) {\n+\t\t\t\tint_tmp = (*p_argv.ui)[ii];\n+\t\t\t\t*(next_arg.u++) = int_tmp;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t*(gpr_base.u++) = int_tmp;\n+\t\t\tfor (ii = 1; ii < 4; ii++) {\n+\t\t\t\tint_tmp = (*p_argv.ui)[ii];\n+\t\t\t\t*(gpr_base.u++) = int_tmp;\n+\t\t\t}\n+\t\t}\n+\t\tintarg_count += 4;\n+\t\tbreak;\n+\t}\n \n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n-\tsoft_double_prep:\n \t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1)\n \t    intarg_count++;\n \t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n@@ -319,9 +325,6 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tdo_struct:\n-#endif\n \t  struct_copy_size = ((*ptr)->size + 15) & ~0xF;\n \t  copy_space.c -= struct_copy_size;\n \t  memcpy (copy_space.c, *p_argv.c, (*ptr)->size);\n@@ -349,7 +352,6 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_POINTER:\n-\tsoft_float_prep:\n \n \t  gprvalue = **p_argv.ui;\n \n@@ -366,8 +368,10 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   /* Check that we didn't overrun the stack...  */\n   FFI_ASSERT (copy_space.c >= next_arg.c);\n   FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);\n+#ifndef __NO_FPRS__\n   FFI_ASSERT (fpr_base.u\n \t      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n+#endif\n   FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n }\n \n@@ -604,9 +608,6 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   unsigned type = cif->rtype->type;\n   unsigned size = cif->rtype->size;\n \n-  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-    NUM_FPR_ARG_REGISTERS = 0;\n-\n   if (cif->abi != FFI_LINUX64)\n     {\n       /* All the machine-independent calculation of cif->bytes will be wrong.\n@@ -646,62 +647,56 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n      - Single/double FP values in fpr1, long double in fpr1,fpr2.\n      - soft-float float/doubles are treated as UINT32/UINT64 respectivley.\n      - soft-float long doubles are returned in gpr3-gpr6.  */\n+  /* First translate for softfloat/nonlinux */\n+  if (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n+\tif (type == FFI_TYPE_FLOAT)\n+\t\ttype = FFI_TYPE_UINT32;\n+\tif (type == FFI_TYPE_DOUBLE)\n+\t\ttype = FFI_TYPE_UINT64;\n+\tif (type == FFI_TYPE_LONGDOUBLE)\n+\t\ttype = FFI_TYPE_UINT128;\n+  } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tif (type == FFI_TYPE_LONGDOUBLE)\n+\t\ttype = FFI_TYPE_STRUCT;\n+#endif\n+  }\n+\n   switch (type)\n     {\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+#ifndef __NO_FPRS__\n     case FFI_TYPE_LONGDOUBLE:\n-      if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64\n-\t&& cif->abi != FFI_LINUX_SOFT_FLOAT)\n-\tgoto byref;\n       flags |= FLAG_RETURNS_128BITS;\n       /* Fall through.  */\n-#endif\n     case FFI_TYPE_DOUBLE:\n       flags |= FLAG_RETURNS_64BITS;\n       /* Fall through.  */\n     case FFI_TYPE_FLOAT:\n-      /* With FFI_LINUX_SOFT_FLOAT no fp registers are used.  */\n-      if (cif->abi != FFI_LINUX_SOFT_FLOAT)\n-\tflags |= FLAG_RETURNS_FP;\n+      flags |= FLAG_RETURNS_FP;\n       break;\n+#endif\n \n+    case FFI_TYPE_UINT128:\n+      flags |= FLAG_RETURNS_128BITS;\n+      /* Fall through.  */\n     case FFI_TYPE_UINT64:\n     case FFI_TYPE_SINT64:\n       flags |= FLAG_RETURNS_64BITS;\n       break;\n \n     case FFI_TYPE_STRUCT:\n-      if (cif->abi == FFI_SYSV)\n-\t{\n-\t  /* The final SYSV ABI says that structures smaller or equal 8 bytes\n-\t     are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them\n-\t     in memory.  */\n-\n-\t  /* Treat structs with size <= 8 bytes.  */\n-\t  if (size <= 8)\n-\t    {\n-\t      flags |= FLAG_RETURNS_SMST;\n-\t      /* These structs are returned in r3. We pack the type and the\n-\t\t precalculated shift value (needed in the sysv.S) into flags.\n-\t\t The same applies for the structs returned in r3/r4.  */\n-\t      if (size <= 4)\n-\t\t{\n-\t\t  flags |= FLAG_SYSV_SMST_R3;\n-\t\t  flags |= 8 * (4 - size) << 8;\n-\t\t  break;\n-\t\t}\n-\t      /* These structs are returned in r3 and r4. See above.   */\n-\t      if  (size <= 8)\n-\t\t{\n-\t\t  flags |= FLAG_SYSV_SMST_R3 | FLAG_SYSV_SMST_R4;\n-\t\t  flags |= 8 * (8 - size) << 8;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-    byref:\n-#endif\n+      /*\n+       * The final SYSV ABI says that structures smaller or equal 8 bytes\n+       * are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them\n+       * in memory.\n+       *\n+       * NOTE: The assembly code can safely assume that it just needs to\n+       *       store both r3 and r4 into a 8-byte word-aligned buffer, as\n+       *       we allocate a temporary buffer in ffi_call() if this flag is\n+       *       set.\n+       */\n+      if (cif->abi == FFI_SYSV && size <= 8)\n+\tflags |= FLAG_RETURNS_SMST;\n       intarg_count++;\n       flags |= FLAG_RETVAL_REFERENCE;\n       /* Fall through.  */\n@@ -722,39 +717,36 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n        Stuff on the stack needs to keep proper alignment.  */\n     for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n       {\n-\tswitch ((*ptr)->type)\n-\t  {\n+\tunsigned short typenum = (*ptr)->type;\n+\n+\t/* We may need to handle some values depending on ABI */\n+\tif (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n+\t\tif (typenum == FFI_TYPE_FLOAT)\n+\t\t\ttypenum = FFI_TYPE_UINT32;\n+\t\tif (typenum == FFI_TYPE_DOUBLE)\n+\t\t\ttypenum = FFI_TYPE_UINT64;\n+\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n+\t\t\ttypenum = FFI_TYPE_UINT128;\n+\t} else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n+\t\t\ttypenum = FFI_TYPE_STRUCT;\n+#endif\n+\t}\n+\n+\tswitch (typenum) {\n+#ifndef __NO_FPRS__\n \t  case FFI_TYPE_FLOAT:\n-\t    /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */\n-\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t      goto soft_float_cif;\n \t    fparg_count++;\n \t    /* floating singles are not 8-aligned on stack */\n \t    break;\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \t  case FFI_TYPE_LONGDOUBLE:\n-\t    if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n-\t      goto do_struct;\n-\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t      {\n-\t\tif (intarg_count >= NUM_GPR_ARG_REGISTERS - 3\n-\t\t  || intarg_count < NUM_GPR_ARG_REGISTERS)\n-\t\t  /* A long double in FFI_LINUX_SOFT_FLOAT can use only\n-\t\t     a set of four consecutive gprs. If we have not enough,\n-\t\t     we have to adjust the intarg_count value.  */\n-\t\t  intarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;\n-\t\tintarg_count += 4;\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      fparg_count++;\n+\t    fparg_count++;\n \t    /* Fall thru */\n #endif\n \t  case FFI_TYPE_DOUBLE:\n-\t    /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */\n-\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t      goto soft_double_cif;\n \t    fparg_count++;\n \t    /* If this FP arg is going on the stack, it must be\n \t       8-byte-aligned.  */\n@@ -763,10 +755,21 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t\t&& intarg_count % 2 != 0)\n \t      intarg_count++;\n \t    break;\n+#endif\n+\t  case FFI_TYPE_UINT128:\n+\t\t/*\n+\t\t * A long double in FFI_LINUX_SOFT_FLOAT can use only a set\n+\t\t * of four consecutive gprs. If we do not have enough, we\n+\t\t * have to adjust the intarg_count value.\n+\t\t */\n+\t\tif (intarg_count >= NUM_GPR_ARG_REGISTERS - 3\n+\t\t\t\t&& intarg_count < NUM_GPR_ARG_REGISTERS)\n+\t\t\tintarg_count = NUM_GPR_ARG_REGISTERS;\n+\t\tintarg_count += 4;\n+\t\tbreak;\n \n \t  case FFI_TYPE_UINT64:\n \t  case FFI_TYPE_SINT64:\n-\t  soft_double_cif:\n \t    /* 'long long' arguments are passed as two words, but\n \t       either both words must fit in registers or both go\n \t       on the stack.  If they go on the stack, they must\n@@ -783,22 +786,27 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t    break;\n \n \t  case FFI_TYPE_STRUCT:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  do_struct:\n-#endif\n \t    /* We must allocate space for a copy of these to enforce\n \t       pass-by-value.  Pad the space up to a multiple of 16\n \t       bytes (the maximum alignment required for anything under\n \t       the SYSV ABI).  */\n \t    struct_copy_size += ((*ptr)->size + 15) & ~0xF;\n \t    /* Fall through (allocate space for the pointer).  */\n \n-\t  default:\n-\t  soft_float_cif:\n+\t  case FFI_TYPE_POINTER:\n+\t  case FFI_TYPE_INT:\n+\t  case FFI_TYPE_UINT32:\n+\t  case FFI_TYPE_SINT32:\n+\t  case FFI_TYPE_UINT16:\n+\t  case FFI_TYPE_SINT16:\n+\t  case FFI_TYPE_UINT8:\n+\t  case FFI_TYPE_SINT8:\n \t    /* Everything else is passed as a 4-byte word in a GPR, either\n \t       the object itself or a pointer to it.  */\n \t    intarg_count++;\n \t    break;\n+\t  default:\n+\t\tFFI_ASSERT (0);\n \t  }\n       }\n   else\n@@ -827,38 +835,57 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t    intarg_count += ((*ptr)->size + 7) / 8;\n \t    break;\n \n-\t  default:\n+\t  case FFI_TYPE_POINTER:\n+\t  case FFI_TYPE_UINT64:\n+\t  case FFI_TYPE_SINT64:\n+\t  case FFI_TYPE_INT:\n+\t  case FFI_TYPE_UINT32:\n+\t  case FFI_TYPE_SINT32:\n+\t  case FFI_TYPE_UINT16:\n+\t  case FFI_TYPE_SINT16:\n+\t  case FFI_TYPE_UINT8:\n+\t  case FFI_TYPE_SINT8:\n \t    /* Everything else is passed as a 8-byte word in a GPR, either\n \t       the object itself or a pointer to it.  */\n \t    intarg_count++;\n \t    break;\n+\t  default:\n+\t\tFFI_ASSERT (0);\n \t  }\n       }\n \n+#ifndef __NO_FPRS__\n   if (fparg_count != 0)\n     flags |= FLAG_FP_ARGUMENTS;\n+#endif\n   if (intarg_count > 4)\n     flags |= FLAG_4_GPR_ARGUMENTS;\n   if (struct_copy_size != 0)\n     flags |= FLAG_ARG_NEEDS_COPY;\n \n   if (cif->abi != FFI_LINUX64)\n     {\n+#ifndef __NO_FPRS__\n       /* Space for the FPR registers, if needed.  */\n       if (fparg_count != 0)\n \tbytes += NUM_FPR_ARG_REGISTERS * sizeof (double);\n+#endif\n \n       /* Stack space.  */\n       if (intarg_count > NUM_GPR_ARG_REGISTERS)\n \tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof (int);\n+#ifndef __NO_FPRS__\n       if (fparg_count > NUM_FPR_ARG_REGISTERS)\n \tbytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof (double);\n+#endif\n     }\n   else\n     {\n+#ifndef __NO_FPRS__\n       /* Space for the FPR registers, if needed.  */\n       if (fparg_count != 0)\n \tbytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);\n+#endif\n \n       /* Stack space.  */\n       if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n@@ -886,28 +913,41 @@ extern void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, unsigned long,\n void\n ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n+  /*\n+   * The final SYSV ABI says that structures smaller or equal 8 bytes\n+   * are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them\n+   * in memory.\n+   *\n+   * Just to keep things simple for the assembly code, we will always\n+   * bounce-buffer struct return values less than or equal to 8 bytes.\n+   * This allows the ASM to handle SYSV small structures by directly\n+   * writing r3 and r4 to memory without worrying about struct size.\n+   */\n+  unsigned int smst_buffer[2];\n   extended_cif ecif;\n+  unsigned int rsize;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n \n-  /* If the return value is a struct and we don't have a return\t*/\n-  /* value address then we need to make one\t\t        */\n-\n-  if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))\n-    {\n-      ecif.rvalue = alloca(cif->rtype->size);\n-    }\n-  else\n-    ecif.rvalue = rvalue;\n-\n+  /* Ensure that we have a valid struct return value */\n+  ecif.rvalue = rvalue;\n+  if (cif->rtype->type == FFI_TYPE_STRUCT) {\n+    rsize = cif->rtype->size;\n+    if (rsize <= 8)\n+      ecif.rvalue = smst_buffer;\n+    else if (!rvalue)\n+      ecif.rvalue = alloca(rsize);\n+  }\n \n   switch (cif->abi)\n     {\n #ifndef POWERPC64\n+# ifndef __NO_FPRS__\n     case FFI_SYSV:\n     case FFI_GCC_SYSV:\n     case FFI_LINUX:\n+# endif\n     case FFI_LINUX_SOFT_FLOAT:\n       ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n       break;\n@@ -920,6 +960,10 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n       FFI_ASSERT (0);\n       break;\n     }\n+\n+  /* Check for a bounce-buffered return value */\n+  if (rvalue && ecif.rvalue == smst_buffer)\n+    memcpy(rvalue, smst_buffer, rsize);\n }\n \n \n@@ -949,14 +993,19 @@ ffi_prep_closure_loc (ffi_closure *closure,\n #ifdef POWERPC64\n   void **tramp = (void **) &closure->tramp[0];\n \n-  FFI_ASSERT (cif->abi == FFI_LINUX64);\n+  if (cif->abi != FFI_LINUX64)\n+    return FFI_BAD_ABI;\n   /* Copy function address and TOC from ffi_closure_LINUX64.  */\n   memcpy (tramp, (char *) ffi_closure_LINUX64, 16);\n   tramp[2] = codeloc;\n #else\n   unsigned int *tramp;\n \n-  FFI_ASSERT (cif->abi == FFI_GCC_SYSV || cif->abi == FFI_SYSV);\n+  if (! (cif->abi == FFI_GCC_SYSV \n+\t || cif->abi == FFI_SYSV\n+\t || cif->abi == FFI_LINUX\n+\t || cif->abi == FFI_LINUX_SOFT_FLOAT))\n+    return FFI_BAD_ABI;\n \n   tramp = (unsigned int *) &closure->tramp[0];\n   tramp[0] = 0x7c0802a6;  /*   mflr    r0 */\n@@ -1011,32 +1060,38 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n   void **          avalue;\n   ffi_type **      arg_types;\n   long             i, avn;\n-  long             nf;   /* number of floating registers already used */\n-  long             ng;   /* number of general registers already used */\n-  ffi_cif *        cif;\n-  double           temp;\n-  unsigned         size;\n+#ifndef __NO_FPRS__\n+  long             nf = 0;   /* number of floating registers already used */\n+#endif\n+  long             ng = 0;   /* number of general registers already used */\n+\n+  ffi_cif *cif = closure->cif;\n+  unsigned       size     = cif->rtype->size;\n+  unsigned short rtypenum = cif->rtype->type;\n \n-  cif = closure->cif;\n   avalue = alloca (cif->nargs * sizeof (void *));\n-  size = cif->rtype->size;\n \n-  nf = 0;\n-  ng = 0;\n+  /* First translate for softfloat/nonlinux */\n+  if (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n+\tif (rtypenum == FFI_TYPE_FLOAT)\n+\t\trtypenum = FFI_TYPE_UINT32;\n+\tif (rtypenum == FFI_TYPE_DOUBLE)\n+\t\trtypenum = FFI_TYPE_UINT64;\n+\tif (rtypenum == FFI_TYPE_LONGDOUBLE)\n+\t\trtypenum = FFI_TYPE_UINT128;\n+  } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tif (rtypenum == FFI_TYPE_LONGDOUBLE)\n+\t\trtypenum = FFI_TYPE_STRUCT;\n+#endif\n+  }\n+\n \n   /* Copy the caller's structure return value address so that the closure\n      returns the data directly to the caller.\n      For FFI_SYSV the result is passed in r3/r4 if the struct size is less\n      or equal 8 bytes.  */\n-\n-  if ((cif->rtype->type == FFI_TYPE_STRUCT\n-       && !((cif->abi == FFI_SYSV) && (size <= 8)))\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-      || (cif->rtype->type == FFI_TYPE_LONGDOUBLE\n-\t  && cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n-#endif\n-      )\n-    {\n+  if (rtypenum == FFI_TYPE_STRUCT && ((cif->abi != FFI_SYSV) || (size > 8))) {\n       rvalue = (void *) *pgr;\n       ng++;\n       pgr++;\n@@ -1047,10 +1102,109 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n   arg_types = cif->arg_types;\n \n   /* Grab the addresses of the arguments from the stack frame.  */\n-  while (i < avn)\n-    {\n-      switch (arg_types[i]->type)\n-\t{\n+  while (i < avn) {\n+      unsigned short typenum = arg_types[i]->type;\n+\n+      /* We may need to handle some values depending on ABI */\n+      if (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n+\t\tif (typenum == FFI_TYPE_FLOAT)\n+\t\t\ttypenum = FFI_TYPE_UINT32;\n+\t\tif (typenum == FFI_TYPE_DOUBLE)\n+\t\t\ttypenum = FFI_TYPE_UINT64;\n+\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n+\t\t\ttypenum = FFI_TYPE_UINT128;\n+      } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n+\t\t\ttypenum = FFI_TYPE_STRUCT;\n+#endif\n+      }\n+\n+      switch (typenum) {\n+#ifndef __NO_FPRS__\n+\tcase FFI_TYPE_FLOAT:\n+\t  /* unfortunately float values are stored as doubles\n+\t   * in the ffi_closure_SYSV code (since we don't check\n+\t   * the type in that routine).\n+\t   */\n+\n+\t  /* there are 8 64bit floating point registers */\n+\n+\t  if (nf < 8)\n+\t    {\n+\t      temp = pfr->d;\n+\t      pfr->f = (float) temp;\n+\t      avalue[i] = pfr;\n+\t      nf++;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* FIXME? here we are really changing the values\n+\t       * stored in the original calling routines outgoing\n+\t       * parameter stack.  This is probably a really\n+\t       * naughty thing to do but...\n+\t       */\n+\t      avalue[i] = pst;\n+\t      pst += 1;\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  /* On the outgoing stack all values are aligned to 8 */\n+\t  /* there are 8 64bit floating point registers */\n+\n+\t  if (nf < 8)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      nf++;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (((long) pst) & 4)\n+\t\tpst++;\n+\t      avalue[i] = pst;\n+\t      pst += 2;\n+\t    }\n+\t  break;\n+\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if (nf < 7)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr += 2;\n+\t      nf += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (((long) pst) & 4)\n+\t\tpst++;\n+\t      avalue[i] = pst;\n+\t      pst += 4;\n+\t      nf = 8;\n+\t    }\n+\t  break;\n+#endif\n+#endif /* have FPRS */\n+\n+\tcase FFI_TYPE_UINT128:\n+\t\t/*\n+\t\t * Test if for the whole long double, 4 gprs are available.\n+\t\t * otherwise the stuff ends up on the stack.\n+\t\t */\n+\t\tif (ng < 5) {\n+\t\t\tavalue[i] = pgr;\n+\t\t\tpgr += 4;\n+\t\t\tng += 4;\n+\t\t} else {\n+\t\t\tavalue[i] = pst;\n+\t\t\tpst += 4;\n+\t\t\tng = 8+4;\n+\t\t}\n+\t\tbreak;\n+\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT8:\n \t  /* there are 8 gpr registers used to pass values */\n@@ -1086,7 +1240,6 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_POINTER:\n-\tsoft_float_closure:\n \t  /* there are 8 gpr registers used to pass values */\n \t  if (ng < 8)\n \t    {\n@@ -1102,9 +1255,6 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tdo_struct:\n-#endif\n \t  /* Structs are passed by reference. The address will appear in a\n \t     gpr if it is one of the first 8 arguments.  */\n \t  if (ng < 8)\n@@ -1122,7 +1272,6 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n-\tsoft_double_closure:\n \t  /* passing long long ints are complex, they must\n \t   * be passed in suitable register pairs such as\n \t   * (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)\n@@ -1154,99 +1303,8 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t    }\n \t  break;\n \n-\tcase FFI_TYPE_FLOAT:\n-\t  /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */\n-\t  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t    goto soft_float_closure;\n-\t  /* unfortunately float values are stored as doubles\n-\t   * in the ffi_closure_SYSV code (since we don't check\n-\t   * the type in that routine).\n-\t   */\n-\n-\t  /* there are 8 64bit floating point registers */\n-\n-\t  if (nf < 8)\n-\t    {\n-\t      temp = pfr->d;\n-\t      pfr->f = (float) temp;\n-\t      avalue[i] = pfr;\n-\t      nf++;\n-\t      pfr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* FIXME? here we are really changing the values\n-\t       * stored in the original calling routines outgoing\n-\t       * parameter stack.  This is probably a really\n-\t       * naughty thing to do but...\n-\t       */\n-\t      avalue[i] = pst;\n-\t      pst += 1;\n-\t    }\n-\t  break;\n-\n-\tcase FFI_TYPE_DOUBLE:\n-\t  /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */\n-\t  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t    goto soft_double_closure;\n-\t  /* On the outgoing stack all values are aligned to 8 */\n-\t  /* there are 8 64bit floating point registers */\n-\n-\t  if (nf < 8)\n-\t    {\n-\t      avalue[i] = pfr;\n-\t      nf++;\n-\t      pfr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (((long) pst) & 4)\n-\t\tpst++;\n-\t      avalue[i] = pst;\n-\t      pst += 2;\n-\t    }\n-\t  break;\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-\t  if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n-\t    goto do_struct;\n-\t  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t    { /* Test if for the whole long double, 4 gprs are available.\n-\t\t otherwise the stuff ends up on the stack.  */\n-\t      if (ng < 5)\n-\t\t{\n-\t\t  avalue[i] = pgr;\n-\t\t  pgr += 4;\n-\t\t  ng += 4;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  avalue[i] = pst;\n-\t\t  pst += 4;\n-\t\t  ng = 8;\n-\t\t}\n-\t      break;\n-\t    }\n-\t  if (nf < 7)\n-\t    {\n-\t      avalue[i] = pfr;\n-\t      pfr += 2;\n-\t      nf += 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (((long) pst) & 4)\n-\t\tpst++;\n-\t      avalue[i] = pst;\n-\t      pst += 4;\n-\t      nf = 8;\n-\t    }\n-\t  break;\n-#endif\n-\n \tdefault:\n-\t  FFI_ASSERT (0);\n+\t\tFFI_ASSERT (0);\n \t}\n \n       i++;\n@@ -1263,39 +1321,9 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n      already used and we never have a struct with size zero. That is the reason\n      for the subtraction of 1. See the comment in ffitarget.h about ordering.\n   */\n-  if (cif->abi == FFI_SYSV && cif->rtype->type == FFI_TYPE_STRUCT\n-      && size <= 8)\n+  if (cif->abi == FFI_SYSV && rtypenum == FFI_TYPE_STRUCT && size <= 8)\n     return (FFI_SYSV_TYPE_SMALL_STRUCT - 1) + size;\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-  else if (cif->rtype->type == FFI_TYPE_LONGDOUBLE\n-\t   && cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n-    return FFI_TYPE_STRUCT;\n-#endif\n-  /* With FFI_LINUX_SOFT_FLOAT floats and doubles are handled like UINT32\n-     respectivley UINT64.  */\n-  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-    {\n-      switch (cif->rtype->type)\n-\t{\n-\tcase FFI_TYPE_FLOAT:\n-\t  return FFI_TYPE_UINT32;\n-\t  break;\n-\tcase FFI_TYPE_DOUBLE:\n-\t  return FFI_TYPE_UINT64;\n-\t  break;\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-\t  return FFI_TYPE_UINT128;\n-\t  break;\n-#endif\n-\tdefault:\n-\t  return cif->rtype->type;\n-\t}\n-    }\n-  else\n-    {\n-      return cif->rtype->type;\n-    }\n+  return rtypenum;\n }\n \n int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,"}, {"sha": "3c9db495f49b6ea7840620caca7600fceabd3b5b", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,6 +1,8 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n-   Copyright (C) 2007, 2008, 2010 Free Software Foundation, Inc\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (C) 2007, 2008, 2010 Free Software Foundation, Inc\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n+\n    Target configuration macros for PowerPC.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -28,6 +30,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- System specific configurations ----------------------------------- */\n \n #if defined (POWERPC) && defined (__powerpc64__)\t/* linux64 */\n@@ -60,18 +66,14 @@ typedef enum ffi_abi {\n   FFI_LINUX64,\n   FFI_LINUX,\n   FFI_LINUX_SOFT_FLOAT,\n-# ifdef POWERPC64\n+# if defined(POWERPC64)\n   FFI_DEFAULT_ABI = FFI_LINUX64,\n-# else\n-#  if (!defined(__NO_FPRS__) && (__LDBL_MANT_DIG__ == 106))\n-  FFI_DEFAULT_ABI = FFI_LINUX,\n-#  else\n-#   ifdef __NO_FPRS__\n+# elif defined(__NO_FPRS__)\n   FFI_DEFAULT_ABI = FFI_LINUX_SOFT_FLOAT,\n-#   else\n+# elif (__LDBL_MANT_DIG__ == 106)\n+  FFI_DEFAULT_ABI = FFI_LINUX,\n+# else\n   FFI_DEFAULT_ABI = FFI_GCC_SYSV,\n-#   endif\n-#  endif\n # endif\n #endif\n "}, {"sha": "41fb8851b6242642603b131714afc3ed793c0c6c", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -122,22 +122,41 @@ ENTRY(ffi_closure_SYSV)\n \tblr\n \n # case FFI_TYPE_FLOAT\n+#ifndef __NO_FPRS__\n \tlfs %f1,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+#else\n+\tnop\n+\tnop\n+\tnop\n+#endif\n \tblr\n \n # case FFI_TYPE_DOUBLE\n+#ifndef __NO_FPRS__\n \tlfd %f1,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+#else\n+\tnop\n+\tnop\n+\tnop\n+#endif\n \tblr\n \n # case FFI_TYPE_LONGDOUBLE\n+#ifndef __NO_FPRS__\n \tlfd %f1,112+0(%r1)\n \tlfd %f2,112+8(%r1)\n \tmtlr %r0\n \tb .Lfinish\n+#else\n+\tnop\n+\tnop\n+\tnop\n+\tblr\n+#endif\n \n # case FFI_TYPE_UINT8\n \tlbz %r3,112+3(%r1)"}, {"sha": "675ed03eeb9667f8ff14aa659a00448f755d600e", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -83,6 +83,7 @@ ENTRY(ffi_call_SYSV)\n \tnop\n 1:\n \n+#ifndef __NO_FPRS__\n \t/* Load all the FP registers.  */\n \tbf-\t6,2f\n \tlfd\t%f1,-16-(8*4)-(8*8)(%r28)\n@@ -94,6 +95,7 @@ ENTRY(ffi_call_SYSV)\n \tlfd\t%f6,-16-(8*4)-(3*8)(%r28)\n \tlfd\t%f7,-16-(8*4)-(2*8)(%r28)\n \tlfd\t%f8,-16-(8*4)-(1*8)(%r28)\n+#endif\n 2:\n \n \t/* Make the call.  */\n@@ -103,7 +105,9 @@ ENTRY(ffi_call_SYSV)\n \tmtcrf\t0x01,%r31 /* cr7  */\n \tbt-\t31,L(small_struct_return_value)\n \tbt-\t30,L(done_return_value)\n+#ifndef __NO_FPRS__\n \tbt-\t29,L(fp_return_value)\n+#endif\n \tstw\t%r3,0(%r30)\n \tbf+\t28,L(done_return_value)\n \tstw\t%r4,4(%r30)\n@@ -124,6 +128,7 @@ L(done_return_value):\n \tlwz\t%r1,0(%r1)\n \tblr\n \n+#ifndef __NO_FPRS__\n L(fp_return_value):\n \tbf\t28,L(float_return_value)\n \tstfd\t%f1,0(%r30)\n@@ -134,21 +139,17 @@ L(fp_return_value):\n L(float_return_value):\n \tstfs\t%f1,0(%r30)\n \tb\tL(done_return_value)\n+#endif\n \n L(small_struct_return_value):\n-\textrwi\t%r6,%r31,2,19         /* number of bytes padding = shift/8 */\n-\tmtcrf\t0x02,%r31\t      /* copy flags to cr[24:27] (cr6) */\n-\textrwi\t%r5,%r31,5,19         /* r5 <- number of bits of padding */\n-\tsubfic  %r6,%r6,4             /* r6 <- number of useful bytes in r3 */\n-\tbf-\t25,L(done_return_value) /* struct in r3 ? if not, done. */\n-/* smst_one_register: */\n-\tslw\t%r3,%r3,%r5           /* Left-justify value in r3 */\n-\tmtxer\t%r6                   /* move byte count to XER ... */\n-\tstswx\t%r3,0,%r30            /* ... and store that many bytes */\n-\tbf+\t26,L(done_return_value)  /* struct in r3:r4 ? */\n-\tadd\t%r6,%r6,%r30          /* adjust pointer */\n-\tstswi\t%r4,%r6,4             /* store last four bytes */\n-\tb\tL(done_return_value)\n+\t/*\n+\t * The C code always allocates a properly-aligned 8-byte bounce\n+\t * buffer to make this assembly code very simple.  Just write out\n+\t * r3 and r4 to the buffer to allow the C code to handle the rest.\n+\t */\n+\tstw %r3, 0(%r30)\n+\tstw %r4, 4(%r30)\n+\tb L(done_return_value)\n \n .LFE1:\n END(ffi_call_SYSV)"}, {"sha": "eb6834199b1ca0a5c15a042bcab0433ecab63343", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   prep_cif.c - Copyright (c) 1996, 1998, 2007  Red Hat, Inc.\n+   prep_cif.c - Copyright (c) 2011, 2012  Anthony Green\n+                Copyright (c) 1996, 1998, 2007  Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -37,17 +38,21 @@ static ffi_status initialize_aggregate(ffi_type *arg)\n {\n   ffi_type **ptr;\n \n-  FFI_ASSERT(arg != NULL);\n+  if (UNLIKELY(arg == NULL || arg->elements == NULL))\n+    return FFI_BAD_TYPEDEF;\n \n-  FFI_ASSERT(arg->elements != NULL);\n-  FFI_ASSERT(arg->size == 0);\n-  FFI_ASSERT(arg->alignment == 0);\n+  arg->size = 0;\n+  arg->alignment = 0;\n \n   ptr = &(arg->elements[0]);\n \n+  if (UNLIKELY(ptr == 0))\n+    return FFI_BAD_TYPEDEF;\n+\n   while ((*ptr) != NULL)\n     {\n-      if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))\n+      if (UNLIKELY(((*ptr)->size == 0)\n+\t\t    && (initialize_aggregate((*ptr)) != FFI_OK)))\n \treturn FFI_BAD_TYPEDEF;\n \n       /* Perform a sanity check on the argument type */\n@@ -85,24 +90,38 @@ static ffi_status initialize_aggregate(ffi_type *arg)\n /* Perform machine independent ffi_cif preparation, then call\n    machine dependent routine. */\n \n-ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n-\t\t\tffi_type *rtype, ffi_type **atypes)\n+/* For non variadic functions isvariadic should be 0 and\n+   nfixedargs==ntotalargs.\n+\n+   For variadic calls, isvariadic should be 1 and nfixedargs\n+   and ntotalargs set as appropriate. nfixedargs must always be >=1 */\n+\n+\n+ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n+\t\t\t     unsigned int isvariadic,\n+                             unsigned int nfixedargs,\n+                             unsigned int ntotalargs,\n+\t\t\t     ffi_type *rtype, ffi_type **atypes)\n {\n   unsigned bytes = 0;\n   unsigned int i;\n   ffi_type **ptr;\n \n   FFI_ASSERT(cif != NULL);\n+  FFI_ASSERT((!isvariadic) || (nfixedargs >= 1));\n+  FFI_ASSERT(nfixedargs <= ntotalargs);\n+\n #ifndef X86_WIN32\n-  FFI_ASSERT((abi > FFI_FIRST_ABI) && (abi <= FFI_DEFAULT_ABI));\n+  if (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI))\n+    return FFI_BAD_ABI;\n #else\n-  FFI_ASSERT(abi > FFI_FIRST_ABI && abi <= FFI_DEFAULT_ABI\n-\t     || abi == FFI_THISCALL);\n+  if (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI || abi == FFI_THISCALL))\n+    return FFI_BAD_ABI;\n #endif\n \n   cif->abi = abi;\n   cif->arg_types = atypes;\n-  cif->nargs = nargs;\n+  cif->nargs = ntotalargs;\n   cif->rtype = rtype;\n \n   cif->flags = 0;\n@@ -115,7 +134,7 @@ ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n   FFI_ASSERT_VALID_TYPE(cif->rtype);\n \n   /* x86, x86-64 and s390 stack space allocation is handled in prep_machdep. */\n-#if !defined M68K && !defined __i386__ && !defined __x86_64__ && !defined S390 && !defined PA\n+#if !defined M68K && !defined X86_ANY && !defined S390 && !defined PA\n   /* Make space for the return structure pointer */\n   if (cif->rtype->type == FFI_TYPE_STRUCT\n #ifdef SPARC\n@@ -136,7 +155,7 @@ ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n \t check after the initialization.  */\n       FFI_ASSERT_VALID_TYPE(*ptr);\n \n-#if !defined __i386__ && !defined __x86_64__ && !defined S390 && !defined PA\n+#if !defined X86_ANY && !defined S390 && !defined PA\n #ifdef SPARC\n       if (((*ptr)->type == FFI_TYPE_STRUCT\n \t   && ((*ptr)->size > 16 || cif->abi != FFI_V9))\n@@ -158,10 +177,31 @@ ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n   cif->bytes = bytes;\n \n   /* Perform machine dependent cif processing */\n+#ifdef FFI_TARGET_SPECIFIC_VARIADIC\n+  if (isvariadic)\n+\treturn ffi_prep_cif_machdep_var(cif, nfixedargs, ntotalargs);\n+#endif\n+\n   return ffi_prep_cif_machdep(cif);\n }\n #endif /* not __CRIS__ */\n \n+ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n+\t\t\t     ffi_type *rtype, ffi_type **atypes)\n+{\n+  return ffi_prep_cif_core(cif, abi, 0, nargs, nargs, rtype, atypes);\n+}\n+\n+ffi_status ffi_prep_cif_var(ffi_cif *cif,\n+                            ffi_abi abi,\n+                            unsigned int nfixedargs,\n+                            unsigned int ntotalargs,\n+                            ffi_type *rtype,\n+                            ffi_type **atypes)\n+{\n+  return ffi_prep_cif_core(cif, abi, 1, nfixedargs, ntotalargs, rtype, atypes);\n+}\n+\n #if FFI_CLOSURES\n \n ffi_status"}, {"sha": "97fa5c4b671d63bee85654d2f4ca97e149645ba5", "filename": "libffi/src/s390/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fs390%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fs390%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for S390.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n #if defined (__s390x__)\n #ifndef S390X\n #define S390X\n@@ -42,8 +47,8 @@ typedef signed long            ffi_sarg;\n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_SYSV,\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n } ffi_abi;\n #endif\n "}, {"sha": "a36bf4207046d74f53f92de4ce19eeb469321287", "filename": "libffi/src/sh/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsh%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsh%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012 Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for SuperH.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- Generic type definitions ----------------------------------------- */\n \n #ifndef LIBFFI_ASM\n@@ -36,8 +41,8 @@ typedef signed long            ffi_sarg;\n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_SYSV,\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n } ffi_abi;\n #endif\n "}, {"sha": "08a6fe96cc71d72e8d7d1daeb3677c607ca28fd2", "filename": "libffi/src/sh64/ffitarget.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsh64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsh64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh64%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for SuperH - SHmedia.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- Generic type definitions ----------------------------------------- */\n \n #ifndef LIBFFI_ASM\n@@ -36,8 +41,8 @@ typedef signed long            ffi_sarg;\n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_SYSV,\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n } ffi_abi;\n \n #define FFI_EXTRA_CIF_FIELDS long long flags2"}, {"sha": "1ac5d464e8b992770dfe1f90b685f0eb5ba7cdf6", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996, 2003, 2004, 2007, 2008 Red Hat, Inc.\n+   ffi.c - Copyright (c) 2011 Anthony Green\n+           Copyright (c) 1996, 2003-2004, 2007-2008 Red Hat, Inc.\n    \n    SPARC Foreign Function Interface \n \n@@ -406,8 +407,50 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n       /* We don't yet support calling 32bit code from 64bit */\n       FFI_ASSERT(0);\n #else\n-      ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes, \n-\t\t  cif->flags, rvalue, fn);\n+      if (rvalue && (cif->rtype->type == FFI_TYPE_STRUCT\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t  || cif->flags == FFI_TYPE_LONGDOUBLE\n+#endif\n+\t  ))\n+\t{\n+\t  /* For v8, we need an \"unimp\" with size of returning struct */\n+\t  /* behind \"call\", so we alloc some executable space for it. */\n+\t  /* l7 is used, we need to make sure v8.S doesn't use %l7.   */\n+\t  unsigned int *call_struct = NULL;\n+\t  ffi_closure_alloc(32, &call_struct);\n+\t  if (call_struct)\n+\t    {\n+\t      unsigned long f = (unsigned long)fn;\n+\t      call_struct[0] = 0xae10001f;\t\t /* mov   %i7, %l7\t */\n+\t      call_struct[1] = 0xbe10000f;\t\t /* mov   %o7, %i7\t */\n+\t      call_struct[2] = 0x03000000 | f >> 10;     /* sethi %hi(fn), %g1\t */\n+\t      call_struct[3] = 0x9fc06000 | (f & 0x3ff); /* jmp %g1+%lo(fn), %o7 */\n+\t      call_struct[4] = 0x01000000;\t\t /* nop\t\t\t */\n+\t      if (cif->rtype->size < 0x7f)\n+\t\tcall_struct[5] = cif->rtype->size;\t /* unimp\t\t */\n+\t      else\n+\t\tcall_struct[5] = 0x01000000;\t     \t /* nop\t\t\t */\n+\t      call_struct[6] = 0x81c7e008;\t\t /* ret\t\t\t */\n+\t      call_struct[7] = 0xbe100017;\t\t /* mov   %l7, %i7\t */\n+\t      asm volatile (\"iflush %0; iflush %0+8; iflush %0+16; iflush %0+24\" : :\n+\t\t\t    \"r\" (call_struct) : \"memory\");\n+\t      /* SPARC v8 requires 5 instructions for flush to be visible */\n+\t      asm volatile (\"nop; nop; nop; nop; nop\");\n+\t      ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes,\n+\t\t\t  cif->flags, rvalue, call_struct);\n+\t      ffi_closure_free(call_struct);\n+\t    }\n+\t  else\n+\t    {\n+\t      ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes,\n+\t\t\t  cif->flags, rvalue, fn);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes,\n+\t\t      cif->flags, rvalue, fn);\n+\t}\n #endif\n       break;\n     case FFI_V9:\n@@ -425,7 +468,6 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n       FFI_ASSERT(0);\n       break;\n     }\n-\n }\n \n \n@@ -447,7 +489,8 @@ ffi_prep_closure_loc (ffi_closure* closure,\n #ifdef SPARC64\n   /* Trampoline address is equal to the closure address.  We take advantage\n      of that to reduce the trampoline size by 8 bytes. */\n-  FFI_ASSERT (cif->abi == FFI_V9);\n+  if (cif->abi != FFI_V9)\n+    return FFI_BAD_ABI;\n   fn = (unsigned long) ffi_closure_v9;\n   tramp[0] = 0x83414000;\t/* rd\t%pc, %g1\t*/\n   tramp[1] = 0xca586010;\t/* ldx\t[%g1+16], %g5\t*/\n@@ -456,7 +499,8 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   *((unsigned long *) &tramp[4]) = fn;\n #else\n   unsigned long ctx = (unsigned long) codeloc;\n-  FFI_ASSERT (cif->abi == FFI_V8);\n+  if (cif->abi != FFI_V8)\n+    return FFI_BAD_ABI;\n   fn = (unsigned long) ffi_closure_v8;\n   tramp[0] = 0x03000000 | fn >> 10;\t/* sethi %hi(fn), %g1\t*/\n   tramp[1] = 0x05000000 | ctx >> 10;\t/* sethi %hi(ctx), %g2\t*/\n@@ -468,13 +512,13 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   closure->fun = fun;\n   closure->user_data = user_data;\n \n-  /* Flush the Icache.  FIXME: alignment isn't certain, assume 8 bytes */\n+  /* Flush the Icache.  closure is 8 bytes aligned.  */\n #ifdef SPARC64\n-  asm volatile (\"flush\t%0\" : : \"r\" (closure) : \"memory\");\n-  asm volatile (\"flush\t%0\" : : \"r\" (((char *) closure) + 8) : \"memory\");\n+  asm volatile (\"flush\t%0; flush %0+8\" : : \"r\" (closure) : \"memory\");\n #else\n-  asm volatile (\"iflush\t%0\" : : \"r\" (closure) : \"memory\");\n-  asm volatile (\"iflush\t%0\" : : \"r\" (((char *) closure) + 8) : \"memory\");\n+  asm volatile (\"iflush\t%0; iflush %0+8\" : : \"r\" (closure) : \"memory\");\n+  /* SPARC v8 requires 5 instructions for flush to be visible */\n+  asm volatile (\"nop; nop; nop; nop; nop\");\n #endif\n \n   return FFI_OK;"}, {"sha": "d89f7877a815090609883a410defb7cbd6bb12f3", "filename": "libffi/src/sparc/ffitarget.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsparc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsparc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for SPARC.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,6 +28,10 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- System specific configurations ----------------------------------- */\n \n #if defined(__arch64__) || defined(__sparcv9)\n@@ -44,12 +49,12 @@ typedef enum ffi_abi {\n   FFI_V8,\n   FFI_V8PLUS,\n   FFI_V9,\n+  FFI_LAST_ABI,\n #ifdef SPARC64\n-  FFI_DEFAULT_ABI = FFI_V9,\n+  FFI_DEFAULT_ABI = FFI_V9\n #else\n-  FFI_DEFAULT_ABI = FFI_V8,\n+  FFI_DEFAULT_ABI = FFI_V8\n #endif\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n } ffi_abi;\n #endif\n "}, {"sha": "489ff0293f2f90896f4f63c9781917436b8e92db", "filename": "libffi/src/sparc/v9.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsparc%2Fv9.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fsparc%2Fv9.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv9.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -32,7 +32,7 @@\n /* Only compile this in for 64bit builds, because otherwise the object file\n    will have inproper architecture due to used instructions.  */\n \n-#define STACKFRAME 176\t\t/* Minimum stack framesize for SPARC 64-bit */\n+#define STACKFRAME 128\t\t/* Minimum stack framesize for SPARC */\n #define STACK_BIAS 2047\n #define ARGS (128)\t\t/* Offset of register area in frame */\n "}, {"sha": "9343c26072890048b7727bfaaaa0fecc1bd009f9", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 7, "deletions": 43, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -228,12 +228,10 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   switch (cif->rtype->type)\n     {\n     case FFI_TYPE_VOID:\n-#if defined(X86) || defined (X86_WIN32) || defined(X86_FREEBSD) || defined(X86_DARWIN) || defined(X86_WIN64)\n     case FFI_TYPE_UINT8:\n     case FFI_TYPE_UINT16:\n     case FFI_TYPE_SINT8:\n     case FFI_TYPE_SINT16:\n-#endif\n #ifdef X86_WIN64\n     case FFI_TYPE_UINT32:\n     case FFI_TYPE_SINT32:\n@@ -364,27 +362,8 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     {\n #ifdef X86_WIN64\n     case FFI_WIN64:\n-      {\n-        /* Make copies of all struct arguments\n-           NOTE: not sure if responsibility should be here or in caller */\n-        unsigned int i;\n-        for (i=0; i < cif->nargs;i++) {\n-          size_t size = cif->arg_types[i]->size;\n-          if ((cif->arg_types[i]->type == FFI_TYPE_STRUCT\n-               && (size != 1 && size != 2 && size != 4 && size != 8))\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-              || cif->arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n-#endif\n-              )\n-            {\n-              void *local = alloca(size);\n-              memcpy(local, avalue[i], size);\n-              avalue[i] = local;\n-            }\n-        }\n-        ffi_call_win64(ffi_prep_args, &ecif, cif->bytes,\n-                       cif->flags, ecif.rvalue, fn);\n-      }\n+      ffi_call_win64(ffi_prep_args, &ecif, cif->bytes,\n+                     cif->flags, ecif.rvalue, fn);\n       break;\n #elif defined(X86_WIN32)\n     case FFI_SYSV:\n@@ -447,8 +426,6 @@ unsigned int FFI_HIDDEN ffi_closure_SYSV_inner (ffi_closure *, void **, void *)\n void FFI_HIDDEN ffi_closure_raw_SYSV (ffi_raw_closure *)\n      __attribute__ ((regparm(1)));\n #ifdef X86_WIN32\n-void FFI_HIDDEN ffi_closure_raw_THISCALL (ffi_raw_closure *)\n-     __attribute__ ((regparm(1)));\n void FFI_HIDDEN ffi_closure_STDCALL (ffi_closure *)\n      __attribute__ ((regparm(1)));\n void FFI_HIDDEN ffi_closure_THISCALL (ffi_closure *)\n@@ -616,7 +593,7 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n { unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n    unsigned int  __fun = (unsigned int)(FUN); \\\n    unsigned int  __ctx = (unsigned int)(CTX); \\\n-   unsigned int  __dis = __fun - (__ctx + 49);  \\\n+   unsigned int  __dis = __fun - (__ctx + 22);  \\\n    unsigned short __size = (unsigned short)(SIZE); \\\n    *(unsigned int *) &__tramp[0] = 0x8324048b;\t/* mov (%esp), %eax */ \\\n    *(unsigned int *) &__tramp[4] = 0x4c890cec;\t/* sub $12, %esp */ \\\n@@ -722,9 +699,6 @@ ffi_prep_raw_closure_loc (ffi_raw_closure* closure,\n   int i;\n \n   if (cif->abi != FFI_SYSV) {\n-#ifdef X86_WIN32\n-    if (cif->abi != FFI_THISCALL)\n-#endif\n     return FFI_BAD_ABI;\n   }\n \n@@ -739,20 +713,10 @@ ffi_prep_raw_closure_loc (ffi_raw_closure* closure,\n       FFI_ASSERT (cif->arg_types[i]->type != FFI_TYPE_LONGDOUBLE);\n     }\n   \n-#ifdef X86_WIN32\n-  if (cif->abi == FFI_SYSV)\n-    {\n-#endif\n+\n   FFI_INIT_TRAMPOLINE (&closure->tramp[0], &ffi_closure_raw_SYSV,\n                        codeloc);\n-#ifdef X86_WIN32\n-    }\n-  else if (cif->abi == FFI_THISCALL)\n-    {\n-      FFI_INIT_TRAMPOLINE_THISCALL (&closure->tramp[0], &ffi_closure_raw_THISCALL,\n-\t\t\t\t    codeloc, cif->bytes);\n-    }\n-#endif\n+    \n   closure->cif  = cif;\n   closure->user_data = user_data;\n   closure->fun  = fun;\n@@ -797,7 +761,7 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n #ifdef X86_WIN32\n     case FFI_SYSV:\n     case FFI_STDCALL:\n-      ffi_call_win32(ffi_prep_args_raw, &ecif, cif->abi, cif->bytes, cif->flags,\n+      ffi_call_win32(ffi_prep_args, &ecif, cif->abi, cif->bytes, cif->flags,\n \t\t     ecif.rvalue, fn);\n       break;\n     case FFI_THISCALL:\n@@ -825,7 +789,7 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n \t  cif->abi = abi = FFI_THISCALL;\n \tif (passed_regs < 1 && abi == FFI_THISCALL)\n \t  cif->abi = abi = FFI_STDCALL;\n-        ffi_call_win32(ffi_prep_args_raw, &ecif, abi, cif->bytes, cif->flags,\n+        ffi_call_win32(ffi_prep_args, &ecif, abi, cif->bytes, cif->flags,\n                        ecif.rvalue, fn);\n       }\n       break;"}, {"sha": "defd7744cce09b7d1bb59ee5019c5fa96fb72203", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,7 +1,8 @@\n /* -----------------------------------------------------------------------\n-   ffi64.c - Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>\n+   ffi64.c - Copyright (c) 20011  Anthony Green\n              Copyright (c) 2008, 2010  Red Hat, Inc.\n-   \n+             Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>\n+             \n    x86-64 Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -426,7 +427,7 @@ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n   /* If the return value is passed in memory, add the pointer as the\n      first integer argument.  */\n   if (ret_in_memory)\n-    reg_args->gpr[gprcount++] = (long) rvalue;\n+    reg_args->gpr[gprcount++] = (unsigned long) rvalue;\n \n   avn = cif->nargs;\n   arg_types = cif->arg_types;\n@@ -498,12 +499,21 @@ ffi_prep_closure_loc (ffi_closure* closure,\n {\n   volatile unsigned short *tramp;\n \n+  /* Sanity check on the cif ABI.  */\n+  {\n+    int abi = cif->abi;\n+    if (UNLIKELY (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI)))\n+      return FFI_BAD_ABI;\n+  }\n+\n   tramp = (volatile unsigned short *) &closure->tramp[0];\n \n   tramp[0] = 0xbb49;\t\t/* mov <code>, %r11\t*/\n-  *(void * volatile *) &tramp[1] = ffi_closure_unix64;\n+  *((unsigned long long * volatile) &tramp[1])\n+    = (unsigned long) ffi_closure_unix64;\n   tramp[5] = 0xba49;\t\t/* mov <data>, %r10\t*/\n-  *(void * volatile *) &tramp[6] = codeloc;\n+  *((unsigned long long * volatile) &tramp[6])\n+    = (unsigned long) codeloc;\n \n   /* Set the carry bit iff the function uses any sse registers.\n      This is clc or stc, together with the first byte of the jmp.  */\n@@ -542,7 +552,7 @@ ffi_closure_unix64_inner(ffi_closure *closure, void *rvalue,\n \t{\n \t  /* The return value goes in memory.  Arrange for the closure\n \t     return value to go directly back to the original caller.  */\n-\t  rvalue = (void *) reg_args->gpr[gprcount++];\n+\t  rvalue = (void *) (unsigned long) reg_args->gpr[gprcount++];\n \t  /* We don't have to do anything in asm for the return.  */\n \t  ret = FFI_TYPE_VOID;\n \t}"}, {"sha": "54a61212e4f9a9a03470810503ecec7d0239d114", "filename": "libffi/src/x86/ffitarget.h", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffitarget.h?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 1996-2003, 2010  Red Hat, Inc.\n-   Copyright (C) 2008  Free Software Foundation, Inc.\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 1996-2003, 2010  Red Hat, Inc.\n+                 Copyright (C) 2008  Free Software Foundation, Inc.\n \n    Target configuration macros for x86 and x86-64.\n \n@@ -29,8 +30,15 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n /* ---- System specific configurations ----------------------------------- */\n \n+/* For code common to all platforms on x86 and x86_64. */\n+#define X86_ANY\n+\n #if defined (X86_64) && defined (__i386__)\n #undef X86_64\n #define X86\n@@ -53,9 +61,15 @@ typedef unsigned long long     ffi_arg;\n typedef long long              ffi_sarg;\n #endif\n #else\n+#if defined __x86_64__ && !defined __LP64__\n+#define FFI_SIZEOF_ARG 8\n+typedef unsigned long long     ffi_arg;\n+typedef long long              ffi_sarg;\n+#else\n typedef unsigned long          ffi_arg;\n typedef signed long            ffi_sarg;\n #endif\n+#endif\n \n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n@@ -66,28 +80,26 @@ typedef enum ffi_abi {\n   FFI_STDCALL,\n   FFI_THISCALL,\n   FFI_FASTCALL,\n+  FFI_LAST_ABI,\n   /* TODO: Add fastcall support for the sake of completeness */\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n-#endif\n+  FFI_DEFAULT_ABI = FFI_SYSV\n \n-#ifdef X86_WIN64\n+#elif defined(X86_WIN64)\n   FFI_WIN64,\n-  FFI_DEFAULT_ABI = FFI_WIN64,\n-#else\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_WIN64\n \n+#else\n   /* ---- Intel x86 and AMD x86-64 - */\n-#if !defined(X86_WIN32) && (defined(__i386__) || defined(__x86_64__) || defined(__i386) || defined(__amd64))\n   FFI_SYSV,\n   FFI_UNIX64,   /* Unix variants all use the same ABI for x86-64  */\n+  FFI_LAST_ABI,\n #if defined(__i386__) || defined(__i386)\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n #else\n-  FFI_DEFAULT_ABI = FFI_UNIX64,\n+  FFI_DEFAULT_ABI = FFI_UNIX64\n #endif\n #endif\n-#endif /* X86_WIN64 */\n-\n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n } ffi_abi;\n #endif\n "}, {"sha": "e5c93ecf7b95002070aa3dafd79adac9ef0e08b4", "filename": "libffi/src/x86/win32.S", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fwin32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fwin32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin32.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -264,18 +264,6 @@ ffi_closure_SYSV ENDP\n #define RAW_CLOSURE_USER_DATA_OFFSET (RAW_CLOSURE_FUN_OFFSET + 4)\n #define CIF_FLAGS_OFFSET 20\n \n-ffi_closure_raw_THISCALL PROC NEAR\n-\tpush ebp\n-\tmov  ebp, esp\n-\tpush esi\n-\tsub esp, 36\n-\tmov  esi, [eax + RAW_CLOSURE_CIF_OFFSET]        ;; closure->cif\n-\tmov  edx, [eax + RAW_CLOSURE_USER_DATA_OFFSET]  ;; closure->user_data\n-\tmov [esp + 12], edx\n-\tlea edx, [ebp + 12], edx\n-\tjmp stubraw\n-ffi_closure_raw_SYSV ENDP\n-\n ffi_closure_raw_SYSV PROC NEAR USES esi\n     ;; the ffi_closure ctx is passed in eax by the trampoline.\n \n@@ -284,7 +272,6 @@ ffi_closure_raw_SYSV PROC NEAR USES esi\n         mov  edx, [eax + RAW_CLOSURE_USER_DATA_OFFSET]  ;; closure->user_data\n         mov  [esp + 12], edx                            ;; user_data\n         lea  edx, [ebp + 8]\n-stubraw:\n         mov  [esp + 8], edx                             ;; raw_args\n         lea  edx, [ebp - 24]\n         mov  [esp + 4], edx                             ;; &res\n@@ -735,21 +722,7 @@ _ffi_closure_SYSV:\n #define RAW_CLOSURE_FUN_OFFSET (RAW_CLOSURE_CIF_OFFSET + 4)\n #define RAW_CLOSURE_USER_DATA_OFFSET (RAW_CLOSURE_FUN_OFFSET + 4)\n #define CIF_FLAGS_OFFSET 20\n-        .balign 16\n-\t.globl\t_ffi_closure_raw_THISCALL\n-#ifndef __OS2__\n-\t.def\t_ffi_closure_raw_THISCALL;\t.scl\t2;\t.type\t32;\t.endef\n-#endif\n-_ffi_closure_raw_THISCALL:\n-\tpushl\t%ebp\n-\tmovl\t%esp, %ebp\n-\tpushl\t%esi\n-\tsubl\t$36, %esp\n-\tmovl\tRAW_CLOSURE_CIF_OFFSET(%eax), %esi\t /* closure->cif */\n-\tmovl\tRAW_CLOSURE_USER_DATA_OFFSET(%eax), %edx /* closure->user_data */\n-\tmovl\t%edx, 12(%esp)\t/* user_data */\n-\tleal\t12(%ebp), %edx\t/* __builtin_dwarf_cfa () */\n-\tjmp\t.stubraw\n+\n         # This assumes we are using gas.\n         .balign 16\n \t.globl\t_ffi_closure_raw_SYSV\n@@ -769,7 +742,6 @@ _ffi_closure_raw_SYSV:\n \tmovl\tRAW_CLOSURE_USER_DATA_OFFSET(%eax), %edx /* closure->user_data */\n \tmovl\t%edx, 12(%esp)\t/* user_data */\n \tleal\t8(%ebp), %edx\t/* __builtin_dwarf_cfa () */\n-.stubraw:\n \tmovl\t%edx, 8(%esp)\t/* raw_args */\n \tleal\t-24(%ebp), %edx\n \tmovl\t%edx, 4(%esp)\t/* &res */"}, {"sha": "fcdb270faf587743626a9a65aa0cf25ea79205f1", "filename": "libffi/src/x86/win64.S", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fwin64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Fsrc%2Fx86%2Fwin64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin64.S?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -232,10 +232,18 @@ ret_void$:\n ffi_call_win64 ENDP\n _TEXT\tENDS\n END\n-#else        \n+\n+#else\n+\n+#ifdef SYMBOL_UNDERSCORE\n+#define SYMBOL_NAME(name) _##name\n+#else\n+#define SYMBOL_NAME(name) name\n+#endif\n+\n .text\n \n-.extern _ffi_closure_win64_inner\n+.extern SYMBOL_NAME(ffi_closure_win64_inner)\n \n # ffi_closure_win64 will be called with these registers set:\n #    rax points to 'closure'\n@@ -246,8 +254,8 @@ END\n # call ffi_closure_win64_inner for the actual work, then return the result.\n # \n \t.balign 16\n-        .globl _ffi_closure_win64\t\n-_ffi_closure_win64:     \n+        .globl SYMBOL_NAME(ffi_closure_win64)\n+SYMBOL_NAME(ffi_closure_win64):\n \t# copy register arguments onto stack\n \ttest\t$1,%r11\n \tjne\t.Lfirst_is_float\t\n@@ -287,7 +295,7 @@ _ffi_closure_win64:\n \tmov\t%rax, %rcx\t# context is first parameter\n \tmov\t%rsp, %rdx\t# stack is second parameter\n \tadd\t$48, %rdx\t# point to start of arguments\n-\tmov\t$_ffi_closure_win64_inner, %rax\n+\tmov\t$SYMBOL_NAME(ffi_closure_win64_inner), %rax\n \tcallq\t*%rax\t\t# call the real closure function\n \tadd\t$40, %rsp\n \tmovq\t%rax, %xmm0\t# If the closure returned a float,\n@@ -296,8 +304,8 @@ _ffi_closure_win64:\n .ffi_closure_win64_end:\n \n \t.balign 16\n-        .globl\t_ffi_call_win64\n-_ffi_call_win64:        \n+        .globl\tSYMBOL_NAME(ffi_call_win64)\n+SYMBOL_NAME(ffi_call_win64):\n         # copy registers onto stack\n \tmov\t%r9,32(%rsp)\n \tmov\t%r8,24(%rsp)"}, {"sha": "67e44a4ed3d5667ba40db41d18992bd5c2523ca7", "filename": "libffi/testsuite/libffi.call/cls_double_va.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -37,7 +37,8 @@ int main (void)\n \targ_types[1] = &ffi_type_double;\n \targ_types[2] = NULL;\n \n-\tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_sint,\n+\t/* This printf call is variadic */\n+\tCHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2, &ffi_type_sint,\n \t\targ_types) == FFI_OK);\n \n \targs[0] = &format;\n@@ -49,6 +50,9 @@ int main (void)\n \tprintf(\"res: %d\\n\", (int) res);\n \t// { dg-output \"\\nres: 4\" }\n \n+\t/* The call to cls_double_va_fn is static, so have to use a normal prep_cif */\n+\tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_sint, arg_types) == FFI_OK);\n+\n \tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_double_va_fn, NULL, code) == FFI_OK);\n \n \tres\t= ((int(*)(char*, double))(code))(format, doubleArg);"}, {"sha": "6b8484a8595d5db5359a218dee10ff45f8f0d405", "filename": "libffi/testsuite/libffi.call/cls_longdouble_va.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -37,7 +37,8 @@ int main (void)\n \targ_types[1] = &ffi_type_longdouble;\n \targ_types[2] = NULL;\n \n-\tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_sint,\n+\t/* This printf call is variadic */\n+\tCHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2, &ffi_type_sint,\n \t\targ_types) == FFI_OK);\n \n \targs[0] = &format;\n@@ -49,6 +50,10 @@ int main (void)\n \tprintf(\"res: %d\\n\", (int) res);\n \t// { dg-output \"\\nres: 4\" }\n \n+\t/* The call to cls_longdouble_va_fn is static, so have to use a normal prep_cif */\n+\tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_sint,\n+\t\targ_types) == FFI_OK);\n+\n \tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_longdouble_va_fn, NULL, code) == FFI_OK);\n \n \tres\t= ((int(*)(char*, long double))(code))(format, ldArg);"}, {"sha": "f5a73179ec96a345cc3f9f6199c54cdcb33941c0", "filename": "libffi/testsuite/libffi.call/err_bad_abi.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_abi.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -4,7 +4,8 @@\n    PR:\t\t\tnone.\n    Originator:\tBlake Chaffin 6/6/2007\t */\n \n-/* { dg-do run { xfail *-*-* } } */\n+/* { dg-do run } */\n+\n #include \"ffitest.h\"\n \n static void"}, {"sha": "253927392d34cb4677f80c46c9f689556ef2602a", "filename": "libffi/testsuite/libffi.call/err_bad_typedef.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -4,7 +4,8 @@\n    PR:\t\t\tnone.\n    Originator:\tBlake Chaffin 6/6/2007\t */\n \n-/* { dg-do run { xfail *-*-* } } */\n+/* { dg-do run } */\n+\n #include \"ffitest.h\"\n \n int main (void)"}, {"sha": "2039ae547919abf0b9ae599163368f4614d38bad", "filename": "libffi/testsuite/libffi.call/float_va.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -0,0 +1,107 @@\n+/* Area:        fp and variadics\n+   Purpose:     check fp inputs and returns work on variadics, even the fixed params\n+   Limitations: None\n+   PR:          none\n+   Originator:  <david.gilbert@linaro.org> 2011-01-25\n+\n+   Intended to stress the difference in ABI on ARM vfp\n+*/\n+\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+\n+#include \"ffitest.h\"\n+\n+/* prints out all the parameters, and returns the sum of them all.\n+ * 'x' is the number of variadic parameters all of which are double in this test\n+ */\n+double float_va_fn(unsigned int x, double y,...)\n+{\n+  double total=0.0;\n+  va_list ap;\n+  unsigned int i;\n+\n+  total+=(double)x;\n+  total+=y;\n+\n+  printf(\"%u: %.1lf :\", x, y);\n+\n+  va_start(ap, y);\n+  for(i=0;i<x;i++)\n+  {\n+    double arg=va_arg(ap, double);\n+    total+=arg;\n+    printf(\" %d:%.1lf \", i, arg);\n+  }\n+  va_end(ap);\n+\n+  printf(\" total: %.1lf\\n\", total);\n+\n+  return total;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif    cif;\n+\n+  ffi_type    *arg_types[5];\n+  void        *values[5];\n+  double        doubles[5];\n+  unsigned int firstarg;\n+  double        resfp;\n+\n+  /* First test, pass float_va_fn(0,2.0) - note there are no actual\n+   * variadic parameters, but it's declared variadic so the ABI may be\n+   * different. */\n+  /* Call it statically and then via ffi */\n+  resfp=float_va_fn(0,2.0);\n+  // { dg-output \"0: 2.0 : total: 2.0\" }\n+  printf(\"compiled: %.1lf\\n\", resfp);\n+  // { dg-output \"\\ncompiled: 2.0\" }\n+\n+  arg_types[0] = &ffi_type_uint;\n+  arg_types[1] = &ffi_type_double;\n+  arg_types[2] = NULL;\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 2, 2,\n+        &ffi_type_double, arg_types) == FFI_OK);\n+\n+  firstarg = 0;\n+  doubles[0] = 2.0;\n+  values[0] = &firstarg;\n+  values[1] = &doubles[0];\n+  ffi_call(&cif, FFI_FN(float_va_fn), &resfp, values);\n+  // { dg-output \"\\n0: 2.0 : total: 2.0\" }\n+  printf(\"ffi: %.1lf\\n\", resfp);\n+  // { dg-output \"\\nffi: 2.0\" }\n+\n+  /* Second test, float_va_fn(2,2.0,3.0,4.0), now with variadic params */\n+  /* Call it statically and then via ffi */\n+  resfp=float_va_fn(2,2.0,3.0,4.0);\n+  // { dg-output \"\\n2: 2.0 : 0:3.0  1:4.0  total: 11.0\" }\n+  printf(\"compiled: %.1lf\\n\", resfp);\n+  // { dg-output \"\\ncompiled: 11.0\" }\n+\n+  arg_types[0] = &ffi_type_uint;\n+  arg_types[1] = &ffi_type_double;\n+  arg_types[2] = &ffi_type_double;\n+  arg_types[3] = &ffi_type_double;\n+  arg_types[4] = NULL;\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 2, 4,\n+        &ffi_type_double, arg_types) == FFI_OK);\n+\n+  firstarg = 2;\n+  doubles[0] = 2.0;\n+  doubles[1] = 3.0;\n+  doubles[2] = 4.0;\n+  values[0] = &firstarg;\n+  values[1] = &doubles[0];\n+  values[2] = &doubles[1];\n+  values[3] = &doubles[2];\n+  ffi_call(&cif, FFI_FN(float_va_fn), &resfp, values);\n+  // { dg-output \"\\n2: 2.0 : 0:3.0  1:4.0  total: 11.0\" }\n+  printf(\"ffi: %.1lf\\n\", resfp);\n+  // { dg-output \"\\nffi: 11.0\" }\n+\n+  exit(0);\n+}"}, {"sha": "a36cf3eb8803236f538b6145c850a752a49e369f", "filename": "libffi/testsuite/libffi.call/return_sc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Freturn_sc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d/libffi%2Ftestsuite%2Flibffi.call%2Freturn_sc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_sc.c?ref=34fa7690ac66c6d3c5ddb1d35d267836e3c23f3d", "patch": "@@ -30,7 +30,7 @@ int main (void)\n        sc < (signed char) 127; sc++)\n     {\n       ffi_call(&cif, FFI_FN(return_sc), &rint, values);\n-      CHECK(rint == (ffi_arg) sc);\n+      CHECK((signed char)rint == sc);\n     }\n   exit(0);\n }"}]}