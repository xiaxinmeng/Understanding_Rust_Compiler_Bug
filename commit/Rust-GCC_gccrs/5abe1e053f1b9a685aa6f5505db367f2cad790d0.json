{"sha": "5abe1e053f1b9a685aa6f5505db367f2cad790d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFiZTFlMDUzZjFiOWE2ODVhYTZmNTUwNWRiMzY3ZjJjYWQ3OTBkMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-21T12:45:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-21T12:45:04Z"}, "message": "tree-vect-data-refs.c (vect_update_interleaving_chain): Remove.\n\n2013-03-21  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_update_interleaving_chain): Remove.\n\t(vect_insert_into_interleaving_chain): Likewise.\n\t(vect_drs_dependent_in_basic_block): Inline ...\n\t(vect_slp_analyze_data_ref_dependence): ... here.  New function,\n\tsplit out from ...\n\t(vect_analyze_data_ref_dependence): ... here.  Simplify.\n\t(vect_check_interleaving): Simplify.\n\t(vect_analyze_data_ref_dependences): Likewise.  Split out ...\n\t(vect_slp_analyze_data_ref_dependences): ... this new function.\n\t(dr_group_sort_cmp): New function.\n\t(vect_analyze_data_ref_accesses): Compute data-reference groups\n\there instead of in vect_analyze_data_ref_dependence.  Use\n\ta more efficient algorithm.\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Use\n\tvect_slp_analyze_data_ref_dependences.  Call\n\tvect_analyze_data_ref_accesses earlier.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n\t* tree-vectorizer.h (vect_analyze_data_ref_dependences): Adjust.\n\t(vect_slp_analyze_data_ref_dependences): New prototype.\n\n\t* gcc.dg/vect/vect-outer-3a-big-array.c: Adjust.\n\t* gcc.dg/vect/vect-outer-3a.c: Likewise.\n\nFrom-SVN: r196872", "tree": {"sha": "84e4ad879190f0b64f86ed7410a8243bd1629036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84e4ad879190f0b64f86ed7410a8243bd1629036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5abe1e053f1b9a685aa6f5505db367f2cad790d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abe1e053f1b9a685aa6f5505db367f2cad790d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5abe1e053f1b9a685aa6f5505db367f2cad790d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abe1e053f1b9a685aa6f5505db367f2cad790d0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd059b265f8adbe9a45995118356d7d623a268f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd059b265f8adbe9a45995118356d7d623a268f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd059b265f8adbe9a45995118356d7d623a268f5"}], "stats": {"total": 835, "additions": 376, "deletions": 459}, "files": [{"sha": "0058ae75c1bbf292136bee3fb254455e02ef8bee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -1,3 +1,25 @@\n+2013-03-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-data-refs.c (vect_update_interleaving_chain): Remove.\n+\t(vect_insert_into_interleaving_chain): Likewise.\n+\t(vect_drs_dependent_in_basic_block): Inline ...\n+\t(vect_slp_analyze_data_ref_dependence): ... here.  New function,\n+\tsplit out from ...\n+\t(vect_analyze_data_ref_dependence): ... here.  Simplify.\n+\t(vect_check_interleaving): Simplify.\n+\t(vect_analyze_data_ref_dependences): Likewise.  Split out ...\n+\t(vect_slp_analyze_data_ref_dependences): ... this new function.\n+\t(dr_group_sort_cmp): New function.\n+\t(vect_analyze_data_ref_accesses): Compute data-reference groups\n+\there instead of in vect_analyze_data_ref_dependence.  Use\n+\ta more efficient algorithm.\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Use\n+\tvect_slp_analyze_data_ref_dependences.  Call\n+\tvect_analyze_data_ref_accesses earlier.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n+\t* tree-vectorizer.h (vect_analyze_data_ref_dependences): Adjust.\n+\t(vect_slp_analyze_data_ref_dependences): New prototype.\n+\n 2013-03-21  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-im.c (can_sm_ref_p): Do not test whether"}, {"sha": "61729b0fc6e656f4897bfdd4260214ffbb1e3aba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -1,3 +1,8 @@\n+2013-03-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/vect-outer-3a-big-array.c: Adjust.\n+\t* gcc.dg/vect/vect-outer-3a.c: Likewise.\n+\n 2013-03-21   Naveen H.S  <Naveen.Hurugalawadi@caviumnetworks.com>\n \n \t* gcc.target/aarch64/vect.c: Test and result vector added"}, {"sha": "ecb2d9076d25bb885959bbf9f4c0b0614fe68659", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a-big-array.c?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -49,6 +49,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 2 \"vect\" { target { ! vect_multiple_sizes } } } } */\n-/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 3 \"vect\" { target vect_multiple_sizes } } } */\n+/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d0b4f80745f28d4567d189334fbd949aac86ce21", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3a.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -49,6 +49,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 2 \"vect\" { target { ! vect_multiple_sizes } } } } */\n-/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 3 \"vect\" { target vect_multiple_sizes } } } */\n+/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "579f6032280b102671157c6b7e28be191ffe998d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 320, "deletions": 426, "changes": 746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -154,328 +154,6 @@ vect_get_place_in_interleaving_chain (gimple stmt, gimple first_stmt)\n }\n \n \n-/* Function vect_insert_into_interleaving_chain.\n-\n-   Insert DRA into the interleaving chain of DRB according to DRA's INIT.  */\n-\n-static void\n-vect_insert_into_interleaving_chain (struct data_reference *dra,\n-\t\t\t\t     struct data_reference *drb)\n-{\n-  gimple prev, next;\n-  tree next_init;\n-  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n-  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n-\n-  prev = GROUP_FIRST_ELEMENT (stmtinfo_b);\n-  next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n-  while (next)\n-    {\n-      next_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n-      if (tree_int_cst_compare (next_init, DR_INIT (dra)) > 0)\n-\t{\n-\t  /* Insert here.  */\n-\t  GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = DR_STMT (dra);\n-\t  GROUP_NEXT_ELEMENT (stmtinfo_a) = next;\n-\t  return;\n-\t}\n-      prev = next;\n-      next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n-    }\n-\n-  /* We got to the end of the list. Insert here.  */\n-  GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = DR_STMT (dra);\n-  GROUP_NEXT_ELEMENT (stmtinfo_a) = NULL;\n-}\n-\n-\n-/* Function vect_update_interleaving_chain.\n-\n-   For two data-refs DRA and DRB that are a part of a chain interleaved data\n-   accesses, update the interleaving chain.  DRB's INIT is smaller than DRA's.\n-\n-   There are four possible cases:\n-   1. New stmts - both DRA and DRB are not a part of any chain:\n-      FIRST_DR = DRB\n-      NEXT_DR (DRB) = DRA\n-   2. DRB is a part of a chain and DRA is not:\n-      no need to update FIRST_DR\n-      no need to insert DRB\n-      insert DRA according to init\n-   3. DRA is a part of a chain and DRB is not:\n-      if (init of FIRST_DR > init of DRB)\n-          FIRST_DR = DRB\n-\t  NEXT(FIRST_DR) = previous FIRST_DR\n-      else\n-          insert DRB according to its init\n-   4. both DRA and DRB are in some interleaving chains:\n-      choose the chain with the smallest init of FIRST_DR\n-      insert the nodes of the second chain into the first one.  */\n-\n-static void\n-vect_update_interleaving_chain (struct data_reference *drb,\n-\t\t\t\tstruct data_reference *dra)\n-{\n-  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n-  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n-  tree next_init, init_dra_chain, init_drb_chain;\n-  gimple first_a, first_b;\n-  tree node_init;\n-  gimple node, prev, next, first_stmt;\n-\n-  /* 1. New stmts - both DRA and DRB are not a part of any chain.   */\n-  if (!GROUP_FIRST_ELEMENT (stmtinfo_a) && !GROUP_FIRST_ELEMENT (stmtinfo_b))\n-    {\n-      GROUP_FIRST_ELEMENT (stmtinfo_a) = DR_STMT (drb);\n-      GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (drb);\n-      GROUP_NEXT_ELEMENT (stmtinfo_b) = DR_STMT (dra);\n-      return;\n-    }\n-\n-  /* 2. DRB is a part of a chain and DRA is not.  */\n-  if (!GROUP_FIRST_ELEMENT (stmtinfo_a) && GROUP_FIRST_ELEMENT (stmtinfo_b))\n-    {\n-      GROUP_FIRST_ELEMENT (stmtinfo_a) = GROUP_FIRST_ELEMENT (stmtinfo_b);\n-      /* Insert DRA into the chain of DRB.  */\n-      vect_insert_into_interleaving_chain (dra, drb);\n-      return;\n-    }\n-\n-  /* 3. DRA is a part of a chain and DRB is not.  */\n-  if (GROUP_FIRST_ELEMENT (stmtinfo_a) && !GROUP_FIRST_ELEMENT (stmtinfo_b))\n-    {\n-      gimple old_first_stmt = GROUP_FIRST_ELEMENT (stmtinfo_a);\n-      tree init_old = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (\n-\t\t\t\t\t\t\t      old_first_stmt)));\n-      gimple tmp;\n-\n-      if (tree_int_cst_compare (init_old, DR_INIT (drb)) > 0)\n-\t{\n-\t  /* DRB's init is smaller than the init of the stmt previously marked\n-\t     as the first stmt of the interleaving chain of DRA.  Therefore, we\n-\t     update FIRST_STMT and put DRB in the head of the list.  */\n-\t  GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (drb);\n-\t  GROUP_NEXT_ELEMENT (stmtinfo_b) = old_first_stmt;\n-\n-\t  /* Update all the stmts in the list to point to the new FIRST_STMT.  */\n-\t  tmp = old_first_stmt;\n-\t  while (tmp)\n-\t    {\n-\t      GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) = DR_STMT (drb);\n-\t      tmp = GROUP_NEXT_ELEMENT (vinfo_for_stmt (tmp));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Insert DRB in the list of DRA.  */\n-\t  vect_insert_into_interleaving_chain (drb, dra);\n-\t  GROUP_FIRST_ELEMENT (stmtinfo_b) = GROUP_FIRST_ELEMENT (stmtinfo_a);\n-\t}\n-      return;\n-    }\n-\n-  /* 4. both DRA and DRB are in some interleaving chains.  */\n-  first_a = GROUP_FIRST_ELEMENT (stmtinfo_a);\n-  first_b = GROUP_FIRST_ELEMENT (stmtinfo_b);\n-  if (first_a == first_b)\n-    return;\n-  init_dra_chain = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_a)));\n-  init_drb_chain = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_b)));\n-\n-  if (tree_int_cst_compare (init_dra_chain, init_drb_chain) > 0)\n-    {\n-      /* Insert the nodes of DRA chain into the DRB chain.\n-\t After inserting a node, continue from this node of the DRB chain (don't\n-         start from the beginning.  */\n-      node = GROUP_FIRST_ELEMENT (stmtinfo_a);\n-      prev = GROUP_FIRST_ELEMENT (stmtinfo_b);\n-      first_stmt = first_b;\n-    }\n-  else\n-    {\n-      /* Insert the nodes of DRB chain into the DRA chain.\n-\t After inserting a node, continue from this node of the DRA chain (don't\n-         start from the beginning.  */\n-      node = GROUP_FIRST_ELEMENT (stmtinfo_b);\n-      prev = GROUP_FIRST_ELEMENT (stmtinfo_a);\n-      first_stmt = first_a;\n-    }\n-\n-  while (node)\n-    {\n-      node_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (node)));\n-      next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n-      while (next)\n-\t{\n-\t  next_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n-\t  if (tree_int_cst_compare (next_init, node_init) > 0)\n-\t    {\n-\t      /* Insert here.  */\n-\t      GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = node;\n-\t      GROUP_NEXT_ELEMENT (vinfo_for_stmt (node)) = next;\n-\t      prev = node;\n-\t      break;\n-\t    }\n-\t  prev = next;\n-\t  next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev));\n-\t}\n-      if (!next)\n-\t{\n-\t  /* We got to the end of the list. Insert here.  */\n-\t  GROUP_NEXT_ELEMENT (vinfo_for_stmt (prev)) = node;\n-\t  GROUP_NEXT_ELEMENT (vinfo_for_stmt (node)) = NULL;\n-\t  prev = node;\n-\t}\n-      GROUP_FIRST_ELEMENT (vinfo_for_stmt (node)) = first_stmt;\n-      node = GROUP_NEXT_ELEMENT (vinfo_for_stmt (node));\n-    }\n-}\n-\n-/* Check dependence between DRA and DRB for basic block vectorization.\n-   If the accesses share same bases and offsets, we can compare their initial\n-   constant offsets to decide whether they differ or not.  In case of a read-\n-   write dependence we check that the load is before the store to ensure that\n-   vectorization will not change the order of the accesses.  */\n-\n-static bool\n-vect_drs_dependent_in_basic_block (struct data_reference *dra,\n-                                   struct data_reference *drb)\n-{\n-  HOST_WIDE_INT type_size_a, type_size_b, init_a, init_b;\n-  gimple earlier_stmt;\n-\n-  /* We only call this function for pairs of loads and stores, but we verify\n-     it here.  */\n-  if (DR_IS_READ (dra) == DR_IS_READ (drb))\n-    {\n-      if (DR_IS_READ (dra))\n-        return false;\n-      else\n-        return true;\n-    }\n-\n-  /* Check that the data-refs have same bases and offsets.  If not, we can't\n-     determine if they are dependent.  */\n-  if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0)\n-      || !dr_equal_offsets_p (dra, drb))\n-    return true;\n-\n-  /* Check the types.  */\n-  type_size_a = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))));\n-  type_size_b = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n-\n-  if (type_size_a != type_size_b\n-      || !types_compatible_p (TREE_TYPE (DR_REF (dra)),\n-                              TREE_TYPE (DR_REF (drb))))\n-    return true;\n-\n-  init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n-  init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n-\n-  /* Two different locations - no dependence.  */\n-  if (init_a != init_b)\n-    return false;\n-\n-  /* We have a read-write dependence.  Check that the load is before the store.\n-     When we vectorize basic blocks, vector load can be only before \n-     corresponding scalar load, and vector store can be only after its\n-     corresponding scalar store.  So the order of the acceses is preserved in\n-     case the load is before the store.  */\n-  earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));   \n-  if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n-    return false;\n-\n-  return true;\n-}\n-\n-\n-/* Function vect_check_interleaving.\n-\n-   Check if DRA and DRB are a part of interleaving.  In case they are, insert\n-   DRA and DRB in an interleaving chain.  */\n-\n-static bool\n-vect_check_interleaving (struct data_reference *dra,\n-\t\t\t struct data_reference *drb)\n-{\n-  HOST_WIDE_INT type_size_a, type_size_b, diff_mod_size, step, init_a, init_b;\n-\n-  /* Check that the data-refs have same first location (except init) and they\n-     are both either store or load (not load and store).  */\n-  if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0)\n-      || !dr_equal_offsets_p (dra, drb)\n-      || !tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb))\n-      || DR_IS_READ (dra) != DR_IS_READ (drb))\n-    return false;\n-\n-  /* Check:\n-     1. data-refs are of the same type\n-     2. their steps are equal\n-     3. the step (if greater than zero) is greater than the difference between\n-        data-refs' inits.  */\n-  type_size_a = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))));\n-  type_size_b = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n-\n-  if (type_size_a != type_size_b\n-      || tree_int_cst_compare (DR_STEP (dra), DR_STEP (drb))\n-      || !types_compatible_p (TREE_TYPE (DR_REF (dra)),\n-                              TREE_TYPE (DR_REF (drb))))\n-    return false;\n-\n-  init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n-  init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n-  step = TREE_INT_CST_LOW (DR_STEP (dra));\n-\n-  if (init_a > init_b)\n-    {\n-      /* If init_a == init_b + the size of the type * k, we have an interleaving,\n-\t and DRB is accessed before DRA.  */\n-      diff_mod_size = (init_a - init_b) % type_size_a;\n-\n-      if (step && (init_a - init_b) > step)\n-         return false;\n-\n-      if (diff_mod_size == 0)\n-\t{\n-\t  vect_update_interleaving_chain (drb, dra);\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"Detected interleaving \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-\t      dump_printf (MSG_NOTE,  \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-\t    }\n-\t  return true;\n-\t}\n-    }\n-  else\n-    {\n-      /* If init_b == init_a + the size of the type * k, we have an\n-\t interleaving, and DRA is accessed before DRB.  */\n-      diff_mod_size = (init_b - init_a) % type_size_a;\n-\n-      if (step && (init_b - init_a) > step)\n-         return false;\n-\n-      if (diff_mod_size == 0)\n-\t{\n-\t  vect_update_interleaving_chain (dra, drb);\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"Detected interleaving \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-\t      dump_printf (MSG_NOTE,  \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-\t    }\n-\t  return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* Check if data references pointed by DR_I and DR_J are same or\n    belong to same interleaving group.  Return FALSE if drs are\n    different, otherwise return TRUE.  */\n@@ -578,111 +256,47 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n                                   loop_vec_info loop_vinfo, int *max_vf)\n {\n   unsigned int i;\n-  struct loop *loop = NULL;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n   stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n   stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n   lambda_vector dist_v;\n   unsigned int loop_depth;\n \n-  /* Don't bother to analyze statements marked as unvectorizable.  */\n+  /* In loop analysis all data references should be vectorizable.  */\n   if (!STMT_VINFO_VECTORIZABLE (stmtinfo_a)\n       || !STMT_VINFO_VECTORIZABLE (stmtinfo_b))\n-    return false;\n+    gcc_unreachable ();\n \n+  /* Independent data accesses.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n-    {\n-      /* Independent data accesses.  */\n-      vect_check_interleaving (dra, drb);\n-      return false;\n-    }\n-\n-  if (loop_vinfo)\n-    loop = LOOP_VINFO_LOOP (loop_vinfo);\n+    return false;\n \n-  if ((DR_IS_READ (dra) && DR_IS_READ (drb) && loop_vinfo) || dra == drb)\n+  if (dra == drb\n+      || (DR_IS_READ (dra) && DR_IS_READ (drb)))\n     return false;\n \n+  /* Unknown data dependence.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n-      gimple earlier_stmt;\n-\n-      if (loop_vinfo)\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"versioning for alias required: \"\n-                               \"can't determine dependence between \");\n-              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                 DR_REF (dra));\n-              dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                 DR_REF (drb));\n-            }\n-\n-          /* Add to list of ddrs that need to be tested at run-time.  */\n-          return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n-        }\n-\n-      /* When vectorizing a basic block unknown depnedence can still mean\n-\t grouped access.  */\n-      if (vect_check_interleaving (dra, drb))\n-         return false;\n-\n-      /* Read-read is OK (we need this check here, after checking for\n-         interleaving).  */\n-      if (DR_IS_READ (dra) && DR_IS_READ (drb))\n-        return false;\n-\n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"can't determine dependence between \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n-          dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n-        }\n-\n-      /* We do not vectorize basic blocks with write-write dependencies.  */\n-      if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n-        return true;\n-\n-      /* Check that it's not a load-after-store dependence.  */\n-      earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n-      if (DR_IS_WRITE (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n-        return true;\n-\n-      return false;\n-    }\n-\n-  /* Versioning for alias is not yet supported for basic block SLP, and\n-     dependence distance is unapplicable, hence, in case of known data\n-     dependence, basic block vectorization is impossible for now.  */\n-  if (!loop_vinfo)\n-    {\n-      if (dra != drb && vect_check_interleaving (dra, drb))\n-        return false;\n-\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"determined dependence between \");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-          dump_printf (MSG_NOTE, \" and \");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-        }\n-\n-      /* Do not vectorize basic blcoks with write-write dependences.  */\n-      if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n-        return true;\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"versioning for alias required: \"\n+\t\t\t   \"can't determine dependence between \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t     DR_REF (dra));\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t     DR_REF (drb));\n+\t}\n \n-      /* Check if this dependence is allowed in basic block vectorization.  */\n-      return vect_drs_dependent_in_basic_block (dra, drb);\n+      /* Add to list of ddrs that need to be tested at run-time.  */\n+      return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n     }\n \n-  /* Loop-based vectorization and known data dependence.  */\n+  /* Known data dependence.  */\n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n       if (dump_enabled_p ())\n@@ -719,7 +333,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t    }\n \n           /* For interleaving, mark that there is a read-write dependency if\n-             necessary. We check before that one of the data-refs is store.  */\n+             necessary.  We check before that one of the data-refs is store.  */\n           if (DR_IS_READ (dra))\n             GROUP_READ_WRITE_DEPENDENCE (stmtinfo_a) = true;\n \t  else\n@@ -787,35 +401,161 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n    the maximum vectorization factor the data dependences allow.  */\n \n bool\n-vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n-                                   bb_vec_info bb_vinfo, int *max_vf)\n+vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo, int *max_vf)\n {\n   unsigned int i;\n-  vec<ddr_p> ddrs = vNULL;\n   struct data_dependence_relation *ddr;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_dependences ===\");\n-  if (loop_vinfo)\n+                     \"=== vect_analyze_data_ref_dependences ===\");\n+\n+  if (!compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n+\t\t\t\t&LOOP_VINFO_DDRS (loop_vinfo),\n+\t\t\t\tLOOP_VINFO_LOOP_NEST (loop_vinfo), true))\n+    return false;\n+\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_DDRS (loop_vinfo), i, ddr)\n+    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n+      return false;\n+\n+  return true;\n+}\n+\n+\n+/* Function vect_slp_analyze_data_ref_dependence.\n+\n+   Return TRUE if there (might) exist a dependence between a memory-reference\n+   DRA and a memory-reference DRB.  When versioning for alias may check a\n+   dependence at run-time, return FALSE.  Adjust *MAX_VF according to\n+   the data dependence.  */\n+\n+static bool\n+vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n+{\n+  struct data_reference *dra = DDR_A (ddr);\n+  struct data_reference *drb = DDR_B (ddr);\n+\n+  /* We need to check dependences of statements marked as unvectorizable\n+     as well, they still can prohibit vectorization.  */\n+\n+  /* Independent data accesses.  */\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+    return false;\n+\n+  if (dra == drb)\n+    return false;\n+\n+  /* Read-read is OK.  */\n+  if (DR_IS_READ (dra) && DR_IS_READ (drb))\n+    return false;\n+\n+  /* Unknown data dependence.  */\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n-      if (!compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n-\t\t\t\t    &LOOP_VINFO_DDRS (loop_vinfo),\n-\t\t\t\t    LOOP_VINFO_LOOP_NEST (loop_vinfo), true))\n-\treturn false;\n-      ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+      gimple earlier_stmt;\n+\n+      if (dump_enabled_p ())\n+        {\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"can't determine dependence between \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n+          dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n+        }\n+\n+      /* We do not vectorize basic blocks with write-write dependencies.  */\n+      if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n+        return true;\n+\n+      /* Check that it's not a load-after-store dependence.  */\n+      earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n+      if (DR_IS_WRITE (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n+        return true;\n+\n+      return false;\n     }\n-  else\n+\n+  if (dump_enabled_p ())\n     {\n-      if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n-\t\t\t\t    &BB_VINFO_DDRS (bb_vinfo),\n-\t\t\t\t    vNULL, true))\n-\treturn false;\n-      ddrs = BB_VINFO_DDRS (bb_vinfo);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"determined dependence between \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+      dump_printf (MSG_NOTE, \" and \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n     }\n \n-  FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n+  /* Do not vectorize basic blocks with write-write dependences.  */\n+  if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n+    return true;\n+\n+  /* Check dependence between DRA and DRB for basic block vectorization.\n+     If the accesses share same bases and offsets, we can compare their initial\n+     constant offsets to decide whether they differ or not.  In case of a read-\n+     write dependence we check that the load is before the store to ensure that\n+     vectorization will not change the order of the accesses.  */\n+\n+  HOST_WIDE_INT type_size_a, type_size_b, init_a, init_b;\n+  gimple earlier_stmt;\n+\n+  /* Check that the data-refs have same bases and offsets.  If not, we can't\n+     determine if they are dependent.  */\n+  if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0)\n+      || !dr_equal_offsets_p (dra, drb))\n+    return true;\n+\n+  /* Check the types.  */\n+  type_size_a = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))));\n+  type_size_b = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n+\n+  if (type_size_a != type_size_b\n+      || !types_compatible_p (TREE_TYPE (DR_REF (dra)),\n+                              TREE_TYPE (DR_REF (drb))))\n+    return true;\n+\n+  init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n+  init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n+\n+  /* Two different locations - no dependence.  */\n+  if (init_a != init_b)\n+    return false;\n+\n+  /* We have a read-write dependence.  Check that the load is before the store.\n+     When we vectorize basic blocks, vector load can be only before\n+     corresponding scalar load, and vector store can be only after its\n+     corresponding scalar store.  So the order of the acceses is preserved in\n+     case the load is before the store.  */\n+  earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n+  if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Function vect_analyze_data_ref_dependences.\n+\n+   Examine all the data references in the basic-block, and make sure there\n+   do not exist any data dependences between them.  Set *MAX_VF according to\n+   the maximum vectorization factor the data dependences allow.  */\n+\n+bool\n+vect_slp_analyze_data_ref_dependences (bb_vec_info bb_vinfo)\n+{\n+  struct data_dependence_relation *ddr;\n+  unsigned int i;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_slp_analyze_data_ref_dependences ===\");\n+\n+  if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n+\t\t\t\t&BB_VINFO_DDRS (bb_vinfo),\n+\t\t\t\tvNULL, true))\n+    return false;\n+\n+  FOR_EACH_VEC_ELT (BB_VINFO_DDRS (bb_vinfo), i, ddr)\n+    if (vect_slp_analyze_data_ref_dependence (ddr))\n       return false;\n \n   return true;\n@@ -2567,6 +2307,68 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   return vect_analyze_group_access (dr);\n }\n \n+/* Compare two data-references DRA and DRB to group them into chunks\n+   suitable for grouping.  */\n+\n+static int\n+dr_group_sort_cmp (const void *dra_, const void *drb_)\n+{\n+  data_reference_p dra = *(data_reference_p *)const_cast<void *>(dra_);\n+  data_reference_p drb = *(data_reference_p *)const_cast<void *>(drb_);\n+  hashval_t h1, h2;\n+  int cmp;\n+\n+  /* Stabilize sort.  */\n+  if (dra == drb)\n+    return 0;\n+\n+  /* Ordering of DRs according to base.  */\n+  if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0))\n+    {\n+      h1 = iterative_hash_expr (DR_BASE_ADDRESS (dra), 0);\n+      h2 = iterative_hash_expr (DR_BASE_ADDRESS (drb), 0);\n+      if (h1 != h2)\n+\treturn h1 < h2 ? -1 : 1;\n+    }\n+\n+  /* And according to DR_OFFSET.  */\n+  if (!dr_equal_offsets_p (dra, drb))\n+    {\n+      h1 = iterative_hash_expr (DR_OFFSET (dra), 0);\n+      h2 = iterative_hash_expr (DR_OFFSET (drb), 0);\n+      if (h1 != h2)\n+\treturn h1 < h2 ? -1 : 1;\n+    }\n+\n+  /* Put reads before writes.  */\n+  if (DR_IS_READ (dra) != DR_IS_READ (drb))\n+    return DR_IS_READ (dra) ? -1 : 1;\n+\n+  /* Then sort after access size.  */\n+  if (!operand_equal_p (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))),\n+\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))), 0))\n+    {\n+      h1 = iterative_hash_expr (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))), 0);\n+      h2 = iterative_hash_expr (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))), 0);\n+      if (h1 != h2)\n+\treturn h1 < h2 ? -1 : 1;\n+    }\n+\n+  /* And after step.  */\n+  if (!operand_equal_p (DR_STEP (dra), DR_STEP (drb), 0))\n+    {\n+      h1 = iterative_hash_expr (DR_STEP (dra), 0);\n+      h2 = iterative_hash_expr (DR_STEP (drb), 0);\n+      if (h1 != h2)\n+\treturn h1 < h2 ? -1 : 1;\n+    }\n+\n+  /* Then sort after DR_INIT.  In case of identical DRs sort after stmt UID.  */\n+  cmp = tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb));\n+  if (cmp == 0)\n+    return gimple_uid (DR_STMT (dra)) < gimple_uid (DR_STMT (drb)) ? -1 : 1;\n+  return cmp;\n+}\n \n /* Function vect_analyze_data_ref_accesses.\n \n@@ -2593,6 +2395,98 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   else\n     datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n \n+  if (datarefs.is_empty ())\n+    return true;\n+\n+  /* Sort the array of datarefs to make building the interleaving chains\n+     linear.  */\n+  qsort (datarefs.address(), datarefs.length (),\n+\t sizeof (data_reference_p), dr_group_sort_cmp);\n+\n+  /* Build the interleaving chains.  */\n+  for (i = 0; i < datarefs.length () - 1;)\n+    {\n+      data_reference_p dra = datarefs[i];\n+      stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n+      stmt_vec_info lastinfo = NULL;\n+      for (i = i + 1; i < datarefs.length (); ++i)\n+\t{\n+\t  data_reference_p drb = datarefs[i];\n+\t  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+\n+\t  /* ???  Imperfect sorting (non-compatible types, non-modulo\n+\t     accesses, same accesses) can lead to a group to be artificially\n+\t     split here as we don't just skip over those.  If it really\n+\t     matters we can push those to a worklist and re-iterate\n+\t     over them.  The we can just skip ahead to the next DR here.  */\n+\n+\t  /* Check that the data-refs have same first location (except init)\n+\t     and they are both either store or load (not load and store).  */\n+\t  if (DR_IS_READ (dra) != DR_IS_READ (drb)\n+\t      || !operand_equal_p (DR_BASE_ADDRESS (dra),\n+\t\t\t\t   DR_BASE_ADDRESS (drb), 0)\n+\t      || !dr_equal_offsets_p (dra, drb))\n+\t    break;\n+\n+\t  /* Check that the data-refs have the same constant size and step.  */\n+\t  tree sza = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra)));\n+\t  tree szb = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb)));\n+\t  if (!host_integerp (sza, 1)\n+\t      || !host_integerp (szb, 1)\n+\t      || !tree_int_cst_equal (sza, szb)\n+\t      || !host_integerp (DR_STEP (dra), 0)\n+\t      || !host_integerp (DR_STEP (drb), 0)\n+\t      || !tree_int_cst_equal (DR_STEP (dra), DR_STEP (drb)))\n+\t    break;\n+\n+\t  /* Do not place the same access in the interleaving chain twice.  */\n+\t  if (tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb)) == 0)\n+\t    break;\n+\n+\t  /* Check the types are compatible.\n+\t     ???  We don't distinguish this during sorting.  */\n+\t  if (!types_compatible_p (TREE_TYPE (DR_REF (dra)),\n+\t\t\t\t   TREE_TYPE (DR_REF (drb))))\n+\t    break;\n+\n+\t  /* Sorting has ensured that DR_INIT (dra) <= DR_INIT (drb).  */\n+\t  HOST_WIDE_INT init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n+\t  HOST_WIDE_INT init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n+\t  gcc_assert (init_a < init_b);\n+\n+\t  /* If init_b == init_a + the size of the type * k, we have an\n+\t     interleaving, and DRA is accessed before DRB.  */\n+\t  HOST_WIDE_INT type_size_a = TREE_INT_CST_LOW (sza);\n+\t  if ((init_b - init_a) % type_size_a != 0)\n+\t    break;\n+\n+\t  /* The step (if not zero) is greater than the difference between\n+\t     data-refs' inits.  This splits groups into suitable sizes.  */\n+\t  HOST_WIDE_INT step = TREE_INT_CST_LOW (DR_STEP (dra));\n+\t  if (step != 0 && step <= (init_b - init_a))\n+\t    break;\n+\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"Detected interleaving \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+\t      dump_printf (MSG_NOTE,  \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n+\t    }\n+\n+\t  /* Link the found element into the group list.  */\n+\t  if (!GROUP_FIRST_ELEMENT (stmtinfo_a))\n+\t    {\n+\t      GROUP_FIRST_ELEMENT (stmtinfo_a) = DR_STMT (dra);\n+\t      lastinfo = stmtinfo_a;\n+\t    }\n+\t  GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (dra);\n+\t  GROUP_NEXT_ELEMENT (lastinfo) = DR_STMT (drb);\n+\t  lastinfo = stmtinfo_b;\n+\t}\n+    }\n+\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) \n         && !vect_analyze_data_ref_access (dr))"}, {"sha": "542082f3cf6182471ebc626161281d5a3712784d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -1589,6 +1589,18 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n+  /* Analyze the access patterns of the data-refs in the loop (consecutive,\n+     complex, etc.). FORNOW: Only handle consecutive access pattern.  */\n+\n+  ok = vect_analyze_data_ref_accesses (loop_vinfo, NULL);\n+  if (!ok)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad data access.\");\n+      return false;\n+    }\n+\n   /* Classify all cross-iteration scalar data-flow cycles.\n      Cross-iteration cycles caused by virtual phis are analyzed separately.  */\n \n@@ -1612,7 +1624,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n      the dependences.\n      FORNOW: fail at the first data dependence that we encounter.  */\n \n-  ok = vect_analyze_data_ref_dependences (loop_vinfo, NULL, &max_vf);\n+  ok = vect_analyze_data_ref_dependences (loop_vinfo, &max_vf);\n   if (!ok\n       || max_vf < min_vf)\n     {\n@@ -1650,18 +1662,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-  /* Analyze the access patterns of the data-refs in the loop (consecutive,\n-     complex, etc.). FORNOW: Only handle consecutive access pattern.  */\n-\n-  ok = vect_analyze_data_ref_accesses (loop_vinfo, NULL);\n-  if (!ok)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data access.\");\n-      return false;\n-    }\n-\n   /* Prune the list of ddrs to be tested at run-time by versioning for alias.\n      It is important to call pruning after vect_analyze_data_ref_accesses,\n      since we use grouping information gathered by interleaving analysis.  */"}, {"sha": "8ef5d0684b48271145c4a4b0c571b1f08f711692", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -2082,7 +2082,6 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   slp_instance instance;\n   int i;\n   int min_vf = 2;\n-  int max_vf = MAX_VECTORIZATION_FACTOR;\n \n   bb_vinfo = new_bb_vec_info (bb);\n   if (!bb_vinfo)\n@@ -2110,10 +2109,20 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n+  if (!vect_analyze_data_ref_accesses (NULL, bb_vinfo))\n+    {\n+     if (dump_enabled_p ())\n+       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\"not vectorized: unhandled data access in \"\n+\t\t\t\"basic block.\\n\");\n+\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n   vect_pattern_recog (NULL, bb_vinfo);\n \n-  if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf)\n-       || min_vf > max_vf)\n+  if (!vect_slp_analyze_data_ref_dependences (bb_vinfo))\n      {\n        if (dump_enabled_p ())\n \t dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2135,17 +2144,6 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  if (!vect_analyze_data_ref_accesses (NULL, bb_vinfo))\n-    {\n-     if (dump_enabled_p ())\n-       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\"not vectorized: unhandled data access in \"\n-\t\t\t\"basic block.\\n\");\n-\n-      destroy_bb_vec_info (bb_vinfo);\n-      return NULL;\n-    }\n-\n   /* Check the SLP opportunities in the basic block, analyze and build SLP\n      trees.  */\n   if (!vect_analyze_slp (NULL, bb_vinfo))"}, {"sha": "6c08979e8a61aecc447995e5834b19447ee7422a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abe1e053f1b9a685aa6f5505db367f2cad790d0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5abe1e053f1b9a685aa6f5505db367f2cad790d0", "patch": "@@ -914,8 +914,8 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n                                            (struct data_reference *, bool);\n extern tree vect_get_smallest_scalar_type (gimple, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n-extern bool vect_analyze_data_ref_dependences (loop_vec_info, bb_vec_info,\n-\t\t\t\t\t       int *);\n+extern bool vect_analyze_data_ref_dependences (loop_vec_info, int *);\n+extern bool vect_slp_analyze_data_ref_dependences (bb_vec_info);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n extern bool vect_analyze_data_refs_alignment (loop_vec_info, bb_vec_info);\n extern bool vect_verify_datarefs_alignment (loop_vec_info, bb_vec_info);"}]}