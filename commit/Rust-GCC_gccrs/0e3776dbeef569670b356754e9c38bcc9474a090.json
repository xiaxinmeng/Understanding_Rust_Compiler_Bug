{"sha": "0e3776dbeef569670b356754e9c38bcc9474a090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzNzc2ZGJlZWY1Njk2NzBiMzU2NzU0ZTljMzhiY2M5NDc0YTA5MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-11-16T13:26:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-11-16T13:26:40Z"}, "message": "cgraph.c (cgraph_release_function_body): Update use of ipa_transforms_to_apply.\n\n\n\t* cgraph.c (cgraph_release_function_body): Update use of\n\tipa_transforms_to_apply.\n\t(cgraph_remove_node): Remove ipa_transforms_to_apply.\n\t* cgraph.h (struct cgraph_node): Add ipa_transforms_to_apply.\n\t* cgraphunit.c (save_inline_function_body): Clear ipa_transforms for\n\tcopied body.\n\t(cgraph_materialize_clone): Remove original if dead.\n\t* lto-streamer-in.c (lto_read_body): Remove FIXME and\n\tipa_transforms_to_apply hack.\n\t* function.h (struct function): Add ipa_transforms_to_apply.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Handle dead clone originals.\n\t* tree-inline.c (copy_bb): Update sanity check.\n\t(initialize_cfun): Do not copy ipa_transforms_to_apply.\n\t(expand_call_inline): remove dead clone originals.\n\t(tree_function_versioning): Merge transformation queues.\n\t* passes.c (add_ipa_transform_pass): Remove.\n\t(execute_one_ipa_transform_pass): Update ipa_transforms_to_apply\n\ttracking.\n\t(execute_all_ipa_transforms): Update.\n\t(execute_one_pass): Update.\n\n\t* lto.c (read_cgraph_and_symbols): Set also ipa_transforms_to_apply.\n\nFrom-SVN: r154200", "tree": {"sha": "ece4c3265c5f578e93ab9450ccf60b597e2a02e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ece4c3265c5f578e93ab9450ccf60b597e2a02e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3776dbeef569670b356754e9c38bcc9474a090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3776dbeef569670b356754e9c38bcc9474a090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3776dbeef569670b356754e9c38bcc9474a090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3776dbeef569670b356754e9c38bcc9474a090/comments", "author": null, "committer": null, "parents": [{"sha": "0229b692f4cba2d23b960284c79384b6f5b2309a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0229b692f4cba2d23b960284c79384b6f5b2309a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0229b692f4cba2d23b960284c79384b6f5b2309a"}], "stats": {"total": 199, "additions": 140, "deletions": 59}, "files": [{"sha": "9796fa09ce9c18f0da8416c77b2a4c2019523525", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1,3 +1,26 @@\n+2009-11-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_release_function_body): Update use of\n+\tipa_transforms_to_apply.\n+\t(cgraph_remove_node): Remove ipa_transforms_to_apply.\n+\t* cgraph.h (struct cgraph_node): Add ipa_transforms_to_apply.\n+\t* cgraphunit.c (save_inline_function_body): Clear ipa_transforms for\n+\tcopied body.\n+\t(cgraph_materialize_clone): Remove original if dead.\n+\t* lto-streamer-in.c (lto_read_body): Remove FIXME and\n+\tipa_transforms_to_apply hack.\n+\t* function.h (struct function): Add ipa_transforms_to_apply.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Handle dead clone originals.\n+\t* tree-inline.c (copy_bb): Update sanity check.\n+\t(initialize_cfun): Do not copy ipa_transforms_to_apply.\n+\t(expand_call_inline): remove dead clone originals.\n+\t(tree_function_versioning): Merge transformation queues.\n+\t* passes.c (add_ipa_transform_pass): Remove.\n+\t(execute_one_ipa_transform_pass): Update ipa_transforms_to_apply\n+\ttracking.\n+\t(execute_all_ipa_transforms): Update.\n+\t(execute_one_pass): Update.\n+\n 2009-11-14  Andy Hutchinson   <hutchinsonandy@gcc.gnu.org>\n \n \tPR target/21078, 21080"}, {"sha": "840cf297bb5f167fb1f12a3c89a5451404dac160", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1132,7 +1132,7 @@ cgraph_release_function_body (struct cgraph_node *node)\n       pop_cfun();\n       gimple_set_body (node->decl, NULL);\n       VEC_free (ipa_opt_pass, heap,\n-      \t\tDECL_STRUCT_FUNCTION (node->decl)->ipa_transforms_to_apply);\n+      \t\tnode->ipa_transforms_to_apply);\n       /* Struct function hangs a lot of data that would leak if we didn't\n          removed all pointers to it.   */\n       ggc_free (DECL_STRUCT_FUNCTION (node->decl));\n@@ -1159,6 +1159,8 @@ cgraph_remove_node (struct cgraph_node *node)\n   cgraph_call_node_removal_hooks (node);\n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n+  VEC_free (ipa_opt_pass, heap,\n+            node->ipa_transforms_to_apply);\n \n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */"}, {"sha": "33eb821dd5d49693852a5eb14cf1ebb9f549e225", "filename": "gcc/cgraph.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -190,6 +190,11 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n \n   PTR GTY ((skip)) aux;\n \n+  /* Interprocedural passes scheduled to have their transform functions\n+     applied next time we execute local pass on them.  We maintain it\n+     per-function in order to allow IPA passes to introduce new functions.  */\n+  VEC(ipa_opt_pass,heap) * GTY((skip)) ipa_transforms_to_apply;\n+\n   struct cgraph_local_info local;\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n@@ -206,16 +211,24 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n      number of cfg nodes with -fprofile-generate and -fprofile-use */\n   int pid;\n \n-  /* Set when function must be output - it is externally visible\n-     or its address is taken.  */\n+  /* Set when function must be output for some reason.  The primary\n+     use of this flag is to mark functions needed to be output for\n+     non-standard reason.  Functions that are externally visible\n+     or reachable from functions needed to be output are marked\n+     by specialized flags.  */\n   unsigned needed : 1;\n-  /* Set when function has address taken.  */\n+  /* Set when function has address taken.\n+     In current implementation it imply needed flag. */\n   unsigned address_taken : 1;\n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n   unsigned abstract_and_needed : 1;\n   /* Set when function is reachable by call from other function\n-     that is either reachable or needed.  */\n+     that is either reachable or needed.  \n+     This flag is computed at original cgraph construction and then\n+     updated in cgraph_remove_unreachable_nodes.  Note that after\n+     cgraph_remove_unreachable_nodes cgraph still can contain unreachable\n+     nodes when they are needed for virtual clone instantiation.  */\n   unsigned reachable : 1;\n   /* Set once the function is lowered (i.e. its CFG is built).  */\n   unsigned lowered : 1;"}, {"sha": "1c13f955cfa3e168dff4b322647cb2afa2e066d9", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1777,8 +1777,8 @@ save_inline_function_body (struct cgraph_node *node)\n   TREE_PUBLIC (first_clone->decl) = 0;\n   DECL_COMDAT (first_clone->decl) = 0;\n   VEC_free (ipa_opt_pass, heap,\n-            DECL_STRUCT_FUNCTION (first_clone->decl)->ipa_transforms_to_apply);\n-  DECL_STRUCT_FUNCTION (first_clone->decl)->ipa_transforms_to_apply = NULL;\n+            first_clone->ipa_transforms_to_apply);\n+  first_clone->ipa_transforms_to_apply = NULL;\n \n #ifdef ENABLE_CHECKING\n   verify_cgraph_node (first_clone);\n@@ -1810,6 +1810,8 @@ cgraph_materialize_clone (struct cgraph_node *node)\n     node->clone_of->clones = node->next_sibling_clone;\n   node->next_sibling_clone = NULL;\n   node->prev_sibling_clone = NULL;\n+  if (!node->clone_of->analyzed && !node->clone_of->clones)\n+    cgraph_remove_node (node->clone_of);\n   node->clone_of = NULL;\n   bitmap_obstack_release (NULL);\n }"}, {"sha": "ad203ba195e0cf46abbc1e9ccdeed49b8108a3bb", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -522,11 +522,6 @@ struct GTY(()) function {\n   unsigned int curr_properties;\n   unsigned int last_verified;\n \n-  /* Interprocedural passes scheduled to have their transform functions\n-     applied next time we execute local pass on them.  We maintain it\n-     per-function in order to allow IPA passes to introduce new functions.  */\n-  VEC(ipa_opt_pass,heap) * GTY((skip)) ipa_transforms_to_apply;\n-\n   /* Non-null if the function does something that would prevent it from\n      being copied; this applies to both versioning and inlining.  Set to\n      a string describing the reason for failure.  */"}, {"sha": "4d52ed404f36f77b6020e8799388aa4c3701da6b", "filename": "gcc/ipa.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -121,6 +121,7 @@ bool\n cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n   struct cgraph_node *first = (struct cgraph_node *) (void *) 1;\n+  struct cgraph_node *processed = (struct cgraph_node *) (void *) 2;\n   struct cgraph_node *node, *next;\n   bool changed = false;\n \n@@ -142,9 +143,13 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n         gcc_assert (!node->global.inlined_to);\n \tnode->aux = first;\n \tfirst = node;\n+\tnode->reachable = true;\n       }\n     else\n-      gcc_assert (!node->aux);\n+      {\n+        gcc_assert (!node->aux);\n+\tnode->reachable = false;\n+      }\n \n   /* Perform reachability analysis.  As a special case do not consider\n      extern inline functions not inlined as live because we won't output\n@@ -154,17 +159,26 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       struct cgraph_edge *e;\n       node = first;\n       first = (struct cgraph_node *) first->aux;\n-\n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (!e->callee->aux\n-\t    && node->analyzed\n-\t    && (!e->inline_failed || !e->callee->analyzed\n-\t\t|| (!DECL_EXTERNAL (e->callee->decl))\n-                || before_inlining_p))\n-\t  {\n-\t    e->callee->aux = first;\n-\t    first = e->callee;\n-\t  }\n+      node->aux = processed;\n+\n+      if (node->reachable)\n+        for (e = node->callees; e; e = e->next_callee)\n+\t  if (!e->callee->reachable\n+\t      && node->analyzed\n+\t      && (!e->inline_failed || !e->callee->analyzed\n+\t\t  || (!DECL_EXTERNAL (e->callee->decl))\n+                  || before_inlining_p))\n+\t    {\n+\t      bool prev_reachable = e->callee->reachable;\n+\t      e->callee->reachable |= node->reachable;\n+\t      if (!e->callee->aux\n+\t          || (e->callee->aux == processed\n+\t\t      && prev_reachable != e->callee->reachable))\n+\t        {\n+\t          e->callee->aux = first;\n+\t          first = e->callee;\n+\t        }\n+\t    }\n       while (node->clone_of && !node->clone_of->aux && !gimple_has_body_p (node->decl))\n         {\n \t  node = node->clone_of;\n@@ -184,13 +198,18 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   for (node = cgraph_nodes; node; node = next)\n     {\n       next = node->next;\n+      if (node->aux && !node->reachable)\n+        {\n+\t  cgraph_node_remove_callees (node);\n+\t  node->analyzed = false;\n+\t  node->local.inlinable = false;\n+\t}\n       if (!node->aux)\n \t{\n           node->global.inlined_to = NULL;\n \t  if (file)\n \t    fprintf (file, \" %s\", cgraph_node_name (node));\n-\t  if (!node->analyzed || !DECL_EXTERNAL (node->decl)\n-\t      || before_inlining_p)\n+\t  if (!node->analyzed || !DECL_EXTERNAL (node->decl) || before_inlining_p)\n \t    cgraph_remove_node (node);\n \t  else\n \t    {\n@@ -219,6 +238,12 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t      node->analyzed = false;\n \t\t      node->local.inlinable = false;\n \t\t    }\n+\t\t  if (node->prev_sibling_clone)\n+\t\t    node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n+\t\t  else if (node->clone_of)\n+\t\t    node->clone_of->clones = node->next_sibling_clone;\n+\t\t  if (node->next_sibling_clone)\n+\t\t    node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n \t\t}\n \t      else\n \t\tcgraph_remove_node (node);"}, {"sha": "dcc92fde13d5686e2d77f53f8357502109b95382", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1476,15 +1476,6 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n       /* Restore decl state */\n       file_data->current_decl_state = file_data->global_decl_state;\n \n-      /* FIXME: ipa_transforms_to_apply holds list of passes that have optimization\n-         summaries computed and needs to apply changes.  At the moment WHOPR only\n-         supports inlining, so we can push it here by hand.  In future we need to stream\n-         this field into ltrans compilation.  This will also need to move the field\n-\t from struct function into cgraph node where it belongs.  */\n-      if (flag_ltrans && !cgraph_node (fn_decl)->global.inlined_to)\n-\t VEC_safe_push (ipa_opt_pass, heap,\n-\t\t\tcfun->ipa_transforms_to_apply,\n-\t\t\t(ipa_opt_pass)&pass_ipa_inline);\n       pop_cfun ();\n     }\n   else "}, {"sha": "963319980a0c2f838c5c36e43f7dba196c1d351c", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1,3 +1,7 @@\n+2009-11-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (read_cgraph_and_symbols): Set also ipa_transforms_to_apply.\n+\n 2009-11-12  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* lang.opt (fresolution): Renamed from resolution."}, {"sha": "40f3c30fb640712f056651bca4971bcef6481487", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1826,9 +1826,19 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n      phase. */\n   if (flag_ltrans)\n     for (node = cgraph_nodes; node; node = node->next)\n-      if (!node->global.inlined_to\n-\t  && cgraph_decide_is_function_needed (node, node->decl))\n-        cgraph_mark_needed_node (node);\n+      {\n+        if (!node->global.inlined_to\n+\t    && cgraph_decide_is_function_needed (node, node->decl))\n+          cgraph_mark_needed_node (node);\n+\t/* FIXME: ipa_transforms_to_apply holds list of passes that have optimization\n+\t   summaries computed and needs to apply changes.  At the moment WHOPR only\n+\t   supports inlining, so we can push it here by hand.  In future we need to stream\n+\t   this field into ltrans compilation.  */\n+\tif (node->analyzed)\n+\t  VEC_safe_push (ipa_opt_pass, heap,\n+\t\t\t node->ipa_transforms_to_apply,\n+\t\t\t (ipa_opt_pass)&pass_ipa_inline);\n+      }\n \n   timevar_push (TV_IPA_LTO_DECL_IO);\n "}, {"sha": "e92d0860bd9721759cebd30604649d6c65c95694", "filename": "gcc/passes.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1376,15 +1376,6 @@ update_properties_after_pass (void *data)\n \t\t           & ~pass->properties_destroyed;\n }\n \n-/* Schedule IPA transform pass DATA for CFUN.  */\n-\n-static void\n-add_ipa_transform_pass (void *data)\n-{\n-  struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *) data;\n-  VEC_safe_push (ipa_opt_pass, heap, cfun->ipa_transforms_to_apply, ipa_pass);\n-}\n-\n /* Execute summary generation for all of the passes in IPA_PASS.  */\n \n void\n@@ -1464,19 +1455,22 @@ execute_one_ipa_transform_pass (struct cgraph_node *node,\n void\n execute_all_ipa_transforms (void)\n {\n-  if (cfun && cfun->ipa_transforms_to_apply)\n+  struct cgraph_node *node;\n+  if (!cfun)\n+    return;\n+  node = cgraph_node (current_function_decl);\n+  if (node->ipa_transforms_to_apply)\n     {\n       unsigned int i;\n-      struct cgraph_node *node = cgraph_node (current_function_decl);\n \n-      for (i = 0; i < VEC_length (ipa_opt_pass, cfun->ipa_transforms_to_apply);\n+      for (i = 0; i < VEC_length (ipa_opt_pass, node->ipa_transforms_to_apply);\n \t   i++)\n \texecute_one_ipa_transform_pass (node,\n \t\t\t\t\tVEC_index (ipa_opt_pass,\n-\t\t\t\t\t\t   cfun->ipa_transforms_to_apply,\n+\t\t\t\t\t\t   node->ipa_transforms_to_apply,\n \t\t\t\t\t\t   i));\n-      VEC_free (ipa_opt_pass, heap, cfun->ipa_transforms_to_apply);\n-      cfun->ipa_transforms_to_apply = NULL;\n+      VEC_free (ipa_opt_pass, heap, node->ipa_transforms_to_apply);\n+      node->ipa_transforms_to_apply = NULL;\n     }\n }\n \n@@ -1551,7 +1545,13 @@ execute_one_pass (struct opt_pass *pass)\n   execute_todo (todo_after | pass->todo_flags_finish);\n   verify_interpass_invariants ();\n   if (pass->type == IPA_PASS)\n-    do_per_function (add_ipa_transform_pass, pass);\n+    {\n+      struct cgraph_node *node;\n+      for (node = cgraph_nodes; node; node = node->next)\n+        if (node->analyzed)\n+          VEC_safe_push (ipa_opt_pass, heap, node->ipa_transforms_to_apply,\n+\t\t\t (struct ipa_opt_pass_d *)pass);\n+    }\n \n   if (!current_function_decl)\n     cgraph_process_new_functions ();"}, {"sha": "629ccfb524fb5b5c36b192c788af4582a067bb94", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3776dbeef569670b356754e9c38bcc9474a090/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0e3776dbeef569670b356754e9c38bcc9474a090", "patch": "@@ -1665,10 +1665,12 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \n \t\t  /* We have missing edge in the callgraph.  This can happen\n \t\t     when previous inlining turned an indirect call into a\n-\t\t     direct call by constant propagating arguments.  In all\n+\t\t     direct call by constant propagating arguments or we are\n+\t\t     producing dead clone (for further clonning).  In all\n \t\t     other cases we hit a bug (incorrect node sharing is the\n \t\t     most common reason for missing edges).  */\n-\t\t  gcc_assert (dest->needed || !dest->analyzed);\n+\t\t  gcc_assert (dest->needed || !dest->analyzed\n+\t\t  \t      || !id->src_node->analyzed);\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    cgraph_create_edge_including_clones\n \t\t      (id->dst_node, dest, stmt, bb->count,\n@@ -1983,9 +1985,6 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n   cfun->function_end_locus = src_cfun->function_end_locus;\n   cfun->curr_properties = src_cfun->curr_properties;\n   cfun->last_verified = src_cfun->last_verified;\n-  if (src_cfun->ipa_transforms_to_apply)\n-    cfun->ipa_transforms_to_apply = VEC_copy (ipa_opt_pass, heap,\n-\t\t\t\t\t      src_cfun->ipa_transforms_to_apply);\n   cfun->va_list_gpr_size = src_cfun->va_list_gpr_size;\n   cfun->va_list_fpr_size = src_cfun->va_list_fpr_size;\n   cfun->function_frequency = src_cfun->function_frequency;\n@@ -3822,6 +3821,10 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   (*debug_hooks->outlining_inline_function) (cg_edge->callee->decl);\n \n   /* Update callgraph if needed.  */\n+  if (cg_edge->callee->clone_of\n+      && !cg_edge->callee->clone_of->next_sibling_clone\n+      && !cg_edge->callee->analyzed)\n+    cgraph_remove_node (cg_edge->callee);\n   cgraph_remove_node (cg_edge->callee);\n \n   id->block = NULL_TREE;\n@@ -4848,6 +4851,19 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   id.src_node = old_version_node;\n   id.dst_node = new_version_node;\n   id.src_cfun = DECL_STRUCT_FUNCTION (old_decl);\n+  if (id.src_node->ipa_transforms_to_apply)\n+    {\n+      VEC(ipa_opt_pass,heap) * old_transforms_to_apply = id.dst_node->ipa_transforms_to_apply;\n+      unsigned int i;\n+\n+      id.dst_node->ipa_transforms_to_apply = VEC_copy (ipa_opt_pass, heap,\n+\t\t\t\t\t               id.src_node->ipa_transforms_to_apply);\n+      for (i = 0; i < VEC_length (ipa_opt_pass, old_transforms_to_apply); i++)\n+        VEC_safe_push (ipa_opt_pass, heap, id.dst_node->ipa_transforms_to_apply,\n+\t\t       VEC_index (ipa_opt_pass,\n+\t\t       \t\t  old_transforms_to_apply,\n+\t\t\t\t  i));\n+    }\n   \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges"}]}