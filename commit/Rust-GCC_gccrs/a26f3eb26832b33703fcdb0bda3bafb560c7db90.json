{"sha": "a26f3eb26832b33703fcdb0bda3bafb560c7db90", "node_id": "C_kwDOANBUbNoAKGEyNmYzZWIyNjgzMmIzMzcwM2ZjZGIwYmRhM2JhZmI1NjBjN2RiOTA", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-10T12:59:40Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-03T06:42:32Z"}, "message": "Implement class vrange_storage to stream ranges to long term memory.\n\nThis patch implements a storage class that will be used to stream out\nranges to long term storage, initially in SSA_NAME_RANGE_INFO, but it\nis flexible enough to use with our obstack allocator.  For instance,\nin the future we could use it in the ranger cache to save memory.\n\nThe current size of range_info_def which is used in\nSSA_NAME_RANGE_INFO is 16 bytes.  With this patch, the size of the\nslot (irange_storage_slot) will be 24 bytes.  But we'll have the\nability to be able to store up to 5 pairs of sub-ranges if necessary.\nIf we ever need to save more (say for switches), we could explore a\ntrailing_wide_ints structure with a pointer to the m_len[N] bits as\nJakub has suggested.\n\nIn follow-up patches I will contribute the SSA_NAME_RANGE_INFO changes\nas well as changes storing the nonzero bits within an irange.\n\nFor reference, the main interface is rather simple:\n\nclass vrange_storage\n{\npublic:\n  vrange_storage (vrange_allocator *alloc) : m_alloc (alloc) { }\n  void *alloc_slot (const vrange &r);\n  void free (void *slot);\n  void get_vrange (const void *slot, vrange &r, tree type);\n  void set_vrange (void *slot, const vrange &r);\n  static bool fits_p (const void *slot, const vrange &r);\n};\n\nThe above class will have the knowledge to stream out the different\nranges we support (currently only irange_storage_slot).  As has been\ndiscussed, the irange storage will use trailing wide ints:\n\nclass GTY ((variable_size)) irange_storage_slot\n{\n<snip>\n<snip>\n  // This is the maximum number of wide_int's allowed in the trailing\n  // ints structure, without going over 16 bytes (128 bits) in the\n  // control word that preceeds the HOST_WIDE_INTs in\n  // trailing_wide_ints::m_val[].\n  static const unsigned MAX_INTS = 12;\n\n  // Maximum number of range pairs we can handle, considering the\n  // nonzero bits take one wide_int.\n  static const unsigned MAX_PAIRS = (MAX_INTS - 1) / 2;\n\n  trailing_wide_ints<MAX_INTS> m_ints;\n};\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* Makefile.in (OBJS): Add value-range-storage.o.\n\t(GTFILES): Add value-range-storage.h.\n\t* gengtype.cc (open_base_files): Add value-range-storage.h.\n\t* value-range-storage.cc: New file.\n\t* value-range-storage.h: New file.", "tree": {"sha": "70fba2d1e0fb215a27827c532aa50e76078fb317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70fba2d1e0fb215a27827c532aa50e76078fb317"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a26f3eb26832b33703fcdb0bda3bafb560c7db90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a26f3eb26832b33703fcdb0bda3bafb560c7db90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a26f3eb26832b33703fcdb0bda3bafb560c7db90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a26f3eb26832b33703fcdb0bda3bafb560c7db90/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f150dc1bd11802b70277f0fa209f2d23695a1095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f150dc1bd11802b70277f0fa209f2d23695a1095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f150dc1bd11802b70277f0fa209f2d23695a1095"}], "stats": {"total": 300, "additions": 300, "deletions": 0}, "files": [{"sha": "3ae237024265cb642a35dd8027694a436c573482", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a26f3eb26832b33703fcdb0bda3bafb560c7db90", "patch": "@@ -1711,6 +1711,7 @@ OBJS = \\\n \tvalue-query.o \\\n \tvalue-range.o \\\n \tvalue-range-equiv.o \\\n+\tvalue-range-storage.o \\\n \tvalue-relation.o \\\n \tvalue-prof.o \\\n \tvar-tracking.o \\\n@@ -2719,6 +2720,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-ssanames.h \\\n   $(srcdir)/tree-vrp.h \\\n   $(srcdir)/value-range.h \\\n+  $(srcdir)/value-range-storage.h \\\n   $(srcdir)/ipa-prop.h \\\n   $(srcdir)/trans-mem.cc \\\n   $(srcdir)/lto-streamer.h \\"}, {"sha": "42363439bd8bd73ad5215b12145d1b44eedc9cca", "filename": "gcc/gengtype.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2Fgengtype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2Fgengtype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.cc?ref=a26f3eb26832b33703fcdb0bda3bafb560c7db90", "patch": "@@ -1705,6 +1705,7 @@ open_base_files (void)\n       \"stmt.h\", \"expr.h\", \"alloc-pool.h\", \"cselib.h\", \"insn-addr.h\",\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"internal-fn.h\",\n       \"gimple-iterator.h\", \"gimple-fold.h\", \"value-range.h\",\n+      \"value-range-storage.h\",\n       \"tree-eh.h\", \"gimple-ssa.h\", \"tree-cfg.h\",\n       \"tree-vrp.h\", \"tree-phinodes.h\", \"ssa-iterators.h\", \"stringpool.h\",\n       \"tree-ssanames.h\", \"tree-ssa-loop.h\", \"tree-ssa-loop-ivopts.h\","}, {"sha": "ea9b18f993b7fc653da2df2c292f000aabd27395", "filename": "gcc/value-range-storage.cc", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=a26f3eb26832b33703fcdb0bda3bafb560c7db90", "patch": "@@ -0,0 +1,212 @@\n+/* Support routines for vrange storage.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-range.h\"\n+#include \"value-range-storage.h\"\n+\n+// Return a newly allocated slot holding R.\n+\n+void *\n+vrange_storage::alloc_slot (const vrange &r)\n+{\n+  gcc_checking_assert (m_alloc);\n+\n+  if (is_a <irange> (r))\n+    return irange_storage_slot::alloc_slot (*m_alloc, as_a <irange> (r));\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+// Set SLOT to R.\n+\n+void\n+vrange_storage::set_vrange (void *slot, const vrange &r)\n+{\n+  if (is_a <irange> (r))\n+    {\n+      irange_storage_slot *s = static_cast <irange_storage_slot *> (slot);\n+      gcc_checking_assert (s->fits_p (as_a <irange> (r)));\n+      s->set_irange (as_a <irange> (r));\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+// Restore R from SLOT.  TYPE is the type of R.\n+\n+void\n+vrange_storage::get_vrange (const void *slot, vrange &r, tree type)\n+{\n+  if (is_a <irange> (r))\n+    {\n+      const irange_storage_slot *s\n+\t= static_cast <const irange_storage_slot *> (slot);\n+      s->get_irange (as_a <irange> (r), type);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+// Return TRUE if SLOT can fit R.\n+\n+bool\n+vrange_storage::fits_p (const void *slot, const vrange &r)\n+{\n+  if (is_a <irange> (r))\n+    {\n+      const irange_storage_slot *s\n+\t= static_cast <const irange_storage_slot *> (slot);\n+      return s->fits_p (as_a <irange> (r));\n+    }\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+// Factory that creates a new irange_storage_slot object containing R.\n+// This is the only way to construct an irange slot as stack creation\n+// is disallowed.\n+\n+irange_storage_slot *\n+irange_storage_slot::alloc_slot (vrange_allocator &allocator, const irange &r)\n+{\n+  size_t size = irange_storage_slot::size (r);\n+  irange_storage_slot *p\n+    = static_cast <irange_storage_slot *> (allocator.alloc (size));\n+  new (p) irange_storage_slot (r);\n+  return p;\n+}\n+\n+// Initialize the current slot with R.\n+\n+irange_storage_slot::irange_storage_slot (const irange &r)\n+{\n+  gcc_checking_assert (!r.undefined_p ());\n+\n+  unsigned prec = TYPE_PRECISION (r.type ());\n+  unsigned n = num_wide_ints_needed (r);\n+  if (n > MAX_INTS)\n+    {\n+      int_range<MAX_PAIRS> squash (r);\n+      m_ints.set_precision (prec, num_wide_ints_needed (squash));\n+      set_irange (squash);\n+    }\n+  else\n+    {\n+      m_ints.set_precision (prec, n);\n+      set_irange (r);\n+    }\n+}\n+\n+// Store R into the current slot.\n+\n+void\n+irange_storage_slot::set_irange (const irange &r)\n+{\n+  gcc_checking_assert (fits_p (r));\n+\n+  //m_ints[0] = r.get_nonzero_bits ();\n+  unsigned pairs = r.num_pairs ();\n+  for (unsigned i = 0; i < pairs; ++i)\n+    {\n+      m_ints[i*2 + 1] = r.lower_bound (i);\n+      m_ints[i*2 + 2] = r.upper_bound (i);\n+    }\n+}\n+\n+// Restore a range of TYPE from the current slot into R.\n+\n+void\n+irange_storage_slot::get_irange (irange &r, tree type) const\n+{\n+  gcc_checking_assert (TYPE_PRECISION (type) == m_ints.get_precision ());\n+\n+  r.set_undefined ();\n+  unsigned nelements = m_ints.num_elements ();\n+  for (unsigned i = 1; i < nelements; i += 2)\n+    {\n+      int_range<2> tmp (type, m_ints[i], m_ints[i + 1]);\n+      r.union_ (tmp);\n+    }\n+  //r.set_nonzero_bits (get_nonzero_bits ());\n+}\n+\n+// Return the size in bytes to allocate a slot that can hold R.\n+\n+size_t\n+irange_storage_slot::size (const irange &r)\n+{\n+  gcc_checking_assert (!r.undefined_p ());\n+\n+  unsigned prec = TYPE_PRECISION (r.type ());\n+  unsigned n = num_wide_ints_needed (r);\n+  if (n > MAX_INTS)\n+    n = MAX_INTS;\n+  return (sizeof (irange_storage_slot)\n+\t  + trailing_wide_ints<MAX_INTS>::extra_size (prec, n));\n+}\n+\n+// Return the number of wide ints needed to represent R.\n+\n+unsigned int\n+irange_storage_slot::num_wide_ints_needed (const irange &r)\n+{\n+  return r.num_pairs () * 2 + 1;\n+}\n+\n+// Return TRUE if R fits in the current slot.\n+\n+bool\n+irange_storage_slot::fits_p (const irange &r) const\n+{\n+  return m_ints.num_elements () >= num_wide_ints_needed (r);\n+}\n+\n+// Dump the current slot.\n+\n+void\n+irange_storage_slot::dump () const\n+{\n+  fprintf (stderr, \"raw irange_storage_slot:\\n\");\n+  for (unsigned i = 1; i < m_ints.num_elements (); i += 2)\n+    {\n+      m_ints[i].dump ();\n+      m_ints[i + 1].dump ();\n+    }\n+  fprintf (stderr, \"NONZERO \");\n+  wide_int nz = get_nonzero_bits ();\n+  nz.dump ();\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const irange_storage_slot &storage)\n+{\n+  storage.dump ();\n+  fprintf (stderr, \"\\n\");\n+}"}, {"sha": "58c5e114320b6b522b7c8ced3acf148179a6f227", "filename": "gcc/value-range-storage.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2Fvalue-range-storage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a26f3eb26832b33703fcdb0bda3bafb560c7db90/gcc%2Fvalue-range-storage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.h?ref=a26f3eb26832b33703fcdb0bda3bafb560c7db90", "patch": "@@ -0,0 +1,85 @@\n+/* Support routines for vrange storage.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VALUE_RANGE_STORAGE_H\n+#define GCC_VALUE_RANGE_STORAGE_H\n+\n+// This class is used to allocate chunks of memory that can store\n+// ranges as memory efficiently as possible.  It is meant to be used\n+// when long term storage of a range is needed.  The class can be used\n+// with any vrange_allocator (i.e. alloca or GC).\n+\n+class vrange_storage\n+{\n+public:\n+  vrange_storage (vrange_allocator *alloc) : m_alloc (alloc) { }\n+  void *alloc_slot (const vrange &r);\n+  void free (void *slot) { m_alloc->free (slot); }\n+  void get_vrange (const void *slot, vrange &r, tree type);\n+  void set_vrange (void *slot, const vrange &r);\n+  static bool fits_p (const void *slot, const vrange &r);\n+private:\n+  DISABLE_COPY_AND_ASSIGN (vrange_storage);\n+  vrange_allocator *m_alloc;\n+};\n+\n+\n+// INTERNAL USE ONLY.  The remaining interfaces are only exposed for\n+// the GTY machinery to play nice with tree_ssa_name.\n+\n+// A chunk of memory pointing to an irange storage.\n+\n+class GTY ((variable_size)) irange_storage_slot\n+{\n+public:\n+  static irange_storage_slot *alloc_slot (vrange_allocator &, const irange &r);\n+  void set_irange (const irange &r);\n+  void get_irange (irange &r, tree type) const;\n+  wide_int get_nonzero_bits () const { return m_ints[0]; }\n+  bool fits_p (const irange &r) const;\n+  static size_t size (const irange &r);\n+  void dump () const;\n+private:\n+  DISABLE_COPY_AND_ASSIGN (irange_storage_slot);\n+  friend void gt_ggc_mx_irange_storage_slot (void *);\n+  friend void gt_pch_p_19irange_storage_slot (void *, void *,\n+\t\t\t\t\t      gt_pointer_operator, void *);\n+  friend void gt_pch_nx_irange_storage_slot (void *);\n+\n+  // This is the maximum number of wide_int's allowed in the trailing\n+  // ints structure, without going over 16 bytes (128 bits) in the\n+  // control word that preceeds the HOST_WIDE_INTs in\n+  // trailing_wide_ints::m_val[].\n+  static const unsigned MAX_INTS = 12;\n+\n+  // Maximum number of range pairs we can handle, considering the\n+  // nonzero bits take one wide_int.\n+  static const unsigned MAX_PAIRS = (MAX_INTS - 1) / 2;\n+\n+  // Constructor is private to disallow stack initialization.  Use\n+  // alloc_slot() to create objects.\n+  irange_storage_slot (const irange &r);\n+\n+  static unsigned num_wide_ints_needed (const irange &r);\n+\n+  trailing_wide_ints<MAX_INTS> m_ints;\n+};\n+\n+#endif // GCC_VALUE_RANGE_STORAGE_H"}]}