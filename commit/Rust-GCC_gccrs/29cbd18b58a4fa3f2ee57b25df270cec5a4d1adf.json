{"sha": "29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjljYmQxOGI1OGE0ZmEzZjJlZTU3YjI1ZGYyNzBjZWM1YTRkMWFkZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-06-21T16:59:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-06-21T16:59:28Z"}, "message": "tree-inline.c (copy_edges_for_bb): Minor tweak.\n\n\t* tree-inline.c (copy_edges_for_bb): Minor tweak.\n\t(maybe_move_debug_stmts_to_successors): Also reset the locus of the\n\tdebug statement when resetting its value.\n\t(expand_call_inline): Copy the locus of the call onto the assignment\n\tof the return value, if any.  Use local variable in more cases.\n\nFrom-SVN: r261853", "tree": {"sha": "28b5c759c6baf61c94710cffb4e008f5d5a38c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28b5c759c6baf61c94710cffb4e008f5d5a38c31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf/comments", "author": null, "committer": null, "parents": [{"sha": "e9df6a8f03d5c6422350865a374e5f5b948c05ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9df6a8f03d5c6422350865a374e5f5b948c05ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9df6a8f03d5c6422350865a374e5f5b948c05ed"}], "stats": {"total": 33, "additions": 22, "deletions": 11}, "files": [{"sha": "b76ae5a7902d9e4ce8889ebb68c903431bf8f72f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf", "patch": "@@ -1,3 +1,11 @@\n+2018-06-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-inline.c (copy_edges_for_bb): Minor tweak.\n+\t(maybe_move_debug_stmts_to_successors): Also reset the locus of the\n+\tdebug statement when resetting its value.\n+\t(expand_call_inline): Copy the locus of the call onto the assignment\n+\tof the return value, if any.  Use local variable in more cases.\n+\n 2018-06-21  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-pure-const.c (propagate_nothrow): Use"}, {"sha": "82e6d4c7d75eee65fb27af91da7f17cab3127297", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=29cbd18b58a4fa3f2ee57b25df270cec5a4d1adf", "patch": "@@ -2151,7 +2151,6 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n   edge_iterator ei;\n   edge old_edge;\n   gimple_stmt_iterator si;\n-  int flags;\n   bool need_debug_cleanup = false;\n \n   /* Use the indices from the original blocks to create edges for the\n@@ -2160,14 +2159,14 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n     if (!(old_edge->flags & EDGE_EH))\n       {\n \tedge new_edge;\n+\tint flags = old_edge->flags;\n \n-\tflags = old_edge->flags;\n-\n-\t/* Return edges do get a FALLTHRU flag when the get inlined.  */\n+\t/* Return edges do get a FALLTHRU flag when they get inlined.  */\n \tif (old_edge->dest->index == EXIT_BLOCK\n-\t    && !(old_edge->flags & (EDGE_TRUE_VALUE|EDGE_FALSE_VALUE|EDGE_FAKE))\n+\t    && !(flags & (EDGE_TRUE_VALUE|EDGE_FALSE_VALUE|EDGE_FAKE))\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  flags |= EDGE_FALLTHRU;\n+\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n \tnew_edge->probability = old_edge->probability;\n       }\n@@ -2502,7 +2501,10 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n \t      si = ssi;\n \t      gsi_prev (&ssi);\n \t      if (!single_pred_p (e->dest) && gimple_debug_bind_p (stmt))\n-\t\tgimple_debug_bind_reset_value (stmt);\n+\t\t{\n+\t\t  gimple_debug_bind_reset_value (stmt);\n+\t\t  gimple_set_location (stmt, UNKNOWN_LOCATION);\n+\t\t}\n \t      gsi_remove (&si, false);\n \t      gsi_insert_before (&dsi, stmt, GSI_SAME_STMT);\n \t      continue;\n@@ -2515,10 +2517,10 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n \t\t{\n \t\t  value = gimple_debug_bind_get_value (stmt);\n \t\t  value = unshare_expr (value);\n+\t\t  new_stmt = gimple_build_debug_bind (var, value, stmt);\n \t\t}\n \t      else\n-\t\tvalue = NULL_TREE;\n-\t      new_stmt = gimple_build_debug_bind (var, value, stmt);\n+\t\tnew_stmt = gimple_build_debug_bind (var, NULL_TREE, NULL);\n \t    }\n \t  else if (gimple_debug_source_bind_p (stmt))\n \t    {\n@@ -4456,9 +4458,9 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n   id->assign_stmts.create (0);\n \n   /* Update the callers EH personality.  */\n-  if (DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl))\n+  if (DECL_FUNCTION_PERSONALITY (fn))\n     DECL_FUNCTION_PERSONALITY (cg_edge->caller->decl)\n-      = DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl);\n+      = DECL_FUNCTION_PERSONALITY (fn);\n \n   /* Split the block before the GIMPLE_CALL.  */\n   stmt_gsi = gsi_for_stmt (stmt);\n@@ -4711,6 +4713,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n     {\n       gimple *old_stmt = stmt;\n       stmt = gimple_build_assign (gimple_call_lhs (stmt), use_retvar);\n+      gimple_set_location (stmt, gimple_location (old_stmt));\n       gsi_replace (&stmt_gsi, stmt, false);\n       maybe_clean_or_replace_eh_stmt (old_stmt, stmt);\n       /* Append a clobber for id->retvar if easily possible.  */\n@@ -4806,7 +4809,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n      variables in the function when the blocks get blown away as soon as we\n      remove the cgraph node.  */\n   if (gimple_block (stmt))\n-    (*debug_hooks->outlining_inline_function) (cg_edge->callee->decl);\n+    (*debug_hooks->outlining_inline_function) (fn);\n \n   /* Update callgraph if needed.  */\n   cg_edge->callee->remove ();"}]}