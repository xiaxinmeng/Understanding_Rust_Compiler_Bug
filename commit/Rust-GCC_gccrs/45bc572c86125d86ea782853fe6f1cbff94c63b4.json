{"sha": "45bc572c86125d86ea782853fe6f1cbff94c63b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDViYzU3MmM4NjEyNWQ4NmVhNzgyODUzZmU2ZjFjYmZmOTRjNjNiNA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael.morin@tele2.fr", "date": "2008-10-30T20:45:09Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-10-30T20:45:09Z"}, "message": "re PR fortran/37903 (wrong-code for complicated vector subscripts)\n\n2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n\n        PR fortran/37903\n        * trans-array.c (gfc_trans_create_temp_array): If n is less\n\tthan the temporary dimension, assert that loop->from is\n\tzero (reverts to earlier versions). If there is at least one\n\tnull loop->to[n], it is a callee allocated array so set the\n\tsize to NULL and break.\n\t(gfc_trans_constant_array_constructor): Set the offset to zero.\n\t(gfc_trans_array_constructor): Remove loop shifting around the\n\ttemporary creation.\n\t(gfc_conv_loop_setup): Prefer zero-based descriptors if\n\tpossible.  Calculate the translation from loop variables to\n\tarray indices if an array constructor.\n\n2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n\n        PR fortran/37749\n        * trans-array.c (gfc_trans_create_temp_array): If size is NULL\n\tuse the array bounds for loop->to.\n\n2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n\n        PR fortran/37903\n        * gfortran.dg/vector_subscript_4.f90: New test.\n\n2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n\n        PR fortran/37749\n        * gfortran.dg/vector_subscript__5.f90: New test.\n\nFrom-SVN: r141467", "tree": {"sha": "9d0afc69002d14e4a8f26dc27e704b7126263fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d0afc69002d14e4a8f26dc27e704b7126263fe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45bc572c86125d86ea782853fe6f1cbff94c63b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45bc572c86125d86ea782853fe6f1cbff94c63b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45bc572c86125d86ea782853fe6f1cbff94c63b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45bc572c86125d86ea782853fe6f1cbff94c63b4/comments", "author": null, "committer": null, "parents": [{"sha": "73c07a3e71de3e5155e3687a52f7963edece0a01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c07a3e71de3e5155e3687a52f7963edece0a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c07a3e71de3e5155e3687a52f7963edece0a01"}], "stats": {"total": 128, "additions": 92, "deletions": 36}, "files": [{"sha": "6ebb660f62c5a056c00ce41519e1f96fc6ea2a49", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=45bc572c86125d86ea782853fe6f1cbff94c63b4", "patch": "@@ -1,3 +1,24 @@\n+2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+        PR fortran/37903\n+        * trans-array.c (gfc_trans_create_temp_array): If n is less\n+\tthan the temporary dimension, assert that loop->from is\n+\tzero (reverts to earlier versions). If there is at least one\n+\tnull loop->to[n], it is a callee allocated array so set the\n+\tsize to NULL and break.\n+\t(gfc_trans_constant_array_constructor): Set the offset to zero.\n+\t(gfc_trans_array_constructor): Remove loop shifting around the\n+\ttemporary creation.\n+\t(gfc_conv_loop_setup): Prefer zero-based descriptors if\n+\tpossible.  Calculate the translation from loop variables to\n+\tarray indices if an array constructor.\n+\n+2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+        PR fortran/37749\n+        * trans-array.c (gfc_trans_create_temp_array): If size is NULL\n+\tuse the array bounds for loop->to.\n+\n 2008-10-28  Tobias Burnus  <burnus@net-b.de>\n \n \t* intrinsic.texi: Update OpenMP section for OMPv3."}, {"sha": "5080e0fa5cc79b898ea032133bf4b9fa007221c8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=45bc572c86125d86ea782853fe6f1cbff94c63b4", "patch": "@@ -595,9 +595,9 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n   for (dim = 0; dim < info->dimen; dim++)\n     {\n       n = loop->order[dim];\n-      /* TODO: Investigate why \"if (n < loop->temp_dim)\n-\t gcc_assert (integer_zerop (loop->from[n]));\" fails here.  */\n-      if (n >= loop->temp_dim)\n+      if (n < loop->temp_dim)\n+      gcc_assert (integer_zerop (loop->from[n]));\n+      else\n \t{\n \t  /* Callee allocated arrays may not have a known bound yet.  */\n           if (loop->to[n])\n@@ -642,9 +642,18 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   or_expr = NULL_TREE;\n \n+  /* If there is at least one null loop->to[n], it is a callee allocated \n+     array.  */\n   for (n = 0; n < info->dimen; n++)\n-    {\n-      if (loop->to[n] == NULL_TREE)\n+    if (loop->to[n] == NULL_TREE)\n+      {\n+\tsize = NULL_TREE;\n+\tbreak;\n+      }\n+\n+  for (n = 0; n < info->dimen; n++)\n+     {\n+      if (size == NULL_TREE)\n         {\n \t  /* For a callee allocated array express the loop bounds in terms\n \t     of the descriptor fields.  */\n@@ -653,7 +662,6 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \t\t\t gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]),\n \t\t\t gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]));\n           loop->to[n] = tmp;\n-          size = NULL_TREE;\n           continue;\n         }\n         \n@@ -1628,8 +1636,7 @@ gfc_trans_constant_array_constructor (gfc_loopinfo * loop,\n \n   info->descriptor = tmp;\n   info->data = build_fold_addr_expr (tmp);\n-  info->offset = fold_build1 (NEGATE_EXPR, gfc_array_index_type,\n-\t\t\t      loop->from[0]);\n+  info->offset = gfc_index_zero_node;\n \n   for (i = 0; i < info->dimen; i++)\n     {\n@@ -1692,7 +1699,6 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n   tree offsetvar;\n   tree desc;\n   tree type;\n-  tree loopfrom;\n   bool dynamic;\n   bool old_first_len, old_typespec_chararray_ctor;\n   tree old_first_len_val;\n@@ -1804,34 +1810,9 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n \t}\n     }\n \n-  /* Temporarily reset the loop variables, so that the returned temporary\n-     has the right size and bounds.  This seems only to be necessary for\n-     1D arrays.  */\n-  if (!integer_zerop (loop->from[0]) && loop->dimen == 1)\n-    {\n-      loopfrom = loop->from[0];\n-      loop->from[0] = gfc_index_zero_node;\n-      loop->to[0] = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t loop->to[0], loopfrom);\n-    }\n-  else\n-    loopfrom = NULL_TREE;\n-\n   gfc_trans_create_temp_array (&loop->pre, &loop->post, loop, &ss->data.info,\n \t\t\t       type, dynamic, true, false, where);\n \n-  if (loopfrom != NULL_TREE)\n-    {\n-      loop->from[0] = loopfrom;\n-      loop->to[0] = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t loop->to[0], loopfrom);\n-      /* In the case of a non-zero from, the temporary needs an offset\n-\t so that subsequent indexing is correct.  */\n-      ss->data.info.offset = fold_build1 (NEGATE_EXPR,\n-\t\t\t\t\t  gfc_array_index_type,\n-\t\t\t\t\t  loop->from[0]);\n-    }\n-\n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n   offsetvar = gfc_create_var_np (gfc_array_index_type, \"offset\");\n@@ -3379,7 +3360,10 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t  if (ss->shape)\n \t    {\n \t      /* The frontend has worked out the size for us.  */\n-\t      loopspec[n] = ss;\n+\t      if (!loopspec[n] || !loopspec[n]->shape\n+\t\t    || !integer_zerop (loopspec[n]->data.info.start[n]))\n+\t\t/* Prefer zero-based descriptors if possible.  */\n+\t\tloopspec[n] = ss;\n \t      continue;\n \t    }\n \n@@ -3556,7 +3540,9 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n   /* Calculate the translation from loop variables to array indices.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n-      if (ss->type != GFC_SS_SECTION && ss->type != GFC_SS_COMPONENT)\n+      if (ss->type != GFC_SS_SECTION && ss->type != GFC_SS_COMPONENT\n+\t    && ss->type != GFC_SS_CONSTRUCTOR)\n+\n \tcontinue;\n \n       info = &ss->data.info;"}, {"sha": "85e97f3277c48cff21b4c8ac0fceee9e9e2206c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=45bc572c86125d86ea782853fe6f1cbff94c63b4", "patch": "@@ -1,3 +1,13 @@\n+2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+        PR fortran/37903\n+        * gfortran.dg/vector_subscript_4.f90: New test.\n+\n+2008-10-30  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+        PR fortran/37749\n+        * gfortran.dg/vector_subscript__5.f90: New test.\n+\n 2008-10-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.target/s390/pr36822.c: Avoid cast to pointer from integer"}, {"sha": "204468456e10f4a48e9ca846166c59155e26d6e3", "filename": "gcc/testsuite/gfortran.dg/vector_subscript_4.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_4.f90?ref=45bc572c86125d86ea782853fe6f1cbff94c63b4", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR37903, in which the temporary for the vector index\n+! got the wrong size.\n+!\n+! Contributed by Mikael Morin <mikael.morin@tele2.fr>\n+!\n+     integer :: i(-1:1) = 1, j(3) = 1, k(3)\n+      k = j((/1,1,1/)+i)\n+      end\n+! { dg-final { scan-tree-dump-times \"A\\.3\\\\\\[3\\\\\\]\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "88eb358e6bf10f5a7aef4eb018233322732b1e3f", "filename": "gcc/testsuite/gfortran.dg/vector_subscript_5.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45bc572c86125d86ea782853fe6f1cbff94c63b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_5.f90?ref=45bc572c86125d86ea782853fe6f1cbff94c63b4", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR37749 in which the expression in line 13 would cause an ICE\n+! because the upper value of the loop range was not set.\n+!\n+! Contributed by Jakub Jelinek <jakub@gcc.gnu.org>\n+!\n+subroutine subr (m, n, a, b, c, d, p)\n+  implicit none\n+  integer m, n\n+  real a(m,n), b(m,n), c(n,n), d(m,n)\n+  integer p(n)\n+  d = a(:,p) - matmul(b, c)\n+end subroutine\n+\n+  implicit none\n+  integer i\n+  real a(3,2), b(3,2), c(2,2), d(3,2)\n+  integer p(2)\n+  a = reshape ((/(i, i = 1, 6)/), (/3, 2/))\n+  b = 1\n+  c = 2\n+  p = 2\n+  call subr (3, 2, a, b, c, d, p)\n+  if (any (d .ne. reshape ((/(mod (i + 2, 3), i = 1, 6)/), (/3, 2/)))) call abort\n+end"}]}