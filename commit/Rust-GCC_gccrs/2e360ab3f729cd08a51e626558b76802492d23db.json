{"sha": "2e360ab3f729cd08a51e626558b76802492d23db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUzNjBhYjNmNzI5Y2QwOGE1MWU2MjY1NThiNzY4MDI0OTJkMjNkYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-30T23:51:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-30T23:51:07Z"}, "message": "(BITS_PER_WORD): TARGET_POWERPC64 dependent.\n\n(MAX_BITS_PER_WORD): Define.\n(UNITS_PER_WORD): TARGET_POWERPC64 dependent.\n(MAX_UNITS_PER_WORD): Define.\n(UNITS_PER_FP_WORD): Define.\n(HARD_REGNO_NREGS): Use MAX_UNITS_PER_FP_WORD.\n(HARD_REGNO_MODE_OK): Likewise.\n(CLASS_MAX_NREGS): Likewise.\n(MOVE_MAX): TARGET_POWER and TARGET_POWERPC64 dependent.\n(MAX_MOVE_MAX): Define.\n\nFrom-SVN: r8590", "tree": {"sha": "6ee75a23835b6a9e97c4b6edcbf2fc334064560b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ee75a23835b6a9e97c4b6edcbf2fc334064560b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e360ab3f729cd08a51e626558b76802492d23db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e360ab3f729cd08a51e626558b76802492d23db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e360ab3f729cd08a51e626558b76802492d23db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e360ab3f729cd08a51e626558b76802492d23db/comments", "author": null, "committer": null, "parents": [{"sha": "414d3ee46f170886e41e083912df38e21b9440d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/414d3ee46f170886e41e083912df38e21b9440d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/414d3ee46f170886e41e083912df38e21b9440d2"}], "stats": {"total": 16, "additions": 10, "deletions": 6}, "files": [{"sha": "e2858f684e4247b98868ac50c3021a6b425b324d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e360ab3f729cd08a51e626558b76802492d23db/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e360ab3f729cd08a51e626558b76802492d23db/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2e360ab3f729cd08a51e626558b76802492d23db", "patch": "@@ -277,10 +277,13 @@ extern char *rs6000_cpu_string;\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n+#define BITS_PER_WORD (TARGET_POWERPC64 ? 64 : 32)\n+#define MAX_BITS_PER_WORD 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n+#define UNITS_PER_WORD (TARGET_POWERPC64 ? 8 : 4)\n+#define MAX_UNITS_PER_WORD 8\n+#define UNITS_PER_FP_WORD 8\n \n /* Type used for ptrdiff_t, as a string used in a declaration.  */\n #define PTRDIFF_TYPE \"int\"\n@@ -434,7 +437,7 @@ extern char *rs6000_cpu_string;\n \n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   (FP_REGNO_P (REGNO)\t\t\t\\\n-   ? ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\\n+   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n@@ -447,7 +450,7 @@ extern char *rs6000_cpu_string;\n   (FP_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n    (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n     || (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n-\t&& GET_MODE_SIZE (MODE) == 2 * UNITS_PER_WORD))\t\t\\\n+\t&& GET_MODE_SIZE (MODE) == UNITS_PER_FP_WORD))\t\t\\\n    : CR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC\t\\\n    : ! INT_REGNO_P (REGNO) ? (GET_MODE_CLASS (MODE) == MODE_INT\t\\\n \t\t\t      && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD) \\\n@@ -718,7 +721,7 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n    except in the FP regs, where a single reg is enough for two words.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n  ((CLASS) == FLOAT_REGS\t\t\t\\\n-  ? ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\\n+  ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* If defined, gives a class of registers that cannot be used as the\n@@ -1364,7 +1367,8 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX 16\n+#define MOVE_MAX (TARGET_POWER ? 16 : (TARGET_POWERPC64 ? 8 : 4))\n+#define MAX_MOVE_MAX 16\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n    Also non-zero if doing byte operations (specifically shifts) in registers"}]}