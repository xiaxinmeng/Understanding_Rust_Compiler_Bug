{"sha": "f947ee3467dee8ca1b681c459804b02657113e9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk0N2VlMzQ2N2RlZThjYTFiNjgxYzQ1OTgwNGIwMjY1NzExM2U5ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-23T11:04:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-23T11:04:39Z"}, "message": "[multiple changes]\n\n2011-11-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_Iterator_Loop): Wrap the expanded loop\n\tand the cursor declarations in a block, so that the loop variable\n\tis local to the construct.\n\n2011-11-23  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-coorma.ads, a-ciorma.ads, a-cborma.ads (Iterate): Returns\n\ttype Reversible_Iterator'Class.\n\t* a-coorma.adb, a-ciorma.adb, a-cborma.adb (Iterator):\n\tDeclare type as limited.\n\t(First, Last): Return value depends on iterator's start node value.\n\t(Next, Previous): Call corresponding Cursor-based operation.\n\t(Iterate): Indicate whether complete or partial iteration\n\nFrom-SVN: r181659", "tree": {"sha": "5fb6c077b0e3f24d74204d0e539e282bdb998d66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fb6c077b0e3f24d74204d0e539e282bdb998d66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f947ee3467dee8ca1b681c459804b02657113e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f947ee3467dee8ca1b681c459804b02657113e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f947ee3467dee8ca1b681c459804b02657113e9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f947ee3467dee8ca1b681c459804b02657113e9d/comments", "author": null, "committer": null, "parents": [{"sha": "fb2bd3a70d29393806e9c21c9568de1170fee9f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb2bd3a70d29393806e9c21c9568de1170fee9f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb2bd3a70d29393806e9c21c9568de1170fee9f9"}], "stats": {"total": 461, "additions": 368, "deletions": 93}, "files": [{"sha": "30486c131c55d498a13eed522ab0ea4888c8edc0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -1,3 +1,19 @@\n+2011-11-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Iterator_Loop): Wrap the expanded loop\n+\tand the cursor declarations in a block, so that the loop variable\n+\tis local to the construct.\n+\n+2011-11-23  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-coorma.ads, a-ciorma.ads, a-cborma.ads (Iterate): Returns\n+\ttype Reversible_Iterator'Class.\n+\t* a-coorma.adb, a-ciorma.adb, a-cborma.adb (Iterator):\n+\tDeclare type as limited.\n+\t(First, Last): Return value depends on iterator's start node value.\n+\t(Next, Previous): Call corresponding Cursor-based operation.\n+\t(Iterate): Indicate whether complete or partial iteration\n+\n 2011-11-23  Robert Dewar  <dewar@adacore.com>\n \n \t* errout.adb: Minor reformattin (Finalize): Take templates into"}, {"sha": "940d6efa9cbcc4ebf64d72ce2f5ccd2e5be451e8", "filename": "gcc/ada/a-cborma.adb", "status": "modified", "additions": 98, "deletions": 18, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.adb?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -39,7 +39,7 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Bounded_Ordered_Maps is\n \n-   type Iterator is new\n+   type Iterator is limited new\n      Map_Iterator_Interfaces.Reversible_Iterator with record\n         Container : Map_Access;\n         Node      : Count_Type;\n@@ -579,12 +579,24 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n-      F : constant Count_Type := Object.Container.First;\n    begin\n-      if F = 0 then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is 0, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is positive, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return Bounded_Ordered_Maps.First (Object.Container.all);\n       else\n-         return Cursor'(Object.Container.all'Unchecked_Access, F);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end First;\n \n@@ -886,22 +898,62 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n    end Iterate;\n \n    function Iterate\n-     (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'class\n+     (Container : Map) return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator :=\n-             (Container'Unrestricted_Access, Container.First);\n    begin\n-      return It;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is 0 (as is the case here), this means the iterator object\n+      --  was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => 0);\n    end Iterate;\n \n    function Iterate\n      (Container : Map;\n       Start     : Cursor)\n-      return Map_Iterator_Interfaces.Reversible_Iterator'class\n+      return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unrestricted_Access, Start.Node);\n    begin\n-      return It;\n+\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is positive (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. (Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.)\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ---------\n@@ -935,12 +987,24 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n-      F : constant Count_Type := Object.Container.Last;\n    begin\n-      if F = 0 then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is 0, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is positive, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return Bounded_Ordered_Maps.Last (Object.Container.all);\n       else\n-         return Cursor'(Object.Container.all'Unchecked_Access, F);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end Last;\n \n@@ -1044,8 +1108,16 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n      (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong map\";\n+      end if;\n+\n       return Next (Position);\n    end Next;\n \n@@ -1095,8 +1167,16 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n      (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong map\";\n+      end if;\n+\n       return Previous (Position);\n    end Previous;\n "}, {"sha": "05c55730f101d5aefe83e60f1598c7616c6b95ec", "filename": "gcc/ada/a-cborma.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-cborma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-cborma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.ads?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -227,17 +227,18 @@ package Ada.Containers.Bounded_Ordered_Maps is\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n \n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n    function Iterate\n-     (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'class;\n+     (Container : Map)\n+      return Map_Iterator_Interfaces.Reversible_Iterator'Class;\n \n    function Iterate\n      (Container : Map;\n       Start     : Cursor)\n-      return Map_Iterator_Interfaces.Reversible_Iterator'class;\n-\n-   procedure Reverse_Iterate\n-     (Container : Map;\n-      Process   : not null access procedure (Position : Cursor));\n+      return Map_Iterator_Interfaces.Reversible_Iterator'Class;\n \n private\n "}, {"sha": "ea8fa75636b8b1408c871b51f99926273c2160cc", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 109, "deletions": 27, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -40,7 +40,7 @@ with System; use type System.Address;\n package body Ada.Containers.Indefinite_Ordered_Maps is\n    pragma Suppress (All_Checks);\n \n-   type Iterator is new\n+   type Iterator is limited new\n      Map_Iterator_Interfaces.Reversible_Iterator with record\n         Container : Map_Access;\n         Node      : Node_Access;\n@@ -558,11 +558,25 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n-      M : constant Map_Access  := Object.Container;\n-      N : constant Node_Access := M.Tree.First;\n    begin\n-      return (if N = null then No_Element\n-              else Cursor'(Object.Container.all'Unchecked_Access, N));\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.First;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end First;\n \n    -------------------\n@@ -571,13 +585,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function First_Element (Container : Map) return Element_Type is\n       T : Tree_Type renames Container.Tree;\n-\n    begin\n       if T.First = null then\n          raise Constraint_Error with \"map is empty\";\n+      else\n+         return T.First.Element.all;\n       end if;\n-\n-      return T.First.Element.all;\n    end First_Element;\n \n    ---------------\n@@ -586,13 +599,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function First_Key (Container : Map) return Key_Type is\n       T : Tree_Type renames Container.Tree;\n-\n    begin\n       if T.First = null then\n          raise Constraint_Error with \"map is empty\";\n+      else\n+         return T.First.Key.all;\n       end if;\n-\n-      return T.First.Key.all;\n    end First_Key;\n \n    -----------\n@@ -864,22 +876,62 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    end Iterate;\n \n    function Iterate\n-     (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'class\n+     (Container : Map) return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      Node : constant Node_Access := Container.Tree.First;\n-      It   : constant Iterator := (Container'Unrestricted_Access, Node);\n    begin\n-      return It;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => null);\n    end Iterate;\n \n    function Iterate\n      (Container : Map;\n       Start     : Cursor)\n-      return Map_Iterator_Interfaces.Reversible_Iterator'class\n+      return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unrestricted_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ---------\n@@ -916,11 +968,25 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n-      M : constant Map_Access  := Object.Container;\n-      N : constant Node_Access := M.Tree.Last;\n    begin\n-      return (if N = null then No_Element\n-              else Cursor'(Object.Container.all'Unchecked_Access, N));\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.Last;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end Last;\n \n    ------------------\n@@ -1017,8 +1083,16 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      return (if Position.Node = null then No_Element\n-              else (Object.Container, Tree_Operations.Next (Position.Node)));\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong map\";\n+      end if;\n+\n+      return Next (Position);\n    end Next;\n \n    ------------\n@@ -1065,9 +1139,16 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      return\n-        (if Position.Node = null then No_Element\n-         else (Object.Container, Tree_Operations.Previous (Position.Node)));\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong map\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    -------------------\n@@ -1490,4 +1571,5 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    begin\n       raise Program_Error with \"attempt to stream reference\";\n    end Write;\n+\n end Ada.Containers.Indefinite_Ordered_Maps;"}, {"sha": "f4c1321835efb790979a7efb29dd8ed6cb8990a5", "filename": "gcc/ada/a-ciorma.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -201,14 +201,18 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n \n+   --  The map container supports iteration in both the forward and reverse\n+   --  directions, hence these constructor functions return an object that\n+   --  supports the Reversible_Iterator interface.\n+\n    function Iterate\n      (Container : Map)\n-      return Map_Iterator_Interfaces.Forward_Iterator'class;\n+      return Map_Iterator_Interfaces.Reversible_Iterator'Class;\n \n    function Iterate\n      (Container : Map;\n       Start     : Cursor)\n-      return Map_Iterator_Interfaces.Reversible_Iterator'class;\n+      return Map_Iterator_Interfaces.Reversible_Iterator'Class;\n \n private\n "}, {"sha": "d5f5391d8714cae4ebcbb350784e7ac54b6651e4", "filename": "gcc/ada/a-coorma.adb", "status": "modified", "additions": 97, "deletions": 26, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -39,7 +39,7 @@ with System; use type System.Address;\n \n package body Ada.Containers.Ordered_Maps is\n \n-   type Iterator is new\n+   type Iterator is limited new\n      Map_Iterator_Interfaces.Reversible_Iterator with record\n         Container : Map_Access;\n         Node      : Node_Access;\n@@ -518,13 +518,24 @@ package body Ada.Containers.Ordered_Maps is\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n-      M : constant Map_Access  := Object.Container;\n-      N : constant Node_Access := M.Tree.First;\n    begin\n-      if N = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.First;\n       else\n-         return Cursor'(Object.Container.all'Unchecked_Access, N);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end First;\n \n@@ -534,7 +545,6 @@ package body Ada.Containers.Ordered_Maps is\n \n    function First_Element (Container : Map) return Element_Type is\n       T : Tree_Type renames Container.Tree;\n-\n    begin\n       if T.First = null then\n          raise Constraint_Error with \"map is empty\";\n@@ -827,21 +837,60 @@ package body Ada.Containers.Ordered_Maps is\n    end Iterate;\n \n    function Iterate\n-     (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'class\n+     (Container : Map) return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      Node : constant Node_Access := Container.Tree.First;\n-      It   : constant Iterator := (Container'Unrestricted_Access, Node);\n-\n    begin\n-      return It;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a\n+      --  complete iterator, meaning that the iteration starts from the\n+      --  (logical) beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => null);\n    end Iterate;\n \n    function Iterate (Container : Map; Start : Cursor)\n-      return Map_Iterator_Interfaces.Reversible_Iterator'class\n+      return Map_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unrestricted_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ---------\n@@ -876,13 +925,24 @@ package body Ada.Containers.Ordered_Maps is\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n-      M : constant Map_Access  := Object.Container;\n-      N : constant Node_Access := M.Tree.Last;\n    begin\n-      if N = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.Last;\n       else\n-         return Cursor'(Object.Container.all'Unchecked_Access, N);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end Last;\n \n@@ -980,11 +1040,16 @@ package body Ada.Containers.Ordered_Maps is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      if Position.Node = null then\n+      if Position.Container = null then\n          return No_Element;\n-      else\n-         return (Object.Container, Tree_Operations.Next (Position.Node));\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong map\";\n+      end if;\n+\n+      return Next (Position);\n    end Next;\n \n    ------------\n@@ -1032,12 +1097,18 @@ package body Ada.Containers.Ordered_Maps is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      if Position.Node = null then\n+      if Position.Container = null then\n          return No_Element;\n-      else\n-         return (Object.Container, Tree_Operations.Previous (Position.Node));\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong map\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "9d2737a5efb644ab56d5fa1781be974b2d7bd510", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -203,19 +203,23 @@ package Ada.Containers.Ordered_Maps is\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n \n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   --  The map container supports iteration in both the forward and reverse\n+   --  directions, hence these constructor functions return an object that\n+   --  supports the Reversible_Iterator interface.\n+\n    function Iterate\n      (Container : Map)\n-      return Map_Iterator_Interfaces.Forward_Iterator'class;\n+      return Map_Iterator_Interfaces.Reversible_Iterator'class;\n \n    function Iterate\n      (Container : Map;\n       Start     : Cursor)\n       return Map_Iterator_Interfaces.Reversible_Iterator'class;\n \n-   procedure Reverse_Iterate\n-     (Container : Map;\n-      Process   : not null access procedure (Position : Cursor));\n-\n private\n \n    pragma Inline (Next);"}, {"sha": "772faa932165a4b908829642a06a1ca0a50515ae", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f947ee3467dee8ca1b681c459804b02657113e9d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=f947ee3467dee8ca1b681c459804b02657113e9d", "patch": "@@ -3178,11 +3178,13 @@ package body Exp_Ch5 is\n             --  Determine the advancement and initialization steps for the\n             --  cursor.\n \n-            --  Must verify that the container has a reverse iterator ???\n+            --  Analysis of the expanded loop will verify that the container\n+            --  has a reverse iterator.\n \n             if Reverse_Present (I_Spec) then\n                Name_Init := Name_Last;\n                Name_Step := Name_Previous;\n+\n             else\n                Name_Init := Name_First;\n                Name_Step := Name_Next;\n@@ -3251,6 +3253,7 @@ package body Exp_Ch5 is\n             declare\n                Decl1 : Node_Id;\n                Decl2 : Node_Id;\n+               Decl3 : Node_Id;\n \n             begin\n                Decl1 :=\n@@ -3274,16 +3277,30 @@ package body Exp_Ch5 is\n \n                Set_Assignment_OK (Decl2);\n \n-               Insert_Actions (N, New_List (Decl1, Decl2));\n-            end;\n+               --  The cursor is only modified in expanded code, so it appears\n+               --  as unassigned to the warning machinery. We must suppress\n+               --  this spurious warning explicitly.\n+\n+               Decl3 :=\n+                 Make_Pragma (Loc,\n+                   Chars => Name_Warnings,\n+                   Pragma_Argument_Associations => New_List (\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression => Make_Identifier (Loc, Name_Off)),\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression =>\n+                         New_Occurrence_Of (Cursor, Loc))));\n \n-            --  The Iterator is not modified in the source, but of course will\n-            --  be updated in the generated code. Indicate that it is actually\n-            --  set to prevent spurious warnings. Ditto for the Cursor, which\n-            --  is modified indirectly in generated code.\n+               --  The expanded loop is wrapped in a block, to make the loop\n+               --  variable local.\n \n-            Set_Never_Set_In_Source (Iterator, False);\n-            Set_Never_Set_In_Source (Cursor, False);\n+               New_Loop :=\n+                 Make_Block_Statement (Loc,\n+                   Declarations => New_List (Decl1, Decl2, Decl3),\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (New_Loop)));\n+            end;\n \n             --  If the range of iteration is given by a function call that\n             --  returns a container, the finalization actions have been saved"}]}