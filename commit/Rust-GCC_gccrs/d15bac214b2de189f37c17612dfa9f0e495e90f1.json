{"sha": "d15bac214b2de189f37c17612dfa9f0e495e90f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1YmFjMjE0YjJkZTE4OWYzN2MxNzYxMmRmYTlmMGU0OTVlOTBmMQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-05-17T18:45:32Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-05-17T18:45:32Z"}, "message": "class.c (gfc_add_component_ref,gfc_class_null_initializer, [...]): Moved here from other places.\n\n2010-05-17  Janus Weil  <janus@gcc.gnu.org>\n\n\t* class.c (gfc_add_component_ref,gfc_class_null_initializer,\n\tgfc_build_class_symbol,add_proc_component,add_proc_comps, \n\tadd_procs_to_declared_vtab1,copy_vtab_proc_comps,\n\tadd_procs_to_declared_vtab,add_generic_specifics, \n\tadd_generics_to_declared_vtab,gfc_find_derived_vtab,\n\tfind_typebound_proc_uop,gfc_find_typebound_proc,\n\tgfc_find_typebound_user_op,gfc_find_typebound_intrinsic_op, \n\tgfc_get_tbp_symtree): Moved here from other places.\n\t* expr.c (gfc_add_component_ref,gfc_class_null_initializer): Move to\n\tclass.c.\n\t* gfortran.h (gfc_build_class_symbol,gfc_find_derived_vtab,\n\tgfc_find_typebound_proc,gfc_find_typebound_user_op,\n\tgfc_find_typebound_intrinsic_op,gfc_get_tbp_symtree,\n\tgfc_add_component_ref, gfc_class_null_initializer): Moved to class.c.\n\t* Make-lang.in: Add class.o.\n\t* symbol.c (gfc_build_class_symbol,add_proc_component,add_proc_comps,\n\tadd_procs_to_declared_vtab1,copy_vtab_proc_comps,\n\tadd_procs_to_declared_vtab,add_generic_specifics,\n\tadd_generics_to_declared_vtab,gfc_find_derived_vtab,\n\tfind_typebound_proc_uop,gfc_find_typebound_proc,\n\tgfc_find_typebound_user_op,gfc_find_typebound_intrinsic_op,\n\tgfc_get_tbp_symtree): Move to class.c.\n\nFrom-SVN: r159506", "tree": {"sha": "a37de26e524676acb8ec93419f6ba56004d28d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a37de26e524676acb8ec93419f6ba56004d28d9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d15bac214b2de189f37c17612dfa9f0e495e90f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15bac214b2de189f37c17612dfa9f0e495e90f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15bac214b2de189f37c17612dfa9f0e495e90f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15bac214b2de189f37c17612dfa9f0e495e90f1/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5d74497b283d6a2623ec4d1a2d5fb99cbf97c1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d74497b283d6a2623ec4d1a2d5fb99cbf97c1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d74497b283d6a2623ec4d1a2d5fb99cbf97c1b"}], "stats": {"total": 1611, "additions": 844, "deletions": 767}, "files": [{"sha": "45fe11a8e17ffb1766ec1974818b64431fd5abee", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d15bac214b2de189f37c17612dfa9f0e495e90f1", "patch": "@@ -1,3 +1,28 @@\n+2010-05-17  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* class.c (gfc_add_component_ref,gfc_class_null_initializer,\n+\tgfc_build_class_symbol,add_proc_component,add_proc_comps, \n+\tadd_procs_to_declared_vtab1,copy_vtab_proc_comps,\n+\tadd_procs_to_declared_vtab,add_generic_specifics, \n+\tadd_generics_to_declared_vtab,gfc_find_derived_vtab,\n+\tfind_typebound_proc_uop,gfc_find_typebound_proc,\n+\tgfc_find_typebound_user_op,gfc_find_typebound_intrinsic_op, \n+\tgfc_get_tbp_symtree): Moved here from other places.\n+\t* expr.c (gfc_add_component_ref,gfc_class_null_initializer): Move to\n+\tclass.c.\n+\t* gfortran.h (gfc_build_class_symbol,gfc_find_derived_vtab,\n+\tgfc_find_typebound_proc,gfc_find_typebound_user_op,\n+\tgfc_find_typebound_intrinsic_op,gfc_get_tbp_symtree,\n+\tgfc_add_component_ref, gfc_class_null_initializer): Moved to class.c.\n+\t* Make-lang.in: Add class.o.\n+\t* symbol.c (gfc_build_class_symbol,add_proc_component,add_proc_comps,\n+\tadd_procs_to_declared_vtab1,copy_vtab_proc_comps,\n+\tadd_procs_to_declared_vtab,add_generic_specifics,\n+\tadd_generics_to_declared_vtab,gfc_find_derived_vtab,\n+\tfind_typebound_proc_uop,gfc_find_typebound_proc,\n+\tgfc_find_typebound_user_op,gfc_find_typebound_intrinsic_op,\n+\tgfc_get_tbp_symtree): Move to class.c.\n+\n 2010-05-17  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* trans-types.c (gfc_init_types): Use build_function_type_list."}, {"sha": "49ffdf963bf1129f5f46691bdb809979bd182d2d", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=d15bac214b2de189f37c17612dfa9f0e495e90f1", "patch": "@@ -53,13 +53,13 @@ fortran-warn = $(STRICT_WARN)\n # from the parse tree to GENERIC\n \n F95_PARSER_OBJS = fortran/arith.o fortran/array.o fortran/bbt.o \\\n-    fortran/check.o fortran/constructor.o fortran/cpp.o fortran/data.o \\\n-    fortran/decl.o fortran/dump-parse-tree.o fortran/error.o fortran/expr.o \\\n-    fortran/interface.o fortran/intrinsic.o fortran/io.o fortran/iresolve.o \\\n-    fortran/match.o fortran/matchexp.o fortran/misc.o fortran/module.o \\\n-    fortran/openmp.o fortran/options.o fortran/parse.o fortran/primary.o \\\n-    fortran/resolve.o fortran/scanner.o fortran/simplify.o fortran/st.o \\\n-    fortran/symbol.o fortran/target-memory.o\n+    fortran/check.o fortran/class.o fortran/constructor.o fortran/cpp.o \\\n+    fortran/data.o fortran/decl.o fortran/dump-parse-tree.o fortran/error.o \\\n+    fortran/expr.o fortran/interface.o fortran/intrinsic.o fortran/io.o \\\n+    fortran/iresolve.o fortran/match.o fortran/matchexp.o fortran/misc.o \\\n+    fortran/module.o fortran/openmp.o fortran/options.o fortran/parse.o \\\n+    fortran/primary.o fortran/resolve.o fortran/scanner.o fortran/simplify.o \\\n+    fortran/st.o fortran/symbol.o fortran/target-memory.o\n \n F95_OBJS = $(F95_PARSER_OBJS) $(FORTRAN_TARGET_OBJS) \\\n     fortran/convert.o fortran/dependency.o fortran/f95-lang.o \\"}, {"sha": "37b9cf015908fcdff42504f6faee77b19aae5fa8", "filename": "gcc/fortran/class.c", "status": "added", "additions": 797, "deletions": 0, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=d15bac214b2de189f37c17612dfa9f0e495e90f1", "patch": "@@ -0,0 +1,797 @@\n+/* Implementation of Fortran 2003 Polymorphism.\n+   Copyright (C) 2009, 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Paul Richard Thomas & Janus Weil\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* class.c -- This file contains the front end functions needed to service\n+              the implementation of Fortran 2003 polymorphism and other\n+              object-oriented features.  */\n+\n+\n+/* Outline of the internal representation:\n+\n+   Each CLASS variable is encapsulated by a class container, which is a\n+   structure with two fields:\n+    * $data: A pointer to the actual data of the variable. This field has the\n+             declared type of the class variable and its attributes\n+             (pointer/allocatable/dimension/...).\n+    * $vptr: A pointer to the vtable entry (see below) of the dynamic type.\n+    \n+   For each derived type we set up a \"vtable\" entry, i.e. a structure with the\n+   following fields:\n+    * $hash: A hash value serving as a unique identifier for this type.\n+    * $size: The size in bytes of the derived type.\n+    * $extends: A pointer to the vtable entry of the parent derived type.\n+   In addition to these fields, each vtable entry contains additional procedure\n+   pointer components, which contain pointers to the procedures which are bound\n+   to the type's \"methods\" (type-bound procedures).  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"gfortran.h\"\n+#include \"constructor.h\"\n+\n+\n+/* Insert a reference to the component of the given name.\n+   Only to be used with CLASS containers.  */\n+\n+void\n+gfc_add_component_ref (gfc_expr *e, const char *name)\n+{\n+  gfc_ref **tail = &(e->ref);\n+  gfc_ref *next = NULL;\n+  gfc_symbol *derived = e->symtree->n.sym->ts.u.derived;\n+  while (*tail != NULL)\n+    {\n+      if ((*tail)->type == REF_COMPONENT)\n+\tderived = (*tail)->u.c.component->ts.u.derived;\n+      if ((*tail)->type == REF_ARRAY && (*tail)->next == NULL)\n+\tbreak;\n+      tail = &((*tail)->next);\n+    }\n+  if (*tail != NULL && strcmp (name, \"$data\") == 0)\n+    next = *tail;\n+  (*tail) = gfc_get_ref();\n+  (*tail)->next = next;\n+  (*tail)->type = REF_COMPONENT;\n+  (*tail)->u.c.sym = derived;\n+  (*tail)->u.c.component = gfc_find_component (derived, name, true, true);\n+  gcc_assert((*tail)->u.c.component);\n+  if (!next)\n+    e->ts = (*tail)->u.c.component->ts;\n+}\n+\n+\n+/* Build a NULL initializer for CLASS pointers,\n+   initializing the $data and $vptr components to zero.  */\n+\n+gfc_expr *\n+gfc_class_null_initializer (gfc_typespec *ts)\n+{\n+  gfc_expr *init;\n+  gfc_component *comp;\n+  \n+  init = gfc_get_structure_constructor_expr (ts->type, ts->kind,\n+\t\t\t\t\t     &ts->u.derived->declared_at);\n+  init->ts = *ts;\n+  \n+  for (comp = ts->u.derived->components; comp; comp = comp->next)\n+    {\n+      gfc_constructor *ctor = gfc_constructor_get();\n+      ctor->expr = gfc_get_expr ();\n+      ctor->expr->expr_type = EXPR_NULL;\n+      ctor->expr->ts = comp->ts;\n+      gfc_constructor_append (&init->value.constructor, ctor);\n+    }\n+\n+  return init;\n+}\n+\n+\n+/* Build a polymorphic CLASS entity, using the symbol that comes from\n+   build_sym. A CLASS entity is represented by an encapsulating type,\n+   which contains the declared type as '$data' component, plus a pointer\n+   component '$vptr' which determines the dynamic type.  */\n+\n+gfc_try\n+gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n+\t\t\tgfc_array_spec **as, bool delayed_vtab)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 5];\n+  gfc_symbol *fclass;\n+  gfc_symbol *vtab;\n+  gfc_component *c;\n+\n+  /* Determine the name of the encapsulating type.  */\n+  if ((*as) && (*as)->rank && attr->allocatable)\n+    sprintf (name, \"class$%s_%d_a\", ts->u.derived->name, (*as)->rank);\n+  else if ((*as) && (*as)->rank)\n+    sprintf (name, \"class$%s_%d\", ts->u.derived->name, (*as)->rank);\n+  else if (attr->pointer)\n+    sprintf (name, \"class$%s_p\", ts->u.derived->name);\n+  else if (attr->allocatable)\n+    sprintf (name, \"class$%s_a\", ts->u.derived->name);\n+  else\n+    sprintf (name, \"class$%s\", ts->u.derived->name);\n+\n+  gfc_find_symbol (name, ts->u.derived->ns, 0, &fclass);\n+  if (fclass == NULL)\n+    {\n+      gfc_symtree *st;\n+      /* If not there, create a new symbol.  */\n+      fclass = gfc_new_symbol (name, ts->u.derived->ns);\n+      st = gfc_new_symtree (&ts->u.derived->ns->sym_root, name);\n+      st->n.sym = fclass;\n+      gfc_set_sym_referenced (fclass);\n+      fclass->refs++;\n+      fclass->ts.type = BT_UNKNOWN;\n+      fclass->attr.abstract = ts->u.derived->attr.abstract;\n+      if (ts->u.derived->f2k_derived)\n+\tfclass->f2k_derived = gfc_get_namespace (NULL, 0);\n+      if (gfc_add_flavor (&fclass->attr, FL_DERIVED,\n+\t  NULL, &gfc_current_locus) == FAILURE)\n+\treturn FAILURE;\n+\n+      /* Add component '$data'.  */\n+      if (gfc_add_component (fclass, \"$data\", &c) == FAILURE)\n+\treturn FAILURE;\n+      c->ts = *ts;\n+      c->ts.type = BT_DERIVED;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->ts.u.derived = ts->u.derived;\n+      c->attr.class_pointer = attr->pointer;\n+      c->attr.pointer = attr->pointer || attr->dummy;\n+      c->attr.allocatable = attr->allocatable;\n+      c->attr.dimension = attr->dimension;\n+      c->attr.codimension = attr->codimension;\n+      c->attr.abstract = ts->u.derived->attr.abstract;\n+      c->as = (*as);\n+      c->initializer = NULL;\n+\n+      /* Add component '$vptr'.  */\n+      if (gfc_add_component (fclass, \"$vptr\", &c) == FAILURE)\n+\treturn FAILURE;\n+      c->ts.type = BT_DERIVED;\n+      if (delayed_vtab)\n+\tc->ts.u.derived = NULL;\n+      else\n+\t{\n+\t  vtab = gfc_find_derived_vtab (ts->u.derived, false);\n+\t  gcc_assert (vtab);\n+\t  c->ts.u.derived = vtab->ts.u.derived;\n+\t}\n+      c->attr.pointer = 1;\n+    }\n+\n+  /* Since the extension field is 8 bit wide, we can only have\n+     up to 255 extension levels.  */\n+  if (ts->u.derived->attr.extension == 255)\n+    {\n+      gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n+\t\t ts->u.derived->name, &ts->u.derived->declared_at);\n+      return FAILURE;\n+    }\n+    \n+  fclass->attr.extension = ts->u.derived->attr.extension + 1;\n+  fclass->attr.is_class = 1;\n+  ts->u.derived = fclass;\n+  attr->allocatable = attr->pointer = attr->dimension = 0;\n+  (*as) = NULL;  /* XXX */\n+  return SUCCESS;\n+}\n+\n+\n+static void\n+add_proc_component (gfc_component *c, gfc_symbol *vtype,\n+\t\t    gfc_symtree *st, gfc_symbol *specific,\n+\t\t    bool is_generic, bool is_generic_specific)\n+{\n+  /* Add procedure component.  */\n+  if (is_generic)\n+    {\n+      if (gfc_add_component (vtype, specific->name, &c) == FAILURE)\n+\treturn;\n+      c->ts.interface = specific;\n+    }\n+  else if (c && is_generic_specific)\n+    {\n+      c->ts.interface = st->n.tb->u.specific->n.sym;\n+    }\n+  else\n+    {\n+      c = gfc_find_component (vtype, st->name, true, true);\n+      if (!c && gfc_add_component (vtype, st->name, &c) == FAILURE)\n+\treturn;\n+      c->ts.interface = st->n.tb->u.specific->n.sym;\n+    }\n+\n+  if (!c->tb)\n+    c->tb = XCNEW (gfc_typebound_proc);\n+  *c->tb = *st->n.tb;\n+  c->tb->ppc = 1;\n+  c->attr.procedure = 1;\n+  c->attr.proc_pointer = 1;\n+  c->attr.flavor = FL_PROCEDURE;\n+  c->attr.access = ACCESS_PRIVATE;\n+  c->attr.external = 1;\n+  c->attr.untyped = 1;\n+  c->attr.if_source = IFSRC_IFBODY;\n+\n+  /* A static initializer cannot be used here because the specific\n+     function is not a constant; internal compiler error: in\n+     output_constant, at varasm.c:4623  */\n+  c->initializer = NULL;\n+}\n+\n+\n+static void\n+add_proc_comps (gfc_component *c, gfc_symbol *vtype,\n+\t\tgfc_symtree *st, bool is_generic)\n+{\n+  if (c == NULL && !is_generic)\n+    {\n+      add_proc_component (c, vtype, st, NULL, false, false);\n+    }\n+  else if (is_generic && st->n.tb && vtype->components == NULL)\n+    {\n+      gfc_tbp_generic* g;\n+      gfc_symbol * specific;\n+      for (g = st->n.tb->u.generic; g; g = g->next)\n+\t{\n+\t  if (!g->specific)\n+\t    continue;\n+\t  specific = g->specific->u.specific->n.sym;\n+\t  add_proc_component (NULL, vtype, st, specific, true, false);\n+\t}\n+    }\n+  else if (c->attr.proc_pointer && c->tb)\n+    {\n+      *c->tb = *st->n.tb;\n+      c->tb->ppc = 1;\n+      c->ts.interface = st->n.tb->u.specific->n.sym;\t  \n+    }\n+}\n+\n+static void\n+add_procs_to_declared_vtab1 (gfc_symtree *st, gfc_symbol *vtype,\n+\t\t\t     bool resolved)\n+{\n+  gfc_component *c;\n+  gfc_symbol *generic;\n+  char name[3 * GFC_MAX_SYMBOL_LEN + 10];\n+\n+  if (!st)\n+    return;\n+\n+  if (st->left)\n+    add_procs_to_declared_vtab1 (st->left, vtype, resolved);\n+\n+  if (st->right)\n+    add_procs_to_declared_vtab1 (st->right, vtype, resolved);\n+\n+  if (!st->n.tb)\n+    return;\n+\n+  if (!st->n.tb->is_generic && st->n.tb->u.specific)\n+    {\n+      c = gfc_find_component (vtype, st->name, true, true);\n+      add_proc_comps (c, vtype, st, false);\n+    }\n+  else if (st->n.tb->is_generic)\n+    {\n+      c = gfc_find_component (vtype, st->name, true, true);\n+\n+      if (c == NULL)\n+\t{\n+\t  /* Add derived type component with generic name.  */\n+\t  if (gfc_add_component (vtype, st->name, &c) == FAILURE)\n+\t    return;\n+\t  c->ts.type = BT_DERIVED;\n+\t  c->attr.flavor = FL_VARIABLE;\n+\t  c->attr.pointer = 1;\n+\n+\t  /* Add a special empty derived type as a placeholder.  */\n+\t  sprintf (name, \"$empty\");\n+\t  gfc_find_symbol (name, vtype->ns, 0, &generic);\n+\t  if (generic == NULL)\n+\t    {\n+\t      gfc_get_symbol (name, vtype->ns, &generic);\n+\t      generic->attr.flavor = FL_DERIVED;\n+\t      generic->refs++;\n+\t      gfc_set_sym_referenced (generic);\n+\t      generic->ts.type = BT_UNKNOWN;\n+\t      generic->attr.zero_comp = 1;\n+\t    }\n+\n+\t  c->ts.u.derived = generic;\n+\t}\n+    }\n+}\n+\n+\n+static void\n+copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype,\n+\t\t      bool resolved)\n+{\n+  gfc_component *c, *cmp;\n+  gfc_symbol *vtab;\n+\n+  vtab = gfc_find_derived_vtab (declared, resolved);\n+\n+  for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)\n+    {\n+      if (gfc_find_component (vtype, cmp->name, true, true))\n+\tcontinue;\n+\n+      if (gfc_add_component (vtype, cmp->name, &c) == FAILURE)\n+\treturn;\n+\n+      if (cmp->ts.type == BT_DERIVED)\n+\t{\n+\t  c->ts = cmp->ts;\n+\t  c->ts.u.derived = cmp->ts.u.derived;\n+\t  c->attr.flavor = FL_VARIABLE;\n+\t  c->attr.pointer = 1;\n+\t  c->initializer = NULL;\n+\t  continue;\n+\t}\n+\n+      c->tb = XCNEW (gfc_typebound_proc);\n+      *c->tb = *cmp->tb;\n+      c->attr.procedure = 1;\n+      c->attr.proc_pointer = 1;\n+      c->attr.flavor = FL_PROCEDURE;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->attr.external = 1;\n+      c->ts.interface = cmp->ts.interface;\n+      c->attr.untyped = 1;\n+      c->attr.if_source = IFSRC_IFBODY;\n+      c->initializer = NULL;\n+    }\n+}\n+\n+static void\n+add_procs_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n+\t\t\t    gfc_symbol *derived, bool resolved)\n+{\n+  gfc_symbol* super_type;\n+\n+  super_type = gfc_get_derived_super_type (declared);\n+\n+  if (super_type && (super_type != declared))\n+    add_procs_to_declared_vtab (super_type, vtype, derived, resolved);\n+\n+  if (declared != derived)\n+    copy_vtab_proc_comps (declared, vtype, resolved);\n+\n+  if (declared->f2k_derived && declared->f2k_derived->tb_sym_root)\n+    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_sym_root,\n+\t\t\t\t vtype, resolved);\n+\n+  if (declared->f2k_derived && declared->f2k_derived->tb_uop_root)\n+    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_uop_root,\n+\t\t\t\t vtype, resolved);\n+}\n+\n+\n+static\n+void add_generic_specifics (gfc_symbol *declared, gfc_symbol *vtab,\n+\t\t\t    const char *name)\n+{\n+  gfc_tbp_generic* g;\n+  gfc_symbol * specific1;\n+  gfc_symbol * specific2;\n+  gfc_symtree *st = NULL;\n+  gfc_component *c;\n+\n+  /* Find the generic procedure using the component name.  */\n+  st = gfc_find_typebound_proc (declared, NULL, name, true, NULL);\n+  if (st == NULL)\n+    st = gfc_find_typebound_user_op (declared, NULL, name, true, NULL);\n+\n+  if (st == NULL)\n+    return;\n+\n+  /* Add procedure pointer components for the specific procedures. */\n+  for (g = st->n.tb->u.generic; g; g = g->next)\n+    {\n+      if (!g->specific)\n+\tcontinue;\n+      specific1 = g->specific_st->n.tb->u.specific->n.sym;\n+\n+      c = vtab->ts.u.derived->components;\n+      specific2 = NULL;\n+\n+      /* Override identical specific interface.  */\n+      if (vtab->ts.u.derived->components)\n+\t{\n+\t  for (; c; c= c->next)\n+\t    {\n+\t      specific2 = c->ts.interface;\n+\t      if (gfc_compare_interfaces (specific2, specific1,\n+\t\t\t\t\t  specific1->name, 0, 0, NULL, 0))\n+\t\tbreak;\n+\t    }\n+\t}\n+\n+      add_proc_component (c, vtab->ts.u.derived, g->specific_st,\n+\t\t\t  NULL, false, true);\n+      vtab->ts.u.derived->attr.zero_comp = 0;\n+    }\n+}\n+\n+\n+static void\n+add_generics_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n+\t\t\t       gfc_symbol *derived, bool resolved)\n+{\n+  gfc_component *cmp;\n+  gfc_symtree *st = NULL;\n+  gfc_symbol * vtab;\n+  char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n+  gfc_symbol* super_type;\n+\n+  gcc_assert (resolved);\n+\n+  for (cmp = vtype->components; cmp; cmp = cmp->next)\n+    {\n+      if (cmp->ts.type != BT_DERIVED)\n+\tcontinue;\n+\n+      /* The only derived type that does not represent a generic\n+\t procedure is the pointer to the parent vtab.  */\n+      if (cmp->ts.u.derived\n+\t    && strcmp (cmp->ts.u.derived->name, \"$extends\") == 0)\n+\tcontinue;\n+\n+      /* Find the generic procedure using the component name.  */\n+      st = gfc_find_typebound_proc (declared, NULL, cmp->name,\n+\t\t\t\t    true, NULL);\n+      if (st == NULL)\n+\tst = gfc_find_typebound_user_op (declared, NULL, cmp->name,\n+\t\t\t\t\t true, NULL);\n+\n+      /* Should be an error but we pass on it for now.  */\n+      if (st == NULL || !st->n.tb->is_generic)\n+\tcontinue;\n+\n+      vtab = NULL;\n+\n+      /* Build a vtab and a special vtype, with only the procedure\n+\t pointer fields, to carry the pointers to the specific\n+\t procedures.  Should this name ever be changed, the same\n+\t should be done in trans-expr.c(gfc_trans_assign_vtab_procs). */\n+      sprintf (name, \"vtab$%s$%s\", vtype->name, cmp->name);\n+      gfc_find_symbol (name, derived->ns, 0, &vtab);\n+      if (vtab == NULL)\n+\t{\n+\t  gfc_get_symbol (name, derived->ns, &vtab);\n+\t  vtab->ts.type = BT_DERIVED;\n+\t  vtab->attr.flavor = FL_VARIABLE;\n+\t  vtab->attr.target = 1;\n+\t  vtab->attr.save = SAVE_EXPLICIT;\n+\t  vtab->attr.vtab = 1;\n+\t  vtab->refs++;\n+\t  gfc_set_sym_referenced (vtab);\n+\t  sprintf (name, \"%s$%s\", vtype->name, cmp->name);\n+\t  \n+\t  gfc_find_symbol (name, derived->ns, 0, &cmp->ts.u.derived);\n+\t  if (cmp->ts.u.derived == NULL\n+\t\t|| (strcmp (cmp->ts.u.derived->name, \"$empty\") == 0))\n+\t    {\n+\t      gfc_get_symbol (name, derived->ns, &cmp->ts.u.derived);\n+\t      if (gfc_add_flavor (&cmp->ts.u.derived->attr, FL_DERIVED,\n+\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t\treturn;\n+\t      cmp->ts.u.derived->refs++;\n+\t      gfc_set_sym_referenced (cmp->ts.u.derived);\n+\t      cmp->ts.u.derived->attr.vtype = 1;\n+\t      cmp->ts.u.derived->attr.zero_comp = 1;\n+\t    }\n+\t  vtab->ts.u.derived = cmp->ts.u.derived;\n+\t}\n+\n+      /* Store this for later use in setting the pointer.  */\n+      cmp->ts.interface = vtab;\n+\n+      if (vtab->ts.u.derived->components)\n+\tcontinue;\n+\n+      super_type = gfc_get_derived_super_type (declared);\n+\n+      if (super_type && (super_type != declared))\n+\tadd_generic_specifics (super_type, vtab, cmp->name);\n+\n+      add_generic_specifics (declared, vtab, cmp->name);\n+    }\n+}\n+\n+\n+/* Find the symbol for a derived type's vtab.  A vtab has the following\n+   fields:\n+   $hash\ta hash value used to identify the derived type\n+   $size\tthe size in bytes of the derived type\n+   $extends\ta pointer to the vtable of the parent derived type\n+   then:\n+   procedure pointer components for the specific typebound procedures\n+   structure pointers to reduced vtabs that contain procedure\n+   pointers to the specific procedures.  */\n+\n+gfc_symbol *\n+gfc_find_derived_vtab (gfc_symbol *derived, bool resolved)\n+{\n+  gfc_namespace *ns;\n+  gfc_symbol *vtab = NULL, *vtype = NULL;\n+  char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n+\n+  ns = gfc_current_ns;\n+\n+  for (; ns; ns = ns->parent)\n+    if (!ns->parent)\n+      break;\n+\n+  if (ns)\n+    {\n+      sprintf (name, \"vtab$%s\", derived->name);\n+      gfc_find_symbol (name, ns, 0, &vtab);\n+\n+      if (vtab == NULL)\n+\t{\n+\t  gfc_get_symbol (name, ns, &vtab);\n+\t  vtab->ts.type = BT_DERIVED;\n+\t  vtab->attr.flavor = FL_VARIABLE;\n+\t  vtab->attr.target = 1;\n+\t  vtab->attr.save = SAVE_EXPLICIT;\n+\t  vtab->attr.vtab = 1;\n+\t  vtab->refs++;\n+\t  gfc_set_sym_referenced (vtab);\n+\t  sprintf (name, \"vtype$%s\", derived->name);\n+\t  \n+\t  gfc_find_symbol (name, ns, 0, &vtype);\n+\t  if (vtype == NULL)\n+\t    {\n+\t      gfc_component *c;\n+\t      gfc_symbol *parent = NULL, *parent_vtab = NULL;\n+\n+\t      gfc_get_symbol (name, ns, &vtype);\n+\t      if (gfc_add_flavor (&vtype->attr, FL_DERIVED,\n+\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t\treturn NULL;\n+\t      vtype->refs++;\n+\t      gfc_set_sym_referenced (vtype);\n+\n+\t      /* Add component '$hash'.  */\n+\t      if (gfc_add_component (vtype, \"$hash\", &c) == FAILURE)\n+\t\treturn NULL;\n+\t      c->ts.type = BT_INTEGER;\n+\t      c->ts.kind = 4;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t NULL, derived->hash_value);\n+\n+\t      /* Add component '$size'.  */\n+\t      if (gfc_add_component (vtype, \"$size\", &c) == FAILURE)\n+\t\treturn NULL;\n+\t      c->ts.type = BT_INTEGER;\n+\t      c->ts.kind = 4;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      /* Remember the derived type in ts.u.derived,\n+\t\t so that the correct initializer can be set later on\n+\t\t (in gfc_conv_structure).  */\n+\t      c->ts.u.derived = derived;\n+\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t NULL, 0);\n+\n+\t      /* Add component $extends.  */\n+\t      if (gfc_add_component (vtype, \"$extends\", &c) == FAILURE)\n+\t\treturn NULL;\n+\t      c->attr.pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      parent = gfc_get_derived_super_type (derived);\n+\t      if (parent)\n+\t\t{\n+\t\t  parent_vtab = gfc_find_derived_vtab (parent, resolved);\n+\t\t  c->ts.type = BT_DERIVED;\n+\t\t  c->ts.u.derived = parent_vtab->ts.u.derived;\n+\t\t  c->initializer = gfc_get_expr ();\n+\t\t  c->initializer->expr_type = EXPR_VARIABLE;\n+\t\t  gfc_find_sym_tree (parent_vtab->name, parent_vtab->ns,\n+\t\t\t\t     0, &c->initializer->symtree);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  c->ts.type = BT_DERIVED;\n+\t\t  c->ts.u.derived = vtype;\n+\t\t  c->initializer = gfc_get_null_expr (NULL);\n+\t\t}\n+\n+\t      add_procs_to_declared_vtab (derived, vtype, derived, resolved);\n+\t      vtype->attr.vtype = 1;\n+\t    }\n+\n+\t  vtab->ts.u.derived = vtype;\n+\t  vtab->value = gfc_default_initializer (&vtab->ts);\n+\t}\n+    }\n+\n+  /* Catch the call just before the backend declarations are built, so that\n+     the generic procedures have been resolved and the specific procedures\n+     have formal interfaces that can be compared.  */\n+  if (resolved\n+\t&& vtab->ts.u.derived\n+\t&& vtab->ts.u.derived->backend_decl == NULL)\n+    add_generics_to_declared_vtab (derived, vtab->ts.u.derived,\n+\t\t\t\t   derived, resolved);\n+\n+  return vtab;\n+}\n+\n+\n+/* General worker function to find either a type-bound procedure or a\n+   type-bound user operator.  */\n+\n+static gfc_symtree*\n+find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n+\t\t\t const char* name, bool noaccess, bool uop,\n+\t\t\t locus* where)\n+{\n+  gfc_symtree* res;\n+  gfc_symtree* root;\n+\n+  /* Set correct symbol-root.  */\n+  gcc_assert (derived->f2k_derived);\n+  root = (uop ? derived->f2k_derived->tb_uop_root\n+\t      : derived->f2k_derived->tb_sym_root);\n+\n+  /* Set default to failure.  */\n+  if (t)\n+    *t = FAILURE;\n+\n+  /* Try to find it in the current type's namespace.  */\n+  res = gfc_find_symtree (root, name);\n+  if (res && res->n.tb && !res->n.tb->error)\n+    {\n+      /* We found one.  */\n+      if (t)\n+\t*t = SUCCESS;\n+\n+      if (!noaccess && derived->attr.use_assoc\n+\t  && res->n.tb->access == ACCESS_PRIVATE)\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n+\t\t       name, derived->name, where);\n+\t  if (t)\n+\t    *t = FAILURE;\n+\t}\n+\n+      return res;\n+    }\n+\n+  /* Otherwise, recurse on parent type if derived is an extension.  */\n+  if (derived->attr.extension)\n+    {\n+      gfc_symbol* super_type;\n+      super_type = gfc_get_derived_super_type (derived);\n+      gcc_assert (super_type);\n+\n+      return find_typebound_proc_uop (super_type, t, name,\n+\t\t\t\t      noaccess, uop, where);\n+    }\n+\n+  /* Nothing found.  */\n+  return NULL;\n+}\n+\n+\n+/* Find a type-bound procedure or user operator by name for a derived-type\n+   (looking recursively through the super-types).  */\n+\n+gfc_symtree*\n+gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n+\t\t\t const char* name, bool noaccess, locus* where)\n+{\n+  return find_typebound_proc_uop (derived, t, name, noaccess, false, where);\n+}\n+\n+gfc_symtree*\n+gfc_find_typebound_user_op (gfc_symbol* derived, gfc_try* t,\n+\t\t\t    const char* name, bool noaccess, locus* where)\n+{\n+  return find_typebound_proc_uop (derived, t, name, noaccess, true, where);\n+}\n+\n+\n+/* Find a type-bound intrinsic operator looking recursively through the\n+   super-type hierarchy.  */\n+\n+gfc_typebound_proc*\n+gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n+\t\t\t\t gfc_intrinsic_op op, bool noaccess,\n+\t\t\t\t locus* where)\n+{\n+  gfc_typebound_proc* res;\n+\n+  /* Set default to failure.  */\n+  if (t)\n+    *t = FAILURE;\n+\n+  /* Try to find it in the current type's namespace.  */\n+  if (derived->f2k_derived)\n+    res = derived->f2k_derived->tb_op[op];\n+  else  \n+    res = NULL;\n+\n+  /* Check access.  */\n+  if (res && !res->error)\n+    {\n+      /* We found one.  */\n+      if (t)\n+\t*t = SUCCESS;\n+\n+      if (!noaccess && derived->attr.use_assoc\n+\t  && res->access == ACCESS_PRIVATE)\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n+\t\t       gfc_op2string (op), derived->name, where);\n+\t  if (t)\n+\t    *t = FAILURE;\n+\t}\n+\n+      return res;\n+    }\n+\n+  /* Otherwise, recurse on parent type if derived is an extension.  */\n+  if (derived->attr.extension)\n+    {\n+      gfc_symbol* super_type;\n+      super_type = gfc_get_derived_super_type (derived);\n+      gcc_assert (super_type);\n+\n+      return gfc_find_typebound_intrinsic_op (super_type, t, op,\n+\t\t\t\t\t      noaccess, where);\n+    }\n+\n+  /* Nothing found.  */\n+  return NULL;\n+}\n+\n+\n+/* Get a typebound-procedure symtree or create and insert it if not yet\n+   present.  This is like a very simplified version of gfc_get_sym_tree for\n+   tbp-symtrees rather than regular ones.  */\n+\n+gfc_symtree*\n+gfc_get_tbp_symtree (gfc_symtree **root, const char *name)\n+{\n+  gfc_symtree *result;\n+\n+  result = gfc_find_symtree (*root, name);\n+  if (!result)\n+    {\n+      result = gfc_new_symtree (root, name);\n+      gcc_assert (result);\n+      result->n.tb = NULL;\n+    }\n+\n+  return result;\n+}"}, {"sha": "75f27be80ee8f05d1d93b9add82079bb390a099d", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=d15bac214b2de189f37c17612dfa9f0e495e90f1", "patch": "@@ -676,36 +676,6 @@ gfc_has_vector_index (gfc_expr *e)\n }\n \n \n-/* Insert a reference to the component of the given name.\n-   Only to be used with CLASS containers.  */\n-\n-void\n-gfc_add_component_ref (gfc_expr *e, const char *name)\n-{\n-  gfc_ref **tail = &(e->ref);\n-  gfc_ref *next = NULL;\n-  gfc_symbol *derived = e->symtree->n.sym->ts.u.derived;\n-  while (*tail != NULL)\n-    {\n-      if ((*tail)->type == REF_COMPONENT)\n-\tderived = (*tail)->u.c.component->ts.u.derived;\n-      if ((*tail)->type == REF_ARRAY && (*tail)->next == NULL)\n-\tbreak;\n-      tail = &((*tail)->next);\n-    }\n-  if (*tail != NULL && strcmp (name, \"$data\") == 0)\n-    next = *tail;\n-  (*tail) = gfc_get_ref();\n-  (*tail)->next = next;\n-  (*tail)->type = REF_COMPONENT;\n-  (*tail)->u.c.sym = derived;\n-  (*tail)->u.c.component = gfc_find_component (derived, name, true, true);\n-  gcc_assert((*tail)->u.c.component);\n-  if (!next)\n-    e->ts = (*tail)->u.c.component->ts;\n-}\n-\n-\n /* Copy a shape array.  */\n \n mpz_t *\n@@ -3628,32 +3598,6 @@ gfc_default_initializer (gfc_typespec *ts)\n }\n \n \n-/* Build a NULL initializer for CLASS pointers,\n-   initializing the $data and $vptr components to zero.  */\n-\n-gfc_expr *\n-gfc_class_null_initializer (gfc_typespec *ts)\n-{\n-  gfc_expr *init;\n-  gfc_component *comp;\n-  \n-  init = gfc_get_structure_constructor_expr (ts->type, ts->kind,\n-\t\t\t\t\t     &ts->u.derived->declared_at);\n-  init->ts = *ts;\n-  \n-  for (comp = ts->u.derived->components; comp; comp = comp->next)\n-    {\n-      gfc_constructor *ctor = gfc_constructor_get();\n-      ctor->expr = gfc_get_expr ();\n-      ctor->expr->expr_type = EXPR_NULL;\n-      ctor->expr->ts = comp->ts;\n-      gfc_constructor_append (&init->value.constructor, ctor);\n-    }\n-\n-  return init;\n-}\n-\n-\n /* Given a symbol, create an expression node with that symbol as a\n    variable. If the symbol is array valued, setup a reference of the\n    whole array.  */"}, {"sha": "c14bcce9423b135c9313f6bee3d156e8c6677051", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d15bac214b2de189f37c17612dfa9f0e495e90f1", "patch": "@@ -2512,22 +2512,11 @@ void gfc_free_dt_list (void);\n gfc_gsymbol *gfc_get_gsymbol (const char *);\n gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n-gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n-\t\t\t\tgfc_array_spec **, bool);\n-gfc_symbol *gfc_find_derived_vtab (gfc_symbol *, bool);\n gfc_typebound_proc* gfc_get_typebound_proc (void);\n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n gfc_symbol* gfc_get_ultimate_derived_super_type (gfc_symbol*);\n bool gfc_type_is_extension_of (gfc_symbol *, gfc_symbol *);\n bool gfc_type_compatible (gfc_typespec *, gfc_typespec *);\n-gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*,\n-\t\t\t\t      const char*, bool, locus*);\n-gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, gfc_try*,\n-\t\t\t\t\t const char*, bool, locus*);\n-gfc_typebound_proc* gfc_find_typebound_intrinsic_op (gfc_symbol*, gfc_try*,\n-\t\t\t\t\t\t     gfc_intrinsic_op, bool,\n-\t\t\t\t\t\t     locus*);\n-gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n \n void gfc_copy_formal_args (gfc_symbol *, gfc_symbol *);\n void gfc_copy_formal_args_intr (gfc_symbol *, gfc_intrinsic_sym *);\n@@ -2593,7 +2582,6 @@ gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n bool is_subref_array (gfc_expr *);\n \n-void gfc_add_component_ref (gfc_expr *, const char *);\n gfc_expr *gfc_build_conversion (gfc_expr *);\n void gfc_free_ref_list (gfc_ref *);\n void gfc_type_convert_binary (gfc_expr *, int);\n@@ -2630,7 +2618,6 @@ gfc_try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n \n gfc_expr *gfc_default_initializer (gfc_typespec *);\n-gfc_expr *gfc_class_null_initializer (gfc_typespec *);\n gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n \n gfc_array_spec *gfc_get_full_arrayspec_from_expr (gfc_expr *expr);\n@@ -2785,4 +2772,19 @@ int gfc_is_data_pointer (gfc_expr *);\n /* check.c */\n gfc_try gfc_check_same_strlen (const gfc_expr*, const gfc_expr*, const char*);\n \n+/* class.c */\n+void gfc_add_component_ref (gfc_expr *, const char *);\n+gfc_expr *gfc_class_null_initializer (gfc_typespec *);\n+gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n+\t\t\t\tgfc_array_spec **, bool);\n+gfc_symbol *gfc_find_derived_vtab (gfc_symbol *, bool);\n+gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*,\n+\t\t\t\t      const char*, bool, locus*);\n+gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, gfc_try*,\n+\t\t\t\t\t const char*, bool, locus*);\n+gfc_typebound_proc* gfc_find_typebound_intrinsic_op (gfc_symbol*, gfc_try*,\n+\t\t\t\t\t\t     gfc_intrinsic_op, bool,\n+\t\t\t\t\t\t     locus*);\n+gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n+\n #endif /* GCC_GFORTRAN_H  */"}, {"sha": "b719de110448c06eeedc8a63b095942d6cc4fe51", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 0, "deletions": 691, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15bac214b2de189f37c17612dfa9f0e495e90f1/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=d15bac214b2de189f37c17612dfa9f0e495e90f1", "patch": "@@ -4699,694 +4699,3 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n   else\n     return 0;\n }\n-\n-\n-/* Build a polymorphic CLASS entity, using the symbol that comes from\n-   build_sym. A CLASS entity is represented by an encapsulating type,\n-   which contains the declared type as '$data' component, plus a pointer\n-   component '$vptr' which determines the dynamic type.  */\n-\n-gfc_try\n-gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n-\t\t\tgfc_array_spec **as, bool delayed_vtab)\n-{\n-  char name[GFC_MAX_SYMBOL_LEN + 5];\n-  gfc_symbol *fclass;\n-  gfc_symbol *vtab;\n-  gfc_component *c;\n-\n-  /* Determine the name of the encapsulating type.  */\n-  if ((*as) && (*as)->rank && attr->allocatable)\n-    sprintf (name, \"class$%s_%d_a\", ts->u.derived->name, (*as)->rank);\n-  else if ((*as) && (*as)->rank)\n-    sprintf (name, \"class$%s_%d\", ts->u.derived->name, (*as)->rank);\n-  else if (attr->pointer)\n-    sprintf (name, \"class$%s_p\", ts->u.derived->name);\n-  else if (attr->allocatable)\n-    sprintf (name, \"class$%s_a\", ts->u.derived->name);\n-  else\n-    sprintf (name, \"class$%s\", ts->u.derived->name);\n-\n-  gfc_find_symbol (name, ts->u.derived->ns, 0, &fclass);\n-  if (fclass == NULL)\n-    {\n-      gfc_symtree *st;\n-      /* If not there, create a new symbol.  */\n-      fclass = gfc_new_symbol (name, ts->u.derived->ns);\n-      st = gfc_new_symtree (&ts->u.derived->ns->sym_root, name);\n-      st->n.sym = fclass;\n-      gfc_set_sym_referenced (fclass);\n-      fclass->refs++;\n-      fclass->ts.type = BT_UNKNOWN;\n-      fclass->attr.abstract = ts->u.derived->attr.abstract;\n-      if (ts->u.derived->f2k_derived)\n-\tfclass->f2k_derived = gfc_get_namespace (NULL, 0);\n-      if (gfc_add_flavor (&fclass->attr, FL_DERIVED,\n-\t  NULL, &gfc_current_locus) == FAILURE)\n-\treturn FAILURE;\n-\n-      /* Add component '$data'.  */\n-      if (gfc_add_component (fclass, \"$data\", &c) == FAILURE)\n-\treturn FAILURE;\n-      c->ts = *ts;\n-      c->ts.type = BT_DERIVED;\n-      c->attr.access = ACCESS_PRIVATE;\n-      c->ts.u.derived = ts->u.derived;\n-      c->attr.class_pointer = attr->pointer;\n-      c->attr.pointer = attr->pointer || attr->dummy;\n-      c->attr.allocatable = attr->allocatable;\n-      c->attr.dimension = attr->dimension;\n-      c->attr.codimension = attr->codimension;\n-      c->attr.abstract = ts->u.derived->attr.abstract;\n-      c->as = (*as);\n-      c->initializer = NULL;\n-\n-      /* Add component '$vptr'.  */\n-      if (gfc_add_component (fclass, \"$vptr\", &c) == FAILURE)\n-\treturn FAILURE;\n-      c->ts.type = BT_DERIVED;\n-      if (delayed_vtab)\n-\tc->ts.u.derived = NULL;\n-      else\n-\t{\n-\t  vtab = gfc_find_derived_vtab (ts->u.derived, false);\n-\t  gcc_assert (vtab);\n-\t  c->ts.u.derived = vtab->ts.u.derived;\n-\t}\n-      c->attr.pointer = 1;\n-    }\n-\n-  /* Since the extension field is 8 bit wide, we can only have\n-     up to 255 extension levels.  */\n-  if (ts->u.derived->attr.extension == 255)\n-    {\n-      gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n-\t\t ts->u.derived->name, &ts->u.derived->declared_at);\n-      return FAILURE;\n-    }\n-    \n-  fclass->attr.extension = ts->u.derived->attr.extension + 1;\n-  fclass->attr.is_class = 1;\n-  ts->u.derived = fclass;\n-  attr->allocatable = attr->pointer = attr->dimension = 0;\n-  (*as) = NULL;  /* XXX */\n-  return SUCCESS;\n-}\n-\n-\n-static void\n-add_proc_component (gfc_component *c, gfc_symbol *vtype,\n-\t\t    gfc_symtree *st, gfc_symbol *specific,\n-\t\t    bool is_generic, bool is_generic_specific)\n-{\n-  /* Add procedure component.  */\n-  if (is_generic)\n-    {\n-      if (gfc_add_component (vtype, specific->name, &c) == FAILURE)\n-\treturn;\n-      c->ts.interface = specific;\n-    }\n-  else if (c && is_generic_specific)\n-    {\n-      c->ts.interface = st->n.tb->u.specific->n.sym;\n-    }\n-  else\n-    {\n-      c = gfc_find_component (vtype, st->name, true, true);\n-      if (!c && gfc_add_component (vtype, st->name, &c) == FAILURE)\n-\treturn;\n-      c->ts.interface = st->n.tb->u.specific->n.sym;\n-    }\n-\n-  if (!c->tb)\n-    c->tb = XCNEW (gfc_typebound_proc);\n-  *c->tb = *st->n.tb;\n-  c->tb->ppc = 1;\n-  c->attr.procedure = 1;\n-  c->attr.proc_pointer = 1;\n-  c->attr.flavor = FL_PROCEDURE;\n-  c->attr.access = ACCESS_PRIVATE;\n-  c->attr.external = 1;\n-  c->attr.untyped = 1;\n-  c->attr.if_source = IFSRC_IFBODY;\n-\n-  /* A static initializer cannot be used here because the specific\n-     function is not a constant; internal compiler error: in\n-     output_constant, at varasm.c:4623  */\n-  c->initializer = NULL;\n-}\n-\n-\n-static void\n-add_proc_comps (gfc_component *c, gfc_symbol *vtype,\n-\t\tgfc_symtree *st, bool is_generic)\n-{\n-  if (c == NULL && !is_generic)\n-    {\n-      add_proc_component (c, vtype, st, NULL, false, false);\n-    }\n-  else if (is_generic && st->n.tb && vtype->components == NULL)\n-    {\n-      gfc_tbp_generic* g;\n-      gfc_symbol * specific;\n-      for (g = st->n.tb->u.generic; g; g = g->next)\n-\t{\n-\t  if (!g->specific)\n-\t    continue;\n-\t  specific = g->specific->u.specific->n.sym;\n-\t  add_proc_component (NULL, vtype, st, specific, true, false);\n-\t}\n-    }\n-  else if (c->attr.proc_pointer && c->tb)\n-    {\n-      *c->tb = *st->n.tb;\n-      c->tb->ppc = 1;\n-      c->ts.interface = st->n.tb->u.specific->n.sym;\t  \n-    }\n-}\n-\n-static void\n-add_procs_to_declared_vtab1 (gfc_symtree *st, gfc_symbol *vtype,\n-\t\t\t     bool resolved)\n-{\n-  gfc_component *c;\n-  gfc_symbol *generic;\n-  char name[3 * GFC_MAX_SYMBOL_LEN + 10];\n-\n-  if (!st)\n-    return;\n-\n-  if (st->left)\n-    add_procs_to_declared_vtab1 (st->left, vtype, resolved);\n-\n-  if (st->right)\n-    add_procs_to_declared_vtab1 (st->right, vtype, resolved);\n-\n-  if (!st->n.tb)\n-    return;\n-\n-  if (!st->n.tb->is_generic && st->n.tb->u.specific)\n-    {\n-      c = gfc_find_component (vtype, st->name, true, true);\n-      add_proc_comps (c, vtype, st, false);\n-    }\n-  else if (st->n.tb->is_generic)\n-    {\n-      c = gfc_find_component (vtype, st->name, true, true);\n-\n-      if (c == NULL)\n-\t{\n-\t  /* Add derived type component with generic name.  */\n-\t  if (gfc_add_component (vtype, st->name, &c) == FAILURE)\n-\t    return;\n-\t  c->ts.type = BT_DERIVED;\n-\t  c->attr.flavor = FL_VARIABLE;\n-\t  c->attr.pointer = 1;\n-\n-\t  /* Add a special empty derived type as a placeholder.  */\n-\t  sprintf (name, \"$empty\");\n-\t  gfc_find_symbol (name, vtype->ns, 0, &generic);\n-\t  if (generic == NULL)\n-\t    {\n-\t      gfc_get_symbol (name, vtype->ns, &generic);\n-\t      generic->attr.flavor = FL_DERIVED;\n-\t      generic->refs++;\n-\t      gfc_set_sym_referenced (generic);\n-\t      generic->ts.type = BT_UNKNOWN;\n-\t      generic->attr.zero_comp = 1;\n-\t    }\n-\n-\t  c->ts.u.derived = generic;\n-\t}\n-    }\n-}\n-\n-\n-static void\n-copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype,\n-\t\t      bool resolved)\n-{\n-  gfc_component *c, *cmp;\n-  gfc_symbol *vtab;\n-\n-  vtab = gfc_find_derived_vtab (declared, resolved);\n-\n-  for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)\n-    {\n-      if (gfc_find_component (vtype, cmp->name, true, true))\n-\tcontinue;\n-\n-      if (gfc_add_component (vtype, cmp->name, &c) == FAILURE)\n-\treturn;\n-\n-      if (cmp->ts.type == BT_DERIVED)\n-\t{\n-\t  c->ts = cmp->ts;\n-\t  c->ts.u.derived = cmp->ts.u.derived;\n-\t  c->attr.flavor = FL_VARIABLE;\n-\t  c->attr.pointer = 1;\n-\t  c->initializer = NULL;\n-\t  continue;\n-\t}\n-\n-      c->tb = XCNEW (gfc_typebound_proc);\n-      *c->tb = *cmp->tb;\n-      c->attr.procedure = 1;\n-      c->attr.proc_pointer = 1;\n-      c->attr.flavor = FL_PROCEDURE;\n-      c->attr.access = ACCESS_PRIVATE;\n-      c->attr.external = 1;\n-      c->ts.interface = cmp->ts.interface;\n-      c->attr.untyped = 1;\n-      c->attr.if_source = IFSRC_IFBODY;\n-      c->initializer = NULL;\n-    }\n-}\n-\n-static void\n-add_procs_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n-\t\t\t    gfc_symbol *derived, bool resolved)\n-{\n-  gfc_symbol* super_type;\n-\n-  super_type = gfc_get_derived_super_type (declared);\n-\n-  if (super_type && (super_type != declared))\n-    add_procs_to_declared_vtab (super_type, vtype, derived, resolved);\n-\n-  if (declared != derived)\n-    copy_vtab_proc_comps (declared, vtype, resolved);\n-\n-  if (declared->f2k_derived && declared->f2k_derived->tb_sym_root)\n-    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_sym_root,\n-\t\t\t\t vtype, resolved);\n-\n-  if (declared->f2k_derived && declared->f2k_derived->tb_uop_root)\n-    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_uop_root,\n-\t\t\t\t vtype, resolved);\n-}\n-\n-\n-static\n-void add_generic_specifics (gfc_symbol *declared, gfc_symbol *vtab,\n-\t\t\t    const char *name)\n-{\n-  gfc_tbp_generic* g;\n-  gfc_symbol * specific1;\n-  gfc_symbol * specific2;\n-  gfc_symtree *st = NULL;\n-  gfc_component *c;\n-\n-  /* Find the generic procedure using the component name.  */\n-  st = gfc_find_typebound_proc (declared, NULL, name, true, NULL);\n-  if (st == NULL)\n-    st = gfc_find_typebound_user_op (declared, NULL, name, true, NULL);\n-\n-  if (st == NULL)\n-    return;\n-\n-  /* Add procedure pointer components for the specific procedures. */\n-  for (g = st->n.tb->u.generic; g; g = g->next)\n-    {\n-      if (!g->specific)\n-\tcontinue;\n-      specific1 = g->specific_st->n.tb->u.specific->n.sym;\n-\n-      c = vtab->ts.u.derived->components;\n-      specific2 = NULL;\n-\n-      /* Override identical specific interface.  */\n-      if (vtab->ts.u.derived->components)\n-\t{\n-\t  for (; c; c= c->next)\n-\t    {\n-\t      specific2 = c->ts.interface;\n-\t      if (gfc_compare_interfaces (specific2, specific1,\n-\t\t\t\t\t  specific1->name, 0, 0, NULL, 0))\n-\t\tbreak;\n-\t    }\n-\t}\n-\n-      add_proc_component (c, vtab->ts.u.derived, g->specific_st,\n-\t\t\t  NULL, false, true);\n-      vtab->ts.u.derived->attr.zero_comp = 0;\n-    }\n-}\n-\n-\n-static void\n-add_generics_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n-\t\t\t       gfc_symbol *derived, bool resolved)\n-{\n-  gfc_component *cmp;\n-  gfc_symtree *st = NULL;\n-  gfc_symbol * vtab;\n-  char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n-  gfc_symbol* super_type;\n-\n-  gcc_assert (resolved);\n-\n-  for (cmp = vtype->components; cmp; cmp = cmp->next)\n-    {\n-      if (cmp->ts.type != BT_DERIVED)\n-\tcontinue;\n-\n-      /* The only derived type that does not represent a generic\n-\t procedure is the pointer to the parent vtab.  */\n-      if (cmp->ts.u.derived\n-\t    && strcmp (cmp->ts.u.derived->name, \"$extends\") == 0)\n-\tcontinue;\n-\n-      /* Find the generic procedure using the component name.  */\n-      st = gfc_find_typebound_proc (declared, NULL, cmp->name,\n-\t\t\t\t    true, NULL);\n-      if (st == NULL)\n-\tst = gfc_find_typebound_user_op (declared, NULL, cmp->name,\n-\t\t\t\t\t true, NULL);\n-\n-      /* Should be an error but we pass on it for now.  */\n-      if (st == NULL || !st->n.tb->is_generic)\n-\tcontinue;\n-\n-      vtab = NULL;\n-\n-      /* Build a vtab and a special vtype, with only the procedure\n-\t pointer fields, to carry the pointers to the specific\n-\t procedures.  Should this name ever be changed, the same\n-\t should be done in trans-expr.c(gfc_trans_assign_vtab_procs). */\n-      sprintf (name, \"vtab$%s$%s\", vtype->name, cmp->name);\n-      gfc_find_symbol (name, derived->ns, 0, &vtab);\n-      if (vtab == NULL)\n-\t{\n-\t  gfc_get_symbol (name, derived->ns, &vtab);\n-\t  vtab->ts.type = BT_DERIVED;\n-\t  vtab->attr.flavor = FL_VARIABLE;\n-\t  vtab->attr.target = 1;\n-\t  vtab->attr.save = SAVE_EXPLICIT;\n-\t  vtab->attr.vtab = 1;\n-\t  vtab->refs++;\n-\t  gfc_set_sym_referenced (vtab);\n-\t  sprintf (name, \"%s$%s\", vtype->name, cmp->name);\n-\t  \n-\t  gfc_find_symbol (name, derived->ns, 0, &cmp->ts.u.derived);\n-\t  if (cmp->ts.u.derived == NULL\n-\t\t|| (strcmp (cmp->ts.u.derived->name, \"$empty\") == 0))\n-\t    {\n-\t      gfc_get_symbol (name, derived->ns, &cmp->ts.u.derived);\n-\t      if (gfc_add_flavor (&cmp->ts.u.derived->attr, FL_DERIVED,\n-\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n-\t\treturn;\n-\t      cmp->ts.u.derived->refs++;\n-\t      gfc_set_sym_referenced (cmp->ts.u.derived);\n-\t      cmp->ts.u.derived->attr.vtype = 1;\n-\t      cmp->ts.u.derived->attr.zero_comp = 1;\n-\t    }\n-\t  vtab->ts.u.derived = cmp->ts.u.derived;\n-\t}\n-\n-      /* Store this for later use in setting the pointer.  */\n-      cmp->ts.interface = vtab;\n-\n-      if (vtab->ts.u.derived->components)\n-\tcontinue;\n-\n-      super_type = gfc_get_derived_super_type (declared);\n-\n-      if (super_type && (super_type != declared))\n-\tadd_generic_specifics (super_type, vtab, cmp->name);\n-\n-      add_generic_specifics (declared, vtab, cmp->name);\n-    }\n-}\n-\n-\n-/* Find the symbol for a derived type's vtab.  A vtab has the following\n-   fields:\n-   $hash\ta hash value used to identify the derived type\n-   $size\tthe size in bytes of the derived type\n-   $extends\ta pointer to the vtable of the parent derived type\n-   then:\n-   procedure pointer components for the specific typebound procedures\n-   structure pointers to reduced vtabs that contain procedure\n-   pointers to the specific procedures.  */\n-\n-gfc_symbol *\n-gfc_find_derived_vtab (gfc_symbol *derived, bool resolved)\n-{\n-  gfc_namespace *ns;\n-  gfc_symbol *vtab = NULL, *vtype = NULL;\n-  char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n-\n-  ns = gfc_current_ns;\n-\n-  for (; ns; ns = ns->parent)\n-    if (!ns->parent)\n-      break;\n-\n-  if (ns)\n-    {\n-      sprintf (name, \"vtab$%s\", derived->name);\n-      gfc_find_symbol (name, ns, 0, &vtab);\n-\n-      if (vtab == NULL)\n-\t{\n-\t  gfc_get_symbol (name, ns, &vtab);\n-\t  vtab->ts.type = BT_DERIVED;\n-\t  vtab->attr.flavor = FL_VARIABLE;\n-\t  vtab->attr.target = 1;\n-\t  vtab->attr.save = SAVE_EXPLICIT;\n-\t  vtab->attr.vtab = 1;\n-\t  vtab->refs++;\n-\t  gfc_set_sym_referenced (vtab);\n-\t  sprintf (name, \"vtype$%s\", derived->name);\n-\t  \n-\t  gfc_find_symbol (name, ns, 0, &vtype);\n-\t  if (vtype == NULL)\n-\t    {\n-\t      gfc_component *c;\n-\t      gfc_symbol *parent = NULL, *parent_vtab = NULL;\n-\n-\t      gfc_get_symbol (name, ns, &vtype);\n-\t      if (gfc_add_flavor (&vtype->attr, FL_DERIVED,\n-\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n-\t\treturn NULL;\n-\t      vtype->refs++;\n-\t      gfc_set_sym_referenced (vtype);\n-\n-\t      /* Add component '$hash'.  */\n-\t      if (gfc_add_component (vtype, \"$hash\", &c) == FAILURE)\n-\t\treturn NULL;\n-\t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = 4;\n-\t      c->attr.access = ACCESS_PRIVATE;\n-\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n-\t\t\t\t\t\t NULL, derived->hash_value);\n-\n-\t      /* Add component '$size'.  */\n-\t      if (gfc_add_component (vtype, \"$size\", &c) == FAILURE)\n-\t\treturn NULL;\n-\t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = 4;\n-\t      c->attr.access = ACCESS_PRIVATE;\n-\t      /* Remember the derived type in ts.u.derived,\n-\t\t so that the correct initializer can be set later on\n-\t\t (in gfc_conv_structure).  */\n-\t      c->ts.u.derived = derived;\n-\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n-\t\t\t\t\t\t NULL, 0);\n-\n-\t      /* Add component $extends.  */\n-\t      if (gfc_add_component (vtype, \"$extends\", &c) == FAILURE)\n-\t\treturn NULL;\n-\t      c->attr.pointer = 1;\n-\t      c->attr.access = ACCESS_PRIVATE;\n-\t      parent = gfc_get_derived_super_type (derived);\n-\t      if (parent)\n-\t\t{\n-\t\t  parent_vtab = gfc_find_derived_vtab (parent, resolved);\n-\t\t  c->ts.type = BT_DERIVED;\n-\t\t  c->ts.u.derived = parent_vtab->ts.u.derived;\n-\t\t  c->initializer = gfc_get_expr ();\n-\t\t  c->initializer->expr_type = EXPR_VARIABLE;\n-\t\t  gfc_find_sym_tree (parent_vtab->name, parent_vtab->ns,\n-\t\t\t\t     0, &c->initializer->symtree);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  c->ts.type = BT_DERIVED;\n-\t\t  c->ts.u.derived = vtype;\n-\t\t  c->initializer = gfc_get_null_expr (NULL);\n-\t\t}\n-\n-\t      add_procs_to_declared_vtab (derived, vtype, derived, resolved);\n-\t      vtype->attr.vtype = 1;\n-\t    }\n-\n-\t  vtab->ts.u.derived = vtype;\n-\t  vtab->value = gfc_default_initializer (&vtab->ts);\n-\t}\n-    }\n-\n-  /* Catch the call just before the backend declarations are built, so that\n-     the generic procedures have been resolved and the specific procedures\n-     have formal interfaces that can be compared.  */\n-  if (resolved\n-\t&& vtab->ts.u.derived\n-\t&& vtab->ts.u.derived->backend_decl == NULL)\n-    add_generics_to_declared_vtab (derived, vtab->ts.u.derived,\n-\t\t\t\t   derived, resolved);\n-\n-  return vtab;\n-}\n-\n-\n-/* General worker function to find either a type-bound procedure or a\n-   type-bound user operator.  */\n-\n-static gfc_symtree*\n-find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n-\t\t\t const char* name, bool noaccess, bool uop,\n-\t\t\t locus* where)\n-{\n-  gfc_symtree* res;\n-  gfc_symtree* root;\n-\n-  /* Set correct symbol-root.  */\n-  gcc_assert (derived->f2k_derived);\n-  root = (uop ? derived->f2k_derived->tb_uop_root\n-\t      : derived->f2k_derived->tb_sym_root);\n-\n-  /* Set default to failure.  */\n-  if (t)\n-    *t = FAILURE;\n-\n-  /* Try to find it in the current type's namespace.  */\n-  res = gfc_find_symtree (root, name);\n-  if (res && res->n.tb && !res->n.tb->error)\n-    {\n-      /* We found one.  */\n-      if (t)\n-\t*t = SUCCESS;\n-\n-      if (!noaccess && derived->attr.use_assoc\n-\t  && res->n.tb->access == ACCESS_PRIVATE)\n-\t{\n-\t  if (where)\n-\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n-\t\t       name, derived->name, where);\n-\t  if (t)\n-\t    *t = FAILURE;\n-\t}\n-\n-      return res;\n-    }\n-\n-  /* Otherwise, recurse on parent type if derived is an extension.  */\n-  if (derived->attr.extension)\n-    {\n-      gfc_symbol* super_type;\n-      super_type = gfc_get_derived_super_type (derived);\n-      gcc_assert (super_type);\n-\n-      return find_typebound_proc_uop (super_type, t, name,\n-\t\t\t\t      noaccess, uop, where);\n-    }\n-\n-  /* Nothing found.  */\n-  return NULL;\n-}\n-\n-\n-/* Find a type-bound procedure or user operator by name for a derived-type\n-   (looking recursively through the super-types).  */\n-\n-gfc_symtree*\n-gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n-\t\t\t const char* name, bool noaccess, locus* where)\n-{\n-  return find_typebound_proc_uop (derived, t, name, noaccess, false, where);\n-}\n-\n-gfc_symtree*\n-gfc_find_typebound_user_op (gfc_symbol* derived, gfc_try* t,\n-\t\t\t    const char* name, bool noaccess, locus* where)\n-{\n-  return find_typebound_proc_uop (derived, t, name, noaccess, true, where);\n-}\n-\n-\n-/* Find a type-bound intrinsic operator looking recursively through the\n-   super-type hierarchy.  */\n-\n-gfc_typebound_proc*\n-gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n-\t\t\t\t gfc_intrinsic_op op, bool noaccess,\n-\t\t\t\t locus* where)\n-{\n-  gfc_typebound_proc* res;\n-\n-  /* Set default to failure.  */\n-  if (t)\n-    *t = FAILURE;\n-\n-  /* Try to find it in the current type's namespace.  */\n-  if (derived->f2k_derived)\n-    res = derived->f2k_derived->tb_op[op];\n-  else  \n-    res = NULL;\n-\n-  /* Check access.  */\n-  if (res && !res->error)\n-    {\n-      /* We found one.  */\n-      if (t)\n-\t*t = SUCCESS;\n-\n-      if (!noaccess && derived->attr.use_assoc\n-\t  && res->access == ACCESS_PRIVATE)\n-\t{\n-\t  if (where)\n-\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n-\t\t       gfc_op2string (op), derived->name, where);\n-\t  if (t)\n-\t    *t = FAILURE;\n-\t}\n-\n-      return res;\n-    }\n-\n-  /* Otherwise, recurse on parent type if derived is an extension.  */\n-  if (derived->attr.extension)\n-    {\n-      gfc_symbol* super_type;\n-      super_type = gfc_get_derived_super_type (derived);\n-      gcc_assert (super_type);\n-\n-      return gfc_find_typebound_intrinsic_op (super_type, t, op,\n-\t\t\t\t\t      noaccess, where);\n-    }\n-\n-  /* Nothing found.  */\n-  return NULL;\n-}\n-\n-\n-/* Get a typebound-procedure symtree or create and insert it if not yet\n-   present.  This is like a very simplified version of gfc_get_sym_tree for\n-   tbp-symtrees rather than regular ones.  */\n-\n-gfc_symtree*\n-gfc_get_tbp_symtree (gfc_symtree **root, const char *name)\n-{\n-  gfc_symtree *result;\n-\n-  result = gfc_find_symtree (*root, name);\n-  if (!result)\n-    {\n-      result = gfc_new_symtree (root, name);\n-      gcc_assert (result);\n-      result->n.tb = NULL;\n-    }\n-\n-  return result;\n-}"}]}