{"sha": "33e9d2aa3de5ab3e8267ffed4e1fd927de469552", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNlOWQyYWEzZGU1YWIzZTgyNjdmZmVkNGUxZmQ5MjdkZTQ2OTU1Mg==", "commit": {"author": {"name": "Devang Patel", "email": "dpatel@apple.com", "date": "2003-07-01T19:04:18Z"}, "committer": {"name": "Devang Patel", "email": "dpatel@gcc.gnu.org", "date": "2003-07-01T19:04:18Z"}, "message": "dbxout.c (DBXOUT_DECR_NESTING): Emit pending bincls, if required.\n\n2003-07-01  Devang Patel  <dpatel@apple.com>\n\n        * dbxout.c (DBXOUT_DECR_NESTING): Emit pending bincls, if required.\n        (binclstatus): New.\n        (struct dbx_file): New members - bincl_status, pending_bincl_name and\n        prev.\n        (pending_bincls): New.\n        (dbxout_init): Initialize new dbx_file members.\n        (dbxout_start_source_file): Same.\n        (emit_bincl_stab): New function.\n        (emit_pending_bincls): Same.\n        (emit_pending_bincls_if_required): Same.\n        (dbxout_end_source_file): Emit EINCL stab only if BINCL is  already\n        processed.\n        (dbxout_begin_block): Emit pending BINCL stabs.\n        (dbxout_end_block): Same.\n        (dbxout_function_decl): Same.\n        (dbxout_continue): Same.\n        (dbxout_type): Same.\n        (dbxout_class_name_qualifiers): Same.\n        (dbxout_symbol): Same.\n        (dbxout_symbol_location): Same.\n        (dbxout_parms): Same.\n\nFrom-SVN: r68787", "tree": {"sha": "19310319c49d2025d297ca1c1fbba1a65167bd45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19310319c49d2025d297ca1c1fbba1a65167bd45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33e9d2aa3de5ab3e8267ffed4e1fd927de469552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e9d2aa3de5ab3e8267ffed4e1fd927de469552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33e9d2aa3de5ab3e8267ffed4e1fd927de469552", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e9d2aa3de5ab3e8267ffed4e1fd927de469552/comments", "author": null, "committer": null, "parents": [{"sha": "28570f7ec6c78e415c43bcbfb74f1be3efece311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28570f7ec6c78e415c43bcbfb74f1be3efece311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28570f7ec6c78e415c43bcbfb74f1be3efece311"}], "stats": {"total": 124, "additions": 118, "deletions": 6}, "files": [{"sha": "f846aebf69cce154a4aa3c00f02c52af6bb59d3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e9d2aa3de5ab3e8267ffed4e1fd927de469552/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e9d2aa3de5ab3e8267ffed4e1fd927de469552/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33e9d2aa3de5ab3e8267ffed4e1fd927de469552", "patch": "@@ -1,3 +1,27 @@\n+2003-07-01  Devang Patel  <dpatel@apple.com>\n+\n+\t* dbxout.c (DBXOUT_DECR_NESTING): Emit pending bincls, if required.\n+\t(binclstatus): New.\n+\t(struct dbx_file): New members - bincl_status, pending_bincl_name and \n+\tprev.\n+\t(pending_bincls): New.\n+\t(dbxout_init): Initialize new dbx_file members.\n+\t(dbxout_start_source_file): Same.\n+\t(emit_bincl_stab): New function.\n+\t(emit_pending_bincls): Same.\n+\t(emit_pending_bincls_if_required): Same.\n+\t(dbxout_end_source_file): Emit EINCL stab only if BINCL is  already \n+\tprocessed.\n+\t(dbxout_begin_block): Emit pending BINCL stabs.\n+\t(dbxout_end_block): Same.\n+\t(dbxout_function_decl): Same.\n+\t(dbxout_continue): Same.\n+\t(dbxout_type): Same.\n+\t(dbxout_class_name_qualifiers): Same.\n+\t(dbxout_symbol): Same.\n+\t(dbxout_symbol_location): Same.\n+\t(dbxout_parms): Same.\n+\t\n 2003-07-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-semantics.c (genrtl_case_label): Fix format specifier bug."}, {"sha": "603b8fafc9ccb77193d35c7ab929e32381b1a0ef", "filename": "gcc/dbxout.c", "status": "modified", "additions": 94, "deletions": 6, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e9d2aa3de5ab3e8267ffed4e1fd927de469552/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e9d2aa3de5ab3e8267ffed4e1fd927de469552/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=33e9d2aa3de5ab3e8267ffed4e1fd927de469552", "patch": "@@ -96,7 +96,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #undef DBXOUT_DECR_NESTING\n #define DBXOUT_DECR_NESTING \\\n   if (--debug_nesting == 0 && symbol_queue_index > 0) \\\n-    debug_flush_symbol_queue ()\n+    { emit_pending_bincls_if_required (); debug_flush_symbol_queue (); }\n \n #undef DBXOUT_DECR_NESTING_AND_RETURN\n #define DBXOUT_DECR_NESTING_AND_RETURN(x) \\\n@@ -179,6 +179,8 @@ static GTY(()) int typevec_len;\n \n static GTY(()) int next_type_number;\n \n+enum binclstatus {BINCL_NOT_REQUIRED, BINCL_PENDING, BINCL_PROCESSED};\n+\n /* When using N_BINCL in dbx output, each type number is actually a\n    pair of the file number and the type number within the file.\n    This is a stack of input files.  */\n@@ -188,8 +190,14 @@ struct dbx_file GTY(())\n   struct dbx_file *next;\n   int file_number;\n   int next_type_number;\n+  enum binclstatus bincl_status;      /* Keep track of lazy bincl.  */\n+  const char *pending_bincl_name;     /* Name of bincl.  */\n+  struct dbx_file *prev;              /* Chain to traverse all pending bincls.  */\n };\n \n+/* If zero then there is no pending BINCL.  */\n+static int pending_bincls = 0;\n+\n /* This is the top of the stack.  */\n \n static GTY(()) struct dbx_file *current_file;\n@@ -307,6 +315,10 @@ static int current_sym_nchars;\n #define CONTIN do { } while (0)\n #endif\n \n+static void emit_bincl_stab             (const char *c);\n+static void emit_pending_bincls         (void);\n+static inline void emit_pending_bincls_if_required (void);\n+\n static void dbxout_init (const char *);\n static void dbxout_finish (const char *);\n static void dbxout_start_source_file (unsigned, const char *);\n@@ -502,6 +514,9 @@ dbxout_init (const char *input_file_name)\n   current_file->file_number = 0;\n   current_file->next_type_number = 1;\n   next_file_number = 1;\n+  current_file->prev = NULL;\n+  current_file->bincl_status = BINCL_NOT_REQUIRED;\n+  current_file->pending_bincl_name = NULL;\n #endif\n \n   /* Make sure that types `int' and `char' have numbers 1 and 2.\n@@ -542,6 +557,59 @@ dbxout_typedefs (tree syms)\n     }\n }\n \n+/* Emit BINCL stab using given name.   */\n+static void\n+emit_bincl_stab (const char *name)\n+{\n+  fprintf (asmfile, \"%s\", ASM_STABS_OP);\n+  output_quoted_string (asmfile, name);\n+  fprintf (asmfile, \",%d,0,0,0\\n\", N_BINCL);\n+}\n+\n+/* If there are pending bincls then it is time to emit all of them.  */\n+\n+static inline void\n+emit_pending_bincls_if_required ()\n+{\n+#ifdef DBX_USE_BINCL\n+  if (pending_bincls)\n+    emit_pending_bincls ();\n+#endif\n+}\n+\n+/* Emit all pending bincls.  */\n+\n+static void\n+emit_pending_bincls ()\n+{\n+  struct dbx_file *f = current_file;\n+\n+  /* Find first pending bincl.  */\n+  while (f->bincl_status == BINCL_PENDING)\n+    f = f->next;\n+\n+  /* Now emit all bincls.  */\n+  f = f->prev;\n+\n+  while (f)\n+    {\n+      if (f->bincl_status == BINCL_PENDING)\n+        {\n+          emit_bincl_stab (f->pending_bincl_name);\n+\n+\t  /* Update file number and status.  */\n+          f->file_number = next_file_number++;\n+          f->bincl_status = BINCL_PROCESSED;\n+        }\n+      if (f == current_file)\n+        break;\n+      f = f->prev;\n+    }\n+\n+  /* All pending bincls have been emitted.  */\n+  pending_bincls = 0;\n+}\n+\n /* Change to reading from a new source file.  Generate a N_BINCL stab.  */\n \n static void\n@@ -552,12 +620,16 @@ dbxout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n   struct dbx_file *n = (struct dbx_file *) ggc_alloc (sizeof *n);\n \n   n->next = current_file;\n-  n->file_number = next_file_number++;\n   n->next_type_number = 1;\n+  /* Do not assign file number now. \n+     Delay it until we actually emit BINCL.  */\n+  n->file_number = 0;\n+  n->prev = NULL;\n+  current_file->prev = n;\n+  n->bincl_status = BINCL_PENDING;\n+  n->pending_bincl_name = filename;\n+  pending_bincls = 1;\n   current_file = n;\n-  fprintf (asmfile, \"%s\", ASM_STABS_OP);\n-  output_quoted_string (asmfile, filename);\n-  fprintf (asmfile, \",%d,0,0,0\\n\", N_BINCL);\n #endif\n }\n \n@@ -567,7 +639,10 @@ static void\n dbxout_end_source_file (unsigned int line ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_USE_BINCL\n-  fprintf (asmfile, \"%s%d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n+  /* Emit EINCL stab only if BINCL is not pending.  */\n+  if (current_file->bincl_status == BINCL_PROCESSED)\n+    fprintf (asmfile, \"%s%d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n+  current_file->bincl_status = BINCL_NOT_REQUIRED;\n   current_file = current_file->next;\n #endif\n }\n@@ -652,6 +727,7 @@ dbxout_source_line (unsigned int lineno, const char *filename)\n static void\n dbxout_begin_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n+  emit_pending_bincls_if_required ();\n   (*targetm.asm_out.internal_label) (asmfile, \"LBB\", n);\n }\n \n@@ -660,6 +736,7 @@ dbxout_begin_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n static void\n dbxout_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n+  emit_pending_bincls_if_required ();\n   (*targetm.asm_out.internal_label) (asmfile, \"LBE\", n);\n }\n \n@@ -672,6 +749,7 @@ dbxout_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n static void\n dbxout_function_decl (tree decl)\n {\n+  emit_pending_bincls_if_required ();\n #ifndef DBX_FUNCTION_FIRST\n   dbxout_begin_function (decl);\n #endif\n@@ -798,6 +876,7 @@ dbxout_type_index (tree type)\n static void\n dbxout_continue (void)\n {\n+  emit_pending_bincls_if_required ();\n #ifdef DBX_CONTIN_CHAR\n   fprintf (asmfile, \"%c\", DBX_CONTIN_CHAR);\n #else\n@@ -1183,6 +1262,7 @@ dbxout_type (tree type, int full)\n \t}\n \n #ifdef DBX_USE_BINCL\n+      emit_pending_bincls_if_required ();\n       typevec[TYPE_SYMTAB_ADDRESS (type)].file_number\n \t= current_file->file_number;\n       typevec[TYPE_SYMTAB_ADDRESS (type)].type_number\n@@ -1977,6 +2057,8 @@ dbxout_class_name_qualifiers (tree decl)\n     {\n       tree name = TYPE_NAME (context);\n \n+      emit_pending_bincls_if_required ();\n+\n       if (TREE_CODE (name) == TYPE_DECL)\n \t{\n \t  dbxout_class_name_qualifiers (name);\n@@ -2069,6 +2151,8 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n         debug_queue_symbol (TYPE_NAME (t));\n     }\n \n+  emit_pending_bincls_if_required ();\n+\n   dbxout_prepare_symbol (decl);\n \n   /* The output will always start with the symbol name,\n@@ -2341,6 +2425,8 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n   int letter = 0;\n   int regno = -1;\n \n+  emit_pending_bincls_if_required ();\n+\n   /* Don't mention a variable at all\n      if it was completely optimized into nothingness.\n \n@@ -2654,6 +2740,8 @@ dbxout_parms (tree parms)\n {\n   ++debug_nesting;\n \n+  emit_pending_bincls_if_required ();\n+\n   for (; parms; parms = TREE_CHAIN (parms))\n     if (DECL_NAME (parms) && TREE_TYPE (parms) != error_mark_node)\n       {"}]}