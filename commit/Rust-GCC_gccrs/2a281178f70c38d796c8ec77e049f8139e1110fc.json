{"sha": "2a281178f70c38d796c8ec77e049f8139e1110fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyODExNzhmNzBjMzhkNzk2YzhlYzc3ZTA0OWY4MTM5ZTExMTBmYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:10:02Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:10:02Z"}, "message": "Code refactoring for call_summary.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* symbol-summary.h (release): Move definition out of class\n\tdeclaration.\n\t(symtab_removal): Likewise.\n\t(symtab_duplication): Likewise.\n\nFrom-SVN: r261308", "tree": {"sha": "ce72a2afcaa62c39b9575278f66b9fa9f2201ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce72a2afcaa62c39b9575278f66b9fa9f2201ae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a281178f70c38d796c8ec77e049f8139e1110fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a281178f70c38d796c8ec77e049f8139e1110fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a281178f70c38d796c8ec77e049f8139e1110fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a281178f70c38d796c8ec77e049f8139e1110fc/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef2ceb103d2eaa47fc9d2a8e8c93360c7886a186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2ceb103d2eaa47fc9d2a8e8c93360c7886a186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef2ceb103d2eaa47fc9d2a8e8c93360c7886a186"}], "stats": {"total": 130, "additions": 77, "deletions": 53}, "files": [{"sha": "9a338f2643a98dc72d5c2e861ac82783aa7f6b60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a281178f70c38d796c8ec77e049f8139e1110fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a281178f70c38d796c8ec77e049f8139e1110fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a281178f70c38d796c8ec77e049f8139e1110fc", "patch": "@@ -1,3 +1,10 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* symbol-summary.h (release): Move definition out of class\n+\tdeclaration.\n+\t(symtab_removal): Likewise.\n+\t(symtab_duplication): Likewise.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* symbol-summary.h (function_summary): Move constructor"}, {"sha": "a73472ef0ae88b3c6846a033385b8339e92fb777", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 70, "deletions": 53, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a281178f70c38d796c8ec77e049f8139e1110fc/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a281178f70c38d796c8ec77e049f8139e1110fc/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=2a281178f70c38d796c8ec77e049f8139e1110fc", "patch": "@@ -330,21 +330,7 @@ class GTY((user)) call_summary <T *>\n   }\n \n   /* Destruction method that can be called for GGT purpose.  */\n-  void release ()\n-  {\n-    if (m_released)\n-      return;\n-\n-    m_symtab->remove_edge_removal_hook (m_symtab_removal_hook);\n-    m_symtab->remove_edge_duplication_hook (m_symtab_duplication_hook);\n-\n-    /* Release all summaries.  */\n-    typedef typename hash_map <map_hash, T *>::iterator map_iterator;\n-    for (map_iterator it = m_map.begin (); it != m_map.end (); ++it)\n-      release ((*it).second);\n-\n-    m_released = true;\n-  }\n+  void release ();\n \n   /* Traverses all summarys with a function F called with\n      ARG as argument.  */\n@@ -369,16 +355,7 @@ class GTY((user)) call_summary <T *>\n   }\n \n   /* Release an item that is stored within map.  */\n-  void release (T *item)\n-  {\n-    if (m_ggc)\n-      {\n-\titem->~T ();\n-\tggc_free (item);\n-      }\n-    else\n-      delete item;\n-  }\n+  void release (T *item);\n \n   /* Getter for summary callgraph edge pointer.  */\n   T* get (cgraph_edge *edge)\n@@ -399,37 +376,11 @@ class GTY((user)) call_summary <T *>\n   }\n \n   /* Symbol removal hook that is registered to symbol table.  */\n-  static void symtab_removal (cgraph_edge *edge, void *data)\n-  {\n-    call_summary *summary = (call_summary <T *> *) (data);\n-\n-    int h_uid = summary->hashable_uid (edge);\n-    T **v = summary->m_map.get (h_uid);\n-\n-    if (v)\n-      {\n-\tsummary->remove (edge, *v);\n-\tsummary->release (*v);\n-\tsummary->m_map.remove (h_uid);\n-      }\n-  }\n+  static void symtab_removal (cgraph_edge *edge, void *data);\n \n   /* Symbol duplication hook that is registered to symbol table.  */\n   static void symtab_duplication (cgraph_edge *edge1, cgraph_edge *edge2,\n-\t\t\t\t  void *data)\n-  {\n-    call_summary *summary = (call_summary <T *> *) (data);\n-    T **v = summary->m_map.get (summary->hashable_uid (edge1));\n-\n-    if (v)\n-      {\n-\t/* This load is necessary, because we insert a new value!  */\n-\tT *data = *v;\n-\tT *duplicate = summary->allocate_new ();\n-\tsummary->m_map.put (summary->hashable_uid (edge2), duplicate);\n-\tsummary->duplicate (edge1, edge2, data, duplicate);\n-      }\n-  }\n+\t\t\t\t  void *data);\n \n protected:\n   /* Indication if we use ggc summary.  */\n@@ -473,6 +424,72 @@ class GTY((user)) call_summary <T *>\n       gt_pointer_operator, void *);\n };\n \n+template <typename T>\n+void\n+call_summary<T *>::release ()\n+{\n+  if (m_released)\n+    return;\n+\n+  m_symtab->remove_edge_removal_hook (m_symtab_removal_hook);\n+  m_symtab->remove_edge_duplication_hook (m_symtab_duplication_hook);\n+\n+  /* Release all summaries.  */\n+  typedef typename hash_map <map_hash, T *>::iterator map_iterator;\n+  for (map_iterator it = m_map.begin (); it != m_map.end (); ++it)\n+    release ((*it).second);\n+\n+  m_released = true;\n+}\n+\n+template <typename T>\n+void\n+call_summary<T *>::release (T *item)\n+{\n+  if (m_ggc)\n+    {\n+      item->~T ();\n+      ggc_free (item);\n+    }\n+  else\n+    delete item;\n+}\n+\n+template <typename T>\n+void\n+call_summary<T *>::symtab_removal (cgraph_edge *edge, void *data)\n+{\n+  call_summary *summary = (call_summary <T *> *) (data);\n+\n+  int h_uid = summary->hashable_uid (edge);\n+  T **v = summary->m_map.get (h_uid);\n+\n+  if (v)\n+    {\n+      summary->remove (edge, *v);\n+      summary->release (*v);\n+      summary->m_map.remove (h_uid);\n+    }\n+}\n+\n+template <typename T>\n+void\n+call_summary<T *>::symtab_duplication (cgraph_edge *edge1,\n+\t\t\t\t       cgraph_edge *edge2, void *data)\n+{\n+  call_summary *summary = (call_summary <T *> *) (data);\n+  T **v = summary->m_map.get (summary->hashable_uid (edge1));\n+\n+  if (v)\n+    {\n+      /* This load is necessary, because we insert a new value!  */\n+      T *data = *v;\n+      T *duplicate = summary->allocate_new ();\n+      summary->m_map.put (summary->hashable_uid (edge2), duplicate);\n+      summary->duplicate (edge1, edge2, data, duplicate);\n+    }\n+}\n+\n template <typename T>\n void\n gt_ggc_mx(call_summary<T *>* const &summary)"}]}