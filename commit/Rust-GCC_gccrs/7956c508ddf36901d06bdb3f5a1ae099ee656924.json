{"sha": "7956c508ddf36901d06bdb3f5a1ae099ee656924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk1NmM1MDhkZGYzNjkwMWQwNmJkYjNmNWExYWUwOTllZTY1NjkyNA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-06-21T14:01:11Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-06-21T14:01:11Z"}, "message": "PR libstdc++/70940 make pmr::resource_adaptor return aligned memory\n\n\tPR libstdc++/70940\n\t* include/experimental/memory_resource (__resource_adaptor_common):\n\tNew base class.\n\t(__resource_adaptor_common::_AlignMgr): Helper for obtaining aligned\n\tpointer from unaligned, and vice versa.\n\t(__resource_adaptor_imp::do_allocate): Use _AlignMgr to adjust\n\tallocated pointer to meet alignment request.\n\t(__resource_adaptor_imp::do_deallocate): Use _AlignMgr to retrieve\n\toriginal pointer for deallocation.\n\t(__resource_adaptor_imp::do_is_equal): Reformat.\n\t(__resource_adaptor_imp::_S_aligned_size): Remove.\n\t(__resource_adaptor_imp::_S_supported): Remove.\n\t(new_delete_resource): Use __gnu_cxx::new_allocator.\n\t* testsuite/experimental/memory_resource/resource_adaptor.cc: Test\n\textended alignments and use debug_allocator to check for matching\n\tallocate/deallocate pairs.\n\nFrom-SVN: r261849", "tree": {"sha": "286e04e81c5b4bb551b3135eb3d9b675e6cda6dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/286e04e81c5b4bb551b3135eb3d9b675e6cda6dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7956c508ddf36901d06bdb3f5a1ae099ee656924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7956c508ddf36901d06bdb3f5a1ae099ee656924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7956c508ddf36901d06bdb3f5a1ae099ee656924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7956c508ddf36901d06bdb3f5a1ae099ee656924/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67b3b8feb3e6a4d2bb94a66498864eef5d5b5963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b3b8feb3e6a4d2bb94a66498864eef5d5b5963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67b3b8feb3e6a4d2bb94a66498864eef5d5b5963"}], "stats": {"total": 225, "additions": 186, "deletions": 39}, "files": [{"sha": "699ec136ae6db92a066f7122508136923b727adb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7956c508ddf36901d06bdb3f5a1ae099ee656924/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7956c508ddf36901d06bdb3f5a1ae099ee656924/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7956c508ddf36901d06bdb3f5a1ae099ee656924", "patch": "@@ -1,3 +1,22 @@\n+2018-06-21  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/70940\n+\t* include/experimental/memory_resource (__resource_adaptor_common):\n+\tNew base class.\n+\t(__resource_adaptor_common::_AlignMgr): Helper for obtaining aligned\n+\tpointer from unaligned, and vice versa.\n+\t(__resource_adaptor_imp::do_allocate): Use _AlignMgr to adjust\n+\tallocated pointer to meet alignment request.\n+\t(__resource_adaptor_imp::do_deallocate): Use _AlignMgr to retrieve\n+\toriginal pointer for deallocation.\n+\t(__resource_adaptor_imp::do_is_equal): Reformat.\n+\t(__resource_adaptor_imp::_S_aligned_size): Remove.\n+\t(__resource_adaptor_imp::_S_supported): Remove.\n+\t(new_delete_resource): Use __gnu_cxx::new_allocator.\n+\t* testsuite/experimental/memory_resource/resource_adaptor.cc: Test\n+\textended alignments and use debug_allocator to check for matching\n+\tallocate/deallocate pairs.\n+\n 2018-06-21  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/debug/debug.h"}, {"sha": "3d2dce19868e6fcad6636225a02fe2d2fc81dd01", "filename": "libstdc++-v3/include/experimental/memory_resource", "status": "modified", "additions": 120, "deletions": 34, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7956c508ddf36901d06bdb3f5a1ae099ee656924/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7956c508ddf36901d06bdb3f5a1ae099ee656924/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource?ref=7956c508ddf36901d06bdb3f5a1ae099ee656924", "patch": "@@ -33,6 +33,7 @@\n #include <new>\n #include <atomic>\n #include <cstddef>\n+#include <ext/new_allocator.h>\n #include <experimental/bits/lfts_config.h>\n \n namespace std {\n@@ -253,9 +254,103 @@ namespace pmr {\n \t\t    const polymorphic_allocator<_Tp2>& __b) noexcept\n     { return !(__a == __b); }\n \n+  class __resource_adaptor_common\n+  {\n+    template<typename> friend class __resource_adaptor_imp;\n+\n+    struct _AlignMgr\n+    {\n+      _AlignMgr(size_t __nbytes, size_t __align)\n+      : _M_nbytes(__nbytes), _M_align(__align)\n+      { }\n+\n+      // Total size that needs to be allocated.\n+      size_t\n+      _M_alloc_size() const { return _M_buf_size() + _M_token_size(); }\n+\n+      void*\n+      _M_adjust(void* __ptr) const\n+      {\n+\tconst auto __orig_ptr = static_cast<char*>(__ptr);\n+\tsize_t __space = _M_buf_size();\n+\t// Align the pointer within the buffer:\n+\tstd::align(_M_align, _M_nbytes, __ptr, __space);\n+\tconst auto __aligned_ptr = static_cast<char*>(__ptr);\n+\tconst auto __token_size = _M_token_size();\n+\t// Store token immediately after the aligned block:\n+\tchar* const __end = __aligned_ptr + _M_nbytes;\n+\tif (__token_size == 1)\n+\t  _S_write<unsigned char>(__end, __aligned_ptr - __orig_ptr);\n+\telse if (__token_size == sizeof(short))\n+\t  _S_write<unsigned short>(__end, __aligned_ptr - __orig_ptr);\n+\telse if (__token_size == sizeof(int) && sizeof(int) < sizeof(char*))\n+\t  _S_write<unsigned int>(__end, __aligned_ptr - __orig_ptr);\n+\telse // (__token_size == sizeof(char*))\n+\t  // Just store the original pointer:\n+\t  _S_write<char*>(__end, __orig_ptr);\n+\treturn __aligned_ptr;\n+      }\n+\n+      char*\n+      _M_unadjust(char* __ptr) const\n+      {\n+\tconst char* const __end = __ptr + _M_nbytes;\n+\tchar* __orig_ptr;\n+\tconst auto __token_size = _M_token_size();\n+\t// Read the token and restore the original pointer:\n+\tif (__token_size == 1)\n+\t  __orig_ptr = __ptr - _S_read<unsigned char>(__end);\n+\telse if (__token_size == sizeof(short))\n+\t  __orig_ptr = __ptr - _S_read<unsigned short>(__end);\n+\telse if (__token_size == sizeof(int)\n+\t    && sizeof(int) < sizeof(char*))\n+\t  __orig_ptr = __ptr - _S_read<unsigned int>(__end);\n+\telse // (__token_size == sizeof(char*))\n+\t  __orig_ptr = _S_read<char*>(__end);\n+\treturn __orig_ptr;\n+      }\n+\n+    private:\n+      size_t _M_nbytes;\n+      size_t _M_align;\n+\n+      // Number of bytes needed to fit block of given size and alignment.\n+      size_t\n+      _M_buf_size() const { return _M_nbytes + _M_align - 1; }\n+\n+      // Number of additional bytes needed to write the token.\n+      int\n+      _M_token_size() const\n+      {\n+\tif (_M_align <= (1ul << __CHAR_BIT__))\n+\t  return 1;\n+\tif (_M_align <= (1ul << (sizeof(short) * __CHAR_BIT__)))\n+\t  return sizeof(short);\n+\tif (_M_align <= (1ul << (sizeof(int) * __CHAR_BIT__)))\n+\t  return sizeof(int);\n+\treturn sizeof(char*);\n+      }\n+\n+      template<typename _Tp>\n+\tstatic void\n+\t_S_write(void* __to, _Tp __val)\n+\t{ __builtin_memcpy(__to, &__val, sizeof(_Tp)); }\n+\n+      template<typename _Tp>\n+\tstatic _Tp\n+\t_S_read(const void* __from)\n+\t{\n+\t  _Tp __val;\n+\t  __builtin_memcpy(&__val, __from, sizeof(_Tp));\n+\t  return __val;\n+\t}\n+    };\n+  };\n+\n   // 8.7.1 __resource_adaptor_imp\n   template <typename _Alloc>\n-    class __resource_adaptor_imp : public memory_resource\n+    class __resource_adaptor_imp\n+    : public memory_resource, private __resource_adaptor_common\n     {\n       static_assert(is_same<char,\n \t  typename allocator_traits<_Alloc>::value_type>::value,\n@@ -295,50 +390,41 @@ namespace pmr {\n \n     protected:\n       virtual void*\n-      do_allocate(size_t __bytes, size_t __alignment)\n+      do_allocate(size_t __bytes, size_t __alignment) override\n       {\n-\tusing _Aligned_alloc = std::__alloc_rebind<_Alloc, char>;\n-\tsize_t __new_size = _S_aligned_size(__bytes,\n-\t\t\t\t\t    _S_supported(__alignment) ?\n-\t\t\t\t\t    __alignment : _S_max_align);\n-\treturn _Aligned_alloc(_M_alloc).allocate(__new_size);\n+\tif (__alignment == 1)\n+\t  return _M_alloc.allocate(__bytes);\n+\n+\tconst _AlignMgr __mgr(__bytes, __alignment);\n+\t// Assume _M_alloc returns 1-byte aligned memory, so allocate enough\n+\t// space to fit a block of the right size and alignment, plus some\n+\t// extra bytes to store a token for retrieving the original pointer.\n+\treturn __mgr._M_adjust(_M_alloc.allocate(__mgr._M_alloc_size()));\n       }\n \n       virtual void\n-      do_deallocate(void* __p, size_t __bytes, size_t __alignment)\n+      do_deallocate(void* __p, size_t __bytes, size_t __alignment) noexcept\n+      override\n       {\n-\tusing _Aligned_alloc = std::__alloc_rebind<_Alloc, char>;\n-\tsize_t __new_size = _S_aligned_size(__bytes,\n-\t\t\t\t\t    _S_supported(__alignment) ?\n-\t\t\t\t\t    __alignment : _S_max_align);\n-\tusing _Ptr = typename allocator_traits<_Aligned_alloc>::pointer;\n-\t_Aligned_alloc(_M_alloc).deallocate(static_cast<_Ptr>(__p),\n-\t\t\t\t\t    __new_size);\n+\tauto __ptr = static_cast<char*>(__p);\n+\tif (__alignment == 1)\n+\t  _M_alloc.deallocate(__ptr, __bytes);\n+\n+\tconst _AlignMgr __mgr(__bytes, __alignment);\n+\t// Use the stored token to retrieve the original pointer to deallocate.\n+\t_M_alloc.deallocate(__mgr._M_unadjust(__ptr), __mgr._M_alloc_size());\n       }\n \n       virtual bool\n-      do_is_equal(const memory_resource& __other) const noexcept\n+      do_is_equal(const memory_resource& __other) const noexcept override\n       {\n-\tauto __p = dynamic_cast<const __resource_adaptor_imp*>(&__other);\n-\treturn __p ? (_M_alloc == __p->_M_alloc) : false;\n+\tif (auto __p = dynamic_cast<const __resource_adaptor_imp*>(&__other))\n+\t  return _M_alloc == __p->_M_alloc;\n+\treturn false;\n       }\n \n     private:\n-      // Calculate Aligned Size\n-      // Returns a size that is larger than or equal to __size and divisible\n-      // by __alignment, where __alignment is required to be a power of 2.\n-      static size_t\n-      _S_aligned_size(size_t __size, size_t __alignment)\n-      { return ((__size - 1)|(__alignment - 1)) + 1; }\n-\n-      // Determine whether alignment meets one of those preconditions:\n-      // 1. Equal to Zero\n-      // 2. Is power of two\n-      static bool\n-      _S_supported (size_t __x)\n-      { return ((__x != 0) && !(__x & (__x - 1))); }\n-\n-      _Alloc _M_alloc;\n+      _Alloc _M_alloc{};\n     };\n \n   // Global memory resources\n@@ -352,7 +438,7 @@ namespace pmr {\n   inline memory_resource*\n   new_delete_resource() noexcept\n   {\n-    using type = resource_adaptor<std::allocator<char>>;\n+    using type = resource_adaptor<__gnu_cxx::new_allocator<char>>;\n     alignas(type) static unsigned char __buf[sizeof(type)];\n     static type* __r = new(__buf) type;\n     return __r;"}, {"sha": "4e39e773248b6c7f4dc07d7e14db09cb115608ea", "filename": "libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7956c508ddf36901d06bdb3f5a1ae099ee656924/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fresource_adaptor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7956c508ddf36901d06bdb3f5a1ae099ee656924/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fresource_adaptor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fresource_adaptor.cc?ref=7956c508ddf36901d06bdb3f5a1ae099ee656924", "patch": "@@ -19,6 +19,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <experimental/memory_resource>\n+#include <ext/debug_allocator.h>\n #include <testsuite_hooks.h>\n #include <testsuite_allocator.h>\n \n@@ -34,18 +35,22 @@ template<typename T>\n       Allocator(const Allocator<U>&) { }\n   };\n \n-template<typename T>\n+template<std::size_t A>\n   bool aligned(void* p)\n   {\n-    return (reinterpret_cast<std::uintptr_t>(p) % alignof(T)) == 0;\n+    return (reinterpret_cast<std::uintptr_t>(p) % A) == 0;\n   }\n \n+template<typename T>\n+  bool aligned(void* p)\n+  { return aligned<alignof(T)>(p); }\n+\n // resource_adaptor\n void\n test05()\n {\n   using std::max_align_t;\n-  using std::uintptr_t;\n+  using std::size_t;\n   void* p = nullptr;\n \n   Allocator<int> a1(1), a2(2); // minimal interface allocators\n@@ -61,12 +66,18 @@ test05()\n   p = r1.allocate(1, alignof(long));\n   VERIFY( aligned<long>(p) );\n   r1.deallocate(p, 1, alignof(long));\n+  constexpr size_t big_al = alignof(max_align_t) * 8;\n+  p = r1.allocate(1, big_al);\n+  VERIFY( aligned<big_al>(p) );\n+  r1.deallocate(p, 1, big_al);\n \n   __gnu_test::uneq_allocator<double> a3(3), a4(4); // non-equal allocators\n   resource_adaptor<decltype(a3)> r3(a3), r4(a4);\n   VERIFY( r3 == r3 );\n   VERIFY( r4 == r4 );\n   VERIFY( r3 != r4 );\n+  VERIFY( r3 != r1 );\n+  VERIFY( r3 != r2 );\n   p = r3.allocate(1);\n   VERIFY( aligned<max_align_t>(p) );\n   r3.deallocate(p, 1);\n@@ -76,9 +87,40 @@ test05()\n   p = r3.allocate(1, alignof(long));\n   VERIFY( aligned<long>(p) );\n   r3.deallocate(p, 1, alignof(long));\n+  p = r3.allocate(1, big_al);\n+  VERIFY( aligned<big_al>(p) );\n+  r3.deallocate(p, 1, big_al);\n+\n+  __gnu_cxx::debug_allocator<std::allocator<short>> a5;\n+  resource_adaptor<decltype(a5)> r5(a5), r6(a5);\n+  VERIFY( r5 == r5 );\n+  VERIFY( r5 == r6 );\n+  VERIFY( r5 != r1 );\n+  VERIFY( r5 != r3 );\n+  p = r5.allocate(1);\n+  VERIFY( aligned<max_align_t>(p) );\n+  r5.deallocate(p, 1);\n+  p = r5.allocate(1, alignof(short));\n+  VERIFY( aligned<short>(p) );\n+  r5.deallocate(p, 1, alignof(short));\n+  p = r5.allocate(1, alignof(long));\n+  VERIFY( aligned<long>(p) );\n+  r5.deallocate(p, 1, alignof(long));\n+  p = r5.allocate(1, big_al);\n+  VERIFY( aligned<big_al>(p) );\n+  r5.deallocate(p, 1, big_al);\n \n-  // TODO test with an allocator that doesn't use new or malloc, so\n-  // returns pointers that are not suitably aligned for any type.\n+  // Test extended alignments\n+  constexpr size_t al6 = (1ul << 6), al12 = (1ul << 12), al18 = (1ul << 18);\n+  p = r5.allocate(1024, al6);\n+  VERIFY( aligned<al6>(p) );\n+  r5.deallocate(p, 1024, al6);\n+  p = r5.allocate(1024, al12);\n+  VERIFY( aligned<al12>(p) );\n+  r5.deallocate(p, 1024, al12);\n+  p = r5.allocate(1024, al18);\n+  VERIFY( aligned<al18>(p) );\n+  r5.deallocate(p, 1024, al18);\n }\n \n int main()"}]}