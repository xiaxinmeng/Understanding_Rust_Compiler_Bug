{"sha": "d77704579c02c48223abfe8db569941dfe0e4f46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3NzA0NTc5YzAyYzQ4MjIzYWJmZThkYjU2OTk0MWRmZTBlNGY0Ng==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2005-08-13T17:28:43Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2005-08-13T17:28:43Z"}, "message": "re PR tree-optimization/22236 (wrong code for casts and scev)\n\n\tPR tree-optimization/22236\n\t* tree-cfg.c (print_pred_bbs, print_succ_bbs): Correctly print\n\tsuccessors and predecessors.\n\t* tree-chrec.c (chrec_convert): Before converting, check that\n\tsequences don't wrap.\n\t* tree-data-ref.c (compute_estimated_nb_iterations): Moved ...\n\t(analyze_array): Extern.\n\t(find_data_references_in_loop): Remove call to\n\tcompute_estimated_nb_iterations.\n\t* tree-data-ref.h (analyze_array): Declared.\n\t* tree-flow-inline.h (single_ssa_tree_operand, single_ssa_use_operand,\n\tsingle_ssa_def_operand, zero_ssa_operands): Fix documentation.\n\t* tree-flow.h (scev_probably_wraps_p): Declare with an extra parameter.\n\t* tree-scalar-evolution.c (instantiate_parameters_1): Factor entry\n\tcondition.\n\t* tree-ssa-loop-ivcanon.c: Fix documentation.\n\t* tree-ssa-loop-ivopts.c (idx_find_step): Add a fixme note.\n\t* tree-ssa-loop-niter.c (compute_estimated_nb_iterations): ... here.\n\t(infer_loop_bounds_from_undefined): New.\n\t(estimate_numbers_of_iterations_loop): Use\n\tinfer_loop_bounds_from_undefined.\n\t(used_in_pointer_arithmetic_p): New.\n\t(scev_probably_wraps_p): Pass an extra parameter.  Call\n\tused_in_pointer_arithmetic_p.  Check that AT_STMT is not null.\n\t(convert_step): Fix documentation.\n\t* tree-vrp.c (adjust_range_with_scev): Call instantiate_parameters.\n\tUse initial_condition_in_loop_num and evolution_part_in_loop_num\n\tinstead of CHREC_LEFT and CHREC_RIGHT.  Adjust the call to\n\tscev_probably_wraps_p.\n\nFrom-SVN: r103055", "tree": {"sha": "e16e6f08588cfad8cd3b6712bf30a607ac5f488d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e16e6f08588cfad8cd3b6712bf30a607ac5f488d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d77704579c02c48223abfe8db569941dfe0e4f46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77704579c02c48223abfe8db569941dfe0e4f46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d77704579c02c48223abfe8db569941dfe0e4f46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77704579c02c48223abfe8db569941dfe0e4f46/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2df5c1deede2103cdc08e772cb57aede4288043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2df5c1deede2103cdc08e772cb57aede4288043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2df5c1deede2103cdc08e772cb57aede4288043"}], "stats": {"total": 383, "additions": 323, "deletions": 60}, "files": [{"sha": "456967757d46ea4abd268edec5556d33d4d00e51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1,3 +1,35 @@\n+2005-08-13  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\tPR tree-optimization/22236\n+\t* tree-cfg.c (print_pred_bbs, print_succ_bbs): Correctly print\n+\tsuccessors and predecessors.\n+\t* tree-chrec.c (chrec_convert): Before converting, check that\n+\tsequences don't wrap.\n+\t* tree-data-ref.c (compute_estimated_nb_iterations): Moved ...\n+\t(analyze_array): Extern.\n+\t(find_data_references_in_loop): Remove call to\n+\tcompute_estimated_nb_iterations.\n+\t* tree-data-ref.h (analyze_array): Declared.\n+\t* tree-flow-inline.h (single_ssa_tree_operand, single_ssa_use_operand,\n+\tsingle_ssa_def_operand, zero_ssa_operands): Fix documentation.\n+\t* tree-flow.h (scev_probably_wraps_p): Declare with an extra parameter.\n+\t* tree-scalar-evolution.c (instantiate_parameters_1): Factor entry \n+\tcondition.\n+\t* tree-ssa-loop-ivcanon.c: Fix documentation.\n+\t* tree-ssa-loop-ivopts.c (idx_find_step): Add a fixme note.\n+\t* tree-ssa-loop-niter.c (compute_estimated_nb_iterations): ... here.\n+\t(infer_loop_bounds_from_undefined): New.\n+\t(estimate_numbers_of_iterations_loop): Use\n+\tinfer_loop_bounds_from_undefined.\n+\t(used_in_pointer_arithmetic_p): New.\n+\t(scev_probably_wraps_p): Pass an extra parameter.  Call\n+\tused_in_pointer_arithmetic_p.  Check that AT_STMT is not null.\n+\t(convert_step): Fix documentation.\n+\t* tree-vrp.c (adjust_range_with_scev): Call instantiate_parameters.\n+\tUse initial_condition_in_loop_num and evolution_part_in_loop_num\n+\tinstead of CHREC_LEFT and CHREC_RIGHT.  Adjust the call to\n+\tscev_probably_wraps_p.\n+\n 2005-08-13  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (s390_split_branches): Revert 2005-08-12 change."}, {"sha": "1986c2f0cfe8c4f0ccf21b34446a411628851e19", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22236.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22236.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22236.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22236.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O1 -fno-tree-vrp -fwrapv\" } */\n+\n+/* PR tree-optimization/22236\n+\n+    Avoid conversion of (signed char) {(uchar)1, +, (uchar)1}_x when\n+    it is not possible to prove that the scev does not wrap.  \n+\n+    In this PR, a sequence 1, 2, ..., 255 has to be converted to\n+    signed char, but this would wrap: 1, 2, ..., 127, -128, ...  The\n+    result should not be a linear scev {(schar)1, +, (schar)1}_x.\n+    The conversion should be kept: (schar) {(uchar)1, +, (uchar)1}_x.\n+ */\n+\n+void abort(void);\n+\n+static inline void\n+foo (signed char a)\n+{\n+  int b = a - 0x7F;\n+  if (b > 1)\n+    abort();\n+}\n+\n+int main()\n+{\n+  unsigned char b;\n+  for(b = 0; b < 0xFF; b++)\n+    foo (b);\n+\n+  return 0;\n+}\n+"}, {"sha": "ad399fbce64cb86bd07cc9534a5509448d049a6c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -4502,7 +4502,7 @@ static void print_pred_bbs (FILE *, basic_block bb);\n static void print_succ_bbs (FILE *, basic_block bb);\n \n \n-/* Print the predecessors indexes of edge E on FILE.  */\n+/* Print on FILE the indexes for the predecessors of basic_block BB.  */\n \n static void\n print_pred_bbs (FILE *file, basic_block bb)\n@@ -4511,11 +4511,11 @@ print_pred_bbs (FILE *file, basic_block bb)\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n-    fprintf (file, \"bb_%d\", e->src->index);\n+    fprintf (file, \"bb_%d \", e->src->index);\n }\n \n \n-/* Print the successors indexes of edge E on FILE.  */\n+/* Print on FILE the indexes for the successors of basic_block BB.  */\n \n static void\n print_succ_bbs (FILE *file, basic_block bb)\n@@ -4524,7 +4524,7 @@ print_succ_bbs (FILE *file, basic_block bb)\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    fprintf (file, \"bb_%d\", e->src->index);\n+    fprintf (file, \"bb_%d \", e->dest->index);\n }\n \n "}, {"sha": "1a229225f80a0be40d91d64144a566e37eeec33b", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1110,9 +1110,24 @@ chrec_convert (tree type, tree chrec, tree at_stmt)\n \n   if (evolution_function_is_affine_p (chrec))\n     {\n-      tree step = convert_step (current_loops->parray[CHREC_VARIABLE (chrec)],\n- \t\t\t\ttype, CHREC_LEFT (chrec), CHREC_RIGHT (chrec),\n- \t\t\t\tat_stmt);\n+      tree step;\n+      bool dummy;\n+\n+      /* Avoid conversion of (signed char) {(uchar)1, +, (uchar)1}_x\n+\t when it is not possible to prove that the scev does not wrap.\n+\t See PR22236, where a sequence 1, 2, ..., 255 has to be\n+\t converted to signed char, but this would wrap: \n+\t 1, 2, ..., 127, -128, ...  The result should not be\n+\t {(schar)1, +, (schar)1}_x, but instead, we should keep the\n+\t conversion: (schar) {(uchar)1, +, (uchar)1}_x.  */\n+      if (scev_probably_wraps_p (type, CHREC_LEFT (chrec), CHREC_RIGHT (chrec),\n+\t\t\t\t at_stmt,\n+\t\t\t\t current_loops->parray[CHREC_VARIABLE (chrec)],\n+\t\t\t\t &dummy, &dummy))\n+\treturn fold_convert (type, chrec);\n+\n+      step = convert_step (current_loops->parray[CHREC_VARIABLE (chrec)], type,\n+\t\t\t   CHREC_LEFT (chrec), CHREC_RIGHT (chrec), at_stmt);\n       if (!step)\n  \treturn fold_convert (type, chrec);\n "}, {"sha": "7fc64242bf358749d4bb2d6589254aae8dd7b6a3", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -731,23 +731,6 @@ dump_ddrs (FILE *file, varray_type ddrs)\n \n \f\n \n-/* Initialize LOOP->ESTIMATED_NB_ITERATIONS with the lowest safe\n-   approximation of the number of iterations for LOOP.  */\n-\n-static void\n-compute_estimated_nb_iterations (struct loop *loop)\n-{\n-  struct nb_iter_bound *bound;\n-  \n-  for (bound = loop->bounds; bound; bound = bound->next)\n-    if (TREE_CODE (bound->bound) == INTEGER_CST\n-\t/* Update only when there is no previous estimation.  */\n-\t&& (chrec_contains_undetermined (loop->estimated_nb_iterations)\n-\t    /* Or when the current estimation is smaller.  */\n-\t    || tree_int_cst_lt (bound->bound, loop->estimated_nb_iterations)))\n-      loop->estimated_nb_iterations = bound->bound;\n-}\n-\n /* Estimate the number of iterations from the size of the data and the\n    access functions.  */\n \n@@ -830,7 +813,7 @@ analyze_array_indexes (struct loop *loop,\n    set to true when REF is in the right hand side of an\n    assignment.  */\n \n-static struct data_reference *\n+struct data_reference *\n analyze_array (tree stmt, tree ref, bool is_read)\n {\n   struct data_reference *res;\n@@ -3644,9 +3627,6 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n \t    loop->parallel_p = false;\n \t}\n-\n-      if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n-\tcompute_estimated_nb_iterations (loop);\n     }\n \n   free (bbs);"}, {"sha": "f845fcd4dcf97cf9ae4240e3c4205018648f686c", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -264,6 +264,7 @@ extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (varray_type);\n extern void free_data_refs (varray_type);\n extern void compute_subscript_distance (struct data_dependence_relation *);\n+extern struct data_reference *analyze_array (tree, tree, bool);\n \n \n \f"}, {"sha": "b0f5e8885518e097f5e9cd08dd2e7f77fcc61d50", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1191,7 +1191,7 @@ op_iter_init_must_and_may_def (ssa_op_iter *ptr, tree stmt,\n \n \n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n-   return NULL.  PTR is the iterator to use.  */\n+   return NULL.  */\n static inline tree\n single_ssa_tree_operand (tree stmt, int flags)\n {\n@@ -1209,7 +1209,7 @@ single_ssa_tree_operand (tree stmt, int flags)\n \n \n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n-   return NULL.  PTR is the iterator to use.  */\n+   return NULL.  */\n static inline use_operand_p\n single_ssa_use_operand (tree stmt, int flags)\n {\n@@ -1228,7 +1228,7 @@ single_ssa_use_operand (tree stmt, int flags)\n \n \n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n-   return NULL.  PTR is the iterator to use.  */\n+   return NULL.  */\n static inline def_operand_p\n single_ssa_def_operand (tree stmt, int flags)\n {\n@@ -1246,7 +1246,7 @@ single_ssa_def_operand (tree stmt, int flags)\n \n \n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n-   return NULL.  PTR is the iterator to use.  */\n+   return NULL.  */\n static inline bool\n zero_ssa_operands (tree stmt, int flags)\n {"}, {"sha": "fa5c1d692df115cb36322bfe80e4d811b8996f61", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -728,7 +728,8 @@ tree find_loop_niter (struct loop *, edge *);\n tree loop_niter_by_eval (struct loop *, edge);\n tree find_loop_niter_by_eval (struct loop *, edge *);\n void estimate_numbers_of_iterations (struct loops *);\n-bool scev_probably_wraps_p (tree, tree, tree, tree, struct loop *, bool *);\n+bool scev_probably_wraps_p (tree, tree, tree, tree, struct loop *, bool *,\n+\t\t\t    bool *);\n tree convert_step (struct loop *, tree, tree, tree, tree);\n void free_numbers_of_iterations_estimates (struct loops *);\n void rewrite_into_loop_closed_ssa (bitmap, unsigned);"}, {"sha": "db798c025e2b094096ef4a29d83ebaaafa1ed00d", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1939,11 +1939,8 @@ instantiate_parameters_1 (struct loop *loop, tree chrec,\n   basic_block def_bb;\n   struct loop *def_loop;\n  \n-  if (chrec == NULL_TREE\n-      || automatically_generated_chrec_p (chrec))\n-    return chrec;\n- \n-  if (is_gimple_min_invariant (chrec))\n+  if (automatically_generated_chrec_p (chrec)\n+      || is_gimple_min_invariant (chrec))\n     return chrec;\n \n   switch (TREE_CODE (chrec))"}, {"sha": "1788c33e037ba73dc871f5e6b4024918e5420074", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -267,7 +267,7 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n }\n \n /* Adds a canonical induction variable to LOOP if suitable.  LOOPS is the loops\n-   tree.  CREATE_IV is true if we may create a new iv.  UL determines what\n+   tree.  CREATE_IV is true if we may create a new iv.  UL determines \n    which loops we are allowed to completely unroll.  If TRY_EVAL is true, we try\n    to determine the number of iterations of a loop by direct evaluation. \n    Returns true if cfg is changed.  */"}, {"sha": "d0a186a166a3301d795caa1e18630e19424969af", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1443,6 +1443,8 @@ idx_find_step (tree base, tree *idx, void *data)\n     /* The step for pointer arithmetics already is 1 byte.  */\n     step = build_int_cst (sizetype, 1);\n \n+  /* FIXME: convert_step should not be used outside chrec_convert: fix\n+     this by calling chrec_convert.  */\n   iv_step = convert_step (dta->ivopts_data->current_loop,\n \t\t\t  sizetype, iv->base, iv->step, dta->stmt);\n "}, {"sha": "8399faf30e2335240a8e551f93bd5e9ab831ab7c", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 214, "deletions": 14, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1381,6 +1381,128 @@ record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt)\n   loop->bounds = elt;\n }\n \n+/* Initialize LOOP->ESTIMATED_NB_ITERATIONS with the lowest safe\n+   approximation of the number of iterations for LOOP.  */\n+\n+static void\n+compute_estimated_nb_iterations (struct loop *loop)\n+{\n+  struct nb_iter_bound *bound;\n+  \n+  for (bound = loop->bounds; bound; bound = bound->next)\n+    if (TREE_CODE (bound->bound) == INTEGER_CST\n+\t/* Update only when there is no previous estimation.  */\n+\t&& (chrec_contains_undetermined (loop->estimated_nb_iterations)\n+\t    /* Or when the current estimation is smaller.  */\n+\t    || tree_int_cst_lt (bound->bound, loop->estimated_nb_iterations)))\n+      loop->estimated_nb_iterations = bound->bound;\n+}\n+\n+/* The following analyzers are extracting informations on the bounds\n+   of LOOP from the following undefined behaviors:\n+\n+   - data references should not access elements over the statically\n+     allocated size,\n+\n+   - signed variables should not overflow when flag_wrapv is not set.\n+*/\n+\n+static void\n+infer_loop_bounds_from_undefined (struct loop *loop)\n+{\n+  unsigned i;\n+  basic_block bb, *bbs;\n+  block_stmt_iterator bsi;\n+  \n+  bbs = get_loop_body (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = bbs[i];\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+        {\n+\t  tree stmt = bsi_stmt (bsi);\n+\n+\t  switch (TREE_CODE (stmt))\n+\t    {\n+\t    case MODIFY_EXPR:\n+\t      {\n+\t\ttree op0 = TREE_OPERAND (stmt, 0);\n+\t\ttree op1 = TREE_OPERAND (stmt, 1);\n+\n+\t\t/* For each array access, analyze its access function\n+\t\t   and record a bound on the loop iteration domain.  */\n+\t\tif (TREE_CODE (op1) == ARRAY_REF)\n+\t\t  analyze_array (stmt, op1, true);\n+\n+\t\tif (TREE_CODE (op0) == ARRAY_REF)\n+\t\t  analyze_array (stmt, op0, false);\n+\n+\t\t/* For each signed type variable in LOOP, analyze its\n+\t\t   scalar evolution and record a bound of the loop\n+\t\t   based on the type's ranges.  */\n+\t\telse if (!flag_wrapv && TREE_CODE (op0) == SSA_NAME)\n+\t\t  {\n+\t\t    tree init, step, diff, estimation;\n+\t\t    tree scev = instantiate_parameters \n+\t\t      (loop, analyze_scalar_evolution (loop, op0));\n+\t\t    tree type = chrec_type (scev);\n+\t\t    tree utype;\n+\n+\t\t    if (chrec_contains_undetermined (scev)\n+\t\t\t|| TYPE_UNSIGNED (type))\n+\t\t      break;\n+\n+\t\t    init = initial_condition_in_loop_num (scev, loop->num);\n+\t\t    step = evolution_part_in_loop_num (scev, loop->num);\n+\n+\t\t    if (init == NULL_TREE\n+\t\t\t|| step == NULL_TREE\n+\t\t\t|| TREE_CODE (init) != INTEGER_CST\n+\t\t\t|| TREE_CODE (step) != INTEGER_CST)\n+\t\t      break;\n+\n+\t\t    utype = unsigned_type_for (type);\n+\t\t    if (tree_int_cst_lt (step, integer_zero_node))\n+\t\t      diff = fold (build2 (MINUS_EXPR, utype, init,\n+\t\t\t\t\t   TYPE_MIN_VALUE (type)));\n+\t\t    else\n+\t\t      diff = fold (build2 (MINUS_EXPR, utype,\n+\t\t\t\t\t   TYPE_MAX_VALUE (type), init));\n+\n+\t\t    estimation = fold (build2 (CEIL_DIV_EXPR, utype, diff,\n+\t\t\t\t\t       step));\n+\t\t    record_estimate (loop, estimation, boolean_true_node, stmt);\n+\t\t  }\n+\n+\t\tbreak;\n+\t      }\n+\n+\t    case CALL_EXPR:\n+\t      {\n+\t\ttree args;\n+\n+\t\tfor (args = TREE_OPERAND (stmt, 1); args;\n+\t\t     args = TREE_CHAIN (args))\n+\t\t  if (TREE_CODE (TREE_VALUE (args)) == ARRAY_REF)\n+\t\t    analyze_array (stmt, TREE_VALUE (args), true);\n+\n+\t\tbreak;\n+\t      }\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n+\tcompute_estimated_nb_iterations (loop);\n+    }\n+\n+  free (bbs);\n+}\n+\n /* Records estimates on numbers of iterations of LOOP.  */\n \n static void\n@@ -1419,14 +1541,8 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n     }\n   free (exits);\n   \n-  /* Analyzes the bounds of arrays accessed in the loop.  */\n   if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n-    {\n-      varray_type datarefs;\n-      VARRAY_GENERIC_PTR_INIT (datarefs, 3, \"datarefs\");\n-      find_data_references_in_loop (loop, &datarefs);\n-      free_data_refs (datarefs);\n-    }\n+    infer_loop_bounds_from_undefined (loop);\n }\n \n /* Records estimates on numbers of iterations of LOOPS.  */\n@@ -1645,26 +1761,104 @@ convert_step_widening (struct loop *loop, tree new_type, tree base, tree step,\n   return NULL_TREE;\n }\n \n+/* Returns true when VAR is used in pointer arithmetics.  DEPTH is\n+   used for limiting the search.  */\n+\n+static bool\n+used_in_pointer_arithmetic_p (tree var, int depth)\n+{\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+\n+  if (depth == 0\n+      || TREE_CODE (var) != SSA_NAME\n+      || !has_single_use (var))\n+    return false;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+    {\n+      tree stmt = USE_STMT (use_p);\n+\n+      if (stmt && TREE_CODE (stmt) == MODIFY_EXPR)\n+\t{\n+\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\n+\t  if (TREE_CODE (rhs) == NOP_EXPR\n+\t      || TREE_CODE (rhs) == CONVERT_EXPR)\n+\t    {\n+\t      if (POINTER_TYPE_P (TREE_TYPE (rhs)))\n+\t\treturn true;\n+\t      return false;\n+\t    }\n+\t  else\n+\t    return used_in_pointer_arithmetic_p (TREE_OPERAND (stmt, 0),\n+\t\t\t\t\t\t depth - 1);\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Return false only when the induction variable BASE + STEP * I is\n    known to not overflow: i.e. when the number of iterations is small\n    enough with respect to the step and initial condition in order to\n    keep the evolution confined in TYPEs bounds.  Return true when the\n    iv is known to overflow or when the property is not computable.\n \n    Initialize INIT_IS_MAX to true when the evolution goes from\n-   INIT_IS_MAX to LOWER_BOUND_IN_TYPE, false in the contrary case, not\n-   defined when the function returns true.  */\n+   INIT_IS_MAX to LOWER_BOUND_IN_TYPE, false in the contrary case.\n+   When this property cannot be determined, UNKNOWN_MAX is set to\n+   true.  */\n \n bool\n scev_probably_wraps_p (tree type, tree base, tree step, \n \t\t       tree at_stmt, struct loop *loop,\n-\t\t       bool *init_is_max)\n+\t\t       bool *init_is_max, bool *unknown_max)\n {\n   struct nb_iter_bound *bound;\n   tree delta, step_abs;\n   tree unsigned_type, valid_niter;\n-  tree base_plus_step = fold_build2 (PLUS_EXPR, type, base, step);\n+  tree base_plus_step;\n+\n+  /* FIXME: The following code will not be used anymore once\n+     http://gcc.gnu.org/ml/gcc-patches/2005-06/msg02025.html is\n+     committed.\n+\n+     If AT_STMT is a cast to unsigned that is later used for\n+     referencing a memory location, it is followed by a pointer\n+     conversion just after.  Because pointers do not wrap, the\n+     sequences that reference the memory do not wrap either.  In the\n+     following example, sequences corresponding to D_13 and to D_14\n+     can be proved to not wrap because they are used for computing a\n+     memory access:\n+\t \n+       D.1621_13 = (long unsigned intD.4) D.1620_12;\n+       D.1622_14 = D.1621_13 * 8;\n+       D.1623_15 = (doubleD.29 *) D.1622_14;\n+  */\n+  if (at_stmt && TREE_CODE (at_stmt) == MODIFY_EXPR)\n+    {\n+      tree op0 = TREE_OPERAND (at_stmt, 0);\n+      tree op1 = TREE_OPERAND (at_stmt, 1);\n+      tree type_op1 = TREE_TYPE (op1);\n+\n+      if ((TYPE_UNSIGNED (type_op1)\n+\t   && used_in_pointer_arithmetic_p (op0, 2))\n+\t  || POINTER_TYPE_P (type_op1))\n+\t{\n+\t  *unknown_max = true;\n+\t  return false;\n+\t}\n+    }\n \n+  if (TREE_CODE (base) == REAL_CST\n+      || TREE_CODE (step) == REAL_CST)\n+    {\n+      *unknown_max = true;\n+      return true;\n+    }\n+\n+  *unknown_max = false;\n+  base_plus_step = fold_build2 (PLUS_EXPR, type, base, step);\n   switch (compare_trees (base_plus_step, base))\n     {\n     case -1:\n@@ -1691,6 +1885,7 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n \t don't know as in the default case.  */\n \n     default:\n+      *unknown_max = true;\n       return true;\n     }\n \n@@ -1709,7 +1904,7 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n      i_2 to wrap around, but not i.0_6, because it is of a signed\n      type.  This causes VRP to erroneously fold the predicate above\n      because it thinks that i.0_6 cannot be negative.  */\n-  if (TREE_CODE (at_stmt) == MODIFY_EXPR)\n+  if (at_stmt && TREE_CODE (at_stmt) == MODIFY_EXPR)\n     {\n       tree rhs = TREE_OPERAND (at_stmt, 1);\n       tree outer_t = TREE_TYPE (rhs);\n@@ -1725,7 +1920,10 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n \t  if (TYPE_UNSIGNED (inner_t)\n \t      && (TYPE_SIZE (inner_t) <= TYPE_SIZE (outer_t)\n \t\t  || TYPE_PRECISION (inner_t) <= TYPE_PRECISION (outer_t)))\n-\t    return true;\n+\t    {\n+\t      *unknown_max = true;\n+\t      return true;\n+\t    }\n \t}\n     }\n \n@@ -1746,11 +1944,13 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n \n   /* At this point we still don't have a proof that the iv does not\n      overflow: give up.  */\n+  *unknown_max = true;\n   return true;\n }\n \n /* Return the conversion to NEW_TYPE of the STEP of an induction\n-   variable BASE + STEP * I at AT_STMT.  */\n+   variable BASE + STEP * I at AT_STMT.  When it fails, return\n+   NULL_TREE.  */\n \n tree\n convert_step (struct loop *loop, tree new_type, tree base, tree step,"}, {"sha": "8f18d89f9a460a5b673e6ac20023474929027668", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1173,7 +1173,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n       if (!dr || !DR_REF (dr))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-              fprintf (vect_dump, \"not vectorized: unhandled data-ref \");\n+\t    fprintf (vect_dump, \"not vectorized: unhandled data-ref \");\n           return false;\n         }\n  "}, {"sha": "0f7f67104339375d180718bb47594e6230ab5348", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77704579c02c48223abfe8db569941dfe0e4f46/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d77704579c02c48223abfe8db569941dfe0e4f46", "patch": "@@ -1534,29 +1534,31 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t\t\ttree var)\n {\n   tree init, step, chrec;\n-  bool init_is_max;\n+  bool init_is_max, unknown_max;\n \n   /* TODO.  Don't adjust anti-ranges.  An anti-range may provide\n      better opportunities than a regular range, but I'm not sure.  */\n   if (vr->type == VR_ANTI_RANGE)\n     return;\n \n-  chrec = analyze_scalar_evolution (loop, var);\n+  chrec = instantiate_parameters (loop, analyze_scalar_evolution (loop, var));\n   if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n     return;\n \n-  init = CHREC_LEFT (chrec);\n-  step = CHREC_RIGHT (chrec);\n+  init = initial_condition_in_loop_num (chrec, loop->num);\n+  step = evolution_part_in_loop_num (chrec, loop->num);\n \n   /* If STEP is symbolic, we can't know whether INIT will be the\n      minimum or maximum value in the range.  */\n-  if (!is_gimple_min_invariant (step))\n+  if (step == NULL_TREE\n+      || !is_gimple_min_invariant (step))\n     return;\n \n   /* Do not adjust ranges when chrec may wrap.  */\n   if (scev_probably_wraps_p (chrec_type (chrec), init, step, stmt,\n \t\t\t     cfg_loops->parray[CHREC_VARIABLE (chrec)],\n-\t\t\t     &init_is_max))\n+\t\t\t     &init_is_max, &unknown_max)\n+      || unknown_max)\n     return;\n \n   if (!POINTER_TYPE_P (TREE_TYPE (init))"}]}