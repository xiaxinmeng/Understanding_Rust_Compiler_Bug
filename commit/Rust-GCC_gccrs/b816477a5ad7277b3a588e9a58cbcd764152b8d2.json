{"sha": "b816477a5ad7277b3a588e9a58cbcd764152b8d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxNjQ3N2E1YWQ3Mjc3YjNhNTg4ZTlhNThjYmNkNzY0MTUyYjhkMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-08-31T00:35:01Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-08-31T00:35:01Z"}, "message": "Remove arbitrary limits from rich_location\n\nThis patch eliminates the hard-coded limits within rich_location\n(up to 3 ranges, up to 2 fixits).  The common case is still\nhandled by embedding the values inside rich_location - it only\nuses dynamic allocation if these limits are exceeded, so\ncreation of rich_location instances on the stack should still\nbe fast.  This is implemented via a new container class,\nsemi_embedded_vec <T, N>.\n\ngcc/ChangeLog:\n\t* diagnostic-show-locus.c (colorizer::begin_state): Support more\n\tthan 3 ranges per diagnostic by alternating between color 1 and\n\tcolor 2.\n\t(layout::layout): Replace use of rich_location::MAX_RANGES\n\twith richloc->get_num_locations ().\n\t(layout::calculate_line_spans): Replace use of\n\trich_location::MAX_RANGES with m_layout_ranges.length ().\n\t(layout::print_annotation_line): Handle arbitrary numbers of\n\tranges in caret-printing by defaulting to '^'.\n\t(selftest::test_one_liner_many_fixits): New function.\n\t(test_diagnostic_show_locus_one_liner): Call it.\n\t* diagnostic.c (diagnostic_initialize): Update for renaming\n\tof rich_location::MAX_RANGES to\n\trich_location::STATICALLY_ALLOCATED_RANGES.\n\t* diagnostic.h (struct diagnostic_context): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/diagnostic-test-show-locus-bw.c\n\t(test_many_nested_locations): New function.\n\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n\t(test_show_locus): Handle \"test_many_nested_locations\".\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (class semi_embedded_vec): New class.\n\t(semi_embedded_vec<T, NUM_EMBEDDED>::semi_embedded_vec): New ctor.\n\t(semi_embedded_vec<T, NUM_EMBEDDED>::~semi_embedded_vec): New\n\tdtor.\n\t(semi_embedded_vec<T, NUM_EMBEDDED>::operator[]): New methods.\n\t(semi_embedded_vec<T, NUM_EMBEDDED>::push): New method.\n\t(semi_embedded_vec<T, NUM_EMBEDDED>::truncate): New method.\n\t(rich_location::get_num_locations): Reimplement in terms of\n\tm_ranges.\n\t(rich_location::get_range): Make non-inline.\n\t(rich_location::get_num_fixit_hints): Reimplement in terms of\n\tm_fixit_hints.\n\t(rich_location::add_fixit): New function.\n\t(rich_location::MAX_RANGES): Rename to...\n\t(rich_location::STATICALLY_ALLOCATED_RANGES): ...this.\n\t(rich_location::MAX_FIXIT_HINTS): Rename to...\n\t(rich_location::STATICALLY_ALLOCATED_RANGES): ...this, and make\n\tprivate.\n\t(rich_location::m_num_ranges): Eliminate in favor of...\n\t(rich_location::m_ranges): ...this, converting from a fixed-size\n\tarray to a semi_embedded_vec.\n\t(rich_location::m_num_fixit_hints): Eliminate in favor of...\n\t(rich_location::m_fixit_hints): ...this, converting from a\n\tfixed-size array to a semi_embedded_vec.\n\t* line-map.c (rich_location::rich_location): Update for above\n\tchanges.\n\t(rich_location::~rich_location): Likewise.\n\t(rich_location::get_loc): Likewise.\n\t(rich_location::get_range): New methods.\n\t(rich_location::add_range): Update for above changes.\n\t(rich_location::set_range): Likewise.\n\t(rich_location::add_fixit_insert): Likewise.\n\t(rich_location::add_fixit_replace): Likewise.\n\t(rich_location::get_last_fixit_hint): Likewise.\n\t(rich_location::reject_impossible_fixit): Likewise.\n\t(rich_location::add_fixit): New method.\n\nFrom-SVN: r239879", "tree": {"sha": "4e3390b81b9f7a7b900db1de9278ee74805abf77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e3390b81b9f7a7b900db1de9278ee74805abf77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b816477a5ad7277b3a588e9a58cbcd764152b8d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b816477a5ad7277b3a588e9a58cbcd764152b8d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b816477a5ad7277b3a588e9a58cbcd764152b8d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b816477a5ad7277b3a588e9a58cbcd764152b8d2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb8e9c5e8ee12831db4a020f7ccb63ac7bbf9dee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb8e9c5e8ee12831db4a020f7ccb63ac7bbf9dee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb8e9c5e8ee12831db4a020f7ccb63ac7bbf9dee"}], "stats": {"total": 466, "additions": 405, "deletions": 61}, "files": [{"sha": "54f2f7a33ba469be1dfd1c01dc10421a852553fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -1,3 +1,21 @@\n+2016-08-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-show-locus.c (colorizer::begin_state): Support more\n+\tthan 3 ranges per diagnostic by alternating between color 1 and\n+\tcolor 2.\n+\t(layout::layout): Replace use of rich_location::MAX_RANGES\n+\twith richloc->get_num_locations ().\n+\t(layout::calculate_line_spans): Replace use of\n+\trich_location::MAX_RANGES with m_layout_ranges.length ().\n+\t(layout::print_annotation_line): Handle arbitrary numbers of\n+\tranges in caret-printing by defaulting to '^'.\n+\t(selftest::test_one_liner_many_fixits): New function.\n+\t(test_diagnostic_show_locus_one_liner): Call it.\n+\t* diagnostic.c (diagnostic_initialize): Update for renaming\n+\tof rich_location::MAX_RANGES to\n+\trich_location::STATICALLY_ALLOCATED_RANGES.\n+\t* diagnostic.h (struct diagnostic_context): Likewise.\n+\n 2016-08-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* selftest.c (selftest::named_temp_file::named_temp_file): New"}, {"sha": "a22a660543a7bceb8d7408e9fcab88e044cd9005", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -317,8 +317,12 @@ colorizer::begin_state (int state)\n       break;\n \n     default:\n-      /* We don't expect more than 3 ranges per diagnostic.  */\n-      gcc_unreachable ();\n+      /* For ranges beyond 2, alternate between color 1 and color 2.  */\n+      {\n+\tgcc_assert (state > 2);\n+\tpp_string (m_context->printer,\n+\t\t   state % 2 ? m_range1 : m_range2);\n+      }\n       break;\n     }\n }\n@@ -720,8 +724,8 @@ layout::layout (diagnostic_context * context,\n   m_exploc (richloc->get_expanded_location (0)),\n   m_colorizer (context, diagnostic_kind),\n   m_colorize_source_p (context->colorize_source_p),\n-  m_layout_ranges (rich_location::MAX_RANGES),\n-  m_line_spans (1 + rich_location::MAX_RANGES),\n+  m_layout_ranges (richloc->get_num_locations ()),\n+  m_line_spans (1 + richloc->get_num_locations ()),\n   m_x_offset (0)\n {\n   source_location primary_loc = richloc->get_range (0)->m_loc;\n@@ -904,7 +908,7 @@ layout::calculate_line_spans ()\n \n   /* Populate tmp_spans with individual spans, for each of\n      m_exploc, and for m_layout_ranges.  */\n-  auto_vec<line_span> tmp_spans (1 + rich_location::MAX_RANGES);\n+  auto_vec<line_span> tmp_spans (1 + m_layout_ranges.length ());\n   tmp_spans.safe_push (line_span (m_exploc.line, m_exploc.line));\n   for (unsigned int i = 0; i < m_layout_ranges.length (); i++)\n     {\n@@ -1050,8 +1054,15 @@ layout::print_annotation_line (int row, const line_bounds lbounds)\n \t  /* Within a range.  Draw either the caret or an underline.  */\n \t  m_colorizer.set_range (state.range_idx);\n \t  if (state.draw_caret_p)\n-\t    /* Draw the caret.  */\n-\t    pp_character (m_pp, m_context->caret_chars[state.range_idx]);\n+\t    {\n+\t      /* Draw the caret.  */\n+\t      char caret_char;\n+\t      if (state.range_idx < rich_location::STATICALLY_ALLOCATED_RANGES)\n+\t\tcaret_char = m_context->caret_chars[state.range_idx];\n+\t      else\n+\t\tcaret_char = '^';\n+\t      pp_character (m_pp, caret_char);\n+\t    }\n \t  else\n \t    pp_character (m_pp, '~');\n \t}\n@@ -1654,6 +1665,44 @@ test_one_liner_fixit_validation_adhoc_locations ()\n   }\n }\n \n+/* Ensure that we can add an arbitrary number of fix-it hints to a\n+   rich_location.  */\n+\n+static void\n+test_one_liner_many_fixits ()\n+{\n+  test_diagnostic_context dc;\n+  location_t equals = linemap_position_for_column (line_table, 5);\n+  rich_location richloc (line_table, equals);\n+  for (int i = 0; i < 19; i++)\n+    richloc.add_fixit_insert (\"a\");\n+  ASSERT_EQ (19, richloc.get_num_fixit_hints ());\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" foo = bar.field;\\n\"\n+\t\t\"     ^\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\"\n+\t\t\"     a\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n /* Run the various one-liner tests.  */\n \n static void\n@@ -1687,6 +1736,7 @@ test_diagnostic_show_locus_one_liner (const line_table_case &case_)\n   test_one_liner_fixit_replace_non_equal_range ();\n   test_one_liner_fixit_replace_equal_secondary_range ();\n   test_one_liner_fixit_validation_adhoc_locations ();\n+  test_one_liner_many_fixits ();\n }\n \n /* Verify that fix-it hints are appropriately consolidated."}, {"sha": "47b4c79ebcc2a34eb4600f700ab46cb55a65b3c4", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -147,7 +147,7 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n     context->classify_diagnostic[i] = DK_UNSPECIFIED;\n   context->show_caret = false;\n   diagnostic_set_caret_max_width (context, pp_line_cutoff (context->printer));\n-  for (i = 0; i < rich_location::MAX_RANGES; i++)\n+  for (i = 0; i < rich_location::STATICALLY_ALLOCATED_RANGES; i++)\n     context->caret_chars[i] = '^';\n   context->show_option_requested = false;\n   context->abort_on_error = false;"}, {"sha": "0727644d96b7da5c79a6e698c99ad4dc3e63dc67", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -109,7 +109,7 @@ struct diagnostic_context\n   int caret_max_width;\n \n   /* Character used for caret diagnostics.  */\n-  char caret_chars[rich_location::MAX_RANGES];\n+  char caret_chars[rich_location::STATICALLY_ALLOCATED_RANGES];\n \n   /* True if we should print the command line option which controls\n      each diagnostic, if known.  */"}, {"sha": "cf97b393f12587de8c8b88511f05c05765f62dcd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -1,3 +1,10 @@\n+2016-08-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/diagnostic-test-show-locus-bw.c\n+\t(test_many_nested_locations): New function.\n+\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n+\t(test_show_locus): Handle \"test_many_nested_locations\".\n+\n 2016-08-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* g++.dg/template/double-greater-than-fixit.C: New test case."}, {"sha": "e8112bfa3a5522610ce5707849acd6e3b6009b98", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-locus-bw.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -205,3 +205,47 @@ int test_percent_q_plus_d (void)\n    { dg-end-multiline-output \"\" } */\n   return local;\n }\n+\n+/* Test of many nested locations and fixits.  */\n+\n+void test_many_nested_locations (void)\n+{\n+  /* { dg-warning \"test of 70 locations\" }\n+    Lorem ipsum dolor sit amet, consectetur adipiscing elit,\n+    sed do eiusmod tempor incididunt ut labore et dolore magna\n+    aliqua. Ut enim ad minim veniam, quis nostrud exercitation\n+    ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis\n+    aute irure dolor in reprehenderit in voluptate velit esse cillum\n+    dolore eu fugiat nulla pariatur. Excepteur sint occaecat\n+    cupidatat non proident, sunt in culpa qui officia deserunt\n+    mollit anim id est laborum.\n+  */\n+/* { dg-begin-multiline-output \"\" }\n+   /*\n+   ^\n+     Lorem ipsum dolor sit amet, consectetur adipiscing elit,\n+     ^~~~~ ^~~~~ ^~~~~ ^~~ ^~~~  ^~~~~~~~~~~ ^~~~~~~~~~ ^~~~\n+     LOREM IPSUM DOLOR SIT AMET  CONSECTETUR ADIPISCING ELIT\n+     sed do eiusmod tempor incididunt ut labore et dolore magna\n+     ^~~ ^~ ^~~~~~~ ^~~~~~ ^~~~~~~~~~ ^~ ^~~~~~ ^~ ^~~~~~ ^~~~~\n+     SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA\n+     aliqua. Ut enim ad minim veniam, quis nostrud exercitation\n+     ^~~~~~  ^~ ^~~~ ^~ ^~~~~ ^~~~~~  ^~~~ ^~~~~~~ ^~~~~~~~~~~~\n+     ALIQUA  UT ENIM AD MINIM VENIAM  QUIS NOSTRUD EXERCITATION\n+     ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis\n+     ^~~~~~~ ^~~~~~~ ^~~~ ^~ ^~~~~~~ ^~ ^~ ^~~~~~~ ^~~~~~~~~  ^~~~\n+     ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT  DUIS\n+     aute irure dolor in reprehenderit in voluptate velit esse cillum\n+     ^~~~ ^~~~~ ^~~~~ ^~ ^~~~~~~~~~~~~ ^~ ^~~~~~~~~ ^~~~~ ^~~~ ^~~~~~\n+     AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM\n+     dolore eu fugiat nulla pariatur. Excepteur sint occaecat\n+     ^~~~~~ ^~ ^~~~~~ ^~~~~ ^~~~~~~~  ^~~~~~~~~ ^~~~ ^~~~~~~~\n+     DOLORE EU FUGIAT NULLA PARIATUR  EXCEPTEUR SINT OCCAECAT\n+     cupidatat non proident, sunt in culpa qui officia deserunt\n+     ^~~~~~~~~ ^~~ ^~~~~~~~  ^~~~ ^~ ^~~~~ ^~~ ^~~~~~~ ^~~~~~~~\n+     CUPIDATAT NON PROIDENT  SUNT IN CULPA QUI OFFICIA DESERUNT\n+     mollit anim id est laborum.\n+     ^~~~~~ ^~~~ ^~ ^~~ ^~~~~~~\n+     MOLLIT ANIM ID EST LABORUM\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "ea28f046e8d5db88ff51c206a4a902e7f8f3aa34", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_show_locus.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -325,6 +325,59 @@ test_show_locus (function *fun)\n       warning_at (input_location, 0,\n \t\t  \"example of plus in format code for %q+D\", local);\n     }\n+\n+  /* Example of many locations and many fixits.\n+     Underline (separately) every word in a comment, and convert them\n+     to upper case.  */\n+  if (0 == strcmp (fnname, \"test_many_nested_locations\"))\n+    {\n+      const char *file = LOCATION_FILE (fnstart);\n+      const int start_line = fnstart_line + 2;\n+      const int finish_line = start_line + 7;\n+      location_t loc = get_loc (start_line - 1, 2);\n+      rich_location richloc (line_table, loc);\n+      for (int line = start_line; line <= finish_line; line++)\n+\t{\n+\t  int line_size;\n+\t  const char *content = location_get_source_line (file, line,\n+\t\t\t\t\t\t\t  &line_size);\n+\t  gcc_assert (content);\n+\t  /* Split line up into words.  */\n+\t  for (int idx = 0; idx < line_size; idx++)\n+\t    {\n+\t      if (ISALPHA (content[idx]))\n+\t\t{\n+\t\t  int start_idx = idx;\n+\t\t  while (idx < line_size && ISALPHA (content[idx]))\n+\t\t    idx++;\n+\t\t  if (idx == line_size || !ISALPHA (content[idx]))\n+\t\t    {\n+\t\t      location_t start_of_word = get_loc (line, start_idx);\n+\t\t      location_t end_of_word = get_loc (line, idx - 1);\n+\t\t      location_t word\n+\t\t\t= make_location (start_of_word, start_of_word,\n+\t\t\t\t\t end_of_word);\n+\t\t      richloc.add_range (word, true);\n+\n+\t\t      /* Add a fixit, converting to upper case.  */\n+\t\t      char *copy = xstrndup (content + start_idx,\n+\t\t\t\t\t     idx - start_idx);\n+\t\t      for (char *ch = copy; *ch; ch++)\n+\t\t\t*ch = TOUPPER (*ch);\n+\t\t      richloc.add_fixit_replace (word, copy);\n+\t\t      free (copy);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      /* Verify that we added enough locations to fully exercise\n+\t rich_location.  We want to exceed both the\n+\t statically-allocated buffer in class rich_location,\n+\t and then trigger a reallocation of the dynamic buffer.  */\n+      gcc_assert (richloc.get_num_locations () > 3 + (2 * 16));\n+      warning_at_rich_loc (&richloc, 0, \"test of %i locations\",\n+\t\t\t   richloc.get_num_locations ());\n+    }\n }\n \n unsigned int"}, {"sha": "595d6ca4cca815153be5d9c1fa5c8fbc3cd071a1", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -1,3 +1,42 @@\n+2016-08-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (class semi_embedded_vec): New class.\n+\t(semi_embedded_vec<T, NUM_EMBEDDED>::semi_embedded_vec): New ctor.\n+\t(semi_embedded_vec<T, NUM_EMBEDDED>::~semi_embedded_vec): New\n+\tdtor.\n+\t(semi_embedded_vec<T, NUM_EMBEDDED>::operator[]): New methods.\n+\t(semi_embedded_vec<T, NUM_EMBEDDED>::push): New method.\n+\t(semi_embedded_vec<T, NUM_EMBEDDED>::truncate): New method.\n+\t(rich_location::get_num_locations): Reimplement in terms of\n+\tm_ranges.\n+\t(rich_location::get_range): Make non-inline.\n+\t(rich_location::get_num_fixit_hints): Reimplement in terms of\n+\tm_fixit_hints.\n+\t(rich_location::add_fixit): New function.\n+\t(rich_location::MAX_RANGES): Rename to...\n+\t(rich_location::STATICALLY_ALLOCATED_RANGES): ...this.\n+\t(rich_location::MAX_FIXIT_HINTS): Rename to...\n+\t(rich_location::STATICALLY_ALLOCATED_RANGES): ...this, and make\n+\tprivate.\n+\t(rich_location::m_num_ranges): Eliminate in favor of...\n+\t(rich_location::m_ranges): ...this, converting from a fixed-size\n+\tarray to a semi_embedded_vec.\n+\t(rich_location::m_num_fixit_hints): Eliminate in favor of...\n+\t(rich_location::m_fixit_hints): ...this, converting from a\n+\tfixed-size array to a semi_embedded_vec.\n+\t* line-map.c (rich_location::rich_location): Update for above\n+\tchanges.\n+\t(rich_location::~rich_location): Likewise.\n+\t(rich_location::get_loc): Likewise.\n+\t(rich_location::get_range): New methods.\n+\t(rich_location::add_range): Update for above changes.\n+\t(rich_location::set_range): Likewise.\n+\t(rich_location::add_fixit_insert): Likewise.\n+\t(rich_location::add_fixit_replace): Likewise.\n+\t(rich_location::get_last_fixit_hint): Likewise.\n+\t(rich_location::reject_impossible_fixit): Likewise.\n+\t(rich_location::add_fixit): New method.\n+\n 2016-08-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* include/line-map.h (rich_location::add_fixit_insert): Add"}, {"sha": "0c95b292599b60606fbd95359e1446e57aa369ff", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 132, "deletions": 13, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -1288,6 +1288,128 @@ struct location_range\n   bool m_show_caret_p;\n };\n \n+/* A partially-embedded vec for use within rich_location for storing\n+   ranges and fix-it hints.\n+\n+   Elements [0..NUM_EMBEDDED) are allocated within m_embed, after\n+   that they are within the dynamically-allocated m_extra.\n+\n+   This allows for static allocation in the common case, whilst\n+   supporting the rarer case of an arbitrary number of elements.\n+\n+   Dynamic allocation is not performed unless it's needed.  */\n+\n+template <typename T, int NUM_EMBEDDED>\n+class semi_embedded_vec\n+{\n+ public:\n+  semi_embedded_vec ();\n+  ~semi_embedded_vec ();\n+\n+  unsigned int count () const { return m_num; }\n+  T& operator[] (int idx);\n+  const T& operator[] (int idx) const;\n+\n+  void push (const T&);\n+  void truncate (int len);\n+\n+ private:\n+  int m_num;\n+  T m_embedded[NUM_EMBEDDED];\n+  int m_alloc;\n+  T *m_extra;\n+};\n+\n+/* Constructor for semi_embedded_vec.  In particular, no dynamic allocation\n+   is done.  */\n+\n+template <typename T, int NUM_EMBEDDED>\n+semi_embedded_vec<T, NUM_EMBEDDED>::semi_embedded_vec ()\n+: m_num (0), m_alloc (0), m_extra (NULL)\n+{\n+}\n+\n+/* semi_embedded_vec's dtor.  Release any dynamically-allocated memory.  */\n+\n+template <typename T, int NUM_EMBEDDED>\n+semi_embedded_vec<T, NUM_EMBEDDED>::~semi_embedded_vec ()\n+{\n+  XDELETEVEC (m_extra);\n+}\n+\n+/* Look up element IDX, mutably.  */\n+\n+template <typename T, int NUM_EMBEDDED>\n+T&\n+semi_embedded_vec<T, NUM_EMBEDDED>::operator[] (int idx)\n+{\n+  linemap_assert (idx < m_num);\n+  if (idx < NUM_EMBEDDED)\n+    return m_embedded[idx];\n+  else\n+    {\n+      linemap_assert (m_extra != NULL);\n+      return m_extra[idx - NUM_EMBEDDED];\n+    }\n+}\n+\n+/* Look up element IDX (const).  */\n+\n+template <typename T, int NUM_EMBEDDED>\n+const T&\n+semi_embedded_vec<T, NUM_EMBEDDED>::operator[] (int idx) const\n+{\n+  linemap_assert (idx < m_num);\n+  if (idx < NUM_EMBEDDED)\n+    return m_embedded[idx];\n+  else\n+    {\n+      linemap_assert (m_extra != NULL);\n+      return m_extra[idx - NUM_EMBEDDED];\n+    }\n+}\n+\n+/* Append VALUE to the end of the semi_embedded_vec.  */\n+\n+template <typename T, int NUM_EMBEDDED>\n+void\n+semi_embedded_vec<T, NUM_EMBEDDED>::push (const T& value)\n+{\n+  int idx = m_num++;\n+  if (idx < NUM_EMBEDDED)\n+    m_embedded[idx] = value;\n+  else\n+    {\n+      /* Offset \"idx\" to be an index within m_extra.  */\n+      idx -= NUM_EMBEDDED;\n+      if (NULL == m_extra)\n+\t{\n+\t  linemap_assert (m_alloc == 0);\n+\t  m_alloc = 16;\n+\t  m_extra = XNEWVEC (T, m_alloc);\n+\t}\n+      else if (idx >= m_alloc)\n+\t{\n+\t  linemap_assert (m_alloc > 0);\n+\t  m_alloc *= 2;\n+\t  m_extra = XRESIZEVEC (T, m_extra, m_alloc);\n+\t}\n+      linemap_assert (m_extra);\n+      linemap_assert (idx < m_alloc);\n+      m_extra[idx] = value;\n+    }\n+}\n+\n+/* Truncate to length LEN.  No deallocation is performed.  */\n+\n+template <typename T, int NUM_EMBEDDED>\n+void\n+semi_embedded_vec<T, NUM_EMBEDDED>::truncate (int len)\n+{\n+  linemap_assert (len <= m_num);\n+  m_num = len;\n+}\n+\n class fixit_hint;\n   class fixit_insert;\n   class fixit_remove;\n@@ -1387,13 +1509,10 @@ class rich_location\n   set_range (line_maps *set, unsigned int idx, source_location loc,\n \t     bool show_caret_p);\n \n-  unsigned int get_num_locations () const { return m_num_ranges; }\n+  unsigned int get_num_locations () const { return m_ranges.count (); }\n \n-  location_range *get_range (unsigned int idx)\n-  {\n-    linemap_assert (idx < m_num_ranges);\n-    return &m_ranges[idx];\n-  }\n+  const location_range *get_range (unsigned int idx) const;\n+  location_range *get_range (unsigned int idx);\n \n   expanded_location get_expanded_location (unsigned int idx);\n \n@@ -1446,29 +1565,29 @@ class rich_location\n   add_fixit_replace (source_range src_range,\n \t\t     const char *new_content);\n \n-  unsigned int get_num_fixit_hints () const { return m_num_fixit_hints; }\n+  unsigned int get_num_fixit_hints () const { return m_fixit_hints.count (); }\n   fixit_hint *get_fixit_hint (int idx) const { return m_fixit_hints[idx]; }\n   fixit_hint *get_last_fixit_hint () const;\n \n private:\n   bool reject_impossible_fixit (source_location where);\n+  void add_fixit (fixit_hint *hint);\n \n public:\n-  static const int MAX_RANGES = 3;\n-  static const int MAX_FIXIT_HINTS = 2;\n+  static const int STATICALLY_ALLOCATED_RANGES = 3;\n \n protected:\n   line_maps *m_line_table;\n-  unsigned int m_num_ranges;\n-  location_range m_ranges[MAX_RANGES];\n+  semi_embedded_vec <location_range, STATICALLY_ALLOCATED_RANGES> m_ranges;\n \n   int m_column_override;\n \n   bool m_have_expanded_location;\n   expanded_location m_expanded_location;\n \n-  unsigned int m_num_fixit_hints;\n-  fixit_hint *m_fixit_hints[MAX_FIXIT_HINTS];\n+  static const int MAX_STATIC_FIXIT_HINTS = 2;\n+  semi_embedded_vec <fixit_hint *, MAX_STATIC_FIXIT_HINTS> m_fixit_hints;\n+\n   bool m_seen_impossible_fixit;\n };\n "}, {"sha": "72549ba0732d2debebe8c7dbcd1002e81f701c1d", "filename": "libcpp/line-map.c", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b816477a5ad7277b3a588e9a58cbcd764152b8d2/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b816477a5ad7277b3a588e9a58cbcd764152b8d2/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=b816477a5ad7277b3a588e9a58cbcd764152b8d2", "patch": "@@ -1983,10 +1983,10 @@ source_range::intersects_line_p (const char *file, int line) const\n \n rich_location::rich_location (line_maps *set, source_location loc) :\n   m_line_table (set),\n-  m_num_ranges (0),\n+  m_ranges (),\n   m_column_override (0),\n   m_have_expanded_location (false),\n-  m_num_fixit_hints (0),\n+  m_fixit_hints (),\n   m_seen_impossible_fixit (false)\n {\n   add_range (loc, true);\n@@ -1996,17 +1996,33 @@ rich_location::rich_location (line_maps *set, source_location loc) :\n \n rich_location::~rich_location ()\n {\n-  for (unsigned int i = 0; i < m_num_fixit_hints; i++)\n-    delete m_fixit_hints[i];\n+  for (unsigned int i = 0; i < m_fixit_hints.count (); i++)\n+    delete get_fixit_hint (i);\n }\n \n /* Get location IDX within this rich_location.  */\n \n source_location\n rich_location::get_loc (unsigned int idx) const\n {\n-  linemap_assert (idx < m_num_ranges);\n-  return m_ranges[idx].m_loc;\n+  const location_range *locrange = get_range (idx);\n+  return locrange->m_loc;\n+}\n+\n+/* Get range IDX within this rich_location.  */\n+\n+const location_range *\n+rich_location::get_range (unsigned int idx) const\n+{\n+  return &m_ranges[idx];\n+}\n+\n+/* Mutable access to range IDX within this rich_location.  */\n+\n+location_range *\n+rich_location::get_range (unsigned int idx)\n+{\n+  return &m_ranges[idx];\n }\n \n /* Expand location IDX within this rich_location.  */\n@@ -2049,11 +2065,10 @@ rich_location::override_column (int column)\n void\n rich_location::add_range (source_location loc, bool show_caret_p)\n {\n-  linemap_assert (m_num_ranges < MAX_RANGES);\n-\n-  location_range *range = &m_ranges[m_num_ranges++];\n-  range->m_loc = loc;\n-  range->m_show_caret_p = show_caret_p;\n+  location_range range;\n+  range.m_loc = loc;\n+  range.m_show_caret_p = show_caret_p;\n+  m_ranges.push (range);\n }\n \n /* Add or overwrite the location given by IDX, setting its location to LOC,\n@@ -2073,19 +2088,18 @@ void\n rich_location::set_range (line_maps * /*set*/, unsigned int idx,\n \t\t\t  source_location loc, bool show_caret_p)\n {\n-  linemap_assert (idx < MAX_RANGES);\n-\n   /* We can either overwrite an existing range, or add one exactly\n      on the end of the array.  */\n-  linemap_assert (idx <= m_num_ranges);\n-\n-  location_range *locrange = &m_ranges[idx];\n-  locrange->m_loc = loc;\n-  locrange->m_show_caret_p = show_caret_p;\n+  linemap_assert (idx <= m_ranges.count ());\n \n-  /* Are we adding a range onto the end?  */\n-  if (idx == m_num_ranges)\n-    m_num_ranges = idx + 1;\n+  if (idx == m_ranges.count ())\n+    add_range (loc,  show_caret_p);\n+  else\n+    {\n+      location_range *locrange = get_range (idx);\n+      locrange->m_loc = loc;\n+      locrange->m_show_caret_p = show_caret_p;\n+    }\n \n   if (idx == 0)\n     /* Mark any cached value here as dirty.  */\n@@ -2114,10 +2128,7 @@ rich_location::add_fixit_insert (source_location where,\n \n   if (reject_impossible_fixit (where))\n     return;\n-\n-  linemap_assert (m_num_fixit_hints < MAX_FIXIT_HINTS);\n-  m_fixit_hints[m_num_fixit_hints++]\n-    = new fixit_insert (where, new_content);\n+  add_fixit (new fixit_insert (where, new_content));\n }\n \n /* Methods for adding removal fix-it hints.  */\n@@ -2217,8 +2228,6 @@ void\n rich_location::add_fixit_replace (source_range src_range,\n \t\t\t\t  const char *new_content)\n {\n-  linemap_assert (m_num_fixit_hints < MAX_FIXIT_HINTS);\n-\n   src_range.m_start = get_pure_location (m_line_table, src_range.m_start);\n   src_range.m_finish = get_pure_location (m_line_table, src_range.m_finish);\n \n@@ -2229,23 +2238,20 @@ rich_location::add_fixit_replace (source_range src_range,\n \n   /* Consolidate neighboring fixits.  */\n   fixit_hint *prev = get_last_fixit_hint ();\n-  if (m_num_fixit_hints > 0)\n-    {\n-      if (prev->maybe_append_replace (m_line_table, src_range, new_content))\n-\treturn;\n-    }\n+  if (prev)\n+    if (prev->maybe_append_replace (m_line_table, src_range, new_content))\n+      return;\n \n-  m_fixit_hints[m_num_fixit_hints++]\n-    = new fixit_replace (src_range, new_content);\n+  add_fixit (new fixit_replace (src_range, new_content));\n }\n \n /* Get the last fix-it hint within this rich_location, or NULL if none.  */\n \n fixit_hint *\n rich_location::get_last_fixit_hint () const\n {\n-  if (m_num_fixit_hints > 0)\n-    return m_fixit_hints[m_num_fixit_hints - 1];\n+  if (m_fixit_hints.count () > 0)\n+    return get_fixit_hint (m_fixit_hints.count () - 1);\n   else\n     return NULL;\n }\n@@ -2275,13 +2281,21 @@ rich_location::reject_impossible_fixit (source_location where)\n   m_seen_impossible_fixit = true;\n \n   /* Purge the rich_location of any fix-its that were already added. */\n-  for (unsigned int i = 0; i < m_num_fixit_hints; i++)\n-    delete m_fixit_hints[i];\n-  m_num_fixit_hints = 0;\n+  for (unsigned int i = 0; i < m_fixit_hints.count (); i++)\n+    delete get_fixit_hint (i);\n+  m_fixit_hints.truncate (0);\n \n   return true;\n }\n \n+/* Add HINT to the fix-it hints in this rich_location.  */\n+\n+void\n+rich_location::add_fixit (fixit_hint *hint)\n+{\n+  m_fixit_hints.push (hint);\n+}\n+\n /* class fixit_insert.  */\n \n fixit_insert::fixit_insert (source_location where,"}]}