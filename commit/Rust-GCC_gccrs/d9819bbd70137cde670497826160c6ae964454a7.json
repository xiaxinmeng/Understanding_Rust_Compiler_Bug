{"sha": "d9819bbd70137cde670497826160c6ae964454a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk4MTliYmQ3MDEzN2NkZTY3MDQ5NzgyNjE2MGM2YWU5NjQ0NTRhNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:30:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:30:29Z"}, "message": "[multiple changes]\n\n2012-07-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Convert_To_Positional): Increase acceptable size\n\tof static aggregate when Static_Elaboration_Desired is requested.\n\tAdd a warning if the request cannot be satisfied either because\n\tsome components or some array bounds are non-static.\n\n2012-07-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_pakd.adb: Minor reformatting.\n\n2012-07-12  Tristan Gingold  <gingold@adacore.com>\n\n\t* tracebak.c: Fix warnings.\n\t* raise-gcc.c (__gnat_adjust_context): New function\n\t(__gnat_personality_seh0): Call __gnat_adjust_context to adjust\n\tPC in machine frame for exceptions that occur in the current\n\tfunction.\n\n2012-07-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-bytswa.adb, g-bytswa.ads, s-bytswa.adb, s-bytswa.ads, Makefile.rtl:\n\tMove GNAT.Byte_Swapping to System (with a renaming under GNAT)\n\tso that it is usable in expanded code.\n\n2012-07-12  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-osinte-hpux.ads: Increase alternate stack size on hpux.\n\nFrom-SVN: r189434", "tree": {"sha": "04a8e86ff3e86b38d6ad932ef1f19194fec3232d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04a8e86ff3e86b38d6ad932ef1f19194fec3232d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9819bbd70137cde670497826160c6ae964454a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9819bbd70137cde670497826160c6ae964454a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9819bbd70137cde670497826160c6ae964454a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9819bbd70137cde670497826160c6ae964454a7/comments", "author": null, "committer": null, "parents": [{"sha": "2ed5b74848f711b62fb30cfa324377217534411a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed5b74848f711b62fb30cfa324377217534411a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed5b74848f711b62fb30cfa324377217534411a"}], "stats": {"total": 848, "additions": 561, "deletions": 287}, "files": [{"sha": "ec8cded8dcfe09526aeaefe58664d714850ebee4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -1,3 +1,32 @@\n+2012-07-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Convert_To_Positional): Increase acceptable size\n+\tof static aggregate when Static_Elaboration_Desired is requested.\n+\tAdd a warning if the request cannot be satisfied either because\n+\tsome components or some array bounds are non-static.\n+\n+2012-07-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_pakd.adb: Minor reformatting.\n+\n+2012-07-12  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* tracebak.c: Fix warnings.\n+\t* raise-gcc.c (__gnat_adjust_context): New function\n+\t(__gnat_personality_seh0): Call __gnat_adjust_context to adjust\n+\tPC in machine frame for exceptions that occur in the current\n+\tfunction.\n+\n+2012-07-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-bytswa.adb, g-bytswa.ads, s-bytswa.adb, s-bytswa.ads, Makefile.rtl:\n+\tMove GNAT.Byte_Swapping to System (with a renaming under GNAT)\n+\tso that it is usable in expanded code.\n+\n+2012-07-12  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-osinte-hpux.ads: Increase alternate stack size on hpux.\n+\n 2012-07-12  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch3.adb (Make_Neq_Body): Fix typo in comment."}, {"sha": "144e91469d4b0c9c2c2780fb416dcb6925acd58a", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -483,6 +483,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-auxdec$(objext) \\\n   s-bitops$(objext) \\\n   s-boarop$(objext) \\\n+  s-bytswa$(objext) \\\n   s-carsi8$(objext) \\\n   s-carun8$(objext) \\\n   s-casi16$(objext) \\"}, {"sha": "2d8c2a1bf297151780d7942c4e2a8bed43332f01", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -294,15 +294,21 @@ package body Exp_Aggr is\n \n       --  The normal limit is 5000, but we increase this limit to 2**24 (about\n       --  16 million) if Restrictions (No_Elaboration_Code) or Restrictions\n-      --  (No_Implicit_Loops) is specified, since in either case, we are at\n-      --  risk of declaring the program illegal because of this limit.\n+      --  (No_Implicit_Loops) is specified, since in either case we are at risk\n+      --  of declaring the program illegal because of this limit. We also\n+      --  increase the limit when Static_Elaboration_Desired, given that this\n+      --  means that objects are intended to be placed in data memory.\n \n       Max_Aggr_Size : constant Nat :=\n                         5000 + (2 ** 24 - 5000) *\n                           Boolean'Pos\n                             (Restriction_Active (No_Elaboration_Code)\n-                              or else\n-                             Restriction_Active (No_Implicit_Loops));\n+                               or else\n+                             Restriction_Active (No_Implicit_Loops)\n+                               or else\n+                             ((Ekind (Current_Scope) = E_Package\n+                               and then\n+                                 Static_Elaboration_Desired (Current_Scope))));\n \n       function Component_Count (T : Entity_Id) return Int;\n       --  The limit is applied to the total number of components that the\n@@ -3512,10 +3518,11 @@ package body Exp_Aggr is\n                            --  we skip this test if either of the restrictions\n                            --  No_Elaboration_Code or No_Implicit_Loops is\n                            --  active, if this is a preelaborable unit or a\n-                           --  predefined unit. This ensures that predefined\n-                           --  units get the same level of constant folding in\n-                           --  Ada 95 and Ada 2005, where their categorization\n-                           --  has changed.\n+                           --  predefined unit, or if the unit must be placed\n+                           --  in data memory. This also ensures that\n+                           --  predefined units get the same level of constant\n+                           --  folding in Ada 95 and Ada 2005, where their\n+                           --  categorization has changed.\n \n                            declare\n                               P : constant Entity_Id :=\n@@ -3527,6 +3534,10 @@ package body Exp_Aggr is\n \n                               if Restriction_Active (No_Elaboration_Code)\n                                 or else Restriction_Active (No_Implicit_Loops)\n+                                or else\n+                                  (Ekind (Current_Scope) = E_Package\n+                                    and then\n+                                    Static_Elaboration_Desired (Current_Scope))\n                                 or else Is_Preelaborated (P)\n                                 or else (Ekind (P) = E_Package_Body\n                                           and then\n@@ -3717,6 +3728,38 @@ package body Exp_Aggr is\n \n          Analyze_And_Resolve (N, Typ);\n       end if;\n+\n+      if (Ekind (Current_Scope) = E_Package\n+        and then Static_Elaboration_Desired (Current_Scope))\n+        and then Nkind (Parent (N)) = N_Object_Declaration\n+      then\n+         declare\n+            Expr : Node_Id;\n+\n+         begin\n+            if Present (Expressions (N)) then\n+               Expr := First (Expressions (N));\n+               while Present (Expr) loop\n+                  if Nkind_In (Expr, N_Integer_Literal, N_Real_Literal)\n+                    or else\n+                      (Is_Entity_Name (Expr)\n+                        and then Ekind (Entity (Expr)) = E_Enumeration_Literal)\n+                  then\n+                     null;\n+                  else\n+                     Error_Msg_N (\"non-static object \"\n+                       & \" requires elaboration code?\", N);\n+                     exit;\n+                  end if;\n+                  Next (Expr);\n+               end loop;\n+\n+               if Present (Component_Associations (N)) then\n+                  Error_Msg_N (\"object requires elaboration code?\", N);\n+               end if;\n+            end if;\n+         end;\n+      end if;\n    end Convert_To_Positional;\n \n    ----------------------------\n@@ -6145,9 +6188,7 @@ package body Exp_Aggr is\n \n             --  Now we can rewrite with the proper value\n \n-            Lit :=\n-              Make_Integer_Literal (Loc,\n-                Intval => Aggregate_Val);\n+            Lit := Make_Integer_Literal (Loc, Intval => Aggregate_Val);\n             Set_Print_In_Hex (Lit);\n \n             --  Construct the expression using this literal. Note that it is"}, {"sha": "ee75cf732beab86c5134b2de19e54f0066167a47", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -1593,8 +1593,7 @@ package body Exp_Pakd is\n                      --  Note that Rhs_Val has already been normalized to\n                      --  be an unsigned value with the proper number of bits.\n \n-                     Rhs :=\n-                       Make_Integer_Literal (Loc, Rhs_Val);\n+                     Rhs := Make_Integer_Literal (Loc, Rhs_Val);\n \n                   --  Otherwise we need an unchecked conversion\n "}, {"sha": "f686d4f8e7fea28887ff015941034dff701fd0db", "filename": "gcc/ada/g-bytswa.adb", "status": "modified", "additions": 6, "deletions": 96, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fg-bytswa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fg-bytswa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-bytswa.adb?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                    G N A T . B Y T E _ S W A P P I N G                   --\n+--                     G N A T . B Y T E _ S W A P P I N G                  --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2006-2012, AdaCore                     --\n+--                     Copyright (C) 1995-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,98 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a general implementation that uses GCC intrinsics to take\n---  advantage of any machine-specific instructions.\n+--  This package does not require a body, since it is a package renaming. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-with Ada.Unchecked_Conversion; use Ada;\n-\n-package body GNAT.Byte_Swapping is\n-\n-   type U16 is mod 2**16;\n-   type U32 is mod 2**32;\n-   type U64 is mod 2**64;\n-\n-   function Bswap_16 (X : U16) return U16 is (X / 256 or X * 256);\n-   --  The above is an idiom recognized by GCC\n-\n-   function Bswap_32 (X : U32) return U32;\n-   pragma Import (Intrinsic, Bswap_32, \"__builtin_bswap32\");\n-\n-   function Bswap_64 (X : U64) return U64;\n-   pragma Import (Intrinsic, Bswap_64, \"__builtin_bswap64\");\n-\n-   --------------\n-   -- Swapped2 --\n-   --------------\n-\n-   function Swapped2 (Input : Item) return Item is\n-      function As_U16 is new Unchecked_Conversion (Item, U16);\n-      function As_Item is new Unchecked_Conversion (U16, Item);\n-\n-      function Bswap_16 (X : U16) return U16 is (X / 256 or X * 256);\n-      --  ??? Need to have function local here to allow inlining\n-      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 2,\n-        \"storage size must be 2 bytes\");\n-   begin\n-      return As_Item (Bswap_16 (As_U16 (Input)));\n-   end Swapped2;\n-\n-   --------------\n-   -- Swapped4 --\n-   --------------\n-\n-   function Swapped4 (Input : Item) return Item is\n-      function As_U32 is new Unchecked_Conversion (Item, U32);\n-      function As_Item is new Unchecked_Conversion (U32, Item);\n-      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 4,\n-        \"storage size must be 4 bytes\");\n-   begin\n-      return As_Item (Bswap_32 (As_U32 (Input)));\n-   end Swapped4;\n-\n-   --------------\n-   -- Swapped8 --\n-   --------------\n-\n-   function Swapped8 (Input : Item) return Item is\n-      function As_U64 is new Unchecked_Conversion (Item, U64);\n-      function As_Item is new Unchecked_Conversion (U64, Item);\n-      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 8,\n-        \"storage size must be 8 bytes\");\n-   begin\n-      return As_Item (Bswap_64 (As_U64 (Input)));\n-   end Swapped8;\n-\n-   -----------\n-   -- Swap2 --\n-   -----------\n-\n-   procedure Swap2 (Location : System.Address) is\n-      X : U16;\n-      for X'Address use Location;\n-   begin\n-      X := Bswap_16 (X);\n-   end Swap2;\n-\n-   -----------\n-   -- Swap4 --\n-   -----------\n-\n-   procedure Swap4 (Location : System.Address) is\n-      X : U32;\n-      for X'Address use Location;\n-   begin\n-      X := Bswap_32 (X);\n-   end Swap4;\n-\n-   -----------\n-   -- Swap8 --\n-   -----------\n-\n-   procedure Swap8 (Location : System.Address) is\n-      X : U64;\n-      for X'Address use Location;\n-   begin\n-      X := Bswap_64 (X);\n-   end Swap8;\n-end GNAT.Byte_Swapping;\n+pragma No_Body;"}, {"sha": "2018dea3c9b15658fdde1405ce7d7a218fc22b46", "filename": "gcc/ada/g-bytswa.ads", "status": "modified", "additions": 5, "deletions": 173, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fg-bytswa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fg-bytswa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-bytswa.ads?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                    G N A T . B Y T E _ S W A P P I N G                   --\n+--                     G N A T . B Y T E _ S W A P P I N G                  --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2006-2011, AdaCore                     --\n+--                     Copyright (C) 2006-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,176 +31,8 @@\n \n --  Simple routines for swapping the bytes of 16-, 32-, and 64-bit objects\n \n---  The generic functions should be instantiated with types that are of a size\n---  in bytes corresponding to the name of the generic. For example, a 2-byte\n---  integer type would be compatible with Swapped2, 4-byte integer with\n---  Swapped4, and so on. Failure to do so will result in a warning when\n---  compiling the instantiation; this warning should be heeded. Ignoring this\n---  warning can result in unexpected results.\n+--  See file s-bytswa.ads for full documentation of the interface\n \n---  An example of proper usage follows:\n+with System.Byte_Swapping;\n \n---     declare\n---        type Short_Integer is range -32768 .. 32767;\n---        for Short_Integer'Size use 16; -- for confirmation\n-\n---        X : Short_Integer := 16#7FFF#;\n-\n---        function Swapped is new Byte_Swapping.Swapped2 (Short_Integer);\n-\n---     begin\n---        Put_Line (X'Img);\n---        X := Swapped (X);\n---        Put_Line (X'Img);\n---     end;\n-\n---  Note that the generic actual types need not be scalars, but must be\n---  'definite' types. They can, for example, be constrained subtypes of\n---  unconstrained array types as long as the size is correct. For instance,\n---  a subtype of String with length of 4 would be compatible with the\n---  Swapped4 generic:\n-\n---     declare\n---        subtype String4 is String (1 .. 4);\n---        function Swapped is new Byte_Swapping.Swapped4 (String4);\n---        S : String4 := \"ABCD\";\n---        for S'Alignment use 4;\n---     begin\n---        Put_Line (S);\n---        S := Swapped (S);\n---        Put_Line (S);\n---     end;\n-\n---  Similarly, a constrained array type is also acceptable:\n-\n---     declare\n---        type Mask is array (0 .. 15) of Boolean;\n---        for Mask'Alignment use 2;\n---        for Mask'Component_Size use Boolean'Size;\n---        X : Mask := (0 .. 7 => True, others => False);\n---        function Swapped is new Byte_Swapping.Swapped2 (Mask);\n---     begin\n---        ...\n---        X := Swapped (X);\n---        ...\n---     end;\n-\n---  A properly-sized record type will also be acceptable, and so forth\n-\n---  However, as described, a size mismatch must be avoided. In the following we\n---  instantiate one of the generics with a type that is too large. The result\n---  of the function call is undefined, such that assignment to an object can\n---  result in garbage values.\n-\n---     Wrong: declare\n---        subtype String16 is String (1 .. 16);\n-\n---        function Swapped is new Byte_Swapping.Swapped8 (String16);\n---        --  Instantiation generates a compiler warning about\n---        --  mismatched sizes\n-\n---        S : String16;\n-\n---     begin\n---        S := \"ABCDEFGHDEADBEEF\";\n---\n---        Put_Line (S);\n---\n---        --  the following assignment results in garbage in S after the\n---        --  first 8 bytes\n---\n---        S := Swapped (S);\n---\n---        Put_Line (S);\n---     end Wrong;\n-\n---  When the size of the type is larger than 8 bytes, the use of the non-\n---  generic procedures is an alternative because no function result is\n---  involved; manipulation of the object is direct.\n-\n---  The procedures are passed the address of an object to manipulate. They will\n---  swap the first N bytes of that object corresponding to the name of the\n---  procedure.  For example:\n-\n---     declare\n---        S2 : String := \"AB\";\n---        for S2'Alignment use 2;\n---        S4 : String := \"ABCD\";\n---        for S4'Alignment use 4;\n---        S8 : String := \"ABCDEFGH\";\n---        for S8'Alignment use 8;\n-\n---     begin\n---        Swap2 (S2'Address);\n---        Put_Line (S2);\n-\n---        Swap4 (S4'Address);\n---        Put_Line (S4);\n-\n---        Swap8 (S8'Address);\n---        Put_Line (S8);\n---     end;\n-\n---  If an object of a type larger than N is passed, the remaining bytes of the\n---  object are undisturbed. For example:\n-\n---     declare\n---        subtype String16 is String (1 .. 16);\n-\n---        S : String16;\n---        for S'Alignment use 8;\n-\n---     begin\n---        S  := \"ABCDEFGHDEADBEEF\";\n---        Put_Line (S);\n---        Swap8 (S'Address);\n---        Put_Line (S);\n---     end;\n-\n-with System;\n-\n-package GNAT.Byte_Swapping is\n-   pragma Pure;\n-\n-   --  NB: all the routines in this package treat the application objects as\n-   --  unsigned (modular) types of a size in bytes corresponding to the routine\n-   --  name. For example, the generic function Swapped2 manipulates the object\n-   --  passed to the formal parameter Input as a value of an unsigned type that\n-   --  is 2 bytes long. Therefore clients are responsible for the compatibility\n-   --  of application types manipulated by these routines and these modular\n-   --  types, in terms of both size and alignment. This requirement applies to\n-   --  the generic actual type passed to the generic formal type Item in the\n-   --  generic functions, as well as to the type of the object implicitly\n-   --  designated by the address passed to the non-generic procedures. Use of\n-   --  incompatible types can result in implementation- defined effects.\n-\n-   generic\n-      type Item is limited private;\n-   function Swapped2 (Input : Item) return Item;\n-   --  Return the 2-byte value of Input with the bytes swapped\n-\n-   generic\n-      type Item is limited private;\n-   function Swapped4 (Input : Item) return Item;\n-   --  Return the 4-byte value of Input with the bytes swapped\n-\n-   generic\n-      type Item is limited private;\n-   function Swapped8 (Input : Item) return Item;\n-   --  Return the 8-byte value of Input with the bytes swapped\n-\n-   procedure Swap2 (Location : System.Address);\n-   --  Swap the first 2 bytes of the object starting at the address specified\n-   --  by Location.\n-\n-   procedure Swap4 (Location : System.Address);\n-   --  Swap the first 4 bytes of the object starting at the address specified\n-   --  by Location.\n-\n-   procedure Swap8 (Location : System.Address);\n-   --  Swap the first 8 bytes of the object starting at the address specified\n-   --  by Location.\n-\n-   pragma Inline (Swap2, Swap4, Swap8, Swapped2, Swapped4, Swapped8);\n-\n-end GNAT.Byte_Swapping;\n+package GNAT.Byte_Swapping renames System.Byte_Swapping;"}, {"sha": "2383aa86054eeb1acc3c9423755fb887661563ba", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 130, "deletions": 1, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -1216,6 +1216,75 @@ __gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n EXCEPTION_DISPOSITION __gnat_SEH_error_handler\n  (struct _EXCEPTION_RECORD*, void*, struct _CONTEXT*, void*);\n \n+/* Unwind opcodes.  */\n+#define UWOP_PUSH_NONVOL 0\n+#define UWOP_ALLOC_LARGE 1\n+#define UWOP_ALLOC_SMALL 2\n+#define UWOP_SET_FPREG\t 3\n+#define UWOP_SAVE_NONVOL 4\n+#define UWOP_SAVE_NONVOL_FAR 5\n+#define UWOP_SAVE_XMM128 8\n+#define UWOP_SAVE_XMM128_FAR 9\n+#define UWOP_PUSH_MACHFRAME 10\n+\n+/* Modify the IP value saved in the machine frame.  This is really a kludge,\n+   that will be removed if we could propagate the Windows exception (and not\n+   the GCC one).\n+   What is very wrong is that the Windows unwinder will try to decode the\n+   instruction at IP, which isn't valid anymore after the adjust.  */\n+\n+static void\n+__gnat_adjust_context (unsigned char *unw, ULONG64 rsp)\n+{\n+  unsigned int len;\n+\n+  /* Version = 1, no flags, no prolog.  */\n+  if (unw[0] != 1 || unw[1] != 0)\n+    return;\n+  len = unw[2];\n+  /* No frame pointer.  */\n+  if (unw[3] != 0)\n+    return;\n+  unw += 4;\n+  while (len > 0)\n+    {\n+      /* Offset in prolog = 0.  */\n+      if (unw[0] != 0)\n+\treturn;\n+      switch (unw[1] & 0xf)\n+\t{\n+\tcase UWOP_ALLOC_LARGE:\n+\t  /* Expect < 512KB.  */\n+\t  if ((unw[1] & 0xf0) != 0)\n+\t    return;\n+\t  rsp += *(unsigned short *)(unw + 2) * 8;\n+\t  len--;\n+\t  unw += 2;\n+\t  break;\n+\tcase UWOP_SAVE_NONVOL:\n+\tcase UWOP_SAVE_XMM128:\n+\t  len--;\n+\t  unw += 2;\n+\t  break;\n+\tcase UWOP_PUSH_MACHFRAME:\n+\t  {\n+\t    ULONG64 *rip;\n+\t    rip = (ULONG64 *)rsp;\n+\t    if ((unw[1] & 0xf0) == 0x10)\n+\t      rip++;\n+\t    /* Adjust rip.  */\n+\t    (*rip)++;\n+\t  }\n+\t  return;\n+\tdefault:\n+\t  /* Unexpected.  */\n+\t  return;\n+\t}\n+      unw += 2;\n+      len--;\n+    }\n+}\n+\n EXCEPTION_DISPOSITION\n __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \t\t\t PCONTEXT ms_orig_context,\n@@ -1225,7 +1294,67 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n      optimization, we call __gnat_SEH_error_handler only on non-user\n      exceptions.  */\n   if (!(ms_exc->ExceptionCode & STATUS_USER_DEFINED))\n-    __gnat_SEH_error_handler (ms_exc, this_frame, ms_orig_context, ms_disp);\n+    {\n+      ULONG64 excpip = (ULONG64) ms_exc->ExceptionAddress;\n+      if (excpip != 0\n+\t  && excpip >= (ms_disp->ImageBase\n+\t\t\t+ ms_disp->FunctionEntry->BeginAddress)\n+\t  && excpip < (ms_disp->ImageBase\n+\t\t       + ms_disp->FunctionEntry->EndAddress))\n+\t{\n+\t  /* This is a fault in this function.  We need to adjust the return\n+\t     address before raising the GCC exception.  */\n+\t  CONTEXT context;\n+\t  PRUNTIME_FUNCTION mf_func = NULL;\n+\t  ULONG64 mf_imagebase;\n+\t  ULONG64 mf_rsp;\n+\n+\t  /* Get the context.  */\n+\t  RtlCaptureContext (&context);\n+\n+\t  while (1)\n+\t    {\n+\t      PRUNTIME_FUNCTION RuntimeFunction;\n+\t      ULONG64 ImageBase;\n+\t      VOID *HandlerData;\n+\t      ULONG64 EstablisherFrame;\n+\n+\t      /* Get function metadata.  */\n+\t      RuntimeFunction = RtlLookupFunctionEntry\n+\t\t(context.Rip, &ImageBase, ms_disp->HistoryTable);\n+\t      if (RuntimeFunction == ms_disp->FunctionEntry)\n+\t\tbreak;\n+\t      mf_func = RuntimeFunction;\n+\t      mf_imagebase = ImageBase;\n+\t      mf_rsp = context.Rsp;\n+\n+\t      if (!RuntimeFunction)\n+\t\t{\n+\t\t  /* In case of failure, assume this is a leaf function.  */\n+\t\t  context.Rip = *(ULONG64 *) context.Rsp;\n+\t\t  context.Rsp += 8;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Unwind.  */\n+\t\t  RtlVirtualUnwind (0, ImageBase, context.Rip, RuntimeFunction,\n+\t\t\t\t    &context, &HandlerData, &EstablisherFrame,\n+\t\t\t\t    NULL);\n+\t\t}\n+\n+\t      /* 0 means bottom of the stack.  */\n+\t      if (context.Rip == 0)\n+\t\t{\n+\t\t  mf_func = NULL;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (mf_func != NULL)\n+\t    __gnat_adjust_context\n+\t      ((unsigned char *)(mf_imagebase + mf_func->UnwindData), mf_rsp);\n+\t}\n+      __gnat_SEH_error_handler (ms_exc, this_frame, ms_orig_context, ms_disp);\n+    }\n \n   return _GCC_specific_handler (ms_exc, this_frame, ms_orig_context,\n \t\t\t\tms_disp, __gnat_personality_imp);"}, {"sha": "ac54d0eedb0d9abaf3de7acbd3a2104f7e99bc22", "filename": "gcc/ada/s-bytswa.adb", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fs-bytswa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fs-bytswa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bytswa.adb?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -0,0 +1,127 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . B Y T E _ S W A P P I N G                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2006-2012, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a general implementation that uses GCC intrinsics to take\n+--  advantage of any machine-specific instructions.\n+\n+with Ada.Unchecked_Conversion; use Ada;\n+\n+package body System.Byte_Swapping is\n+\n+   type U16 is mod 2**16;\n+   type U32 is mod 2**32;\n+   type U64 is mod 2**64;\n+\n+   function Bswap_16 (X : U16) return U16;\n+   pragma Import (Intrinsic, Bswap_16, \"__builtin_bswap16\");\n+\n+   function Bswap_32 (X : U32) return U32;\n+   pragma Import (Intrinsic, Bswap_32, \"__builtin_bswap32\");\n+\n+   function Bswap_64 (X : U64) return U64;\n+   pragma Import (Intrinsic, Bswap_64, \"__builtin_bswap64\");\n+\n+   --------------\n+   -- Swapped2 --\n+   --------------\n+\n+   function Swapped2 (Input : Item) return Item is\n+      function As_U16 is new Unchecked_Conversion (Item, U16);\n+      function As_Item is new Unchecked_Conversion (U16, Item);\n+\n+      function Bswap_16 (X : U16) return U16 is (X / 256 or X * 256);\n+      --  ??? Need to have function local here to allow inlining\n+      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 2,\n+        \"storage size must be 2 bytes\");\n+   begin\n+      return As_Item (Bswap_16 (As_U16 (Input)));\n+   end Swapped2;\n+\n+   --------------\n+   -- Swapped4 --\n+   --------------\n+\n+   function Swapped4 (Input : Item) return Item is\n+      function As_U32 is new Unchecked_Conversion (Item, U32);\n+      function As_Item is new Unchecked_Conversion (U32, Item);\n+      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 4,\n+        \"storage size must be 4 bytes\");\n+   begin\n+      return As_Item (Bswap_32 (As_U32 (Input)));\n+   end Swapped4;\n+\n+   --------------\n+   -- Swapped8 --\n+   --------------\n+\n+   function Swapped8 (Input : Item) return Item is\n+      function As_U64 is new Unchecked_Conversion (Item, U64);\n+      function As_Item is new Unchecked_Conversion (U64, Item);\n+      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 8,\n+        \"storage size must be 8 bytes\");\n+   begin\n+      return As_Item (Bswap_64 (As_U64 (Input)));\n+   end Swapped8;\n+\n+   -----------\n+   -- Swap2 --\n+   -----------\n+\n+   procedure Swap2 (Location : System.Address) is\n+      X : U16;\n+      for X'Address use Location;\n+   begin\n+      X := Bswap_16 (X);\n+   end Swap2;\n+\n+   -----------\n+   -- Swap4 --\n+   -----------\n+\n+   procedure Swap4 (Location : System.Address) is\n+      X : U32;\n+      for X'Address use Location;\n+   begin\n+      X := Bswap_32 (X);\n+   end Swap4;\n+\n+   -----------\n+   -- Swap8 --\n+   -----------\n+\n+   procedure Swap8 (Location : System.Address) is\n+      X : U64;\n+      for X'Address use Location;\n+   begin\n+      X := Bswap_64 (X);\n+   end Swap8;\n+\n+end System.Byte_Swapping;"}, {"sha": "2ce1fe863c69af421bb02b1c10f86fd7f69acdbc", "filename": "gcc/ada/s-bytswa.ads", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fs-bytswa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fs-bytswa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bytswa.ads?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -0,0 +1,206 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . B Y T E _ S W A P P I N G                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2006-2012, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Simple routines for swapping the bytes of 16-, 32-, and 64-bit objects\n+\n+--  The generic functions should be instantiated with types that are of a size\n+--  in bytes corresponding to the name of the generic. For example, a 2-byte\n+--  integer type would be compatible with Swapped2, 4-byte integer with\n+--  Swapped4, and so on. Failure to do so will result in a warning when\n+--  compiling the instantiation; this warning should be heeded. Ignoring this\n+--  warning can result in unexpected results.\n+\n+--  An example of proper usage follows:\n+\n+--     declare\n+--        type Short_Integer is range -32768 .. 32767;\n+--        for Short_Integer'Size use 16; -- for confirmation\n+\n+--        X : Short_Integer := 16#7FFF#;\n+\n+--        function Swapped is new Byte_Swapping.Swapped2 (Short_Integer);\n+\n+--     begin\n+--        Put_Line (X'Img);\n+--        X := Swapped (X);\n+--        Put_Line (X'Img);\n+--     end;\n+\n+--  Note that the generic actual types need not be scalars, but must be\n+--  'definite' types. They can, for example, be constrained subtypes of\n+--  unconstrained array types as long as the size is correct. For instance,\n+--  a subtype of String with length of 4 would be compatible with the\n+--  Swapped4 generic:\n+\n+--     declare\n+--        subtype String4 is String (1 .. 4);\n+--        function Swapped is new Byte_Swapping.Swapped4 (String4);\n+--        S : String4 := \"ABCD\";\n+--        for S'Alignment use 4;\n+--     begin\n+--        Put_Line (S);\n+--        S := Swapped (S);\n+--        Put_Line (S);\n+--     end;\n+\n+--  Similarly, a constrained array type is also acceptable:\n+\n+--     declare\n+--        type Mask is array (0 .. 15) of Boolean;\n+--        for Mask'Alignment use 2;\n+--        for Mask'Component_Size use Boolean'Size;\n+--        X : Mask := (0 .. 7 => True, others => False);\n+--        function Swapped is new Byte_Swapping.Swapped2 (Mask);\n+--     begin\n+--        ...\n+--        X := Swapped (X);\n+--        ...\n+--     end;\n+\n+--  A properly-sized record type will also be acceptable, and so forth\n+\n+--  However, as described, a size mismatch must be avoided. In the following we\n+--  instantiate one of the generics with a type that is too large. The result\n+--  of the function call is undefined, such that assignment to an object can\n+--  result in garbage values.\n+\n+--     Wrong: declare\n+--        subtype String16 is String (1 .. 16);\n+\n+--        function Swapped is new Byte_Swapping.Swapped8 (String16);\n+--        --  Instantiation generates a compiler warning about\n+--        --  mismatched sizes\n+\n+--        S : String16;\n+\n+--     begin\n+--        S := \"ABCDEFGHDEADBEEF\";\n+--\n+--        Put_Line (S);\n+--\n+--        --  the following assignment results in garbage in S after the\n+--        --  first 8 bytes\n+--\n+--        S := Swapped (S);\n+--\n+--        Put_Line (S);\n+--     end Wrong;\n+\n+--  When the size of the type is larger than 8 bytes, the use of the non-\n+--  generic procedures is an alternative because no function result is\n+--  involved; manipulation of the object is direct.\n+\n+--  The procedures are passed the address of an object to manipulate. They will\n+--  swap the first N bytes of that object corresponding to the name of the\n+--  procedure.  For example:\n+\n+--     declare\n+--        S2 : String := \"AB\";\n+--        for S2'Alignment use 2;\n+--        S4 : String := \"ABCD\";\n+--        for S4'Alignment use 4;\n+--        S8 : String := \"ABCDEFGH\";\n+--        for S8'Alignment use 8;\n+\n+--     begin\n+--        Swap2 (S2'Address);\n+--        Put_Line (S2);\n+\n+--        Swap4 (S4'Address);\n+--        Put_Line (S4);\n+\n+--        Swap8 (S8'Address);\n+--        Put_Line (S8);\n+--     end;\n+\n+--  If an object of a type larger than N is passed, the remaining bytes of the\n+--  object are undisturbed. For example:\n+\n+--     declare\n+--        subtype String16 is String (1 .. 16);\n+\n+--        S : String16;\n+--        for S'Alignment use 8;\n+\n+--     begin\n+--        S  := \"ABCDEFGHDEADBEEF\";\n+--        Put_Line (S);\n+--        Swap8 (S'Address);\n+--        Put_Line (S);\n+--     end;\n+\n+with System;\n+\n+package System.Byte_Swapping is\n+   pragma Pure;\n+\n+   --  NB: all the routines in this package treat the application objects as\n+   --  unsigned (modular) types of a size in bytes corresponding to the routine\n+   --  name. For example, the generic function Swapped2 manipulates the object\n+   --  passed to the formal parameter Input as a value of an unsigned type that\n+   --  is 2 bytes long. Therefore clients are responsible for the compatibility\n+   --  of application types manipulated by these routines and these modular\n+   --  types, in terms of both size and alignment. This requirement applies to\n+   --  the generic actual type passed to the generic formal type Item in the\n+   --  generic functions, as well as to the type of the object implicitly\n+   --  designated by the address passed to the non-generic procedures. Use of\n+   --  incompatible types can result in implementation- defined effects.\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped2 (Input : Item) return Item;\n+   --  Return the 2-byte value of Input with the bytes swapped\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped4 (Input : Item) return Item;\n+   --  Return the 4-byte value of Input with the bytes swapped\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped8 (Input : Item) return Item;\n+   --  Return the 8-byte value of Input with the bytes swapped\n+\n+   procedure Swap2 (Location : System.Address);\n+   --  Swap the first 2 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   procedure Swap4 (Location : System.Address);\n+   --  Swap the first 4 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   procedure Swap8 (Location : System.Address);\n+   --  Swap the first 8 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   pragma Inline (Swap2, Swap4, Swap8, Swapped2, Swapped4, Swapped8);\n+\n+end System.Byte_Swapping;"}, {"sha": "b916b8db94014cc5a5a52e893312e25c43a4e568", "filename": "gcc/ada/s-osinte-hpux.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fs-osinte-hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Fs-osinte-hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-hpux.ads?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --               Copyright (C) 1991-1994, Florida State University          --\n---            Copyright (C) 1995-2011, Free Software Foundation, Inc.       --\n+--            Copyright (C) 1995-2012, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -290,7 +290,7 @@ package System.OS_Interface is\n    pragma Import (C, Alternate_Stack, \"__gnat_alternate_stack\");\n    --  The alternate signal stack for stack overflows\n \n-   Alternate_Stack_Size : constant := 16 * 1024;\n+   Alternate_Stack_Size : constant := 128 * 1024;\n    --  This must be in keeping with init.c:__gnat_alternate_stack\n \n    Stack_Base_Available : constant Boolean := False;"}, {"sha": "2c8335de68b16e585eed6f2fd7714b1553cb4f5b", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9819bbd70137cde670497826160c6ae964454a7/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=d9819bbd70137cde670497826160c6ae964454a7", "patch": "@@ -143,7 +143,7 @@ __gnat_backtrace (void **array,\n       if (!RuntimeFunction)\n \t{\n \t  /* In case of failure, assume this is a leaf function.  */\n-\t  context.Rip = *(ULONG64 **) context.Rsp;\n+\t  context.Rip = *(ULONG64 *) context.Rsp;\n \t  context.Rsp += 8;\n \t}\n       else\n@@ -170,7 +170,7 @@ __gnat_backtrace (void **array,\n \t  && (void *)context.Rip <= exclude_max)\n \tcontinue;\n \n-      array[i++] = context.Rip - 2;\n+      array[i++] = (void *)(context.Rip - 2);\n       if (i >= size)\n \tbreak;\n     }"}]}