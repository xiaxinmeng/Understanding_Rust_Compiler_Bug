{"sha": "bf08fb1644d49b10c81c0598f0581de9e974b2cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYwOGZiMTY0NGQ0OWIxMGM4MWMwNTk4ZjA1ODFkZTllOTc0YjJjYw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-11-13T18:00:43Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-11-13T18:00:43Z"}, "message": "re PR rtl-optimization/59036 (Performance degradation after r204212 on 32-bit x86 targets.)\n\n2013-11-13  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/59036\n\t* ira-color.c (struct allocno_color_data): Add new members\n\tfirst_thread_allocno, next_thread_allocno, thread_freq.\n\t(sorted_copies): New static var.\n\t(allocnos_conflict_by_live_ranges_p, copy_freq_compare_func): Move\n\tup.\n\t(allocno_thread_conflict_p, merge_threads)\n\t(form_threads_from_copies, form_threads_from_bucket)\n\t(form_threads_from_colorable_allocno, init_allocno_threads): New\n\tfunctions.\n\t(bucket_allocno_compare_func): Add comparison by thread frequency\n\tand threads.\n\t(add_allocno_to_ordered_bucket): Rename to\n\tadd_allocno_to_ordered_colorable_bucket.  Remove parameter.\n        (push_only_colorable): Call form_threads_from_bucket.\n\t(color_pass): Call init_allocno_threads.  Use\n\tconsideration_allocno_bitmap instead of coloring_allocno_bitmap\n\tfor nuillify allocno color data.\n\t(ira_initiate_assign, ira_finish_assign): Allocate/free\n\tsorted_copies.\n\t(coalesce_allocnos): Use static sorted copies.\n\nFrom-SVN: r204752", "tree": {"sha": "5d18f2a3c9796fbeb8c83ed9dd457074959b505a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d18f2a3c9796fbeb8c83ed9dd457074959b505a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf08fb1644d49b10c81c0598f0581de9e974b2cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf08fb1644d49b10c81c0598f0581de9e974b2cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf08fb1644d49b10c81c0598f0581de9e974b2cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf08fb1644d49b10c81c0598f0581de9e974b2cc/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a9335ba2445a4c0a10ed9288b8c712c46a2c8da4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9335ba2445a4c0a10ed9288b8c712c46a2c8da4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9335ba2445a4c0a10ed9288b8c712c46a2c8da4"}], "stats": {"total": 380, "additions": 308, "deletions": 72}, "files": [{"sha": "c566a85c18e9bd913d9c99446921def250a90cf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf08fb1644d49b10c81c0598f0581de9e974b2cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf08fb1644d49b10c81c0598f0581de9e974b2cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf08fb1644d49b10c81c0598f0581de9e974b2cc", "patch": "@@ -1,3 +1,27 @@\n+2013-11-13  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/59036\n+\t* ira-color.c (struct allocno_color_data): Add new members\n+\tfirst_thread_allocno, next_thread_allocno, thread_freq.\n+\t(sorted_copies): New static var.\n+\t(allocnos_conflict_by_live_ranges_p, copy_freq_compare_func): Move\n+\tup.\n+\t(allocno_thread_conflict_p, merge_threads)\n+\t(form_threads_from_copies, form_threads_from_bucket)\n+\t(form_threads_from_colorable_allocno, init_allocno_threads): New\n+\tfunctions.\n+\t(bucket_allocno_compare_func): Add comparison by thread frequency\n+\tand threads.\n+\t(add_allocno_to_ordered_bucket): Rename to\n+\tadd_allocno_to_ordered_colorable_bucket.  Remove parameter.\n+        (push_only_colorable): Call form_threads_from_bucket.\n+\t(color_pass): Call init_allocno_threads.  Use\n+\tconsideration_allocno_bitmap instead of coloring_allocno_bitmap\n+\tfor nuillify allocno color data.\n+\t(ira_initiate_assign, ira_finish_assign): Allocate/free\n+\tsorted_copies.\n+\t(coalesce_allocnos): Use static sorted copies.\n+\n 2013-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* passes.c (execute_todo): Don't call do_per_function if"}, {"sha": "70cf54118427be61f4cf7d0402507c95d3bc0b6f", "filename": "gcc/ira-color.c", "status": "modified", "additions": 284, "deletions": 72, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf08fb1644d49b10c81c0598f0581de9e974b2cc/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf08fb1644d49b10c81c0598f0581de9e974b2cc/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=bf08fb1644d49b10c81c0598f0581de9e974b2cc", "patch": "@@ -142,6 +142,15 @@ struct allocno_color_data\n      used to restore original hard reg costs of allocnos connected to\n      this allocno by copies.  */\n   struct update_cost_record *update_cost_records;\n+  /* Threads.  We collect allocnos connected by copies into threads\n+     and try to assign hard regs to allocnos by threads.  */\n+  /* Allocno representing all thread.  */\n+  ira_allocno_t first_thread_allocno;\n+  /* Allocnos in thread forms a cycle list through the following\n+     member.  */\n+  ira_allocno_t next_thread_allocno;\n+  /* All thread frequency.  Defined only for first thread allocno.  */\n+  int thread_freq;\n };\n \n /* See above.  */\n@@ -1863,6 +1872,252 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \n \f\n \n+/* An array used to sort copies.  */\n+static ira_copy_t *sorted_copies;\n+\n+/* Return TRUE if live ranges of allocnos A1 and A2 intersect.  It is\n+   used to find a conflict for new allocnos or allocnos with the\n+   different allocno classes.  */\n+static bool\n+allocnos_conflict_by_live_ranges_p (ira_allocno_t a1, ira_allocno_t a2)\n+{\n+  rtx reg1, reg2;\n+  int i, j;\n+  int n1 = ALLOCNO_NUM_OBJECTS (a1);\n+  int n2 = ALLOCNO_NUM_OBJECTS (a2);\n+\n+  if (a1 == a2)\n+    return false;\n+  reg1 = regno_reg_rtx[ALLOCNO_REGNO (a1)];\n+  reg2 = regno_reg_rtx[ALLOCNO_REGNO (a2)];\n+  if (reg1 != NULL && reg2 != NULL\n+      && ORIGINAL_REGNO (reg1) == ORIGINAL_REGNO (reg2))\n+    return false;\n+\n+  for (i = 0; i < n1; i++)\n+    {\n+      ira_object_t c1 = ALLOCNO_OBJECT (a1, i);\n+\n+      for (j = 0; j < n2; j++)\n+\t{\n+\t  ira_object_t c2 = ALLOCNO_OBJECT (a2, j);\n+\n+\t  if (ira_live_ranges_intersect_p (OBJECT_LIVE_RANGES (c1),\n+\t\t\t\t\t   OBJECT_LIVE_RANGES (c2)))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* The function is used to sort copies according to their execution\n+   frequencies.  */\n+static int\n+copy_freq_compare_func (const void *v1p, const void *v2p)\n+{\n+  ira_copy_t cp1 = *(const ira_copy_t *) v1p, cp2 = *(const ira_copy_t *) v2p;\n+  int pri1, pri2;\n+\n+  pri1 = cp1->freq;\n+  pri2 = cp2->freq;\n+  if (pri2 - pri1)\n+    return pri2 - pri1;\n+\n+  /* If freqencies are equal, sort by copies, so that the results of\n+     qsort leave nothing to chance.  */\n+  return cp1->num - cp2->num;\n+}\n+\n+\f\n+\n+/* Return true if any allocno from thread of A1 conflicts with any\n+   allocno from thread A2.  */\n+static bool\n+allocno_thread_conflict_p (ira_allocno_t a1, ira_allocno_t a2)\n+{\n+  ira_allocno_t a, conflict_a;\n+\n+  for (a = ALLOCNO_COLOR_DATA (a2)->next_thread_allocno;;\n+       a = ALLOCNO_COLOR_DATA (a)->next_thread_allocno)\n+    {\n+      for (conflict_a = ALLOCNO_COLOR_DATA (a1)->next_thread_allocno;;\n+\t   conflict_a = ALLOCNO_COLOR_DATA (conflict_a)->next_thread_allocno)\n+\t{\n+\t  if (allocnos_conflict_by_live_ranges_p (a, conflict_a))\n+\t    return true;\n+\t  if (conflict_a == a1)\n+\t    break;\n+\t}\n+      if (a == a2)\n+\tbreak;\n+    }\n+  return false;\n+}\n+\n+/* Merge two threads given correspondingly by their first allocnos T1\n+   and T2 (more accurately merging T2 into T1).  */\n+static void\n+merge_threads (ira_allocno_t t1, ira_allocno_t t2)\n+{\n+  ira_allocno_t a, next, last;\n+\n+  gcc_assert (t1 != t2\n+\t      && ALLOCNO_COLOR_DATA (t1)->first_thread_allocno == t1\n+\t      && ALLOCNO_COLOR_DATA (t2)->first_thread_allocno == t2);\n+  for (last = t2, a = ALLOCNO_COLOR_DATA (t2)->next_thread_allocno;;\n+       a = ALLOCNO_COLOR_DATA (a)->next_thread_allocno)\n+    {\n+      ALLOCNO_COLOR_DATA (a)->first_thread_allocno = t1;\n+      if (a == t2)\n+\tbreak;\n+      last = a;\n+    }\n+  next = ALLOCNO_COLOR_DATA (t1)->next_thread_allocno;\n+  ALLOCNO_COLOR_DATA (t1)->next_thread_allocno = t2;\n+  ALLOCNO_COLOR_DATA (last)->next_thread_allocno = next;\n+  ALLOCNO_COLOR_DATA (t1)->thread_freq += ALLOCNO_COLOR_DATA (t2)->thread_freq;\n+}\n+\n+/* Create threads by processing CP_NUM copies from sorted)ciopeis.  We\n+   process the most expensive copies first.  */\n+static void\n+form_threads_from_copies (int cp_num)\n+{\n+  ira_allocno_t a, thread1, thread2;\n+  ira_copy_t cp;\n+  int i, n;\n+\n+  qsort (sorted_copies, cp_num, sizeof (ira_copy_t), copy_freq_compare_func);\n+  /* Form threads processing copies, most frequently executed\n+     first.  */\n+  for (; cp_num != 0;)\n+    {\n+      for (i = 0; i < cp_num; i++)\n+\t{\n+\t  cp = sorted_copies[i];\n+\t  thread1 = ALLOCNO_COLOR_DATA (cp->first)->first_thread_allocno;\n+\t  thread2 = ALLOCNO_COLOR_DATA (cp->second)->first_thread_allocno;\n+\t  if (thread1 == thread2)\n+\t    continue;\n+\t  if (! allocno_thread_conflict_p (thread1, thread2))\n+\t    {\n+\t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\tfprintf\n+\t\t  (ira_dump_file,\n+\t\t   \"      Forming thread by copy %d:a%dr%d-a%dr%d (freq=%d):\\n\",\n+\t\t   cp->num, ALLOCNO_NUM (cp->first), ALLOCNO_REGNO (cp->first),\n+\t\t   ALLOCNO_NUM (cp->second), ALLOCNO_REGNO (cp->second),\n+\t\t   cp->freq);\n+\t      merge_threads (thread1, thread2);\n+\t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\t{\n+\t\t  thread1 = ALLOCNO_COLOR_DATA (thread1)->first_thread_allocno;\n+\t\t  fprintf (ira_dump_file, \"        Result (freq=%d): a%dr%d(%d)\",\n+\t\t\t   ALLOCNO_COLOR_DATA (thread1)->thread_freq,\n+\t\t\t   ALLOCNO_NUM (thread1), ALLOCNO_REGNO (thread1),\n+\t\t\t   ALLOCNO_FREQ (thread1));\n+\t\t  for (a = ALLOCNO_COLOR_DATA (thread1)->next_thread_allocno;\n+\t\t       a != thread1;\n+\t\t       a = ALLOCNO_COLOR_DATA (a)->next_thread_allocno)\n+\t\t    fprintf (ira_dump_file, \" a%dr%d(%d)\",\n+\t\t\t     ALLOCNO_NUM (a), ALLOCNO_REGNO (a),\n+\t\t\t     ALLOCNO_FREQ (a));\n+\t\t  fprintf (ira_dump_file, \"\\n\");\n+\t\t}\n+\t      i++;\n+\t      break;\n+\t    }\n+\t}\n+      /* Collect the rest of copies.  */\n+      for (n = 0; i < cp_num; i++)\n+\t{\n+\t  cp = sorted_copies[i];\n+\t  if (ALLOCNO_COLOR_DATA (cp->first)->first_thread_allocno\n+\t      != ALLOCNO_COLOR_DATA (cp->second)->first_thread_allocno)\n+\t    sorted_copies[n++] = cp;\n+\t}\n+      cp_num = n;\n+    }\n+}\n+\n+/* Create threads by processing copies of all alocnos from BUCKET.  We\n+   process the most expensive copies first.  */\n+static void\n+form_threads_from_bucket (ira_allocno_t bucket)\n+{\n+  ira_allocno_t a;\n+  ira_copy_t cp, next_cp;\n+  int cp_num = 0;\n+\n+  for (a = bucket; a != NULL; a = ALLOCNO_COLOR_DATA (a)->next_bucket_allocno)\n+    {\n+      for (cp = ALLOCNO_COPIES (a); cp != NULL; cp = next_cp)\n+\t{\n+\t  if (cp->first == a)\n+\t    {\n+\t      next_cp = cp->next_first_allocno_copy;\n+\t      sorted_copies[cp_num++] = cp;\n+\t    }\n+\t  else if (cp->second == a)\n+\t    next_cp = cp->next_second_allocno_copy;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+  form_threads_from_copies (cp_num);\n+}\n+\n+/* Create threads by processing copies of colorable allocno A.  We\n+   process most expensive copies first.  */\n+static void\n+form_threads_from_colorable_allocno (ira_allocno_t a)\n+{\n+  ira_allocno_t another_a;\n+  ira_copy_t cp, next_cp;\n+  int cp_num = 0;\n+\n+  for (cp = ALLOCNO_COPIES (a); cp != NULL; cp = next_cp)\n+    {\n+      if (cp->first == a)\n+\t{\n+\t  next_cp = cp->next_first_allocno_copy;\n+\t  another_a = cp->second;\n+\t}\n+      else if (cp->second == a)\n+\t{\n+\t  next_cp = cp->next_second_allocno_copy;\n+\t  another_a = cp->first;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      if ((! ALLOCNO_COLOR_DATA (another_a)->in_graph_p\n+\t   && !ALLOCNO_COLOR_DATA (another_a)->may_be_spilled_p)\n+\t   || ALLOCNO_COLOR_DATA (another_a)->colorable_p)\n+\tsorted_copies[cp_num++] = cp;\n+    }\n+  form_threads_from_copies (cp_num);\n+}\n+\n+/* Form initial threads which contain only one allocno.  */\n+static void\n+init_allocno_threads (void)\n+{\n+  ira_allocno_t a;\n+  unsigned int j;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (consideration_allocno_bitmap, 0, j, bi)\n+    {\n+      a = ira_allocnos[j];\n+      /* Set up initial thread data: */\n+      ALLOCNO_COLOR_DATA (a)->first_thread_allocno\n+\t= ALLOCNO_COLOR_DATA (a)->next_thread_allocno = a;\n+      ALLOCNO_COLOR_DATA (a)->thread_freq = ALLOCNO_FREQ (a);\n+    }\n+}\n+\n+\f\n+\n /* This page contains the allocator based on the Chaitin-Briggs algorithm.  */\n \n /* Bucket of allocnos that can colored currently without spilling.  */\n@@ -1923,20 +2178,32 @@ bucket_allocno_compare_func (const void *v1p, const void *v2p)\n {\n   ira_allocno_t a1 = *(const ira_allocno_t *) v1p;\n   ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n-  int diff, a1_freq, a2_freq, a1_num, a2_num;\n+  int diff, freq1, freq2, a1_num, a2_num;\n+  ira_allocno_t t1 = ALLOCNO_COLOR_DATA (a1)->first_thread_allocno;\n+  ira_allocno_t t2 = ALLOCNO_COLOR_DATA (a2)->first_thread_allocno;\n   int cl1 = ALLOCNO_CLASS (a1), cl2 = ALLOCNO_CLASS (a2);\n \n+  freq1 = ALLOCNO_COLOR_DATA (t1)->thread_freq;\n+  freq2 = ALLOCNO_COLOR_DATA (t2)->thread_freq;\n+  if ((diff = freq1 - freq2) != 0)\n+    return diff;\n+  \n+  if ((diff = ALLOCNO_NUM (t2) - ALLOCNO_NUM (t1)) != 0)\n+    return diff;\n+\n   /* Push pseudos requiring less hard registers first.  It means that\n      we will assign pseudos requiring more hard registers first\n      avoiding creation small holes in free hard register file into\n      which the pseudos requiring more hard registers can not fit.  */\n   if ((diff = (ira_reg_class_max_nregs[cl1][ALLOCNO_MODE (a1)]\n \t       - ira_reg_class_max_nregs[cl2][ALLOCNO_MODE (a2)])) != 0)\n     return diff;\n-  a1_freq = ALLOCNO_FREQ (a1);\n-  a2_freq = ALLOCNO_FREQ (a2);\n-  if ((diff = a1_freq - a2_freq) != 0)\n+\n+  freq1 = ALLOCNO_FREQ (a1);\n+  freq2 = ALLOCNO_FREQ (a2);\n+  if ((diff = freq1 - freq2) != 0)\n     return diff;\n+\n   a1_num = ALLOCNO_COLOR_DATA (a1)->available_regs_num;\n   a2_num = ALLOCNO_COLOR_DATA (a2)->available_regs_num;\n   if ((diff = a2_num - a1_num) != 0)\n@@ -1973,22 +2240,16 @@ sort_bucket (ira_allocno_t *bucket_ptr,\n   *bucket_ptr = head;\n }\n \n-/* Add ALLOCNO to bucket *BUCKET_PTR maintaining the order according\n+/* Add ALLOCNO to colorable bucket maintaining the order according\n    their priority.  ALLOCNO should be not in a bucket before the\n    call.  */\n static void\n-add_allocno_to_ordered_bucket (ira_allocno_t allocno,\n-\t\t\t       ira_allocno_t *bucket_ptr)\n+add_allocno_to_ordered_colorable_bucket (ira_allocno_t allocno)\n {\n   ira_allocno_t before, after;\n \n-  if (bucket_ptr == &uncolorable_allocno_bucket\n-      && ALLOCNO_CLASS (allocno) != NO_REGS)\n-    {\n-      uncolorable_allocnos_num++;\n-      ira_assert (uncolorable_allocnos_num > 0);\n-    }\n-  for (before = *bucket_ptr, after = NULL;\n+  form_threads_from_colorable_allocno (allocno);\n+  for (before = colorable_allocno_bucket, after = NULL;\n        before != NULL;\n        after = before,\n \t before = ALLOCNO_COLOR_DATA (before)->next_bucket_allocno)\n@@ -1997,7 +2258,7 @@ add_allocno_to_ordered_bucket (ira_allocno_t allocno,\n   ALLOCNO_COLOR_DATA (allocno)->next_bucket_allocno = before;\n   ALLOCNO_COLOR_DATA (allocno)->prev_bucket_allocno = after;\n   if (after == NULL)\n-    *bucket_ptr = allocno;\n+    colorable_allocno_bucket = allocno;\n   else\n     ALLOCNO_COLOR_DATA (after)->next_bucket_allocno = allocno;\n   if (before != NULL)\n@@ -2078,8 +2339,7 @@ push_allocno_to_stack (ira_allocno_t a)\n \t    {\n \t      delete_allocno_from_bucket\n \t\t(conflict_a, &uncolorable_allocno_bucket);\n-\t      add_allocno_to_ordered_bucket\n-\t\t(conflict_a, &colorable_allocno_bucket);\n+\t      add_allocno_to_ordered_colorable_bucket (conflict_a);\n \t      if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n \t\t{\n \t\t  fprintf (ira_dump_file, \"        Making\");\n@@ -2123,6 +2383,7 @@ remove_allocno_from_bucket_and_push (ira_allocno_t allocno, bool colorable_p)\n static void\n push_only_colorable (void)\n {\n+  form_threads_from_bucket (colorable_allocno_bucket);\n   sort_bucket (&colorable_allocno_bucket, bucket_allocno_compare_func);\n   for (;colorable_allocno_bucket != NULL;)\n     remove_allocno_from_bucket_and_push (colorable_allocno_bucket, true);\n@@ -2911,6 +3172,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n       ALLOCNO_ADD_DATA (a) = allocno_color_data + n;\n       n++;\n     }\n+  init_allocno_threads ();\n   /* Color all mentioned allocnos including transparent ones.  */\n   color_allocnos ();\n   /* Process caps.  They are processed just once.  */\n@@ -3041,7 +3303,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t}\n     }\n   ira_free (allocno_color_data);\n-  EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, j, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (consideration_allocno_bitmap, 0, j, bi)\n     {\n       a = ira_allocnos[j];\n       ALLOCNO_ADD_DATA (a) = NULL;\n@@ -3327,41 +3589,6 @@ ira_reassign_conflict_allocnos (int start_regno)\n /* This page contains functions used to find conflicts using allocno\n    live ranges.  */\n \n-/* Return TRUE if live ranges of allocnos A1 and A2 intersect.  It is\n-   used to find a conflict for new allocnos or allocnos with the\n-   different allocno classes.  */\n-static bool\n-allocnos_conflict_by_live_ranges_p (ira_allocno_t a1, ira_allocno_t a2)\n-{\n-  rtx reg1, reg2;\n-  int i, j;\n-  int n1 = ALLOCNO_NUM_OBJECTS (a1);\n-  int n2 = ALLOCNO_NUM_OBJECTS (a2);\n-\n-  if (a1 == a2)\n-    return false;\n-  reg1 = regno_reg_rtx[ALLOCNO_REGNO (a1)];\n-  reg2 = regno_reg_rtx[ALLOCNO_REGNO (a2)];\n-  if (reg1 != NULL && reg2 != NULL\n-      && ORIGINAL_REGNO (reg1) == ORIGINAL_REGNO (reg2))\n-    return false;\n-\n-  for (i = 0; i < n1; i++)\n-    {\n-      ira_object_t c1 = ALLOCNO_OBJECT (a1, i);\n-\n-      for (j = 0; j < n2; j++)\n-\t{\n-\t  ira_object_t c2 = ALLOCNO_OBJECT (a2, j);\n-\n-\t  if (ira_live_ranges_intersect_p (OBJECT_LIVE_RANGES (c1),\n-\t\t\t\t\t   OBJECT_LIVE_RANGES (c2)))\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n #ifdef ENABLE_IRA_CHECKING\n \n /* Return TRUE if live ranges of pseudo-registers REGNO1 and REGNO2\n@@ -3423,24 +3650,6 @@ static coalesce_data_t allocno_coalesce_data;\n /* Macro to access the data concerning coalescing.  */\n #define ALLOCNO_COALESCE_DATA(a) ((coalesce_data_t) ALLOCNO_ADD_DATA (a))\n \n-/* The function is used to sort allocnos according to their execution\n-   frequencies.  */\n-static int\n-copy_freq_compare_func (const void *v1p, const void *v2p)\n-{\n-  ira_copy_t cp1 = *(const ira_copy_t *) v1p, cp2 = *(const ira_copy_t *) v2p;\n-  int pri1, pri2;\n-\n-  pri1 = cp1->freq;\n-  pri2 = cp2->freq;\n-  if (pri2 - pri1)\n-    return pri2 - pri1;\n-\n-  /* If freqencies are equal, sort by copies, so that the results of\n-     qsort leave nothing to chance.  */\n-  return cp1->num - cp2->num;\n-}\n-\n /* Merge two sets of coalesced allocnos given correspondingly by\n    allocnos A1 and A2 (more accurately merging A2 set into A1\n    set).  */\n@@ -3511,7 +3720,7 @@ static void\n coalesce_allocnos (void)\n {\n   ira_allocno_t a;\n-  ira_copy_t cp, next_cp, *sorted_copies;\n+  ira_copy_t cp, next_cp;\n   unsigned int j;\n   int i, n, cp_num, regno;\n   bitmap_iterator bi;\n@@ -4458,6 +4667,8 @@ ira_initiate_assign (void)\n   consideration_allocno_bitmap = ira_allocate_bitmap ();\n   initiate_cost_update ();\n   allocno_priorities = (int *) ira_allocate (sizeof (int) * ira_allocnos_num);\n+  sorted_copies = (ira_copy_t *) ira_allocate (ira_copies_num\n+\t\t\t\t\t       * sizeof (ira_copy_t));\n }\n \n /* Deallocate data used by assign_hard_reg.  */\n@@ -4468,6 +4679,7 @@ ira_finish_assign (void)\n   ira_free_bitmap (consideration_allocno_bitmap);\n   finish_cost_update ();\n   ira_free (allocno_priorities);\n+  ira_free (sorted_copies);\n }\n \n \f"}]}